import { ISupportsDataChangeNotifications } from "./ISupportsDataChangeNotifications";
import { IDataSourceSupportsCount } from "./IDataSourceSupportsCount";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { IDataSourceExecutionContext } from "./IDataSourceExecutionContext";
import { IDataSourceDataProviderUpdateNotifier } from "./IDataSourceDataProviderUpdateNotifier";
import { SortDescriptionCollection } from "./SortDescriptionCollection";
import { Base, Type, IList$1 } from "./type";
import { DataSourceDataProviderSchemaChangedEventArgs } from "./DataSourceDataProviderSchemaChangedEventArgs";
import { DataSourceSchemaPropertyType } from "./DataSourceSchemaPropertyType";
import { NotifyCollectionChangedEventArgs } from "./NotifyCollectionChangedEventArgs";
/**
 * @hidden
 */
export interface IDataSourceDataProvider extends ISupportsDataChangeNotifications, IDataSourceSupportsCount {
    getItemValue(a: any, b: string): any;
    schemaChanged: (sender: any, args: DataSourceDataProviderSchemaChangedEventArgs) => void;
    readonly actualSchema: IDataSourceSchema;
    executionContext: IDataSourceExecutionContext;
    updateNotifier: IDataSourceDataProviderUpdateNotifier;
    queueAutoRefresh(): void;
    deferAutoRefresh: boolean;
    flushAutoRefresh(): void;
    refresh(): void;
    readonly isSortingSupported: boolean;
    readonly isGroupingSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly isFilteringSupported: boolean;
    readonly filterExpressions: FilterExpressionCollection;
    propertiesRequested: string[];
    readonly notifyUsingSourceIndexes: boolean;
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    readonly isItemIndexLookupSupported: boolean;
    readonly isKeyIndexLookupSupported: boolean;
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
}
/**
 * @hidden
 */
export declare let IDataSourceDataProvider_$type: Type;
/**
 * @hidden
 */
export interface IFilterExpression {
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    readonly isPropertyReference: boolean;
    readonly isOperation: boolean;
    readonly isFunction: boolean;
    readonly isLiteral: boolean;
    readonly isNull: boolean;
    match(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    readonly precedence: number;
    readonly isAutoGenerated: boolean;
    markAutoGenerated(): void;
}
/**
 * @hidden
 */
export declare let IFilterExpression_$type: Type;
/**
 * @hidden
 */
export declare class FilterExpressionCollection extends Base {
    static $t: Type;
    private a;
    syncTarget: FilterExpressionCollection;
    private f;
    constructor();
    add(a: IFilterExpression): boolean;
    insert(a: number, b: IFilterExpression): void;
    clear(): void;
    get(a: number): IFilterExpression;
    indexOf(a: IFilterExpression): number;
    remove(a: IFilterExpression): boolean;
    removeAt(a: number): IFilterExpression;
    set(a: number, b: IFilterExpression): IFilterExpression;
    size(): number;
    onChanged: () => void;
    m(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    p(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    readonly j: IList$1<IFilterExpression>;
}
