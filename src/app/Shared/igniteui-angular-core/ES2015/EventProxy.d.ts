import { Base, Point, Type } from "./type";
import { Rect } from "./Rect";
import { ModifierKeys } from "./ModifierKeys";
import { NormalizedEvent, DomWrapper } from "./dom";
import { Key } from "./Key";
/**
 * @hidden
 */
export declare abstract class EventProxy extends Base {
    static $t: Type;
    onMouseWheel: (point: Point, delta: number) => boolean;
    onPinchStarted: (point: Point, scale: number) => void;
    onPinchDelta: (point: Point, scale: number) => void;
    onGestureCompleted: (point: Point, scale: number) => void;
    onZoomStarted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomDelta: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomCompleted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onFlingStarted: (point: Point, velocityX: number, velocityY: number) => boolean;
    onContactStarted: (point: Point, isFinger: boolean) => void;
    onDragStarted: (point: Point) => void;
    onContactMoved: (point: Point, isFinger: boolean) => void;
    onDragDelta: (point: Point) => void;
    onContactCompleted: (point: Point, isFinger: boolean) => void;
    onDragCompleted: (point: Point) => void;
    onMouseLeave: (point: Point) => void;
    onMouseOver: (point: Point, onMouseMove: boolean, isFinger: boolean) => void;
    onMouseEnter: (point: Point) => void;
    onMouseDown: (point: Point) => void;
    onMouseUp: (point: Point) => void;
    onDoubleTap: (point: Point) => void;
    onHold: (point: Point) => void;
    onKeyDown: (key: Key) => boolean;
    onKeyUp: (key: Key) => boolean;
    abstract bc(a: DomWrapper): Rect;
    bd: Rect;
    ba: ModifierKeys;
    ag: boolean;
    ai: (arg1: Point) => boolean;
    ak: (arg1: Point, arg2: boolean, arg3: boolean) => boolean;
    protected aa(a: Point, b: boolean, c: boolean): boolean;
    al: (arg1: NormalizedEvent) => boolean;
    abstract d(): EventProxy;
    abstract ao(): void;
    protected get_ah(): boolean;
    readonly ah: boolean;
    am: any;
    protected af(a: Point, b: number): boolean;
    protected a5(a: Point, b: number): void;
    protected a8(a: Point, b: number, c: number, d: number): void;
    protected ac(a: Point, b: number, c: number): boolean;
    protected a4(a: Point, b: number): void;
    protected a7(a: Point, b: number, c: number, d: number): void;
    protected a6(a: Point, b: number, c: number, d: number): void;
    protected ax(a: Point, b: number): void;
    protected as(a: Point, b: boolean): void;
    protected aw(a: Point): void;
    protected ar(a: Point, b: boolean): void;
    protected av(a: Point): void;
    protected aq(a: Point, b: boolean): void;
    protected au(a: Point): void;
    protected a1(a: Point): void;
    protected a2(a: Point, b: boolean, c: boolean): void;
    protected a0(a: Point): void;
    protected az(a: Point): void;
    protected a3(a: Point): void;
    protected ad(a: Key): boolean;
    protected ae(a: Key): boolean;
    protected at(a: Point): void;
    protected ay(a: Point): void;
    abstract bb(): Point;
    private y;
    ab: boolean;
    z: boolean;
    aj: (arg1: Point) => boolean;
    protected ap(): void;
    abstract an(a: any, b: string): void;
    abstract a9(a: any, b: string): void;
}
