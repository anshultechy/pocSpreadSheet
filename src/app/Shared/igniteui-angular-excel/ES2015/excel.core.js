/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Enum, ValueType, markEnum, Type, SystemException, BaseError, Base, markType, callStaticConstructors, IEnumerable$1_$type, IEnumerable_$type, IEnumerator$1_$type, IDisposable_$type, NotSupportedException, toEnum, IList$1_$type, Stream, typeCast, Nullable$1, Number_$type, Boolean_$type, IConvertible_$type, ICollection$1_$type, Nullable, IList_$type, String_$type, Point_$type, typeCastObjTo$t, getBoxIfEnum, fromEnum, Array_$type, Date_$type, EnumUtil, typeGetValue, getInstanceType, PointUtil, IComparable$1_$type, markStruct, enumGetBox, runOn, IEqualityComparer$1_$type, EnumeratorWrapper, getEnumerator, IEquatable$1_$type, IComparable_$type, FormatException, fromEn } from "../../igniteui-angular-core/ES2015/type";
import { Color } from "../../igniteui-angular-core/ES2015/Color";
import { DependencyObject } from "../../igniteui-angular-core/ES2015/DependencyObject";
import { NotImplementedException } from "../../igniteui-angular-core/ES2015/NotImplementedException";
import { unicode_hack, b64toUint8Array, stringFormat, lastIndexOfAny, trimEnd, trimStart, stringFormat1, isDigit, stringSplit, indexOfAny, stringEquals1, stringCompare1, stringInsert, stringFormat2, stringCompare3, startsWith1, isLetter, isNumber } from "../../igniteui-angular-core/ES2015/stringExtended";
import { Calendar, CultureInfo, Thread, DateTimeFormat, NumberFormatInfo } from "../../igniteui-angular-core/ES2015/culture";
import { ArgumentOutOfRangeException } from "../../igniteui-angular-core/ES2015/ArgumentOutOfRangeException";
import { dateFromValues, dateGetMonth, dateAddMonths, dateAddDays, dateAddHours, dateAddMinutes, dateAddSeconds, dateMinValue, dateFromTicks, dateGetTimeOfDay, dateNow, dateGetDate, dateAddYears, dateToday } from "../../igniteui-angular-core/ES2015/date";
import { List$1 } from "../../igniteui-angular-core/ES2015/List$1";
import { ArgumentException } from "../../igniteui-angular-core/ES2015/ArgumentException";
import { KeyValuePair$2 } from "../../igniteui-angular-core/ES2015/KeyValuePair$2";
import { Comparer$1 } from "../../igniteui-angular-core/ES2015/Comparer$1";
import { ImageFormat, WorkItem, UriUtilities, DocCoreUtils, StructuredStorageManager, Async, WorkItemExtensions, EscherSysIndex_$type, IPackage_$type, Windows932Encoding, Windows936Encoding, Windows1252Encoding, BinaryData, StringUtilities, WorkItemScheduler, OleDataSpaces, ValueTuple$2, ValueTuple, DocumentEncryptedException, Directory, UserFileStream, ST_TotalsRowFunction_$type, ST_ShapeType_$type, SummaryInformation, DocumentSummaryInformation, CT_TextBodyPropertiesBase, ST_CellType_$type, LfuCache$2, CT_Transform2D, ST_PositiveCoordinate, ST_Coordinate, CT_PositiveSize2D, CT_Point2D } from "./documents.core";
import { MemoryStream } from "../../igniteui-angular-core/ES2015/MemoryStream";
import { Encoding } from "../../igniteui-angular-core/ES2015/Encoding";
import { Rect } from "../../igniteui-angular-core/ES2015/Rect";
import { StringComparer } from "../../igniteui-angular-core/ES2015/StringComparer";
import { IOPath } from "../../igniteui-angular-core/ES2015/IOPath";
import { Dictionary$2 } from "../../igniteui-angular-core/ES2015/Dictionary$2";
import { IComparer$1_$type } from "../../igniteui-angular-core/ES2015/IComparer$1";
import { WeakReference } from "../../igniteui-angular-core/ES2015/WeakReference";
import { Uri } from "../../igniteui-angular-core/ES2015/Uri";
import { Guid } from "../../igniteui-angular-core/ES2015/Guid";
import { BitConverter } from "../../igniteui-angular-core/ES2015/BitConverter";
import { Buffer } from "../../igniteui-angular-core/ES2015/Buffer";
import { HashSet$1 } from "../../igniteui-angular-core/ES2015/HashSet$1";
import { Regex } from "../../igniteui-angular-core/ES2015/Regex";
import { StringBuilder } from "../../igniteui-angular-core/ES2015/StringBuilder";
import { Size } from "../../igniteui-angular-core/ES2015/Size";
import { Localization } from "../../igniteui-angular-core/ES2015/Localization";
import { BinaryReader } from "../../igniteui-angular-core/ES2015/BinaryReader";
import { Tuple$3 } from "../../igniteui-angular-core/ES2015/Tuple$3";
import { Tuple } from "../../igniteui-angular-core/ES2015/Tuple";
import { InvalidOperationException } from "../../igniteui-angular-core/ES2015/InvalidOperationException";
import { Convert } from "../../igniteui-angular-core/ES2015/Convert";
import { intSToU, u32LS, u32BitwiseOr, u32BitwiseAnd, u32BitwiseXor, intToString1, numberToString, round10N, tryParseNumber1, intToString, tryParseInt32_1, numberToString2, tryParseInt32_2, tryParseInt16_1 } from "../../igniteui-angular-core/ES2015/numberExtended";
import { truncate, intDivide, isInfinity, isNaN_, isNegativeInfinity, tryParseNumber } from "../../igniteui-angular-core/ES2015/number";
import { nullableEquals, nullableNotEquals, wrapNullable, unwrapNullable, nullableIsNull, nullableGreaterThan, nullableLessThan, nullableGreaterThanOrEqual } from "../../igniteui-angular-core/ES2015/nullable";
import { ConvertUtil } from "../../igniteui-angular-core/ES2015/convertUtil";
import { fromOADate, dateTryParse, toOADate, dateToStringFormat, toLongDateString, toLongTimeString } from "../../igniteui-angular-core/ES2015/dateExtended";
import { stringStartsWith, stringEmpty, stringIsNullOrEmpty, stringReplace, stringConcat, stringContains, stringToLocaleUpper, stringEndsWith, stringRemove, stringToLocaleLower, stringCompare, stringCreateFromChar, stringIsNullOrWhiteSpace } from "../../igniteui-angular-core/ES2015/string";
import { arrayCopyTo, boxArray$1, arrayShallowClone, arrayGetLength } from "../../igniteui-angular-core/ES2015/array";
import { timeSpanTotalDays, timeSpanTotalHours, timeSpanTotalMinutes, timeSpanTotalSeconds, timeSpanFromDays, timeSpanHours, timeSpanMinutes, timeSpanSeconds, timeSpanMilliseconds } from "../../igniteui-angular-core/ES2015/timespan";
import { ArgumentNullException } from "../../igniteui-angular-core/ES2015/ArgumentNullException";
import { Enumerable } from "../../igniteui-angular-core/ES2015/Enumerable";
import { IDictionary$2_$type } from "../../igniteui-angular-core/ES2015/IDictionary$2";
import { Stack$1 } from "../../igniteui-angular-core/ES2015/Stack$1";
import { sizeFromLiteral, sizeToLiteral } from "../../igniteui-angular-core/ES2015/IgSize";
import { DomWrapper_$type } from "../../igniteui-angular-core/ES2015/dom";
import { ReadOnlyCollection$1 } from "../../igniteui-angular-core/ES2015/ReadOnlyCollection$1";
import { getColorStringSafe } from "../../igniteui-angular-core/ES2015/colorCore";
import { rectToLiteral, rectFromLiteral, isRect } from "../../igniteui-angular-core/ES2015/IgRect";
import { pointFromLiteral, pointToLiteral } from "../../igniteui-angular-core/ES2015/IgPoint";
import { BitArray } from "../../igniteui-angular-core/ES2015/BitArray";
import { Tuple$2 } from "../../igniteui-angular-core/ES2015/Tuple$2";
import { EqualityComparer$1 } from "../../igniteui-angular-core/ES2015/EqualityComparer$1";
import { arrayCopy1, arrayCopy2, arrayIndexOf1, arrayClear1 } from "../../igniteui-angular-core/ES2015/arrayExtended";
import { ObservableCollection$1 } from "../../igniteui-angular-core/ES2015/ObservableCollection$1";
import { CompareUtil } from "../../igniteui-angular-core/ES2015/compareUtil";
import { Environment } from "../../igniteui-angular-core/ES2015/Environment";
import { IndexOutOfRangeException } from "../../igniteui-angular-core/ES2015/IndexOutOfRangeException";
import { Queue$1 } from "../../igniteui-angular-core/ES2015/Queue$1";
import { tryParseBool, boolCompare } from "../../igniteui-angular-core/ES2015/bool";
import { boolToString } from "../../igniteui-angular-core/ES2015/boolExtended";
/**
 * @hidden
 */
export let ReferenceActionCode_$type = markEnum('ReferenceActionCode', 'Create,0|Remove,1');
/**
 * @hidden
 */
export let NodeState_$type = markEnum('NodeState', 'NotVisited,0|Visiting,1|Visited,2');
/**
 * @hidden
 */
export let UltraCalcOperatorFunction_$type = markEnum('UltraCalcOperatorFunction', 'Add,0|Subtract,1|Multiply,2|Divide,3|Equal,4|NotEqual,5|GreaterThanOrEqual,6|GreaterThan,7|LessThanOrEqual,8|LessThan,9|Concatenate,10|Exponent,11|Percent,12|UnaryMinus,13|UnaryPlus,14');
/**
 * @hidden
 */
export let UltraCalcFormulaTokenType_$type = markEnum('UltraCalcFormulaTokenType', 'Value,0|Function,1');
/**
 * Enumeration of error codes assigned to [[ExcelCalcErrorValue]].
 */
export var ExcelCalcErrorCode;
(function (ExcelCalcErrorCode) {
  /**
   * Occurs when an invalid or disconnected reference is encountered while evaluating a formula
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Reference"] = 0] = "Reference";
  /**
   * Occurs when the wrong type of argument or operand is used in a formula
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Value"] = 1] = "Value";
  /**
   * Occurs when a number is divided by zero (0)
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Div"] = 2] = "Div";
  /**
   * Occurs when @NA is entered into a formula
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["NA"] = 3] = "NA";
  /**
   * Occurs with invalid numeric values in a formula or function
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Num"] = 4] = "Num";
  /**
   * Occurs when a circularity formula is used when circularities are not allowed.
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Circularity"] = 5] = "Circularity";
  /**
   * Occurs when there is an intersection of two references that do not contain any common cells.
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Null"] = 6] = "Null";
  /**
   * Occurs when text in a formula is not recognized.
   */
  ExcelCalcErrorCode[ExcelCalcErrorCode["Name1"] = 7] = "Name1";
})(ExcelCalcErrorCode || (ExcelCalcErrorCode = {}));
/**
 * @hidden
 */
export let ExcelCalcErrorCode_$type = markEnum('ExcelCalcErrorCode', 'Reference,0|Value,1|Div,2|NA,3|Num,4|Circularity,5|Null,6|Name:Name1,7');
/**
 * @hidden
 */
export let ValueFormatterFlags_$type = markEnum('ValueFormatterFlags', 'None,0|Date,1|Time,2');
/**
 * @hidden
 */
export let DayCountBasis_$type = markEnum('DayCountBasis', 'NASD360,0|Actual,1|Actual360,2|Actual365,3|European360,4');
/**
 * @hidden
 */
export let CalcArgumentFlags_$type = markEnum('CalcArgumentFlags', 'SkipEmptyReferences,1|SkipHiddenRows,2|IgnoreRefString,4|IgnoreRefBoolean,8|AdjustFor1904System,16|TreatIndirectStringsAsZero,32|IgnoreArrayBoolean,64|TreatNullAsZero,128|IgnoreErrors,256|TreatErrorsAsZero,512|IgnoreArrayString,1024|SkipSubtotals,2048|SkipHiddenColumns,4096|SkipHiddenCells,4098|Normal,1229|NormalA,1249|Count,1485|CountA,673|EnumerableNumericOnlyFlags,1101');
/**
 * @hidden
 */
export let CalcArgumentSource_$type = markEnum('CalcArgumentSource', 'Direct,0|Array,1|Reference,2');
/**
 * @hidden
 */
export let ValueFormatter_WellKnownPartType_$type = markEnum('ValueFormatter_WellKnownPartType', 'Whitespace,0|GeneralString,1|VerbatimString,2|DecimalSeparator,3|DigitOrEmpty,4|DigitOrZero,5|DigitOrWhitespace,6|GroupShiftPlaceholder,7|Percent,8|FractionSeparator,9|Scientific,10|ScientificWithSign,11|AMPMShortLL,12|AMPMShortLU,13|AMPMShortUL,14|AMPMShortUU,15|AMPMLong,16|AMPMChinese,17|HoursShort,18|HoursLong,19|HoursTotal,20|Milliseconds1,21|Milliseconds2,22|Milliseconds3,23|MinutesShort,24|MinutesLong,25|MinutesTotal,26|SecondsShort,27|SecondsLong,28|SecondsTotal,29|BuddhistYearsShort,30|BuddhistYearsLong,31|DaysShort,32|DaysLong,33|DayShortDescription,34|DayLongDescription,35|MonthsShort,36|MonthsLong,37|MonthShortDescription,38|MonthLongDescription,39|MonthFirstLetter,40|YearsShort,41|YearsLong,42|EraYearsShort,43|EraYearsLong,44|EraEnglishName,45|EraAbbreviatedName,46|EraName,47|DayShortDescriptionLocalized,48|DayLongDescriptionLocalized,49');
/**
 * @hidden
 */
export let ValueFormatter_SectionType_$type = markEnum('ValueFormatter_SectionType', 'Default,0|Date,1|Number,2|Text,3');
/**
 * @hidden
 */
export let ValueFormatter_NumberSection_$type = markEnum('ValueFormatter_NumberSection', 'Number,0|Fraction,1|GeneratedNumerator,2|GeneratedDenominator,3|ScientificCoefficient,4|ScientificCoefficientFraction,5|ScientificExponent,6|ScientificExponentFraction,7');
/**
 * @hidden
 */
export let ValueFormatter_LiteralType_$type = markEnum('ValueFormatter_LiteralType', 'Normal,0|Repeated,1|Placeholder,2');
/**
 * @hidden
 */
export let ValueFormatter_CompareOperator_$type = markEnum('ValueFormatter_CompareOperator', 'AnyValue,0|Equals,1|NotEquals,2|LessThan,3|LessThanOrEquals,4|GreaterThan,5|GreaterThanOrEquals,6');
/**
 * @hidden
 */
export let PropertyType_$type = markEnum('PropertyType', 'TransformLeft,0|TransformTop,1|TransformRight,2|TransformBottom,3|TransformRotation,4|TransformFFlipV,62|TransformFFlipH,63|TransformBooleanProperties,63|ProtectionLockAgainstUngrouping,118|ProtectionLockRotation,119|ProtectionLockAspectRatio,120|ProtectionLockPosition,121|ProtectionLockAgainstSelect,122|ProtectionLockCropping,123|ProtectionLockVertices,124|ProtectionLockText,125|ProtectionLockAdjustHandles,126|ProtectionLockAgainstGrouping,127|ProtectionBooleanProperties,127|TextID,128|TextLeft,129|TextTop,130|TextRight,131|TextBottom,132|TextAnchorText,135|TextShapeNext,138|TextDirection,139|TextSelectText,187|TextAutoTextMargin,188|TextRotateText,189|TextFitToText,190|TextFitToShape,191|TextBooleanProperties,191|BLIPId,260|BLIPName,261|BLIPFlags,262|BLIPPictureId,267|BLIPPictureActive,319|GeometryRight,322|GeometryBottom,323|GeometryShapePath,324|GeometryVertices,325|GeometrySegmentInfo,326|GeometryConnectionSites,337|GeometryConnectionSitesDirection,338|GeometryAdjustHandles,341|GeometryGuides,342|GeometryInscribe,343|GeometryTypeOfConnectionSites,344|GeometryFragments,345|GeometryFillOK,383|FillStyleColor,385|FillStyleOpacity,386|FillStyleBackColor,387|FillStyleColorModification,389|FillStyleBLIPName,391|FillStyleRectLeft,401|FillStyleRectTop,402|FillStyleRectRight,403|FillStyleRectBottom,404|FillStyleShadeColors,407|FillStyleRecolorFillAsPicture,441|FillStyleUseShapeAnchor,442|FillStyleFilled,443|FillStyleHitTestFill,444|FillStyleShape,445|FillStyleUseRect,446|FillStyleNoFillHitTest,447|FillStyleBooleanProperties,447|LineStyleColor,448|LineStyleOpacity,449|LineStyleColorModification,451|LineStyleWidth,459|LineStyleDashStyle,463|LineStyleInsetPen,505|LineStyleInsetPenOK,506|LineStyleArrowheadsOK,507|LineStyleLine,508|LineStyleHitTestLine,509|LineStyleFillShape,510|LineStyleNoLineDrawDash,511|LineStyleBooleanProperties,511|ShadowColor,513|ShadowColorModification,515|ShadowSoftness,540|ShadowObscured,575|ShapeMaster,769|ShapePolicyLabel,822|ShapePolicyBarcode,823|ShapeFlipHOverride,824|ShapeFlipVOverride,825|ShapeOleIcon,826|ShapePreferRelativeResize,827|ShapeLockShapeType,828|ShapeInitiator,829|ShapeDeleteAttachedObject,830|ShapeBackground,831|ShapeBooleanProperties,831|GroupShapeName,896|GroupShapeDescription,897|GroupShapeWrapPolygonVertices,899|GroupTableRowProperties,928|Office2007Data,937|GroupShapeLayoutInCell,944|GroupShapeIsBullet,945|GroupShapeStandardHR,946|GroupShapeNoshadeHR,947|GroupShapeHorizRule,948|GroupShapeUserDrawn,949|GroupShapeAllowOverlap,950|GroupShapeReallyHidden,951|GroupShapeScriptAnchor,952|GroupShapeEditedWrap,953|GroupShapeBehindDocument,954|GroupShapeOnDblClickNotify,955|GroupShapeIsButton,956|GroupShapeOneD,957|GroupShapeHidden,958|GroupShapePrint,959|GroupShapeBooleanProperties,959|DiagramRelationTable,1284|DiagramConstrainBounds,1288|LineLeftStyleDashStyle,1349|LineTopStyleDashStyle,1423|LineRightStyleDashStyle,1487|LineBottomStyleDashStyle,1551|LineColumnStyleDashStyle,1615|ClipVertices,1728|ClipSegmentsInfo,1729');
/**
 * @hidden
 */
export let EscherRecordType_$type = markEnum('EscherRecordType', 'DrawingGroupContainer,61440|BLIPStoreContainer,61441|DrawingContainer,61442|GroupContainer,61443|ShapeContainer,61444|SolverContainer,61445|DrawingGroup,61446|BLIPStoreEntry,61447|Drawing,61448|GroupShape,61449|Shape,61450|PropertyTable1,61451|Textbox,61452|ClientTextbox,61453|Anchor,61454|ChildAnchor,61455|ClientAnchor,61456|ClientData,61457|ConnectorRule,61458|AlignRule,61459|ArcRule,61460|ClientRule,61461|ClassID,61462|CalloutRule,61463|BLIPMin,61464|BLIPMax,61719|Regroup,61720|Selections,61721|ColorMRU,61722|DeletedPSPL,61725|SplitMenuColors,61726|OLEObject,61727|ColorScheme,61728|PropertyTable2,61729|PropertyTable3,61730');
/**
 * @hidden
 */
export let BLIPUsage_$type = markEnum('BLIPUsage', 'Default,0|Texture,1|Max,255');
/**
 * @hidden
 */
export let BLIPType_$type = markEnum('BLIPType', 'Error,0|Unknown,1|EMF,2|WMF,3|PICT,4|JPEG,5|PNG,6|DIB,7|TIFF,17|CMYKJPEG,18|FirstClient,32|LastClient,255');
/**
 * @hidden
 */
export let BLIPRecordType_$type = markEnum('BLIPRecordType', 'Unknwon,0|WMF,534|EMF,980|PICT,1346|PNG,1760|JPEG,1130|DIB,1960|CMYKJPEG,1762|TIFF,1764|Client,2048');
/**
 * @hidden
 */
export let PictureClipboardFormat_$type = markEnum('PictureClipboardFormat', 'Emf,2|Bitmap,9|Unspecified,65535');
/**
 * @hidden
 */
export let ObjectType_$type = markEnum('ObjectType', 'Group,0|Line,1|Rectangle,2|Oval,3|Arc,4|Chart,5|Text,6|Button,7|Picture,8|Polygon,9|CheckBox,11|OptionButton,12|EditBox,13|Label,14|DialogBox,15|Spinner,16|ScrollBar,17|ListBox,18|GroupBox,19|ComboBox,20|Comment,25|MicrosoftOfficeDrawing,30');
/**
 * @hidden
 */
export let OBJRecordType_$type = markEnum('OBJRecordType', 'Macro,4|Button,5|GroupMarker,6|ClipboardFormat,7|PictureOptionFlags,8|PictureFormulaStyleMacro,9|CheckBoxLink,10|RadioButton,11|ScrollBar,12|Note,13|ScrollBarFormulaStyleMacro,14|GroupBoxData,15|EditControlData,16|RadioButtonData,17|CheckBoxData,18|ListBoxData,19|CheckBoxLinkFormulaStyleMacro,20|CommonObjectData,21');
/**
 * @hidden
 */
export let IconSet_$type = markEnum('IconSet', '_3Arrows,0|_3ArrowsGray,1|_3Flags,2|_3TrafficLights1,3|_3Signs,4|_3TrafficLights2,5|_3Symbols,6|_3Symbols2,7|_4Arrows,8|_4ArrowsGray,9|_4RedToBlack,10|_4Ratings,11|_4TrafficLights,12|_5Arrows,13|_5ArrowsGray,14|_5Ratings,15|_5Quarters,16');
/**
 * @hidden
 */
export let CfValueType_$type = markEnum('CfValueType', 'Zero,0|Number,1|Min,2|Max,3|Percent,4|Percentile,5|Formula,7');
/**
 * @hidden
 */
export let CfDateOperator_$type = markEnum('CfDateOperator', 'Today,0|Tomorrow,6|Yesterday,1|Last7Days,2|LastMonth,5|NextMonth,8|ThisWeek,3|NextWeek,7|LastWeek,4|ThisMonth,9');
/**
 * @hidden
 */
export let CfTextOperator_$type = markEnum('CfTextOperator', 'Contains,0|NotContains,1|BeginsWith,2|EndsWith,3');
/**
 * @hidden
 */
export let CfTemplate_$type = markEnum('CfTemplate', 'CellValue,0|Formula,1|ColorScale,2|DataBar,3|IconSet,4|FilterAKATopTen,5|Unique,7|ContainsText,8|Blanks,9|NoBlanks,10|Errors,11|NoErrors,12|Today,15|Tomorrow,16|Yesterday,17|Last7Days,18|LastMonth,19|NextMonth,20|ThisWeek,21|NextWeek,22|LastWeek,23|ThisMonth,24|AboveAverage,25|BelowAverage,26|Duplicate,27|AboveOrEqualToAverage,29|BelowOrEqualToAverage,30');
/**
 * @hidden
 */
export let CfOperator_$type = markEnum('CfOperator', 'Zero,0|Between,1|NotBetween,2|Equal,3|NotEqual,4|GreaterThan,5|LessThan,6|GreaterEqual,7|LessEqual,8');
/**
 * @hidden
 */
export let CfType_$type = markEnum('CfType', 'Zero,0|CellValueIs,1|FormulaIs,2|ColorScale,3|DataBar,4|FilterAKATopTen,5|IconSet,6');
/**
 * @hidden
 */
export let XColorType_$type = markEnum('XColorType', 'Auto,0|Indexed,1|RGB,2|Themed,3|NotSet,4');
/**
 * @hidden
 */
export let SourceType_$type = markEnum('SourceType', 'Range,0|Sharepoint,1|XML,2|ExternalData,3');
/**
 * @hidden
 */
export let SharedFeatureType_$type = markEnum('SharedFeatureType', 'Protection,2|Fec2,3|Factoid,4|List,5');
/**
 * @hidden
 */
export let FontScheme_$type = markEnum('FontScheme', 'None,0|Major,1|Minor,2|Nil,255');
/**
 * @hidden
 */
export let BIFF8RecordType_$type = markEnum('BIFF8RecordType', 'Default,0|Record1904,34|ACTIVEXMARKER,445|ADDIN,135|ADDMENU,194|AREAFORMAT,4106|ARRAY,545|AUTOFILTER,158|AUTOFILTER12,2174|AUTOFILTERINFO,157|AXCEXT,4194|AXESUSED,4166|AXIS,4125|AXISLINE,4129|AXISPARENT,4161|BACKUP,64|BEGIN,4147|BITMAP,233|BLANK,513|BOF,2057|BOOKBOOL,218|BOOKEXT,2147|BOOLERR,517|BOTTOMMARGIN,41|BOUNDSHEET,133|BRAI,4177|CALCCOUNT,12|CALCMODE,13|CATLAB,2134|CATSERRANGE,4128|CELLWATCH,2156|CF,433|CF12,2170|CFEX,2171|CHART,4098|CHART3DBarSHAPE,4191|CHARTFORMAT,4116|CHARTFRTINFO,2128|CODEPAGE,66|COLINFO,125|CONDFMT,432|CONDFMT12,2169|CONTINUE,60|CONTINUEFRT,2066|CONTINUEFRT11,2165|CONTINUEFRT12,2175|COORDLIST,169|COUNTRY,140|CRASHRECERR,2149|CRN,90|CRTCOOPT,2251|CRTLINK,4130|DATAFORMAT,4102|DATALABEXT,2154|DATALABEXTCONTENTS,2155|DBCELL,215|DBQUERYEXT,2051|DCON,80|DCONBIN,437|DCONNAME,82|DCONREF,81|DEFAULTROWHEIGHT,549|DEFAULTTEXT,4132|DEFCOLWIDTH,85|DELMENU,195|DELTA,16|DIMENSIONS,512|DOCROUTE,184|DROPDOWNOBJIDS,2164|DSF,353|DV,446|DVAL,434|DXF,2189|EDG,136|EFONT,69|END,4148|ENDBLOCK,2131|EOF,10|EXCEL9FILE,448|EXTERNCOUNT,22|EXTERNNAME,35|EXTERNSHEET,23|EXTSST,255|EXTSTRING,2052|FEAT,2152|FEAT11,2162|FEAT12,2168|FEATHEADR,2151|FEATHEADR11,2161|FILEPASS,47|FILESHARING,91|FILESHARING2,293|FILTERMODE,155|FMQRY,2246|FMSQRY,2247|FNGROUPCOUNT,156|FNGROUPNAME,154|FONT,49|FONTX,4134|FOOTER,21|FORMAT,1054|FORMULA,6|FRAME,4146|GCW,171|GRIDSET,130|GUTS,128|HCENTER,131|HEADER,20|HEADERFOOTER,2204|HFPicture,2150|HIDEOBJ,141|HLINK,440|HLINKTOOLTIP,2048|HORIZONTALPAGEBREAKS,27|IMDATA,127|INDEX,523|INTERFACEEND,226|INTERFACEHDR,225|ITERATION,17|LABEL,516|LABELRANGES,351|LABELSST,253|LEFTMARGIN,38|LEGEND,4117|LHNGRAPH,149|LHRECORD,148|LINE,4120|LINEFORMAT,4103|LIST12,2167|LISTCF,2245|LISTCONDFMT,2244|LISTDV,2243|LISTFIELD,2242|LISTOBJ,2241|LNEXT,2249|LPR,152|MARKERFORMAT,4105|MERGEDCELLS,229|MKREXT,2250|MMS,193|MSODRAWING,236|MSODRAWINGGROUP,235|MSODRAWINGSELECTION,237|MULBLANK,190|MULRK,189|NAME,24|NAMEEXT,2196|NOTE,28|NUMBER,515|OBJ,93|OBJECTLINK,4135|OBJPROTECT,99|OBPROJ,211|OLEDBCONN,2058|OLESIZE,222|PAGELAYOUTINFO,2187|PALETTE,146|PANE,65|PARAMQRY,220|PASSWORD,19|PIEFORMAT,4107|PLOTAREA,4149|PLOTGROWTH,4196|PLS,77|PLV,2248|POS,4175|PRECISION,14|PRINTGRIDLINES,43|PRINTHEADERS,42|PROTECT,18|PROT4REV,431|PROT4REVPASS,444|PUB,137|QSI,429|QSIF,2055|QSIR,2054|QSISXTAG,2050|REALTIMEDATA,2067|RECALCID,449|RECIPNAME,185|REFMODE,15|REFRESHALL,439|RIGHTMARGIN,39|RK,638|ROW,520|RSTRING,214|SAVERECALC,95|SCENARIO,175|SCENMAN,174|SCENPROTECT,221|SCL,160|SELECTION,29|SERIES,4099|SERIESTEXT,4109|SERTOCRT,4165|SETUP,161|SHEETEXT,2146|SHRFMLA,1212|SHTPROPS,4164|SORT,144|SORTDATA12,2197|SOUND,150|SST,252|STANDARDWIDTH,153|STARTBLOCK,2130|STRING,519|STYLE,659|STYLEEXT,2194|SUB,145|SUPBOOK,430|SXADDL,2148|SXDB,198|SXDBEX,290|SXDI,197|SXDXF,244|SXEX,241|SXEXT,220|SXFDBTYPE,443|SXFILT,242|SXFMLA,249|SXFORMAT,251|SXFORMULA,259|SXIDSTM,213|SXITM,245|SXIVD,180|SXLI,181|SXNAME,246|SXPAIR,248|SXPI,182|SXPIEX,2062|SXRULE,240|SXSELECT,247|SXSTRING,205|SXTBL,208|SXTBPG,210|SXTBRGIITM,209|SXTH,2061|SXVD,177|SXVDEX,256|SXVDTEX,2063|SXVI,178|SXVIEW,176|SXVIEWEX,2060|SXVIEWEX9,2064|SXVS,227|TABID,317|TABIDCONF,234|TABLE,566|TABLESTYLE,2191|TABLESTYLEELEMENT,2192|TABLESTYLES,2190|TEMPLATE,96|TEXT,4133|THEME,2198|TICK,4126|TOPMARGIN,40|TXO,438|TXTQUERY,2053|UDDESC,223|UNCALCED,94|UNITS,4097|USERBVIEW,425|USERSVIEWBEGIN,426|USERSVIEWEND,427|USESELFS,352|VALUERANGE,4127|VBAOBJECTNAME,442|VCENTER,132|VERTICALPAGEBREAKS,26|WEBPUB,2049|WINDOW1,61|WINDOW2,574|WINDOWPROTECT,25|WOPT,2059|WRITEACCESS,92|WRITEPROT,134|WSBOOL,129|XCT,89|XF,224|XFCRC,2172|XFEXT,2173|XL5MODIFY,354');
/**
 * @hidden
 */
export let XFPropType_$type = markEnum('XFPropType', 'PatternFill,0|ForegroundColor,1|BackgroundColor,2|GradientFill,3|GradientStop,4|FontColor,5|TopBorder,6|BottomBorder,7|LeftBorder,8|RightBorder,9|DiagonalBorder,10|VerticalBorder,11|HorizontalBorder,12|DiagonalUpBorder,13|DiagonalDownBorder,14|HorizontalAlignment,15|VerticalAlignment,16|TextRotation,17|TextIndentationLevel,18|ReadingOrder,19|WrappedText,20|JustifyDistributed,21|ShrinkToFit,22|CellMerged,23|FontName,24|FontBold,25|FontUnderline,26|FontSubscriptSuperscript,27|FontItalic,28|FontStrikethrough,29|FontOutline,30|FontShadow,31|FontCondensed,32|FontExtended,33|FontCharacterSet,34|FontFamily,35|FontHeight,36|FontScheme,37|NumberFormat,38|NumberFormatId,41|TextIndentationLevelRelative,42|Locked,43|Hidden,44');
/**
 * @hidden
 */
export let ExtPropType_$type = markEnum('ExtPropType', 'ForegroundColor,4|BackgroundColor,5|GradientFill,6|TopBorderColor,7|BottomBorderColor,8|LeftBorderColor,9|RightBorderColor,10|DiagonalBorderColor,11|CellTextColor,13|FontScheme,14|TextIndentationLevel,15');
/**
 * @hidden
 */
export let SubstreamType_$type = markEnum('SubstreamType', 'WorkbookGlobals,5|VisualBasicModule,6|Worksheet,16|Chart,32|MacroSheet,64|WorkspaceFile,256');
/**
 * @hidden
 */
export let BiffSheetType_$type = markEnum('BiffSheetType', 'Worksheet,0|MacroSheet,1|Chart,2|VBModule,6');
/**
 * @hidden
 */
export let ErrorAlertStyle_$type = markEnum('ErrorAlertStyle', 'Stop,0|Warning,1|Infromation,2');
/**
 * @hidden
 */
export let DataValidationOperatorType_$type = markEnum('DataValidationOperatorType', 'Between,0|NotBetween,1|Equal,2|NotEqual,3|GreaterThan,4|LessThan,5|GreaterThanOrEqual,6|LessThanOrEqual,7');
/**
 * @hidden
 */
export let DataValidationType_$type = markEnum('DataValidationType', 'AnyValue,0|WholeNumber,1|Decimal,2|List,3|Date,4|Time,5|TextLength,6|Formula,7');
/**
 * @hidden
 */
export let SeriesValuesType_$type = markEnum('SeriesValuesType', 'Numeric,0|String:string1,1');
/**
 * @hidden
 */
export let Series_BitValues_$type = markEnum('Series_BitValues', 'ApplyPicToEnd,1|ApplyPicToFront,2|ApplyPicToSides,4|InvertIfNegative,8|Smooth,16|ShowDataLabels,32|ShowWaterfallConnectorLines,64');
/**
 * @hidden
 */
export let XValuesDataType_$type = markEnum('XValuesDataType', 'String:string1,0|StringArray,1|Number,2');
/**
 * Constants which determine the type of a [[Wall]],
 * i.e., back, side, or floor. Applicable only for 3-D charts.
 */
export var WallType;
(function (WallType) {
  /**
   * The back wall, i.e., "behind" the plot area.
   */
  WallType[WallType["Back"] = 0] = "Back";
  /**
   * The side wall. Note that only one side is ever visible,
   * based on the rotation around the Y-axis.
   */
  WallType[WallType["Side"] = 1] = "Side";
  /**
   * The bottom wall, i.e., the floor of the chart.
   */
  WallType[WallType["Floor"] = 2] = "Floor";
  /**
   * Applies to the back and side walls, and the floor.
   */
  WallType[WallType["All"] = 3] = "All";
})(WallType || (WallType = {}));
/**
 * @hidden
 */
export let WallType_$type = markEnum('WallType', 'Back,0|Side,1|Floor,2|All,3');
/**
 * Determines the horizontal alignment for a title
 */
export var VerticalTitleAlignment;
(function (VerticalTitleAlignment) {
  /**
   * The title will be aligned on the bottom
   */
  VerticalTitleAlignment[VerticalTitleAlignment["Bottom"] = -4107] = "Bottom";
  /**
   * The title will be centered vertically
   */
  VerticalTitleAlignment[VerticalTitleAlignment["Center"] = -4108] = "Center";
  /**
   * The title will be distributed
   */
  VerticalTitleAlignment[VerticalTitleAlignment["Distributed"] = -4117] = "Distributed";
  /**
   * The title will be justified
   */
  VerticalTitleAlignment[VerticalTitleAlignment["Justify"] = -4130] = "Justify";
  /**
   * The title will be aligned on the top
   */
  VerticalTitleAlignment[VerticalTitleAlignment["Top"] = -4160] = "Top";
})(VerticalTitleAlignment || (VerticalTitleAlignment = {}));
/**
 * @hidden
 */
export let VerticalTitleAlignment_$type = markEnum('VerticalTitleAlignment', 'Bottom,-4107|Center,-4108|Distributed,-4117|Justify,-4130|Top,-4160');
/**
 * Constants which distinguish between an up or down bar in a stock chart.
 */
export var UpDownBarType;
(function (UpDownBarType) {
  /**
   * Up bar.
   */
  UpDownBarType[UpDownBarType["Up"] = 0] = "Up";
  /**
   * Down bar.
   */
  UpDownBarType[UpDownBarType["Down"] = 1] = "Down";
})(UpDownBarType || (UpDownBarType = {}));
/**
 * @hidden
 */
export let UpDownBarType_$type = markEnum('UpDownBarType', 'Up,0|Down,1');
/**
 * Constants which define the various types of trendlines
 * supported by a [[WorksheetChart]].
 */
export var TrendlineType;
(function (TrendlineType) {
  /**
   * The trendline is exponential.
   */
  TrendlineType[TrendlineType["Exponential"] = 0] = "Exponential";
  /**
   * The trendline is linear.
   */
  TrendlineType[TrendlineType["Linear"] = 1] = "Linear";
  /**
   * The trendline is logarithmic.
   */
  TrendlineType[TrendlineType["Logarithmic"] = 2] = "Logarithmic";
  /**
   * The trendline depicts a moving average.
   */
  TrendlineType[TrendlineType["MovingAverage"] = 3] = "MovingAverage";
  /**
   * The trendline depicts a polynomial of order/degree <i>n</i>,
   * when <i>n</i> is specified by the ChartTrendline.PolynomialOrder
   * property.
   */
  TrendlineType[TrendlineType["Polynomial"] = 4] = "Polynomial";
  /**
   * The trendline depicts a power curve.
   */
  TrendlineType[TrendlineType["Power"] = 5] = "Power";
})(TrendlineType || (TrendlineType = {}));
/**
 * @hidden
 */
export let TrendlineType_$type = markEnum('TrendlineType', 'Exponential,0|Linear,1|Logarithmic,2|MovingAverage,3|Polynomial,4|Power,5');
/**
 * Constants which define the order/degree of the polynomial
 * applied to a [[Trendline]] when the trendline
 * type is <i>Polynomial</i>.
 * @see [[TrendlineType]]
 */
export var TrendlinePolynomialOrder;
(function (TrendlinePolynomialOrder) {
  /**
   * A second-order/degree polynomial.
   */
  TrendlinePolynomialOrder[TrendlinePolynomialOrder["Second"] = 2] = "Second";
  /**
   * A third-order/degree polynomial.
   */
  TrendlinePolynomialOrder[TrendlinePolynomialOrder["Third"] = 3] = "Third";
  /**
   * A fourth-order/degree polynomial.
   */
  TrendlinePolynomialOrder[TrendlinePolynomialOrder["Fourth"] = 4] = "Fourth";
  /**
   * A fifth-order/degree polynomial.
   */
  TrendlinePolynomialOrder[TrendlinePolynomialOrder["Fifth"] = 5] = "Fifth";
  /**
   * A sixth-order/degree polynomial.
   */
  TrendlinePolynomialOrder[TrendlinePolynomialOrder["Sixth"] = 6] = "Sixth";
})(TrendlinePolynomialOrder || (TrendlinePolynomialOrder = {}));
/**
 * @hidden
 */
export let TrendlinePolynomialOrder_$type = markEnum('TrendlinePolynomialOrder', 'Second,2|Third,3|Fourth,4|Fifth,5|Sixth,6');
/**
 * Constants which determine the unit of measure for [[Axis]] date/time values.
 */
export var TimeUnit;
(function (TimeUnit) {
  /**
   * The Axis interval is expressed in days.
   */
  TimeUnit[TimeUnit["Days"] = 0] = "Days";
  /**
   * The Axis interval is expressed in months.
   */
  TimeUnit[TimeUnit["Months"] = 1] = "Months";
  /**
   * The Axis interval is expressed in years.
   */
  TimeUnit[TimeUnit["Years"] = 2] = "Years";
})(TimeUnit || (TimeUnit = {}));
/**
 * @hidden
 */
export let TimeUnit_$type = markEnum('TimeUnit', 'Days,0|Months,1|Years,2');
/**
 * Constants which determine the placement of an axis' <see cref="Axis.MajorTickMark">major</see>
 * and <see cref="Axis.MinorTickMark">minor</see> tick marks.
 */
export var TickMark;
(function (TickMark) {
  /**
   * The tick marks cross the axis line.
   */
  TickMark[TickMark["Cross"] = 4] = "Cross";
  /**
   * The tick marks appear on the side of the axis line
   * closest to the inside of the plot area.
   */
  TickMark[TickMark["Inside"] = 2] = "Inside";
  /**
   * Tick marks are not displayed.
   */
  TickMark[TickMark["None"] = 4142] = "None";
  /**
   * The tick marks appear on the side of the axis line
   * closest to the outside of the plot area.
   */
  TickMark[TickMark["Outside"] = 3] = "Outside";
})(TickMark || (TickMark = {}));
/**
 * @hidden
 */
export let TickMark_$type = markEnum('TickMark', 'Cross,4|Inside,2|None,4142|Outside,3');
/**
 * Determines the alignment for axis [[Axis.tickLabels]]
 */
export var TickLabelAlignment;
(function (TickLabelAlignment) {
  /**
   * The tick labels will be aligned on the left
   */
  TickLabelAlignment[TickLabelAlignment["Left"] = -4131] = "Left";
  /**
   * The tick labels will be centered
   */
  TickLabelAlignment[TickLabelAlignment["Center"] = -4108] = "Center";
  /**
   * The tick labels will be aligned on the right
   */
  TickLabelAlignment[TickLabelAlignment["Right"] = -4152] = "Right";
})(TickLabelAlignment || (TickLabelAlignment = {}));
/**
 * @hidden
 */
export let TickLabelAlignment_$type = markEnum('TickLabelAlignment', 'Left,-4131|Center,-4108|Right,-4152');
/**
 * Constants which determine the placement of an axis' <see cref="Axis.TickLabels">tick labels</see>.
 */
export var TickLabelPosition;
(function (TickLabelPosition) {
  /**
   * Tick labels appear near the highest data value.
   */
  TickLabelPosition[TickLabelPosition["High"] = -4127] = "High";
  /**
   * Tick labels appear near the lowest data value.
   */
  TickLabelPosition[TickLabelPosition["Low"] = -4134] = "Low";
  /**
   * Tick labels appear near the axis.
   */
  TickLabelPosition[TickLabelPosition["NextToAxis"] = 4] = "NextToAxis";
  /**
   * Tick labels are not displayed.
   */
  TickLabelPosition[TickLabelPosition["None"] = -4142] = "None";
})(TickLabelPosition || (TickLabelPosition = {}));
/**
 * @hidden
 */
export let TickLabelPosition_$type = markEnum('TickLabelPosition', 'High,-4127|Low,-4134|NextToAxis,4|None,-4142');
/**
 * Constants which describe whether text is allowed to continue
 * vertically outside the bounds of the containing element.
 */
export var TextVerticalOverflow;
(function (TextVerticalOverflow) {
  /**
   * The text is clipped by the containing element.
   */
  TextVerticalOverflow[TextVerticalOverflow["Clip"] = 0] = "Clip";
  /**
   * The text is allowed to continue outside the bounds
   * of the containing element.
   */
  TextVerticalOverflow[TextVerticalOverflow["Overflow"] = 1] = "Overflow";
  /**
   * Overflowing text is truncated and an ellipsis is displayed.
   */
  TextVerticalOverflow[TextVerticalOverflow["Ellipsis"] = 2] = "Ellipsis";
})(TextVerticalOverflow || (TextVerticalOverflow = {}));
/**
 * @hidden
 */
export let TextVerticalOverflow_$type = markEnum('TextVerticalOverflow', 'Clip,0|Overflow,1|Ellipsis,2');
/**
 * Constants which describe whether text is allowed to continue
 * horizontally outside the bounds of the containing element.
 */
export var TextHorizontalOverflow;
(function (TextHorizontalOverflow) {
  /**
   * The text is clipped by the containing element.
   */
  TextHorizontalOverflow[TextHorizontalOverflow["Clip"] = 0] = "Clip";
  /**
   * The text is allowed to continue outside the bounds
   * of the containing element.
   */
  TextHorizontalOverflow[TextHorizontalOverflow["Overflow"] = 1] = "Overflow";
})(TextHorizontalOverflow || (TextHorizontalOverflow = {}));
/**
 * @hidden
 */
export let TextHorizontalOverflow_$type = markEnum('TextHorizontalOverflow', 'Clip,0|Overflow,1');
/**
 * Determines the direction in which text flows.
 */
export var TextDirection;
(function (TextDirection) {
  /**
   * Text flows along the horizontal plane. Note that under this setting,
   * text rotation is also supported, with the angle of rotation being
   * relative to the horizontal plane.
   */
  TextDirection[TextDirection["Horizontal"] = 0] = "Horizontal";
  /**
   * Text flows along the vertical plane. The plane is defined by rotating
   * the horizontal axis by 90 degrees in the clockwise direction.
   */
  TextDirection[TextDirection["Vertical"] = 1] = "Vertical";
  /**
   * Text flows along the vertical plane. The plane is defined by rotating
   * the horizontal axis by 270 degrees in the clockwise direction.
   */
  TextDirection[TextDirection["Vertical270"] = 2] = "Vertical270";
  /**
   * Text flows along the vertical plane with East Asian vertical orientation.
   */
  TextDirection[TextDirection["EastAsianVertical"] = 3] = "EastAsianVertical";
  /**
   * Text flows along the vertical plane with Mongolian vertical orientation.
   */
  TextDirection[TextDirection["MongolianVertical"] = 4] = "MongolianVertical";
  /**
   * Text flows along the vertical plane with WordArt vertical orientation.
   */
  TextDirection[TextDirection["WordArtVertical"] = 5] = "WordArtVertical";
  /**
   * Similar to <i>WordArtVertical</i>, with a right-to-left text reading direction.
   */
  TextDirection[TextDirection["WordArtVerticalRtl"] = 6] = "WordArtVerticalRtl";
})(TextDirection || (TextDirection = {}));
/**
 * @hidden
 */
export let TextDirection_$type = markEnum('TextDirection', 'Horizontal,0|Vertical,1|Vertical270,2|EastAsianVertical,3|MongolianVertical,4|WordArtVertical,5|WordArtVerticalRtl,6');
/**
 * Constants which determine the manner in which series values
 * are used to color regions on a geographic map chart.
 * <p class="body">
 * Applicable only when the associated series [[Series.chartType]] is <i>RegionMap</i>.
 * </p>
 */
export var SeriesValuesColorBy;
(function (SeriesValuesColorBy) {
  /**
   * The coloring of map regions is determined by the numerical value of the associated data point.
   */
  SeriesValuesColorBy[SeriesValuesColorBy["NumericalValue"] = 0] = "NumericalValue";
  /**
   * The coloring of map regions is determined by the value of the associated data point,
   * which is assumed to represent a category.
   */
  SeriesValuesColorBy[SeriesValuesColorBy["SecondaryCategory"] = 1] = "SecondaryCategory";
})(SeriesValuesColorBy || (SeriesValuesColorBy = {}));
/**
 * @hidden
 */
export let SeriesValuesColorBy_$type = markEnum('SeriesValuesColorBy', 'NumericalValue,0|SecondaryCategory,1');
/**
 * Determines the type of [[Series]].
 */
export var SeriesType;
(function (SeriesType) {
  /**
   * Area; used by both area and area 3D charts.
   */
  SeriesType[SeriesType["Area"] = 0] = "Area";
  /**
   * Bar; used by both bar and bar 3D charts.
   */
  SeriesType[SeriesType["Bar"] = 1] = "Bar";
  /**
   * Line; used by line, line 3D, and stock charts.
   */
  SeriesType[SeriesType["Line"] = 2] = "Line";
  /**
   * Pie; used by pie, pie 3D, doughnut, and 'of pie' charts.
   */
  SeriesType[SeriesType["Pie"] = 3] = "Pie";
  /**
   * Radar.
   */
  SeriesType[SeriesType["Radar"] = 4] = "Radar";
  /**
   * Surface; used by surface and surface 3D charts.
   */
  SeriesType[SeriesType["Surface"] = 5] = "Surface";
  /**
   * Scatter.
   */
  SeriesType[SeriesType["Scatter"] = 6] = "Scatter";
  /**
   * Bubble.
   */
  SeriesType[SeriesType["Bubble"] = 7] = "Bubble";
})(SeriesType || (SeriesType = {}));
/**
 * @hidden
 */
export let SeriesType_$type = markEnum('SeriesType', 'Area,0|Bar,1|Line,2|Pie,3|Radar,4|Surface,5|Scatter,6|Bubble,7');
/**
 * Determines the numerical scale of the axis
 */
export var ScaleType;
(function (ScaleType) {
  /**
   * The scale is linear.
   */
  ScaleType[ScaleType["Linear"] = -4132] = "Linear";
  /**
   * The scale is logarithmic.
   */
  ScaleType[ScaleType["Logarithmic"] = -4133] = "Logarithmic";
})(ScaleType || (ScaleType = {}));
/**
 * @hidden
 */
export let ScaleType_$type = markEnum('ScaleType', 'Linear,-4132|Logarithmic,-4133');
/**
 * Constants which determine the reading order.
 */
export var ReadingOrder;
(function (ReadingOrder) {
  /**
   * The direction is based on context.
   */
  ReadingOrder[ReadingOrder["Context"] = -5002] = "Context";
  /**
   * The order is left-to-right.
   */
  ReadingOrder[ReadingOrder["LeftToRight"] = -5003] = "LeftToRight";
  /**
   * The order is right-to-left.
   */
  ReadingOrder[ReadingOrder["RightToLeft"] = -5004] = "RightToLeft";
})(ReadingOrder || (ReadingOrder = {}));
/**
 * @hidden
 */
export let ReadingOrder_$type = markEnum('ReadingOrder', 'Context,-5002|LeftToRight,-5003|RightToLeft,-5004');
/**
 * Constants which determine the method of calculation
 * used when determining the median for a box and whisker chart.
 */
export var QuartileCalculation;
(function (QuartileCalculation) {
  /**
   * The median is included in the calculation if <i>n</i> (the number of values in the data) is odd.
   */
  QuartileCalculation[QuartileCalculation["InclusiveMedian"] = 0] = "InclusiveMedian";
  /**
   * The median is excluded from the calculation if <i>n</i> (the number of values in the data) is odd.
   */
  QuartileCalculation[QuartileCalculation["ExclusiveMedian"] = 1] = "ExclusiveMedian";
})(QuartileCalculation || (QuartileCalculation = {}));
/**
 * @hidden
 */
export let QuartileCalculation_$type = markEnum('QuartileCalculation', 'InclusiveMedian,0|ExclusiveMedian,1');
/**
 * Constants which determine the manner in which a picture is displayed.
 */
export var PictureType;
(function (PictureType) {
  /**
   * The picture is stretched to fill it's containing element.
   */
  PictureType[PictureType["Stretch"] = 1] = "Stretch";
  /**
   * The picture is stacked or tiled to fill it's containing element.
   */
  PictureType[PictureType["Stack"] = 2] = "Stack";
  /**
   * The picture is scaled to fill it's containing element.
   */
  PictureType[PictureType["Scale"] = 3] = "Scale";
})(PictureType || (PictureType = {}));
/**
 * @hidden
 */
export let PictureType_$type = markEnum('PictureType', 'Stretch,1|Stack,2|Scale,3');
/**
 * Constants which define the label positioning for a <i>Treemap</i> chart.
 */
export var ParentLabelLayout;
(function (ParentLabelLayout) {
  /**
   * Labels are not displayed.
   */
  ParentLabelLayout[ParentLabelLayout["None"] = 0] = "None";
  /**
   * Labels are displayed as banners.
   */
  ParentLabelLayout[ParentLabelLayout["Banner"] = 1] = "Banner";
  /**
   * Labels are displayed with overlapping.
   */
  ParentLabelLayout[ParentLabelLayout["Overlapping"] = 2] = "Overlapping";
})(ParentLabelLayout || (ParentLabelLayout = {}));
/**
 * @hidden
 */
export let ParentLabelLayout_$type = markEnum('ParentLabelLayout', 'None,0|Banner,1|Overlapping,2');
/**
 * Constants which determine the style of the markers displayed by line charts.
 */
export var MarkerStyle;
(function (MarkerStyle) {
  /**
   * The marker style is determined automatically.
   */
  MarkerStyle[MarkerStyle["Automatic"] = -4105] = "Automatic";
  /**
   * The marker is circular.
   */
  MarkerStyle[MarkerStyle["Circle"] = 8] = "Circle";
  /**
   * The marker is a dash.
   */
  MarkerStyle[MarkerStyle["Dash"] = -4115] = "Dash";
  /**
   * The marker is diamond-shaped.
   */
  MarkerStyle[MarkerStyle["Diamond"] = 2] = "Diamond";
  /**
   * The marker is a dot or bullet.
   */
  MarkerStyle[MarkerStyle["Dot"] = -4118] = "Dot";
  /**
   * No marker is displayed.
   */
  MarkerStyle[MarkerStyle["None"] = -4142] = "None";
  /**
   * The marker appears as a picture.
   */
  MarkerStyle[MarkerStyle["Picture"] = -4147] = "Picture";
  /**
   * The marker appears as a plus sign (+).
   */
  MarkerStyle[MarkerStyle["Plus"] = 9] = "Plus";
  /**
   * The marker appears as a square.
   */
  MarkerStyle[MarkerStyle["Square"] = 1] = "Square";
  /**
   * The marker appears as a star.
   */
  MarkerStyle[MarkerStyle["Star"] = 5] = "Star";
  /**
   * The marker appears as a triangle.
   */
  MarkerStyle[MarkerStyle["Triangle"] = 3] = "Triangle";
  /**
   * The marker appears as an 'X'
   */
  MarkerStyle[MarkerStyle["X"] = -4168] = "X";
})(MarkerStyle || (MarkerStyle = {}));
/**
 * @hidden
 */
export let MarkerStyle_$type = markEnum('MarkerStyle', 'Automatic,-4105|Circle,8|Dash,-4115|Diamond,2|Dot,-4118|None,-4142|Picture,-4147|Plus,9|Square,1|Star,5|Triangle,3|X,-4168');
/**
 * Determines the style of a line, i.e., solid, dashed, dotted, etc.
 * @see [[ChartLine.lineStyle]]
 */
export var LineStyle;
(function (LineStyle) {
  /**
   * Solid line.
   */
  LineStyle[LineStyle["Solid"] = 0] = "Solid";
  /**
   * Dashed line.
   */
  LineStyle[LineStyle["Dash"] = 1] = "Dash";
  /**
   * Alternating dashes and dots.
   */
  LineStyle[LineStyle["DashDot"] = 2] = "DashDot";
  /**
   * Dotted line.
   */
  LineStyle[LineStyle["Dot"] = 3] = "Dot";
  /**
   * Large dashed line.
   */
  LineStyle[LineStyle["LargeDash"] = 4] = "LargeDash";
  /**
   * Large alternating dashes and dots.
   */
  LineStyle[LineStyle["LargeDashDot"] = 5] = "LargeDashDot";
  /**
   * Large alternating dashes and pairs of dots.
   */
  LineStyle[LineStyle["LargeDashDotDot"] = 6] = "LargeDashDotDot";
  /**
   * No line.
   */
  LineStyle[LineStyle["None"] = 7] = "None";
  /**
   * System-defined dashed line.
   */
  LineStyle[LineStyle["SysDash"] = 8] = "SysDash";
  /**
   * System-defined alternating dashes and dots.
   */
  LineStyle[LineStyle["SysDashDot"] = 9] = "SysDashDot";
  /**
   * System-defined alternating dashes and pairs of dots.
   */
  LineStyle[LineStyle["SysDashDotDot"] = 10] = "SysDashDotDot";
  /**
   * System-defined dotted line.
   */
  LineStyle[LineStyle["SysDot"] = 11] = "SysDot";
})(LineStyle || (LineStyle = {}));
/**
 * @hidden
 */
export let LineStyle_$type = markEnum('LineStyle', 'Solid,0|Dash,1|DashDot,2|Dot,3|LargeDash,4|LargeDashDot,5|LargeDashDotDot,6|None,7|SysDash,8|SysDashDot,9|SysDashDotDot,10|SysDot,11');
/**
 * Constants which determine the placement of the chart's
 * [[Legend]].
 */
export var LegendPosition;
(function (LegendPosition) {
  /**
   * The legend appears at the bottom of the chart.
   */
  LegendPosition[LegendPosition["Bottom"] = 0] = "Bottom";
  /**
   * The legend appears near the left edge of the chart.
   */
  LegendPosition[LegendPosition["Left"] = 1] = "Left";
  /**
   * The legend appears near the right edge of the chart.
   */
  LegendPosition[LegendPosition["Right"] = 2] = "Right";
  /**
   * The legend appears at the top of the chart.
   */
  LegendPosition[LegendPosition["Top"] = 3] = "Top";
  /**
   * The legend appears near the top right corner of the chart.
   */
  LegendPosition[LegendPosition["TopRight"] = 4] = "TopRight";
  /**
   * The legend's size and location is determined by the
   * [[Legend.left]], [[Legend.top]],
   * [[Legend.width]], and [[Legend.height]]
   * properties.
   */
  LegendPosition[LegendPosition["Custom"] = 5] = "Custom";
  /**
   * The legend position is determined automatically by Excel.
   */
  LegendPosition[LegendPosition["Default"] = 6] = "Default";
  /**
   * The legend appears near the top left corner of the chart.
   * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
   */
  LegendPosition[LegendPosition["TopLeft"] = 7] = "TopLeft";
  /**
   * The legend appears near the bottom left corner of the chart.
   * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
   */
  LegendPosition[LegendPosition["BottomLeft"] = 8] = "BottomLeft";
  /**
   * The legend appears near the bottom right corner of the chart.
   * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
   */
  LegendPosition[LegendPosition["BottomRight"] = 9] = "BottomRight";
})(LegendPosition || (LegendPosition = {}));
/**
 * @hidden
 */
export let LegendPosition_$type = markEnum('LegendPosition', 'Bottom,0|Left,1|Right,2|Top,3|TopRight,4|Custom,5|Default,6|TopLeft,7|BottomLeft,8|BottomRight,9');
/**
 * @hidden
 */
export let HorizontalTitleAlignment_$type = markEnum('HorizontalTitleAlignment', 'Center,-4108|Distributed,-4117|Justify,-4130|Left,-4131|Right,-4152');
/**
 * Constants which define whether a gridline is major or minor.
 */
export var GridLineType;
(function (GridLineType) {
  /**
   * [[Axis.majorGridLines]]
   */
  GridLineType[GridLineType["Major"] = 0] = "Major";
  /**
   * [[Axis.minorGridLines]]
   */
  GridLineType[GridLineType["Minor"] = 1] = "Minor";
})(GridLineType || (GridLineType = {}));
/**
 * @hidden
 */
export let GridLineType_$type = markEnum('GridLineType', 'Major,0|Minor,1');
/**
 * Constants which determine the type of gradient applied to a
 * [[ChartGradientFill]].
 */
export var GradientType;
(function (GradientType) {
  /**
   * The gradient extends in a linear direction.
   */
  GradientType[GradientType["Linear"] = 0] = "Linear";
  /**
   * The gradient extends along a radial curve.
   */
  GradientType[GradientType["Radial"] = 1] = "Radial";
  /**
   * The gradient extends along a rectangular path.
   */
  GradientType[GradientType["Rectangular"] = 2] = "Rectangular";
  /**
   * The gradient direction is determined by the shape's path.
   */
  GradientType[GradientType["Path"] = 3] = "Path";
})(GradientType || (GradientType = {}));
/**
 * @hidden
 */
export let GradientType_$type = markEnum('GradientType', 'Linear,0|Radial,1|Rectangular,2|Path,3');
/**
 * Constants which specify the units used to depict errors on an
 * <see cref="ErrorBars">error bar</see>.
 */
export var ErrorValueType;
(function (ErrorValueType) {
  /**
   * The error range is defined by a fixed numerical value.
   */
  ErrorValueType[ErrorValueType["FixedValue"] = 0] = "FixedValue";
  /**
   * The error range is defined by a percentage.
   */
  ErrorValueType[ErrorValueType["Percentage"] = 1] = "Percentage";
  /**
   * The error range is defined by standard deviation.
   */
  ErrorValueType[ErrorValueType["StandardDeviation"] = 2] = "StandardDeviation";
  /**
   * The error range is defined by standard error.
   */
  ErrorValueType[ErrorValueType["StandardError"] = 3] = "StandardError";
})(ErrorValueType || (ErrorValueType = {}));
/**
 * @hidden
 */
export let ErrorValueType_$type = markEnum('ErrorValueType', 'FixedValue,0|Percentage,1|StandardDeviation,2|StandardError,3');
/**
 * Constants which specify the direction in which an
 * <see cref="ErrorBars">error bar</see> extends.
 */
export var ErrorBarDirection;
(function (ErrorBarDirection) {
  /**
   * The error bar extends in both directions.
   */
  ErrorBarDirection[ErrorBarDirection["Both"] = 0] = "Both";
  /**
   * The error bar extends only in the positive direction.
   */
  ErrorBarDirection[ErrorBarDirection["Plus"] = 1] = "Plus";
  /**
   * The error bar extends only in the negative direction.
   */
  ErrorBarDirection[ErrorBarDirection["Minus"] = 2] = "Minus";
})(ErrorBarDirection || (ErrorBarDirection = {}));
/**
 * @hidden
 */
export let ErrorBarDirection_$type = markEnum('ErrorBarDirection', 'Both,0|Plus,1|Minus,2');
/**
 * Constants which determine the style of the endpoint
 * of a line on a line chart.
 */
export var EndStyleCap;
(function (EndStyleCap) {
  /**
   * The line terminates with a cap.
   */
  EndStyleCap[EndStyleCap["Cap"] = 1] = "Cap";
  /**
   * No cap is displayed at the end of the line.
   */
  EndStyleCap[EndStyleCap["NoCap"] = 2] = "NoCap";
})(EndStyleCap || (EndStyleCap = {}));
/**
 * @hidden
 */
export let EndStyleCap_$type = markEnum('EndStyleCap', 'Cap,1|NoCap,2');
/**
 * Constants which determine whether a chart element is positioned
 * automatically or at a specific location in the chart space.
 */
export var ElementPosition;
(function (ElementPosition) {
  /**
   * The chart element is positioned automatically as appropriate
   * for that element. For example, a [[ChartTitle]] is typically
   * positioned at the top of the chart space, centered horizontally.
   */
  ElementPosition[ElementPosition["Automatic"] = -4105] = "Automatic";
  /**
   * Custom.
   */
  ElementPosition[ElementPosition["Custom"] = -4114] = "Custom";
  /**
   * The chart element is positioned above the plot area, centered horizontally.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["Top"] = 100] = "Top";
  /**
   * The chart element is positioned to the left of the plot area, centered vertically.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["Left"] = 101] = "Left";
  /**
   * The chart element is positioned to the right of the plot area, centered vertically.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["Right"] = 102] = "Right";
  /**
   * The chart element is positioned under the plot area, centered horizontally.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["Bottom"] = 103] = "Bottom";
  /**
   * The chart element is positioned above the plot area, horizontally aligned with the left edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["TopLeft"] = 104] = "TopLeft";
  /**
   * The chart element is positioned above the plot area, horizontally aligned with the right edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["TopRight"] = 105] = "TopRight";
  /**
   * The chart element is positioned below the plot area, horizontally aligned with the left edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["BottomLeft"] = 106] = "BottomLeft";
  /**
   * The chart element is positioned below the plot area, horizontally aligned with the right edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["BottomRight"] = 107] = "BottomRight";
  /**
   * The chart element is positioned to the left of the plot area, vertically aligned with the top edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["LeftTop"] = 108] = "LeftTop";
  /**
   * The chart element is positioned to the left of the plot area, vertically aligned with the bottom edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["LeftBottom"] = 109] = "LeftBottom";
  /**
   * The chart element is positioned to the right of the plot area, vertically aligned with the top edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["RightTop"] = 110] = "RightTop";
  /**
   * The chart element is positioned to the right of the plot area, vertically aligned with the bottom edge.
   * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
   */
  ElementPosition[ElementPosition["RightBottom"] = 111] = "RightBottom";
})(ElementPosition || (ElementPosition = {}));
/**
 * @hidden
 */
export let ElementPosition_$type = markEnum('ElementPosition', 'Automatic,-4105|Custom,-4114|Top,100|Left,101|Right,102|Bottom,103|TopLeft,104|TopRight,105|BottomLeft,106|BottomRight,107|LeftTop,108|LeftBottom,109|RightTop,110|RightBottom,111');
/**
 * Constants which determine the unit of expression for
 * [[Axis]] value labels.
 */
export var DisplayUnit;
(function (DisplayUnit) {
  /**
   * The raw value is displayed without special formatting.
   */
  DisplayUnit[DisplayUnit["None"] = -4142] = "None";
  /**
   * The [[Axis.displayUnitCustom]] property determines the display unit.
   */
  DisplayUnit[DisplayUnit["Custom"] = -4114] = "Custom";
  /**
   * 100,000,000
   */
  DisplayUnit[DisplayUnit["HundredMillions"] = -8] = "HundredMillions";
  /**
   * 100
   */
  DisplayUnit[DisplayUnit["Hundreds"] = -2] = "Hundreds";
  /**
   * 100,000
   */
  DisplayUnit[DisplayUnit["HundredThousands"] = -5] = "HundredThousands";
  /**
   * 1,000,000,000,000 (trillions)
   */
  DisplayUnit[DisplayUnit["MillionMillions"] = -10] = "MillionMillions";
  /**
   * 1,000,000
   */
  DisplayUnit[DisplayUnit["Millions"] = -6] = "Millions";
  /**
   * 10,000,000
   */
  DisplayUnit[DisplayUnit["TenMillions"] = -7] = "TenMillions";
  /**
   * 10,000
   */
  DisplayUnit[DisplayUnit["TenThousands"] = -4] = "TenThousands";
  /**
   * 1,000,000,000 (billions)
   */
  DisplayUnit[DisplayUnit["ThousandMillions"] = -9] = "ThousandMillions";
  /**
   * 1,000
   */
  DisplayUnit[DisplayUnit["Thousands"] = -3] = "Thousands";
  /**
   * Displays as a percentage. Applicable only to
   * Box and Whisker, Histogram, Pareto, Sunburst, Treemap, and Waterfall chart types;
   * if used for any other chart type, resolved to <i>Hundreds</i>.
   */
  DisplayUnit[DisplayUnit["Percentage"] = 1] = "Percentage";
})(DisplayUnit || (DisplayUnit = {}));
/**
 * @hidden
 */
export let DisplayUnit_$type = markEnum('DisplayUnit', 'None,-4142|Custom,-4114|HundredMillions,-8|Hundreds,-2|HundredThousands,-5|MillionMillions,-10|Millions,-6|TenMillions,-7|TenThousands,-4|ThousandMillions,-9|Thousands,-3|Percentage,1');
/**
 * Constants which define how blank cell values are plotted on the chart.
 */
export var DisplayBlanksAs;
(function (DisplayBlanksAs) {
  /**
   * Points representing blank cell values are not plotted on the chart.
   */
  DisplayBlanksAs[DisplayBlanksAs["NotPlotted"] = 1] = "NotPlotted";
  /**
   * Blank cell values are interpreted as having a value of zero.
   */
  DisplayBlanksAs[DisplayBlanksAs["Zero"] = 2] = "Zero";
  /**
   * The value is interpolated from adjacent values.
   */
  DisplayBlanksAs[DisplayBlanksAs["Interpolated"] = 3] = "Interpolated";
})(DisplayBlanksAs || (DisplayBlanksAs = {}));
/**
 * @hidden
 */
export let DisplayBlanksAs_$type = markEnum('DisplayBlanksAs', 'NotPlotted,1|Zero,2|Interpolated,3');
/**
 * Constants which define the location at which a [[DataLabel]] is positioned.
 * <p class="body">
 * Note that which constants in this enumeration are applicable is dependent on the chart type.
 * </p>
 * <p class="body">
 * The following table lists the supported constants for each chart type.
 * </p>
 * <p class="body">
 * <table border="1">
 * <tr>
 * <th><b>Chart Type</b></th><th><b>Supported Constant(s)</b></th>
 * </tr>
 * <tr>
 * <td>3D charts (except pie/doughnut)</td><td>Custom</td>
 * </tr>
 * <tr>
 * <td>Area, Radar</td><td>Custom</td>
 * </tr>
 * <tr>
 * <td>Surface</td><td>Data labels are not supported</td>
 * </tr>
 * <tr>
 * <td>Bar/Column (stacked)</td><td>Center, InsideEnd, InsideBase</td>
 * </tr>
 * <tr>
 * <td>Bar/Column (clustered)</td><td>Center, InsideEnd, InsideBase, OutsideEnd</td>
 * </tr>
 * <tr>
 * <td>Line/Scatter/Bubble</td><td>Center, Left, Right, Above, Below</td>
 * </tr>
 * <tr>
 * <td>Pie/Doughnut</td><td>Center, InsideEnd, OutsideEnd, BestFit</td>
 * </tr>
 * </table>
 * </p>
 * @see [[DataLabel.labelPosition]]
 * @see [[Series.dataLabels]]
 * @see [[DataLabel]]
 */
export var DataLabelPosition;
(function (DataLabelPosition) {
  /**
   * The label position is not specified, and is determined automatically by Excel.
   */
  DataLabelPosition[DataLabelPosition["Default"] = 0] = "Default";
  /**
   * The label is centered with respect to the associated data point.
   */
  DataLabelPosition[DataLabelPosition["Center"] = 1] = "Center";
  /**
   * The label's left edge coincides with the left edge of the series bar/line.
   */
  DataLabelPosition[DataLabelPosition["InsideBase"] = 2] = "InsideBase";
  /**
   * The label's right edge coincides with the right edge of the series bar/line.
   */
  DataLabelPosition[DataLabelPosition["InsideEnd"] = 3] = "InsideEnd";
  /**
   * The label's left edge coincides with the right edge of the series bar/line.
   */
  DataLabelPosition[DataLabelPosition["OutsideEnd"] = 4] = "OutsideEnd";
  /**
   * The label's position is explicitly defined via the [[ChartTextAreaBase.left]]
   * and [[ChartTextAreaBase.top]] properties.
   */
  DataLabelPosition[DataLabelPosition["Custom"] = 5] = "Custom";
  /**
   * The label is positioned to the left of the associated data point.
   */
  DataLabelPosition[DataLabelPosition["Left"] = 6] = "Left";
  /**
   * The label is positioned to the right of the associated data point.
   */
  DataLabelPosition[DataLabelPosition["Right"] = 7] = "Right";
  /**
   * The label is positioned above the associated data point.
   */
  DataLabelPosition[DataLabelPosition["Above"] = 8] = "Above";
  /**
   * The label is positioned below the associated data point.
   */
  DataLabelPosition[DataLabelPosition["Below"] = 9] = "Below";
  /**
   * The label is positioned where it best fits with relation to the associated pie slice.
   */
  DataLabelPosition[DataLabelPosition["BestFit"] = 10] = "BestFit";
})(DataLabelPosition || (DataLabelPosition = {}));
/**
 * @hidden
 */
export let DataLabelPosition_$type = markEnum('DataLabelPosition', 'Default,0|Center,1|InsideBase,2|InsideEnd,3|OutsideEnd,4|Custom,5|Left,6|Right,7|Above,8|Below,9|BestFit,10');
/**
 * @hidden
 */
export let ChartTypeContext_$type = markEnum('ChartTypeContext', 'Default,0|Series,1');
/**
 * Constants which identify the chart's type, i.e.,
 * area chart, bar chart, pie chart, etc.
 */
export var ChartType;
(function (ChartType) {
  /**
   * Not an actual value; used for variable initialization.
   */
  ChartType[ChartType["Unknown"] = 0] = "Unknown";
  /**
   * 3D Area.
   */
  ChartType[ChartType["Area3D"] = -4098] = "Area3D";
  /**
   * 3D Stacked Area.
   */
  ChartType[ChartType["Area3DStacked"] = 78] = "Area3DStacked";
  /**
   * 100% Stacked Area.
   */
  ChartType[ChartType["Area3DStacked100"] = 79] = "Area3DStacked100";
  /**
   * 3D Clustered Bar.
   */
  ChartType[ChartType["Bar3DClustered"] = 60] = "Bar3DClustered";
  /**
   * 3D Stacked Bar.
   */
  ChartType[ChartType["Bar3DStacked"] = 61] = "Bar3DStacked";
  /**
   * 3D 100% Stacked Bar.
   */
  ChartType[ChartType["Bar3DStacked100"] = 62] = "Bar3DStacked100";
  /**
   * 3D Column.
   */
  ChartType[ChartType["Column3D"] = -4100] = "Column3D";
  /**
   * 3D Clustered Column.
   */
  ChartType[ChartType["Column3DClustered"] = 54] = "Column3DClustered";
  /**
   * 3D Stacked Column.
   */
  ChartType[ChartType["Column3DStacked"] = 55] = "Column3DStacked";
  /**
   * 3D 100% Stacked Column.
   */
  ChartType[ChartType["Column3DStacked100"] = 56] = "Column3DStacked100";
  /**
   * 3D Line.
   */
  ChartType[ChartType["Line3D"] = -4101] = "Line3D";
  /**
   * 3D Pie.
   */
  ChartType[ChartType["Pie3D"] = -4102] = "Pie3D";
  /**
   * Exploded 3D Pie.
   */
  ChartType[ChartType["Pie3DExploded"] = 70] = "Pie3DExploded";
  /**
   * Area
   */
  ChartType[ChartType["Area"] = 1] = "Area";
  /**
   * Stacked Area.
   */
  ChartType[ChartType["AreaStacked"] = 76] = "AreaStacked";
  /**
   * 100% Stacked Area.
   */
  ChartType[ChartType["AreaStacked100"] = 77] = "AreaStacked100";
  /**
   * Clustered Bar.
   */
  ChartType[ChartType["BarClustered"] = 57] = "BarClustered";
  /**
   * Bar of Pie.
   */
  ChartType[ChartType["BarOfPie"] = 71] = "BarOfPie";
  /**
   * Stacked Bar.
   */
  ChartType[ChartType["BarStacked"] = 58] = "BarStacked";
  /**
   * 100% Stacked Bar.
   */
  ChartType[ChartType["BarStacked100"] = 59] = "BarStacked100";
  /**
   * Bubble.
   */
  ChartType[ChartType["Bubble"] = 15] = "Bubble";
  /**
   * Bubble with 3D effects.
   */
  ChartType[ChartType["Bubble3DEffect"] = 87] = "Bubble3DEffect";
  /**
   * Clustered Column.
   */
  ChartType[ChartType["ColumnClustered"] = 51] = "ColumnClustered";
  /**
   * Stacked Column.
   */
  ChartType[ChartType["ColumnStacked"] = 52] = "ColumnStacked";
  /**
   * 100% Stacked Column.
   */
  ChartType[ChartType["ColumnStacked100"] = 53] = "ColumnStacked100";
  /**
   * Clustered Cone Bar.
   */
  ChartType[ChartType["ConeBarClustered"] = 102] = "ConeBarClustered";
  /**
   * Stacked Cone Bar.
   */
  ChartType[ChartType["ConeBarStacked"] = 103] = "ConeBarStacked";
  /**
   * 100% Stacked Cone Bar.
   */
  ChartType[ChartType["ConeBarStacked100"] = 104] = "ConeBarStacked100";
  /**
   * 3D Cone Column.
   */
  ChartType[ChartType["ConeCol"] = 105] = "ConeCol";
  /**
   * Clustered Cone Column.
   */
  ChartType[ChartType["ConeColClustered"] = 99] = "ConeColClustered";
  /**
   * Stacked Cone Column.
   */
  ChartType[ChartType["ConeColStacked"] = 100] = "ConeColStacked";
  /**
   * 100% Stacked Cone Column.
   */
  ChartType[ChartType["ConeColStacked100"] = 101] = "ConeColStacked100";
  /**
   * Clustered Cylinder Bar.
   */
  ChartType[ChartType["CylinderBarClustered"] = 95] = "CylinderBarClustered";
  /**
   * Stacked Cylinder Bar.
   */
  ChartType[ChartType["CylinderBarStacked"] = 96] = "CylinderBarStacked";
  /**
   * 100% Stacked Cylinder Bar.
   */
  ChartType[ChartType["CylinderBarStacked100"] = 97] = "CylinderBarStacked100";
  /**
   * 3D Cylinder Column.
   */
  ChartType[ChartType["CylinderCol"] = 98] = "CylinderCol";
  /**
   * Clustered Cone Column.
   */
  ChartType[ChartType["CylinderColClustered"] = 92] = "CylinderColClustered";
  /**
   * Stacked Cone Column.
   */
  ChartType[ChartType["CylinderColStacked"] = 93] = "CylinderColStacked";
  /**
   * 100% Stacked Cylinder Column.
   */
  ChartType[ChartType["CylinderColStacked100"] = 94] = "CylinderColStacked100";
  /**
   * Doughnut.
   */
  ChartType[ChartType["Doughnut"] = -4120] = "Doughnut";
  /**
   * Exploded Doughnut.
   */
  ChartType[ChartType["DoughnutExploded"] = 80] = "DoughnutExploded";
  /**
   * Line.
   */
  ChartType[ChartType["Line"] = 4] = "Line";
  /**
   * Line with Markers.
   */
  ChartType[ChartType["LineMarkers"] = 65] = "LineMarkers";
  /**
   * Stacked Line with Markers.
   */
  ChartType[ChartType["LineMarkersStacked"] = 66] = "LineMarkersStacked";
  /**
   * 100% Stacked Line with Markers.
   */
  ChartType[ChartType["LineMarkersStacked100"] = 67] = "LineMarkersStacked100";
  /**
   * Stacked Line.
   */
  ChartType[ChartType["LineStacked"] = 63] = "LineStacked";
  /**
   * 100% Stacked Line.
   */
  ChartType[ChartType["LineStacked100"] = 64] = "LineStacked100";
  /**
   * Pie.
   */
  ChartType[ChartType["Pie"] = 5] = "Pie";
  /**
   * Exploded Pie.
   */
  ChartType[ChartType["PieExploded"] = 69] = "PieExploded";
  /**
   * Pie of Pie.
   */
  ChartType[ChartType["PieOfPie"] = 68] = "PieOfPie";
  /**
   * Clustered Pyramid Bar.
   */
  ChartType[ChartType["PyramidBarClustered"] = 109] = "PyramidBarClustered";
  /**
   * Stacked Pyramid Bar.
   */
  ChartType[ChartType["PyramidBarStacked"] = 110] = "PyramidBarStacked";
  /**
   * 100% Stacked Pyramid Bar.
   */
  ChartType[ChartType["PyramidBarStacked100"] = 111] = "PyramidBarStacked100";
  /**
   * 3D Pyramid Column.
   */
  ChartType[ChartType["PyramidCol"] = 112] = "PyramidCol";
  /**
   * Clustered Pyramid Column.
   */
  ChartType[ChartType["PyramidColClustered"] = 106] = "PyramidColClustered";
  /**
   * Stacked Pyramid Column.
   */
  ChartType[ChartType["PyramidColStacked"] = 107] = "PyramidColStacked";
  /**
   * 100% Stacked Pyramid Column.
   */
  ChartType[ChartType["PyramidColStacked100"] = 108] = "PyramidColStacked100";
  /**
   * Radar.
   */
  ChartType[ChartType["Radar"] = -4151] = "Radar";
  /**
   * Filled Radar.
   */
  ChartType[ChartType["RadarFilled"] = 82] = "RadarFilled";
  /**
   * Radar with Data Markers.
   */
  ChartType[ChartType["RadarMarkers"] = 81] = "RadarMarkers";
  /**
   * High-Low-Close.
   */
  ChartType[ChartType["StockHLC"] = 88] = "StockHLC";
  /**
   * Open-High-Low-Close.
   */
  ChartType[ChartType["StockOHLC"] = 89] = "StockOHLC";
  /**
   * Volume-High-Low-Close.
   */
  ChartType[ChartType["StockVHLC"] = 90] = "StockVHLC";
  /**
   * Volume-Open-High-Low-Close.
   */
  ChartType[ChartType["StockVOHLC"] = 91] = "StockVOHLC";
  /**
   * Surface (a.k.a. Contour).
   */
  ChartType[ChartType["Surface"] = 83] = "Surface";
  /**
   * 3D Surface (Top View).
   */
  ChartType[ChartType["SurfaceTopView"] = 85] = "SurfaceTopView";
  /**
   * 3D Surface (Top View wireframe).
   */
  ChartType[ChartType["SurfaceTopViewWireframe"] = 86] = "SurfaceTopViewWireframe";
  /**
   * Surface (a.k.a. Contour - wireframe).
   */
  ChartType[ChartType["SurfaceWireframe"] = 84] = "SurfaceWireframe";
  /**
   * Scatter.
   */
  ChartType[ChartType["XYScatter"] = -4169] = "XYScatter";
  /**
   * Scatter with Lines.
   */
  ChartType[ChartType["XYScatterLines"] = 74] = "XYScatterLines";
  /**
   * Scatter with Lines and No Data Markers.
   */
  ChartType[ChartType["XYScatterLinesNoMarkers"] = 75] = "XYScatterLinesNoMarkers";
  /**
   * Scatter with Smoothed Lines.
   */
  ChartType[ChartType["XYScatterSmooth"] = 72] = "XYScatterSmooth";
  /**
   * Scatter with Smoothed Lines and No Data Markers.
   */
  ChartType[ChartType["XYScatterSmoothNoMarkers"] = 73] = "XYScatterSmoothNoMarkers";
  /**
   * Combination of different chart types.
   */
  ChartType[ChartType["Combo"] = 113] = "Combo";
  /**
   * Box and whisker (Office2016 or later)
   */
  ChartType[ChartType["BoxAndWhisker"] = 114] = "BoxAndWhisker";
  /**
   * Funnel (Office365 only)
   */
  ChartType[ChartType["Funnel"] = 115] = "Funnel";
  /**
   * Pareto chart with bars and lines (Office2016 or later)
   */
  ChartType[ChartType["Pareto"] = 116] = "Pareto";
  /**
   * Histogram chart (Office2016 or later)
   */
  ChartType[ChartType["Histogram"] = 117] = "Histogram";
  /**
   * Sunburst chart (Office2016 or later)
   */
  ChartType[ChartType["Sunburst"] = 118] = "Sunburst";
  /**
   * Tree map chart (Office2016 or later)
   */
  ChartType[ChartType["Treemap"] = 119] = "Treemap";
  /**
   * Waterfall chart (Office2016 or later)
   */
  ChartType[ChartType["Waterfall"] = 120] = "Waterfall";
  /**
   * Region map (geographic) chart (Office365 only)
   */
  ChartType[ChartType["RegionMap"] = 121] = "RegionMap";
})(ChartType || (ChartType = {}));
/**
 * @hidden
 */
export let ChartType_$type = markEnum('ChartType', 'Unknown,0|Area3D,-4098|Area3DStacked,78|Area3DStacked100,79|Bar3DClustered,60|Bar3DStacked,61|Bar3DStacked100,62|Column3D,-4100|Column3DClustered,54|Column3DStacked,55|Column3DStacked100,56|Line3D,-4101|Pie3D,-4102|Pie3DExploded,70|Area,1|AreaStacked,76|AreaStacked100,77|BarClustered,57|BarOfPie,71|BarStacked,58|BarStacked100,59|Bubble,15|Bubble3DEffect,87|ColumnClustered,51|ColumnStacked,52|ColumnStacked100,53|ConeBarClustered,102|ConeBarStacked,103|ConeBarStacked100,104|ConeCol,105|ConeColClustered,99|ConeColStacked,100|ConeColStacked100,101|CylinderBarClustered,95|CylinderBarStacked,96|CylinderBarStacked100,97|CylinderCol,98|CylinderColClustered,92|CylinderColStacked,93|CylinderColStacked100,94|Doughnut,-4120|DoughnutExploded,80|Line,4|LineMarkers,65|LineMarkersStacked,66|LineMarkersStacked100,67|LineStacked,63|LineStacked100,64|Pie,5|PieExploded,69|PieOfPie,68|PyramidBarClustered,109|PyramidBarStacked,110|PyramidBarStacked100,111|PyramidCol,112|PyramidColClustered,106|PyramidColStacked,107|PyramidColStacked100,108|Radar,-4151|RadarFilled,82|RadarMarkers,81|StockHLC,88|StockOHLC,89|StockVHLC,90|StockVOHLC,91|Surface,83|SurfaceTopView,85|SurfaceTopViewWireframe,86|SurfaceWireframe,84|XYScatter,-4169|XYScatterLines,74|XYScatterLinesNoMarkers,75|XYScatterSmooth,72|XYScatterSmoothNoMarkers,73|Combo,113|BoxAndWhisker,114|Funnel,115|Pareto,116|Histogram,117|Sunburst,118|Treemap,119|Waterfall,120|RegionMap,121');
/**
 * @hidden
 */
export let ChartsheetProtectionType_$type = markEnum('ChartsheetProtectionType', 'Objects,1|Contents,2');
/**
 * Constants which define the type of a category axis.
 */
export var CategoryType;
(function (CategoryType) {
  /**
   * Scale is determined automatically.
   */
  CategoryType[CategoryType["AutomaticScale"] = -4105] = "AutomaticScale";
  /**
   * A category [[Axis]].
   */
  CategoryType[CategoryType["CategoryScale"] = 2] = "CategoryScale";
  /**
   * A date/time [[Axis]].
   */
  CategoryType[CategoryType["TimeScale"] = 3] = "TimeScale";
})(CategoryType || (CategoryType = {}));
/**
 * @hidden
 */
export let CategoryType_$type = markEnum('CategoryType', 'AutomaticScale,-4105|CategoryScale,2|TimeScale,3');
/**
 * Determines the style of a border line, i.e., solid, dashed, dotted, etc.
 * @see [[ChartBorder.lineStyle]]
 */
export var BorderLineStyle;
(function (BorderLineStyle) {
  /**
   * Solid line.
   */
  BorderLineStyle[BorderLineStyle["Solid"] = 0] = "Solid";
  /**
   * Dashed line.
   */
  BorderLineStyle[BorderLineStyle["Dash"] = 1] = "Dash";
  /**
   * Alternating dashes and dots.
   */
  BorderLineStyle[BorderLineStyle["DashDot"] = 2] = "DashDot";
  /**
   * Dotted line.
   */
  BorderLineStyle[BorderLineStyle["Dot"] = 3] = "Dot";
  /**
   * Large dashed line.
   */
  BorderLineStyle[BorderLineStyle["LargeDash"] = 4] = "LargeDash";
  /**
   * Large alternating dashes and dots.
   */
  BorderLineStyle[BorderLineStyle["LargeDashDot"] = 5] = "LargeDashDot";
  /**
   * Large alternating dashes and pairs of dots.
   */
  BorderLineStyle[BorderLineStyle["LargeDashDotDot"] = 6] = "LargeDashDotDot";
  /**
   * No line.
   */
  BorderLineStyle[BorderLineStyle["None"] = 7] = "None";
  /**
   * System-defined dashed line.
   */
  BorderLineStyle[BorderLineStyle["SysDash"] = 8] = "SysDash";
  /**
   * System-defined alternating dashes and dots.
   */
  BorderLineStyle[BorderLineStyle["SysDashDot"] = 9] = "SysDashDot";
  /**
   * System-defined alternating dashes and pairs of dots.
   */
  BorderLineStyle[BorderLineStyle["SysDashDotDot"] = 10] = "SysDashDotDot";
  /**
   * System-defined dotted line.
   */
  BorderLineStyle[BorderLineStyle["SysDot"] = 11] = "SysDot";
})(BorderLineStyle || (BorderLineStyle = {}));
/**
 * @hidden
 */
export let BorderLineStyle_$type = markEnum('BorderLineStyle', 'Solid,0|Dash,1|DashDot,2|Dot,3|LargeDash,4|LargeDashDot,5|LargeDashDotDot,6|None,7|SysDash,8|SysDashDot,9|SysDashDotDot,10|SysDot,11');
/**
 * @hidden
 */
export let IntervalClosedSide_$type = markEnum('IntervalClosedSide', 'Left,0|Right,1');
/**
 * Constants which define the shape used by a bar chart series.
 */
export var BarShape;
(function (BarShape) {
  /**
   * Square box
   */
  BarShape[BarShape["Box"] = 0] = "Box";
  /**
   * Pyramid-shaped bar extending to the series maximum.
   */
  BarShape[BarShape["PyramidToPoint"] = 1] = "PyramidToPoint";
  /**
   * Truncated pyramid-shaped bar.
   */
  BarShape[BarShape["PyramidToMax"] = 2] = "PyramidToMax";
  /**
   * Cylinder shaped bar.
   */
  BarShape[BarShape["Cylinder"] = 3] = "Cylinder";
  /**
   * Cone-shaped bar extending to the series maximum.
   */
  BarShape[BarShape["ConeToPoint"] = 4] = "ConeToPoint";
  /**
   * Truncated cone-shaped bar.
   */
  BarShape[BarShape["ConeToMax"] = 5] = "ConeToMax";
})(BarShape || (BarShape = {}));
/**
 * @hidden
 */
export let BarShape_$type = markEnum('BarShape', 'Box,0|PyramidToPoint,1|PyramidToMax,2|Cylinder,3|ConeToPoint,4|ConeToMax,5');
/**
 * Specifies the axis type.
 */
export var AxisType;
(function (AxisType) {
  /**
   * Axis displays categories.
   */
  AxisType[AxisType["Category"] = 1] = "Category";
  /**
   * Axis displays values.
   */
  AxisType[AxisType["Value"] = 2] = "Value";
  /**
   * Axis displays data series along the Z-axis (3D charts only).
   */
  AxisType[AxisType["SeriesAxis"] = 3] = "SeriesAxis";
})(AxisType || (AxisType = {}));
/**
 * @hidden
 */
export let AxisType_$type = markEnum('AxisType', 'Category,1|Value,2|SeriesAxis,3');
/**
 * Constants which determine the placement of an [[Axis]],
 * as relative to the chart space.
 */
export var AxisPosition;
(function (AxisPosition) {
  /**
   * The axis is positioned automatically, with the value axes
   * appearing on the left/right, and the category axes appearing
   * on the top/bottom.
   */
  AxisPosition[AxisPosition["Automatic"] = 0] = "Automatic";
  /**
   * The axis appears alongside the bottom edge of the chart.
   */
  AxisPosition[AxisPosition["Bottom"] = 1] = "Bottom";
  /**
   * The axis appears alongside the left edge of the chart.
   */
  AxisPosition[AxisPosition["Left"] = 2] = "Left";
  /**
   * The axis appears alongside the right edge of the chart.
   */
  AxisPosition[AxisPosition["Right"] = 3] = "Right";
  /**
   * The axis appears alongside the top edge of the chart.
   */
  AxisPosition[AxisPosition["Top"] = 4] = "Top";
})(AxisPosition || (AxisPosition = {}));
/**
 * @hidden
 */
export let AxisPosition_$type = markEnum('AxisPosition', 'Automatic,0|Bottom,1|Left,2|Right,3|Top,4');
/**
 * Specifies the group of the axis, i.e., whether it is a primary
 * or secondary axis.
 */
export var AxisGroup;
(function (AxisGroup) {
  /**
   * Primary axis group.
   */
  AxisGroup[AxisGroup["Primary"] = 1] = "Primary";
  /**
   * Secondary axis group. Invalid for [[AxisType.seriesAxis]] in 3D charts
   */
  AxisGroup[AxisGroup["Secondary"] = 2] = "Secondary";
})(AxisGroup || (AxisGroup = {}));
/**
 * @hidden
 */
export let AxisGroup_$type = markEnum('AxisGroup', 'Primary,1|Secondary,2');
/**
 * Constants which describe the point at which
 * <see cref="Axis">axes</see> intersect.
 */
export var AxisCrosses;
(function (AxisCrosses) {
  /**
   * The crossing point is determined automatically.
   */
  AxisCrosses[AxisCrosses["Automatic"] = -4105] = "Automatic";
  /**
   * A custom value is designated as the crossing point, using the
   * [[Axis.crossesAt]] property
   */
  AxisCrosses[AxisCrosses["Custom"] = -4114] = "Custom";
  /**
   * The axes cross at the point coinciding with the axis' maximum value.
   */
  AxisCrosses[AxisCrosses["Maximum"] = 2] = "Maximum";
  /**
   * The axes cross at the point coinciding with the axis' minimum value.
   */
  AxisCrosses[AxisCrosses["Minimum"] = 4] = "Minimum";
})(AxisCrosses || (AxisCrosses = {}));
/**
 * @hidden
 */
export let AxisCrosses_$type = markEnum('AxisCrosses', 'Automatic,-4105|Custom,-4114|Maximum,2|Minimum,4');
/**
 * Constants which define the manner in which colors are used
 * to depict series values in a geographic map chart.
 */
export var GeographicMapSeriesColor;
(function (GeographicMapSeriesColor) {
  /**
   * Two colors define the minimum and maximum series values.
   */
  GeographicMapSeriesColor[GeographicMapSeriesColor["Sequential"] = 0] = "Sequential";
  /**
   * Three colors define the minimum, midpoint, and maximum series values.
   */
  GeographicMapSeriesColor[GeographicMapSeriesColor["Diverging"] = 1] = "Diverging";
})(GeographicMapSeriesColor || (GeographicMapSeriesColor = {}));
/**
 * @hidden
 */
export let GeographicMapSeriesColor_$type = markEnum('GeographicMapSeriesColor', 'Sequential,0|Diverging,1');
/**
 * Constants which define the manner in which map labels are displayed.
 */
export var GeographicMapLabels;
(function (GeographicMapLabels) {
  /**
   * Map labels are not displayed.
   */
  GeographicMapLabels[GeographicMapLabels["None"] = 0] = "None";
  /**
   * Map labels are displayed only for regions inside which the label can fit.
   */
  GeographicMapLabels[GeographicMapLabels["BestFit"] = 1] = "BestFit";
  /**
   * Map labels are displayed for all regions.
   */
  GeographicMapLabels[GeographicMapLabels["ShowAll"] = 2] = "ShowAll";
})(GeographicMapLabels || (GeographicMapLabels = {}));
/**
 * @hidden
 */
export let GeographicMapLabels_$type = markEnum('GeographicMapLabels', 'None,0|BestFit,1|ShowAll,2');
/**
 * Constants which define the level of granularity for a geographic map chart.
 */
export var GeographicMappingArea;
(function (GeographicMappingArea) {
  /**
   * Only regions for which series data is available are displayed.
   */
  GeographicMappingArea[GeographicMappingArea["DataOnly"] = 0] = "DataOnly";
  /**
   * A postal region is displayed.
   */
  GeographicMappingArea[GeographicMappingArea["PostalCode"] = 1] = "PostalCode";
  /**
   * A county is displayed.
   */
  GeographicMappingArea[GeographicMappingArea["County"] = 2] = "County";
  /**
   * A state is displayed.
   */
  GeographicMappingArea[GeographicMappingArea["State"] = 3] = "State";
  /**
   * The entire country or region is displayed, with areas for which no
   * series data is available appearing in a lighter color.
   */
  GeographicMappingArea[GeographicMappingArea["CountryOrRegion"] = 4] = "CountryOrRegion";
  /**
   * Multiple countries or regions are displayed, with areas for which no
   * series data is available appearing in a lighter color.
   */
  GeographicMappingArea[GeographicMappingArea["MultipleCountriesOrRegions"] = 5] = "MultipleCountriesOrRegions";
  /**
   * The entire world map is displayed, with areas for which no
   * series data is available appearing in a lighter color.
   */
  GeographicMappingArea[GeographicMappingArea["World"] = 6] = "World";
})(GeographicMappingArea || (GeographicMappingArea = {}));
/**
 * @hidden
 */
export let GeographicMappingArea_$type = markEnum('GeographicMappingArea', 'DataOnly,0|PostalCode,1|County,2|State,3|CountryOrRegion,4|MultipleCountriesOrRegions,5|World,6');
/**
 * Constants which define the projection for a geographic map chart.
 */
export var GeographicMapProjection;
(function (GeographicMapProjection) {
  /**
   * Albers equal-area conic projection.
   */
  GeographicMapProjection[GeographicMapProjection["Albers"] = 0] = "Albers";
  /**
   * Mercator cylindrical map projection.
   */
  GeographicMapProjection[GeographicMapProjection["Mercator"] = 1] = "Mercator";
  /**
   * Miller cylindrical map projection.
   */
  GeographicMapProjection[GeographicMapProjection["Miller"] = 2] = "Miller";
  /**
   * Robinson flat map projection.
   */
  GeographicMapProjection[GeographicMapProjection["Robinson"] = 3] = "Robinson";
})(GeographicMapProjection || (GeographicMapProjection = {}));
/**
 * @hidden
 */
export let GeographicMapProjection_$type = markEnum('GeographicMapProjection', 'Albers,0|Mercator,1|Miller,2|Robinson,3');
/**
 * @hidden
 */
export let Axis_BitValues_$type = markEnum('Axis_BitValues', 'AxisBetweenCategories,1|BaseUnitIsAuto,2|MajorUnitIsAuto,4|MaximumScaleIsAuto,8|MinimumScaleIsAuto,16|MinorUnitIsAuto,32|ReversePlotOrder,64|TickLabelSpacingIsAuto,128|Visible,256');
/**
 * Constants which determine  the manner in which cell values
 * are compared to the [[ConditionValue.value]]
 * property when conditional criteria is evaluated by an
 * [[IconSetConditionalFormat]].
 */
export var ThresholdComparison;
(function (ThresholdComparison) {
  /**
   * The cell value can be greater than <b>or equal to</b> the threshold <see cref="ConditionValue.Value">value</see>.
   */
  ThresholdComparison[ThresholdComparison["GreaterEqual"] = 0] = "GreaterEqual";
  /**
   * The cell value must be greater than <b>but not equal to</b> the threshold <see cref="ConditionValue.Value">value</see>.
   */
  ThresholdComparison[ThresholdComparison["Greater"] = 1] = "Greater";
})(ThresholdComparison || (ThresholdComparison = {}));
/**
 * @hidden
 */
export let ThresholdComparison_$type = markEnum('ThresholdComparison', 'GreaterEqual,0|Greater,1');
/**
 * Constants which specify the manner in which the color for negative-value
 * data bars is determined.
 */
export var DataBarNegativeBarColorType;
(function (DataBarNegativeBarColorType) {
  /**
   * Use the value of the [[NegativeBarFormat.barColor]] property.
   */
  DataBarNegativeBarColorType[DataBarNegativeBarColorType["Color"] = 0] = "Color";
  /**
   * Use the same color as that of the positive-value data bars.
   */
  DataBarNegativeBarColorType[DataBarNegativeBarColorType["SameAsPositive"] = 1] = "SameAsPositive";
})(DataBarNegativeBarColorType || (DataBarNegativeBarColorType = {}));
/**
 * @hidden
 */
export let DataBarNegativeBarColorType_$type = markEnum('DataBarNegativeBarColorType', 'Color,0|SameAsPositive,1');
/**
 * Constants which determine whether <see cref="DataBarConditionalFormat">data bars</see> are filled with a solid color or
 * with a gradient.
 */
export var DataBarDirection;
(function (DataBarDirection) {
  /**
   * The direction the data bar is displayed is based on context.
   */
  DataBarDirection[DataBarDirection["Context"] = -5002] = "Context";
  /**
   * The data bar is displayed from left-to-right.
   */
  DataBarDirection[DataBarDirection["LeftToRight"] = -5003] = "LeftToRight";
  /**
   * The data bar is displayed from right-to-left.
   */
  DataBarDirection[DataBarDirection["RightToLeft"] = -5004] = "RightToLeft";
})(DataBarDirection || (DataBarDirection = {}));
/**
 * @hidden
 */
export let DataBarDirection_$type = markEnum('DataBarDirection', 'Context,-5002|LeftToRight,-5003|RightToLeft,-5004');
/**
 * Constants which determine whether <see cref="DataBarConditionalFormat">data bars</see> are filled with a solid color or
 * with a gradient.
 */
export var DataBarFillType;
(function (DataBarFillType) {
  /**
   * Data bars are filled with a solid color.
   */
  DataBarFillType[DataBarFillType["SolidColor"] = 0] = "SolidColor";
  /**
   * Data bars are filled with a linear gradient.
   */
  DataBarFillType[DataBarFillType["Gradient"] = 1] = "Gradient";
})(DataBarFillType || (DataBarFillType = {}));
/**
 * @hidden
 */
export let DataBarFillType_$type = markEnum('DataBarFillType', 'SolidColor,0|Gradient,1');
/**
 * Constants which determine the axis position for a [[DataBarConditionalFormat]].
 */
export var DataBarAxisPosition;
(function (DataBarAxisPosition) {
  /**
   * Displays the axis at a variable position based on the ratio of the minimum
   * negative value to the maximum positive value in the associated range. Positive
   * values are displayed in a left-to-right direction; negative values are displayed
   * from right to left. When all values are positive, or all values are negative,
   * no axis is displayed.
   */
  DataBarAxisPosition[DataBarAxisPosition["Automatic"] = 0] = "Automatic";
  /**
   * Displays the axis at the midpoint of the cell, regardless of the set of values
   * in the associated range. Positive values are displayed in a left-to-right
   * direction; negative values are displayed from right to left.
   */
  DataBarAxisPosition[DataBarAxisPosition["Midpoint"] = 1] = "Midpoint";
  /**
   * No axis is displayed; positive and negative values are both displayed in
   * the left-to-right direction.
   */
  DataBarAxisPosition[DataBarAxisPosition["None"] = 2] = "None";
})(DataBarAxisPosition || (DataBarAxisPosition = {}));
/**
 * @hidden
 */
export let DataBarAxisPosition_$type = markEnum('DataBarAxisPosition', 'Automatic,0|Midpoint,1|None,2');
/**
 * Constants which identify whether a [[ColorScaleConditionalFormat]]
 * supports two or three thresholds. Used to differentiate between a 2-color and
 * 3-color scale.
 */
export var ColorScaleType;
(function (ColorScaleType) {
  /**
   * The color scale supports only the <see cref="ColorScaleConditionalFormat.MinimumThreshold">minimum</see>
   * and <see cref="ColorScaleConditionalFormat.MaximumThreshold">maximum</see> thresholds.
   */
  ColorScaleType[ColorScaleType["TwoColor"] = 0] = "TwoColor";
  /**
   * In addition to the the <see cref="ColorScaleConditionalFormat.MinimumThreshold">minimum</see>
   * and <see cref="ColorScaleConditionalFormat.MaximumThreshold">maximum</see> thresholds, the color
   * scale also supports a <see cref="ColorScaleConditionalFormat.MidpointThreshold">midpoint</see>
   * threshold.
   */
  ColorScaleType[ColorScaleType["ThreeColor"] = 1] = "ThreeColor";
})(ColorScaleType || (ColorScaleType = {}));
/**
 * @hidden
 */
export let ColorScaleType_$type = markEnum('ColorScaleType', 'TwoColor,0|ThreeColor,1');
/**
 * Constants which identify the threshold of a [[ColorScaleCriterion]].
 */
export var ColorScaleCriterionThreshold;
(function (ColorScaleCriterionThreshold) {
  /**
   * Identifies the minimum threshold.
   */
  ColorScaleCriterionThreshold[ColorScaleCriterionThreshold["Minimum"] = 0] = "Minimum";
  /**
   * Identifies the midpoint threshold.
   */
  ColorScaleCriterionThreshold[ColorScaleCriterionThreshold["Midpoint"] = 1] = "Midpoint";
  /**
   * Identifies the maximum threshold.
   */
  ColorScaleCriterionThreshold[ColorScaleCriterionThreshold["Maximum"] = 2] = "Maximum";
})(ColorScaleCriterionThreshold || (ColorScaleCriterionThreshold = {}));
/**
 * @hidden
 */
export let ColorScaleCriterionThreshold_$type = markEnum('ColorScaleCriterionThreshold', 'Minimum,0|Midpoint,1|Maximum,2');
/**
 * Constants which identify the type of value which defines the criteria for a
 * [[ColorScaleCriterion]] or [[IconCriterion]].
 */
export var FormatConditionValueType;
(function (FormatConditionValueType) {
  /**
   * The criteria is defined by a numeric value.
   */
  FormatConditionValueType[FormatConditionValueType["Number"] = 0] = "Number";
  /**
   * The criteria is defined by a percentage.
   */
  FormatConditionValueType[FormatConditionValueType["Percentage"] = 1] = "Percentage";
  /**
   * The criteria is defined by a percentile rating.
   */
  FormatConditionValueType[FormatConditionValueType["Percentile"] = 2] = "Percentile";
  /**
   * The criteria is defined by a formula.
   */
  FormatConditionValueType[FormatConditionValueType["Formula"] = 3] = "Formula";
  /**
   * The criteria is defined by the lowest value across the associated range.
   */
  FormatConditionValueType[FormatConditionValueType["LowestValue"] = 4] = "LowestValue";
  /**
   * The criteria is defined by the highest value across the associated range.
   */
  FormatConditionValueType[FormatConditionValueType["HighestValue"] = 5] = "HighestValue";
  /**
   * The shortest data bar is proportional to the lowest value across the associated range.
   * Applicable only to the [[IconCriterion]] class.
   */
  FormatConditionValueType[FormatConditionValueType["AutomaticMinimum"] = 6] = "AutomaticMinimum";
  /**
   * The longest data bar is proportional to the highest value across the associated range.
   * Applicable only to the [[IconCriterion]] class.
   */
  FormatConditionValueType[FormatConditionValueType["AutomaticMaximum"] = 7] = "AutomaticMaximum";
})(FormatConditionValueType || (FormatConditionValueType = {}));
/**
 * @hidden
 */
export let FormatConditionValueType_$type = markEnum('FormatConditionValueType', 'Number,0|Percentage,1|Percentile,2|Formula,3|LowestValue,4|HighestValue,5|AutomaticMinimum,6|AutomaticMaximum,7');
/**
 * Constants which define the manner in which a cell's date/time value is compared
 * when evaluating a [[DateTimeConditionalFormat]].
 */
export var FormatConditionTimePeriod;
(function (FormatConditionTimePeriod) {
  /**
   * The cell's date/time value is compared to the current date.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["Today"] = 0] = "Today";
  /**
   * The cell's date/time value is compared to the day after the current date.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["Tomorrow"] = 1] = "Tomorrow";
  /**
   * The cell's date/time value is compared to the day before the current date.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["Yesterday"] = 2] = "Yesterday";
  /**
   * The cell's date/time value is compared to the current week, as defined by the
   * [[CalendarWeekRule]].
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["ThisWeek"] = 3] = "ThisWeek";
  /**
   * The cell's date/time value is compared to the week after the current one, as defined by the
   * [[CalendarWeekRule]].
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["NextWeek"] = 4] = "NextWeek";
  /**
   * The cell's date/time value is compared to the week before the current one, as defined by the
   * [[CalendarWeekRule]].
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["LastWeek"] = 5] = "LastWeek";
  /**
   * The cell's date/time value meets the condition if it lies within the range
   * of the past seven days, without regard to the
   * [[CalendarWeekRule]].
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["LastSevenDays"] = 6] = "LastSevenDays";
  /**
   * The cell's date/time value is compared to the current month.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["ThisMonth"] = 7] = "ThisMonth";
  /**
   * The cell's date/time value is compared to the month after the current one.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["NextMonth"] = 8] = "NextMonth";
  /**
   * The cell's date/time value is compared to the month before the current one.
   */
  FormatConditionTimePeriod[FormatConditionTimePeriod["LastMonth"] = 9] = "LastMonth";
})(FormatConditionTimePeriod || (FormatConditionTimePeriod = {}));
/**
 * @hidden
 */
export let FormatConditionTimePeriod_$type = markEnum('FormatConditionTimePeriod', 'Today,0|Tomorrow,1|Yesterday,2|ThisWeek,3|NextWeek,4|LastWeek,5|LastSevenDays,6|ThisMonth,7|NextMonth,8|LastMonth,9');
/**
 * Constans which identify whether a [[RankConditionalFormat]] evaluates
 * to true for the top or bottom ranked values across the associated range.
 */
export var FormatConditionTopBottom;
(function (FormatConditionTopBottom) {
  /**
   * The cell value must fall within the bottom ranking of values for the associated range.
   */
  FormatConditionTopBottom[FormatConditionTopBottom["Bottom"] = 0] = "Bottom";
  /**
   * The cell value must fall within the top ranking of values for the associated range.
   */
  FormatConditionTopBottom[FormatConditionTopBottom["Top"] = 1] = "Top";
})(FormatConditionTopBottom || (FormatConditionTopBottom = {}));
/**
 * @hidden
 */
export let FormatConditionTopBottom_$type = markEnum('FormatConditionTopBottom', 'Bottom,0|Top,1');
/**
 * Constants which specify the manner in which cell values are compared
 * when evaluating a [[AverageConditionalFormat]].
 */
export var FormatConditionAboveBelow;
(function (FormatConditionAboveBelow) {
  /**
   * The cell value must be above the average for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["AboveAverage"] = 0] = "AboveAverage";
  /**
   * The cell value must be below the average for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["BelowAverage"] = 1] = "BelowAverage";
  /**
   * The cell value must be equal to or above the average for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["EqualAboveAverage"] = 2] = "EqualAboveAverage";
  /**
   * The cell value must be equal to or below the average for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["EqualBelowAverage"] = 3] = "EqualBelowAverage";
  /**
   * The cell value must be above the standard deviation for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["AboveStandardDeviation"] = 4] = "AboveStandardDeviation";
  /**
   * The cell value must be below the standard deviation for the associated range
   * in order to meet the associated condition.
   */
  FormatConditionAboveBelow[FormatConditionAboveBelow["BelowStandardDeviation"] = 5] = "BelowStandardDeviation";
})(FormatConditionAboveBelow || (FormatConditionAboveBelow = {}));
/**
 * @hidden
 */
export let FormatConditionAboveBelow_$type = markEnum('FormatConditionAboveBelow', 'AboveAverage,0|BelowAverage,1|EqualAboveAverage,2|EqualBelowAverage,3|AboveStandardDeviation,4|BelowStandardDeviation,5');
/**
 * Constants which specify the text comparison method applied when
 * evaluating a <see cref="ConditionalFormatBase">format condition</see>.
 */
export var FormatConditionTextOperator;
(function (FormatConditionTextOperator) {
  /**
   * The string being evaluated must begin with the value to which
   * it is being compared in order for the condition to be met.
   */
  FormatConditionTextOperator[FormatConditionTextOperator["BeginsWith"] = 0] = "BeginsWith";
  /**
   * The string being evaluated must end with the value to which
   * it is being compared in order for the condition to be met.
   */
  FormatConditionTextOperator[FormatConditionTextOperator["EndsWith"] = 1] = "EndsWith";
  /**
   * The string being evaluated must match some part of the value to which
   * it is being compared in order for the condition to be met.
   */
  FormatConditionTextOperator[FormatConditionTextOperator["Contains"] = 2] = "Contains";
  /**
   * Negates the [[FormatConditionTextOperator.contains]] value; the string being evaluated
   * must not match any part of the value to which it is being compared in
   * order for the condition to be met.
   */
  FormatConditionTextOperator[FormatConditionTextOperator["DoesNotContain"] = 3] = "DoesNotContain";
})(FormatConditionTextOperator || (FormatConditionTextOperator = {}));
/**
 * @hidden
 */
export let FormatConditionTextOperator_$type = markEnum('FormatConditionTextOperator', 'BeginsWith,0|EndsWith,1|Contains,2|DoesNotContain,3');
/**
 * Constants which specify the manner in which a cell value is
 * compared against one or more operands.
 */
export var FormatConditionOperator;
(function (FormatConditionOperator) {
  /**
   * The condition evaluates to true if the cell value is between
   * the values of the two operands.
   */
  FormatConditionOperator[FormatConditionOperator["Between"] = 0] = "Between";
  /**
   * The condition evaluates to true if the cell value is not between
   * the values of the two operands.
   */
  FormatConditionOperator[FormatConditionOperator["NotBetween"] = 1] = "NotBetween";
  /**
   * The condition evaluates to true if the cell value is equal to
   * the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["Equal"] = 2] = "Equal";
  /**
   * The condition evaluates to true if the cell value is not equal to
   * the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["NotEqual"] = 3] = "NotEqual";
  /**
   * The condition evaluates to true if the cell value is greater than
   * the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["Greater"] = 4] = "Greater";
  /**
   * The condition evaluates to true if the cell value is less than
   * the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["Less"] = 5] = "Less";
  /**
   * The condition evaluates to true if the cell value is greater than
   * or equal to the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["GreaterEqual"] = 6] = "GreaterEqual";
  /**
   * The condition evaluates to true if the cell value is less than
   * or equal to the value of the operand.
   */
  FormatConditionOperator[FormatConditionOperator["LessEqual"] = 7] = "LessEqual";
})(FormatConditionOperator || (FormatConditionOperator = {}));
/**
 * @hidden
 */
export let FormatConditionOperator_$type = markEnum('FormatConditionOperator', 'Between,0|NotBetween,1|Equal,2|NotEqual,3|Greater,4|Less,5|GreaterEqual,6|LessEqual,7');
/**
 * Constants which determine the criteria for a format <see cref="ConditionBase">condition</see>.
 */
export var FormatConditionType;
(function (FormatConditionType) {
  /**
   * The format is based on the cell's value, which is evaluated against
   * one or more conditions to determine whether the value meets a particular
   * criteria.
   */
  FormatConditionType[FormatConditionType["CellValue"] = 0] = "CellValue";
  /**
   * The format is determined by evaluating a formula.
   */
  FormatConditionType[FormatConditionType["Expression"] = 1] = "Expression";
  /**
   * Represents a conditional formatting rule which applies gradations to
   * cell colors to indicate relative differences in the values of cells
   * which belong to the associated range.
   */
  FormatConditionType[FormatConditionType["ColorScale"] = 2] = "ColorScale";
  /**
   * Represents a conditional formatting rule which renders a color bar
   * inside the cell to indicate relative differences in the values of cells
   * which belong to the associated range.
   */
  FormatConditionType[FormatConditionType["DataBar"] = 3] = "DataBar";
  /**
   * Cells with the top/bottom <i>n</i> values are formatted, where <i>n</i>
   * represents a numeric, percentage, or percentile ranking. For example,
   * this type can be used to to enable a 'top ten' condition.
   */
  FormatConditionType[FormatConditionType["Rank"] = 4] = "Rank";
  /**
   * Represents a conditional formatting rule which displays an icon
   * inside the cell which indicates the cell's value as relative to
   * the highest and lowest value in the associated range.
   */
  FormatConditionType[FormatConditionType["IconSets"] = 5] = "IconSets";
  /**
   * Cells with values which are unique across the associated range are formatted.
   */
  FormatConditionType[FormatConditionType["UniqueValues"] = 6] = "UniqueValues";
  /**
   * Cells with values which are duplicated (non-unique) across the associated range are formatted.
   */
  FormatConditionType[FormatConditionType["DuplicateValues"] = 7] = "DuplicateValues";
  /**
   * The format is determined by whether the cell's value matches a literal string value.
   */
  FormatConditionType[FormatConditionType["TextString"] = 8] = "TextString";
  /**
   * Cells with no value are formatted. Note that foreground-related
   * properties such as font colors are not applicable.
   */
  FormatConditionType[FormatConditionType["Blanks"] = 9] = "Blanks";
  /**
   * The format is determined by whether a cell's date value falls within
   * a given period of time.
   */
  FormatConditionType[FormatConditionType["TimePeriod"] = 10] = "TimePeriod";
  /**
   * Cells with values which are greater than or less than the average value
   * for the associated region are formatted.
   */
  FormatConditionType[FormatConditionType["Average"] = 11] = "Average";
  /**
   * Cells with a non-empty value are formatted.
   */
  FormatConditionType[FormatConditionType["NoBlanks"] = 12] = "NoBlanks";
  /**
   * The format is applied to cells which contain an error.
   */
  FormatConditionType[FormatConditionType["Errors"] = 13] = "Errors";
  /**
   * The format is applied to cells which do not contain an error.
   */
  FormatConditionType[FormatConditionType["NoErrors"] = 14] = "NoErrors";
})(FormatConditionType || (FormatConditionType = {}));
/**
 * @hidden
 */
export let FormatConditionType_$type = markEnum('FormatConditionType', 'CellValue,0|Expression,1|ColorScale,2|DataBar,3|Rank,4|IconSets,5|UniqueValues,6|DuplicateValues,7|TextString,8|Blanks,9|TimePeriod,10|Average,11|NoBlanks,12|Errors,13|NoErrors,14');
/**
 * @hidden
 */
export let FormatConditionNotificationType_$type = markEnum('FormatConditionNotificationType', 'NoneRquired,0|WhenCellInRegionChanges,1|WhenAnyCellChanges,2');
/**
 * @hidden
 */
export let WorksheetFilterSettings_WorksheetFilterFlags_$type = markEnum('WorksheetFilterSettings_WorksheetFilterFlags', 'RefilterRequired,1');
/**
 * Represents the various filter types available for the [[TopOrBottomFilter]].
 * @see [[TopOrBottomFilter.type]]
 */
export var TopOrBottomFilterType;
(function (TopOrBottomFilterType) {
  /**
   * Filter in the top N values in the sorted list of values.
   */
  TopOrBottomFilterType[TopOrBottomFilterType["TopValues"] = 0] = "TopValues";
  /**
   * Filter in the bottom N values in the sorted list of values.
   */
  TopOrBottomFilterType[TopOrBottomFilterType["BottomValues"] = 1] = "BottomValues";
  /**
   * Filter in the top N percent of values the sorted list of values.
   */
  TopOrBottomFilterType[TopOrBottomFilterType["TopPercentage"] = 2] = "TopPercentage";
  /**
   * Filter in the bottom N percent of values the sorted list of values.
   */
  TopOrBottomFilterType[TopOrBottomFilterType["BottomPercentage"] = 3] = "BottomPercentage";
})(TopOrBottomFilterType || (TopOrBottomFilterType = {}));
/**
 * @hidden
 */
export let TopOrBottomFilterType_$type = markEnum('TopOrBottomFilterType', 'TopValues,0|BottomValues,1|TopPercentage,2|BottomPercentage,3');
/**
 * Represents the various relative date offsets which can be filtered by the [[RelativeDateRangeFilter]].
 * @see [[RelativeDateRangeFilter.offset]]
 */
export var RelativeDateRangeOffset;
(function (RelativeDateRangeOffset) {
  /**
   * Filter in values in the previous duration relative to the filter's creation date.
   */
  RelativeDateRangeOffset[RelativeDateRangeOffset["Previous"] = 0] = "Previous";
  /**
   * Filter in values in the current duration relative to the filter's creation date.
   */
  RelativeDateRangeOffset[RelativeDateRangeOffset["Current"] = 1] = "Current";
  /**
   * Filter in values in the next duration relative to the filter's creation date.
   */
  RelativeDateRangeOffset[RelativeDateRangeOffset["Next"] = 2] = "Next";
})(RelativeDateRangeOffset || (RelativeDateRangeOffset = {}));
/**
 * @hidden
 */
export let RelativeDateRangeOffset_$type = markEnum('RelativeDateRangeOffset', 'Previous,0|Current,1|Next,2');
/**
 * Represents the various durations which can be filtered by the [[RelativeDateRangeFilter]].
 * @see [[RelativeDateRangeFilter.duration]]
 */
export var RelativeDateRangeDuration;
(function (RelativeDateRangeDuration) {
  /**
   * The duration of accepted values is one day.
   */
  RelativeDateRangeDuration[RelativeDateRangeDuration["Day"] = 0] = "Day";
  /**
   * The duration of accepted values is one week.
   */
  RelativeDateRangeDuration[RelativeDateRangeDuration["Week"] = 1] = "Week";
  /**
   * The duration of accepted values is one month.
   */
  RelativeDateRangeDuration[RelativeDateRangeDuration["Month"] = 2] = "Month";
  /**
   * The duration of accepted values is one quarter.
   */
  RelativeDateRangeDuration[RelativeDateRangeDuration["Quarter"] = 3] = "Quarter";
  /**
   * The duration of accepted values is one year.
   */
  RelativeDateRangeDuration[RelativeDateRangeDuration["Year"] = 4] = "Year";
})(RelativeDateRangeDuration || (RelativeDateRangeDuration = {}));
/**
 * @hidden
 */
export let RelativeDateRangeDuration_$type = markEnum('RelativeDateRangeDuration', 'Day,0|Week,1|Month,2|Quarter,3|Year,4');
/**
 * Represents the various types, or precisions, of a [[FixedDateGroup]].
 * @see [[FixedDateGroup.type]]
 */
export var FixedDateGroupType;
(function (FixedDateGroupType) {
  /**
   * The group represents the day in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Day"] = 0] = "Day";
  /**
   * The group represents the hour in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Hour"] = 1] = "Hour";
  /**
   * The group represents the minute in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Minute"] = 2] = "Minute";
  /**
   * The group represents the month in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Month"] = 3] = "Month";
  /**
   * The group represents the second in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Second"] = 4] = "Second";
  /**
   * The group represents the year in which the [[FixedDateGroup.value]] exists.
   */
  FixedDateGroupType[FixedDateGroupType["Year"] = 5] = "Year";
})(FixedDateGroupType || (FixedDateGroupType = {}));
/**
 * @hidden
 */
export let FixedDateGroupType_$type = markEnum('FixedDateGroupType', 'Day,0|Hour,1|Minute,2|Month,3|Second,4|Year,5');
/**
 * Represents the various comparisons which can be used in the [[CustomFilterCondition]].
 * @see [[CustomFilterCondition.comparisonOperator]]
 */
export var ExcelComparisonOperator;
(function (ExcelComparisonOperator) {
  /**
   * Filter in values which are equal to the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["Equals"] = 0] = "Equals";
  /**
   * Filter in values which are not equal to the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["NotEqual"] = 1] = "NotEqual";
  /**
   * Filter in values which are greater than the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["GreaterThan"] = 2] = "GreaterThan";
  /**
   * Filter in values which are greater than or equal to the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["GreaterThanOrEqual"] = 3] = "GreaterThanOrEqual";
  /**
   * Filter in values which are less than the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["LessThan"] = 4] = "LessThan";
  /**
   * Filter in values which are less than or equal to the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["LessThanOrEqual"] = 5] = "LessThanOrEqual";
  /**
   * Filter in string values which begin with the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["BeginsWith"] = 6] = "BeginsWith";
  /**
   * Filter in string values which do not begin with the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["DoesNotBeginWith"] = 7] = "DoesNotBeginWith";
  /**
   * Filter in string values which ends with the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["EndsWith"] = 8] = "EndsWith";
  /**
   * Filter in string values which do not end with the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["DoesNotEndWith"] = 9] = "DoesNotEndWith";
  /**
   * Filter in string values which contain the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["Contains"] = 10] = "Contains";
  /**
   * Filter in string values which do not contain the comparison value.
   */
  ExcelComparisonOperator[ExcelComparisonOperator["DoesNotContain"] = 11] = "DoesNotContain";
})(ExcelComparisonOperator || (ExcelComparisonOperator = {}));
/**
 * @hidden
 */
export let ExcelComparisonOperator_$type = markEnum('ExcelComparisonOperator', 'Equals,0|NotEqual,1|GreaterThan,2|GreaterThanOrEqual,3|LessThan,4|LessThanOrEqual,5|BeginsWith,6|DoesNotBeginWith,7|EndsWith,8|DoesNotEndWith,9|Contains,10|DoesNotContain,11');
/**
 * Represents the various date range types which can be filtered by the [[DatePeriodFilter]].
 * @see [[DatePeriodFilter.type]]
 */
export var DatePeriodFilterType;
(function (DatePeriodFilterType) {
  /**
   * Filter in dates in a specific month of any year.
   */
  DatePeriodFilterType[DatePeriodFilterType["Month"] = 0] = "Month";
  /**
   * Filter in dates in a specific quarter of any year.
   */
  DatePeriodFilterType[DatePeriodFilterType["Quarter"] = 1] = "Quarter";
})(DatePeriodFilterType || (DatePeriodFilterType = {}));
/**
 * @hidden
 */
export let DatePeriodFilterType_$type = markEnum('DatePeriodFilterType', 'Month,0|Quarter,1');
/**
 * Represents the various logical operators used to combine the conditions of the [[CustomFilter]].
 * @see [[CustomFilter.conditionalOperator]]
 */
export var ConditionalOperator;
(function (ConditionalOperator) {
  /**
   * Filter in values where only [[CustomFilter.condition1]] and [[CustomFilter.condition2]] pass.
   */
  ConditionalOperator[ConditionalOperator["And"] = 0] = "And";
  /**
   * Filter in values where either [[CustomFilter.condition1]] or [[CustomFilter.condition2]] (or both) pass.
   */
  ConditionalOperator[ConditionalOperator["Or"] = 1] = "Or";
})(ConditionalOperator || (ConditionalOperator = {}));
/**
 * @hidden
 */
export let ConditionalOperator_$type = markEnum('ConditionalOperator', 'And,0|Or,1');
/**
 * Represents the various calendar types available for the [[FixedValuesFilter]]
 * @see [[FixedValuesFilter.calendarType]]
 */
export var CalendarType;
(function (CalendarType) {
  /**
   * The Gregorian calendar should be used.
   */
  CalendarType[CalendarType["Gregorian"] = 0] = "Gregorian";
  /**
   * The Arabic version of the Gregorian calendar should be used.
   */
  CalendarType[CalendarType["GregorianArabic"] = 1] = "GregorianArabic";
  /**
   * The Middle East French version of the Gregorian calendar should be used.
   */
  CalendarType[CalendarType["GregorianMeFrench"] = 2] = "GregorianMeFrench";
  /**
   * The US English version of the Gregorian calendar should be used.
   */
  CalendarType[CalendarType["GregorianUs"] = 3] = "GregorianUs";
  /**
   * The transliterated English version of the Gregorian calendar should be used.
   */
  CalendarType[CalendarType["GregorianXlitEnglish"] = 4] = "GregorianXlitEnglish";
  /**
   * The transliterated French version of the Gregorian calendar should be used.
   */
  CalendarType[CalendarType["GregorianXlitFrench"] = 5] = "GregorianXlitFrench";
  /**
   * The Hebrew lunar calendar, as described by the Gauss formula for Passover and The Complete Restatement of Oral Law,
   * should be used.
   */
  CalendarType[CalendarType["Hebrew"] = 6] = "Hebrew";
  /**
   * The Hijri lunar calendar, as described by the Kingdom of Saudi Arabia, Ministry of Islamic Affairs, Endowments, Dawah
   * and Guidance, should be used.
   */
  CalendarType[CalendarType["Hijri"] = 7] = "Hijri";
  /**
   * The Japanese Emperor Era calendar, as described by Japanese Industrial Standard JIS X 0301, should be used.
   */
  CalendarType[CalendarType["Japan"] = 8] = "Japan";
  /**
   * The Korean Tangun Era calendar, as described by Korean Law Enactment No. 4, should be used.
   */
  CalendarType[CalendarType["Korea"] = 9] = "Korea";
  /**
   * Specifies that no calendar should be used.
   */
  CalendarType[CalendarType["None"] = 10] = "None";
  /**
   * The Saka Era calendar, as described by the Calendar Reform Committee of India, as part of the Indian Ephemeris and Nautical
   * Almanac, should be used.
   */
  CalendarType[CalendarType["Saka"] = 11] = "Saka";
  /**
   * The Taiwanese calendar, as defined by the Chinese National Standard CNS 7648, should be used.
   */
  CalendarType[CalendarType["Taiwan"] = 12] = "Taiwan";
  /**
   * The Thai calendar, as defined by the Royal Decree of H.M. King Vajiravudh (Rama VI) in Royal Gazette B. E. 2456 (1913 A.D.)
   * and by the decree of Prime Minister Phibunsongkhram (1941 A.D.) to start the year on the Gregorian January 1 and to map year
   * zero to Gregorian year 543 B.C., should be used.
   */
  CalendarType[CalendarType["Thai"] = 13] = "Thai";
})(CalendarType || (CalendarType = {}));
/**
 * @hidden
 */
export let CalendarType_$type = markEnum('CalendarType', 'Gregorian,0|GregorianArabic,1|GregorianMeFrench,2|GregorianUs,3|GregorianXlitEnglish,4|GregorianXlitFrench,5|Hebrew,6|Hijri,7|Japan,8|Korea,9|None,10|Saka,11|Taiwan,12|Thai,13');
/**
 * Represents the various types of the [[AverageFilter]].
 * @see [[AverageFilter.type]]
 */
export var AverageFilterType;
(function (AverageFilterType) {
  /**
   * Filter in values above the average of the entire range of data being filtered.
   */
  AverageFilterType[AverageFilterType["AboveAverage"] = 0] = "AboveAverage";
  /**
   * Filter in values below the average of the entire range of data being filtered.
   */
  AverageFilterType[AverageFilterType["BelowAverage"] = 1] = "BelowAverage";
})(AverageFilterType || (AverageFilterType = {}));
/**
 * @hidden
 */
export let AverageFilterType_$type = markEnum('AverageFilterType', 'AboveAverage,0|BelowAverage,1');
/**
 * @hidden
 */
export let RefBase_InternalFlags_$type = markEnum('RefBase_InternalFlags', 'NodeStateMask,3|HasNewFormulaToBeCalculated,4|IsDirty,8|IsInCalcNetwork,16|IsInCircularity,32|IsInNamedReferenceOnlyCircularity,64|IgnoreNextCalculatedValue,128');
/**
 * @hidden
 */
export let NonNumericElementBehavior_$type = markEnum('NonNumericElementBehavior', 'CausesError,0|TreatAsZero,1|Ignore,2');
/**
 * @hidden
 */
export let TokenClass_$type = markEnum('TokenClass', 'Reference,32|Value,64|Array,96|Control,255');
/**
 * @hidden
 */
export let Token_$type = markEnum('Token', 'Exp,1|Tbl,2|Add,3|Sub,4|Mul,5|Div,6|Power,7|Concat,8|LT,9|LE,10|EQ,11|GE,12|GT,13|NE,14|Isect,15|Union,16|Range,17|Uplus,18|Uminus,19|Percent,20|Paren,21|MissArg,22|Str,23|Extended,24|Attr,25|Err,28|Bool,29|Int,30|Number,31|ArrayR,32|ArrayV,64|ArrayA,96|FuncR,33|FuncV,65|FuncA,97|FuncVarR,34|FuncVarV,66|FuncVarA,98|NameR,35|NameV,67|NameA,99|RefR,36|RefV,68|RefA,100|AreaR,37|AreaV,69|AreaA,101|MemAreaR,38|MemAreaV,70|MemAreaA,102|MemErrR,39|MemErrV,71|MemErrA,103|MemNoMemR,40|MemNoMemV,72|MemNoMemA,104|MemFuncR,41|MemFuncV,73|MemFuncA,105|RefErrR,42|RefErrV,74|RefErrA,106|AreaErrR,43|AreaErrV,75|AreaErrA,107|RefNR,44|RefNV,76|RefNA,108|AreaNR,45|AreaNV,77|AreaNA,109|NameXR,57|NameXV,89|NameXA,121|Ref3dR,58|Ref3dV,90|Ref3dA,122|Area3DR,59|Area3DV,91|Area3DA,123|RefErr3dR,60|RefErr3dV,92|RefErr3dA,124|AreaErr3dR,61|AreaErr3dV,93|AreaErr3dA,125|Excel2007Token,4096|StructuredTableReferenceR,4128|StructuredTableReferenceV,4160|StructuredTableReferenceA,4192');
/**
 * @hidden
 */
export let AttrTokenBase_AttrType_$type = markEnum('AttrTokenBase_AttrType', 'Volatile,1|If,2|Choose,4|Skip,8|Sum,16|Assign,32|Space,64|SpaceVolatile,65');
/**
 * @hidden
 */
export let WhitespaceType_$type = markEnum('WhitespaceType', 'SpacesBeforeNextToken,0|CarriageReturnsBeforeNextToken,1|SpacesBeforeOpeningParens,2|CarriageReturnsBeforeOpeningParens,3|SpacesBeforeClosingParens,4|CarriageReturnsBeforeClosingParens,5|SpacesFollowEqualitySign,6');
/**
 * @hidden
 */
export let WorksheetSortSettings_WorksheetSortFlags_$type = markEnum('WorksheetSortSettings_WorksheetSortFlags', 'SortRequired,1');
/**
 * @hidden
 */
export let SortMethod_$type = markEnum('SortMethod', 'Default,0|PinYin,1|Stroke,2');
/**
 * Represents the various sort directions which can be used with a [[SortCondition]].
 * @see [[SortCondition.sortDirection]]
 */
export var SortDirection;
(function (SortDirection) {
  /**
   * Sort values in an ascending manner.
   */
  SortDirection[SortDirection["Ascending"] = 0] = "Ascending";
  /**
   * Sort values in an descending manner.
   */
  SortDirection[SortDirection["Descending"] = 1] = "Descending";
})(SortDirection || (SortDirection = {}));
/**
 * @hidden
 */
export let SortDirection_$type = markEnum('SortDirection', 'Ascending,0|Descending,1');
/**
 * @hidden
 */
export let SparklineGroup_BitValues_$type = markEnum('SparklineGroup_BitValues', 'DateAxis,1|Markers,2|HighPoint,4|LowPoint,8|FirstPoint,16|LastPoint,32|NegativePoints,64|DisplayXAxis,128|DisplayHidden,256|RightToLeft,512|Isinitialized,1024|IsRemovedFromColection,2048');
/**
 * @hidden
 */
export let WorksheetRow_InternalFlags_$type = markEnum('WorksheetRow_InternalFlags', 'Hidden,1|HasThickTop,2|HasThickBottom,4|HasThickTopIsDirty,8|HasThickBottomIsDirty,16|HasCustomHeight,32|WasRemoved,64|ClonableFlags,32');
/**
 * @hidden
 */
export let WorksheetColumn_InternalFlags_$type = markEnum('WorksheetColumn_InternalFlags', 'WasRemoved,1');
/**
 * @hidden
 */
export let CellFormatValueChangedOptions_$type = markEnum('CellFormatValueChangedOptions', 'DefaultBehavior,0|PreventAdjacentBorderSyncronization,1|PreventCellToMergedRegionSyncronization,2|PreventMergedRegionToCellSyncronization,4|PreventOwnerToCellSynchronization,8|PreventFontToFormattedStringSynchronization,16|AlwaysSendChangeNotifications,32|SkipDirtyResolvedRowHeight,64|PreventAllSyncronization,-97');
/**
 * @hidden
 */
export let WorksheetCellFormatType_$type = markEnum('WorksheetCellFormatType', 'CellFormat,0|StyleFormat,1|DifferentialFormat,2');
/**
 * @hidden
 */
export let PreventTextFormattingTypes_$type = markEnum('PreventTextFormattingTypes', 'None,0|String:string1,1');
/**
 * @hidden
 */
export let WorksheetCellBlock_ValueCoercionType_$type = markEnum('WorksheetCellBlock_ValueCoercionType', 'None,0|TableHeaderCell,1|TableTotalCell,2');
/**
 * @hidden
 */
export let WorksheetCellBlock_DataTypeEncoded_$type = markEnum('WorksheetCellBlock_DataTypeEncoded', 'Byte:byte1,0|SByte,1|Int16,2|UInt16,3|Int32,4|UInt32,5|Single,6|Boolean:boolean1,7|DBNull,8|ErrorValue,9|Formula,10|Decimal,11|StringBuilder,12|Char:char1,14|DateTimeNotConvertible,15|Enum:en,16|Guid,17');
/**
 * @hidden
 */
export let WorksheetCellBlock_DataType_$type = markEnum('WorksheetCellBlock_DataType', 'Null,0|Int64,1|UInt64,2|Double:double1,3|DateTime,4|String:string1,5|FormattedString,6|Encoded,7');
/**
 * @hidden
 */
export let WorkbookStyleCollection_RemovalType_$type = markEnum('WorkbookStyleCollection_RemovalType', 'HideBuiltInStyles,0|RemoveBuiltInStyles,1|ResetBuiltInStyles,2');
/**
 * @hidden
 */
export let WorkbookFontProxy_PropertyIds_$type = markEnum('WorkbookFontProxy_PropertyIds', 'Bold,0|ColorInfo,1|Height,2|Italic,3|Name:Name1,4|Strikeout,5|SuperscriptSubscriptStyle,6|UnderlineStyle,7');
/**
 * @hidden
 */
export let FontFamilyInternal_$type = markEnum('FontFamilyInternal', 'DontCare,0|Roman,1|Swiss,2|Modern,3|Script,4|Decorative,5');
/**
 * @hidden
 */
export let SystemColorsInternal_SystemColorValue_$type = markEnum('SystemColorsInternal_SystemColorValue', 'ActiveBorder,0|ActiveCaption,1|ActiveCaptionText,2|AppWorkspace,3|ButtonFace,4|ButtonHighlight,5|ButtonShadow,6|Control,7|ControlDark,8|ControlDarkDark,9|ControlLight,10|ControlLightLight,11|ControlText,12|Desktop,13|GradientActiveCaption,14|GradientInactiveCaption,15|GrayText,16|Highlight,17|HighlightText,18|HotTrack,19|InactiveBorder,20|InactiveCaption,21|InactiveCaptionText,22|Info,23|InfoText,24|Menu,25|MenuBar,26|MenuHighlight,27|MenuText,28|ScrollBar,29|Window,30|WindowFrame,31|WindowText,32|MaxValue,33');
/**
 * @hidden
 */
export let WorksheetTableColumn_InternalFlags_$type = markEnum('WorksheetTableColumn_InternalFlags', 'HasBeenInitialized,1|HoldHasBeenInitialized,2|OverwriteExistingValues,4|SuspendCellValueSynchronizations,8');
/**
 * @hidden
 */
export let WorksheetTable_TableFlags_$type = markEnum('WorksheetTable_TableFlags', 'DisplayBandedColumns,1|DisplayBandedRows,2|DisplayFirstColumnFormatting,4|DisplayLastColumnFormatting,8|HasTotalsRowEverBeenVisible,16|IsFilterUIVisible,32|IsHeaderRowVisible,64|IsInsertRowVisible,128|IsResizing,256|IsTotalsRowVisible,512|PreventAssigningUniqueColumnNames,1024|Published,2048|RefilterRequired,4096|SuspendAreaFormatSynchronization,8192|WereCellsShiftedToShowInsertRow,16384|IsChangingHeaderOrTotalRowVisibility,32768|IsProcessingUndo,65536');
/**
 * @hidden
 */
export let WorksheetProtectionType_$type = markEnum('WorksheetProtectionType', 'Objects,1|Scenarios,2|FormatCells,4|FormatColumns,8|FormatRows,16|InsertColumns,32|InsertRows,64|InsertHyperlinks,128|DeleteColumns,256|DeleteRows,512|Sort,1024|AutoFilter,2048|PivotTables,4096');
/**
 * Enumeration used to indicate which cells may be selected when the Worksheet is protected.
 * @see [[WorksheetProtection.selectionMode]]
 */
export var WorksheetProtectedSelectionMode;
(function (WorksheetProtectedSelectionMode) {
  /**
   * All cells including locked cells may be selected.
   */
  WorksheetProtectedSelectionMode[WorksheetProtectedSelectionMode["AllCells"] = 0] = "AllCells";
  /**
   * Only cells that are unlocked may be selected via the keyboard or mouse. Note a cell that is locked may be selected if a range selection is created between 2 unlocked cells.
   */
  WorksheetProtectedSelectionMode[WorksheetProtectedSelectionMode["UnlockedCells"] = 1] = "UnlockedCells";
  /**
   * The selection cannot be change.
   */
  WorksheetProtectedSelectionMode[WorksheetProtectedSelectionMode["NoCells"] = 2] = "NoCells";
})(WorksheetProtectedSelectionMode || (WorksheetProtectedSelectionMode = {}));
/**
 * @hidden
 */
export let WorksheetProtectedSelectionMode_$type = markEnum('WorksheetProtectedSelectionMode', 'AllCells,0|UnlockedCells,1|NoCells,2');
/**
 * @hidden
 */
export let LoadOnDemandTree_FindState_$type = markEnum('LoadOnDemandTree_FindState', 'ValueNotFound,0|ValueFound,1|ValueInserted,2');
/**
 * @hidden
 */
export let ApplyFormulaFlags_$type = markEnum('ApplyFormulaFlags', 'None,0|PreventNumberFormat,1');
/**
 * @hidden
 */
export let Formula_InternalFlags_$type = markEnum('Formula_InternalFlags', 'RecalculateAlways,1|AreTokenReferencesResolved,2|HasHyperlink,4|IsConnected,8|IsDirtyOnLoad,16|MayUseDynamicReferences,32|HasMissingFunctions,64');
/**
 * Represents the various visibilities of a worksheet.
 * <p class="body">
 * The worksheet visibility indicates how the worksheet will be displayed in the tab bar at
 * the bottom of the workbook window in Microsoft Excel.
 * </p>
 */
export var WorksheetVisibility;
(function (WorksheetVisibility) {
  /**
   * The worksheet tab is present in the tab bar.
   */
  WorksheetVisibility[WorksheetVisibility["Visible"] = 0] = "Visible";
  /**
   * The worksheet tab is not present in the tab bar. The worksheet can be made visible
   * from the Unhide dialog in Microsoft Excel.
   */
  WorksheetVisibility[WorksheetVisibility["Hidden"] = 1] = "Hidden";
  /**
   * The worksheet tab is not present in the tab bar. The worksheet can only be made visible
   * again through a Visual Basic procedure in Microsoft Excel. The worksheet can not be made
   * visible through the user interface.
   */
  WorksheetVisibility[WorksheetVisibility["StrongHidden"] = 2] = "StrongHidden";
})(WorksheetVisibility || (WorksheetVisibility = {}));
/**
 * @hidden
 */
export let WorksheetVisibility_$type = markEnum('WorksheetVisibility', 'Visible,0|Hidden,1|StrongHidden,2');
/**
 * Represents the various views for a worksheet.
 */
export var WorksheetView;
(function (WorksheetView) {
  /**
   * The worksheet is displayed in the normal view.
   */
  WorksheetView[WorksheetView["Normal"] = 0] = "Normal";
  /**
   * The worksheet is displayed as it will appear when printed. This view displays where
   * printed pages will begin and end as well as any headers or footers for the workbook.
   * This value is only supported in Excel 2007 and defaults to Normal in earlier version.
   */
  WorksheetView[WorksheetView["PageLayout"] = 1] = "PageLayout";
  /**
   * This view shows a preview of where pages will break when the worksheet is printed.
   */
  WorksheetView[WorksheetView["PageBreakPreview"] = 2] = "PageBreakPreview";
})(WorksheetView || (WorksheetView = {}));
/**
 * @hidden
 */
export let WorksheetView_$type = markEnum('WorksheetView', 'Normal,0|PageLayout,1|PageBreakPreview,2');
/**
 * Represents the various units in which a column width can be represented.
 * @see [[Worksheet.getDefaultColumnWidth]]
 * @see [[Worksheet.setDefaultColumnWidth]]
 * @see [[WorksheetColumn.getWidth]]
 * @see [[WorksheetColumn.setWidth]]
 */
export var WorksheetColumnWidthUnit;
(function (WorksheetColumnWidthUnit) {
  /**
   * The column width is represented in units of the '0' digit character width, including column padding. The digit is
   * measured with the default font for the workbook. The padding is a few pixels on either side of the column plus an
   * additional pixel for the gridline.
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["Character"] = 0] = "Character";
  /**
   * The column width is represented in 256ths of the '0' digit character width, including column padding, which means this
   * value will be 256 times the width expressed in Character units. The digit is measured with the default font for the
   * workbook. The padding is a few pixels on either side of the column plus an additional pixel for the gridline. These
   * units are the units in which the [[WorksheetColumn.width]] and [[Worksheet.defaultColumnWidth]]
   * properties are expressed.
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["Character256th"] = 1] = "Character256th";
  /**
   * The column width is represented in units of the '0' digit character width, excluding padding. The digit is measured with
   * the default font for the workbook. These units are the units in which Microsoft Excel displays column widths to the user
   * and accepts new column widths from the user in the 'Column Width' dialog.
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["CharacterPaddingExcluded"] = 2] = "CharacterPaddingExcluded";
  /**
   * The column width is represented in pixels.
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["Pixel"] = 3] = "Pixel";
  /**
   * The column width is represented in points.
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["Point"] = 4] = "Point";
  /**
   * The column width is represented in twips (20ths of a point).
   */
  WorksheetColumnWidthUnit[WorksheetColumnWidthUnit["Twip"] = 5] = "Twip";
})(WorksheetColumnWidthUnit || (WorksheetColumnWidthUnit = {}));
/**
 * @hidden
 */
export let WorksheetColumnWidthUnit_$type = markEnum('WorksheetColumnWidthUnit', 'Character,0|Character256th,1|CharacterPaddingExcluded,2|Pixel,3|Point,4|Twip,5');
/**
 * Represents the various areas which can have a format applied at the table style level.
 * <p class="note">
 * <b>Note:</b> Only certain properties can be set on the table style are formats. The are as follows:
 * <list type="bullet">
 * <item>[[IWorksheetCellFormat.bottomBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.bottomBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.fill]]</item>
 * <item>[[IWorksheetCellFormat.leftBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.leftBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.rightBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.rightBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.topBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.topBorderStyle]]</item>
 * <item><see cref="IWorkbookFont.Bold">Font.Bold</see></item>
 * <item><see cref="IWorkbookFont.ColorInfo">Font.ColorInfo</see></item>
 * <item><see cref="IWorkbookFont.Italic">Font.Italic</see></item>
 * <item><see cref="IWorkbookFont.Strikeout">Font.Strikeout</see></item>
 * <item><see cref="IWorkbookFont.UnderlineStyle">Font.UnderlineStyle</see></item>
 * </list>
 * Setting any other format or font properties on the table style areas will cause an exception.
 * </p>
 * @see [[WorksheetTableStyle.areaFormats]]
 */
export var WorksheetTableStyleArea;
(function (WorksheetTableStyleArea) {
  /**
   * The format is applied to the entire table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["WholeTable"] = 0] = "WholeTable";
  /**
   * The format is applied to the odd numbered column stripes in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["ColumnStripe"] = 7] = "ColumnStripe";
  /**
   * The format is applied to the even numbered column stripes in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["AlternateColumnStripe"] = 8] = "AlternateColumnStripe";
  /**
   * The format is applied to the odd numbered row stripes in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["RowStripe"] = 5] = "RowStripe";
  /**
   * The format is applied to the even numbered row stripes in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["AlternateRowStripe"] = 6] = "AlternateRowStripe";
  /**
   * The format is applied to the last column in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["LastColumn"] = 4] = "LastColumn";
  /**
   * The format is applied to the first column in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["FirstColumn"] = 3] = "FirstColumn";
  /**
   * The format is applied to the header row in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["HeaderRow"] = 1] = "HeaderRow";
  /**
   * The format is applied to the totals row in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["TotalRow"] = 2] = "TotalRow";
  /**
   * The format is applied to the first header cell in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["FirstHeaderCell"] = 9] = "FirstHeaderCell";
  /**
   * The format is applied to the last header cell in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["LastHeaderCell"] = 10] = "LastHeaderCell";
  /**
   * The format is applied to the first total cell in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["FirstTotalCell"] = 11] = "FirstTotalCell";
  /**
   * The format is applied to the last total cell in the table.
   */
  WorksheetTableStyleArea[WorksheetTableStyleArea["LastTotalCell"] = 12] = "LastTotalCell";
})(WorksheetTableStyleArea || (WorksheetTableStyleArea = {}));
/**
 * @hidden
 */
export let WorksheetTableStyleArea_$type = markEnum('WorksheetTableStyleArea', 'WholeTable,0|ColumnStripe,7|AlternateColumnStripe,8|RowStripe,5|AlternateRowStripe,6|LastColumn,4|FirstColumn,3|HeaderRow,1|TotalRow,2|FirstHeaderCell,9|LastHeaderCell,10|FirstTotalCell,11|LastTotalCell,12');
/**
 * Represents the various areas which can have a format applied at the table column level.
 * @see [[WorksheetTableColumn.areaFormats]]
 */
export var WorksheetTableColumnArea;
(function (WorksheetTableColumnArea) {
  /**
   * The format is applied to the data area of the table column.
   */
  WorksheetTableColumnArea[WorksheetTableColumnArea["DataArea"] = 0] = "DataArea";
  /**
   * The format is applied to the header cell of the table column.
   */
  WorksheetTableColumnArea[WorksheetTableColumnArea["HeaderCell"] = 1] = "HeaderCell";
  /**
   * The format is applied to the total cell of the table column.
   */
  WorksheetTableColumnArea[WorksheetTableColumnArea["TotalCell"] = 2] = "TotalCell";
})(WorksheetTableColumnArea || (WorksheetTableColumnArea = {}));
/**
 * @hidden
 */
export let WorksheetTableColumnArea_$type = markEnum('WorksheetTableColumnArea', 'DataArea,0|HeaderCell,1|TotalCell,2');
/**
 * Represents the various areas which can have a format applied at the table level.
 * @see [[WorksheetTable.areaFormats]]
 */
export var WorksheetTableArea;
(function (WorksheetTableArea) {
  /**
   * The format is applied to the entire table. Only the outer border properties can be set on this area format.
   * Setting any other will cause an exception.
   */
  WorksheetTableArea[WorksheetTableArea["WholeTable"] = 0] = "WholeTable";
  /**
   * The format is applied to the data area of the table.
   */
  WorksheetTableArea[WorksheetTableArea["DataArea"] = 1] = "DataArea";
  /**
   * The format is applied to the header row of the table. All but the top border properties can be set on this
   * area format. Setting the top border properties will cause an exception.
   */
  WorksheetTableArea[WorksheetTableArea["HeaderRow"] = 2] = "HeaderRow";
  /**
   * The format is applied to the totals row of the table. All but the bottom border properties can be set on this
   * area format. Setting the bottom border properties will cause an exception.
   */
  WorksheetTableArea[WorksheetTableArea["TotalsRow"] = 3] = "TotalsRow";
})(WorksheetTableArea || (WorksheetTableArea = {}));
/**
 * @hidden
 */
export let WorksheetTableArea_$type = markEnum('WorksheetTableArea', 'WholeTable,0|DataArea,1|HeaderRow,2|TotalsRow,3');
/**
 * Determines whether worksheet rows of columns are sorted within the region
 * @see [[WorksheetSortSettings]]
 * @see [[Worksheet.sortSettings]]
 */
export var WorksheetSortType;
(function (WorksheetSortType) {
  /**
   * Sort rows
   */
  WorksheetSortType[WorksheetSortType["Rows"] = 0] = "Rows";
  /**
   * Sort columns
   */
  WorksheetSortType[WorksheetSortType["Columns"] = 1] = "Columns";
})(WorksheetSortType || (WorksheetSortType = {}));
/**
 * @hidden
 */
export let WorksheetSortType_$type = markEnum('WorksheetSortType', 'Rows,0|Columns,1');
/**
 * @hidden
 */
export let WorksheetPermissions_$type = markEnum('WorksheetPermissions', 'None,0|SelectLockedCells,1|SelectUnlockedCells,2|FormatCells,4|FormatColumns,8|FormatRows,16|InsertColumns,32|InsertRows,64|InsertHyperlinks,128|DeleteColumns,256|DeleteRows,512|Sort,1024|Filter,2048|PivotTable,4096|EditObjects,8192|EditScenarios,16384|All,-1');
/**
 * Represents the various theme colors in a workbook.
 * @see [[WorkbookColorInfo.themeColorType]]
 */
export var WorkbookThemeColorType;
(function (WorkbookThemeColorType) {
  /**
   * Represents the Text/Background - Light 1 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Light1"] = 0] = "Light1";
  /**
   * Represents the Text/Background - Dark 1 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Dark1"] = 1] = "Dark1";
  /**
   * Represents the Text/Background - Light 2 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Light2"] = 2] = "Light2";
  /**
   * Represents the Text/Background - Dark 2 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Dark2"] = 3] = "Dark2";
  /**
   * Represents the Accent 1 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent1"] = 4] = "Accent1";
  /**
   * Represents the Accent 2 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent2"] = 5] = "Accent2";
  /**
   * Represents the Accent 3 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent3"] = 6] = "Accent3";
  /**
   * Represents the Accent 4 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent4"] = 7] = "Accent4";
  /**
   * Represents the Accent 5 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent5"] = 8] = "Accent5";
  /**
   * Represents the Accent 6 theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Accent6"] = 9] = "Accent6";
  /**
   * Represents the Hyperlink theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["Hyperlink"] = 10] = "Hyperlink";
  /**
   * Represents the Followed Hyperlink theme color.
   */
  WorkbookThemeColorType[WorkbookThemeColorType["FollowedHyperlink"] = 11] = "FollowedHyperlink";
})(WorkbookThemeColorType || (WorkbookThemeColorType = {}));
/**
 * @hidden
 */
export let WorkbookThemeColorType_$type = markEnum('WorkbookThemeColorType', 'Light1,0|Dark1,1|Light2,2|Dark2,3|Accent1,4|Accent2,5|Accent3,6|Accent4,7|Accent5,8|Accent6,9|Hyperlink,10|FollowedHyperlink,11');
/**
 * Represents the various file formats in which a workbook can be saved.
 */
export var WorkbookFormat;
(function (WorkbookFormat) {
  /**
   * The Excel 97-2003 BIFF8 file format.
   */
  WorkbookFormat[WorkbookFormat["Excel97To2003"] = 0] = "Excel97To2003";
  /**
   * The Excel 97-2003 Template BIFF8 file format.
   */
  WorkbookFormat[WorkbookFormat["Excel97To2003Template"] = 1] = "Excel97To2003Template";
  /**
   * The Excel 2007 XML file format.
   */
  WorkbookFormat[WorkbookFormat["Excel2007"] = 2] = "Excel2007";
  /**
   * The Excel 2007 Macro-Enabled XML file format.
   */
  WorkbookFormat[WorkbookFormat["Excel2007MacroEnabled"] = 3] = "Excel2007MacroEnabled";
  /**
   * The Excel 2007 Macro-Enabled Template XML file format.
   */
  WorkbookFormat[WorkbookFormat["Excel2007MacroEnabledTemplate"] = 4] = "Excel2007MacroEnabledTemplate";
  /**
   * The Excel 2007 Template XML file format.
   */
  WorkbookFormat[WorkbookFormat["Excel2007Template"] = 5] = "Excel2007Template";
  /**
   * The Strict Open XML file format (ISO/IEC 29500 Strict).
   */
  WorkbookFormat[WorkbookFormat["StrictOpenXml"] = 6] = "StrictOpenXml";
})(WorkbookFormat || (WorkbookFormat = {}));
/**
 * @hidden
 */
export let WorkbookFormat_$type = markEnum('WorkbookFormat', 'Excel97To2003,0|Excel97To2003Template,1|Excel2007,2|Excel2007MacroEnabled,3|Excel2007MacroEnabledTemplate,4|Excel2007Template,5|StrictOpenXml,6');
/**
 * Represents the various encryption modes that can be used to encrypt documents saved in the 2007 file formats and later.
 */
export var WorkbookEncryptionMode;
(function (WorkbookEncryptionMode) {
  /**
   * Standard encryption used in Excel 2007 and later
   */
  WorkbookEncryptionMode[WorkbookEncryptionMode["Standard"] = 0] = "Standard";
  /**
   * Agile encryption used in Excel 2010 and later
   */
  WorkbookEncryptionMode[WorkbookEncryptionMode["Agile"] = 1] = "Agile";
})(WorkbookEncryptionMode || (WorkbookEncryptionMode = {}));
/**
 * @hidden
 */
export let WorkbookEncryptionMode_$type = markEnum('WorkbookEncryptionMode', 'Standard,0|Agile,1');
/**
 * Represents the various vertical text alignment types.
 */
export var VerticalTextAlignment;
(function (VerticalTextAlignment) {
  /**
   * Align the text to the bottom of the available area.
   */
  VerticalTextAlignment[VerticalTextAlignment["Bottom"] = 0] = "Bottom";
  /**
   * Align the center to the bottom of the available area.
   */
  VerticalTextAlignment[VerticalTextAlignment["Center"] = 1] = "Center";
  /**
   * Align the text to the top of the available area.
   */
  VerticalTextAlignment[VerticalTextAlignment["Top"] = 2] = "Top";
})(VerticalTextAlignment || (VerticalTextAlignment = {}));
/**
 * @hidden
 */
export let VerticalTextAlignment_$type = markEnum('VerticalTextAlignment', 'Bottom,0|Center,1|Top,2');
/**
 * Enumeration for vertical alignment styles. Default value is used in property override situations.
 */
export var VerticalCellAlignment;
(function (VerticalCellAlignment) {
  /**
   * Use the current default.
   */
  VerticalCellAlignment[VerticalCellAlignment["Default"] = -1] = "Default";
  /**
   * Top alignment.
   */
  VerticalCellAlignment[VerticalCellAlignment["Top"] = 0] = "Top";
  /**
   * Center alignment.
   */
  VerticalCellAlignment[VerticalCellAlignment["Center"] = 1] = "Center";
  /**
   * Bottom alignment.
   */
  VerticalCellAlignment[VerticalCellAlignment["Bottom"] = 2] = "Bottom";
  /**
   * Justify alignment.
   */
  VerticalCellAlignment[VerticalCellAlignment["Justify"] = 3] = "Justify";
  /**
   * Distributed alignment.
   */
  VerticalCellAlignment[VerticalCellAlignment["Distributed"] = 4] = "Distributed";
})(VerticalCellAlignment || (VerticalCellAlignment = {}));
/**
 * @hidden
 */
export let VerticalCellAlignment_$type = markEnum('VerticalCellAlignment', 'Default,-1|Top,0|Center,1|Bottom,2|Justify,3|Distributed,4');
/**
 * Flagged enumeration which indicates which groups of formatting properties are used in a format.
 * @see [[IWorksheetCellFormat.formatOptions]]
 */
export var WorksheetCellFormatOptions;
(function (WorksheetCellFormatOptions) {
  /**
   * No format properties are used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["None"] = 0] = "None";
  /**
   * The [[IWorksheetCellFormat.formatString]] property is used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyNumberFormatting"] = 1] = "ApplyNumberFormatting";
  /**
   * The [[IWorksheetCellFormat.alignment]], [[IWorksheetCellFormat.indent]], [[IWorksheetCellFormat.rotation]],
   * [[IWorksheetCellFormat.shrinkToFit]], [[IWorksheetCellFormat.verticalAlignment]], and
   * [[IWorksheetCellFormat.wrapText]] properties are used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyAlignmentFormatting"] = 2] = "ApplyAlignmentFormatting";
  /**
   * The [[IWorksheetCellFormat.font]] property is used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyFontFormatting"] = 4] = "ApplyFontFormatting";
  /**
   * The [[IWorksheetCellFormat.bottomBorderColorInfo]], [[IWorksheetCellFormat.bottomBorderStyle]],
   * [[IWorksheetCellFormat.diagonalBorderColorInfo]], [[IWorksheetCellFormat.diagonalBorders]],
   * [[IWorksheetCellFormat.diagonalBorderStyle]], [[IWorksheetCellFormat.leftBorderColorInfo]],
   * [[IWorksheetCellFormat.leftBorderStyle]], [[IWorksheetCellFormat.rightBorderColorInfo]],
   * [[IWorksheetCellFormat.rightBorderStyle]], [[IWorksheetCellFormat.topBorderColorInfo]], and
   * [[IWorksheetCellFormat.topBorderStyle]] properties are used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyBorderFormatting"] = 8] = "ApplyBorderFormatting";
  /**
   * The [[IWorksheetCellFormat.fill]] property is used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyFillFormatting"] = 16] = "ApplyFillFormatting";
  /**
   * The [[IWorksheetCellFormat.locked]] property is used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["ApplyProtectionFormatting"] = 32] = "ApplyProtectionFormatting";
  /**
   * All properties are used on the format.
   */
  WorksheetCellFormatOptions[WorksheetCellFormatOptions["All"] = 63] = "All";
})(WorksheetCellFormatOptions || (WorksheetCellFormatOptions = {}));
/**
 * @hidden
 */
export let WorksheetCellFormatOptions_$type = markEnum('WorksheetCellFormatOptions', 'None,0|ApplyNumberFormatting,1|ApplyAlignmentFormatting,2|ApplyFontFormatting,4|ApplyBorderFormatting,8|ApplyFillFormatting,16|ApplyProtectionFormatting,32|All,63');
/**
 * Represents the various way to combine a cell's value and format string to get its text.
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 * @see [[WorksheetRow.getCellText]]
 */
export var TextFormatMode;
(function (TextFormatMode) {
  /**
   * Format the cell text as it is displayed in the Microsoft Excel UI. This takes into account the cell width when
   * formatting the text.
   */
  TextFormatMode[TextFormatMode["AsDisplayed"] = 0] = "AsDisplayed";
  /**
   * Format the cell text as if it had unlimited space in the cell. However, this will not include padding characters
   * from the format string.
   */
  TextFormatMode[TextFormatMode["IgnoreCellWidth"] = 1] = "IgnoreCellWidth";
})(TextFormatMode || (TextFormatMode = {}));
/**
 * @hidden
 */
export let TextFormatMode_$type = markEnum('TextFormatMode', 'AsDisplayed,0|IgnoreCellWidth,1');
/**
 * @hidden
 */
export let StyleCategory_$type = markEnum('StyleCategory', 'Custom,0|GoodBadNeutral,1|DataModel,2|TitleAndHeading,3|Themed,4|NumberFormat,5');
/**
 * @hidden
 */
export let StructuredTableReferenceKeywordType_$type = markEnum('StructuredTableReferenceKeywordType', 'All,0|Data,1|Headers,2|Totals,3|ThisRow,4');
/**
 * Determines the type if sparkline
 * @see [[SparklineGroup.type]]
 */
export var SparklineType;
(function (SparklineType) {
  /**
   * A line sparkline
   */
  SparklineType[SparklineType["Line"] = 0] = "Line";
  /**
   * A series of vertical columns
   */
  SparklineType[SparklineType["Column"] = 1] = "Column";
  /**
   * Deprecated - same as WinLoss
   */
  SparklineType[SparklineType["Stacked"] = 2] = "Stacked";
  /**
   * Positive and negative values stacked
   */
  SparklineType[SparklineType["WinLoss"] = 2] = "WinLoss";
})(SparklineType || (SparklineType = {}));
/**
 * @hidden
 */
export let SparklineType_$type = markEnum('SparklineType', 'Line,0|Column,1|Stacked,2|WinLoss,2');
/**
 * Determines how blanks are displayed in a sparkline
 * @see [[SparklineGroup.displayBlanksAs]]
 */
export var SparklineDisplayBlanksAs;
(function (SparklineDisplayBlanksAs) {
  /**
   * Empty cells are plotted as interpolated.
   */
  SparklineDisplayBlanksAs[SparklineDisplayBlanksAs["Span"] = 0] = "Span";
  /**
   * Empty cells are not plotted.
   */
  SparklineDisplayBlanksAs[SparklineDisplayBlanksAs["Gap"] = 1] = "Gap";
  /**
   * Empty cells are plotted as zero.
   */
  SparklineDisplayBlanksAs[SparklineDisplayBlanksAs["Zero"] = 2] = "Zero";
})(SparklineDisplayBlanksAs || (SparklineDisplayBlanksAs = {}));
/**
 * @hidden
 */
export let SparklineDisplayBlanksAs_$type = markEnum('SparklineDisplayBlanksAs', 'Span,0|Gap,1|Zero,2');
/**
 * Determines how the min or max axis is calculated for a
 * @see [[Sparkline]]
 * @see [[SparklineGroup.verticalAxisMaxType]]
 * @see [[SparklineGroup.verticalAxisMinType]]
 */
export var SparklineAxisMinMax;
(function (SparklineAxisMinMax) {
  /**
   * Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
   */
  SparklineAxisMinMax[SparklineAxisMinMax["Individual"] = 0] = "Individual";
  /**
   * Specifies that the vertical axis minimum or maximum is shared across all sparklines in this sparkline group and is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
   */
  SparklineAxisMinMax[SparklineAxisMinMax["Group"] = 1] = "Group";
  /**
   * Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is specified by the [[SparklineGroup.verticalAxisMin]] or the [[SparklineGroup.verticalAxisMax]] attribute of the [[SparklineGroup]].
   */
  SparklineAxisMinMax[SparklineAxisMinMax["Custom"] = 2] = "Custom";
})(SparklineAxisMinMax || (SparklineAxisMinMax = {}));
/**
 * @hidden
 */
export let SparklineAxisMinMax_$type = markEnum('SparklineAxisMinMax', 'Individual,0|Group,1|Custom,2');
/**
 * Indicates the type of workbook [[Sheet]]
 */
export var SheetType;
(function (SheetType) {
  /**
   * A sheet that contains rows and columns of data.
   */
  SheetType[SheetType["Worksheet"] = 0] = "Worksheet";
  /**
   * A sheet that displays a single [[WorksheetChart]]
   */
  SheetType[SheetType["Chartsheet"] = 1] = "Chartsheet";
})(SheetType || (SheetType = {}));
/**
 * @hidden
 */
export let SheetType_$type = markEnum('SheetType', 'Worksheet,0|Chartsheet,1');
/**
 * @hidden
 */
export let ShapeType_$type = markEnum('ShapeType', 'NotPrimitive,0|Rectangle,1|RoundRectangle,2|Ellipse,3|Diamond,4|IsocelesTriangle,5|RightTriangle,6|Parallelogram,7|Trapezoid,8|Hexagon,9|Octagon,10|Plus,11|Star,12|Arrow,13|ThickArrow,14|HomePlate,15|Cube,16|Balloon,17|Seal,18|Arc,19|Line,20|Plaque,21|Can,22|Donut,23|TextSimple,24|TextOctagon,25|TextHexagon,26|TextCurve,27|TextWave,28|TextRing,29|TextOnCurve,30|TextOnRing,31|StraightConnector1,32|BentConnector2,33|BentConnector3,34|BentConnector4,35|BentConnector5,36|CurvedConnector2,37|CurvedConnector3,38|CurvedConnector4,39|CurvedConnector5,40|Callout1,41|Callout2,42|Callout3,43|AccentCallout1,44|AccentCallout2,45|AccentCallout3,46|BorderCallout1,47|BorderCallout2,48|BorderCallout3,49|AccentBorderCallout1,50|AccentBorderCallout2,51|AccentBorderCallout3,52|Ribbon,53|Ribbon2,54|Chevron,55|Pentagon,56|NoSmoking,57|Seal8,58|Seal16,59|Seal32,60|WedgeRectCallout,61|WedgeRRectCallout,62|WedgeEllipseCallout,63|Wave,64|FoldedCorner,65|LeftArrow,66|DownArrow,67|UpArrow,68|LeftRightArrow,69|UpDownArrow,70|IrregularSeal1,71|IrregularSeal2,72|LightningBolt,73|Heart,74|PictureFrame,75|QuadArrow,76|LeftArrowCallout,77|RightArrowCallout,78|UpArrowCallout,79|DownArrowCallout,80|LeftRightArrowCallout,81|UpDownArrowCallout,82|QuadArrowCallout,83|Bevel,84|LeftBracket,85|RightBracket,86|LeftBrace,87|RightBrace,88|LeftUpArrow,89|BentUpArrow,90|BentArrow,91|Seal24,92|StripedRightArrow,93|NotchedRightArrow,94|BlockArc,95|SmileyFace,96|VerticalScroll,97|HorizontalScroll,98|CircularArrow,99|NotchedCircularArrow,100|UturnArrow,101|CurvedRightArrow,102|CurvedLeftArrow,103|CurvedUpArrow,104|CurvedDownArrow,105|CloudCallout,106|EllipseRibbon,107|EllipseRibbon2,108|FlowChartProcess,109|FlowChartDecision,110|FlowChartInputOutput,111|FlowChartPredefinedProcess,112|FlowChartInternalStorage,113|FlowChartDocument,114|FlowChartMultidocument,115|FlowChartTerminator,116|FlowChartPreparation,117|FlowChartManualInput,118|FlowChartManualOperation,119|FlowChartConnector,120|FlowChartPunchedCard,121|FlowChartPunchedTape,122|FlowChartSummingJunction,123|FlowChartOr,124|FlowChartCollate,125|FlowChartSort,126|FlowChartExtract,127|FlowChartMerge,128|FlowChartOfflineStorage,129|FlowChartOnlineStorage,130|FlowChartMagneticTape,131|FlowChartMagneticDisk,132|FlowChartMagneticDrum,133|FlowChartDisplay,134|FlowChartDelay,135|TextPlainText,136|TextStop,137|TextTriangle,138|TextTriangleInverted,139|TextChevron,140|TextChevronInverted,141|TextRingInside,142|TextRingOutside,143|TextArchUpCurve,144|TextArchDownCurve,145|TextCircleCurve,146|TextButtonCurve,147|TextArchUpPour,148|TextArchDownPour,149|TextCirclePour,150|TextButtonPour,151|TextCurveUp,152|TextCurveDown,153|TextCascadeUp,154|TextCascadeDown,155|TextWave1,156|TextWave2,157|TextWave3,158|TextWave4,159|TextInflate,160|TextDeflate,161|TextInflateBottom,162|TextDeflateBottom,163|TextInflateTop,164|TextDeflateTop,165|TextDeflateInflate,166|TextDeflateInflateDeflate,167|TextFadeRight,168|TextFadeLeft,169|TextFadeUp,170|TextFadeDown,171|TextSlantUp,172|TextSlantDown,173|TextCanUp,174|TextCanDown,175|FlowChartAlternateProcess,176|FlowChartOffpageConnector,177|Callout90,178|AccentCallout90,179|BorderCallout90,180|AccentBorderCallout90,181|LeftRightUpArrow,182|Sun,183|Moon,184|BracketPair,185|BracePair,186|Seal4,187|DoubleWave,188|ActionButtonBlank,189|ActionButtonHome,190|ActionButtonHelp,191|ActionButtonInformation,192|ActionButtonForwardNext,193|ActionButtonBackPrevious,194|ActionButtonEnd,195|ActionButtonBeginning,196|ActionButtonReturn,197|ActionButtonDocument,198|ActionButtonSound,199|ActionButtonMovie,200|HostControl,201|TextBox,202');
/**
 * Represents the ways shapes will be repositioned when rows and columns are resized.
 */
export var ShapePositioningMode;
(function (ShapePositioningMode) {
  /**
   * Shapes will move and size with the cells. If columns before (or rows above) the shape are expanded,
   * the shape will shift left. If columns within a shape are expanded, the shape will be widened.
   */
  ShapePositioningMode[ShapePositioningMode["MoveAndSizeWithCells"] = 0] = "MoveAndSizeWithCells";
  /**
   * Shapes will move but not size with the cells. If columns before (or rows above) the shape are
   * expanded, the shape will shift left. If columns within a shape are expanded, the shape will not
   * be widened.
   */
  ShapePositioningMode[ShapePositioningMode["MoveWithCells"] = 2] = "MoveWithCells";
  /**
   * Shapes will not move or size with the cells. The shape will remain in its absolute pixel position of
   * the worksheet, regardless the rows and columns resized before or inside it.
   */
  ShapePositioningMode[ShapePositioningMode["DontMoveOrSizeWithCells"] = 3] = "DontMoveOrSizeWithCells";
})(ShapePositioningMode || (ShapePositioningMode = {}));
/**
 * @hidden
 */
export let ShapePositioningMode_$type = markEnum('ShapePositioningMode', 'MoveAndSizeWithCells,0|MoveWithCells,2|DontMoveOrSizeWithCells,3');
/**
 * Represents the various scroll bar configurations available for the workbook.
 */
export var ScrollBars;
(function (ScrollBars) {
  /**
   * No scroll bars are shown in Microsoft Excel.
   */
  ScrollBars[ScrollBars["None"] = 0] = "None";
  /**
   * Only the horizontal scroll bar is shown in Microsoft Excel.
   */
  ScrollBars[ScrollBars["Horizontal"] = 1] = "Horizontal";
  /**
   * Only the vertical scroll bar is shown in Microsoft Excel.
   */
  ScrollBars[ScrollBars["Vertical"] = 2] = "Vertical";
  /**
   * Both scroll bars are shown in Microsoft Excel.
   */
  ScrollBars[ScrollBars["Both"] = 3] = "Both";
})(ScrollBars || (ScrollBars = {}));
/**
 * @hidden
 */
export let ScrollBars_$type = markEnum('ScrollBars', 'None,0|Horizontal,1|Vertical,2|Both,3');
/**
 * Represents the ways to scale a worksheet when it is printed.
 */
export var ScalingType;
(function (ScalingType) {
  /**
   * The scaling factor is used to scale the worksheet when printing.
   */
  ScalingType[ScalingType["UseScalingFactor"] = 0] = "UseScalingFactor";
  /**
   * The page maximums are used to determine how many pages the worksheet can be printed on.
   * Less pages can be used if there is not enough printable content in the worksheet.
   */
  ScalingType[ScalingType["FitToPages"] = 1] = "FitToPages";
})(ScalingType || (ScalingType = {}));
/**
 * @hidden
 */
export let ScalingType_$type = markEnum('ScalingType', 'UseScalingFactor,0|FitToPages,1');
/**
 * @hidden
 */
export let ReferenceShiftType_$type = markEnum('ReferenceShiftType', 'MaintainReference,0|MaintainRelativeReferenceOffset,1');
/**
 * Represents the various ways to print cell notes.
 */
export var PrintNotes;
(function (PrintNotes) {
  /**
   * Cell notes are not printed.
   */
  PrintNotes[PrintNotes["DontPrint"] = 0] = "DontPrint";
  /**
   * Cell notes are printed as they are shown on the worksheet. With this option, cell
   * notes will only appear in the printed worksheet if they are displayed on the worksheet
   * in Microsoft Excel. If the notes just show indicators in Excel, the indicators and notes
   * will not be printed.
   */
  PrintNotes[PrintNotes["PrintAsDisplayed"] = 1] = "PrintAsDisplayed";
  /**
   * Cell notes are printed on the last page, after the entire worksheet has printed.
   */
  PrintNotes[PrintNotes["PrintAtEndOfSheet"] = 2] = "PrintAtEndOfSheet";
})(PrintNotes || (PrintNotes = {}));
/**
 * @hidden
 */
export let PrintNotes_$type = markEnum('PrintNotes', 'DontPrint,0|PrintAsDisplayed,1|PrintAtEndOfSheet,2');
/**
 * Represents the various ways to print cell errors in a worksheet.
 */
export var PrintErrors;
(function (PrintErrors) {
  /**
   * Errors are printed just as they are displayed on the worksheet.
   */
  PrintErrors[PrintErrors["PrintAsDisplayed"] = 0] = "PrintAsDisplayed";
  /**
   * Errors are not prints, as though the cells containing them have no value.
   */
  PrintErrors[PrintErrors["DontPrint"] = 1] = "DontPrint";
  /**
   * Errors are printed as two dashes "--".
   */
  PrintErrors[PrintErrors["PrintAsDashes"] = 2] = "PrintAsDashes";
  /**
   * Errors are prints as "#N/A".
   */
  PrintErrors[PrintErrors["PrintAsNA"] = 3] = "PrintAsNA";
})(PrintErrors || (PrintErrors = {}));
/**
 * @hidden
 */
export let PrintErrors_$type = markEnum('PrintErrors', 'PrintAsDisplayed,0|DontPrint,1|PrintAsDashes,2|PrintAsNA,3');
/**
 * Represents the shape types that are predefined in Microsoft Excel.
 */
export var PredefinedShapeType;
(function (PredefinedShapeType) {
  /**
   * Represents the [[DiamondShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Diamond"] = 4] = "Diamond";
  /**
   * Represents the [[EllipseShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Ellipse"] = 3] = "Ellipse";
  /**
   * Represents the [[HeartShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Heart"] = 74] = "Heart";
  /**
   * Represents the [[IrregularSeal1Shape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["IrregularSeal1"] = 71] = "IrregularSeal1";
  /**
   * Represents the [[IrregularSeal2Shape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["IrregularSeal2"] = 72] = "IrregularSeal2";
  /**
   * Represents the [[LightningBoltShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["LightningBolt"] = 73] = "LightningBolt";
  /**
   * Represents the [[LineShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Line"] = 20] = "Line";
  /**
   * Represents the [[PentagonShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Pentagon"] = 56] = "Pentagon";
  /**
   * Represents the [[RectangleShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["Rectangle"] = 1] = "Rectangle";
  /**
   * Represents the [[RightTriangleShape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["RightTriangle"] = 6] = "RightTriangle";
  /**
   * Represents the [[StraightConnector1Shape]] shape.
   */
  PredefinedShapeType[PredefinedShapeType["StraightConnector1"] = 32] = "StraightConnector1";
})(PredefinedShapeType || (PredefinedShapeType = {}));
/**
 * @hidden
 */
export let PredefinedShapeType_$type = markEnum('PredefinedShapeType', 'Diamond,4|Ellipse,3|Heart,74|IrregularSeal1,71|IrregularSeal2,72|LightningBolt,73|Line,20|Pentagon,56|Rectangle,1|RightTriangle,6|StraightConnector1,32');
/**
 * Represents the types of precision which can be used when obtaining the value of a cell.
 */
export var Precision;
(function (Precision) {
  /**
   * The display value of the cell is used. If the cell's actual value is 10.005, but it is using currency formatting,
   * it will display as $10.01.  When this cell is used in calculations, its displayed value of 10.01 will be used.
   */
  Precision[Precision["UseDisplayValues"] = 0] = "UseDisplayValues";
  /**
   * The actual value of the cell is used. If the cell's actual value is 10.005, but it is using currency formatting,
   * it will display as $10.01.  When this cell is used in calculations, its stored value of 10.005 will be used,
   * even though the display shows a slightly different value.
   */
  Precision[Precision["UseRealCellValues"] = 1] = "UseRealCellValues";
})(Precision || (Precision = {}));
/**
 * @hidden
 */
export let Precision_$type = markEnum('Precision', 'UseDisplayValues,0|UseRealCellValues,1');
/**
 * Represents the options available for getting or setting the bounds of a shape, cell, or region.
 */
export var PositioningOptions;
(function (PositioningOptions) {
  /**
   * No special options should be used. Get and set actual bounds on the worksheet in its current state.
   */
  PositioningOptions[PositioningOptions["None"] = 0] = "None";
  /**
   * Ignore the [[RowColumnBase.hidden]] value on all rows and columns.
   * Get and set bounds as if all rows and columns were currently visible.
   */
  PositioningOptions[PositioningOptions["TreatAllRowsAndColumnsAsVisible"] = 1] = "TreatAllRowsAndColumnsAsVisible";
})(PositioningOptions || (PositioningOptions = {}));
/**
 * @hidden
 */
export let PositioningOptions_$type = markEnum('PositioningOptions', 'None,0|TreatAllRowsAndColumnsAsVisible,1');
/**
 * Represents the various paper sizes available for printing.
 */
export var PaperSize;
(function (PaperSize) {
  /**
   * Undefined
   */
  PaperSize[PaperSize["Undefined"] = 0] = "Undefined";
  /**
   * Letter 8 1/2\" x 11\"
   */
  PaperSize[PaperSize["Letter"] = 1] = "Letter";
  /**
   * Letter small 8 1/2\" x 11\"
   */
  PaperSize[PaperSize["LetterSmall"] = 2] = "LetterSmall";
  /**
   * Tabloid 11\" x 17\"
   */
  PaperSize[PaperSize["Tabloid"] = 3] = "Tabloid";
  /**
   * Ledger 17\" x 11\"
   */
  PaperSize[PaperSize["Ledger"] = 4] = "Ledger";
  /**
   * Legal 8 1/2\" x 14\"
   */
  PaperSize[PaperSize["Legal"] = 5] = "Legal";
  /**
   * Statement 5 1/2\" x 8 1/2\"
   */
  PaperSize[PaperSize["Statement"] = 6] = "Statement";
  /**
   * Executive 7 1/4\" x 10 1/2\"
   */
  PaperSize[PaperSize["Executive"] = 7] = "Executive";
  /**
   * A3 297mm x 420mm
   */
  PaperSize[PaperSize["A3"] = 8] = "A3";
  /**
   * A4 210mm x 297mm
   */
  PaperSize[PaperSize["A4"] = 9] = "A4";
  /**
   * A4 small 210mm x 297mm
   */
  PaperSize[PaperSize["A4Small"] = 10] = "A4Small";
  /**
   * A5 148mm x 210mm
   */
  PaperSize[PaperSize["A5"] = 11] = "A5";
  /**
   * B4 (JIS) 257mm x 364mm
   */
  PaperSize[PaperSize["B4JIS"] = 12] = "B4JIS";
  /**
   * B5 (JIS) 182mm x 257mm
   */
  PaperSize[PaperSize["B5JIS"] = 13] = "B5JIS";
  /**
   * Folio 8 1/2\" x 13\"
   */
  PaperSize[PaperSize["Folio"] = 14] = "Folio";
  /**
   * Quarto 215mm x 275mm
   */
  PaperSize[PaperSize["Quarto"] = 15] = "Quarto";
  /**
   * 10x14 10\" x 14\"
   */
  PaperSize[PaperSize["Size10x14"] = 16] = "Size10x14";
  /**
   * 11x17 11\" x 17\"
   */
  PaperSize[PaperSize["Size11x17"] = 17] = "Size11x17";
  /**
   * Note 8 1/2\" x 11\"
   */
  PaperSize[PaperSize["Note"] = 18] = "Note";
  /**
   * Envelope #9 3 7/8\" x 8 7/8\"
   */
  PaperSize[PaperSize["Envelope9"] = 19] = "Envelope9";
  /**
   * Envelope #10 4 1/8\" x 9 1/2\"
   */
  PaperSize[PaperSize["Envelope10"] = 20] = "Envelope10";
  /**
   * Envelope #11 4 1/2\" x 10 3/8\"
   */
  PaperSize[PaperSize["Envelope11"] = 21] = "Envelope11";
  /**
   * Envelope #12 4 3/4\" x 11\"
   */
  PaperSize[PaperSize["Envelope12"] = 22] = "Envelope12";
  /**
   * Envelope #14 5\" x 11 1/2\"
   */
  PaperSize[PaperSize["Envelope14"] = 23] = "Envelope14";
  /**
   * C 17\" x 22\"
   */
  PaperSize[PaperSize["C"] = 24] = "C";
  /**
   * D 22\" x 34\"
   */
  PaperSize[PaperSize["D"] = 25] = "D";
  /**
   * E 34\" x 44\"
   */
  PaperSize[PaperSize["E"] = 26] = "E";
  /**
   * Envelope DL 110mm x 220mm
   */
  PaperSize[PaperSize["EnvelopeDL"] = 27] = "EnvelopeDL";
  /**
   * Envelope C5 162mm x 229mm
   */
  PaperSize[PaperSize["EnvelopeC5"] = 28] = "EnvelopeC5";
  /**
   * Envelope C3 324mm x 458mm
   */
  PaperSize[PaperSize["EnvelopeC3"] = 29] = "EnvelopeC3";
  /**
   * Envelope C4 229mm x 324mm
   */
  PaperSize[PaperSize["EnvelopeC4"] = 30] = "EnvelopeC4";
  /**
   * Envelope C6 114mm x 162mm
   */
  PaperSize[PaperSize["EnvelopeC6"] = 31] = "EnvelopeC6";
  /**
   * Envelope C6/C5 114mm x 229mm
   */
  PaperSize[PaperSize["EnvelopeC6C5"] = 32] = "EnvelopeC6C5";
  /**
   * B4 (ISO) 250mm x 353mm
   */
  PaperSize[PaperSize["B4ISO_1"] = 33] = "B4ISO_1";
  /**
   * B5 (ISO) 176mm x 250mm
   */
  PaperSize[PaperSize["B5ISO"] = 34] = "B5ISO";
  /**
   * B6 (ISO) 125mm x 176mm
   */
  PaperSize[PaperSize["B6ISO"] = 35] = "B6ISO";
  /**
   * Envelope Italy 110mm x 230mm
   */
  PaperSize[PaperSize["EnvelopeItaly"] = 36] = "EnvelopeItaly";
  /**
   * Envelope Monarch 3 7/8\" x 7 1/2\"
   */
  PaperSize[PaperSize["EnvelopeMonarch"] = 37] = "EnvelopeMonarch";
  /**
   * 6 3/4 Envelope 3 5/8\" x 6 1/2\"
   */
  PaperSize[PaperSize["Size634Envelope"] = 38] = "Size634Envelope";
  /**
   * US Standard Fanfold 14 7/8\" x 11\"
   */
  PaperSize[PaperSize["USStandardFanfold"] = 39] = "USStandardFanfold";
  /**
   * German Std. Fanfold 8 1/2\" x 12\"
   */
  PaperSize[PaperSize["GermanStandardFanfold"] = 40] = "GermanStandardFanfold";
  /**
   * German Legal Fanfold 8 1/2\" x 13\"
   */
  PaperSize[PaperSize["GermanLegalFanfold"] = 41] = "GermanLegalFanfold";
  /**
   * B4 (ISO) 250mm x 353mm
   */
  PaperSize[PaperSize["B4ISO_2"] = 42] = "B4ISO_2";
  /**
   * Japanese Postcard 100mm x 148mm
   */
  PaperSize[PaperSize["JapanesePostcard"] = 43] = "JapanesePostcard";
  /**
   * 9x11 9\" x 11\"
   */
  PaperSize[PaperSize["Size9x11"] = 44] = "Size9x11";
  /**
   * 10x11 10\" x 11\"
   */
  PaperSize[PaperSize["Size10x11"] = 45] = "Size10x11";
  /**
   * 15x11 15\" x 11\"
   */
  PaperSize[PaperSize["Size15x11"] = 46] = "Size15x11";
  /**
   * Envelope Invite 220mm x 220mm
   */
  PaperSize[PaperSize["EnvelopeInvite"] = 47] = "EnvelopeInvite";
  /**
   * Letter Extra 9 1/2\" x 12\"
   */
  PaperSize[PaperSize["LetterExtra"] = 50] = "LetterExtra";
  /**
   * Legal Extra 9 1/2\" x 15\"
   */
  PaperSize[PaperSize["LegalExtra"] = 51] = "LegalExtra";
  /**
   * Tabloid Extra 11 11/16\" x 18\"
   */
  PaperSize[PaperSize["TabloidExtra"] = 52] = "TabloidExtra";
  /**
   * A4 Extra 235mm x 322mm
   */
  PaperSize[PaperSize["A4Extra"] = 53] = "A4Extra";
  /**
   * Letter Transverse 8 1/2\" x 11\"
   */
  PaperSize[PaperSize["LetterTransverse"] = 54] = "LetterTransverse";
  /**
   * A4 Transverse 210mm x 297mm
   */
  PaperSize[PaperSize["A4Transverse"] = 55] = "A4Transverse";
  /**
   * Letter Extra Transv. 9 1/2\" x 12\"
   */
  PaperSize[PaperSize["LetterExtraTransverse"] = 56] = "LetterExtraTransverse";
  /**
   * Super A/A4 227mm x 356mm
   */
  PaperSize[PaperSize["SuperAA4"] = 57] = "SuperAA4";
  /**
   * Super B/A3 305mm x 487mm
   */
  PaperSize[PaperSize["SuperBA3"] = 58] = "SuperBA3";
  /**
   * Letter Plus 8 1/2\" x 12 11/16\"
   */
  PaperSize[PaperSize["LetterPlus"] = 59] = "LetterPlus";
  /**
   * A4 Plus 210mm x 330mm
   */
  PaperSize[PaperSize["A4Plus"] = 60] = "A4Plus";
  /**
   * A5 Transverse 148mm x 210mm
   */
  PaperSize[PaperSize["A5Transverse"] = 61] = "A5Transverse";
  /**
   * B5 (JIS) Transverse 182mm x 257mm
   */
  PaperSize[PaperSize["B5JISTransverse"] = 62] = "B5JISTransverse";
  /**
   * A3 Extra 322mm x 445mm
   */
  PaperSize[PaperSize["A3Extra"] = 63] = "A3Extra";
  /**
   * A5 Extra 174mm x 235mm
   */
  PaperSize[PaperSize["A5Extra"] = 64] = "A5Extra";
  /**
   * B5 (ISO) Extra 201mm x 276mm
   */
  PaperSize[PaperSize["B5ISOExtra"] = 65] = "B5ISOExtra";
  /**
   * A2 420mm x 594mm
   */
  PaperSize[PaperSize["A2"] = 66] = "A2";
  /**
   * A3 Transverse 297mm x 420mm
   */
  PaperSize[PaperSize["A3Transverse"] = 67] = "A3Transverse";
  /**
   * A3 Extra Transverse 322mm x 445mm
   */
  PaperSize[PaperSize["A3ExtraTransverse"] = 68] = "A3ExtraTransverse";
  /**
   * Dbl. Japanese Postcard 200mm x 148mm
   */
  PaperSize[PaperSize["DblJapanesePostcard"] = 69] = "DblJapanesePostcard";
  /**
   * A6 105mm x 148mm
   */
  PaperSize[PaperSize["A6"] = 70] = "A6";
  /**
   * Letter Rotated 11\" x 8 1/2\"
   */
  PaperSize[PaperSize["LetterRotated"] = 75] = "LetterRotated";
  /**
   * A3 Rotated 420mm x 297mm
   */
  PaperSize[PaperSize["A3Rotated"] = 76] = "A3Rotated";
  /**
   * A4 Rotated 297mm x 210mm
   */
  PaperSize[PaperSize["A4Rotated"] = 77] = "A4Rotated";
  /**
   * A5 Rotated 210mm x 148mm
   */
  PaperSize[PaperSize["A5Rotated"] = 78] = "A5Rotated";
  /**
   * B4 (JIS) Rotated 364mm x 257mm
   */
  PaperSize[PaperSize["B4JISRotated"] = 79] = "B4JISRotated";
  /**
   * B5 (JIS) Rotated 257mm x 182mm
   */
  PaperSize[PaperSize["B5JISRotated"] = 80] = "B5JISRotated";
  /**
   * Japanese Postcard Rot. 148mm x 100mm
   */
  PaperSize[PaperSize["JapanesePostcardRotated"] = 81] = "JapanesePostcardRotated";
  /**
   * Dbl. Jap. Postcard Rot. 148mm x 200mm
   */
  PaperSize[PaperSize["DblJapanesePostcardRotated"] = 82] = "DblJapanesePostcardRotated";
  /**
   * A6 Rotated 148mm x 105mm
   */
  PaperSize[PaperSize["A6Rotated"] = 83] = "A6Rotated";
  /**
   * B6 (JIS) 128mm x 182mm
   */
  PaperSize[PaperSize["B6JIS"] = 88] = "B6JIS";
  /**
   * B6 (JIS) Rotated 182mm x 128mm
   */
  PaperSize[PaperSize["B6JISRotated"] = 89] = "B6JISRotated";
  /**
   * 12x11 12\" x 11\"
   */
  PaperSize[PaperSize["Size12x11"] = 90] = "Size12x11";
})(PaperSize || (PaperSize = {}));
/**
 * @hidden
 */
export let PaperSize_$type = markEnum('PaperSize', 'Undefined,0|Letter,1|LetterSmall,2|Tabloid,3|Ledger,4|Legal,5|Statement,6|Executive,7|A3,8|A4,9|A4Small,10|A5,11|B4JIS,12|B5JIS,13|Folio,14|Quarto,15|Size10x14,16|Size11x17,17|Note,18|Envelope9,19|Envelope10,20|Envelope11,21|Envelope12,22|Envelope14,23|C,24|D,25|E,26|EnvelopeDL,27|EnvelopeC5,28|EnvelopeC3,29|EnvelopeC4,30|EnvelopeC6,31|EnvelopeC6C5,32|B4ISO_1,33|B5ISO,34|B6ISO,35|EnvelopeItaly,36|EnvelopeMonarch,37|Size634Envelope,38|USStandardFanfold,39|GermanStandardFanfold,40|GermanLegalFanfold,41|B4ISO_2,42|JapanesePostcard,43|Size9x11,44|Size10x11,45|Size15x11,46|EnvelopeInvite,47|LetterExtra,50|LegalExtra,51|TabloidExtra,52|A4Extra,53|LetterTransverse,54|A4Transverse,55|LetterExtraTransverse,56|SuperAA4,57|SuperBA3,58|LetterPlus,59|A4Plus,60|A5Transverse,61|B5JISTransverse,62|A3Extra,63|A5Extra,64|B5ISOExtra,65|A2,66|A3Transverse,67|A3ExtraTransverse,68|DblJapanesePostcard,69|A6,70|LetterRotated,75|A3Rotated,76|A4Rotated,77|A5Rotated,78|B4JISRotated,79|B5JISRotated,80|JapanesePostcardRotated,81|DblJapanesePostcardRotated,82|A6Rotated,83|B6JIS,88|B6JISRotated,89|Size12x11,90');
/**
 * @hidden
 */
export let PaneLocation_$type = markEnum('PaneLocation', 'BottomRight,0|TopRight,1|BottomLeft,2|TopLeft,3');
/**
 * Represents the way pages are numbered when printed.
 */
export var PageNumbering;
(function (PageNumbering) {
  /**
   * Pages are automatically numbered based on the style of the worksheet.
   */
  PageNumbering[PageNumbering["Automatic"] = 0] = "Automatic";
  /**
   * The starting page number specified is used for the first page, additional
   * pages receive a page number that it one greater than the previous page.
   */
  PageNumbering[PageNumbering["UseStartPageNumber"] = 1] = "UseStartPageNumber";
})(PageNumbering || (PageNumbering = {}));
/**
 * @hidden
 */
export let PageNumbering_$type = markEnum('PageNumbering', 'Automatic,0|UseStartPageNumber,1');
/**
 * Represents the ways to order the pages of multiple page worksheets.
 */
export var PageOrder;
(function (PageOrder) {
  /**
   * The first page to print is the top-left page. The next pages printed are below the first page.
   * When there are no more pages below, the page to the right of the top-left page is printed, then the pages
   * below it, and so on.
   */
  PageOrder[PageOrder["DownThenOver"] = 0] = "DownThenOver";
  /**
   * The first page to print is the top-left page. The next pages printed are right of the first page.
   * When there are no more pages to the right, the page below the top-left page is printed, then the pages
   * to the right of it, and so on.
   */
  PageOrder[PageOrder["OverThenDown"] = 1] = "OverThenDown";
})(PageOrder || (PageOrder = {}));
/**
 * @hidden
 */
export let PageOrder_$type = markEnum('PageOrder', 'DownThenOver,0|OverThenDown,1');
/**
 * Represents the page orientations available when a worksheet is printed.
 */
export var Orientation;
(function (Orientation) {
  /**
   * The page is printed with the larger dimension horizontal.
   */
  Orientation[Orientation["Landscape"] = 0] = "Landscape";
  /**
   * The page is printed with the larger dimension vertical.
   */
  Orientation[Orientation["Portrait"] = 1] = "Portrait";
  /**
   * The page is printed with the default setting.
   */
  Orientation[Orientation["Default"] = 2] = "Default";
})(Orientation || (Orientation = {}));
/**
 * @hidden
 */
export let Orientation_$type = markEnum('Orientation', 'Landscape,0|Portrait,1|Default,2');
/**
 * Represents the various way objects and shapes are displayed in the workbook.
 */
export var ObjectDisplayStyle;
(function (ObjectDisplayStyle) {
  /**
   * All object are be shown.
   */
  ObjectDisplayStyle[ObjectDisplayStyle["ShowAll"] = 0] = "ShowAll";
  /**
   * Placeholders are shown in place of objects.
   */
  ObjectDisplayStyle[ObjectDisplayStyle["ShowPlaceholders"] = 1] = "ShowPlaceholders";
  /**
   * No objects or shapes are shown.
   */
  ObjectDisplayStyle[ObjectDisplayStyle["HideAll"] = 2] = "HideAll";
})(ObjectDisplayStyle || (ObjectDisplayStyle = {}));
/**
 * @hidden
 */
export let ObjectDisplayStyle_$type = markEnum('ObjectDisplayStyle', 'ShowAll,0|ShowPlaceholders,1|HideAll,2');
/**
 * @hidden
 */
export let NameType_$type = markEnum('NameType', 'Normal,0|AddInFunctionName,1|OleObject,2');
/**
 * @hidden
 */
export let LengthType_$type = markEnum('LengthType', 'EightBit,0|SixteenBit,1');
/**
 * Represents the various horizontal text alignment types.
 */
export var HorizontalTextAlignment;
(function (HorizontalTextAlignment) {
  /**
   * Align text in the center of the line.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["Center"] = 0] = "Center";
  /**
   * Distributes the words across the entire line.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["Distributed"] = 1] = "Distributed";
  /**
   * Align text so it is justified across the line.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["Justified"] = 2] = "Justified";
  /**
   * Aligns the text with an adjusted kashida length for Arabic text.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["JustifiedLow"] = 3] = "JustifiedLow";
  /**
   * Align the text to the left of the line.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["Left"] = 4] = "Left";
  /**
   * Align the text to the right of the line.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["Right"] = 5] = "Right";
  /**
   * Distributes Thai text by treating each character as a word.
   */
  HorizontalTextAlignment[HorizontalTextAlignment["ThaiDistributed"] = 6] = "ThaiDistributed";
})(HorizontalTextAlignment || (HorizontalTextAlignment = {}));
/**
 * @hidden
 */
export let HorizontalTextAlignment_$type = markEnum('HorizontalTextAlignment', 'Center,0|Distributed,1|Justified,2|JustifiedLow,3|Left,4|Right,5|ThaiDistributed,6');
/**
 * Enumeration for horizontal alignment styles. Default value is used in property override situations.
 */
export var HorizontalCellAlignment;
(function (HorizontalCellAlignment) {
  /**
   * Use the current default.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Default"] = -1] = "Default";
  /**
   * Alignment depends on underlying data type.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["General"] = 0] = "General";
  /**
   * Left alignment.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Left"] = 1] = "Left";
  /**
   * Centered alignment.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Center"] = 2] = "Center";
  /**
   * Right alignment.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Right"] = 3] = "Right";
  /**
   * Repeat cell value to fill whole cell.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Fill"] = 4] = "Fill";
  /**
   * Justify alignment.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Justify"] = 5] = "Justify";
  /**
   * Centers the contents of the left-most cell in a center across selection group. All other cells in the center across selection group must be empty. The cells are not merged, and the data may appear to be in a cell other than the left-most cell.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["CenterAcrossSelection"] = 6] = "CenterAcrossSelection";
  /**
   * Distributed alignment.
   */
  HorizontalCellAlignment[HorizontalCellAlignment["Distributed"] = 7] = "Distributed";
})(HorizontalCellAlignment || (HorizontalCellAlignment = {}));
/**
 * @hidden
 */
export let HorizontalCellAlignment_$type = markEnum('HorizontalCellAlignment', 'Default,-1|General,0|Left,1|Center,2|Right,3|Fill,4|Justify,5|CenterAcrossSelection,6|Distributed,7');
/**
 * @hidden
 */
export let FunctionGroup_$type = markEnum('FunctionGroup', 'Financial,1|DateAndTime,2|MathAndTrig,3|Statistical,4|LookupAndReference,5|Database,6|Text,7|Logical,8|Information,9|Commands,10|Customizing,11|MacroControl,12|DDEExternal,13|UserDefined,14');
/**
 * @hidden
 */
export let FormulaType_$type = markEnum('FormulaType', 'Formula,0|ArrayFormula,1|SharedFormula,2|NamedReferenceFormula,3|ExternalNamedReferenceFormula,4|ListDataValidationFormula,5|NonListDataValidationFormula,6|ConditionalFormatFormula,7');
/**
 * Constants which identify a set of icons for an [[IconSetConditionalFormat]].
 */
export var FormatConditionIconSet;
(function (FormatConditionIconSet) {
  /**
   * No icon is shown.
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSetNoIcon"] = -1] = "IconSetNoIcon";
  /**
   * Microsoft.Office.Interop.Excel.xl3Arrows = 1
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Arrows"] = 1] = "IconSet3Arrows";
  /**
   * Microsoft.Office.Interop.Excel.xl3ArrowsGray = 2
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3ArrowsGray"] = 2] = "IconSet3ArrowsGray";
  /**
   * Microsoft.Office.Interop.Excel.xl3Flags = 3
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Flags"] = 3] = "IconSet3Flags";
  /**
   * Microsoft.Office.Interop.Excel.xl3TrafficLights1 = 4
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3TrafficLights1"] = 4] = "IconSet3TrafficLights1";
  /**
   * Microsoft.Office.Interop.Excel.xl3TrafficLights2 = 5
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3TrafficLights2"] = 5] = "IconSet3TrafficLights2";
  /**
   * Microsoft.Office.Interop.Excel.xl3Signs = 6
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Signs"] = 6] = "IconSet3Signs";
  /**
   * Microsoft.Office.Interop.Excel.xl3Symbols = 7
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Symbols"] = 7] = "IconSet3Symbols";
  /**
   * Microsoft.Office.Interop.Excel.xl3Symbols2 = 8
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Symbols2"] = 8] = "IconSet3Symbols2";
  /**
   * Microsoft.Office.Interop.Excel.xl4Arrows = 9
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet4Arrows"] = 9] = "IconSet4Arrows";
  /**
   * Microsoft.Office.Interop.Excel.xl4ArrowsGray = 10
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet4ArrowsGray"] = 10] = "IconSet4ArrowsGray";
  /**
   * Microsoft.Office.Interop.Excel.xl4RedToBlack = 11
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet4RedToBlack"] = 11] = "IconSet4RedToBlack";
  /**
   * Microsoft.Office.Interop.Excel.xl4CRV = 12
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet4Rating"] = 12] = "IconSet4Rating";
  /**
   * Microsoft.Office.Interop.Excel.xl4TrafficLights = 13
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet4TrafficLights"] = 13] = "IconSet4TrafficLights";
  /**
   * Microsoft.Office.Interop.Excel.xl5Arrows = 14
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet5Arrows"] = 14] = "IconSet5Arrows";
  /**
   * Microsoft.Office.Interop.Excel.xl5ArrowsGray = 15
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet5ArrowsGray"] = 15] = "IconSet5ArrowsGray";
  /**
   * Microsoft.Office.Interop.Excel.xl5CRV = 16
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet5Rating"] = 16] = "IconSet5Rating";
  /**
   * Microsoft.Office.Interop.Excel.xl5Quarters = 17
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet5Quarters"] = 17] = "IconSet5Quarters";
  /**
   * Microsoft.Office.Interop.Excel.xl3Stars = 18
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Stars"] = 18] = "IconSet3Stars";
  /**
   * Microsoft.Office.Interop.Excel.xl3Triangles = 19
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet3Triangles"] = 19] = "IconSet3Triangles";
  /**
   * Microsoft.Office.Interop.Excel.xl5Boxes = 20
   */
  FormatConditionIconSet[FormatConditionIconSet["IconSet5Boxes"] = 20] = "IconSet5Boxes";
})(FormatConditionIconSet || (FormatConditionIconSet = {}));
/**
 * @hidden
 */
export let FormatConditionIconSet_$type = markEnum('FormatConditionIconSet', 'IconSetNoIcon,-1|IconSet3Arrows,1|IconSet3ArrowsGray,2|IconSet3Flags,3|IconSet3TrafficLights1,4|IconSet3TrafficLights2,5|IconSet3Signs,6|IconSet3Symbols,7|IconSet3Symbols2,8|IconSet4Arrows,9|IconSet4ArrowsGray,10|IconSet4RedToBlack,11|IconSet4Rating,12|IconSet4TrafficLights,13|IconSet5Arrows,14|IconSet5ArrowsGray,15|IconSet5Rating,16|IconSet5Quarters,17|IconSet3Stars,18|IconSet3Triangles,19|IconSet5Boxes,20');
/**
 * Identifies the set of icons used by a [[IconCriterion]].
 * @see [[IconCriterion.icon]]
 */
export var FormatConditionIcon;
(function (FormatConditionIcon) {
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenUpArrow = 1
   */
  FormatConditionIcon[FormatConditionIcon["GreenUpArrow"] = 1] = "GreenUpArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowSideArrow = 2
   */
  FormatConditionIcon[FormatConditionIcon["YellowSideArrow"] = 2] = "YellowSideArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedDownArrow = 3
   */
  FormatConditionIcon[FormatConditionIcon["RedDownArrow"] = 3] = "RedDownArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGrayUpArrow = 4
   */
  FormatConditionIcon[FormatConditionIcon["GrayUpArrow"] = 4] = "GrayUpArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGraySideArrow = 5
   */
  FormatConditionIcon[FormatConditionIcon["GraySideArrow"] = 5] = "GraySideArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGrayDownArrow = 6
   */
  FormatConditionIcon[FormatConditionIcon["GrayDownArrow"] = 6] = "GrayDownArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenFlag = 7
   */
  FormatConditionIcon[FormatConditionIcon["GreenFlag"] = 7] = "GreenFlag";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowFlag = 8
   */
  FormatConditionIcon[FormatConditionIcon["YellowFlag"] = 8] = "YellowFlag";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedFlag = 9
   */
  FormatConditionIcon[FormatConditionIcon["RedFlag"] = 9] = "RedFlag";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenCircle = 10
   */
  FormatConditionIcon[FormatConditionIcon["GreenCircle"] = 10] = "GreenCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowCircle = 11
   */
  FormatConditionIcon[FormatConditionIcon["YellowCircle"] = 11] = "YellowCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedCircleWithBorder = 12
   */
  FormatConditionIcon[FormatConditionIcon["RedCircleWithBorder"] = 12] = "RedCircleWithBorder";
  /**
   * Microsoft.Office.Interop.Excel.xlIconBlackCircleWithBorder = 13
   */
  FormatConditionIcon[FormatConditionIcon["BlackCircleWithBorder"] = 13] = "BlackCircleWithBorder";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenTrafficLight = 14
   */
  FormatConditionIcon[FormatConditionIcon["GreenTrafficLight"] = 14] = "GreenTrafficLight";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowTrafficLight = 15
   */
  FormatConditionIcon[FormatConditionIcon["YellowTrafficLight"] = 15] = "YellowTrafficLight";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedTrafficLight = 16
   */
  FormatConditionIcon[FormatConditionIcon["RedTrafficLight"] = 16] = "RedTrafficLight";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowTriangle = 17
   */
  FormatConditionIcon[FormatConditionIcon["YellowTriangle"] = 17] = "YellowTriangle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedDiamond = 18
   */
  FormatConditionIcon[FormatConditionIcon["RedDiamond"] = 18] = "RedDiamond";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenCheckSymbol = 19
   */
  FormatConditionIcon[FormatConditionIcon["GreenCheckSymbol"] = 19] = "GreenCheckSymbol";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowExclamationSymbol = 20
   */
  FormatConditionIcon[FormatConditionIcon["YellowExclamationSymbol"] = 20] = "YellowExclamationSymbol";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedCrossSymbol = 21
   */
  FormatConditionIcon[FormatConditionIcon["RedCrossSymbol"] = 21] = "RedCrossSymbol";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenCheck = 22
   */
  FormatConditionIcon[FormatConditionIcon["GreenCheck"] = 22] = "GreenCheck";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowExclamation = 23
   */
  FormatConditionIcon[FormatConditionIcon["YellowExclamation"] = 23] = "YellowExclamation";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedCross = 24
   */
  FormatConditionIcon[FormatConditionIcon["RedCross"] = 24] = "RedCross";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowUpInclineArrow = 25
   */
  FormatConditionIcon[FormatConditionIcon["YellowUpInclineArrow"] = 25] = "YellowUpInclineArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowDownInclineArrow = 26
   */
  FormatConditionIcon[FormatConditionIcon["YellowDownInclineArrow"] = 26] = "YellowDownInclineArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGrayUpInclineArrow = 27
   */
  FormatConditionIcon[FormatConditionIcon["GrayUpInclineArrow"] = 27] = "GrayUpInclineArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGrayDownInclineArrow = 28
   */
  FormatConditionIcon[FormatConditionIcon["GrayDownInclineArrow"] = 28] = "GrayDownInclineArrow";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedCircle = 29
   */
  FormatConditionIcon[FormatConditionIcon["RedCircle"] = 29] = "RedCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconPinkCircle = 30
   */
  FormatConditionIcon[FormatConditionIcon["PinkCircle"] = 30] = "PinkCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGrayCircle = 31
   */
  FormatConditionIcon[FormatConditionIcon["GrayCircle"] = 31] = "GrayCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconBlackCircle = 32
   */
  FormatConditionIcon[FormatConditionIcon["BlackCircle"] = 32] = "BlackCircle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconCircleWithOneWhiteQuarter = 33
   */
  FormatConditionIcon[FormatConditionIcon["CircleWithOneWhiteQuarter"] = 33] = "CircleWithOneWhiteQuarter";
  /**
   * Microsoft.Office.Interop.Excel.xlIconCircleWithTwoWhiteQuarters = 34
   */
  FormatConditionIcon[FormatConditionIcon["CircleWithTwoWhiteQuarters"] = 34] = "CircleWithTwoWhiteQuarters";
  /**
   * Microsoft.Office.Interop.Excel.xlIconCircleWithThreeWhiteQuarters = 35
   */
  FormatConditionIcon[FormatConditionIcon["CircleWithThreeWhiteQuarters"] = 35] = "CircleWithThreeWhiteQuarters";
  /**
   * Microsoft.Office.Interop.Excel.xlIconWhiteCircleAllWhiteQuarters = 36
   */
  FormatConditionIcon[FormatConditionIcon["WhiteCircleAllWhiteQuarters"] = 36] = "WhiteCircleAllWhiteQuarters";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon0Bars = 37
   */
  FormatConditionIcon[FormatConditionIcon["ZeroBars"] = 37] = "ZeroBars";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon1Bar = 38
   */
  FormatConditionIcon[FormatConditionIcon["OneBar"] = 38] = "OneBar";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon2Bars = 39
   */
  FormatConditionIcon[FormatConditionIcon["TwoBars"] = 39] = "TwoBars";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon3Bars = 40
   */
  FormatConditionIcon[FormatConditionIcon["ThreeBars"] = 40] = "ThreeBars";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon4Bars = 41
   */
  FormatConditionIcon[FormatConditionIcon["FourBars"] = 41] = "FourBars";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGoldStar = 42
   */
  FormatConditionIcon[FormatConditionIcon["GoldStar"] = 42] = "GoldStar";
  /**
   * Microsoft.Office.Interop.Excel.xlIconHalfGoldStar = 43
   */
  FormatConditionIcon[FormatConditionIcon["HalfGoldStar"] = 43] = "HalfGoldStar";
  /**
   * Microsoft.Office.Interop.Excel.xlIconSilverStar = 44
   */
  FormatConditionIcon[FormatConditionIcon["SilverStar"] = 44] = "SilverStar";
  /**
   * Microsoft.Office.Interop.Excel.xlIconGreenUpTriangle = 45
   */
  FormatConditionIcon[FormatConditionIcon["GreenUpTriangle"] = 45] = "GreenUpTriangle";
  /**
   * Microsoft.Office.Interop.Excel.xlIconYellowDash = 46
   */
  FormatConditionIcon[FormatConditionIcon["YellowDash"] = 46] = "YellowDash";
  /**
   * Microsoft.Office.Interop.Excel.xlIconRedDownTriangle = 47
   */
  FormatConditionIcon[FormatConditionIcon["RedDownTriangle"] = 47] = "RedDownTriangle";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon4FilledBoxes = 48
   */
  FormatConditionIcon[FormatConditionIcon["FourFilledBoxes"] = 48] = "FourFilledBoxes";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon3FilledBoxes = 49
   */
  FormatConditionIcon[FormatConditionIcon["ThreeFilledBoxes"] = 49] = "ThreeFilledBoxes";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon2FilledBoxes = 50
   */
  FormatConditionIcon[FormatConditionIcon["TwoFilledBoxes"] = 50] = "TwoFilledBoxes";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon1FilledBox = 51
   */
  FormatConditionIcon[FormatConditionIcon["OneFilledBox"] = 51] = "OneFilledBox";
  /**
   * Microsoft.Office.Interop.Excel.xlIcon0FilledBoxes = 52
   */
  FormatConditionIcon[FormatConditionIcon["ZeroFilledBoxes"] = 52] = "ZeroFilledBoxes";
  /**
   * Microsoft.Office.Interop.Excel.xlIconNoCellIcon = -1
   */
  FormatConditionIcon[FormatConditionIcon["NoCellIcon"] = -1] = "NoCellIcon";
})(FormatConditionIcon || (FormatConditionIcon = {}));
/**
 * @hidden
 */
export let FormatConditionIcon_$type = markEnum('FormatConditionIcon', 'GreenUpArrow,1|YellowSideArrow,2|RedDownArrow,3|GrayUpArrow,4|GraySideArrow,5|GrayDownArrow,6|GreenFlag,7|YellowFlag,8|RedFlag,9|GreenCircle,10|YellowCircle,11|RedCircleWithBorder,12|BlackCircleWithBorder,13|GreenTrafficLight,14|YellowTrafficLight,15|RedTrafficLight,16|YellowTriangle,17|RedDiamond,18|GreenCheckSymbol,19|YellowExclamationSymbol,20|RedCrossSymbol,21|GreenCheck,22|YellowExclamation,23|RedCross,24|YellowUpInclineArrow,25|YellowDownInclineArrow,26|GrayUpInclineArrow,27|GrayDownInclineArrow,28|RedCircle,29|PinkCircle,30|GrayCircle,31|BlackCircle,32|CircleWithOneWhiteQuarter,33|CircleWithTwoWhiteQuarters,34|CircleWithThreeWhiteQuarters,35|WhiteCircleAllWhiteQuarters,36|ZeroBars,37|OneBar,38|TwoBars,39|ThreeBars,40|FourBars,41|GoldStar,42|HalfGoldStar,43|SilverStar,44|GreenUpTriangle,45|YellowDash,46|RedDownTriangle,47|FourFilledBoxes,48|ThreeFilledBoxes,49|TwoFilledBoxes,50|OneFilledBox,51|ZeroFilledBoxes,52|NoCellIcon,-1');
/**
 * Enumeration for font underline styles. Default value is used in property override situations.
 */
export var FontUnderlineStyle;
(function (FontUnderlineStyle) {
  /**
   * Use the current default.
   */
  FontUnderlineStyle[FontUnderlineStyle["Default"] = -1] = "Default";
  /**
   * No underline style.
   */
  FontUnderlineStyle[FontUnderlineStyle["None"] = 0] = "None";
  /**
   * Single underline style.
   */
  FontUnderlineStyle[FontUnderlineStyle["Single"] = 1] = "Single";
  /**
   * Double underline style.
   */
  FontUnderlineStyle[FontUnderlineStyle["double1"] = 2] = "double1";
  /**
   * Single accounting underline style.
   */
  FontUnderlineStyle[FontUnderlineStyle["SingleAccounting"] = 33] = "SingleAccounting";
  /**
   * Double accounting underline style.
   */
  FontUnderlineStyle[FontUnderlineStyle["DoubleAccounting"] = 34] = "DoubleAccounting";
})(FontUnderlineStyle || (FontUnderlineStyle = {}));
/**
 * @hidden
 */
export let FontUnderlineStyle_$type = markEnum('FontUnderlineStyle', 'Default,-1|None,0|Single,1|Double:double1,2|SingleAccounting,33|DoubleAccounting,34');
/**
 * Enumeration for font superscript or subscript style. Default value is used in property override situations.
 */
export var FontSuperscriptSubscriptStyle;
(function (FontSuperscriptSubscriptStyle) {
  /**
   * Use the current default.
   */
  FontSuperscriptSubscriptStyle[FontSuperscriptSubscriptStyle["Default"] = -1] = "Default";
  /**
   * No superscript or subscript style.
   */
  FontSuperscriptSubscriptStyle[FontSuperscriptSubscriptStyle["None"] = 0] = "None";
  /**
   * Superscript style.
   */
  FontSuperscriptSubscriptStyle[FontSuperscriptSubscriptStyle["Superscript"] = 1] = "Superscript";
  /**
   * Subscript style.
   */
  FontSuperscriptSubscriptStyle[FontSuperscriptSubscriptStyle["Subscript"] = 2] = "Subscript";
})(FontSuperscriptSubscriptStyle || (FontSuperscriptSubscriptStyle = {}));
/**
 * @hidden
 */
export let FontSuperscriptSubscriptStyle_$type = markEnum('FontSuperscriptSubscriptStyle', 'Default,-1|None,0|Superscript,1|Subscript,2');
/**
 * Enumeration for fill pattern styles. Default value is used in property override situations.
 */
export var FillPatternStyle;
(function (FillPatternStyle) {
  /**
   * Obsolete. Use None instead.
   */
  FillPatternStyle[FillPatternStyle["Default"] = -1] = "Default";
  /**
   * No fill pattern.
   */
  FillPatternStyle[FillPatternStyle["None"] = 0] = "None";
  /**
   * Solid fill pattern with fill pattern foreground color.
   */
  FillPatternStyle[FillPatternStyle["Solid"] = 1] = "Solid";
  /**
   * "50% gray" fill pattern.
   */
  FillPatternStyle[FillPatternStyle["Gray50percent"] = 2] = "Gray50percent";
  /**
   * "75% gray" fill pattern.
   */
  FillPatternStyle[FillPatternStyle["Gray75percent"] = 3] = "Gray75percent";
  /**
   * "25% gray" fill pattern.
   */
  FillPatternStyle[FillPatternStyle["Gray25percent"] = 4] = "Gray25percent";
  /**
   * Horizontal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["HorizontalStripe"] = 5] = "HorizontalStripe";
  /**
   * Vertical stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["VerticalStripe"] = 6] = "VerticalStripe";
  /**
   * Reverse diagonal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ReverseDiagonalStripe"] = 7] = "ReverseDiagonalStripe";
  /**
   * Diagonal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["DiagonalStripe"] = 8] = "DiagonalStripe";
  /**
   * Diagonal crosshatch fill pattern.
   */
  FillPatternStyle[FillPatternStyle["DiagonalCrosshatch"] = 9] = "DiagonalCrosshatch";
  /**
   * Thick diagonal crosshatch fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThickDiagonalCrosshatch"] = 10] = "ThickDiagonalCrosshatch";
  /**
   * Thin horizontal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinHorizontalStripe"] = 11] = "ThinHorizontalStripe";
  /**
   * Thin vertical stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinVerticalStripe"] = 12] = "ThinVerticalStripe";
  /**
   * Thin reverse diagonal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinReverseDiagonalStripe"] = 13] = "ThinReverseDiagonalStripe";
  /**
   * Thin diagonal stripe fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinDiagonalStripe"] = 14] = "ThinDiagonalStripe";
  /**
   * Thin horizontal crosshatch fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinHorizontalCrosshatch"] = 15] = "ThinHorizontalCrosshatch";
  /**
   * Thin diagonal crosshatch fill pattern.
   */
  FillPatternStyle[FillPatternStyle["ThinDiagonalCrosshatch"] = 16] = "ThinDiagonalCrosshatch";
  /**
   * "12.5% gray" fill pattern.
   */
  FillPatternStyle[FillPatternStyle["Gray12percent"] = 17] = "Gray12percent";
  /**
   * "6.25% gray" fill pattern.
   */
  FillPatternStyle[FillPatternStyle["Gray6percent"] = 18] = "Gray6percent";
})(FillPatternStyle || (FillPatternStyle = {}));
/**
 * @hidden
 */
export let FillPatternStyle_$type = markEnum('FillPatternStyle', 'Default,-1|None,0|Solid,1|Gray50percent,2|Gray75percent,3|Gray25percent,4|HorizontalStripe,5|VerticalStripe,6|ReverseDiagonalStripe,7|DiagonalStripe,8|DiagonalCrosshatch,9|ThickDiagonalCrosshatch,10|ThinHorizontalStripe,11|ThinVerticalStripe,12|ThinReverseDiagonalStripe,13|ThinDiagonalStripe,14|ThinHorizontalCrosshatch,15|ThinDiagonalCrosshatch,16|Gray12percent,17|Gray6percent,18');
/**
 * @hidden
 */
export let ExcelChangeAction_$type = markEnum('ExcelChangeAction', 'ApplyArrayFormula,0|ApplyTableFilters,1|ApplySortConditions,2|CellComment,3|CellFormat,4|CellValue,5|ChartAdd,6|ChartModify,7|ChartRemove,8|Chartsheet,9|ClearArrayFormula,10|ClearDataTables,11|ClearDataValidationRules,12|ClearDisplayValues,13|ClearFormattedTextParagraphs,14|ClearFixedDateGroups,15|ClearHyperlinks,16|ClearNamedReferences,17|ClearMergedRegions,18|ClearPageBreaks,19|ClearPrintAreas,20|ClearShapes,21|ClearSortConditions,22|ClearTableFilters,23|ClearTableStyles,24|ClearWorksheetTables,25|Column,26|ColumnFormat,27|ConditionalFormat,28|DataTableAdd,29|DataTableRemove,30|DataValidationRule,31|DataValidationRuleAdd,32|DataValidationRuleRemove,33|DocumentProperties,34|DisplayOptions,35|DisplayValueAdd,36|DisplayValueRemove,37|Filter,38|FixedDateGroupAdd,39|FixedDateGroupRemove,40|FormattedString,41|FormattedText,42|FormattedTextParagraph,43|FormattedTextParagraphAdd,44|FormattedTextParagraphRemove,45|FormulaTokensChanged,46|Hyperlink,47|HyperlinkAdd,48|HyperlinkRemove,49|MergedRegionAdd,50|MergedRegionRemove,51|NamedReference,52|NamedReferenceAdd,53|NamedReferenceRemove,54|PageBreakAdd,55|PageBreakRemove,56|PrintAreaAdd,57|PrintAreaRemove,58|PrintOptions,59|Row,60|RowFormat,61|Shape,62|ShapeAdd,63|ShapeRemove,64|Sheet,65|SparklineAdd,66|SparklineRemove,67|SparklineColorChange,68|SparklineDataChange,69|SparklineStyleChange,70|SparklineTypeChange,71|Table,72|TableAdd,73|TableColumn,74|TableColumnInsert,75|TableColumnRemove,76|TableRowInsert,77|TableRowRemove,78|TableResize,79|TableSort,80|TableStyle,81|TableStyleAdd,82|TableStyleRemove,83|TableRemove,84|TableAreaFormat,85|WindowOptions,86|Workbook,87|WorkbookFont,88|WorkbookStyleCellFormat,89|Worksheet,90|SheetAdd,91|SheetRemove,92|WorksheetCellAdd,93|WorksheetCellRemove,94|WorksheetColumnAdd,95|WorksheetColumnRemove,96|WorksheetRowAdd,97|WorksheetRowRemove,98|Zoom,99|ClearProtectedRanges,100|ProtectedRangeAdd,101|ProtectedRangeRemove,102|WorksheetProtection,103');
/**
 * Represents the diagonal borders which can be displayed in cells.
 */
export var DiagonalBorders;
(function (DiagonalBorders) {
  /**
   * The default value for the diagonal borders.
   */
  DiagonalBorders[DiagonalBorders["Default"] = 0] = "Default";
  /**
   * No diagonal borders will be displayed in the cell.
   */
  DiagonalBorders[DiagonalBorders["None"] = 1] = "None";
  /**
   * A diagonal border going from the top-left to bottom-right corner will be displayed in the cell.
   */
  DiagonalBorders[DiagonalBorders["DiagonalDown"] = 3] = "DiagonalDown";
  /**
   * A diagonal border going from the bottom-left to top-right corner will be displayed in the cell.
   */
  DiagonalBorders[DiagonalBorders["DiagonalUp"] = 5] = "DiagonalUp";
  /**
   * Both diagonal borders will be displayed in the cell.
   */
  DiagonalBorders[DiagonalBorders["All"] = 7] = "All";
})(DiagonalBorders || (DiagonalBorders = {}));
/**
 * @hidden
 */
export let DiagonalBorders_$type = markEnum('DiagonalBorders', 'Default,0|None,1|DiagonalDown,3|DiagonalUp,5|All,7');
/**
 * Represents the various ways a date can be stored internally.
 */
export var DateSystem;
(function (DateSystem) {
  /**
   * Dates are stored as time elapsed since 1900.
   */
  DateSystem[DateSystem["From1900"] = 0] = "From1900";
  /**
   * Dates are stored as time elapsed since 1904 (used mainly on Apple computers).
   */
  DateSystem[DateSystem["From1904"] = 1] = "From1904";
})(DateSystem || (DateSystem = {}));
/**
 * @hidden
 */
export let DateSystem_$type = markEnum('DateSystem', 'From1900,0|From1904,1');
/**
 * @hidden
 */
export let ColorableItem_$type = markEnum('ColorableItem', 'CellBorder,0|CellFill,1|CellFont,2|WorksheetGrid,3|WorksheetTab,4');
/**
 * @hidden
 */
export let CellShiftType_$type = markEnum('CellShiftType', 'HorizontalShift,0|TableResizedWithoutShift,1|VerticalRotate,2|VerticalShift,3');
/**
 * @hidden
 */
export let CellShiftResult_$type = markEnum('CellShiftResult', 'Success,0|ErrorLossOfData,1|ErrorLossOfObject,2|ErrorSplitTable,3|ErrorSplitFilterArea,4|ErrorSplitMergedRegion,5|ErrorSplitBlockingValue,6');
/**
 * @hidden
 */
export let CellShiftInitializeFormatType_$type = markEnum('CellShiftInitializeFormatType', 'UseDefaultFormat,0|FromShiftedCellsAdjacentToInsertRegion,1|FromStationaryCellsAdjacentToInsertRegion,2');
/**
 * @hidden
 */
export let CellShiftDeleteReason_$type = markEnum('CellShiftDeleteReason', 'NotDeleted,0|ShiftDownCoveredAddress,1|ShiftUpCoveredAddress,2|ShiftedOffWorksheetBottom,3|ShiftedOffWorksheetTop,4');
/**
 * Represents the various ways cells can be referenced in a formula.
 * <p class="body">
 * Setting this on the [[Workbook.cellReferenceMode]] will also affect the row and column labels.
 * </p>
 */
export var CellReferenceMode;
(function (CellReferenceMode) {
  /**
   * Cells are referenced by first specifying characters representing the column and a one-based number
   * specifying the row (R54 or CA56). The dollar sign ($) can preface one or both identifiers to make them
   * absolute references ($A$7). Without the dollar sign, references still use absolute row and column addresses,
   * although shifting a formula to a new cell will perform a similar shift on all relative references.
   */
  CellReferenceMode[CellReferenceMode["A1"] = 1] = "A1";
  /**
   * Cells are referenced in the following format R<RowIndex>C<ColumnIndex> (R34C5 or R2C345).
   * These indices are one-based and represent absolute references. To create a relative reference in R1C1 mode, a relative
   * index must be placed inside square brackets following the R and/or C ( R[-1]C[5] or R9C[-3] ).  An R by itself
   * also represents a relative reference and is equivalent to R[0]. Similarly, C is equivalent to C[0], which means a
   * formula of =RC always references the cell which contains the formula.
   */
  CellReferenceMode[CellReferenceMode["R1C1"] = 0] = "R1C1";
})(CellReferenceMode || (CellReferenceMode = {}));
/**
 * @hidden
 */
export let CellReferenceMode_$type = markEnum('CellReferenceMode', 'A1,1|R1C1,0');
/**
 * @hidden
 */
export let CellFormatValue_$type = markEnum('CellFormatValue', 'Alignment,1|BottomBorderColorInfo,2|BottomBorderStyle,4|DiagonalBorderColorInfo,8|DiagonalBorders,16|DiagonalBorderStyle,32|Fill,64|FontBold,128|FontColorInfo,256|FontHeight,512|FontItalic,1024|FontName,2048|FontStrikeout,4096|FontSuperscriptSubscriptStyle,8192|FontUnderlineStyle,16384|FormatOptions,32768|FormatString,65536|Indent,131072|LeftBorderColorInfo,262144|LeftBorderStyle,524288|Locked,1048576|RightBorderColorInfo,2097152|RightBorderStyle,4194304|Rotation,8388608|ShrinkToFit,16777216|Style,33554432|TopBorderColorInfo,67108864|TopBorderStyle,134217728|VerticalAlignment,268435456|WrapText,536870912|_EndValue,1073741824|_OuterBorders,208404486|_TopAndBottomBorders,201326598|_UndoElementData,33587200|ThemeProperties,69470538|ThemeColorProperties,69468490|AlignmentFormattingProperties,830603265|BorderFormattingProperties,208404542|FillFormattingProperties,1073741888|FontFormattingProperties,32640|NumberFormattingProperties,1073807360|ProtectionFormattingProperties,1074790400|AllFormattingProperties,2147483647');
/**
 * Represents the different cell border line styles.
 */
export var CellBorderLineStyle;
(function (CellBorderLineStyle) {
  /**
   * Use the default border line style.
   */
  CellBorderLineStyle[CellBorderLineStyle["Default"] = -1] = "Default";
  /**
   * No border.
   */
  CellBorderLineStyle[CellBorderLineStyle["None"] = 0] = "None";
  /**
   * Thin border.
   */
  CellBorderLineStyle[CellBorderLineStyle["Thin"] = 1] = "Thin";
  /**
   * Medium border.
   */
  CellBorderLineStyle[CellBorderLineStyle["Medium"] = 2] = "Medium";
  /**
   * Dashed border.
   */
  CellBorderLineStyle[CellBorderLineStyle["Dashed"] = 3] = "Dashed";
  /**
   * Dotted border.
   */
  CellBorderLineStyle[CellBorderLineStyle["Dotted"] = 4] = "Dotted";
  /**
   * Thick border.
   */
  CellBorderLineStyle[CellBorderLineStyle["Thick"] = 5] = "Thick";
  /**
   * Double-line border.
   */
  CellBorderLineStyle[CellBorderLineStyle["double1"] = 6] = "double1";
  /**
   * Dotted border with small dots.
   */
  CellBorderLineStyle[CellBorderLineStyle["Hair"] = 7] = "Hair";
  /**
   * Dotted border with big dots.
   */
  CellBorderLineStyle[CellBorderLineStyle["MediumDashed"] = 8] = "MediumDashed";
  /**
   * Dash-dot border.
   */
  CellBorderLineStyle[CellBorderLineStyle["DashDot"] = 9] = "DashDot";
  /**
   * Medium dash-dot border.
   */
  CellBorderLineStyle[CellBorderLineStyle["MediumDashDot"] = 10] = "MediumDashDot";
  /**
   * Dash-dot-dot border.
   */
  CellBorderLineStyle[CellBorderLineStyle["DashDotDot"] = 11] = "DashDotDot";
  /**
   * Medium dash-dot-dot border.
   */
  CellBorderLineStyle[CellBorderLineStyle["MediumDashDotDot"] = 12] = "MediumDashDotDot";
  /**
   * Slanted dash-dot border.
   */
  CellBorderLineStyle[CellBorderLineStyle["SlantedDashDot"] = 13] = "SlantedDashDot";
})(CellBorderLineStyle || (CellBorderLineStyle = {}));
/**
 * @hidden
 */
export let CellBorderLineStyle_$type = markEnum('CellBorderLineStyle', 'Default,-1|None,0|Thin,1|Medium,2|Dashed,3|Dotted,4|Thick,5|Double:double1,6|Hair,7|MediumDashed,8|DashDot,9|MediumDashDot,10|DashDotDot,11|MediumDashDotDot,12|SlantedDashDot,13');
/**
 * Represents the the ways formulas are recalculated when their referenced values change.
 * @see [[Workbook.calculationMode]]
 */
export var CalculationMode;
(function (CalculationMode) {
  /**
   * Formulas must be recalculated manually, by pressing a button in the Microsoft Excel interface.
   */
  CalculationMode[CalculationMode["Manual"] = 0] = "Manual";
  /**
   * Formulas and data tables are automatically recalculated when the values in referenced cells change.
   */
  CalculationMode[CalculationMode["Automatic"] = 1] = "Automatic";
  /**
   * Only formulas are automatically recalculated when the values in referenced cells change.
   * Data tables must be recalculated manually.
   */
  CalculationMode[CalculationMode["AutomaticExceptForDataTables"] = 2] = "AutomaticExceptForDataTables";
})(CalculationMode || (CalculationMode = {}));
/**
 * @hidden
 */
export let CalculationMode_$type = markEnum('CalculationMode', 'Manual,0|Automatic,1|AutomaticExceptForDataTables,2');
/**
 * @hidden
 */
export let BuiltInStyleType_$type = markEnum('BuiltInStyleType', 'Normal,0|RowLevelX,1|ColLevelX,2|Comma,3|Currency,4|Percent,5|Comma0,6|Currency0,7|Hyperlink,8|FollowedHyperlink,9|Note,10|WarningText,11|Emphasis1,12|Emphasis2,13|Emphasis3,14|Title,15|Heading1,16|Heading2,17|Heading3,18|Heading4,19|Input,20|Output,21|Calculation,22|CheckCell,23|LinkedCell,24|Total,25|Good,26|Bad,27|Neutral,28|Accent1,29|Accent1pct20,30|Accent1pct40,31|Accent1pct60,32|Accent2,33|Accent2pct20,34|Accent2pct40,35|Accent2pct60,36|Accent3,37|Accent3pct20,38|Accent3pct40,39|Accent3pct60,40|Accent4,41|Accent4pct20,42|Accent4pct40,43|Accent4pct60,44|Accent5,45|Accent5pct20,46|Accent5pct40,47|Accent5pct60,48|Accent6,49|Accent6pct20,50|Accent6pct40,51|Accent6pct60,52|ExplanatoryText,53');
/**
 * @hidden
 */
export let BuiltInName_$type = markEnum('BuiltInName', 'ConsolidateArea,0|AutoOpen,1|AutoClose,2|Extract,3|Database,4|Criteria,5|PrintArea,6|PrintTitles,7|Recorder,8|DataForm,9|AutoActivate,10|AutoDeactivate,11|SheetTitle,12|FilterDatabase,13');
/**
 * @hidden
 */
export let BorderThickness_$type = markEnum('BorderThickness', 'Thin,0|Medium,1|Thick,2');
/**
 * Represents the various operators which can be used when validating the cell value against two constraints.
 * @see [[TwoConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraint]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraint]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraint]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraint]]
 * @see [[TwoConstraintDataValidationRule.getLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraintFormula]]
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 */
export var TwoConstraintDataValidationOperator;
(function (TwoConstraintDataValidationOperator) {
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is between the
   * constraints applied to the validation rule. The constraints are inclusive.
   */
  TwoConstraintDataValidationOperator[TwoConstraintDataValidationOperator["Between"] = 0] = "Between";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is not between the
   * constraints applied to the validation rule. The constraints are exclusive.
   */
  TwoConstraintDataValidationOperator[TwoConstraintDataValidationOperator["NotBetween"] = 1] = "NotBetween";
})(TwoConstraintDataValidationOperator || (TwoConstraintDataValidationOperator = {}));
/**
 * @hidden
 */
export let TwoConstraintDataValidationOperator_$type = markEnum('TwoConstraintDataValidationOperator', 'Between,0|NotBetween,1');
/**
 * Represents the various operators which can be used when validating the cell value against a constraint.
 * @see [[OneConstraintDataValidationRule]]
 * @see [[OneConstraintDataValidationRule.setConstraint]]
 * @see [[OneConstraintDataValidationRule.setConstraint]]
 * @see [[OneConstraintDataValidationRule.getConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.getConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.setConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.setConstraintFormula]]
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 */
export var OneConstraintDataValidationOperator;
(function (OneConstraintDataValidationOperator) {
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is equal to the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["EqualTo"] = 2] = "EqualTo";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is not equal to the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["NotEqualTo"] = 3] = "NotEqualTo";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is greater than the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["GreaterThan"] = 4] = "GreaterThan";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is greater than or equal to the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["GreaterThanOrEqualTo"] = 6] = "GreaterThanOrEqualTo";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is less than the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["LessThan"] = 5] = "LessThan";
  /**
   * Only allows the cell value if it or its text length, depending on the validation criteria, is less than or equal to the
   * constraint applied to the validation rule.
   */
  OneConstraintDataValidationOperator[OneConstraintDataValidationOperator["LessThanOrEqualTo"] = 7] = "LessThanOrEqualTo";
})(OneConstraintDataValidationOperator || (OneConstraintDataValidationOperator = {}));
/**
 * @hidden
 */
export let OneConstraintDataValidationOperator_$type = markEnum('OneConstraintDataValidationOperator', 'EqualTo,2|NotEqualTo,3|GreaterThan,4|GreaterThanOrEqualTo,6|LessThan,5|LessThanOrEqualTo,7');
/**
 * Represents the various styles in which invalid values are handled by Microsoft Excel. When error messages are not
 * shown for invalid values, the error style is ignored and all invalid values are allowed to be set on cells.
 * @see [[DataValidationRule.errorStyle]]
 * @see [[DataValidationRule.showErrorMessageForInvalidValue]]
 */
export var DataValidationErrorStyle;
(function (DataValidationErrorStyle) {
  /**
   * Invalid values are not allowed. The error dialog shown in Microsoft Excel displays an error icon and retry and cancel
   * buttons. The retry button will put focus back in the cell and allow the user to try to enter a new value. The cancel
   * button will cancel the edit and revert the cell back to the previous value it contained before the edit operation.
   */
  DataValidationErrorStyle[DataValidationErrorStyle["Stop"] = 0] = "Stop";
  /**
   * Invalid values are allowed. The error dialog shown in Microsoft Excel displays a warning icon, asks the user if they
   * want to continue, and has yes, no and cancel buttons. The yes button commits the value to the cell. The no button will
   * put focus back in the cell and allow the user to try to enter a new value. And the cancel button will cancel the edit
   * and revert the cell back to the previous value it contained before the edit operation.
   */
  DataValidationErrorStyle[DataValidationErrorStyle["Warning"] = 1] = "Warning";
  /**
   * Invalid values are allowed. The error dialog shown in Microsoft Excel displays an information icon and ok and cancel
   * buttons. The ok button commits the value to the cell. The cancel button will cancel the edit and revert the cell back
   * to the previous value it contained before the edit operation.
   */
  DataValidationErrorStyle[DataValidationErrorStyle["Information"] = 2] = "Information";
})(DataValidationErrorStyle || (DataValidationErrorStyle = {}));
/**
 * @hidden
 */
export let DataValidationErrorStyle_$type = markEnum('DataValidationErrorStyle', 'Stop,0|Warning,1|Information,2');
/**
 * Determines what types of cell values are allowed and how the cell value is validated against the constraint(s).
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export var DataValidationCriteria;
(function (DataValidationCriteria) {
  /**
   * Only numbers are allowed and they cannot have a fractional part.
   * When comparing against constraints, the cell value is used.
   */
  DataValidationCriteria[DataValidationCriteria["WholeNumber"] = 1] = "WholeNumber";
  /**
   * Only numbers are allowed.
   * When comparing against constraints, the cell value is used.
   */
  DataValidationCriteria[DataValidationCriteria["Decimal"] = 2] = "Decimal";
  /**
   * Dates with or without time portions are allowed as well as numbers equivalent to valid dates.
   * When comparing against constraints, the cell value is used.
   */
  DataValidationCriteria[DataValidationCriteria["Date"] = 4] = "Date";
  /**
   * Times are allowed are well as numbers equivalent to valid times without a date portion.
   * When comparing against constraints, the cell value is used.
   */
  DataValidationCriteria[DataValidationCriteria["Time"] = 5] = "Time";
  /**
   * Non-error values are allowed.
   * When comparing against constraints, the length of the cell value's text equivalent is used.
   */
  DataValidationCriteria[DataValidationCriteria["TextLength"] = 6] = "TextLength";
})(DataValidationCriteria || (DataValidationCriteria = {}));
/**
 * @hidden
 */
export let DataValidationCriteria_$type = markEnum('DataValidationCriteria', 'WholeNumber,1|Decimal,2|Date,4|Time,5|TextLength,6');
/**
 * @hidden
 */
export let WorksheetChart_BitValues_$type = markEnum('WorksheetChart_BitValues', 'AutoScaling,1|IsInitializing,2|PlotByRows,4|PlotVisibleOnly,8|RightAngleAxes,16|VaryColors,32');
/**
 * @hidden
 */
export let SeriesChartTypeGroup_$type = markEnum('SeriesChartTypeGroup', 'Unsupported,0|Area,1|AreaStacked,2|AreaStacked100,3|BarClustered,4|BarStacked,5|BarStacked100,6|ColClustered,7|ColStacked,8|ColStacked100,9|Line,10|LineStacked,11|LineStacked100,12|Pie,13|PieOfPie,14|BarOfPie,15|Doughnut,16|Radar,17|RadarFilled,18|ScatterStraight,19|ScatterSmooth,20');
/**
 * @hidden
 */
export let GroupSeriesMajorType_$type = markEnum('GroupSeriesMajorType', 'Undefined,0|Area,1|Bar,2|Column,3|Line,4|Pie,5|Radar,6|Scatter,7');
/**
 * @hidden
 */
export let GroupSeriesType_$type = markEnum('GroupSeriesType', 'Undefined,0|Area,1|AreaStacked,2|AreaStacked100,3|Bar,4|BarStacked,5|BarStacked100,6|Column,7|ColumnStacked,8|ColumnStacked100,9|Line,10|LineStacked,11|LineStacked100,12|Pie,13|Radar,14|Scatter,15');
/**
 * @hidden
 */
export let StackedType_$type = markEnum('StackedType', 'NotApplicable,0|Normal,1|Stacked,2|Stacked100,3');
/**
 * @hidden
 */
export let WorkbookColorInfo_ColorInfoState_$type = markEnum('WorkbookColorInfo_ColorInfoState', 'IsAutomatic,1|IsRGB,2|IsThemeColor,4|IsTintValid,8|HasTransform,16');
/**
 * @hidden
 */
export let IGVerticalTextAlignment_$type = markEnum('IGVerticalTextAlignment', 'Top,0|Center,1|Bottom,2|Justify,3|Distributed,4');
/**
 * @hidden
 */
export let IGTextAlignment_$type = markEnum('IGTextAlignment', 'Left,0|Right,1|Center,2|Justify,3|Distributed,4|Fill,5');
/**
 * @hidden
 */
export let DueDate_$type = markEnum('DueDate', 'EndOfPeriod,0|BegOfPeriod,1');
/**
 * @hidden
 */
export let FirstWeekOfYear_$type = markEnum('FirstWeekOfYear', 'System,0|Jan1,1|FirstFourDays,2|FirstFullWeek,3');
/**
 * @hidden
 */
export let DateInterval_$type = markEnum('DateInterval', 'Year,0|Quarter,1|Month,2|DayOfYear,3|Day,4|WeekOfYear,5|Weekday,6|Hour,7|Minute,8|Second,9');
/**
 * @hidden
 */
export let FirstDayOfWeek_$type = markEnum('FirstDayOfWeek', 'System,0|Sunday,1|Monday,2|Tuesday,3|Wednesday,4|Thursday,5|Friday,6|Saturday,7');
/**
 * @hidden
 */
export let UnicodeCategory_$type = markEnum('UnicodeCategory', 'UppercaseLetter,0|LowercaseLetter,1|TitlecaseLetter,2|ModifierLetter,3|OtherLetter,4|NonSpacingMark,5|SpacingCombiningMark,6|EnclosingMark,7|DecimalDigitNumber,8|LetterNumber,9|OtherNumber,10|SpaceSeparator,11|LineSeparator,12|ParagraphSeparator,13|Control,14|Format,15|Surrogate,16|PrivateUse,17|ConnectorPunctuation,18|DashPunctuation,19|OpenPunctuation,20|ClosePunctuation,21|InitialQuotePunctuation,22|FinalQuotePunctuation,23|OtherPunctuation,24|MathSymbol,25|CurrencySymbol,26|ModifierSymbol,27|OtherSymbol,28|OtherNotAssigned,29');
/**
 * @hidden
 */
export let GregorianCalendarTypes_$type = markEnum('GregorianCalendarTypes', 'Localized,1|USEnglish,2|MiddleEastFrench,9|Arabic,10|TransliteratedEnglish,11|TransliteratedFrench,12');
/**
 * Represents an arithmetic error.
 */
export class ArithmeticException extends SystemException {
  constructor(message, innerException) {
    super(2, message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
ArithmeticException.$t = markType(ArithmeticException, 'ArithmeticException', SystemException.$);
/**
 * Represents an error in which a division by zero occurred during calculations.
 */
export class DivideByZeroException extends ArithmeticException {
  constructor(message, innerException) {
    super(message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
DivideByZeroException.$t = markType(DivideByZeroException, 'DivideByZeroException', ArithmeticException.$);
/**
 * Represents an error in which an attempt was made to treat a value as the wrong type.
 */
export class InvalidCastException extends SystemException {
  constructor(message, innerException) {
    super(2, message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
InvalidCastException.$t = markType(InvalidCastException, 'InvalidCastException', SystemException.$);
/**
 * @hidden
 */
export class Colors extends Base {
  static get a() {
    return Color.u(255, 0, 0, 0);
  }
  static get b() {
    return Color.u(255, 0, 0, 255);
  }
  static get c() {
    return Color.u(255, 165, 42, 42);
  }
  static get d() {
    return Color.u(255, 0, 255, 255);
  }
  static get e() {
    return Color.u(255, 169, 169, 169);
  }
  static get f() {
    return Color.u(255, 128, 128, 128);
  }
  static get g() {
    return Color.u(255, 0, 128, 0);
  }
  static get h() {
    return Color.u(255, 173, 255, 47);
  }
  static get i() {
    return Color.u(255, 240, 255, 240);
  }
  static get j() {
    return Color.u(255, 211, 211, 211);
  }
  static get k() {
    return Color.u(255, 255, 0, 255);
  }
  static get l() {
    return Color.u(255, 255, 165, 0);
  }
  static get m() {
    return Color.u(255, 255, 192, 203);
  }
  static get n() {
    return Color.u(255, 128, 0, 128);
  }
  static get o() {
    return Color.u(255, 255, 0, 0);
  }
  static get p() {
    return Color.u(255, 65, 105, 225);
  }
  static get q() {
    return Color.u(255, 0, 128, 128);
  }
  static get r() {
    return Color.u(0, 255, 255, 255);
  }
  static get s() {
    return Color.u(255, 245, 222, 179);
  }
  static get t() {
    return Color.u(255, 255, 255, 255);
  }
  static get u() {
    return Color.u(255, 255, 255, 0);
  }
}
Colors.$t = markType(Colors, 'Colors');
/**
 * @hidden
 */
export class ImageSource extends DependencyObject {
}
ImageSource.$t = markType(ImageSource, 'ImageSource', DependencyObject.$);
/**
 * @hidden
 */
export class BitmapSource extends ImageSource {
  constructor(a, b) {
    super();
    this._j = 0;
    this._k = 0;
    this._k = a;
    this._j = b;
  }
}
BitmapSource.$t = markType(BitmapSource, 'BitmapSource', ImageSource.$);
/**
 * @hidden
 */
export class WBitmap extends BitmapSource {
  constructor(a, b) {
    super(a, b);
    this._l = null;
    this._l = new Array(a * b);
  }
  get _pixels() {
    return this._l;
  }
  _n() {
  }
}
WBitmap.$t = markType(WBitmap, 'WBitmap', BitmapSource.$);
/**
 * Represents an error in I/O processing.
 */
export class IOException extends SystemException {
  constructor(message, innerException) {
    super(2, message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
IOException.$t = markType(IOException, 'IOException', SystemException.$);
/**
 * Represents an error in which an attempt was made to read past the end of a stream of data.
 */
export class EndOfStreamException extends IOException {
  constructor(message, innerException) {
    super(message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
EndOfStreamException.$t = markType(EndOfStreamException, 'EndOfStreamException', IOException.$);
/**
 * @hidden
 */
export class CharUnicodeInfo extends Base {
  static staticInit() {
    let a = "\\p{Lo}";
    CharUnicodeInfo.k = unicode_hack(a);
  }
  static g(a) {
    throw new NotImplementedException(0);
  }
  static h(a, b) {
    return CharUnicodeInfo.g(a.charAt(b));
  }
  static i(a) {
    throw new NotImplementedException(0);
  }
  static j(a, b) {
    return CharUnicodeInfo.i(a.charAt(b));
  }
  static c(a) {
    throw new NotImplementedException(0);
  }
  static d(a, b) {
    return CharUnicodeInfo.c(a.charAt(b));
  }
  static e(a) {
    if (CharUnicodeInfo.a("Lu", a)) {
      return 0;
    }
    if (CharUnicodeInfo.a("Ll", a)) {
      return 1;
    }
    if (CharUnicodeInfo.a("Lt", a)) {
      return 2;
    }
    if (CharUnicodeInfo.a("Lm", a)) {
      return 3;
    }
    if (CharUnicodeInfo.a("Lo", a)) {
      return 4;
    }
    if (CharUnicodeInfo.a("Mn", a)) {
      return 5;
    }
    if (CharUnicodeInfo.a("Mc", a)) {
      return 6;
    }
    if (CharUnicodeInfo.a("Me", a)) {
      return 7;
    }
    if (CharUnicodeInfo.a("Nd", a)) {
      return 8;
    }
    if (CharUnicodeInfo.a("Nl", a)) {
      return 9;
    }
    if (CharUnicodeInfo.a("No", a)) {
      return 10;
    }
    if (CharUnicodeInfo.a("Zs", a)) {
      return 11;
    }
    if (CharUnicodeInfo.a("Zl", a)) {
      return 12;
    }
    if (CharUnicodeInfo.a("Zp", a)) {
      return 13;
    }
    if (CharUnicodeInfo.a("Cc", a)) {
      return 14;
    }
    if (CharUnicodeInfo.a("Cf", a)) {
      return 15;
    }
    if (CharUnicodeInfo.a("Cs", a)) {
      return 16;
    }
    if (CharUnicodeInfo.a("Co", a)) {
      return 17;
    }
    if (CharUnicodeInfo.a("Pc", a)) {
      return 18;
    }
    if (CharUnicodeInfo.a("Pd", a)) {
      return 19;
    }
    if (CharUnicodeInfo.a("Ps", a)) {
      return 20;
    }
    if (CharUnicodeInfo.a("Pe", a)) {
      return 21;
    }
    if (CharUnicodeInfo.a("Pi", a)) {
      return 22;
    }
    if (CharUnicodeInfo.a("Pf", a)) {
      return 23;
    }
    if (CharUnicodeInfo.a("Po", a)) {
      return 24;
    }
    if (CharUnicodeInfo.a("Sm", a)) {
      return 25;
    }
    if (CharUnicodeInfo.a("Sc", a)) {
      return 26;
    }
    if (CharUnicodeInfo.a("So", a)) {
      return 28;
    }
    if (CharUnicodeInfo.a("Sk", a)) {
      return 27;
    }
    return 29;
  }
  static a(a, b) {
    let c = "\\p{" + a + "}";
    return (unicode_hack(c).test(b));
  }
  static f(a, b) {
    return CharUnicodeInfo.e(a.charAt(b));
  }
  static b(a) {
    return (CharUnicodeInfo.k.test(a));
  }
}
CharUnicodeInfo.$t = markType(CharUnicodeInfo, 'CharUnicodeInfo');
CharUnicodeInfo.k = null;
/**
 * @hidden
 */
export class GregorianCalendar extends Calendar {
  constructor(a, ..._rest) {
    super();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
        }
        break;
    }
  }
}
GregorianCalendar.$t = markType(GregorianCalendar, 'GregorianCalendar', Calendar.$);
/**
 * @hidden
 */
export class HebrewCalendar extends Calendar {
}
HebrewCalendar.$t = markType(HebrewCalendar, 'HebrewCalendar', Calendar.$);
/**
 * @hidden
 */
export class HijriCalendar extends Calendar {
}
HijriCalendar.$t = markType(HijriCalendar, 'HijriCalendar', Calendar.$);
/**
 * @hidden
 */
export class CalendarEraInfo extends Base {
  constructor(a, b, c, d, e, f, g, h, i, j) {
    super();
    this.b = 0;
    this.a = new Date();
    this.e = 0;
    this.g = 0;
    this.f = 0;
    this.j = null;
    this.h = null;
    this.i = null;
    this.b = a;
    this.a = dateFromValues(b, c, d, 0, 0, 0, 0);
    this.e = e;
    this.g = f;
    this.f = g;
    this.j = h;
    this.h = i;
    this.i = j;
  }
  static c(a, b) {
    for (let c = 0; c < a.length; c++) {
      if (b == a[c].b) {
        return c;
      }
    }
    return -1;
  }
  static d(a, b, c) {
    let d = CalendarEraInfo.c(a, c);
    if (d < 0) {
      throw new ArgumentOutOfRangeException(0);
    }
    let e = a[d];
    if (b < e.g || e.f < b) {
      throw new ArgumentOutOfRangeException(0);
    }
    return e.e + b;
  }
}
CalendarEraInfo.$t = markType(CalendarEraInfo, 'CalendarEraInfo');
/**
 * @hidden
 */
export class JapaneseCalendar extends Calendar {
  static staticInit() {
    JapaneseCalendar._l = [4, 3, 2, 1];
    let a = new List$1(CalendarEraInfo.$, 0);
    a.add(new CalendarEraInfo(4, 1989, 1, 8, 1988, 1, 8011, "", "", "H"));
    a.add(new CalendarEraInfo(3, 1926, 12, 25, 1925, 1, 64, "", "", "S"));
    a.add(new CalendarEraInfo(2, 1912, 7, 30, 1911, 1, 15, "", "", "T"));
    a.add(new CalendarEraInfo(1, 1868, 1, 1, 1867, 1, 45, "", "", "M"));
    JapaneseCalendar._k = a.toArray();
  }
  _getEraInfo(a) {
    let b = CalendarEraInfo.c(JapaneseCalendar._k, a);
    return b < 0 ? null : JapaneseCalendar._k[b];
  }
  get_eras() {
    return JapaneseCalendar._l;
  }
  addMonths(a, b) {
    let c = super.addMonths(a, b);
    if (c < JapaneseCalendar._m) {
      throw new ArgumentException(0);
    }
    return c;
  }
  addYears(a, b) {
    let c = super.addYears(a, b);
    if (c < JapaneseCalendar._m) {
      throw new ArgumentException(0);
    }
    return c;
  }
  getDaysInMonth(a, b, c) {
    let d = CalendarEraInfo.d(JapaneseCalendar._k, a, c);
    return super.getDaysInMonth(d, b, 0);
  }
  getDaysInYear(a, b) {
    let c = CalendarEraInfo.d(JapaneseCalendar._k, a, b);
    return c % 4 != 0 || (c % 100 == 0 && c % 400 != 0) ? 365 : 366;
  }
  getEra(a) {
    for (let b = 0; b < JapaneseCalendar._k.length; b++) {
      if (JapaneseCalendar._k[b].a <= a) {
        return JapaneseCalendar._k[b].b;
      }
    }
    throw new ArgumentOutOfRangeException(0);
  }
  getYear(a) {
    for (let b = 0; b < JapaneseCalendar._k.length; b++) {
      if (JapaneseCalendar._k[b].a <= a) {
        return super.getYear(a) - JapaneseCalendar._k[b].e;
      }
    }
    throw new ArgumentOutOfRangeException(0);
  }
  toDateTime(a, b, c, d, e, f, g, h) {
    let i = CalendarEraInfo.d(JapaneseCalendar._k, a, h);
    let j = dateFromValues(i, b, c, d, e, f, g);
    if (j < JapaneseCalendar._m) {
      throw new ArgumentOutOfRangeException(0);
    }
    return j;
  }
}
JapaneseCalendar.$t = markType(JapaneseCalendar, 'JapaneseCalendar', Calendar.$);
JapaneseCalendar._l = null;
JapaneseCalendar._k = null;
JapaneseCalendar._m = dateFromValues(1868, 9, 8, 0, 0, 0, 0);
/**
 * @hidden
 */
export class KoreanCalendar extends Calendar {
}
KoreanCalendar.$t = markType(KoreanCalendar, 'KoreanCalendar', Calendar.$);
/**
 * @hidden
 */
export class TaiwanCalendar extends Calendar {
}
TaiwanCalendar.$t = markType(TaiwanCalendar, 'TaiwanCalendar', Calendar.$);
/**
 * @hidden
 */
export class ThaiBuddhistCalendar extends Calendar {
}
ThaiBuddhistCalendar.$t = markType(ThaiBuddhistCalendar, 'ThaiBuddhistCalendar', Calendar.$);
/**
 * @hidden
 */
export class UmAlQuraCalendar extends Calendar {
}
UmAlQuraCalendar.$t = markType(UmAlQuraCalendar, 'UmAlQuraCalendar', Calendar.$);
/**
 * Represents an error in which a keyed collection was accessed with a key which does not exist in the collection.
 */
export class KeyNotFoundException extends SystemException {
  constructor(message, innerException) {
    super(2, message, innerException);
    message = (message !== void 0 ? message : null);
    innerException = (innerException !== void 0 ? innerException : null);
  }
}
KeyNotFoundException.$t = markType(KeyNotFoundException, 'KeyNotFoundException', SystemException.$);
/**
 * @hidden
 */
export class SortedList$2 extends Base {
  constructor($tKey, $tValue, a, ..._rest) {
    super();
    this.$tKey = null;
    this.$tValue = null;
    this._f = null;
    this._g = null;
    this._i = null;
    this.$tKey = $tKey;
    this.$tValue = $tValue;
    this.$type = this.$type.specialize(this.$tKey, this.$tValue);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = [Comparer$1.defaultComparerValue(this.$tKey)];
          {
            let e = c[0];
            this._f = e;
            this._g = new List$1(this.$tKey, 0);
            this._i = new List$1(this.$tValue, 0);
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          this._f = c;
          this._g = new List$1(this.$tKey, 0);
          this._i = new List$1(this.$tValue, 0);
        }
        break;
    }
  }
  *_getEnumerator() {
    for (let a = 0; a < this._g.count; a++) {
      yield new KeyValuePair$2(this.$tKey, this.$tValue, 1, this._g._inner[a], this._i._inner[a]);
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  _m(a, b) {
    let c = this._g.g(a, this._f);
    if (c < 0) {
      this._g.insert(~c, a);
      this._i.insert(~c, b);
    }
    else {
    }
  }
  _b(a) {
    let b = this._g.g(a, this._f);
    return 0 <= b;
  }
  _l(a) {
    let b = this._g.g(a, this._f);
    if (b < 0) {
      return -1;
    }
    return b;
  }
  _c(a) {
    let b = this._g.g(a, this._f);
    if (b < 0) {
      return false;
    }
    this._n(b);
    return true;
  }
  _n(a) {
    this._g.removeAt(a);
    this._i.removeAt(a);
  }
  _d(a, b) {
    let c = this._g.g(a, this._f);
    if (c < 0) {
      b = Type.getDefaultValue(this.$tValue);
      return {
        ret: false,
        p1: b
      };
    }
    b = this._i._inner[c];
    return {
      ret: true,
      p1: b
    };
  }
  get _e() {
    return this._f;
  }
  get _k() {
    return this._g.count;
  }
  _item(a, b) {
    if (arguments.length === 2) {
      let c = this._g.g(a, this._f);
      if (c < 0) {
        this._g.insert(~c, a);
        this._i.insert(~c, b);
      }
      else {
        this._i._inner[c] = b;
      }
      return b;
    }
    else {
      let b = this._g.g(a, this._f);
      if (b < 0) {
        throw new KeyNotFoundException(null, null);
      }
      return this._i._inner[b];
    }
  }
  get _h() {
    return this._g;
  }
  get _j() {
    return this._i;
  }
}
SortedList$2.$t = markType(SortedList$2, 'SortedList$2', Base.$, [IEnumerable$1_$type.specialize(KeyValuePair$2.$.specialize(0, 1))]);
/**
 * @hidden
 */
export class FinancialUtils extends Base {
  static iPmt(a, b, c, d, e, f) {
    let g = f != 0 ? 2 : 1;
    if ((b <= 0) || (b >= (c + 1))) {
      throw new ArgumentOutOfRangeException(2, "per", ExcelUtils.ef("LE_ArgumentOutOfRangeException_Per"));
    }
    if ((f != 0) && (b == 1)) {
      return 0;
    }
    let h = FinancialUtils.d(a, c, d, e, f);
    if (f != 0) {
      d += h;
    }
    return FinancialUtils.a(a, b - g, h, d, 0) * a;
  }
  static pPmt(a, b, c, d, e, f) {
    if ((b <= 0) || (b >= (c + 1))) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_Per"), "per");
    }
    let g = FinancialUtils.d(a, c, d, e, f);
    let h = FinancialUtils.iPmt(a, b, c, d, e, f);
    return g - h;
  }
  static nPer(a, b, c, d, e) {
    let f;
    if (a <= -1) {
      throw new ArgumentOutOfRangeException(2, "rate", ExcelUtils.ef("LE_ArgumentOutOfRangeException_Rate"));
    }
    if (a == 0) {
      if (b == 0) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_Pmt"), "pmt");
      }
      return -(c + d) / b;
    }
    if (e != 0) {
      f = (b * (1 + a)) / a;
    }
    else {
      f = b / a;
    }
    let g = -d + f;
    let h = c + f;
    if ((g < 0) && (h < 0)) {
      g = -1 * g;
      h = -1 * h;
    }
    else if ((g <= 0) || (h <= 0)) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_NPerFunction"));
    }
    let i = a + 1;
    return (Math.log(g) - Math.log(h)) / Math.log(i);
  }
  static d(a, b, c, d, e) {
    let f;
    if (b == 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NPer"), "nPer");
    }
    if (a == 0) {
      return (-d - c) / b;
    }
    if (e != 0) {
      f = 1 + a;
    }
    else {
      f = 1;
    }
    let g = a + 1;
    let h = Math.pow(g, b);
    return ((-d - (c * h)) / (f * (h - 1))) * a;
  }
  static a(a, b, c, d, e) {
    let f;
    if (a == 0) {
      return -d - (c * b);
    }
    if (e != 0) {
      f = 1 + a;
    }
    else {
      f = 1;
    }
    let g = 1 + a;
    let h = Math.pow(g, b);
    return (-d * h) - (((c / a) * f) * (h - 1));
  }
}
FinancialUtils.$t = markType(FinancialUtils, 'FinancialUtils');
/**
 * @hidden
 */
export class EncodingProperty extends Base {
}
EncodingProperty.$t = markType(EncodingProperty, 'EncodingProperty');
/**
 * @hidden
 */
export let IImageEncoder_$type = new Type(null, 'IImageEncoder');
/**
 * @hidden
 */
export class DefaultStyleHelper extends Base {
  static a(a) {
    DefaultStyleHelper.c(a);
    return null;
  }
  static c(a) {
    let b;
    let c = (d) => ((() => {
      let $ret = new WorksheetTableStyle(d, false);
      $ret._s = true;
      return $ret;
    })());
    let d = (e, f) => e._areaFormats$i._d(null, f);
    let e = (f, g) => {
      f.fill = g;
      return f;
    };
    let f = (g, h) => new CellFillPattern(g, h, 1, false, true);
    let g = (h, i) => new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, h), Nullable$1.toNullable(Number_$type, i), true, true);
    let h = 0.79998168889431442;
    let i = g(9, h);
    let j = f(i, i);
    let k = (l, m) => {
      l.font.colorInfo = m;
      return l;
    };
    let l = (m) => new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, m), Nullable$1.toNullable(Number_$type, null), true, true);
    let m = l(1);
    let n = (o, p, q) => {
      o.topBorderStyle = p;
      o.topBorderColorInfo = q;
      return o;
    };
    let o = 0.39997558519241921;
    let p = g(9, o);
    let q = (r, s, t) => {
      r.leftBorderStyle = s;
      r.leftBorderColorInfo = t;
      return r;
    };
    let r = (s, t, u) => {
      s.bottomBorderStyle = t;
      s.bottomBorderColorInfo = u;
      return s;
    };
    let s = (t, u, v) => {
      t.rightBorderStyle = u;
      t.rightBorderColorInfo = v;
      return t;
    };
    let t = (u, v) => {
      u.font._bold$i = v;
      return u;
    };
    let u = Nullable$1.toNullable(Boolean_$type, true);
    let v = l(9);
    let w = 0.59999389629810485;
    let x = g(9, w);
    let y = f(x, x);
    let z = (aa) => {
      aa._s = false;
      a.add(aa);
    };
    let aa = g(8, h);
    let ab = f(aa, aa);
    let ac = g(8, o);
    let ad = l(8);
    let ae = g(8, w);
    let af = f(ae, ae);
    let ag = g(7, h);
    let ah = f(ag, ag);
    let ai = g(7, o);
    let aj = l(7);
    let ak = g(7, w);
    let al = f(ak, ak);
    let am = g(6, h);
    let an = f(am, am);
    let ao = g(6, o);
    let ap = l(6);
    let aq = g(6, w);
    let ar = f(aq, aq);
    let as = g(5, h);
    let at = f(as, as);
    let au = g(5, o);
    let av = l(5);
    let aw = g(5, w);
    let ax = f(aw, aw);
    let ay = g(4, h);
    let az = f(ay, ay);
    let a0 = g(4, o);
    let a1 = l(4);
    let a2 = g(4, w);
    let a3 = f(a2, a2);
    let a4 = g(0, -0.14999847407452621);
    let a5 = f(a4, a4);
    let a6 = g(0, -0.34998626667073579);
    let a7 = f(a6, a6);
    let a8 = f(v, v);
    let a9 = l(0);
    let ba = f(ad, ad);
    let bb = f(aj, aj);
    let bc = f(ap, ap);
    let bd = f(av, av);
    let be = f(a1, a1);
    let bf = f(m, m);
    let bg = (bh, bi) => {
      bh.formatOptions = bi;
      return bh;
    };
    let bh = 28;
    let bi = -0.249977111117893;
    let bj = g(9, bi);
    let bk = g(8, bi);
    let bl = g(7, bi);
    let bm = g(6, bi);
    let bn = g(5, bi);
    let bo = g(4, bi);
    let bp = -0.499984740745262;
    let bq = g(9, bp);
    let br = f(bq, bq);
    let bs = f(bj, bj);
    let bt = g(8, bp);
    let bu = f(bt, bt);
    let bv = f(bk, bk);
    let bw = g(7, bp);
    let bx = f(bw, bw);
    let by = f(bl, bl);
    let bz = g(6, bp);
    let b0 = f(bz, bz);
    let b1 = f(bm, bm);
    let b2 = g(5, bp);
    let b3 = f(b2, b2);
    let b4 = f(bn, bn);
    let b5 = g(4, bp);
    let b6 = f(b5, b5);
    let b7 = f(bo, bo);
    let b8 = g(1, 0.44999542222357858);
    let b9 = f(b8, b8);
    let ca = g(1, 0.14999847407452621);
    let cb = f(ca, ca);
    let cc = g(1, 0.249977111117893);
    let cd = f(cc, cc);
    b = c("TableStyleMedium28");
    s(r(q(n(k(e(d(b, 0), j), m), 1, p), 1, p), 1, p), 1, p);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, v);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), y);
    e(d(b, 7), y);
    z(b);
    b = c("TableStyleMedium27");
    s(r(q(n(k(e(d(b, 0), ab), m), 1, ac), 1, ac), 1, ac), 1, ac);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, ad);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), af);
    e(d(b, 7), af);
    z(b);
    b = c("TableStyleMedium26");
    s(r(q(n(k(e(d(b, 0), ah), m), 1, ai), 1, ai), 1, ai), 1, ai);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, aj);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), al);
    e(d(b, 7), al);
    z(b);
    b = c("TableStyleMedium25");
    s(r(q(n(k(e(d(b, 0), an), m), 1, ao), 1, ao), 1, ao), 1, ao);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, ap);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ar);
    e(d(b, 7), ar);
    z(b);
    b = c("TableStyleMedium24");
    s(r(q(n(k(e(d(b, 0), at), m), 1, au), 1, au), 1, au), 1, au);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, av);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ax);
    e(d(b, 7), ax);
    z(b);
    b = c("TableStyleMedium23");
    s(r(q(n(k(e(d(b, 0), az), m), 1, a0), 1, a0), 1, a0), 1, a0);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, a1);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a3);
    e(d(b, 7), a3);
    z(b);
    b = c("TableStyleMedium22");
    s(r(q(n(k(e(d(b, 0), a5), m), 1, m), 1, m), 1, m), 1, m);
    k(t(d(b, 1), u), m);
    n(k(t(d(b, 2), u), m), 2, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a7);
    e(d(b, 7), a7);
    z(b);
    b = c("TableStyleMedium21");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), a8), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), a8), u), a9);
    k(t(e(d(b, 4), a8), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium20");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), ba), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), ba), u), a9);
    k(t(e(d(b, 4), ba), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium19");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), bb), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), bb), u), a9);
    k(t(e(d(b, 4), bb), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium18");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), bc), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), bc), u), a9);
    k(t(e(d(b, 4), bc), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium17");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), bd), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), bd), u), a9);
    k(t(e(d(b, 4), bd), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium16");
    r(n(k(d(b, 0), m), 2, m), 2, m);
    r(k(t(e(d(b, 1), be), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), be), u), a9);
    k(t(e(d(b, 4), be), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium15");
    s(r(q(n(k(d(b, 0), m), 2, m), 1, m), 2, m), 1, m);
    r(k(t(e(d(b, 1), bf), u), a9), 2, m);
    n(d(b, 2), 6, m);
    k(t(e(d(b, 3), bf), u), a9);
    k(t(e(d(b, 4), bf), u), a9);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleMedium14");
    bg(k(e(d(b, 0), j), m), bh);
    r(k(t(e(d(b, 1), a8), u), a9), 5, a9);
    n(k(t(e(d(b, 2), a8), u), a9), 5, a9);
    k(t(e(d(b, 3), a8), u), a9);
    k(t(e(d(b, 4), a8), u), a9);
    e(d(b, 5), y);
    e(d(b, 7), y);
    z(b);
    b = c("TableStyleMedium13");
    bg(k(e(d(b, 0), ab), m), bh);
    r(k(t(e(d(b, 1), ba), u), a9), 5, a9);
    n(k(t(e(d(b, 2), ba), u), a9), 5, a9);
    k(t(e(d(b, 3), ba), u), a9);
    k(t(e(d(b, 4), ba), u), a9);
    e(d(b, 5), af);
    e(d(b, 7), af);
    z(b);
    b = c("TableStyleMedium12");
    bg(k(e(d(b, 0), ah), m), bh);
    r(k(t(e(d(b, 1), bb), u), a9), 5, a9);
    n(k(t(e(d(b, 2), bb), u), a9), 5, a9);
    k(t(e(d(b, 3), bb), u), a9);
    k(t(e(d(b, 4), bb), u), a9);
    e(d(b, 5), al);
    e(d(b, 7), al);
    z(b);
    b = c("TableStyleMedium11");
    bg(k(e(d(b, 0), an), m), bh);
    r(k(t(e(d(b, 1), bc), u), a9), 5, a9);
    n(k(t(e(d(b, 2), bc), u), a9), 5, a9);
    k(t(e(d(b, 3), bc), u), a9);
    k(t(e(d(b, 4), bc), u), a9);
    e(d(b, 5), ar);
    e(d(b, 7), ar);
    z(b);
    b = c("TableStyleMedium10");
    bg(k(e(d(b, 0), at), m), bh);
    r(k(t(e(d(b, 1), bd), u), a9), 5, a9);
    n(k(t(e(d(b, 2), bd), u), a9), 5, a9);
    k(t(e(d(b, 3), bd), u), a9);
    k(t(e(d(b, 4), bd), u), a9);
    e(d(b, 5), ax);
    e(d(b, 7), ax);
    z(b);
    b = c("TableStyleMedium9");
    bg(k(e(d(b, 0), az), m), bh);
    r(k(t(e(d(b, 1), be), u), a9), 5, a9);
    n(k(t(e(d(b, 2), be), u), a9), 5, a9);
    k(t(e(d(b, 3), be), u), a9);
    k(t(e(d(b, 4), be), u), a9);
    e(d(b, 5), a3);
    e(d(b, 7), a3);
    z(b);
    b = c("TableStyleMedium8");
    bg(k(e(d(b, 0), a5), m), bh);
    r(k(t(e(d(b, 1), bf), u), a9), 5, a9);
    n(k(t(e(d(b, 2), bf), u), a9), 5, a9);
    k(t(e(d(b, 3), bf), u), a9);
    k(t(e(d(b, 4), bf), u), a9);
    e(d(b, 5), a7);
    e(d(b, 7), a7);
    z(b);
    b = c("TableStyleMedium7");
    s(r(q(n(k(d(b, 0), m), 1, p), 1, p), 1, p), 1, p);
    k(t(e(d(b, 1), a8), u), a9);
    n(k(t(d(b, 2), u), m), 6, v);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), j);
    e(d(b, 7), j);
    z(b);
    b = c("TableStyleMedium6");
    s(r(q(n(k(d(b, 0), m), 1, ac), 1, ac), 1, ac), 1, ac);
    k(t(e(d(b, 1), ba), u), a9);
    n(k(t(d(b, 2), u), m), 6, ad);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ab);
    e(d(b, 7), ab);
    z(b);
    b = c("TableStyleMedium5");
    s(r(q(n(k(d(b, 0), m), 1, ai), 1, ai), 1, ai), 1, ai);
    k(t(e(d(b, 1), bb), u), a9);
    n(k(t(d(b, 2), u), m), 6, aj);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ah);
    e(d(b, 7), ah);
    z(b);
    b = c("TableStyleMedium4");
    s(r(q(n(k(d(b, 0), m), 1, ao), 1, ao), 1, ao), 1, ao);
    k(t(e(d(b, 1), bc), u), a9);
    n(k(t(d(b, 2), u), m), 6, ap);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), an);
    e(d(b, 7), an);
    z(b);
    b = c("TableStyleMedium3");
    s(r(q(n(k(d(b, 0), m), 1, au), 1, au), 1, au), 1, au);
    k(t(e(d(b, 1), bd), u), a9);
    n(k(t(d(b, 2), u), m), 6, av);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), at);
    e(d(b, 7), at);
    z(b);
    b = c("TableStyleMedium2");
    s(r(q(n(k(d(b, 0), m), 1, a0), 1, a0), 1, a0), 1, a0);
    k(t(e(d(b, 1), be), u), a9);
    n(k(t(d(b, 2), u), m), 6, a1);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), az);
    e(d(b, 7), az);
    z(b);
    b = c("TableStyleMedium1");
    s(r(q(n(k(d(b, 0), m), 1, m), 1, m), 1, m), 1, m);
    k(t(e(d(b, 1), bf), u), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleLight21");
    s(r(q(n(k(d(b, 0), m), 1, v), 1, v), 1, v), 1, v);
    r(k(t(d(b, 1), u), m), 2, v);
    n(k(t(d(b, 2), u), m), 6, v);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), j);
    e(d(b, 7), j);
    z(b);
    b = c("TableStyleLight20");
    s(r(q(n(k(d(b, 0), m), 1, ad), 1, ad), 1, ad), 1, ad);
    r(k(t(d(b, 1), u), m), 2, ad);
    n(k(t(d(b, 2), u), m), 6, ad);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ab);
    e(d(b, 7), ab);
    z(b);
    b = c("TableStyleLight19");
    s(r(q(n(k(d(b, 0), m), 1, aj), 1, aj), 1, aj), 1, aj);
    r(k(t(d(b, 1), u), m), 2, aj);
    n(k(t(d(b, 2), u), m), 6, aj);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ah);
    e(d(b, 7), ah);
    z(b);
    b = c("TableStyleLight18");
    s(r(q(n(k(d(b, 0), m), 1, ap), 1, ap), 1, ap), 1, ap);
    r(k(t(d(b, 1), u), m), 2, ap);
    n(k(t(d(b, 2), u), m), 6, ap);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), an);
    e(d(b, 7), an);
    z(b);
    b = c("TableStyleLight17");
    s(r(q(n(k(d(b, 0), m), 1, av), 1, av), 1, av), 1, av);
    r(k(t(d(b, 1), u), m), 2, av);
    n(k(t(d(b, 2), u), m), 6, av);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), at);
    e(d(b, 7), at);
    z(b);
    b = c("TableStyleLight16");
    s(r(q(n(k(d(b, 0), m), 1, a1), 1, a1), 1, a1), 1, a1);
    r(k(t(d(b, 1), u), m), 2, a1);
    n(k(t(d(b, 2), u), m), 6, a1);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), az);
    e(d(b, 7), az);
    z(b);
    b = c("TableStyleLight15");
    s(r(q(n(k(d(b, 0), m), 1, m), 1, m), 1, m), 1, m);
    r(k(t(d(b, 1), u), m), 2, m);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleLight14");
    s(r(q(n(k(d(b, 0), m), 1, v), 1, v), 1, v), 1, v);
    k(t(e(d(b, 1), a8), u), a9);
    n(k(t(d(b, 2), u), m), 6, v);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, v);
    n(d(b, 6), 1, v);
    q(d(b, 7), 1, v);
    q(d(b, 8), 1, v);
    z(b);
    b = c("TableStyleLight13");
    s(r(q(n(k(d(b, 0), m), 1, ad), 1, ad), 1, ad), 1, ad);
    k(t(e(d(b, 1), ba), u), a9);
    n(k(t(d(b, 2), u), m), 6, ad);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, ad);
    n(d(b, 6), 1, ad);
    q(d(b, 7), 1, ad);
    q(d(b, 8), 1, ad);
    z(b);
    b = c("TableStyleLight12");
    s(r(q(n(k(d(b, 0), m), 1, aj), 1, aj), 1, aj), 1, aj);
    k(t(e(d(b, 1), bb), u), a9);
    n(k(t(d(b, 2), u), m), 6, aj);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, aj);
    n(d(b, 6), 1, aj);
    q(d(b, 7), 1, aj);
    q(d(b, 8), 1, aj);
    z(b);
    b = c("TableStyleLight11");
    s(r(q(n(k(d(b, 0), m), 1, ap), 1, ap), 1, ap), 1, ap);
    k(t(e(d(b, 1), bc), u), a9);
    n(k(t(d(b, 2), u), m), 6, ap);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, ap);
    n(d(b, 6), 1, ap);
    q(d(b, 7), 1, ap);
    q(d(b, 8), 1, ap);
    z(b);
    b = c("TableStyleLight10");
    s(r(q(n(k(d(b, 0), m), 1, av), 1, av), 1, av), 1, av);
    k(t(e(d(b, 1), bd), u), a9);
    n(k(t(d(b, 2), u), m), 6, av);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, av);
    n(d(b, 6), 1, av);
    q(d(b, 7), 1, av);
    q(d(b, 8), 1, av);
    z(b);
    b = c("TableStyleLight9");
    s(r(q(n(k(d(b, 0), m), 1, a1), 1, a1), 1, a1), 1, a1);
    k(t(e(d(b, 1), be), u), a9);
    n(k(t(d(b, 2), u), m), 6, a1);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, a1);
    n(d(b, 6), 1, a1);
    q(d(b, 7), 1, a1);
    q(d(b, 8), 1, a1);
    z(b);
    b = c("TableStyleLight8");
    s(r(q(n(k(d(b, 0), m), 1, m), 1, m), 1, m), 1, m);
    k(t(e(d(b, 1), bf), u), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    n(d(b, 5), 1, m);
    n(d(b, 6), 1, m);
    q(d(b, 7), 1, m);
    q(d(b, 8), 1, m);
    z(b);
    b = c("TableStyleLight7");
    r(n(k(d(b, 0), bj), 1, v), 1, v);
    r(k(t(d(b, 1), u), bj), 1, v);
    n(k(t(d(b, 2), u), bj), 1, v);
    k(t(d(b, 3), u), bj);
    k(t(d(b, 4), u), bj);
    e(d(b, 5), j);
    e(d(b, 7), j);
    z(b);
    b = c("TableStyleLight6");
    r(n(k(d(b, 0), bk), 1, ad), 1, ad);
    r(k(t(d(b, 1), u), bk), 1, ad);
    n(k(t(d(b, 2), u), bk), 1, ad);
    k(t(d(b, 3), u), bk);
    k(t(d(b, 4), u), bk);
    e(d(b, 5), ab);
    e(d(b, 7), ab);
    z(b);
    b = c("TableStyleLight5");
    r(n(k(d(b, 0), bl), 1, aj), 1, aj);
    r(k(t(d(b, 1), u), bl), 1, aj);
    n(k(t(d(b, 2), u), bl), 1, aj);
    k(t(d(b, 3), u), bl);
    k(t(d(b, 4), u), bl);
    e(d(b, 5), ah);
    e(d(b, 7), ah);
    z(b);
    b = c("TableStyleLight4");
    r(n(k(d(b, 0), bm), 1, ap), 1, ap);
    r(k(t(d(b, 1), u), bm), 1, ap);
    n(k(t(d(b, 2), u), bm), 1, ap);
    k(t(d(b, 3), u), bm);
    k(t(d(b, 4), u), bm);
    e(d(b, 5), an);
    e(d(b, 7), an);
    z(b);
    b = c("TableStyleLight3");
    r(n(k(d(b, 0), bn), 1, av), 1, av);
    r(k(t(d(b, 1), u), bn), 1, av);
    n(k(t(d(b, 2), u), bn), 1, av);
    k(t(d(b, 3), u), bn);
    k(t(d(b, 4), u), bn);
    e(d(b, 5), at);
    e(d(b, 7), at);
    z(b);
    b = c("TableStyleLight2");
    r(n(k(d(b, 0), bo), 1, a1), 1, a1);
    r(k(t(d(b, 1), u), bo), 1, a1);
    n(k(t(d(b, 2), u), bo), 1, a1);
    k(t(d(b, 3), u), bo);
    k(t(d(b, 4), u), bo);
    e(d(b, 5), az);
    e(d(b, 7), az);
    z(b);
    b = c("TableStyleLight1");
    r(n(k(d(b, 0), m), 1, m), 1, m);
    r(k(t(d(b, 1), u), m), 1, m);
    n(k(t(d(b, 2), u), m), 1, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a5);
    e(d(b, 7), a5);
    z(b);
    b = c("TableStyleDark11");
    e(d(b, 0), ab);
    k(e(d(b, 1), a8), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), af);
    e(d(b, 7), af);
    z(b);
    b = c("TableStyleDark10");
    e(d(b, 0), an);
    k(e(d(b, 1), bb), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), ar);
    e(d(b, 7), ar);
    z(b);
    b = c("TableStyleDark9");
    e(d(b, 0), az);
    k(e(d(b, 1), bd), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a3);
    e(d(b, 7), a3);
    z(b);
    b = c("TableStyleDark8");
    e(d(b, 0), a5);
    k(e(d(b, 1), bf), a9);
    n(k(t(d(b, 2), u), m), 6, m);
    k(t(d(b, 3), u), m);
    k(t(d(b, 4), u), m);
    e(d(b, 5), a7);
    e(d(b, 7), a7);
    z(b);
    b = c("TableStyleDark7");
    k(e(d(b, 0), a8), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), br), u), a9), 2, a9);
    s(k(t(e(d(b, 3), bs), u), a9), 2, a9);
    q(k(t(e(d(b, 4), bs), u), a9), 2, a9);
    e(d(b, 5), bs);
    e(d(b, 7), bs);
    z(b);
    b = c("TableStyleDark6");
    k(e(d(b, 0), ba), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), bu), u), a9), 2, a9);
    s(k(t(e(d(b, 3), bv), u), a9), 2, a9);
    q(k(t(e(d(b, 4), bv), u), a9), 2, a9);
    e(d(b, 5), bv);
    e(d(b, 7), bv);
    z(b);
    b = c("TableStyleDark5");
    k(e(d(b, 0), bb), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), bx), u), a9), 2, a9);
    s(k(t(e(d(b, 3), by), u), a9), 2, a9);
    q(k(t(e(d(b, 4), by), u), a9), 2, a9);
    e(d(b, 5), by);
    e(d(b, 7), by);
    z(b);
    b = c("TableStyleDark4");
    k(e(d(b, 0), bc), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), b0), u), a9), 2, a9);
    s(k(t(e(d(b, 3), b1), u), a9), 2, a9);
    q(k(t(e(d(b, 4), b1), u), a9), 2, a9);
    e(d(b, 5), b1);
    e(d(b, 7), b1);
    z(b);
    b = c("TableStyleDark3");
    k(e(d(b, 0), bd), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), b3), u), a9), 2, a9);
    s(k(t(e(d(b, 3), b4), u), a9), 2, a9);
    q(k(t(e(d(b, 4), b4), u), a9), 2, a9);
    e(d(b, 5), b4);
    e(d(b, 7), b4);
    z(b);
    b = c("TableStyleDark2");
    k(e(d(b, 0), be), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), b6), u), a9), 2, a9);
    s(k(t(e(d(b, 3), b7), u), a9), 2, a9);
    q(k(t(e(d(b, 4), b7), u), a9), 2, a9);
    e(d(b, 5), b7);
    e(d(b, 7), b7);
    z(b);
    b = c("TableStyleDark1");
    k(e(d(b, 0), b9), a9);
    r(k(t(e(d(b, 1), bf), u), a9), 2, a9);
    n(k(t(e(d(b, 2), cb), u), a9), 2, a9);
    s(k(t(e(d(b, 3), cd), u), a9), 2, a9);
    q(k(t(e(d(b, 4), cd), u), a9), 2, a9);
    e(d(b, 5), cd);
    e(d(b, 7), cd);
    z(b);
  }
  static b(a) {
    let b = (c) => new WorksheetCellFormatData(c, 1);
    let c = new Workbook(2);
    let d = (e, f) => {
      e.font.setFontFormatting(f);
      return e;
    };
    let e = Nullable$1.toNullable(Boolean_$type, false);
    let f = (g) => new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, g), Nullable$1.toNullable(Number_$type, null), true, true);
    let g = f(1);
    let h = 220;
    let i = "Calibri";
    let j = 0;
    let k = 0;
    let l = (m, n, o, p, q, r, s, t) => {
      let u = new WorkbookFontData(0, null);
      u._bold$i = m;
      u.colorInfo = n;
      u.height = o;
      u._italic$i = p;
      u.name = q;
      u._strikeout$i = r;
      u.superscriptSubscriptStyle = s;
      u.underlineStyle = t;
      return u;
    };
    let m = l(e, g, h, e, i, e, j, k);
    let n = (o, p) => {
      o.fill = p;
      return o;
    };
    let o = (p, q) => {
      p.formatString = q;
      return p;
    };
    let p = (q, r, s) => {
      let t = r;
      q.bottomBorderStyle = t;
      q.topBorderStyle = t;
      q.rightBorderStyle = t;
      q.leftBorderStyle = t;
      q.bottomBorderColorInfo = s;
      q.topBorderColorInfo = s;
      q.rightBorderColorInfo = s;
      q.leftBorderColorInfo = s;
      return q;
    };
    let q = (r, s, t, u) => {
      r.diagonalBorderStyle = s;
      r.diagonalBorderColorInfo = t;
      r.diagonalBorders = u;
      return r;
    };
    let r = 1;
    let s = (t, u) => {
      t.formatOptions = u;
      return t;
    };
    let t = (u, v, w, x) => a.add(new WorkbookBuiltInStyle(u, v, w, x));
    let u = 255;
    let v = Nullable$1.toNullable(Boolean_$type, true);
    let w = l(v, g, h, e, i, e, j, k);
    let x = l(e, g, h, v, i, e, j, k);
    let y = f(10);
    let z = 1;
    let aa = l(e, y, h, e, i, e, j, z);
    let ab = f(11);
    let ac = l(e, ab, h, e, i, e, j, z);
    let ad = (ae, af) => new CellFillPattern(ae, af, 1, false, true);
    let ae = (af) => new WorkbookColorInfo(Nullable$1.toNullable(Color.$, af), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), true, true);
    let af = ExcelUtils.gx;
    let ag = af(-52);
    let ah = ae(ag);
    let ai = ae(SystemColorsInternal.bb);
    let aj = ad(ah, ai);
    let ak = af(-5066062);
    let al = ae(ak);
    let am = af(-65536);
    let an = ae(am);
    let ao = l(e, an, h, e, i, e, j, k);
    let ap = f(3);
    let aq = l(v, ap, 360, e, "Cambria", e, j, k);
    let ar = l(v, ap, 300, e, i, e, j, k);
    let as = (at, au, av) => {
      at.topBorderStyle = au;
      at.topBorderColorInfo = av;
      return at;
    };
    let at = (au, av, aw) => {
      au.leftBorderStyle = av;
      au.leftBorderColorInfo = aw;
      return au;
    };
    let au = (av, aw, ax) => {
      av.bottomBorderStyle = aw;
      av.bottomBorderColorInfo = ax;
      return av;
    };
    let av = f(4);
    let aw = (ax, ay, az) => {
      ax.rightBorderStyle = ay;
      ax.rightBorderColorInfo = az;
      return ax;
    };
    let ax = l(v, ap, 260, e, i, e, j, k);
    let ay = (az, a0) => new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, az), Nullable$1.toNullable(Number_$type, a0), true, true);
    let az = ay(4, 0.499984740745262);
    let a0 = l(v, ap, h, e, i, e, j, k);
    let a1 = 0.39997558519241921;
    let a2 = ay(4, a1);
    let a3 = af(-12632202);
    let a4 = ae(a3);
    let a5 = l(e, a4, h, e, i, e, j, k);
    let a6 = af(-13159);
    let a7 = ae(a6);
    let a8 = ad(a7, ai);
    let a9 = af(-8421505);
    let ba = ae(a9);
    let bb = af(-12632257);
    let bc = ae(bb);
    let bd = l(v, bc, h, e, i, e, j, k);
    let be = af(-855310);
    let bf = ae(be);
    let bg = ad(bf, ai);
    let bh = af(-361216);
    let bi = ae(bh);
    let bj = l(v, bi, h, e, i, e, j, k);
    let bk = f(0);
    let bl = l(v, bk, h, e, i, e, j, k);
    let bm = af(-5921371);
    let bn = ae(bm);
    let bo = ad(bn, ai);
    let bp = l(e, bi, h, e, i, e, j, k);
    let bq = af(-32767);
    let br = ae(bq);
    let bs = af(-16752384);
    let bt = ae(bs);
    let bu = l(e, bt, h, e, i, e, j, k);
    let bv = af(-3739698);
    let bw = ae(bv);
    let bx = ad(bw, ai);
    let by = af(-6553594);
    let bz = ae(by);
    let b0 = l(e, bz, h, e, i, e, j, k);
    let b1 = af(-14386);
    let b2 = ae(b1);
    let b3 = ad(b2, ai);
    let b4 = af(-6527744);
    let b5 = ae(b4);
    let b6 = l(e, b5, h, e, i, e, j, k);
    let b7 = af(-5220);
    let b8 = ae(b7);
    let b9 = ad(b8, ai);
    let ca = l(e, bk, h, e, i, e, j, k);
    let cb = ad(av, ai);
    let cc = 0.79998168889431442;
    let cd = ay(4, cc);
    let ce = ad(cd, ai);
    let cf = 0.59999389629810485;
    let cg = ay(4, cf);
    let ch = ad(cg, ai);
    let ci = ad(a2, ai);
    let cj = f(5);
    let ck = ad(cj, ai);
    let cl = ay(5, cc);
    let cm = ad(cl, ai);
    let cn = ay(5, cf);
    let co = ad(cn, ai);
    let cp = ay(5, a1);
    let cq = ad(cp, ai);
    let cr = f(6);
    let cs = ad(cr, ai);
    let ct = ay(6, cc);
    let cu = ad(ct, ai);
    let cv = ay(6, cf);
    let cw = ad(cv, ai);
    let cx = ay(6, a1);
    let cy = ad(cx, ai);
    let cz = f(7);
    let c0 = ad(cz, ai);
    let c1 = ay(7, cc);
    let c2 = ad(c1, ai);
    let c3 = ay(7, cf);
    let c4 = ad(c3, ai);
    let c5 = ay(7, a1);
    let c6 = ad(c5, ai);
    let c7 = f(8);
    let c8 = ad(c7, ai);
    let c9 = ay(8, cc);
    let da = ad(c9, ai);
    let db = ay(8, cf);
    let dc = ad(db, ai);
    let dd = ay(8, a1);
    let de = ad(dd, ai);
    let df = f(9);
    let dg = ad(df, ai);
    let dh = ay(9, cc);
    let di = ad(dh, ai);
    let dj = ay(9, cf);
    let dk = ad(dj, ai);
    let dl = ay(9, a1);
    let dm = ad(dl, ai);
    let dn = l(e, ba, h, v, i, e, j, k);
    t(c, s(q(p(o(n(d(b(c), m), CellFill.noColor), "General"), 0, null), 0, null, r), 63), 0, u);
    t(c, d(b(c), w), 1, 0);
    t(c, d(b(c), w), 2, 0);
    t(c, d(b(c), x), 1, 1);
    t(c, d(b(c), x), 2, 1);
    t(c, d(b(c), m), 1, 2);
    t(c, d(b(c), m), 2, 2);
    t(c, d(b(c), m), 1, 3);
    t(c, d(b(c), m), 2, 3);
    t(c, d(b(c), m), 1, 4);
    t(c, d(b(c), m), 2, 4);
    t(c, d(b(c), m), 1, 5);
    t(c, d(b(c), m), 2, 5);
    t(c, d(b(c), m), 1, 6);
    t(c, d(b(c), m), 2, 6);
    t(c, o(b(c), "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)"), 3, u);
    t(c, o(b(c), "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)"), 4, u);
    t(c, o(b(c), "0%"), 5, u);
    t(c, o(b(c), "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)"), 6, u);
    t(c, o(b(c), "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)"), 7, u);
    t(c, d(b(c), aa), 8, u);
    t(c, d(b(c), ac), 9, u);
    t(c, q(p(n(b(c), aj), 1, al), 0, null, r), 10, u);
    t(c, d(b(c), ao), 11, u);
    t(c, d(b(c), aq), 15, u);
    t(c, q(aw(au(at(as(d(b(c), ar), 0, null), 0, null), 5, av), 0, null), 0, null, r), 16, u);
    t(c, q(aw(au(at(as(d(b(c), ax), 0, null), 0, null), 5, az), 0, null), 0, null, r), 17, u);
    t(c, q(aw(au(at(as(d(b(c), a0), 0, null), 0, null), 2, a2), 0, null), 0, null, r), 18, u);
    t(c, d(b(c), a0), 19, u);
    t(c, q(p(n(d(b(c), a5), a8), 1, ba), 0, null, r), 20, u);
    t(c, q(p(n(d(b(c), bd), bg), 1, bc), 0, null, r), 21, u);
    t(c, q(p(n(d(b(c), bj), bg), 1, ba), 0, null, r), 22, u);
    t(c, q(p(n(d(b(c), bl), bo), 6, bc), 0, null, r), 23, u);
    t(c, q(aw(au(at(as(d(b(c), bp), 0, null), 0, null), 6, br), 0, null), 0, null, r), 24, u);
    t(c, q(aw(au(at(as(d(b(c), w), 1, av), 0, null), 6, av), 0, null), 0, null, r), 25, u);
    t(c, n(d(b(c), bu), bx), 26, u);
    t(c, n(d(b(c), b0), b3), 27, u);
    t(c, n(d(b(c), b6), b9), 28, u);
    t(c, n(d(b(c), ca), cb), 29, u);
    t(c, n(d(b(c), m), ce), 30, u);
    t(c, n(d(b(c), m), ch), 31, u);
    t(c, n(d(b(c), ca), ci), 32, u);
    t(c, n(d(b(c), ca), ck), 33, u);
    t(c, n(d(b(c), m), cm), 34, u);
    t(c, n(d(b(c), m), co), 35, u);
    t(c, n(d(b(c), ca), cq), 36, u);
    t(c, n(d(b(c), ca), cs), 37, u);
    t(c, n(d(b(c), m), cu), 38, u);
    t(c, n(d(b(c), m), cw), 39, u);
    t(c, n(d(b(c), ca), cy), 40, u);
    t(c, n(d(b(c), ca), c0), 41, u);
    t(c, n(d(b(c), m), c2), 42, u);
    t(c, n(d(b(c), m), c4), 43, u);
    t(c, n(d(b(c), ca), c6), 44, u);
    t(c, n(d(b(c), ca), c8), 45, u);
    t(c, n(d(b(c), m), da), 46, u);
    t(c, n(d(b(c), m), dc), 47, u);
    t(c, n(d(b(c), ca), de), 48, u);
    t(c, n(d(b(c), ca), dg), 49, u);
    t(c, n(d(b(c), m), di), 50, u);
    t(c, n(d(b(c), m), dk), 51, u);
    t(c, n(d(b(c), ca), dm), 52, u);
    t(c, d(b(c), dn), 53, u);
  }
}
DefaultStyleHelper.$t = markType(DefaultStyleHelper, 'DefaultStyleHelper');
/**
 * @hidden
 */
export class SecureString extends Base {
  constructor() {
    super();
  }
}
SecureString.$t = markType(SecureString, 'SecureString');
/**
 * @hidden
 */
export class ExcelUtils extends Base {
  static g9(a, b, c, d) {
    return new Rect(0, a, b, c, d);
  }
  static fk(a) {
    a();
  }
  static fl(a, b = null) {
    {
      a(b);
    }
  }
  static ee(a) {
    return null;
  }
  static g3(a, b, c) {
    let d = null;
    ExcelUtils.fk(() => {
      d = new WBitmap(b, c);
      let e = 0;
      for (let f = c - 1; f >= 0; f--) {
        for (let g = 0; g < b; g++) {
          let h = a[e++];
          let i = a[e++];
          let j = a[e++];
          d._pixels[(f * b) + g] = SilverlightFixes.k(Color.u(255, j, i, h));
        }
        while (e % 4 != 0) {
          e++;
        }
      }
      d._n();
    });
    return d;
  }
  static b(a, b, c) {
    let d = null;
    let e = 0;
    let f = 0;
    ExcelUtils.fk(() => {
      e = a._k;
      f = a._j;
      let g = ExcelUtils.dj(e * 3, 4);
      d = new Array(g * f);
      let h = 0;
      for (let i = f - 1; i >= 0; i--) {
        for (let j = 0; j < e; j++) {
          let k = SilverlightFixes.w(a._pixels[i * e + j]);
          d[h++] = k.m;
          d[h++] = k.n;
          d[h++] = k.o;
        }
        while (h % 4 != 0) {
          d[h++] = 0;
        }
      }
      a._n();
    });
    b = e;
    c = f;
    return {
      ret: d,
      p1: b,
      p2: c
    };
  }
  static g4(a) {
    return null;
  }
  static y(a, b) {
    return null;
  }
  static d3(a, b) {
    let c = typeCast(IConvertible_$type, a);
    if (c != null) {
      return ConvertUtil.toString1(c, b);
    }
    return a.toString();
  }
  static cp(a) {
    switch (a) {
      case 0: return new GregorianCalendar(0);
      case 1: return new GregorianCalendar(1, 10);
      case 2: return new GregorianCalendar(1, 9);
      case 3: return new GregorianCalendar(1, 2);
      case 4: return new GregorianCalendar(1, 11);
      case 5: return new GregorianCalendar(1, 12);
      case 6: return new HebrewCalendar();
      case 7: return new HijriCalendar();
      case 8: return new JapaneseCalendar();
      case 9: return new KoreanCalendar();
      case 10: return ExcelUtils.cq.calendar;
      case 11: return ExcelUtils.cq.calendar;
      case 12: return new TaiwanCalendar();
      case 13: return new ThaiBuddhistCalendar();
      default: return ExcelUtils.cq.calendar;
    }
  }
  static get cq() {
    return Thread.currentThread.currentCulture;
  }
  static ce(a) {
    return fromOADate(a);
  }
  static az(a) {
    return a == -1;
  }
  static a3(a) {
    if (a == Number_$type || a == String_$type) {
      return false;
    }
    return a.isEnumType;
  }
  static bc(a) {
    return a.isPrimitive;
  }
  static bg(a) {
    if (a == Number_$type || a == Boolean_$type) {
      return true;
    }
    if ((typeof a.isValueType !== 'function')) {
      return false;
    }
    return a.isValueType;
  }
  static em(a, b) {
    return StringComparer.a(a, b);
  }
  static staticInit() {
  }
  static e0(a, b, c, d) {
    let e = d - c + 1;
    a |= (b << c);
    return {
      p0: a
    };
  }
  static e1(a, b, c, d) {
    let e = d - c + 1;
    a |= (b << c);
    return {
      p0: a
    };
  }
  static e2(a, b, c, d) {
    let e = d - c + 1;
    a = u32BitwiseOr(a, (u32LS(intSToU(b), c)));
    return {
      p0: a
    };
  }
  static e3(a, b, c, d) {
    let e = d - c + 1;
    a |= (b << c);
    return {
      p0: a
    };
  }
  static gs(a, b, c, d, e) {
    let f = Color.u(a, b, c, d);
    return ExcelUtils.gt(f, e);
  }
  static gt(a, b) {
    let c = ExcelUtils.cn(a.o / 255);
    let d = ExcelUtils.cn(a.n / 255);
    let e = ExcelUtils.cn(a.m / 255);
    let f = c * b < 0 ? 0 : (c * b > 1 ? 1 : c * b);
    let g = d * b < 0 ? 0 : (d * b > 1 ? 1 : d * b);
    let h = e * b < 0 ? 0 : (e * b > 1 ? 1 : e * b);
    let i = ExcelUtils.ck(f);
    let j = ExcelUtils.ck(g);
    let k = ExcelUtils.ck(h);
    return Color.u(255, truncate(MathUtilities.f(i * 255)), truncate(MathUtilities.f(j * 255)), truncate(MathUtilities.f(k * 255)));
  }
  static cn(a) {
    if (a < 0) {
      return 0;
    }
    if (a <= 0.04045) {
      return a / 12.92;
    }
    if (a <= 1) {
      return Math.pow(((a + 0.055) / 1.055), 2.4);
    }
    return 1;
  }
  static ck(a) {
    if (a < 0) {
      return 0;
    }
    if (a <= 0.0031308) {
      return a * 12.92;
    }
    if (a < 1) {
      return 1.055 * (Math.pow(a, (1 / 2.4))) - 0.055;
    }
    return 1;
  }
  static gu(a, b) {
    if (b == 0) {
      return a;
    }
    let c, d, e;
    let f = ExcelUtils.e8(a, c, e, d);
    c = f.p1;
    e = f.p2;
    d = f.p3;
    let g = e;
    if (b < 0) {
      g = truncate(MathUtilities.j(e * (1 + b)));
    }
    else if (b > 0) {
      g = truncate(MathUtilities.j(e * (1 - b))) + (240 - truncate(MathUtilities.j(240 * (1 - b))));
    }
    return ExcelUtils.gy(c, g, d);
  }
  static cv($t, a, b, c) {
    let d = 0;
    let e = a.count - 1;
    while (d <= e) {
      let f = d + (intDivide((e - d), 2));
      let g = a.item(f);
      let h = c.compare(g, b);
      if (h == 0) {
        return f;
      }
      if (h < 0) {
        d = f + 1;
      }
      else {
        e = f - 1;
      }
    }
    return ~d;
  }
  static cw($t, a, b, c, d, e) {
    let f = 0;
    let g = a.count - 1;
    while (f <= g) {
      let h = f + (intDivide((g - f), 2));
      let i = typeCastObjTo$t($t, ExcelUtils.dy(a._inner[h]));
      if (getBoxIfEnum($t, i) == null) {
        a.removeAt(h);
        g--;
        continue;
      }
      let j = c.compare(i, b);
      if (j == 0) {
        e = i;
        if (d) {
          return {
            ret: ~h,
            p4: e
          };
        }
        return {
          ret: h,
          p4: e
        };
      }
      if (j < 0) {
        f = h + 1;
      }
      else {
        g = h - 1;
      }
    }
    e = Type.getDefaultValue($t);
    return {
      ret: ~f,
      p4: e
    };
  }
  static cf(a, b) {
    let c = a._e6;
    let d = 0;
    let e = 0;
    for (let f of fromEnum(ExcelUtils.ca(b, false))) {
      let g;
      if (((() => { let h = ExcelUtils.by(f, a, c, false, g); g = h.p4; return h.ret; })())) {
        d++;
        e += g;
      }
    }
    if (d == 0) {
      return Number.NEGATIVE_INFINITY;
    }
    return e / d;
  }
  static cg(a, b, c) {
    let d = a._e6;
    let e = new List$1(Number_$type, 0);
    ExcelUtils.fn(a, c, d, true, e);
    if (e.count == 0) {
      return Number.NEGATIVE_INFINITY;
    }
    let f = e._inner[0];
    if (e.count > 1) {
      e.y();
      let g = 1 / (e.count - 1);
      let h = (b % g) / g;
      let i = truncate(((e.count - 1) * b));
      f = e._inner[i];
      if (i < e.count - 1 && h != 0) {
        f += (e._inner[i + 1] - e._inner[i]) * h;
      }
    }
    return f;
  }
  static ch(a, b) {
    let c = a._e6;
    let d = new List$1(Number_$type, 0);
    ExcelUtils.fn(a, b, c, false, d);
    if (d.count == 0) {
      return 0;
    }
    let e = CalcFunctionUtilities.r(d);
    return CalcFunctionUtilities.y(e, d.count, false);
  }
  static fn(a, b, c, d, e) {
    for (let f of fromEnum(ExcelUtils.ca(b, d))) {
      let g;
      if (((() => { let h = ExcelUtils.by(f, a, c, false, g); g = h.p4; return h.ret; })())) {
        e.add(g);
      }
    }
  }
  static e4(a, b, c) {
    let d = c - b + 1;
    let e = ((1 << d) - 1) << b;
    a &= ~e;
    return {
      p0: a
    };
  }
  static e5(a, b, c) {
    let d = c - b + 1;
    let e = ((1 << d) - 1) << b;
    a &= ~e;
    return {
      p0: a
    };
  }
  static e6(a, b, c) {
    let d = c - b + 1;
    let e = u32LS(intSToU(((1 << d) - 1)), b);
    a = u32BitwiseAnd(a, ~e);
    return {
      p0: a
    };
  }
  static e7(a, b, c) {
    let d = c - b + 1;
    let e = ((1 << d) - 1) << b;
    a &= ~e;
    return {
      p0: a
    };
  }
  static ez(a) {
    if (a.isAbsoluteUri == false) {
      return a;
    }
    let b = "file://";
    let c = a.originalString;
    if (stringStartsWith(c, b) == false) {
      return a;
    }
    c = c.substr(b.length);
    if (c.length != 0 && c.charAt(0) == '/') {
      c = c.substr(1);
    }
    c = ExcelUtils.ek(c);
    return UriUtilities.b(c);
  }
  static gx(a) {
    let b = a & 4294967295;
    return Color.u(((b >> 24) & 255), ((b >> 16) & 255), ((b >> 8) & 255), (b & 255));
  }
  static gw(a, b, c) {
    return Color.u(255, a, b, c);
  }
  static al(a) {
    return Color.b(a, ExcelUtils.gv);
  }
  static am(a) {
    return SystemColorsInternal.c(a);
  }
  static cx(a) {
    return ((((a.l << 24) | (a.o << 16)) | (a.n << 8)) | a.m);
  }
  static d2(a) {
    return "#" + intToString1(a.o, "X2", null) + intToString1(a.n, "X2", null) + intToString1(a.m, "X2", null);
  }
  static g1(a) {
    return a;
  }
  static g2(a) {
    return a;
  }
  static an(a, b, c, d) {
    let e = null;
    if (c != null && c.cellFormat != null) {
      e = c.cellFormat.fill;
    }
    if (e == null) {
      e = b._ar;
    }
    if (a != null) {
      e = e._c(a);
      d = d._c(a);
    }
    let f = typeCast(CellFillPattern.$, e);
    let g = typeCast(CellFillPattern.$, d);
    if (f != null && g != null) {
      if (f.patternStyle == 0) {
        return g.patternStyle == 0;
      }
      else if (f.patternStyle == 1) {
        return g.patternStyle == 1 && WorkbookColorInfo.l_op_Equality(f.backgroundColorInfo, g.backgroundColorInfo);
      }
    }
    return Base.equalsStatic(e, d);
  }
  static ao(a, b, c, d) {
    let e = null;
    if (c != null && c.cellFormat != null && c.cellFormat.font != null) {
      e = c.cellFormat.font.colorInfo;
    }
    if (WorkbookColorInfo.l_op_Equality(e, null)) {
      e = b._bh;
    }
    if (a != null) {
      e = e._g(a);
      d = d._g(a);
    }
    return e.equals(d);
  }
  static ap(a, b, c) {
    let d = a != null ? a.iconInfo : null;
    if (nullableEquals(c, null)) {
      return d == null || d.icon == -1;
    }
    return d != null && d.icon != -1 && ExcelUtils.ak(d.iconSet) == b && d.iconIndex == c.value;
  }
  static cr(a) {
    a = DocCoreUtils.a(a);
    let b = 1732584193;
    let c = 4023233417;
    let d = 2562383102;
    let e = 271733878;
    let f = new Array(16);
    for (let g = 0; g < a.length; g += 64) {
      for (let h = 0; h < 16; h++) {
        f[h] = BitConverter.x(a, g + (h * 4));
      }
      let i = b;
      let j = c;
      let k = d;
      let l = e;
      let m = ExcelUtils.fp(b, c, d, e, f, 0, 3);
      b = m.p0;
      let n = ExcelUtils.fp(e, b, c, d, f, 1, 7);
      e = n.p0;
      let o = ExcelUtils.fp(d, e, b, c, f, 2, 11);
      d = o.p0;
      let p = ExcelUtils.fp(c, d, e, b, f, 3, 19);
      c = p.p0;
      let q = ExcelUtils.fp(b, c, d, e, f, 4, 3);
      b = q.p0;
      let r = ExcelUtils.fp(e, b, c, d, f, 5, 7);
      e = r.p0;
      let s = ExcelUtils.fp(d, e, b, c, f, 6, 11);
      d = s.p0;
      let t = ExcelUtils.fp(c, d, e, b, f, 7, 19);
      c = t.p0;
      let u = ExcelUtils.fp(b, c, d, e, f, 8, 3);
      b = u.p0;
      let v = ExcelUtils.fp(e, b, c, d, f, 9, 7);
      e = v.p0;
      let w = ExcelUtils.fp(d, e, b, c, f, 10, 11);
      d = w.p0;
      let x = ExcelUtils.fp(c, d, e, b, f, 11, 19);
      c = x.p0;
      let y = ExcelUtils.fp(b, c, d, e, f, 12, 3);
      b = y.p0;
      let z = ExcelUtils.fp(e, b, c, d, f, 13, 7);
      e = z.p0;
      let aa = ExcelUtils.fp(d, e, b, c, f, 14, 11);
      d = aa.p0;
      let ab = ExcelUtils.fp(c, d, e, b, f, 15, 19);
      c = ab.p0;
      let ac = ExcelUtils.fq(b, c, d, e, f, 0, 3);
      b = ac.p0;
      let ad = ExcelUtils.fq(e, b, c, d, f, 4, 5);
      e = ad.p0;
      let ae = ExcelUtils.fq(d, e, b, c, f, 8, 9);
      d = ae.p0;
      let af = ExcelUtils.fq(c, d, e, b, f, 12, 13);
      c = af.p0;
      let ag = ExcelUtils.fq(b, c, d, e, f, 1, 3);
      b = ag.p0;
      let ah = ExcelUtils.fq(e, b, c, d, f, 5, 5);
      e = ah.p0;
      let ai = ExcelUtils.fq(d, e, b, c, f, 9, 9);
      d = ai.p0;
      let aj = ExcelUtils.fq(c, d, e, b, f, 13, 13);
      c = aj.p0;
      let ak = ExcelUtils.fq(b, c, d, e, f, 2, 3);
      b = ak.p0;
      let al = ExcelUtils.fq(e, b, c, d, f, 6, 5);
      e = al.p0;
      let am = ExcelUtils.fq(d, e, b, c, f, 10, 9);
      d = am.p0;
      let an = ExcelUtils.fq(c, d, e, b, f, 14, 13);
      c = an.p0;
      let ao = ExcelUtils.fq(b, c, d, e, f, 3, 3);
      b = ao.p0;
      let ap = ExcelUtils.fq(e, b, c, d, f, 7, 5);
      e = ap.p0;
      let aq = ExcelUtils.fq(d, e, b, c, f, 11, 9);
      d = aq.p0;
      let ar = ExcelUtils.fq(c, d, e, b, f, 15, 13);
      c = ar.p0;
      let as = ExcelUtils.fr(b, c, d, e, f, 0, 3);
      b = as.p0;
      let at = ExcelUtils.fr(e, b, c, d, f, 8, 9);
      e = at.p0;
      let au = ExcelUtils.fr(d, e, b, c, f, 4, 11);
      d = au.p0;
      let av = ExcelUtils.fr(c, d, e, b, f, 12, 15);
      c = av.p0;
      let aw = ExcelUtils.fr(b, c, d, e, f, 2, 3);
      b = aw.p0;
      let ax = ExcelUtils.fr(e, b, c, d, f, 10, 9);
      e = ax.p0;
      let ay = ExcelUtils.fr(d, e, b, c, f, 6, 11);
      d = ay.p0;
      let az = ExcelUtils.fr(c, d, e, b, f, 14, 15);
      c = az.p0;
      let a0 = ExcelUtils.fr(b, c, d, e, f, 1, 3);
      b = a0.p0;
      let a1 = ExcelUtils.fr(e, b, c, d, f, 9, 9);
      e = a1.p0;
      let a2 = ExcelUtils.fr(d, e, b, c, f, 5, 11);
      d = a2.p0;
      let a3 = ExcelUtils.fr(c, d, e, b, f, 13, 15);
      c = a3.p0;
      let a4 = ExcelUtils.fr(b, c, d, e, f, 3, 3);
      b = a4.p0;
      let a5 = ExcelUtils.fr(e, b, c, d, f, 11, 9);
      e = a5.p0;
      let a6 = ExcelUtils.fr(d, e, b, c, f, 7, 11);
      d = a6.p0;
      let a7 = ExcelUtils.fr(c, d, e, b, f, 15, 15);
      c = a7.p0;
      b += i;
      c += j;
      d += k;
      e += l;
    }
    let a8 = new Array(16);
    Buffer.c(BitConverter.i(b), 0, a8, 0, 4);
    Buffer.c(BitConverter.i(c), 0, a8, 4, 4);
    Buffer.c(BitConverter.i(d), 0, a8, 8, 4);
    Buffer.c(BitConverter.i(e), 0, a8, 12, 4);
    return new Guid(1, a8);
  }
  static fp(a, b, c, d, e, f, g) {
    a = DocCoreUtils.ai((a + (u32BitwiseOr((u32BitwiseAnd(b, c)), (u32BitwiseAnd(~b, d)))) + e[f]), g);
    return {
      p0: a
    };
  }
  static fq(a, b, c, d, e, f, g) {
    a = DocCoreUtils.ai((a + (u32BitwiseOr(u32BitwiseOr((u32BitwiseAnd(b, c)), (u32BitwiseAnd(b, d))), (u32BitwiseAnd(c, d)))) + e[f] + 1518500249), g);
    return {
      p0: a
    };
  }
  static fr(a, b, c, d, e, f, g) {
    a = DocCoreUtils.ai((a + (u32BitwiseXor(u32BitwiseXor(b, c), d)) + e[f] + 1859775393), g);
    return {
      p0: a
    };
  }
  static eu(a, b) {
    ExcelUtils.fo();
    for (let c = 0; c < b.length; c++) {
      let d = b[c];
      let e = (u32BitwiseXor((a >>> 24), d));
      a = u32LS(a, 8);
      a = u32BitwiseXor(a, ExcelUtils.c[e]);
    }
    return a;
  }
  static fo() {
    if (ExcelUtils.c != null) {
      return;
    }
    ExcelUtils.c = new Array(256);
    for (let a = 0; a < 256; a++) {
      let b = intSToU((a << 24));
      for (let c = 0; c < 8; c++) {
        if ((u32BitwiseAnd(b, 2147483648)) != 0) {
          b = u32LS(b, 1);
          b = u32BitwiseXor(b, 175);
        }
        else {
          b = u32LS(b, 1);
        }
      }
      b &= 65535;
      ExcelUtils.c[a] = b;
    }
  }
  static cs(a) {
    return Math.max(-32768, Math.min(a, 32767));
  }
  static et(a) {
    return Math.max(0, Math.min(a, 65535));
  }
  static gy(a, b, c) {
    let d, e, f;
    let g, h;
    if (c == 0) {
      d = e = f = intDivide((b * 255), 240);
    }
    else {
      if (b <= (intDivide(240, 2))) {
        h = intDivide((b * (240 + c) + (intDivide(240, 2))), 240);
      }
      else {
        h = b + c - intDivide(((b * c) + (intDivide(240, 2))), 240);
      }
      g = 2 * b - h;
      d = intDivide((ExcelUtils.dg(g, h, a + (intDivide(240, 3))) * 255 + (intDivide(240, 2))), 240);
      e = intDivide((ExcelUtils.dg(g, h, a) * 255 + (intDivide(240, 2))), 240);
      f = intDivide((ExcelUtils.dg(g, h, a - (intDivide(240, 3))) * 255 + (intDivide(240, 2))), 240);
    }
    return Color.u(255, d, e, f);
  }
  static e8(a, b, c, d) {
    let e = Math.max(Math.max(a.o, a.n), a.m);
    let f = Math.min(Math.min(a.o, a.n), a.m);
    c = intDivide((((e + f) * 240) + 255), (2 * 255));
    if (e == f) {
      d = 0;
      b = 160;
    }
    else {
      if (c <= (intDivide(240, 2))) {
        d = intDivide((((e - f) * 240) + (intDivide((e + f), 2))), (e + f));
      }
      else {
        d = intDivide((((e - f) * 240) + (intDivide((2 * 255 - e - f), 2))), (2 * 255 - e - f));
      }
      let g = intDivide((((e - a.o) * (intDivide(240, 6))) + (intDivide((e - f), 2))), (e - f));
      let h = intDivide((((e - a.n) * (intDivide(240, 6))) + (intDivide((e - f), 2))), (e - f));
      let i = intDivide((((e - a.m) * (intDivide(240, 6))) + (intDivide((e - f), 2))), (e - f));
      if (a.o == e) {
        b = i - h;
      }
      else if (a.n == e) {
        b = (intDivide(240, 3)) + g - i;
      }
      else {
        b = (intDivide((2 * 240), 3)) + h - g;
      }
      if (b < 0) {
        b += 240;
      }
      if (b > 240) {
        b -= 240;
      }
    }
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  static fb(a, b, c, d = true, e = 0) {
    b._bl(c, a._aj(c), d, e);
  }
  static e9(a, b, c) {
    b._dv(c, a._dd(c));
  }
  static fa(a, b, c) {
    b._bk(c, a._dd(c));
  }
  static fc(a, b, c, d = false, e = true, f = 0, g = false) {
    if (d) {
      let h = 0;
      for (let i = 1; i != 1073741824; i = (i << 1)) {
        if ((c & i) == 0) {
          continue;
        }
        if (i != 32768 && a._aa(i) == false) {
          h |= i;
        }
      }
      c = h;
    }
    if ((c & 33554432) != 0) {
      let j = a.style;
      if (j != null && b._v != null && j._g != b._v.workbook) {
        let k = b._v.workbook;
        let l = k._styles$i._item1(j.name);
        if (l == null) {
          l = k._styles$i._addUserDefinedStyle(j.styleFormat, j.name);
        }
        j = l;
      }
      b._bl(33554432, j, e, f);
      c &= ~33554432;
    }
    for (let m = 1; m != 1073741824; m = (m << 1)) {
      if ((c & m) == 0) {
        continue;
      }
      if (!g || ((m & 69468490) == 0)) {
        ExcelUtils.fb(a, b, m, e, f);
      }
      else {
        let n = a._aj(m);
        if (n != null) {
          let o = a._v != null ? a._v.workbook : null;
          switch (m) {
            case 64:
              n = ExcelUtils.j(n, o);
              break;
            default:
              n = ExcelUtils.ah(n, o);
              break;
          }
        }
        b._bl(m, n, e, f);
      }
    }
  }
  static w(a, b, c) {
    return new ArgumentExceptionExtension(a, b, c);
  }
  static x(a, b, c) {
    return new ArgumentOutOfRangeExceptionExtension(a, b, c);
  }
  static g5(a, b) {
    return { $type: Point_$type, x: a, y: b };
  }
  static g6(a, b) {
    return { $type: Point_$type, x: a, y: b };
  }
  static b8() {
    return new HashSet$1(Rect.$, 0);
  }
  static d5(a, b) {
    return ExcelUtils.d6(a, b, null);
  }
  static d6(a, b, c) {
    return ExcelUtils.d4(a, false, b, c);
  }
  static d4(a, b, c, d) {
    if (a == "<AddInFunctions>") {
      return stringEmpty();
    }
    let e = false;
    let f = null;
    if (c != null) {
      if (d == null) {
        f = c;
        e = FormulaParser.bo(c);
      }
      else {
        f = stringFormat("{0}:{1}", c, d);
        e = FormulaParser.bo(c) || FormulaParser.bo(d);
      }
    }
    if (stringIsNullOrEmpty(a)) {
      if (c == null) {
        return stringEmpty();
      }
      if (e) {
        return stringFormat("'{0}'!", stringReplace(f, "'", "''"));
      }
      return stringFormat("{0}!", f);
    }
    if (stringIsNullOrEmpty(c) || a == c) {
      if (b == false && FormulaParser.bo(a)) {
        return stringFormat("'{0}'!", stringReplace(a, "'", "''"));
      }
      return stringFormat("{0}!", a);
    }
    let g = lastIndexOfAny(a, [ExcelUtils.b2, ExcelUtils.b1]);
    let h;
    let i = e;
    if (b) {
      h = stringFormat("{0}{1}", a, f);
    }
    else {
      let j = a.substr(0, g + 1);
      let k = a.substr(g + 1);
      h = stringFormat("{0}[{1}]{2}", j, k, f);
      if (stringIsNullOrEmpty(j) == false || FormulaParser.bo(k)) {
        i = true;
      }
    }
    if (i) {
      return stringFormat("'{0}'!", stringReplace(h, "'", "''"));
    }
    return stringFormat("{0}!", h);
  }
  static ep(a, b) {
    b = false;
    let c = new StringBuilder(2, "\\A" + Regex.f(a) + "\\z");
    for (let d = 0; d < c.c; d++) {
      switch (c.item(d)) {
        case '~':
          c.y(d++, 1);
          if (d < c.c - 1 && c.item(d) == '\\') {
            switch (c.item(d + 1)) {
              case '?':
              case '*':
                c.y(d, 1);
                break;
            }
          }
          break;
        case '\\':
          switch (c.item(d + 1)) {
            case '?':
              c.y(d, 2);
              c.x(d, ".");
              b = true;
              break;
            case '*':
              c.y(d, 2);
              c.x(d, ".*");
              b = true;
              break;
          }
          break;
      }
    }
    return {
      ret: new Regex(1, c.toString(), 1),
      p1: b
    };
  }
  static fd(a, b = null) {
    if (ExcelUtils.br) {
      return;
    }
  }
  static fe(a) {
    if (ExcelUtils.br) {
      return;
    }
  }
  static ff() {
  }
  static fg() {
  }
  static fh(a, b) {
    if (a) {
    }
  }
  static gz(a) {
    let b = (a & 255);
    let c = ((a & 65280) >>> 8);
    let d = ((a & 16711680) >>> 16);
    let e = ((u32BitwiseAnd(a, 4278190080)) >>> 24);
    return Color.u(e, b, c, d);
  }
  static ci(a) {
    let b = (a & 1) == 1;
    let c = (a & 2) == 2;
    let d = u32BitwiseAnd(a, 4294967292);
    if (c) {
      let e = d >> 2;
      if (b) {
        e /= 100;
      }
      return e;
    }
    else {
      let f = new Array(8);
      f[0] = 0;
      f[1] = 0;
      f[2] = 0;
      f[3] = 0;
      let g = BitConverter.i(d);
      arrayCopyTo(g, f, 4);
      let h = BitConverter.o(f, 0);
      if (b) {
        h /= 100;
      }
      return h;
    }
  }
  static d7(a, b) {
    if (b.trim().length == 0) {
      return a;
    }
    if (b.charAt(0) != String.fromCharCode(1)) {
      return b;
    }
    let c = new StringBuilder(0);
    if (a != null) {
      c.l(IOPath.getDirectoryName(a));
      c.h(ExcelUtils.b2);
    }
    for (let d = 1; d < b.length; d++) {
      switch (b.charAt(d).charCodeAt(0)) {
        case 1:
          {
            c.c = 0;
            let e = b.charAt(++d);
            if (e == '@') {
              c.h(ExcelUtils.b2);
              c.h(ExcelUtils.b2);
            }
            else {
              c.h(e);
              c.h(ExcelUtils.b3);
              c.h(ExcelUtils.b2);
            }
            break;
          }
        case 2:
          c.c = 0;
          c.l(IOPath.getPathRoot(a));
          break;
        case 3:
          c.h(ExcelUtils.b2);
          break;
        case 4:
          let f = c.toString();
          c.c = 0;
          c.l(IOPath.getDirectoryName(f));
          c.h(ExcelUtils.b2);
          break;
        case 5:
          {
            let g = Workbook._g1.getBytes1(b.charAt(++d).toString());
            c.c = 0;
            c.l(b.substr(++d, g[0]));
            d += c.c;
            break;
          }
        case 6: break;
        case 7: break;
        default:
          c.h(b.charAt(d));
          break;
      }
    }
    return c.toString();
  }
  static aq(a, b) {
    return ExcelUtils.ar(a, b._ac, b._w, b._ae, b._x);
  }
  static ar(a, b, c, d, e) {
    let f = false;
    if (a.shiftsColumns) {
      f = a.index <= c && a.index + a.count - 1 >= e;
    }
    else if (a.shiftsRows) {
      f = a.index <= b && a.index + a.count - 1 >= d;
    }
    return f;
  }
  static as(a, b) {
    return ExcelUtils.at(a, b._ac, b._w, b._ae, b._x);
  }
  static at(a, b, c, d, e) {
    let f = false;
    if (a.shiftsColumns) {
      f = a.index <= e && a.index + a.count - 1 >= c;
    }
    else if (a.shiftsRows) {
      f = a.index <= d && a.index + a.count - 1 >= b;
    }
    return f;
  }
  static c1(a) {
    return intDivide((a * 20), 12700);
  }
  static ha(a) {
    return new Rect(0, ExcelUtils.c1(truncate(a.left)), ExcelUtils.c1(truncate(a.top)), ExcelUtils.c1(truncate(a.width)), ExcelUtils.c1(truncate(a.height)));
  }
  static cj(a) {
    if (a == 0) {
      return 0;
    }
    return a / 12700;
  }
  static dh(a) {
    if (a == 0) {
      return 0;
    }
    return truncate((a * 12700));
  }
  static fi(a, b, c, d) {
    let e = Nullable$1.toNullable(Number_$type, null);
    let f = Nullable$1.toNullable(EscherSysIndex_$type, null);
    let g = Nullable$1.toNullable(Number_$type, null);
    if (ExcelUtils.am(b)) {
      if (Color.b(b, SystemColorsInternal.l)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 0);
      }
      else if (Color.b(b, SystemColorsInternal.bf)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 1);
      }
      else if (Color.b(b, SystemColorsInternal.a3)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 2);
      }
      else if (Color.b(b, SystemColorsInternal.al)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 3);
      }
      else if (Color.b(b, SystemColorsInternal.an)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 4);
      }
      else if (Color.b(b, SystemColorsInternal.h)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 5);
      }
      else if (Color.b(b, SystemColorsInternal.f)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 6);
      }
      else if (Color.b(b, SystemColorsInternal.n)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 7);
      }
      else if (Color.b(b, SystemColorsInternal.p)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 8);
      }
      else if (Color.b(b, SystemColorsInternal.z)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 9);
      }
      else if (Color.b(b, SystemColorsInternal.aj)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 10);
      }
      else if (Color.b(b, SystemColorsInternal.at)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 11);
      }
      else if (Color.b(b, SystemColorsInternal.av)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 12);
      }
      else if (Color.b(b, SystemColorsInternal.ax)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 13);
      }
      else if (Color.b(b, SystemColorsInternal.az)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 14);
      }
      else if (Color.b(b, SystemColorsInternal.a7)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 15);
      }
      else if (Color.b(b, SystemColorsInternal.a9)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 16);
      }
      else if (Color.b(b, SystemColorsInternal.bb)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 17);
      }
      else if (Color.b(b, SystemColorsInternal.bd)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 18);
      }
      else if (Color.b(b, SystemColorsInternal.v)) {
        f = Nullable$1.toNullable(EscherSysIndex_$type, 19);
      }
    }
    let h = nullableEquals(f, null) ? ExcelUtils.dx(Color.$, b) : Nullable$1.toNullable(Color.$, null);
    let i;
    let j;
    let k = DocCoreUtils.am(h, e, f, g, i, j);
    i = k.p4;
    j = k.p5;
    if (nullableNotEquals(i, null)) {
      a.add(new PropertyTableBase_PropertyValue(0, c, i.value));
    }
    if (nullableNotEquals(j, null)) {
      a.add(new PropertyTableBase_PropertyValue(0, d, j.value));
    }
  }
  static ev(a) {
    return intSToU(((a.o) | (a.n << 8) | (a.m << 16) | (a.l << 24)));
  }
  static d8(a) {
    let b = new StringBuilder(0);
    b.h(String.fromCharCode(1));
    if (IOPath.isPathRooted(a)) {
      let c = IOPath.getPathRoot(a);
      b.h(String.fromCharCode(1));
      if (stringStartsWith(c, stringConcat(ExcelUtils.b2, ExcelUtils.b2))) {
        let d = c.lastIndexOf(ExcelUtils.b2);
        if (d < 0) {
          d = c.lastIndexOf(ExcelUtils.b1);
        }
        if (d < 0) {
          d = c.length;
        }
        b.l("@" + c.substr(2, d - 2));
        b.h(String.fromCharCode(3));
      }
      else {
        b.l(c.substr(0, 1));
      }
      let e = new List$1(String_$type, 0);
      while (true) {
        let f = IOPath.getFileName(a);
        if (f == null || f.length == 0) {
          break;
        }
        e.insert(0, f);
        a = IOPath.getDirectoryName(a);
      }
      for (let g = 0; g < e.count; g++) {
        let h = e._inner[g];
        b.l(h);
        if (g < e.count - 1) {
          b.h(String.fromCharCode(3));
        }
      }
      return b.toString();
    }
    else if (Uri.isWellFormedUriString(a, 1)) {
      b.h(String.fromCharCode(5));
      b.l(ExcelUtils.en.getString([a.length]));
      b.l(a);
      return b.toString();
    }
    else {
      return a;
    }
  }
  static get en() {
    return Encoding.defaultValue;
  }
  static c2(a) {
    return SilverlightFixes.l(a);
  }
  static eo(a) {
    return SilverlightFixes.u(a);
  }
  static d9(a) {
    if (a != null) {
      let b = null;
      for (let c = 0; c < a.length; c++) {
        let d = a.charAt(c);
        let e = null;
        switch (d) {
          case ' ':
            e = "%20";
            break;
          case '#':
            e = "%23";
            break;
          case '%':
            e = "%25";
            break;
          case '^':
            e = "%5e";
            break;
          case '`':
            e = "%60";
            break;
          case '{':
            e = "%7b";
            break;
          case '}':
            e = "%7d";
            break;
        }
        if (e != null) {
          if (b == null) {
            b = new StringBuilder(0);
            if (c > 0) {
              b.m(a, 0, c);
            }
          }
          b.l(e);
        }
        else if (b != null) {
          b.h(d);
        }
      }
      if (b != null) {
        a = b.toString();
      }
    }
    return a;
  }
  static ea(a) {
    let b = new StringBuilder(2, a);
    for (let c = 0; c < b.c; c++) {
      switch (b.item(c)) {
        case '*':
        case '?':
          b.x(c++, "~");
          break;
      }
    }
    return b.toString();
  }
  static fj(a) {
    if (10 <= a && a <= 400) {
      return {
        p0: a
      };
    }
    a = 100;
    return {
      p0: a
    };
  }
  static eb(a) {
    if (a == null) {
      return null;
    }
    return stringReplace(a, "\0", "");
  }
  static z(a) {
    return typeCast(SingleTargetFormula.$, a);
  }
  static d1(a) {
    let b = (a >>> 16);
    let c = (a & 65535);
    return b + (c / 65536);
  }
  static c3(a, b, c, d) {
    if (b == false) {
      return a;
    }
    a += c;
    if (a < 0) {
      a += d;
    }
    else if (d <= a) {
      a -= d;
    }
    return a;
  }
  static m(a) {
    switch (a) {
      case 2: return 4;
      case 4: return 2;
      case 8: return 32;
      case 32: return 8;
      case 262144: return 524288;
      case 524288: return 262144;
      case 2097152: return 4194304;
      case 4194304: return 2097152;
      case 67108864: return 134217728;
      case 134217728: return 67108864;
      default: return a;
    }
  }
  static c4(a, b, c) {
    let d = c - b + 1;
    let e = (1 << d) - 1;
    return (a >>> b) & e;
  }
  static c6(a, b, c) {
    let d = c - b + 1;
    let e = (1 << d) - 1;
    return (a >>> b) & e;
  }
  static c7(a, b, c) {
    let d = c - b + 1;
    let e = (1 << d) - 1;
    return (u32BitwiseAnd((a >>> b), e));
  }
  static c5(a, b, c) {
    let d = c - b + 1;
    let e = (1 << d) - 1;
    return ((a >> b) & e);
  }
  static c8(a, b, c) {
    let d = c - b + 1;
    let e = (1 << d) - 1;
    return ((a >>> b) & e);
  }
  static b9(a) {
    return ExcelUtils.ca([a]);
  }
  static *_ca(a, b = true) {
    let c = null;
    let d = null;
    for (let e of fromEnum(a)) {
      if (e == null) {
        continue;
      }
      if (d != null && b) {
        if (c == null) {
          c = new List$1(WorksheetRegion.$, 0);
        }
        c.add(d);
      }
      d = e;
      for (let f of fromEnum(e.worksheet._rows$i._o(e.firstRow, e.lastRow))) {
        for (let g of fromEnum(f._ch(e.firstColumn, e.lastColumn, true))) {
          let h = g.s(f);
          if (h == null) {
            continue;
          }
          let i = false;
          if (c != null) {
            for (let j = 0; j < c.count; j++) {
              if (c._inner[j]._q(f.index, g.r)) {
                i = true;
                break;
              }
            }
          }
          if (!i) {
            yield h;
          }
        }
      }
    }
  }
  static ca(a, b = true) {
    return toEnum(() => ExcelUtils._ca(a, b));
  }
  static dr(a) {
    let b = typeCast(AreaToken.$, a);
    if (b != null) {
      return Nullable$1.toNullable(CellAddressRange.$, b.x);
    }
    let c = typeCast(AreaNToken.$, a);
    if (c != null) {
      return Nullable$1.toNullable(CellAddressRange.$, c.x);
    }
    let d = typeCast(Area3DNToken.$, a);
    if (d != null) {
      return Nullable$1.toNullable(CellAddressRange.$, d.x);
    }
    let e = typeCast(Area3DToken.$, a);
    if (e != null) {
      return Nullable$1.toNullable(CellAddressRange.$, e.x);
    }
    return Nullable$1.toNullable(CellAddressRange.$, null);
  }
  static n(a) {
    let b = 0;
    if ((a & 2) != 0) {
      b |= 830603265;
    }
    if ((a & 8) != 0) {
      b |= 208404542;
    }
    if ((a & 16) != 0) {
      b |= 1073741888;
    }
    if ((a & 4) != 0) {
      b |= 32640;
    }
    if ((a & 1) != 0) {
      b |= 1073807360;
    }
    if ((a & 32) != 0) {
      b |= 1074790400;
    }
    return b;
  }
  static ac(a, b, c, d) {
    switch (b) {
      case 0: return WorkbookColorInfo.automatic;
      case 1: return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, a._palette$i._ae(c)), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), d, true, false);
      case 2:
        let e = ExcelUtils.gz(c);
        return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, e), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), d, true, true);
      case 3:
        let f = c;
        return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, f), d, true, false);
      case 4: return null;
      default: return null;
    }
  }
  static c9(a, b, c, d) {
    return ExcelUtils.c3(a, b, d, Workbook.getMaxColumnCount(c.worksheet._o));
  }
  static p(a, b) {
    b = b % 6;
    let c = 4;
    switch (b) {
      case 0: break;
      case 1:
        c = 5;
        break;
      case 2:
        c = 6;
        break;
      case 3:
        c = 7;
        break;
      case 4:
        c = 8;
        break;
      case 5:
        c = 9;
        break;
    }
    let d = new WorkbookColorInfo(c);
    let e = new ChartSolidFill(d);
    e._l(a);
    return e;
  }
  static ec(a) {
    return a.dateSeparator;
  }
  static ed(a, b) {
    if (b == null) {
      return stringEmpty();
    }
    return b.toString();
  }
  static da(a) {
    return ((a - 1) * 3) + 1;
  }
  static ad(a, b = 1) {
    return a != null ? a.colorInfo : new WorkbookColorInfo(b);
  }
  static s(a) {
    if (a == null) {
      return 0;
    }
    let b;
    if (((() => { let c = ExcelUtils.b4.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    return 0;
  }
  static b7() {
    let a = new Dictionary$2(String_$type, FontFamilyInternal_$type, 0);
    ExcelUtils.fx(a);
    return a;
  }
  static fx(a) {
    a.addItem("Aharoni", 0);
    a.addItem("Bookshelf Symbol 7", 0);
    a.addItem("DaunPenh", 0);
    a.addItem("Ebrima", 0);
    a.addItem("Gentium Basic", 0);
    a.addItem("Gentium Book Basic", 0);
    a.addItem("Jing Jing", 0);
    a.addItem("Kootenay", 0);
    a.addItem("Levenim MT", 0);
    a.addItem("Marlett", 0);
    a.addItem("Microsoft Himalaya", 0);
    a.addItem("Microsoft Uighur", 0);
    a.addItem("Moire", 0);
    a.addItem("Moire ExtraBold", 0);
    a.addItem("Moire Light", 0);
    a.addItem("Motorwerk", 0);
    a.addItem("MS Outlook", 0);
    a.addItem("MS Reference Specialty", 0);
    a.addItem("MV Boli", 0);
    a.addItem("Nyala", 0);
    a.addItem("OpenSymbol", 0);
    a.addItem("Quartz MS", 0);
    a.addItem("Sakkal Majalla", 0);
    a.addItem("Segoe Print", 0);
    a.addItem("SimSun", 0);
    a.addItem("SketchFlow Print", 0);
    a.addItem("Wingdings", 0);
    a.addItem("Andalus", 1);
    a.addItem("Angsana New", 1);
    a.addItem("AngsanaUPC", 1);
    a.addItem("Baskerville Old Face", 1);
    a.addItem("Batang", 1);
    a.addItem("Bell MT", 1);
    a.addItem("Bernard MT Condensed", 1);
    a.addItem("Bodoni MT", 1);
    a.addItem("Bodoni MT Black", 1);
    a.addItem("Bodoni MT Condensed", 1);
    a.addItem("Bodoni MT Poster Compressed", 1);
    a.addItem("Book Antiqua", 1);
    a.addItem("Bookman Old Style", 1);
    a.addItem("Californian FB", 1);
    a.addItem("Calisto MT", 1);
    a.addItem("Cambria", 1);
    a.addItem("Cambria Math", 1);
    a.addItem("Castellar", 1);
    a.addItem("Centaur", 1);
    a.addItem("Century", 1);
    a.addItem("Century Schoolbook", 1);
    a.addItem("Constantia", 1);
    a.addItem("Cooper Black", 1);
    a.addItem("DejaVu Serif", 1);
    a.addItem("DejaVu Serif Condensed", 1);
    a.addItem("DilleniaUPC", 1);
    a.addItem("Elephant", 1);
    a.addItem("Engravers MT", 1);
    a.addItem("EucrosiaUPC", 1);
    a.addItem("Footlight MT Light", 1);
    a.addItem("Garamond", 1);
    a.addItem("Georgia", 1);
    a.addItem("Gloucester MT Extra Condensed", 1);
    a.addItem("Goudy Old Style", 1);
    a.addItem("Goudy Stout", 1);
    a.addItem("Gungsuh", 1);
    a.addItem("HGKyokashotai", 1);
    a.addItem("HGMinchoB", 1);
    a.addItem("HGPKyokashotai", 1);
    a.addItem("HGPMinchoB", 1);
    a.addItem("HGPMinchoE", 1);
    a.addItem("HGPSoeiPresenceEB", 1);
    a.addItem("HGSKyokashotai", 1);
    a.addItem("HGSMinchoB", 1);
    a.addItem("HGSMinchoE", 1);
    a.addItem("HGSoeiPresenceEB", 1);
    a.addItem("HGSSoeiPresenceEB", 1);
    a.addItem("High Tower Text", 1);
    a.addItem("JasmineUPC", 1);
    a.addItem("Kartika", 1);
    a.addItem("KodchiangUPC", 1);
    a.addItem("Lucida Bright", 1);
    a.addItem("Lucida Fax", 1);
    a.addItem("Mangal", 1);
    a.addItem("MingLiU_HKSCS", 1);
    a.addItem("MingLiU_HKSCS-ExtB", 1);
    a.addItem("MingLiU-ExtB", 1);
    a.addItem("Modern No. 20", 1);
    a.addItem("MS PMincho", 1);
    a.addItem("MT Extra", 1);
    a.addItem("Palatino Linotype", 1);
    a.addItem("Perpetua", 1);
    a.addItem("Perpetua Titling MT", 1);
    a.addItem("Pescadero", 1);
    a.addItem("Plantagenet Cherokee", 1);
    a.addItem("PMingLiU", 1);
    a.addItem("PMingLiU-ExtB", 1);
    a.addItem("Poor Richard", 1);
    a.addItem("Rockwell", 1);
    a.addItem("Rockwell Condensed", 1);
    a.addItem("Rockwell Extra Bold", 1);
    a.addItem("Simplified Arabic", 1);
    a.addItem("Sylfaen", 1);
    a.addItem("Symbol", 1);
    a.addItem("Times New Roman", 1);
    a.addItem("Traditional Arabic", 1);
    a.addItem("Webdings", 1);
    a.addItem("Wide Latin", 1);
    a.addItem("Wingdings 2", 1);
    a.addItem("Wingdings 3", 1);
    a.addItem("Agency FB", 2);
    a.addItem("Aparajita", 2);
    a.addItem("Arial", 2);
    a.addItem("Arial Black", 2);
    a.addItem("Arial Narrow", 2);
    a.addItem("Arial Rounded MT Bold", 2);
    a.addItem("Arial Unicode MS", 2);
    a.addItem("Arimo", 2);
    a.addItem("Berlin Sans FB", 2);
    a.addItem("Berlin Sans FB Demi", 2);
    a.addItem("Britannic Bold", 2);
    a.addItem("Browallia New", 2);
    a.addItem("BrowalliaUPC", 2);
    a.addItem("Calibri", 2);
    a.addItem("Calibri Light", 2);
    a.addItem("Candara", 2);
    a.addItem("Century Gothic", 2);
    a.addItem("Copperplate Gothic Bold", 2);
    a.addItem("Copperplate Gothic Light", 2);
    a.addItem("Corbel", 2);
    a.addItem("Cordia New", 2);
    a.addItem("CordiaUPC", 2);
    a.addItem("David", 2);
    a.addItem("DejaVu Sans", 2);
    a.addItem("DejaVu Sans Condensed", 2);
    a.addItem("DejaVu Sans Light", 2);
    a.addItem("DokChampa", 2);
    a.addItem("Dotum", 2);
    a.addItem("Eras Bold ITC", 2);
    a.addItem("Eras Demi ITC", 2);
    a.addItem("Eras Light ITC", 2);
    a.addItem("Eras Medium ITC", 2);
    a.addItem("Euphemia", 2);
    a.addItem("Franklin Gothic Book", 2);
    a.addItem("Franklin Gothic Demi", 2);
    a.addItem("Franklin Gothic Demi Cond", 2);
    a.addItem("Franklin Gothic Heavy", 2);
    a.addItem("Franklin Gothic Medium", 2);
    a.addItem("Franklin Gothic Medium Cond", 2);
    a.addItem("FrankRuehl", 2);
    a.addItem("FreesiaUPC", 2);
    a.addItem("Gadugi", 2);
    a.addItem("Gautami", 2);
    a.addItem("Gill Sans MT", 2);
    a.addItem("Gill Sans MT Condensed", 2);
    a.addItem("Gill Sans MT Ext Condensed Bold", 2);
    a.addItem("Gill Sans Ultra Bold", 2);
    a.addItem("Gill Sans Ultra Bold Condensed", 2);
    a.addItem("Gisha", 2);
    a.addItem("Gulim", 2);
    a.addItem("Haettenschweiler", 2);
    a.addItem("HGMaruGothicMPRO", 2);
    a.addItem("HGPGothicE", 2);
    a.addItem("HGPSoeiKakugothicUB", 2);
    a.addItem("HGSGothicE", 2);
    a.addItem("HGSSoeiKakugothicUB", 2);
    a.addItem("Impact", 2);
    a.addItem("IrisUPC", 2);
    a.addItem("Iskoola Pota", 2);
    a.addItem("Kalinga", 2);
    a.addItem("Khmer UI", 2);
    a.addItem("Kokila", 2);
    a.addItem("Lao UI", 2);
    a.addItem("Latha", 2);
    a.addItem("Leelawadee", 2);
    a.addItem("LilyUPC", 2);
    a.addItem("Lucida Sans", 2);
    a.addItem("Lucida Sans Unicode", 2);
    a.addItem("Maiandra GD", 2);
    a.addItem("Malgun Gothic", 2);
    a.addItem("Meiryo", 2);
    a.addItem("Meiryo UI", 2);
    a.addItem("Microsoft JhengHei", 2);
    a.addItem("Microsoft JhengHei UI", 2);
    a.addItem("Microsoft MHei", 2);
    a.addItem("Microsoft NeoGothic", 2);
    a.addItem("Microsoft New Tai Lue", 2);
    a.addItem("Microsoft PhagsPa", 2);
    a.addItem("Microsoft Sans Serif", 2);
    a.addItem("Microsoft Tai Le", 2);
    a.addItem("Microsoft YaHei", 2);
    a.addItem("Microsoft YaHei UI", 2);
    a.addItem("Miramonte", 2);
    a.addItem("Miriam", 2);
    a.addItem("MoolBoran", 2);
    a.addItem("MS PGothic", 2);
    a.addItem("MS Reference Sans Serif", 2);
    a.addItem("MS UI Gothic", 2);
    a.addItem("Narkisim", 2);
    a.addItem("News Gothic", 2);
    a.addItem("Nina", 2);
    a.addItem("Nirmala UI", 2);
    a.addItem("Pericles", 2);
    a.addItem("Pericles Light", 2);
    a.addItem("Raavi", 2);
    a.addItem("Segoe Condensed", 2);
    a.addItem("Segoe Keycaps", 2);
    a.addItem("Segoe Script", 2);
    a.addItem("Segoe UI", 2);
    a.addItem("Segoe UI Light", 2);
    a.addItem("Segoe UI Semibold", 2);
    a.addItem("Segoe UI Semilight", 2);
    a.addItem("Segoe UI Symbol", 2);
    a.addItem("Segoe WP", 2);
    a.addItem("Segoe WP Black", 2);
    a.addItem("Segoe WP Light", 2);
    a.addItem("Segoe WP Semibold", 2);
    a.addItem("Segoe WP SemiLight", 2);
    a.addItem("Shonar Bangla", 2);
    a.addItem("Shruti", 2);
    a.addItem("Tahoma", 2);
    a.addItem("Trebuchet MS", 2);
    a.addItem("Tunga", 2);
    a.addItem("Tw Cen MT", 2);
    a.addItem("Tw Cen MT Condensed", 2);
    a.addItem("Tw Cen MT Condensed Extra Bold", 2);
    a.addItem("Utsaah", 2);
    a.addItem("Vani", 2);
    a.addItem("Verdana", 2);
    a.addItem("Vijaya", 2);
    a.addItem("Vrinda", 2);
    a.addItem("Wasco Sans", 2);
    a.addItem("Yu Gothic", 2);
    a.addItem("BatangChe", 3);
    a.addItem("Consolas", 3);
    a.addItem("Courier New", 3);
    a.addItem("DejaVu Sans Mono", 3);
    a.addItem("DotumChe", 3);
    a.addItem("FangSong", 3);
    a.addItem("GulimChe", 3);
    a.addItem("GungsuhChe", 3);
    a.addItem("HGGothicE", 3);
    a.addItem("HGGothicM", 3);
    a.addItem("HGMinchoE", 3);
    a.addItem("HGPGothicM", 3);
    a.addItem("HGSGothicM", 3);
    a.addItem("HGSoeiKakugothicUB", 3);
    a.addItem("KaiTi", 3);
    a.addItem("Lucida Console", 3);
    a.addItem("Lucida Sans Typewriter", 3);
    a.addItem("MingLiU", 3);
    a.addItem("Miriam Fixed", 3);
    a.addItem("MS Gothic", 3);
    a.addItem("MS Mincho", 3);
    a.addItem("NSimSun", 3);
    a.addItem("OCR A Extended", 3);
    a.addItem("OCRB", 3);
    a.addItem("Rod", 3);
    a.addItem("Segoe UI Mono", 3);
    a.addItem("SimHei", 3);
    a.addItem("Simplified Arabic Fixed", 3);
    a.addItem("SimSun-ExtB", 3);
    a.addItem("Andy", 4);
    a.addItem("Arabic Typesetting", 4);
    a.addItem("Bradley Hand ITC", 4);
    a.addItem("Brush Script MT", 4);
    a.addItem("Buxton Sketch", 4);
    a.addItem("Comic Sans MS", 4);
    a.addItem("DengXian", 4);
    a.addItem("DFKai-SB", 4);
    a.addItem("Edwardian Script ITC", 4);
    a.addItem("Estrangelo Edessa", 4);
    a.addItem("Forte", 4);
    a.addItem("Freestyle Script", 4);
    a.addItem("French Script MT", 4);
    a.addItem("HGGyoshotai", 4);
    a.addItem("HGPGyoshotai", 4);
    a.addItem("HGSeikaishotaiPRO", 4);
    a.addItem("HGSGyoshotai", 4);
    a.addItem("Informal Roman", 4);
    a.addItem("Kristen ITC", 4);
    a.addItem("Kunstler Script", 4);
    a.addItem("Lindsey", 4);
    a.addItem("Lucida Calligraphy", 4);
    a.addItem("Lucida Handwriting", 4);
    a.addItem("Matura MT Script Capitals", 4);
    a.addItem("Microsoft Yi Baiti", 4);
    a.addItem("Mistral", 4);
    a.addItem("Mongolian Baiti", 4);
    a.addItem("Monotype Corsiva", 4);
    a.addItem("Old English Text MT", 4);
    a.addItem("Palace Script MT", 4);
    a.addItem("Papyrus", 4);
    a.addItem("Parchment", 4);
    a.addItem("Pristina", 4);
    a.addItem("Rage Italic", 4);
    a.addItem("Script MT Bold", 4);
    a.addItem("Segoe Marker", 4);
    a.addItem("Viner Hand ITC", 4);
    a.addItem("Vivaldi", 4);
    a.addItem("Vladimir Script", 4);
    a.addItem("Algerian", 5);
    a.addItem("Bauhaus 93", 5);
    a.addItem("Blackadder ITC", 5);
    a.addItem("Broadway", 5);
    a.addItem("Chiller", 5);
    a.addItem("Colonna MT", 5);
    a.addItem("Curlz MT", 5);
    a.addItem("Felix Titling", 5);
    a.addItem("Gabriola", 5);
    a.addItem("Gigi", 5);
    a.addItem("Harlow Solid Italic", 5);
    a.addItem("Harrington", 5);
    a.addItem("HGPSoeiKakupoptai", 5);
    a.addItem("HGSoeiKakupoptai", 5);
    a.addItem("HGSSoeiKakupoptai", 5);
    a.addItem("Imprint MT Shadow", 5);
    a.addItem("Jokerman", 5);
    a.addItem("Juice ITC", 5);
    a.addItem("Magneto", 5);
    a.addItem("Niagara Engraved", 5);
    a.addItem("Niagara Solid", 5);
    a.addItem("Onyx", 5);
    a.addItem("Playbill", 5);
    a.addItem("Ravie", 5);
    a.addItem("Showcard Gothic", 5);
    a.addItem("Snap ITC", 5);
    a.addItem("Stencil", 5);
    a.addItem("Tempus Sans ITC", 5);
  }
  static aa(a) {
    let b = typeCast(StringElement.$, a);
    if (b != null) {
      return b;
    }
    let c = typeCast(FormattedString.$, a);
    if (c != null) {
      return c._m;
    }
    let d = typeCast(FormattedStringValueReference.$, a);
    if (d != null) {
      return d.c;
    }
    return null;
  }
  static db(a) {
    if (a < 360) {
      return 0;
    }
    else if (a < 460) {
      return 2;
    }
    else if (a < 700) {
      return 4;
    }
    else if (a < 840) {
      return 6;
    }
    else {
      return truncate(Math.floor((a - 1080) / 240)) * 2 + 10;
    }
  }
  static dc(a, b, c = true) {
    if (a != null && a.iconInfo != null && a.iconInfo.icon != -1) {
      let d = b._cq;
      if (d < 220) {
        if (d < 60) {
          d = 30;
        }
        else if (d < 80) {
          d = 80;
        }
        else if (d > 160) {
          d = 160;
        }
      }
      else {
        if (d < 280) {
          d = 220;
        }
        else if (d > 340 && d < 400) {
          d = 340;
        }
        else if (d > 460 && d < 520) {
          d = 460;
        }
        else if (d > 580 && d < 640) {
          d = 580;
        }
        else if (d > 700 && d < 760) {
          d = 700;
        }
      }
      return truncate(MathUtilities.f(Workbook._er(b.v, d, true))) + 1;
    }
    return 0;
  }
  static ak(a) {
    return (a - 1);
  }
  static cc(a, b, c) {
    b = new List$1(Number_$type, 0);
    b.add(0);
    c = new List$1(String_$type, 0);
    let d = new List$1(String_$type, 0);
    let e = 0;
    for (let f = 0; f < a.length; f++) {
      switch (a.charAt(f)) {
        case '\r':
          d.add(a.substr(e, f - e));
          if (f < a.length - 1 && a.charAt(f + 1) == '\n') {
            c.add("\r\n");
            f++;
          }
          else {
            c.add("\r");
          }
          e = f + 1;
          b.add(e);
          break;
        case '\n':
          c.add("\n");
          d.add(a.substr(e, f - e));
          e = f + 1;
          b.add(e);
          break;
      }
    }
    d.add(a.substr(e));
    return {
      ret: d,
      p1: b,
      p2: c
    };
  }
  static o(a) {
    switch (a) {
      case 2: return 67108864;
      case 4: return 134217728;
      case 262144: return 2097152;
      case 524288: return 4194304;
      case 2097152: return 262144;
      case 4194304: return 524288;
      case 67108864: return 2;
      case 134217728: return 4;
      default: return a;
    }
  }
  static hc() {
    let a = 96;
    let b = new Size(1, a, a);
    return b;
  }
  static dd(a) {
    return (intDivide((dateGetMonth(a) - 1), 3)) + 1;
  }
  static cd(a) {
    let b = new List$1(CellAddressRange.$, 0);
    if (a == null) {
      return b;
    }
    let e = a._e;
    for (let d = 0; d < e.length; d++) {
      let c = e[d];
      if (typeCast(MemOperatorBase.$, c) !== null) {
        continue;
      }
      if (typeCast(UnionOperator.$, c) !== null) {
        continue;
      }
      let f = typeCast(Ref3DToken.$, c);
      if (f != null) {
        b.add(new CellAddressRange(1, f.y, f.y));
        continue;
      }
      let g = typeCast(Area3DToken.$, c);
      if (g == null) {
        continue;
      }
      b.add(g.x);
    }
    return b;
  }
  static hd() {
    let a = Workbook._jh;
    return a;
  }
  static de(a, b, c) {
    return ExcelUtils.c3(a, b, c.index, Workbook.getMaxRowCount(c.worksheet._o));
  }
  static ef(a) {
    return Localization.c("excel", a);
  }
  static eg(a, ...b) {
    return Localization.c("excel", a, ...b);
  }
  static a(a, b) {
    if (b && (a & 32640) != 32640) {
      b = false;
    }
    let c;
    let d = b ? ExcelUtils.b5 : ExcelUtils.b6;
    if (d == null) {
      d = new Dictionary$2(CellFormatValue_$type, Array_$type, 0);
      if (b) {
        ExcelUtils.b5 = d;
      }
      else {
        ExcelUtils.b6 = d;
      }
    }
    if (!((() => { let e = d.tryGetValue(a, c); c = e.p1; return e.ret; })())) {
      if (ExcelUtils.cb == null) {
        ExcelUtils.cb = new List$1(CellFormatValue_$type, 0);
      }
      else {
        ExcelUtils.cb.clear();
      }
      for (let e = 1; e != 1073741824; e = (e << 1)) {
        if ((a & e) == 0) {
          continue;
        }
        let f = e;
        if (b && (e & 32640) == e) {
          if (e == 128) {
            f = 32640;
          }
          else {
            continue;
          }
        }
        ExcelUtils.cb.add(f);
      }
      d.item(a, c = ExcelUtils.cb.toArray());
    }
    return c;
  }
  static dy(a) {
    try {
      if (a == null || a.a == false) {
        return null;
      }
      return a.c;
    }
    catch (b) {
      return null;
    }
  }
  static f(a, b, c) {
    return ExcelUtils.g(a, b, true, c);
  }
  static g(a, b, c, d) {
    if (a == null || a.length == 0) {
      return WorkItem.g(WorkbookFormat_$type, (-1));
    }
    if (StructuredStorageManager._j(a)) {
      return WorkItem.g(WorkbookFormat_$type, 0);
    }
    if (ExcelUtils.co == null) {
      throw new NotSupportedException(1, ExcelUtils.eg("LE_OpenXmlSerializerNotLoaded", "{unknown}"));
    }
    let e = (-1);
    return WorkItemExtensions.g(WorkbookFormat_$type, Async.j(BaseError.$, () => {
      let f = d._d._open$i(a, 3);
      return WorkItemExtensions.e(IPackage_$type, f, (g) => {
        let h = WorkItemExtensions.m(IPackage_$type, g);
        let i = ExcelUtils.co(h);
        if (nullableNotEquals(i, null)) {
          e = i.value;
        }
      });
    }, (f) => {
      if (c) {
        throw new ArgumentExceptionExtension(ExcelUtils.ef("LE_ArgumentException_InvalidFileFormat"), b, null);
      }
    }, null), () => e);
  }
  static dg(a, b, c) {
    if (c < 0) {
      c += 240;
    }
    if (c > 240) {
      c -= 240;
    }
    if (c < (intDivide(240, 6))) {
      return a + (intDivide(((b - a) * c + (intDivide(240, 12))), (intDivide(240, 6))));
    }
    if (c < (intDivide(240, 2))) {
      return b;
    }
    if (c < (intDivide((240 * 2), 3))) {
      return a + (intDivide(((b - a) * ((intDivide((240 * 2), 3)) - c) + (intDivide(240, 12))), (intDivide(240, 6))));
    }
    return a;
  }
  static au(a) {
    return ExcelUtils.av(a) == false;
  }
  static av(a) {
    switch (a) {
      case 0:
      case 1: return false;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6: return true;
      default: return false;
    }
  }
  static a4(a) {
    if (a == null) {
      return false;
    }
    let b = getInstanceType(a);
    if (b == null) {
      return false;
    }
    if (b == String_$type) {
      return false;
    }
    return typeCast(IEnumerable_$type, a) !== null;
  }
  static aw(a) {
    switch (a) {
      case -1:
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13: return true;
    }
    return false;
  }
  static ax(a) {
    switch (a) {
      case 1:
      case 0: return true;
    }
    return false;
  }
  static get ay() {
    return ExcelUtils.cq.name == "ja-JP";
  }
  static a0(a) {
    return (a & 3) == 3;
  }
  static a1(a) {
    return (a & 5) == 5;
  }
  static a2(a) {
    return ExcelUtils.a6(a) || ExcelUtils.bh(a);
  }
  static a5(a) {
    switch (ExcelUtils.dk(a)) {
      case 0:
      case 2:
      case 1: return true;
    }
    return false;
  }
  static a6(a) {
    switch (a) {
      case 2:
      case 4:
      case 67108864:
      case 134217728: return true;
      default: return false;
    }
  }
  static a7(a) {
    switch (a) {
      case -1:
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7: return true;
    }
    return false;
  }
  static a8(a) {
    switch (a) {
      case 0:
      case 1:
      case 3:
      case 4: return true;
      case 2:
      case 5:
      case 6: return false;
      default: return false;
    }
  }
  static a9(a) {
    return a == null;
  }
  static ba(a) {
    return (typeof a == 'number');
  }
  static bb(a) {
    if (typeof a === 'number') {
      let b = a;
      if (isInfinity(b) || isNaN_(b)) {
        return false;
      }
      return true;
    }
    let c = getInstanceType(a);
    if (ExcelUtils.bc(c) || c == Number_$type) {
      if (c != Boolean_$type && c != String_$type) {
        return true;
      }
      else {
        return false;
      }
    }
    return false;
  }
  static bd(a) {
    return a >= 45 ? (a + 45) % 180 >= 90 : a < -45 && (a - 45) % 180 < -90;
  }
  static be(a) {
    switch (a) {
      case 0:
      case 1: return true;
    }
    return false;
  }
  static bf(a) {
    let b = 100;
    let c = 0;
    while (c < a.length) {
      let d = a.length - c;
      if (d > b) {
        d = b;
      }
      let e = Encoding.unicode.getBytes1(a.substr(c, d));
      for (let f = 1; f < e.length; f += 2) {
        if (e[f] != 0) {
          return true;
        }
      }
      c += d;
    }
    return false;
  }
  static bh(a) {
    switch (a) {
      case 262144:
      case 524288:
      case 2097152:
      case 4194304: return true;
      default: return false;
    }
  }
  static bi(a) {
    switch (a) {
      case -1:
      case 0:
      case 1:
      case 2:
      case 3:
      case 4: return true;
    }
    return false;
  }
  static bj(a) {
    if (a == null) {
      return false;
    }
    {
      let b = new BinaryReader(1, a);
      try {
        if (a.length <= a.position + 4) {
          return false;
        }
        let c = b.readUInt16();
        if (c != 2057) {
          return false;
        }
        let d = b.readUInt16();
        a.position += d;
        if (a.length <= a.position + 4) {
          return false;
        }
        let e = b.readUInt16();
        if (e == 134) {
          let f = b.readUInt16();
          a.position += f;
          if (a.length <= a.position + 4) {
            return false;
          }
          e = b.readUInt16();
        }
        return e == 47;
      }
      finally {
        if (b != null) {
          b.dispose();
        }
      }
    }
  }
  static bl(a) {
    switch (a) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5: return true;
    }
    return false;
  }
  static bk(a) {
    switch (a) {
      case 0:
      case 1:
      case 2:
      case 5:
      case 3:
      case 4:
      case 6: return true;
    }
    return false;
  }
  static e(a, b) {
    let c = null;
    return c;
  }
  static cl(a) {
    let b = 360;
    if (a == 0 || a == b) {
      return 0;
    }
    a = a % b;
    return a > 0 ? a : a + b;
  }
  static i(a, b) {
    return b > a ? b : a;
  }
  static ab($t, a, b) {
    if (Base.equalsStatic(b, null)) {
      return a;
    }
    if (Base.equalsStatic(a, null)) {
      return b;
    }
    let c = getInstanceType(a);
    if (c != getInstanceType(b)) {
      return a;
    }
    if (Nullable.getUnderlyingType(c) != null) {
      return a;
    }
    if (c == Boolean_$type || c == Number_$type) {
      return a;
    }
    if (c.baseType == ValueType.$ || c == String_$type) {
      return a || b;
    }
    let d = IList_$type;
    let e = (Type.createInstance(c));
    let f = new HashSet$1(Base.$, 0);
    f.add_1("init");
    f.add_1("$type");
    let g = (h) => {
      if (Base.equalsStatic(h, null)) {
        return true;
      }
      let i = getInstanceType(h);
      if (i == Boolean_$type || i == Number_$type || Nullable.getUnderlyingType(i) != null || c == Date_$type || c.baseType == ValueType.$ || c == String_$type) {
        return true;
      }
      return f.add_1(h);
    };
    let h = (i) => {
      if (!f.add_1(i)) {
        return;
      }
      let propValue = a[i];
      if (typeof propValue !== 'function') {
        let majorValue = a[i];
        let minorValue = b[i];
        try {
          if (typeCast(d, majorValue) !== null) {
            if (!g(majorValue)) {
              return;
            }
            let chosenList = majorValue.count !== 0 ? majorValue : minorValue;
            let mergedList = e[i] || (e[i] = Type.createInstance(getInstanceType(majorValue)));
            let en = chosenList.getEnumerator();
            while (en.moveNext()) {
              var item = en.current;
              mergedList.add(item);
            }
          }
          else {
            if (majorValue !== null || minorValue !== null) {
              let newValue = majorValue || minorValue;
              if (g(newValue)) {
                e[i] = ExcelUtils.ab(getInstanceType(newValue), majorValue, minorValue);
              }
            }
            else {
              e[i] = null;
            }
          }
        }
        catch (e) { }
      }
      ;
    };
    let i = c.InstanceConstructor.prototype;
    for (let p in i) {
      h(p);
    }
    ;
    for (let p of Object.getOwnPropertyNames(a)) {
      if (!p.startsWith("_")) {
        h(p);
      }
    }
    ;
    for (let p of Object.getOwnPropertyNames(b)) {
      if (!p.startsWith("_")) {
        h(p);
      }
    }
    ;
    return e;
  }
  static v(a, b) {
    let c = new WorkbookFontProxy(1, new WorkbookFontData(0, b), b._ax);
    for (let d = a.length - 1; d >= 0; d -= 1) {
      let e = a[d];
      if (e == null) {
        continue;
      }
      if (nullableNotEquals(e._bold$i, null)) {
        c._bold$i = e._bold$i;
      }
      if (WorkbookColorInfo.l_op_Inequality(e.colorInfo, null)) {
        c.colorInfo = e.colorInfo;
      }
      if (e.height >= 0) {
        c.height = e.height;
      }
      if (nullableNotEquals(e._italic$i, null)) {
        c._italic$i = e._italic$i;
      }
      if (stringIsNullOrEmpty(e.name) == false) {
        c.name = e.name;
      }
      if (nullableNotEquals(e._strikeout$i, null)) {
        c._strikeout$i = e._strikeout$i;
      }
      if (e.superscriptSubscriptStyle != -1) {
        c.superscriptSubscriptStyle = e.superscriptSubscriptStyle;
      }
      if (e.underlineStyle != -1) {
        c.underlineStyle = e.underlineStyle;
      }
    }
    return c;
  }
  static fs(a, b, c) {
    a = new Rect(0, a.x + b, a.y + c, a.width, a.height);
    return {
      p0: a
    };
  }
  static bm(a, b, c, d, e) {
    return {
      ret: ((() => { let f = ExcelUtils.bn(a, 0, a.length, b, c, d, e); d = f.p5; e = f.p6; return f.ret; })()),
      p3: d,
      p4: e
    };
  }
  static bn(a, b, c, d, e, f, g) {
    f = 0;
    g = 0;
    let h = false;
    let i;
    if (((() => { let j = FormulaParser.am(a, b, d, e, f, h, i); f = j.p4; h = j.p5; i = j.p6; return j.ret; })()) == false) {
      return {
        ret: false,
        p5: f,
        p6: g
      };
    }
    let j = false;
    let k;
    if (((() => { let l = FormulaParser.a9(a, b + i, d, g, j, k); g = l.p3; j = l.p4; k = l.p5; return l.ret; })()) == false) {
      return {
        ret: false,
        p5: f,
        p6: g
      };
    }
    return {
      ret: k + i == c,
      p5: f,
      p6: g
    };
  }
  static ai(a, b, c) {
    let d;
    let e;
    let f;
    let g;
    let h = ExcelUtils.ft(a, b._o, c, d, e, f, g);
    d = h.p3;
    e = h.p4;
    f = h.p5;
    g = h.p6;
    if (0 <= f) {
      return b._cx(d, e, f, g);
    }
    if (0 <= d) {
      return b._cx(d, e, d, e);
    }
    return null;
  }
  static ft(a, b, c, d, e, f, g) {
    d = -1;
    e = -1;
    f = -1;
    g = -1;
    a = trimEnd(a);
    let h = a.indexOf(":");
    if (h >= 0) {
      let i = a.substr(0, h);
      i = trimEnd(i);
      let j = a.substr(h + 1);
      j = trimStart(j);
      let k = false;
      let l = 0;
      let m = 0;
      let n = 0;
      let o = 0;
      if (((() => { let p = ExcelUtils.bm(i, b, c, l, m); l = p.p3; m = p.p4; return p.ret; })())) {
        if (((() => { let p = ExcelUtils.bm(j, b, c, n, o); n = p.p3; o = p.p4; return p.ret; })())) {
          k = true;
        }
      }
      if (k == false) {
        let p = false;
        let q;
        if (((() => { let r = FormulaParser.am(i, 0, b, c, l, p, q); l = r.p4; p = r.p5; q = r.p6; return r.ret; })())) {
          if (q != i.length) {
            return {
              p3: d,
              p4: e,
              p5: f,
              p6: g
            };
          }
          if (((() => { let r = FormulaParser.am(j, 0, b, c, n, p, q); n = r.p4; p = r.p5; q = r.p6; return r.ret; })())) {
            if (q != j.length) {
              return {
                p3: d,
                p4: e,
                p5: f,
                p6: g
              };
            }
            m = 0;
            o = Workbook.getMaxRowCount(b) - 1;
            k = true;
          }
        }
      }
      if (k == false) {
        let r = false;
        let s;
        if (((() => { let t = FormulaParser.a9(i, 0, b, m, r, s); m = t.p3; r = t.p4; s = t.p5; return t.ret; })())) {
          if (s != i.length) {
            return {
              p3: d,
              p4: e,
              p5: f,
              p6: g
            };
          }
          if (((() => { let t = FormulaParser.a9(j, 0, b, o, r, s); o = t.p3; r = t.p4; s = t.p5; return t.ret; })())) {
            if (s != j.length) {
              return {
                p3: d,
                p4: e,
                p5: f,
                p6: g
              };
            }
            l = 0;
            n = (Workbook.getMaxColumnCount(b) - 1);
            k = true;
          }
        }
      }
      if (k == false) {
        return {
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
      if (n < l) {
        let t = ExcelUtils.gb(Number_$type, l, n);
        l = t.p0;
        n = t.p1;
      }
      if (o < m) {
        let u = ExcelUtils.gb(Number_$type, m, o);
        m = u.p0;
        o = u.p1;
      }
      d = m;
      e = l;
      f = o;
      g = n;
      return {
        p3: d,
        p4: e,
        p5: f,
        p6: g
      };
    }
    else {
      let v;
      let w;
      if (((() => { let x = ExcelUtils.bm(a, b, c, v, w); v = x.p3; w = x.p4; return x.ret; })())) {
        d = f = w;
        e = g = v;
        return {
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
    }
    return {
      p3: d,
      p4: e,
      p5: f,
      p6: g
    };
  }
  static bo(a, b, c, d, e, f) {
    return {
      ret: ((() => { let g = ExcelUtils.bp(a, 0, a.length, b, c, d, e, f); c = g.p4; d = g.p5; e = g.p6; f = g.p7; return g.ret; })()),
      p2: c,
      p3: d,
      p4: e,
      p5: f
    };
  }
  static bp(a, b, c, d, e, f, g, h) {
    e = 0;
    f = false;
    g = 0;
    h = false;
    let i;
    if (((() => { let j = FormulaParser.bc(a, b, d, g, h, i); g = j.p3; h = j.p4; i = j.p5; return j.ret; })()) == false) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g,
        p7: h
      };
    }
    let j;
    if (((() => { let k = FormulaParser.ap(a, b + i, d, e, f, j); e = k.p3; f = k.p4; j = k.p5; return k.ret; })()) == false) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g,
        p7: h
      };
    }
    return {
      ret: i + j == c,
      p4: e,
      p5: f,
      p6: g,
      p7: h
    };
  }
  static fu(a, b, c, d, e, f, g, h) {
    e = -1;
    f = -1;
    g = -1;
    h = -1;
    a = trimEnd(a);
    let i = a.indexOf(":");
    if (i >= 0) {
      let j = a.substr(0, i);
      j = trimEnd(j);
      let k = a.substr(i + 1);
      k = trimStart(k);
      let l = false;
      let m = 0;
      let n = false;
      let o = 0;
      let p = false;
      let q = 0;
      let r = false;
      let s = 0;
      let t = false;
      if (((() => { let u = ExcelUtils.bo(j, b, m, n, o, p); m = u.p2; n = u.p3; o = u.p4; p = u.p5; return u.ret; })())) {
        if (((() => { let u = ExcelUtils.bo(k, b, q, r, s, t); q = u.p2; r = u.p3; s = u.p4; t = u.p5; return u.ret; })())) {
          l = true;
        }
      }
      if (l == false) {
        let u;
        if (((() => { let v = FormulaParser.ap(j, 0, b, m, n, u); m = v.p3; n = v.p4; u = v.p5; return v.ret; })())) {
          if (u != j.length) {
            return {
              p4: e,
              p5: f,
              p6: g,
              p7: h
            };
          }
          if (((() => { let v = FormulaParser.ap(k, 0, b, q, r, u); q = v.p3; r = v.p4; u = v.p5; return v.ret; })())) {
            if (u != k.length) {
              return {
                p4: e,
                p5: f,
                p6: g,
                p7: h
              };
            }
            o = 0;
            p = false;
            s = Workbook.getMaxRowCount(b) - 1;
            t = false;
            l = true;
          }
        }
      }
      if (l == false) {
        let v;
        if (((() => { let w = FormulaParser.bc(j, 0, b, o, p, v); o = w.p3; p = w.p4; v = w.p5; return w.ret; })())) {
          if (v != j.length) {
            return {
              p4: e,
              p5: f,
              p6: g,
              p7: h
            };
          }
          if (((() => { let w = FormulaParser.bc(k, 0, b, s, t, v); s = w.p3; t = w.p4; v = w.p5; return w.ret; })())) {
            if (v != k.length) {
              return {
                p4: e,
                p5: f,
                p6: g,
                p7: h
              };
            }
            m = 0;
            n = false;
            q = (Workbook.getMaxColumnCount(b) - 1);
            r = false;
            l = true;
          }
        }
      }
      if (l == false) {
        return {
          p4: e,
          p5: f,
          p6: g,
          p7: h
        };
      }
      if (r || t || n || p) {
        if (c == null) {
          return {
            p4: e,
            p5: f,
            p6: g,
            p7: h
          };
        }
        m = ExcelUtils.c9(m, n, c, d);
        o = ExcelUtils.de(o, p, c);
        q = ExcelUtils.c9(q, r, c, d);
        s = ExcelUtils.de(s, t, c);
      }
      if (q < m) {
        let w = ExcelUtils.gb(Number_$type, m, q);
        m = w.p0;
        q = w.p1;
      }
      if (s < o) {
        let x = ExcelUtils.gb(Number_$type, o, s);
        o = x.p0;
        s = x.p1;
      }
      e = o;
      f = m;
      g = s;
      h = q;
      return {
        p4: e,
        p5: f,
        p6: g,
        p7: h
      };
    }
    else {
      let y;
      let z;
      let aa;
      let ab;
      if (((() => { let ac = ExcelUtils.bo(a, b, y, z, aa, ab); y = ac.p2; z = ac.p3; aa = ac.p4; ab = ac.p5; return ac.ret; })())) {
        if (z || ab) {
          if (c == null) {
            return {
              p4: e,
              p5: f,
              p6: g,
              p7: h
            };
          }
          y = ExcelUtils.c9(y, z, c, d);
          aa = ExcelUtils.de(aa, ab, c);
        }
        e = g = aa;
        f = h = y;
        return {
          p4: e,
          p5: f,
          p6: g,
          p7: h
        };
      }
      let ac;
      if (((() => { let ad = FormulaParser.ap(a, 0, b, y, z, ac); y = ad.p3; z = ad.p4; ac = ad.p5; return ad.ret; })())) {
        if (ac != a.length) {
          return {
            p4: e,
            p5: f,
            p6: g,
            p7: h
          };
        }
        if (z) {
          if (c == null) {
            return {
              p4: e,
              p5: f,
              p6: g,
              p7: h
            };
          }
          y = ExcelUtils.c9(y, z, c, d);
        }
        e = 0;
        f = y;
        g = Workbook.getMaxRowCount(b) - 1;
        h = y;
      }
      let ad;
      if (((() => { let ae = FormulaParser.bc(a, 0, b, aa, ab, ad); aa = ae.p3; ab = ae.p4; ad = ae.p5; return ae.ret; })())) {
        if (ad != a.length) {
          return {
            p4: e,
            p5: f,
            p6: g,
            p7: h
          };
        }
        if (ab) {
          if (c == null) {
            return {
              p4: e,
              p5: f,
              p6: g,
              p7: h
            };
          }
          aa = ExcelUtils.de(aa, ab, c);
        }
        e = aa;
        f = 0;
        g = aa;
        h = (Workbook._fe(b) - 1);
      }
    }
    return {
      p4: e,
      p5: f,
      p6: g,
      p7: h
    };
  }
  static fv(a, b, c, d, e, f, g, h, i, j) {
    if (c == 1) {
      let k = ExcelUtils.ft(a, b, d, g, h, i, j);
      g = k.p3;
      h = k.p4;
      i = k.p5;
      j = k.p6;
    }
    else {
      let l = ExcelUtils.fu(a, b, e, f, g, h, i, j);
      g = l.p4;
      h = l.p5;
      i = l.p6;
      j = l.p7;
    }
    return {
      p6: g,
      p7: h,
      p8: i,
      p9: j
    };
  }
  static u(a, b, c, d, e, f, g, h, i = null, j = 0) {
    let k = b.workbook;
    let l = null;
    try {
      if (a != null && a.length > 0 && a.charAt(0) != '=') {
        a = "=" + a;
      }
      l = typeCast(SingleTargetFormula.$, Formula._k(a, e, j, k.currentFormat, k._e6, i));
      if (l != null) {
        l._b5(new FormulaContext(3, k, b.type == 0 ? b : null, null, -1, l));
      }
    }
    catch (m) {
      throw new ArgumentExceptionExtension(ExcelUtils.ef(g), f, m);
    }
    if (l == null || l._e.length == 0) {
      throw new ArgumentExceptionExtension(ExcelUtils.ef(g), f, null);
    }
    if (l._e.length > 1) {
      let p = l._e;
      for (let o = 0; o < p.length; o++) {
        let n = p[o];
        let q = typeCast(AreaToken.$, n);
        if (q != null) {
          ExcelUtils.fy(typeCast(Worksheet.$, b), h, k, q);
          continue;
        }
        if (typeCast(UnionOperator.$, n) !== null) {
          continue;
        }
        throw new ArgumentExceptionExtension(ExcelUtils.ef(g), f, null);
      }
      return l;
    }
    let r = l._e[0];
    let s = typeCast(NameToken.$, r);
    if (s != null) {
      return l;
    }
    try {
      let t = new TempCellCalcReference(true, b, new WorksheetCellAddress(1, c, d));
      l._cx(t, k);
      let u = l._cf(k, t, false);
      let v = typeCast(RefBase.$, u.toReference());
      if (v != null) {
        let w = v._am();
        if (w != null) {
          for (let x of fromEnum(w)) {
            h.add(Tuple.b(Worksheet.$, WorksheetRegionAddress.$, String_$type, x.worksheet, x._h, ExcelUtils.d5(null, x.worksheet.name)));
          }
        }
        else {
          if (typeCast(AreaToken.$, r) !== null) {
            ExcelUtils.fy(typeCast(Worksheet.$, b), h, k, typeCast(AreaToken.$, r));
          }
        }
      }
      return l;
    }
    catch (y) {
      throw new ArgumentExceptionExtension(ExcelUtils.ef(g), f, y);
    }
  }
  static fy(a, b, c, d) {
    let e = d.x;
    let f = new WorksheetRegionAddress(1, e.d.t, e.b.t, e.d.r, e.b.r);
    if (d.o == null) {
      if (a != null) {
        b.add(Tuple.b(Worksheet.$, WorksheetRegionAddress.$, String_$type, a, f, ExcelUtils.d5(null, a.name)));
      }
    }
    else if (d.o.e != null) {
      let g = d.o.e.l;
      if (g == c) {
        let h = d.o.n;
        let i = typeCast(WorksheetReferenceSingle.$, d.o);
        if (i != null) {
          b.add(Tuple.b(Worksheet.$, WorksheetRegionAddress.$, String_$type, typeCast(Worksheet.$, h), f, i.p));
        }
      }
    }
  }
  static fw(a, b) {
    if (a == null || a.length == 0) {
      return;
    }
    for (let c = 0; c < a.length; c++) {
      a[c] = b;
    }
  }
  static fz(a, b) {
    if (a == b) {
      a = 1;
      b = 1;
      return {
        p0: a,
        p1: b
      };
    }
    if (a == -b) {
      a = 1;
      b = -1;
      return {
        p0: a,
        p1: b
      };
    }
    for (let c = 0; c < ExcelUtils.d.length; c++) {
      let d = ExcelUtils.d[c];
      if (a < d || b < d) {
        break;
      }
      while (a % d == 0 && b % d == 0) {
        a = intDivide(a, d);
        b = intDivide(b, d);
      }
    }
    return {
      p0: a,
      p1: b
    };
  }
  static g0(a) {
    if (ExcelUtils.al(a) || a.l == 255) {
      return a;
    }
    return Color.u(255, a.o, a.n, a.m);
  }
  static eh(a) {
    if (a == null) {
      return null;
    }
    return stringReplace(a, "\r\n", "\n");
  }
  static bq(a, b, c) {
    if (a != null && b != null) {
      let d = a.count;
      for (let e = d - 1; e >= 0; e--) {
        let f = a._inner[e];
        if (f._o == b && f._ab == c) {
          a._inner[e] = a._inner[d - 1];
          a.removeAt(d - 1);
          return true;
        }
      }
    }
    return false;
  }
  static f0(a) {
    a &= ~2;
    return {
      p0: a
    };
  }
  static f1(a) {
    a &= ~4;
    return {
      p0: a
    };
  }
  static f2(a) {
    if (a != null) {
      let b = a.count;
      let c = 0;
      for (let d = b - 1; d >= 0; d--) {
        if (a._inner[d].worksheet == null) {
          a._inner[d] = a._inner[b - c - 1];
          c++;
        }
      }
      if (c > 0) {
        a.v(b - c, c);
      }
    }
  }
  static dz(a, b, c, d, e, f) {
    let g = a._b4(b, c)._dd(f);
    if (0 <= e && WorksheetCellFormatData._cf(f, g)) {
      g = a._b4(d, e)._dd(ExcelUtils.o(f));
    }
    return g;
  }
  static d0(a, b, c) {
    let d = WorksheetCellFormatData._c8(c);
    if (a != null && a._hasCellFormat) {
      d = a._cellFormatInternal._aj(c);
    }
    if (WorksheetCellFormatData._cf(c, d) && b != null && b._hasCellFormat) {
      d = b._cellFormatInternal._aj(ExcelUtils.o(c));
    }
    return d;
  }
  static ae(a, b) {
    let c = Nullable$1.toNullable(Number_$type, null);
    if (b.b != 0) {
      c = Nullable$1.toNullable(Number_$type, b.b / 32767);
    }
    return ExcelUtils.ac(a, b.a, b.c, c);
  }
  static l(a, b) {
    let c = Nullable$1.toNullable(Number_$type, null);
    if (b.c != 0) {
      c = Nullable$1.toNullable(Number_$type, b.c);
    }
    let d = ExcelUtils.ac(a, b.a, b.d, c);
    return new CellFillGradientStop(d, b.b);
  }
  static k(a, b) {
    let c = new Array(b.a.length);
    for (let d = 0; d < c.length; d++) {
      c[d] = ExcelUtils.l(a, b.a[d]);
    }
    if (b.g == 1) {
      return new CellFillRectangularGradient(b.d, b.f, b.e, b.c, ...c);
    }
    return new CellFillLinearGradient(b.b, ...c);
  }
  static af(a, b) {
    if (b == null) {
      return null;
    }
    let c = ExcelUtils.bt(b.b, 0);
    let d = ExcelUtils.c4(b.b, 1, 7);
    let e = Nullable$1.toNullable(Number_$type, null);
    if (b.c != 0) {
      e = Nullable$1.toNullable(Number_$type, b.c / 32767);
    }
    let f;
    if (d == 1 || d == 3) {
      f = b.a;
    }
    else if (d == 2) {
      f = b.d;
    }
    else {
      f = 0;
    }
    return ExcelUtils.ac(a, d, f, e);
  }
  static f3(a, b, c, d) {
    let e = (a.o / 255);
    let f = (a.n / 255);
    let g = (a.m / 255);
    let h = e * 0.412453 + f * 0.35758 + g * 0.180423;
    let i = e * 0.212671 + f * 0.71516 + g * 0.072169;
    let j = e * 0.019334 + f * 0.119193 + g * 0.950227;
    let k = ExcelUtils.cm(h / 0.95047);
    let l = ExcelUtils.cm(i / 1);
    let m = ExcelUtils.cm(j / 1.08883);
    b = (116 * l) - 16;
    c = 500 * (k - l);
    d = 200 * (l - m);
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  static cm(a) {
    if (a > 0.008856) {
      return Math.pow(a, (1 / 3));
    }
    else {
      return (7.787 * a) + (16 / 116);
    }
  }
  static dj(a, b) {
    return a + b - 1 - ((a - 1) % b);
  }
  static f4(a, b, c) {
    let d = false;
    if (d == false) {
      a.i(c, b);
      c.flush();
    }
  }
  static f6(a, b, c) {
    let d = ExcelUtils.f5(a, nullableEquals(b, true), c);
    a = d.p0;
    return {
      p0: a
    };
  }
  static f5(a, b, c) {
    let d = (1 << c);
    if (b) {
      a |= d;
    }
    else {
      a &= ~d;
    }
    return {
      p0: a
    };
  }
  static f8(a, b, c) {
    let d = ExcelUtils.f7(a, nullableEquals(b, true), c);
    a = d.p0;
    return {
      p0: a
    };
  }
  static f7(a, b, c) {
    let d = (1 << c);
    if (b) {
      a |= d;
    }
    else {
      a &= ~d;
    }
    return {
      p0: a
    };
  }
  static f9(a, b, c) {
    let d = intSToU((1 << c));
    if (b) {
      a = u32BitwiseOr(a, d);
    }
    else {
      a = u32BitwiseAnd(a, ~d);
    }
    return {
      p0: a
    };
  }
  static bs(a) {
    return a.isEmpty || a.height == 0 || a.width == 0;
  }
  static ga(a, b, c, d, e, f, g, h, i) {
    let j = Worksheet._fh;
    j.clear();
    let k = e == null || (e._ad > 0 && e._aa > 0);
    if (e != null) {
      c = e._ad == 1;
    }
    let l = c && (e != null && e._aa == 1);
    try {
      let m = ExcelUtils.u(b, a, e != null ? e.firstRow : 0, e != null ? e._v : 0, f, "dataRange", "LE_InvalidRegion", j);
      if (m == null) {
        throw new ArgumentExceptionExtension(ExcelUtils.ef("LE_InvalidRegion"), "dataRange", null);
      }
      let n = 0;
      let o = 0;
      let p = 0;
      let q = 0;
      let r = 0;
      let s = 0;
      for (let t = 0; t < j.count; t++) {
        let u = j._inner[t].d;
        if (WorksheetRegionAddress._p(Nullable$1.toNullable(WorksheetRegionAddress.$, u), Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
          continue;
        }
        let v = u._af;
        let w = u._ad;
        if (t == 0) {
          r = v;
          s = w;
        }
        else {
          r = Math.min(r, v);
          s = Math.min(s, w);
        }
        p = Math.max(p, v);
        q = Math.max(q, w);
        n += v;
        o += w;
      }
      if (j.count > 0) {
        if (e != null && k) {
          if (l && p == 1) {
            c = false;
          }
          if (c) {
            k = e._aa == q;
          }
          else {
            k = e._ad == p;
          }
        }
        if (k) {
          if (d) {
            if (r == p && r == 1) {
              c = false;
            }
            else {
              c = true;
              k = s == q && s == 1;
            }
          }
          if (c) {
            k = r == p;
          }
          else {
            k = s == q;
          }
        }
      }
      else {
        if (k && e != null && e._ad != 1 && e._aa != 1) {
          throw new ArgumentExceptionExtension(ExcelUtils.ef("LE_LocationNotSingleRowOrColumn"), "locationRange", null);
        }
      }
      if (!k) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_LocationOrDataAreaInvalid"));
      }
      if (g != null) {
        g(c ? p : q);
      }
      let x = j.count;
      if (x == 0) {
        if (h != null) {
          h();
        }
      }
      else {
        let y = c ? e != null ? e._aa : q : e != null ? e._ad : p;
        for (let z = 0; z < x; z++) {
          for (let aa = 0; aa < y; aa++) {
            let ab = j._inner[z];
            let ac = ab.d;
            if (c) {
              if (aa >= ac._ad) {
                continue;
              }
            }
            else {
              if (aa >= ac._af) {
                continue;
              }
            }
            let ad = ab.c;
            let ae = aa;
            let af = z;
            if (e != null) {
              if (c) {
                ae = e.firstRow + aa;
                af = (e._v + z);
              }
              else {
                ae = e.firstRow + z;
                af = (e._v + aa);
              }
            }
            let ag = new WorksheetRegionAddress(1, ae, ae, af, af);
            let ah = c ? new WorksheetRegionAddress(1, ac._ac + aa, ac._ac + aa, ac._w, ac._x) : new WorksheetRegionAddress(1, ac._ac, ac._ae, (ac._w + aa), (ac._w + aa));
            if (i != null) {
              i(ad, ag, ah, ab.e);
            }
          }
        }
      }
    }
    finally {
      j.clear();
    }
  }
  static ei(a, b = ", ") {
    if (a == null || a.length == 0) {
      return null;
    }
    let c = new StringBuilder(0);
    for (let d = 0; d < a.length; d++) {
      if (d > 0) {
        c.l(b);
      }
      c.l(EnumUtil.getName(ChartType_$type, a[d]));
    }
    return c.toString();
  }
  static gc(a, b, c, d, e) {
    let f = ExcelUtils.m(c);
    let g = ExcelUtils.o(c);
    let h = ExcelUtils.m(g);
    let i = b._aj(h);
    if (WorksheetCellFormatData._cf(h, i) == false && a._aa(f)) {
      a._bl(f, i, true, e);
    }
    if (Base.equalsStatic(b._aj(g), d) == false) {
      b._as(g, 1);
      b._as(h, 1);
    }
  }
  static gb($t, a, b) {
    let c = a;
    a = b;
    b = c;
    return {
      p0: a,
      p1: b
    };
  }
  static bt(a, b) {
    let c = (1 << b);
    return (a & c) == c;
  }
  static bu(a, b) {
    let c = u32LS(intSToU(1), b);
    return (u32BitwiseAnd(a, c)) == c;
  }
  static bv(a, b) {
    return (a & b) == b;
  }
  static bw(a, b) {
    return (a & b) == b;
  }
  static bx(a, b) {
    return (a & b) == b;
  }
  static ag(a) {
    if (ExcelUtils.al(a)) {
      return null;
    }
    return new WorkbookColorInfo(a);
  }
  static dv(a) {
    return Nullable$1.toNullable(Boolean_$type, a ? true : false);
  }
  static dw(a) {
    if (a.hasValue == false) {
      return Nullable$1.toNullable(Boolean_$type, null);
    }
    return Nullable$1.toNullable(Boolean_$type, a.value ? true : false);
  }
  static ey(a) {
    let b = MathUtilities.j(a);
    let c = truncate(b);
    b = Math.abs(a % 1) * 65536;
    let d = truncate(MathUtilities.f(b));
    return intSToU((c << 16)) + d;
  }
  static t(a) {
    if (a == 20) {
      return -1;
    }
    return (a + 1);
  }
  static aj(a) {
    if (a == -1) {
      return 20;
    }
    return (a - 1);
  }
  static ah(a, b) {
    if (WorkbookColorInfo.l_op_Inequality(a, null) && b != null && nullableNotEquals(a._themeColorType$i, ExcelUtils.dt)) {
      a = a._g(b);
    }
    return a;
  }
  static j(a, b) {
    if (a != null && b != null && !Base.referenceEquals(CellFill.noColor, a)) {
      let c = typeCast(CellFillPattern.$, a);
      if (c == null || c.patternStyle != 0) {
        a = a._c(b);
      }
    }
    return a;
  }
  static q(a) {
    switch (a) {
      case 1:
      case -4098:
      case 78:
      case 79:
      case 76:
      case 77: return 0;
      case 60:
      case 61:
      case 62:
      case 57:
      case 71:
      case 58:
      case 59:
      case -4100:
      case 54:
      case 55:
      case 56:
      case 51:
      case 52:
      case 53:
      case 105:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 95:
      case 96:
      case 97:
      case 98:
      case 92:
      case 93:
      case 94:
      case 109:
      case 110:
      case 111:
      case 112:
      case 106:
      case 107:
      case 108: return 1;
      case 15:
      case 87: return 7;
      case 5:
      case -4102:
      case 70:
      case 69:
      case 68:
      case -4120:
      case 80: return 3;
      case -4151:
      case 82:
      case 81: return 4;
      case 83:
      case 85:
      case 86:
      case 84: return 5;
      case 4:
      case -4101:
      case 65:
      case 66:
      case 67:
      case 63:
      case 64:
      case 88:
      case 89:
      case 90:
      case 91: return 2;
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73: return 6;
      case 116: return 2;
      case 118: return 3;
      case 117:
      case 119:
      case 120:
      case 114:
      case 115:
      case 121: return 1;
      case 113:
      case 0: break;
      default: break;
    }
    return 1;
  }
  static ej(a, b) {
    return numberToString(a, b);
  }
  static gd(a) {
    let b = a.getFormattingRuns(null);
    let c = a.unformattedString;
    for (let d = b.count - 1; d >= 0; d--) {
      if (c.length <= b._inner[d].k) {
        let e = b._inner[d];
        if (e.h) {
          e.f(null).i();
        }
        b.removeAt(d);
      }
      else {
        break;
      }
    }
  }
  static by(a, b, c, d, e) {
    if (typeof a === 'number') {
      e = a;
      return {
        ret: true,
        p4: e
      };
    }
    if (typeCast(Boolean_$type, a) !== null && !d) {
      e = 0;
      return {
        ret: false,
        p4: e
      };
    }
    e = NaN;
    if (ExcelCalcValue._ac(a)) {
      e = 0;
      return {
        ret: false,
        p4: e
      };
    }
    if (typeof a === 'string') {
      if (((() => { let f = MathUtilities.c(a, c, e); e = f.p2; return f.ret; })())) {
        return {
          ret: true,
          p4: e
        };
      }
      let f;
      let g = ((() => { let h = dateTryParse(a, f); f = h.p1; return h.ret; })());
      if (g) {
        let h = ExcelCalcValue._dateTimeToExcelDate(b, f);
        if (h.hasValue) {
          let i = c == null ? MathUtilities.l.dateTimeFormat : c.getFormat(DateTimeFormat.$);
          if (c != null && stringContains(a, ExcelUtils.ec(i))) {
            e = h.value;
            return {
              ret: true,
              p4: e
            };
          }
        }
      }
      return {
        ret: false,
        p4: e
      };
    }
    if (true && typeCast(Date_$type, a) !== null) {
      let j = ExcelCalcValue._dateTimeToExcelDate(b, a);
      if (j.hasValue == false) {
        e = 0;
        return {
          ret: false,
          p4: e
        };
      }
      e = j.value;
      return {
        ret: true,
        p4: e
      };
    }
    try {
      let k = typeCast(IConvertible_$type, a);
      if (k != null) {
        e = ConvertUtil.toDouble(k, c);
        return {
          ret: true,
          p4: e
        };
      }
      else {
        e = 0;
        return {
          ret: false,
          p4: e
        };
      }
    }
    catch (l) {
      e = 0;
      return {
        ret: false,
        p4: e
      };
    }
  }
  static bz(a, b) {
    b = 0;
    let c = false;
    let d = false;
    for (let e = 0; e < 2; e++) {
      let f = BitConverter.c(a);
      if (f[0] == 0 && f[1] == 0 && f[2] == 0 && f[3] == 0 && (f[4] & 3) == 0) {
        b = BitConverter.x(f, 4);
        c = true;
        break;
      }
      if (a % 1 == 0 && -536870912 <= a && a <= 536870911) {
        b = intSToU((truncate(a) << 2));
        b = u32BitwiseOr(b, 2);
        c = true;
        break;
      }
      a *= 100;
      d = true;
    }
    if (c) {
      if (d) {
        b = u32BitwiseOr(b, 1);
      }
      return {
        ret: true,
        p1: b
      };
    }
    return {
      ret: false,
      p1: b
    };
  }
  static b0(a, b, c) {
    if (typeCast(Date_$type, b) !== null) {
      let d = ExcelCalcValue._dateTimeToExcelDate(a, b);
      if (d.hasValue) {
        c = d.value;
        return {
          ret: true,
          p2: c
        };
      }
    }
    else if (typeof b === 'number') {
      c = b;
      return {
        ret: true,
        p2: c
      };
    }
    else if (typeof b === 'number') {
      c = typeGetValue(b);
      return {
        ret: true,
        p2: c
      };
    }
    else if (typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number' || typeof b === 'number') {
      try {
        let e = ExcelUtils.cq;
        if (a != null) {
          e = a._e6;
        }
        c = Convert.toDouble4(b, e);
        return {
          ret: true,
          p2: c
        };
      }
      catch (f) {
      }
    }
    else if (b == ErrorValue.circularity) {
      c = 0;
      return {
        ret: true,
        p2: c
      };
    }
    c = NaN;
    return {
      ret: false,
      p2: c
    };
  }
  static dm(a) {
    if (isInfinity(a) || isNaN_(a)) {
      return 0;
    }
    return truncate(a) * (intDivide(12700, 20));
  }
  static dn(a) {
    return a * (intDivide(12700, 20));
  }
  static hb(a) {
    return new Rect(0, ExcelUtils.dm(a.x), ExcelUtils.dm(a.y), ExcelUtils.dm(a.width), ExcelUtils.dm(a.height));
  }
  static ek(a) {
    if (a != null) {
      let b = null;
      for (let c = 0; c < a.length; c++) {
        let d = a.charAt(c);
        if (d == '%' && c < a.length - 3) {
          let e = a.charAt(c + 1);
          let f = a.charAt(c + 2);
          let g = d;
          switch (a.charAt(c + 1)) {
            case '2':
              if (f == '0') {
                g = ' ';
              }
              else if (f == '3') {
                g = '#';
              }
              else if (f == '5') {
                g = '%';
              }
              break;
            case '5':
              if (f == 'e') {
                g = '^';
              }
              break;
            case '6':
              if (f == '0') {
                g = '`';
              }
              break;
            case '7':
              if (f == 'b') {
                g = '{';
              }
              else if (f == 'd') {
                g = '}';
              }
              break;
          }
          if (d != g) {
            if (b == null) {
              b = new StringBuilder(0);
              if (c > 0) {
                b.m(a, 0, c);
              }
            }
            c += 2;
            d = g;
          }
        }
        if (b != null) {
          b.h(d);
        }
      }
      if (b != null) {
        a = b.toString();
      }
    }
    return a;
  }
  static el(a) {
    let b = new StringBuilder(2, a);
    for (let c = 0; c < b.c; c++) {
      switch (b.item(c)) {
        case '~':
          b.y(c, 1);
          break;
      }
    }
    return b.toString();
  }
  static ge(a, b) {
    return {
      p0: a
    };
  }
  static gf(a, b = null) {
    let c = a[0].worksheet;
    for (let d = 0; d < a.length; d++) {
      let e = a[d];
      for (let f = e.firstRow; f <= e.lastRow; f++) {
        let g = c._rows$i._aj(f);
        if (g == null) {
          continue;
        }
        for (let h = e._v; h <= e._w; h++) {
          let i = typeCast(IRegionBlockingSingleCellComponent_$type, g._c6(h));
          if (i != null) {
            if (e._o(i.owningValue.blockedRegion) == false) {
              i.owningValue.throwBlockingException();
            }
            if (b != null) {
              b.add_1(i.owningValue);
            }
          }
        }
      }
    }
  }
  static gg(a, b) {
    if (a < 0 || b <= a) {
      throw new ArgumentOutOfRangeExceptionExtension(ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidCollectionIndex"), null);
    }
  }
  static gh(a, b, c) {
    let d = a._columns$i.maxCount;
    if (0 <= b && b <= d) {
      return;
    }
    throw new ArgumentOutOfRangeExceptionExtension(c, b, ExcelUtils.eg("LE_ArgumentOutOfRangeException_InvalidColumnCount", b, 0, d));
  }
  static gi(a, b, c) {
    let d = a._columns$i.maxCount;
    if (0 <= b && b <= d - 1) {
      return;
    }
    throw new ArgumentOutOfRangeExceptionExtension(c, b, ExcelUtils.eg("LE_ArgumentOutOfRangeException_InvalidColumnIndex", b, 0, d - 1));
  }
  static gj(a) {
  }
  static gk(a, b) {
  }
  static gl($t, a) {
    ExcelUtils.gm($t, a, "value");
  }
  static gm($t, a, b) {
    if (EnumUtil.isDefined($t, getBoxIfEnum($t, a)) == false) {
      throw new InvalidEnumArgumentException(b, Convert.toInt321(getBoxIfEnum($t, a)), $t);
    }
  }
  static gn(a, b) {
    if (ExcelUtils.a5(a) == false) {
      throw new InvalidEnumArgumentException(b, ExcelUtils.dk(a), Nullable$1.$.specialize(Boolean_$type));
    }
  }
  static go(a, b, c) {
    let d = a._rows$i.maxCount;
    if (0 <= b && b <= d) {
      return;
    }
    throw new ArgumentOutOfRangeExceptionExtension(c, b, ExcelUtils.eg("LE_ArgumentOutOfRangeException_InvalidRowCount", b, 0, d));
  }
  static gp(a, b, c) {
    let d = a._rows$i.maxCount;
    if (0 <= b && b <= d - 1) {
      return;
    }
    throw new ArgumentOutOfRangeExceptionExtension(c, b, ExcelUtils.eg("LE_ArgumentOutOfRangeException_InvalidRowIndex", b, 0, d - 1));
  }
  static gq(a) {
    if (ExcelUtils.be(a) == false) {
      throw new InvalidEnumArgumentException("value", a, TextFormatMode_$type);
    }
  }
  static gr(a) {
    if (ExcelUtils.bl(a) == false) {
      throw new InvalidEnumArgumentException("value", a, WorksheetColumnWidthUnit_$type);
    }
  }
  static fm($t, a, b) {
    for (let c of fromEnum(a)) {
      b(c);
    }
  }
  static h(a) {
    switch (a) {
      case 5:
      case 6: return 2;
      case 2:
      case 10:
      case 12:
      case 8:
      case 13: return 1;
      case 9:
      case 11:
      case 3:
      case 4:
      case 7:
      case 0:
      case 1: return 0;
      case -1: return 0;
      default: return 0;
    }
  }
  static du(a) {
    return wrapNullable(Boolean_$type, (a));
  }
  static dk(a) {
    if (nullableEquals(a, true)) {
      return 1;
    }
    if (nullableEquals(a, false)) {
      return 2;
    }
    return 0;
  }
  static dx($t, a) {
    return Nullable$1.toNullable($t, a);
  }
}
ExcelUtils.$t = markType(ExcelUtils, 'ExcelUtils');
ExcelUtils.b1 = IOPath.altDirectorySeparatorChar;
ExcelUtils.b2 = IOPath.directorySeparatorChar;
ExcelUtils.b3 = IOPath.volumeSeparatorChar;
ExcelUtils.g7 = { $type: Point_$type, x: 0, y: 0 };
ExcelUtils.g8 = { $type: Point_$type, x: 0, y: 0 };
ExcelUtils.d = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
ExcelUtils.br = false;
ExcelUtils.dq = Nullable$1.toNullable(Boolean_$type, null);
ExcelUtils.ds = Nullable$1.toNullable(Number_$type, null);
ExcelUtils.dt = Nullable$1.toNullable(WorkbookThemeColorType_$type, null);
ExcelUtils.gv = new Color();
ExcelUtils.c = null;
ExcelUtils.b4 = ExcelUtils.b7();
ExcelUtils.b6 = null;
ExcelUtils.b5 = null;
ExcelUtils.cb = null;
ExcelUtils.co = null;
/**
 * @hidden
 */
export class Utilities_Int16Comparer extends Comparer$1 {
  constructor() {
    super(Number_$type);
  }
  compare(a, b) {
    if (a < b) {
      return -1;
    }
    if (b < a) {
      return 1;
    }
    return 0;
  }
}
Utilities_Int16Comparer.$t = markType(Utilities_Int16Comparer, 'Utilities_Int16Comparer', Comparer$1.$.specialize(Number_$type));
Utilities_Int16Comparer._c = new Utilities_Int16Comparer();
/**
 * @hidden
 */
export let IRegionAddress_$type = new Type(null, 'IRegionAddress');
/**
 * @hidden
 */
export class WorksheetRegionAddress extends ValueType {
  constructor(a, ..._rest) {
    super();
    this._u = 0;
    this._y = 0;
    this._v = 0;
    this._aa = 0;
    this._z = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this._u = e;
          this._y = c;
          this._v = f;
          this._aa = d;
          this._z = WorksheetRegionAddress._ab(this._y, this._aa, this._u, this._v);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          this._u = Math.min(c.m, d.m);
          this._y = Math.min(c.o, d.o);
          this._v = Math.max(c.m, d.m);
          this._aa = Math.max(c.o, d.o);
          this._z = WorksheetRegionAddress._ab(this._y, this._aa, this._u, this._v);
        }
        break;
    }
  }
  compareTo(a) {
    let b = this._u - a._u;
    if (b != 0) {
      return b;
    }
    b = this._y - a._y;
    if (b != 0) {
      return b;
    }
    b = this._v - a._v;
    if (b != 0) {
      return b;
    }
    b = this._aa - a._aa;
    if (b != 0) {
      return b;
    }
    return 0;
  }
  equals(a) {
    if ((typeCast(WorksheetRegionAddress.$, a) !== null) == false) {
      return false;
    }
    return WorksheetRegionAddress._o(this, a);
  }
  getHashCode() {
    return this._z;
  }
  toString() {
    return this._ah(false, false, 2, 1);
  }
  static _ab(a, b, c, d) {
    return a ^ b << 5 ^ c << 10 ^ d << 15;
  }
  _a() {
    return new WorksheetRegionAddress(1, this._y, this._aa, this._u, this._v);
  }
  _g(a) {
    return this._i(a.o, a.m);
  }
  _i(a, b) {
    if (this._n == false) {
      return false;
    }
    if (a < this._y || this._aa < a || b < this._u || this._v < b) {
      return false;
    }
    return true;
  }
  _h(a) {
    if (this._n == false) {
      return false;
    }
    if (a._y < this._y || a._u < this._u || this._aa < a._aa || this._v < a._v) {
      return false;
    }
    return true;
  }
  static _ag(a, b) {
    if (a._j(b)) {
      return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, Math.max(a._ac, b._ac), Math.min(a._ae, b._ae), Math.max(a._w, b._w), Math.min(a._x, b._x)));
    }
    return Nullable$1.toNullable(WorksheetRegionAddress.$, null);
  }
  _j(a) {
    if (a._aa < this._y || a._v < this._u || this._aa < a._y || this._v < a._u) {
      return false;
    }
    return true;
  }
  _k(a) {
    return this._y == 0 && this._aa == a.maxRowCount - 1;
  }
  _l(a) {
    return this._u == 0 && this._v == a.maxColumnCount - 1;
  }
  _ah(a, b, c, d, e = null) {
    if (this._n == false) {
      return "#REF!";
    }
    let f = this._y;
    let g = this._u;
    if (e == null) {
      e = stringEmpty();
    }
    return stringFormat1("{0}{1}{2}{3}", e, CellAddress.u(this._y, this._u, c, a, b, f, g, false, d), ":", CellAddress.u(this._aa, this._v, c, a, b, f, g, false, d));
  }
  _c(a) {
    if (a == this._u) {
      return this;
    }
    return new WorksheetRegionAddress(1, this._y, this._aa, a, this._v);
  }
  _d(a) {
    if (a == this._y) {
      return this;
    }
    return new WorksheetRegionAddress(1, a, this._aa, this._u, this._v);
  }
  _e(a) {
    if (a == this._v) {
      return this;
    }
    return new WorksheetRegionAddress(1, this._y, this._aa, this._u, a);
  }
  _f(a) {
    if (a == this._aa) {
      return this;
    }
    return new WorksheetRegionAddress(1, this._y, a, this._u, this._v);
  }
  get _w() {
    return this._u;
  }
  get _ac() {
    return this._y;
  }
  get _ad() {
    return this._aa - this._y + 1;
  }
  get _m() {
    return this._y == this._aa && this._u == this._v;
  }
  get _n() {
    return this._y >= 0 && this._u >= 0;
  }
  get _x() {
    return this._v;
  }
  get _ae() {
    return this._aa;
  }
  get _af() {
    return this._v - this._u + 1;
  }
  containsColumns(a, b) {
    return a >= this._u && b <= this._v;
  }
  intersectsWithColumns(a, b) {
    if (b < this._u || this._v < a) {
      return false;
    }
    return true;
  }
  static _o(a, b) {
    return a._u == b._u && a._y == b._y && a._v == b._v && a._aa == b._aa;
  }
  static _p(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return WorksheetRegionAddress._o(a.value, b.value);
  }
  static _q(a, b) {
    return !(WorksheetRegionAddress._o(a, b));
  }
  static _r(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return WorksheetRegionAddress._q(a.value, b.value);
  }
}
WorksheetRegionAddress.$t = markStruct(WorksheetRegionAddress, 'WorksheetRegionAddress', ValueType.$, [IComparable$1_$type.specialize(-1), IRegionAddress_$type]).initSelfReferences();
WorksheetRegionAddress._b = new WorksheetRegionAddress(1, -1, -1, -1, -1);
/**
 * @hidden
 */
export class ChangeInfo extends Base {
  constructor(a, b) {
    super();
    this.c = null;
    this.a = 0;
    this.c = a;
    this.a = b;
  }
  d(a, b) {
    if (b != null) {
      if (a != null) {
        a._ic(b);
      }
    }
  }
  b(a, b, c) {
    if (a != null && !a._c4 && (a._bm == null || a._bm != b)) {
      return a._go(b, this.a, c);
    }
    return null;
  }
  e($tContext, $tValue, a, b, c) {
    let d = typeCast(ChangeInfo$2.$.specialize($tContext, $tValue), this);
    d.x(a, b, c);
  }
  static f(a, b, c) {
    a[b] = c;
  }
  g($tContext, $tValue, a, b, c, d = false) {
    let e = typeCast(ChangeInfo$2.$.specialize($tContext, $tValue), this);
    e.z(a);
    let f = b;
    b = c;
    if (!d) {
      e.x(a, f, c);
    }
    return {
      p1: b
    };
  }
  h($tContext, $tValue, a, b) {
    let c = typeCast(ChangeInfo$2.$.specialize($tContext, $tValue), this);
    let d = c.r ? this.b(c.l(a), c.k(a), c.c) : null;
    let e = c.j(a);
    c.p(a, b);
    this.e($tContext, $tValue, a, e, b);
    this.d(c.l(a), d);
  }
  static i(a) {
    for (let b = 0; b < a.length; b++) {
    }
  }
}
ChangeInfo.$t = markType(ChangeInfo, 'ChangeInfo');
/**
 * @hidden
 */
export class SilverlightFixes extends Base {
  static staticInit() {
  }
  static get t() {
    return Encoding.uTF8;
  }
  static l(a) {
    if (a == Encoding.unicode) {
      return 1200;
    }
    if (a == Encoding.bigEndianUnicode) {
      return 1201;
    }
    if (a == Encoding.uTF8) {
      return 65001;
    }
    return 0;
  }
  static u(a) {
    switch (a) {
      case 1200: return Encoding.unicode;
      case 1201: return Encoding.bigEndianUnicode;
      case 65001: return Encoding.uTF8;
      case 932: return new Windows932Encoding();
      case 936: return new Windows936Encoding();
      case 1252: return new Windows1252Encoding();
      default: return Encoding.uTF8;
    }
  }
  static j(a) {
    return CultureInfo.currentCulture;
  }
  static p(a) {
    return truncate(Math.round(a));
  }
  static o(a) {
    return truncate(Math.round(a));
  }
  static h(a, b) {
    return round10N(a, b);
  }
  static g(a) {
    if (a < 0) {
      return Math.ceil(a);
    }
    return Math.floor(a);
  }
  static m(a) {
    throw new NotImplementedException(0);
  }
  static s(a) {
    return a.toUpperCase();
  }
  static d($t, a) {
    return true;
  }
  static c(a) {
    return true;
  }
  static r($t, a) {
    return a;
  }
  static b(a) {
    return Color.b(a, SilverlightFixes.v);
  }
  static w(a) {
    let b = a & 4294967295;
    return Color.u(((b >> 24) & 255), ((b >> 16) & 255), ((b >> 8) & 255), (b & 255));
  }
  static k(a) {
    return ((((a.l << 24) | (a.o << 16)) | (a.n << 8)) | a.m);
  }
  static e(a, b, c) {
    let d = truncate(Math.round(SilverlightFixes.f(b)));
    switch (a) {
      case 0: return SilverlightFixes.i.calendar.addYears(c, d);
      case 1: return dateAddMonths(c, d * 3);
      case 2: return SilverlightFixes.i.calendar.addMonths(c, d);
      case 3:
      case 4:
      case 6: return dateAddDays(c, d);
      case 5: return dateAddDays(c, d * 7);
      case 7: return dateAddHours(c, d);
      case 8: return dateAddMinutes(c, d);
      case 9: return dateAddSeconds(c, d);
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_Interval"), "interval");
  }
  static a(a) {
    if (a != null) {
      a = stringToLocaleUpper(a, CultureInfo.invariantCulture);
    }
    switch (a) {
      case "YYYY": return 0;
      case "Y": return 3;
      case "M": return 2;
      case "D": return 4;
      case "H": return 7;
      case "N": return 8;
      case "S": return 9;
      case "WW": return 5;
      case "W": return 6;
      default:
        if (a != "Q") {
          throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_IntervalStr"), "interval");
        }
        break;
    }
    return 1;
  }
  static q(a, b, c, d, e) {
    let f;
    let g = +c - +b;
    switch (a) {
      case 0:
        f = SilverlightFixes.i.calendar;
        return (f.getYear(c) - f.getYear(b));
      case 1:
        f = SilverlightFixes.i.calendar;
        return ((((f.getYear(c) - f.getYear(b)) * 4) + (intDivide((f.getMonth(c) - 1), 3))) - (intDivide((f.getMonth(b) - 1), 3)));
      case 2:
        f = SilverlightFixes.i.calendar;
        return ((((f.getYear(c) - f.getYear(b)) * 12) + f.getMonth(c)) - f.getMonth(b));
      case 3:
      case 4: return truncate(Math.round(SilverlightFixes.f(timeSpanTotalDays(g))));
      case 5:
        b = dateAddDays(b, (0 - SilverlightFixes.n(b, d)));
        c = dateAddDays(c, (0 - SilverlightFixes.n(c, d)));
        return intDivide(truncate(Math.round(SilverlightFixes.f(timeSpanTotalDays((+c - +b))))), 7);
      case 6: return intDivide(truncate(Math.round(SilverlightFixes.f(timeSpanTotalDays(g)))), 7);
      case 7: return truncate(Math.round(SilverlightFixes.f(timeSpanTotalHours(g))));
      case 8: return truncate(Math.round(SilverlightFixes.f(timeSpanTotalMinutes(g))));
      case 9: return truncate(Math.round(SilverlightFixes.f(timeSpanTotalSeconds(g))));
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_Interval"), "interval");
  }
  static f(a) {
    if (a >= 0) {
      return Math.floor(a);
    }
    return -Math.floor(-a);
  }
  static n(a, b) {
    if ((b < 0) || (b > 7)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_WeekdayFirst"), "weekdayFirst");
    }
    if (b == 0) {
      return 1;
    }
    return (((a.getDay() - b) + 8) % (6 | 1)) + 1;
  }
  static get i() {
    return Thread.currentThread.currentCulture;
  }
}
SilverlightFixes.$t = markType(SilverlightFixes, 'SilverlightFixes');
SilverlightFixes.v = new Color();
/**
 * @hidden
 */
export let IWorkbookProvider_$type = new Type(null, 'IWorkbookProvider');
/**
 * @hidden
 */
export let ISheetProvider_$type = new Type(null, 'ISheetProvider');
/**
 * @hidden
 */
export let IChangeInfoContext_$type = new Type(null, 'IChangeInfoContext', null, [IWorkbookProvider_$type, ISheetProvider_$type]);
/**
 * @hidden
 */
export class Workbook_ChangeInfoContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
        }
        break;
    }
  }
  get workbook() {
    return this.a;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.a;
  }
}
Workbook_ChangeInfoContext.$t = markStruct(Workbook_ChangeInfoContext, 'Workbook_ChangeInfoContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class ChangeInfo$2 extends ChangeInfo {
  constructor($tContext, $tValue, a, b, c, d, e, f, g, h, i, j) {
    super(a, b);
    this.$tContext = null;
    this.$tValue = null;
    this.u = null;
    this.r = false;
    this.s = false;
    this.m = 0;
    this.o = null;
    this.p = null;
    this.t = null;
    this.n = null;
    this.q = false;
    this.$tContext = $tContext;
    this.$tValue = $tValue;
    this.$type = this.$type.specialize(this.$tContext, this.$tValue);
    this.u = c;
    this.r = h;
    this.s = f;
    this.m = g;
    this.o = d;
    this.p = e;
    this.t = i;
    this.q = this.c == "Reset";
    this.n = j;
  }
  v(a) {
    return this.t != null ? this.t(a) : -1;
  }
  w(a) {
    return a.source;
  }
  j(a) {
    return this.u(a);
  }
  l(a) {
    return a.workbook;
  }
  k(a) {
    return a.sheet;
  }
  x(a, b, c) {
    let d = this.l(a);
    if (d != null && !d._c4 && (d._bm == null || d._bm != this.k(a))) {
      d._hu(this.$tContext, this.$tValue, a, b, c, this);
    }
  }
  y(a, b) {
    if (this.n != null) {
      this.n(a);
    }
    this.z(a);
    this.o(a, b);
  }
  z(a) {
    let b = this.l(a);
    let c = this.k(a);
    let d = this.m;
  }
}
ChangeInfo$2.$t = markType(ChangeInfo$2, 'ChangeInfo$2', ChangeInfo.$);
export class Workbook extends Base {
  constructor(..._rest) {
    super();
    this._dx = null;
    this._v = null;
    this._x = 1;
    this._fh = 0;
    this._b9 = null;
    this._cb = null;
    this._z = 1;
    this._bx = 0;
    this._ag = null;
    this._ai = 0;
    this._fo = 0;
    this._ak = null;
    this._au = null;
    this._as = null;
    this._aw = null;
    this._b1 = null;
    this._em = null;
    this._c3 = false;
    this._dc = false;
    this._ev = 0.001;
    this._f4 = 100;
    this._a4 = null;
    this._bv = null;
    this._d0 = null;
    this._a6 = 1;
    this._dg = true;
    this._di = false;
    this._dm = true;
    this._dp = true;
    this._b5 = null;
    this._j = null;
    this._gz = null;
    this._b7 = null;
    this._ce = null;
    this._bn = null;
    this._gi = 0;
    this._ei = null;
    this._ek = null;
    this._ee = null;
    this._eg = null;
    this._bi = null;
    this._bg = null;
    this._dy = null;
    this._d = null;
    this._ae = null;
    this._ch = null;
    this._g = null;
    this._dr = false;
    this._d2 = new Dictionary$2(String_$type, NamedReferenceBase.$, 2, StringComparer.c);
    this._g5 = 1;
    this._e4 = null;
    this._e7 = null;
    this._a8 = null;
    this._ba = null;
    this._de = false;
    this._jg = Size.empty;
    this._dw = new Dictionary$2(Number_$type, Sheet.$, 0);
    this._cl = false;
    this._d5 = null;
    this._eb = null;
    this._ed = null;
    this._ec = null;
    this._am = null;
    this._az = null;
    this._bt = new Workbook_ChangeInfoContext();
    this._bk = null;
    this._dv = null;
    this._b3 = null;
    /**
     * @hidden
     */
    this._bu = null;
    /**
     * @hidden
     */
    this._m = null;
    /**
     * @hidden
     */
    this._n = null;
    /**
     * @hidden
     */
    this._o = null;
    /**
     * @hidden
     */
    this._gx = null;
    /**
     * @hidden
     */
    this._gy = null;
    /**
     * @hidden
     */
    this._i = null;
    /**
     * @hidden
     */
    this._du = 0;
    /**
     * @hidden
     */
    this._fb = new Guid();
    this._t = null;
    this._isSaving = false;
    /**
     * @hidden
     */
    this._df = false;
    /**
     * @hidden
     */
    this._ad = null;
    /**
     * @hidden
     */
    this._g3 = 0;
    /**
     * @hidden
     */
    this._gk = Nullable$1.toNullable(Number_$type, null);
    /**
     * @hidden
     */
    this._gw = null;
    /**
     * @hidden
     */
    this._gn = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    /**
     * @hidden
     */
    this._l = 0;
    /**
     * @hidden
     */
    this._dt = false;
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let b = [Workbook._bz()];
          {
            let format = b[0];
            this._bt = new Workbook_ChangeInfoContext(1, this);
            if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, format)) == false) {
              throw new InvalidEnumArgumentException("format", format, WorkbookFormat_$type);
            }
            this._v = new ExcelCalcEngine(this);
            this._bx = format;
            let c = new WorkbookFontData(0, this);
            this._au = new GenericCachedCollectionEx$1(WorkbookFontData.$, c, this, 512);
            this._as = new GenericCachedCollectionEx$1(WorkbookFontData.$, new WorkbookFontData(0, this), this, 512);
            this._aw = new GenericCachedCollectionEx$1(WorkbookFontData.$, new WorkbookFontData(0, this), this, 512);
            this._bv = new WorkbookColorPalette(this);
            this._bi = new SharedStringTable(this);
            let d = new WorksheetCellFormatData(this, 0);
            d.style = this._styles$i.normalStyle;
            this._b9 = new WorksheetCellFormatCollection(d, this);
            this._cb = new WorksheetCellFormatCollection(new WorksheetCellFormatData(this, 2), this);
            this._am = new FormatLimitErrors(this);
            this._b3 = new WorkbookProtection(this);
            this._t = new ActiveCellChangedInfo(this);
            this._fb = Guid.newGuid();
            this._l = (format == 6) ? 1 : 0;
          }
        }
        break;
      case 1:
        {
          let format = _rest[0];
          this._bt = new Workbook_ChangeInfoContext(1, this);
          if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, format)) == false) {
            throw new InvalidEnumArgumentException("format", format, WorkbookFormat_$type);
          }
          this._v = new ExcelCalcEngine(this);
          this._bx = format;
          let b = new WorkbookFontData(0, this);
          this._au = new GenericCachedCollectionEx$1(WorkbookFontData.$, b, this, 512);
          this._as = new GenericCachedCollectionEx$1(WorkbookFontData.$, new WorkbookFontData(0, this), this, 512);
          this._aw = new GenericCachedCollectionEx$1(WorkbookFontData.$, new WorkbookFontData(0, this), this, 512);
          this._bv = new WorkbookColorPalette(this);
          this._bi = new SharedStringTable(this);
          let c = new WorksheetCellFormatData(this, 0);
          c.style = this._styles$i.normalStyle;
          this._b9 = new WorksheetCellFormatCollection(c, this);
          this._cb = new WorksheetCellFormatCollection(new WorksheetCellFormatData(this, 2), this);
          this._am = new FormatLimitErrors(this);
          this._b3 = new WorkbookProtection(this);
          this._t = new ActiveCellChangedInfo(this);
          this._fb = Guid.newGuid();
          this._l = (format == 6) ? 1 : 0;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _br(a) {
    let b = null;
    return new HtmlTextMetricsProvider(a);
  }
  /**
   * @hidden
   */
  _f() {
    return null;
  }
  /**
   * @hidden
   */
  get _cs() {
    return false;
  }
  /**
   * @hidden
   */
  get _cw() {
    return false;
  }
  /**
   * @hidden
   */
  static _e9() {
    let a = CultureInfo.invariantCulture.clone();
    a.numberFormat.currencySymbol = "$";
    return a;
  }
  static staticInit() {
    Workbook._a = Workbook._b();
  }
  /**
   * @hidden
   */
  static _bz() {
    if (Workbook._e2 != null) {
      return 0;
    }
    return 2;
  }
  /**
   * Converts units of 1/256s of the average character width to pixels.
   * <p class="body">
   * The units of 1/256s of the average character width are based on the font height of the normal style.
   * </p>
   * @param characterWidth256ths The number of units of 1/256s of the average character width.
   * @return The number of pixels equivalent to the 'characterWidth256ths' value.
   * @see [[pixelsToCharacterWidth256ths]]
   * @see [[WorksheetColumn.width]]
   * @see [[Worksheet.defaultColumnWidth]]
   */
  characterWidth256thsToPixels(characterWidth256ths) {
    return MathUtilities.f(this._gj * (characterWidth256ths / 256));
  }
  /**
   * Clears all external data connections from the [[Workbook]].
   */
  clearConnectionData() {
    this._m = null;
  }
  /**
   * Clears all pivot tables and associated slicers from the [[Workbook]].
   */
  clearPivotTableData() {
    if (this._eb != null) {
      this._eb.clear();
    }
    if (this._ec != null) {
      this._ec.clear();
    }
    if (this._ed != null) {
      this._ed.clear();
    }
    for (let a of fromEnum(this._worksheets$i)) {
      a._hc();
    }
  }
  /**
   * Factory method which creates new workbook font.
   * <p class="body">[[IWorkbookFont]] describes font used in excel workbook.
   * If many parts of excel workbook have same and complex (more than one property in common) font formatting, use this method in following manner:
   * <ol>
   * <li class="taskitem"><span class="taskitemtext">Create new font format with [[createNewWorkbookFont]],</span></li>
   * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given font format,</span></li>
   * <li class="taskitem"><span class="taskitemtext">Apply font format to all excel objects which use it with [[IWorkbookFont.setFontFormatting]] method.</span></li>
   * </ol></p>
   * <p class="body">Use of this procedure will simplify you code for complex font formats and increase speed of resulting program. It will not reduce total number of font formats in a workbook as font formats are internally cached no matter which method is used.</p>
   * @return The created excel font object.
   */
  createNewWorkbookFont() {
    return new WorkbookFontData(0, this);
  }
  /**
   * Creates new worksheet cell format.
   * <p class="body">[[IWorksheetCellFormat]] describes cell specific formatting (font, number format, appearance etc.). Total number of different cell formats in excel workbook is limited to [[Workbook.maxExcelCellFormatCount]].
   * If many parts of excel workbook have same and complex (more than one property in common) cell formatting, use this method in following manner:
   * <ol>
   * <li class="taskitem"><span class="taskitemtext">Create new cell format with [[createNewWorksheetCellFormat]],</span></li>
   * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given cell format,</span></li>
   * <li class="taskitem"><span class="taskitemtext">Apply cell format to all excel objects which use it with [[IWorksheetCellFormat.setFormatting]] method.</span></li>
   * </ol></p>
   * <p class="body">Use of this procedure will simplify you code for complex cell formats and increase speed of resulting program. It will not reduce total number of cell formats in a workbook as cell formats are internally cached no matter which method is used.</p>
   * @return The cell format which was created.
   */
  createNewWorksheetCellFormat() {
    return this._cd(0);
  }
  /**
   * @hidden
   */
  _cd(a) {
    let b = new WorksheetCellFormatData(this, a);
    if (a == 0) {
      b.style = this._styles$i.normalStyle;
    }
    return b;
  }
  /**
   * Gets the table with the specified name.
   * <p class="body">
   * Table names are compared case-insensitively.
   * </p>
   * @param name The name of the table to get.
   * @return A [[WorksheetTable]] instance if a table exists with the specified name; Otherwise null.
   */
  getTable(name) {
    let a;
    if (((() => { let b = this._d2.tryGetValue(name, a); a = b.p1; return b.ret; })()) == false) {
      return null;
    }
    return typeCast(WorksheetTable.$, a);
  }
  /**
   * Converts pixels to units of 1/256s of the average character width.
   * <p class="body">
   * The units of 1/256s of the average character width are based on the font height of the normal style.
   * </p>
   * @param pixels The number of pixels.
   * @return The number of units of 1/256s of the average character width equivalent to the 'pixels' value.
   * @see [[characterWidth256thsToPixels]]
   * @see [[WorksheetColumn.width]]
   * @see [[Worksheet.defaultColumnWidth]]
   */
  pixelsToCharacterWidth256ths(pixels) {
    return MathUtilities.j((pixels / this._gj) * 256);
  }
  /**
   * Protects the Workbook without a password.
   * <p class="body">When a Workbook is protected without a password, the end user may unprotect the Workbook in Excel without
   * having to supply a password. To programatically unprotect a Workbook, one may use the [[unprotect]] method.</p>
   * <p class="body">When a Workbook is protected, the values of the properties of the [[WorkbookProtection]] instance from
   * this Workbook's [[protection]] property indicate the disabled operations.</p>
   * <p class="note"><b>Note:</b> If [[isProtected]] is already true, the method will be ignored.</p>
   * @param allowEditStructure Optional boolean indicating the new value for the [[WorkbookProtection.allowEditStructure]].
   * @param allowEditWindows Optional boolean indicating the new value for the [[WorkbookProtection.allowEditWindows]].
   * @see [[hasProtectionPassword]]
   * @see [[isProtected]]
   * @see [[protection]]
   * @see [[WorkbookProtection]]
   * @see [[unprotect]]
   */
  protect(allowEditStructure = false, allowEditWindows = true) {
    this.protection._h(null, allowEditStructure, allowEditWindows);
  }
  recalculate() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._recalculate.apply(this, arguments);
      case 1: return this._recalculate1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _recalculate() {
    this._recalculate1(false);
  }
  /**
   * @hidden
   */
  _recalculate1(a) {
    this._ip(a, true);
  }
  /**
   * @hidden
   */
  _ip(a, b) {
    if (this._c4) {
      return;
    }
    if (a) {
      this._w.z();
    }
    this._w.aa(false);
    this._w.as(b);
  }
  registerUserDefinedFunction() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._registerUserDefinedFunction.apply(this, arguments);
      case 1: return this._registerUserDefinedFunction1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _registerUserDefinedFunction(a) {
    this._w.ac();
    let b = this._w.d._g(a);
    this._ie();
    return b;
  }
  /**
   * @hidden
   */
  _registerUserDefinedFunction1(a, b, c, d) {
    let e = new CustomExcelCalcFunction(a, b, c, d);
    return this._registerUserDefinedFunction(e);
  }
  /**
   * Resumes the calculation of formulas.
   * <p class="body">
   * If calculations were not suspended when this is called, it will have no effect.
   * </p>
   * <p class="body">
   * For each call to [[suspendCalculations]], a call to ResumeCalculations must be made. As soon as the number of calls to
   * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
   * </p>
   * @see [[suspendCalculations]]
   */
  resumeCalculations() {
    if (this._fh > 0) {
      this._fh--;
    }
    if (this._fh == 0 && this._de) {
      this._hm((a, b) => b._b6(this), true);
      this._de = false;
    }
  }
  save() {
    let n;
    if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 3) {
      n = 0;
    }
    switch (n) {
      case 0: return this._save.apply(this, arguments);
      case 1: return this._save1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _save1(a, b) {
    this._save(null, a, b);
  }
  /**
   * @hidden
   */
  _save(a, b, c) {
    let d = "base64";
    let e = "string";
    let f = "uint8array";
    let g = "arraybuffer";
    let h = "blob";
    let i;
    try {
      if (this.isSaving) {
        throw new InvalidOperationException(1, "The workbook is already in a save operation and cannot start another save operation.");
      }
      if (a != null) {
        if (typeCast(WorkbookSaveOptions.$, a) !== null == false) {
          let j = a;
          a = new WorkbookSaveOptions();
          a.type = (j.type);
        }
      }
      else {
        a = new WorkbookSaveOptions();
      }
      this._i8(a);
      i = a.type != null ? a.type : d;
      switch (i) {
        case d:
        case e:
        case f:
        case g:
        case h: break;
        default: throw new ArgumentException(1, "Unrecognized type: " + i);
      }
    }
    catch (k) {
      if (c != null) {
        c(k);
        return;
      }
      throw k;
    }
    this.isSaving = true;
    WorkItemScheduler.c().d(Async.n(MemoryStream.$, new MemoryStream(0), (l) => WorkItemExtensions.b(this._s(l, a), (m) => {
      this.isSaving = false;
      if (m.v != null) {
        if (c != null) {
          c(m.v);
        }
        else {
          m.y();
        }
      }
      else {
        if (b != null) {
          let n = l.getBuffer();
          switch (i) {
            case d:
              b(Convert.toBase64String(n));
              break;
            case e:
              {
                if (typeof n === 'string') {
                  b(n);
                }
                let o = "";
                let p = 4096;
                for (let q = 0; q < n.length; q += p) {
                  o += (String.fromCharCode.apply(null, n.slice(q, Math.min(q + p, n.length))));
                }
                b(o);
              }
              break;
            case f:
            case g:
            case h:
              {
                let r = new Uint8Array(l.toArray());
                switch (i) {
                  case f:
                    b(r);
                    break;
                  case g:
                    b(r.buffer);
                    break;
                  case h:
                    let s;
                    let t1 = this.currentFormat;
                    L0: while (true) {
                      switch (t1) {
                        case 0:
                        case 1:
                          s = "application/vnd.ms-excel";
                          break;
                        case 2:
                        case 6:
                          s = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                          break;
                        case 5:
                          s = "application/vnd.openxmlformats-officedocument.spreadsheetml.template";
                          break;
                        case 3:
                          s = "application/vnd.ms-excel.sheet.macroEnabled.12";
                          break;
                        case 4:
                          s = "application/vnd.ms-excel.template.macroEnabled.12";
                          break;
                        default:
                          t1 = 0;
                          continue L0;
                      }
                      break;
                    }
                    b(new Blob([r.buffer], { type: s }));
                    break;
                }
              }
              break;
          }
        }
      }
    })));
  }
  /**
   * Gets the value indicating whether the [[Workbook]] is currently being saved.
   */
  get isSaving() {
    return this._isSaving;
  }
  /**
   * Gets the value indicating whether the [[Workbook]] is currently being saved.
   */
  set isSaving(a) {
    this._isSaving = a;
  }
  /**
   * @hidden
   */
  _ix(a, b = null) {
    b = b || new WorkbookSaveOptions();
    if (a == null) {
      throw new ArgumentNullException(2, "stream", ExcelUtils.ef("LE_ArgumentNullException_SaveStream"));
    }
    if (a.canSeek == false || a.canRead == false) {
      {
        let c = new MemoryStream(0);
        try {
          this._ix(c, b);
          let d = c.getBuffer();
          a.write(d, 0, c.length);
          return;
        }
        finally {
          if (c != null) {
            c.dispose();
          }
        }
      }
    }
    this._i8(b);
    WorkItemExtensions.o(this._s(a, b));
  }
  /**
   * Sets the current format of the workbook.
   * @param format The file format to use when imposing format restrictions and saving.
   * @throws [[InvalidEnumArgumentException]] 'format' is not defined in the [[WorkbookFormat]] enumeration.
   * @throws [[InvalidOperationException]] The workbook already contains data which exceeds the limits imposed by 'format'.
   * @see [[currentFormat]]
   */
  setCurrentFormat(format) {
    if (this._bx == format) {
      return;
    }
    if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, format)) == false) {
      throw new InvalidEnumArgumentException("format", format, WorkbookFormat_$type);
    }
    let a = this._an();
    this._ja(a, format);
    if (a.d) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_WorkbookDataViolatesFormatLimits"));
    }
    this._i7(format);
    let b = this._bx;
    this._iz(format);
    this._hw(b);
    Workbook._a[2].e(Workbook_ChangeInfoContext.$, WorkbookFormat_$type, this._bt, b, this._bx);
  }
  /**
   * Temporarily suspends the calculation of formulas.
   * <p class="body">
   * This should be used when adding many formulas or modifying large amounts of data on a workbook at once so formulas are not calculated
   * each time cells are dirtied.
   * </p>
   * <p class="body">
   * For each call to SuspendCalculations, a call to [[resumeCalculations]] must be made. As soon as the number of calls to
   * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
   * </p>
   * @see [[resumeCalculations]]
   */
  suspendCalculations() {
    this._fh++;
  }
  /**
   * Removes the Workbook protection.
   * @see [[isProtected]]
   * @see [[hasProtectionPassword]]
   * @see [[protect]]
   */
  unprotect() {
    this.protection._b.l();
  }
  static load() {
    let n;
    if (arguments.length === 3) {
      n = 1;
    }
    else if (arguments.length === 4) {
      n = 0;
    }
    switch (n) {
      case 0:
        arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
        arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
        return Workbook._load1.apply(null, arguments);
      case 1:
        arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
        arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
        return Workbook._load2.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _load2(a, b, c) {
    Workbook._load1(a, null, b, c);
  }
  /**
   * @hidden
   */
  static _load1(a, b, c, d) {
    WorkItemScheduler.c().d(WorkItemExtensions.e(Workbook.$, Workbook._p(a, b || new WorkbookLoadOptions()), (e) => {
      if (e.v != null) {
        if (d != null) {
          d(e.v);
        }
        else {
          e.y();
        }
      }
      else {
        c(WorkItemExtensions.m(Workbook.$, e));
      }
    }));
  }
  /**
   * @hidden
   */
  static _bs(a, b = null) {
    return WorkItemExtensions.m(Workbook.$, Workbook._p(a, b || new WorkbookLoadOptions()));
  }
  /**
   * @hidden
   */
  static _p(a, b) {
    return Workbook._q(a, "stream", b);
  }
  /**
   * Returns the WorkbookFormat based on the file extension of the specified file.
   * @param fileName The filename of an excel file.
   * @return The workbook format based on the file extension of the file, or null if the correct format cannot be determined.
   */
  static getWorkbookFormat(fileName) {
    return unwrapNullable(this._getWorkbookFormat$i.apply(this, arguments));
  }
  /**
   * @hidden
   */
  static _getWorkbookFormat$i(a) {
    let b = IOPath.getExtension(a).toLowerCase();
    switch (b) {
      case ".xls": return Nullable$1.toNullable(WorkbookFormat_$type, 0);
      case ".xlt": return Nullable$1.toNullable(WorkbookFormat_$type, 1);
      case ".xlsx": return Nullable$1.toNullable(WorkbookFormat_$type, 2);
      case ".xlsm": return Nullable$1.toNullable(WorkbookFormat_$type, 3);
      case ".xltm": return Nullable$1.toNullable(WorkbookFormat_$type, 4);
      case ".xltx": return Nullable$1.toNullable(WorkbookFormat_$type, 5);
    }
    return Nullable$1.toNullable(WorkbookFormat_$type, null);
  }
  /**
   * Determines whether the workbook in the specified stream is encrypted with an open password.
   * @param stream The stream to check for encryption.
   * @throws [[ArgumentNullException]] Occurs when 'stream' is null.
   * @return True if the stream contains a workbook which is encrypted; False otherwise
   */
  static isWorkbookEncrypted(stream) {
    arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
    arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
    return this._isWorkbookEncrypted$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  static _isWorkbookEncrypted$i(a) {
    DocCoreUtils.au(a, "stream");
    let b = a.position;
    try {
      if (StructuredStorageManager._j(a) == false) {
        return false;
      }
      {
        let c = new StructuredStorageManager(a, true);
        try {
          if (OleDataSpaces.c(c)) {
            return true;
          }
          {
            let d = c._ac("Workbook");
            try {
              if (ExcelUtils.bj(d)) {
                return true;
              }
            }
            finally {
              if (d != null) {
                d.dispose();
              }
            }
          }
        }
        finally {
          if (c != null) {
            c.dispose();
          }
        }
      }
    }
    catch (e) {
    }
    finally {
      if (a.canSeek) {
        a.position = b;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _g7(a) {
    if (this._ee == null) {
      this._ee = new List$1(BinaryData.$, 0);
    }
    this._ee.add(a);
  }
  /**
   * @hidden
   */
  _g8(a) {
    if (this._eg == null) {
      this._eg = new List$1(BinaryData.$, 0);
    }
    this._eg.add(a);
  }
  /**
   * @hidden
   */
  _g9(a) {
    if (a == null) {
      return;
    }
    this._w.w(a);
  }
  /**
   * @hidden
   */
  _ha(a) {
    if (a == null) {
      return;
    }
    this._w.am(a, 0);
  }
  /**
   * @hidden
   */
  _hb(a) {
    if (this._eb == null) {
      this._eb = new List$1(PivotCacheInfo.$, 0);
    }
    this._eb.add(a);
  }
  /**
   * @hidden
   */
  _hc(a) {
    if (this._ec == null) {
      this._ec = new List$1(PivotCacheInfo.$, 0);
    }
    this._ec.add(a);
  }
  /**
   * @hidden
   */
  _hd(a) {
    if (this._ed == null) {
      this._ed = new List$1(BinaryData.$, 0);
    }
    this._ed.add(a);
  }
  /**
   * @hidden
   */
  get _cn() {
    switch (this.currentFormat) {
      case 0:
      case 1: return false;
    }
    return true;
  }
  /**
   * @hidden
   */
  _he(a, b) {
    if (this._dx == null) {
      this._dx = new Dictionary$2(String_$type, Array_$type, 0);
    }
    let c = new Array(b.length);
    b.read(c, 0, c.length);
    this._dx.addItem(a, c);
  }
  /**
   * @hidden
   */
  *__d7() {
    if (this._dx != null) {
      for (let a of fromEnum(this._dx)) {
        yield a;
      }
    }
  }
  _d7() {
    return toEnum(() => this.__d7());
  }
  /**
   * @hidden
   */
  static _fc(a) {
    if (a == null) {
      return null;
    }
    if (a._bu == null) {
      a._bu = new Workbook_MetricsProviderCache(a);
    }
    else {
      a._bu._g();
    }
    return a._bu;
  }
  /**
   * @hidden
   */
  static _ep(a, b, c) {
    return b * Workbook._eu(a, c);
  }
  /**
   * @hidden
   */
  static _eq(a) {
    return MathUtilities.f(a * 20);
  }
  /**
   * @hidden
   */
  static _er(a, b, c, d = true) {
    let e = b / Workbook._eu(a, c);
    if (d) {
      return MathUtilities.f(e);
    }
    return e;
  }
  /**
   * @hidden
   */
  static _es(a) {
    return a / 20;
  }
  /**
   * @hidden
   */
  _hi() {
    if (this.calculationMode != 0) {
      this._ip(false, this.calculationMode == 1);
    }
  }
  /**
   * @hidden
   */
  _hj(a) {
    if (this._cm || this.calculationMode == 0) {
      return;
    }
    this._w.ab(a, this.calculationMode == 1);
  }
  /**
   * @hidden
   */
  _gv(a) {
    if (a != null && a.length == 6) {
      if (stringStartsWith(a, "+mn")) {
        if (this._gy == null) {
          return "Calibri";
        }
        return this._gy;
      }
      else if (stringStartsWith(a, "+mj")) {
        if (this._gx == null) {
          return "Cambria";
        }
        return this._gx;
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  _bh(a) {
    if (a && this._bg == null) {
      this._bg = new SharedStringTable(this);
    }
    return this._bg;
  }
  /**
   * @hidden
   */
  static _fr(a) {
    if (ExcelUtils.au(a)) {
      return 4000;
    }
    return 64000;
  }
  /**
   * Returns the number of columns that are supported by the specified format.
   * @param format The format used by the workbook.
   * @return The maximum number of columns supported by the format.
   */
  static getMaxColumnCount(format) {
    return Workbook._fe(format);
  }
  /**
   * @hidden
   */
  static _fe(a) {
    if (ExcelUtils.au(a)) {
      return 256;
    }
    return 16384;
  }
  /**
   * Returns the number of rows that are supported by the specified format.
   * @param format The format used by the workbook.
   * @return The maximum number of rows supported by the format.
   */
  static getMaxRowCount(format) {
    if (ExcelUtils.au(format)) {
      return 65536;
    }
    return 1048576;
  }
  /**
   * @hidden
   */
  _a2(a, b) {
    let c = null;
    if (b != null) {
      c = this._namedReferences$i._find1(a, b);
    }
    else {
      c = this._a3(a);
    }
    if (c == null && this._cu) {
      let d = b != null ? b : this;
      for (let e of fromEnum(this._en)) {
        if (e.scope == d && StringUtilities.c(a, e.name, this._e6, 1) == 0) {
          c = e;
          break;
        }
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  _g2() {
    let a = 1;
    while (this._dw.containsKey(a)) {
      a++;
    }
    return a;
  }
  /**
   * @hidden
   */
  _g4() {
    return this._g5++;
  }
  /**
   * @hidden
   */
  _hk(a) {
    do {
      a++;
    } while (this._d5 != null && this._d5.contains(a) == false);
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _d8() {
    if (this._eb == null) {
      return Enumerable.k(PivotCacheInfo.$);
    }
    return this._eb;
  }
  /**
   * @hidden
   */
  _d9() {
    if (this._ec == null) {
      return Enumerable.k(PivotCacheInfo.$);
    }
    return this._ec;
  }
  /**
   * @hidden
   */
  static _et(a, b) {
    let c = a != null ? a._jk : Workbook._jh;
    return b ? c.height : c.width;
  }
  /**
   * @hidden
   */
  _ea() {
    if (this._ed == null) {
      return Enumerable.k(BinaryData.$);
    }
    return this._ed;
  }
  /**
   * @hidden
   */
  _cj(a) {
    let b = this._customTableStyles$i._item1(a);
    if (b != null) {
      return b;
    }
    b = this._standardTableStyles$i._item1(a);
    return b;
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    let c;
    switch (b) {
      case 0:
      case 9: return null;
      case 1:
        c = 101;
        break;
      case 3:
        c = 102;
        break;
      case 2:
        c = 103;
        break;
      case 4:
        c = 104;
        break;
      case 5:
        c = 105;
        break;
      case 7:
        c = 107;
        break;
      case 6:
        c = 109;
        break;
      case 8:
        c = 110;
        break;
      default: return null;
    }
    if (ExcelUtils.au(this.currentFormat)) {
      let d = a.table;
      if (d == null) {
        return null;
      }
      let e;
      let f;
      let g = d._d8(e, f);
      e = g.p0;
      f = g.p1;
      let h = new CellAddressRange(1, new CellAddress(1, e, true, a._at, true), new CellAddress(1, f, true, a._at, true));
      let i = new FormulaContext(4, d.worksheet, f + 1, a._at, this.currentFormat, null, CultureInfo.invariantCulture, this.cellReferenceMode);
      let j = h.s(i, false);
      return Formula._parse3(stringFormat("=SUBTOTAL({0}{2}{1})", c, j, FormulaParser.by(i.o.numberFormat.numberDecimalSeparator)), i.b, i.h, i.o);
    }
    else {
      return Formula._parse3(stringFormat("=SUBTOTAL({0},[{1}])", c, StructuredTableReference.ad(a.name)), this.cellReferenceMode, this.currentFormat, CultureInfo.invariantCulture);
    }
  }
  /**
   * @hidden
   */
  _ck(a) {
    let b = a.totalFormula;
    if (b == null) {
      return 0;
    }
    let c = this._gl(a, b);
    if (c.hasValue) {
      return c.value;
    }
    return 9;
  }
  /**
   * @hidden
   */
  _gl(a, b) {
    if (b._e.length != 3) {
      return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
    }
    let c = typeCast(IntToken.$, b._e[0]);
    if (c == null) {
      return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
    }
    let d;
    switch (c.p) {
      case 101:
        d = 1;
        break;
      case 102:
        d = 3;
        break;
      case 103:
        d = 2;
        break;
      case 104:
        d = 4;
        break;
      case 105:
        d = 5;
        break;
      case 107:
        d = 7;
        break;
      case 109:
        d = 6;
        break;
      case 110:
        d = 8;
        break;
      default: return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
    }
    let e = typeCast(AreaToken.$, b._e[1]);
    if (e != null) {
      let f = a.table;
      let g = e.x.j(f.worksheet, f.dataAreaRegion.lastRow + 1, a._at, e.v);
      if (g == null || a.dataAreaRegion.equals(g) == false) {
        return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
      }
    }
    else if (ExcelUtils.au(this.currentFormat) == false) {
      let h = this._e6;
      let i = typeCast(StructuredTableReference.$, b._e[1]);
      if (i == null || StringUtilities.c(i.ag, a.name, h, 1) != 0) {
        return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
      }
      if (i.ah != null && StringUtilities.c(i.ah, a.table.name, h, 1) != 0) {
        return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
      }
    }
    let j = typeCast(FunctionVOperator.$, b._e[2]);
    if (j == null || j.$function != Function._n5) {
      return Nullable$1.toNullable(ST_TotalsRowFunction_$type, null);
    }
    return Nullable$1.toNullable(ST_TotalsRowFunction_$type, d);
  }
  /**
   * @hidden
   */
  static _eu(a, b) {
    return 1440 / Workbook._et(a, b);
  }
  /**
   * @hidden
   */
  static _hl(a, b, c, d) {
    if (a == null) {
      b = 1;
      c = 2;
      d = ExcelUtils.cq;
      return {
        p1: b,
        p2: c,
        p3: d
      };
    }
    b = a.cellReferenceMode;
    c = a.currentFormat;
    d = a._e6;
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _bf(a) {
    if (a == null || a == this._gw) {
      return this._bb;
    }
    if (a == "<AddInFunctions>") {
      return this._a9;
    }
    if (this._dy == null) {
      this._dy = new Dictionary$2(String_$type, WorkbookReferenceBase.$, 2, StringUtilities.e);
    }
    let b;
    if (((() => { let c = this._dy.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      b = new ExternalWorkbookReference(a, this);
      this._dy.addItem(a, b);
    }
    return b;
  }
  /**
   * @hidden
   */
  _be(a, b = '|') {
    let c;
    let d;
    let e = FormulaParser.ef(a, c, d, b);
    c = e.p1;
    d = e.p2;
    if (Workbook._c6(c, d)) {
      return this._bd(c, UriUtilities.b(d));
    }
    else {
      return this._bc(c, d);
    }
  }
  /**
   * @hidden
   */
  static _c5(a, b = '|') {
    let c;
    let d;
    let e = FormulaParser.ef(a, c, d, b);
    c = e.p1;
    d = e.p2;
    return Workbook._c6(c, d);
  }
  /**
   * @hidden
   */
  static _c6(a, b) {
    return a != null && a.indexOf('.') > 0;
  }
  /**
   * @hidden
   */
  _bc(a, b) {
    if (this._dy == null) {
      this._dy = new Dictionary$2(String_$type, WorkbookReferenceBase.$, 2, StringUtilities.e);
    }
    let c = DdeLinkWorkbookReference.aj(a, b);
    let d;
    if (!((() => { let e = this._dy.tryGetValue(c, d); d = e.p1; return e.ret; })())) {
      this._dy.item(c, d = new DdeLinkWorkbookReference(a, b, this));
    }
    return typeCast(DdeLinkWorkbookReference.$, d);
  }
  /**
   * @hidden
   */
  _bd(a, b) {
    if (this._dy == null) {
      this._dy = new Dictionary$2(String_$type, WorkbookReferenceBase.$, 2, StringUtilities.e);
    }
    if (this._dv == null) {
      this._dv = new Dictionary$2(ValueTuple$2.$.specialize(String_$type, Uri.$), OleLinkWorkbookReference.$, 2, Workbook_OleLinkInfoComparer._a);
    }
    let c = ValueTuple.a(String_$type, Uri.$, a, b);
    let d;
    if (((() => { let e = this._dv.tryGetValue(c, d); d = e.p1; return e.ret; })()) == false) {
      d = new OleLinkWorkbookReference(c._a, c._b, this);
      this._dv.addItem(c, d);
      this._dy.item(d.x, d);
    }
    return d;
  }
  /**
   * @hidden
   */
  _a3(a) {
    let b;
    let c = this._d2.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * @hidden
   */
  _bl(a) {
    let b;
    let c = this._dw.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * @hidden
   */
  _an() {
    this._am.h();
    return this._am;
  }
  /**
   * @hidden
   */
  _hm(a, b) {
    this._hn(a, this._namedReferences$i, this._sheets$i, b);
  }
  /**
   * @hidden
   */
  _hn(a, b, c, d) {
    for (let e of fromEnum(b)) {
      if (e._j != null) {
        a(null, e._j);
      }
    }
    this._hp(a, c, d);
  }
  /**
   * @hidden
   */
  _hp(a, b, c) {
    for (let d of fromEnum(b)) {
      switch (d.type) {
        case 1:
          this._ho(WorksheetShape.$, d, d._p, a, c);
          continue;
        case 0: break;
        default: continue;
      }
      let e = d;
      if (e._d6) {
        for (let f of fromEnum(e._dataValidationRules$i.keys)) {
          let g = f._l(null);
          let h = f._m(null);
          if (g != null) {
            a(e, g);
          }
          if (h != null) {
            a(e, h);
          }
        }
      }
      for (let i of fromEnum(e._tables$i)) {
        for (let j of fromEnum(i._columns$i)) {
          let k = j.columnFormula;
          if (k != null) {
            if (k._ab == null || k != k._ab.getCellFormula(k._bb)) {
              a(e, k);
            }
          }
          if (i.isTotalsRowVisible == false && j._aa != null) {
            a(e, j._aa);
          }
        }
      }
      if (c) {
        e._conditionalFormats$i._ay(a);
      }
      this._ho(WorksheetShape.$, e, e._shapes$i, a, c);
      let l = new List$1(Array_$type, 0);
      for (let m of fromEnum(e._rows$i)) {
        if (m._bx == false) {
          continue;
        }
        l.clear();
        l.o(m._br._j);
        for (let n = 0; n < l.count; n++) {
          let o = l._inner[n];
          for (let p = 0; p < o.length; p++) {
            let q = o[p];
            if (q == null) {
              continue;
            }
            let r = q._formula;
            if (r != null && r._cj) {
              a(e, r._i);
            }
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ho($t, a, b, c, d) {
    for (let e of fromEnum(b)) {
      let f = typeCast(WorksheetShapeGroupBase.$, e);
      if (f != null) {
        this._ho(WorksheetShape.$, a, f._shapes$i, c, d);
      }
      let g = typeCast(WorksheetChart.$, e);
      if (g != null) {
        if (g._g3 != null) {
          for (let h = 0; h < g._g3.count; h++) {
            c(a, g._g3._inner[h]);
          }
        }
        if (d) {
          g.iterateFormulas(c);
        }
      }
      let i = typeCast(UnknownShape.$, e);
      if (i != null && i._eg != null) {
        if (i._eg.fmlaMacro != null) {
          c(a, i._eg.fmlaMacro);
        }
      }
      if (e._h == null) {
        continue;
      }
      if (e._h.l != null && e._h.l.c != null) {
        e._h.l.c.f(a, c);
      }
      if (e._h.w != null && e._h.w.b != null) {
        e._h.w.b.f(a, c);
      }
      if (e._h.j != null && e._h.j.e != null) {
        e._h.j.e.f(a, c);
      }
      if (e._h.o != null) {
        if (e._h.o.c != null) {
          e._h.o.c.f(a, c);
        }
        if (e._h.o.e != null) {
          if (e._h.o.e.c != null) {
            e._h.o.e.c.f(a, c);
          }
          if (e._h.o.e.e != null) {
            e._h.o.e.e.f(a, c);
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _hs(a) {
    this._w.an(a);
  }
  /**
   * @hidden
   */
  _ht(a) {
    if (this._c4) {
      return;
    }
    this._w.ap(a);
  }
  /**
   * @hidden
   */
  _hu($tContext, $tValue, a, b, c, d) {
    if (this._az != null) {
      this._az._onChange$2$i($tContext, $tValue, a, !this._df, b, c, d);
    }
  }
  /**
   * @hidden
   */
  _hv(a) {
    if (this._az != null) {
      this._az.onConditionalFormatChange(a);
    }
  }
  /**
   * @hidden
   */
  _hw(a) {
    for (let b of fromEnum(this._sheets$i)) {
      b._ao(a);
    }
    this._hm((c, d) => d._bx(this, a), true);
  }
  /**
   * @hidden
   */
  _hx(a) {
    this._v.ak(a);
  }
  /**
   * @hidden
   */
  _hy() {
    this._fo++;
    this._it();
    for (let a of fromEnum(this._worksheets$i)) {
      a._rows$i._az(false);
    }
  }
  /**
   * @hidden
   */
  _hz() {
    Workbook._a[8].e(Workbook_ChangeInfoContext.$, Workbook.$, this._bt, this, this);
  }
  /**
   * @hidden
   */
  _h0(a) {
    if (a.scope == this) {
      this._ih(a);
    }
    if (this._cm == false) {
      this._hm((b, c) => c._b6(this), true);
    }
    else {
      this._de = true;
    }
  }
  /**
   * @hidden
   */
  _h1(a) {
    if (a.scope == this) {
      this._ii(a);
    }
    this._hm((b, c) => c._by(a), true);
  }
  /**
   * @hidden
   */
  _h2(a, b) {
    if (a.scope == this) {
      if (this._d2.removeItem(b) == false) {
      }
      this._d2.item(a.name, a);
    }
  }
  /**
   * @hidden
   */
  _h8(a) {
    let b = this._styles$i.normalStyle;
    let c = new List$1(WorksheetCellFormatData.$, 0);
    for (let d of fromEnum(this._ca)) {
      if (d.style == a) {
        c.add(d);
      }
    }
    let e = false;
    for (let f = 0; f < c.count; f++) {
      let g = c._inner[f];
      let h = g._bu();
      h.style = b;
      if (this._ca._a(h) != null) {
        e = true;
        continue;
      }
      this._ca._remove(g);
      g.style = b;
      this._ca._q(g);
    }
    if (e) {
      for (let i of fromEnum(this._worksheets$i)) {
        for (let j of fromEnum(i._rows$i)) {
          if (j._hasCellFormat && j.cellFormat.style == a) {
            j.cellFormat.style = b;
          }
          if (j._by == false) {
            continue;
          }
          let m = j._ah;
          for (let l = 0; l < m.length; l++) {
            let k = m[l];
            if (k.a == null) {
              break;
            }
            for (let n = 0; n < k.a.length; n++) {
              let o = k.a[n];
              if (o == null || o.style != a) {
                continue;
              }
              let p = GenericCacheElementEx.p(WorksheetCellFormatData.$, o, true);
              o = p.p0;
              o.style = b;
              let q = GenericCacheElementEx.z(WorksheetCellFormatData.$, this._ca, o);
              o = q.p1;
              k.a[n] = o;
            }
          }
        }
        for (let r of fromEnum(i._ff)) {
          let s = r.b;
          if (s.style != a) {
            continue;
          }
          let t = GenericCacheElementEx.p(WorksheetCellFormatData.$, s, true);
          s = t.p0;
          s.style = b;
          let u = GenericCacheElementEx.z(WorksheetCellFormatData.$, this._ca, s);
          s = u.p1;
          r.b = s;
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ib(a, b, c) {
    this._hm((d, e) => {
      if (e._aw(a, b)) {
        c.add(e);
      }
    }, true);
  }
  /**
   * @hidden
   */
  _h9(a, b) {
    this._hm((c, d) => d._bz(a, b), true);
  }
  /**
   * @hidden
   */
  _ia(a) {
    this._w.ao(a);
    this._hm((b, c) => c._bs(this, a), true);
    this._ii(a);
  }
  /**
   * @hidden
   */
  _go(a, b, c) {
    if (this._az != null && !this._c3 && !this._df && (this._bk == null || this._bk != a)) {
      return this._az.onTransactionalChangeBegin(b, c);
    }
    return null;
  }
  /**
   * @hidden
   */
  _ic(a) {
    if (this._az != null && !this._df) {
      this._az.onTransactionalChangeEnd(a);
    }
  }
  /**
   * @hidden
   */
  _id(a) {
    if (this._az != null && !this._df) {
      this._az.onTransactionalChangeRollback(a);
    }
  }
  /**
   * @hidden
   */
  _ig() {
    this._t.e();
    if (this._az != null) {
      Workbook._a[10].e(Workbook_ChangeInfoContext.$, Workbook.$, this._bt, this, this);
    }
  }
  /**
   * @hidden
   */
  _h4(a) {
    if (this.windowOptions.selectedSheet == null) {
      this.windowOptions.selectedSheet = a;
    }
    if (this._ag != null) {
      for (let b of fromEnum(this._ag)) {
        b._y(a);
      }
    }
    this._dw.item(a._am, a);
  }
  /**
   * @hidden
   */
  _h5(a, b) {
    let c = typeCast(Worksheet.$, a);
    this._bb.ad();
    if (c != null) {
      this._hm((d, e) => e._b3(c, b), true);
    }
    this._v.aa();
    if (this._az != null) {
      Workbook._a[7].e(Workbook_ChangeInfoContext.$, Workbook.$, this._bt, this, this);
    }
  }
  /**
   * @hidden
   */
  _h3() {
    if (this._az != null) {
      Workbook._a[4].e(Workbook_ChangeInfoContext.$, Workbook.$, this._bt, this, this);
    }
  }
  /**
   * @hidden
   */
  _h6(a, b) {
    let c = typeCast(Worksheet.$, a);
    if (c != null) {
      this._bb.ae(b);
    }
    if (this.windowOptions.selectedSheet == a) {
      let d = null;
      for (let e = 0; e < this._sheets$i.count; e++) {
        if (this._sheets$i._item(e)._e.visibility == 0) {
          d = this._sheets$i._item(e);
          break;
        }
      }
      this.windowOptions.selectedSheet = d;
    }
    let f = null;
    if (this._cv && c != null) {
      let g = null;
      for (let h = this._namedReferences$i.count - 1; h >= 0; h--) {
        let i = this._namedReferences$i.item(h);
        if (i.scope == c) {
          if (g == null) {
            g = new HashSet$1(NamedReference.$, 0);
            this._hm((j, k) => {
              let n = k._e;
              for (let m = 0; m < n.length; m++) {
                let l = n[m];
                let o = typeCast(NameToken.$, l);
                if (o == null) {
                  continue;
                }
                let p = typeCast(NamedReference.$, o.u);
                if (p != null && p.scope == c) {
                  g.add_1(p);
                }
              }
            }, true);
          }
          if (g.contains(i) == false || this._d2.containsKey(i.name)) {
            if (f == null) {
              f = new List$1(Number_$type, 0);
            }
            f.add(h);
            continue;
          }
          i._af = this;
          this._d2.addItem(i.name, i);
        }
      }
    }
    if (c != null) {
      this._hm((j, k) => k._b4(c, b), true);
    }
    if (f != null) {
      for (let j of fromEnum(f)) {
        this._namedReferences$i.removeAt(j);
      }
    }
    if (this._cq) {
      for (let k of fromEnum(this._customViews$i)) {
        k._z(a);
      }
    }
    if (c != null && c._d5) {
      for (let l of fromEnum(c._dataTables$i)) {
        this._w.al(l);
      }
    }
    if (c != null) {
      for (let m of fromEnum(this._sheets$i)) {
        if (m._p != null) {
          m._p._ah((n) => {
            let o = typeCast(IChartObject_$type, n);
            if (o != null) {
              o.verifyFormulas(c);
            }
          });
        }
      }
    }
    this._dw.removeItem(a._am);
    this._bk = null;
    this._v.aa();
  }
  /**
   * @hidden
   */
  _h7(a) {
    let b = typeCast(Worksheet.$, a);
    this._bk = a;
    if (this._az != null) {
      this._az.onSheetRemoving(a);
    }
    if (b != null) {
      for (let c of fromEnum(b._rows$i._n(0, b._rows$i.maxCount - 1, false))) {
        for (let d of fromEnum(c._ci(false))) {
          c._d6(d, null, false);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ar(a, b, c, d, e, f, g = false, h = false) {
    f = false;
    let i;
    if (((() => { let j = Formula._a3("=" + a, b, this.currentFormat, this._e6, i); i = j.p4; return j.ret; })()) == false) {
      return {
        ret: null,
        p5: f
      };
    }
    let j = new FormulaContext(3, this, c, d, e, i);
    i._b5(j);
    return {
      ret: ((() => { let k = this._ap(j, f, g, h); f = k.p1; return k.ret; })()),
      p5: f
    };
  }
  /**
   * @hidden
   */
  _ap(a, b, c = false, d = false) {
    let e = a.d;
    b = false;
    if (e._e.length == 1) {
      return {
        ret: ((() => { let f = this._aq(e._e[0], a, b, d); b = f.p2; return f.ret; })()),
        p1: b
      };
    }
    let f = new Stack$1(RefBase.$);
    for (let g = 0; g < e._e.length; g++) {
      let h = e._e[g];
      if (typeCast(UnionOperator.$, h) !== null) {
        if (f.f < 2) {
          return {
            ret: null,
            p1: b
          };
        }
        let i = RegionGroupCalcReference._a7(f.e());
        if (i == null) {
          return {
            ret: null,
            p1: b
          };
        }
        let j = RegionGroupCalcReference._a7(f.e());
        if (j == null) {
          return {
            ret: null,
            p1: b
          };
        }
        if (i._u != j._u) {
          return {
            ret: null,
            p1: b
          };
        }
        f.h(RegionGroupCalcReference._a6(i, j));
        continue;
      }
      else if (typeCast(IsectOperator.$, h) !== null) {
        if (f.f < 2) {
          return {
            ret: null,
            p1: b
          };
        }
        let k = RegionGroupCalcReference._a7(f.e());
        if (k == null) {
          return {
            ret: null,
            p1: b
          };
        }
        let l = RegionGroupCalcReference._a7(f.e());
        if (l == null) {
          return {
            ret: null,
            p1: b
          };
        }
        if (k._u != l._u) {
          return {
            ret: null,
            p1: b
          };
        }
        f.h(RegionGroupCalcReference._a3(k, l));
        continue;
      }
      else if (c) {
        if (typeCast(AttrTokenBase.$, h) !== null && (typeCast(AttrSumToken.$, h) !== null) == false) {
          continue;
        }
        else if (typeCast(ParenToken.$, h) !== null) {
          continue;
        }
      }
      let m;
      let n = ((() => { let o = this._aq(h, a, m, d); m = o.p2; return o.ret; })());
      if (n == null) {
        return {
          ret: null,
          p1: b
        };
      }
      f.h(n);
    }
    if (f.f == 1) {
      return {
        ret: f.d(),
        p1: b
      };
    }
    return {
      ret: null,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _aq(a, b, c, d = false) {
    c = false;
    let e = typeCast(ReferenceToken.$, a);
    if (e == null || e.r) {
      return {
        ret: null,
        p2: c
      };
    }
    let f = typeCast(CellReferenceToken.$, e);
    if (f != null) {
      if (f.w) {
        return {
          ret: null,
          p2: c
        };
      }
      if (false == b.l.e && f.v && f.p) {
        if (d) {
          return {
            ret: null,
            p2: c
          };
        }
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_RelativeR1C1AddressNeedsOriginCell"));
      }
    }
    else {
      c = typeCast(NameToken.$, e) !== null || typeCast(StructuredTableReference.$, e) !== null;
    }
    if (false == b.l.e) {
      let g = typeCast(StructuredTableReference.$, e);
      if (g != null && g.aa) {
        if (d) {
          return {
            ret: null,
            p2: c
          };
        }
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CurrentTableRowAddressNeedsOriginCell"));
      }
    }
    let h = typeCast(RefBase.$, e.n(b));
    if (h == ExcelReferenceError._a2 || typeCast(NamedCalcReferenceUnconnected.$, h) !== null) {
      return {
        ret: null,
        p2: c
      };
    }
    return {
      ret: h,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _ij(a) {
    let b = this._df;
    this._df = false;
    try {
      a();
    }
    finally {
      this._df = b;
    }
  }
  /**
   * @hidden
   */
  _il(a, b) {
    if (!this._c3 && (this._bk == null || this._bk != a.worksheet)) {
      if (this._az != null) {
        this._az.onCellValueChange(a, b);
      }
      a.worksheet._conditionalFormats$i._az(a, b);
    }
  }
  /**
   * @hidden
   */
  _iq(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "owner");
    }
    if (this._az == null) {
      this._az = a;
    }
    else {
      throw new NotSupportedException(1, "Workbooks can not have multiple owners");
    }
  }
  /**
   * @hidden
   */
  _ir(a) {
    if (a == null) {
      return;
    }
    this._w.au(a);
  }
  /**
   * @hidden
   */
  _is(a) {
    if (a == null) {
      return;
    }
    this._w.am(a, 1);
  }
  /**
   * @hidden
   */
  static _ey(a, b, c, d) {
    if (a != null) {
      let e = a._jk;
      let f = Workbook._jh;
      let g = c ? e.height : e.width;
      let h = c ? f.height : f.width;
      if (g != h) {
        let i = d ? g / h : h / g;
        return truncate(MathUtilities.f(b * i));
      }
    }
    return b;
  }
  /**
   * @hidden
   */
  _iz(a) {
    this._bx = a;
  }
  /**
   * @hidden
   */
  _i6(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "owner");
    }
    if (a == this._az) {
      this._az = null;
    }
  }
  /**
   * @hidden
   */
  _i9() {
    if (!this._cn) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ChartNotSupported"));
    }
  }
  /**
   * @hidden
   */
  _jc(a, b) {
    let c = this;
    if (b != null) {
      c = b.scope;
    }
    if (this._cv) {
      let d = this._namedReferences$i.findAll(a);
      for (let f = 0; f < d.length; f++) {
        let e = d[f];
        if (e == b) {
          continue;
        }
        if (b._y == false && e._y == false && e.scope != c) {
          continue;
        }
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_NamedReferenceNameAlreadyExists", a));
      }
    }
    let g = this.getTable(a);
    if (g != null && g != b) {
      throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_NamedReferenceNameAlreadyExists", a));
    }
  }
  /**
   * @hidden
   */
  _jb(a, b, c) {
    if (this._c4) {
      return;
    }
    for (let d = 0; d < a._e.length; d++) {
      let e = a._e[d];
      if (typeCast(TblToken.$, e) !== null) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_DataTableFormulaCannotBeApplied"));
      }
      let f = typeCast(StructuredTableReference.$, e);
      if (f == null) {
        continue;
      }
      let g = null;
      if (f.ah == null) {
        if (b != null) {
          g = b._bp(c);
        }
        if (g == null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TableReferenceMustBeUsedFromInsideTable"));
        }
      }
      else if (f.r) {
        continue;
      }
      else {
        g = typeCast(WorksheetTable.$, this._a3(f.ah));
        if (g == null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TableReferenceToMissingTable"));
        }
      }
      let h = true;
      if (f.ag != null) {
        h = (g._columns$i._item1(f.ag) != null);
      }
      else if (f.u != null) {
        let i = f.u.p;
        let j = f.u.q;
        h = (i == null || g._columns$i._item1(i) != null) && (j == null || g._columns$i._item1(j) != null);
      }
      if (h == false) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TableReferenceToMissingTableColumn"));
      }
    }
  }
  /**
   * @hidden
   */
  static _i2() {
  }
  /**
   * @hidden
   */
  _i3() {
    Workbook._i4(this._cw);
  }
  /**
   * @hidden
   */
  static _i4(a) {
    throw new DocumentEncryptedException();
  }
  /**
   * @hidden
   */
  _jd(a, b, c) {
    for (let d of fromEnum(this._sheets$i)) {
      if (d == a) {
        continue;
      }
      if (StringUtilities.c(d.name, b, this._e6, 1) == 0) {
        throw new ArgumentException(2, ExcelUtils.eg("LE_ArgumentException_WorksheetNameAlreadyExists", d.name), c);
      }
    }
  }
  /**
   * @hidden
   */
  _hf(a, b, c) {
    for (let d of fromEnum(b.y)) {
      let e = d.t;
      if (stringIsNullOrEmpty(c) == false) {
        e = c + "\\" + e;
      }
      let f = typeCast(Directory.$, d);
      if (f != null) {
        this._hf(a, f, e);
        continue;
      }
      let g = d;
      switch (e) {
        case "Book":
        case "\u0005DocumentSummaryInformation":
        case "\u0005SummaryInformation":
        case "Workbook":
        case "encryption": continue;
      }
      {
        let h = new UserFileStream(a, g);
        try {
          this._he(e, h);
        }
        finally {
          if (h != null) {
            h.dispose();
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _ac($tValue, a, b, c, d = null, e = false, f = false, g = 0) {
    return new ChangeInfo$2(Workbook_ChangeInfoContext.$, $tValue, a, 87, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(11);
    ChangeInfo.f(a, 0, Workbook._ac(CellReferenceMode_$type, "CellReferenceMode", (b) => b.workbook.cellReferenceMode, (b, c) => b.workbook.cellReferenceMode = c));
    ChangeInfo.f(a, 1, Workbook._ac(CultureInfo.$, "Culture", (b) => b.workbook._culture$i, (b, c) => b.workbook._culture$i = c));
    ChangeInfo.f(a, 2, Workbook._ac(WorkbookFormat_$type, "CurrentFormat", (b) => b.workbook.currentFormat, (b, c) => {
    }));
    ChangeInfo.f(a, 3, Workbook._ac(DateSystem_$type, "DateSystem", (b) => b.workbook.dateSystem, (b, c) => b.workbook.dateSystem = c));
    ChangeInfo.f(a, 4, Workbook._ac(Workbook.$, "PaletteColorChanged", (b) => b.workbook, (b, c) => {
    }));
    ChangeInfo.f(a, 5, Workbook._ac(Precision_$type, "Precision", (b) => b.workbook.precision, (b, c) => b.workbook.precision = c));
    ChangeInfo.f(a, 6, Workbook._ac(Size.$, "ScreenDpi", (b) => b.workbook._screenDpi$i, (b, c) => b.workbook._screenDpi$i = c, (b, c) => b.workbook._i0(c), true, true));
    ChangeInfo.f(a, 7, Workbook._ac(Workbook.$, "WorksheetMoved", (b) => b.workbook, (b, c) => {
    }));
    ChangeInfo.f(a, 8, Workbook._ac(Workbook.$, "IsProtected", (b) => b.workbook, (b, c) => {
    }));
    ChangeInfo.f(a, 9, Workbook._ac(CultureInfo.$, "EditingCulture", (b) => b.workbook._editingCulture$i, (b, c) => b.workbook._editingCulture$i = c));
    ChangeInfo.f(a, 10, Workbook._ac(Workbook.$, "VolatileFormulaDirtied", (b) => b.workbook, (b, c) => {
    }));
    return a;
  }
  /**
   * @hidden
   */
  static _q(a, b, c, d = false, e = Nullable$1.toNullable(WorkbookFormat_$type, null)) {
    let f = null;
    return WorkItemExtensions.l(Boolean_$type, Workbook.$, OleDataSpaces.b(a, runOn(c, c._f), (g, h) => WorkItemExtensions.e(Workbook.$, Workbook._q(g, b, c, true), (i) => {
      f = WorkItemExtensions.m(Workbook.$, i);
      f._l = h;
    }), () => Workbook._i4(c._j), Workbook._i2), (g) => {
      if (WorkItemExtensions.m(Boolean_$type, g)) {
        return WorkItem.g(Workbook.$, f);
      }
      let h = e.hasValue ? WorkItem.g(WorkbookFormat_$type, e.value) : ExcelUtils.f(a, "stream", c);
      return WorkItemExtensions.l(WorkbookFormat_$type, Workbook.$, h, (i) => {
        let j = WorkItemExtensions.m(WorkbookFormat_$type, i);
        return Workbook._r(j, f, a, b, c, d);
      });
    });
  }
  /**
   * @hidden
   */
  static _r(a, b, c, d, e, f) {
    if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, a)) == false) {
      throw new InvalidEnumArgumentException("format", a, WorkbookFormat_$type);
    }
    b = new Workbook(a);
    b._dt = f;
    b._c3 = true;
    b._culture$i = e._culture$i;
    b.suspendCalculations();
    if (e._k) {
      for (let g of fromEnum(e.userDefinedFunctions)) {
        b._registerUserDefinedFunction(g);
      }
    }
    b._gw = ExcelUtils.ee(c);
    let h = Workbook._fc(b);
    return WorkItemExtensions.g(Workbook.$, Async.h(() => {
      switch (a) {
        case 0:
        case 1:
          {
            if (Workbook._ez == null) {
              throw new NotSupportedException(1, ExcelUtils.eg("LE_Biff8SerializerNotLoaded", enumGetBox(WorkbookFormat_$type, a)));
            }
            return Workbook._ez(b, c, d, e);
          }
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
          if (Workbook._e1 == null) {
            throw new NotSupportedException(1, ExcelUtils.eg("LE_OpenXmlSerializerNotLoaded", enumGetBox(WorkbookFormat_$type, a)));
          }
          return Workbook._e1(b, c, e);
        default: return null;
      }
    }, () => {
      b._c3 = false;
      for (let i of fromEnum(b._sheets$i)) {
        if (i.type == 0) {
          let j = i;
          j.filterSettings._bc();
          j.sortSettings._al();
        }
        if (i._p != null) {
          i._p._ah((k) => {
            let l = typeCast(WorksheetChart.$, k);
            if (l != null) {
              l._jk();
            }
          });
        }
      }
      if (e == null || e.autoResumeCalculations) {
        b.resumeCalculations();
      }
      if (b.calculationMode != 0) {
        b._w.ax();
      }
      b._w.aa(false);
      h.dispose();
    }), () => b);
  }
  /**
   * @hidden
   */
  _ih(a) {
    this._d2.item(a.name, a);
  }
  /**
   * @hidden
   */
  _ii(a) {
    if (this._d2.removeItem(a.name) == false) {
    }
  }
  /**
   * @hidden
   */
  _ie() {
    this._hm((a, b) => {
      if (b._aj) {
        b._aj = false;
        b._b7();
      }
    }, true);
  }
  /**
   * @hidden
   */
  _s(a, b) {
    switch (this._bx) {
      case 0:
      case 1:
        {
          if (Workbook._e2 == null) {
            this.isSaving = false;
            throw new NotSupportedException(1, ExcelUtils.eg("LE_Biff8SerializerNotLoaded", enumGetBox(WorkbookFormat_$type, this._bx)));
          }
          return Workbook._e2(this, a, b);
        }
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        if (Workbook._e3 == null) {
          this.isSaving = false;
          throw new NotSupportedException(1, ExcelUtils.eg("LE_OpenXmlSerializerNotLoaded", enumGetBox(WorkbookFormat_$type, this._bx)));
        }
        return Workbook._e3(this, a, b);
      default: return null;
    }
  }
  /**
   * @hidden
   */
  _i7(a) {
    this._ca._i = Workbook._fr(a);
  }
  /**
   * @hidden
   */
  _i8(a = null) {
    let b = WorkbookSaveOptions._h(a).c(this);
    if (b.count == 0) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSaveWithNoWorksheets"));
    }
    let c = false;
    for (let d of fromEnum(b)) {
      if (d._e.visibility == 0) {
        c = true;
        break;
      }
    }
    if (c == false) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSaveWithNoVisibleWorksheets"));
    }
    if (this._cq) {
      for (let e of fromEnum(this._customViews$i)) {
        let f = 0;
        let g = false;
        for (let h of fromEnum(b)) {
          let i = e.getSheetDisplayOptions(h, false);
          if (i == null) {
            continue;
          }
          f++;
          if (i.visibility == 0) {
            g = true;
            break;
          }
        }
        if (f > 0 && g == false) {
          throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CustomViewNoVisibleWorksheets", e.name));
        }
      }
    }
    let j = false;
    for (let k of fromEnum(this._worksheets$i)) {
      for (let l of fromEnum(k.protection._allowedEditRanges$i)) {
        if (l.ranges.count == 0) {
          j = true;
          break;
        }
      }
      if (j) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSaveEditRangeWithoutRange"));
      }
    }
  }
  /**
   * @hidden
   */
  _ja(a, b) {
    if (this._k != null && ExcelUtils.av(b) && ExcelUtils.a8(b) == false) {
      a.g(ExcelUtils.ef("LE_FormatLimitError_MacroWorkbook"));
    }
    if (this._cv) {
      this._namedReferences$i._af(a, b);
    }
    if (this._bn != null) {
      this._bn._x(a, b);
    }
  }
  /**
   * Gets or sets the value which indicates how a formula will be recalculated when a referenced value changes.
   * <p class="body">
   * If this is set to a value of Manual, the [[recalculateBeforeSave]] property will determine
   * if formulas are recalculated just before saving the file.  Otherwise, that property is ignored.
   * </p>
   * The value which indicates how a formula will be recalculated when a referenced value changes.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[calculationMode]] enumeration.
   * @see [[recalculateBeforeSave]]
   */
  get calculationMode() {
    return this._x;
  }
  /**
   * Gets or sets the value which indicates how a formula will be recalculated when a referenced value changes.
   * <p class="body">
   * If this is set to a value of Manual, the [[recalculateBeforeSave]] property will determine
   * if formulas are recalculated just before saving the file.  Otherwise, that property is ignored.
   * </p>
   * The value which indicates how a formula will be recalculated when a referenced value changes.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[calculationMode]] enumeration.
   * @see [[recalculateBeforeSave]]
   */
  set calculationMode(a) {
    if (this._x != a) {
      if (EnumUtil.isDefined(CalculationMode_$type, enumGetBox(CalculationMode_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, CalculationMode_$type);
      }
      switch (a) {
        case 0:
          this._ip(false, this._x == 1);
          break;
        case 2:
          if (this._x == 1) {
            this._recalculate();
          }
          break;
        case 1: break;
        default: break;
      }
      this._x = a;
    }
  }
  /**
   * Gets or sets the value which indicates the way cells in the workbook are referenced.
   * <p class="body">
   * The value of this property will affect the row and columns labels of the workbook when opened in Microsoft Excel.
   * In addition, it will affect the display of formulas referencing different cells.
   * </p>
   * The value which indicates the way cells in the workbook are referenced.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[cellReferenceMode]] enumeration.
   */
  get cellReferenceMode() {
    return this._z;
  }
  /**
   * Gets or sets the value which indicates the way cells in the workbook are referenced.
   * <p class="body">
   * The value of this property will affect the row and columns labels of the workbook when opened in Microsoft Excel.
   * In addition, it will affect the display of formulas referencing different cells.
   * </p>
   * The value which indicates the way cells in the workbook are referenced.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[cellReferenceMode]] enumeration.
   */
  set cellReferenceMode(a) {
    if (this._z != a) {
      if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, CellReferenceMode_$type);
      }
      let b = Workbook._a[0].g(Workbook_ChangeInfoContext.$, CellReferenceMode_$type, this._bt, this._z, a);
      this._z = b.p1;
    }
  }
  /**
   * Gets or sets the culture to use as the current culture for the workbook when doing any culture-aware conversions
   * or comparisons.
   * <p class="note">
   * <b>Note:</b> The culture is not saved or loaded in workbook files, so this is only used at when accessing and
   * manipulating objects owned or associated with the Workbook.
   * </p>
   * The current culture for the workbook or Null to use the thread's current culture.
   */
  get culture() {
    return (((t) => t == null ? null : t.name)(this._culture$i));
  }
  /**
   * Gets or sets the culture to use as the current culture for the workbook when doing any culture-aware conversions
   * or comparisons.
   * <p class="note">
   * <b>Note:</b> The culture is not saved or loaded in workbook files, so this is only used at when accessing and
   * manipulating objects owned or associated with the Workbook.
   * </p>
   * The current culture for the workbook or Null to use the thread's current culture.
   */
  set culture(a) {
    arguments[0] = typeof arguments[0] === 'string' ? new CultureInfo(arguments[0]) : arguments[0];
    this._culture$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _culture$i() {
    return this._e4;
  }
  /**
   * @hidden
   */
  set _culture$i(a) {
    if (this._e4 != a) {
      let b = Workbook._a[1].g(Workbook_ChangeInfoContext.$, CultureInfo.$, this._bt, this._e4, a);
      this._e4 = b.p1;
    }
  }
  /**
   * Gets the current format of the workbook. This is the format which will be used when saving and imposing format restrictions.
   * @see [[setCurrentFormat]]
   */
  get currentFormat() {
    return this._bx;
  }
  customTableStyles() {
    if (arguments.length !== 0) {
      let a = this._customTableStyles$i;
      return a.item.apply(a, arguments);
    }
    return this._customTableStyles$i;
  }
  /**
   * @hidden
   */
  get _customTableStyles$i() {
    if (this._ae == null) {
      this._ae = new CustomTableStyleCollection(this);
    }
    return this._ae;
  }
  customViews() {
    if (arguments.length !== 0) {
      let a = this._customViews$i;
      return a.item.apply(a, arguments);
    }
    return this._customViews$i;
  }
  /**
   * @hidden
   */
  get _customViews$i() {
    if (this._ag == null) {
      this._ag = new CustomViewCollection(this);
    }
    return this._ag;
  }
  /**
   * @hidden
   */
  get _cq() {
    return this._ag != null && this._ag.count > 0;
  }
  /**
   * Gets or sets the date system used internally by Microsoft Excel.
   * The date system used internally by Microsoft Excel.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[dateSystem]] enumeration.
   */
  get dateSystem() {
    return this._ai;
  }
  /**
   * Gets or sets the date system used internally by Microsoft Excel.
   * The date system used internally by Microsoft Excel.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[dateSystem]] enumeration.
   */
  set dateSystem(a) {
    if (this._ai != a) {
      if (EnumUtil.isDefined(DateSystem_$type, enumGetBox(DateSystem_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, DateSystem_$type);
      }
      let b = Workbook._a[3].g(Workbook_ChangeInfoContext.$, DateSystem_$type, this._bt, this._ai, a);
      this._ai = b.p1;
      if (this._v != null) {
        this._v.z();
      }
    }
  }
  /**
   * Gets or sets the default style for tables in the workbook.
   * <p class="body">
   * This can be set to any [[WorksheetTableStyle]] in the [[customTableStyles]] or [[standardTableStyles]] collection.
   * </p>
   * <p class="body">
   * This will never return a null value. If it is set to null, it will be reset to the TableStyleMedium2 table style.
   * </p>
   * <p class="body">
   * If this value is changed, it will not be applied to existing tables in the workbook. Only newly created tables will use
   * default table style on the workbook.
   * </p>
   * @throws [[ArgumentException]] The specified value is not in the [[customTableStyles]] or [[standardTableStyles]] collections.
   * @see [[customTableStyles]]
   * @see [[standardTableStyles]]
   * @see [[WorksheetTable.style]]
   */
  get defaultTableStyle() {
    if (this._ch == null) {
      this._ch = this._standardTableStyles$i._d;
    }
    return this._ch;
  }
  /**
   * Gets or sets the default style for tables in the workbook.
   * <p class="body">
   * This can be set to any [[WorksheetTableStyle]] in the [[customTableStyles]] or [[standardTableStyles]] collection.
   * </p>
   * <p class="body">
   * This will never return a null value. If it is set to null, it will be reset to the TableStyleMedium2 table style.
   * </p>
   * <p class="body">
   * If this value is changed, it will not be applied to existing tables in the workbook. Only newly created tables will use
   * default table style on the workbook.
   * </p>
   * @throws [[ArgumentException]] The specified value is not in the [[customTableStyles]] or [[standardTableStyles]] collections.
   * @see [[customTableStyles]]
   * @see [[standardTableStyles]]
   * @see [[WorksheetTable.style]]
   */
  set defaultTableStyle(a) {
    if (this._ch == a) {
      return;
    }
    if (a != null && a.isCustom && (a._h == null || a._h._e != this)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DefaultTableStyleNotInWorkbook"), "value");
    }
    this._ch = a;
  }
  /**
   * Gets the properties associated with the workbook document.
   * <p class="body">
   * The document properties are pieces of information which provide details on the content of the workbook,
   * such as the author, title, and subject of the workbook.
   * </p>
   * The properties associated with the workbook document.
   */
  get documentProperties() {
    if (this._ak == null) {
      this._ak = new DocumentProperties(this);
    }
    return this._ak;
  }
  /**
   * @hidden
   */
  get _cr() {
    return this._ak != null;
  }
  /**
   * The editing culture affects certain language specific features such as formatting of dates.
   * or comparisons.
   * <p class="note">
   * <b>Note:</b> The EditingCulture is not saved or loaded in workbook files, so this is only used at when accessing and
   * manipulating objects owned or associated with the Workbook.
   * </p>
   * @see [[culture]]
   */
  get editingCulture() {
    return (((t) => t == null ? null : t.name)(this._editingCulture$i));
  }
  /**
   * The editing culture affects certain language specific features such as formatting of dates.
   * or comparisons.
   * <p class="note">
   * <b>Note:</b> The EditingCulture is not saved or loaded in workbook files, so this is only used at when accessing and
   * manipulating objects owned or associated with the Workbook.
   * </p>
   * @see [[culture]]
   */
  set editingCulture(a) {
    arguments[0] = typeof arguments[0] === 'string' ? new CultureInfo(arguments[0]) : arguments[0];
    this._editingCulture$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _editingCulture$i() {
    return this._e7;
  }
  /**
   * @hidden
   */
  set _editingCulture$i(a) {
    if (this._e7 != a) {
      let b = Workbook._a[9].g(Workbook_ChangeInfoContext.$, CultureInfo.$, this._bt, this._e7, a);
      this._e7 = b.p1;
    }
  }
  /**
   * Returns a boolean indicating if the Workbook has been protected with a password.
   * <p class="body">When protecting a Workbook, a password is optional. The HasProtectionPassword will return true if the
   * Workbook is currently protected (see [[isProtected]]) and a password was specified when it was protected. To protect
   * a Workbook without a password, one may use the [[protect]]
   * method that doesn't take a password.</p>
   * @see [[isProtected]]
   * @see [[protection]]
   * @see [[WorkbookProtection]]
   * @see [[protect]]
   * @see [[unprotect]]
   */
  get hasProtectionPassword() {
    return this.protection._b.f;
  }
  /**
   * Returns a boolean indicating if the Workbook has been protected.
   * <p class="body">The IsProtected property will return true if the Workbook is currently protected. When a Workbook is protected
   * certain operations related to the Worksheets displayed or their order or the properties of the windows for the Workbook may be
   * restricted based on the values of the [[protection]].</p>
   * @see [[hasProtectionPassword]]
   * @see [[protection]]
   * @see [[WorkbookProtection]]
   * @see [[protect]]
   * @see [[unprotect]]
   */
  get isProtected() {
    return this.protection._b.g;
  }
  /**
   * Gets a value indicating whether the specified function will be recognized and solved by Microsoft Excel when the workbook is saved out.
   * @param functionName The case-insensitive name of the function.
   * @return True if the function will be recognized in Microsoft Excel; False otherwise.
   */
  isValidFunctionName(functionName) {
    let a = Function._gv(functionName);
    return a != null && a._qr == false;
  }
  /**
   * Gets or sets the value which indicates whether iterations are allowed while calculating formulas containing
   * circular references.
   * <p class="body">
   * When iterative calculations are enabled, a formula is allowed to use circular references,
   * or directly or indirectly reference the cell to which it belongs. Microsoft Excel stops iteratively
   * calculating formulas after iterating [[maxRecursionIterations]] times or when all formula
   * values change by less than [[maxChangeInIteration]] between two iterations.
   * </p>
   * <p class="body">
   * When iterative calculations are disabled, circular references are not allowed, and a formula which
   * references the cell to which it belongs, directly or indirectly, will cause Microsoft Excel to show an
   * error message and the cell will contain a <see cref="ErrorValue.Circularity">Circularity</see> error.
   * </p>
   * The value which indicates whether iterations are allowed while calculating recursive formulas.
   * @see [[ErrorValue.circularity]]
   * @see [[maxChangeInIteration]]
   * @see [[maxRecursionIterations]]
   */
  get iterativeCalculationsEnabled() {
    return this._dc;
  }
  /**
   * Gets or sets the value which indicates whether iterations are allowed while calculating formulas containing
   * circular references.
   * <p class="body">
   * When iterative calculations are enabled, a formula is allowed to use circular references,
   * or directly or indirectly reference the cell to which it belongs. Microsoft Excel stops iteratively
   * calculating formulas after iterating [[maxRecursionIterations]] times or when all formula
   * values change by less than [[maxChangeInIteration]] between two iterations.
   * </p>
   * <p class="body">
   * When iterative calculations are disabled, circular references are not allowed, and a formula which
   * references the cell to which it belongs, directly or indirectly, will cause Microsoft Excel to show an
   * error message and the cell will contain a <see cref="ErrorValue.Circularity">Circularity</see> error.
   * </p>
   * The value which indicates whether iterations are allowed while calculating recursive formulas.
   * @see [[ErrorValue.circularity]]
   * @see [[maxChangeInIteration]]
   * @see [[maxRecursionIterations]]
   */
  set iterativeCalculationsEnabled(a) {
    if (this._dc == a) {
      return;
    }
    this._dc = a;
  }
  /**
   * Gets or sets the maximum change of the values in a formula between iterations which will exit from iteration.
   * <p class="body">
   * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
   * </p>
   * <p class="body">
   * When iterative calculations, or circular references, are enabled, this property determines the maximum change in
   * all values of a formula between two iterations that will cause the formula to exit iterative calculations. Iterative
   * calculations will also be stopped if the formula iterates [[maxRecursionIterations]] times.
   * </p>
   * The maximum change of the values in a formula between iterations which will exit from iteration.
   * @see [[iterativeCalculationsEnabled]]
   * @see [[maxRecursionIterations]]
   */
  get maxChangeInIteration() {
    return this._ev;
  }
  /**
   * Gets or sets the maximum change of the values in a formula between iterations which will exit from iteration.
   * <p class="body">
   * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
   * </p>
   * <p class="body">
   * When iterative calculations, or circular references, are enabled, this property determines the maximum change in
   * all values of a formula between two iterations that will cause the formula to exit iterative calculations. Iterative
   * calculations will also be stopped if the formula iterates [[maxRecursionIterations]] times.
   * </p>
   * The maximum change of the values in a formula between iterations which will exit from iteration.
   * @see [[iterativeCalculationsEnabled]]
   * @see [[maxRecursionIterations]]
   */
  set maxChangeInIteration(a) {
    if (this._ev == a) {
      return;
    }
    this._ev = a;
  }
  /**
   * Gets the maximum number of columns allowed in each worksheet based on the [[currentFormat]].
   */
  get maxColumnCount() {
    return this._ff;
  }
  /**
   * Gets or sets the maximum number of times formulas should be iteratively calculated.
   * <p class="body">
   * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
   * </p>
   * <p class="body">
   * When iterative calculations, or circular references, are enabled, this property determines the number of iterations
   * allowed when calculating iteratively.
   * </p>
   * The maximum number of times formulas should be iteratively calculated.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 32767.
   * @see [[iterativeCalculationsEnabled]]
   * @see [[maxChangeInIteration]]
   */
  get maxRecursionIterations() {
    return this._f4;
  }
  /**
   * Gets or sets the maximum number of times formulas should be iteratively calculated.
   * <p class="body">
   * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
   * </p>
   * <p class="body">
   * When iterative calculations, or circular references, are enabled, this property determines the number of iterations
   * allowed when calculating iteratively.
   * </p>
   * The maximum number of times formulas should be iteratively calculated.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 32767.
   * @see [[iterativeCalculationsEnabled]]
   * @see [[maxChangeInIteration]]
   */
  set maxRecursionIterations(a) {
    if (this._c4) {
      a = Math.min(Math.max(1, a), 32767);
    }
    if (this._f4 != a) {
      if (a < 1 || 32767 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MaxRecursionIterations"));
      }
      this._f4 = a;
    }
  }
  /**
   * Gets the maximum number of rows allowed in each worksheet based on the [[currentFormat]].
   */
  get maxRowCount() {
    return Workbook.getMaxRowCount(this.currentFormat);
  }
  namedReferences() {
    if (arguments.length !== 0) {
      let a = this._namedReferences$i;
      return a.item.apply(a, arguments);
    }
    return this._namedReferences$i;
  }
  /**
   * @hidden
   */
  get _namedReferences$i() {
    if (this._a4 == null) {
      this._a4 = new NamedReferenceCollection(this);
    }
    return this._a4;
  }
  /**
   * @hidden
   */
  get _cv() {
    return this._a4 != null && this._a4.count > 0;
  }
  palette() {
    if (arguments.length !== 0) {
      let a = this._palette$i;
      return a.item.apply(a, arguments);
    }
    return this._palette$i;
  }
  /**
   * @hidden
   */
  get _palette$i() {
    return this._bv;
  }
  /**
   * Gets or sets the precision to use when obtaining a cell's value.
   * <p class="body">
   * The precision determines whether to use the actual value of the cell or the display value of the cell.
   * These are typically the same, but the format of a cell could cause a loss of precision in the displayed
   * value.  For example, if a cell's value is 18.975, and a currency format is used for the cell, the display
   * value will be 18.98.
   * </p>
   * The precision to use when obtaining a cell's value.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the  enumeration.
   */
  get precision() {
    return this._a6;
  }
  /**
   * Gets or sets the precision to use when obtaining a cell's value.
   * <p class="body">
   * The precision determines whether to use the actual value of the cell or the display value of the cell.
   * These are typically the same, but the format of a cell could cause a loss of precision in the displayed
   * value.  For example, if a cell's value is 18.975, and a currency format is used for the cell, the display
   * value will be 18.98.
   * </p>
   * The precision to use when obtaining a cell's value.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the  enumeration.
   */
  set precision(a) {
    if (this._a6 != a) {
      if (EnumUtil.isDefined(Precision_$type, enumGetBox(Precision_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, Precision_$type);
      }
      let b = Workbook._a[5].g(Workbook_ChangeInfoContext.$, Precision_$type, this._bt, this._a6, a);
      this._a6 = b.p1;
    }
  }
  /**
   * Returns an object that provides information used when the Workbook has been protected.
   * @see [[hasProtectionPassword]]
   * @see [[isProtected]]
   * @see [[WorkbookProtection]]
   * @see [[protect]]
   * @see [[unprotect]]
   */
  get protection() {
    return this._b3;
  }
  /**
   * Gets or sets the value which indicates whether the workbook should recalculate all formulas before saving.
   * <p class="body">
   * This property only applies if the [[calculationMode]] is set to Manual.  Otherwise, it is ignored.
   * </p>
   * The value which indicates whether the workbook should recalculate all formulas before saving.
   * @see [[recalculate]]
   * @see [[calculationMode]]
   */
  get recalculateBeforeSave() {
    return this._dg;
  }
  /**
   * Gets or sets the value which indicates whether the workbook should recalculate all formulas before saving.
   * <p class="body">
   * This property only applies if the [[calculationMode]] is set to Manual.  Otherwise, it is ignored.
   * </p>
   * The value which indicates whether the workbook should recalculate all formulas before saving.
   * @see [[recalculate]]
   * @see [[calculationMode]]
   */
  set recalculateBeforeSave(a) {
    if (a != this._dg) {
      this._dg = a;
    }
  }
  /**
   * Gets or sets the value which indicates whether to save values linked from external workbooks.
   * <p class="body">
   * This value will only be used when the workbook is opened in Microsoft Excel. When referencing external values
   * and saving a workbook through the Excel assembly, external linked values will never be saved.
   * </p>
   * The value which indicates whether to save values linked from external workbooks.
   */
  get saveExternalLinkedValues() {
    return this._dm;
  }
  /**
   * Gets or sets the value which indicates whether to save values linked from external workbooks.
   * <p class="body">
   * This value will only be used when the workbook is opened in Microsoft Excel. When referencing external values
   * and saving a workbook through the Excel assembly, external linked values will never be saved.
   * </p>
   * The value which indicates whether to save values linked from external workbooks.
   */
  set saveExternalLinkedValues(a) {
    if (a != this._dm) {
      this._dm = a;
    }
  }
  /**
   * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
   * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
   */
  get screenDpi() {
    return sizeToLiteral(this._screenDpi$i);
  }
  /**
   * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
   * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
   */
  set screenDpi(a) {
    arguments[0] = sizeFromLiteral(arguments[0]);
    this._screenDpi$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _screenDpi$i() {
    return this._jg;
  }
  /**
   * @hidden
   */
  set _screenDpi$i(a) {
    if (Size.l_op_Equality(this._jg, a)) {
      return;
    }
    if (Size.l_op_Inequality(a, Size.empty)) {
      if (Workbook._c2(a.height) == false || Workbook._c2(a.width) == false || (a.height > 0 && a.width == 0) || (a.height == 0 && a.width > 0)) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_InvalidDpi"));
      }
    }
    Workbook._a[6].h(Workbook_ChangeInfoContext.$, Size.$, this._bt, a);
  }
  /**
   * @hidden
   */
  _i0(a) {
    this._jg = a;
    this._it();
    for (let b of fromEnum(this._worksheets$i)) {
      b._h1();
    }
  }
  /**
   * @hidden
   */
  static _c2(a) {
    return 0 <= a && isNaN_(a) == false && isInfinity(a) == false;
  }
  sheets() {
    if (arguments.length !== 0) {
      let a = this._sheets$i;
      return a.item.apply(a, arguments);
    }
    return this._sheets$i;
  }
  /**
   * @hidden
   */
  get _sheets$i() {
    if (this._bn == null) {
      this._bn = new SheetCollection(this);
    }
    return this._bn;
  }
  /**
   * Gets or sets the value which indicates whether carriage return characters should be removed from string values in cells
   * when the workbook is saved to an Excel file.
   * <p class="body">
   * In Microsoft Excel 2003, carriage return characters are displayed as boxes. Most of the time, this should not be seen
   * and removing the carriage return characters has no adverse effect on the layout of the text within a cell. Therefore,
   * this property is True by default.
   * </p>
   * True if the saved workbook file should not contain the carriage return characters from cell values; False to export the
   * string values as they have been set on the cells.
   */
  get shouldRemoveCarriageReturnsOnSave() {
    return this._dp;
  }
  /**
   * Gets or sets the value which indicates whether carriage return characters should be removed from string values in cells
   * when the workbook is saved to an Excel file.
   * <p class="body">
   * In Microsoft Excel 2003, carriage return characters are displayed as boxes. Most of the time, this should not be seen
   * and removing the carriage return characters has no adverse effect on the layout of the text within a cell. Therefore,
   * this property is True by default.
   * </p>
   * True if the saved workbook file should not contain the carriage return characters from cell values; False to export the
   * string values as they have been set on the cells.
   */
  set shouldRemoveCarriageReturnsOnSave(a) {
    if (a != this._dp) {
      this._dp = a;
    }
  }
  standardTableStyles() {
    if (arguments.length !== 0) {
      let a = this._standardTableStyles$i;
      return a.item.apply(a, arguments);
    }
    return this._standardTableStyles$i;
  }
  /**
   * @hidden
   */
  get _standardTableStyles$i() {
    return StandardTableStyleCollection._c;
  }
  styles() {
    if (arguments.length !== 0) {
      let a = this._styles$i;
      return a.item.apply(a, arguments);
    }
    return this._styles$i;
  }
  /**
   * @hidden
   */
  get _styles$i() {
    if (this._b5 == null) {
      this._b5 = new WorkbookStyleCollection(this);
    }
    return this._b5;
  }
  /**
   * Gets or sets the value indicating whether the format strings should be validated when they are set.
   * <p class="body">
   * This value is False by default to maintain backward compatibility.
   * </p>
   * <p class="body">
   * When True, format strings will be validated when a [[IWorksheetCellFormat.formatString]] property is set. An invalid
   * format string will cause an exception. When False, invalid format strings will be allowed, but if the display text of a cell is
   * requested, an exception will be thrown at that time. If invalid format strings are allowed and the workbook is saved and opened
   * in Microsoft Excel, it will show an error.
   * </p>
   * @see [[IWorksheetCellFormat.formatString]]
   * @see [[WorksheetCell.getText]]
   * @see [[WorksheetCell.getText]]
   * @see [[WorksheetRow.getCellText]]
   * @see [[WorksheetRow.getCellText]]
   */
  get validateFormatStrings() {
    return this._dr;
  }
  /**
   * Gets or sets the value indicating whether the format strings should be validated when they are set.
   * <p class="body">
   * This value is False by default to maintain backward compatibility.
   * </p>
   * <p class="body">
   * When True, format strings will be validated when a [[IWorksheetCellFormat.formatString]] property is set. An invalid
   * format string will cause an exception. When False, invalid format strings will be allowed, but if the display text of a cell is
   * requested, an exception will be thrown at that time. If invalid format strings are allowed and the workbook is saved and opened
   * in Microsoft Excel, it will show an error.
   * </p>
   * @see [[IWorksheetCellFormat.formatString]]
   * @see [[WorksheetCell.getText]]
   * @see [[WorksheetCell.getText]]
   * @see [[WorksheetRow.getCellText]]
   * @see [[WorksheetRow.getCellText]]
   */
  set validateFormatStrings(a) {
    if (a != this._dr) {
      this._dr = a;
    }
  }
  /**
   * Gets the options which control various workbook level display properties.
   * <p class="body">
   * The window options control properties of the child MDI window showing the workbook in Microsoft Excel.
   * They also control display options of the workbook which do not change based on the selected worksheet.
   * </p>
   * The options which control various workbook level display properties.
   * @see [[CustomView.windowOptions]]
   */
  get windowOptions() {
    if (this._b7 == null) {
      this._b7 = new WorkbookWindowOptions(this);
    }
    return this._b7;
  }
  worksheets() {
    if (arguments.length !== 0) {
      let a = this._worksheets$i;
      return a.item.apply(a, arguments);
    }
    return this._worksheets$i;
  }
  /**
   * @hidden
   */
  get _worksheets$i() {
    if (this._ce == null) {
      this._ce = new WorksheetCollection(this);
    }
    return this._ce;
  }
  /**
   * @hidden
   */
  get _u() {
    return this._t;
  }
  /**
   * @hidden
   */
  get _a9() {
    if (this._a8 == null) {
      this._a8 = new AddInFunctionsWorkbookReference(this);
    }
    return this._a8;
  }
  /**
   * @hidden
   */
  get _cm() {
    return this._fh > 0;
  }
  /**
   * @hidden
   */
  get _ab() {
    return this._bu != null ? this._bu._b : null;
  }
  /**
   * @hidden
   */
  get _bq() {
    return this._bu != null ? this._bu._d : null;
  }
  /**
   * @hidden
   */
  get _ca() {
    return this._b9;
  }
  /**
   * @hidden
   */
  get _e6() {
    return this._e4 || ExcelUtils.cq;
  }
  /**
   * @hidden
   */
  get _bb() {
    if (this._ba == null) {
      this._ba = new CurrentWorkbookReference(this);
    }
    return this._ba;
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
  /**
   * @hidden
   */
  set _e(a) {
    this._d = a;
  }
  /**
   * @hidden
   */
  get _ef() {
    return this._ee;
  }
  /**
   * @hidden
   */
  get _eh() {
    return this._eg;
  }
  /**
   * @hidden
   */
  get _fp() {
    return this._fo;
  }
  /**
   * @hidden
   */
  get _cc() {
    return this._cb;
  }
  /**
   * @hidden
   */
  get _ej() {
    return this._ei;
  }
  /**
   * @hidden
   */
  set _ej(a) {
    this._ei = a;
  }
  /**
   * @hidden
   */
  get _el() {
    return this._ek;
  }
  /**
   * @hidden
   */
  set _el(a) {
    this._ek = a;
  }
  /**
   * @hidden
   */
  get _dz() {
    return this._dy;
  }
  /**
   * @hidden
   */
  get _av() {
    return this._au;
  }
  /**
   * @hidden
   */
  get _at() {
    return this._as;
  }
  /**
   * @hidden
   */
  get _ax() {
    return this._aw;
  }
  /**
   * @hidden
   */
  get _b2() {
    if (this._b1 == null) {
      this._b1 = new WorkbookFormatCollection(this);
    }
    return this._b1;
  }
  /**
   * @hidden
   */
  get _ct() {
    return this._b1 != null && this._b1.r > 0;
  }
  /**
   * @hidden
   */
  get _co() {
    return this._cl;
  }
  /**
   * @hidden
   */
  set _co(a) {
    this._cl = a;
  }
  /**
   * @hidden
   */
  get _cp() {
    if (this._g0 == null) {
      return false;
    }
    if (this._dx == null) {
      return false;
    }
    let a = "\\" + this._g0;
    for (let b of fromEnum(this._dx)) {
      if (stringEndsWith(b.key, a)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  get _cx() {
    return this._az != null;
  }
  /**
   * @hidden
   */
  get _cy() {
    return this._eb != null && this._eb.count != 0;
  }
  /**
   * @hidden
   */
  get _cz() {
    return this._ec != null && this._ec.count != 0;
  }
  /**
   * @hidden
   */
  get _c1() {
    return this._ed != null && this._ed.count != 0;
  }
  /**
   * @hidden
   */
  get _en() {
    if (this._em == null) {
      this._em = new List$1(NamedReference.$, 0);
    }
    return this._em;
  }
  /**
   * @hidden
   */
  get _cu() {
    return this._em != null && this._em.count > 0;
  }
  /**
   * @hidden
   */
  get _c4() {
    return this._c3;
  }
  /**
   * @hidden
   */
  get _c9() {
    return this._az != null && this._az.isUndoEnabled;
  }
  /**
   * @hidden
   */
  get _fv() {
    return Workbook._fr(this.currentFormat);
  }
  /**
   * @hidden
   */
  get _ff() {
    return Workbook._fe(this.currentFormat);
  }
  /**
   * @hidden
   */
  get _g6() {
    return this._g5;
  }
  /**
   * @hidden
   */
  set _g6(a) {
    this._g5 = a;
  }
  /**
   * @hidden
   */
  get _d1() {
    if (this._d0 == null) {
      this._d0 = new Dictionary$2(String_$type, Formula.$, 0);
    }
    return this._d0;
  }
  /**
   * @hidden
   */
  get _a0() {
    return this._az;
  }
  /**
   * @hidden
   */
  static get _jh() {
    if (ExcelUtils.bs(Workbook._je)) {
      Workbook._je = ExcelUtils.hc();
    }
    return Workbook._je;
  }
  /**
   * @hidden
   */
  get _dj() {
    return this._di;
  }
  /**
   * @hidden
   */
  set _dj(a) {
    this._di = a;
  }
  /**
   * @hidden
   */
  get _d6() {
    if (this._d5 == null) {
      this._d5 = new HashSet$1(Number_$type, 0);
    }
    return this._d5;
  }
  /**
   * @hidden
   */
  get _bj() {
    return this._bi;
  }
  /**
   * @hidden
   */
  get _h() {
    if (this._g == null) {
      this._g = Workbook._c();
    }
    return this._g;
  }
  /**
   * @hidden
   */
  static _c() {
    let a = new Array(12);
    a[0] = SystemColorsInternal.bc;
    a[1] = SystemColorsInternal.bg;
    a[2] = ExcelUtils.g2(ExcelUtils.gx(4293848289));
    a[3] = ExcelUtils.g2(ExcelUtils.gx(4280240509));
    a[4] = ExcelUtils.g2(ExcelUtils.gx(4283400637));
    a[5] = ExcelUtils.g2(ExcelUtils.gx(4290793549));
    a[6] = ExcelUtils.g2(ExcelUtils.gx(4288396121));
    a[7] = ExcelUtils.g2(ExcelUtils.gx(4286604450));
    a[8] = ExcelUtils.g2(ExcelUtils.gx(4283149510));
    a[9] = ExcelUtils.g2(ExcelUtils.gx(4294415942));
    a[10] = ExcelUtils.g2(ExcelUtils.gx(4278190335));
    a[11] = ExcelUtils.g2(ExcelUtils.gx(4286578816));
    return a;
  }
  /**
   * @hidden
   */
  get _k() {
    return this._j;
  }
  /**
   * @hidden
   */
  set _k(a) {
    this._j = a;
  }
  /**
   * @hidden
   */
  get _g0() {
    return this._gz;
  }
  /**
   * @hidden
   */
  set _g0(a) {
    this._gz = a;
  }
  /**
   * @hidden
   */
  get _bm() {
    return this._bk;
  }
  /**
   * @hidden
   */
  get _gj() {
    if (this._gi == 0) {
      try {
        {
          let a = Workbook._fc(this);
          try {
            let b = this._bq;
            let c = this._styles$i.normalStyle._i;
            let d = b._g(c, "0", Nullable$1.toNullable(Size.$, null), false, false);
            let e;
            if (((() => { let f = Workbook._d4.tryGetValue(c._df, e); e = f.p1; return f.ret; })())) {
              let f = (c._cq / 20);
              let g;
              if (((() => { let h = e._d(f, g); g = h.p1; return h.ret; })())) {
                if (g) {
                  d.width++;
                }
                else {
                  d.width--;
                }
              }
            }
            let h = b._f(d);
            d = h.p0;
            this._gi = truncate(d.width);
          }
          finally {
            if (a != null) {
              a.dispose();
            }
          }
        }
      }
      catch (i) {
        this._gi = 7;
      }
    }
    return this._gi;
  }
  /**
   * @hidden
   */
  _it() {
    this._gi = 0;
  }
  /**
   * @hidden
   */
  static get _d4() {
    if (Workbook._d3 == null) {
      Workbook._d3 = new Dictionary$2(String_$type, SortedList$2.$.specialize(Number_$type, Boolean_$type), 2, StringUtilities.e);
      let a = Workbook._ji.width == 120;
      let b = new SortedList$2(Number_$type, Boolean_$type, 0);
      b._item(1, true);
      b._item(2, true);
      b._item(3, true);
      b._item(6, true);
      b._item(7, false);
      b._item(13, false);
      b._item(22, false);
      b._item(25, false);
      b._item(34, false);
      b._item(37, false);
      b._item(40, false);
      b._item(49, false);
      Workbook._d3.item("Arial", b);
      b = new SortedList$2(Number_$type, Boolean_$type, 0);
      b._item(1, true);
      b._item(3, true);
      b._item(6, true);
      if (Workbook._jh.width == 120) {
        b._item(11, false);
        b._item(17, false);
        b._item(23, false);
      }
      Workbook._d3.item("Calibri", b);
      b = new SortedList$2(Number_$type, Boolean_$type, 0);
      b._item(1, true);
      b._item(3, true);
      b._item(4, false);
      b._item(7, false);
      b._item(13, false);
      b._item(19, false);
      b._item(22, false);
      b._item(28, false);
      b._item(34, false);
      b._item(37, false);
      b._item(43, false);
      b._item(49, false);
      Workbook._d3.item("Courier New", b);
      b = new SortedList$2(Number_$type, Boolean_$type, 0);
      b._item(1, true);
      b._item(3, true);
      b._item(6, true);
      b._item(10, false);
      b._item(19, false);
      b._item(22, false);
      Workbook._d3.item("Times New Roman", b);
      b = new SortedList$2(Number_$type, Boolean_$type, 0);
      b._item(1, true);
      b._item(3, true);
      b._item(6, true);
      b._item(10, false);
      b._item(13, false);
      b._item(16, false);
      b._item(25, false);
      b._item(28, false);
      b._item(31, false);
      b._item(43, false);
      b._item(46, false);
      b._item(49, false);
      Workbook._d3.item("Tahoma", b);
      b = new SortedList$2(Number_$type, Boolean_$type, 0);
      if (a) {
        for (let c = 5; c < 50; c += 6) {
          b._item(c, false);
        }
      }
      else {
        b._item(1, true);
        b._item(3, true);
        b._item(6, true);
      }
      Workbook._d3.item("MS PGothic", b);
      Workbook._d3.item(UnicodeStrings.a, b);
    }
    return Workbook._d3;
  }
  /**
   * @hidden
   */
  get _w() {
    return this._v;
  }
  /**
   * @hidden
   */
  static get _ji() {
    if (ExcelUtils.bs(Workbook._jf)) {
      Workbook._jf = ExcelUtils.hd();
    }
    return Workbook._jf;
  }
  /**
   * @hidden
   */
  get _jk() {
    if (ExcelUtils.bs(this._jg)) {
      return Workbook._ji;
    }
    return this._jg;
  }
}
Workbook.$t = markType(Workbook, 'Workbook');
Workbook.maxExcel2007RowCount = 1048576;
Workbook.maxExcel2007ColumnCount = 16384;
Workbook.maxExcelRowCount = 65536;
Workbook.maxExcelColumnCount = 256;
Workbook.maxExcelCellFormatCount = 4000;
Workbook.maxExcel2007CellFormatCount = 64000;
Workbook.maxExcelWorkbookFonts = 512;
/**
 * @hidden
 */
Workbook._gq = "Book";
/**
 * @hidden
 */
Workbook._gr = "\u0005DocumentSummaryInformation";
/**
 * @hidden
 */
Workbook._gt = "\u0005SummaryInformation";
/**
 * @hidden
 */
Workbook._gu = "Workbook";
/**
 * @hidden
 */
Workbook._gs = "encryption";
/**
 * @hidden
 */
Workbook._b0 = 2;
/**
 * @hidden
 */
Workbook._fg = 101;
/**
 * @hidden
 */
Workbook._fj = 102;
/**
 * @hidden
 */
Workbook._fk = 103;
/**
 * @hidden
 */
Workbook._f7 = 104;
/**
 * @hidden
 */
Workbook._f8 = 105;
/**
 * @hidden
 */
Workbook._gd = 107;
/**
 * @hidden
 */
Workbook._ge = 109;
/**
 * @hidden
 */
Workbook._gf = 110;
/**
 * @hidden
 */
Workbook._gp = "VelvetSweatshop";
/**
 * @hidden
 */
Workbook._fi = 0;
/**
 * @hidden
 */
Workbook._fl = 1;
/**
 * @hidden
 */
Workbook._fm = 2;
/**
 * @hidden
 */
Workbook._fn = 3;
/**
 * @hidden
 */
Workbook._ga = 4;
/**
 * @hidden
 */
Workbook._gb = 5;
/**
 * @hidden
 */
Workbook._gc = 6;
/**
 * @hidden
 */
Workbook._gh = 7;
/**
 * @hidden
 */
Workbook._fu = 8;
/**
 * @hidden
 */
Workbook._fq = 9;
/**
 * @hidden
 */
Workbook._gg = 10;
/**
 * @hidden
 */
Workbook._f9 = 11;
/**
 * @hidden
 */
Workbook._a = null;
/**
 * @hidden
 */
Workbook._g1 = ExcelUtils.eo(1252);
/**
 * @hidden
 */
Workbook._fd = CultureInfo.invariantCulture;
/**
 * @hidden
 */
Workbook._je = Size.empty;
/**
 * @hidden
 */
Workbook._jf = Size.empty;
/**
 * @hidden
 */
Workbook._fa = Workbook._e9();
/**
 * @hidden
 */
Workbook._ez = null;
/**
 * @hidden
 */
Workbook._e2 = null;
/**
 * @hidden
 */
Workbook._e1 = null;
/**
 * @hidden
 */
Workbook._e3 = null;
/**
 * @hidden
 */
Workbook._e0 = null;
/**
 * @hidden
 */
Workbook._d3 = null;
/**
 * @hidden
 */
export class Workbook_MetricsProviderCache extends Base {
  constructor(a) {
    super();
    this._f = 0;
    this._e = null;
    this._c = null;
    this._a = null;
    this._e = a;
    this._g();
  }
  get _b() {
    if (this._a == null && this._f > 0) {
      this._a = new CellSizeMeasurementContext(this._e, this._d);
    }
    return this._a;
  }
  get _d() {
    if (this._c == null && this._f > 0) {
      this._c = Workbook._br(this._e);
    }
    return this._c;
  }
  _g() {
    this._f++;
  }
  dispose() {
    this._f--;
    if (this._f == 0) {
      let a = this._e._bu;
      if (a == this) {
        this._e._bu = null;
      }
      let b = this._c;
      this._c = null;
      this._a = null;
      if (b != null) {
        b.dispose();
      }
    }
  }
}
Workbook_MetricsProviderCache.$t = markType(Workbook_MetricsProviderCache, 'Workbook_MetricsProviderCache', Base.$, [IDisposable_$type]);
/**
 * @hidden
 */
export class Workbook_OleLinkInfoComparer extends Base {
  constructor() {
    super();
  }
  equalsC(a, b) {
    return StringUtilities.e.equalsC(a._a, b._a) && a._b == b._b;
  }
  getHashCodeC(a) {
    return StringUtilities.e.getHashCodeC(a._a) ^ (Base.getHashCodeStatic(a._b) << 3);
  }
}
Workbook_OleLinkInfoComparer.$t = markType(Workbook_OleLinkInfoComparer, 'Workbook_OleLinkInfoComparer', Base.$, [IEqualityComparer$1_$type.specialize(ValueTuple$2.$.specialize(String_$type, Uri.$))]);
Workbook_OleLinkInfoComparer._a = new Workbook_OleLinkInfoComparer();
/**
 * @hidden
 */
export class GenericCacheElement extends Base {
  constructor() {
    super();
    this.e = 0;
  }
  equals(a) {
    return super.equals(a);
  }
  getHashCode() {
    return super.getHashCode();
  }
  j() {
    this.e--;
  }
  k() {
    this.e++;
  }
  l(a) {
  }
  static h($t, a, b) {
    b = GenericCacheElement.a($t, b, a);
    return {
      p1: b
    };
  }
  static i($t, a, b, c) {
    GenericCacheElement.m($t, b, a);
    if (c && b.f > 0) {
      b = typeCastObjTo$t($t, b.g(a._d));
    }
    return {
      p1: b
    };
  }
  static a($t, a, b) {
    let c;
    if (b == null) {
      if (a.f <= 0) {
        c = a;
      }
      else {
        c = typeCastObjTo$t($t, a.g(null));
      }
    }
    else {
      let d = b._k(a, c);
      c = d.p1;
      c.k();
    }
    return c;
  }
  static m($t, a, b) {
    if (b != null) {
      a.j();
    }
    if (b != null && a.e <= 0) {
      b._remove(a);
    }
  }
  static o($t, a, b, c) {
    if (b != a) {
      let d = GenericCacheElement.i($t, b, c, true);
      c = d.p1;
      b = a;
      let e = GenericCacheElement.h($t, b, c);
      c = e.p1;
    }
    return {
      p1: b,
      p2: c
    };
  }
  n() {
    this.e = 0;
  }
  get f() {
    return this.e;
  }
}
GenericCacheElement.$t = markType(GenericCacheElement, 'GenericCacheElement');
/**
 * @hidden
 */
export class GenericCacheElementEx extends GenericCacheElement {
  constructor(a) {
    super();
    this.s = null;
    this.u = null;
    this.w = false;
    this.u = a;
  }
  ab(a) {
    this.t = a;
  }
  ac() {
    this.t = null;
  }
  static z($t, a, b) {
    b = GenericCacheElementEx.r($t, b, a);
    return {
      p1: b
    };
  }
  static p($t, a, b) {
    let c = GenericCacheElementEx.q($t, a);
    if (b && a.f > 0) {
      a = typeCastObjTo$t($t, a.y());
    }
    return {
      ret: c,
      p0: a
    };
  }
  y() {
    return this.g(this.v);
  }
  static r($t, a, b) {
    let c;
    if (b == null) {
      if (a.f <= 0) {
        c = a;
      }
      else {
        c = typeCastObjTo$t($t, a.y());
      }
    }
    else {
      if (a.s == b) {
        c = a;
      }
      else {
        let d = b._k(a, c);
        c = d.p1;
      }
      c.k();
    }
    return c;
  }
  static q($t, a) {
    let b = typeCast(GenericCachedCollection$1.$.specialize($t), a.t);
    if (b != null) {
      a.j();
    }
    if (b != null && a.f <= 0) {
      b._remove(a);
    }
    return b;
  }
  static ad($t, a, b) {
    let c = typeCast(GenericCachedCollection$1.$.specialize($t), b.t);
    if (c != a) {
      let d = ((() => { let e = GenericCacheElementEx.p($t, b, true); b = e.p0; return e.ret; })());
      c = a;
      let e = GenericCacheElementEx.z($t, c, b);
      b = e.p1;
    }
    return {
      p1: b
    };
  }
  ae(a, b) {
    if (this.u == a) {
      return;
    }
    this.u = a;
    this.l(b);
  }
  get t() {
    return this.s;
  }
  set t(a) {
    this.s = a;
    if (this.s != null) {
      if (this.v == null) {
        this.v = this.s.workbook;
      }
      else {
      }
    }
  }
  get x() {
    return this.w;
  }
  set x(a) {
    this.w = a;
  }
  get v() {
    return this.u;
  }
  set v(a) {
    this.ae(a, true);
  }
}
GenericCacheElementEx.$t = markType(GenericCacheElementEx, 'GenericCacheElementEx', GenericCacheElement.$);
/**
 * @hidden
 */
export let IWorkbookFontDefaultsResolver_$type = new Type(null, 'IWorkbookFontDefaultsResolver');
/**
 * @hidden
 */
export let IWorksheetCellFormat_$type = new Type(null, 'IWorksheetCellFormat');
/**
 * @hidden
 */
export class WorksheetCellFormatData extends GenericCacheElementEx {
  constructor(a, b) {
    super(a);
    this._as = null;
    this._b4 = false;
    this._a3 = 0;
    this._ba = null;
    this._ag = 0;
    this._cx = Nullable$1.toNullable(Number_$type, null);
    this._bt = null;
    this._bb = null;
    this._au = 0;
    this._ah = 0;
    this._aq = null;
    this._bo = null;
    this._bw = 0;
    this._a5 = 255;
    this._ci = 0;
    this._cj = 0;
    this._b5 = false;
    this._bc = null;
    this._ai = 0;
    this._cz = Nullable$1.toNullable(Boolean_$type, null);
    this._av = 0;
    this._bd = null;
    this._aj = 0;
    this._ck = 0;
    this._c0 = Nullable$1.toNullable(Boolean_$type, null);
    this._bq = null;
    this._be = null;
    this._ak = 0;
    this._b0 = 0;
    this._b2 = null;
    this._a7 = 0;
    this._c1 = Nullable$1.toNullable(Boolean_$type, null);
    this._cy = Nullable$1.toNullable(Boolean_$type, null);
    this._b0 = b;
    this._dr(63);
  }
  resolveDefaults(a) {
    if (nullableEquals(a._bold$i, null)) {
      a._bold$i = this._c2;
    }
    if (WorkbookColorInfo.l_op_Equality(a.colorInfo, null)) {
      a.colorInfo = this._bh;
    }
    a.colorInfo = this._bn(a.colorInfo);
    if (a.height < 0) {
      a.height = this._cq;
    }
    if (nullableEquals(a._italic$i, null)) {
      a._italic$i = this._c3;
    }
    if (a.name == null) {
      a.name = this._df;
    }
    if (nullableEquals(a._strikeout$i, null)) {
      a._strikeout$i = this._c4;
    }
    if (a.superscriptSubscriptStyle == -1) {
      a.superscriptSubscriptStyle = this._a0;
    }
    if (a.underlineStyle == -1) {
      a.underlineStyle = this._a1;
    }
  }
  g(a) {
    return this._bv(a);
  }
  _bu() {
    return this._bv(this.v);
  }
  _bv(a, b = false) {
    if (a == null) {
      a = this.v;
    }
    let c = new WorksheetCellFormatData(a, this._b1);
    c._b4 = this._b4;
    c._a3 = this._a3;
    c._ba = b ? ExcelUtils.ah(this._ba, this.v) : this._ba;
    c._ag = this._ag;
    c._cx = this._cx;
    c._bb = b ? ExcelUtils.ah(this._bb, this.v) : this._bb;
    c._au = this._au;
    c._ah = this._ah;
    c._aq = b ? ExcelUtils.j(this._aq, this.v) : this._aq;
    c._bw = this._bw;
    c._a5 = this._a5;
    c._ci = this._ci;
    c._cj = this._cj;
    c._b5 = this._b5;
    c._bc = b ? ExcelUtils.ah(this._bc, this.v) : this._bc;
    c._ai = this._ai;
    c._cz = this._cz;
    c._av = this._av;
    c._bd = b ? ExcelUtils.ah(this._bd, this.v) : this._bd;
    c._aj = this._aj;
    c._ck = this._ck;
    c._c0 = this._c0;
    c._be = b ? ExcelUtils.ah(this._be, this.v) : this._be;
    c._ak = this._ak;
    c._b0 = this._b0;
    c._b2 = this._b2;
    c._a7 = this._a7;
    c._c1 = this._c1;
    if (this._bt != null) {
      c._bt = this._bt._bv(a, b);
    }
    if (a != null && this._bq != null) {
      if (a != this._bq._g) {
        c._bq = a._styles$i._item1(this._bq.name);
      }
      else {
        c._bq = this._bq;
      }
    }
    else {
      c._bq = null;
    }
    let d = this._bo.d;
    if (d.v != a || d.x || b) {
      d = d._aj(a);
      if (b) {
        d.colorInfo = ExcelUtils.ah(d.colorInfo, this.v);
      }
    }
    c._bo = new WorkbookFontProxy(0, d, a, c);
    return c;
  }
  aa(a) {
    let b = typeCast(WorksheetCellFormatData.$, a);
    if (b == null) {
      return;
    }
    this.setFormatting(b);
  }
  equals(a) {
    if (this == a) {
      return true;
    }
    let b = typeCast(WorksheetCellFormatData.$, a);
    return this._ca(b);
  }
  _ca(a) {
    if (a == null) {
      return false;
    }
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    if (this._b0 != a._b0) {
      return false;
    }
    return this.c(a);
  }
  getHashCode() {
    if (this._cx.hasValue == false) {
      let a = this._b0;
      if (this._bo.d != null) {
        a ^= this._bo.d.getHashCode() << 1;
      }
      a ^= this._ci << 2;
      a ^= ExcelUtils.dk(this._cz) << 3;
      a ^= ExcelUtils.dk(this._c1) << 4;
      a ^= ExcelUtils.dk(this._c0) << 5;
      a ^= this._a3 << 6;
      a ^= this._a7 << 7;
      a ^= this._ck << 8;
      a ^= this._cj << 9;
      a ^= this._ai << 10;
      a ^= this._aj << 11;
      a ^= this._ak << 12;
      a ^= this._ag << 13;
      if (WorkbookColorInfo.l_op_Inequality(this._bc, null)) {
        a ^= this._bc.getHashCode() << 14;
      }
      if (WorkbookColorInfo.l_op_Inequality(this._bd, null)) {
        a ^= this._bd.getHashCode() << 15;
      }
      if (WorkbookColorInfo.l_op_Inequality(this._be, null)) {
        a ^= this._be.getHashCode() << 16;
      }
      if (WorkbookColorInfo.l_op_Inequality(this._ba, null)) {
        a ^= this._ba.getHashCode() << 17;
      }
      if (this._aq != null) {
        a ^= Base.getHashCodeStatic(this._aq) << 18;
      }
      a ^= this._bw << 19;
      if (WorkbookColorInfo.l_op_Inequality(this._bb, null)) {
        a ^= this._bb.getHashCode() << 20;
      }
      a ^= this._au << 21;
      a ^= this._ah << 22;
      if (this._b4 == true) {
        a ^= 1 << 23;
      }
      if (this._bq != null) {
        a ^= Base.getHashCodeStatic(this._bq);
      }
      this._cx = Nullable$1.toNullable(Number_$type, a);
    }
    return this._cx.value;
  }
  c(a) {
    if (this == a) {
      return true;
    }
    let b = a;
    if (this._bw != b._bw) {
      return false;
    }
    if (this._ci != b._ci) {
      return false;
    }
    if (nullableNotEquals(this._cz, b._cz)) {
      return false;
    }
    if (nullableNotEquals(this._c1, b._c1)) {
      return false;
    }
    if (nullableNotEquals(this._c0, b._c0)) {
      return false;
    }
    if (this._a3 != b._a3) {
      return false;
    }
    if (this._a7 != b._a7) {
      return false;
    }
    if (this._ck != b._ck) {
      return false;
    }
    if (this._cj != b._cj) {
      return false;
    }
    if (this._ai != b._ai) {
      return false;
    }
    if (this._aj != b._aj) {
      return false;
    }
    if (this._ak != b._ak) {
      return false;
    }
    if (this._ag != b._ag) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._bc, b._bc)) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._bd, b._bd)) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._be, b._be)) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._ba, b._ba)) {
      return false;
    }
    if (Base.equalsStatic(this._aq, b._aq) == false) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._bb, b._bb)) {
      return false;
    }
    if (this._au != b._au) {
      return false;
    }
    if (this._ah != b._ah) {
      return false;
    }
    if (this._bo.d.equals(b._bo.d) == false) {
      return false;
    }
    if (this._b4 != b._b4) {
      return false;
    }
    if (this._bq != b._bq) {
      return false;
    }
    if (this._bt == null) {
      if (b._bt != null) {
        return false;
      }
    }
    else if (this._bt._ca(b._bt) == false) {
      return false;
    }
    return true;
  }
  ab(a) {
    super.ab(a);
    if (this._bo != null && this.v != null) {
      this._bo.h(WorksheetCellFormatData._a2(this.v, this));
    }
    if (this.style != null) {
      this.style._x();
    }
  }
  ac() {
    super.ac();
    if (this._bp != null) {
      this._bp.i();
    }
    if (this.style != null) {
      this.style._y();
    }
  }
  l(a) {
    super.l(a);
    if (this._bt != null) {
      this._bt.v = this.v;
    }
    if (a || (this.style != null && this.style._g != this.v)) {
      this.style = null;
    }
    if (this._bo != null) {
      this._bo.i();
      if (this.v != null) {
        this._bo.h(WorksheetCellFormatData._a2(this.v, this));
      }
    }
  }
  af() {
    if (this.x) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ReadOnlyFormat"));
    }
  }
  setFormatting(a) {
    if (a == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFormatting"));
    }
    this.af();
    let b = typeCast(WorksheetCellFormatData.$, a);
    if (b != null) {
      let c = this._bw;
      this._bo.setFontFormatting(b._bp.d);
      this._a3 = b._a3;
      this._ba = b._ba;
      this._ag = b._ag;
      this._bb = b._bb;
      this._au = b._au;
      this._ah = b._ah;
      this._aq = b._aq;
      this._bw = b._bw;
      this._ci = b._ci;
      this._cj = b._cj;
      this._bc = b._bc;
      this._ai = b._ai;
      this._cz = b._cz;
      this._bd = b._bd;
      this._aj = b._aj;
      this._ck = b._ck;
      this._c0 = b._c0;
      if (this._b1 != 1) {
        this._bq = b._bq;
      }
      this._be = b._be;
      this._ak = b._ak;
      this._a7 = b._a7;
      this._c1 = b._c1;
      this._cx = ExcelUtils.ds;
      this._cy = ExcelUtils.dq;
      this._dq(2);
      this._dq(8);
      this._dq(16);
      this._dq(4);
      this._dq(1);
      this._dq(32);
      this._dn(c);
    }
    else {
      this._bo.setFontFormatting(a.font);
      this.formatString = a.formatString;
      this._locked$i = a._locked$i;
      this._wrapText$i = a._wrapText$i;
      this._shrinkToFit$i = a._shrinkToFit$i;
      this.alignment = a.alignment;
      this.verticalAlignment = a.verticalAlignment;
      this.rotation = a.rotation;
      this.indent = a.indent;
      this.leftBorderStyle = a.leftBorderStyle;
      this.rightBorderStyle = a.rightBorderStyle;
      this.topBorderStyle = a.topBorderStyle;
      this.bottomBorderStyle = a.bottomBorderStyle;
      this.leftBorderColorInfo = a.leftBorderColorInfo;
      this.rightBorderColorInfo = a.rightBorderColorInfo;
      this.topBorderColorInfo = a.topBorderColorInfo;
      this.bottomBorderColorInfo = a.bottomBorderColorInfo;
      this.fill = a.fill;
      this.diagonalBorderColorInfo = a.diagonalBorderColorInfo;
      this.diagonalBorders = a.diagonalBorders;
      this.diagonalBorderStyle = a.diagonalBorderStyle;
      if (this._b1 == 0) {
        this.style = a.style;
      }
      this.formatOptions = a.formatOptions;
    }
  }
  _dh(a, b) {
    if (this._b1 == 1) {
      return;
    }
    if (a == 0) {
      return;
    }
    if (this._bt == null) {
      this._bt = new WorksheetCellFormatData(this.v, 1);
    }
    if (ExcelUtils.bx(a, 1)) {
      if (ExcelUtils.bx(b.formatOptions, 1)) {
        this._bt._ci = b._ci;
      }
      this._bt.formatOptions |= 1;
    }
    if (ExcelUtils.bx(a, 2)) {
      if (ExcelUtils.bx(b.formatOptions, 2)) {
        this._bt._a3 = b._a3;
        this._bt._cj = b._cj;
        this._bt._ck = b._ck;
        this._bt._c0 = b._c0;
        this._bt._a7 = b._a7;
        this._bt._c1 = b._c1;
      }
      this._bt.formatOptions |= 2;
    }
    if (ExcelUtils.bx(a, 4)) {
      if (ExcelUtils.bx(b.formatOptions, 4)) {
        this._bt.font.setFontFormatting(b._bp.d);
      }
      this._bt.formatOptions |= 4;
    }
    if (ExcelUtils.bx(a, 8)) {
      if (ExcelUtils.bx(b.formatOptions, 8)) {
        this._bt._ba = b._ba;
        this._bt._ag = b._ag;
        this._bt._bb = b._bb;
        this._bt._au = b._au;
        this._bt._ah = b._ah;
        this._bt._bc = b._bc;
        this._bt._ai = b._ai;
        this._bt._bd = b._bd;
        this._bt._aj = b._aj;
        this._bt._be = b._be;
        this._bt._ak = b._ak;
      }
      this._bt.formatOptions |= 8;
    }
    if (ExcelUtils.bx(a, 16)) {
      if (ExcelUtils.bx(b.formatOptions, 16)) {
        this._bt._aq = b._aq;
      }
      this._bt.formatOptions |= 16;
    }
    if (ExcelUtils.bx(a, 32)) {
      if (ExcelUtils.bx(b.formatOptions, 32)) {
        this._bt._cz = b._cz;
      }
      this._bt.formatOptions |= 32;
    }
    this.formatOptions |= a;
  }
  _dk() {
    if (typeCast(GenericCachedCollection$1.$.specialize(WorksheetCellFormatData.$), this.t) !== null) {
      return;
    }
    this.x = true;
    this._bp.d._ay();
  }
  static _c8(a) {
    switch (a) {
      case 1: return KnownBoxes.ax;
      case 2:
      case 8:
      case 256:
      case 2048:
      case 65536:
      case 262144:
      case 2097152:
      case 67108864: return null;
      case 4:
      case 32:
      case 524288:
      case 4194304:
      case 134217728: return KnownBoxes.f;
      case 16: return KnownBoxes.s;
      case 64: return null;
      case 128:
      case 1024:
      case 4096:
      case 1048576:
      case 16777216:
      case 536870912: return KnownBoxes.y;
      case 512:
      case 131072:
      case 8388608: return KnownBoxes.a4;
      case 8192: return KnownBoxes.ab;
      case 16384: return KnownBoxes.af;
      case 33554432: return null;
      case 268435456: return KnownBoxes.bf;
      default: return true;
    }
  }
  _ay(a) {
    return WorksheetCellFormatData._az(a, this);
  }
  static _az(a, b) {
    if (a == null) {
      if (ExcelUtils.bx(b.formatOptions, 16)) {
        return 0;
      }
      return -1;
    }
    let c = typeCast(CellFillPattern.$, a);
    if (c != null) {
      return c.patternStyle;
    }
    let d = typeCast(CellFillGradient.$, a);
    if (d != null) {
      return 1;
    }
    return -1;
  }
  _bi(a, b, c) {
    return WorksheetCellFormatData._bj(a, b, c, this, this._b9);
  }
  static _bj(a, b, c, d, e) {
    let f = b ? new WorkbookColorInfo(SystemColorsInternal.bb) : WorkbookColorInfo.automatic;
    let g = c ? f : null;
    if (a == null) {
      if (ExcelUtils.bx(d.formatOptions, 16)) {
        return f;
      }
      return g;
    }
    let h = typeCast(CellFillPattern.$, a);
    if (h != null) {
      if (b) {
        return h._z(e);
      }
      return h._ab(e);
    }
    let i = typeCast(CellFillGradient.$, a);
    if (i != null) {
      if (b) {
        return WorkbookColorInfo.automatic;
      }
      return i.stops.item(0).colorInfo;
    }
    return g;
  }
  static _a2(a, b) {
    if (a == null) {
      return null;
    }
    return a._av;
  }
  _da(a, b = null) {
    let c;
    let d = ((() => { let e = this._db(a, b, c); c = e.p2; return e.ret; })());
    if (c == false && b != null && ExcelUtils.a2(a) && Base.equalsStatic(d, WorksheetCellFormatData._dc(a))) {
      let e = ExcelUtils.m(a);
      let f = this._dd(e);
      if (WorksheetCellFormatData._cf(e, f) || Base.equalsStatic(f, WorksheetCellFormatData._dc(e))) {
        let g;
        if (((() => { let h = b(a, g); g = h.p1; return h.ret; })())) {
          return g;
        }
      }
    }
    return d;
  }
  _db(a, b, c) {
    c = false;
    let d = this._dd(a);
    if (WorksheetCellFormatData._cf(a, d) == false) {
      return {
        ret: d,
        p2: c
      };
    }
    let e = WorksheetCellFormatData._by(a);
    if (this._b1 == 2 && ExcelUtils.bx(this.formatOptions, e) == false) {
      return {
        ret: d,
        p2: c
      };
    }
    if (b != null && this._b1 == 0 && ExcelUtils.a2(a)) {
      if (((() => { let f = b(a, d); d = f.p1; return f.ret; })())) {
        c = true;
        return {
          ret: d,
          p2: c
        };
      }
    }
    let f;
    d = ((() => { let g = this._c9(a, f); f = g.p1; return g.ret; })());
    if (f && this._b1 != 1) {
      if (ExcelUtils.bx(this.formatOptions, e)) {
        if (this._bt != null) {
          d = this._bt._da(a);
        }
      }
      else if (this.style != null) {
        d = this.style._i._da(a);
      }
    }
    return {
      ret: d,
      p2: c
    };
  }
  _dd(a) {
    switch (a) {
      case 1: return KnownBoxes.ap(this.alignment);
      case 2: return this.bottomBorderColorInfo;
      case 4: return KnownBoxes.al(this.bottomBorderStyle);
      case 8: return this.diagonalBorderColorInfo;
      case 16: return KnownBoxes.am(this.diagonalBorders);
      case 32: return KnownBoxes.al(this.diagonalBorderStyle);
      case 64: return this.fill;
      case 128: return KnownBoxes.au(this.font._bold$i);
      case 256: return this.font.colorInfo;
      case 512: return KnownBoxes.at(this.font.height);
      case 1024: return KnownBoxes.au(this.font._italic$i);
      case 2048: return this.font.name;
      case 4096: return KnownBoxes.au(this.font._strikeout$i);
      case 8192: return KnownBoxes.an(this.font.superscriptSubscriptStyle);
      case 16384: return KnownBoxes.ao(this.font.underlineStyle);
      case 65536: return this.formatString;
      case 131072: return KnownBoxes.at(this.indent);
      case 262144: return this.leftBorderColorInfo;
      case 524288: return KnownBoxes.al(this.leftBorderStyle);
      case 1048576: return KnownBoxes.au(this._locked$i);
      case 2097152: return this.rightBorderColorInfo;
      case 4194304: return KnownBoxes.al(this.rightBorderStyle);
      case 8388608: return KnownBoxes.at(this.rotation);
      case 16777216: return KnownBoxes.au(this._shrinkToFit$i);
      case 33554432: return this.style;
      case 32768: return KnownBoxes.ar(this.formatOptions);
      case 67108864: return this.topBorderColorInfo;
      case 134217728: return KnownBoxes.al(this.topBorderStyle);
      case 268435456: return KnownBoxes.aq(this.verticalAlignment);
      case 536870912: return KnownBoxes.au(this._wrapText$i);
      default: return null;
    }
  }
  _cg() {
    let a = new List$1(ExtProp.$, 0);
    this._dw(this._bf, 8, a);
    this._dw(this._bg, 11, a);
    this._dw(this._bk, 9, a);
    this._dw(this._bl, 10, a);
    this._dw(this._bm, 7, a);
    let b = this._bn(this._bh);
    if (WorkbookColorInfo.l_op_Inequality(b, null)) {
      a.add(new ExtPropColor(b, 13));
    }
    let c = this._ar;
    if (c != null) {
      c._r(this, a);
    }
    let d = this._ct;
    if (15 < d) {
      a.add(new ExtPropTextIndentationLevel(d));
    }
    if (this._a5 != 255) {
      a.add(new ExtPropFontScheme(this._a5));
    }
    return a;
  }
  _ch() {
    let a = (this._b1 == 2);
    let b = new List$1(XFProp.$, 0);
    if (ExcelUtils.bx(this.formatOptions, 2)) {
      if (a) {
        if (this.alignment != -1) {
          b.add(new XFPropHorizontalAlignment(this.alignment));
        }
        if (this.indent != -1) {
          b.add(new XFPropTextIndentationLevel(Math.min(this.indent, 15)));
        }
        if (this.rotation != -1) {
          b.add(new XFPropTextRotation(this.rotation));
        }
        if (nullableNotEquals(this._shrinkToFit$i, null)) {
          b.add(new XFPropBool(1, 22, this._shrinkToFit$i));
        }
        if (this.verticalAlignment != -1) {
          b.add(new XFPropVerticalAlignment(this.verticalAlignment));
        }
        if (nullableNotEquals(this._wrapText$i, null)) {
          b.add(new XFPropBool(1, 20, this._wrapText$i));
        }
      }
      if (15 < this.indent) {
        b.add(new XFPropTextIndentationLevelRelative((this.indent - 15)));
      }
    }
    if (ExcelUtils.bx(this.formatOptions, 8)) {
      if (WorkbookColorInfo.l_op_Inequality(this.bottomBorderColorInfo, null) || this.bottomBorderStyle != -1) {
        b.add(new XFPropBorder(7, this._bf, this._al));
      }
      if (WorkbookColorInfo.l_op_Inequality(this.diagonalBorderColorInfo, null) || this.topBorderStyle != -1) {
        b.add(new XFPropBorder(6, this._bm, this._ap));
      }
      if (WorkbookColorInfo.l_op_Inequality(this.leftBorderColorInfo, null) || this.leftBorderStyle != -1) {
        b.add(new XFPropBorder(8, this._bk, this._an));
      }
      if (WorkbookColorInfo.l_op_Inequality(this.rightBorderColorInfo, null) || this.rightBorderStyle != -1) {
        b.add(new XFPropBorder(9, this._bl, this._ao));
      }
      if (WorkbookColorInfo.l_op_Inequality(this.bottomBorderColorInfo, null) || this.topBorderStyle != -1) {
        b.add(new XFPropBorder(6, this._bm, this._ap));
      }
      if (ExcelUtils.bv(this.diagonalBorders, 3)) {
        b.add(new XFPropBool(0, 14, true));
      }
      if (ExcelUtils.bv(this.diagonalBorders, 5)) {
        b.add(new XFPropBool(0, 13, true));
      }
    }
    if (ExcelUtils.bx(this.formatOptions, 16)) {
      let c = this._ar;
      if (c != null) {
        c._s(this, b);
      }
    }
    if (ExcelUtils.bx(this.formatOptions, 4)) {
      if (a) {
        let d = this._bp.d;
        if (nullableNotEquals(d._bold$i, null)) {
          b.add(new XFPropFontBold(1, d._bold$i));
        }
        if (WorkbookColorInfo.l_op_Inequality(d.colorInfo, null)) {
          b.add(new XFPropColor(5, this._bn(d.colorInfo)));
        }
        if (d.height != -1) {
          b.add(new XFPropFontHeight(intSToU(d.height)));
        }
        if (nullableNotEquals(d._italic$i, null)) {
          b.add(new XFPropBool(1, 28, d._italic$i));
        }
        if (d.name != null) {
          b.add(new XFPropFontName(d.name));
        }
        if (nullableNotEquals(d._strikeout$i, null)) {
          b.add(new XFPropBool(1, 28, d._strikeout$i));
        }
        if (d.superscriptSubscriptStyle != -1) {
          b.add(new XFPropFontSubscriptSuperscript(d.superscriptSubscriptStyle));
        }
        if (d.underlineStyle != -1) {
          b.add(new XFPropFontUnderline(d.underlineStyle));
        }
      }
      if (this._a5 != 255) {
        b.add(new XFPropFontScheme(this._a5));
      }
    }
    if (a) {
      if (ExcelUtils.bx(this.formatOptions, 1)) {
        if (this._cr != -1) {
          if (this.v != null && this.v._b2.e(this._cr)) {
            b.add(new XFPropNumberFormatId(this._cr));
          }
          else {
            b.add(new XFPropNumberFormat(this._cr, this.formatString));
          }
        }
      }
      if (ExcelUtils.bx(this.formatOptions, 32)) {
        if (nullableNotEquals(this._locked$i, null)) {
          b.add(new XFPropBool(1, 43, this._locked$i));
        }
      }
    }
    return b;
  }
  _cc() {
    return WorkbookColorInfo.l_op_Inequality(this.bottomBorderColorInfo, null) || this.bottomBorderStyle != -1 || WorkbookColorInfo.l_op_Inequality(this.diagonalBorderColorInfo, null) || this.diagonalBorders != 0 || this.diagonalBorderStyle != -1 || WorkbookColorInfo.l_op_Inequality(this.leftBorderColorInfo, null) || this.leftBorderStyle != -1 || WorkbookColorInfo.l_op_Inequality(this.rightBorderColorInfo, null) || this.rightBorderStyle != -1 || WorkbookColorInfo.l_op_Inequality(this.topBorderColorInfo, null) || this.topBorderStyle != -1;
  }
  static _cf(a, b) {
    if (a == 32768) {
      return false;
    }
    return Base.equalsStatic(b, WorksheetCellFormatData._c8(a));
  }
  _dm() {
    if (this._df == "Calibri") {
      this._a5 = 2;
    }
    else if (this._df == "Cambria") {
      this._a5 = 1;
    }
    else {
      this._a5 = 255;
    }
    this._dq(4);
  }
  _ds(a) {
    this._dv(a, WorksheetCellFormatData._c8(a));
  }
  _dv(a, b) {
    switch (a) {
      case 1:
        this.alignment = EnumUtil.getEnumValue(HorizontalCellAlignment_$type, b);
        break;
      case 2:
        this.bottomBorderColorInfo = b;
        break;
      case 4:
        this.bottomBorderStyle = EnumUtil.getEnumValue(CellBorderLineStyle_$type, b);
        break;
      case 8:
        this.diagonalBorderColorInfo = b;
        break;
      case 16:
        this.diagonalBorders = EnumUtil.getEnumValue(DiagonalBorders_$type, b);
        break;
      case 32:
        this.diagonalBorderStyle = EnumUtil.getEnumValue(CellBorderLineStyle_$type, b);
        break;
      case 64:
        this.fill = b;
        break;
      case 128:
        this.font._bold$i = wrapNullable(Boolean_$type, b);
        break;
      case 256:
        this.font.colorInfo = b;
        break;
      case 512:
        this.font.height = typeGetValue(b);
        break;
      case 1024:
        this.font._italic$i = wrapNullable(Boolean_$type, b);
        break;
      case 2048:
        this.font.name = b;
        break;
      case 4096:
        this.font._strikeout$i = wrapNullable(Boolean_$type, b);
        break;
      case 8192:
        this.font.superscriptSubscriptStyle = EnumUtil.getEnumValue(FontSuperscriptSubscriptStyle_$type, b);
        break;
      case 16384:
        this.font.underlineStyle = EnumUtil.getEnumValue(FontUnderlineStyle_$type, b);
        break;
      case 65536:
        this.formatString = b;
        break;
      case 131072:
        this.indent = typeGetValue(b);
        break;
      case 262144:
        this.leftBorderColorInfo = b;
        break;
      case 524288:
        this.leftBorderStyle = EnumUtil.getEnumValue(CellBorderLineStyle_$type, b);
        break;
      case 1048576:
        this._locked$i = wrapNullable(Boolean_$type, b);
        break;
      case 2097152:
        this.rightBorderColorInfo = b;
        break;
      case 4194304:
        this.rightBorderStyle = EnumUtil.getEnumValue(CellBorderLineStyle_$type, b);
        break;
      case 8388608:
        this.rotation = typeGetValue(b);
        break;
      case 16777216:
        this._shrinkToFit$i = wrapNullable(Boolean_$type, b);
        break;
      case 33554432:
        this.style = b;
        break;
      case 32768:
        this.formatOptions = EnumUtil.getEnumValue(WorksheetCellFormatOptions_$type, b);
        break;
      case 67108864:
        this.topBorderColorInfo = b;
        break;
      case 134217728:
        this.topBorderStyle = EnumUtil.getEnumValue(CellBorderLineStyle_$type, b);
        break;
      case 268435456:
        this.verticalAlignment = EnumUtil.getEnumValue(VerticalCellAlignment_$type, b);
        break;
      case 536870912:
        this._wrapText$i = wrapNullable(Boolean_$type, b);
        break;
      default: break;
    }
  }
  _dw(a, b, c) {
    if (WorkbookColorInfo.l_op_Equality(a, null)) {
      return;
    }
    let d;
    switch (b) {
      case 8:
      case 11:
      case 9:
      case 10:
      case 7:
        d = 0;
        break;
      case 13:
        d = 2;
        break;
      case 4:
      case 5:
        d = 1;
        break;
      default:
        d = 0;
        break;
    }
    if (a._o(this.v, d) == false) {
      c.add(new ExtPropColor(a, b));
    }
  }
  _dx(a, b, c) {
    if (WorkbookColorInfo.l_op_Equality(a, null)) {
      return;
    }
    let d;
    switch (b) {
      case 1:
      case 2:
        d = 1;
        break;
      default:
        d = 0;
        break;
    }
    if (a._o(this.v, d) == false) {
      c.add(new XFPropColor(b, a));
    }
  }
  static _di(a) {
    if (WorkbookColorInfo.l_op_Equality(a, null)) {
      return {
        p0: a
      };
    }
    if (a._color$i.hasValue && Color.b(a._color$i.value, SystemColorsInternal.bd)) {
      a = new WorkbookColorInfo(Nullable$1.toNullable(Color.$, SystemColorsInternal.bf), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a._tint$i, false, false);
    }
    return {
      p0: a
    };
  }
  _br(a) {
    if (a == null && this._b1 != 1 && this.v != null) {
      return this.v._styles$i.normalStyle;
    }
    return a;
  }
  _bx(a) {
    let b = 0;
    let c = this._dj(a, 2, b);
    b = c.p2;
    let d = this._dj(a, 8, b);
    b = d.p2;
    let e = this._dj(a, 16, b);
    b = e.p2;
    let f = this._dj(a, 4, b);
    b = f.p2;
    let g = this._dj(a, 1, b);
    b = g.p2;
    let h = this._dj(a, 32, b);
    b = h.p2;
    return b;
  }
  _dj(a, b, c) {
    if (ExcelUtils.bx(a, b)) {
      if (this._cb(b) == false) {
        c |= b;
      }
    }
    return {
      p2: c
    };
  }
  static _by(a) {
    switch (a) {
      case 1:
      case 131072:
      case 8388608:
      case 16777216:
      case 268435456:
      case 536870912: return 2;
      case 64: return 16;
      case 2:
      case 4:
      case 8:
      case 16:
      case 32:
      case 262144:
      case 524288:
      case 2097152:
      case 4194304:
      case 67108864:
      case 134217728: return 8;
      case 65536: return 1;
      case 1048576: return 32;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384: return 4;
      case 33554432:
      case 32768: return 0;
      default: return 0;
    }
  }
  static _at(a) {
    switch (a) {
      case 1: return 1073807360;
      case 2: return 830603265;
      case 4: return 32640;
      case 8: return 208404542;
      case 16: return 1073741888;
      case 32: return 1074790400;
      default: return 0;
    }
  }
  _dl(a, b, c, d) {
    let e = ExcelUtils.bx(a, b);
    let f = ExcelUtils.bx(this.formatOptions, b);
    if (e != f) {
      if (f == false) {
        c |= b;
      }
      else {
        d |= b;
      }
    }
    return {
      p2: c,
      p3: d
    };
  }
  _c9(a, b) {
    b = true;
    switch (a) {
      case 32:
        let c = this.diagonalBorderColorInfo;
        let d = this.diagonalBorders;
        if (WorkbookColorInfo.l_op_Inequality(c, null) || ExcelUtils.bv(d, 3) || ExcelUtils.bv(d, 5)) {
          b = false;
          return {
            ret: enumGetBox(CellBorderLineStyle_$type, 1),
            p1: b
          };
        }
        break;
      case 4:
      case 524288:
      case 4194304:
      case 134217728:
        let e = this._dd(ExcelUtils.m(a));
        if (WorkbookColorInfo.l_op_Inequality(e, null)) {
          b = false;
          return {
            ret: enumGetBox(CellBorderLineStyle_$type, 1),
            p1: b
          };
        }
        break;
    }
    return {
      ret: WorksheetCellFormatData._dc(a),
      p1: b
    };
  }
  static _dc(a) {
    switch (a) {
      case 1: return KnownBoxes.a0;
      case 2:
      case 8:
      case 256:
      case 262144:
      case 2097152:
      case 67108864: return WorkbookColorInfo.automatic;
      case 4:
      case 32:
      case 524288:
      case 4194304:
      case 134217728: return KnownBoxes.n;
      case 16: return KnownBoxes.v;
      case 64: return CellFill.noColor;
      case 128:
      case 1024:
      case 4096:
      case 16777216:
      case 536870912: return KnownBoxes.z;
      case 512: return WorkbookFontData._at;
      case 2048: return "Calibri";
      case 8192: return KnownBoxes.ac;
      case 16384: return KnownBoxes.ai;
      case 65536: return "General";
      case 131072:
      case 8388608: return KnownBoxes.a5;
      case 1048576: return KnownBoxes.aa;
      case 268435456: return KnownBoxes.bd;
      case 33554432:
      case 32768: return null;
      default: return null;
    }
  }
  _cb(a) {
    let b = WorksheetCellFormatData._at(a);
    for (let c = 1; c != 1073741824; c = (c << 1)) {
      if ((b & c) == 0) {
        continue;
      }
      if (Base.equalsStatic(this._da(c), WorksheetCellFormatData._dc(c)) == false) {
        return false;
      }
    }
    return true;
  }
  _dp(a) {
    this._dq(WorksheetCellFormatData._by(a));
  }
  _dq(a) {
    this._cx = ExcelUtils.ds;
    this._cy = ExcelUtils.dq;
    switch (a) {
      case 1:
        this._d1();
        break;
      case 2:
        this._dy();
        break;
      case 4:
        this._d0();
        break;
      case 8:
        this._dz();
        break;
      case 16:
        this._d2();
        break;
      case 32:
        this._d3();
        break;
      default: break;
    }
    if (this._b2 != null) {
      this._b2(a);
    }
  }
  _dr(a) {
    if (a == 0) {
      return;
    }
    if (ExcelUtils.bx(a, 1)) {
      this._ci = -1;
      if (this._b2 != null) {
        this._b2(1);
      }
    }
    if (ExcelUtils.bx(a, 2)) {
      this._a3 = -1;
      this._cj = -1;
      this._ck = -1;
      this._c0 = ExcelUtils.dq;
      this._c1 = ExcelUtils.dq;
      this._a7 = -1;
      if (this._b2 != null) {
        this._b2(2);
      }
    }
    if (ExcelUtils.bx(a, 4)) {
      if (this._bo == null) {
        this._bo = new WorkbookFontProxy(0, new WorkbookFontData(0, this.v), this.v, this);
      }
      else {
        this._bo.setFontFormatting(new WorkbookFontData(0, this.v));
      }
      if (this._b2 != null) {
        this._b2(4);
      }
    }
    if (ExcelUtils.bx(a, 8)) {
      this._ba = null;
      this._ag = -1;
      this._bb = null;
      this._au = 0;
      this._ah = -1;
      this._bc = null;
      this._ai = -1;
      this._bd = null;
      this._aj = -1;
      this._be = null;
      this._ak = -1;
      if (this._b2 != null) {
        this._b2(8);
      }
    }
    if (ExcelUtils.bx(a, 16)) {
      this._aq = null;
      if (this._b2 != null) {
        this._b2(16);
      }
    }
    if (ExcelUtils.bx(a, 32)) {
      this._cz = ExcelUtils.dq;
      if (this._b2 != null) {
        this._b2(32);
      }
    }
    this._cx = ExcelUtils.ds;
    this._cy = ExcelUtils.dq;
    if (this._bt != null) {
      this._bt.formatOptions &= ~a;
      if (this._bt.formatOptions == 0) {
        this._bt = null;
      }
    }
  }
  _dy() {
    let a = this.alignment != -1 || this.indent != -1 || this.rotation != -1 || nullableNotEquals(this._shrinkToFit$i, null) || this.verticalAlignment != -1 || nullableNotEquals(this._wrapText$i, null);
    if (a) {
      this.formatOptions |= 2;
    }
  }
  _dz() {
    if (this._cc()) {
      this.formatOptions |= 8;
    }
  }
  _d0() {
    let a = (this._bp.d._am == false);
    if (a) {
      this.formatOptions |= 4;
    }
  }
  _d1() {
    let a = this.formatString != null;
    if (a) {
      this.formatOptions |= 1;
    }
  }
  _d2() {
    let a = this.fill != null;
    if (a) {
      this.formatOptions |= 16;
    }
  }
  _d3() {
    let a = nullableNotEquals(this._locked$i, null);
    if (a) {
      this.formatOptions |= 32;
    }
  }
  _bn(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, null) && this.v != null) {
      let b = this.v._palette$i._l(a, 2);
      if (66 <= b && b <= 81) {
        let c = ExcelUtils.gx(ExcelUtils.cx(a._getResolvedColor1(this.v)));
        return new WorkbookColorInfo(c);
      }
    }
    return a;
  }
  get alignment() {
    return this._a3;
  }
  set alignment(a) {
    this.af();
    if (this.alignment == a) {
      return;
    }
    if (ExcelUtils.a7(a) == false) {
      throw new InvalidEnumArgumentException("value", a, HorizontalCellAlignment_$type);
    }
    this._a3 = a;
    if (this._a3 != 7) {
      this._b6 = false;
    }
    this._dp(1);
  }
  get bottomBorderColorInfo() {
    return this._ba;
  }
  set bottomBorderColorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this.bottomBorderColorInfo, a)) {
      return;
    }
    let b = WorksheetCellFormatData._di(a);
    a = b.p0;
    this._ba = a;
    this._dp(2);
  }
  get bottomBorderStyle() {
    return this._ag;
  }
  set bottomBorderStyle(a) {
    this.af();
    if (this.bottomBorderStyle == a) {
      return;
    }
    if (ExcelUtils.aw(a) == false) {
      throw new InvalidEnumArgumentException("value", a, CellBorderLineStyle_$type);
    }
    this._ag = a;
    this._dp(4);
  }
  get diagonalBorderColorInfo() {
    return this._bb;
  }
  set diagonalBorderColorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this.diagonalBorderColorInfo, a)) {
      return;
    }
    let b = WorksheetCellFormatData._di(a);
    a = b.p0;
    this._bb = a;
    this._dp(8);
  }
  get diagonalBorders() {
    return this._au;
  }
  set diagonalBorders(a) {
    this.af();
    if (this.diagonalBorders == a) {
      return;
    }
    if (EnumUtil.isDefined(DiagonalBorders_$type, enumGetBox(DiagonalBorders_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, DiagonalBorders_$type);
    }
    this._av = this._au;
    this._au = a;
    this._dp(16);
  }
  get diagonalBorderStyle() {
    return this._ah;
  }
  set diagonalBorderStyle(a) {
    this.af();
    if (this.diagonalBorderStyle == a) {
      return;
    }
    if (ExcelUtils.aw(a) == false) {
      throw new InvalidEnumArgumentException("value", a, CellBorderLineStyle_$type);
    }
    this._ah = a;
    this._dp(32);
  }
  get fill() {
    return this._aq;
  }
  set fill(a) {
    this.af();
    if (this.fill == a) {
      return;
    }
    this._aq = a;
    this._dp(64);
  }
  get font() {
    return this._bp;
  }
  get formatOptions() {
    return this._bw;
  }
  set formatOptions(a) {
    this.af();
    a &= 63;
    if (this._bw == a) {
      return;
    }
    let b = this._bw;
    this._dt(a);
    this._dn(b);
    if (this._b2 != null) {
      this._b2(63);
    }
  }
  _dt(a) {
    this._bw = a;
    this._cx = ExcelUtils.ds;
    this._cy = ExcelUtils.dq;
    if (this._b2 != null) {
      this._b2(63);
    }
  }
  _dn(a) {
    let b = 0;
    let c = 0;
    let d = this._dl(a, 1, b, c);
    b = d.p2;
    c = d.p3;
    let e = this._dl(a, 2, b, c);
    b = e.p2;
    c = e.p3;
    let f = this._dl(a, 4, b, c);
    b = f.p2;
    c = f.p3;
    let g = this._dl(a, 8, b, c);
    b = g.p2;
    c = g.p3;
    let h = this._dl(a, 16, b, c);
    b = h.p2;
    c = h.p3;
    let i = this._dl(a, 32, b, c);
    b = i.p2;
    c = i.p3;
    this._dr(b);
    if (this.style != null) {
      this._dh(c, this.style._i);
    }
  }
  get formatString() {
    if (this.v == null) {
      return null;
    }
    return this.v._b2.item(this._ci);
  }
  set formatString(a) {
    this.af();
    if (this.formatString == a) {
      return;
    }
    if (a != null) {
      let b = this.v;
      if (b != null) {
        if (b.validateFormatStrings) {
          let c = new ValueFormatter(0, b, a, b._e6);
          if (c.o == false) {
            if (b._c4) {
            }
            else {
              throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidOperationException_InvalidFormatString"), "value");
            }
          }
        }
        this._ci = b._b2.q(a);
      }
      else {
      }
    }
    else {
      this._ci = -1;
    }
    this._dp(65536);
  }
  get indent() {
    return this._cj;
  }
  set indent(a) {
    this.af();
    if (this.indent == a) {
      return;
    }
    if (a != -1 && (a < 0 || 250 < a)) {
      throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Indent"));
    }
    this._cj = a;
    this._dp(131072);
  }
  get leftBorderColorInfo() {
    return this._bc;
  }
  set leftBorderColorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this.leftBorderColorInfo, a)) {
      return;
    }
    let b = WorksheetCellFormatData._di(a);
    a = b.p0;
    this._bc = a;
    this._dp(262144);
  }
  get leftBorderStyle() {
    return this._ai;
  }
  set leftBorderStyle(a) {
    this.af();
    if (this.leftBorderStyle == a) {
      return;
    }
    if (ExcelUtils.aw(a) == false) {
      throw new InvalidEnumArgumentException("value", a, CellBorderLineStyle_$type);
    }
    this._ai = a;
    this._dp(524288);
  }
  get locked() {
    return unwrapNullable(this._locked$i);
  }
  set locked(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._locked$i = arguments[0];
  }
  get _locked$i() {
    return this._cz;
  }
  set _locked$i(a) {
    this.af();
    if (nullableEquals(this._locked$i, a)) {
      return;
    }
    if (ExcelUtils.a5(a) == false) {
      throw new InvalidEnumArgumentException("value", ExcelUtils.dk(a), Nullable$1.$.specialize(Boolean_$type));
    }
    this._cz = a;
    this._dp(1048576);
  }
  get rightBorderColorInfo() {
    return this._bd;
  }
  set rightBorderColorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this.rightBorderColorInfo, a)) {
      return;
    }
    let b = WorksheetCellFormatData._di(a);
    a = b.p0;
    this._bd = a;
    this._dp(2097152);
  }
  get rightBorderStyle() {
    return this._aj;
  }
  set rightBorderStyle(a) {
    this.af();
    if (this.rightBorderStyle == a) {
      return;
    }
    if (ExcelUtils.aw(a) == false) {
      throw new InvalidEnumArgumentException("value", a, CellBorderLineStyle_$type);
    }
    this._aj = a;
    this._dp(4194304);
  }
  get rotation() {
    return this._ck;
  }
  set rotation(a) {
    this.af();
    if (this.rotation == a) {
      return;
    }
    this._ck = a;
    this._dp(8388608);
  }
  get shrinkToFit() {
    return unwrapNullable(this._shrinkToFit$i);
  }
  set shrinkToFit(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._shrinkToFit$i = arguments[0];
  }
  get _shrinkToFit$i() {
    return this._c0;
  }
  set _shrinkToFit$i(a) {
    this.af();
    if (nullableEquals(this._shrinkToFit$i, a)) {
      return;
    }
    if (ExcelUtils.a5(a) == false) {
      throw new InvalidEnumArgumentException("value", ExcelUtils.dk(a), Nullable$1.$.specialize(Boolean_$type));
    }
    this._c0 = a;
    this._dp(16777216);
  }
  get style() {
    return this._br(this._bq);
  }
  set style(a) {
    this.af();
    a = this._br(a);
    if (this._bq == a) {
      return;
    }
    if (a != null) {
      if (this._b1 == 1) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotSetParentStyleOnStyle"));
      }
      if (a._g != this.v) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidOperationException_ParentStyleFromOtherWorkbook"), "value");
      }
    }
    if (this._bq != null && this.t != null) {
      this._bq._y();
    }
    if (this._bq != null && a != null && this.v._c4 == false) {
      let b = this._bq._i.formatOptions;
      b &= ~a._i.formatOptions;
      b = this._bx(b);
      this._dh(b, this._bq._i);
    }
    this._bq = a;
    if (this._bq != null && this.t != null) {
      this._bq._x();
    }
    if (this._bq != null && (this.v == null || this.v._c4 == false)) {
      this.formatOptions &= ~this._bq._i.formatOptions;
    }
    if (this._b2 != null) {
      this._b2(63);
    }
  }
  _du(a) {
    this._bq = a;
    this._cx = ExcelUtils.ds;
    this._cy = ExcelUtils.dq;
    if (this._b2 != null) {
      this._b2(63);
    }
  }
  get topBorderColorInfo() {
    return this._be;
  }
  set topBorderColorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this.topBorderColorInfo, a)) {
      return;
    }
    let b = WorksheetCellFormatData._di(a);
    a = b.p0;
    this._be = a;
    this._dp(67108864);
  }
  get topBorderStyle() {
    return this._ak;
  }
  set topBorderStyle(a) {
    this.af();
    if (this._ak == a) {
      return;
    }
    if (ExcelUtils.aw(a) == false) {
      throw new InvalidEnumArgumentException("value", a, CellBorderLineStyle_$type);
    }
    this._ak = a;
    this._dp(134217728);
  }
  get verticalAlignment() {
    return this._a7;
  }
  set verticalAlignment(a) {
    this.af();
    if (this._a7 == a) {
      return;
    }
    if (ExcelUtils.bi(a) == false) {
      throw new InvalidEnumArgumentException("value", a, VerticalCellAlignment_$type);
    }
    this._a7 = a;
    this._dp(268435456);
  }
  get wrapText() {
    return unwrapNullable(this._wrapText$i);
  }
  set wrapText(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._wrapText$i = arguments[0];
  }
  get _wrapText$i() {
    return this._c1;
  }
  set _wrapText$i(a) {
    this.af();
    if (nullableEquals(this._c1, a)) {
      return;
    }
    if (ExcelUtils.a5(a) == false) {
      throw new InvalidEnumArgumentException("value", ExcelUtils.dk(a), Nullable$1.$.specialize(Boolean_$type));
    }
    this._c1 = a;
    this._dp(536870912);
  }
  get _a4() {
    return EnumUtil.getEnumValue(HorizontalCellAlignment_$type, this._da(1));
  }
  get _bf() {
    return this._da(2);
  }
  get _al() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._da(4));
  }
  get _bg() {
    return this._da(8);
  }
  get _aw() {
    return EnumUtil.getEnumValue(DiagonalBorders_$type, this._da(16));
  }
  get _am() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._da(32));
  }
  get _ar() {
    return this._da(64);
  }
  get _c2() {
    return wrapNullable(Boolean_$type, this._da(128));
  }
  get _bh() {
    return this._da(256);
  }
  get _cq() {
    return typeGetValue(this._da(512));
  }
  get _c3() {
    return wrapNullable(Boolean_$type, this._da(1024));
  }
  get _df() {
    return this._da(2048);
  }
  get _c4() {
    return wrapNullable(Boolean_$type, this._da(4096));
  }
  get _a0() {
    return EnumUtil.getEnumValue(FontSuperscriptSubscriptStyle_$type, this._da(8192));
  }
  get _a1() {
    return EnumUtil.getEnumValue(FontUnderlineStyle_$type, this._da(16384));
  }
  get _bz() {
    return EnumUtil.getEnumValue(WorksheetCellFormatOptions_$type, this._da(32768));
  }
  get _cs() {
    if (this._ci < 0) {
      if (ExcelUtils.bx(this.formatOptions, 1)) {
        if (this._bt != null) {
          return this._bt._cs;
        }
      }
      else {
        if (this.style != null) {
          return this.style._i._cs;
        }
      }
      return 0;
    }
    return this._ci;
  }
  get _dg() {
    return this._da(65536);
  }
  get _ct() {
    return typeGetValue(this._da(131072));
  }
  get _bk() {
    return this._da(262144);
  }
  get _an() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._da(524288));
  }
  get _c5() {
    return wrapNullable(Boolean_$type, this._da(1048576));
  }
  get _bl() {
    return this._da(2097152);
  }
  get _ao() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._da(4194304));
  }
  get _cw() {
    return typeGetValue(this._da(8388608));
  }
  get _c6() {
    return wrapNullable(Boolean_$type, this._da(16777216));
  }
  get _bs() {
    return this._da(33554432);
  }
  get _bm() {
    return this._da(67108864);
  }
  get _ap() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._da(134217728));
  }
  get _a9() {
    return EnumUtil.getEnumValue(VerticalCellAlignment_$type, this._da(268435456));
  }
  get _c7() {
    return wrapNullable(Boolean_$type, this._da(536870912));
  }
  get _b6() {
    return this._b4;
  }
  set _b6(a) {
    this._b4 = a;
  }
  get _cl() {
    let a = this._ct;
    if (a != 0) {
      let b = this._co;
      if (b != 255) {
        a = 0;
      }
      else {
        let c = this._a9;
        if (c != 2 && c != 4) {
          a = 0;
        }
      }
    }
    return a;
  }
  get _cm() {
    let a = this._ct;
    if (a != 0) {
      let b = this._a4;
      if (b != 1 && b != 7) {
        a = 0;
      }
      else if (this._cw != 0) {
        a = 0;
      }
    }
    return a;
  }
  get _cn() {
    let a = this._ct;
    if (a != 0) {
      let b = this._a4;
      if (b != 3 && b != 7) {
        a = 0;
      }
    }
    return a;
  }
  get _cp() {
    let a = this._ct;
    if (a != 0) {
      let b = this._co;
      if (b != 255) {
        a = 0;
      }
      else {
        let c = this._a9;
        if (c != 0 && c != 4) {
          a = 0;
        }
      }
    }
    return a;
  }
  get _co() {
    let a = this._cw;
    if (a != 0) {
      switch (this._a4) {
        case 6:
        case 4:
          a = 0;
          break;
      }
    }
    return a;
  }
  get _b7() {
    if (nullableEquals(this._c6, true)) {
      if (this._b8) {
        return false;
      }
      switch (this._a4) {
        case 0:
        case 1:
        case 3:
        case 2:
        case 6: return true;
      }
    }
    return false;
  }
  get _a8() {
    let a = this._a9;
    if (a == 4 || a == 3) {
      let b = this._a4;
      if (b == 4) {
        a = 2;
      }
    }
    return a;
  }
  get _b8() {
    if (nullableEquals(this._cy, null)) {
      let a = this._a4;
      switch (a) {
        case 4:
          this._cy = Nullable$1.toNullable(Boolean_$type, false);
          break;
        case 7:
        case 5:
          this._cy = Nullable$1.toNullable(Boolean_$type, true);
          break;
        default:
          let b = this._a9;
          switch (b) {
            case 3:
            case 4:
              this._cy = Nullable$1.toNullable(Boolean_$type, true);
              break;
            default:
              if (nullableEquals(this._c7, true)) {
                this._cy = Nullable$1.toNullable(Boolean_$type, true);
              }
              else {
                this._cy = Nullable$1.toNullable(Boolean_$type, false);
              }
              break;
          }
          break;
      }
    }
    return nullableEquals(this._cy, true);
  }
  get _b9() {
    return this._b5 || this._b0 != 2;
  }
  get _bp() {
    return this._bo;
  }
  get _a6() {
    return this._a5;
  }
  set _a6(a) {
    this._a5 = a;
  }
  get _cr() {
    return this._ci;
  }
  set _cr(a) {
    this._ci = a;
    this._dp(65536);
  }
  get _cd() {
    if (this._b1 == 0 && this.v != null) {
      return this.v._ca._p.equals(this);
    }
    if (this.formatOptions != 0) {
      return false;
    }
    if (this.style != null && this.style._n == false) {
      return false;
    }
    return true;
  }
  get _ce() {
    return this._b5;
  }
  set _ce(a) {
    this._b5 = a;
  }
  get _b1() {
    return this._b0;
  }
  set _b1(a) {
    if (this._b0 == a) {
      return;
    }
    this._b0 = a;
    this._cx = ExcelUtils.ds;
    this._cy = ExcelUtils.dq;
    this.style = null;
  }
  get _ax() {
    return this._av;
  }
  get _b3() {
    return this._b2;
  }
  set _b3(a) {
    this._b2 = a;
  }
}
WorksheetCellFormatData.$t = markType(WorksheetCellFormatData, 'WorksheetCellFormatData', GenericCacheElementEx.$, [IWorkbookFontDefaultsResolver_$type, IWorksheetCellFormat_$type]);
/**
 * @hidden
 */
export class CellFormatCache extends Base {
  constructor(a) {
    super();
    this.c = -1;
    this.a = null;
    this.f = null;
    this.d = null;
    this.e = null;
    this.b = false;
    this.a = a;
    a._as = this;
    this.b = a._a1 != 0;
  }
  g() {
    if (this.f != null) {
      CellFormatCache.h(this.f);
    }
    this.d = null;
    this.e = null;
    this.a._as = null;
  }
  static h(a) {
    let b = null;
    b = typeCast(DomWrapper_$type, a);
    if (b != null) {
      b.remove();
    }
    else if (a != null && a.parentNode != null) {
      a.parentNode.removeChild(a);
    }
  }
}
CellFormatCache.$t = markType(CellFormatCache, 'CellFormatCache');
/**
 * @hidden
 */
export class TextMetricsProviderBase extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  dispose() {
  }
  get__b() {
    return false;
  }
  get _b() {
    return this.get__b();
  }
  _e(a) {
    return 0;
  }
  static _c(a) {
    return a == 33 || a == 34;
  }
  _f(a) {
    let b = Workbook._et(this._a, false);
    if (b != Workbook._jh.width) {
      let c = b / Workbook._jh.width;
      a.width = truncate(MathUtilities.f(a.width * c));
    }
    let d = Workbook._et(this._a, true);
    if (d != Workbook._jh.height) {
      let e = d / Workbook._jh.height;
      a.height = truncate(MathUtilities.f(a.height * e));
    }
    return {
      p0: a
    };
  }
}
TextMetricsProviderBase.$t = markType(TextMetricsProviderBase, 'TextMetricsProviderBase', Base.$, [IDisposable_$type]);
/**
 * @hidden
 */
export class DomTextMetricsProvider extends TextMetricsProviderBase {
  constructor(a, b) {
    super(a);
    this._i = null;
    this._h = new List$1(WorksheetCellFormatData.$, 0);
    this._k = null;
    this._j = null;
    this._i = b;
  }
  dispose() {
    super.dispose();
    if (this._k != null) {
      CellFormatCache.h(this._k);
      this._k = null;
    }
    if (this._j != null) {
      CellFormatCache.h(this._j);
      this._j = null;
    }
    if (this._h != null) {
      for (let a = this._h.count - 1; a >= 0; a--) {
        this._h._inner[a]._as.g();
      }
      this._h.clear();
    }
  }
  _n() {
    if (this._k == null) {
      let a = this._i.createElement("div");
      a.setStyleProperty("position", "absolute");
      a.setStyleProperty("display", "block");
      a.setStyleProperty("visibility", "hidden");
      a.setStyleProperty("overflow", "hidden");
      this._k = a;
      this._i.appendToBody(this._k);
    }
    return this._k;
  }
  _d(a) {
    if (a._as != null && a._as.c >= 0) {
      return a._as.c;
    }
    let b = this._j == null;
    if (b) {
      this._j = this._m();
    }
    this._j.setStyleProperty("font-family", a._df);
    this._j.setStyleProperty("font-size", ((intDivide(a._cq, 20)) + "pt"));
    if (b) {
      this._j.setText("0");
      this._n().append(this._j);
    }
    let c = this._j.height();
    ;
    if (a._as == null) {
      new CellFormatCache(a);
      this._h.add(a);
    }
    c = Math.round(c * 1.085);
    a._as.c = c;
    return c;
  }
  _e(a) {
    let b = this._d(a);
    return MathUtilities.f(Math.max(1, 0.05 * b)) * 3;
  }
  _g(a, b, c = Nullable$1.toNullable(Size.$, null), d = true, e = false) {
    if (e) {
      b = stringReplace(stringReplace(stringReplace(b, "\r\n", ""), "\r", ""), "\n", "");
    }
    else if (b != null && b.length > 0 && b.charCodeAt(b.length - 1) == 10) {
      b += " ";
    }
    if (a._as == null) {
      new CellFormatCache(a);
      this._h.add(a);
    }
    if (Size.l_op_Equality_Lifted(c, Nullable$1.toNullable(Size.$, null)) && b.indexOf('\n') < 0) {
      let f = a._as.e;
      if (f == null) {
        let g = this._i.createElement("canvas").getNativeElement();
        f = g.getContext("2d");
        a._as.d = g;
        a._as.e = f;
        let h = "";
        if (nullableEquals(a._c3, true)) {
          h += "italic ";
        }
        if (nullableEquals(a._c2, true)) {
          h += "bold ";
        }
        h += (intDivide(a._cq, 20)) + "pt \"" + a._df + "\"";
        f.font = h;
      }
      if (!a._as.b) {
        let i = Math.round(a._as.e.measureText(b).width);
        let j = this._d(a);
        return new Size(1, i, j);
      }
    }
    let k = false;
    let l = a._as.f;
    if (l == null) {
      a._as.f = l = this._l(a);
      k = true;
    }
    l.setText(b);
    l.setStyleProperty("max-width", Size.l_op_Inequality_Lifted(c, Nullable$1.toNullable(Size.$, null)) ? c.value.width + "px" : "none");
    if (k) {
      this._n().append(l);
    }
    let m = l.width();
    let n = l.height();
    return new Size(1, m, n);
  }
  _m() {
    let a = this._i.createElement("span");
    a.setStyleProperty("border", "0px none");
    a.setStyleProperty("margin", "0px");
    a.setStyleProperty("padding", "0px");
    a.setStyleProperty("line-height", "normal");
    a.setStyleProperty("position", "relative");
    a.setStyleProperty("display", "block");
    a.setStyleProperty("visibility", "hidden");
    a.setStyleProperty("white-space", "pre");
    a.setStyleProperty("text-decoration", "none");
    a.setStyleProperty("font-weight", "normal");
    a.setStyleProperty("font-style", "normal");
    a.setStyleProperty("max-width", "none");
    return a;
  }
  _l(a) {
    let b = this._i.createElement("span");
    let c = a._b8;
    b.setStyleProperty("border", "0px none");
    b.setStyleProperty("margin", "0px");
    b.setStyleProperty("padding", "0px");
    b.setStyleProperty("line-height", "normal");
    b.setStyleProperty("position", "relative");
    b.setStyleProperty("display", "block");
    b.setStyleProperty("visibility", "hidden");
    b.setStyleProperty("font-family", a._df);
    b.setStyleProperty("font-size", ((intDivide(a._cq, 20)) + "pt"));
    b.setStyleProperty("white-space", (c ? "pre-wrap" : "pre"));
    b.setStyleProperty("overflow-wrap", (c ? "break-word" : "normal"));
    b.setStyleProperty("word-wrap", (c ? "break-word" : "normal"));
    b.setStyleProperty("text-decoration", (a._a1 != 0 ? "underline" : "none"));
    b.setStyleProperty("font-weight", (nullableEquals(a._c2, true) ? "bold" : "normal"));
    b.setStyleProperty("font-style", (nullableEquals(a._c3, true) ? "italic" : "normal"));
    return b;
  }
}
DomTextMetricsProvider.$t = markType(DomTextMetricsProvider, 'DomTextMetricsProvider', TextMetricsProviderBase.$);
/**
 * @hidden
 */
export class HtmlTextMetricsProvider extends TextMetricsProviderBase {
  constructor(a) {
    super(a);
    this._h = new List$1(WorksheetCellFormatData.$, 0);
    this._j = null;
    this._l = null;
  }
  dispose() {
    super.dispose();
    if (this._j != null) {
      CellFormatCache.h(this._j);
      this._j = null;
    }
    if (this._l != null) {
      CellFormatCache.h(this._l);
      this._l = null;
    }
    if (this._h != null) {
      for (let a = this._h.count - 1; a >= 0; a--) {
        this._h._inner[a]._as.g();
      }
      this._h.clear();
    }
  }
  _k() {
    if (this._j == null) {
      let a = document.createElement("div");
      a.style.position = "absolute";
      a.style.display = "block";
      a.style.visibility = "hidden";
      a.style.overflow = "hidden";
      this._j = a;
      document.body.appendChild(this._j);
    }
    return this._j;
  }
  _d(a) {
    if (a._as != null && a._as.c >= 0) {
      return a._as.c;
    }
    let b = this._l == null;
    if (b) {
      this._l = this._n();
    }
    this._l.style.fontFamily = a._df;
    this._l.style.fontSize = (intDivide(a._cq, 20)) + "pt";
    if (b) {
      this._l.innerText = "0";
      this._k().appendChild(this._l);
    }
    let c = HtmlTextMetricsProvider._i(window.getComputedStyle(this._l).height);
    if (a._as == null) {
      new CellFormatCache(a);
      this._h.add(a);
    }
    c = Math.round(c * 1.085);
    a._as.c = c;
    return c;
  }
  _e(a) {
    let b = this._d(a);
    return MathUtilities.f(Math.max(1, 0.05 * b)) * 3;
  }
  _g(a, b, c = Nullable$1.toNullable(Size.$, null), d = true, e = false) {
    if (e) {
      b = stringReplace(stringReplace(stringReplace(b, "\r\n", ""), "\r", ""), "\n", "");
    }
    else if (b != null && b.length > 0 && b.charCodeAt(b.length - 1) == 10) {
      b += " ";
    }
    if (a._as == null) {
      new CellFormatCache(a);
      this._h.add(a);
    }
    if (Size.l_op_Equality_Lifted(c, Nullable$1.toNullable(Size.$, null)) && b.indexOf('\n') < 0) {
      let f = a._as.e;
      if (f == null) {
        let g = document.createElement("canvas");
        f = g.getContext("2d");
        a._as.d = g;
        a._as.e = f;
        let h = "";
        if (nullableEquals(a._c3, true)) {
          h += "italic ";
        }
        if (nullableEquals(a._c2, true)) {
          h += "bold ";
        }
        h += (intDivide(a._cq, 20)) + "pt \"" + a._df + "\"";
        f.font = h;
      }
      if (!a._as.b) {
        let i = Math.round(a._as.e.measureText(b).width);
        let j = this._d(a);
        return new Size(1, i, j);
      }
    }
    let k = false;
    let l = a._as.f;
    if (l == null) {
      a._as.f = l = this._m(a);
      k = true;
    }
    l.innerText = b;
    l.style.maxWidth = Size.l_op_Inequality_Lifted(c, Nullable$1.toNullable(Size.$, null)) ? c.value.width + "px" : "none";
    if (k) {
      this._k().appendChild(l);
    }
    let m = window.getComputedStyle(l);
    let n = HtmlTextMetricsProvider._i(m.width);
    let o = HtmlTextMetricsProvider._i(m.height);
    return new Size(1, n, o);
  }
  static _i(a) {
    return parseFloat(stringReplace(a, "px", ""));
  }
  _n() {
    let a = document.createElement("span");
    a.style.border = "0px none";
    a.style.margin = "0px";
    a.style.padding = "0px";
    a.style.lineHeight = "normal";
    a.style.position = "relative";
    a.style.display = "block";
    a.style.visibility = "hidden";
    a.style.whiteSpace = "pre";
    a.style.textDecoration = "none";
    a.style.fontWeight = "normal";
    a.style.fontStyle = "normal";
    a.style.maxWidth = "none";
    return a;
  }
  _m(a) {
    let b = document.createElement("span");
    let c = a._b8;
    b.style.border = "0px none";
    b.style.margin = "0px";
    b.style.padding = "0px";
    b.style.lineHeight = "normal";
    b.style.position = "relative";
    b.style.display = "block";
    b.style.visibility = "hidden";
    b.style.fontFamily = a._df;
    b.style.fontSize = ((intDivide(a._cq, 20)) + "pt");
    b.style.whiteSpace = (c ? "pre-wrap" : "pre");
    b.style.overflowWrap = (c ? "break-word" : "normal");
    b.style.wordWrap = (c ? "break-word" : "normal");
    b.style.textDecoration = (a._a1 != 0 ? "underline" : "none");
    b.style.fontWeight = (nullableEquals(a._c2, true) ? "bold" : "normal");
    b.style.fontStyle = (nullableEquals(a._c3, true) ? "italic" : "normal");
    return b;
  }
}
HtmlTextMetricsProvider.$t = markType(HtmlTextMetricsProvider, 'HtmlTextMetricsProvider', TextMetricsProviderBase.$);
/**
 * Abstract base class for [[WorkbookLoadOptions]] or [[WorkbookSaveOptions]].
 */
export class WorkbookOptionsBase extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._b = null;
    this._c = a;
  }
  static staticInit() {
  }
  /**
   * @hidden
   */
  get _c() {
    return this._a;
  }
  /**
   * @hidden
   */
  set _c(a) {
    if (this._a == a) {
      return;
    }
    this._a = a;
    this._b = null;
  }
  /**
   * @hidden
   */
  get _d() {
    if (this._b == null) {
      this._b = this._c;
      if (this._b == null && WorkbookOptionsBase._e != null) {
        this._b = WorkbookOptionsBase._e();
      }
    }
    return this._b;
  }
}
WorkbookOptionsBase.$t = markType(WorkbookOptionsBase, 'WorkbookOptionsBase');
/**
 * @hidden
 */
WorkbookOptionsBase._e = null;
/**
 * #elif WINRT#elif TINYCLR
 * Contains the options related to loading a workbook from a file or stream.
 * @see [[Workbook.load]]
 */
export class WorkbookLoadOptions extends WorkbookOptionsBase {
  constructor() {
    super(null);
    this._g = true;
    this._h = true;
    this._n = null;
    this._culture$i_1 = null;
  }
  /**
   * @hidden
   */
  _f() {
    return null;
  }
  /**
   * @hidden
   */
  get _j() {
    return false;
  }
  /**
   * Returns or sets a boolean indicating whether the Workbook will automatically call its [[Workbook.resumeCalculations]] methods before the Load method returns.
   * When the Load method starts the [[Workbook.suspendCalculations]] is invoked so that no
   * calculations occurs as the load is in progress. When the Load operation is complete and the Workbook
   * is about to be returned from the Load method, it will call the [[Workbook.resumeCalculations]]
   * method to ensure that the loaded formulas have been added to the calculation network and the formulas
   * can be calculated. However if one wanted to delay calling that method, perhaps to add additional formulas
   * to the workbook being loaded, one can set this property to false and then the Workbook will not call
   * ResumeCalculations. Instead it will be the responsibility of the caller to invoke this method.
   * @see [[Workbook.suspendCalculations]]
   * @see [[Workbook.resumeCalculations]]
   */
  get autoResumeCalculations() {
    return this._g;
  }
  /**
   * Returns or sets a boolean indicating whether the Workbook will automatically call its [[Workbook.resumeCalculations]] methods before the Load method returns.
   * When the Load method starts the [[Workbook.suspendCalculations]] is invoked so that no
   * calculations occurs as the load is in progress. When the Load operation is complete and the Workbook
   * is about to be returned from the Load method, it will call the [[Workbook.resumeCalculations]]
   * method to ensure that the loaded formulas have been added to the calculation network and the formulas
   * can be calculated. However if one wanted to delay calling that method, perhaps to add additional formulas
   * to the workbook being loaded, one can set this property to false and then the Workbook will not call
   * ResumeCalculations. Instead it will be the responsibility of the caller to invoke this method.
   * @see [[Workbook.suspendCalculations]]
   * @see [[Workbook.resumeCalculations]]
   */
  set autoResumeCalculations(a) {
    this._g = a;
  }
  /**
   * Returns or sets the value for the [[Workbook.culture]] property.
   * @see [[Workbook.culture]]
   */
  get culture() {
    return (((t) => t == null ? null : t.name)(this._culture$i));
  }
  /**
   * Returns or sets the value for the [[Workbook.culture]] property.
   * @see [[Workbook.culture]]
   */
  set culture(a) {
    arguments[0] = typeof arguments[0] === 'string' ? new CultureInfo(arguments[0]) : arguments[0];
    this._culture$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _culture$i() {
    return this._culture$i_1;
  }
  /**
   * @hidden
   */
  set _culture$i(a) {
    this._culture$i_1 = a;
  }
  /**
   * @hidden
   */
  get _k() {
    return (this._n != null && this._n.count > 0);
  }
  /**
   * Returns or sets a boolean indicating whether duplicate formulas parsed during the load will be optimized for faster loading of the workbook.
   * <p class="body">
   * By default when an exact duplicate of a formula string is encountered during the load, the previously parsed formula
   * will be cloned rather than reparsing the string to create an entirely new formula.
   * </p>
   * <p class="note"><b>Note:</b> This property does not apply to the loading of the xls formats.</p>
   */
  get isDuplicateFormulaParsingOptimized() {
    return this._h;
  }
  /**
   * Returns or sets a boolean indicating whether duplicate formulas parsed during the load will be optimized for faster loading of the workbook.
   * <p class="body">
   * By default when an exact duplicate of a formula string is encountered during the load, the previously parsed formula
   * will be cloned rather than reparsing the string to create an entirely new formula.
   * </p>
   * <p class="note"><b>Note:</b> This property does not apply to the loading of the xls formats.</p>
   */
  set isDuplicateFormulaParsingOptimized(a) {
    this._h = a;
  }
  /**
   * Returns a list of user defined functions that should be registered before the workbook is loaded.
   */
  get userDefinedFunctions() {
    if (this._n == null) {
      this._n = new List$1(ExcelCalcFunction.$, 0);
    }
    return this._n;
  }
}
WorkbookLoadOptions.$t = markType(WorkbookLoadOptions, 'WorkbookLoadOptions', WorkbookOptionsBase.$);
/**
 * Represents a range of cells in a worksheet that may be edited by the end user.
 */
export class WorksheetProtectedRange extends Base {
  constructor(title) {
    super();
    this._a = null;
    this._k = null;
    this._d = null;
    this._g = false;
    this._l = null;
    this._f = null;
    /**
     * @hidden
     */
    this._c = null;
    this.title = title;
    this._f = new WorksheetProtectedRangeRegionCollection(this);
    this._c = new WorkbookPasswordInfo(null);
  }
  /**
   * @hidden
   */
  _b() {
    return this._a;
  }
  /**
   * @hidden
   */
  _m() {
    return this._k;
  }
  /**
   * @hidden
   */
  _o(a) {
    this._a = a;
  }
  /**
   * @hidden
   */
  _p(a) {
    this._k = a;
  }
  /**
   * Returns true if the range has a password associated with it.
   */
  get hasPassword() {
    return this._c.f;
  }
  /**
   * Returns a boolean indicating if the range is currently locked.
   * <p class="body">When the associated Worksheet is protected, the ranges with a password
   * will be marked as protected until they are unprotected.</p>
   */
  get isProtected() {
    return this._g;
  }
  /**
   * Returns a boolean indicating if the range is currently locked.
   * <p class="body">When the associated Worksheet is protected, the ranges with a password
   * will be marked as protected until they are unprotected.</p>
   */
  set isProtected(a) {
    this._g = a;
  }
  /**
   * Returns a collection of ranges that may be edited when the worksheet is protected.
   */
  get ranges() {
    return this._f;
  }
  /**
   * Returns or sets the name of the range.
   */
  get title() {
    return this._l;
  }
  /**
   * Returns or sets the name of the range.
   */
  set title(a) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentNullException_WorksheetProtectedRangeTitleCantBeNull"));
    }
    if (a != this._l) {
      if (a.length > 255) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_WorksheetProtectedRangeTitleTooLong"));
      }
      if (this._d != null) {
        let b = this._d.protection._allowedEditRanges$i._b(a);
        if (b != null && b != this) {
          throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DuplicateWorksheetProtectedRangeTitle", a));
        }
      }
      this._l = a;
    }
  }
  /**
   * Returns the worksheet with which the edit range is associated.
   */
  get worksheet() {
    return this._d;
  }
  /**
   * Returns the worksheet with which the edit range is associated.
   */
  set worksheet(a) {
    this._d = a;
  }
  /**
   * Removes the password from the range.
   * <p class="note"><b>Note:</b> If the range is not currently protected (i.e. [[isProtected]] returns
   * false) the method will not do anything.</p>
   * @see [[isProtected]]
   * @see [[hasPassword]]
   */
  unprotect() {
    if (this._c.f == false) {
      this._c.l();
      this.isProtected = false;
    }
  }
}
WorksheetProtectedRange.$t = markType(WorksheetProtectedRange, 'WorksheetProtectedRange');
/**
 * @hidden
 */
export class MathUtilities extends Base {
  static get l() {
    return Thread.currentThread.currentCulture;
  }
  static q(a, b) {
    return MathUtilities.r(a, b);
  }
  static r(a, b) {
    let c = b.name;
    if (c != MathUtilities.p) {
      MathUtilities.p = c;
      MathUtilities.n = new Intl.NumberFormat(c, { useGrouping: false, minimumSignificantDigits: 1 });
    }
    return (MathUtilities.n.format(a));
  }
  static b(a, b, c) {
    if (true) {
      if (((() => { let d = tryParseNumber1(a, 511 & ~8, b, c); c = d.p3; return d.ret; })()) == false) {
        return {
          ret: false,
          p2: c
        };
      }
      return {
        ret: ((() => { let d = MathUtilities.e(Number_$type, a, b, c); c = d.p2; return d.ret; })()),
        p2: c
      };
    }
  }
  static c(a, b, c) {
    if (true) {
      if (((() => { let d = MathUtilities.d(a, c); c = d.p1; return d.ret; })())) {
        return {
          ret: true,
          p2: c
        };
      }
      if (((() => { let d = tryParseNumber1(a, 511 & ~8, b, c); c = d.p3; return d.ret; })()) == false) {
        return {
          ret: false,
          p2: c
        };
      }
      return {
        ret: ((() => { let d = MathUtilities.e(Number_$type, a, b, c); c = d.p2; return d.ret; })()),
        p2: c
      };
    }
  }
  static d(a, b) {
    b = 0;
    let c = a.length;
    if (c == 0) {
      return {
        ret: false,
        p1: b
      };
    }
    for (let d = 0; d < c; d++) {
      let e = a.charAt(d);
      if (e.charCodeAt(0) < '0'.charCodeAt(0) || '9'.charCodeAt(0) < e.charCodeAt(0)) {
        return {
          ret: false,
          p1: b
        };
      }
      b *= 10;
      b += e.charCodeAt(0) - '0'.charCodeAt(0);
    }
    return {
      ret: true,
      p1: b
    };
  }
  static e($t, a, b, c) {
    a = a.trim();
    let d = typeCast(CultureInfo.$, b);
    let e;
    if (d != null) {
      e = d.compareInfo;
    }
    else {
      e = MathUtilities.l.compareInfo;
    }
    let f = b.getFormat(NumberFormatInfo.$) || MathUtilities.l.numberFormat;
    let g = a;
    let h = e.indexOf3(a, f.numberDecimalSeparator, 1);
    if (0 <= h) {
      g = a.substr(0, h);
    }
    else {
      let i = e.indexOf3(a, "E", 1);
      if (0 <= i) {
        g = a.substr(0, i);
      }
    }
    for (let j = g.length - 1; j >= 0; j--) {
      let k = false;
      if (e.compare1(g, j, f.numberGroupSeparator.length, f.numberGroupSeparator, 0, f.numberGroupSeparator.length, 1) == 0) {
        k = true;
      }
      else {
        let l = g.charAt(j);
        if (isDigit(l)) {
          k = true;
        }
      }
      if (k) {
        g = g.substr(0, j + 1);
        break;
      }
    }
    let m = stringSplit(g, [f.numberGroupSeparator], 0);
    let n = f.numberGroupSizes[0];
    for (let o = 1; o < m.length; o++) {
      if (m[o].length < n) {
        c = Type.getDefaultValue($t);
        return {
          ret: false,
          p2: c
        };
      }
    }
    return {
      ret: true,
      p2: c
    };
  }
  static m(a) {
    let b = 0;
    if (a < 1) {
      while (0 < a && a < 1) {
        a *= 10;
        b--;
      }
    }
    else {
      while (10 <= a) {
        a /= 10;
        b++;
      }
    }
    return b;
  }
  static o(a) {
    return MathUtilities.g(a, 0);
  }
  static f(a) {
    return MathUtilities.g(a, 0);
  }
  static g(a, b) {
    return MathUtilities.h(a, b, true);
  }
  static h(a, b, c) {
    if (isNaN_(a) || isInfinity(a)) {
      return a;
    }
    let d;
    if (b < 0) {
      d = 1 / Math.pow(10, -b);
    }
    else if (b > 25) {
      d = parseFloat("1e" + b);
    }
    else if (b > 15) {
      d = Math.pow(10, b);
    }
    else {
      d = MathUtilities.a[b];
    }
    let e = Math.sign(a);
    let f = a * d;
    if (c) {
      f = MathUtilities.i(f);
    }
    let g = f % 1;
    f = MathUtilities.j(f);
    if (Math.abs(g) >= 0.5) {
      f += Math.sign(g);
    }
    return f / d;
  }
  static i(a) {
    if (a == 0) {
      return a;
    }
    let b = 14 - MathUtilities.m(Math.abs(a));
    if (b > 0) {
      return MathUtilities.h(a, b, false);
    }
    return a;
  }
  static j(a) {
    return SilverlightFixes.g(a);
  }
  static k(a, b) {
    if (isNaN_(a) || isInfinity(a)) {
      return a;
    }
    let c;
    if (b < 0 || b > 15) {
      c = Math.pow(10, b);
    }
    else {
      c = MathUtilities.a[b];
    }
    let d = Math.sign(a);
    let e = a * c;
    e = MathUtilities.j(e);
    return e / c;
  }
}
MathUtilities.$t = markType(MathUtilities, 'MathUtilities');
MathUtilities.p = null;
MathUtilities.n = null;
MathUtilities.a = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1E+15];
/**
 * Abstract base class for the fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillPattern]]
 * @see [[CellFillGradient]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export class CellFill extends Base {
  static createLinearGradientFill() {
    let n;
    if (arguments.length === 3) {
      if (typeof arguments[1] === 'string' || typeCast(Color.$, arguments[1]) !== null) {
        n = 2;
      }
      else if (typeCast(CellFillGradientStop.$, arguments[1]) !== null) {
        n = 0;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[1]) !== null) {
        n = 1;
      }
      else if (arguments[1] == null) {
        if (typeof arguments[2] === 'string' || typeCast(Color.$, arguments[2]) !== null) {
          n = 2;
        }
        else if (typeCast(CellFillGradientStop.$, arguments[2]) !== null) {
          n = 0;
        }
        else if (typeCast(WorkbookColorInfo.$, arguments[2]) !== null) {
          n = 1;
        }
        else if (arguments[2] == null) {
          n = 1;
        }
      }
    }
    else {
      n = 0;
    }
    switch (n) {
      case 0: return CellFill._createLinearGradientFill.apply(null, arguments);
      case 1: return CellFill._createLinearGradientFill1.apply(null, arguments);
      case 2:
        arguments[1] = Color.create(arguments[1]);
        arguments[2] = Color.create(arguments[2]);
        return CellFill._createLinearGradientFill2.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _createLinearGradientFill2(a, b, c) {
    return CellFill._createLinearGradientFill1(a, CellFill._p(b), CellFill._p(c));
  }
  /**
   * @hidden
   */
  static _createLinearGradientFill1(a, b, c) {
    return CellFill._createLinearGradientFill(a, new CellFillGradientStop(b, 0), new CellFillGradientStop(c, 1));
  }
  /**
   * @hidden
   */
  static _createLinearGradientFill(a, ...b) {
    return new CellFillLinearGradient(a, ...b);
  }
  static createPatternFill() {
    let n;
    if (arguments.length === 3) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        if (typeof arguments[1] === 'string' || typeCast(Color.$, arguments[1]) !== null) {
          n = 1;
        }
        else if (typeCast(WorkbookColorInfo.$, arguments[1]) !== null) {
          n = 0;
        }
        else if (arguments[1] == null) {
          n = 0;
        }
      }
    }
    switch (n) {
      case 0: return CellFill._createPatternFill.apply(null, arguments);
      case 1:
        arguments[0] = Color.create(arguments[0]);
        arguments[1] = Color.create(arguments[1]);
        return CellFill._createPatternFill1.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _createPatternFill1(a, b, c) {
    return CellFill._createPatternFill(new WorkbookColorInfo(a), new WorkbookColorInfo(b), c);
  }
  /**
   * @hidden
   */
  static _createPatternFill(a, b, c) {
    return new CellFillPattern(a, b, c);
  }
  static createRectangularGradientFill() {
    let n;
    if (arguments.length === 2) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        n = 4;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        if (typeof arguments[1] === 'string' || typeCast(Color.$, arguments[1]) !== null) {
          n = 4;
        }
        else if (typeCast(WorkbookColorInfo.$, arguments[1]) !== null) {
          n = 0;
        }
        else if (arguments[1] == null) {
          n = 0;
        }
      }
    }
    else if (arguments.length === 6) {
      if (typeof arguments[4] === 'string' || typeCast(Color.$, arguments[4]) !== null) {
        n = 3;
      }
      else if (typeCast(CellFillGradientStop.$, arguments[4]) !== null) {
        n = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[4]) !== null) {
        n = 2;
      }
      else if (arguments[4] == null) {
        if (typeof arguments[5] === 'string' || typeCast(Color.$, arguments[5]) !== null) {
          n = 3;
        }
        else if (typeCast(CellFillGradientStop.$, arguments[5]) !== null) {
          n = 1;
        }
        else if (typeCast(WorkbookColorInfo.$, arguments[5]) !== null) {
          n = 2;
        }
        else if (arguments[5] == null) {
          n = 2;
        }
      }
    }
    else {
      n = 1;
    }
    switch (n) {
      case 0: return CellFill._createRectangularGradientFill.apply(null, arguments);
      case 1: return CellFill._createRectangularGradientFill1.apply(null, arguments);
      case 2: return CellFill._createRectangularGradientFill2.apply(null, arguments);
      case 3:
        arguments[4] = Color.create(arguments[4]);
        arguments[5] = Color.create(arguments[5]);
        return CellFill._createRectangularGradientFill3.apply(null, arguments);
      case 4:
        arguments[0] = Color.create(arguments[0]);
        arguments[1] = Color.create(arguments[1]);
        return CellFill._createRectangularGradientFill4.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _createRectangularGradientFill4(a, b) {
    return CellFill._createRectangularGradientFill3(0.5, 0.5, 0.5, 0.5, a, b);
  }
  /**
   * @hidden
   */
  static _createRectangularGradientFill3(a, b, c, d, e, f) {
    return CellFill._createRectangularGradientFill2(a, b, c, d, CellFill._p(e), CellFill._p(f));
  }
  /**
   * @hidden
   */
  static _createRectangularGradientFill(a, b) {
    return CellFill._createRectangularGradientFill2(0.5, 0.5, 0.5, 0.5, a, b);
  }
  /**
   * @hidden
   */
  static _createRectangularGradientFill2(a, b, c, d, e, f) {
    return CellFill._createRectangularGradientFill1(a, b, c, d, new CellFillGradientStop(e, 0), new CellFillGradientStop(f, 1));
  }
  /**
   * @hidden
   */
  static _createRectangularGradientFill1(a, b, c, d, ...e) {
    return new CellFillRectangularGradient(a, b, c, d, ...e);
  }
  static createSolidFill() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return CellFill._createSolidFill.apply(null, arguments);
      case 1:
        arguments[0] = Color.create(arguments[0]);
        return CellFill._createSolidFill1.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _createSolidFill1(a) {
    return CellFill._createSolidFill(new WorkbookColorInfo(a));
  }
  /**
   * @hidden
   */
  static _createSolidFill(a) {
    return new CellFillPattern(a, null, 1);
  }
  /**
   * @hidden
   */
  static _q(a) {
    if (a.isAutomatic) {
      a = new WorkbookColorInfo(Nullable$1.toNullable(Color.$, ExcelUtils.gx(ExcelUtils.cx(a._color$i.value))), a._themeColorType$i, a._tint$i, false, true);
    }
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  static _p(a) {
    return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, a), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, true);
  }
  /**
   * Gets the default cell fill, which is no background color.
   */
  static get noColor() {
    if (CellFill._a == null) {
      CellFill._a = new CellFillPattern(null, WorkbookColorInfo.automatic, 0);
    }
    return CellFill._a;
  }
}
CellFill.$t = markType(CellFill, 'CellFill');
/**
 * @hidden
 */
CellFill._a = null;
/**
 * An immutable object which represents a solid or pattern fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export class CellFillPattern extends CellFill {
  constructor(..._rest) {
    super();
    this._v = null;
    this._w = null;
    this._t = 0;
    let a;
    if (arguments.length === 3) {
      a = 0;
    }
    else if (arguments.length === 4) {
      if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeof arguments[0] === 'number') {
        a = 4;
      }
      else if (arguments[0] == null) {
        a = 1;
      }
    }
    else if (arguments.length === 5) {
      if (typeCast(Boolean_$type, arguments[3]) !== null) {
        a = 3;
      }
      else if (typeCast(WorksheetCellFormatData.$, arguments[3]) !== null) {
        a = 2;
      }
      else if (arguments[3] == null) {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          let backgroundColorInfo = _rest[0];
          let patternColorInfo = _rest[1];
          let patternStyle = _rest[2];
          let b = [backgroundColorInfo, patternColorInfo, patternStyle, null];
          {
            let backgroundColorInfo = b[0];
            let patternColorInfo = b[1];
            let patternStyle = b[2];
            let owningFormat = b[3];
            let c = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat, false];
            {
              let backgroundColorInfo = c[0];
              let patternColorInfo = c[1];
              let patternStyle = c[2];
              let owningFormat = c[3];
              let isCreatedInternally = c[4];
              let d = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat != null && owningFormat._b9, isCreatedInternally];
              {
                let backgroundColorInfo = d[0];
                let patternColorInfo = d[1];
                let patternStyle = d[2];
                let doesReverseColorsForSolidFill = d[3];
                let isCreatedInternally = d[4];
                if (patternStyle == 1 && doesReverseColorsForSolidFill) {
                  let e = ExcelUtils.gb(WorkbookColorInfo.$, backgroundColorInfo, patternColorInfo);
                  backgroundColorInfo = e.p0;
                  patternColorInfo = e.p1;
                }
                ExcelUtils.gm(FillPatternStyle_$type, patternStyle, "patternStyle");
                if (ExcelUtils.az(patternStyle)) {
                  throw new InvalidEnumArgumentException(ExcelUtils.ef("LE_InvalidEnumArgumentException_DefaultPatternCannotBeUsed"), null);
                }
                if (WorkbookColorInfo.l_op_Equality(backgroundColorInfo, null)) {
                  backgroundColorInfo = new WorkbookColorInfo(SystemColorsInternal.bb);
                }
                if (isCreatedInternally == false) {
                  let f = CellFill._q(backgroundColorInfo);
                  backgroundColorInfo = f.p0;
                }
                if (WorkbookColorInfo.l_op_Equality(patternColorInfo, null)) {
                  patternColorInfo = WorkbookColorInfo.automatic;
                }
                this._v = backgroundColorInfo;
                this._t = patternStyle;
                this._w = patternColorInfo;
              }
            }
          }
        }
        break;
      case 1:
        {
          let backgroundColorInfo = _rest[0];
          let patternColorInfo = _rest[1];
          let patternStyle = _rest[2];
          let owningFormat = _rest[3];
          let b = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat, false];
          {
            let backgroundColorInfo = b[0];
            let patternColorInfo = b[1];
            let patternStyle = b[2];
            let owningFormat = b[3];
            let isCreatedInternally = b[4];
            let c = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat != null && owningFormat._b9, isCreatedInternally];
            {
              let backgroundColorInfo = c[0];
              let patternColorInfo = c[1];
              let patternStyle = c[2];
              let doesReverseColorsForSolidFill = c[3];
              let isCreatedInternally = c[4];
              if (patternStyle == 1 && doesReverseColorsForSolidFill) {
                let d = ExcelUtils.gb(WorkbookColorInfo.$, backgroundColorInfo, patternColorInfo);
                backgroundColorInfo = d.p0;
                patternColorInfo = d.p1;
              }
              ExcelUtils.gm(FillPatternStyle_$type, patternStyle, "patternStyle");
              if (ExcelUtils.az(patternStyle)) {
                throw new InvalidEnumArgumentException(ExcelUtils.ef("LE_InvalidEnumArgumentException_DefaultPatternCannotBeUsed"), null);
              }
              if (WorkbookColorInfo.l_op_Equality(backgroundColorInfo, null)) {
                backgroundColorInfo = new WorkbookColorInfo(SystemColorsInternal.bb);
              }
              if (isCreatedInternally == false) {
                let e = CellFill._q(backgroundColorInfo);
                backgroundColorInfo = e.p0;
              }
              if (WorkbookColorInfo.l_op_Equality(patternColorInfo, null)) {
                patternColorInfo = WorkbookColorInfo.automatic;
              }
              this._v = backgroundColorInfo;
              this._t = patternStyle;
              this._w = patternColorInfo;
            }
          }
        }
        break;
      case 2:
        {
          let backgroundColorInfo = _rest[0];
          let patternColorInfo = _rest[1];
          let patternStyle = _rest[2];
          let owningFormat = _rest[3];
          let isCreatedInternally = _rest[4];
          let b = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat != null && owningFormat._b9, isCreatedInternally];
          {
            let backgroundColorInfo = b[0];
            let patternColorInfo = b[1];
            let patternStyle = b[2];
            let doesReverseColorsForSolidFill = b[3];
            let isCreatedInternally = b[4];
            if (patternStyle == 1 && doesReverseColorsForSolidFill) {
              let c = ExcelUtils.gb(WorkbookColorInfo.$, backgroundColorInfo, patternColorInfo);
              backgroundColorInfo = c.p0;
              patternColorInfo = c.p1;
            }
            ExcelUtils.gm(FillPatternStyle_$type, patternStyle, "patternStyle");
            if (ExcelUtils.az(patternStyle)) {
              throw new InvalidEnumArgumentException(ExcelUtils.ef("LE_InvalidEnumArgumentException_DefaultPatternCannotBeUsed"), null);
            }
            if (WorkbookColorInfo.l_op_Equality(backgroundColorInfo, null)) {
              backgroundColorInfo = new WorkbookColorInfo(SystemColorsInternal.bb);
            }
            if (isCreatedInternally == false) {
              let d = CellFill._q(backgroundColorInfo);
              backgroundColorInfo = d.p0;
            }
            if (WorkbookColorInfo.l_op_Equality(patternColorInfo, null)) {
              patternColorInfo = WorkbookColorInfo.automatic;
            }
            this._v = backgroundColorInfo;
            this._t = patternStyle;
            this._w = patternColorInfo;
          }
        }
        break;
      case 3:
        {
          let backgroundColorInfo = _rest[0];
          let patternColorInfo = _rest[1];
          let patternStyle = _rest[2];
          let doesReverseColorsForSolidFill = _rest[3];
          let isCreatedInternally = _rest[4];
          if (patternStyle == 1 && doesReverseColorsForSolidFill) {
            let b = ExcelUtils.gb(WorkbookColorInfo.$, backgroundColorInfo, patternColorInfo);
            backgroundColorInfo = b.p0;
            patternColorInfo = b.p1;
          }
          ExcelUtils.gm(FillPatternStyle_$type, patternStyle, "patternStyle");
          if (ExcelUtils.az(patternStyle)) {
            throw new InvalidEnumArgumentException(ExcelUtils.ef("LE_InvalidEnumArgumentException_DefaultPatternCannotBeUsed"), null);
          }
          if (WorkbookColorInfo.l_op_Equality(backgroundColorInfo, null)) {
            backgroundColorInfo = new WorkbookColorInfo(SystemColorsInternal.bb);
          }
          if (isCreatedInternally == false) {
            let c = CellFill._q(backgroundColorInfo);
            backgroundColorInfo = c.p0;
          }
          if (WorkbookColorInfo.l_op_Equality(patternColorInfo, null)) {
            patternColorInfo = WorkbookColorInfo.automatic;
          }
          this._v = backgroundColorInfo;
          this._t = patternStyle;
          this._w = patternColorInfo;
        }
        break;
      case 4:
        {
          let backgroundColorIndex = _rest[0];
          let foregroundColorIndex = _rest[1];
          let patternStyle = _rest[2];
          let owningFormat = _rest[3];
          let b = [new WorkbookColorInfo(owningFormat.v, backgroundColorIndex), new WorkbookColorInfo(owningFormat.v, foregroundColorIndex), patternStyle, owningFormat, true];
          {
            let backgroundColorInfo = b[0];
            let patternColorInfo = b[1];
            let patternStyle = b[2];
            let owningFormat = b[3];
            let isCreatedInternally = b[4];
            let c = [backgroundColorInfo, patternColorInfo, patternStyle, owningFormat != null && owningFormat._b9, isCreatedInternally];
            {
              let backgroundColorInfo = c[0];
              let patternColorInfo = c[1];
              let patternStyle = c[2];
              let doesReverseColorsForSolidFill = c[3];
              let isCreatedInternally = c[4];
              if (patternStyle == 1 && doesReverseColorsForSolidFill) {
                let d = ExcelUtils.gb(WorkbookColorInfo.$, backgroundColorInfo, patternColorInfo);
                backgroundColorInfo = d.p0;
                patternColorInfo = d.p1;
              }
              ExcelUtils.gm(FillPatternStyle_$type, patternStyle, "patternStyle");
              if (ExcelUtils.az(patternStyle)) {
                throw new InvalidEnumArgumentException(ExcelUtils.ef("LE_InvalidEnumArgumentException_DefaultPatternCannotBeUsed"), null);
              }
              if (WorkbookColorInfo.l_op_Equality(backgroundColorInfo, null)) {
                backgroundColorInfo = new WorkbookColorInfo(SystemColorsInternal.bb);
              }
              if (isCreatedInternally == false) {
                let e = CellFill._q(backgroundColorInfo);
                backgroundColorInfo = e.p0;
              }
              if (WorkbookColorInfo.l_op_Equality(patternColorInfo, null)) {
                patternColorInfo = WorkbookColorInfo.automatic;
              }
              this._v = backgroundColorInfo;
              this._t = patternStyle;
              this._w = patternColorInfo;
            }
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Determines whether the [[CellFillPattern]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CellFillPattern.$, obj);
    if (a == null) {
      return false;
    }
    if (this._t != a._t) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._v, a._v)) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._w, a._w)) {
      return false;
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CellFillPattern]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    let a = this._v.getHashCode();
    a ^= this._w.getHashCode();
    a ^= this._t;
    return a;
  }
  /**
   * @hidden
   */
  _r(a, b) {
    let c = this._y(a);
    let d = this._aa(a);
    switch (this.patternStyle) {
      case 0: break;
      case 1:
        b.add(new ExtPropColor(d, 4));
        a._dw(c, 5, b);
        break;
      default:
        b.add(new ExtPropColor(c, 5));
        a._dw(d, 4, b);
        break;
    }
  }
  /**
   * @hidden
   */
  _s(a, b) {
    b.add(new XFPropFillPattern(this.patternStyle));
    if (a._b1 == 2) {
      b.add(new XFPropColor(1, this._aa(a)));
      b.add(new XFPropColor(2, this._y(a)));
    }
    else {
      let c = this._y(a);
      let d = this._aa(a);
      switch (this.patternStyle) {
        case 0: break;
        case 1:
          b.add(new XFPropColor(1, d));
          a._dx(c, 2, b);
          break;
        default:
          b.add(new XFPropColor(2, c));
          a._dx(d, 1, b);
          break;
      }
    }
  }
  /**
   * @hidden
   */
  _c(a) {
    if (this._v._n && this._w._n) {
      return this;
    }
    let b = this._v;
    if (WorkbookColorInfo.l_op_Inequality(b, null) && b.isAutomatic) {
      b = new WorkbookColorInfo(SystemColorsInternal.bb);
    }
    return new CellFillPattern(b._g(a), this._w._g(a), this._t, null, true);
  }
  /**
   * @hidden
   */
  _y(a) {
    return this._z(a._b9);
  }
  /**
   * @hidden
   */
  _z(a) {
    if (a && this._t == 1) {
      return this._w;
    }
    return this._v;
  }
  /**
   * @hidden
   */
  _aa(a) {
    return this._ab(a._b9);
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a && this._t == 1) {
      return this._v;
    }
    return this._w;
  }
  /**
   * Gets the [[WorkbookColorInfo]] which describes the background color of the cell, which will only be seen if the
   * [[patternStyle]] is not None.
   */
  get backgroundColorInfo() {
    return this._v;
  }
  /**
   * Gets the fill pattern for the cell.
   */
  get patternStyle() {
    return this._t;
  }
  /**
   * Gets the [[WorkbookColorInfo]] which describes the pattern color of the cell, which will only be seen if the
   * [[patternStyle]] is not None or Solid.
   */
  get patternColorInfo() {
    return this._w;
  }
}
CellFillPattern.$t = markType(CellFillPattern, 'CellFillPattern', CellFill.$);
/**
 * Abstract base class for a gradient fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export class CellFillGradient extends CellFill {
  constructor(a) {
    super();
    this._v = null;
    if (a == null || a.length < 2) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_LessThanTwoGradientStops"), "stops");
    }
    this._v = new ReadOnlyCollection$1(CellFillGradientStop.$, 1, boxArray$1(a));
  }
  /**
   * Determines whether the [[CellFillGradient]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    let a = typeCast(CellFillGradient.$, obj);
    if (a == null) {
      return false;
    }
    if (this._v.count != a._v.count) {
      return false;
    }
    for (let b = 0; b < this._v.count; b++) {
      if (this._v.item(b).equals(a._v.item(b)) == false) {
        return false;
      }
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CellFillGradient]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return this._v.count ^ this._v.item(0).getHashCode() ^ this._v.item(this._v.count - 1).getHashCode();
  }
  /**
   * @hidden
   */
  _r(a, b) {
    b.add(new ExtPropGradientFill(this));
  }
  /**
   * @hidden
   */
  _t(a, b) {
    let c = new Array(this.stops.count);
    b = true;
    for (let d = 0; d < this.stops.count; d++) {
      let e = this.stops.item(d);
      c[d] = e._a(a);
      b = e.colorInfo._n && b;
    }
    return {
      ret: c,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _w(a) {
    for (let b = 0; b < this.stops.count; b++) {
      let c = this.stops.item(b);
      a.add(new XFPropGradientStop(c.colorInfo, c.offset));
    }
  }
  /**
   * Gets the read-only collection of gradient stops which describe the color transitions and their positions within the gradient.
   */
  get stops() {
    return this._v;
  }
}
CellFillGradient.$t = markType(CellFillGradient, 'CellFillGradient', CellFill.$);
/**
 * An immutable object which represents a linear gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export class CellFillLinearGradient extends CellFillGradient {
  constructor(angle, ...stops) {
    super(stops);
    this._x = 0;
    this._x = angle;
  }
  /**
   * Determines whether the [[CellFillLinearGradient]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CellFillLinearGradient.$, obj);
    if (a == null) {
      return false;
    }
    if (this._x != a._x) {
      return false;
    }
    if (super.equals(a) == false) {
      return false;
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CellFillLinearGradient]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return (this._x) ^ super.getHashCode();
  }
  /**
   * @hidden
   */
  _s(a, b) {
    b.add(new XFPropGradientFill(false, this.angle, 0, 0, 0, 0));
    this._w(b);
  }
  /**
   * @hidden
   */
  _c(a) {
    let b;
    let c = ((() => { let d = this._t(a, b); b = d.p1; return d.ret; })());
    if (b) {
      return this;
    }
    return new CellFillLinearGradient(this._x, ...c);
  }
  /**
   * Gets the angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
   */
  get angle() {
    return this._x;
  }
}
CellFillLinearGradient.$t = markType(CellFillLinearGradient, 'CellFillLinearGradient', CellFillGradient.$);
/**
 * An immutable object which represents a rectangular gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export class CellFillRectangularGradient extends CellFillGradient {
  constructor(left, top, right, bottom, ...stops) {
    super(stops);
    this._x = 0;
    this._y = 0;
    this._z = 0;
    this._aa = 0;
    CellFillRectangularGradient._af(left, "left");
    CellFillRectangularGradient._af(top, "top");
    CellFillRectangularGradient._af(right, "right");
    CellFillRectangularGradient._af(bottom, "bottom");
    this._x = bottom;
    this._y = left;
    this._z = right;
    this._aa = top;
  }
  /**
   * Determines whether the [[CellFillRectangularGradient]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CellFillRectangularGradient.$, obj);
    if (a == null) {
      return false;
    }
    if (this._x != a._x) {
      return false;
    }
    if (this._y != a._y) {
      return false;
    }
    if (this._z != a._z) {
      return false;
    }
    if (this._aa != a._aa) {
      return false;
    }
    if (super.equals(a) == false) {
      return false;
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CellFillRectangularGradient]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return (this._x) ^ (this._y) ^ (this._z) ^ (this._aa) ^ super.getHashCode();
  }
  /**
   * @hidden
   */
  _s(a, b) {
    b.add(new XFPropGradientFill(true, 0, this.left, this.right, this.top, this.bottom));
    this._w(b);
  }
  /**
   * @hidden
   */
  _c(a) {
    let b;
    let c = ((() => { let d = this._t(a, b); b = d.p1; return d.ret; })());
    if (b) {
      return this;
    }
    return new CellFillRectangularGradient(this._y, this._aa, this._z, this._x, ...c);
  }
  /**
   * @hidden
   */
  static _af(a, b) {
    if (a < 0 || 1 < a) {
      throw ExcelUtils.x(b, a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidRelativeRectangleValueForGradient"));
    }
  }
  /**
   * Gets the bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
   */
  get bottom() {
    return this._x;
  }
  /**
   * Gets the left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
   */
  get left() {
    return this._y;
  }
  /**
   * Gets the right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
   */
  get right() {
    return this._z;
  }
  /**
   * Gets the top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
   */
  get top() {
    return this._aa;
  }
}
CellFillRectangularGradient.$t = markType(CellFillRectangularGradient, 'CellFillRectangularGradient', CellFillGradient.$);
/**
 * Immutable class which describes a color transition in a cell fill gradient.
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export class CellFillGradientStop extends Base {
  constructor(..._rest) {
    super();
    this._b = null;
    this._e = 0;
    let a;
    if (arguments.length === 2) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        a = 0;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (arguments[0] == null) {
        a = 1;
      }
    }
    switch (a) {
      case 0:
        {
          let color = _rest[0];
          let offset = _rest[1];
          let b = [new WorkbookColorInfo(color), offset];
          {
            let colorInfo = b[0];
            let offset = b[1];
            if (colorInfo._p) {
              throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidGradientStopColor"), "colorInfo");
            }
            if (offset < 0 || 1 < offset) {
              throw ExcelUtils.x("offset", offset, ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidGradientStopOffset"));
            }
            let c = CellFill._q(colorInfo);
            colorInfo = c.p0;
            this._b = colorInfo;
            this._e = offset;
          }
          color = Color.create(color);
        }
        break;
      case 1:
        {
          let colorInfo = _rest[0];
          let offset = _rest[1];
          if (colorInfo._p) {
            throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidGradientStopColor"), "colorInfo");
          }
          if (offset < 0 || 1 < offset) {
            throw ExcelUtils.x("offset", offset, ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidGradientStopOffset"));
          }
          let b = CellFill._q(colorInfo);
          colorInfo = b.p0;
          this._b = colorInfo;
          this._e = offset;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Determines whether the [[CellFillGradientStop]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CellFillGradientStop.$, obj);
    if (a == null) {
      return false;
    }
    if (this._e != a._e) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._b, a._b)) {
      return false;
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CellFillGradientStop]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return this._b.getHashCode() ^ (this._e);
  }
  /**
   * @hidden
   */
  _a(a) {
    if (this._b._n) {
      return this;
    }
    return new CellFillGradientStop(this._b._g(a, false), this._e);
  }
  /**
   * Gets the [[WorkbookColorInfo]] describing the color transition for the gradient stop.
   * @see [[offset]]
   */
  get colorInfo() {
    return this._b;
  }
  /**
   * Gets the position in the gradient of the color transition for the gradient stop, ranging from 0.0 to 1.0.
   * <p class="body">
   * When used in a [[CellFillLinearGradient]], a value of 0.0 is at the beginning of the gradient and 1.0 is at the end of the
   * gradient. When used in a [[CellFillRectangularGradient]], a value of 0.0 is at the inner rectangle and 1.0 is at the outer
   * edges of the cell.
   * </p>
   * @see [[colorInfo]]
   */
  get offset() {
    return this._e;
  }
}
CellFillGradientStop.$t = markType(CellFillGradientStop, 'CellFillGradientStop');
/**
 * An immutable object which represents a color in a Microsoft Excel workbook.
 * @see [[IWorksheetCellFormat.bottomBorderColorInfo]]
 * @see [[IWorksheetCellFormat.diagonalBorderColorInfo]]
 * @see [[IWorksheetCellFormat.leftBorderColorInfo]]
 * @see [[IWorksheetCellFormat.rightBorderColorInfo]]
 * @see [[IWorksheetCellFormat.topBorderColorInfo]]
 * @see [[IWorkbookFont.colorInfo]]
 * @see [[CellFillPattern.backgroundColorInfo]]
 * @see [[CellFillPattern.patternColorInfo]]
 * @see [[CellFillGradientStop.colorInfo]]
 */
export class WorkbookColorInfo extends Base {
  constructor(..._rest) {
    super();
    this._ag = new Color();
    this._i = 0;
    this._v = 0;
    this._w = 0;
    this._j = null;
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeof arguments[0] === 'number') {
        a = 4;
      }
      else if (arguments[0] == null) {
        a = 1;
      }
    }
    else if (arguments.length === 2) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        if (typeCast(WorkbookColorTransform.$, arguments[1]) !== null) {
          a = 3;
        }
        else if (typeof arguments[1] === 'number') {
          a = 2;
        }
        else if (arguments[1] == null) {
          a = 3;
        }
      }
      else if (typeCast(Workbook.$, arguments[0]) !== null) {
        a = 9;
      }
      else if (typeof arguments[0] === 'number') {
        if (typeCast(WorkbookColorTransform.$, arguments[1]) !== null) {
          a = 6;
        }
        else if (typeof arguments[1] === 'number') {
          a = 5;
        }
        else if (arguments[1] == null) {
          a = 6;
        }
      }
      else if (arguments[0] == null) {
        if (typeCast(WorkbookColorTransform.$, arguments[1]) !== null) {
          a = 3;
        }
        else if (typeof arguments[1] === 'number') {
          a = 9;
        }
        else if (arguments[1] == null) {
          a = 3;
        }
      }
    }
    else if (arguments.length === 4) {
      a = 7;
    }
    else if (arguments.length === 5) {
      if (typeCast(Boolean_$type, arguments[3]) !== null) {
        a = 7;
      }
      else if (typeCast(WorkbookColorTransform.$, arguments[3]) !== null) {
        a = 8;
      }
      else if (arguments[3] == null) {
        a = 8;
      }
    }
    else if (arguments.length === 6) {
      a = 8;
    }
    switch (a) {
      case 0:
        {
          this._i = 1;
        }
        break;
      case 1:
        {
          let color = _rest[0];
          let b = [Nullable$1.toNullable(Color.$, color), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let isLoading = b[3];
            let preventUsingAutomaticColor = b[4];
            let c = [color, themeColorType, tint, null, isLoading, preventUsingAutomaticColor];
            {
              let color = c[0];
              let themeColorType = c[1];
              let tint = c[2];
              let transform = c[3];
              let isLoading = c[4];
              let preventUsingAutomaticColor = c[5];
              if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
                this._i = 1;
                return;
              }
              if (color.hasValue) {
                this._i = 2;
                this._ag = color.value;
                WorkbookColorInfo._ad(this._ag);
              }
              if (themeColorType.hasValue) {
                this._i = 4;
                WorkbookColorInfo._ae(themeColorType.value);
                this._v = themeColorType.value;
              }
              if (tint.hasValue) {
                this._i |= 8;
                this._w = tint.value;
                let d = WorkbookColorInfo._af(this._w, isLoading);
                this._w = d.p0;
              }
              if (transform != null) {
                this._i |= 16;
                this._j = transform;
              }
            }
          }
          color = Color.create(color);
        }
        break;
      case 2:
        {
          let color = _rest[0];
          let tint = _rest[1];
          let b = [Nullable$1.toNullable(Color.$, color), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, tint), false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let isLoading = b[3];
            let preventUsingAutomaticColor = b[4];
            let c = [color, themeColorType, tint, null, isLoading, preventUsingAutomaticColor];
            {
              let color = c[0];
              let themeColorType = c[1];
              let tint = c[2];
              let transform = c[3];
              let isLoading = c[4];
              let preventUsingAutomaticColor = c[5];
              if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
                this._i = 1;
                return;
              }
              if (color.hasValue) {
                this._i = 2;
                this._ag = color.value;
                WorkbookColorInfo._ad(this._ag);
              }
              if (themeColorType.hasValue) {
                this._i = 4;
                WorkbookColorInfo._ae(themeColorType.value);
                this._v = themeColorType.value;
              }
              if (tint.hasValue) {
                this._i |= 8;
                this._w = tint.value;
                let d = WorkbookColorInfo._af(this._w, isLoading);
                this._w = d.p0;
              }
              if (transform != null) {
                this._i |= 16;
                this._j = transform;
              }
            }
          }
          color = Color.create(color);
        }
        break;
      case 3:
        {
          let color = _rest[0];
          let transform = _rest[1];
          let b = [Nullable$1.toNullable(Color.$, ExcelUtils.g2(color)), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), transform, false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let transform = b[3];
            let isLoading = b[4];
            let preventUsingAutomaticColor = b[5];
            if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
              this._i = 1;
              return;
            }
            if (color.hasValue) {
              this._i = 2;
              this._ag = color.value;
              WorkbookColorInfo._ad(this._ag);
            }
            if (themeColorType.hasValue) {
              this._i = 4;
              WorkbookColorInfo._ae(themeColorType.value);
              this._v = themeColorType.value;
            }
            if (tint.hasValue) {
              this._i |= 8;
              this._w = tint.value;
              let c = WorkbookColorInfo._af(this._w, isLoading);
              this._w = c.p0;
            }
            if (transform != null) {
              this._i |= 16;
              this._j = transform;
            }
          }
          color = Color.create(color);
        }
        break;
      case 4:
        {
          let themeColorType = _rest[0];
          let b = [Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, themeColorType), Nullable$1.toNullable(Number_$type, null), null, false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let transform = b[3];
            let isLoading = b[4];
            let preventUsingAutomaticColor = b[5];
            if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
              this._i = 1;
              return;
            }
            if (color.hasValue) {
              this._i = 2;
              this._ag = color.value;
              WorkbookColorInfo._ad(this._ag);
            }
            if (themeColorType.hasValue) {
              this._i = 4;
              WorkbookColorInfo._ae(themeColorType.value);
              this._v = themeColorType.value;
            }
            if (tint.hasValue) {
              this._i |= 8;
              this._w = tint.value;
              let c = WorkbookColorInfo._af(this._w, isLoading);
              this._w = c.p0;
            }
            if (transform != null) {
              this._i |= 16;
              this._j = transform;
            }
          }
        }
        break;
      case 5:
        {
          let themeColorType = _rest[0];
          let tint = _rest[1];
          let b = [Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, themeColorType), Nullable$1.toNullable(Number_$type, tint), null, false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let transform = b[3];
            let isLoading = b[4];
            let preventUsingAutomaticColor = b[5];
            if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
              this._i = 1;
              return;
            }
            if (color.hasValue) {
              this._i = 2;
              this._ag = color.value;
              WorkbookColorInfo._ad(this._ag);
            }
            if (themeColorType.hasValue) {
              this._i = 4;
              WorkbookColorInfo._ae(themeColorType.value);
              this._v = themeColorType.value;
            }
            if (tint.hasValue) {
              this._i |= 8;
              this._w = tint.value;
              let c = WorkbookColorInfo._af(this._w, isLoading);
              this._w = c.p0;
            }
            if (transform != null) {
              this._i |= 16;
              this._j = transform;
            }
          }
        }
        break;
      case 6:
        {
          let themeColorType = _rest[0];
          let transform = _rest[1];
          let b = [Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, themeColorType), Nullable$1.toNullable(Number_$type, null), transform, false, false];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let transform = b[3];
            let isLoading = b[4];
            let preventUsingAutomaticColor = b[5];
            if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
              this._i = 1;
              return;
            }
            if (color.hasValue) {
              this._i = 2;
              this._ag = color.value;
              WorkbookColorInfo._ad(this._ag);
            }
            if (themeColorType.hasValue) {
              this._i = 4;
              WorkbookColorInfo._ae(themeColorType.value);
              this._v = themeColorType.value;
            }
            if (tint.hasValue) {
              this._i |= 8;
              this._w = tint.value;
              let c = WorkbookColorInfo._af(this._w, isLoading);
              this._w = c.p0;
            }
            if (transform != null) {
              this._i |= 16;
              this._j = transform;
            }
          }
        }
        break;
      case 7:
        {
          let color = _rest[0];
          let themeColorType = _rest[1];
          let tint = _rest[2];
          let isLoading = _rest[3];
          let preventUsingAutomaticColor = _rest[4];
          let b = [color, themeColorType, tint, null, isLoading, preventUsingAutomaticColor];
          {
            let color = b[0];
            let themeColorType = b[1];
            let tint = b[2];
            let transform = b[3];
            let isLoading = b[4];
            let preventUsingAutomaticColor = b[5];
            if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
              this._i = 1;
              return;
            }
            if (color.hasValue) {
              this._i = 2;
              this._ag = color.value;
              WorkbookColorInfo._ad(this._ag);
            }
            if (themeColorType.hasValue) {
              this._i = 4;
              WorkbookColorInfo._ae(themeColorType.value);
              this._v = themeColorType.value;
            }
            if (tint.hasValue) {
              this._i |= 8;
              this._w = tint.value;
              let c = WorkbookColorInfo._af(this._w, isLoading);
              this._w = c.p0;
            }
            if (transform != null) {
              this._i |= 16;
              this._j = transform;
            }
          }
        }
        break;
      case 8:
        {
          let color = _rest[0];
          let themeColorType = _rest[1];
          let tint = _rest[2];
          let transform = _rest[3];
          let isLoading = _rest[4];
          let preventUsingAutomaticColor = _rest[5];
          if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
            this._i = 1;
            return;
          }
          if (color.hasValue) {
            this._i = 2;
            this._ag = color.value;
            WorkbookColorInfo._ad(this._ag);
          }
          if (themeColorType.hasValue) {
            this._i = 4;
            WorkbookColorInfo._ae(themeColorType.value);
            this._v = themeColorType.value;
          }
          if (tint.hasValue) {
            this._i |= 8;
            this._w = tint.value;
            let b = WorkbookColorInfo._af(this._w, isLoading);
            this._w = b.p0;
          }
          if (transform != null) {
            this._i |= 16;
            this._j = transform;
          }
        }
        break;
      case 9:
        {
          let workbook = _rest[0];
          let index = _rest[1];
          let b = [workbook._palette$i._ae(index)];
          {
            let color = b[0];
            let c = [Nullable$1.toNullable(Color.$, color), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, false];
            {
              let color = c[0];
              let themeColorType = c[1];
              let tint = c[2];
              let isLoading = c[3];
              let preventUsingAutomaticColor = c[4];
              let d = [color, themeColorType, tint, null, isLoading, preventUsingAutomaticColor];
              {
                let color = d[0];
                let themeColorType = d[1];
                let tint = d[2];
                let transform = d[3];
                let isLoading = d[4];
                let preventUsingAutomaticColor = d[5];
                if (preventUsingAutomaticColor == false && Color.c(color, Nullable$1.toNullable(Color.$, SystemColorsInternal.bg)) && nullableEquals(themeColorType, null) && nullableEquals(tint, null)) {
                  this._i = 1;
                  return;
                }
                if (color.hasValue) {
                  this._i = 2;
                  this._ag = color.value;
                  WorkbookColorInfo._ad(this._ag);
                }
                if (themeColorType.hasValue) {
                  this._i = 4;
                  WorkbookColorInfo._ae(themeColorType.value);
                  this._v = themeColorType.value;
                }
                if (tint.hasValue) {
                  this._i |= 8;
                  this._w = tint.value;
                  let e = WorkbookColorInfo._af(this._w, isLoading);
                  this._w = e.p0;
                }
                if (transform != null) {
                  this._i |= 16;
                  this._j = transform;
                }
              }
            }
            color = Color.create(color);
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Determines whether the [[WorkbookColorInfo]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    let a = typeCast(WorkbookColorInfo.$, obj);
    if (WorkbookColorInfo.l_op_Equality(a, null)) {
      return false;
    }
    return WorkbookColorInfo.l_op_Equality(this, a);
  }
  /**
   * Gets the hash code for the [[WorkbookColorInfo]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    let a = 0;
    a ^= this._i;
    a ^= this._ag.getHashCode();
    a ^= this._v;
    a ^= (this._w);
    return a;
  }
  /**
   * Gets the string representation of the [[WorkbookColorInfo]].
   * @return
   */
  toString() {
    if (this.isAutomatic) {
      return ExcelUtils.eg("WorkbookColorInfo_Description", ExcelUtils.ef("WorkbookColorInfo_Automatic_Description"));
    }
    let a;
    if (WorkbookColorInfo._u(this._i, 2)) {
      a = this._ag.toString();
    }
    else if (WorkbookColorInfo._u(this._i, 4)) {
      a = EnumUtil.getName(WorkbookThemeColorType_$type, this._v);
    }
    else {
      return super.toString();
    }
    if (WorkbookColorInfo._u(this._i, 8)) {
      return ExcelUtils.eg("WorkbookColorInfo_WithTint_Description", a, this._w);
    }
    return ExcelUtils.eg("WorkbookColorInfo_Description", a);
  }
  getResolvedColor() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getResolvedColor.apply(this, arguments).colorString;
      case 1: return this._getResolvedColor1.apply(this, arguments).colorString;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getResolvedColor() {
    return this._getResolvedColor1(null);
  }
  /**
   * @hidden
   */
  _getResolvedColor1(a) {
    return ExcelUtils.g1(this._aj(a));
  }
  /**
   * @hidden
   */
  _aj(a, b = true, c = false) {
    if (this.isAutomatic) {
      return SystemColorsInternal.bg;
    }
    let d = new Color();
    if (WorkbookColorInfo._u(this._i, 2)) {
      d = this._ag;
      if (b && d.l != 255) {
        d = Color.u(255, this._ag.o, this._ag.n, this._ag.m);
      }
    }
    else if (WorkbookColorInfo._u(this._i, 4)) {
      if (a == null) {
        if (c) {
          d = Workbook._c()[this._v];
        }
        else {
          throw new ArgumentNullException(2, "workbook", ExcelUtils.ef("LE_ArgumentNullException_WorkbookRequiredToResolveThemeColor"));
        }
      }
      else {
        d = a._h[this._v];
      }
    }
    else {
      return ColorsInternal.c;
    }
    if (WorkbookColorInfo._u(this._i, 8)) {
      return ExcelUtils.g2(ExcelUtils.gu(ExcelUtils.g1(d), this._w));
    }
    if (WorkbookColorInfo._u(this._i, 16) && this._j != null && this._j._b()) {
      if (this._j._luminanceModulation$i.hasValue || this._j._luminanceOffset$i.hasValue) {
        let e, f, g;
        let h = ExcelUtils.e8(ExcelUtils.g1(d), e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        let i = f;
        if (this._j._luminanceModulation$i.hasValue) {
          i *= this._j._luminanceModulation$i.value;
        }
        if (this._j._luminanceOffset$i.hasValue) {
          i += (this._j._luminanceOffset$i.value * 240);
        }
        f = Math.min(truncate(i), 240);
        let j = ExcelUtils.gy(e, f, g);
        d = Color.u(255, j.o, j.n, j.m);
      }
      if (this._j._alpha$i.hasValue) {
        let k = d.l;
        k = truncate(Math.min(k * this._j._alpha$i.value, 255));
        k = Math.max(k, 0);
        d = Color.u(k, d.o, d.n, d.m);
      }
      if (this._j._shade$i.hasValue) {
        let l = ExcelUtils.gs(d.l, d.o, d.n, d.m, this._j._shade$i.value);
        d = Color.u(l.l, l.o, l.n, l.m);
      }
    }
    return d;
  }
  /**
   * @hidden
   */
  _y(a, b) {
    return a._palette$i._l(this, b);
  }
  /**
   * @hidden
   */
  _o(a, b) {
    if (this.isAutomatic) {
      return true;
    }
    if (WorkbookColorInfo._u(this._i, 4) || WorkbookColorInfo._u(this._i, 8)) {
      return false;
    }
    let c = a._palette$i._ae(this._y(a, b));
    return WorkbookColorPalette._e(this._ag, c);
  }
  /**
   * @hidden
   */
  _g(a, b = true) {
    if (this._n && (b || !this._p)) {
      return this;
    }
    let c = this._getResolvedColor1(a);
    if (!b && ExcelUtils.am(c)) {
      c = ExcelUtils.gx(ExcelUtils.cx(c));
    }
    return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, c), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, true);
  }
  /**
   * @hidden
   */
  _h(a) {
    let b;
    if (Color.c(this._color$i, Nullable$1.toNullable(Color.$, null))) {
      b = Nullable$1.toNullable(Color.$, null);
    }
    else {
      b = Nullable$1.toNullable(Color.$, this._ag);
    }
    return new WorkbookColorInfo(b, this._themeColorType$i, this._tint$i, a, false, !this.isAutomatic);
  }
  /**
   * @hidden
   */
  static _u(a, b) {
    return (a & b) == b;
  }
  /**
   * @hidden
   */
  static _ad(a) {
    if (ExcelUtils.al(a)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CannotCreateEmptyColorInfo"), "color");
    }
  }
  /**
   * @hidden
   */
  static _ae(a) {
    ExcelUtils.gm(WorkbookThemeColorType_$type, a, "themeColor");
  }
  /**
   * @hidden
   */
  static _af(a, b) {
    if (a < -1 || 1 < a) {
      if (b) {
        a = a % 2;
        if (a < -1) {
          a += 2;
        }
        else if (1 < a) {
          a -= 2;
        }
      }
      else {
        throw ExcelUtils.x("tint", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidColorInfoTint"));
      }
    }
    return {
      p0: a
    };
  }
  /**
   * Gets the automatic color, which is the window text system color.
   * @see [[isAutomatic]]
   */
  static get automatic() {
    return WorkbookColorInfo._a;
  }
  /**
   * Gets the base color associated of the [[WorkbookColorInfo]].
   * @see [[tint]]
   */
  get color() {
    return getColorStringSafe(unwrapNullable(this._color$i));
  }
  /**
   * @hidden
   */
  get _color$i() {
    if (WorkbookColorInfo._u(this._i, 1)) {
      return Nullable$1.toNullable(Color.$, SystemColorsInternal.bf);
    }
    if (WorkbookColorInfo._u(this._i, 2)) {
      return Nullable$1.toNullable(Color.$, ExcelUtils.g1(this._ag));
    }
    return Nullable$1.toNullable(Color.$, null);
  }
  /**
   * Gets the value which indicates whether the [[WorkbookColorInfo]] is automatic, or the window text system color.
   */
  get isAutomatic() {
    return WorkbookColorInfo._u(this._i, 1);
  }
  /**
   * Gets the base theme color associated of the [[WorkbookColorInfo]].
   * @see [[tint]]
   */
  get themeColorType() {
    return unwrapNullable(this._themeColorType$i);
  }
  /**
   * @hidden
   */
  get _themeColorType$i() {
    if (WorkbookColorInfo._u(this._i, 4)) {
      return Nullable$1.toNullable(WorkbookThemeColorType_$type, this._v);
    }
    return Nullable$1.toNullable(WorkbookThemeColorType_$type, null);
  }
  /**
   * Gets the to apply to the base color, from -1.0 (100% darken) to 1.0 (100% lighten).
   * @see [[color]]
   * @see [[themeColorType]]
   */
  get tint() {
    return unwrapNullable(this._tint$i);
  }
  /**
   * @hidden
   */
  get _tint$i() {
    if (WorkbookColorInfo._u(this._i, 8)) {
      return Nullable$1.toNullable(Number_$type, this._w);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * Returns the associated [[WorkbookColorTransform]], or null
   * if this instance is not associated with a transform.
   */
  get transform() {
    if (WorkbookColorInfo._u(this._i, 16)) {
      return this._j;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _n() {
    return this._i == 2;
  }
  /**
   * @hidden
   */
  get _p() {
    if (this.isAutomatic) {
      return true;
    }
    if (WorkbookColorInfo._u(this._i, 2)) {
      return ExcelUtils.am(this._ag);
    }
    return false;
  }
  /**
   * @hidden
   */
  static l_op_Equality(a, b) {
    if (Base.referenceEquals(a, b)) {
      return true;
    }
    if (null == a || null == b) {
      return false;
    }
    if (a._i != b._i) {
      return false;
    }
    if (a._v != b._v) {
      return false;
    }
    if (a._w != b._w) {
      return false;
    }
    if (WorkbookColorPalette._e(a._ag, b._ag) == false) {
      return false;
    }
    if (WorkbookColorTransform._a(a._j, b._j) == false) {
      return false;
    }
    return true;
  }
  /**
   * @hidden
   */
  static l_op_Inequality(a, b) {
    return !(WorkbookColorInfo.l_op_Equality(a, b));
  }
  /**
   * @hidden
   */
  static l_op_Implicit_WorkbookColorInfo_Color(color) {
    arguments[0] = Color.create(arguments[0]);
    return this._l_op_Implicit_WorkbookColorInfo_Color$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  static _l_op_Implicit_WorkbookColorInfo_Color$i(a) {
    return new WorkbookColorInfo(a);
  }
  /**
   * @hidden
   */
  static l_op_Implicit_WorkbookColorInfo_WorkbookThemeColorType(themeColorType) {
    return new WorkbookColorInfo(themeColorType);
  }
}
WorkbookColorInfo.$t = markType(WorkbookColorInfo, 'WorkbookColorInfo');
/**
 * @hidden
 */
WorkbookColorInfo._a = new WorkbookColorInfo();
/**
 * Defines color transforms for a [[WorkbookColorInfo]] instance.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * Color transforms are not applicable to all contexts within which a WorkbookColorInfo is used;
 * currently they are only used by <see cref="WorksheetChart">charts</see>.
 * </p>
 * @see [[ChartSolidFill]]
 * @see [[GradientStop]]
 * @see [[ChartGradientFill]]
 */
export class WorkbookColorTransform extends Base {
  constructor(alpha, luminanceModulation, luminanceOffset, shade) {
    super();
    this._alpha$i_1 = Nullable$1.toNullable(Number_$type, null);
    this._luminanceModulation$i_1 = Nullable$1.toNullable(Number_$type, null);
    this._luminanceOffset$i_1 = Nullable$1.toNullable(Number_$type, null);
    this._shade$i_1 = Nullable$1.toNullable(Number_$type, null);
    if (alpha !== void 0) {
      alpha = wrapNullable(Number_$type, alpha);
    }
    if (luminanceModulation !== void 0) {
      luminanceModulation = wrapNullable(Number_$type, luminanceModulation);
    }
    if (luminanceOffset !== void 0) {
      luminanceOffset = wrapNullable(Number_$type, luminanceOffset);
    }
    if (shade !== void 0) {
      shade = wrapNullable(Number_$type, shade);
    }
    this._alpha$i = alpha;
    this._luminanceModulation$i = luminanceModulation;
    this._luminanceOffset$i = luminanceOffset;
    this._shade$i = shade;
  }
  /**
   * Defines the value of the alpha channel for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a number between 0 and 1.
   * <p class="body">
   * Use this property to control the transparency of the associated color.
   * </p>
   * <p class="body">
   * For example, to make the associated color 50% transparent, assign a value of <b>.5</b> to this property.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated
   * color has no specific alpha channel setting, i.e., the associated color
   * is fully opaque.
   * </p>
   */
  get alpha() {
    return unwrapNullable(this._alpha$i);
  }
  /**
   * Defines the value of the alpha channel for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a number between 0 and 1.
   * <p class="body">
   * Use this property to control the transparency of the associated color.
   * </p>
   * <p class="body">
   * For example, to make the associated color 50% transparent, assign a value of <b>.5</b> to this property.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated
   * color has no specific alpha channel setting, i.e., the associated color
   * is fully opaque.
   * </p>
   */
  set alpha(a) {
    this._alpha$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _alpha$i() {
    return this._alpha$i_1;
  }
  /**
   * @hidden
   */
  set _alpha$i(a) {
    this._alpha$i_1 = a;
  }
  /**
   * Defines the luminance modulation for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * <p class="body">
   * Luminance is also referred to as brightness.
   * </p>
   * <p class="body">
   * This property specifies the amount by which the luminance of the associated
   * base color is increased. For example, a value of .5 yields a 50% reduction
   * in luminance. A value of 1.0 implies no change in luminance. A value greater
   * than 1.0 implies an increase in luminance; for example, a value of 2.0 doubles
   * the luminance.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated color has no specific luminance modulation.
   * </p>
   * <p class="body">
   * Luminance modulation is applied by converting the base color from RGB to HSL, then
   * multiplying the luminance channel by the value of this property, then converting
   * back to RGB.
   * </p>
   * @see [[luminanceOffset]]
   */
  get luminanceModulation() {
    return unwrapNullable(this._luminanceModulation$i);
  }
  /**
   * Defines the luminance modulation for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * <p class="body">
   * Luminance is also referred to as brightness.
   * </p>
   * <p class="body">
   * This property specifies the amount by which the luminance of the associated
   * base color is increased. For example, a value of .5 yields a 50% reduction
   * in luminance. A value of 1.0 implies no change in luminance. A value greater
   * than 1.0 implies an increase in luminance; for example, a value of 2.0 doubles
   * the luminance.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated color has no specific luminance modulation.
   * </p>
   * <p class="body">
   * Luminance modulation is applied by converting the base color from RGB to HSL, then
   * multiplying the luminance channel by the value of this property, then converting
   * back to RGB.
   * </p>
   * @see [[luminanceOffset]]
   */
  set luminanceModulation(a) {
    this._luminanceModulation$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _luminanceModulation$i() {
    return this._luminanceModulation$i_1;
  }
  /**
   * @hidden
   */
  set _luminanceModulation$i(a) {
    this._luminanceModulation$i_1 = a;
  }
  /**
   * Defines the luminance offset for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * <p class="body">
   * Luminance is also referred to as brightness.
   * </p>
   * <p class="body">
   * The luminance offset is applied by converting the base color from RGB to HSL, then
   * the value of this property to the luminance channel, then converting back to RGB.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated color has no specific luminance offset.
   * </p>
   * @see [[luminanceModulation]]
   */
  get luminanceOffset() {
    return unwrapNullable(this._luminanceOffset$i);
  }
  /**
   * Defines the luminance offset for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * <p class="body">
   * Luminance is also referred to as brightness.
   * </p>
   * <p class="body">
   * The luminance offset is applied by converting the base color from RGB to HSL, then
   * the value of this property to the luminance channel, then converting back to RGB.
   * </p>
   * <p class="body">
   * Assigning a value of null to this property implies that the associated color has no specific luminance offset.
   * </p>
   * @see [[luminanceModulation]]
   */
  set luminanceOffset(a) {
    this._luminanceOffset$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _luminanceOffset$i() {
    return this._luminanceOffset$i_1;
  }
  /**
   * @hidden
   */
  set _luminanceOffset$i(a) {
    this._luminanceOffset$i_1 = a;
  }
  /**
   * Defines the shading for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * @see [[alpha]]
   */
  get shade() {
    return unwrapNullable(this._shade$i);
  }
  /**
   * Defines the shading for the associated
   * [[WorkbookColorInfo]] instance, expressed
   * as a fractional number.
   * @see [[alpha]]
   */
  set shade(a) {
    this._shade$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _shade$i() {
    return this._shade$i_1;
  }
  /**
   * @hidden
   */
  set _shade$i(a) {
    this._shade$i_1 = a;
  }
  /**
   * @hidden
   */
  _b() {
    return this._alpha$i.hasValue || this._luminanceModulation$i.hasValue || this._luminanceOffset$i.hasValue || this._shade$i.hasValue;
  }
  /**
   * @hidden
   */
  static _a(a, b) {
    if (a == null && b == null) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    return nullableEquals(a._alpha$i, b._alpha$i) && nullableEquals(a._luminanceModulation$i, b._luminanceModulation$i) && nullableEquals(a._luminanceOffset$i, b._luminanceOffset$i) && nullableEquals(a._shade$i, b._shade$i);
  }
}
WorkbookColorTransform.$t = markType(WorkbookColorTransform, 'WorkbookColorTransform');
/**
 * @hidden
 */
WorkbookColorTransform._c = 100000;
/**
 * @hidden
 */
export class FormattingRunBase extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.j = 0;
    this.b = a;
    this.j = b;
  }
  a(a, b) {
    let c = b.createRun(this.i);
    c.m(this, a);
    return c;
  }
  e() {
    return this.f(null);
  }
  g(a, b) {
    if (b == null) {
      b = new WorkbookFontProxy(1, new WorkbookFontData(0, a), a != null ? a._av : null);
    }
    return {
      ret: b,
      p1: b
    };
  }
  m(a, b) {
    if (a.h) {
      let c = this.d(b);
      let d = typeCast(WorkbookFontProxy.$, c);
      if (d != null) {
        d._t(a.d(b), false);
      }
      else {
        c.setFontFormatting(a.d(b));
      }
    }
  }
  get k() {
    return this.j;
  }
  set k(a) {
    this.j = a;
  }
  get c() {
    return this.b;
  }
  get_l() {
    let a = this.c.getFormattingRuns(null);
    let b = a.indexOf(this);
    if (b < 0) {
      return stringEmpty();
    }
    let c = this.c.unformattedString;
    if (c == null) {
      return stringEmpty();
    }
    let d = c.toString();
    let e = d.length;
    let f = b < (a.count - 1) ? a._inner[b + 1] : null;
    let g = this.j;
    return f == null ? d.substr(g) : d.substr(g, f.j - g);
  }
  get l() {
    return this.get_l();
  }
}
FormattingRunBase.$t = markType(FormattingRunBase, 'FormattingRunBase');
/**
 * @hidden
 */
export class CellFormattingRunPlaceholder extends FormattingRunBase {
  constructor(a, b) {
    super(new CellFormattingRunPlaceholder_RunOwner(a), 0);
    this.n = null;
    this.n = b;
  }
  get_i() {
    return 0;
  }
  set_i(a) {
  }
  get i() {
    return this.get_i();
  }
  set i(a) {
    this.set_i(a);
  }
  d(a) {
    return this.n;
  }
  f(a) {
    return null;
  }
  get_h() {
    return true;
  }
  get h() {
    return this.get_h();
  }
  m(a, b) {
  }
  get_l() {
    let a = this.c.getFormattingRuns(null);
    if (a.count == 0) {
      return this.c.unformattedString;
    }
    return this.c.unformattedString.substr(0, a._inner[0].k);
  }
}
CellFormattingRunPlaceholder.$t = markType(CellFormattingRunPlaceholder, 'CellFormattingRunPlaceholder', FormattingRunBase.$);
/**
 * @hidden
 */
export let IFormattedRunOwner_$type = new Type(null, 'IFormattedRunOwner');
/**
 * @hidden
 */
export class CellFormattingRunPlaceholder_RunOwner extends Base {
  constructor(a) {
    super();
    this.a = null;
    this.a = a;
  }
  addRun(a) {
  }
  createRun(a) {
    return new FormattedStringRun(typeCast(FormattedStringElement.$, this.a), a);
  }
  getFormattingRuns(a) {
    let b = typeCast(FormattedStringElement.$, this.a);
    if (b == null) {
      return new List$1(FormattingRunBase.$, 0);
    }
    return b._ah;
  }
  insertRun(a, b) {
  }
  get startIndex() {
    return 0;
  }
  get unformattedString() {
    return this.a._y;
  }
}
CellFormattingRunPlaceholder_RunOwner.$t = markType(CellFormattingRunPlaceholder_RunOwner, 'CellFormattingRunPlaceholder_RunOwner', Base.$, [IFormattedRunOwner_$type]);
/**
 * @hidden
 */
export let ICellShiftOperationOverride_$type = new Type(null, 'ICellShiftOperationOverride');
/**
 * @hidden
 */
export class CellShiftOperation extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.j = new WorksheetRegionAddress();
    this.n = false;
    this.v = 0;
    this.a = 0;
    this.m = null;
    this.g = null;
    this.u = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          let j = [c, d, null, e, f, g, h, i, false];
          {
            let l = j[0];
            let m = j[1];
            let n = j[2];
            let o = j[3];
            let p = j[4];
            let q = j[5];
            let r = j[6];
            let s = j[7];
            let t = j[8];
            this.a = m;
            this.j = new WorksheetRegionAddress(1, o, p, q, r);
            this.n = t;
            this.v = s;
            this.m = n;
            this.g = l;
            this.u = new List$1(WorksheetRegion.$, 0);
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          let j = _rest[7];
          let k = _rest[8];
          this.a = d;
          this.j = new WorksheetRegionAddress(1, f, g, h, i);
          this.n = k;
          this.v = j;
          this.m = e;
          this.g = c;
          this.u = new List$1(WorksheetRegion.$, 0);
        }
        break;
    }
  }
  i(a) {
    switch (this.a) {
      case 1: return a;
      case 2:
        if (this.j._g(a)) {
          if (this.v <= 0) {
            let b = this.j._ae + this.v - 1;
            if (b <= a.o) {
              let c = a.o - b;
              return new WorksheetCellAddress(1, this.j._ac + c, a.m);
            }
          }
          else {
            let d = this.j._ac + this.v - 1;
            if (a.o <= d) {
              let e = d - a.o;
              return new WorksheetCellAddress(1, this.j._ae - e, a.m);
            }
          }
          return new WorksheetCellAddress(1, a.o + this.v, a.m);
        }
        break;
      case 0:
        {
          if (this.k._g(a)) {
            return new WorksheetCellAddress(1, a.o, (a.m - this.v));
          }
        }
        break;
      case 3:
        {
          if (this.k._g(a)) {
            return new WorksheetCellAddress(1, a.o - this.v, a.m);
          }
        }
        break;
      default: break;
    }
    return a;
  }
  z(a, b, c, d) {
    this.ac(a, b, c, d, null, null, false);
  }
  ab(a, b, c) {
    this.ac(a, null, null, c, b, null, false);
  }
  aa(a, b, c, d) {
    this.ac(a, b, null, -1, null, c, d);
  }
  ac(a, b, c, d, e, f, g) {
    let h = b == null ? false : b._hasCellFormat;
    let i = g;
    let j = null;
    if (0 <= d) {
      if (c != null && c.index == d) {
        j = c;
        i = j._hasCellFormat;
      }
      else {
        j = a._rows$i.item(d);
        i = j._hasCellFormat;
      }
    }
    if (b != null) {
      for (let k of fromEnum(b._ch(this.j._w, this.j._x, true))) {
        if (k.d != null) {
          this.ae(k.r, k.r, b, k.d, j, e, f);
        }
        if (h == false && i == false && k.n) {
          this.ad(k.r, k.r, b, j, e, f);
        }
      }
    }
    else if (e != null) {
      for (let l of fromEnum(e.keys)) {
        this.ae(l, l, b, null, j, e, f);
        this.ad(l, l, b, j, e, f);
      }
    }
    if (h || i) {
      for (let m = this.j._w; m <= this.j._x; m++) {
        this.ad(m, m, b, j, e, f);
      }
    }
  }
  ad(a, b, c, d, e, f) {
    let g;
    if (c != null) {
      g = c._bc(a);
    }
    else if (e != null) {
      let h;
      if (((() => { let i = e.tryGetValue(a, h); h = i.p1; return i.ret; })()) == false) {
        return;
      }
      g = h.e;
    }
    else {
      return;
    }
    let i = typeCast(WorksheetCellFormatProxy.$, g);
    let j = 16 | 1 | 2;
    if (d != null) {
      if (d == c) {
        if (g != null) {
          d._bc(b)._setFormatting1(g, j);
        }
        else {
          d._bc(b)._ar(j);
        }
        if (c == d && c._hasCellFormat) {
          c._bc(a)._setFormatting1(c._cellFormatInternal, j);
        }
        else {
          c._bc(a)._ar(j);
        }
        return;
      }
      else if (g != null) {
        d._bc(b)._setFormatting1(g, j);
      }
    }
    else if (f != null) {
      let k = i != null ? i.d._bu() : g;
      let l;
      let m;
      if (((() => { let n = f.tryGetValue(a, m); m = n.p1; return n.ret; })())) {
        l = Tuple.b(Base.$, Boolean_$type, IWorksheetCellFormat_$type, m.c, m.d, k);
      }
      else {
        l = Tuple.b(Base.$, Boolean_$type, IWorksheetCellFormat_$type, null, false, k);
      }
      f.item(a, l);
    }
    else {
      return;
    }
    if (i != null) {
      i._ar(j);
    }
  }
  ae(a, b, c, d, e, f, g) {
    let h;
    let i;
    if (c != null) {
      if (d == null) {
        return;
      }
      let j;
      let k = new WorksheetCellBlock_CellValue();
      h = ((() => { let l = d.ac(c, a, j, k); j = l.p2; k = l.p3; return l.ret; })());
      i = d.r(a);
      let l;
      let m = d.as(c, a, false, l, false);
      l = m.p3;
      let n = d.ap(c, a, null, h, j, k, l, true);
      l = n.p6;
    }
    else if (f != null) {
      let o;
      if (((() => { let p = f.tryGetValue(a, o); o = p.p1; return p.ret; })()) == false) {
        return;
      }
      h = o.c;
      i = o.d;
    }
    else {
      return;
    }
    if (e != null) {
      let p = e._a1(b);
      let q;
      let r = p.ap(e, b, h, null, 0, new WorksheetCellBlock_CellValue(), q, true);
      q = r.p6;
      if (q != null) {
        p = q;
      }
      let s = p.as(e, b, i, q, false);
      q = s.p3;
    }
    else if (g != null) {
      g.item(b, Tuple.b(Base.$, Boolean_$type, IWorksheetCellFormat_$type, h, i, null));
    }
    else {
      return;
    }
  }
  c(a) {
    let b = a.o;
    let c = a.m;
    let d = ((() => { let e = this.d(b, c); b = e.p0; c = e.p1; return e.ret; })());
    if (d.f) {
      a = new WorksheetCellAddress(1, b, c);
    }
    return {
      ret: d,
      p0: a
    };
  }
  d(a, b) {
    switch (this.a) {
      case 1: return {
        ret: ShiftAddressResult.d,
        p0: a,
        p1: b
      };
      case 2:
        if (this.j._i(a, b)) {
          if (this.v <= 0) {
            let c = this.j._ac - this.v - 1;
            if (a <= c) {
              let d = c - a;
              a = this.j._ae - d;
              return {
                ret: ShiftAddressResult.c,
                p0: a,
                p1: b
              };
            }
          }
          else {
            let e = this.j._ae - this.v + 1;
            if (e <= a) {
              let f = e - a;
              a = this.j._ac + f;
              return {
                ret: ShiftAddressResult.c,
                p0: a,
                p1: b
              };
            }
          }
          a += this.v;
          return {
            ret: ShiftAddressResult.c,
            p0: a,
            p1: b
          };
        }
        break;
      case 0:
        if (this.j._ac <= a && a <= this.j._ae) {
          let g = 0;
          let h = false;
          if (this.j._w <= b && b <= this.j._x) {
            b += this.v;
            h = true;
            if (b < 0) {
              g = 4;
            }
            else if (this.g._columns$i.maxCount <= b) {
              g = 3;
            }
          }
          else {
            if (this.v <= 0) {
              if (this.j._w + this.v <= b && b < this.j._w) {
                h = true;
                if (b + this.v < 0) {
                  g = 4;
                }
                else {
                  g = 2;
                }
              }
            }
            else {
              if (this.j._x < b && b <= this.j._x + this.v) {
                h = true;
                if (this.g._columns$i.maxCount <= b + this.v) {
                  g = 3;
                }
                else {
                  g = 1;
                }
              }
            }
          }
          return {
            ret: new ShiftAddressResult(1, h, g),
            p0: a,
            p1: b
          };
        }
        break;
      case 3:
        if (this.j._w <= b && b <= this.j._x) {
          let i = 0;
          let j = false;
          if (this.j._ac <= a && a <= this.j._ae) {
            a += this.v;
            j = true;
            if (a < 0) {
              i = 4;
            }
            else if (this.g._rows$i.maxCount <= a) {
              i = 3;
            }
          }
          else {
            if (this.v <= 0) {
              if (this.j._ac + this.v <= a && a < this.j._ac) {
                j = true;
                if (a + this.v < 0) {
                  i = 4;
                }
                else {
                  i = 2;
                }
              }
            }
            else {
              if (this.j._ae < a && a <= this.j._ae + this.v) {
                j = true;
                if (this.g._rows$i.maxCount <= a + this.v) {
                  i = 3;
                }
                else {
                  i = 1;
                }
              }
            }
          }
          return {
            ret: new ShiftAddressResult(1, j, i),
            p0: a,
            p1: b
          };
        }
        break;
      default: break;
    }
    return {
      ret: ShiftAddressResult.d,
      p0: a,
      p1: b
    };
  }
  e(a, b) {
    let c;
    let d = ((() => { let e = this.f(a, b, false, c); a = e.p0; c = e.p3; return e.ret; })());
    return {
      ret: d,
      p0: a
    };
  }
  f(a, b, c, d) {
    d = null;
    switch (this.a) {
      case 1:
        {
          if (c == false && ((() => { let e = this.r(a); a = e.p0; return e.ret; })())) {
            return {
              ret: ShiftAddressResult.c,
              p0: a,
              p3: d
            };
          }
          return {
            ret: ShiftAddressResult.d,
            p0: a,
            p3: d
          };
        }
      case 2:
        {
          if (c == false && ((() => { let e = this.r(a); a = e.p0; return e.ret; })())) {
            return {
              ret: ShiftAddressResult.c,
              p0: a,
              p3: d
            };
          }
          if (this.j._j(a) == false) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
        }
        break;
      case 0:
        if (this.v <= 0) {
          if (this.j._x < a._w) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
        }
        else {
          if (a._x < this.j._w) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
        }
        break;
      case 3:
        if (this.v <= 0) {
          if (this.j._ae < a._ac) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
        }
        else {
          if (a._ae < this.j._ac) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
        }
        break;
      default: break;
    }
    if (this.a == 0) {
      if (this.j._ac <= a._ac && a._ae <= this.j._ae) {
        let e = 0;
        let f = false;
        let g = a._w;
        if (this.j._w <= a._w && a._w <= this.j._x) {
          if (a._w == 0 && a._x == this.g._columns$i.maxCount - 1) {
            return {
              ret: ShiftAddressResult.d,
              p0: a,
              p3: d
            };
          }
          f = true;
          if (this.v > 0 && this.j._x < a._x && a._x <= (this.j._x + this.v)) {
            a = a._e((this.j._x + this.v));
          }
          a = a._c((a._w + this.v));
          if (a._w < 0) {
            e = 4;
          }
          else if (this.g._columns$i.maxCount <= a._w) {
            e = 3;
          }
        }
        else if (this.v > 0 && this.j._x < a._w && a._w <= this.j._x + this.v) {
          f = true;
          a = a._c((this.j._x + this.v + 1));
        }
        let h = b && this.v < 0 && a._x == this.g._columns$i.maxCount - 1;
        if (h == false) {
          if (this.j._w <= a._x && a._x <= this.j._x) {
            f = true;
            if (this.v < 0 && g < this.j._w && (this.j._w + this.v) <= g) {
              a = a._c((this.j._w + this.v));
            }
            a = a._e((a._x + this.v));
          }
          else if (this.v < 0 && this.j._w + this.v <= a._x && a._x < this.j._w) {
            f = true;
            a = a._e((this.j._w + this.v - 1));
          }
        }
        if (a._x < a._w) {
          if (this.v <= 0) {
            if (a._x < 0) {
              e = 4;
            }
            else {
              e = 2;
            }
          }
          else {
            if (this.g._columns$i.maxCount <= a._w) {
              e = 3;
            }
            else {
              e = 1;
            }
          }
        }
        return {
          ret: new ShiftAddressResult(1, f, e),
          p0: a,
          p3: d
        };
      }
      else if (c && this.j._ac <= a._ae && a._ac <= this.j._ae) {
        let i = new WorksheetRegionAddress();
        let j = new WorksheetRegionAddress();
        if (a._ac < this.j._ac) {
          i = new WorksheetRegionAddress(1, a._ac, this.j._ac - 1, a._w, a._x);
          j = new WorksheetRegionAddress(1, this.j._ac, a._ae, a._w, a._x);
        }
        else {
          i = new WorksheetRegionAddress(1, this.j._ae + 1, a._ae, a._w, a._x);
          j = new WorksheetRegionAddress(1, a._ac, this.j._ae, a._w, a._x);
        }
        let k = ((() => { let l = this.f(j, b, c, d); j = l.p0; d = l.p3; return l.ret; })());
        a = i;
        if (k.g == false) {
          if (d == null) {
            d = new List$1(WorksheetRegionAddress.$, 0);
          }
          d.add(j);
        }
        return {
          ret: ShiftAddressResult.c,
          p0: a,
          p3: d
        };
      }
    }
    else {
      if (this.j._w <= a._w && a._x <= this.j._x) {
        switch (this.a) {
          case 2:
            {
              let l = a._ac;
              let m = a._ae;
              let n = a._w;
              let o = a._x;
              let p = ((() => { let q = this.d(l, n); l = q.p0; n = q.p1; return q.ret; })());
              let q = ((() => { let r = this.d(m, o); m = r.p0; o = r.p1; return r.ret; })());
              if (p.f || q.f) {
                if (p.f && q.f) {
                  if (m < l) {
                    if (c) {
                      if (d == null) {
                        d = new List$1(WorksheetRegionAddress.$, 0);
                      }
                      let r = this.v <= 0 ? new WorksheetRegionAddress(1, l, this.j._ae, n, o) : new WorksheetRegionAddress(1, this.j._ac, m, n, o);
                      d.add(r);
                    }
                    if (this.v <= 0) {
                      l = this.j._ac;
                    }
                    else {
                      m = this.j._ae;
                    }
                  }
                }
                else if (c) {
                  let s = new WorksheetRegionAddress();
                  let t = new WorksheetRegionAddress();
                  if (p.f == false) {
                    s = new WorksheetRegionAddress(1, l, this.j._ac, n, o);
                    t = new WorksheetRegionAddress(1, this.j._ac, m, n, o);
                  }
                  else {
                    s = new WorksheetRegionAddress(1, this.j._ae, m, n, o);
                    t = new WorksheetRegionAddress(1, l, this.j._ae, n, o);
                  }
                  let u = ((() => { let v = this.f(t, b, c, d); t = v.p0; d = v.p3; return v.ret; })());
                  a = s;
                  if (u.g == false) {
                    if (d == null) {
                      d = new List$1(WorksheetRegionAddress.$, 0);
                    }
                    d.add(t);
                  }
                  return {
                    ret: ShiftAddressResult.c,
                    p0: a,
                    p3: d
                  };
                }
                a = new WorksheetRegionAddress(1, l, m, n, o);
                return {
                  ret: ShiftAddressResult.c,
                  p0: a,
                  p3: d
                };
              }
            }
            break;
          case 3:
            {
              let v = 0;
              let w = false;
              if (this.j._ac <= a._ac && a._ac <= this.j._ae) {
                if (a._ac == 0 && a._ae == this.g._rows$i.maxCount) {
                  return {
                    ret: ShiftAddressResult.d,
                    p0: a,
                    p3: d
                  };
                }
                w = true;
                if (this.v > 0 && this.j._ae < a._ae && a._ae <= (this.j._ae + this.v)) {
                  a = a._f(this.j._ae + this.v);
                }
                a = a._d(a._ac + this.v);
                if (a._ac < 0) {
                  v = 4;
                }
                else if (this.g._rows$i.maxCount <= a._ac) {
                  v = 3;
                }
              }
              else if (this.v > 0 && this.j._ae < a._ac && a._ac <= this.j._ae + this.v) {
                w = true;
                a = a._d(this.j._ae + this.v + 1);
              }
              let x = b && this.v < 0 && a._ae == this.g._rows$i.maxCount - 1;
              if (x == false) {
                if (this.j._ac <= a._ae && a._ae <= this.j._ae) {
                  if (false == w && this.v < 0 && a._ac < this.j._ac && (this.j._ac + this.v) <= a._ac) {
                    a = a._d(this.j._ac + this.v);
                  }
                  a = a._f(a._ae + this.v);
                  w = true;
                }
                else if (this.v < 0 && this.j._ac + this.v <= a._ae && a._ae < this.j._ac) {
                  w = true;
                  a = a._f(this.j._ac + this.v - 1);
                }
              }
              if (a._ae < a._ac) {
                if (this.v <= 0) {
                  if (a._ae < 0) {
                    v = 4;
                  }
                  else {
                    v = 2;
                  }
                }
                else {
                  if (this.g._rows$i.maxCount <= a._ac) {
                    v = 3;
                  }
                  else {
                    v = 1;
                  }
                }
              }
              return {
                ret: new ShiftAddressResult(1, w, v),
                p0: a,
                p3: d
              };
            }
          default: break;
        }
      }
      else if (c && this.j._w <= a._x && a._w <= this.j._x) {
        let y = new WorksheetRegionAddress();
        let z = new WorksheetRegionAddress();
        if (a._w < this.j._w) {
          y = new WorksheetRegionAddress(1, a._ac, a._ae, a._w, (this.j._w - 1));
          z = new WorksheetRegionAddress(1, a._ac, a._ae, this.j._w, a._x);
        }
        else {
          y = new WorksheetRegionAddress(1, a._ac, a._ae, (this.j._x + 1), a._x);
          z = new WorksheetRegionAddress(1, a._ac, a._ae, a._w, this.j._x);
        }
        let aa = ((() => { let ab = this.f(z, b, c, d); z = ab.p0; d = ab.p3; return ab.ret; })());
        a = y;
        if (aa.g == false) {
          if (d == null) {
            d = new List$1(WorksheetRegionAddress.$, 0);
          }
          d.add(z);
        }
        return {
          ret: ShiftAddressResult.c,
          p0: a,
          p3: d
        };
      }
    }
    return {
      ret: ShiftAddressResult.d,
      p0: a,
      p3: d
    };
  }
  r(a) {
    if (this.m == null) {
      return {
        ret: false,
        p0: a
      };
    }
    if (this.m.d._w <= a._w && a._x <= this.m.d._x) {
      if (a._ac == this.m.c._ac || a._ac == this.m.d._ac) {
        if (a._ae == this.m.c._ae || a._ae == this.m.d._ae) {
          let b = (this.m.b._ae - this.m.d._ae);
          a = new WorksheetRegionAddress(1, a._ac, a._ae + b, a._w, a._x);
          return {
            ret: true,
            p0: a
          };
        }
      }
    }
    return {
      ret: false,
      p0: a
    };
  }
  af(a) {
    switch (this.a) {
      case 1: return;
      case 2:
        {
          let b = new Dictionary$2(Number_$type, Dictionary$2.$.specialize(Number_$type, Tuple$3.$.specialize(Base.$, Boolean_$type, IWorksheetCellFormat_$type)), 0);
          let c;
          let d;
          let e;
          let f;
          let g;
          if (this.v <= 0) {
            c = this.j._ac - this.v;
            d = this.j._ae;
            e = this.j._ac;
            f = c - 1;
            g = true;
          }
          else {
            c = this.j._ac;
            d = this.j._ae - this.v;
            e = d + 1;
            f = this.j._ae;
            g = false;
          }
          for (let h of fromEnum(this.g._rows$i._m(e, f))) {
            let i = h.index;
            let j = this.j._w;
            let k = this.d(i, j);
            i = k.p0;
            j = k.p1;
            let l = this.g._rows$i._aj(i);
            let m = l != null && l._hasCellFormat;
            let n = new Dictionary$2(Number_$type, Tuple$3.$.specialize(Base.$, Boolean_$type, IWorksheetCellFormat_$type), 0);
            this.aa(this.g, h, n, m);
            b.item(h.index, n);
          }
          let o = null;
          for (let p of fromEnum(this.g._rows$i._n(c, d, g))) {
            this.z(this.g, p, o, p.index + this.v);
            o = p;
          }
          for (let q of fromEnum(b)) {
            let r = q.key;
            let s = this.j._w;
            let t = q.value;
            let u = this.d(r, s);
            r = u.p0;
            s = u.p1;
            this.ab(this.g, t, r);
          }
        }
        break;
      case 0:
        {
          if (a != null && a.performsShift) {
            if (a.performShift(this)) {
              break;
            }
          }
          let v = this.k._w - this.l._w;
          let w = v < 0;
          for (let x of fromEnum(this.g._rows$i._m(this.j._ac, this.j._ae))) {
            let y = x._ch(this.j._w, this.j._x, w);
            if (!w) {
              y = Enumerable.n(CellDataContext.$, y);
            }
            for (let z of fromEnum(y)) {
              if (z.d != null) {
                this.ae(z.r, (z.r + v), x, z.d, x, null, null);
              }
              this.ad(z.r, (z.r + v), x, x, null, null);
            }
          }
        }
        break;
      case 3:
        {
          if (a != null && a.performsShift) {
            if (a.performShift(this)) {
              break;
            }
          }
          let aa = this.k._ac < this.l._ac;
          let ab = null;
          for (let ac of fromEnum(this.g._rows$i._n(this.j._ac, this.j._ae, aa))) {
            this.z(this.g, ac, ab, ac.index + this.v);
            ab = ac;
          }
        }
        break;
      default: break;
    }
  }
  s($t, a, b, c, d) {
    switch (this.a) {
      case 1: return this.t($t, c, d);
      case 0:
        {
          if (this.t($t, c, d) == false) {
            return false;
          }
          let e = this.l;
          let f = this.k;
          if (d._x < e._w && d._x < f._w) {
            return true;
          }
          if (e._x < d._w && f._x < d._w) {
            return true;
          }
          if (e._h(d)) {
            if (b != null) {
              b.add(c);
            }
            return true;
          }
          if (a != null && a.shiftsColumns) {
            if (ExcelUtils.as(a, d)) {
              if (b != null) {
                b.add(c);
              }
              return true;
            }
          }
          if (e._j(d) || f._j(d)) {
            return false;
          }
          return true;
        }
      case 2:
      case 3:
        {
          if (this.t($t, c, d) == false) {
            return false;
          }
          let g = this.l;
          let h = this.k;
          if (d._ae < g._ac && d._ae < h._ac) {
            return true;
          }
          if (g._ae < d._ac && h._ae < d._ac) {
            return true;
          }
          let i = typeCast(WorksheetTable.$, c);
          if (i != null && false == i._ct(a)) {
            return false;
          }
          if (g._h(d)) {
            if (this.a == 2) {
              let j = (this.v <= 0) ? g._ac - this.v : g._ae - this.v;
              let k = d._ac < j;
              let l = d._ae < j;
              if (k != l) {
                return false;
              }
            }
            if (b != null) {
              b.add(c);
            }
            return true;
          }
          if (a != null && a.shiftsRows) {
            if (ExcelUtils.as(a, d)) {
              if (b != null) {
                b.add(c);
              }
              return true;
            }
          }
          if (g._j(d) || h._j(d)) {
            return false;
          }
          return true;
        }
      default: return true;
    }
  }
  t($t, a, b) {
    if (this.m != null && this.m.b._j(b)) {
      if (typeCast(ArrayFormula.$, a) !== null && b._m) {
        return true;
      }
      return false;
    }
    return true;
  }
  get x() {
    switch (this.a) {
      case 1:
      case 2: return Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      case 0:
        if (this.v <= 0) {
          return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac, this.j._ae, (this.j._w + this.v), (this.j._w - 1)));
        }
        return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac, this.j._ae, (this.j._x + 1), (this.j._x + this.v)));
      case 3:
        if (this.v <= 0) {
          return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac + this.v, this.j._ac - 1, this.j._w, this.j._x));
        }
        return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ae + 1, this.j._ae + this.v, this.j._w, this.j._x));
      default: return Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
  }
  get y() {
    switch (this.a) {
      case 1:
      case 2: return Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      case 0:
        if (this.v <= 0) {
          return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac, this.j._ae, (this.j._x + this.v + 1), this.j._x));
        }
        return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac, this.j._ae, this.j._w, (this.j._w + this.v - 1)));
      case 3:
        if (this.v <= 0) {
          return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ae + this.v + 1, this.j._ae, this.j._w, this.j._x));
        }
        return Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, this.j._ac, this.j._ac + this.v - 1, this.j._w, this.j._x));
      default: return Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
  }
  get o() {
    switch (this.a) {
      case 1:
      case 0: return false;
      case 2:
      case 3: return true;
      default: return false;
    }
  }
  get k() {
    switch (this.a) {
      case 1:
        if (this.m != null) {
          return this.m.b;
        }
        return this.j;
      case 0: return new WorksheetRegionAddress(1, this.j._ac, this.j._ae, (this.j._w + this.v), (this.j._x + this.v));
      case 2: return this.j;
      case 3: return new WorksheetRegionAddress(1, this.j._ac + this.v, this.j._ae + this.v, this.j._w, this.j._x);
      default: return this.j;
    }
  }
  get l() {
    return this.j;
  }
  get p() {
    return this.a != 2 && this.a != 1 && this.g.workbook._cx;
  }
  get q() {
    return this.n;
  }
  get w() {
    return this.v;
  }
  get b() {
    return this.a;
  }
  get h() {
    return this.g;
  }
}
CellShiftOperation.$t = markStruct(CellShiftOperation, 'CellShiftOperation');
/**
 * @hidden
 */
export class ShiftAddressResult extends Base {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.e = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = [c, 0];
          {
            let f = d[0];
            let g = d[1];
            this.e = f;
            this.a = g;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.e = c;
          this.a = d;
        }
        break;
    }
  }
  get b() {
    return this.a;
  }
  get f() {
    return this.e;
  }
  get g() {
    return this.a != 0;
  }
}
ShiftAddressResult.$t = markType(ShiftAddressResult, 'ShiftAddressResult');
ShiftAddressResult.d = new ShiftAddressResult(0, false);
ShiftAddressResult.c = new ShiftAddressResult(0, true);
/**
 * @hidden
 */
export class SheetChangeInfoContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.b = c;
        }
        break;
    }
  }
  get sheet() {
    return this.b;
  }
  get workbook() {
    return this.b.workbook;
  }
  get c() {
    return typeCast(Worksheet.$, this.b);
  }
  get source() {
    return this.b;
  }
  static a($tSheet, $tValue, a, b, c, d, e = null, f = true, g = true, h = 0) {
    let i = null;
    if (e != null) {
      i = (j, k) => e(j.sheet, k);
    }
    return new ChangeInfo$2(SheetChangeInfoContext.$, $tValue, a, b, (j) => c(j.sheet), (j, k) => d(j.sheet, k), i, f, h, g, null, null);
  }
}
SheetChangeInfoContext.$t = markStruct(SheetChangeInfoContext, 'SheetChangeInfoContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Base class for a sheet in a Microsoft Excel workbook.
 */
export class Sheet extends Base {
  constructor(a, b, c) {
    super();
    this._k = null;
    this._ah = null;
    this._v = false;
    this._q = false;
    this._m = null;
    this._al = 0;
    this._aj = null;
    /**
     * @hidden
     */
    this._h = new SheetChangeInfoContext();
    this._h = new SheetChangeInfoContext(1, this);
    this._k = b;
    this._ah = a;
    this._al = c;
  }
  static staticInit() {
    Sheet._a = Sheet._b();
  }
  /**
   * @hidden
   */
  get _c() {
    if (this.workbook == null) {
      return 1;
    }
    return this.workbook.cellReferenceMode;
  }
  /**
   * @hidden
   */
  get _y() {
    if (this._k == null) {
      return ExcelUtils.cq;
    }
    return this._k._e6;
  }
  /**
   * @hidden
   */
  get _o() {
    if (this._k == null) {
      return 2;
    }
    return this._k.currentFormat;
  }
  /**
   * @hidden
   */
  get _r() {
    return this._q;
  }
  /**
   * @hidden
   */
  set _r(a) {
    this._q = a;
  }
  /**
   * Returns a boolean indicating if the Sheet has been protected with a password.
   * <p class="body">When protecting a Sheet, a password is optional. The HasProtectionPassword will return true if the
   * Sheet is currently protected (see [[isProtected]]) and a password was specified when it was protected.</p>
   * @see [[isProtected]]
   * @see@see [[sheetProtection]]
   * @see [[Worksheet.protect]]
   * @see [[unprotect]]
   */
  get hasProtectionPassword() {
    return this._i._c.f;
  }
  /**
   * @hidden
   */
  get _t() {
    if (this._k == null) {
      return false;
    }
    return this._k._c4;
  }
  /**
   * Returns a boolean indicating if the Worksheet has been protected.
   * <p class="body">The IsProtected property will return true if the Worksheet is currently protected. When a Worksheet is protected
   * only unprotected cells may be edited. In addition, other operations may be limited based on the properties of the
   * [[WorksheetProtection]] which may be accessed using the Protection property.</p>
   * @see [[hasProtectionPassword]]
   * @see [[sheetProtection]]
   * @see [[WorksheetProtection]]
   * @see@see [[Worksheet.protection]]
   * @see [[Chartsheet.protection]]
   * @see [[unprotect]]
   */
  get isProtected() {
    return this._i._c.g;
  }
  /**
   * @hidden
   */
  get _w() {
    return this._v;
  }
  /**
   * @hidden
   */
  set _w(a) {
    let b = Sheet._a[2].g(SheetChangeInfoContext.$, Boolean_$type, this._h, this._v, a);
    this._v = b.p1;
  }
  /**
   * Gets or sets the sheet name.
   * <p class="body">The sheet name is case-insensitively unique in the workbook.</p>
   * <p class="body">
   * The sheet name is shown in the tab for the worksheet. In addition, the worksheet name can be used by formulas
   * from other worksheets to refer to cells in this worksheet.
   * </p>
   * The sheet name.
   * @throws [[ArgumentNullException]] The value assigned is null or empty.
   * @throws [[ArgumentException]] The value assigned contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
   * @throws [[ArgumentException]] The value assigned exceeds 31 characters in length.
   * @throws [[ArgumentException]] The value assigned is being used as the name of another sheet (sheet names are case-insensitively compared).
   */
  get name() {
    return this._ah;
  }
  /**
   * Gets or sets the sheet name.
   * <p class="body">The sheet name is case-insensitively unique in the workbook.</p>
   * <p class="body">
   * The sheet name is shown in the tab for the worksheet. In addition, the worksheet name can be used by formulas
   * from other worksheets to refer to cells in this worksheet.
   * </p>
   * The sheet name.
   * @throws [[ArgumentNullException]] The value assigned is null or empty.
   * @throws [[ArgumentException]] The value assigned contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
   * @throws [[ArgumentException]] The value assigned exceeds 31 characters in length.
   * @throws [[ArgumentException]] The value assigned is being used as the name of another sheet (sheet names are case-insensitively compared).
   */
  set name(a) {
    if (this._ah != a) {
      Sheet._a[0].h(SheetChangeInfoContext.$, String_$type, this._h, a);
    }
  }
  /**
   * @hidden
   */
  _at(a) {
    Worksheet._aw(a, "value");
    if (this._k != null) {
      this._k._jd(this, a, "value");
    }
    let b = this._ah;
    this._ah = a;
    if (this._k != null) {
      this._k._w.aa();
    }
  }
  /**
   * Gets the value which indicates whether this worksheet is selected.
   * <p class="body">
   * If the worksheet has been removed from its parent [[Workbook.worksheets]] collection, this will always return False.
   * </p>
   * The value which indicates whether this worksheet is selected.
   * @see [[WindowOptions]]
   * @see */
  get selected() {
    if (this._k == null) {
      return false;
    }
    return this == this._k.windowOptions.selectedSheet;
  }
  /**
   * @hidden
   */
  get _am() {
    return this._al;
  }
  /**
   * Gets the zero-based index of this sheet in its parent [[Workbook.sheets]] collection.
   * <p class="body">
   * Negative one indicates the sheet has been removed from its parent collection.
   * </p>
   * The zero-based index of this sheet in its parent Sheets collection.
   * @see [[SheetCollection.indexOf]]
   * @see [[moveToSheetIndex]]
   */
  get sheetIndex() {
    if (this.workbook == null) {
      return -1;
    }
    return this.workbook._sheets$i.indexOf(this);
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] to use for the associated sheet's tab in the tab bar of Microsoft Excel.
   * <p class="body">
   * If the tab bar is not visible, this color will not be seen.
   * </p>
   * The WorkbookColorInfo to use for the associated sheet's tab in the tab bar of Microsoft Excel.
   * @see [[WindowOptions.tabBarVisible]]
   */
  get tabColorInfo() {
    return this._m;
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] to use for the associated sheet's tab in the tab bar of Microsoft Excel.
   * <p class="body">
   * If the tab bar is not visible, this color will not be seen.
   * </p>
   * The WorkbookColorInfo to use for the associated sheet's tab in the tab bar of Microsoft Excel.
   * @see [[WindowOptions.tabBarVisible]]
   */
  set tabColorInfo(a) {
    let b = Sheet._a[3].g(SheetChangeInfoContext.$, WorkbookColorInfo.$, this._h, this._m, a);
    this._m = b.p1;
  }
  /**
   * @hidden
   */
  get _ak() {
    return this._aj;
  }
  /**
   * @hidden
   */
  set _ak(a) {
    this._aj = a;
  }
  /**
   * Gets the [[workbook]] that owns the worksheet.
   * The Workbook that owns the worksheet.
   */
  get workbook() {
    return this._k;
  }
  /**
   * @hidden
   */
  get__ag() {
    return -1;
  }
  /**
   * @hidden
   */
  get _ag() {
    return this.get__ag();
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, SheetChangeInfoContext.a(Sheet.$, String_$type, "Name", 65, (b) => b.name, (b, c) => b.name = c, (b, c) => b._at(c)));
    ChangeInfo.f(a, 1, SheetChangeInfoContext.a(Sheet.$, Sheet.$, "IsProtected", 65, (b) => b, (b, c) => {
    }, void 0, false));
    ChangeInfo.f(a, 2, SheetChangeInfoContext.a(Sheet.$, Boolean_$type, "IsTabSelected", 65, (b) => b._w, (b, c) => b._w = c, null, false, false));
    ChangeInfo.f(a, 3, SheetChangeInfoContext.a(Sheet.$, WorkbookColorInfo.$, "TabColorInfo", 65, (b) => b.tabColorInfo, (b, c) => b.tabColorInfo = c, null, true, false));
    return a;
  }
  /**
   * Moves the sheet to a new position in the owning workbook's collections of sheets.
   * @param index The new 0-based index to where the sheet should be moved.
   * @throws [[InvalidOperationException]] The sheet has previously been removed from its workbook.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of sheets in the owning workbook.
   * @see [[Workbook.sheets]]
   * @see [[SheetCollection.indexOf]]
   * @see [[sheetIndex]]
   */
  moveToSheetIndex(index) {
    if (this.workbook == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotMoveDisconnectedWorksheet"));
    }
    if (index < 0 || this.workbook._sheets$i.count <= index) {
      throw new ArgumentOutOfRangeException(1, "index");
    }
    this.workbook._sheets$i._v(this.sheetIndex, index);
  }
  /**
   * @hidden
   */
  _ao(a) {
  }
  /**
   * @hidden
   */
  _ap() {
    Sheet._a[1].e(SheetChangeInfoContext.$, Sheet.$, this._h, this, this);
  }
  /**
   * @hidden
   */
  _aq() {
    this._k = null;
  }
  /**
   * @hidden
   */
  _ar() {
  }
  /**
   * @hidden
   */
  _as(a, b) {
    if (b != 0 && this._w && !this._t) {
      this._w = false;
    }
  }
  /**
   * Removes the Sheet protection.
   * @see [[isProtected]]
   * @see [[hasProtectionPassword]]
   * @see [[Worksheet.protect]]
   */
  unprotect() {
    this._i._c.l();
  }
  /**
   * @hidden
   */
  static _aw(a, b) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, b, ExcelUtils.ef("LE_ArgumentNullException_WorksheetName"));
    }
    if (indexOfAny(a, [':', '\\', '/', '?', '*', '[', ']']) >= 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidWorksheetName"), b);
    }
    if (stringStartsWith(a, "'") || stringEndsWith(a, "'")) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidWorksheetNameStartingQuote"), b);
    }
    if (a.length > 31) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_WorksheetNameTooLong"), b);
    }
  }
  /**
   * @hidden
   */
  _av(a, b) {
  }
}
Sheet.$t = markType(Sheet, 'Sheet', Base.$, [IWorkbookProvider_$type]);
/**
 * @hidden
 */
Sheet._ac = 0;
/**
 * @hidden
 */
Sheet._z = 1;
/**
 * @hidden
 */
Sheet._aa = 2;
/**
 * @hidden
 */
Sheet._af = 3;
/**
 * @hidden
 */
Sheet._ad = 4;
/**
 * @hidden
 */
Sheet._a = null;
/**
 * @hidden
 */
Sheet._ab = 31;
/**
 * @hidden
 */
export let IWorksheetShapeOwner_$type = new Type(null, 'IWorksheetShapeOwner', null, [ISheetProvider_$type]);
/**
 * A sheet in a Mirosoft Excel workbook that displays a single chart.
 */
export class Chartsheet extends Sheet {
  constructor(a, b, c) {
    super(a, b, c);
    this._a6 = null;
    this._be = null;
    this._az = null;
    this._a1 = null;
    this._a3 = null;
    this._ba = null;
    /**
     * @hidden
     */
    this._a7 = null;
    this._a3 = new ChartsheetProtection(this);
    this._a6 = new WorksheetShapeCollection(this);
    if (!b._c4) {
      this._a6._addChart2(51, new Rect(0, 0, 0, 13650, 9915), null);
    }
  }
  static staticInit() {
    Chartsheet._ax = Chartsheet._ay();
  }
  /**
   * @hidden
   */
  _d(a) {
    return new CustomViewChartDisplayOptions(this, a);
  }
  /**
   * @hidden
   */
  _f() {
    return new ChartsheetPrintOptions(this, true);
  }
  /**
   * @hidden
   */
  get__e() {
    return this.displayOptions;
  }
  /**
   * @hidden
   */
  get _e() {
    return this.get__e();
  }
  /**
   * @hidden
   */
  _ao(a) {
    if (this._az != null) {
      this._az._o();
    }
    super._ao(a);
  }
  /**
   * @hidden
   */
  get__g() {
    return this.printOptions;
  }
  /**
   * @hidden
   */
  get _g() {
    return this.get__g();
  }
  /**
   * @hidden
   */
  get__p() {
    return this._a6;
  }
  /**
   * @hidden
   */
  get _p() {
    return this.get__p();
  }
  /**
   * @hidden
   */
  get__i() {
    return this.protection;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * Returns Chartsheet
   */
  get_type() {
    return 1;
  }
  /**
   * Returns Chartsheet
   */
  get type() {
    return this.get_type();
  }
  /**
   * Returns the [[WorksheetChart]] displayed in this chartsheet.
   */
  get chart() {
    if (this._a6.count == 0) {
      return null;
    }
    return this._a6.item(0);
  }
  /**
   * Gets the object which controls the display of the chartsheet.
   * <p class="body">
   * The display options include any settings which affect the display of the chartsheet when viewed in Microsoft Excel.
   * These settings will not affect the printed chartsheet or the data stored in the chartsheet.
   * </p>
   * The object which controls the display of the chartsheet.
   * @see [[CustomView.getSheetDisplayOptions]]
   */
  get displayOptions() {
    if (this._az == null) {
      this._az = new ChartsheetDisplayOptions(this);
    }
    return this._az;
  }
  /**
   * @hidden
   */
  get _bf() {
    return this._be;
  }
  /**
   * @hidden
   */
  set _bf(a) {
    if (a != this._be) {
      Chartsheet._ax[0].h(SheetChangeInfoContext.$, WBitmap.$, this._h, a);
    }
  }
  /**
   * @hidden
   */
  _bd(a) {
    this._be = a;
    this._a7 = null;
  }
  /**
   * @hidden
   */
  get _bb() {
    return this._ba;
  }
  /**
   * @hidden
   */
  set _bb(a) {
    this._ba = a;
  }
  /**
   * Gets the object which controls how the chartsheet prints.
   * The object which controls how the chartsheet prints.
   * @see [[CustomView.getSheetPrintOptions]]
   */
  get printOptions() {
    if (this._a1 == null) {
      this._a1 = new ChartsheetPrintOptions(this, false);
    }
    return this._a1;
  }
  /**
   * Returns an object that provides information used when the Chartsheet has been protected.
   * @see@see@see [[ChartsheetProtection]]
   * @see [[protect]]
   * @see */
  get protection() {
    return this._a3;
  }
  /**
   * @hidden
   */
  static _ay() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, SheetChangeInfoContext.a(Chartsheet.$, WBitmap.$, "ImageBackground", 9, (b) => b._bf, (b, c) => b._bf = c, (b, c) => b._bd(c)));
    return a;
  }
  /**
   * Protects the chartsheet without a password.
   * <p class="body">When a Chartsheet is protected without a password, the end user may unprotect the Chartsheet in Excel without
   * having to supply a password. To programatically unprotect a Chartsheet, one may use the Unprotect() method.</p>
   * <p class="body">The optional parameters are used to update the property values of the [[ChartsheetProtection]] instance from
   * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
   * be retained; otherwise the property will be updated with the specified value. For example, if the [[ChartsheetProtection.allowEditObjects]]
   * is currently true and the 'allowEditObjects' is null, then the property will continue to be true but if the
   * 'allowEditObjects' is false the [[ChartsheetProtection.allowEditObjects]] will be changed to false.</p>
   * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
   * @param allowEditObjects Optional boolean indicating the new value for the [[ChartsheetProtection.allowEditObjects]].
   * @param allowEditContents Optional boolean indicating the new value for the ChartsheetProtection.AllowEditScenarios.
   * @see@see@see [[protection]]
   * @see [[ChartsheetProtection]]
   * @see */
  protect(allowEditObjects, allowEditContents) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Boolean_$type, arguments[1]);
    }
    return this._protect$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _protect$i(a = Nullable$1.toNullable(Boolean_$type, null), b = Nullable$1.toNullable(Boolean_$type, null)) {
    this.protection._j(null, a, b);
  }
  /**
   * @hidden
   */
  onChildShapeBoundsChanged(childShape, oldTopLeftCell, oldBottomRightCell, isNotifyOnly) {
    throw new NotImplementedException(0);
  }
  /**
   * @hidden
   */
  onShapeAdded(shape) {
    if (this.workbook._c4) {
    }
    else if (this._a6.item(0) != shape) {
      throw new InvalidOperationException(0);
    }
  }
  /**
   * @hidden
   */
  onShapeRemoved(shape) {
    throw new InvalidOperationException(0);
  }
  /**
   * @hidden
   */
  get areChildrenTopMost() {
    return true;
  }
  /**
   * @hidden
   */
  get ChildShapes() {
    return this._a6;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this;
  }
}
Chartsheet.$t = markType(Chartsheet, 'Chartsheet', Sheet.$, [IWorksheetShapeOwner_$type]);
/**
 * @hidden
 */
Chartsheet._a8 = 0;
/**
 * @hidden
 */
Chartsheet._a9 = 1;
/**
 * @hidden
 */
Chartsheet._ax = null;
/**
 * @hidden
 */
export let IChartObject_$type = new Type(null, 'IChartObject', null, [ISheetProvider_$type, IWorkbookProvider_$type]);
/**
 * Abstract base class for objects that are exposed off a
 * @see [[WorksheetChart]]
 */
export class ChartObject extends Base {
  constructor(a) {
    super();
    this._c = null;
    this._c = a;
  }
  /**
   * @hidden
   */
  _e(a) {
    return null;
  }
  /**
   * @hidden
   */
  _a(a) {
    throw new NotImplementedException(1, "must be overriden by each class that calls SetProperty");
  }
  /**
   * @hidden
   */
  _f(a, b = true) {
    let c = this.workbook;
    if (c == null) {
      c = a;
    }
    let d = null;
    if (c != null) {
      d = new WorkbookFontProxy(1, new WorkbookFontData(0, c), c._ax);
      if (b) {
        d._s(runOn(this, this._n));
      }
    }
    if (d == null) {
    }
    return d;
  }
  /**
   * @hidden
   */
  _l(a) {
    this._c = a;
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = this._d;
    if (b != null) {
      b.onPropertyChanged();
    }
  }
  /**
   * @hidden
   */
  _j(a) {
    let b = this.workbook;
    return b != null && b._cx ? b._go(this.sheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _p(a) {
    if (a != null) {
      let b = this.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _q($tContext, $t, a, b, c, d) {
    let e = this._r($tContext, $t, a, b, c, d, (e) => ExcelUtils.gl($t, e));
    c = e.p2;
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  _r($tContext, $t, a, b, c, d, e = null) {
    this._u();
    if (e != null) {
      e(d);
    }
    let f = this._a(b).g($tContext, $t, a, c, d, this._h);
    c = f.p1;
    c = d;
    this.onPropertyChanged();
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  _s() {
    let a = this.chart;
    if (a != null) {
      WorksheetChart._jv(this.sheet, a.chartType);
    }
  }
  /**
   * @hidden
   */
  _u() {
    let a = this.workbook;
    if (a != null) {
      a._i9();
    }
  }
  /**
   * @hidden
   */
  static _v(a, b) {
    if (b == null || a == null) {
      return;
    }
    if (a.chart != null && b.chart != null && b.chart != a.chart) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ChartObject_DifferentChart"));
    }
  }
  /**
   * Returns the owning chart (read-only)
   * @see [[owner]]
   */
  get chart() {
    return this._c != null ? this._c.chart : null;
  }
  /**
   * returns this object's owner. (read-only)
   * The owner or null if this object is owned directly by the Chart
   * @see [[chart]]
   */
  get owner() {
    return typeCast(ChartObject.$, this._c);
  }
  /**
   * The owning sheet (read-only)
   */
  get sheet() {
    let a = this.chart;
    return a != null ? a.sheet : null;
  }
  /**
   * The owning workbook (read-only)
   */
  get workbook() {
    let a = this.sheet;
    return a != null ? a.workbook : null;
  }
  /**
   * The owning worksheet (read-only)
   */
  get worksheet() {
    let a = this.chart;
    return a != null ? a.worksheet : null;
  }
  /**
   * @hidden
   */
  get _h() {
    let a = this.chart;
    return a == null || a._gc;
  }
  /**
   * @hidden
   */
  get _d() {
    return this._c != null ? this._c : this.chart;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  onPropertyChanged() {
    let a = this.chart;
    if (a != null) {
      a.onPropertyChanged();
    }
  }
  /**
   * @hidden
   */
  isReferencingAnythingInRegion(ws, region) {
    return this._i(ws, region);
  }
  /**
   * @hidden
   */
  _i(a, b) {
    return false;
  }
  /**
   * @hidden
   */
  iterateFormulas(callback) {
    this._m(callback);
  }
  /**
   * @hidden
   */
  _m(a) {
  }
  /**
   * @hidden
   */
  onShiftRegion(callback, shiftOperation, operationOverride) {
    this._o(callback, shiftOperation, operationOverride);
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
  }
  /**
   * @hidden
   */
  undoChartShift(context) {
    return this._k(context);
  }
  /**
   * @hidden
   */
  _k(a) {
    return null;
  }
  /**
   * @hidden
   */
  verifyFormulas(removedWorksheet) {
    this._t(removedWorksheet);
  }
  /**
   * @hidden
   */
  _t(a) {
  }
}
ChartObject.$t = markType(ChartObject, 'ChartObject', Base.$, [IChartObject_$type, IChangeInfoContext_$type]);
/**
 * Exposes chart-level properties for [[Series]] which appear within a combo chart.
 * @see [[WorksheetChart.comboChartGroups]]
 */
export class ComboChartGroup extends ChartObject {
  constructor(a, b, c, d) {
    super(a);
    this._aj = Nullable$1.toNullable(Number_$type, null);
    this._ak = Nullable$1.toNullable(Number_$type, null);
    this._al = Nullable$1.toNullable(Number_$type, null);
    this._am = Nullable$1.toNullable(Number_$type, null);
    this._axisGroup = 0;
    this._chartType = 0;
    if (d) {
      ComboChartGroup._au(b);
    }
    this.chartType = b;
    this.axisGroup = c;
  }
  static staticInit() {
    ComboChartGroup._w = ComboChartGroup._x();
  }
  /**
   * @hidden
   */
  _ac(a, b, c) {
    if (WorksheetChart._go(b) == false) {
      return null;
    }
    return new ComboChartGroup(a, b, c, false);
  }
  /**
   * Returns the [[axisGroup]] value with which this instance was created.
   */
  get axisGroup() {
    return this._axisGroup;
  }
  /**
   * Returns the [[axisGroup]] value with which this instance was created.
   */
  set axisGroup(a) {
    this._axisGroup = a;
  }
  /**
   * Returns the [[chartType]] value with which this instance was created.
   */
  get chartType() {
    return this._chartType;
  }
  /**
   * Returns the [[chartType]] value with which this instance was created.
   */
  set chartType(a) {
    this._chartType = a;
  }
  /**
   * Returns or sets the size of the hole in a doughnut chart,
   * expressed as a percentage of the size of the encompassing circle.
   * <p class="body">
   * This property is only applicable to doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 90, inclusive.
   * </p>
   * @see [[WorksheetChart.doughnutHoleSize]]
   */
  get doughnutHoleSize() {
    return unwrapNullable(this._doughnutHoleSize$i);
  }
  /**
   * Returns or sets the size of the hole in a doughnut chart,
   * expressed as a percentage of the size of the encompassing circle.
   * <p class="body">
   * This property is only applicable to doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 90, inclusive.
   * </p>
   * @see [[WorksheetChart.doughnutHoleSize]]
   */
  set doughnutHoleSize(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._doughnutHoleSize$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _doughnutHoleSize$i() {
    return this._aj;
  }
  /**
   * @hidden
   */
  set _doughnutHoleSize$i(a) {
    if (nullableNotEquals(a, this._aj)) {
      let b = this._r(ComboChartGroup.$, Nullable$1.$.specialize(Number_$type), this, 0, this._aj, a, (b) => {
        if (b.hasValue) {
          DocCoreUtils.av(Number_$type, b.value, "DoughnutHoleSize", 0, 90);
        }
      });
      this._aj = b.p2;
    }
  }
  /**
   * Returns or sets the angle, expressed in degrees which determines the origin
   * of the first slice, as relative to the 12 o'clock position of the emcompassing
   * circle.
   * <p class="body">
   * This property is only applicable to pie and doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between 0 and 360, inclusive.
   * </p>
   * @see [[WorksheetChart.firstSliceAngle]]
   */
  get firstSliceAngle() {
    return unwrapNullable(this._firstSliceAngle$i);
  }
  /**
   * Returns or sets the angle, expressed in degrees which determines the origin
   * of the first slice, as relative to the 12 o'clock position of the emcompassing
   * circle.
   * <p class="body">
   * This property is only applicable to pie and doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between 0 and 360, inclusive.
   * </p>
   * @see [[WorksheetChart.firstSliceAngle]]
   */
  set firstSliceAngle(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._firstSliceAngle$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _firstSliceAngle$i() {
    return this._ak;
  }
  /**
   * @hidden
   */
  set _firstSliceAngle$i(a) {
    if (nullableNotEquals(a, this._ak)) {
      let b = this._r(ComboChartGroup.$, Nullable$1.$.specialize(Number_$type), this, 1, this._ak, a, (b) => {
        if (b.hasValue) {
          DocCoreUtils.av(Number_$type, b.value, "FirstSliceAngle", 0, 360);
        }
      });
      this._ak = b.p2;
    }
  }
  /**
   * Specifies the width of the gap between bars.
   * Applicable only for bar/column charts.
   * <p class="body">
   * This property is only applicable for bar charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between 0 and 500, inclusive.
   * </p>
   * @see [[WorksheetChart.gapWidth]]
   */
  get gapWidth() {
    return unwrapNullable(this._gapWidth$i);
  }
  /**
   * Specifies the width of the gap between bars.
   * Applicable only for bar/column charts.
   * <p class="body">
   * This property is only applicable for bar charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between 0 and 500, inclusive.
   * </p>
   * @see [[WorksheetChart.gapWidth]]
   */
  set gapWidth(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._gapWidth$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _gapWidth$i() {
    return this._al;
  }
  /**
   * @hidden
   */
  set _gapWidth$i(a) {
    if (nullableNotEquals(a, this._al)) {
      let b = this._r(ComboChartGroup.$, Nullable$1.$.specialize(Number_$type), this, 2, this._al, a, (b) => {
        if (b.hasValue) {
          DocCoreUtils.av(Number_$type, b.value, "GapWidth", 0, 500);
        }
      });
      this._al = b.p2;
    }
  }
  /**
   * Determines the amount by which intersecting [[Series]] overlap,
   * expressed as a percentage of the bar size.
   * <p class="body">
   * This property is only applicable for bar charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between -100 and 100, inclusive.
   * </p>
   * @see [[WorksheetChart.seriesOverlap]]
   */
  get seriesOverlap() {
    return unwrapNullable(this._seriesOverlap$i);
  }
  /**
   * Determines the amount by which intersecting [[Series]] overlap,
   * expressed as a percentage of the bar size.
   * <p class="body">
   * This property is only applicable for bar charts.
   * </p>
   * <p class="body">
   * The valid range for this property is between -100 and 100, inclusive.
   * </p>
   * @see [[WorksheetChart.seriesOverlap]]
   */
  set seriesOverlap(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._seriesOverlap$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _seriesOverlap$i() {
    return this._am;
  }
  /**
   * @hidden
   */
  set _seriesOverlap$i(a) {
    if (nullableNotEquals(a, this._am)) {
      let b = this._r(ComboChartGroup.$, Nullable$1.$.specialize(Number_$type), this, 3, this._am, a, (b) => {
        if (b.hasValue) {
          DocCoreUtils.av(Number_$type, b.value, "SeriesOverlap", -100, 100);
        }
      });
      this._am = b.p2;
    }
  }
  /**
   * @hidden
   */
  static _ar(a, b) {
    let c;
    return ((() => { let d = ComboChartGroup._as(a, b, c); c = d.p2; return d.ret; })());
  }
  /**
   * @hidden
   */
  static _as(a, b, c) {
    c = ComboChartGroup._ad(a);
    return {
      ret: ComboChartGroup._at(c, b),
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _at(a, b) {
    if (a == 0) {
      return null;
    }
    return stringFormat("{0}.{1}", enumGetBox(SeriesChartTypeGroup_$type, a), enumGetBox(AxisGroup_$type, b));
  }
  /**
   * @hidden
   */
  static _ad(a) {
    if (WorksheetChart._go(a) == false) {
      return 0;
    }
    switch (a) {
      case 51: return 7;
      case 52: return 8;
      case 53: return 9;
      case 57: return 4;
      case 58: return 5;
      case 59: return 6;
      case 4:
      case 65: return 10;
      case 63:
      case 66: return 11;
      case 64:
      case 67: return 12;
      case 1: return 1;
      case 76: return 2;
      case 77: return 3;
      case 5:
      case 69: return 13;
      case 71: return 15;
      case 68: return 14;
      case -4120:
      case 80: return 16;
      case -4169:
      case 74:
      case 75: return 19;
      case 72:
      case 73: return 20;
      case -4151:
      case 81: return 17;
      case 82: return 18;
      default: return 0;
    }
  }
  /**
   * @hidden
   */
  static _y(a) {
    if (a == 0) {
      return null;
    }
    let b = new List$1(ChartType_$type, 0);
    switch (a) {
      case 1:
        b.add(1);
        break;
      case 2:
        b.add(76);
        break;
      case 3:
        b.add(77);
        break;
      case 4:
        b.add(57);
        break;
      case 5:
        b.add(58);
        break;
      case 6:
        b.add(59);
        break;
      case 15:
        b.add(71);
        break;
      case 7:
        b.add(51);
        break;
      case 8:
        b.add(52);
        break;
      case 9:
        b.add(53);
        break;
      case 16:
        b.add(-4120);
        b.add(80);
        break;
      case 10:
        b.add(4);
        b.add(65);
        break;
      case 11:
        b.add(63);
        b.add(66);
        break;
      case 12:
        b.add(64);
        b.add(67);
        break;
      case 13:
        b.add(5);
        b.add(69);
        break;
      case 14:
        b.add(68);
        break;
      case 17:
        b.add(-4151);
        b.add(81);
        break;
      case 18:
        b.add(82);
        break;
      case 20:
        b.add(72);
        b.add(73);
        break;
      case 19:
        b.add(-4169);
        b.add(74);
        b.add(75);
        break;
    }
    return b.toArray();
  }
  /**
   * @hidden
   */
  static _au(a) {
    if (WorksheetChart._go(a) == false) {
      throw new NotSupportedException(1, ExcelUtils.eg("LE_Series_ChartType_InvalidForComboChart", enumGetBox(ChartType_$type, a)));
    }
  }
  /**
   * @hidden
   */
  _a(a) {
    return ComboChartGroup._w[a];
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ComboChartGroup.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, ComboChartGroup._z(Nullable$1.$.specialize(Number_$type), "DoughnutHoleSize", 7, (b) => b._doughnutHoleSize$i, (b, c) => b._doughnutHoleSize$i = c));
    ChangeInfo.f(a, 1, ComboChartGroup._z(Nullable$1.$.specialize(Number_$type), "FirstSliceAngle", 7, (b) => b._firstSliceAngle$i, (b, c) => b._firstSliceAngle$i = c));
    ChangeInfo.f(a, 2, ComboChartGroup._z(Nullable$1.$.specialize(Number_$type), "GapWidth", 7, (b) => b._gapWidth$i, (b, c) => b._gapWidth$i = c));
    ChangeInfo.f(a, 3, ComboChartGroup._z(Nullable$1.$.specialize(Number_$type), "SeriesOverlap", 7, (b) => b._seriesOverlap$i, (b, c) => b._seriesOverlap$i = c));
    return a;
  }
}
ComboChartGroup.$t = markType(ComboChartGroup, 'ComboChartGroup', ChartObject.$);
/**
 * @hidden
 */
ComboChartGroup._ae = 0;
/**
 * @hidden
 */
ComboChartGroup._af = 1;
/**
 * @hidden
 */
ComboChartGroup._ag = 2;
/**
 * @hidden
 */
ComboChartGroup._ai = 3;
/**
 * @hidden
 */
ComboChartGroup._ah = 4;
/**
 * @hidden
 */
ComboChartGroup._w = null;
/**
 * @hidden
 */
export class ComboChartGroupValidator extends Base {
  static r(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.s(b);
  }
  static s(a) {
    switch (a) {
      case 10:
      case 11:
      case 12: return true;
      default: return false;
    }
  }
  static p(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.q(b);
  }
  static q(a) {
    switch (a) {
      case 7:
      case 8:
      case 9: return true;
      default: return false;
    }
  }
  static n(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.o(b);
  }
  static o(a) {
    switch (a) {
      case 4:
      case 5:
      case 6: return true;
      default: return false;
    }
  }
  static l(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.m(b);
  }
  static m(a) {
    switch (a) {
      case 1:
      case 2:
      case 3: return true;
      default: return false;
    }
  }
  static x(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.y(b);
  }
  static y(a) {
    switch (a) {
      case 19:
      case 20: return true;
      default: return false;
    }
  }
  static v(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.w(b);
  }
  static w(a) {
    switch (a) {
      case 17:
      case 18: return true;
      default: return false;
    }
  }
  static t(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.u(b);
  }
  static u(a) {
    switch (a) {
      case 13:
      case 16: return true;
      default: return false;
    }
  }
  static h(a) {
    let b = ComboChartGroup._ad(a);
    return ComboChartGroupValidator.i(b);
  }
  static i(a) {
    let b = 0;
    switch (a) {
      case 10:
      case 4:
      case 7:
      case 1:
        b = 1;
        break;
      case 2:
      case 11:
      case 8:
      case 5:
        b = 2;
        break;
      case 3:
      case 12:
      case 9:
      case 6:
        b = 3;
        break;
      default: break;
    }
    return b;
  }
  static b(a, b) {
    let c = a;
    let d = ComboChartGroupValidator.h(a);
    if (d == 0) {
      return c;
    }
    switch (a) {
      case 51:
        c = b == 2 ? 52 : b == 3 ? 53 : 51;
        break;
      case 52:
        c = b == 3 ? 53 : b == 1 ? 51 : 52;
        break;
      case 53:
        c = b == 2 ? 52 : b == 1 ? 51 : 53;
        break;
      case 57:
        c = b == 2 ? 58 : b == 3 ? 59 : 57;
        break;
      case 58:
        c = b == 3 ? 59 : b == 1 ? 57 : 58;
        break;
      case 59:
        c = b == 2 ? 58 : b == 1 ? 57 : 59;
        break;
      case 4:
        c = b == 2 ? 63 : b == 3 ? 64 : 4;
        break;
      case 65:
        c = b == 2 ? 66 : b == 3 ? 67 : 65;
        break;
      case 63:
        c = b == 3 ? 63 : b == 1 ? 4 : 63;
        break;
      case 66:
        c = b == 3 ? 67 : b == 1 ? 65 : 66;
        break;
      case 64:
        c = b == 2 ? 63 : b == 1 ? 4 : 64;
        break;
      case 67:
        c = b == 2 ? 66 : b == 1 ? 65 : 67;
        break;
      case 1:
        c = b == 2 ? 76 : b == 3 ? 77 : 1;
        break;
      case 76:
        c = b == 3 ? 77 : b == 1 ? 1 : 76;
        break;
      case 77:
        c = b == 2 ? 76 : b == 1 ? 1 : 77;
        break;
      default:
        c = a;
        break;
    }
    return c;
  }
  static g(a) {
    switch (a) {
      case 1: return 1;
      case 2: return 2;
      case 3: return 3;
      case 4: return 4;
      case 5: return 5;
      case 6: return 6;
      case 7: return 7;
      case 8: return 8;
      case 9: return 9;
      case 16:
      case 13:
      case 15:
      case 14: return 13;
      case 10: return 10;
      case 11: return 11;
      case 12: return 12;
      case 17:
      case 18: return 14;
      case 20:
      case 19: return 15;
      default: return 0;
    }
  }
  static f(a) {
    switch (a) {
      case 1:
      case 2:
      case 3: return 1;
      case 4:
      case 5:
      case 6: return 2;
      case 7:
      case 8:
      case 9: return 3;
      case 10:
      case 11:
      case 12: return 4;
      case 13: return 5;
      case 14: return 6;
      case 15: return 7;
      case 0: break;
    }
    return 0;
  }
  static j(a, b, c = false) {
    let d = ComboChartGroup._ad(a);
    let e = ComboChartGroup._ad(b);
    let f = ComboChartGroupValidator.k(d, e);
    if (f) {
      let g = ExcelUtils.q(a);
      let h = ExcelUtils.q(b);
      if (g == h) {
        let i = ComboChartGroupValidator.h(a);
        let j = ComboChartGroupValidator.h(b);
        if (i != 0 && j != 0) {
          if (i != j) {
            f = false;
          }
        }
      }
    }
    return f;
  }
  static k(a, b) {
    let c = ComboChartGroupValidator.g(a);
    let d = ComboChartGroupValidator.g(b);
    if (c == d) {
      return true;
    }
    switch (c) {
      case 1:
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 15:
        switch (d) {
          case 4:
          case 5:
          case 6:
          case 13:
          case 14: return false;
        }
        break;
      case 4:
      case 5:
      case 6:
      case 13:
      case 14:
        if (d != c) {
          return false;
        }
        break;
    }
    return true;
  }
  static aa(a, b, c, d) {
    let e = ExcelUtils.q(b);
    let f = d._ak(Nullable$1.toNullable(SeriesType_$type, e), Nullable$1.toNullable(AxisGroup_$type, c), a);
    if (f == null || f.count == 0) {
      return null;
    }
    let g = ComboChartGroupValidator.h(b);
    let h = new List$1(Series.$, 0);
    for (let i of fromEnum(f)) {
      if (i == a) {
        continue;
      }
      let j = ComboChartGroupValidator.h(i.chartType);
      if (j == 0) {
        continue;
      }
      if (j != g) {
        let k = ComboChartGroupValidator.b(i.chartType, g);
        h.add(i);
      }
    }
    return h.count > 0 ? h : null;
  }
  static d(a, b = true) {
    let c = ComboChartGroupValidator.e(a);
    if (c.d || b == false) {
      return c;
    }
    let d = null;
    if (((() => { let e = ComboChartGroupValidator.z(a, d); d = e.p1; return e.ret; })())) {
      let e = ComboChartGroupValidator.e(d);
      if (e.d) {
        e.c = d;
        return e;
      }
    }
    return c;
  }
  static e(a) {
    let b = new ComboChartGroupValidationResult();
    if (a == null || a.length == 0) {
      return b;
    }
    let c = new SeriesAxisGroup();
    c._a(a[0]);
    b.e.add(c);
    for (let d = 1; d < a.length; d++) {
      let e = a[d];
      let f = false;
      for (let g of fromEnum(b.e)) {
        if (g._a(e)) {
          f = true;
          break;
        }
      }
      if (f == false) {
        c = new SeriesAxisGroup();
        c._a(e);
        b.e.add(c);
      }
    }
    return b;
  }
  static z(a, b) {
    b = a;
    let c = 0;
    for (let e = 0; e < a.length; e++) {
      let d = a[e];
      c = ComboChartGroupValidator.h(d);
      if (c != 0) {
        break;
      }
    }
    if (c == 0) {
      return {
        ret: false,
        p1: b
      };
    }
    let f = new List$1(ChartType_$type, 0);
    for (let h = 0; h < a.length; h++) {
      let g = a[h];
      let i = ComboChartGroupValidator.b(g, c);
      f.add(i);
    }
    b = f.toArray();
    return {
      ret: true,
      p1: b
    };
  }
  static ac(a, b, c) {
    if (b.length == c.length && b.length >= a.count) {
      return {
        p1: b,
        p2: c
      };
    }
    let d = a.count - b.length;
    let e = new List$1(ChartType_$type, 0);
    e.o(b);
    let f = new List$1(AxisGroup_$type, 0);
    f.o(c);
    let g = b[b.length - 1];
    let h = c[c.length - 1];
    for (let i = 0; i < d; i++) {
      e.add(g);
      f.add(h);
    }
    b = e.toArray();
    c = f.toArray();
    return {
      p1: b,
      p2: c
    };
  }
  static c(a, b, c, d) {
    let e = b._ak(Nullable$1.toNullable(SeriesType_$type, null), Nullable$1.toNullable(AxisGroup_$type, 1), a);
    let f = b._ak(Nullable$1.toNullable(SeriesType_$type, null), Nullable$1.toNullable(AxisGroup_$type, 2), a);
    let g = true;
    let h = true;
    for (let i of fromEnum(e)) {
      if (ComboChartGroupValidator.j(i.chartType, c) == false) {
        g = false;
        break;
      }
    }
    for (let j of fromEnum(f)) {
      if (ComboChartGroupValidator.j(j.chartType, c) == false) {
        h = false;
        break;
      }
    }
    let k = null;
    if ((g && d == 1) || (h && d == 2)) {
      k = new ChartTypeValidationResult();
      return k;
    }
    if ((g && d == 2) || (h && d == 1)) {
      k = ((() => {
        let $ret = new ChartTypeValidationResult();
        $ret.d = Nullable$1.toNullable(AxisGroup_$type, g ? 1 : 2);
        return $ret;
      })());
      return k;
    }
    k = new ChartTypeValidationResult();
    let l = ComboChartGroupValidator.aa(a, c, d, b);
    k.b = l;
    if (l == null) {
      let m = new NotSupportedException(1, ExcelUtils.ef("LE_WorksheetChart_SetSourceData_TooManyAxes"));
      k.c = m;
    }
    return k;
  }
  static a(a, b, c) {
    let d = b._ak(Nullable$1.toNullable(SeriesType_$type, null), Nullable$1.toNullable(AxisGroup_$type, c), a);
    let e = true;
    let f = a.chartType;
    let g = Nullable$1.toNullable(ChartType_$type, null);
    for (let h of fromEnum(d)) {
      if (ComboChartGroupValidator.j(f, h.chartType, true) == false) {
        g = Nullable$1.toNullable(ChartType_$type, h.chartType);
        e = false;
        break;
      }
    }
    if (e) {
      return new AxisGroupValidationResult();
    }
    else {
      let i = ExcelUtils.eg("LE_Series_InvalidAxisGroup", enumGetBox(AxisGroup_$type, c), enumGetBox(ChartType_$type, g.value), enumGetBox(ChartType_$type, f));
      let j = new NotSupportedException(1, i);
      return ((() => {
        let $ret = new AxisGroupValidationResult();
        $ret.c = Nullable$1.toNullable(ChartType_$type, g.value);
        $ret.b = j;
        return $ret;
      })());
    }
  }
}
ComboChartGroupValidator.$t = markType(ComboChartGroupValidator, 'ComboChartGroupValidator');
/**
 * @hidden
 */
export class AxisGroupValidationResult extends Base {
  constructor() {
    super(...arguments);
    this.c = Nullable$1.toNullable(ChartType_$type, null);
    this.b = null;
  }
  get a() {
    return this.b == null;
  }
}
AxisGroupValidationResult.$t = markType(AxisGroupValidationResult, 'AxisGroupValidationResult');
/**
 * @hidden
 */
export class ChartTypeValidationResult extends Base {
  constructor() {
    super(...arguments);
    this.d = Nullable$1.toNullable(AxisGroup_$type, null);
    this.c = null;
    this.b = null;
  }
  get a() {
    return this.c == null;
  }
}
ChartTypeValidationResult.$t = markType(ChartTypeValidationResult, 'ChartTypeValidationResult');
/**
 * @hidden
 */
export class ComboChartGroupValidationResult extends Base {
  constructor() {
    super();
    this.e = null;
    this.c = null;
    this.e = new List$1(SeriesAxisGroup.$, 0);
  }
  get d() {
    return this.e.count > 0 && this.e.count <= 2;
  }
  a(a) {
    let b = new Array(a.length);
    arrayCopyTo(a, b, 0);
    let c = new List$1(ChartType_$type, 0);
    for (let d of fromEnum(this.e)) {
      for (let e of fromEnum(d)) {
        c.add(e);
        for (let f = 0; f < b.length; f++) {
          if (b[f] == e) {
            b[f] = 0;
            break;
          }
        }
      }
    }
    for (let h = 0; h < b.length; h++) {
      let g = b[h];
    }
    return c.toArray();
  }
  b(a) {
    let b = this.a(a);
    let c = new List$1(AxisGroup_$type, 2, a.length);
    for (let d = 0; d < this.e.count; d++) {
      let e = d == 0 ? 1 : 2;
      let f = this.e._inner[d];
      for (let g of fromEnum(f)) {
        c.add(e);
      }
    }
    return c.toArray();
  }
}
ComboChartGroupValidationResult.$t = markType(ComboChartGroupValidationResult, 'ComboChartGroupValidationResult');
/**
 * @hidden
 */
export class SeriesAxisGroup extends Base {
  constructor() {
    super();
    this._b = null;
    this._b = new List$1(ChartType_$type, 0);
  }
  _a(a) {
    let b = true;
    for (let c of fromEnum(this._b)) {
      if (ComboChartGroupValidator.j(c, a) == false) {
        b = false;
        break;
      }
    }
    if (b) {
      this._b.add(a);
    }
    return b;
  }
  toString() {
    let a = new StringBuilder(0);
    for (let b = 0; b < this._b.count; b++) {
      let c = this._b._inner[b];
      if (b > 0) {
        a.l(", ");
      }
      a.k(enumGetBox(ChartType_$type, c));
    }
    return a.toString();
  }
  getEnumerator() {
    return this._b.getEnumerator();
  }
  getEnumeratorObject() {
    return this._b.getEnumerator();
  }
}
SeriesAxisGroup.$t = markType(SeriesAxisGroup, 'SeriesAxisGroup', Base.$, [IEnumerable$1_$type.specialize(ChartType_$type)]);
/**
 * @hidden
 */
export class ComboChartGroupCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b.sheet;
  }
  get source() {
    return this.b.chart;
  }
}
ComboChartGroupCollection_CollectionChangeContext.$t = markStruct(ComboChartGroupCollection_CollectionChangeContext, 'ComboChartGroupCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[ComboChartGroup]] objects for a [[WorksheetChart]]
 * <p class="body">
 * This collection is used to apply chart-specific properties to [[Series]] which
 * appear within a combo chart.
 * </p>
 * @see [[ComboChartGroup]]
 * @see [[WorksheetChart.comboChartGroups]]
 */
export class ComboChartGroupCollection extends ChartObject {
  constructor(a) {
    super(a);
    this._af = null;
    this._af = new Dictionary$2(String_$type, ComboChartGroup.$, 0);
  }
  static staticInit() {
    ComboChartGroupCollection._w = ComboChartGroupCollection._x();
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    return this._af.count;
  }
  /**
   * Returns the [[ComboChartGroup]] instance associated with the specified
   * 'chartType' and 'axisGroup', or null if no such
   * instance exists.
   * @param chartType A [[ChartType]] constant which identifies the combo chart group.
   * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
   * @return A new or existing [[ComboChartGroup]] instance.
   */
  item(a, b) {
    ComboChartGroup._au(a);
    let c = ComboChartGroup._ar(a, b);
    return this._item1(c);
  }
  /**
   * @hidden
   */
  _item1(a) {
    let b = null;
    let c = this._af.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * Determines if the collecion can be modified (read-only)
   */
  get isReadOnly() {
    let a = this.workbook;
    if (a != null) {
      return !a._cn;
    }
    return false;
  }
  /**
   * Creates a new [[ComboChartGroup]], or returns an existing one,
   * which matches the specified 'chartType' and 'axisGroup'.
   * <p class="body">
   * This method returns an object which provides a way to set chart-specific
   * properties for a [[Series]] that is displayed within a combo chart.
   * </p>
   * <p class="body">
   * For example, to change the [[WorksheetChart.gapWidth]] property for
   * each series associated with a bar chart contained within a combo chart, set the
   * [[ComboChartGroup.gapWidth]] property of the instance returned from
   * this method.
   * </p>
   * <p class="body">
   * If a [[ComboChartGroup]] instance corresponding to the specified
   * 'chartType' and 'axisGroup' already exists,
   * that instance is returned; otherwise a new instance is created and that instance
   * is returned.
   * </p>
   * @param chartType A [[ChartType]] constant which identifies the combo chart group.
   * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
   * @return A new or existing [[ComboChartGroup]] instance.
   * @see [[ComboChartGroup]]
   * @see [[remove]]
   * @throws [[NotSupportedException]] The specified 'chartType' is not supported within a combo chart.
   * See documentation for the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
   * method for a list of supported chart types.
   */
  add(chartType, axisGroup) {
    ComboChartGroup._au(chartType);
    this._u();
    let a = ComboChartGroup._ar(chartType, axisGroup);
    let b = null;
    if (((() => { let c = this._af.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      b = new ComboChartGroup(this, chartType, axisGroup, false);
      this._al(b, a);
    }
    return b;
  }
  /**
   * @hidden
   */
  _al(a, b, c = true) {
    let d = null;
    if (((() => { let e = this._af.tryGetValue(b, d); d = e.p1; return e.ret; })())) {
      return;
    }
    let e = this.workbook;
    let f = this.sheet;
    let g = new ComboChartGroupCollection_CollectionChangeContext(1, this, a);
    let h = null;
    let i = null;
    if (e != null && !e._c4 && !this._h) {
      h = ComboChartGroupCollection._w[0];
      i = h.b(e, f, h.c);
    }
    this._af.addItem(b, a);
    if (h != null) {
      h.e(ComboChartGroupCollection_CollectionChangeContext.$, ComboChartGroup.$, g, null, a);
      if (i != null) {
        h.d(e, i);
      }
    }
    this.onPropertyChanged();
  }
  /**
   * Clears the collection.
   */
  clear() {
    this._u();
    let a = this.count > 1 ? this._j(7) : null;
    let b = new List$1(ComboChartGroup.$, 2, this._af.count);
    for (let c of fromEnum(this._af.values)) {
      b.add(c);
    }
    for (let d = b.count - 1; d >= 0; d--) {
      let e = b._inner[d];
      if (e != null) {
        this._remove1(e);
      }
    }
    this._p(a);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return getEnumerator(this._af.values);
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      n = 1;
    }
    else if (arguments.length === 2) {
      n = 0;
    }
    switch (n) {
      case 0: return this._remove.apply(this, arguments);
      case 1: return this._remove1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove1(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "comboChartGroup");
    }
    let b = ComboChartGroup._ar(a.chartType, a.axisGroup);
    let c = null;
    if (((() => { let d = this._af.tryGetValue(b, c); c = d.p1; return d.ret; })()) == false || a != c) {
      throw new BaseError(1, ExcelUtils.ef("LE_ComboChartGroupCollection_DoesNotExist"));
    }
    this._am(a);
    return true;
  }
  /**
   * @hidden
   */
  _remove(a, b) {
    this._u();
    ComboChartGroup._au(a);
    let c = this.item(a, b);
    if (c == null) {
      return false;
    }
    this._am(c);
    return true;
  }
  /**
   * @hidden
   */
  _am(a) {
    let b = this.workbook;
    let c = this.sheet;
    let d = ComboChartGroupCollection._w[1];
    let e = new ComboChartGroupCollection_CollectionChangeContext(1, this, a);
    let f = b == null || b._c4 || this._h ? null : d.b(b, c, d.c);
    let g = a.chartType;
    let h = a.axisGroup;
    let i = ComboChartGroup._ar(g, h);
    this._af.removeItem(i);
    if (b != null && !b._c4 && !this._h) {
      d.e(ComboChartGroupCollection_CollectionChangeContext.$, ComboChartGroup.$, e, null, a);
      if (f != null) {
        d.d(b, f);
      }
    }
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ComboChartGroupCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, ComboChartGroupCollection._y(ComboChartGroup.$, "Add", 7, (b) => b.a, (b, c) => ComboChartGroupCollection._an(b, c)));
    ChangeInfo.f(a, 1, ComboChartGroupCollection._y(ComboChartGroup.$, "Remove", 7, (b) => b.a, (b, c) => ComboChartGroupCollection._ao(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  static _an(a, b) {
    if (a.a != null) {
      a.b._remove1(a.a);
    }
  }
  /**
   * @hidden
   */
  static _ao(a, b) {
    let c = a.a;
    let d = ComboChartGroup._ar(c.chartType, c.axisGroup);
    a.b._al(c, d, true);
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return getEnumerator(this._af.values);
  }
}
ComboChartGroupCollection.$t = markType(ComboChartGroupCollection, 'ComboChartGroupCollection', ChartObject.$, [IEnumerable$1_$type.specialize(ComboChartGroup.$)]);
/**
 * @hidden
 */
ComboChartGroupCollection._ag = 0;
/**
 * @hidden
 */
ComboChartGroupCollection._aj = 1;
/**
 * @hidden
 */
ComboChartGroupCollection._ai = 2;
/**
 * @hidden
 */
ComboChartGroupCollection._w = null;
/**
 * Abstract base class for the fill of a shape.
 * @see [[WorksheetShape.fill]]
 * @see [[ShapeFillSolid]]
 */
export class ShapeFill extends Base {
  /**
   * Creates an instance to describe a solid fill outline.
   * @param solidColor The color of the fill to create.
   * @return A [[ShapeFillSolid]] instance with the specified color.
   */
  static fromColor(solidColor) {
    arguments[0] = Color.create(arguments[0]);
    return this._fromColor$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  static _fromColor$i(a) {
    return new ShapeFillSolid(a);
  }
  /**
   * Creates an instance to describe a solid fill outline.
   * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the fill to create.
   * @return A [[ShapeFillSolid]] instance with the specified color.
   */
  static fromColorInfo(solidColorInfo) {
    return new ShapeFillSolid(solidColorInfo);
  }
}
ShapeFill.$t = markType(ShapeFill, 'ShapeFill');
/**
 * Abstract base class for the outline of a shape.
 * @see [[WorksheetShape.outline]]
 * @see [[ShapeOutlineSolid]]
 */
export class ShapeOutline extends Base {
  constructor() {
    super(...arguments);
    /**
     * @hidden
     */
    this._e = null;
    /**
     * @hidden
     */
    this._f = null;
    /**
     * @hidden
     */
    this._d = 0;
  }
  /**
   * Creates an instance to describe a solid color outline.
   * @param solidColor The color of the outline to create.
   * @return A [[ShapeOutlineSolid]] instance with the specified color.
   */
  static fromColor(solidColor) {
    arguments[0] = Color.create(arguments[0]);
    return this._fromColor$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  static _fromColor$i(a) {
    return new ShapeOutlineSolid(a);
  }
  /**
   * Creates an instance to describe a solid color outline.
   * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the outline to create.
   * @return A [[ShapeOutlineSolid]] instance with the specified color.
   */
  static fromColorInfo(solidColorInfo) {
    return new ShapeOutlineSolid(solidColorInfo);
  }
  /**
   * @hidden
   */
  static _g(a) {
    let b = 524288;
    if (a._a5) {
      b = u32BitwiseOr(b, 1048592);
    }
    return b;
  }
}
ShapeOutline.$t = markType(ShapeOutline, 'ShapeOutline');
/**
 * Abstract base class for all shapes (atomic or compound) in a worksheet.
 * <p class="body">
 * Atomic shapes are singular shape entities, such as an image, a polygon, or text.
 * Compound shapes are groupings of shapes, and are represented by [[WorksheetShapeGroup]]
 * instances.
 * </p>
 * <p class="body">
 * Currently, not all shape information is customizable (such as shape rotation).  However,
 * for round-tripping purposes, when a shape is loaded from an Excel file, this
 * information in maintained with the shape.  See [[clearUnknownData]] for more
 * information about unsupported data.
 * </p>
 */
export class WorksheetShape extends Base {
  constructor(a, ..._rest) {
    super();
    this._an = null;
    this._u = null;
    this._ac = WorksheetCellAddress.b;
    this._di = PointUtil.create();
    this._dp = new Rect(4);
    this._o = 2;
    this._w = null;
    this._ag = WorksheetCellAddress.b;
    this._ai = new WorksheetCellAddress();
    this._ae = new WorksheetCellAddress();
    this._dk = PointUtil.create();
    this._b2 = Nullable$1.toNullable(Boolean_$type, null);
    this._bd = true;
    this._bh = null;
    this._bj = null;
    this._bl = null;
    this._g = null;
    this._b5 = 0;
    this._cb = 548;
    this._cd = 0;
    this._e = null;
    this._cm = 0;
    this._at = false;
    this._av = false;
    this._i = null;
    this._l = null;
    this._ba = false;
    /**
     * @hidden
     */
    this._b3 = null;
    /**
     * @hidden
     */
    this._ax = false;
    /**
     * @hidden
     */
    this._ay = false;
    /**
     * @hidden
     */
    this._aa = null;
    /**
     * @hidden
     */
    this._az = false;
    /**
     * @hidden
     */
    this._a0 = false;
    /**
     * @hidden
     */
    this._b7 = null;
    /**
     * @hidden
     */
    this._b8 = null;
    /**
     * @hidden
     */
    this._b4 = null;
    /**
     * @hidden
     */
    this._b9 = null;
    /**
     * @hidden
     */
    this._ca = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = [true];
          {
            let e = c[0];
            if (e) {
              this._cr();
            }
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          if (c) {
            this._cr();
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          this._cs(c);
        }
        break;
    }
  }
  static staticInit() {
    WorksheetShape._a = WorksheetShape._b();
    WorksheetShape._bf = new Dictionary$2(ST_ShapeType_$type, ShapeType_$type, 0);
    WorksheetShape._bg = new Dictionary$2(ShapeType_$type, ST_ShapeType_$type, 0);
    WorksheetShape._co(50, 113);
    WorksheetShape._co(51, 114);
    WorksheetShape._co(52, 115);
    WorksheetShape._co(44, 107);
    WorksheetShape._co(45, 108);
    WorksheetShape._co(46, 109);
    WorksheetShape._co(194, 165);
    WorksheetShape._co(196, 167);
    WorksheetShape._co(189, 160);
    WorksheetShape._co(198, 169);
    WorksheetShape._co(195, 166);
    WorksheetShape._co(193, 164);
    WorksheetShape._co(191, 162);
    WorksheetShape._co(190, 161);
    WorksheetShape._co(192, 163);
    WorksheetShape._co(200, 171);
    WorksheetShape._co(197, 168);
    WorksheetShape._co(199, 170);
    WorksheetShape._co(13, 43);
    WorksheetShape._co(33, 96);
    WorksheetShape._co(34, 97);
    WorksheetShape._co(35, 98);
    WorksheetShape._co(36, 99);
    WorksheetShape._co(84, 82);
    WorksheetShape._co(47, 110);
    WorksheetShape._co(48, 111);
    WorksheetShape._co(49, 112);
    WorksheetShape._co(186, 94);
    WorksheetShape._co(185, 93);
    WorksheetShape._co(41, 104);
    WorksheetShape._co(42, 105);
    WorksheetShape._co(43, 106);
    WorksheetShape._co(22, 73);
    WorksheetShape._co(55, 37);
    WorksheetShape._co(106, 119);
    WorksheetShape._co(16, 72);
    WorksheetShape._co(37, 100);
    WorksheetShape._co(38, 101);
    WorksheetShape._co(39, 102);
    WorksheetShape._co(40, 103);
    WorksheetShape._co(105, 70);
    WorksheetShape._co(103, 68);
    WorksheetShape._co(102, 67);
    WorksheetShape._co(104, 69);
    WorksheetShape._co(4, 5);
    WorksheetShape._co(188, 129);
    WorksheetShape._co(67, 46);
    WorksheetShape._co(80, 58);
    WorksheetShape._co(3, 34);
    WorksheetShape._co(107, 123);
    WorksheetShape._co(108, 124);
    WorksheetShape._co(176, 158);
    WorksheetShape._co(125, 147);
    WorksheetShape._co(120, 142);
    WorksheetShape._co(110, 132);
    WorksheetShape._co(135, 157);
    WorksheetShape._co(134, 156);
    WorksheetShape._co(114, 136);
    WorksheetShape._co(127, 149);
    WorksheetShape._co(111, 133);
    WorksheetShape._co(113, 135);
    WorksheetShape._co(132, 154);
    WorksheetShape._co(133, 155);
    WorksheetShape._co(131, 153);
    WorksheetShape._co(118, 140);
    WorksheetShape._co(119, 141);
    WorksheetShape._co(128, 150);
    WorksheetShape._co(115, 137);
    WorksheetShape._co(129, 151);
    WorksheetShape._co(177, 159);
    WorksheetShape._co(130, 152);
    WorksheetShape._co(124, 146);
    WorksheetShape._co(112, 134);
    WorksheetShape._co(117, 139);
    WorksheetShape._co(109, 131);
    WorksheetShape._co(121, 143);
    WorksheetShape._co(122, 144);
    WorksheetShape._co(126, 148);
    WorksheetShape._co(123, 145);
    WorksheetShape._co(116, 138);
    WorksheetShape._co(65, 81);
    WorksheetShape._co(74, 75);
    WorksheetShape._co(9, 10);
    WorksheetShape._co(15, 36);
    WorksheetShape._co(98, 127);
    WorksheetShape._co(71, 79);
    WorksheetShape._co(72, 80);
    WorksheetShape._co(5, 2);
    WorksheetShape._co(66, 44);
    WorksheetShape._co(77, 55);
    WorksheetShape._co(87, 91);
    WorksheetShape._co(85, 89);
    WorksheetShape._co(69, 50);
    WorksheetShape._co(81, 59);
    WorksheetShape._co(73, 74);
    WorksheetShape._co(20, 0);
    WorksheetShape._co(184, 77);
    WorksheetShape._co(94, 48);
    WorksheetShape._co(10, 12);
    WorksheetShape._co(7, 6);
    WorksheetShape._co(56, 9);
    WorksheetShape._co(21, 33);
    WorksheetShape._co(11, 130);
    WorksheetShape._co(1, 4);
    WorksheetShape._co(53, 121);
    WorksheetShape._co(54, 122);
    WorksheetShape._co(78, 56);
    WorksheetShape._co(88, 92);
    WorksheetShape._co(86, 90);
    WorksheetShape._co(6, 3);
    WorksheetShape._co(2, 25);
    WorksheetShape._co(59, 22);
    WorksheetShape._co(92, 23);
    WorksheetShape._co(60, 24);
    WorksheetShape._co(187, 15);
    WorksheetShape._co(58, 19);
    WorksheetShape._co(96, 78);
    WorksheetShape._co(32, 95);
    WorksheetShape._co(183, 76);
    WorksheetShape._co(68, 45);
    WorksheetShape._co(79, 57);
    WorksheetShape._co(70, 51);
    WorksheetShape._co(82, 60);
    WorksheetShape._co(97, 126);
    WorksheetShape._co(64, 128);
    WorksheetShape._co(63, 118);
    WorksheetShape._co(61, 116);
    WorksheetShape._co(62, 117);
  }
  /**
   * Clears the cached unknown shape data which was read in from a parsed excel file.
   * <p class="body">
   * This method will only be needed until all shape information is supported and customizable.
   * After all shape data can be controlled, this method will become obsolete. Currently, all
   * unsupported data will be stored with the shape for round-tripping purposes.  For example,
   * if an Excel file with complex and unsupported shapes is loaded into a
   * [[Workbook]] instance, some cell values are changed, and it is saved to
   * the same file, the complex shapes will still exist in the workbook.  However, if a
   * loaded shape needs to be modified before it is saved back, this method
   * allows for that unsupported data to be removed while all supported data is maintained.
   * </p>
   * <p class="note">
   * <B>Note:</B> This method only clears unsupported data.  In future versions of the product,
   * as more shape data is supported, this method will have different effects on the shape,
   * until eventually all data is supported and this method will have no effect on the shape.
   * </p>
   * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
   */
  clearUnknownData() {
    this._e = null;
    this._bh = null;
    this._bj = null;
    this._bl = null;
    this._g = null;
    this._b3 = null;
    if (typeCast(ShapeFillImage.$, this._i) !== null) {
      this._i = null;
    }
    this._aa = null;
  }
  /**
   * Creates a shape which is predefined in Microsoft Excel.
   * @param shapeType The type of shape to create.
   * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
   * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
   */
  static createPredefinedShape(shapeType) {
    return WorksheetShape._al(shapeType, true);
  }
  /**
   * @hidden
   */
  static _al(a, b) {
    if (EnumUtil.isDefined(PredefinedShapeType_$type, enumGetBox(PredefinedShapeType_$type, a)) == false) {
      throw new InvalidEnumArgumentException("shapeType", a, PredefinedShapeType_$type);
    }
    switch (a) {
      case 4: return new DiamondShape(b);
      case 74: return new HeartShape(b);
      case 71: return new IrregularSeal1Shape(b);
      case 72: return new IrregularSeal2Shape(b);
      case 73: return new LightningBoltShape(b);
      case 20: return new LineShape(b);
      case 3: return new EllipseShape(b);
      case 56: return new PentagonShape(b);
      case 1: return new RectangleShape(b);
      case 6: return new RightTriangleShape(b);
      case 32: return new StraightConnector1Shape(b);
      default: return new RectangleShape(b);
    }
  }
  getBoundsInTwips() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return rectToLiteral(this._getBoundsInTwips.apply(this, arguments));
      case 1: return rectToLiteral(this._getBoundsInTwips1.apply(this, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getBoundsInTwips() {
    return this._getBoundsInTwips1(0);
  }
  /**
   * @hidden
   */
  _getBoundsInTwips1(a) {
    let b = this.sheet;
    if (b != null && b.type == 1) {
      return new Rect(0, 0, 0, ExcelUtils.c1(8676680), ExcelUtils.c1(6295430));
    }
    if (this._w == null || this._u == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_GetBoundsBeforeAnchorsSet"));
    }
    return WorksheetShape._dt(this._w, this._ah, this._topLeftCornerPosition$i, this._ad, this._bottomRightCornerPosition$i, a);
  }
  setBoundsInTwips() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0:
        arguments[1] = rectFromLiteral(arguments[1]);
        return this._setBoundsInTwips.apply(this, arguments);
      case 1:
        arguments[1] = rectFromLiteral(arguments[1]);
        return this._setBoundsInTwips1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setBoundsInTwips(a, b) {
    this._setBoundsInTwips1(a, b, 0);
  }
  /**
   * @hidden
   */
  _setBoundsInTwips1(a, b, c) {
    this._c8(a, b, c, true);
  }
  /**
   * @hidden
   */
  static _c9(a, b, c, d, e, f, g) {
    if (a == null) {
      throw new ArgumentNullException(0, "sheet");
    }
    if (a.type != 0) {
      d = { $type: Point_$type, x: 0, y: 0 };
      f = { $type: Point_$type, x: 100, y: 100 };
      e = c = new WorksheetCellAddress(1, 0, 0);
      return {
        p2: c,
        p3: d,
        p4: e,
        p5: f
      };
    }
    let h = a;
    let i = (g & 1) != 0;
    let j;
    let k;
    let l = h._fw(b.left, 5, false);
    let m = h._fw(b.right, 5, false);
    let n = h._columns$i._ar(l, m, j, k, i);
    l = n.p0;
    m = n.p1;
    j = n.p2;
    k = n.p3;
    let o = (l * 100) / h._gb(j, true);
    let p = (m * 100) / h._gb(k, true);
    let q;
    let r;
    let s = truncate(b.top);
    let t = truncate(b.bottom);
    let u = h._rows$i._ar(s, t, q, r, i);
    s = u.p0;
    t = u.p1;
    q = u.p2;
    r = u.p3;
    let v = (s * 100) / h._gh(q, true);
    let w = (t * 100) / h._gh(r, true);
    d = { $type: Point_$type, x: o, y: v };
    f = { $type: Point_$type, x: p, y: w };
    let x = Workbook.getMaxRowCount(h._o) - 1;
    let y = Workbook.getMaxColumnCount(h._o) - 1;
    if (x < q) {
      q = x;
    }
    if (x < r) {
      r = x;
    }
    if (y < j) {
      j = y;
    }
    if (y < k) {
      k = y;
    }
    c = new WorksheetCellAddress(1, q, j);
    e = new WorksheetCellAddress(1, r, k);
    return {
      p2: c,
      p3: d,
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  _c8(a, b, c, d) {
    let e;
    let f;
    if (d) {
      f = ((() => { let g = this._dn(e); e = g.p0; return g.ret; })());
    }
    else {
      e = null;
      f = this._dp;
    }
    let g = this._dk;
    let h = this._di;
    let i = this._ag;
    let j = this._ac;
    let k = WorksheetShape._c9(a, b, this._ag, this._dk, this._ac, this._di, c);
    this._ag = k.p2;
    this._dk = k.p3;
    this._ac = k.p4;
    this._di = k.p5;
    let l = a.type == 0 ? a : null;
    this._u = l;
    this._w = l;
    if (d) {
      d = WorksheetCellAddress.h(j, this._ac) || WorksheetCellAddress.h(i, this._ag) || PointUtil.notEquals(g, this._dk) || PointUtil.notEquals(h, this._di);
    }
    if (d) {
      let m = this._cx(a, i, g, j, h, f, e);
      e = m.p6;
    }
  }
  /**
   * @hidden
   */
  _dd(a) {
    let b = this._dk;
    let c = this._di;
    let d = this._ag;
    let e = this._ac;
    this._c5(this.sheet, a.b, a.e, a.a, a.d, true);
    this._cw(this.sheet, d, b, e, c, true);
    WorksheetShape._a[8].e(WorksheetShape.$, Rect.$, this, this._dp, this._dp);
  }
  /**
   * @hidden
   */
  static _by(a) {
    if (a == 0) {
      return Nullable$1.toNullable(ST_ShapeType_$type, null);
    }
    let b;
    if (((() => { let c = WorksheetShape._bg.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      return Nullable$1.toNullable(ST_ShapeType_$type, null);
    }
    return Nullable$1.toNullable(ST_ShapeType_$type, b);
  }
  /**
   * @hidden
   */
  static _bz(a) {
    let b;
    if (((() => { let c = WorksheetShape._bf.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      return Nullable$1.toNullable(ShapeType_$type, null);
    }
    return Nullable$1.toNullable(ShapeType_$type, b);
  }
  /**
   * @hidden
   */
  static _ds(a, b, c, d, e) {
    return WorksheetShape._dt(a, b, c, d, e, 0);
  }
  /**
   * @hidden
   */
  static _dt(a, b, c, d, e, f) {
    if (false == b.e || false == d.e) {
      return new Rect(0, 0, 0, 0, 0);
    }
    return WorksheetShape._du(a, b.o, b.m, c, d.o, d.m, e, f);
  }
  /**
   * @hidden
   */
  static _du(a, b, c, d, e, f, g, h) {
    if (a == null) {
      return new Rect(0, 0, 0, 0, 0);
    }
    if (a.type != 0) {
      return new Rect(0, 0, 0, 0, 0);
    }
    let i = a;
    let j = (h & 1) != 0;
    let k;
    let l;
    let m = i._columns$i._aq(c, f, k, l, j);
    k = m.p2;
    l = m.p3;
    let n = (i._gb(c, j) * Math.min(d.x, 100)) / 100;
    k += truncate(MathUtilities.o(n));
    let o = (i._gb(f, j) * Math.min(g.x, 100)) / 100;
    l += truncate(MathUtilities.o(o));
    let p = truncate(MathUtilities.f(i._fl(k, 5, false)));
    let q = truncate(MathUtilities.f(i._fl(l, 5, false)));
    let r;
    let s;
    let t = i._rows$i._aq(b, e, r, s, j);
    r = t.p2;
    s = t.p3;
    let u = (i._gh(b, j) * Math.min(d.y, 100)) / 100;
    r += truncate(MathUtilities.o(u));
    let v = (i._gh(e, j) * Math.min(g.y, 100)) / 100;
    s += truncate(MathUtilities.o(v));
    return new Rect(0, p, Math.min(r, 0x7FFFFFFF), q - p, Math.min(s - r, 0x7FFFFFFF));
  }
  /**
   * @hidden
   */
  _cr() {
    if (this._a5) {
      this.outline = ShapeOutline._fromColor$i(Color.u(255, 74, 126, 187));
    }
    else if (this._a4) {
      this.fill = ShapeFill._fromColor$i(Color.u(255, 79, 129, 189));
      this.outline = ShapeOutline._fromColor$i(Color.u(255, 56, 93, 138));
    }
    this._ax = true;
    this._ay = true;
    this._az = true;
  }
  /**
   * @hidden
   */
  _cs(a) {
    this._u = a._u;
    this._w = a._w;
    this._ac = a._ac;
    this._di = a._di;
    this._o = a._o;
    this._ba = a._ba;
    this._ag = a._ag;
    this._dk = a._dk;
    this._bd = a._bd;
    this._bh = a._bh;
    this._bj = a._bj;
    this._bl = a._bl;
    this._g = a._g;
    this._b5 = a._b5;
    this._cb = a._cb;
    this._e = a._e;
    this._cm = a._cm;
    this._at = a._at;
    this._av = a._av;
    this._b2 = a._b2;
    this._i = a._i;
    this._l = a._l;
    this._b8 = a._b8;
    this._ay = a._ay;
    this._az = a._az;
    this._ax = a._ax;
    this._a0 = a._a0;
    this._b7 = a._b7;
    this._ca = a._ca;
    this._b3 = a._b3;
  }
  /**
   * @hidden
   */
  _ct(a) {
    if (this._an != null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ShapeInAnotherCollection"));
    }
    if (this._a6(a) == false) {
      if (WorksheetCellAddress.g(Nullable$1.toNullable(WorksheetCellAddress.$, this._ag), Nullable$1.toNullable(WorksheetCellAddress.$, null)) || WorksheetCellAddress.g(Nullable$1.toNullable(WorksheetCellAddress.$, this._ac), Nullable$1.toNullable(WorksheetCellAddress.$, null))) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_AnchorShapeBeforeAddingToCollection"));
      }
    }
    let b = a._g;
    if (b != null) {
      this._c0(b);
    }
    this._an = a;
  }
  /**
   * @hidden
   */
  _cu(a) {
    let b = this._dp;
    let c = a.a._c6;
    if (c != null) {
      c.i(this, b);
    }
    let d = this._topLeftCornerPosition$i;
    let e = this._bottomRightCornerPosition$i;
    let f;
    let g;
    if (a.h) {
      f = d.y;
      g = e.y;
    }
    else {
      f = d.x;
      g = e.x;
    }
    let h;
    let i;
    let j = this._cp(a, f, g, h, i);
    f = j.p1;
    g = j.p2;
    h = j.p3;
    i = j.p4;
    let k = this._dp;
    if (a.h) {
      d = { $type: Point_$type, x: d.x, y: f };
      e = { $type: Point_$type, x: e.x, y: g };
      k = new Rect(0, k.x, k.y + h, k.width, Math.max(0, k.height + i));
    }
    else {
      d = { $type: Point_$type, x: f, y: d.y };
      e = { $type: Point_$type, x: g, y: e.y };
      k = new Rect(0, k.x + h, k.y, Math.max(0, k.width + i), k.height);
    }
    switch (this._q) {
      case 3:
        let l = this._ah;
        let m = this._ad;
        let n = this._dk;
        let o = this._di;
        this._c8(this.sheet, k, 0, false);
        if (WorksheetCellAddress.h(l, this._ah) || WorksheetCellAddress.h(m, this._ad) || PointUtil.notEquals(n, this._dk) || PointUtil.notEquals(o, this._di)) {
          this._cw(this.worksheet, l, n, m, o, true);
        }
        break;
      case 0:
        {
          let p = this._topLeftCornerPosition$i;
          let q = this._bottomRightCornerPosition$i;
          this._dk = d;
          this._di = e;
          this._cw(this.worksheet, this._ah, p, this._ad, q, true);
        }
        break;
      case 2:
        {
          let r = this._ag;
          let s = this._dk;
          let t = this._ac;
          let u = this._di;
          this._c8(this.sheet, k, 0, false);
          if (WorksheetCellAddress.h(this._ag, r) || 100 < this._dk.x || 100 < this._dk.y) {
            this._ag = r;
            this._dk = d;
          }
          this._cw(this.worksheet, r, s, t, u, true);
        }
        break;
    }
    this._de((v) => v._dp);
    if (c != null) {
      WorksheetShape._a[8].e(WorksheetShape.$, Rect.$, this, b, k);
    }
    else {
      this._dm(b, null);
    }
    this._dp = new Rect(0, 0, 0, 0, 0);
  }
  /**
   * @hidden
   */
  _a9(a, b) {
    if (this.positioningMode != 0) {
      return false;
    }
    if (this._ag.m >= b._w && this._ag.o >= b._ac && this._ac.m <= b._x && this._ac.o <= b._ae) {
      let c = this.worksheet.workbook;
      let d = c._df;
      c._df = false;
      this.worksheet._shapes$i.remove_1(this);
      c._df = d;
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _cv() {
    let a;
    if (this._ap != null && this._ap.count > 0) {
      a = true;
    }
    else if (this.sheet != this._d) {
      a = true;
    }
    else {
      a = false;
    }
    if (this.positioningMode == 0 && !a) {
      let b = this.sheet;
      let c = b != null ? b.workbook : null;
      if (b == null || c == null || !c._c9) {
        if (Rect.l_op_Equality(this._dp, null)) {
          this._dp = new Rect(4);
        }
        return;
      }
    }
    this._dp = this._getBoundsInTwips();
  }
  /**
   * @hidden
   */
  _cw(a, b, c, d, e, f) {
    if (this._an != null) {
      this._an._f.onChildShapeBoundsChanged(this, b, d, f);
    }
  }
  /**
   * @hidden
   */
  _cy() {
    if (this._bi == null) {
      return;
    }
    for (let a of fromEnum(this._bi)) {
      switch (a._b) {
        case 959:
          {
            if ((typeof a._i === 'number') == false) {
              break;
            }
            let b = typeGetValue(a._i);
            this.visible = (b & 2) == 0;
            break;
          }
      }
    }
  }
  /**
   * @hidden
   */
  _cz() {
    this._an = null;
  }
  /**
   * @hidden
   */
  _c0(a) {
    let b = a != null && a.type == 1 ? null : a;
    if (this._w != b) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TopLeftAnchorFromOtherWorksheet"));
    }
    if (this._u != b) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_BottomRightAnchorFromOtherWorksheet"));
    }
  }
  /**
   * @hidden
   */
  _c2(a, b, c) {
    ExcelUtils.fi(this._bi, ExcelUtils.g1(a._aj(this.sheet.workbook, false)), b, c);
  }
  /**
   * @hidden
   */
  _c3() {
    if (this._g == null) {
      this._g = new Obj(1, this);
    }
  }
  /**
   * @hidden
   */
  _c4(a, b, c) {
    this._ag = b;
    this._ac = c;
  }
  /**
   * @hidden
   */
  _c5(a, b, c, d, e, f = false) {
    let g;
    let h;
    if (!f) {
      h = ((() => { let i = this._dn(g); g = i.p0; return i.ret; })());
    }
    else {
      g = null;
      h = this._dp;
    }
    let i = this._ag;
    let j = this._dk;
    let k = this._ac;
    let l = this._di;
    this._w = a;
    this._u = a;
    this._ag = b;
    this._dk = c;
    this._ac = d;
    this._di = e;
    if (!f) {
      let m = this._cx(a, i, j, k, l, h, g);
      g = m.p6;
    }
    else {
      this._cw(a, i, j, k, l, true);
    }
  }
  /**
   * @hidden
   */
  _da(a, b) {
    this._ba = true;
    if (this._o != a) {
      if (b && EnumUtil.isDefined(ShapePositioningMode_$type, enumGetBox(ShapePositioningMode_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, ShapePositioningMode_$type);
      }
      this._dh(a);
      let c = WorksheetShape._a[5].g(WorksheetShape.$, ShapePositioningMode_$type, this, this._o, a);
      this._o = c.p1;
    }
  }
  /**
   * @hidden
   */
  _r(a, b, c) {
    return {
      ret: ((() => { let d = a.e(c, false); c = d.p0; return d.ret; })()),
      p2: c
    };
  }
  /**
   * @hidden
   */
  _s(a, b, c) {
    let d = c.item(this);
    let e = new WorksheetCellAddress();
    let f;
    let g = new WorksheetCellAddress();
    let h;
    let i = ((() => { let j = this._t(a, d, false, e, f, g, h); e = j.p3; f = j.p4; g = j.p5; h = j.p6; return j.ret; })());
    if (i.f && i.g == false) {
      a.h._c6.i(this, d);
      if (this._o == 0 || this._o == 2) {
        if (b == null || !b.isUndoOperation) {
          if (this._o == 0) {
            if (a.o && e.o == g.o) {
              h.y = 100;
            }
            if (false == a.o && e.m == g.m) {
              h.x = 100;
            }
          }
        }
      }
      this._c5(this._w, e, f, g, h, true);
      WorksheetShape._a[8].e(WorksheetShape.$, Rect.$, this, d, d);
      if (b == null || !b.isUndoOperation) {
        if (this._ap != null) {
          this._de((j) => c.item(j));
        }
      }
    }
    return i;
  }
  /**
   * @hidden
   */
  _t(a, b, c, d, e, f, g) {
    f = this._ac;
    g = this._di;
    d = this._ag;
    e = this._dk;
    if (this.positioningMode == 3) {
      let h = WorksheetShape._c9(a.h, b, d, e, f, g, 0);
      d = h.p2;
      e = h.p3;
      f = h.p4;
      g = h.p5;
      if (WorksheetCellAddress.f(d, this._ag) && PointUtil.equals(e, this._dk) && WorksheetCellAddress.f(f, this._ac) && PointUtil.equals(g, this._di)) {
        return {
          ret: ShiftAddressResult.d,
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
      return {
        ret: ShiftAddressResult.c,
        p3: d,
        p4: e,
        p5: f,
        p6: g
      };
    }
    let i = new WorksheetRegionAddress(1, d.o, d.o, d.m, d.m);
    let j = new WorksheetRegionAddress(1, d.o, d.o, d.m, f.m);
    let k = new WorksheetRegionAddress(1, f.o, f.o, d.m, f.m);
    let l = ((() => { let m = this._r(a, c, j); j = m.p2; return m.ret; })());
    let m = ((() => { let n = this._r(a, c, k); k = n.p2; return n.ret; })());
    if (l.f) {
      let n = WorksheetShape._db(a, j._ac, j._w, l, d, e);
      d = n.p4;
      e = n.p5;
      if (this.positioningMode == 2) {
        let o = WorksheetShape._dt(a.h, d, e, d, e, 0);
        let p = new Rect(0, o.x, o.y, b.width, b.height);
        let q = WorksheetShape._c9(a.h, p, d, e, f, g, 0);
        d = q.p2;
        e = q.p3;
        f = q.p4;
        g = q.p5;
        return {
          ret: ShiftAddressResult.c,
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
      if (m.f) {
        if (m.g && (l.g || m.b == 3)) {
          d = WorksheetCellAddress.b;
          f = WorksheetCellAddress.b;
          return {
            ret: m,
            p3: d,
            p4: e,
            p5: f,
            p6: g
          };
        }
        let r = WorksheetShape._db(a, k._ac, k._x, m, f, g);
        f = r.p4;
        g = r.p5;
        if (!m.g) {
          let s = ((() => { let t = a.e(i, false); i = t.p0; return t.ret; })());
          if (s.g) {
            if (a.o) {
              e.y = 0;
            }
            else {
              e.x = 0;
            }
            return {
              ret: new ShiftAddressResult(1, true, 0),
              p3: d,
              p4: e,
              p5: f,
              p6: g
            };
          }
        }
      }
    }
    else {
      if (this.positioningMode == 2) {
        return {
          ret: ShiftAddressResult.d,
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
      if (m.f == false) {
        return {
          ret: ShiftAddressResult.d,
          p3: d,
          p4: e,
          p5: f,
          p6: g
        };
      }
      let t = WorksheetShape._db(a, k._ac, k._x, m, f, g);
      f = t.p4;
      g = t.p5;
    }
    if (f.o < d.o) {
      f = f.d(d.o);
      g = { $type: Point_$type, x: g.x, y: e.y };
    }
    if (m.f && !c) {
      if (m.g) {
        if (!l.g) {
          if (a.o) {
            f = f.d(Math.max(d.o, f.o - 1));
          }
          else {
            f = f.c(Math.max(d.m + 1, f.m - 1));
          }
          return {
            ret: new ShiftAddressResult(1, true, 0),
            p3: d,
            p4: e,
            p5: f,
            p6: g
          };
        }
      }
    }
    return {
      ret: m,
      p3: d,
      p4: e,
      p5: f,
      p6: g
    };
  }
  /**
   * @hidden
   */
  static _db(a, b, c, d, e, f) {
    if (d.g) {
      if (d.b == 2 || d.b == 4) {
        if (a.o) {
          e = e.d(a.k._ac);
        }
        else {
          e = e.c(a.k._w);
        }
        f = { $type: Point_$type, x: f.x, y: 0 };
      }
      else {
        if (a.o) {
          e = e.d(a.k._ae);
        }
        else {
          e = e.c(a.k._x);
        }
        f = { $type: Point_$type, x: f.x, y: 100 };
      }
    }
    else {
      e = e.d(b);
      e = e.c(c);
    }
    return {
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  _dc() {
    this._ai = this._ag;
    this._ae = this._ac;
  }
  /**
   * @hidden
   */
  _dg() {
  }
  /**
   * @hidden
   */
  _dh(a) {
  }
  /**
   * @hidden
   */
  static _co(a, b) {
    if (a == 0) {
      return;
    }
    WorksheetShape._bf.addItem(b, a);
    WorksheetShape._bg.addItem(a, b);
  }
  /**
   * @hidden
   */
  _dm(a, b) {
    let c = this.sheet;
    let d = c != null ? c.workbook : null;
    if (d != null && d._cx) {
      let e = WorksheetShape._a[0];
      e.e(WorksheetShape.$, Rect.$, this, a, this._getBoundsInTwips1(1));
      if (b != null) {
        e.d(d, b);
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  _bn(a, b, c) {
    let d = a.g(b);
    let e = a.u(b, true);
    let f = a.f(b);
    let g = d ? 0 : e;
    let h = a.s(b, true);
    let i = f ? 0 : h;
    let j = (e * c) / 100;
    let k = truncate(MathUtilities.o(Math.min(g, j)));
    let l = truncate(MathUtilities.o(Math.min(i, j)));
    c = (100 * j) / h;
    if (d && f == false) {
      return {
        ret: a.q(l),
        p2: c
      };
    }
    if (d == false && f) {
      return {
        ret: -a.q(k),
        p2: c
      };
    }
    if (f) {
      return {
        ret: 0,
        p2: c
      };
    }
    if (k <= l) {
      return {
        ret: a.q(l - k),
        p2: c
      };
    }
    return {
      ret: -a.q(k - l),
      p2: c
    };
  }
  /**
   * @hidden
   */
  _dn(a) {
    let b = this.sheet;
    let c = b != null ? b.workbook : null;
    let d = new Rect(4);
    let e = WorksheetShape._a[0];
    a = null;
    if (c != null && c._cx) {
      d = this._getBoundsInTwips1(1);
      a = e.b(c, b, e.c);
    }
    return {
      ret: d,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _cp(a, b, c, d, e) {
    d = 0;
    e = 0;
    if (this.positioningMode == 0 || this.positioningMode == 2) {
      let f = a.h ? this._ah.o : this._ah.m;
      if (a.r < f) {
        let g = a.r;
        let h = Math.min(a.w, f - 1);
        let i = a.q(a.v(g, h));
        let j = a.q(a.t(g, h));
        d += (j - i);
      }
      if (a.r <= f && f <= a.w) {
        d += ((() => { let k = this._bn(a, f, b); b = k.p2; return k.ret; })());
      }
    }
    if (this.positioningMode == 0) {
      let k = a.h ? this._ad.o : this._ad.m;
      if (a.r <= k && k <= a.w) {
        e = ((() => { let l = this._bn(a, k, c); c = l.p2; return l.ret; })());
      }
    }
    return {
      p1: b,
      p2: c,
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = false, h = 8192) {
    return new ChangeInfo$2(WorksheetShape.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(9);
    WorksheetShape._c1(a, 62);
    return a;
  }
  /**
   * @hidden
   */
  _cx(a, b, c, d, e, f, g) {
    this._cw(a, b, c, d, e, false);
    this._dm(f, g);
    g = null;
    return {
      p6: g
    };
  }
  /**
   * @hidden
   */
  static _c1(a, b) {
    ChangeInfo.f(a, 0, WorksheetShape._c(Rect.$, "GetBoundsInTwips", b, (c) => c._getBoundsInTwips1(1), (c, d) => c._setBoundsInTwips1(c.sheet, d, 1), null, true, true));
    ChangeInfo.f(a, 1, WorksheetShape._c(ShapeFill.$, "Fill", b, (c) => c.fill, (c, d) => c.fill = d));
    ChangeInfo.f(a, 2, WorksheetShape._c(Boolean_$type, "FlippedHorizontally", b, (c) => c.flippedHorizontally, (c, d) => c.flippedHorizontally = d));
    ChangeInfo.f(a, 3, WorksheetShape._c(Boolean_$type, "flippedVertically", b, (c) => c.flippedVertically, (c, d) => c.flippedVertically = d));
    ChangeInfo.f(a, 4, WorksheetShape._c(ShapeOutline.$, "Outline", b, (c) => c.outline, (c, d) => c.outline = d));
    ChangeInfo.f(a, 5, WorksheetShape._c(ShapePositioningMode_$type, "PositioningMode", b, (c) => c.positioningMode, (c, d) => c.positioningMode = d));
    ChangeInfo.f(a, 6, WorksheetShape._c(Number_$type, "Rotation", b, (c) => c._b6, (c, d) => c._b6 = d));
    ChangeInfo.f(a, 7, WorksheetShape._c(Boolean_$type, "Visible", b, (c) => c.visible, (c, d) => c.visible = d));
    ChangeInfo.f(a, 8, WorksheetShape._c(Rect.$, "GetBoundsInTwips", b, (c) => c._getBoundsInTwips1(1), (c, d) => {
    }, null, false, false));
  }
  /**
   * @hidden
   */
  _de(a) {
    let b = this._ap;
    if (b != null && b.count > 0) {
      let c = a(this);
      let d = this._getBoundsInTwips();
      let e = this.sheet;
      let f = e.type == 0 ? e._c6 : null;
      let g = c.width == 0 ? 1 : truncate(d.width) / c.width;
      let h = c.height == 0 ? 1 : truncate(d.height) / c.height;
      for (let i of fromEnum(b)) {
        let j = a(i);
        let k = j;
        let l = ExcelUtils.fs(k, -c.x, -c.y);
        k = l.p0;
        if (f != null) {
          f.i(i, j);
        }
        let m = i._dk;
        let n = i._di;
        let o = i._ag;
        let p = i._ac;
        let q = new Rect(0, truncate((k.left * g)) + d.left, truncate((k.top * h)) + d.top, truncate((k.width * g)), truncate((k.height * h)));
        i._c8(e, q, 0, false);
        i._cw(e, o, m, p, n, true);
        if (f != null) {
          WorksheetShape._a[8].e(WorksheetShape.$, Rect.$, i, j, q);
        }
        else {
          i._dm(j, null);
        }
        i._de(a);
        i._dp = new Rect(0, 0, 0, 0, 0);
      }
    }
  }
  /**
   * @hidden
   */
  _df(a) {
    if (WorksheetCell.l_op_Equality(a, null) && this._an != null) {
      throw new ArgumentNullException(2, "value", ExcelUtils.ef("LE_ArgumentNullException_AnchorCell"));
    }
    if (WorksheetCell.l_op_Inequality(a, null) && a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    let b = this.worksheet;
    if (b != null && WorksheetCell.l_op_Inequality(a, null) && a.worksheet != b) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_AnchorCellFromOtherWorksheet"), "value");
    }
  }
  /**
   * @hidden
   */
  _a6(a) {
    let b = a != null ? typeCast(WorksheetShapeGroupBase.$, a._f) : null;
    return b != null && b._dz;
  }
  /**
   * Gets or sets the fill to use in the background of the shape.
   * <p class="note">
   * <b>Note:</b> some shapes, such as connectors or groups, cannot have a fill set. For these shapes, the value on this property
   * will be ignored and lost when the workbook is saved.
   * </p>
   * A [[ShapeFill]]-derived instance describing the fill of the shape, or null for no fill.
   * @see [[ShapeFill.fromColor]]
   * @see [[ShapeFillSolid]]
   * @see [[outline]]
   */
  get fill() {
    return this._i;
  }
  /**
   * Gets or sets the fill to use in the background of the shape.
   * <p class="note">
   * <b>Note:</b> some shapes, such as connectors or groups, cannot have a fill set. For these shapes, the value on this property
   * will be ignored and lost when the workbook is saved.
   * </p>
   * A [[ShapeFill]]-derived instance describing the fill of the shape, or null for no fill.
   * @see [[ShapeFill.fromColor]]
   * @see [[ShapeFillSolid]]
   * @see [[outline]]
   */
  set fill(a) {
    let b = WorksheetShape._a[1].g(WorksheetShape.$, ShapeFill.$, this, this._i, a);
    this._i = b.p1;
  }
  /**
   * @hidden
   */
  get _k() {
    return this._i || ShapeFillNoFill._e;
  }
  /**
   * Gets or sets the cell where the bottom-right corner of the shape resides.
   * <p class="body">
   * This anchor cell, along with the [[topLeftCornerCell]], determines where the shape will be
   * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
   * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
   * </p>
   * The cell where the bottom-right corner of the shape resides.
   * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
   * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerCell]]
   * @see [[topLeftCornerPosition]]
   */
  get bottomRightCornerCell() {
    if (this._u == null || false == this._ac.e) {
      return null;
    }
    return this._u._rows$i.item(this._ac.o)._cells$i.item(this._ac.m);
  }
  /**
   * Gets or sets the cell where the bottom-right corner of the shape resides.
   * <p class="body">
   * This anchor cell, along with the [[topLeftCornerCell]], determines where the shape will be
   * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
   * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
   * </p>
   * The cell where the bottom-right corner of the shape resides.
   * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
   * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerCell]]
   * @see [[topLeftCornerPosition]]
   */
  set bottomRightCornerCell(a) {
    let b;
    let c = new WorksheetCellAddress();
    if (WorksheetCell.l_op_Equality(a, null) || a.worksheet == null) {
      b = null;
      c = WorksheetCellAddress.b;
    }
    else {
      b = a.worksheet;
      c = a._e;
    }
    if (b != this._u || WorksheetCellAddress.h(c, this._ac)) {
      this._df(a);
      let d;
      let e = ((() => { let f = this._dn(d); d = f.p0; return f.ret; })());
      let f = this._ac;
      this._u = b;
      this._ac = c;
      let g = this._cx(b, this._ag, this._dk, f, this._di, e, d);
      d = g.p6;
    }
  }
  /**
   * Gets or sets the position in the [[bottomRightCornerCell]] of the shape's bottom-right corner,
   * expressed in percentages.
   * <p class="body">
   * These percentages are expressed as distance across the associated dimension of the cell, starting at the
   * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
   * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
   * in the cell which is centered horizontally, and a tenth of the way down from the top.
   * </p>
   * The position in the bottom-right corner cell of the shape's bottom-right corner.
   * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
   * @see [[bottomRightCornerCell]]
   * @see [[topLeftCornerCell]]
   * @see [[topLeftCornerPosition]]
   */
  get bottomRightCornerPosition() {
    return pointToLiteral(this._bottomRightCornerPosition$i);
  }
  /**
   * Gets or sets the position in the [[bottomRightCornerCell]] of the shape's bottom-right corner,
   * expressed in percentages.
   * <p class="body">
   * These percentages are expressed as distance across the associated dimension of the cell, starting at the
   * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
   * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
   * in the cell which is centered horizontally, and a tenth of the way down from the top.
   * </p>
   * The position in the bottom-right corner cell of the shape's bottom-right corner.
   * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
   * @see [[bottomRightCornerCell]]
   * @see [[topLeftCornerCell]]
   * @see [[topLeftCornerPosition]]
   */
  set bottomRightCornerPosition(a) {
    arguments[0] = pointFromLiteral(arguments[0]);
    this._bottomRightCornerPosition$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _bottomRightCornerPosition$i() {
    return this._di;
  }
  /**
   * @hidden
   */
  set _bottomRightCornerPosition$i(a) {
    if (PointUtil.notEquals(this._di, a)) {
      let b;
      let c = ((() => { let d = this._dn(b); b = d.p0; return d.ret; })());
      let d = this._di;
      this._di = a;
      let e = this._cx(this._u, this._ag, this._dk, this._ac, d, c, b);
      b = e.p6;
    }
  }
  /**
   * Gets or sets the value which indicates whether the shape is flipped horizontally along the vertical center line.
   * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
   */
  get flippedHorizontally() {
    return this._at;
  }
  /**
   * Gets or sets the value which indicates whether the shape is flipped horizontally along the vertical center line.
   * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
   */
  set flippedHorizontally(a) {
    if (this._at == a) {
      return;
    }
    this._dg();
    let b = WorksheetShape._a[2].g(WorksheetShape.$, Boolean_$type, this, this._at, a);
    this._at = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether the shape is flipped vertically along the horizontal center line.
   * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
   */
  get flippedVertically() {
    return this._av;
  }
  /**
   * Gets or sets the value which indicates whether the shape is flipped vertically along the horizontal center line.
   * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
   */
  set flippedVertically(a) {
    if (this._av == a) {
      return;
    }
    this._dg();
    let b = WorksheetShape._a[3].g(WorksheetShape.$, Boolean_$type, this, this._av, a);
    this._av = b.p1;
  }
  /**
   * Gets or sets the outline to use for the shape.
   * <p class="note">
   * <b>Note:</b> some shapes, such as comments or groups, cannot have a outline set. For these shapes, the value on this property
   * will be ignored and lost when the workbook is saved.
   * </p>
   * A [[ShapeOutline]]-derived instance describing the outline of the shape, or null for no outline.
   * @see [[ShapeOutline.fromColorInfo]]
   * @see [[ShapeOutlineSolid]]
   * @see [[fill]]
   */
  get outline() {
    return this._l;
  }
  /**
   * Gets or sets the outline to use for the shape.
   * <p class="note">
   * <b>Note:</b> some shapes, such as comments or groups, cannot have a outline set. For these shapes, the value on this property
   * will be ignored and lost when the workbook is saved.
   * </p>
   * A [[ShapeOutline]]-derived instance describing the outline of the shape, or null for no outline.
   * @see [[ShapeOutline.fromColorInfo]]
   * @see [[ShapeOutlineSolid]]
   * @see [[fill]]
   */
  set outline(a) {
    let b = WorksheetShape._a[4].g(WorksheetShape.$, ShapeOutline.$, this, this._l, a);
    this._l = b.p1;
  }
  /**
   * @hidden
   */
  get _n() {
    return this._l || ShapeOutlineNoOutline._i;
  }
  /**
   * Gets or sets the way shapes will be repositioned in excel when cells before or within the shape are resized.
   * <p class="body">
   * This value will not be saved for shapes contained in a [[WorksheetShapeGroup]], which inherit their
   * positioning mode from their parent group.
   * </p>
   * The way shapes will be repositioned in excel when cells before or within the shape are resized.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[ShapePositioningMode]] enumeration.
   */
  get positioningMode() {
    return this._o;
  }
  /**
   * Gets or sets the way shapes will be repositioned in excel when cells before or within the shape are resized.
   * <p class="body">
   * This value will not be saved for shapes contained in a [[WorksheetShapeGroup]], which inherit their
   * positioning mode from their parent group.
   * </p>
   * The way shapes will be repositioned in excel when cells before or within the shape are resized.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[ShapePositioningMode]] enumeration.
   */
  set positioningMode(a) {
    this._da(a, true);
  }
  /**
   * @hidden
   */
  get _q() {
    return this._a8 ? this.positioningMode : 0;
  }
  /**
   * @hidden
   */
  get _b6() {
    return this._b5;
  }
  /**
   * @hidden
   */
  set _b6(a) {
    if (this._b5 == a) {
      return;
    }
    this._dg();
    let b = WorksheetShape._a[6].g(WorksheetShape.$, Number_$type, this, this._b5, Math.max(-32768, Math.min(a, 32767)));
    this._b5 = b.p1;
  }
  /**
   * Gets or sets the cell where the top-left corner of the shape resides.
   * <p class="body">
   * This anchor cell, along with the [[bottomRightCornerCell]], determines where the shape will be
   * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
   * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
   * </p>
   * The cell where the top-left corner of the shape resides.
   * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
   * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
   * @see [[bottomRightCornerCell]]
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerPosition]]
   */
  get topLeftCornerCell() {
    if (this._w == null || false == this._ag.e) {
      return null;
    }
    return this._w._rows$i.item(this._ag.o)._cells$i.item(this._ag.m);
  }
  /**
   * Gets or sets the cell where the top-left corner of the shape resides.
   * <p class="body">
   * This anchor cell, along with the [[bottomRightCornerCell]], determines where the shape will be
   * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
   * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
   * </p>
   * The cell where the top-left corner of the shape resides.
   * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
   * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
   * @see [[bottomRightCornerCell]]
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerPosition]]
   */
  set topLeftCornerCell(a) {
    let b;
    let c = new WorksheetCellAddress();
    if (WorksheetCell.l_op_Equality(a, null) || a.worksheet == null) {
      b = null;
      c = WorksheetCellAddress.b;
    }
    else {
      b = a.worksheet;
      c = a._e;
    }
    if (b != this._w || WorksheetCellAddress.h(c, this._ag)) {
      this._df(a);
      let d;
      let e = ((() => { let f = this._dn(d); d = f.p0; return f.ret; })());
      let f = this._ag;
      this._w = b;
      this._ag = c;
      let g = this._cx(b, f, this._dk, this._ac, this._di, e, d);
      d = g.p6;
    }
  }
  /**
   * Gets or sets the position in the [[topLeftCornerCell]] of the shape's top-left corner,
   * expressed in percentages.
   * <p class="body">
   * These percentages are expressed as distance across the associated dimension of the cell, starting at the
   * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
   * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
   * in the cell which is centered horizontally, and a tenth of the way down from the top.
   * </p>
   * The position in the top-left corner cell of the shape's top-left corner.
   * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
   * @see [[bottomRightCornerCell]]
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerCell]]
   */
  get topLeftCornerPosition() {
    return pointToLiteral(this._topLeftCornerPosition$i);
  }
  /**
   * Gets or sets the position in the [[topLeftCornerCell]] of the shape's top-left corner,
   * expressed in percentages.
   * <p class="body">
   * These percentages are expressed as distance across the associated dimension of the cell, starting at the
   * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
   * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
   * in the cell which is centered horizontally, and a tenth of the way down from the top.
   * </p>
   * The position in the top-left corner cell of the shape's top-left corner.
   * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
   * @see [[bottomRightCornerCell]]
   * @see [[bottomRightCornerPosition]]
   * @see [[topLeftCornerCell]]
   */
  set topLeftCornerPosition(a) {
    arguments[0] = pointFromLiteral(arguments[0]);
    this._topLeftCornerPosition$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _topLeftCornerPosition$i() {
    return this._dk;
  }
  /**
   * @hidden
   */
  set _topLeftCornerPosition$i(a) {
    if (PointUtil.notEquals(this._dk, a)) {
      let b;
      let c = ((() => { let d = this._dn(b); b = d.p0; return d.ret; })());
      let d = this._dk;
      this._dk = a;
      let e = this._cx(this._w, this._ag, d, this._ac, this._di, c, b);
      b = e.p6;
    }
  }
  /**
   * Gets or sets the value indicating whether the shape is visible on the worksheet.
   * The value indicating whether the shape is visible on the worksheet.
   */
  get visible() {
    return this._bd;
  }
  /**
   * Gets or sets the value indicating whether the shape is visible on the worksheet.
   * The value indicating whether the shape is visible on the worksheet.
   */
  set visible(a) {
    let b = WorksheetShape._a[7].g(WorksheetShape.$, Boolean_$type, this, this._bd, a);
    this._bd = b.p1;
  }
  /**
   * Gets the worksheet on which the shape resides.
   * The worksheet on which the shape resides.
   */
  get_sheet() {
    if (this._an == null) {
      return null;
    }
    return this._an._g;
  }
  /**
   * Gets the worksheet on which the shape resides.
   * The worksheet on which the shape resides.
   */
  get sheet() {
    return this.get_sheet();
  }
  /**
   * Gets the worksheet on which the shape resides.
   * The worksheet on which the shape resides.
   */
  get worksheet() {
    return typeCast(Worksheet.$, this.sheet);
  }
  /**
   * @hidden
   */
  get _ad() {
    return this._ac;
  }
  /**
   * @hidden
   */
  get _af() {
    return this._ae;
  }
  /**
   * @hidden
   */
  get _v() {
    return this._u;
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e;
  }
  /**
   * @hidden
   */
  set _f(a) {
    this._e = a;
  }
  /**
   * @hidden
   */
  get__aq() {
    return true;
  }
  /**
   * @hidden
   */
  get _aq() {
    return this.get__aq();
  }
  /**
   * @hidden
   */
  get__ar() {
    return true;
  }
  /**
   * @hidden
   */
  get _ar() {
    return this.get__ar();
  }
  /**
   * @hidden
   */
  get__as() {
    return true;
  }
  /**
   * @hidden
   */
  get _as() {
    return this.get__as();
  }
  /**
   * @hidden
   */
  get _bi() {
    return this._bh;
  }
  /**
   * @hidden
   */
  set _bi(a) {
    if (this._bh == a) {
      return;
    }
    this._bh = a;
    this._cy();
  }
  /**
   * @hidden
   */
  get _a1() {
    return this._bh != null && this._bh.count > 0;
  }
  /**
   * @hidden
   */
  get _bk() {
    return this._bj;
  }
  /**
   * @hidden
   */
  set _bk(a) {
    this._bj = a;
  }
  /**
   * @hidden
   */
  get _a2() {
    return this._bj != null && this._bj.count > 0;
  }
  /**
   * @hidden
   */
  get _bm() {
    return this._bl;
  }
  /**
   * @hidden
   */
  set _bm(a) {
    this._bl = a;
  }
  /**
   * @hidden
   */
  get _a3() {
    return this._bl != null && this._bl.count > 0;
  }
  /**
   * @hidden
   */
  get _ao() {
    return this._an;
  }
  /**
   * @hidden
   */
  get__a4() {
    return true;
  }
  /**
   * @hidden
   */
  get _a4() {
    return this.get__a4();
  }
  /**
   * @hidden
   */
  get__a5() {
    return false;
  }
  /**
   * @hidden
   */
  get _a5() {
    return this.get__a5();
  }
  /**
   * @hidden
   */
  get _a7() {
    return this._an != null && this._an._p;
  }
  /**
   * @hidden
   */
  get__a8() {
    return this._an._q;
  }
  /**
   * @hidden
   */
  get _a8() {
    return this.get__a8();
  }
  /**
   * @hidden
   */
  get _h() {
    return this._g;
  }
  /**
   * @hidden
   */
  set _h(a) {
    this._g = a;
  }
  /**
   * @hidden
   */
  get _d() {
    if (this._an == null) {
      return null;
    }
    return this._an._f;
  }
  /**
   * @hidden
   */
  get _bb() {
    return this._ba;
  }
  /**
   * @hidden
   */
  get__cn() {
    return this._cm;
  }
  /**
   * @hidden
   */
  set__cn(a) {
    if (this._cm != a) {
      this._cm = a;
      if (this._e != null) {
        this._e.shapeId = a;
      }
    }
  }
  /**
   * @hidden
   */
  get _cn() {
    return this.get__cn();
  }
  /**
   * @hidden
   */
  set _cn(a) {
    this.set__cn(a);
  }
  /**
   * @hidden
   */
  get__ap() {
    return null;
  }
  /**
   * @hidden
   */
  get _ap() {
    return this.get__ap();
  }
  /**
   * @hidden
   */
  get _ah() {
    return this._ag;
  }
  /**
   * @hidden
   */
  get _aj() {
    return this._ai;
  }
  /**
   * @hidden
   */
  get _x() {
    return this._w;
  }
  /**
   * @hidden
   */
  get _cc() {
    return this._cb;
  }
  /**
   * @hidden
   */
  set _cc(a) {
    this._cb = a;
  }
  /**
   * @hidden
   */
  get _ce() {
    return this._cd;
  }
  /**
   * @hidden
   */
  set _ce(a) {
    this._cd = a;
  }
  /**
   * @hidden
   */
  get _bc() {
    return !nullableIsNull(this._b2) ? this._b2.value : this._a5;
  }
  /**
   * @hidden
   */
  set _bc(a) {
    this._b2 = Nullable$1.toNullable(Boolean_$type, a);
  }
  /**
   * @hidden
   */
  containsColumns(firstColumn, lastColumn) {
    return firstColumn >= this._ag.m && lastColumn <= this._ac.m;
  }
  /**
   * @hidden
   */
  intersectsWithColumns(firstColumn, lastColumn) {
    return firstColumn <= this._ac.m && lastColumn >= this._ag.m;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this.sheet != null ? this.sheet.workbook : null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
WorksheetShape.$t = markType(WorksheetShape, 'WorksheetShape', Base.$, [IRegionAddress_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
WorksheetShape._bo = 0;
/**
 * @hidden
 */
WorksheetShape._bq = 1;
/**
 * @hidden
 */
WorksheetShape._br = 2;
/**
 * @hidden
 */
WorksheetShape._bs = 3;
/**
 * @hidden
 */
WorksheetShape._bu = 4;
/**
 * @hidden
 */
WorksheetShape._bv = 5;
/**
 * @hidden
 */
WorksheetShape._bw = 6;
/**
 * @hidden
 */
WorksheetShape._bx = 7;
/**
 * @hidden
 */
WorksheetShape._bp = 8;
/**
 * @hidden
 */
WorksheetShape._bt = 9;
/**
 * @hidden
 */
WorksheetShape._cf = 131072;
/**
 * @hidden
 */
WorksheetShape._cg = 2;
/**
 * @hidden
 */
WorksheetShape._ch = 1048576;
/**
 * @hidden
 */
WorksheetShape._ci = 16;
/**
 * @hidden
 */
WorksheetShape._ck = 524288;
/**
 * @hidden
 */
WorksheetShape._cj = 1048592;
/**
 * @hidden
 */
WorksheetShape._cl = 8;
/**
 * @hidden
 */
WorksheetShape._a = null;
/**
 * @hidden
 */
WorksheetShape._bf = null;
/**
 * @hidden
 */
WorksheetShape._bg = null;
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export class WorksheetShapeGroupBase extends WorksheetShape {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(0);
          this._dw = null;
          this._dy = false;
          this._d1 = true;
          this._d0 = true;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(0);
            this._dw = null;
            this._dy = false;
            this._d1 = true;
            this._d0 = true;
          }
          this._dy = c;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super(2, c);
          this._dw = null;
          this._dy = false;
          this._d1 = true;
          this._d0 = true;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitWorksheetShapeGroup$i(this, b);
  }
  /**
   * @hidden
   */
  get__ar() {
    return false;
  }
  /**
   * @hidden
   */
  get__as() {
    return false;
  }
  /**
   * @hidden
   */
  get__a4() {
    return false;
  }
  /**
   * @hidden
   */
  _ct(a) {
    if (a != null && a == this._dw) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentOutOfRangeException_GroupAddedToSelf"));
    }
    if (this._dw != null) {
      for (let b of fromEnum(this._dw)) {
        if (b._ao == null) {
          b._ct(this._dw);
        }
      }
    }
    super._ct(a);
  }
  /**
   * @hidden
   */
  _cv() {
    super._cv();
    for (let a of fromEnum(this._shapes$i)) {
      a._cv();
    }
  }
  /**
   * @hidden
   */
  _cw(a, b, c, d, e, f) {
    if (this._d1 && !f && a != null && this._ah.e && this._ad.e && b.e && d.e) {
      try {
        this._d0 = false;
        let g = WorksheetShape._ds(a, b, c, d, e);
        let h = this._getBoundsInTwips();
        if (Rect.l_op_Inequality(g, h)) {
          let i = g.width == 0 ? 1 : truncate(h.width) / g.width;
          let j = g.height == 0 ? 1 : truncate(h.height) / g.height;
          for (let k of fromEnum(this._shapes$i)) {
            let l = k._getBoundsInTwips();
            let m = l;
            let n = ExcelUtils.fs(m, -g.x, -g.y);
            m = n.p0;
            k._setBoundsInTwips(a, new Rect(0, truncate((m.left * i)) + h.left, truncate((m.top * j)) + h.top, truncate((m.width * i)), truncate((m.height * j))));
          }
        }
      }
      finally {
        this._d0 = true;
      }
    }
    super._cw(a, b, c, d, e, f);
  }
  /**
   * @hidden
   */
  _cz() {
    super._cz();
    if (this._dw == null) {
      return;
    }
    for (let a of fromEnum(this._dw)) {
      a._cz();
    }
  }
  /**
   * @hidden
   */
  _c0(a) {
    super._c0(a);
    if (this._dw == null) {
      return;
    }
    for (let b of fromEnum(this._dw)) {
      b._c0(a);
    }
  }
  /**
   * @hidden
   */
  get__ap() {
    return this._shapes$i;
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 0);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, null);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
  /**
   * @hidden
   */
  get areChildrenTopMost() {
    if (this._dw != null && this._dw.count == 1) {
      return this._a8;
    }
    return false;
  }
  /**
   * @hidden
   */
  onChildShapeBoundsChanged(childShape, oldTopLeftCell, oldBottomRightCell, isNotifyOnly) {
    if (this._d0 == false || isNotifyOnly) {
      return;
    }
    this._d4();
  }
  /**
   * @hidden
   */
  onShapeAdded(shape) {
    this._d4();
  }
  /**
   * @hidden
   */
  onShapeRemoved(shape) {
    this._d4();
  }
  /**
   * @hidden
   */
  _dv(a, b) {
    return {
      ret: ((() => { let c = Worksheet._c9(this._dw, a, b); b = c.p2; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  _d2(a) {
    Worksheet._hm(this._dw, a);
  }
  /**
   * @hidden
   */
  _d3() {
    this._dy = false;
  }
  /**
   * @hidden
   */
  _d4() {
    if (this._dy) {
      return;
    }
    if (typeCast(WorksheetChart.$, this) !== null) {
      return;
    }
    let a = this.worksheet;
    let b = this._shapes$i.count;
    let c = b > 0 ? 0x7FFFFFFF : 0;
    let d = b > 0 ? 0x7FFFFFFF : 0;
    let e = 0;
    let f = 0;
    let g = 100;
    let h = 100;
    let i = b > 0 ? 0 : g;
    let j = b > 0 ? 0 : h;
    for (let k of fromEnum(this._shapes$i)) {
      let l = k._x;
      let m = k._ah;
      let n = k._v;
      let o = k._ad;
      if (l == null || n == null || !m.e || !o.e) {
        continue;
      }
      if (a == null) {
        a = l;
      }
      let p = k._topLeftCornerPosition$i;
      let q = k._bottomRightCornerPosition$i;
      let r = WorksheetShapeGroupBase._d6(c, g, m, p);
      c = r.p0;
      g = r.p1;
      let s = WorksheetShapeGroupBase._d6(c, g, o, q);
      c = s.p0;
      g = s.p1;
      let t = WorksheetShapeGroupBase._d8(d, h, m, p);
      d = t.p0;
      h = t.p1;
      let u = WorksheetShapeGroupBase._d8(d, h, o, q);
      d = u.p0;
      h = u.p1;
      let v = WorksheetShapeGroupBase._d7(e, i, m, p);
      e = v.p0;
      i = v.p1;
      let w = WorksheetShapeGroupBase._d7(e, i, o, q);
      e = w.p0;
      i = w.p1;
      let x = WorksheetShapeGroupBase._d5(f, j, m, p);
      f = x.p0;
      j = x.p1;
      let y = WorksheetShapeGroupBase._d5(f, j, o, q);
      f = y.p0;
      j = y.p1;
    }
    let z = this._d1;
    try {
      this._d1 = false;
      this._c5(a, new WorksheetCellAddress(1, d, c), { $type: Point_$type, x: g, y: h }, new WorksheetCellAddress(1, f, e), { $type: Point_$type, x: i, y: j });
    }
    finally {
      this._d1 = z;
    }
  }
  /**
   * @hidden
   */
  static _d5(a, b, c, d) {
    let e = c.o;
    if (e == a) {
      b = Math.max(d.y, b);
    }
    else if (a < e) {
      a = e;
      b = d.y;
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _d6(a, b, c, d) {
    if (c.m == a) {
      b = Math.min(d.x, b);
    }
    else if (c.m < a) {
      a = c.m;
      b = d.x;
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _d7(a, b, c, d) {
    if (c.m == a) {
      b = Math.max(d.x, b);
    }
    else if (a < c.m) {
      a = c.m;
      b = d.x;
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _d8(a, b, c, d) {
    let e = c.o;
    if (e == a) {
      b = Math.min(d.y, b);
    }
    else if (e < a) {
      a = e;
      b = d.y;
    }
    return {
      p0: a,
      p1: b
    };
  }
  shapes() {
    if (arguments.length !== 0) {
      let a = this._shapes$i;
      return a.item.apply(a, arguments);
    }
    return this._shapes$i;
  }
  /**
   * @hidden
   */
  get _shapes$i() {
    if (this._dw == null) {
      this._dw = new WorksheetShapeCollection(this);
    }
    return this._dw;
  }
  /**
   * @hidden
   */
  get ChildShapes() {
    return this._shapes$i;
  }
  /**
   * @hidden
   */
  get _dz() {
    return this._dy;
  }
}
WorksheetShapeGroupBase.$t = markType(WorksheetShapeGroupBase, 'WorksheetShapeGroupBase', WorksheetShape.$, [IWorksheetShapeOwner_$type]);
/**
 * @hidden
 */
export let IFormattedStringOwner_$type = new Type(null, 'IFormattedStringOwner', null, [ISheetProvider_$type]);
/**
 * Base class for objects which relate to the background fill of a chart element.
 */
export class ChartFillBase extends ChartObject {
  constructor(a) {
    super(a);
  }
}
ChartFillBase.$t = markType(ChartFillBase, 'ChartFillBase', ChartObject.$);
/**
 * Represents a <see cref="ChartBorder">border</see> or
 * <see cref="ChartTickLines">tick line</see>.
 */
export class ChartLineBase extends ChartObject {
  constructor(a) {
    super(a);
    this._aa = null;
    this._ac = 0.75;
  }
  static staticInit() {
    ChartLineBase._w = ChartLineBase._x();
  }
  /**
   * @hidden
   */
  _a(a) {
    return ChartLineBase._w[a];
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill color/gradient for the line.
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fill() {
    return this._aa;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill color/gradient for the line.
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fill(a) {
    if (a != this._aa) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._aa != null) {
        this._aa._l(null);
      }
      let b = this._r(ChartLineBase.$, ChartFillBase.$, this, 0, this._aa, a);
      this._aa = b.p2;
    }
  }
  /**
   * Determines the width of the line, expressed in points.
   * <p class="body">
   * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
   * </p>
   */
  get widthInPoints() {
    return this._ac;
  }
  /**
   * Determines the width of the line, expressed in points.
   * <p class="body">
   * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
   * </p>
   */
  set widthInPoints(a) {
    if (a != this._ac) {
      let b = this._r(ChartLineBase.$, Number_$type, this, 1, this._ac, a);
      this._ac = b.p2;
    }
  }
  /**
   * @hidden
   */
  get__ai() {
    return Nullable$1.toNullable(LineStyle_$type, null);
  }
  /**
   * @hidden
   */
  get _ai() {
    return this.get__ai();
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartLineBase.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartBorder.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, ChartLineBase._z(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 1, ChartLineBase._z(Number_$type, "WidthInPoints", 7, (b) => b.widthInPoints, (b, c) => b.widthInPoints = c));
    return a;
  }
  /**
   * @hidden
   */
  _aj(a) {
    this._ac = a;
  }
}
ChartLineBase.$t = markType(ChartLineBase, 'ChartLineBase', ChartObject.$);
/**
 * @hidden
 */
ChartLineBase._af = 0;
/**
 * @hidden
 */
ChartLineBase._ah = 1;
/**
 * @hidden
 */
ChartLineBase._ag = 2;
/**
 * @hidden
 */
ChartLineBase._ad = 0.75;
/**
 * @hidden
 */
ChartLineBase._w = null;
/**
 * Represents the border of a chart element.
 * <p class="body">
 * The color of the border is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the border lines are controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export class ChartBorder extends ChartLineBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(null);
          this._an = 7;
        }
        break;
      case 1:
        {
          let owner = _rest[0];
          super(owner);
          this._an = 7;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  static staticInit() {
    ChartBorder._ak = ChartBorder._al();
  }
  /**
   * Returns or sets the line style for the border, i.e.,
   * solid, dashed, dotted, etc.
   */
  get lineStyle() {
    return this._an;
  }
  /**
   * Returns or sets the line style for the border, i.e.,
   * solid, dashed, dotted, etc.
   */
  set lineStyle(a) {
    if (a != this._an) {
      let b = this._q(ChartBorder.$, BorderLineStyle_$type, this, 2, this._an, a);
      this._an = b.p2;
    }
  }
  /**
   * @hidden
   */
  get__ai() {
    return Nullable$1.toNullable(LineStyle_$type, this.lineStyle);
  }
  /**
   * @hidden
   */
  get _ap() {
    if (this.fill != null) {
      return this.fill;
    }
    let a = this.chart;
    return a != null ? a._eq : new ChartEmptyFill();
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 2) {
      return super._a(a);
    }
    return ChartBorder._ak[a - 2];
  }
  /**
   * @hidden
   */
  static _am($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartBorder.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _al() {
    let a = 2;
    let b = new Array(3 - a);
    ChangeInfo.f(b, 2 - a, ChartBorder._am(BorderLineStyle_$type, "LineStyle", 7, (c) => c.lineStyle, (c, d) => c.lineStyle = d));
    return b;
  }
}
ChartBorder.$t = markType(ChartBorder, 'ChartBorder', ChartLineBase.$);
/**
 * @hidden
 */
ChartBorder._aq = 2;
/**
 * @hidden
 */
ChartBorder._ar = 2 + 1;
/**
 * @hidden
 */
ChartBorder._ak = null;
/**
 * @hidden
 */
export class Formula_TokensReplacedChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = null;
    this.b = null;
    this.a = null;
    this.d = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.c = c;
          this.b = d;
          this.a = e;
          this.d = c._as;
        }
        break;
    }
  }
  e() {
    for (let a = 0; a < this.b.length; a++) {
      this.c._d[this.a[a]] = this.b[a];
    }
    this.c._b1();
  }
  get workbook() {
    return this.c._y;
  }
  get sheet() {
    return this.c._t;
  }
  get source() {
    return this.c._t;
  }
}
Formula_TokensReplacedChangeContext.$t = markStruct(Formula_TokensReplacedChangeContext, 'Formula_TokensReplacedChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a formula for a cell or group of cells.
 * <p class="body">
 * Formulas provide a way to show dynamic values in a cell. The value could be based any number of factors, such as
 * the values of other cells and the time of day.  Those alternate cells can even exist in different workbook files
 * on the user's machine or on the internet.
 * </p>
 * <p class="body">
 * See Microsoft Excel help for more information on formulas.
 * </p>
 * <p class="body">
 * Use one of the Parse or TryParse overloads to create a new formula.
 * </p>
 */
export class Formula extends Base {
  constructor(a, ..._rest) {
    super();
    this._a8 = 0;
    this._q = 0;
    this._a9 = 0;
    /**
     * @hidden
     */
    this._d = null;
    this._r = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          this._a8 = c;
          this._d = FormulaToken.a;
          this._r = d;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c._a8, 0];
          {
            let f = d[0];
            let g = d[1];
            this._a8 = f;
            this._d = FormulaToken.a;
            this._r = g;
          }
          this._d = [new ExpToken(1, c.cellRange._v, c.cellRange.firstRow)];
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = [c.worksheet.workbook.cellReferenceMode, 0];
          {
            let f = d[0];
            let g = d[1];
            this._a8 = f;
            this._d = FormulaToken.a;
            this._r = g;
          }
          let e = c.cellsInTable;
          this._d = [new TblToken(1, (e._v + 1), e.firstRow + 1)];
        }
        break;
      case 3:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c._a8, c._r];
          {
            let g = e[0];
            let h = e[1];
            this._a8 = g;
            this._d = FormulaToken.a;
            this._r = h;
          }
          let f = d == false && c._as;
          if (f) {
            c._cb();
          }
          this._a9 = c._a9;
          this._q = c._q;
          if (f) {
            this._d = c._d;
            return;
          }
          this._d = new Array(c._d.length);
          for (let g = 0; g < this._d.length; g++) {
            let h = c._d[g];
            let i = h.d(FormulaToken.$, CloneTokenVisitor.a2);
            this._d[g] = i;
          }
        }
        break;
    }
  }
  static staticInit() {
    Formula._a = Formula._b();
  }
  toString() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    else if (arguments.length === 2) {
      n = 2;
    }
    switch (n) {
      case 0: return this._toString.apply(this, arguments);
      case 1: return this._toString1.apply(this, arguments);
      case 2:
        arguments[1] = typeof arguments[1] === 'string' ? new CultureInfo(arguments[1]) : arguments[1];
        return this._toString2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toString() {
    return this._toString1(this._a8);
  }
  applyTo() {
    let n;
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        n = 0;
      }
      else if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._applyTo.apply(this, arguments);
      case 1: return this._applyTo2.apply(this, arguments);
      case 2: return this._applyTo3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyTo2(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    this._bp(a._o, a._ab);
  }
  /**
   * @hidden
   */
  _bp(a, b, c = 0) {
    a.worksheet._jc(this, a, b);
    let d = typeCast(IRegionBlockingSingleCellComponent_$type, a._c6(b));
    if (d != null) {
      let e = d.owningValue.blockedRegion;
      if (e.firstRow != e.lastRow || e.firstColumn != e.lastColumn) {
        d.owningValue.throwBlockingException();
      }
    }
    let f = null;
    if (this._ai) {
      f = a.worksheet._g4(5);
    }
    this._bq(a, b, a, b, c);
    a.worksheet._h4(f);
  }
  /**
   * @hidden
   */
  _applyTo3(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    this._applyTo([a]);
  }
  /**
   * @hidden
   */
  _applyTo(a) {
    this._bm(a, null, -1);
  }
  /**
   * @hidden
   */
  _toString1(a) {
    return this._toString2(a, this._ba);
  }
  /**
   * @hidden
   */
  _toString2(a, b) {
    return this._bk(a, b);
  }
  /**
   * @hidden
   */
  _bq(a, b, c, d, e = 0) {
    let f = c._a1(d);
    let g = typeCast(IRegionBlockingSingleCellComponent_$type, f.aa(c, d));
    if (g != null) {
      g.owningValue.removeFromRegion();
    }
    let h = this;
    if (this._ab != null || (a != null && (d != b || c.index != a.index))) {
      h = h._g();
    }
    let i = c.worksheet.workbook;
    if (this._as == false && a != null) {
      let j = { $type: Point_$type, x: d - b, y: c.index - a.index };
      h._bw(i, c, d, j);
    }
    if (this._z != i.currentFormat) {
      let k = i._an();
      let l = i != null ? i.cellReferenceMode : 1;
      h._ca(i, k, i.currentFormat, l, true, c, d);
      if (k.d) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FormulaReferencesInvalidCells"));
      }
    }
    h._br(c, d, f);
    let m = h._y != null && h._y._c4;
    if (m == false && h._ai) {
      WorksheetHyperlink._at(new WorksheetRegion(c.worksheet, c.index, d, c.index, d));
    }
    if (m == false && (e & 1) == 0 && ExcelUtils.bx(c._a7(d)._bz, 1) == false) {
      let n = c._as(d)._formula;
      if (n != null) {
        for (let o of fromEnum(n)) {
          let p = o;
          let q;
          let r = typeCast(CellCalcReference.$, p);
          if (r != null) {
            if (r._t != n._ch._t) {
              continue;
            }
            q = r._w._a7(r._ao)._dg;
          }
          else {
            let s = p._am();
            if (s == null || s.count == 0 || s.item(0).worksheet.workbook != n._ch._t) {
              continue;
            }
            let t = s.item(0);
            q = t._k._a7(t._v)._dg;
          }
          if (stringEquals1(q, "General", StringUtilities.g)) {
            continue;
          }
          c.getCellFormat(d).formatString = q;
          break;
        }
      }
    }
  }
  /**
   * @hidden
   */
  _bm(a, b, c, d = 0) {
    if (a == null) {
      throw new ArgumentNullException(0, "regions");
    }
    if (a.length == 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NoRegionsInArray"), "regions");
    }
    if (b != null) {
      let e = false;
      for (let f = 0; f < a.length; f++) {
        if (a[f]._p(b, c)) {
          e = true;
          break;
        }
      }
      if (!e) {
        throw new InvalidOperationException(0);
      }
    }
    else {
    }
    let g = a[0].worksheet;
    for (let h = 1; h < a.length; h++) {
      if (a[h].worksheet == null) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionsShiftedOffWorksheet"), "regions");
      }
      if (a[h].worksheet != g) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionsFromMixedWorksheets"), "regions");
      }
    }
    ExcelUtils.gf(a);
    let i = null;
    if (this._ai || a.length > 1 || a[0]._u == false) {
      i = g._g4(5);
    }
    for (let j = 0; j < a.length; j++) {
      let k = a[j]._aj(this, b, c, d);
      b = k.p1;
      c = k.p2;
    }
    g._h4(i);
  }
  /**
   * @hidden
   */
  _br(a, b, c) {
    let d;
    let e = c.ao(a, b, this, d, false);
    d = e.p3;
    c = d || c;
  }
  /**
   * @hidden
   */
  _ad(a, b, c, d) {
    let e = b == null ? null : b.worksheet;
    let f = new FormulaContext(3, a, e, b, c, this);
    return Formula_CanShiftSafelyChecker.a2(f, d);
  }
  /**
   * @hidden
   */
  _b6(a) {
    this._b5(new FormulaContext(1, a, this));
  }
  /**
   * @hidden
   */
  _b5(a) {
    let b = this._i;
    if (b != this) {
      b._b5(new FormulaContext(3, a.f, a.j, a.m, a.l.m, b));
    }
    else {
      let c = Formula_ConnectReferencesVisitor.a9(a, true);
      this._au(c);
    }
    this._al = true;
  }
  /**
   * @hidden
   */
  get__i() {
    return this;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * @hidden
   */
  _bs(a, b) {
    let c = new FormulaContext(1, a, this);
    this._au(Formula_ConvertTableReferencesToRangesVisitor.a9(c, b));
  }
  /**
   * @hidden
   */
  _bt(a) {
    let b = new FormulaContext(1, a, this);
    let c = SharedTokenConverter.a3(b, false);
    let d = new Array(this._d.length);
    for (let e = 0; e < this._d.length; e++) {
      d[e] = this._d[e].d(FormulaToken.$, CloneTokenVisitor.a2).d(FormulaToken.$, c);
    }
    c.a1();
    this._d = d;
    this._r = 0;
  }
  /**
   * @hidden
   */
  static _u(a, b) {
    let c = new SingleTargetFormula(0, a._a8, 0);
    c._d = [new ExpToken(1, b._ab, b.rowIndex)];
    return c;
  }
  /**
   * @hidden
   */
  _bu() {
    if (this._al == false) {
      return;
    }
    let a = Formula_ConnectReferencesVisitor.a9(new FormulaContext(1, this._y, this), false);
    this._au(a);
    this._al = false;
  }
  /**
   * @hidden
   */
  _ae() {
    for (let a = 0; a < this._d.length; a++) {
      let b = typeCast(ReferenceToken.$, this._d[a]);
      if (b != null) {
        if (b.r) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _af() {
    for (let a = 0; a < this._d.length; a++) {
      let b = typeCast(CellReferenceToken.$, this._d[a]);
      if (b != null && b.p) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _c(a, b) {
    let c = new FormulaContext(1, a, this);
    return Formula_AllReferencedRegionsChecker.az(c, b);
  }
  /**
   * @hidden
   */
  _bv(a, b, c, d, e, f) {
    let g = new FormulaContext(3, c.workbook, c, null, -1, this);
    this._au(Formula_FixPasteReferencesVisitor.ba(a, b, g, d, e, f));
  }
  /**
   * @hidden
   */
  _ao(a) {
    if (this._e.length != a._e.length) {
      return false;
    }
    switch (this._s) {
      case 0:
      case 2:
      case 5:
      case 6:
        {
          switch (a._r) {
            case 0:
            case 2:
            case 5:
            case 6: break;
            default: return false;
          }
          break;
        }
      default:
        {
          if (this._s != a._s) {
            return false;
          }
          break;
        }
    }
    let b = new FormulaContext(1, this._y, this);
    let c = new FormulaContext(1, a._y, a);
    for (let d = 0; d < this._e.length; d++) {
      let e = this._e[d];
      let f = a._e[d];
      if (e.j(b, f, c) == false) {
        return false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _ar(a, b, c) {
    let d = new FormulaContext(1, a, this);
    return Formula_IsReferencingAnythingInRegionChecker.a4(d, b, c);
  }
  /**
   * @hidden
   */
  _bw(a, b, c, d) {
    if (this._as == false && PointUtil.notEquals(d, ExcelUtils.g7)) {
      let e = b == null ? null : b.worksheet;
      let f = new FormulaContext(3, a, e, b, c, this);
      this._au(Formula_OffsetReferencesVisitor.a9(f, d));
    }
  }
  /**
   * @hidden
   */
  _av(a, b, c) {
    if (a != null && a.type != 0) {
      let d = this._aa;
      let e = new FormulaContext(4, a, d.o, d.m, this._z, this, null, 1);
      return this._au(Formula_CellsShiftedVisitor.ba(e, b, c));
    }
    let f = a;
    let g = this._bb;
    let h = -1;
    if (this._ab != null) {
      if (this._ab.worksheet == b.h) {
        let i = b.i(new WorksheetCellAddress(1, this._ab.index, this._bb));
        g = i.m;
        h = i.o;
      }
      else {
        h = this._ab.index;
      }
    }
    let j = new FormulaContext(4, f, h, g, this._z, this, null, 1);
    return this._au(Formula_CellsShiftedVisitor.ba(j, b, c));
  }
  /**
   * @hidden
   */
  _bx(a, b) {
    this._z = a.currentFormat;
    let c = Formula_CurrentFormatChangedVisitor.a0(new FormulaContext(1, a, this), b, a.currentFormat);
    c.h();
  }
  /**
   * @hidden
   */
  _by(a) {
    let b = new FormulaContext(1, this._y, this);
    this._au(Formula_NamedReferenceRemovedVisitor.ba(b, a));
  }
  /**
   * @hidden
   */
  _b0() {
    this._b7();
  }
  /**
   * @hidden
   */
  _aw(a, b) {
    let c = new FormulaContext(1, a._k, this);
    let d = Formula_TableResizingVisitor.a9(c, a, b);
    if (d.ax() == false) {
      return false;
    }
    if (d.bc == false) {
      return false;
    }
    return true;
  }
  /**
   * @hidden
   */
  _bz(a, b) {
    for (let c = 0; c < this._d.length; c++) {
      let d = typeCast(StructuredTableReference.$, this._d[c]);
      if (d != null) {
        d.ai(a, b);
      }
    }
  }
  /**
   * @hidden
   */
  _b2(a, b) {
    Formula._a[0].x(new Formula_TokensReplacedChangeContext(1, this, a, b), null, null);
  }
  /**
   * @hidden
   */
  _b3(a, b) {
    let c = new FormulaContext(1, a.workbook, this);
    this._au(Formula_WorksheetMovedVisitor.a9(c, a, b));
  }
  /**
   * @hidden
   */
  _b4(a, b) {
    let c = new FormulaContext(1, this._y, this);
    this._au(Formula_WorksheetRemovedVisitor.a9(c, a, b));
  }
  /**
   * @hidden
   */
  _b9(a) {
    this._e = a;
    this._b1();
  }
  /**
   * @hidden
   */
  _v(a, b, c, d) {
    if (this._as == d) {
      return this;
    }
    let e = new SingleTargetFormula(0, this._a8, d ? 2 : 0);
    e._a9 = this._a9;
    e._q = this._q;
    let f = new FormulaContext(4, this._t, a, b, c, e, null, 1);
    let g = SharedTokenConverter.a3(f, d);
    e._d = new Array(this._d.length);
    for (let h = 0; h < e._e.length; h++) {
      e._d[h] = this._d[h].d(FormulaToken.$, g);
    }
    g.a1();
    return e;
  }
  /**
   * @hidden
   */
  _w(a, b, c) {
    return this._v(a, b, c, false);
  }
  /**
   * @hidden
   */
  _x(a, b, c) {
    return this._v(a, b, c, true);
  }
  /**
   * @hidden
   */
  _ca(a, b, c, d, e, f = null, g = -1) {
    this._bs(a, null);
    let h = this._t;
    let i = h != null && h.type == 0 ? h : null;
    let j = new FormulaContext(5, a, i, f || this._ab, g < 0 ? this._bb : g, this, this._ba, d, a.currentFormat);
    let k = Formula_VerifyFormatLimitsVisitor.a1(j, b, c);
    k.h();
    if (e && this._d.length != 0) {
      let l = FormulaStringGenerator.bj(j);
      let m = l.a2();
      let n = m.b;
      let o;
      let p;
      if (((() => { let q = Formula._a4(n, d, c, j.o, p, o); p = q.p4; o = q.p5; return q.ret; })()) == false) {
        b.g(ExcelUtils.ef("LE_InvalidOperationException_InvalidForWorkbookFormat"));
      }
    }
  }
  /**
   * @hidden
   */
  _cb() {
    if (this._ac) {
      return;
    }
    if (this._aq == false) {
      let a = TokenReferenceResolver.bj(new FormulaContext(1, this._y, this));
      let b = a.a2();
    }
    this._ac = true;
  }
  /**
   * @hidden
   */
  static _h(a, b) {
    let c = a;
    switch (b) {
      case 1: return new ArrayFormula(0, c);
      case 3:
      case 4: return new NamedReferenceFormula(0, c, b);
      default: return new SingleTargetFormula(0, c, b);
    }
  }
  /**
   * Determines whether two [[Formula]] instances are equal using the specified cell reference mode.
   * This essentially performs a case-insensitive string comparison, ignoring the white space in the formula.
   * @param formulaA The first Formula to compare.
   * @param formulaB The second Formula to compare.
   * @param cellReferenceMode The cell reference mode to use when comparing the two formulas.
   * @return True if the formulas are both null or both equivalent; False otherwise.
   */
  static areEqual(formulaA, formulaB, cellReferenceMode) {
    if (formulaA == null && formulaB == null) {
      return true;
    }
    if ((formulaA == null) != (formulaB == null)) {
      return false;
    }
    if (formulaA == formulaB) {
      return true;
    }
    if (getInstanceType(formulaA) != getInstanceType(formulaB)) {
      return false;
    }
    let a = FormulaStringGenerator.bl(new FormulaContext(2, formulaA, cellReferenceMode, CultureInfo.invariantCulture), true);
    let b = a.a2();
    let c = FormulaStringGenerator.bl(new FormulaContext(2, formulaB, cellReferenceMode, CultureInfo.invariantCulture), true);
    let d = c.a2();
    return stringCompare1(b.b, d.b, StringUtilities.g) == 0;
  }
  /**
   * @hidden
   */
  static _p(a, b, c = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    let d;
    let e;
    let f;
    let g = Workbook._hl(b, d, e, f);
    d = g.p1;
    e = g.p2;
    f = g.p3;
    return Formula._parse3(a, !nullableIsNull(c) ? c.value : d, e, f);
  }
  static parse() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      if (typeof arguments[2] === 'string' || typeCast(CultureInfo.$, arguments[2]) !== null) {
        n = 3;
      }
      else if (typeof arguments[2] === 'number') {
        n = 1;
      }
      else if (arguments[2] == null) {
        n = 3;
      }
    }
    else if (arguments.length === 4) {
      n = 2;
    }
    switch (n) {
      case 0: return Formula._parse.apply(null, arguments);
      case 1: return Formula._parse2.apply(null, arguments);
      case 2:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return Formula._parse3.apply(null, arguments);
      case 3:
        arguments[2] = typeof arguments[2] === 'string' ? new CultureInfo(arguments[2]) : arguments[2];
        return Formula._parse4.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _parse(a, b) {
    return Formula._parse4(a, b, ExcelUtils.cq);
  }
  /**
   * @hidden
   */
  static _parse4(a, b, c) {
    return Formula._parse3(a, b, 2, c);
  }
  /**
   * @hidden
   */
  static _parse2(a, b, c) {
    return Formula._parse3(a, b, c, ExcelUtils.cq);
  }
  /**
   * @hidden
   */
  static _parse3(a, b, c, d) {
    return Formula._k(a, b, 0, c, d, null);
  }
  /**
   * @hidden
   */
  static _k(a, b, c, d, e, f) {
    let g;
    let h;
    if (((() => { let i = Formula._a0(a, b, c, d, e, f, g, h); g = i.p6; h = i.p7; return i.ret; })())) {
      return g;
    }
    throw h;
  }
  /**
   * @hidden
   */
  static _o(a, b, c, d) {
    let e;
    let f;
    if (((() => { let g = Formula._a7(a, b, c, d, e, f); e = g.p4; f = g.p5; return g.ret; })())) {
      return e;
    }
    throw f;
  }
  /**
   * @hidden
   */
  static _ay(a, b, c) {
    return {
      ret: ((() => { let d = Formula._a5(a, b, ExcelUtils.cq, c); c = d.p3; return d.ret; })()),
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _a5(a, b, c, d) {
    return {
      ret: ((() => { let e = Formula._a3(a, b, 2, c, d); d = e.p4; return e.ret; })()),
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _az(a, b, c, d) {
    return {
      ret: ((() => { let e = Formula._a6(a, b, ExcelUtils.cq, c, d); c = e.p3; d = e.p4; return e.ret; })()),
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _a6(a, b, c, d, e) {
    return {
      ret: ((() => { let f = Formula._a4(a, b, 2, c, d, e); d = f.p4; e = f.p5; return f.ret; })()),
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _a1(a, b, c, d) {
    return {
      ret: ((() => { let e = Formula._a3(a, b, c, ExcelUtils.cq, d); d = e.p4; return e.ret; })()),
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _a3(a, b, c, d, e) {
    let f;
    return {
      ret: ((() => { let g = Formula._a4(a, b, c, d, e, f); e = g.p4; f = g.p5; return g.ret; })()),
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _a2(a, b, c, d, e) {
    return {
      ret: ((() => { let f = Formula._a4(a, b, c, ExcelUtils.cq, d, e); d = f.p4; e = f.p5; return f.ret; })()),
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _a4(a, b, c, d, e, f) {
    return {
      ret: ((() => { let g = Formula._a0(a, b, 0, c, d, null, e, f); e = g.p6; f = g.p7; return g.ret; })()),
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  static _a0(a, b, c, d, e, f, g, h) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, "value", "The formula string cannot be null.");
    }
    if (ExcelUtils.ax(b) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", b, CellReferenceMode_$type);
    }
    if (ExcelUtils.bk(d) == false) {
      throw new InvalidEnumArgumentException("fileFormat", d, WorkbookFormat_$type);
    }
    try {
      g = ((() => { let i = FormulaParser.d(a, b, c, d, e, f, h); h = i.p6; return i.ret; })());
    }
    catch (i) {
      h = new FormulaParseException(i.message, i);
      g = null;
    }
    return {
      ret: g != null,
      p6: g,
      p7: h
    };
  }
  /**
   * @hidden
   */
  static _a7(a, b, c, d, e, f) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, "value", "The formula string cannot be null.");
    }
    e = ((() => { let g = FormulaParser.f(a, b, c, d, f); f = g.p4; return g.ret; })());
    return {
      ret: e != null,
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  static _f($tChangeContext, $tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2($tChangeContext, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, Formula._f(Formula_TokensReplacedChangeContext.$, Base.$, "TokenReplaced", 46, (b) => null, (b, c) => b.e(), void 0, void 0, false, 0));
    return a;
  }
  /**
   * @hidden
   */
  _ah(a) {
    return (this._q & a) == a;
  }
  /**
   * @hidden
   */
  _au(a) {
    if (a.ax() == false) {
    }
    if (a.a5) {
      this._b1();
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _b1() {
    this._b7();
  }
  /**
   * @hidden
   */
  _b8(a, b) {
    if (b) {
      this._q |= a;
    }
    else {
      this._q &= ~a;
    }
  }
  /**
   * @hidden
   */
  _bk(a, b) {
    if (this._d.length == 0) {
      return stringEmpty();
    }
    let c = new FormulaContext(2, this, a, b);
    let d = FormulaStringGenerator.bj(c);
    let e = d.a2();
    return e.b;
  }
  /**
   * @hidden
   */
  get _ac() {
    return this._ah(2);
  }
  /**
   * @hidden
   */
  set _ac(a) {
    this._b8(2, a);
  }
  /**
   * @hidden
   */
  get _ba() {
    if (this._ab != null) {
      return this._ab.worksheet._y;
    }
    if (this._t != null) {
      return this._t._y;
    }
    return ExcelUtils.cq;
  }
  /**
   * @hidden
   */
  get__z() {
    return this._a9;
  }
  /**
   * @hidden
   */
  set__z(a) {
    this._a9 = a;
  }
  /**
   * @hidden
   */
  get _z() {
    return this.get__z();
  }
  /**
   * @hidden
   */
  set _z(a) {
    this.set__z(a);
  }
  /**
   * @hidden
   */
  get _ai() {
    return this._ah(4);
  }
  /**
   * @hidden
   */
  set _ai(a) {
    this._b8(4, a);
  }
  /**
   * @hidden
   */
  get _aj() {
    return this._ah(64);
  }
  /**
   * @hidden
   */
  set _aj(a) {
    this._b8(64, a);
  }
  /**
   * @hidden
   */
  get _al() {
    return this._ah(8);
  }
  /**
   * @hidden
   */
  set _al(a) {
    this._b8(8, a);
  }
  /**
   * @hidden
   */
  get__am() {
    return false;
  }
  /**
   * @hidden
   */
  get _am() {
    return this.get__am();
  }
  /**
   * @hidden
   */
  get _an() {
    return this._ah(16);
  }
  /**
   * @hidden
   */
  set _an(a) {
    this._b8(16, a);
  }
  /**
   * @hidden
   */
  get__ak() {
    return false;
  }
  /**
   * @hidden
   */
  get _ak() {
    return this.get__ak();
  }
  /**
   * @hidden
   */
  get__ap() {
    return true;
  }
  /**
   * @hidden
   */
  get _ap() {
    return this.get__ap();
  }
  /**
   * @hidden
   */
  get _aq() {
    return this._d.length == 1 && typeCast(SpecialFormulaToken.$, this._d[0]) !== null;
  }
  /**
   * @hidden
   */
  get _as() {
    return this._s == 2;
  }
  /**
   * @hidden
   */
  get _at() {
    return this._ah(32);
  }
  /**
   * @hidden
   */
  set _at(a) {
    this._b8(32, a);
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
  /**
   * @hidden
   */
  set _e(a) {
    this._d = a;
  }
  /**
   * @hidden
   */
  get _ax() {
    return this._ah(1);
  }
  /**
   * @hidden
   */
  set _ax(a) {
    this._b8(1, a);
  }
  /**
   * @hidden
   */
  get _bg() {
    return this._d;
  }
  /**
   * @hidden
   */
  get _s() {
    return this._r;
  }
  /**
   * @hidden
   */
  get__y() {
    let a = this._t;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
  /**
   * @hidden
   */
  get _y() {
    return this.get__y();
  }
}
Formula.$t = markType(Formula, 'Formula');
/**
 * @hidden
 */
Formula._be = 32;
/**
 * @hidden
 */
Formula._bd = 48;
/**
 * @hidden
 */
Formula._bf = 0;
/**
 * @hidden
 */
Formula._bc = 1;
/**
 * @hidden
 */
Formula._a = null;
/**
 * @hidden
 */
export let IExcelCalcFormula_$type = new Type(null, 'IExcelCalcFormula');
/**
 * @hidden
 */
export let IExcelCalcReferenceCollection_$type = new Type(null, 'IExcelCalcReferenceCollection', null, [IEnumerable_$type]);
/**
 * @hidden
 */
export let IExcelCalcReference_$type = new Type(null, 'IExcelCalcReference');
/**
 * @hidden
 */
export let IExcelCalcReferenceCollectionEx_$type = new Type(null, 'IExcelCalcReferenceCollectionEx', null, [IExcelCalcReferenceCollection_$type, IEnumerable$1_$type.specialize(IExcelCalcReference_$type)]);
/**
 * @hidden
 */
export class SingleTargetFormula extends Formula {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(0, c, d);
          this._cc = null;
          this._ck = null;
          this._cl = null;
          this._cm = 0;
          this._cg = null;
          this._cl = new List$1(IExcelCalcReference_$type, 0);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c);
          this._cc = null;
          this._ck = null;
          this._cl = null;
          this._cm = 0;
          this._cg = null;
          this._cl = new List$1(IExcelCalcReference_$type, 0);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super(2, c);
          this._cc = null;
          this._ck = null;
          this._cl = null;
          this._cm = 0;
          this._cg = null;
          this._cl = new List$1(IExcelCalcReference_$type, 0);
        }
        break;
      case 3:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(3, c, d);
          this._cc = null;
          this._ck = null;
          this._cl = null;
          this._cm = 0;
          this._cg = null;
          this._cl = new List$1(IExcelCalcReference_$type, 0);
        }
        break;
    }
  }
  addDynamicReferenceI(a) {
    let b = null;
    let c = this._ch._t;
    if (c != null) {
      b = c._w;
    }
    return this._addDynamicReference1(a, b);
  }
  get baseReference() {
    return this._ch;
  }
  get dynamicReferences() {
    return new SingleTargetFormula_DynamicReferenceCollection(this);
  }
  evaluate(a) {
    return this._cf(this._ch._t, a, false);
  }
  get formulaString() {
    return this._toString();
  }
  get staticReferences() {
    return new SingleTargetFormula_StaticReferenceCollection(this);
  }
  getEnumerator() {
    return this._cl.getEnumerator();
  }
  getEnumeratorObject() {
    return this._cl.getEnumerator();
  }
  _g() {
    return new SingleTargetFormula(3, this, false);
  }
  get__z() {
    if (this._cg != null) {
      let a = this._cg._t;
      if (a != null) {
        return a.currentFormat;
      }
    }
    return super.get__z();
  }
  set__z(a) {
    super.set__z(a);
  }
  get__bb() {
    let a = typeCast(CellCalcReference.$, this._cg);
    if (a != null) {
      return a._ao;
    }
    let b = typeCast(TempCellCalcReference.$, this._cg);
    if (b != null) {
      return b._ao;
    }
    return -1;
  }
  get _bb() {
    return this.get__bb();
  }
  get__ab() {
    let a = typeCast(CellCalcReference.$, this._cg);
    if (a != null) {
      return a._w;
    }
    let b = typeCast(TempCellCalcReference.$, this._cg);
    if (b != null && b._as >= 0) {
      let c = b._u;
      if (c != null) {
        return c._rows$i.item(b._as);
      }
    }
    return null;
  }
  get _ab() {
    return this.get__ab();
  }
  get__aa() {
    let a = typeCast(CellCalcReference.$, this._cg);
    if (a != null) {
      return new WorksheetCellAddress(1, a._w.index, a._ao);
    }
    let b = typeCast(TempCellCalcReference.$, this._cg);
    if (b != null) {
      return new WorksheetCellAddress(1, b._as, b._ao);
    }
    return WorksheetCellAddress.b;
  }
  get _aa() {
    return this.get__aa();
  }
  _b7() {
    if (this._cg != null && this._cg._formula == this && this._ab != null) {
      this._cg._a0(this, false, true);
    }
  }
  get__y() {
    return this._cg != null ? this._cg._t : null;
  }
  get__t() {
    return this._cg != null ? this._cg._r : null;
  }
  get _t() {
    return this.get__t();
  }
  _addDynamicReference1(a, b) {
    let c = ExcelCalcEngine.b(a);
    if (typeCast(ExcelReferenceError.$, c) !== null || typeCast(NamedCalcReferenceUnconnected.$, c) !== null) {
      return false;
    }
    let d;
    for (d = 0; d < this._cm; d++) {
      if (this._cl._inner[d].isSubsetReference(c)) {
        return false;
      }
    }
    let e = typeCast(CellCalcReference.$, c);
    if (e != null) {
      let f = this._cn(e);
      if (0 <= f) {
        this._cw(this._cp(f));
        return false;
      }
      let g;
      let h = this._cv(e, ~f, g);
      g = h.p2;
      this._cw(g);
    }
    else {
      let i = this._cl.count;
      for (let j = 0; d < i; d++ , j++) {
        let k = this._cl._inner[d];
        if (typeCast(CellCalcReference.$, k) !== null) {
          continue;
        }
        if (Base.equalsStatic(k, c)) {
          this._cw(j);
          return false;
        }
      }
      let l = this._cp(this._cl.count);
      this._cl.add(c);
      this._cw(l);
    }
    if (b != null) {
      b.v(c, this._cg);
    }
    else {
    }
    return true;
  }
  _cn(a) {
    let b = this._cr(0);
    let c = this._cl.count - 1;
    while (b <= c) {
      let d = b + (intDivide((c - b), 2));
      let e = SingleTargetFormula._co(a, typeCast(CellCalcReference.$, this._cl._inner[d]));
      if (e == 0) {
        return d;
      }
      if (e < 0) {
        b = d + 1;
      }
      else {
        c = d - 1;
      }
    }
    return ~b;
  }
  _cs(a) {
    let b = this._cq();
    if (this._ck == null || b == 0) {
      return;
    }
    for (let c = b - 1; c >= 0; c--) {
      if (this._ck.b(c) == false) {
        let d = this._cr(c);
        let e = this._cl._inner[d];
        this._cl.removeAt(d);
        a.at(e, this._cg);
      }
    }
    this._ck.m(false);
  }
  static _co(a, b) {
    if (a == b) {
      return 0;
    }
    if (b == null) {
      return 1;
    }
    let c = b._ao - a._ao;
    if (c != 0) {
      return c;
    }
    c = b._w.index - a._w.index;
    if (c != 0) {
      return c;
    }
    return b._u._am - a._u._am;
  }
  _ct(a) {
    if (this._ck == null) {
      this._ck = new BitArray(2, a + 1);
    }
    else if (this._ck.j <= a) {
      this._ck.j = Math.max(a + 1, this._ck.j * 2);
    }
  }
  evaluateCore(a) {
    if (this._cg._aj) {
      return null;
    }
    return this._cf(a, this._cg, false);
  }
  _cf(a, b, c) {
    if (this._am) {
      return this._cc;
    }
    if (this._ch._ai) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(7));
    }
    try {
      let d = new ExcelCalcNumberStack(b, this);
      d._u = c;
      let e;
      if (this._cg == b) {
        e = new FormulaContext(1, a, this._i);
      }
      else {
        let f = typeCast(CellCalcReference.$, b);
        if (f != null) {
          e = new FormulaContext(3, a, f._u, f._w, f._ao, this._i);
        }
        else {
          let g = typeCast(TempCellCalcReference.$, b);
          if (g != null) {
            e = new FormulaContext(4, g._r, g._as, g._ao, a.currentFormat, this._i, a._e6, a.cellReferenceMode);
          }
          else {
            e = new FormulaContext(1, a, this._i);
          }
        }
      }
      let h = FormulaEvaluator.a5(e, this._ch, d);
      h.h();
      if (d.count() == 0) {
        return new ExcelCalcValue(new ExcelCalcErrorValue(1));
      }
      let i = d.pop();
      if (typeCast(UltraCalcErrorException.$, i.value) !== null) {
        i = new ExcelCalcValue(new ExcelCalcErrorValue(i.value._value.code));
      }
      return i;
    }
    catch (j) {
      return new ExcelCalcValue(j);
    }
  }
  _cq() {
    return this._cl.count - this._cm;
  }
  _cp(a) {
    return a - this._cm;
  }
  _cr(a) {
    return a + this._cm;
  }
  _cu(a) {
    this._b6(a);
    let b = new FormulaContext(1, a, this);
    let c = SingleTargetFormula_StaticReferenceFinder.a3(b, this);
    c.h();
  }
  _cv(a, b, c) {
    c = this._cp(b);
    if (this._ck != null) {
      let d = this._cq();
      this._ct(d);
      for (let e = d - 1; e >= c; e--) {
        this._ck.l(e + 1, this._ck.b(e));
      }
    }
    this._cl.insert(b, a);
    return {
      p2: c
    };
  }
  _cw(a) {
    this._ct(a);
    this._ck.l(a, true);
  }
  _cx(a, b, c = false) {
    if (this._cg == a) {
      return;
    }
    let d = this._cg;
    this._cg = a;
    if (d != null) {
      if (this._as) {
        if (a == null && d._u != null && !c) {
          d._u._h3(this);
        }
      }
      else {
        this._bu();
      }
    }
    this._cl.clear();
    if (this._ck != null) {
      this._ck.m(false);
    }
    if (this._cg != null) {
      if (this._al == false) {
        this._b5(new FormulaContext(1, this._cg._t, this));
      }
      if (this._i._aq == false) {
        let e = new FormulaContext(1, b, this._i);
        let f = SingleTargetFormula_StaticReferenceFinder.a3(e, this);
        f.h();
      }
    }
    this._cm = this._cl.count;
  }
  get _cd() {
    return this._cc;
  }
  set _cd(a) {
    if (this._cg != null && this._cg._ad) {
      this._cg._ad = false;
      if (this._cc != null && !this._cg._af) {
        return;
      }
    }
    this._cc = a;
  }
  get hasAlwaysDirty() {
    return this._ax;
  }
  get__cj() {
    return true;
  }
  get _cj() {
    return this.get__cj();
  }
  get _ch() {
    return this._cg;
  }
}
SingleTargetFormula.$t = markType(SingleTargetFormula, 'SingleTargetFormula', Formula.$, [IExcelCalcFormula_$type, IExcelCalcReferenceCollectionEx_$type]);
/**
 * @hidden
 */
export let IWorksheetCellOwnedValue_$type = new Type(null, 'IWorksheetCellOwnedValue');
/**
 * @hidden
 */
export let IFormattedString_$type = new Type(null, 'IFormattedString');
/**
 * @hidden
 */
export let IFormattedItem_$type = new Type(null, 'IFormattedItem', null, [IWorkbookProvider_$type]);
/**
 * Represents a string with mixed formatting in a cell or cell comment.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedString, a portion of the string is "selected" by calling either <see cref="GetFont(int)">GetFont(int)</see> or
 * <see cref="GetFont(int,int)">GetFont(int,int)</see>. Formatting properties are then set on the returned
 * [[FormattedStringFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedStringFont]] will return the formatting of the first
 * character in font's selection range. This is similar to Excel, which will update the formatting interface to
 * reflect the formatting of the first character in a selection range when a cell's text is selected.
 * </p>
 */
export class FormattedString extends Base {
  constructor(..._rest) {
    super();
    this._l = null;
    this._i = null;
    this._h = null;
    let a;
    if (arguments.length === 1) {
      a = 2;
    }
    else if (arguments.length === 2) {
      a = 0;
    }
    else if (arguments.length === 4) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let workbook = _rest[0];
          let element = _rest[1];
          let b = [workbook, element, false, true];
          {
            let workbook = b[0];
            let element = b[1];
            let isElementInCache = b[2];
            let addElementToCache = b[3];
            if (isElementInCache || addElementToCache) {
              if (workbook != null) {
                this._h = workbook._bj;
              }
            }
            if (addElementToCache) {
              this._l = GenericCacheElement.a(StringElement.$, element, this._h);
            }
            else {
              this._l = element;
            }
          }
        }
        break;
      case 1:
        {
          let workbook = _rest[0];
          let element = _rest[1];
          let isElementInCache = _rest[2];
          let addElementToCache = _rest[3];
          if (isElementInCache || addElementToCache) {
            if (workbook != null) {
              this._h = workbook._bj;
            }
          }
          if (addElementToCache) {
            this._l = GenericCacheElement.a(StringElement.$, element, this._h);
          }
          else {
            this._l = element;
          }
        }
        break;
      case 2:
        {
          let unformattedString = _rest[0];
          if (unformattedString == null) {
            throw new ArgumentNullException(2, "unformattedString", ExcelUtils.ef("LE_ArgumentNullException_UnformattedString"));
          }
          unformattedString = ExcelUtils.eb(unformattedString);
          this._l = new StringElement(unformattedString);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Determines whether the specified [[Object]] is equal to this [[FormattedString]].
   * @param obj The value to test for equality to this FormattedString.
   * @return True if the 'obj' is a FormattedString instance and it contains the same unformatted
   * string and formatting as this FormattedString; False otherwise.
   */
  equals(obj) {
    let a = typeCast(FormattedString.$, obj);
    if (a == null) {
      return false;
    }
    return this._l.equals(a._l);
  }
  /**
   * Calculates the has code for this [[FormattedString]].
   * @return A number which can be used in hashing functions.
   */
  getHashCode() {
    return this._l.getHashCode();
  }
  /**
   * Returns the [[String]] that represents this [[FormattedString]].
   * This is just the unformatted string.
   * <p class="body">
   * This will return the same value as [[unformattedString]].
   * </p>
   * @return The String that represents this FormattedString.
   */
  toString() {
    return this.unformattedString;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._sheet;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  compareTo(other) {
    return this._l.compareTo(other._l);
  }
  /**
   * @hidden
   */
  get owner() {
    return this._owner;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  getOwnerAt(startIndex) {
    return this._e();
  }
  /**
   * @hidden
   */
  onFormattingChanged() {
    if (this._i != null) {
      this._i.onFormattingChanged();
    }
  }
  /**
   * @hidden
   */
  setWorkbook(workbook) {
    let a = StringElement._ae(workbook, this._i, this._h, this._l);
    this._h = a.p2;
    this._l = a.p3;
  }
  /**
   * @hidden
   */
  get isOwnedByAllCellsAppliedTo() {
    return true;
  }
  /**
   * @hidden
   */
  setOwningCell(row, columnIndex) {
    this._setOwningCell(row, columnIndex);
  }
  /**
   * @hidden
   */
  _setOwningCell(a, b) {
    if (a == null) {
      this._owner = null;
    }
    else {
      this._owner = a._cells$i.item(b);
    }
  }
  /**
   * @hidden
   */
  verifyNewOwner(ownerRow, ownerColumnIndex) {
    this._verifyNewOwner1(ownerRow._cells$i.item(ownerColumnIndex));
  }
  /**
   * @hidden
   */
  _verifyNewOwner1(a) {
    this._af();
    if (this._i != null && Base.equalsStatic(this._i, a) == false) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FormattedStringAlreadyOwned"));
    }
  }
  /**
   * @hidden
   */
  _w() {
    let a = GenericCacheElement.h(StringElement.$, this._h, this._l);
    this._l = a.p1;
  }
  /**
   * @hidden
   */
  _x() {
    this._af();
    let a = GenericCacheElement.i(StringElement.$, this._h, this._l, true);
    this._l = a.p1;
  }
  /**
   * @hidden
   */
  _y() {
    if (this._h != null) {
      this._h = null;
      this._l = GenericCacheElement.a(StringElement.$, this._l, null);
    }
  }
  /**
   * Creates a new [[FormattedString]] that is a copy of this one.
   * <p class="body">
   * This should be used if the same formatted string needs to be used in multiple cells.
   * The FormattedString class can only exist as the [[WorksheetCell.value]]
   * of one cell at a time. If the FormattedString is already the value of a cell, and needs
   * to be set as the value of another cell, clone the FormattedString and set the returned
   * clone as value of the cell.
   * </p>
   * <p class="body">
   * The cloned FormattedString only takes its original configuration for this instance.
   * If this instance is cloned and than changed, the clone will not be changed as well; it will
   * remain as it was when it was cloned.
   * </p>
   * @return A new FormattedString that is a copy of this one.
   */
  clone() {
    let a = this._h == null ? null : this._h._d;
    return new FormattedString(a, this._l);
  }
  /**
   * @hidden
   */
  static _aa($tValue, a, b, c, d, e, f) {
    ChangeInfo.f(a, b, new ChangeInfo$2(FormattedString.$, $tValue, c, 41, d, e, f, true, 8192, true, null, null));
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(1);
    FormattedString._aa(String_$type, a, 0, "UnformattedString", (b) => b.unformattedString, (b, c) => b.unformattedString = c, (b, c) => b._ad(c));
    return a;
  }
  /**
   * @hidden
   */
  _e() {
    let a = typeCast(FormattedStringElement.$, this._l);
    if (a != null) {
      return a;
    }
    a = FormattedStringElement._af(this._l);
    this._l = a;
    return a;
  }
  getFont() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getFont.apply(this, arguments);
      case 1: return this._getFont1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getFont(a) {
    if (a < 0) {
      throw ExcelUtils.x("startIndex", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_NegativeStartIndex"));
    }
    return new FormattedStringFont(this, a, 0);
  }
  /**
   * @hidden
   */
  _getFont1(a, b) {
    if (a < 0) {
      throw ExcelUtils.x("startIndex", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_NegativeStartIndex"));
    }
    if (b < 1) {
      throw ExcelUtils.x("length", b, ExcelUtils.ef("LE_ArgumentOutOfRangeException_LengthMustBePositive"));
    }
    return new FormattedStringFont(this, a, b);
  }
  /**
   * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
   */
  *_getFormattingRuns() {
    let a = this.unformattedString.length;
    let b = typeCast(FormattedStringElement.$, this._m);
    if (b == null || b._u == false) {
      if (a > 0) {
        yield this._getFont1(0, a);
      }
      return undefined;
    }
    let c = null;
    for (let d of fromEnum(b._ah)) {
      if (c == null) {
        if (d.i != 0) {
          yield this._getFont1(0, d.i);
        }
        c = d;
        continue;
      }
      if ((c.h == false && d.h == false) || c.e().d.c(d.e().d)) {
        continue;
      }
      let e = c.i;
      let f = d.i - e;
      yield this._getFont1(e, f);
      c = d;
    }
    if (c != null) {
      let g = c.i;
      yield this._getFont1(c.i, a - g);
    }
  }
  getFormattingRuns() {
    return toEnum(() => this._getFormattingRuns());
  }
  /**
   * @hidden
   */
  _c() {
    if (typeCast(FormattedStringElement.$, this._l) !== null) {
      return this._l._ah.toArray();
    }
    return new Array(0);
  }
  /**
   * @hidden
   */
  _z(a) {
    let b = GenericCacheElement.o(StringElement.$, a, this._h, this._l);
    this._h = b.p1;
    this._l = b.p2;
  }
  /**
   * @hidden
   */
  _ac(a) {
    let b = null;
    if (a != null) {
      b = a.workbook;
    }
    this.setWorkbook(b);
  }
  /**
   * @hidden
   */
  _af() {
    let a = typeCast(WorksheetCell.$, this._i);
    if (WorksheetCell.l_op_Inequality(a, null)) {
      let b = typeCast(FormattedString.$, a.value);
      if (b == null || b._m != this._m) {
        this._i = null;
        this._y();
      }
    }
  }
  /**
   * Gets or sets the unformatted string.
   * <p class="body">
   * If the new unformatted string assigned is shorter than the old unformatted string, all formatting
   * outside the range of the new value will be lost.
   * </p>
   * The unformatted string.
   * @throws [[ArgumentNullException]] The value assigned is a null string.
   */
  get unformattedString() {
    return this._l._y;
  }
  /**
   * Gets or sets the unformatted string.
   * <p class="body">
   * If the new unformatted string assigned is shorter than the old unformatted string, all formatting
   * outside the range of the new value will be lost.
   * </p>
   * The unformatted string.
   * @throws [[ArgumentNullException]] The value assigned is a null string.
   */
  set unformattedString(a) {
    if (this.unformattedString == a) {
      return;
    }
    if (a == null) {
      throw new ArgumentNullException(2, "unformattedString", ExcelUtils.ef("LE_ArgumentNullException_UnformattedString"));
    }
    FormattedString._a[0].h(FormattedString.$, String_$type, this, a);
  }
  /**
   * @hidden
   */
  _ad(a) {
    this._x();
    this._l._y = a;
    this._w();
    if (this._owner != null) {
      this._owner.onUnformattedStringChanged(this);
    }
  }
  /**
   * @hidden
   */
  get _m() {
    return this._l;
  }
  /**
   * @hidden
   */
  get _owner() {
    return this._i;
  }
  /**
   * @hidden
   */
  set _owner(a) {
    if (this._i == a) {
      return;
    }
    this._i = a;
    let b = this._i == null ? null : this._i.sheet;
    this._ac(b);
  }
  /**
   * @hidden
   */
  get _t() {
    return this._l._w;
  }
  /**
   * @hidden
   */
  get _sheet() {
    if (this._i == null) {
      return null;
    }
    return this._i.sheet;
  }
  /**
   * @hidden
   */
  get _workbook() {
    if (this._i == null) {
      return null;
    }
    let a = this._i.sheet;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
}
FormattedString.$t = markType(FormattedString, 'FormattedString', Base.$, [IWorksheetCellOwnedValue_$type, IComparable$1_$type.specialize(-1), IFormattedString_$type, IFormattedItem_$type, IChangeInfoContext_$type]).initSelfReferences();
/**
 * @hidden
 */
FormattedString._s = 0;
/**
 * @hidden
 */
FormattedString._r = 1;
/**
 * @hidden
 */
FormattedString._a = FormattedString._b();
/**
 * Represents the text area of a chart element.
 * @see [[ChartTitle]]
 * @see [[DisplayUnitLabel]]
 */
export class ChartTextAreaBase extends ChartObject {
  constructor(a) {
    super(a);
    this._z = null;
    this._a8 = null;
    this._ab = null;
    this._a4 = null;
    this._b1 = null;
    this._ah = -4108;
    this._aq = 0;
    this._bd = 0;
    this._ae = -4105;
    this._ak = -5002;
    this._be = 0;
    this._az = null;
    this._an = 0;
    this._bf = 0;
    this._aw = -4108;
    this._at = 2;
    this._a9 = true;
  }
  static staticInit() {
    ChartTextAreaBase._w = ChartTextAreaBase._x();
  }
  /**
   * @hidden
   */
  _a(a) {
    return ChartTextAreaBase._w[a];
  }
  /**
   * @hidden
   */
  _m(a) {
    if (this._a4 != null) {
      a(this.sheet, this._a4);
    }
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._a4 != null && this._a4._ar(a.workbook, a, b)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    if (this._a4 != null) {
      let d = this.sheet;
      if (d != null) {
        let e = this._a4._toString2(1, d.workbook._e6);
        if (this._a4._av(d, b, 0)) {
          a(this, e);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _k(a) {
    let b = typeCast(String_$type, a);
    if (b != null) {
      let c = this.workbook;
      let d = c != null ? c._e6 : CultureInfo.invariantCulture;
      let e = this._a4 != null ? this._a4._toString2(1, d) : null;
      this._setFormula1(b, Nullable$1.toNullable(CellReferenceMode_$type, 1));
      return e;
    }
    return null;
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._a4 != null && this._a4._t == a) {
      this._a4 = null;
    }
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   */
  get border() {
    return this._z;
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   */
  set border(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(ChartTextAreaBase.$, ChartBorder.$, this, 0, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * Defines the font properties for each formatted run in the
   * [[text]] that has no more specific setting. Read-only.
   * <p class="body">
   * Use this object to apply font formatting to the entire run of text
   * which comprises the chart or axis title.
   * </p>
   * <p class="body">
   * Font formatting can be applied to individual runs of text using the
   * [[FormattedString.getFont]] method of the object
   * returned from the [[text]] property. Any such formatting
   * overrides that which is defined by the DefaultFont settings.
   * </p>
   * <para class="note"><b>Note:</b> this property will return null until the [[ChartTitle]]
   * is set on the <see cref="WorksheetChart.ChartTitle">WorksheetChart.ChartTitle</see> property.</para>
   * @see [[text]]
   * @see [[FormattedString]]
   */
  get defaultFont() {
    this._e(this.workbook);
    return this._a8;
  }
  /**
   * @hidden
   */
  _e(a) {
    if (this._a8 != null) {
      return this._a8;
    }
    let b = this.workbook != null ? this.workbook : a;
    if (b == null) {
      return null;
    }
    this._a8 = this._f(b);
    return this._a8;
  }
  /**
   * @hidden
   */
  get _a7() {
    return ExcelUtils.ad(this.defaultFont);
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the text area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fill() {
    return this._ab;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the text area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fill(a) {
    if (a != this._ab) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ab != null) {
        this._ab._l(null);
      }
      let b = this._r(ChartTextAreaBase.$, ChartFillBase.$, this, 1, this._ab, a);
      this._ab = b.p2;
    }
  }
  /**
   * @hidden
   */
  get__ad() {
    let a = this.fill;
    if (a == null) {
      a = new ChartEmptyFill();
    }
    return a;
  }
  /**
   * @hidden
   */
  get _ad() {
    return this.get__ad();
  }
  /**
   * The formula used to get the text displayed within the text area. (read-only).
   * <para class="body">
   * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
   * </para>
   * @see [[setFormula]]
   */
  get_formula() {
    return this._a4;
  }
  /**
   * The formula used to get the text displayed within the text area. (read-only).
   * <para class="body">
   * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
   * </para>
   * @see [[setFormula]]
   */
  get formula() {
    return this.get_formula();
  }
  /**
   * @hidden
   */
  get _a5() {
    return this._a4;
  }
  /**
   * @hidden
   */
  set _a5(a) {
    if (a != this._a4) {
      if (a != null && a._ch == null) {
        ChartTextAreaBase._a6(this.sheet, a);
      }
      let b = this._r(ChartTextAreaBase.$, SingleTargetFormula.$, this, 2, this._a4, a);
      this._a4 = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _aj() {
    return this._ah;
  }
  /**
   * @hidden
   */
  set _aj(a) {
    if (a != this._ah) {
      let b = this._q(ChartTextAreaBase.$, HorizontalTitleAlignment_$type, this, 3, this._ah, a);
      this._ah = b.p2;
    }
  }
  /**
   * Determines whether text is allowed to continue horizontally
   * outside the bounds of the containing element.
   */
  get horizontalOverflow() {
    return this._aq;
  }
  /**
   * Determines whether text is allowed to continue horizontally
   * outside the bounds of the containing element.
   */
  set horizontalOverflow(a) {
    if (a != this._aq) {
      let b = this._q(ChartTextAreaBase.$, TextHorizontalOverflow_$type, this, 4, this._aq, a);
      this._aq = b.p2;
    }
  }
  /**
   * The left position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the width of the chart element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the text area as close as possible to the
   * edge of the chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  get_left() {
    return this._bd;
  }
  /**
   * The left position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the width of the chart element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the text area as close as possible to the
   * edge of the chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  set_left(a) {
    if (a != this._bd) {
      let b = this._r(ChartTextAreaBase.$, Number_$type, this, 5, this._bd, a);
      this._bd = b.p2;
    }
  }
  /**
   * The left position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the width of the chart element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the text area as close as possible to the
   * edge of the chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  get left() {
    return this.get_left();
  }
  /**
   * The left position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the width of the chart element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the text area as close as possible to the
   * edge of the chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  set left(a) {
    this.set_left(a);
  }
  /**
   * Determines whether the position of the text area is automatic or custom
   * as specified by the [[left]] and [[top]] properties.
   */
  get_position() {
    return this._ae;
  }
  /**
   * Determines whether the position of the text area is automatic or custom
   * as specified by the [[left]] and [[top]] properties.
   */
  set_position(a) {
    if (a != this._ae) {
      let b = this._q(ChartTextAreaBase.$, ElementPosition_$type, this, 6, this._ae, a);
      this._ae = b.p2;
    }
  }
  /**
   * Determines whether the position of the text area is automatic or custom
   * as specified by the [[left]] and [[top]] properties.
   */
  get position() {
    return this.get_position();
  }
  /**
   * Determines whether the position of the text area is automatic or custom
   * as specified by the [[left]] and [[top]] properties.
   */
  set position(a) {
    this.set_position(a);
  }
  /**
   * Determines the reading order
   */
  get readingOrder() {
    return this._ak;
  }
  /**
   * Determines the reading order
   */
  set readingOrder(a) {
    if (a != this._ak) {
      let b = this._q(ChartTextAreaBase.$, ReadingOrder_$type, this, 7, this._ak, a);
      this._ak = b.p2;
    }
  }
  /**
   * Determines the rotation of the text area, expressed in degrees.
   */
  get rotation() {
    return this._be;
  }
  /**
   * Determines the rotation of the text area, expressed in degrees.
   */
  set rotation(a) {
    if (a != this._be) {
      let b = this._r(ChartTextAreaBase.$, Number_$type, this, 8, this._be, a);
      this._be = b.p2;
    }
  }
  /**
   * Returns or sets a [[FormattedString]] object which defines
   * the text to be displayed by the associated chart element.
   * <p class="body">
   * Because mixed font settings are supported for chart element text,
   * a special object is required to customize the text.
   * </p>
   * <p class="body">
   * For the simple case where all the text has the same formatting,
   * create an instance of the [[FormattedString]] class,
   * specifiying the text as the value of the 'unformattedString'
   * parameter.
   * </p>
   * <p class="body">
   * To apply font attributes to a given run of text, i.e., a substring
   * within the text, use the [[FormattedString.getFont]]
   * method, and set the applicable properties of the [[FormattedStringFont]]
   * instance returned from the GetFont method.
   * </p>
   * @see [[FormattedString..ctor]]
   * @see [[FormattedString.getFont]]
   */
  get_text() {
    if (this._a4 != null) {
      let a = this._a4._cf(this.workbook, null, false);
      if (!a.isError) {
        let b = a.toString();
        if (b != this._b1) {
          this._b1 = b;
          this._az = new FormattedString(b);
          this._az._owner = this;
        }
      }
    }
    return this._az;
  }
  /**
   * Returns or sets a [[FormattedString]] object which defines
   * the text to be displayed by the associated chart element.
   * <p class="body">
   * Because mixed font settings are supported for chart element text,
   * a special object is required to customize the text.
   * </p>
   * <p class="body">
   * For the simple case where all the text has the same formatting,
   * create an instance of the [[FormattedString]] class,
   * specifiying the text as the value of the 'unformattedString'
   * parameter.
   * </p>
   * <p class="body">
   * To apply font attributes to a given run of text, i.e., a substring
   * within the text, use the [[FormattedString.getFont]]
   * method, and set the applicable properties of the [[FormattedStringFont]]
   * instance returned from the GetFont method.
   * </p>
   * @see [[FormattedString..ctor]]
   * @see [[FormattedString.getFont]]
   */
  set_text(a) {
    if (a != this._az) {
      if (this._az != null) {
        this._az._owner = null;
      }
      if (a != null) {
        a._owner = this;
      }
      let b = this._r(ChartTextAreaBase.$, FormattedString.$, this, 9, this._az, a);
      this._az = b.p2;
    }
  }
  /**
   * Returns or sets a [[FormattedString]] object which defines
   * the text to be displayed by the associated chart element.
   * <p class="body">
   * Because mixed font settings are supported for chart element text,
   * a special object is required to customize the text.
   * </p>
   * <p class="body">
   * For the simple case where all the text has the same formatting,
   * create an instance of the [[FormattedString]] class,
   * specifiying the text as the value of the 'unformattedString'
   * parameter.
   * </p>
   * <p class="body">
   * To apply font attributes to a given run of text, i.e., a substring
   * within the text, use the [[FormattedString.getFont]]
   * method, and set the applicable properties of the [[FormattedStringFont]]
   * instance returned from the GetFont method.
   * </p>
   * @see [[FormattedString..ctor]]
   * @see [[FormattedString.getFont]]
   */
  get text() {
    return this.get_text();
  }
  /**
   * Returns or sets a [[FormattedString]] object which defines
   * the text to be displayed by the associated chart element.
   * <p class="body">
   * Because mixed font settings are supported for chart element text,
   * a special object is required to customize the text.
   * </p>
   * <p class="body">
   * For the simple case where all the text has the same formatting,
   * create an instance of the [[FormattedString]] class,
   * specifiying the text as the value of the 'unformattedString'
   * parameter.
   * </p>
   * <p class="body">
   * To apply font attributes to a given run of text, i.e., a substring
   * within the text, use the [[FormattedString.getFont]]
   * method, and set the applicable properties of the [[FormattedStringFont]]
   * instance returned from the GetFont method.
   * </p>
   * @see [[FormattedString..ctor]]
   * @see [[FormattedString.getFont]]
   */
  set text(a) {
    this.set_text(a);
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  get textDirection() {
    return this._an;
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  set textDirection(a) {
    if (a != this._an) {
      let b = this._q(ChartTextAreaBase.$, TextDirection_$type, this, 10, this._an, a);
      this._an = b.p2;
    }
  }
  /**
   * The top position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the height of the associated chart
   * element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the title as close as possible to the
   * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  get_top() {
    return this._bf;
  }
  /**
   * The top position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the height of the associated chart
   * element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the title as close as possible to the
   * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  set_top(a) {
    if (a != this._bf) {
      let b = this._r(ChartTextAreaBase.$, Number_$type, this, 11, this._bf, a);
      this._bf = b.p2;
    }
  }
  /**
   * The top position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the height of the associated chart
   * element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the title as close as possible to the
   * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  get top() {
    return this.get_top();
  }
  /**
   * The top position of the text area (ignored unless [[position]] is set to 'Custom').
   * <p class="body">
   * The value of this property is expressed as a fractional value between 0 and 1
   * which represents the ratio of the offset to the height of the associated chart
   * element.
   * </p>
   * <p class="body">
   * For example, a value of 0 positions the title as close as possible to the
   * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
   * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
   * the entire chart element, yields the offset.
   * </p>
   * @see [[position]]
   */
  set top(a) {
    this.set_top(a);
  }
  /**
   * Determines the vertical alignment of the text area.
   */
  get verticalAlignment() {
    return this._aw;
  }
  /**
   * Determines the vertical alignment of the text area.
   */
  set verticalAlignment(a) {
    if (a != this._aw) {
      let b = this._q(ChartTextAreaBase.$, VerticalTitleAlignment_$type, this, 12, this._aw, a);
      this._aw = b.p2;
    }
  }
  /**
   * Determines whether text is allowed to continue vertically
   * outside the bounds of the containing element.
   */
  get verticalOverflow() {
    return this._at;
  }
  /**
   * Determines whether text is allowed to continue vertically
   * outside the bounds of the containing element.
   */
  set verticalOverflow(a) {
    if (a != this._at) {
      let b = this._q(ChartTextAreaBase.$, TextVerticalOverflow_$type, this, 13, this._at, a);
      this._at = b.p2;
    }
  }
  /**
   * Determines whether text is wrapped when it would exceed
   * the bounds of the containing element.
   */
  get wrapText() {
    return this._a9;
  }
  /**
   * Determines whether text is wrapped when it would exceed
   * the bounds of the containing element.
   */
  set wrapText(a) {
    if (a != this._a9) {
      let b = this._r(ChartTextAreaBase.$, Boolean_$type, this, 14, this._a9, a);
      this._a9 = b.p2;
    }
  }
  /**
   * Assigns a new [[Formula]] to this instance.
   * @param formula The string representation of the formula used to get the [[text]].
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @see [[text]]
   */
  setFormula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setFormula1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula1(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    if (a != null && a.length > 0 && a.charAt(0) != '=') {
      a = "=" + a;
    }
    this._a5 = ConditionBase._n(a, this.workbook, b);
  }
  /**
   * @hidden
   */
  _b2(a, b) {
    this._a4 = b;
    ChartTextAreaBase._a6(a, b);
  }
  /**
   * @hidden
   */
  _a3(a = true) {
    let b = this.text;
    let c = null;
    if (b != null && a) {
      let d = b.getFormattingRuns();
      if (d != null) {
        for (let e of fromEnum(d)) {
          c = e;
          break;
        }
      }
    }
    if (c == null) {
      return this.defaultFont;
    }
    let f = [c, this.defaultFont];
    return ExcelUtils.v(f, this.workbook);
  }
  /**
   * @hidden
   */
  _bb(a, b = -4105) {
    if (this._z != null) {
      return true;
    }
    if (this._a8 != null && this._a8._p()) {
      return true;
    }
    if (this._ab != null) {
      return true;
    }
    if (this._a4 != null) {
      return true;
    }
    if (stringIsNullOrEmpty(this._b1) == false) {
      return true;
    }
    if (this._ah != -4108) {
      return true;
    }
    if (this._aq != 0) {
      return true;
    }
    if (a) {
      if (this._bd != 0 || this._bf != 0) {
        return true;
      }
    }
    if (this._ae != b) {
      return true;
    }
    if (this._ak != -5002) {
      return true;
    }
    if (this._be != 0) {
      return true;
    }
    if (this._az != null) {
      return true;
    }
    if (this._an != 0) {
      return true;
    }
    if (this._aw != -4108) {
      return true;
    }
    if (this._at != 2) {
      return true;
    }
    if (this._a9 != true) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartTextAreaBase.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(15);
    ChangeInfo.f(a, 0, ChartTextAreaBase._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 1, ChartTextAreaBase._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 2, ChartTextAreaBase._y(SingleTargetFormula.$, "FormulaInternal", 7, (b) => b._a5, (b, c) => b._a5 = c));
    ChangeInfo.f(a, 3, ChartTextAreaBase._y(HorizontalTitleAlignment_$type, "HorizontalAlignment", 7, (b) => b._aj, (b, c) => b._aj = c));
    ChangeInfo.f(a, 4, ChartTextAreaBase._y(TextHorizontalOverflow_$type, "HorizontalOverflow", 7, (b) => b.horizontalOverflow, (b, c) => b.horizontalOverflow = c));
    ChangeInfo.f(a, 5, ChartTextAreaBase._y(Number_$type, "Left", 7, (b) => b.left, (b, c) => b.left = c));
    ChangeInfo.f(a, 6, ChartTextAreaBase._y(ElementPosition_$type, "Position", 7, (b) => b.position, (b, c) => b.position = c));
    ChangeInfo.f(a, 7, ChartTextAreaBase._y(ReadingOrder_$type, "ReadingOrder", 7, (b) => b.readingOrder, (b, c) => b.readingOrder = c));
    ChangeInfo.f(a, 8, ChartTextAreaBase._y(Number_$type, "Rotation", 7, (b) => b.rotation, (b, c) => b.rotation = c));
    ChangeInfo.f(a, 9, ChartTextAreaBase._y(FormattedString.$, "Text", 7, (b) => b.text, (b, c) => b.text = c));
    ChangeInfo.f(a, 10, ChartTextAreaBase._y(TextDirection_$type, "TextDirection", 7, (b) => b.textDirection, (b, c) => b.textDirection = c));
    ChangeInfo.f(a, 11, ChartTextAreaBase._y(Number_$type, "Top", 7, (b) => b.top, (b, c) => b.top = c));
    ChangeInfo.f(a, 12, ChartTextAreaBase._y(VerticalTitleAlignment_$type, "VerticalAlignment", 7, (b) => b.verticalAlignment, (b, c) => b.verticalAlignment = c));
    ChangeInfo.f(a, 13, ChartTextAreaBase._y(TextVerticalOverflow_$type, "VerticalOverflow", 7, (b) => b.verticalOverflow, (b, c) => b.verticalOverflow = c));
    ChangeInfo.f(a, 14, ChartTextAreaBase._y(Boolean_$type, "WrapText", 7, (b) => b.wrapText, (b, c) => b.wrapText = c));
    return a;
  }
  /**
   * @hidden
   */
  static _a6(a, b) {
    if (b != null) {
      let c = new TempCellCalcReference(true, a, new WorksheetCellAddress(1, 0, 0));
      b._cx(c, a.workbook);
    }
    return b;
  }
  /**
   * @hidden
   */
  get allowDefaultValues() {
    return true;
  }
  /**
   * @hidden
   */
  getDefaultFont() {
    return this.defaultFont;
  }
  /**
   * @hidden
   */
  getFontDefaultsResolver() {
    return null;
  }
  /**
   * @hidden
   */
  onUnformattedStringChanged(sender) {
  }
  /**
   * @hidden
   */
  onFormattingChanged() {
    let a = this._d;
    if (a != null) {
      a.onPropertyChanged();
    }
  }
}
ChartTextAreaBase.$t = markType(ChartTextAreaBase, 'ChartTextAreaBase', ChartObject.$, [IFormattedStringOwner_$type]);
/**
 * @hidden
 */
ChartTextAreaBase._bl = 0;
/**
 * @hidden
 */
ChartTextAreaBase._bm = 1;
/**
 * @hidden
 */
ChartTextAreaBase._bn = 2;
/**
 * @hidden
 */
ChartTextAreaBase._bo = 3;
/**
 * @hidden
 */
ChartTextAreaBase._bp = 4;
/**
 * @hidden
 */
ChartTextAreaBase._bq = 5;
/**
 * @hidden
 */
ChartTextAreaBase._bs = 6;
/**
 * @hidden
 */
ChartTextAreaBase._bt = 7;
/**
 * @hidden
 */
ChartTextAreaBase._bu = 8;
/**
 * @hidden
 */
ChartTextAreaBase._bw = 9;
/**
 * @hidden
 */
ChartTextAreaBase._bv = 10;
/**
 * @hidden
 */
ChartTextAreaBase._bx = 11;
/**
 * @hidden
 */
ChartTextAreaBase._by = 12;
/**
 * @hidden
 */
ChartTextAreaBase._bz = 13;
/**
 * @hidden
 */
ChartTextAreaBase._b0 = 14;
/**
 * @hidden
 */
ChartTextAreaBase._br = 15;
/**
 * @hidden
 */
ChartTextAreaBase._ai = -4108;
/**
 * @hidden
 */
ChartTextAreaBase._ar = 0;
/**
 * @hidden
 */
ChartTextAreaBase._bg = 0;
/**
 * @hidden
 */
ChartTextAreaBase._af = -4105;
/**
 * @hidden
 */
ChartTextAreaBase._al = -5002;
/**
 * @hidden
 */
ChartTextAreaBase._bh = 0;
/**
 * @hidden
 */
ChartTextAreaBase._ao = 0;
/**
 * @hidden
 */
ChartTextAreaBase._ax = -4108;
/**
 * @hidden
 */
ChartTextAreaBase._au = 2;
/**
 * @hidden
 */
ChartTextAreaBase._ba = true;
/**
 * @hidden
 */
ChartTextAreaBase._w = null;
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export class ChartTitle extends ChartTextAreaBase {
  constructor() {
    super(null);
    this._b9 = false;
    this._b8 = null;
  }
  static staticInit() {
    ChartTitle._b4 = ChartTitle._b5();
  }
  /**
   * @hidden
   */
  get _b7() {
    let a = this.workbook;
    if (this._b8 == null) {
      this._b8 = this._f(a, false);
      this._cf(this._b8);
    }
    let b = this.defaultFont;
    let c = [this.defaultFont, this._b8];
    return ExcelUtils.v(c, a);
  }
  /**
   * @hidden
   */
  get _ca() {
    let a = typeCast(Axis.$, this.owner);
    return a != null;
  }
  /**
   * Determines whether the chart title is laid over the plot area.
   */
  get overlay() {
    return this._b9;
  }
  /**
   * Determines whether the chart title is laid over the plot area.
   */
  set overlay(a) {
    if (a != this._b9) {
      let b = this._r(ChartTitle.$, Boolean_$type, this, 15, this._b9, a);
      this._b9 = b.p2;
    }
  }
  /**
   * @hidden
   */
  _cf(a) {
    if (a == null) {
      return;
    }
    if (nullableEquals(a._bold$i, null)) {
      a._bold$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._italic$i, null)) {
      a._italic$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (a.underlineStyle == -1) {
      a.underlineStyle = 0;
    }
    if (nullableEquals(a._strikeout$i, null)) {
      a._strikeout$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (a.height <= 0) {
      let b = this._ca ? 9 : 14;
      a.height = 20 * b;
    }
  }
  /**
   * @hidden
   */
  _cc() {
    let a = this._ca ? -4105 : 100;
    return super._bb(false, a);
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 15) {
      return super._a(a);
    }
    return ChartTitle._b4[a - 15];
  }
  /**
   * @hidden
   */
  static _b6($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartTitle.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _b5() {
    let a = 15;
    let b = new Array(16 - a);
    ChangeInfo.f(b, 15 - a, ChartTitle._b6(Boolean_$type, "Overlay", 7, (c) => c.overlay, (c, d) => c.overlay = d));
    return b;
  }
}
ChartTitle.$t = markType(ChartTitle, 'ChartTitle', ChartTextAreaBase.$);
/**
 * @hidden
 */
ChartTitle._ce = 15;
/**
 * @hidden
 */
ChartTitle._cd = 15 + 1;
/**
 * @hidden
 */
ChartTitle._b4 = null;
/**
 * Exposes properties which control the fill and width
 * of the drop lines in a stock chart.
 * @see [[WorksheetChart.dropLines]]
 */
export class ChartDropLines extends ChartLineBase {
  constructor() {
    super(null);
  }
}
ChartDropLines.$t = markType(ChartDropLines, 'ChartDropLines', ChartLineBase.$);
/**
 * Exposes properties which control the fill and width of the lines
 * which depict the high and low values in a stock chart.
 * @see [[WorksheetChart.highLowLines]]
 */
export class ChartHighLowLines extends ChartLineBase {
  constructor() {
    super(null);
    let a = new WorkbookColorInfo(1);
    this.fill = new ChartSolidFill(a);
  }
  /**
   * @hidden
   */
  get _ak() {
    if (this.fill != null) {
      return this.fill;
    }
    let a = this.chart;
    return a != null ? a._ez : ChartSolidFill._w(1);
  }
}
ChartHighLowLines.$t = markType(ChartHighLowLines, 'ChartHighLowLines', ChartLineBase.$);
/**
 * @hidden
 */
export class WorksheetChart_LegendChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = null;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.c = c;
          this.b = d;
          this.a = e;
        }
        break;
    }
  }
  d() {
    let a = this.c._e8;
    let b = a != null ? a._legendEntries$i._w() : null;
    this.c._e8 = this.b;
    if (this.b != null) {
      this.b._legendEntries$i._ag(this.a);
    }
    let c = WorksheetChart._d9[13];
    let d = new WorksheetChart_LegendChangeContext(1, this.c, a, b);
    c.x(d, null, null);
  }
  get workbook() {
    return this.c.workbook;
  }
  get sheet() {
    return this.c.sheet;
  }
  get source() {
    return this.c;
  }
}
WorksheetChart_LegendChangeContext.$t = markStruct(WorksheetChart_LegendChangeContext, 'WorksheetChart_LegendChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Exposes properties which control the fill and width of the lines
 * which connect the first and second plot areas in a 'bar of pie'
 * or 'pie of pie' chart.
 * @see [[WorksheetChart.seriesLines]]
 */
export class ChartSeriesLines extends ChartLineBase {
  constructor() {
    super(null);
    this._al = null;
  }
  /**
   * @hidden
   */
  get _ak() {
    if (this.fill != null) {
      return this.fill;
    }
    if (this._al == null) {
      this._al = ChartSolidFill._w(1, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, 0.35), Nullable$1.toNullable(Number_$type, 0.65));
    }
    return this._al;
  }
}
ChartSeriesLines.$t = markType(ChartSeriesLines, 'ChartSeriesLines', ChartLineBase.$);
/**
 * Represents the bars which depict gain or loss on a stock chart.
 */
export class UpDownBars extends ChartObject {
  constructor() {
    super(null);
    this._ad = 150;
    this._aa = null;
    this._z = null;
  }
  /**
   * Returns an [[UpDownBar]] instance which controls the appearance
   * of the down bars for a stock chart.
   * @see [[downBar]]
   * @see [[WorksheetChart.upDownBars]]
   * @see [[WorksheetChart.highLowLines]]
   */
  get downBar() {
    if (this._z == null) {
      this._z = new UpDownBar(this, 1);
    }
    return this._z;
  }
  /**
   * Specifies the width of the gap between bars.
   */
  get gapWidth() {
    return this._ad;
  }
  /**
   * Specifies the width of the gap between bars.
   */
  set gapWidth(a) {
    if (a != this._ad) {
      let b = this._r(UpDownBars.$, Number_$type, this, 0, this._ad, a);
      this._ad = b.p2;
    }
  }
  /**
   * Returns an [[UpDownBar]] instance which controls the appearance
   * of the up bars for a stock chart.
   * @see [[upBar]]
   * @see [[WorksheetChart.upDownBars]]
   * @see [[WorksheetChart.highLowLines]]
   */
  get upBar() {
    if (this._aa == null) {
      this._aa = new UpDownBar(this, 0);
    }
    return this._aa;
  }
  /**
   * @hidden
   */
  _a(a) {
    return UpDownBars._w[a];
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(UpDownBars.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, UpDownBars._y(Number_$type, "GapWidth", 7, (b) => b.gapWidth, (b, c) => b.gapWidth = c));
    return a;
  }
}
UpDownBars.$t = markType(UpDownBars, 'UpDownBars', ChartObject.$);
/**
 * @hidden
 */
UpDownBars._ag = 0;
/**
 * @hidden
 */
UpDownBars._ah = 1;
/**
 * @hidden
 */
UpDownBars._ae = 150;
/**
 * @hidden
 */
UpDownBars._w = UpDownBars._x();
export class WorksheetChart extends WorksheetShapeGroupBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(0);
          this._fz = WorksheetChart._f0;
          this._ef = null;
          this._fj = null;
          this._iv = Nullable$1.toNullable(BarShape_$type, null);
          this._el = null;
          this._e1 = null;
          this._e3 = 1;
          this._g6 = 100;
          this._e6 = 3;
          this._g7 = 50;
          this._en = null;
          this._fk = null;
          this._g8 = 0;
          this._g9 = -1;
          this._ha = -1;
          this._hb = 100;
          this._er = null;
          this._e8 = null;
          this._hc = 0;
          this._fa = null;
          this._hd = 15;
          this._he = 20;
          this._fc = null;
          this._hf = 50;
          this._et = null;
          this._hg = 0;
          this._fl = null;
          this._fh = null;
          this._fm = null;
          this._fy = null;
          this._fu = null;
          this._ew = null;
          this._ex = null;
          this._ev = null;
          this._ep = null;
          this._eb = null;
          this._fw = null;
          this._i4 = 0;
          this._g1 = null;
          this._g2 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(2, c);
          this._fz = WorksheetChart._f0;
          this._ef = null;
          this._fj = null;
          this._iv = Nullable$1.toNullable(BarShape_$type, null);
          this._el = null;
          this._e1 = null;
          this._e3 = 1;
          this._g6 = 100;
          this._e6 = 3;
          this._g7 = 50;
          this._en = null;
          this._fk = null;
          this._g8 = 0;
          this._g9 = -1;
          this._ha = -1;
          this._hb = 100;
          this._er = null;
          this._e8 = null;
          this._hc = 0;
          this._fa = null;
          this._hd = 15;
          this._he = 20;
          this._fc = null;
          this._hf = 50;
          this._et = null;
          this._hg = 0;
          this._fl = null;
          this._fh = null;
          this._fm = null;
          this._fy = null;
          this._fu = null;
          this._ew = null;
          this._ex = null;
          this._ev = null;
          this._ep = null;
          this._eb = null;
          this._fw = null;
          this._i4 = 0;
          this._g1 = null;
          this._g2 = null;
          this._i4 = c._ep;
        }
        break;
    }
  }
  static staticInit() {
    WorksheetChart._d9 = WorksheetChart._ea();
  }
  /**
   * True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart. The [[rightAngleAxes]]  property must be True
   */
  get autoScaling() {
    return this._f2(1);
  }
  /**
   * True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart. The [[rightAngleAxes]]  property must be True
   */
  set autoScaling(a) {
    this._jm(0, 1, a);
  }
  axisCollection() {
    if (arguments.length !== 0) {
      let a = this._axisCollection$i;
      return a.item.apply(a, arguments);
    }
    return this._axisCollection$i;
  }
  /**
   * @hidden
   */
  get _axisCollection$i() {
    if (this._ef == null) {
      this._ef = new AxisCollection(this);
    }
    return this._ef;
  }
  /**
   * Returns a [[Wall]] object that allows the user to
   * format the back wall of a 3-D chart. Read-only.
   * @see [[floor]]
   * @see [[sideWall]]
   * @see [[wallDefault]]
   */
  get backWall() {
    if (this._fj == null) {
      this._fj = new Wall(this, 0);
    }
    return this._fj;
  }
  /**
   * Returns or sets the shape of [[Series]] bars.
   * Applicable only to 3D bar-type charts.
   * <p class="body">
   * This property is applicable only to the following chart types:
   * </p>
   * <p class="body">
   * <ul>
   * <li>Bar3DStacked</li>
   * <li>Column3DStacked</li>
   * <li>ConeBarStacked</li>
   * <li>ConeColStacked</li>
   * <li>PyramidBarStacked</li>
   * <li>PyramidColStacked</li>
   * <li>CylinderBarStacked</li>
   * <li>CylinderColStacked</li>
   * <li>Bar3DStacked100</li>
   * <li>Column3DStacked100</li>
   * <li>ConeBarStacked100</li>
   * <li>ConeColStacked100</li>
   * <li>PyramidBarStacked100</li>
   * <li>PyramidColStacked100</li>
   * <li>CylinderBarStacked100</li>
   * <li>CylinderColStacked100</li>
   * <li>Column3D</li>
   * <li>PyramidCol</li>
   * <li>ConeCol</li>
   * <li>CylinderCol</li>
   * </ul>
   * </p>
   * <p class="body">
   * Use this property to set the bar shape for all series bars.
   * </p>
   * <p class="body">
   * To set the shape for a particular series bar, use the [[Series.barShape]] property.
   * </p>
   * @see [[Series.barShape]]
   * @see [[chartType]]
   */
  get barShape() {
    return unwrapNullable(this._barShape$i);
  }
  /**
   * Returns or sets the shape of [[Series]] bars.
   * Applicable only to 3D bar-type charts.
   * <p class="body">
   * This property is applicable only to the following chart types:
   * </p>
   * <p class="body">
   * <ul>
   * <li>Bar3DStacked</li>
   * <li>Column3DStacked</li>
   * <li>ConeBarStacked</li>
   * <li>ConeColStacked</li>
   * <li>PyramidBarStacked</li>
   * <li>PyramidColStacked</li>
   * <li>CylinderBarStacked</li>
   * <li>CylinderColStacked</li>
   * <li>Bar3DStacked100</li>
   * <li>Column3DStacked100</li>
   * <li>ConeBarStacked100</li>
   * <li>ConeColStacked100</li>
   * <li>PyramidBarStacked100</li>
   * <li>PyramidColStacked100</li>
   * <li>CylinderBarStacked100</li>
   * <li>CylinderColStacked100</li>
   * <li>Column3D</li>
   * <li>PyramidCol</li>
   * <li>ConeCol</li>
   * <li>CylinderCol</li>
   * </ul>
   * </p>
   * <p class="body">
   * Use this property to set the bar shape for all series bars.
   * </p>
   * <p class="body">
   * To set the shape for a particular series bar, use the [[Series.barShape]] property.
   * </p>
   * @see [[Series.barShape]]
   * @see [[chartType]]
   */
  set barShape(a) {
    arguments[0] = wrapNullable(BarShape_$type, arguments[0]);
    this._barShape$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _barShape$i() {
    return this._iv;
  }
  /**
   * @hidden
   */
  set _barShape$i(a) {
    if (nullableNotEquals(a, this._iv)) {
      if (nullableNotEquals(this._iv, a)) {
        let b = this._jp(Nullable$1.$.specialize(BarShape_$type), 1, this._iv, a);
        this._iv = b.p1;
      }
    }
  }
  /**
   * Returns the resolved value of the [[barShape]] property.
   * @see [[barShape]]
   * @see [[Series.barShape]]
   */
  get barShapeResolved() {
    return this._iv.hasValue ? this._iv.value : this._ej;
  }
  /**
   * @hidden
   */
  get _ej() {
    return this._ek(this.chartType);
  }
  /**
   * @hidden
   */
  _ek(a) {
    switch (a) {
      case 102:
      case 103:
      case 104:
      case 105:
      case 99:
      case 100:
      case 101: return 5;
      case 95:
      case 96:
      case 97:
      case 98:
      case 92:
      case 93:
      case 94: return 3;
      case 109:
      case 110:
      case 111:
      case 112:
      case 106:
      case 107:
      case 108: return 2;
    }
    return 0;
  }
  /**
   * Returns a [[chartArea]] object that represents the complete chart area for the chart. Read-only.
   */
  get chartArea() {
    if (this._el == null) {
      this._el = new ChartArea(this);
    }
    return this._el;
  }
  /**
   * Returns or sets an [[chartTitle]] object.
   */
  get chartTitle() {
    return this._e1;
  }
  /**
   * Returns or sets an [[chartTitle]] object.
   */
  set chartTitle(a) {
    let b = this._e1;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._jp(ChartTitle.$, 2, this._e1, a);
      this._e1 = c.p1;
    }
  }
  /**
   * Specifies the chart type.
   * <p class="body">
   * All chart types are supported by the [[WorksheetChart]] type;
   * no derived classes exist or are necessary to support different chart types.
   * </p>
   * <p class="body">
   * Note that changing the chart type may cause related property values
   * to be changed.
   * </p>
   * <p class="body">
   * For example, when transitioning from a chart type which supports
   * line markers, The [[Series.markerStyle]] property is changed
   * to reflect the new chart style.
   * </p>
   * <p class="body">
   * Using another example, when transitioning from a chart type which does
   * not support <see cref="Axis">axes</see>, such as a pie or doughnut chart,
   * to a chart type that does support them, the [[axisCollection]]
   * is modified accordingly.
   * </p>
   * @see [[WorksheetShapeCollection.addChart]]
   */
  get chartType() {
    return this._e3;
  }
  /**
   * Specifies the chart type.
   * <p class="body">
   * All chart types are supported by the [[WorksheetChart]] type;
   * no derived classes exist or are necessary to support different chart types.
   * </p>
   * <p class="body">
   * Note that changing the chart type may cause related property values
   * to be changed.
   * </p>
   * <p class="body">
   * For example, when transitioning from a chart type which supports
   * line markers, The [[Series.markerStyle]] property is changed
   * to reflect the new chart style.
   * </p>
   * <p class="body">
   * Using another example, when transitioning from a chart type which does
   * not support <see cref="Axis">axes</see>, such as a pie or doughnut chart,
   * to a chart type that does support them, the [[axisCollection]]
   * is modified accordingly.
   * </p>
   * @see [[WorksheetShapeCollection.addChart]]
   */
  set chartType(a) {
    if (a != this._e3) {
      let b = this._e3;
      this._jw(b, a);
      this._ju(b, a);
      this._jx();
      WorksheetChart._jv(this.sheet, a);
      let c = this._i3(7);
      let d = this._jp(ChartType_$type, 3, this._e3, a);
      this._e3 = d.p1;
      this._jh(b, a);
      this._js();
      this._jj(c);
    }
  }
  comboChartGroups() {
    if (arguments.length !== 0) {
      let a = this._comboChartGroups$i;
      return a.item.apply(a, arguments);
    }
    return this._comboChartGroups$i;
  }
  /**
   * @hidden
   */
  get _comboChartGroups$i() {
    if (this._fu == null) {
      this._fu = new ComboChartGroupCollection(this);
    }
    return this._fu;
  }
  /**
   * Returns or sets the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
   */
  get depthPercent() {
    return this._g6;
  }
  /**
   * Returns or sets the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
   */
  set depthPercent(a) {
    if (a != this._g6) {
      let b = this._jp(Number_$type, 4, this._g6, a, (b) => DocCoreUtils.av(Number_$type, b, "DepthPercent", 20, 2000));
      this._g6 = b.p1;
    }
  }
  /**
   * Returns or sets the way that blank cells are plotted on a chart.
   */
  get displayBlanksAs() {
    return this._e6;
  }
  /**
   * Returns or sets the way that blank cells are plotted on a chart.
   */
  set displayBlanksAs(a) {
    if (a != this._e6) {
      let b = this._jo(DisplayBlanksAs_$type, 5, this._e6, a);
      this._e6 = b.p1;
    }
  }
  /**
   * Returns or sets the size of the hole in a doughnut chart,
   * expressed as a percentage of the size of the encompassing circle.
   * <p class="body">
   * This property is only applicable to doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 90, inclusive.
   * </p>
   */
  get doughnutHoleSize() {
    return this._g7;
  }
  /**
   * Returns or sets the size of the hole in a doughnut chart,
   * expressed as a percentage of the size of the encompassing circle.
   * <p class="body">
   * This property is only applicable to doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 90, inclusive.
   * </p>
   */
  set doughnutHoleSize(a) {
    if (a != this._g7) {
      let b = this._jp(Number_$type, 6, this._g7, a, (b) => DocCoreUtils.av(Number_$type, b, "DoughnutHoleSize", 0, 90));
      this._g7 = b.p1;
    }
  }
  /**
   * Returns or sets a [[ChartDropLines]] instance which determines
   * the appearance for a stock chart's drop lines.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * High/low lines are not displayed by default; to enable them,
   * assign a [[ChartDropLines]]to this property.
   * to null.
   * </p>
   */
  get dropLines() {
    return this._en;
  }
  /**
   * Returns or sets a [[ChartDropLines]] instance which determines
   * the appearance for a stock chart's drop lines.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * High/low lines are not displayed by default; to enable them,
   * assign a [[ChartDropLines]]to this property.
   * to null.
   * </p>
   */
  set dropLines(a) {
    let b = this._en;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._jp(ChartDropLines.$, 7, this._en, a);
      this._en = c.p1;
    }
  }
  /**
   * Returns a [[Wall]] object that allows the user to
   * format the bottom wall of a 3-D chart. Read-only.
   * @see [[backWall]]
   * @see [[sideWall]]
   * @see [[wallDefault]]
   */
  get floor() {
    if (this._fk == null) {
      this._fk = new Wall(this, 2);
    }
    return this._fk;
  }
  /**
   * Returns or sets the gap depth in a 3-D chart, expressed
   * as a percentage of the marker width. The value of this property must
   * be between 0 and 500.
   * @see [[gapWidth]]
   */
  get gapDepth() {
    return this._g9 >= 0 ? this._g9 : 150;
  }
  /**
   * Returns or sets the gap depth in a 3-D chart, expressed
   * as a percentage of the marker width. The value of this property must
   * be between 0 and 500.
   * @see [[gapWidth]]
   */
  set gapDepth(a) {
    if (a != this._g9) {
      let b = this._jp(Number_$type, 9, this._g9, a, (b) => DocCoreUtils.av(Number_$type, b, "GapDepth", -1, 500));
      this._g9 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _ix() {
    if (this._g9 < 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    else {
      return Nullable$1.toNullable(Number_$type, this._g9);
    }
  }
  /**
   * Returns or sets the distance between the data series in a bar chart,
   * as a percentage of the marker width. The value of this property must
   * be between 0 and 500.
   * @see [[gapDepth]]
   */
  get gapWidth() {
    return this._ha >= 0 ? this._ha : 150;
  }
  /**
   * Returns or sets the distance between the data series in a bar chart,
   * as a percentage of the marker width. The value of this property must
   * be between 0 and 500.
   * @see [[gapDepth]]
   */
  set gapWidth(a) {
    if (a != this._ha) {
      let b = this._jp(Number_$type, 10, this._ha, a, (b) => DocCoreUtils.av(Number_$type, b, "GapWidth", -1, 500));
      this._ha = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _iy() {
    if (this._ha < 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    else {
      return Nullable$1.toNullable(Number_$type, this._ha);
    }
  }
  /**
   * Returns or sets the angle which determines the origin of the first
   * slice, as relative to the 12 o'clock position of the emcompassing circle.
   * <p class="body">
   * This property is only applicable to pie and doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 360, inclusive. Fractional
   * angles are not supported; nor are negative angles.
   * </p>
   * <p class="body">
   * By default, the first slice begins at the "12 o'clock" position of the
   * pie chart, i.e., the top center point of the encompassing circle.
   * </p>
   * <p class="body">
   * Use this property to offset the origin of the first slice; for example, a
   * value of 30 positions the first slice at the 1 o'clock position, 60 at the
   * 2 o'clock position, 90 for 3 o'clock, etc.
   * </p>
   * <p class="body">
   * Larger values move along the circumference of the emcompassing circle
   * in a clockwise direction, with a value of 0 or 360 both coinciding with
   * the 12 o'clock position.
   * </p>
   */
  get firstSliceAngle() {
    return this._g8;
  }
  /**
   * Returns or sets the angle which determines the origin of the first
   * slice, as relative to the 12 o'clock position of the emcompassing circle.
   * <p class="body">
   * This property is only applicable to pie and doughnut charts.
   * </p>
   * <p class="body">
   * The valid range for this property is 0 through 360, inclusive. Fractional
   * angles are not supported; nor are negative angles.
   * </p>
   * <p class="body">
   * By default, the first slice begins at the "12 o'clock" position of the
   * pie chart, i.e., the top center point of the encompassing circle.
   * </p>
   * <p class="body">
   * Use this property to offset the origin of the first slice; for example, a
   * value of 30 positions the first slice at the 1 o'clock position, 60 at the
   * 2 o'clock position, 90 for 3 o'clock, etc.
   * </p>
   * <p class="body">
   * Larger values move along the circumference of the emcompassing circle
   * in a clockwise direction, with a value of 0 or 360 both coinciding with
   * the 12 o'clock position.
   * </p>
   */
  set firstSliceAngle(a) {
    if (a != this._g8) {
      let b = this._jp(Number_$type, 8, this._g8, a, (b) => DocCoreUtils.av(Number_$type, b, "FirstSliceAngle", 0, 360));
      this._g8 = b.p1;
    }
  }
  /**
   * Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
   */
  get heightPercent() {
    return this._hb;
  }
  /**
   * Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
   */
  set heightPercent(a) {
    if (a != this._hb) {
      let b = this._jp(Number_$type, 11, this._hb, a, (b) => DocCoreUtils.av(Number_$type, b, "HeightPercent", 5, 500));
      this._hb = b.p1;
    }
  }
  /**
   * Returns or sets a [[ChartHighLowLines]] instance which determines
   * the appearance for a stock chart's high/low lines.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * High/low lines depict the high and low prices for a stock chart.
   * </p>
   * <p class="body">
   * High/low lines are displayed by default; to disable them, set this property
   * to null.
   * </p>
   */
  get highLowLines() {
    return this._er;
  }
  /**
   * Returns or sets a [[ChartHighLowLines]] instance which determines
   * the appearance for a stock chart's high/low lines.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * High/low lines depict the high and low prices for a stock chart.
   * </p>
   * <p class="body">
   * High/low lines are displayed by default; to disable them, set this property
   * to null.
   * </p>
   */
  set highLowLines(a) {
    let b = this._er;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._jp(ChartHighLowLines.$, 12, this._er, a);
      this._er = c.p1;
    }
  }
  /**
   * Returns or sets a [[legend]] object which represents
   * the legend for the chart.
   */
  get legend() {
    return this._e8;
  }
  /**
   * Returns or sets a [[legend]] object which represents
   * the legend for the chart.
   */
  set legend(a) {
    let b = this._e8;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      let c = null;
      if (b != null) {
        b._l(null);
        if (b._legendEntries$i.count > 0) {
          c = b._legendEntries$i._w();
          b._legendEntries$i._ad();
        }
      }
      this._e8 = a;
      if (this._e8 != null && this._fc != null) {
        this._fc._a0();
      }
      let d = WorksheetChart._d9[13];
      let e = new WorksheetChart_LegendChangeContext(1, this, b, c);
      d.x(e, null, null);
    }
  }
  /**
   * Returns or sets a value that represents the perspective
   * for the 3-D chart view, expressed in degrees.
   * <p class="body">
   * This property supports values within the inclusive range of <b>0</b> and <b>120</b>.
   * </p>
   */
  get perspective() {
    return this._hc;
  }
  /**
   * Returns or sets a value that represents the perspective
   * for the 3-D chart view, expressed in degrees.
   * <p class="body">
   * This property supports values within the inclusive range of <b>0</b> and <b>120</b>.
   * </p>
   */
  set perspective(a) {
    if (a != this._hc) {
      let b = this._jp(Number_$type, 14, this._hc, a, (b) => DocCoreUtils.av(Number_$type, b, "Perspective", 0, 120));
      this._hc = b.p1;
    }
  }
  /**
   * Returns a PlotArea object that represents the plot area of a chart. Read-only.
   */
  get plotArea() {
    if (this._fa == null) {
      this._fa = new PlotArea(this);
    }
    return this._fa;
  }
  /**
   * True if only visible cells are plotted. False if both visible and hidden cells are plotted.
   */
  get plotVisibleOnly() {
    return this._f2(8);
  }
  /**
   * True if only visible cells are plotted. False if both visible and hidden cells are plotted.
   */
  set plotVisibleOnly(a) {
    this._jm(15, 8, a);
  }
  /**
   * True if the chart axes are at right angles, independent of chart rotation or elevation. Applies only to 3-D line, column, and bar charts.
   */
  get rightAngleAxes() {
    return this._f2(16);
  }
  /**
   * True if the chart axes are at right angles, independent of chart rotation or elevation. Applies only to 3-D line, column, and bar charts.
   */
  set rightAngleAxes(a) {
    this._jm(16, 16, a);
  }
  /**
   * Returns or sets the rotation of a 3-D chart view around the X-axis, expressed in degrees.
   * <p class="body">
   * This property controls the viewing perspective by rotating the
   * chart around the horizontal axis, such that the top of the chart
   * appears to move closer or further away.
   * </p>
   * <p class="body">
   * This property is only applicable to 3D charts.
   * </p>
   * @see [[rotationY]]
   */
  get rotationX() {
    return this._hd;
  }
  /**
   * Returns or sets the rotation of a 3-D chart view around the X-axis, expressed in degrees.
   * <p class="body">
   * This property controls the viewing perspective by rotating the
   * chart around the horizontal axis, such that the top of the chart
   * appears to move closer or further away.
   * </p>
   * <p class="body">
   * This property is only applicable to 3D charts.
   * </p>
   * @see [[rotationY]]
   */
  set rotationX(a) {
    if (a != this._hd) {
      let b = this._jp(Number_$type, 17, this._hd, a, (b) => DocCoreUtils.av(Number_$type, b, "RotationX", -90, 90));
      this._hd = b.p1;
    }
  }
  /**
   * Returns or sets the rotation of a 3-D chart view around the Y-axis, expressed in degrees.
   * <p class="body">
   * This property controls the viewing perspective by rotating the
   * chart around the vertical axis, such that the left edge of the chart
   * appears to move closer or further away.
   * </p>
   * <p class="body">
   * This property is only applicable to 3D charts.
   * </p>
   * @see [[rotationX]]
   */
  get rotationY() {
    return this._he;
  }
  /**
   * Returns or sets the rotation of a 3-D chart view around the Y-axis, expressed in degrees.
   * <p class="body">
   * This property controls the viewing perspective by rotating the
   * chart around the vertical axis, such that the left edge of the chart
   * appears to move closer or further away.
   * </p>
   * <p class="body">
   * This property is only applicable to 3D charts.
   * </p>
   * @see [[rotationX]]
   */
  set rotationY(a) {
    if (a != this._he) {
      let b = this._jp(Number_$type, 18, this._he, a, (b) => DocCoreUtils.av(Number_$type, b, "RotationY", -90, 90));
      this._he = b.p1;
    }
  }
  /**
   * Returns or sets the size of the second plot area in a 'bar of pie'
   * or 'pie of pie' chart, expressed as a percentage of the first plot
   * area's size.
   * <p class="body">
   * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
   * <see cref="WorksheetChart.ChartType">chart types</see>.
   * </p>
   * <p class="body">
   * This property supports values in the range of <b>5</b>  to <b>200</b>, inclusively.
   * </p>
   */
  get secondPlotSize() {
    return this._hf;
  }
  /**
   * Returns or sets the size of the second plot area in a 'bar of pie'
   * or 'pie of pie' chart, expressed as a percentage of the first plot
   * area's size.
   * <p class="body">
   * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
   * <see cref="WorksheetChart.ChartType">chart types</see>.
   * </p>
   * <p class="body">
   * This property supports values in the range of <b>5</b>  to <b>200</b>, inclusively.
   * </p>
   */
  set secondPlotSize(a) {
    if (a != this._hf) {
      let b = this._jp(Number_$type, 19, this._hf, a, (b) => DocCoreUtils.av(Number_$type, b, "SecondPlotSize", 5, 200));
      this._hf = b.p1;
    }
  }
  seriesCollection() {
    if (arguments.length !== 0) {
      let a = this._seriesCollection$i;
      return a.item.apply(a, arguments);
    }
    return this._seriesCollection$i;
  }
  /**
   * @hidden
   */
  get _seriesCollection$i() {
    if (this._fc == null) {
      this._fc = new SeriesCollection(this);
      this._fc._a0();
    }
    return this._fc;
  }
  /**
   * Determines the <see cref="ChartLineBase.Fill">fill</see> and
   * <see cref="ChartLineBase.WidthInPoints">width</see> for the lines
   * which connect the first and second plot areas in a 'bar of pie'
   * or 'pie of pie' chart.
   * <p class="body">
   * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
   * <see cref="WorksheetChart.ChartType">chart types</see>.
   * </p>
   * @see [[secondPlotSize]]
   */
  get seriesLines() {
    return this._et;
  }
  /**
   * Determines the <see cref="ChartLineBase.Fill">fill</see> and
   * <see cref="ChartLineBase.WidthInPoints">width</see> for the lines
   * which connect the first and second plot areas in a 'bar of pie'
   * or 'pie of pie' chart.
   * <p class="body">
   * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
   * <see cref="WorksheetChart.ChartType">chart types</see>.
   * </p>
   * @see [[secondPlotSize]]
   */
  set seriesLines(a) {
    if (a != this._et) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      if (this._et != null) {
        this._et._l(null);
      }
      let b = this._jp(ChartSeriesLines.$, 20, this._et, a);
      this._et = b.p1;
    }
  }
  /**
   * Determines the amount by which intersecting [[Series]] overlap,
   * expressed as a percentage of the bar size.
   * <p class="body">
   * This property is only applicable for 2D bar charts.
   * </p>
   * @see [[gapDepth]]
   * @see [[gapWidth]]
   */
  get seriesOverlap() {
    return this._hg;
  }
  /**
   * Determines the amount by which intersecting [[Series]] overlap,
   * expressed as a percentage of the bar size.
   * <p class="body">
   * This property is only applicable for 2D bar charts.
   * </p>
   * @see [[gapDepth]]
   * @see [[gapWidth]]
   */
  set seriesOverlap(a) {
    if (a != this._hg) {
      let b = this._jp(Number_$type, 21, this._hg, a, (b) => DocCoreUtils.av(Number_$type, b, "SeriesOverlap", -100, 100));
      this._hg = b.p1;
    }
  }
  /**
   * Returns a [[Wall]] object that allows the user to
   * format the side wall of a 3-D chart. Read-only.
   * @see [[floor]]
   * @see [[backWall]]
   * @see [[wallDefault]]
   */
  get sideWall() {
    if (this._fl == null) {
      this._fl = new Wall(this, 1);
    }
    return this._fl;
  }
  /**
   * Returns or sets a [[UpDownBars]] instance which determines
   * the appearance for a stock chart's up/down bars.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * Up/down bars depict gains or losses across a series for a stock chart.
   * </p>
   */
  get upDownBars() {
    return this._fh;
  }
  /**
   * Returns or sets a [[UpDownBars]] instance which determines
   * the appearance for a stock chart's up/down bars.
   * <p class="body">
   * This property is only applicable for stock charts.
   * </p>
   * <p class="body">
   * Up/down bars depict gains or losses across a series for a stock chart.
   * </p>
   */
  set upDownBars(a) {
    let b = this._fh;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._jp(UpDownBars.$, 22, this._fh, a);
      this._fh = c.p1;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether the fill colors
   * for <see cref="Series">series</see> and <see cref="DataPoint">data points</see>
   * are automatically selected by Excel.
   * <p class="body">
   * This property defaults to <b>true</b>, causing fill colors for
   * series and data points to be automatically selected by Excel.
   * </p>
   * <p class="body">
   * The automatically selected color can always be overridden for individual series
   * and/or data points using the [[Series.fill]], [[Series.line]],
   * and [[DataPoint.fill]] properties.
   * </p>
   * <p class="body">
   * In cases where VaryColors is set to true, but a fill is explicitly assigned,
   * the assigned fill is used for the associated series or data point, while series
   * or data points which have no explicitly assigned fill will have a fill color
   * automatically selected.
   * </p>
   * @see [[Series.fill]]
   * @see [[Series.line]]
   * @see [[DataPoint.fill]]
   */
  get varyColors() {
    return this._f2(32);
  }
  /**
   * Returns or sets a boolean value indicating whether the fill colors
   * for <see cref="Series">series</see> and <see cref="DataPoint">data points</see>
   * are automatically selected by Excel.
   * <p class="body">
   * This property defaults to <b>true</b>, causing fill colors for
   * series and data points to be automatically selected by Excel.
   * </p>
   * <p class="body">
   * The automatically selected color can always be overridden for individual series
   * and/or data points using the [[Series.fill]], [[Series.line]],
   * and [[DataPoint.fill]] properties.
   * </p>
   * <p class="body">
   * In cases where VaryColors is set to true, but a fill is explicitly assigned,
   * the assigned fill is used for the associated series or data point, while series
   * or data points which have no explicitly assigned fill will have a fill color
   * automatically selected.
   * </p>
   * @see [[Series.fill]]
   * @see [[Series.line]]
   * @see [[DataPoint.fill]]
   */
  set varyColors(a) {
    this._jm(23, 32, a);
  }
  /**
   * Returns a [[Wall]] object which represents the back and side
   * walls, and floor of the chart. Applicable only for 3-D charts.
   * <p class="body">
   * Use this property to apply the same settings for the back wall, side wall, and floor.
   * </p>
   * <p class="body">
   * Use the [[backWall]] property to control the appearance of the back wall.
   * </p>
   * <p class="body">
   * Use the [[sideWall]] property to control the appearance of the side wall.
   * </p>
   * <p class="body">
   * Use the [[floor]] property to control the appearance of the bottom wall.
   * </p>
   * <p class="body">
   * The BackWall, SideWall, and Floor properties take precedence over this property.
   * </p>
   * @see [[backWall]]
   * @see [[sideWall]]
   * @see [[floor]]
   */
  get wallDefault() {
    if (this._fm == null) {
      this._fm = new Wall(this, 3);
    }
    return this._fm;
  }
  /**
   * Gets the worksheet on which the shape resides.
   */
  get_sheet() {
    return this._fy != null ? this._fy : super.get_sheet();
  }
  /**
   * @hidden
   */
  get _ez() {
    if (this._ew == null) {
      this._ew = new ChartSolidFill(new WorkbookColorInfo(1));
      this._ew._l(this);
    }
    return this._ew;
  }
  /**
   * @hidden
   */
  get _e0() {
    if (this._ex == null) {
      this._ex = new ChartSolidFill(new WorkbookColorInfo(0));
      this._ex._l(this);
    }
    return this._ex;
  }
  /**
   * @hidden
   */
  get _ey() {
    if (this._ev == null) {
      this._ev = new ChartSolidFill(new WorkbookColorInfo(4));
      this._ev._l(this);
    }
    return this._ev;
  }
  /**
   * @hidden
   */
  get _eq() {
    if (this._ep == null) {
      this._ep = new ChartEmptyFill();
      this._ep._l(this);
    }
    return this._ep;
  }
  /**
   * @hidden
   */
  get _gc() {
    return this._f2(2);
  }
  /**
   * @hidden
   */
  get _gu() {
    let a = this._fx;
    return a != null && a.a != null;
  }
  /**
   * @hidden
   */
  get _gv() {
    let a = this._fx;
    return a != null && a.c != null && a.d != null;
  }
  /**
   * @hidden
   */
  get _gt() {
    if (this.chartType == -4169) {
      return false;
    }
    return this.varyColors;
  }
  /**
   * Sets the source data range for a combo chart.
   * <p class="body">
   * Combo charts support multiple chart types within the main chart, with each different
   * chart type being associated with one or more [[Series]].
   * </p>
   * <p class="body">
   * Use this method to populate the [[seriesCollection]] for a combo chart.
   * </p>
   * <p class="body">
   * For example, given a 'dataRange' which yields three series, the caller
   * can specify an array with three elements as the value of the 'seriesChartTypes'
   * parameter. Each array element is then applied to the corresponding series, in the same order
   * in which they appear in the array.
   * </p>
   * <p class="body">
   * Duplicate ChartType values can appear in the 'seriesChartTypes' array,
   * in which case the corresponding series appear within the same chart. For example, specifying
   * an array with <i>ClusteredColumn</i>, <i>Line</i>, and <i>Line</i> results in a combo chart
   * with the first series appearing in a clustered column chart, and the remaining series appearing
   * in a line chart.
   * </p>
   * <p class="body">
   * Specifying null for the value of the 'seriesChartTypes' parameter
   * is treated the same as a two-element array containing 'ColumnClustered' and 'Line',
   * resulting in a clustered column chart for the first series, and a line chart for the
   * remaining series.
   * </p>
   * <p class="body">
   * If fewer values are present in the 'seriesChartTypes' array than the
   * number of series yielded from the specified 'dataRange', the remaining
   * series acquire the same ChartType and AxisGroup as the last element in the <i>seriesChartTypes</i>
   * array. If more values are present in the array than the number of series yielded, these values
   * are ignored.
   * </p>
   * <p class="body">
   * Certain chart type values are invalid for a combo chart; if any of these chart types
   * are present in the array, an exception is thrown, listing the invalid chart types.
   * </p>
   * <p class="body">
   * The following table lists the ChartType values which are supported in combo charts,
   * grouped by series type:
   * </p>
   * <p class="body">
   * <table border = "1" >
   * <tr><th> SeriesType </th ><th>ChartType (supported in combo charts)</th></tr>
   * <tr>
   *  <td>Area</td><td>Area, AreaStacked, AreaStacked100</td>
   * </tr>
   * 	<tr>
   * 		<td>Bar</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, BarClustered, BarStacked, BarStacked100, BarOfPie</td>
   * 	</tr>
   * 	<tr>
   * 		<td>Line</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100</td>
   * 	</tr>
   * 	<tr>
   * 		<td>Pie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td>
   * 	</tr>
   * 	<tr>
   * 		<td>Radar</td><td>Radar, RadarFilled, RadarMarkers</td>
   * 	</tr>
   * 	<tr>
   * 		<td>Scatter</td><td>XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td>
   * 	</tr>
   * 	<tr>
   * 		<td>Bubble</td><td><b>Not Supported</b></td>
   * 	</tr>
   * 	<tr>
   * 		<td>Surface</td><td><b>Not Supported</b></td>
   * 	</tr>
   * </table>
   * </p>
   * <p class="body">
   * Combo charts support a maximum of two axis groups. If the combination of values in the
   * 'seriesChartTypes' array necessitates more than two axis groups, an exception
   * is thrown.
   * </p>
   * <p class="body">
   * Combo charts require a minimum of two [[Series]]. If the specified 'dataRange'
   * yields less that two series, an exception is thrown.
   * </p>
   * <p class="body">
   * If the combination of series used in a combo chart is indistinguishable from a non-combo
   * chart, the chart may not be recognized by Excel as a combo chart. For example, adding two
   * series, one of type <i>Radar</i> and one of type <i>RadarMarkers</i>, is a valid combination.
   * When opened in Excel, however, such a chart will not be recognized as a combo chart, since the
   * combination of series does not necessitate multiple chart elements. All relevant property values
   * are persisted, however, and there is no distinguishable difference between the original chart
   * and the serialized one.
   * </p>
   * @param dataRange The data range for the combo chart
   * @param seriesChartTypes An array of [[chartType]] constants which specify the chart type for each series
   * yielded from the specified 'dataRange'.
   * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
   * @param cellReferenceMode Optional. Determines how to parse the dataRange.
   * @see [[Series]]
   * @see [[Axis]]
   * @see [[Series.chartType]]
   * @see [[Series.axisGroup]]
   * @throws [[BaseError]] The current value of the [[chartType]] property is not <i>Combo</i>.
   * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains one or more values which are not
   * supported within a combo chart.
   * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains a combination of values which
   * would require more than the maximum allowable number of axes (two).
   */
  setComboChartSourceData(dataRange, seriesChartTypes, plotByRows, cellReferenceMode) {
    arguments[2] = (arguments[2] !== void 0 ? arguments[2] : false);
    if (arguments[3] !== void 0) {
      arguments[3] = wrapNullable(CellReferenceMode_$type, arguments[3]);
    }
    return this._setComboChartSourceData$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setComboChartSourceData$i(a, b, c = false, d = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    if (this.chartType != 113) {
      throw new BaseError(1, ExcelUtils.eg("LE_WorksheetChart_SetComboChartSourceData_NotAComboChart", enumGetBox(ChartType_$type, this.chartType)));
    }
    if (b == null || b.length == 0) {
      b = [51, 4];
    }
    this._jr(a, c, d, b);
  }
  /**
   * Sets the source data range for the chart.
   * <p class="data">
   * For combo charts, this method always displays the first series in a clustered column chart,
   * with all subsequent series displayed in line charts. Use the [[setComboChartSourceData]]
   * to customize the series charts for a combo chart.
   * </p>
   * @param dataRange The data range for the chart
   * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
   * @param cellReferenceMode Optional. Determines how to parse the dataRange.
   */
  setSourceData(dataRange, plotByRows, cellReferenceMode) {
    arguments[1] = (arguments[1] !== void 0 ? arguments[1] : false);
    if (arguments[2] !== void 0) {
      arguments[2] = wrapNullable(CellReferenceMode_$type, arguments[2]);
    }
    return this._setSourceData$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setSourceData$i(a, b = false, c = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    let d = null;
    if (this.chartType == 113) {
      d = [51, 4];
    }
    this._jr(a, b, c, d);
  }
  /**
   * @hidden
   */
  _jr(a, b, c, d) {
    this._jx();
    let e = this.chartType;
    let f = WorksheetChart._f9(e);
    if (f) {
      b = false;
    }
    DocCoreUtils.au(a, "dataRange");
    if (nullableNotEquals(c, null)) {
      ExcelUtils.gm(CellReferenceMode_$type, c.value, "cellReferenceMode");
    }
    let g = null;
    if (d != null && d.length > 0) {
      if (e != 113) {
        throw new BaseError(1, ExcelUtils.eg("LE_WorksheetChart_SetComboChartSourceData_SeriesChartTypesNotSupported", enumGetBox(ChartType_$type, e)));
      }
      else {
        let h;
        if (((() => { let i = WorksheetChart._gn(d, h); h = i.p1; return i.ret; })()) == false) {
          throw new BaseError(1, ExcelUtils.eg("LE_WorksheetChart_SetComboChartSourceData_InvalidChartTypes", ExcelUtils.ei(h)));
        }
        g = ComboChartGroupValidator.d(d);
        if (g.d == false) {
          throw new NotSupportedException(1, ExcelUtils.ef("LE_WorksheetChart_SetSourceData_TooManyAxes"));
        }
        else if (g.c != null) {
          d = g.c;
        }
      }
    }
    let i = this.sheet;
    let j = !nullableIsNull(c) ? c.value : i.workbook.cellReferenceMode;
    let k = a.split(',');
    let l = Math.max(1, k != null ? k.length : 1);
    let m = new List$1(Tuple$3.$.specialize(Worksheet.$, WorksheetRegionAddress.$, String_$type), 0);
    let n = 0;
    ExcelUtils.ga(i, a, b, false, null, j, (o) => n = o, () => {
    }, (o, p, q, r) => {
      if (o != null) {
        if (b) {
        }
        else {
        }
        m.add(Tuple.b(Worksheet.$, WorksheetRegionAddress.$, String_$type, o, q, r));
      }
    });
    if (m.count == 0) {
      return;
    }
    let o = this._i3(7);
    this._js();
    let p = false;
    let q = false;
    switch (e) {
      case 15:
      case 87:
        q = true;
        break;
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73:
        p = true;
        break;
    }
    let r = 0;
    let s = 0;
    if (n > 1) {
      for (let t = 0; t < m.count; t++) {
        let u = m._inner[t];
        if (u.c == null) {
          break;
        }
        let v = this._hl(u.c, u.d);
        if (t == 0) {
          if (v == 0) {
            break;
          }
          r = v;
          s = 1;
        }
        else {
          if (v < r) {
            break;
          }
          s++;
        }
      }
      if (r == 0) {
        let w = m.count;
        let x = m._inner[0];
        let y = x.d;
        let z = b ? y._e(y._w)._f(y._ac + w - 1) : y._f(y._ac)._e((y._w + w - 1));
        let aa = b ? y._af - 1 : y._ad - 1;
        let ab = Math.max(1, (w + 0.001) / (2 * l));
        for (let ac = 0; ac < aa; ac++) {
          let ad = b ? z._c((z._w + ac))._e((z._w + ac)) : z._d(z._ac + ac)._f(z._ac + ac);
          let ae = this._hm(x.c, ad);
          if (ae >= ab) {
            r++;
          }
          else {
            break;
          }
        }
      }
      if (r == 0 && s == 0) {
        let af = m._inner[0];
        let ag = af.d;
        let ah = b ? ag._c((ag._w + r)) : ag._d(ag._ac + r);
        let ai = b ? ah._af - r : ah._ad - r;
        if (ai > 0) {
          let aj = Math.max(1, (ai + 0.001) / (2 * l));
          for (let ak = 0; ak < m.count - 1; ak++) {
            let al = b ? ah._d(ah._ac + ak)._f(ah._ac + ak) : ah._c((ah._w + ak))._e((ah._w + ak));
            let am = this._hm(af.c, al);
            if (am >= aj) {
              s++;
            }
            else {
              break;
            }
          }
        }
      }
    }
    this._seriesCollection$i.clear();
    if (r < n && s < m.count) {
      this._i8();
      try {
        if (f) {
          this._i7(this, i, m, e);
        }
        else {
          let an = ExcelUtils.q(e);
          this._i6(b, i, q, p, m, r, s, Nullable$1.toNullable(ChartType_$type, e), Nullable$1.toNullable(SeriesType_$type, an));
          if (d != null && d.length > 0) {
            if (this._seriesCollection$i.count < 2) {
              throw new BaseError(1, ExcelUtils.ef("LE_WorksheetChart_SetSourceData_NotEnoughSeries"));
            }
            let ao = g.b(d);
            let ap = ComboChartGroupValidator.ac(this._seriesCollection$i, d, ao);
            d = ap.p1;
            ao = ap.p2;
            for (let aq = 0; aq < this._seriesCollection$i.count; aq++) {
              let ar = this._seriesCollection$i.item(aq);
              let as = d[aq];
              an = ExcelUtils.q(as);
              let at = ao[aq];
              ar.chartType = as;
              ar.type = an;
              ar.axisGroup = at;
            }
          }
        }
      }
      finally {
        this._ja();
      }
    }
    this._jf(e);
    this._jj(o);
  }
  /**
   * @hidden
   */
  _jb() {
    let a = this._axisCollection$i;
    if (a.item(1, 2) == null) {
      a.add(1, 2);
    }
    if (a.item(2, 2) == null) {
      a.add(2, 2);
    }
  }
  /**
   * @hidden
   */
  _g5() {
    let a = new List$1(LegendEntry.$, 0);
    if (this.legend != null) {
      for (let b of fromEnum(this.legend._legendEntries$i)) {
        a.add(b);
      }
    }
    for (let c of fromEnum(this._seriesCollection$i)) {
      for (let d of fromEnum(c._trendlineCollection$i)) {
        a.add(d.legendEntry);
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  static _i0(a) {
    switch (a) {
      case 88: return Nullable$1.toNullable(Number_$type, 3);
      case 89:
      case 90: return Nullable$1.toNullable(Number_$type, 4);
      case 91: return Nullable$1.toNullable(Number_$type, 5);
      default: return Nullable$1.toNullable(Number_$type, null);
    }
  }
  /**
   * @hidden
   */
  static _g0(a) {
    let b = new HashSet$1(ChartType_$type, 0);
    if (a.hasValue && Series._bz(a.value) == false) {
      return b;
    }
    if (a.hasValue == false || a.value == 0) {
      b.add_1(1);
      b.add_1(76);
      b.add_1(77);
    }
    if (a.hasValue == false || a.value == 1) {
      b.add_1(51);
      b.add_1(52);
      b.add_1(53);
      b.add_1(57);
      b.add_1(58);
      b.add_1(59);
    }
    if (a.hasValue == false || a.value == 2) {
      b.add_1(4);
      b.add_1(63);
      b.add_1(64);
      b.add_1(65);
      b.add_1(66);
      b.add_1(67);
    }
    if (a.hasValue == false || a.value == 3) {
      b.add_1(5);
      b.add_1(69);
      b.add_1(71);
      b.add_1(68);
      b.add_1(-4120);
      b.add_1(80);
    }
    if (a.hasValue == false || a.value == 6) {
      b.add_1(-4169);
      b.add_1(74);
      b.add_1(75);
      b.add_1(72);
      b.add_1(73);
    }
    if (a.hasValue == false || a.value == 4) {
      b.add_1(-4151);
      b.add_1(82);
      b.add_1(81);
    }
    return b;
  }
  /**
   * @hidden
   */
  static _gm(a) {
    let b = null;
    return ((() => { let c = WorksheetChart._gn(a, b); b = c.p1; return c.ret; })());
  }
  /**
   * @hidden
   */
  static _gn(a, b) {
    b = null;
    let c = new HashSet$1(ChartType_$type, 0);
    for (let e = 0; e < a.length; e++) {
      let d = a[e];
      if (WorksheetChart._go(d) == false) {
        c.add_1(d);
      }
    }
    b = new Array(c.count);
    if (c.count > 0) {
      let f = 0;
      for (let g of fromEnum(c)) {
        b[f] = g;
        f += 1;
      }
    }
    return {
      ret: b.length == 0,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _go(a) {
    switch (a) {
      case 51:
      case 52:
      case 53:
      case 57:
      case 58:
      case 59:
      case 4:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 1:
      case 76:
      case 77:
      case 5:
      case 69:
      case 71:
      case 68:
      case -4120:
      case 80:
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73:
      case -4151:
      case 82:
      case 81: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _f8(a, b, c) {
    b = false;
    c = false;
    switch (a) {
      case 57:
      case 60:
      case 109:
      case 102:
      case 95:
        b = false;
        c = true;
        break;
      case 58:
      case 59:
      case 61:
      case 62:
      case 110:
      case 111:
      case 96:
      case 97:
      case 103:
      case 104:
        b = false;
        c = false;
        break;
      case -4100:
      case 105:
        b = true;
        c = false;
        break;
      case 51:
      case 54:
      case 106:
      case 92:
      case 99:
        b = true;
        c = true;
        break;
      case 52:
      case 53:
      case 55:
      case 56:
      case 107:
      case 108:
      case 93:
      case 94:
      case 100:
      case 101:
        b = true;
        c = false;
        break;
      default: return {
        ret: false,
        p1: b,
        p2: c
      };
    }
    return {
      ret: true,
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _gd(a, b = 0) {
    if (WorksheetChart._gg(a)) {
      return true;
    }
    if (b == 1) {
      if (WorksheetChart._gk(a)) {
        return true;
      }
    }
    switch (a) {
      case 4:
      case -4101:
      case 65:
      case 66:
      case 67:
      case 63:
      case 64:
      case -4151:
      case 81: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _ge(a) {
    switch (a) {
      case 71:
      case 5:
      case -4102:
      case 70:
      case 69:
      case 68:
      case -4120:
      case 80: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gk(a) {
    switch (a) {
      case 88:
      case 89:
      case 90:
      case 91: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _f7(a) {
    switch (a) {
      case 1:
      case 76:
      case 77:
      case -4098:
      case 78:
      case 79: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gl(a) {
    switch (a) {
      case 83:
      case 85:
      case 86:
      case 84: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gf(a) {
    switch (a) {
      case -4151:
      case 82:
      case 81: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gg(a) {
    switch (a) {
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gh(a) {
    if (WorksheetChart._gg(a)) {
      return true;
    }
    switch (a) {
      case 15:
      case 87: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _f9(a) {
    switch (a) {
      case 114:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 115:
      case 121: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _f3(a) {
    switch (a) {
      case 5:
      case 69:
      case -4102:
      case 70:
      case -4120:
      case 80:
      case 71:
      case 68:
      case 118:
      case 119: return false;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  static _gr(a) {
    switch (a) {
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73:
      case 15:
      case 87: return false;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  static _f4(a) {
    switch (a) {
      case 65:
      case 66:
      case 67:
      case -4169:
      case 74:
      case 72:
      case 81: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _jd(a, b, c) {
    b = null;
    c = Nullable$1.toNullable(MarkerStyle_$type, null);
    switch (a) {
      case -4169:
        b = new ChartEmptyFill();
        c = Nullable$1.toNullable(MarkerStyle_$type, -4105);
        break;
      case 75:
      case 73:
        c = Nullable$1.toNullable(MarkerStyle_$type, -4142);
        break;
      case 81:
      case 65:
      case 66:
      case 67:
        c = Nullable$1.toNullable(MarkerStyle_$type, -4105);
        break;
      case -4151:
        c = Nullable$1.toNullable(MarkerStyle_$type, -4142);
        break;
    }
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _i8(a = null) {
    this._fy = a;
    this._jl(2, true);
  }
  /**
   * @hidden
   */
  _ja() {
    this._fy = null;
    this._jl(2, false);
  }
  /**
   * @hidden
   */
  static _gx(a) {
    switch (a) {
      case 4:
      case 65:
      case 66:
      case 67:
      case 63:
      case 64:
      case -4169:
      case 74:
      case 75:
      case 72:
      case 73:
      case -4151:
      case 81: return false;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  _je() {
    let a = null;
    if (this.chartArea.fill == null) {
      a = new WorkbookColorInfo(0);
      this.chartArea.fill = new ChartSolidFill(a);
    }
    if (WorksheetChart._f4(this.chartType)) {
      this._seriesCollection$i._ay(8);
    }
    this._jl(32, true);
    let b = this.chartType;
    switch (b) {
      case 85:
      case 86:
        this._hd = 90;
        this._he = 0;
        break;
      case 71:
      case 68:
        if (this.seriesLines == null) {
          a = new WorkbookColorInfo(1);
          this.seriesLines = ((() => {
            let $ret = new ChartSeriesLines();
            $ret.fill = new ChartSolidFill(a);
            return $ret;
          })());
        }
        break;
      case 88:
      case 89:
      case 90:
      case 91:
        this._er = new ChartHighLowLines();
        switch (this.chartType) {
          case 89:
          case 91:
            this._fh = new UpDownBars();
            break;
        }
        break;
      case -4098:
      case 78:
      case 79:
        this._g9 = 150;
        break;
      case -4101:
        this._g9 = 150;
        break;
      case 52:
      case 53:
        this._hg = 100;
        break;
    }
    if (WorksheetChart._f6(b)) {
      let c = new Array(2);
      if (((() => { let d = WorksheetChart._f8(b, c[0], c[1]); c[0] = d.p1; c[1] = d.p2; return d.ret; })())) {
        this._ha = 150;
        this._g9 = 150;
      }
    }
  }
  /**
   * @hidden
   */
  static _jv(a, b) {
    ExcelUtils.gl(ChartType_$type, b);
    let c = a != null ? a.workbook : null;
    switch (b) {
      case 0:
        if (c != null && !c._c4) {
          throw new NotSupportedException(1, ExcelUtils.ef("LE_WorksheetChart_UnknownChartNotSupported"));
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _jk() {
    for (let a of fromEnum(this._seriesCollection$i)) {
      a._dn();
    }
  }
  /**
   * @hidden
   */
  _jf(a) {
    this._i8();
    try {
      if (WorksheetChart._f9(this.chartType)) {
        this._jg(a);
        return;
      }
      if (a == 90 || a == 91) {
        for (let b = 0; b < this._seriesCollection$i.count; b++) {
          let c = this._seriesCollection$i.item(b);
          c.chartType = (b == 0) ? 51 : a;
          c.type = (b == 0) ? 1 : 2;
        }
      }
      if (WorksheetChart._gk(a)) {
        this._seriesCollection$i._ax(new ChartEmptyFill());
      }
      if (a == 113) {
        let d = false;
        for (let e of fromEnum(this._seriesCollection$i)) {
          if (e.axisGroup == 2) {
            d = true;
          }
        }
        for (let f of fromEnum(this._seriesCollection$i)) {
          let g = null;
          let h = Nullable$1.toNullable(MarkerStyle_$type, null);
          let i = WorksheetChart._jd(f.chartType, g, h);
          g = i.p1;
          h = i.p2;
          if (g != null) {
            f.line = ((() => {
              let $ret = new ChartLine();
              $ret.fill = g;
              return $ret;
            })());
          }
          if (h.hasValue) {
            f.markerStyle = h.value;
          }
        }
        if (d) {
          if (this._axisCollection$i.item(2, 2) == null) {
            this._axisCollection$i.add(2, 2);
          }
          if (this._axisCollection$i.item(1, 2) == null) {
            let j = this._axisCollection$i.add(1, 2);
            j.visible = false;
            j.crosses = 2;
          }
        }
      }
    }
    finally {
      this._ja();
    }
  }
  /**
   * @hidden
   */
  _jg(a) {
    this._axisCollection$i._al();
    this._axisCollection$i._ap(4142, 4142);
    let b = (a == 116);
    let c = (a == 121);
    let d = b ? 2 : 1;
    this._seriesCollection$i._a1(d);
    let e = this._seriesCollection$i.count > 0 ? this._seriesCollection$i.item(0) : null;
    let f = this._seriesCollection$i.count > 1 ? this._seriesCollection$i.item(1) : null;
    if (e != null) {
      if (b) {
        if (f == null) {
          f = this._seriesCollection$i.add();
        }
        e._dr(51, false);
        f._dr(116, false);
        f.owningSeries = e;
        f.axisGroup = 2;
        if (e.xValues == null) {
          e.axisBinning = new CategoryAxisBinning();
        }
      }
      else if (c) {
        e.geographicMapSettings = GeographicMapSettings._c();
      }
    }
    if (b) {
      this._axisCollection$i._am();
      let g = this._axisCollection$i.item(2, 2);
      g.displayUnit = 1;
      g.minimumScale = 0;
      g.maximumScale = 1;
      g.minimumScaleIsAuto = false;
      g.maximumScaleIsAuto = false;
    }
    if (e != null) {
      switch (a) {
        case 116:
        case 114:
        case 117:
        case 121:
          e.showDataLabels = false;
          break;
        case 118:
        case 119:
          e.showDataLabels = true;
          e.dataLabels._dt(Nullable$1.toNullable(Boolean_$type, false));
          e.dataLabels._showCategoryName$i = Nullable$1.toNullable(Boolean_$type, true);
          e.dataLabels.labelPosition = 2;
          break;
        case 120:
          e.showDataLabels = true;
          e.dataLabels._dt(Nullable$1.toNullable(Boolean_$type, false));
          e.dataLabels._showValue$i = Nullable$1.toNullable(Boolean_$type, true);
          e.dataLabels.labelPosition = 8;
          break;
        case 115:
          e.showDataLabels = true;
          e.dataLabels._dt(Nullable$1.toNullable(Boolean_$type, false));
          e.dataLabels._showValue$i = Nullable$1.toNullable(Boolean_$type, true);
          e.dataLabels.labelPosition = 1;
          break;
      }
    }
  }
  /**
   * @hidden
   */
  _fr(a, b) {
    return this._comboChartGroups$i.add(a, b);
  }
  /**
   * @hidden
   */
  _fs(a, b) {
    let c = ComboChartGroup._ad(a);
    return this._ft(c, b);
  }
  /**
   * @hidden
   */
  _ft(a, b) {
    if (this._fu == null) {
      return null;
    }
    let c = ComboChartGroup._at(a, b);
    return this._comboChartGroups$i._item1(c);
  }
  /**
   * @hidden
   */
  _gq(a, b) {
    if (this._fu == null) {
      return false;
    }
    return this._fu._remove(a, b);
  }
  /**
   * @hidden
   */
  _eh(a, b = false) {
    if (a.type == 3) {
      return 0;
    }
    if (b && a.position != 0) {
      return a.position;
    }
    let c = this.chartType;
    let d = WorksheetChart._gb(c);
    let e = (a.axisGroup == 1);
    let f = e == false;
    let g = (a.type == 2);
    let h = g == false;
    let i;
    let j;
    if (d == false) {
      let k, l;
      let m = ((() => { let n = WorksheetChart._f8(c, k, l); k = n.p1; l = n.p2; return n.ret; })());
      if (m && k == false) {
        j = h ? 2 : 1;
      }
      else {
        let n = WorksheetChart._gh(c);
        if (n) {
          j = e ? 1 : 2;
        }
        else {
          j = h ? 1 : 2;
        }
      }
    }
    else {
      let o = false;
      let p = (a.type == 2) ? a : a._ab;
      if (p != null) {
        let q = p._bt();
        for (let r of fromEnum(q)) {
          let s, t;
          let u = ((() => { let v = WorksheetChart._f8(r.chartType, s, t); s = v.p1; t = v.p2; return v.ret; })());
          if (u && s == false) {
            o = true;
            break;
          }
        }
      }
      if (o) {
        if (h) {
          j = e ? 1 : 3;
        }
        else {
          j = e ? 2 : 4;
        }
      }
      else {
        if (h) {
          j = e ? 1 : 4;
        }
        else {
          j = e ? 2 : 3;
        }
      }
    }
    let v = a._ac;
    if (v == null) {
      i = j;
    }
    else {
      if (v.crosses == 2) {
        i = j == 1 ? 4 : j == 2 ? 3 : j;
      }
      else {
        i = j;
      }
    }
    return i;
  }
  /**
   * @hidden
   */
  _i6(a, b, c, d, e, f, g, h = Nullable$1.toNullable(ChartType_$type, null), i = Nullable$1.toNullable(SeriesType_$type, null)) {
    let j = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    let k = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    let l = 0;
    let m = e.count - g;
    if (m == 0) {
      return;
    }
    let n = null;
    let o = null;
    let p = null;
    let q = 0;
    let r = -1;
    let s = -1;
    let t = 0;
    let u = 1;
    let v = false;
    if (c) {
      switch (m) {
        case 1: break;
        case 2:
          s = 1;
          u = 2;
          break;
        case 3:
          if (g == 0) {
            r = 0;
            q = 1;
            s = 2;
            u = 3;
          }
          else {
            s = 1;
            u = 2;
          }
          break;
        default:
          {
            v = (m % 2) != 0;
            u = 2;
            s = 1;
            break;
          }
      }
    }
    else if (d) {
      switch (m) {
        case 1: break;
        default:
          {
            v = g == 0;
            break;
          }
      }
    }
    else {
      q = 0;
    }
    let w = e.count;
    for (let x = 0; x < w; x++) {
      let y = e._inner[x];
      let z = y.d;
      if (x == 0) {
        if (f > 0) {
          if (a) {
            j = Nullable$1.toNullable(WorksheetRegionAddress.$, z._f(z._ac + e.count - 1)._e((z._w + f - 1)));
          }
          else {
            j = Nullable$1.toNullable(WorksheetRegionAddress.$, z._f(z._ac + f - 1)._e((z._w + e.count - 1)));
          }
        }
        if (g > 0) {
          if (a) {
            k = Nullable$1.toNullable(WorksheetRegionAddress.$, z._c((z._w + f))._f(z._ac + g - 1));
          }
          else {
            k = Nullable$1.toNullable(WorksheetRegionAddress.$, z._d(z._ac + f)._e((z._w + g - 1)));
          }
        }
      }
      if (g > 0 && x < g) {
        continue;
      }
      if (y.c == null) {
        continue;
      }
      if (v && o == null) {
        o = y;
        continue;
      }
      if (t == q) {
        n = y;
      }
      else if (t == r) {
        o = y;
      }
      else if (t == s) {
        p = y;
      }
      if (x < w - 1 && t < u - 1) {
        t++;
        continue;
      }
      let aa = this._seriesCollection$i.add();
      if (nullableNotEquals(h, null)) {
        aa.chartType = h.value;
      }
      if (nullableNotEquals(i, null)) {
        aa.type = i.value;
      }
      l++;
      aa.plotOrder = l;
      let ab = 0;
      let ac = "";
      if (WorksheetRegionAddress._r(k, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        if (a) {
          if (k.value._ad > 1) {
            ab = 1;
          }
        }
        else {
          if (k.value._af > 1) {
            ab = 1;
          }
        }
        ac = ExcelUtils.d5(null, y.c.name);
        aa.xValues = new XValues(y.c, a, ab, ac + k.value._ah(false, false, b.workbook.currentFormat, 1), Nullable$1.toNullable(CellReferenceMode_$type, 1));
      }
      else if (o != null) {
        let ad = this._hm(o.c, o.d);
        ab = ad == 0 ? 2 : 0;
        ac = ExcelUtils.d5(null, o.c.name);
        aa.xValues = new XValues(o.c, a, ab, ac + o.d._ah(false, false, b.workbook.currentFormat, 1), Nullable$1.toNullable(CellReferenceMode_$type, 1));
      }
      if (f > 0) {
        if (a) {
          z = z._c((z._w + f));
        }
        else {
          z = z._d(z._ac + f);
        }
      }
      if (n != null) {
        ac = ExcelUtils.d5(null, n.c.name);
        aa.values = new SeriesValues(n.c, ac + z._ah(false, false, b.workbook.currentFormat, 1), Nullable$1.toNullable(CellReferenceMode_$type, 1), 0);
      }
      if (p != null) {
        aa.bubbleSizes = new SeriesValues(p.c, ac + z._ah(false, false, b.workbook.currentFormat, 1), Nullable$1.toNullable(CellReferenceMode_$type, 1), 0);
      }
      if (f > 0) {
        let ae = a ? j.value._d(z._ac)._f(z._ae) : j.value._c(z._w)._e(z._x);
        if (stringIsNullOrEmpty(ac)) {
          ac = ExcelUtils.d5(null, y.c.name);
        }
        aa.name = new SeriesName(y.c, ac + ae._ah(false, false, b.workbook.currentFormat, 1), Nullable$1.toNullable(CellReferenceMode_$type, 1));
      }
      else {
        aa.name = new SeriesName((x + 1).toString());
      }
      if (!v) {
        o = null;
      }
      n = null;
      p = null;
      t = 0;
    }
  }
  /**
   * @hidden
   */
  _i7(a, b, c, d) {
    let e = new Array(c.count);
    for (let f = 0; f < c.count; f++) {
      let g = c._inner[f];
      let h = g.d;
      let i = g.c;
      e[f] = WorksheetChart._fg(i, h);
    }
    let j = Nullable$1.toNullable(Number_$type, null);
    let k = Nullable$1.toNullable(Number_$type, null);
    for (let l = 0; l < e.length; l++) {
      let m = e[l];
      if (l == 0 && m == 0) {
        break;
      }
      if (m == 1) {
        if (j.hasValue == false) {
          j = Nullable$1.toNullable(Number_$type, l);
        }
        k = Nullable$1.toNullable(Number_$type, l);
      }
      else {
        break;
      }
    }
    let n = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    let o = null;
    let p = null;
    if (j.hasValue) {
      let q = c._inner[j.value].d;
      if (j.value == k.value) {
        n = Nullable$1.toNullable(WorksheetRegionAddress.$, q);
        o = c._inner[j.value].c;
        p = c._inner[j.value].e;
      }
      else {
        let r = c._inner[k.value].d;
        let s = q._w;
        let t = r._x;
        let u = q._ac;
        let v = r._ae;
        n = Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, u, v, s, t));
        p = c._inner[k.value].e;
      }
    }
    let w = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    let x = null;
    let y = null;
    for (let z = 0; z < e.length; z++) {
      let aa = e[z];
      if (aa == 0) {
        w = Nullable$1.toNullable(WorksheetRegionAddress.$, c._inner[z].d);
        x = c._inner[z].c;
        y = c._inner[z].e;
        break;
      }
    }
    let ab = w.hasValue == false;
    if (ab) {
      w = Nullable$1.toNullable(WorksheetRegionAddress.$, c._inner[0].d);
      n = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      o = null;
      p = null;
    }
    let ac = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    let ad = null;
    let ae = null;
    let af = WorksheetChart._fe(c._inner[0].c, w.value, true);
    if (af == 1) {
      let ag = w.value._ac;
      let ah = new WorksheetRegionAddress(1, ag + 1, w.value._ae, w.value._w, w.value._w);
      w = Nullable$1.toNullable(WorksheetRegionAddress.$, ah);
      ac = Nullable$1.toNullable(WorksheetRegionAddress.$, new WorksheetRegionAddress(1, ag, ag, ah._w, ah._w));
      ad = x;
      ae = y;
      if (n.hasValue) {
        ah = new WorksheetRegionAddress(1, n.value._ac + 1, n.value._ae, n.value._w, n.value._x);
        n = Nullable$1.toNullable(WorksheetRegionAddress.$, ah);
      }
    }
    let ai = null;
    let aj = false;
    let ak = false;
    let al = b.workbook.currentFormat;
    let am = 1;
    ai = a._seriesCollection$i.add();
    let an = w.value._ah(aj, ak, al, am, y);
    ai.values = new SeriesValues(x, an, Nullable$1.toNullable(CellReferenceMode_$type, am), 0);
    if (n.hasValue) {
      an = n.value._ah(aj, ak, al, am, p);
      ai.xValues = new XValues(o, an, Nullable$1.toNullable(CellReferenceMode_$type, am));
    }
    if (ac.hasValue) {
      an = ac.value._ah(aj, ak, al, am, ae);
      ai.name = new SeriesName(ad, an, Nullable$1.toNullable(CellReferenceMode_$type, am));
    }
  }
  /**
   * @hidden
   */
  _hl(a, b) {
    let c = b._ac;
    let d = b._w;
    let e = b._ae;
    let f = b._x;
    let g = 0;
    let h = b._af > 1;
    while (c <= e && d <= f) {
      let i = a._rows$i.item(c);
      let j = i._getCellValue1(d);
      if (j == null || ((typeof j === 'string') && (stringIsNullOrEmpty(typeCast(String_$type, j))))) {
        g++;
      }
      else {
        break;
      }
      if (h) {
        d++;
      }
      else {
        c++;
      }
    }
    return g;
  }
  /**
   * @hidden
   */
  _hm(a, b) {
    let c = b._ac;
    let d = b._w;
    let e = b._ae;
    let f = b._x;
    let g = 0;
    let h = b._af > 1;
    while (c <= e && d <= f) {
      let i = a._rows$i.item(c);
      let j = i._getCellValue1(d);
      if ((typeof j === 'string') && !stringIsNullOrEmpty(typeCast(String_$type, j))) {
        g++;
      }
      if (h) {
        d++;
      }
      else {
        c++;
      }
    }
    return g;
  }
  /**
   * @hidden
   */
  static _i2(a, b, c) {
    let d = b._ac;
    let e = b._w;
    let f = b._ae;
    let g = b._x;
    let h = c ? d : f;
    let i = a._rows$i.item(h);
    return i._getCellValue1(e);
  }
  /**
   * @hidden
   */
  static _ff(a, b) {
    return WorksheetChart._fe(a, b, true);
  }
  /**
   * @hidden
   */
  static _fg(a, b) {
    return WorksheetChart._fe(a, b, false);
  }
  /**
   * @hidden
   */
  static _fe(a, b, c) {
    let d = WorksheetChart._i2(a, b, c);
    return d != null && ExcelUtils.ba(d) ? 0 : 1;
  }
  /**
   * @hidden
   */
  static _ed($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(WorksheetChart.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _ee($tValue, a, b, c, d, e = null, f = true, g = false, h = 4) {
    return new ChangeInfo$2(WorksheetChart_LegendChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _ea() {
    let a = new Array(24);
    ChangeInfo.f(a, 0, WorksheetChart._ed(Boolean_$type, "AutoScaling", 7, (b) => b.autoScaling, (b, c) => b.autoScaling = c));
    ChangeInfo.f(a, 1, WorksheetChart._ed(Nullable$1.$.specialize(BarShape_$type), "BarShape", 7, (b) => b._barShape$i, (b, c) => b._barShape$i = c));
    ChangeInfo.f(a, 2, WorksheetChart._ed(ChartTitle.$, "ChartTitle", 7, (b) => b.chartTitle, (b, c) => b.chartTitle = c));
    ChangeInfo.f(a, 3, WorksheetChart._ed(ChartType_$type, "ChartType", 7, (b) => b.chartType, (b, c) => b.chartType = c));
    ChangeInfo.f(a, 4, WorksheetChart._ed(Number_$type, "DepthPercent", 7, (b) => b.depthPercent, (b, c) => b.depthPercent = c));
    ChangeInfo.f(a, 5, WorksheetChart._ed(DisplayBlanksAs_$type, "DisplayBlanksAs", 7, (b) => b.displayBlanksAs, (b, c) => b.displayBlanksAs = c));
    ChangeInfo.f(a, 6, WorksheetChart._ed(Number_$type, "DoughnutHoleSize", 7, (b) => b.doughnutHoleSize, (b, c) => b.doughnutHoleSize = c));
    ChangeInfo.f(a, 7, WorksheetChart._ed(ChartDropLines.$, "DropLines", 7, (b) => b.dropLines, (b, c) => b.dropLines = c));
    ChangeInfo.f(a, 9, WorksheetChart._ed(Number_$type, "GapDepth", 7, (b) => b.gapDepth, (b, c) => b.gapDepth = c));
    ChangeInfo.f(a, 10, WorksheetChart._ed(Number_$type, "GapWidth", 7, (b) => b.gapWidth, (b, c) => b.gapWidth = c));
    ChangeInfo.f(a, 8, WorksheetChart._ed(Number_$type, "FirstSliceAngle", 7, (b) => b.firstSliceAngle, (b, c) => b.firstSliceAngle = c));
    ChangeInfo.f(a, 11, WorksheetChart._ed(Number_$type, "HeightPercent", 7, (b) => b.heightPercent, (b, c) => b.heightPercent = c));
    ChangeInfo.f(a, 12, WorksheetChart._ed(ChartHighLowLines.$, "HighLowLines", 7, (b) => b.highLowLines, (b, c) => b.highLowLines = c));
    ChangeInfo.f(a, 13, WorksheetChart._ee(Base.$, "Legend", 7, (b) => null, (b, c) => b.d()));
    ChangeInfo.f(a, 14, WorksheetChart._ed(Number_$type, "Perspective", 7, (b) => b.perspective, (b, c) => b.perspective = c));
    ChangeInfo.f(a, 15, WorksheetChart._ed(Boolean_$type, "PlotVisibleOnly", 7, (b) => b.plotVisibleOnly, (b, c) => b.plotVisibleOnly = c));
    ChangeInfo.f(a, 16, WorksheetChart._ed(Boolean_$type, "RightAngleAxes", 7, (b) => b.rightAngleAxes, (b, c) => b.rightAngleAxes = c));
    ChangeInfo.f(a, 17, WorksheetChart._ed(Number_$type, "RotationX", 7, (b) => b.rotationX, (b, c) => b.rotationX = c));
    ChangeInfo.f(a, 18, WorksheetChart._ed(Number_$type, "RotationY", 7, (b) => b.rotationY, (b, c) => b.rotationY = c));
    ChangeInfo.f(a, 19, WorksheetChart._ed(Number_$type, "SecondPlotSize", 7, (b) => b.secondPlotSize, (b, c) => b.secondPlotSize = c));
    ChangeInfo.f(a, 20, WorksheetChart._ed(ChartSeriesLines.$, "SeriesLines", 7, (b) => b.seriesLines, (b, c) => b.seriesLines = c));
    ChangeInfo.f(a, 21, WorksheetChart._ed(Number_$type, "SeriesOverlap", 7, (b) => b.seriesOverlap, (b, c) => b.seriesOverlap = c));
    ChangeInfo.f(a, 22, WorksheetChart._ed(UpDownBars.$, "UpDownBars", 7, (b) => b.upDownBars, (b, c) => b.upDownBars = c));
    ChangeInfo.f(a, 23, WorksheetChart._ed(Boolean_$type, "VaryColors", 7, (b) => b.varyColors, (b, c) => b.varyColors = c));
    return a;
  }
  /**
   * @hidden
   */
  _f2(a) {
    return (this._fz & a) == a;
  }
  /**
   * @hidden
   */
  _i3(a) {
    if (this._gc) {
      return null;
    }
    let b = this.workbook;
    return b != null && b._cx ? b._go(this.sheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _jj(a) {
    if (a != null) {
      let b = this.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _jl(a, b) {
    if (b) {
      this._fz |= a;
    }
    else {
      this._fz &= ~a;
    }
  }
  /**
   * @hidden
   */
  _jm(a, b, c) {
    this._jx();
    let d = this._f2(b);
    if (d == c) {
      return;
    }
    let e = WorksheetChart._d9[a].g(WorksheetChart.$, Boolean_$type, this, d, c, this._gc);
    d = e.p1;
    this._jl(b, c);
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  _jo($t, a, b, c) {
    let d = this._jp($t, a, b, c, (d) => ExcelUtils.gl($t, d));
    b = d.p1;
    return {
      p1: b
    };
  }
  /**
   * @hidden
   */
  _jp($t, a, b, c, d = null) {
    this._jx();
    if (d != null) {
      d(c);
    }
    let e = WorksheetChart._d9[a].g(WorksheetChart.$, $t, this, b, c, this._gc);
    b = e.p1;
    b = c;
    this.onPropertyChanged();
    return {
      p1: b
    };
  }
  /**
   * @hidden
   */
  _js() {
    let a = this.chartType;
    switch (a) {
      case 90:
      case 91:
        if (this._axisCollection$i.item(1, 1) == null) {
          this._axisCollection$i.add(1, 1);
        }
        if (this._axisCollection$i.item(2, 1) == null) {
          this._axisCollection$i.add(2, 1);
        }
        if (this._axisCollection$i.item(1, 2) == null) {
          this._axisCollection$i.add(1, 2);
        }
        if (this._axisCollection$i.item(2, 2) == null) {
          this._axisCollection$i.add(2, 2);
        }
        let b = this._axisCollection$i.item(1, 1);
        let c = this._axisCollection$i.item(1, 2);
        let d = this._axisCollection$i.item(2, 1);
        let e = this._axisCollection$i.item(2, 2);
        b.tickLabelPosition = 4;
        c.visible = false;
        d.tickLabelPosition = 4;
        e.tickLabelPosition = -4127;
        return;
    }
    if (WorksheetChart._f3(a)) {
      let f = WorksheetChart._gr(a);
      let g = this._axisCollection$i.item(2);
      if (g == null) {
        g = this._axisCollection$i.add(2);
      }
      let h = this._axisCollection$i.item(1);
      if (f) {
        if (h == null) {
          h = this._axisCollection$i.add(1);
        }
        if (h._ab == null) {
          h._ab = g;
        }
        if (g._ab == null) {
          g._ab = h;
        }
      }
      else {
        let i = this._axisCollection$i.item(2, 2);
        if (i == null) {
          i = this._axisCollection$i.add(2, 2);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _jt() {
    let a = this.chartType;
    let b = false;
    let c = false;
    let d = false;
    let e = false;
    let f = false;
    let g = this._jc(b, c, d, e, f);
    b = g.p0;
    c = g.p1;
    d = g.p2;
    e = g.p3;
    f = g.p4;
    let h = true;
    switch (a) {
      case 90:
      case 91:
        h = b && c && d && e;
        break;
    }
    if (h == false) {
      throw new BaseError(1, ExcelUtils.eg("LE_WorksheetChart_MissingRequiredAxis_StockCharts", enumGetBox(ChartType_$type, a)));
    }
  }
  /**
   * @hidden
   */
  _jc(a, b, c, d, e) {
    a = this._axisCollection$i.item(1, 1) != null;
    b = this._axisCollection$i.item(2, 1) != null;
    c = this._axisCollection$i.item(1, 2) != null;
    d = this._axisCollection$i.item(2, 2) != null;
    e = this._axisCollection$i.item(3) != null;
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  _jw(a, b) {
    if (this._gc) {
      return;
    }
    let c = (a == 113);
    let d = (b == 113);
    if (c != d) {
      let e = d ? ExcelUtils.eg("LE_WorksheetChart_ChartType_ComboChart_To", enumGetBox(ChartType_$type, a)) : ExcelUtils.eg("LE_WorksheetChart_ChartType_ComboChart_From", enumGetBox(ChartType_$type, b));
      throw new NotSupportedException(1, e);
    }
  }
  /**
   * @hidden
   */
  _ju(a, b) {
    if (this._gc) {
      return;
    }
    let c = WorksheetChart._f9(a);
    let d = WorksheetChart._f9(b);
    if (c != d) {
      let e = ExcelUtils.eg("LE_WorksheetChart_ChartType_ChartEx_CannotTransition", enumGetBox(ChartType_$type, a), enumGetBox(ChartType_$type, b));
      throw new NotSupportedException(1, e);
    }
  }
  /**
   * @hidden
   */
  _jx() {
    let a = this.workbook;
    if (a != null) {
      a._i9();
    }
  }
  /**
   * @hidden
   */
  _jy() {
    if (this._gc) {
      return;
    }
    if (this._seriesCollection$i.count > 0 && this._seriesCollection$i._ae == false) {
      throw new NotSupportedException(1, ExcelUtils.ef("LE_Series_NoPrimaryAxis"));
    }
    let a = this.chartType;
    if (WorksheetChart._gk(a)) {
      let b = WorksheetChart._i0(a);
      if (b.hasValue == false) {
        return;
      }
      let c = this._seriesCollection$i.count;
      if (c < b.value) {
        throw new BaseError(1, ExcelUtils.eg("LE_WorksheetChart_NotEnoughSeries", enumGetBox(ChartType_$type, a), b.value));
      }
      return;
    }
    if (a == 113) {
      if (this._seriesCollection$i.count < 2) {
        throw new BaseError(1, ExcelUtils.ef("LE_WorksheetChart_ComboChart_NotEnoughSeries"));
      }
    }
  }
  /**
   * @hidden
   */
  _jh(a, b) {
    if (this._gc) {
      return;
    }
    let c = WorksheetChart._i1(b);
    if (c.hasValue) {
      this._seriesCollection$i._az(c.value);
    }
    let d = WorksheetChart._f4(a);
    let e = WorksheetChart._f4(b);
    if (d != e) {
      let f = d ? -4142 : 8;
      this._seriesCollection$i._ay(f);
    }
    let g = WorksheetChart._iz(b);
    if (g.hasValue) {
      this._seriesCollection$i._ay(g.value);
    }
    this._seriesCollection$i._aw(a, b);
    let h = WorksheetChart._ga(a);
    let i = WorksheetChart._ga(b);
    let j = WorksheetChart._gi(a);
    let k = WorksheetChart._gi(b);
    if (h && k) {
      this.seriesOverlap = 100;
    }
    else if (j && i) {
      this.seriesOverlap = 0;
    }
    let l = WorksheetChart._gk(a);
    let m = WorksheetChart._gk(b);
    if (m) {
      this._jy();
    }
    if (j != m) {
      let n = null;
      let o = null;
      if (m) {
        n = new UpDownBars();
        o = new ChartHighLowLines();
      }
      this.upDownBars = n;
      this.highLowLines = o;
    }
    if (WorksheetChart._f9(b)) {
      this._ji(a, b);
    }
  }
  /**
   * @hidden
   */
  _ji(a, b) {
    switch (b) {
      case 116:
        if (this._axisCollection$i.item(1, 1) == null) {
          this._axisCollection$i.add(1, 1);
        }
        if (this._axisCollection$i.item(2, 1) == null) {
          this._axisCollection$i.add(2, 1);
        }
        if (this._axisCollection$i.item(2, 2) == null) {
          this._axisCollection$i.add(2, 2);
        }
        let c = null;
        let d = null;
        for (let e of fromEnum(this._seriesCollection$i)) {
          if (c == null && e.chartType == 116) {
            c = e;
          }
          if (d == null && e.chartType == 51) {
            d = e;
          }
        }
        if (d == null && c != null) {
          d = c;
          d._dr(51, false);
          d.axisGroup = 1;
          c = null;
        }
        if (c == null) {
          c = this._seriesCollection$i.add();
          c._dr(116, false);
          c.owningSeries = d;
          c.axisGroup = 2;
        }
        break;
      case 121:
        if (this._seriesCollection$i.count > 0) {
          this._seriesCollection$i.item(0).geographicMapSettings = GeographicMapSettings._c();
        }
        break;
      default: break;
    }
    let f = a == 116;
    if (f) {
      if (this._seriesCollection$i.count > 0) {
        this._seriesCollection$i._a1(1);
        this._seriesCollection$i.item(0)._dr(b, false);
        this._seriesCollection$i.item(0).axisBinning = null;
      }
    }
  }
  /**
   * @hidden
   */
  static _i1(a) {
    switch (a) {
      case 5:
      case -4102:
      case -4120: return Nullable$1.toNullable(Boolean_$type, false);
      case 69:
      case 70:
      case 80: return Nullable$1.toNullable(Boolean_$type, true);
      default: return Nullable$1.toNullable(Boolean_$type, null);
    }
  }
  /**
   * @hidden
   */
  static _f6(a) {
    switch (a) {
      case -4098:
      case 78:
      case 79:
      case 60:
      case 61:
      case 62:
      case -4100:
      case 54:
      case 55:
      case 56:
      case 102:
      case 103:
      case 104:
      case 105:
      case 99:
      case 100:
      case 101:
      case 95:
      case 96:
      case 97:
      case 92:
      case 93:
      case 94:
      case -4101:
      case -4102:
      case 70:
      case 109:
      case 110:
      case 111:
      case 106:
      case 107:
      case 108:
      case 85:
      case 86: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gi(a) {
    let b = false;
    return ((() => { let c = WorksheetChart._gj(a, b); b = c.p1; return c.ret; })());
  }
  /**
   * @hidden
   */
  static _gj(a, b) {
    b = false;
    switch (a) {
      case 79:
      case 77:
      case 62:
      case 59:
      case 56:
      case 53:
      case 104:
      case 101:
      case 97:
      case 67:
      case 64:
      case 111:
      case 108:
        b = true;
        return {
          ret: true,
          p1: b
        };
      case 78:
      case 76:
      case 61:
      case 58:
      case 55:
      case 52:
      case 103:
      case 100:
      case 96:
      case 66:
      case 63:
      case 110:
      case 107: return {
        ret: true,
        p1: b
      };
      default: return {
        ret: false,
        p1: b
      };
    }
  }
  /**
   * @hidden
   */
  static _ga(a) {
    switch (a) {
      case 60:
      case 57:
      case 54:
      case 51:
      case 102:
      case 99:
      case 95:
      case 92:
      case 109:
      case 106: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _gb(a) {
    switch (a) {
      case 113:
      case 90:
      case 91: return true;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _f5(a) {
    return WorksheetChart._gk(a) || WorksheetChart._gb(a);
  }
  /**
   * @hidden
   */
  static _e5(a) {
    switch (a) {
      case 0: return 1;
      case 7: return 15;
      case 2: return 4;
      case 3: return 5;
      case 4: return -4151;
      case 6: return -4169;
      case 5: return 83;
      default: return 51;
    }
  }
  /**
   * @hidden
   */
  static _gy(a) {
    return a == 0 || WorksheetChart._gb(a) || WorksheetChart._gh(a);
  }
  /**
   * @hidden
   */
  static _iz(a) {
    switch (a) {
      case 75:
      case 73:
      case -4151: return Nullable$1.toNullable(MarkerStyle_$type, -4142);
      case 74:
      case 72:
      case 81:
      case 65:
      case 66:
      case 67: return Nullable$1.toNullable(MarkerStyle_$type, -4105);
      default: return Nullable$1.toNullable(MarkerStyle_$type, null);
    }
  }
  /**
   * @hidden
   */
  _i9() {
    if (this._fw != null) {
      this._fw.a = null;
    }
  }
  /**
   * @hidden
   */
  static _gw(a) {
    switch (a) {
      case 15:
      case 87: return false;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  get chart() {
    return this;
  }
  /**
   * @hidden
   */
  onPropertyChanged() {
    let a = this.workbook;
    if (a == null || a._c4 || this._gc) {
      return;
    }
    let b = this.sheet;
    if (b != null) {
      WorksheetChart._jv(b, this.chartType);
    }
    this._ec = null;
    if (this._fw != null) {
      this._fw.a = null;
      this._fw.e = null;
    }
  }
  /**
   * @hidden
   */
  isReferencingAnythingInRegion(ws, region) {
    if (this._fc != null && this._fc._i(ws, region)) {
      return true;
    }
    if (this._ef != null && this._ef._i(ws, region)) {
      return true;
    }
    if (this._e1 != null && this._e1._i(ws, region)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  iterateFormulas(callback) {
    if (this._fc != null) {
      this._fc._m(callback);
    }
    if (this._ef != null) {
      this._ef._m(callback);
    }
    if (this._e1 != null) {
      this._e1._m(callback);
    }
  }
  /**
   * @hidden
   */
  onShiftRegion(callback, shiftOperation, operationOverride) {
    if (this._fc != null) {
      this._fc._o(callback, shiftOperation, operationOverride);
    }
    if (this._ef != null) {
      this._ef._o(callback, shiftOperation, operationOverride);
    }
    if (this._e1 != null) {
      this._e1._o(callback, shiftOperation, operationOverride);
    }
  }
  /**
   * @hidden
   */
  undoChartShift(context) {
    return null;
  }
  /**
   * @hidden
   */
  verifyFormulas(removedWorksheet) {
    if (this._fc != null) {
      this._fc._t(removedWorksheet);
    }
    if (this._ef != null) {
      this._ef._t(removedWorksheet);
    }
    if (this._e1 != null) {
      this._e1._t(removedWorksheet);
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitWorksheetChart$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 201);
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, null);
  }
  /**
   * @hidden
   */
  _dg() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ShapeCantChangeOrientation"));
  }
  /**
   * @hidden
   */
  get _g3() {
    return this._g1;
  }
  /**
   * @hidden
   */
  set _g3(a) {
    this._g1 = a;
  }
  /**
   * @hidden
   */
  get _ec() {
    return this._eb;
  }
  /**
   * @hidden
   */
  set _ec(a) {
    this._eb = a;
  }
  /**
   * @hidden
   */
  get _fx() {
    return this._fw;
  }
  /**
   * @hidden
   */
  set _fx(a) {
    this._fw = a;
  }
  /**
   * @hidden
   */
  get _g4() {
    return this._g2;
  }
  /**
   * @hidden
   */
  set _g4(a) {
    this._g2 = a;
  }
  /**
   * @hidden
   */
  get _i5() {
    return this._i4;
  }
}
WorksheetChart.$t = markType(WorksheetChart, 'WorksheetChart', WorksheetShapeGroupBase.$, [IChartObject_$type]);
/**
 * @hidden
 */
WorksheetChart._ho = 50;
/**
 * @hidden
 */
WorksheetChart._hh = 0;
/**
 * @hidden
 */
WorksheetChart._hi = 1;
/**
 * @hidden
 */
WorksheetChart._hj = 2;
/**
 * @hidden
 */
WorksheetChart._hk = 3;
/**
 * @hidden
 */
WorksheetChart._hx = 4;
/**
 * @hidden
 */
WorksheetChart._hy = 5;
/**
 * @hidden
 */
WorksheetChart._h0 = 6;
/**
 * @hidden
 */
WorksheetChart._h1 = 7;
/**
 * @hidden
 */
WorksheetChart._h3 = 8;
/**
 * @hidden
 */
WorksheetChart._h5 = 9;
/**
 * @hidden
 */
WorksheetChart._h7 = 10;
/**
 * @hidden
 */
WorksheetChart._h9 = 11;
/**
 * @hidden
 */
WorksheetChart._ia = 12;
/**
 * @hidden
 */
WorksheetChart._ib = 13;
/**
 * @hidden
 */
WorksheetChart._ig = 14;
/**
 * @hidden
 */
WorksheetChart._ih = 15;
/**
 * @hidden
 */
WorksheetChart._ii = 16;
/**
 * @hidden
 */
WorksheetChart._ik = 17;
/**
 * @hidden
 */
WorksheetChart._im = 18;
/**
 * @hidden
 */
WorksheetChart._ip = 19;
/**
 * @hidden
 */
WorksheetChart._iq = 20;
/**
 * @hidden
 */
WorksheetChart._is = 21;
/**
 * @hidden
 */
WorksheetChart._it = 22;
/**
 * @hidden
 */
WorksheetChart._iu = 23;
/**
 * @hidden
 */
WorksheetChart._id = 24;
/**
 * @hidden
 */
WorksheetChart._hs = 15;
/**
 * @hidden
 */
WorksheetChart._ht = 20;
/**
 * @hidden
 */
WorksheetChart._hq = 150;
/**
 * @hidden
 */
WorksheetChart._hp = 150;
/**
 * @hidden
 */
WorksheetChart._hn = 100;
/**
 * @hidden
 */
WorksheetChart._hr = 100;
/**
 * @hidden
 */
WorksheetChart._hu = 50;
/**
 * @hidden
 */
WorksheetChart._hv = 100;
/**
 * @hidden
 */
WorksheetChart._ic = 120;
/**
 * @hidden
 */
WorksheetChart._d9 = null;
/**
 * @hidden
 */
WorksheetChart._f0 = 0;
/**
 * @hidden
 */
export class GenericCacheElementProxy$1 extends Base {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.c = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          if (c != null) {
            this.c = GenericCacheElementEx.r(this.$t, c, d);
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c._p, c];
          {
            let f = d[0];
            let g = d[1];
            if (f != null) {
              this.c = GenericCacheElementEx.r(this.$t, f, g);
            }
          }
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(GenericCacheElementProxy$1.$.specialize(this.$t), a);
    if (b == null) {
      return false;
    }
    return this.d.equals(b.d);
  }
  getHashCode() {
    return this.d.getHashCode();
  }
  g(a) {
    let b = GenericCacheElementEx.z(this.$t, a, this.c);
    this.c = b.p1;
  }
  a() {
    return this.b(true);
  }
  b(a) {
    return ((() => { let b = GenericCacheElementEx.p(this.$t, this.c, a); this.c = b.p0; return b.ret; })());
  }
  h(a) {
    this.j(a);
  }
  i() {
    this.j(null);
  }
  k(a) {
    if (this.d == a) {
      return;
    }
    let b = false;
    if (a.x) {
      b = true;
    }
    else if (a.t != null && this.c.t != a.t) {
      b = true;
    }
    else if (a.t == null && this.c.t == null) {
      b = true;
    }
    if (b) {
      a = typeCastObjTo$t(this.$t, a.g(this.d.v));
    }
    let c = this.b(false);
    this.c = a;
    this.g(c);
  }
  j(a) {
    let b = this.d;
    let c = GenericCacheElementEx.ad(this.$t, a, this.c);
    this.c = c.p1;
  }
  get_d() {
    return this.c;
  }
  get d() {
    return this.get_d();
  }
}
GenericCacheElementProxy$1.$t = markType(GenericCacheElementProxy$1, 'GenericCacheElementProxy$1');
/**
 * @hidden
 */
export class WorksheetCellFormatProxy extends GenericCacheElementProxy$1 {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(WorksheetCellFormatData.$, 0, c, d);
          this._t = null;
          this._r = null;
          this._x = false;
          this._r = e;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c == null ? new WorksheetCellFormatData(null, 0) : c._d._ca._p, c, d];
          {
            let g = e[0];
            let h = e[1];
            let i = e[2];
            super(WorksheetCellFormatData.$, 0, g, h);
            this._t = null;
            this._r = null;
            this._x = false;
            this._r = i;
          }
        }
        break;
    }
  }
  static _am(a) {
    a.b._at(a.c);
  }
  static _an(a) {
    a.c._at(a.d);
  }
  static _al(a) {
    a.b._at(a.c);
  }
  static _aq($tValue, a, b, c, d, e, f) {
    ChangeInfo.f(a, WorksheetCellFormatProxy._ad(b), new ChangeInfo$2(WorksheetCellFormatProxy_FormatChangeContext.$, $tValue, EnumUtil.getName(CellFormatValue_$type, b), e, c, (g, h) => WorksheetCellFormatProxy._bo($tValue, g, h, d), null, true, f, false, (g) => WorksheetCellFormatProxy._ac(g), (g) => WorksheetCellFormatProxy._al(g)));
  }
  static _m(a, b) {
    let c = new Array(WorksheetCellFormatProxy._af);
    WorksheetCellFormatProxy._aq(HorizontalCellAlignment_$type, c, 1, (d) => d.proxy.alignment, (d, e) => d.proxy._au(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 2, (d) => d.proxy.bottomBorderColorInfo, (d, e) => d.proxy._av(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellBorderLineStyle_$type, c, 4, (d) => d.proxy.bottomBorderStyle, (d, e) => d.proxy._aw(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 8, (d) => d.proxy.diagonalBorderColorInfo, (d, e) => d.proxy._ax(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(DiagonalBorders_$type, c, 16, (d) => d.proxy.diagonalBorders, (d, e) => d.proxy._ay(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellBorderLineStyle_$type, c, 32, (d) => d.proxy.diagonalBorderStyle, (d, e) => d.proxy._az(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellFill.$, c, 64, (d) => d.proxy.fill, (d, e) => d.proxy._a0(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 128, (d) => d.proxy._u._bold$i, (d, e) => d.proxy._u._b(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 256, (d) => d.proxy._u.colorInfo, (d, e) => d.proxy._u._c(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Number_$type, c, 512, (d) => d.proxy._u.height, (d, e) => d.proxy._u._f(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 1024, (d) => d.proxy._u._italic$i, (d, e) => d.proxy._u._g(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(String_$type, c, 2048, (d) => d.proxy._u.name, (d, e) => d.proxy._u._h(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 4096, (d) => d.proxy._u._strikeout$i, (d, e) => d.proxy._u._i(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(FontSuperscriptSubscriptStyle_$type, c, 8192, (d) => d.proxy._u.superscriptSubscriptStyle, (d, e) => d.proxy._u._j(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(FontUnderlineStyle_$type, c, 16384, (d) => d.proxy._u.underlineStyle, (d, e) => d.proxy._u._k(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(String_$type, c, 65536, (d) => d.proxy.formatString, (d, e) => d.proxy._a5(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Number_$type, c, 131072, (d) => d.proxy.indent, (d, e) => d.proxy._a8(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 262144, (d) => d.proxy.leftBorderColorInfo, (d, e) => d.proxy._a9(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellBorderLineStyle_$type, c, 524288, (d) => d.proxy.leftBorderStyle, (d, e) => d.proxy._ba(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 1048576, (d) => d.proxy._locked$i, (d, e) => d.proxy._bb(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 2097152, (d) => d.proxy.rightBorderColorInfo, (d, e) => d.proxy._bd(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellBorderLineStyle_$type, c, 4194304, (d) => d.proxy.rightBorderStyle, (d, e) => d.proxy._be(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Number_$type, c, 8388608, (d) => d.proxy.rotation, (d, e) => d.proxy._bf(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 16777216, (d) => d.proxy._shrinkToFit$i, (d, e) => d.proxy._bg(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(WorkbookColorInfo.$, c, 67108864, (d) => d.proxy.topBorderColorInfo, (d, e) => d.proxy._bi(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(CellBorderLineStyle_$type, c, 134217728, (d) => d.proxy.topBorderStyle, (d, e) => d.proxy._bj(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(VerticalCellAlignment_$type, c, 268435456, (d) => d.proxy.verticalAlignment, (d, e) => d.proxy._bm(e, true, -97), a, b);
    WorksheetCellFormatProxy._aq(Nullable$1.$.specialize(Boolean_$type), c, 536870912, (d) => d.proxy._wrapText$i, (d, e) => d.proxy._bn(e, true, -97), a, b);
    ChangeInfo.f(c, WorksheetCellFormatProxy._ad(32768), new ChangeInfo$2(WorksheetCellFormatProxy_SetFormattingChangeContext.$, WorksheetCellFormatData.$, "FormatOptions", a, (d) => d.proxy.d, (d, e) => WorksheetCellFormatProxy._bq(d, e), null, true, b, false, null, (d) => WorksheetCellFormatProxy._an(d)));
    ChangeInfo.f(c, WorksheetCellFormatProxy._ad(33554432), new ChangeInfo$2(WorksheetCellFormatProxy_SetFormattingChangeContext.$, WorksheetCellFormatData.$, "Style", a, (d) => d.proxy.d, (d, e) => WorksheetCellFormatProxy._bq(d, e), null, true, b, false, null, (d) => WorksheetCellFormatProxy._an(d)));
    ChangeInfo.f(c, WorksheetCellFormatProxy._ah, new ChangeInfo$2(WorksheetCellFormatProxy_SetFormattingChangeContext.$, WorksheetCellFormatData.$, "SetFormatting", a, (d) => d.proxy.d, (d, e) => WorksheetCellFormatProxy._bq(d, e), null, true, b, false, null, (d) => WorksheetCellFormatProxy._an(d)));
    ChangeInfo.f(c, WorksheetCellFormatProxy._ag, new ChangeInfo$2(WorksheetCellFormatProxy_SetFontFormattingChangeContext.$, WorkbookFontData.$, "SetFontFormatting", a, (d) => d.proxy.d._bp.d, (d, e) => WorksheetCellFormatProxy._bp(d, e), null, true, b, false, null, (d) => WorksheetCellFormatProxy._am(d)));
    return c;
  }
  static _ad(a) {
    let b = a;
    let c = 0;
    while (b % 2 == 0) {
      b >>= 1;
      c++;
    }
    return c;
  }
  static _ac(a) {
    let b = typeCast(WorksheetCellOwnedFormatProxy.$, a.b);
    if (b != null) {
      return b._bv;
    }
    let c = typeCast(WorksheetColumn.$, a.b._s);
    if (c != null) {
      return c._aq;
    }
    let d = typeCast(WorksheetMergedCellsRegion.$, a.b._s);
    if (d != null) {
      return d._h._w;
    }
    return -1;
  }
  _n(a) {
    return WorksheetCellFormatProxy._o(a, this.d);
  }
  static _o(a, b) {
    let c = 0;
    if (b.alignment != a.alignment) {
      c |= 1;
    }
    if (WorkbookColorInfo.l_op_Inequality(b.bottomBorderColorInfo, a.bottomBorderColorInfo)) {
      c |= 2;
    }
    if (b.bottomBorderStyle != a.bottomBorderStyle) {
      c |= 4;
    }
    if (WorkbookColorInfo.l_op_Inequality(b.diagonalBorderColorInfo, a.diagonalBorderColorInfo)) {
      c |= 8;
    }
    if (b.diagonalBorders != a.diagonalBorders) {
      c |= 16;
    }
    if (b.diagonalBorderStyle != a.diagonalBorderStyle) {
      c |= 32;
    }
    if (Base.equalsStatic(b.fill, a.fill) == false) {
      c |= 64;
    }
    let d = typeCast(WorksheetCellFormatData.$, a);
    if (d != null) {
      if (b._cr != d._cr) {
        c |= 65536;
      }
    }
    else {
      let e = typeCast(WorksheetCellFormatProxy.$, a);
      if (e != null) {
        if (b._cr != e.d._cr) {
          c |= 65536;
        }
      }
      else if (b.formatString != a.formatString) {
        c |= 65536;
      }
    }
    if (b.indent != a.indent) {
      c |= 131072;
    }
    if (WorkbookColorInfo.l_op_Inequality(b.leftBorderColorInfo, a.leftBorderColorInfo)) {
      c |= 262144;
    }
    if (b.leftBorderStyle != a.leftBorderStyle) {
      c |= 524288;
    }
    if (nullableNotEquals(b._locked$i, a._locked$i)) {
      c |= 1048576;
    }
    if (WorkbookColorInfo.l_op_Inequality(b.rightBorderColorInfo, a.rightBorderColorInfo)) {
      c |= 2097152;
    }
    if (b.rightBorderStyle != a.rightBorderStyle) {
      c |= 4194304;
    }
    if (b.rotation != a.rotation) {
      c |= 8388608;
    }
    if (nullableNotEquals(b._shrinkToFit$i, a._shrinkToFit$i)) {
      c |= 16777216;
    }
    if (b.style != a.style) {
      c |= 33554432;
    }
    if (b.formatOptions != a.formatOptions) {
      c |= 32768;
    }
    if (WorkbookColorInfo.l_op_Inequality(b.topBorderColorInfo, a.topBorderColorInfo)) {
      c |= 67108864;
    }
    if (b.topBorderStyle != a.topBorderStyle) {
      c |= 134217728;
    }
    if (b.verticalAlignment != a.verticalAlignment) {
      c |= 268435456;
    }
    if (nullableNotEquals(b._wrapText$i, a._wrapText$i)) {
      c |= 536870912;
    }
    c |= WorkbookFontProxy._l(b.font, a.font);
    return c;
  }
  static _ae(a) {
    let b = typeCast(WorksheetCellFormatData.$, a);
    if (b != null) {
      return b._cr;
    }
    let c = typeCast(WorksheetCellFormatProxy.$, a);
    if (c != null) {
      return c.d._cr;
    }
    return -1;
  }
  _ai() {
    return Nullable$1.toNullable(WorksheetCellAddress.$, null);
  }
  _aj(a) {
    return this.d._dd(a);
  }
  static _y(a, b, c) {
    if ((c & 830603265) != 0) {
      if ((c & 1) != 0 && b.alignment != a.alignment) {
        return true;
      }
      if ((c & 131072) != 0 && b.indent != a.indent) {
        return true;
      }
      if ((c & 8388608) != 0 && b.rotation != a.rotation) {
        return true;
      }
      if ((c & 16777216) != 0 && nullableNotEquals(b._shrinkToFit$i, a._shrinkToFit$i)) {
        return true;
      }
      if ((c & 268435456) != 0 && b.verticalAlignment != a.verticalAlignment) {
        return true;
      }
      if ((c & 536870912) != 0 && nullableNotEquals(b._wrapText$i, a._wrapText$i)) {
        return true;
      }
    }
    if ((c & 208404542) != 0) {
      if ((c & 2) != 0 && WorkbookColorInfo.l_op_Inequality(b.bottomBorderColorInfo, a.bottomBorderColorInfo)) {
        return true;
      }
      if ((c & 4) != 0 && b.bottomBorderStyle != a.bottomBorderStyle) {
        return true;
      }
      if ((c & 8) != 0 && WorkbookColorInfo.l_op_Inequality(b.diagonalBorderColorInfo, a.diagonalBorderColorInfo)) {
        return true;
      }
      if ((c & 16) != 0 && b.diagonalBorders != a.diagonalBorders) {
        return true;
      }
      if ((c & 32) != 0 && b.diagonalBorderStyle != a.diagonalBorderStyle) {
        return true;
      }
      if ((c & 262144) != 0 && WorkbookColorInfo.l_op_Inequality(b.leftBorderColorInfo, a.leftBorderColorInfo)) {
        return true;
      }
      if ((c & 524288) != 0 && b.leftBorderStyle != a.leftBorderStyle) {
        return true;
      }
      if ((c & 2097152) != 0 && WorkbookColorInfo.l_op_Inequality(b.rightBorderColorInfo, a.rightBorderColorInfo)) {
        return true;
      }
      if ((c & 4194304) != 0 && b.rightBorderStyle != a.rightBorderStyle) {
        return true;
      }
      if ((c & 67108864) != 0 && WorkbookColorInfo.l_op_Inequality(b.topBorderColorInfo, a.topBorderColorInfo)) {
        return true;
      }
      if ((c & 134217728) != 0 && b.topBorderStyle != a.topBorderStyle) {
        return true;
      }
    }
    if ((c & 64) != 0 && Base.equalsStatic(b.fill, a.fill) == false) {
      return true;
    }
    if ((c & 65536) != 0) {
      let d = WorksheetCellFormatProxy._ae(a);
      let e = WorksheetCellFormatProxy._ae(b);
      if (d >= 0 && e >= 0) {
        if (d != e) {
          return true;
        }
      }
      else if (b.formatString != a.formatString) {
        return true;
      }
    }
    if ((c & 1048576) != 0 && nullableNotEquals(b._locked$i, a._locked$i)) {
      return true;
    }
    if ((c & 33554432) != 0 && b.style != a.style) {
      return true;
    }
    if ((c & 32768) != 0 && b.formatOptions != a.formatOptions) {
      return true;
    }
    if ((c & 32640) != 0 && WorkbookFontProxy._o(b.font, a.font, c)) {
      return true;
    }
    return false;
  }
  _aa(a) {
    return WorksheetCellFormatData._cf(a, this._aj(a));
  }
  _ao(a, b) {
    if (this._r != null) {
      this._r.onCellFormatValueChanged(this, a, b);
    }
  }
  _ap(a) {
    if (this._r != null) {
      this._r.onCellFormatValueChanging(this, a);
    }
  }
  _ar(a = 0) {
    this._bh(null, true, a);
    this._a3(0, true, a);
  }
  _as(a, b) {
    let c = WorksheetCellFormatData._c8(a);
    this._bl(a, c, true, b);
  }
  _at(a) {
  }
  _a1(a, b, c) {
    if (a == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFont"));
    }
    let d = this.d.v;
    let e = null;
    if (d != null) {
      e = d._go(this._v, this._q, null);
    }
    let f = WorkbookFontProxy._l(this.font, a);
    if (f != 0) {
      this._ap(f);
    }
    let g = new WorksheetCellFormatProxy_SetFontFormattingChangeContext(1, this);
    let h = b ? this.a() : null;
    try {
      this.d._bp.setFontFormatting(a);
    }
    finally {
      if (b) {
        this.g(h);
      }
    }
    let i = this._l[WorksheetCellFormatProxy._ag];
    i.e(WorksheetCellFormatProxy_SetFontFormattingChangeContext.$, WorkbookFontData.$, g, g.a, this.d._bp.d);
    if (f != 0) {
      this._ao(f, c);
    }
    if (d != null) {
      d._ic(e);
    }
  }
  _a2($tValue, a, b, c, d, e, f) {
    let g = e(this._u);
    if (EqualityComparer$1.defaultEqualityComparerValue($tValue).equalsC(a, g)) {
      if ((d & 32) != 0) {
        this._ap(b);
        this._ao(b, d);
      }
      return;
    }
    let h = this._l;
    let i = h != null ? h[WorksheetCellFormatProxy._ad(b)] : null;
    let j = new WorksheetCellFormatProxy_FormatChangeContext(1, this);
    let k = j.workbook;
    let l = i != null && k != null ? i.b(k, j.sheet, i.c) : null;
    this._ap(b);
    let m = null;
    if (c) {
      m = this.a();
    }
    f(this.d._bp, a);
    if (c) {
      this.g(m);
    }
    this._ao(b, d);
    if (i != null && k != null) {
      i.e(WorksheetCellFormatProxy_FormatChangeContext.$, $tValue, j, g, a);
      i.d(k, l);
    }
  }
  _ab($tValue, a, b, c, d, e, f) {
    let g = e(this.d);
    if (EqualityComparer$1.defaultEqualityComparerValue($tValue).equalsC(a, g)) {
      if ((d & 32) != 0) {
        this._ap(b);
        this._ao(b, d);
      }
      return false;
    }
    let h = false == this._x ? this._l : null;
    let i = h != null ? h[WorksheetCellFormatProxy._ad(b)] : null;
    let j = null;
    if (!this._x) {
      if ((b & 33587200) != 0) {
        j = new WorksheetCellFormatProxy_SetFormattingChangeContext(1, this);
      }
      else {
        j = new WorksheetCellFormatProxy_FormatChangeContext(1, this);
      }
    }
    let k = j != null ? j.workbook : null;
    let l = i != null && k != null ? i.b(k, this._v, i.c) : null;
    this._ap(b);
    let m = null;
    if (c) {
      m = this.a();
    }
    f(this.d, a);
    if (c) {
      this.g(m);
    }
    this._ao(b, d);
    if (i != null && k != null) {
      if ((b & 33587200) != 0) {
        i.e(WorksheetCellFormatProxy_SetFormattingChangeContext.$, WorksheetCellFormatData.$, j, j.a, this.d);
      }
      else {
        i.e(WorksheetCellFormatProxy_FormatChangeContext.$, $tValue, j, g, a);
      }
      i.d(k, l);
    }
    return true;
  }
  setFormatting(a) {
    this._setFormatting1(a, 0);
  }
  _setFormatting1(a, b) {
    let c = this.d.v;
    let d = null;
    if (c != null) {
      d = c._go(this._v, this._q, null);
    }
    let e = this._n(a);
    if (e != 0) {
      this._ap(e);
    }
    let f = this.c._b1;
    this._a7(a);
    if (e != 0) {
      this._ao(e, b);
    }
    if (c != null) {
      c._ic(d);
    }
  }
  _a7(a) {
    if (a == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFormatting"));
    }
    let b = new WorksheetCellFormatProxy_SetFormattingChangeContext(1, this);
    let c = typeCast(WorksheetCellFormatData.$, a);
    if (c != null && c._b1 == this.c._b1) {
      this.k(c);
    }
    else {
      let d = typeCast(WorksheetCellFormatProxy.$, a);
      if (d != null && d.c._b1 == this.c._b1) {
        this.k(d.c);
      }
      else {
        let e = this.a();
        this.d.setFormatting(a);
        this.g(e);
      }
    }
    let f = this._l[WorksheetCellFormatProxy._ah];
    f.e(WorksheetCellFormatProxy_SetFormattingChangeContext.$, WorksheetCellFormatData.$, b, b.a, this.d);
  }
  _bc(a) {
    this._r = a;
  }
  _bk(a, b) {
    this._bl(a, b, true, 0);
  }
  _bl(a, b, c, d) {
    switch (a) {
      case 1:
        this._au(EnumUtil.getEnumValue(HorizontalCellAlignment_$type, b), c, d);
        break;
      case 2:
        this._av(b, c, d);
        break;
      case 4:
        this._aw(EnumUtil.getEnumValue(CellBorderLineStyle_$type, b), c, d);
        break;
      case 8:
        this._ax(b, c, d);
        break;
      case 16:
        this._ay(EnumUtil.getEnumValue(DiagonalBorders_$type, b), c, d);
        break;
      case 32:
        this._az(EnumUtil.getEnumValue(CellBorderLineStyle_$type, b), c, d);
        break;
      case 64:
        this._a0(b, c, d);
        break;
      case 128:
        this._u._b(wrapNullable(Boolean_$type, b), c, d);
        break;
      case 256:
        this._u._c(b, c, d);
        break;
      case 512:
        this._u._f(typeGetValue(b), c, d);
        break;
      case 1024:
        this._u._g(wrapNullable(Boolean_$type, b), c, d);
        break;
      case 2048:
        this._u._h(b, c, d);
        break;
      case 4096:
        this._u._i(wrapNullable(Boolean_$type, b), c, d);
        break;
      case 8192:
        this._u._j(EnumUtil.getEnumValue(FontSuperscriptSubscriptStyle_$type, b), c, d);
        break;
      case 16384:
        this._u._k(EnumUtil.getEnumValue(FontUnderlineStyle_$type, b), c, d);
        break;
      case 32768:
        this._a3(EnumUtil.getEnumValue(WorksheetCellFormatOptions_$type, b), c, d);
        break;
      case 65536:
        this._a5(b, c, d);
        break;
      case 131072:
        this._a8(typeGetValue(b), c, d);
        break;
      case 262144:
        this._a9(b, c, d);
        break;
      case 524288:
        this._ba(EnumUtil.getEnumValue(CellBorderLineStyle_$type, b), c, d);
        break;
      case 1048576:
        this._bb(wrapNullable(Boolean_$type, b), c, d);
        break;
      case 2097152:
        this._bd(b, c, d);
        break;
      case 4194304:
        this._be(EnumUtil.getEnumValue(CellBorderLineStyle_$type, b), c, d);
        break;
      case 8388608:
        this._bf(typeGetValue(b), c, d);
        break;
      case 16777216:
        this._bg(wrapNullable(Boolean_$type, b), c, d);
        break;
      case 33554432:
        this._bh(b, c, d);
        break;
      case 67108864:
        this._bi(b, c, d);
        break;
      case 134217728:
        this._bj(EnumUtil.getEnumValue(CellBorderLineStyle_$type, b), c, d);
        break;
      case 268435456:
        this._bm(EnumUtil.getEnumValue(VerticalCellAlignment_$type, b), c, d);
        break;
      case 536870912:
        this._bn(wrapNullable(Boolean_$type, b), c, d);
        break;
      default: break;
    }
  }
  static _bo($tValue, a, b, c) {
    c(a, b);
    a.b._a4(a.a, true, -97);
  }
  static _bp(a, b) {
    a.b._a1(b, true, -97);
  }
  static _bq(a, b) {
    a.c._setFormatting1(b, -97);
    a.c._a4(a.b, true, -97);
  }
  get alignment() {
    return this.d.alignment;
  }
  set alignment(a) {
    this._au(a, true, 0);
  }
  _au(a, b, c) {
    this._ab(HorizontalCellAlignment_$type, a, 1, b, c, (d) => d.alignment, (d, e) => d.alignment = e);
  }
  get bottomBorderColorInfo() {
    return this.d.bottomBorderColorInfo;
  }
  set bottomBorderColorInfo(a) {
    this._av(a, true, 0);
  }
  _av(a, b, c) {
    this._ab(WorkbookColorInfo.$, a, 2, b, c, (d) => d.bottomBorderColorInfo, (d, e) => d.bottomBorderColorInfo = e);
  }
  get bottomBorderStyle() {
    return this.d.bottomBorderStyle;
  }
  set bottomBorderStyle(a) {
    this._aw(a, true, 0);
  }
  _aw(a, b, c) {
    this._ab(CellBorderLineStyle_$type, a, 4, b, c, (d) => d.bottomBorderStyle, (d, e) => d.bottomBorderStyle = e);
  }
  get diagonalBorderColorInfo() {
    return this.d.diagonalBorderColorInfo;
  }
  set diagonalBorderColorInfo(a) {
    this._ax(a, true, 0);
  }
  _ax(a, b, c) {
    this._ab(WorkbookColorInfo.$, a, 8, b, c, (d) => d.diagonalBorderColorInfo, (d, e) => d.diagonalBorderColorInfo = e);
  }
  get diagonalBorders() {
    return this.d.diagonalBorders;
  }
  set diagonalBorders(a) {
    this._ay(a, true, 0);
  }
  _ay(a, b, c) {
    this._ab(DiagonalBorders_$type, a, 16, b, c, (d) => d.diagonalBorders, (d, e) => d.diagonalBorders = e);
  }
  get diagonalBorderStyle() {
    return this.d.diagonalBorderStyle;
  }
  set diagonalBorderStyle(a) {
    this._az(a, true, 0);
  }
  _az(a, b, c) {
    this._ab(CellBorderLineStyle_$type, a, 32, b, c, (d) => d.diagonalBorderStyle, (d, e) => d.diagonalBorderStyle = e);
  }
  get fill() {
    return this.d.fill;
  }
  set fill(a) {
    this._a0(a, true, 0);
  }
  _a0(a, b, c) {
    this._ab(CellFill.$, a, 64, b, c, (d) => d.fill, (d, e) => d.fill = e);
  }
  get font() {
    return this._u;
  }
  get formatOptions() {
    return this.d.formatOptions;
  }
  set formatOptions(a) {
    this._a3(a, true, 0);
  }
  get _w() {
    return this.d.formatOptions;
  }
  _a4(a, b, c) {
    this._x = true;
    this._a3(a, b, c);
    this._x = false;
  }
  _a3(a, b, c) {
    if (this._r != null) {
      this._r.verifyFormatOptions(this, a);
    }
    this._ab(WorksheetCellFormatOptions_$type, a, 32768, b, c, (d) => d.formatOptions, (d, e) => d.formatOptions = e);
  }
  get formatString() {
    return this.d.formatString;
  }
  set formatString(a) {
    this._a5(a, true, 0);
  }
  _a5(a, b, c) {
    this._ab(String_$type, a, 65536, b, c, (d) => d.formatString, (d, e) => d.formatString = e);
  }
  get indent() {
    return this.d.indent;
  }
  set indent(a) {
    this._a8(a, true, 0);
  }
  _a8(a, b, c) {
    this._ab(Number_$type, a, 131072, b, c, (d) => d.indent, (d, e) => d.indent = e);
  }
  get leftBorderColorInfo() {
    return this.d.leftBorderColorInfo;
  }
  set leftBorderColorInfo(a) {
    this._a9(a, true, 0);
  }
  _a9(a, b, c) {
    this._ab(WorkbookColorInfo.$, a, 262144, b, c, (d) => d.leftBorderColorInfo, (d, e) => d.leftBorderColorInfo = e);
  }
  get leftBorderStyle() {
    return this.d.leftBorderStyle;
  }
  set leftBorderStyle(a) {
    this._ba(a, true, 0);
  }
  _ba(a, b, c) {
    this._ab(CellBorderLineStyle_$type, a, 524288, b, c, (d) => d.leftBorderStyle, (d, e) => d.leftBorderStyle = e);
  }
  get locked() {
    return unwrapNullable(this._locked$i);
  }
  set locked(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._locked$i = arguments[0];
  }
  get _locked$i() {
    return this.d._locked$i;
  }
  set _locked$i(a) {
    this._bb(a, true, 0);
  }
  _bb(a, b, c) {
    this._ab(Nullable$1.$.specialize(Boolean_$type), a, 1048576, b, c, (d) => d._locked$i, (d, e) => d._locked$i = e);
  }
  get rightBorderColorInfo() {
    return this.d.rightBorderColorInfo;
  }
  set rightBorderColorInfo(a) {
    this._bd(a, true, 0);
  }
  _bd(a, b, c) {
    this._ab(WorkbookColorInfo.$, a, 2097152, b, c, (d) => d.rightBorderColorInfo, (d, e) => d.rightBorderColorInfo = e);
  }
  get rightBorderStyle() {
    return this.d.rightBorderStyle;
  }
  set rightBorderStyle(a) {
    this._be(a, true, 0);
  }
  _be(a, b, c) {
    this._ab(CellBorderLineStyle_$type, a, 4194304, b, c, (d) => d.rightBorderStyle, (d, e) => d.rightBorderStyle = e);
  }
  get rotation() {
    return this.d.rotation;
  }
  set rotation(a) {
    this._bf(a, true, 0);
  }
  _bf(a, b, c) {
    this._ab(Number_$type, a, 8388608, b, c, (d) => d.rotation, (d, e) => d.rotation = e);
  }
  get shrinkToFit() {
    return unwrapNullable(this._shrinkToFit$i);
  }
  set shrinkToFit(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._shrinkToFit$i = arguments[0];
  }
  get _shrinkToFit$i() {
    return this.d._shrinkToFit$i;
  }
  set _shrinkToFit$i(a) {
    this._bg(a, true, 0);
  }
  _bg(a, b, c) {
    this._ab(Nullable$1.$.specialize(Boolean_$type), a, 16777216, b, c, (d) => d._shrinkToFit$i, (d, e) => d._shrinkToFit$i = e);
  }
  get style() {
    return this.d.style;
  }
  set style(a) {
    this._bh(a, true, 0);
  }
  _bh(a, b, c) {
    a = this.d._br(a);
    this._ab(WorkbookStyle.$, a, 33554432, b, c, (d) => d.style, (d, e) => d.style = e);
  }
  get topBorderColorInfo() {
    return this.d.topBorderColorInfo;
  }
  set topBorderColorInfo(a) {
    this._bi(a, true, 0);
  }
  _bi(a, b, c) {
    this._ab(WorkbookColorInfo.$, a, 67108864, b, c, (d) => d.topBorderColorInfo, (d, e) => d.topBorderColorInfo = e);
  }
  get topBorderStyle() {
    return this.d.topBorderStyle;
  }
  set topBorderStyle(a) {
    this._bj(a, true, 0);
  }
  _bj(a, b, c) {
    this._ab(CellBorderLineStyle_$type, a, 134217728, b, c, (d) => d.topBorderStyle, (d, e) => d.topBorderStyle = e);
  }
  get verticalAlignment() {
    return this.d.verticalAlignment;
  }
  set verticalAlignment(a) {
    this._bm(a, true, 0);
  }
  _bm(a, b, c) {
    this._ab(VerticalCellAlignment_$type, a, 268435456, b, c, (d) => d.verticalAlignment, (d, e) => d.verticalAlignment = e);
  }
  get wrapText() {
    return unwrapNullable(this._wrapText$i);
  }
  set wrapText(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._wrapText$i = arguments[0];
  }
  get _wrapText$i() {
    return this.d._wrapText$i;
  }
  set _wrapText$i(a) {
    this._bn(a, true, 0);
  }
  _bn(a, b, c) {
    this._ab(Nullable$1.$.specialize(Boolean_$type), a, 536870912, b, c, (d) => d._wrapText$i, (d, e) => d._wrapText$i = e);
  }
  get _u() {
    if (this._t == null) {
      this._t = new WorkbookFontOwnerAccessor(this);
    }
    return this._t;
  }
  get _z() {
    return this.d._cd;
  }
  get _s() {
    return this._r;
  }
  get__ak() {
    return this._s;
  }
  get _ak() {
    return this.get__ak();
  }
}
WorksheetCellFormatProxy.$t = markType(WorksheetCellFormatProxy, 'WorksheetCellFormatProxy', GenericCacheElementProxy$1.$.specialize(WorksheetCellFormatData.$), [IWorksheetCellFormat_$type]);
WorksheetCellFormatProxy._ah = WorksheetCellFormatProxy._ad(1073741824);
WorksheetCellFormatProxy._ag = WorksheetCellFormatProxy._ah + 1;
WorksheetCellFormatProxy._af = WorksheetCellFormatProxy._ag + 1;
/**
 * @hidden
 */
export let IWorksheetCellFormatProxyContext_$type = new Type(null, 'IWorksheetCellFormatProxyContext', null, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetCellFormatProxy_FormatChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = 0;
    this.c = Nullable$1.toNullable(WorksheetCellAddress.$, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.b = c;
          this.a = this.b.d.formatOptions;
          this.c = this.b._ai();
        }
        break;
    }
  }
  get proxy() {
    return this.b;
  }
  get workbook() {
    return this.b.d.v;
  }
  get sheet() {
    return this.b._v;
  }
  get source() {
    return this.b._ak;
  }
}
WorksheetCellFormatProxy_FormatChangeContext.$t = markStruct(WorksheetCellFormatProxy_FormatChangeContext, 'WorksheetCellFormatProxy_FormatChangeContext', ValueType.$, [IWorksheetCellFormatProxyContext_$type]);
/**
 * @hidden
 */
export class WorksheetCellFormatProxy_SetFormattingChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = null;
    this.b = 0;
    this.a = null;
    this.d = Nullable$1.toNullable(WorksheetCellAddress.$, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.c = c;
          this.b = this.c.d.formatOptions;
          this.a = this.c.d;
          this.d = this.c._ai();
          let d = c.d.v;
          if (d != null && d._c9) {
            this.a = typeCast(WorksheetCellFormatData.$, this.a.y());
          }
        }
        break;
    }
  }
  get proxy() {
    return this.c;
  }
  get workbook() {
    return this.c.d.v;
  }
  get sheet() {
    return this.c._v;
  }
  get source() {
    return this.c._ak;
  }
}
WorksheetCellFormatProxy_SetFormattingChangeContext.$t = markStruct(WorksheetCellFormatProxy_SetFormattingChangeContext, 'WorksheetCellFormatProxy_SetFormattingChangeContext', ValueType.$, [IWorksheetCellFormatProxyContext_$type]);
/**
 * @hidden
 */
export class WorksheetCellFormatProxy_SetFontFormattingChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = Nullable$1.toNullable(WorksheetCellAddress.$, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.b = c;
          this.a = this.b.d._bp.d;
          this.c = this.b._ai();
          let d = c.d.v;
          if (d != null && d._c9) {
            this.a = typeCast(WorkbookFontData.$, this.a.y());
          }
        }
        break;
    }
  }
  get proxy() {
    return this.b;
  }
  get workbook() {
    return this.b.d.v;
  }
  get sheet() {
    return this.b._v;
  }
  get source() {
    return this.b._ak;
  }
}
WorksheetCellFormatProxy_SetFontFormattingChangeContext.$t = markStruct(WorksheetCellFormatProxy_SetFontFormattingChangeContext, 'WorksheetCellFormatProxy_SetFontFormattingChangeContext', ValueType.$, [IWorksheetCellFormatProxyContext_$type]);
/**
 * @hidden
 */
export let IWorkbookFont_$type = new Type(null, 'IWorkbookFont');
/**
 * @hidden
 */
export class WorkbookFontData extends GenericCacheElementEx {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this._aq = ExcelUtils.dq;
          this._al = false;
          this._an = 0;
          this._ai = null;
          this._ao = -1;
          this._ar = ExcelUtils.dq;
          this._au = null;
          this._as = ExcelUtils.dq;
          this._ag = -1;
          this._ah = -1;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c, c.v];
          {
            let f = d[0];
            let g = d[1];
            let h = [g];
            {
              let j = h[0];
              super(j);
              this._aq = ExcelUtils.dq;
              this._al = false;
              this._an = 0;
              this._ai = null;
              this._ao = -1;
              this._ar = ExcelUtils.dq;
              this._au = null;
              this._as = ExcelUtils.dq;
              this._ag = -1;
              this._ah = -1;
            }
            this._aq = f._aq;
            this._ai = f._ai;
            this._ao = f._ao;
            this._ar = f._ar;
            this._au = f._au;
            this._as = f._as;
            this._ag = f._ag;
            this._ah = f._ah;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [d];
          {
            let g = e[0];
            super(g);
            this._aq = ExcelUtils.dq;
            this._al = false;
            this._an = 0;
            this._ai = null;
            this._ao = -1;
            this._ar = ExcelUtils.dq;
            this._au = null;
            this._as = ExcelUtils.dq;
            this._ag = -1;
            this._ah = -1;
          }
          this._aq = c._aq;
          this._ai = c._ai;
          this._ao = c._ao;
          this._ar = c._ar;
          this._au = c._au;
          this._as = c._as;
          this._ag = c._ag;
          this._ah = c._ah;
        }
        break;
    }
  }
  g(a) {
    return this._aj(a);
  }
  _aj(a) {
    return new WorkbookFontData(2, this, a);
  }
  aa(a) {
    let b = typeCast(WorkbookFontData.$, a);
    if (b == null) {
      return;
    }
    this.setFontFormatting(b);
  }
  equals(a) {
    return this.c(typeCast(GenericCacheElement.$, a));
  }
  getHashCode() {
    if (!this._al) {
      let a = 0;
      if (this._au != null) {
        a ^= Base.getHashCodeStatic(this._au);
      }
      a ^= this._ao << 1;
      if (WorkbookColorInfo.l_op_Inequality(this._ai, null)) {
        a ^= this._ai.getHashCode() << 2;
      }
      a ^= ExcelUtils.dk(this._aq) << 3;
      a ^= ExcelUtils.dk(this._ar) << 4;
      a ^= ExcelUtils.dk(this._as) << 5;
      a ^= this._ag << 6;
      a ^= this._ah << 7;
      this._an = a;
      this._al = true;
    }
    return this._an;
  }
  c(a) {
    if (a == null) {
      return false;
    }
    if (this == a) {
      return true;
    }
    let b = a;
    if (this._ao != b._ao) {
      return false;
    }
    if (nullableNotEquals(this._aq, b._aq)) {
      return false;
    }
    if (nullableNotEquals(this._ar, b._ar)) {
      return false;
    }
    if (nullableNotEquals(this._as, b._as)) {
      return false;
    }
    if (this._ag != b._ag) {
      return false;
    }
    if (this._ah != b._ah) {
      return false;
    }
    if (this._au != b._au) {
      return false;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._ai, b._ai)) {
      return false;
    }
    return true;
  }
  af() {
    if (this.x) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ReadOnlyFont"));
    }
  }
  setFontFormatting(a) {
    if (a == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFont"));
    }
    this._au = a.name;
    this._ao = a.height;
    this._ai = a.colorInfo;
    this._aq = a._bold$i;
    this._ar = a._italic$i;
    this._as = a._strikeout$i;
    this._ag = a.superscriptSubscriptStyle;
    this._ah = a.underlineStyle;
    this._al = false;
  }
  _ay() {
    if (this.t != null) {
      return;
    }
    this.x = true;
  }
  _ak(a) {
    if (a == null) {
      a = UltimateFontDefaultsResolver.a;
    }
    let b = new WorkbookFontData(1, this);
    if (a != null) {
      a.resolveDefaults(b);
    }
    return b;
  }
  get bold() {
    return unwrapNullable(this._bold$i);
  }
  set bold(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._bold$i = arguments[0];
  }
  get _bold$i() {
    return this._aq;
  }
  set _bold$i(a) {
    this.af();
    if (nullableEquals(this._aq, a)) {
      return;
    }
    ExcelUtils.gn(a, "value");
    this._aq = a;
    this._al = false;
  }
  get colorInfo() {
    return this._ai;
  }
  set colorInfo(a) {
    this.af();
    if (WorkbookColorInfo.l_op_Equality(this._ai, a)) {
      return;
    }
    this._ai = a;
    this._al = false;
  }
  get height() {
    return this._ao;
  }
  set height(a) {
    this.af();
    if (this._ao == a) {
      return;
    }
    if (a >= 0 && (a < 20 || 8180 < a)) {
      throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_FontHeight"));
    }
    this._ao = a;
    this._al = false;
  }
  get italic() {
    return unwrapNullable(this._italic$i);
  }
  set italic(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._italic$i = arguments[0];
  }
  get _italic$i() {
    return this._ar;
  }
  set _italic$i(a) {
    this.af();
    if (nullableEquals(this._ar, a)) {
      return;
    }
    ExcelUtils.gn(a, "value");
    this._ar = a;
    this._al = false;
  }
  get name() {
    return this._au;
  }
  set name(a) {
    this.af();
    if (this._au == a) {
      return;
    }
    this._au = a;
    this._al = false;
  }
  get strikeout() {
    return unwrapNullable(this._strikeout$i);
  }
  set strikeout(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._strikeout$i = arguments[0];
  }
  get _strikeout$i() {
    return this._as;
  }
  set _strikeout$i(a) {
    this.af();
    if (nullableEquals(this._as, a)) {
      return;
    }
    ExcelUtils.gn(a, "value");
    this._as = a;
    this._al = false;
  }
  get superscriptSubscriptStyle() {
    return this._ag;
  }
  set superscriptSubscriptStyle(a) {
    this.af();
    if (this._ag == a) {
      return;
    }
    ExcelUtils.gm(FontSuperscriptSubscriptStyle_$type, a, "value");
    this._ag = a;
    this._al = false;
  }
  get underlineStyle() {
    return this._ah;
  }
  set underlineStyle(a) {
    this.af();
    if (this._ah == a) {
      return;
    }
    ExcelUtils.gm(FontUnderlineStyle_$type, a, "value");
    this._ah = a;
    this._al = false;
  }
  get _am() {
    return nullableEquals(this._aq, null) && WorkbookColorInfo.l_op_Equality(this._ai, null) && this._ao < 0 && nullableEquals(this._ar, null) && this._au == null && nullableEquals(this._as, null) && this._ag == -1 && this._ah == -1;
  }
}
WorkbookFontData.$t = markType(WorkbookFontData, 'WorkbookFontData', GenericCacheElementEx.$, [IWorkbookFont_$type]);
WorkbookFontData._at = 220;
/**
 * @hidden
 */
export class ConditionalFormatOwnedFormatProxy extends WorksheetCellFormatProxy {
  constructor(a, b) {
    super(0, b._bw, a, b);
  }
  g(a) {
    super.g(a);
    this._s._ba();
  }
  b(a) {
    let b = typeCast(ConditionalFormatBase.$, this._s);
    let c = super.b(a);
    b._bw = this.c;
    return c;
  }
  get__l() {
    return ConditionalFormatOwnedFormatProxy._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 28;
  }
  get _q() {
    return this.get__q();
  }
  get_d() {
    let a = typeCast(ConditionalFormatBase.$, this._s);
    return a._bw;
  }
  get__v() {
    let a = typeCast(ConditionalFormatBase.$, this._s);
    return a != null ? a.worksheet : null;
  }
  get _v() {
    return this.get__v();
  }
}
ConditionalFormatOwnedFormatProxy.$t = markType(ConditionalFormatOwnedFormatProxy, 'ConditionalFormatOwnedFormatProxy', WorksheetCellFormatProxy.$);
ConditionalFormatOwnedFormatProxy._br = WorksheetCellFormatProxy._m(28, 4);
/**
 * Represents a custom view in Microsoft Excel.
 * <p class="body">
 * Custom views provide a way to save display options and optionally print options for the workbook and each worksheet in the workbook.
 * These options can be different from the options currently set on the workbook and worksheets.
 * </p>
 * <p class="body">
 * Multiple custom views can be saved with a workbook, and the options from a custom view can be applied to its associated workbook by
 * calling the [[apply]] method on it.
 * </p>
 * @see [[Workbook.customViews]]
 */
export class CustomView extends Base {
  constructor(a, b, c) {
    super();
    this._i = null;
    this._s = new Guid();
    this._m = false;
    this._k = false;
    this._u = null;
    this._b = null;
    this._o = null;
    this._q = null;
    this._r = null;
    this._p = null;
    this._i = a;
    this._m = b;
    this._k = c;
    this._o = new Dictionary$2(Sheet.$, DisplayOptionsBase.$, 0);
    if (this._m) {
      this._p = new Dictionary$2(Sheet.$, PrintOptionsBase.$, 0);
    }
    if (this._k) {
      this._q = new Dictionary$2(Worksheet.$, HiddenColumnCollection.$, 0);
      this._r = new Dictionary$2(Worksheet.$, HiddenRowCollection.$, 0);
    }
    this._b = new CustomViewWindowOptions(this);
    this._b._ab(a.windowOptions, true);
    if (!a._c4) {
      for (let d of fromEnum(a._sheets$i)) {
        this._y(d);
      }
    }
  }
  /**
   * Applies all options from the custom view to the associated workbook and its worksheets.
   * <p class="body">
   * There is no state of the workbook indicating the custom view currently applied, so applying a custom view
   * simply copies over all options saved with it to the workbook and its worksheet. If an applied custom view
   * is then changed, those changes will not be updated on the workbook or worksheets. Instead, the custom view will need
   * to be applied again for those changes to be reflected on the workbook or worksheet.
   * </p>
   * @throws [[InvalidOperationException]] The custom view has previously been removed from its associated workbook.
   */
  apply() {
    if (this._i == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantApplyRemovedCustomView"));
    }
    let a = null;
    let b = this.windowOptions._k;
    if (b != null) {
      a = this.getSheetDisplayOptions(b, false);
    }
    this._i.windowOptions._ab(this.windowOptions, a != null && a.visibility == 0);
    for (let c of fromEnum(this._o)) {
      c.key._e._n(c.value);
    }
    if (this._m) {
      for (let d of fromEnum(this._p)) {
        d.key._g._bz(d.value);
      }
    }
    if (this._k) {
      for (let e of fromEnum(this._q)) {
        e.key._columns$i._as(e.value);
      }
      for (let f of fromEnum(this._r)) {
        f.key._rows$i._as(f.value);
      }
    }
  }
  /**
   * Gets the display options associated with the specified worksheet.
   * <p class="body">
   * Setting properties on the returned [[DisplayOptions]] instance will not change the actual
   * display of the worksheet. After setting properties, the [[apply]] method of the
   * [[CustomView]] will apply them to the worksheet.
   * </p>
   * @param worksheet The worksheet whose associated display options are to be retrieved.
   * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded.
   * @throws [[ArgumentNullException]] 'worksheet' is null.
   * @return Null if the worksheet does not belong to the workbook associated with this custom view;
   * otherwise, the display options associated with the worksheet.
   * @see [[Worksheet.displayOptions]]
   */
  getDisplayOptions(worksheet, createIfNull = true) {
    return this.getSheetDisplayOptions(worksheet, createIfNull);
  }
  /**
   * Gets the display options associated with the specified sheet.
   * <p class="body">
   * Setting properties on the returned [[DisplayOptionsBase]] instance will not change the actual
   * display of the sheet. After setting properties, the [[apply]] method of the
   * [[CustomView]] will apply them to the sheet.
   * </p>
   * @param sheet The sheet whose associated display options are to be retrieved.
   * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded.
   * @throws [[ArgumentNullException]] 'sheet' is null.
   * @return Null if the sheet does not belong to the workbook associated with this custom view;
   * otherwise, the display options associated with the worksheet.
   * @see [[Worksheet.displayOptions]]
   * @see [[Chartsheet.displayOptions]]
   */
  getSheetDisplayOptions(sheet, createIfNull = true) {
    if (sheet == null) {
      throw new ArgumentNullException(0, "sheet");
    }
    let a;
    if (((() => { let b = this._o.tryGetValue(sheet, a); a = b.p1; return b.ret; })())) {
      return a;
    }
    if (createIfNull && sheet.workbook == this._i) {
      a = sheet._d(this);
      this._o.addItem(sheet, a);
      return a;
    }
    return null;
  }
  /**
   * Gets the hidden columns associated with the specified worksheet.
   * <p class="body">
   * Adding columns on the returned [[HiddenColumnCollection]] instance will not actually hide
   * columns in the worksheet. After modifying the hidden columns in this collection, the [[apply]]
   * method of the [[CustomView]] will hide or unhide the columns.
   * </p>
   * @param worksheet The worksheet whose associated hidden columns are to be retrieved.
   * @param createIfNull True to create the hidden column if it has not yet been allocated of the Worksheet. The options will be initialized based on the current state. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
   * @throws [[ArgumentNullException]] 'worksheet' is null.
   * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
   * associated with this custom view; otherwise, the collection of hidden columns associated with the worksheet.
   * @see [[RowColumnBase.hidden]]
   * @see [[saveHiddenRowsAndColumns]]
   */
  getHiddenColumns(worksheet, createIfNull = true) {
    if (worksheet == null) {
      throw new ArgumentNullException(0, "worksheet");
    }
    if (this._k == false) {
      return null;
    }
    let a;
    if (((() => { let b = this._q.tryGetValue(worksheet, a); a = b.p1; return b.ret; })())) {
      return a;
    }
    if (createIfNull && worksheet.workbook == this._i) {
      a = new HiddenColumnCollection(worksheet, this);
      this._q.addItem(worksheet, a);
      return a;
    }
    return null;
  }
  /**
   * Gets the hidden rows associated with the specified worksheet.
   * <p class="body">
   * Adding rows on the returned [[HiddenRowCollection]] instance will not actually hide
   * rows in the worksheet. After modifying the hidden rows in this collection, the [[apply]]
   * method of the [[CustomView]] will hide or unhide the rows.
   * </p>
   * @param worksheet The worksheet whose associated hidden rows are to be retrieved.
   * @param createIfNull True to create the hidden column if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
   * @throws [[ArgumentNullException]] 'worksheet' is null.
   * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
   * associated with this custom view; otherwise, the collection of hidden rows associated with the worksheet.
   * @see [[RowColumnBase.hidden]]
   * @see [[saveHiddenRowsAndColumns]]
   */
  getHiddenRows(worksheet, createIfNull = true) {
    if (worksheet == null) {
      throw new ArgumentNullException(0, "worksheet");
    }
    if (this._k == false) {
      return null;
    }
    let a;
    if (((() => { let b = this._r.tryGetValue(worksheet, a); a = b.p1; return b.ret; })())) {
      return a;
    }
    if (createIfNull && worksheet.workbook == this._i) {
      a = new HiddenRowCollection(worksheet, this);
      this._r.addItem(worksheet, a);
      return a;
    }
    return null;
  }
  /**
   * Gets the print options associated with the specified worksheet.
   * <p class="body">
   * Setting properties on the returned [[PrintOptions]] instance will not change the actual
   * print settings of the worksheet. After setting properties, the [[apply]] method of the
   * [[CustomView]] will apply them to the worksheet.
   * </p>
   * @param worksheet The worksheet whose associated print options are to be retrieved.
   * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
   * @throws [[ArgumentNullException]] 'worksheet' is null.
   * @return Null if [[savePrintOptions]] is False or if the worksheet does not belong to the workbook associated
   * with this custom view; otherwise, the print options associated with the worksheet.
   * @see [[Worksheet.printOptions]]
   * @see [[savePrintOptions]]
   */
  getPrintOptions(worksheet, createIfNull = true) {
    return this.getSheetPrintOptions(worksheet, createIfNull);
  }
  /**
   * Gets the print options associated with the specified sheet.
   * <p class="body">
   * Setting properties on the returned [[PrintOptionsBase]] instance will not change the actual
   * print settings of the sheet. After setting properties, the [[apply]] method of the
   * [[CustomView]] will apply them to the sheet.
   * </p>
   * @param sheet The sheet whose associated print options are to be retrieved.
   * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
   * @throws [[ArgumentNullException]] 'sheet' is null.
   * @return Null if [[savePrintOptions]] is False or if the sheet does not belong to the workbook associated
   * with this custom view; otherwise, the print options associated with the sheet.
   * @see [[Worksheet.printOptions]]
   * @see [[Chartsheet.printOptions]]
   * @see [[savePrintOptions]]
   */
  getSheetPrintOptions(sheet, createIfNull = true) {
    if (sheet == null) {
      throw new ArgumentNullException(0, "sheet");
    }
    if (this._m == false) {
      return null;
    }
    let a;
    if (((() => { let b = this._p.tryGetValue(sheet, a); a = b.p1; return b.ret; })())) {
      return a;
    }
    if (createIfNull && sheet.workbook == this._i) {
      a = sheet._f();
      this._p.addItem(sheet, a);
      return a;
    }
    return null;
  }
  /**
   * @hidden
   */
  _x() {
    this._i = null;
    this._o.clear();
    if (this._m) {
      this._p.clear();
    }
    if (this._k) {
      this._q.clear();
      this._r.clear();
    }
  }
  /**
   * @hidden
   */
  _y(a) {
    if (this._i._c4) {
      return;
    }
    let b = a._d(this);
    b._n(a._e);
    this._o.addItem(a, b);
    if (this._m) {
      let c = a._f();
      c._bz(a._g);
      this._p.addItem(a, c);
    }
    if (this._k && a.type == 0) {
      let d = a;
      let e = new HiddenColumnCollection(d, this);
      e._n(d);
      this._q.addItem(d, e);
      let f = new HiddenRowCollection(d, this);
      f._n(d);
      this._r.addItem(d, f);
    }
  }
  /**
   * @hidden
   */
  _z(a) {
    if (this.windowOptions.selectedSheet == a) {
      this.windowOptions.selectedSheet = null;
    }
    this._o.removeItem(a);
    if (this._m) {
      this._p.removeItem(a);
    }
    if (this._k && a.type == 0) {
      let b = a;
      this._q.removeItem(b);
      this._r.removeItem(b);
    }
  }
  /**
   * @hidden
   */
  _aa(a) {
    this._k = a;
    if (this._k == false) {
      this._q = null;
      this._r = null;
    }
  }
  /**
   * @hidden
   */
  _ab(a) {
    this._m = a;
    if (this._m == false) {
      this._p = null;
    }
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    if (this._p != null) {
      for (let c of fromEnum(this._p.values)) {
        c._b1(a, b);
      }
    }
  }
  /**
   * Gets or sets the name of the custom view.
   * <p class="body">
   * The name of the custom view is displayed in the custom views dialog of Microsoft Excel and must be
   * case-insensitively unique to other custom views in the workbook.
   * </p>
   * The name of the custom view.
   * @throws [[ArgumentNullException]] The value assigned is a null or empty.
   * @throws [[ArgumentException]] The value assigned is the name of another custom view in this custom view's associated workbook (custom view
   * names are compared case-insensitively).
   */
  get name() {
    return this._u;
  }
  /**
   * Gets or sets the name of the custom view.
   * <p class="body">
   * The name of the custom view is displayed in the custom views dialog of Microsoft Excel and must be
   * case-insensitively unique to other custom views in the workbook.
   * </p>
   * The name of the custom view.
   * @throws [[ArgumentNullException]] The value assigned is a null or empty.
   * @throws [[ArgumentException]] The value assigned is the name of another custom view in this custom view's associated workbook (custom view
   * names are compared case-insensitively).
   */
  set name(a) {
    if (this._u != a) {
      if (stringIsNullOrEmpty(a)) {
        throw new ArgumentNullException(2, "value", ExcelUtils.ef("LE_ArgumentNullException_CustomViewName"));
      }
      if (this._i != null && this._i._cq) {
        for (let b of fromEnum(this._i._customViews$i)) {
          if (b == this) {
            continue;
          }
          if (StringUtilities.c(a, b.name, this._i._e6, 1) == 0) {
            throw new ArgumentException(2, ExcelUtils.eg("LE_ArgumentException_CustomViewNameAlreadyExists", b.name), "value");
          }
        }
      }
      this._u = a;
    }
  }
  /**
   * Gets the value indicating whether hidden row and column settings are saved with the custom view.
   * <p class="body">
   * If the value is False, the return value of [[getHiddenColumns]] and [[getHiddenRows]]
   * will always be null, regardless of the worksheet specified.
   * </p>
   * The value indicating whether hidden row and column settings are saved with the custom view.
   * @see [[getHiddenColumns]]
   * @see [[getHiddenRows]]
   * @see [[HiddenColumnCollection]]
   * @see [[HiddenRowCollection]]
   */
  get saveHiddenRowsAndColumns() {
    return this._k;
  }
  /**
   * Gets the value indicating whether print options are saved with the custom view.
   * <p class="body">
   * If the value is False, the return value of [[getPrintOptions]] will always be null,
   * regardless of the worksheet specified.
   * </p>
   * The value indicating whether print options are saved with the custom view.
   * @see [[getPrintOptions]]
   * @see [[PrintOptions]]
   */
  get savePrintOptions() {
    return this._m;
  }
  /**
   * Gets the window options for the workbook associated with the custom view.
   * <p class="body">
   * Setting properties on the returned [[windowOptions]] instance will not change the actual
   * window options of the associated workbook. After setting properties, the [[apply]] method
   * of the [[CustomView]] will apply them to the workbook.
   * </p>
   * The window options for the workbook associated with the custom view..
   * @see */
  get windowOptions() {
    return this._b;
  }
  /**
   * @hidden
   */
  get _t() {
    if (Guid.l_op_Equality(this._s, new Guid(0))) {
      this._s = Guid.newGuid();
    }
    return this._s;
  }
  /**
   * @hidden
   */
  set _t(a) {
    this._s = a;
  }
  /**
   * @hidden
   */
  get _j() {
    return this._i;
  }
}
CustomView.$t = markType(CustomView, 'CustomView');
/**
 * Abstract base class which exposes the various display options available for a sheet which can be
 * saved with both a sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 */
export class DisplayOptionsBase extends Base {
  constructor(a) {
    super();
    this._f = null;
    this._h = 0;
    this._f = a;
  }
  /**
   * Resets the display options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
   * </p>
   */
  reset() {
    let a = this._d();
    let b = DisplayOptionsBase._a[0];
    let c = b.b(this._f.workbook, this._f, b.c);
    this.resetCore();
    b.x(this, a, this);
    if (c != null) {
      b.d(this._f.workbook, c);
    }
  }
  /**
   * Resets the display options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
   * </p>
   */
  resetCore() {
    this._h = 0;
    if (this._j) {
      this._sheet.tabColorInfo = null;
    }
  }
  /**
   * @hidden
   */
  _d() {
    let a = this._e();
    a._n(this);
    return a;
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = this._h;
    this._h = a.visibility;
    if (b != this.visibility) {
      this._p(b, this.visibility);
    }
  }
  /**
   * @hidden
   */
  _o() {
  }
  /**
   * @hidden
   */
  _p(a, b) {
    if (this._f != null && this._j) {
      this._f._as(a, b);
    }
  }
  /**
   * @hidden
   */
  _s(a) {
    let b = this._d();
    this._n(a);
    DisplayOptionsBase._a[0].x(this, b, this);
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(DisplayOptionsBase.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, DisplayOptionsBase._c(DisplayOptionsBase.$, "Reset", (b) => b, (b, c) => b._s(c), null, true));
    ChangeInfo.f(a, 1, DisplayOptionsBase._c(WorksheetVisibility_$type, "Visibility", (b) => b.visibility, (b, c) => b.visibility = c));
    return a;
  }
  /**
   * Gets or sets the visibility of the sheet.
   * <p class="body">
   * The visibility determines whether the sheet's tab will appear in the tab bar at the
   * bottom of Microsoft Excel.
   * </p>
   * The visibility of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[WorksheetVisibility]] enumeration.
   */
  get visibility() {
    return this._h;
  }
  /**
   * Gets or sets the visibility of the sheet.
   * <p class="body">
   * The visibility determines whether the sheet's tab will appear in the tab bar at the
   * bottom of Microsoft Excel.
   * </p>
   * The visibility of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[WorksheetVisibility]] enumeration.
   */
  set visibility(a) {
    if (this._h != a) {
      if (EnumUtil.isDefined(WorksheetVisibility_$type, enumGetBox(WorksheetVisibility_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, WorksheetVisibility_$type);
      }
      let b = this._h;
      let c = DisplayOptionsBase._a[1].g(DisplayOptionsBase.$, WorksheetVisibility_$type, this, this._h, a);
      this._h = c.p1;
      this._p(b, a);
    }
  }
  /**
   * @hidden
   */
  get _sheet() {
    return this._f;
  }
  /**
   * @hidden
   */
  get workbook() {
    let a = this._sheet;
    return a != null ? a.workbook : null;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._sheet;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
DisplayOptionsBase.$t = markType(DisplayOptionsBase, 'DisplayOptionsBase', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
DisplayOptionsBase._l = 0;
/**
 * @hidden
 */
DisplayOptionsBase._m = 1;
/**
 * @hidden
 */
DisplayOptionsBase._k = 2;
/**
 * @hidden
 */
DisplayOptionsBase._a = DisplayOptionsBase._b();
/**
 * Abstract base class which exposes the various display options available for a worksheet which can be
 * saved with both a worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export class DisplayOptions extends DisplayOptionsBase {
  constructor(a) {
    super(a);
    this._ac = null;
    this._w = null;
    this._a1 = true;
    this._a7 = 64;
    this._aj = false;
    this._bk = Nullable$1.toNullable(Boolean_$type, null);
    this._bm = Nullable$1.toNullable(Boolean_$type, null);
    this._ap = false;
    this._ar = true;
    this._at = true;
    this._av = true;
    this._ax = true;
    this._az = true;
    this._aa = null;
    this._ag = 0;
    this._ae = null;
    this._y = 3;
    this._ac = a;
  }
  /**
   * Resets the display options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    if (this._w != null) {
      this._w.resetCore();
    }
    this._a1 = true;
    this._a7 = 64;
    this._aj = false;
    this._ap = false;
    this._ar = true;
    this._at = true;
    this._av = true;
    this._ax = true;
    this._az = true;
    this._bm = Nullable$1.toNullable(Boolean_$type, null);
    this._bk = Nullable$1.toNullable(Boolean_$type, null);
    if (this._aa != null) {
      this._aa.resetCore();
    }
    this.clearSelection();
    this._y = 3;
    this._ag = 0;
    super.resetCore();
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = typeCast(DisplayOptions.$, a);
    if (b != null) {
      this.frozenPaneSettings._s(b.frozenPaneSettings);
      this._a1 = b._a1;
      this._a7 = b._a7;
      this._aj = b._aj;
      this._ap = b._ap;
      this._ar = b._ar;
      this._at = b._at;
      this._av = b._av;
      this._ax = b._ax;
      this._az = b._az;
      this.unfrozenPaneSettings._s(b.unfrozenPaneSettings);
      this._ag = b._ag;
    }
    if (b != null) {
      if (b._ai) {
        this._af.e(b._af);
      }
      else {
        this.clearSelection();
      }
      this._y = b._y;
    }
    super._n(a);
  }
  /**
   * @hidden
   */
  _bq(a) {
    this._ag = a;
  }
  /**
   * @hidden
   */
  static _v($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(DisplayOptions.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _u() {
    let a = new Array(11);
    ChangeInfo.f(a, 0, DisplayOptions._v(Color.$, "GridlineColor", (b) => b._gridlineColor$i, (b, c) => b._gridlineColor$i = c, (b, c) => b._bp(c)));
    ChangeInfo.f(a, 1, DisplayOptions._v(Boolean_$type, "PanesAreFrozen", (b) => b.panesAreFrozen, (b, c) => b.panesAreFrozen = c));
    ChangeInfo.f(a, 2, DisplayOptions._v(Nullable$1.$.specialize(Boolean_$type), "ShowExpansionIndicatorBelowGroupedRows", (b) => b._showExpansionIndicatorBelowGroupedRows$i, (b, c) => b._showExpansionIndicatorBelowGroupedRows$i = c));
    ChangeInfo.f(a, 3, DisplayOptions._v(Nullable$1.$.specialize(Boolean_$type), "ShowExpansionIndicatorToRightOfGroupedColumns", (b) => b._showExpansionIndicatorToRightOfGroupedColumns$i, (b, c) => b._showExpansionIndicatorToRightOfGroupedColumns$i = c));
    ChangeInfo.f(a, 4, DisplayOptions._v(Boolean_$type, "ShowFormulasInCells", (b) => b.showFormulasInCells, (b, c) => b.showFormulasInCells = c));
    ChangeInfo.f(a, 5, DisplayOptions._v(Boolean_$type, "ShowGridlines", (b) => b.showGridlines, (b, c) => b.showGridlines = c));
    ChangeInfo.f(a, 6, DisplayOptions._v(Boolean_$type, "ShowOutlineSymbols", (b) => b.showOutlineSymbols, (b, c) => b.showOutlineSymbols = c));
    ChangeInfo.f(a, 7, DisplayOptions._v(Boolean_$type, "ShowRowAndColumnHeaders", (b) => b.showRowAndColumnHeaders, (b, c) => b.showRowAndColumnHeaders = c));
    ChangeInfo.f(a, 8, DisplayOptions._v(Boolean_$type, "ShowRulerInPageLayoutView", (b) => b.showRulerInPageLayoutView, (b, c) => b.showRulerInPageLayoutView = c));
    ChangeInfo.f(a, 9, DisplayOptions._v(Boolean_$type, "ShowZeroValues", (b) => b.showZeroValues, (b, c) => b.showZeroValues = c));
    ChangeInfo.f(a, 10, DisplayOptions._v(WorksheetView_$type, "View", (b) => b.view, (b, c) => b.view = c, (b, c) => b._bq(c), true));
    return a;
  }
  /**
   * Gets the settings which control the frozen panes in the worksheet.
   * <p class="body">
   * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be True.
   * </p>
   * <p class="note">
   * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
   * frozen or unfrozen, these settings may not be used.
   * </p>
   * The settings which control the frozen panes in the worksheet..
   * @see [[panesAreFrozen]]
   * @see [[unfrozenPaneSettings]]
   */
  get frozenPaneSettings() {
    if (this._w == null) {
      this._w = new FrozenPaneSettings(this);
    }
    return this._w;
  }
  /**
   * Gets or sets the color of the gridlines on the worksheet.
   * <p class="body">
   * If the workbook is using a standard palette, the color set may be changed if it is not in the palette.
   * In this case, the closest color in the standard palette will be used.
   * </p>
   * The color of the gridlines on the worksheet.
   * @throws [[InvalidOperationException]] The workbook is using a custom palette and setting this color would cause the custom palette to use
   * too many colors.
   */
  get gridlineColor() {
    return this._gridlineColor$i.colorString;
  }
  /**
   * Gets or sets the color of the gridlines on the worksheet.
   * <p class="body">
   * If the workbook is using a standard palette, the color set may be changed if it is not in the palette.
   * In this case, the closest color in the standard palette will be used.
   * </p>
   * The color of the gridlines on the worksheet.
   * @throws [[InvalidOperationException]] The workbook is using a custom palette and setting this color would cause the custom palette to use
   * too many colors.
   */
  set gridlineColor(a) {
    arguments[0] = Color.create(arguments[0]);
    this._gridlineColor$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _gridlineColor$i() {
    return ExcelUtils.g1(this._ac.workbook._palette$i._ae(this._a7));
  }
  /**
   * @hidden
   */
  set _gridlineColor$i(a) {
    DisplayOptions._t[0].h(DisplayOptions.$, Color.$, this, a);
  }
  /**
   * @hidden
   */
  _bp(a) {
    if (Color.d(this._gridlineColor$i, a)) {
      if (ExcelUtils.al(a)) {
        this._a7 = 64;
        this._a1 = true;
      }
      else {
        this._a7 = this._ac.workbook._palette$i._l(WorkbookColorInfo._l_op_Implicit_WorkbookColorInfo_Color$i(a), 3);
        this._a1 = false;
      }
    }
  }
  /**
   * Gets or sets the value which indicates if the panes in the worksheet are frozen.
   * <p class="body">
   * Depending on the value of this property, either the [[frozenPaneSettings]] or the
   * [[unfrozenPaneSettings]] will be used for the worksheet. The unused settings are
   * ignored and are not saved with the workbook stream.
   * </p>
   * The value which indicates if the panes in the worksheet are frozen.
   * @see [[frozenPaneSettings]]
   * @see [[unfrozenPaneSettings]]
   */
  get panesAreFrozen() {
    return this._aj;
  }
  /**
   * Gets or sets the value which indicates if the panes in the worksheet are frozen.
   * <p class="body">
   * Depending on the value of this property, either the [[frozenPaneSettings]] or the
   * [[unfrozenPaneSettings]] will be used for the worksheet. The unused settings are
   * ignored and are not saved with the workbook stream.
   * </p>
   * The value which indicates if the panes in the worksheet are frozen.
   * @see [[frozenPaneSettings]]
   * @see [[unfrozenPaneSettings]]
   */
  set panesAreFrozen(a) {
    let b = DisplayOptions._t[1].g(DisplayOptions.$, Boolean_$type, this, this._aj, a);
    this._aj = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether the expansion indicators should be shown below grouped,
   * or indented rows.
   */
  get showExpansionIndicatorBelowGroupedRows() {
    return unwrapNullable(this._showExpansionIndicatorBelowGroupedRows$i);
  }
  /**
   * Gets or sets the value which indicates whether the expansion indicators should be shown below grouped,
   * or indented rows.
   */
  set showExpansionIndicatorBelowGroupedRows(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showExpansionIndicatorBelowGroupedRows$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showExpansionIndicatorBelowGroupedRows$i() {
    return this._bk;
  }
  /**
   * @hidden
   */
  set _showExpansionIndicatorBelowGroupedRows$i(a) {
    let b = DisplayOptions._t[2].g(DisplayOptions.$, Nullable$1.$.specialize(Boolean_$type), this, this._bk, a);
    this._bk = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether the expansion indicators should be shown to the right of
   * grouped, or indented rows.
   */
  get showExpansionIndicatorToRightOfGroupedColumns() {
    return unwrapNullable(this._showExpansionIndicatorToRightOfGroupedColumns$i);
  }
  /**
   * Gets or sets the value which indicates whether the expansion indicators should be shown to the right of
   * grouped, or indented rows.
   */
  set showExpansionIndicatorToRightOfGroupedColumns(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showExpansionIndicatorToRightOfGroupedColumns$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showExpansionIndicatorToRightOfGroupedColumns$i() {
    return this._bm;
  }
  /**
   * @hidden
   */
  set _showExpansionIndicatorToRightOfGroupedColumns$i(a) {
    let b = DisplayOptions._t[3].g(DisplayOptions.$, Nullable$1.$.specialize(Boolean_$type), this, this._bm, a);
    this._bm = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether formulas are shown in cells.
   * <p class="body">
   * If this value is True, the formula string will be displayed in the cell. If the value is
   * False, the result of the formula will be displayed in the cell.
   * </p>
   * The value which indicates whether formulas are shown in cells.
   */
  get showFormulasInCells() {
    return this._ap;
  }
  /**
   * Gets or sets the value which indicates whether formulas are shown in cells.
   * <p class="body">
   * If this value is True, the formula string will be displayed in the cell. If the value is
   * False, the result of the formula will be displayed in the cell.
   * </p>
   * The value which indicates whether formulas are shown in cells.
   */
  set showFormulasInCells(a) {
    let b = DisplayOptions._t[4].g(DisplayOptions.$, Boolean_$type, this, this._ap, a);
    this._ap = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether gridlines are shown between cells.
   * The value which indicates whether gridlines are shown between cells.
   * @see [[PrintOptions.printGridlines]]
   */
  get showGridlines() {
    return this._ar;
  }
  /**
   * Gets or sets the value which indicates whether gridlines are shown between cells.
   * The value which indicates whether gridlines are shown between cells.
   * @see [[PrintOptions.printGridlines]]
   */
  set showGridlines(a) {
    let b = DisplayOptions._t[5].g(DisplayOptions.$, Boolean_$type, this, this._ar, a);
    this._ar = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether outline symbols are shown for outlined columns and rows.
   * <p class="body">
   * If the outline symbols are displayed, they provide a visual representation of the outline levels or rows
   * and columns in Microsoft Excel.  In addition, the outline symbols include the expansion indicators which
   * allow for the expanding and collapsing of outline groups.
   * </p>
   * The value which indicates whether outline symbols are shown for outlined columns and rows.
   * @see [[RowColumnBase.outlineLevel]]
   */
  get showOutlineSymbols() {
    return this._at;
  }
  /**
   * Gets or sets the value which indicates whether outline symbols are shown for outlined columns and rows.
   * <p class="body">
   * If the outline symbols are displayed, they provide a visual representation of the outline levels or rows
   * and columns in Microsoft Excel.  In addition, the outline symbols include the expansion indicators which
   * allow for the expanding and collapsing of outline groups.
   * </p>
   * The value which indicates whether outline symbols are shown for outlined columns and rows.
   * @see [[RowColumnBase.outlineLevel]]
   */
  set showOutlineSymbols(a) {
    let b = DisplayOptions._t[6].g(DisplayOptions.$, Boolean_$type, this, this._at, a);
    this._at = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether to display row and column headers.
   * <p class="body">
   * The row and column headers show the identifier of the row or column. They also allow the user to easily select
   * all cells in a row or column by clicking them.
   * </p>
   * The value which indicates whether to display row and column headers.
   * @see [[PrintOptions.printRowAndColumnHeaders]]
   */
  get showRowAndColumnHeaders() {
    return this._av;
  }
  /**
   * Gets or sets the value which indicates whether to display row and column headers.
   * <p class="body">
   * The row and column headers show the identifier of the row or column. They also allow the user to easily select
   * all cells in a row or column by clicking them.
   * </p>
   * The value which indicates whether to display row and column headers.
   * @see [[PrintOptions.printRowAndColumnHeaders]]
   */
  set showRowAndColumnHeaders(a) {
    let b = DisplayOptions._t[7].g(DisplayOptions.$, Boolean_$type, this, this._av, a);
    this._av = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether to show rulers in the page layout view.
   * <p class="body">
   * When this value is True, one ruler will display above the column headers of the active page
   * in page layout view. Another ruler will also display before the row headers of the active page.
   * </p>
   * <p class="note">
   * <b>Note:</b> This property will only affect the worksheet view if the [[view]] is
   * PageLayout.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
   * default to Normal view.
   * </p>
   * The value which indicates whether to show rulers in the page layout view.
   * @see [[view]]
   */
  get showRulerInPageLayoutView() {
    return this._ax;
  }
  /**
   * Gets or sets the value which indicates whether to show rulers in the page layout view.
   * <p class="body">
   * When this value is True, one ruler will display above the column headers of the active page
   * in page layout view. Another ruler will also display before the row headers of the active page.
   * </p>
   * <p class="note">
   * <b>Note:</b> This property will only affect the worksheet view if the [[view]] is
   * PageLayout.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
   * default to Normal view.
   * </p>
   * The value which indicates whether to show rulers in the page layout view.
   * @see [[view]]
   */
  set showRulerInPageLayoutView(a) {
    let b = DisplayOptions._t[8].g(DisplayOptions.$, Boolean_$type, this, this._ax, a);
    this._ax = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether zero values are shown in cells.
   * <p class="body">
   * If this value is True, cells with a value of zero will display their values; otherwise,
   * those cells will display as blanks.
   * </p>
   * The value which indicates whether zero values are shown in cells.
   */
  get showZeroValues() {
    return this._az;
  }
  /**
   * Gets or sets the value which indicates whether zero values are shown in cells.
   * <p class="body">
   * If this value is True, cells with a value of zero will display their values; otherwise,
   * those cells will display as blanks.
   * </p>
   * The value which indicates whether zero values are shown in cells.
   */
  set showZeroValues(a) {
    let b = DisplayOptions._t[9].g(DisplayOptions.$, Boolean_$type, this, this._az, a);
    this._az = b.p1;
  }
  /**
   * Gets the settings which control the unfrozen panes in the worksheet.
   * <p class="body">
   * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be False.
   * </p>
   * <p class="note">
   * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
   * frozen or unfrozen, these settings may not be used.
   * </p>
   * The settings which control the unfrozen panes in the worksheet.
   * @see [[panesAreFrozen]]
   * @see [[frozenPaneSettings]]
   */
  get unfrozenPaneSettings() {
    if (this._aa == null) {
      this._aa = new UnfrozenPaneSettings(this);
    }
    return this._aa;
  }
  /**
   * Gets or sets the current view of the worksheet.
   * <p class="body">
   * The view determines the overall display of the worksheet in Microsoft Excel.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
   * default to Normal view.
   * </p>
   * The current view of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the WorksheetView enumeration.
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   */
  get view() {
    return this._ag;
  }
  /**
   * Gets or sets the current view of the worksheet.
   * <p class="body">
   * The view determines the overall display of the worksheet in Microsoft Excel.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
   * default to Normal view.
   * </p>
   * The current view of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the WorksheetView enumeration.
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   */
  set view(a) {
    if (this._ag != a) {
      if (EnumUtil.isDefined(WorksheetView_$type, enumGetBox(WorksheetView_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, WorksheetView_$type);
      }
      DisplayOptions._t[10].h(DisplayOptions.$, WorksheetView_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  get _z() {
    return this._y;
  }
  /**
   * @hidden
   */
  set _z(a) {
    this._y = a;
  }
  /**
   * @hidden
   */
  get _a8() {
    return this._a7;
  }
  /**
   * @hidden
   */
  set _a8(a) {
    if (this._a1) {
    }
    this._a7 = a;
  }
  /**
   * @hidden
   */
  get _ai() {
    return this._ae != null;
  }
  /**
   * @hidden
   */
  get _af() {
    if (this._ae == null) {
      this._ae = new WorksheetSelection();
    }
    return this._ae;
  }
  /**
   * @hidden
   */
  get _an() {
    if (nullableNotEquals(this._bk, null)) {
      return nullableEquals(this._bk, true);
    }
    return this._ad._em;
  }
  /**
   * @hidden
   */
  get _ao() {
    if (nullableNotEquals(this._bm, null)) {
      return nullableEquals(this._bm, true);
    }
    return true;
  }
  /**
   * @hidden
   */
  get _a2() {
    return this._a1;
  }
  /**
   * @hidden
   */
  set _a2(a) {
    this._a1 = a;
  }
  /**
   * @hidden
   */
  get _ad() {
    return this._ac;
  }
  /**
   * Removes any saved selection information.
   */
  clearSelection() {
    this._y = 3;
    this._ae = null;
  }
  /**
   * @hidden
   */
  _o() {
    this._br();
    super._o();
  }
  /**
   * @hidden
   */
  _al() {
    return this._aj && this._w != null && this._w._j();
  }
  /**
   * @hidden
   */
  _am() {
    return this._aj == false && this._aa != null && this._aa._j();
  }
  /**
   * @hidden
   */
  _br() {
    let a = this.panesAreFrozen ? this.frozenPaneSettings : this.unfrozenPaneSettings;
    let b = a._h ? 2 : 1;
    let c = a._i ? 2 : 1;
    if (this.panesAreFrozen) {
      if (b == 2 && c == 2) {
        this._z = 0;
      }
      else if (c == 2) {
        this._z = 1;
      }
      else if (b == 2) {
        this._z = 2;
      }
      else {
        this._z = 3;
      }
    }
    else {
      switch (this._z) {
        case 0:
          if (b < 2 || c < 2) {
            this._z = 3;
          }
          break;
        case 1:
          if (c < 2) {
            this._z = 3;
          }
          break;
        case 2:
          if (b < 2) {
            this._z = 3;
          }
          break;
      }
    }
    if (this._ai) {
      for (let d = this._ae.b.count - 1; d >= 0; d--) {
        let e = this._ae.b.item(d).a;
        let f = false;
        switch (e) {
          case 0:
            f = b < 2 || c < 2;
            break;
          case 1:
            f = c < 2;
            break;
          case 2:
            f = b < 2;
            break;
        }
        if (f) {
          this._ae.b.removeAt(d);
        }
      }
      let g = this._af.a(this._z);
      if (g == null) {
        this._af.b.add(WorksheetPaneSelection.c(this._z));
      }
      let h = this._ac._rows$i.maxCount - 1;
      let i = this._ac._columns$i.maxCount - 1;
      for (let j of fromEnum(this._ae.b)) {
        for (let k = j.d.count - 1; k >= 0; k--) {
          let l = j.d.item(k);
          if (l._w > i || l._x > i || l._ac > h || l._ae > h) {
            l = new WorksheetRegionAddress(1, Math.min(l._ac, h), Math.min(l._ae, h), Math.min(l._w, i), Math.min(l._x, i));
            j.d.item(k, l);
          }
          if ((l._w == 0 && l._x >= i) || (l._ac == 0 && l._ae >= h)) {
          }
          else {
            let m = this._ac._hi(l);
            l = m.p0;
            j.d.item(k, l);
          }
        }
        if (j.b.m > i || j.b.o > h) {
          j.b = new WorksheetCellAddress(1, Math.min(j.b.o, h), Math.min(j.b.m, i));
        }
      }
    }
  }
}
DisplayOptions.$t = markType(DisplayOptions, 'DisplayOptions', DisplayOptionsBase.$);
/**
 * @hidden
 */
DisplayOptions._a4 = 60;
/**
 * @hidden
 */
DisplayOptions._a5 = 100;
/**
 * @hidden
 */
DisplayOptions._a3 = 100;
/**
 * @hidden
 */
DisplayOptions._a6 = 0;
/**
 * @hidden
 */
DisplayOptions._ba = 1;
/**
 * @hidden
 */
DisplayOptions._bb = 2;
/**
 * @hidden
 */
DisplayOptions._bc = 3;
/**
 * @hidden
 */
DisplayOptions._bd = 4;
/**
 * @hidden
 */
DisplayOptions._be = 5;
/**
 * @hidden
 */
DisplayOptions._bf = 6;
/**
 * @hidden
 */
DisplayOptions._bg = 7;
/**
 * @hidden
 */
DisplayOptions._bh = 8;
/**
 * @hidden
 */
DisplayOptions._bi = 9;
/**
 * @hidden
 */
DisplayOptions._bj = 10;
/**
 * @hidden
 */
DisplayOptions._a9 = 11;
/**
 * @hidden
 */
DisplayOptions._t = DisplayOptions._u();
/**
 * Class which exposes the worksheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export class CustomViewDisplayOptions extends DisplayOptions {
  constructor(a, b) {
    super(a);
    this._bx = 100;
    /**
     * @hidden
     */
    this._bw = null;
    this._bw = b;
  }
  /**
   * @hidden
   */
  _e() {
    return new CustomViewDisplayOptions(this._ad, this._bw);
  }
  /**
   * @hidden
   */
  _n(a) {
    super._n(a);
    let b = typeCast(WorksheetDisplayOptions.$, a);
    if (b != null) {
      switch (b.view) {
        case 0:
          this._bx = b.magnificationInNormalView;
          break;
        case 2:
          this._bx = b.magnificationInPageBreakView;
          break;
        case 1:
          this._bx = b.magnificationInPageLayoutView;
          break;
        default: break;
      }
      if (this._ai) {
        for (let c = this._af.b.count - 1; c >= 0; c--) {
          let d = this._af.b.item(c);
          if (d.a != this._z) {
            this._af.b.removeAt(c);
          }
        }
      }
      return;
    }
    let e = typeCast(CustomViewDisplayOptions.$, a);
    if (e != null) {
      this._bx = e._bx;
      return;
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return false;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * Resets the display options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    super.resetCore();
    this._bx = 100;
  }
  /**
   * @hidden
   */
  static _bv($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(CustomViewDisplayOptions.$, $tValue, a, 99, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _bu() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, CustomViewDisplayOptions._bv(Number_$type, "MagnificationInCurrentView", (b) => b.magnificationInCurrentView, (b, c) => b.magnificationInCurrentView = c));
    return a;
  }
  /**
   * Gets or sets the magnification level of the worksheet in the current [[DisplayOptions.view]].
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet in the current View.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   */
  get magnificationInCurrentView() {
    return this._bx;
  }
  /**
   * Gets or sets the magnification level of the worksheet in the current [[DisplayOptions.view]].
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet in the current View.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   */
  set magnificationInCurrentView(a) {
    if (this._bx != a) {
      if (a < 10 || 400 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MagnificationLevel"));
      }
      let b = CustomViewDisplayOptions._bt[0].g(CustomViewDisplayOptions.$, Number_$type, this, this._bx, a);
      this._bx = b.p1;
    }
  }
}
CustomViewDisplayOptions.$t = markType(CustomViewDisplayOptions, 'CustomViewDisplayOptions', DisplayOptions.$);
/**
 * @hidden
 */
CustomViewDisplayOptions._bz = 0;
/**
 * @hidden
 */
CustomViewDisplayOptions._b0 = 1;
/**
 * @hidden
 */
CustomViewDisplayOptions._bt = CustomViewDisplayOptions._bu();
/**
 * A collection of [[CustomView]] instances in a workbook.
 */
export class CustomViewCollection extends Base {
  constructor(a) {
    super();
    this._d = null;
    this._h = null;
    this._d = a;
    this._h = new List$1(CustomView.$, 0);
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddCustomView"));
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._h.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._h.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  insert(index, item) {
    throw new NotSupportedException(0);
  }
  item() {
    if (arguments.length === 2) {
      return this._item$e.apply(this, arguments);
    }
    else {
      return this._item1.apply(this, arguments);
    }
  }
  /**
   * @hidden
   */
  _item$e(a, b) {
    if (arguments.length === 2) {
      throw new NotSupportedException(0);
      return b;
    }
    else {
      return this._item1(a);
    }
  }
  /**
   * @hidden
   */
  indexOf(item) {
    return this._h.indexOf(item);
  }
  /**
   * @hidden
   */
  _add(a, b, c) {
    let d = new CustomView(this._d, b, c);
    d.name = a;
    this._add1(d);
    return d;
  }
  /**
   * @hidden
   */
  _add1(a) {
    this._h.add(a);
  }
  /**
   * Clears all custom views from the collection.
   */
  clear() {
    for (let a = this._h.count - 1; a >= 0; a--) {
      this.removeAt(a);
    }
  }
  /**
   * Determines whether a custom view is in this collection.
   * @param customView The custom view to locate in the collection.
   * @return True if the custom view is found; False otherwise.
   */
  contains(customView) {
    return this._h.contains(customView);
  }
  /**
   * Removes the specified custom view from the collection.
   * @param customView The custom view to remove from the collection.
   * @return True if the custom view was successfully removed; False if the custom view was not
   * in the collection.
   */
  remove_1(customView) {
    if (customView == null) {
      return false;
    }
    let a = this._h.indexOf(customView);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the custom view at the specified index from the collection.
   * @param index The zero-based index of the custom view in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    let a = this._h._inner[index];
    this._h.removeAt(index);
    a._x();
  }
  /**
   * Gets the number of custom views in the collection.
   * The number of custom views in the collection.
   */
  get count() {
    return this._h.count;
  }
  /**
   * @hidden
   */
  _item1(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._h._inner[a];
  }
  /**
   * @hidden
   */
  _item(a) {
    for (let b of fromEnum(this._h)) {
      if (Guid.l_op_Equality(b._t, a)) {
        return b;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
}
CustomViewCollection.$t = markType(CustomViewCollection, 'CustomViewCollection', Base.$, [IList$1_$type.specialize(CustomView.$)]);
/**
 * Abstract base class which exposes the various workbook window options available which can be saved with
 * both a workbook and a custom view.
 * <p class="body">
 * This class provides a way to control how a workbook is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewWindowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export class WindowOptions extends Base {
  constructor(a) {
    super();
    this._l = null;
    this._e = 0;
    this._g = 3;
    this._i = null;
    this._p = true;
    this._y = 600;
    this._l = a;
  }
  /**
   * Resets the window options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
   * </p>
   */
  reset() {
    this._e = 0;
    this._g = 3;
    this._p = true;
    this._y = 600;
    if (this._o) {
      this._i = null;
    }
    else {
      this._i = this._l._sheets$i._item(0);
    }
    WindowOptions._a[0].x(this, this, this);
  }
  /**
   * @hidden
   */
  _ab(a, b) {
    this._e = a._e;
    this._g = a._g;
    this._p = a._p;
    this._y = a._y;
    if (b && a._i != null) {
      this._i = a._i;
      this._ad();
    }
  }
  /**
   * @hidden
   */
  _ad() {
  }
  /**
   * @hidden
   */
  _ae(a, b) {
    if (this._i != a) {
      if (a == null && this._o == false) {
        throw new ArgumentNullException(2, "value", ExcelUtils.ef("LE_ArgumentNullException_SelectedWorksheet"));
      }
      if (a != null) {
        if (a.workbook != this._l) {
          throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_SelectedWorksheetFromOtherWorkbook"), "value");
        }
        let c = this._d(a);
        if (c != null && c.visibility != 0) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_HiddenWorksheetCannotBeSelected"));
        }
      }
      let d = this._i;
      let e = WindowOptions._a[3].g(WindowOptions.$, Sheet.$, this, this._i, a);
      this._i = e.p1;
      if (d != null) {
        d._ar();
      }
      if (this._i != null) {
        this._i._ar();
      }
      if (b) {
        this._ad();
      }
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(WindowOptions.$, $tValue, a, 86, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(6);
    ChangeInfo.f(a, 0, WindowOptions._c(WindowOptions.$, "Reset", (b) => b, (b, c) => {
    }));
    ChangeInfo.f(a, 1, WindowOptions._c(ObjectDisplayStyle_$type, "ObjectDisplayStyle", (b) => b.objectDisplayStyle, (b, c) => b.objectDisplayStyle = c));
    ChangeInfo.f(a, 2, WindowOptions._c(ScrollBars_$type, "ScrollBars", (b) => b.scrollBars, (b, c) => b.scrollBars = c));
    ChangeInfo.f(a, 3, WindowOptions._c(Sheet.$, "SelectedSheet", (b) => b.selectedSheet, (b, c) => b.selectedSheet = c));
    ChangeInfo.f(a, 4, WindowOptions._c(Boolean_$type, "TabBarVisible", (b) => b.tabBarVisible, (b, c) => b.tabBarVisible = c));
    ChangeInfo.f(a, 5, WindowOptions._c(Number_$type, "TabBarWidth", (b) => b.tabBarWidth, (b, c) => b.tabBarWidth = c));
    return a;
  }
  /**
   * @hidden
   */
  _af() {
    if (this._i == null) {
      return;
    }
    let a = this._d(this._i);
    if (a == null || a.visibility == 0) {
      return;
    }
    let b = this._i.sheetIndex;
    if (b < 0) {
      if (this._l._sheets$i.count == 0) {
        this._i = null;
        return;
      }
    }
    for (let c = b + 1; c < this._l._sheets$i.count; c++) {
      let d = this._l._sheets$i._item(c);
      a = this._d(d);
      if (a.visibility != 0) {
        continue;
      }
      this._i = d;
      return;
    }
    for (let e = b - 1; e >= 0; e--) {
      let f = this._l._sheets$i._item(e);
      a = this._d(f);
      if (a.visibility != 0) {
        continue;
      }
      this._i = f;
      return;
    }
  }
  /**
   * Gets or sets the way the objects and shapes are displayed in the workbook.
   * The way the objects and shapes are displayed in the workbook.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[objectDisplayStyle]] enumeration.
   * @see [[WorksheetShape]]
   * @see [[Worksheet.shapes]]
   */
  get objectDisplayStyle() {
    return this._e;
  }
  /**
   * Gets or sets the way the objects and shapes are displayed in the workbook.
   * The way the objects and shapes are displayed in the workbook.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[objectDisplayStyle]] enumeration.
   * @see [[WorksheetShape]]
   * @see [[Worksheet.shapes]]
   */
  set objectDisplayStyle(a) {
    if (this._e != a) {
      if (EnumUtil.isDefined(ObjectDisplayStyle_$type, enumGetBox(ObjectDisplayStyle_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, ObjectDisplayStyle_$type);
      }
      let b = WindowOptions._a[1].g(WindowOptions.$, ObjectDisplayStyle_$type, this, this._e, a);
      this._e = b.p1;
    }
  }
  /**
   * Gets or sets the scroll bars shown in the workbook window.
   * <p class="body">
   * The vertical scroll bar occupies the entire height of the application if it is visible.
   * </p>
   * <p class="body">
   * The horizontal scroll bar occupies the width of the application not used by the worksheet
   * tab bar, if it is visible. Otherwise, it occupies the entire width of the application.
   * </p>
   * The scroll bars shown in the workbook window.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scrollBars]] enumeration.
   * @see [[tabBarWidth]]
   * @see [[tabBarVisible]]
   */
  get scrollBars() {
    return this._g;
  }
  /**
   * Gets or sets the scroll bars shown in the workbook window.
   * <p class="body">
   * The vertical scroll bar occupies the entire height of the application if it is visible.
   * </p>
   * <p class="body">
   * The horizontal scroll bar occupies the width of the application not used by the worksheet
   * tab bar, if it is visible. Otherwise, it occupies the entire width of the application.
   * </p>
   * The scroll bars shown in the workbook window.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scrollBars]] enumeration.
   * @see [[tabBarWidth]]
   * @see [[tabBarVisible]]
   */
  set scrollBars(a) {
    if (this._g != a) {
      if (EnumUtil.isDefined(ScrollBars_$type, enumGetBox(ScrollBars_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, ScrollBars_$type);
      }
      let b = WindowOptions._a[2].g(WindowOptions.$, ScrollBars_$type, this, this._g, a);
      this._g = b.p1;
    }
  }
  /**
   * Gets or sets the selected worksheet of the workbook.
   * <p class="body">
   * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
   * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
   * when the workbook is saved, another worksheet will be selected.
   * </p>
   * The selected worksheet of the workbook.
   * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
   * [[workbook]] has at least one [[Worksheet]].
   * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
   */
  get selectedSheet() {
    this._af();
    return this._i;
  }
  /**
   * Gets or sets the selected worksheet of the workbook.
   * <p class="body">
   * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
   * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
   * when the workbook is saved, another worksheet will be selected.
   * </p>
   * The selected worksheet of the workbook.
   * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
   * [[workbook]] has at least one [[Worksheet]].
   * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
   */
  set selectedSheet(a) {
    this._ae(a, true);
  }
  /**
   * @hidden
   */
  get _k() {
    return this._i;
  }
  /**
   * Gets or sets the selected worksheet of the workbook.
   * <p class="body">
   * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
   * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
   * when the workbook is saved, another worksheet will be selected.
   * </p>
   * The selected worksheet of the workbook.
   * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
   * [[workbook]] has at least one [[Worksheet]].
   * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
   */
  get selectedWorksheet() {
    return typeCast(Worksheet.$, this.selectedSheet);
  }
  /**
   * Gets or sets the selected worksheet of the workbook.
   * <p class="body">
   * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
   * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
   * when the workbook is saved, another worksheet will be selected.
   * </p>
   * The selected worksheet of the workbook.
   * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
   * [[workbook]] has at least one [[Worksheet]].
   * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
   */
  set selectedWorksheet(a) {
    this.selectedSheet = a;
  }
  /**
   * Gets or sets the value indicating whether the worksheet tab bar is visible.
   * <p class="body">
   * If the value is False, the [[tabBarWidth]] will not be used, but it will still
   * be serialized with the workbook.
   * </p>
   * The value indicating whether the worksheet tab bar is visible.
   * @see [[tabBarWidth]]
   * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
   */
  get tabBarVisible() {
    return this._p;
  }
  /**
   * Gets or sets the value indicating whether the worksheet tab bar is visible.
   * <p class="body">
   * If the value is False, the [[tabBarWidth]] will not be used, but it will still
   * be serialized with the workbook.
   * </p>
   * The value indicating whether the worksheet tab bar is visible.
   * @see [[tabBarWidth]]
   * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
   */
  set tabBarVisible(a) {
    if (a != this._p) {
      let b = WindowOptions._a[4].g(WindowOptions.$, Boolean_$type, this, this._p, a);
      this._p = b.p1;
    }
  }
  /**
   * Gets or sets the width of the worksheet tab bar, expressed in 1/1000ths of the application width.
   * <p class="body">
   * This value is only used if [[tabBarVisible]] is True. Regardless of whether the tab bar is
   * visible, the width value is always saved with the workbook.
   * </p>
   * <p class="body">
   * A value of 1000 indicates the worksheet tab bar occupies the entire width of the application, while
   * a value of 0 indicates the worksheet tab bar has no width.
   * </p>
   * <p class="body">
   * All space not occupied by the worksheet tab bar will be used by the horizontal scroll bar, if it is visible.
   * </p>
   * The width of the worksheet tab bar, expressed in 1/1000ths of the application width.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 1000.
   * @see [[tabBarVisible]]
   * @see [[scrollBars]]
   * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
   */
  get tabBarWidth() {
    return this._y;
  }
  /**
   * Gets or sets the width of the worksheet tab bar, expressed in 1/1000ths of the application width.
   * <p class="body">
   * This value is only used if [[tabBarVisible]] is True. Regardless of whether the tab bar is
   * visible, the width value is always saved with the workbook.
   * </p>
   * <p class="body">
   * A value of 1000 indicates the worksheet tab bar occupies the entire width of the application, while
   * a value of 0 indicates the worksheet tab bar has no width.
   * </p>
   * <p class="body">
   * All space not occupied by the worksheet tab bar will be used by the horizontal scroll bar, if it is visible.
   * </p>
   * The width of the worksheet tab bar, expressed in 1/1000ths of the application width.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 1000.
   * @see [[tabBarVisible]]
   * @see [[scrollBars]]
   * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
   */
  set tabBarWidth(a) {
    if (this._y != a) {
      if (this._y < 0 || 1000 < this._y) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_TabBarWidth"));
      }
      let b = WindowOptions._a[5].g(WindowOptions.$, Number_$type, this, this._y, a);
      this._y = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _workbook() {
    return this._l;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
WindowOptions.$t = markType(WindowOptions, 'WindowOptions', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
WindowOptions._r = 600;
/**
 * @hidden
 */
WindowOptions._u = 0;
/**
 * @hidden
 */
WindowOptions._t = 1;
/**
 * @hidden
 */
WindowOptions._v = 2;
/**
 * @hidden
 */
WindowOptions._w = 3;
/**
 * @hidden
 */
WindowOptions._x = 4;
/**
 * @hidden
 */
WindowOptions._aa = 5;
/**
 * @hidden
 */
WindowOptions._s = 6;
/**
 * @hidden
 */
WindowOptions._a = WindowOptions._b();
/**
 * Represents the workbook window options which are saved with custom views.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a custom view, but
 * not with a workbook. Therefore, these properties will not be applied when the
 * [[CustomView.apply]] method is called.
 * </p>
 * @see [[CustomView.windowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export class CustomViewWindowOptions extends WindowOptions {
  constructor(a) {
    super(a._j);
    this._ag = null;
    this._ap = CustomViewWindowOptions._ar;
    this._ah = true;
    this._aj = true;
    this._al = true;
    this._an = 0;
    this._ag = a;
  }
  /**
   * @hidden
   */
  get__o() {
    return true;
  }
  /**
   * @hidden
   */
  get _o() {
    return this.get__o();
  }
  /**
   * @hidden
   */
  _d(a) {
    return this._ag.getSheetDisplayOptions(a, false);
  }
  /**
   * Resets the window options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
   * </p>
   */
  reset() {
    this._ap = new Rect(0, 10, 50, 600, 400);
    this._ah = true;
    this._aj = true;
    this._al = true;
    super.reset();
  }
  /**
   * Gets or sets the pixel bounds of the workbook's MDI child window when [[CustomView]]
   * owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This property will have no affect on the workbook if [[maximized]] is True. However, in this case,
   * the value of this property will still be saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The pixel bounds of the workbook's MDI child window when CustomView owning these
   * window options is applied.
   * @throws [[ArgumentException]] The left or top of the value assigned is outside the bounds of -32768 and 32767.
   * @throws [[ArgumentException]] The width or height of the value assigned is outside the bounds of 0 and 65535.
   * @see [[CustomView.apply]]
   */
  get boundsInPixels() {
    return rectToLiteral(this._boundsInPixels$i);
  }
  /**
   * Gets or sets the pixel bounds of the workbook's MDI child window when [[CustomView]]
   * owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This property will have no affect on the workbook if [[maximized]] is True. However, in this case,
   * the value of this property will still be saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The pixel bounds of the workbook's MDI child window when CustomView owning these
   * window options is applied.
   * @throws [[ArgumentException]] The left or top of the value assigned is outside the bounds of -32768 and 32767.
   * @throws [[ArgumentException]] The width or height of the value assigned is outside the bounds of 0 and 65535.
   * @see [[CustomView.apply]]
   */
  set boundsInPixels(a) {
    arguments[0] = rectFromLiteral(arguments[0]);
    this._boundsInPixels$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _boundsInPixels$i() {
    return this._ap;
  }
  /**
   * @hidden
   */
  set _boundsInPixels$i(a) {
    if (Rect.l_op_Inequality(this._ap, a)) {
      if (a.left < -32768 || 32767 < a.left || a.top < -32768 || 32767 < a.top) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_TopLeftWindowBounds"), "value");
      }
      if (a.width < 0 || 65535 < a.width || a.height < 0 || 65535 < a.height) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_WidthHeightWindowBounds"), "value");
      }
      this._ap = a;
    }
  }
  /**
   * Gets or sets the value indicating whether the workbook's MDI child window will be maximized
   * when the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether the workbook's MDI child window will be maximized when the CustomView owning these
   * window options is applied.
   * @see [[CustomView.apply]]
   * @see [[WorkbookWindowOptions.minimized]]
   */
  get maximized() {
    return this._ah;
  }
  /**
   * Gets or sets the value indicating whether the workbook's MDI child window will be maximized
   * when the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether the workbook's MDI child window will be maximized when the CustomView owning these
   * window options is applied.
   * @see [[CustomView.apply]]
   * @see [[WorkbookWindowOptions.minimized]]
   */
  set maximized(a) {
    if (a != this._ah) {
      this._ah = a;
    }
  }
  /**
   * Gets or sets the value indicating whether Microsoft Excel will display the formula bar when
   * the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling [[CustomView.apply]] on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether Microsoft Excel will display the formula bar when the CustomView owning these window
   * options is applied.
   * @see [[CustomView.apply]]
   */
  get showFormulaBar() {
    return this._aj;
  }
  /**
   * Gets or sets the value indicating whether Microsoft Excel will display the formula bar when
   * the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling [[CustomView.apply]] on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether Microsoft Excel will display the formula bar when the CustomView owning these window
   * options is applied.
   * @see [[CustomView.apply]]
   */
  set showFormulaBar(a) {
    if (a != this._aj) {
      this._aj = a;
    }
  }
  /**
   * Gets or sets the value indicating whether Microsoft Excel will display the status bar when
   * the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether Microsoft Excel will display the status bar when the CustomView owning these window
   * options is applied.
   * @see [[CustomView.apply]]
   */
  get showStatusBar() {
    return this._al;
  }
  /**
   * Gets or sets the value indicating whether Microsoft Excel will display the status bar when
   * the [[CustomView]] owning these window options is applied.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
   * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
   * calling  on the associated CustomView will not apply this property. Only by
   * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
   * </p>
   * The value indicating whether Microsoft Excel will display the status bar when the CustomView owning these window
   * options is applied.
   * @see [[CustomView.apply]]
   */
  set showStatusBar(a) {
    if (a != this._al) {
      this._al = a;
    }
  }
  /**
   * @hidden
   */
  get _ao() {
    return this._an;
  }
  /**
   * @hidden
   */
  set _ao(a) {
    this._an = a;
  }
}
CustomViewWindowOptions.$t = markType(CustomViewWindowOptions, 'CustomViewWindowOptions', WindowOptions.$);
/**
 * @hidden
 */
CustomViewWindowOptions._ar = new Rect(0, 10, 50, 600, 400);
/**
 * Base class for all data validations rules which can be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[AnyValueDataValidationRule]]
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export class DataValidationRule extends Base {
  constructor() {
    super();
    this._ag = null;
    this._ai = null;
    this._d = 0;
    this._ak = null;
    this._am = null;
    this._g = null;
    this._t = false;
    this._v = false;
    this._d = 0;
    this._t = true;
    this._v = true;
  }
  /**
   * Creates a copy of this rule which can be applied to other worksheets.
   */
  clone() {
    let a = this.memberwiseClone();
    a._g = null;
    let b = a._l(null);
    if (b != null) {
      a._aq(b._g(), null);
    }
    let c = a._m(null);
    if (c != null) {
      a._ar(c._g(), null);
    }
    return a;
  }
  /**
   * @hidden
   */
  static _q(a, b) {
    return a == null ? b == null : a._ao(b);
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    return (a != null ? a : stringEmpty()) == (b != null ? b : stringEmpty());
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    return other != null && DataValidationRule._r(other._ag, this._ag) && DataValidationRule._r(other._ai, this._ai) && other._d == this._d && DataValidationRule._r(other._ak, this._ak) && DataValidationRule._r(other._am, this._am) && other._t == this._t && other._v == this._v;
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    this._g = a;
  }
  /**
   * @hidden
   */
  _ap() {
    this._g = null;
  }
  /**
   * @hidden
   */
  _as(a, b, c) {
    if (stringIsNullOrEmpty(a) == false && c < a.length) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_InvalidMessageLength", b, c));
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2(DataValidationRule.$, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(7);
    ChangeInfo.f(a, 0, DataValidationRule._c(String_$type, "ErrorMessageDescription", (b) => b.errorMessageDescription, (b, c) => b.errorMessageDescription = c));
    ChangeInfo.f(a, 1, DataValidationRule._c(String_$type, "ErrorMessageTitle", (b) => b.errorMessageTitle, (b, c) => b.errorMessageTitle = c));
    ChangeInfo.f(a, 2, DataValidationRule._c(DataValidationErrorStyle_$type, "ErrorStyle", (b) => b.errorStyle, (b, c) => b.errorStyle = c));
    ChangeInfo.f(a, 3, DataValidationRule._c(String_$type, "InputMessageDescription", (b) => b.inputMessageDescription, (b, c) => b.inputMessageDescription = c));
    ChangeInfo.f(a, 4, DataValidationRule._c(String_$type, "InputMessageTitle", (b) => b.inputMessageTitle, (b, c) => b.inputMessageTitle = c));
    ChangeInfo.f(a, 5, DataValidationRule._c(Boolean_$type, "ShowErrorMessageForInvalidValue", (b) => b.showErrorMessageForInvalidValue, (b, c) => b.showErrorMessageForInvalidValue = c));
    ChangeInfo.f(a, 6, DataValidationRule._c(Boolean_$type, "ShowInputMessage", (b) => b.showInputMessage, (b, c) => b.showInputMessage = c));
    return a;
  }
  /**
   * Gets or sets the description which appears in the dialog box when an invalid value is applied to a cell
   * in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 225 characters.
   * </p>
   * The description to show the user or null to use a default error description.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 225 characters.
   * @see [[errorMessageTitle]]
   */
  get errorMessageDescription() {
    return this._ag;
  }
  /**
   * Gets or sets the description which appears in the dialog box when an invalid value is applied to a cell
   * in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 225 characters.
   * </p>
   * The description to show the user or null to use a default error description.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 225 characters.
   * @see [[errorMessageTitle]]
   */
  set errorMessageDescription(a) {
    if (this._ag == a) {
      return;
    }
    this._as(a, "ErrorMessageDescription", 225);
    let b = DataValidationRule._a[0].g(DataValidationRule.$, String_$type, this, this._ag, a);
    this._ag = b.p1;
  }
  /**
   * Gets or sets the title which appears in the dialog box when an invalid value is applied to a cell
   * in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 32 characters.
   * </p>
   * The title to show the user or null to use a default error dialog title.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
   * @see [[errorMessageDescription]]
   */
  get errorMessageTitle() {
    return this._ai;
  }
  /**
   * Gets or sets the title which appears in the dialog box when an invalid value is applied to a cell
   * in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 32 characters.
   * </p>
   * The title to show the user or null to use a default error dialog title.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
   * @see [[errorMessageDescription]]
   */
  set errorMessageTitle(a) {
    if (this._ai == a) {
      return;
    }
    this._as(a, "ErrorMessageTitle", 32);
    let b = DataValidationRule._a[1].g(DataValidationRule.$, String_$type, this, this._ai, a);
    this._ai = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether the value is allowed when it is invalid and which options are given to
   * the user in the error dialog shown by Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationErrorStyle]] enumeration.
   * @see [[showErrorMessageForInvalidValue]]
   */
  get errorStyle() {
    return this._d;
  }
  /**
   * Gets or sets the value which indicates whether the value is allowed when it is invalid and which options are given to
   * the user in the error dialog shown by Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showErrorMessageForInvalidValue]] is True.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationErrorStyle]] enumeration.
   * @see [[showErrorMessageForInvalidValue]]
   */
  set errorStyle(a) {
    if (this._d == a) {
      return;
    }
    if (EnumUtil.isDefined(DataValidationErrorStyle_$type, enumGetBox(DataValidationErrorStyle_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, DataValidationErrorStyle_$type);
    }
    let b = DataValidationRule._a[2].g(DataValidationRule.$, DataValidationErrorStyle_$type, this, this._d, a);
    this._d = b.p1;
  }
  /**
   * Gets or sets the description in the tooltip which appears when the user selects the cell in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showInputMessage]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the description cannot be more than 255 characters.
   * </p>
   * The description to show the user in the tooltip.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 255 characters.
   * @see [[inputMessageTitle]]
   */
  get inputMessageDescription() {
    return this._ak;
  }
  /**
   * Gets or sets the description in the tooltip which appears when the user selects the cell in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showInputMessage]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the description cannot be more than 255 characters.
   * </p>
   * The description to show the user in the tooltip.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 255 characters.
   * @see [[inputMessageTitle]]
   */
  set inputMessageDescription(a) {
    if (this._ak == a) {
      return;
    }
    this._as(a, "InputMessageDescription", 255);
    let b = DataValidationRule._a[3].g(DataValidationRule.$, String_$type, this, this._ak, a);
    this._ak = b.p1;
  }
  /**
   * Gets or sets the title in the tooltip which appears when the user selects the cell in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showInputMessage]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 32 characters.
   * </p>
   * The title to show the user in the tooltip.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
   * @see [[inputMessageDescription]]
   */
  get inputMessageTitle() {
    return this._am;
  }
  /**
   * Gets or sets the title in the tooltip which appears when the user selects the cell in Microsoft Excel.
   * <p class="body">
   * This value is only used when [[showInputMessage]] is True.
   * </p>
   * <p class="note">
   * <b>Note:</b> the title cannot be more than 32 characters.
   * </p>
   * The title to show the user in the tooltip.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
   * @see [[inputMessageDescription]]
   */
  set inputMessageTitle(a) {
    if (this._am == a) {
      return;
    }
    this._as(a, "InputMessageTitle", 32);
    let b = DataValidationRule._a[4].g(DataValidationRule.$, String_$type, this, this._am, a);
    this._am = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether the error dialog should appear in Microsoft Excel when invalid data
   * is entered in the cell.
   * <p class="body">
   * When the value is False, invalid data can be entered into cells, but when the user chooses to subsequently circle
   * invalid values in Microsoft Excel, the cell will be circled.
   * </p>
   * True to show the error dialog for invalid cell data; False otherwise.
   * @see [[errorMessageDescription]]
   * @see [[errorMessageTitle]]
   * @see [[errorStyle]]
   */
  get showErrorMessageForInvalidValue() {
    return this._t;
  }
  /**
   * Gets or sets the value which indicates whether the error dialog should appear in Microsoft Excel when invalid data
   * is entered in the cell.
   * <p class="body">
   * When the value is False, invalid data can be entered into cells, but when the user chooses to subsequently circle
   * invalid values in Microsoft Excel, the cell will be circled.
   * </p>
   * True to show the error dialog for invalid cell data; False otherwise.
   * @see [[errorMessageDescription]]
   * @see [[errorMessageTitle]]
   * @see [[errorStyle]]
   */
  set showErrorMessageForInvalidValue(a) {
    if (this._t != a) {
      let b = DataValidationRule._a[5].g(DataValidationRule.$, Boolean_$type, this, this._t, a);
      this._t = b.p1;
    }
  }
  /**
   * Gets or sets the value which indicates whether to show the user an input prompt tooltip when the user selects
   * the cell in Microsoft Excel.
   * <p class="body">
   * The input prompt will only be shown if this value is True and the [[inputMessageDescription]] is not null.
   * </p>
   * @see [[inputMessageDescription]]
   * @see [[inputMessageTitle]]
   */
  get showInputMessage() {
    return this._v;
  }
  /**
   * Gets or sets the value which indicates whether to show the user an input prompt tooltip when the user selects
   * the cell in Microsoft Excel.
   * <p class="body">
   * The input prompt will only be shown if this value is True and the [[inputMessageDescription]] is not null.
   * </p>
   * @see [[inputMessageDescription]]
   * @see [[inputMessageTitle]]
   */
  set showInputMessage(a) {
    if (this._v != a) {
      let b = DataValidationRule._a[6].g(DataValidationRule.$, Boolean_$type, this, this._v, a);
      this._v = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__i() {
    return 6;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * @hidden
   */
  get _h() {
    return this._g;
  }
  /**
   * @hidden
   */
  get _workbook() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
  /**
   * @hidden
   */
  get _o() {
    if (this._g == null) {
      return null;
    }
    return this._g._g;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._o;
  }
  /**
   * @hidden
   */
  get source() {
    return this._o;
  }
}
DataValidationRule.$t = markType(DataValidationRule, 'DataValidationRule', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
DataValidationRule._y = 0;
/**
 * @hidden
 */
DataValidationRule._z = 1;
/**
 * @hidden
 */
DataValidationRule._aa = 2;
/**
 * @hidden
 */
DataValidationRule._ab = 3;
/**
 * @hidden
 */
DataValidationRule._ac = 4;
/**
 * @hidden
 */
DataValidationRule._ae = 5;
/**
 * @hidden
 */
DataValidationRule._af = 6;
/**
 * @hidden
 */
DataValidationRule._ad = 7;
/**
 * @hidden
 */
DataValidationRule._a = DataValidationRule._b();
/**
 * Represents a data validation rule which allows any value to be set on the target cells.
 * This would be used to provide an input message to the user when the cell was selected.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export class AnyValueDataValidationRule extends DataValidationRule {
  constructor() {
    super();
  }
  /**
   * @hidden
   */
  get__p() {
    return true;
  }
  /**
   * @hidden
   */
  set__p(a) {
  }
  /**
   * @hidden
   */
  get _p() {
    return this.get__p();
  }
  /**
   * @hidden
   */
  set _p(a) {
    this.set__p(a);
  }
  /**
   * @hidden
   */
  _l(a) {
    return null;
  }
  /**
   * @hidden
   */
  _m(a) {
    return null;
  }
  /**
   * @hidden
   */
  get__j() {
    return 0;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _aq(a, b) {
  }
  /**
   * @hidden
   */
  _ar(a, b) {
  }
  /**
   * @hidden
   */
  _x(a) {
    return true;
  }
  /**
   * @hidden
   */
  get__k() {
    return 0;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  _at(a, b) {
  }
}
AnyValueDataValidationRule.$t = markType(AnyValueDataValidationRule, 'AnyValueDataValidationRule', DataValidationRule.$);
/**
 * Base class for all data validations rules which prevent certain values form being applied to a cell.
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export class LimitedValueDataValidationRule extends DataValidationRule {
  constructor() {
    super();
    this._a3 = false;
    this._a3 = true;
  }
  /**
   * @hidden
   */
  get__p() {
    return this.allowNull;
  }
  /**
   * @hidden
   */
  set__p(a) {
    this.allowNull = a;
  }
  /**
   * @hidden
   */
  get _p() {
    return this.get__p();
  }
  /**
   * @hidden
   */
  set _p(a) {
    this.set__p(a);
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(LimitedValueDataValidationRule.$, other);
    return a != null && a._a3 == this._a3 && super.isEquivalentTo(other);
  }
  /**
   * @hidden
   */
  _x(a) {
    let b = this._o._rows$i._aj(a.o);
    let c = b == null ? null : b._getCellValue1(a.m);
    if (c == null) {
      return this.allowNull;
    }
    try {
      return this._a8(a, c);
    }
    catch (d) {
      return false;
    }
  }
  /**
   * @hidden
   */
  _aw(a, b, c = true) {
    if (a == null) {
      return null;
    }
    let d = this._o;
    if (d == null) {
      return null;
    }
    let e = d.workbook;
    if (e == null) {
      return null;
    }
    let f = this._a0(a, b, e.currentFormat, e.cellReferenceMode, e._culture$i, true);
    let g = new DataValidationCalcReference(d._rows$i.item(b.o), b.m, c);
    g._a0(f, false);
    e._hj(null);
    return f.evaluateCore(e);
  }
  /**
   * @hidden
   */
  _bd(a, b) {
    if (a == null) {
      return {
        p0: a
      };
    }
    if (a._as == false && b._t.count != 0) {
      let c = b._t._inner[0];
      a = a._x(c._ac, c._w, b.worksheet._o);
    }
    let d = new FormulaContext(4, this._o, -1, -1, b.worksheet._o, a, null, 1);
    a._b5(d);
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _a6(a, b, c, d, e) {
    if (d == false && b) {
      let f = a.h == 64 || a.h == 96;
      if (f == false) {
        return false;
      }
    }
    switch (a.f) {
      case 1:
      case 2:
      case 15:
      case 16:
      case 96:
      case 32:
      case 64:
      case 102:
      case 38:
      case 70:
      case 104:
      case 40:
      case 72: return false;
      case 122:
      case 58:
      case 90:
      case 124:
      case 60:
      case 92: return ExcelUtils.au(e) == false;
      case 121:
      case 57:
      case 89: return ExcelUtils.au(e) == false || LimitedValueDataValidationRule._a5(a);
      case 123:
      case 59:
      case 91:
      case 125:
      case 61:
      case 93: return d;
      case 101:
      case 37:
      case 69:
      case 107:
      case 43:
      case 75:
      case 109:
      case 45:
      case 77:
        if (d) {
          return true;
        }
        return c == false;
      case 24: return true;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  static _a7(a, b, c, d) {
    if (d) {
      if (b) {
        let e = a.h == 64 || a.h == 96;
        if (e == false) {
          return false;
        }
      }
      switch (a.f) {
        case 123:
        case 59:
        case 91:
        case 125:
        case 61:
        case 93: return false;
        case 101:
        case 37:
        case 69:
        case 107:
        case 43:
        case 75:
        case 109:
        case 45:
        case 77: return c == false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _bc(a, b) {
    let c = this._workbook;
    if (c != null && false == c._c4 && c._cx) {
      return Nullable$1.toNullable(LimitedValueDataValidationRule_FormulaChangeContext.$, new LimitedValueDataValidationRule_FormulaChangeContext(1, this, a(), b));
    }
    return Nullable$1.toNullable(LimitedValueDataValidationRule_FormulaChangeContext.$, null);
  }
  /**
   * @hidden
   */
  _be(a, b, c) {
    a.e(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, b, b.c, c);
  }
  /**
   * @hidden
   */
  _az(a, b, c, d) {
    if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, b)) == false) {
      throw new InvalidEnumArgumentException("format", c, WorkbookFormat_$type);
    }
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, c)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", c, CellReferenceMode_$type);
    }
    if (stringIsNullOrEmpty(a)) {
      return null;
    }
    let e;
    let f;
    if (((() => { let g = Formula._a0(a, c, this._i, b, d, null, e, f); e = g.p6; f = g.p7; return g.ret; })()) == false) {
      throw new ArgumentException(3, ExcelUtils.ef("LE_ArgumentException_InvalidFormula"), f);
    }
    return e;
  }
  /**
   * @hidden
   */
  _a1(a, b, c, d, e, f) {
    if (EnumUtil.isDefined(WorkbookFormat_$type, enumGetBox(WorkbookFormat_$type, c)) == false) {
      throw new InvalidEnumArgumentException("format", c, WorkbookFormat_$type);
    }
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, d)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", d, CellReferenceMode_$type);
    }
    if (a == null || b == null) {
      return a;
    }
    let g;
    let h;
    let i;
    let j;
    let k = ExcelUtils.fv(b, c, d, e, null, -1, g, h, i, j);
    g = k.p6;
    h = k.p7;
    i = k.p8;
    j = k.p9;
    if (g < 0 || h < 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_InvalidAddress"), "address");
    }
    return this._a0(a, new WorksheetCellAddress(1, g, h), c, d, e, f);
  }
  /**
   * @hidden
   */
  _a0(a, b, c, d, e, f) {
    if (e == null) {
      e = a._ba;
    }
    let g = a._v(b.o, b.m, c, (f == false));
    if (f == false && this._o != null) {
      let h = new FormulaContext(4, this._o, b.o, b.m, c, g, null, 1);
      g._b5(h);
    }
    return g;
  }
  /**
   * @hidden
   */
  _bf(a, b, c, d, e, f, g) {
    if (a == null) {
      if (b != null) {
        throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_FormulaCannotBeNull", d));
      }
      return;
    }
    let h = null;
    if (b != null) {
      h = b._g.workbook;
      g = b._g._o;
    }
    if (e) {
      let i = a._e.length - 1;
      let j = i == 0;
      for (let k = 0; k < a._e.length; k++) {
        if (this._a6(a._e[k], k == i, j, f, g) == false) {
          throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_DV_InvalidFormula"));
        }
      }
    }
    let l = null;
    let m = null;
    if (b != null) {
      m = b._g;
      l = m.workbook;
      if (a._z != b._g._o) {
        let n = b._g._c;
        if (c == null) {
          c = b.item(this);
        }
        if (c != null) {
          let o;
          let p;
          let q = c._al(o, p);
          o = q.p0;
          p = q.p1;
          if (WorksheetCell.l_op_Inequality(o, null)) {
            let r = a._ba;
            let s = this._a1(a, o._toString2(n, false, false, false), a._z, n, r, true);
            LimitedValueDataValidationRule._bg(h, s, d, g, n);
            if (WorksheetCell.l_op_Inequality(o, p)) {
              let t = this._a1(a, p._toString2(n, false, false, false), a._z, n, r, true);
              LimitedValueDataValidationRule._bg(h, t, d, g, n);
            }
          }
        }
        else {
          LimitedValueDataValidationRule._bg(h, a, d, g, n);
        }
      }
    }
    for (let u = 0; u < a._e.length; u++) {
      let v = typeCast(ReferenceToken.$, a._e[u]);
      if (v == null) {
        continue;
      }
      if (LimitedValueDataValidationRule._a5(v)) {
        continue;
      }
      if (v.r && ExcelUtils.au(g)) {
        throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_FormulaCannotReferenceOtherWorkbook", d));
      }
      if (l == null || l._c4) {
        continue;
      }
      let w = m;
      let x = typeCast(WorksheetReferenceLocal.$, v.o);
      if (x != null) {
        w = x.u;
      }
      let y = typeCast(NameToken.$, v);
      if (y == null) {
        continue;
      }
      let z = l._namedReferences$i._find1(y.w, w);
      if (z == null) {
        if (y.v == null || y.v == l) {
          z = l._a3(y.w);
        }
      }
      if (z == null) {
        throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_FormulaCannotFindNamedReference", d));
      }
      this._bf(z._j, b, c, d, false, f, g);
    }
  }
  /**
   * @hidden
   */
  static _bg(a, b, c, d, e) {
    let f = a._an();
    b._ca(a, f, d, e, true);
    if (f.d) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_FormulaInvalidForWorkbookFormat", c, enumGetBox(WorkbookFormat_$type, d)));
    }
  }
  /**
   * @hidden
   */
  static _ay($tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2(LimitedValueDataValidationRule.$, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _av() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, LimitedValueDataValidationRule._ay(Boolean_$type, "AllowNull", (b) => b.allowNull, (b, c) => b.allowNull = c));
    return a;
  }
  /**
   * @hidden
   */
  static _a5(a) {
    if (a.f != 57) {
      return false;
    }
    let b = a;
    if (b.u._g != 1) {
      return false;
    }
    let c = Function._gv(b.w);
    return c != null && c._qm;
  }
  /**
   * Gets or sets the value which indicates whether a null, or blank, value is allowed to be set on a cell.
   * True if a null value can be set on the cell; False otherwise.
   */
  get allowNull() {
    return this._a3;
  }
  /**
   * Gets or sets the value which indicates whether a null, or blank, value is allowed to be set on a cell.
   * True if a null value can be set on the cell; False otherwise.
   */
  set allowNull(a) {
    if (this._a3 != a) {
      let b = LimitedValueDataValidationRule._au[0].g(LimitedValueDataValidationRule.$, Boolean_$type, this, this._a3, a);
      this._a3 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _ax() {
    if (this._h == null) {
      return 1;
    }
    return this._h._g._c;
  }
  /**
   * @hidden
   */
  get _a9() {
    if (this._h == null) {
      return ExcelUtils.cq;
    }
    return this._h._g._y;
  }
  /**
   * @hidden
   */
  get _a2() {
    if (this._h == null) {
      return 2;
    }
    return this._h._g._o;
  }
}
LimitedValueDataValidationRule.$t = markType(LimitedValueDataValidationRule, 'LimitedValueDataValidationRule', DataValidationRule.$);
/**
 * @hidden
 */
LimitedValueDataValidationRule._ba = 0;
/**
 * @hidden
 */
LimitedValueDataValidationRule._bb = 1;
/**
 * @hidden
 */
LimitedValueDataValidationRule._au = LimitedValueDataValidationRule._av();
/**
 * @hidden
 */
export class LimitedValueDataValidationRule_FormulaChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.c = d;
          this.b = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._workbook;
  }
  get sheet() {
    return this.a._o;
  }
  get source() {
    return this.a._o;
  }
}
LimitedValueDataValidationRule_FormulaChangeContext.$t = markStruct(LimitedValueDataValidationRule_FormulaChangeContext, 'LimitedValueDataValidationRule_FormulaChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a data validation rule which allows any formula to be used to validate the value applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export class CustomDataValidationRule extends LimitedValueDataValidationRule {
  constructor() {
    super();
    this._bk = null;
  }
  /**
   * @hidden
   */
  _l(a) {
    return this._bl(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _m(a) {
    return null;
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(CustomDataValidationRule.$, other);
    return a != null && super.isEquivalentTo(other) && DataValidationRule._q(a._bk, this._bk);
  }
  /**
   * @hidden
   */
  _a6(a, b, c, d, e) {
    if (super._a6(a, b, c, d, e) == false) {
      return false;
    }
    return LimitedValueDataValidationRule._a7(a, b, c, d);
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    super._ao(a, b);
    let c = this._bd(this._bk, b);
    this._bk = c.p0;
  }
  /**
   * @hidden
   */
  _ap() {
    if (this._bk != null) {
      this._bk._bu();
    }
    super._ap();
  }
  /**
   * @hidden
   */
  get__j() {
    return 0;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    this._bs(a, b, this._a2, this._ax, this._a9, true);
  }
  /**
   * @hidden
   */
  _ar(a, b) {
  }
  /**
   * @hidden
   */
  _a8(a, b) {
    let c = this._aw(this._bk, a);
    return c != null && c._toBoolean(this._a9);
  }
  /**
   * @hidden
   */
  get__k() {
    return 7;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  _at(a, b) {
    this._bf(this._bk, a, b, "formula", true, true, this._a2);
  }
  getFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getFormula.apply(this, arguments);
      case 1:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return this._getFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getFormula(a) {
    return this._getFormula1(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _getFormula1(a, b, c, d) {
    let e = this._bl(a, b, c, d);
    if (e == null) {
      return null;
    }
    return e._toString2(c, d);
  }
  setFormula() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setFormula.apply(this, arguments);
      case 1:
        arguments[4] = typeof arguments[4] === 'string' ? new CultureInfo(arguments[4]) : arguments[4];
        return this._setFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setFormula(a, b) {
    this._setFormula1(a, b, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _setFormula1(a, b, c, d, e) {
    let f = this._az(a, c, d, e);
    this._bs(f, b, c, d, e);
  }
  /**
   * @hidden
   */
  _bl(a, b, c, d) {
    return this._a1(this._bk, a, b, c, d, true);
  }
  /**
   * @hidden
   */
  _bs(a, b, c, d, e, f = false) {
    if (!f) {
      this._bf(a, this._h, null, "formula", true, true, c);
    }
    let g = this._bc(() => this._getFormula1("A1", c, 1, CultureInfo.invariantCulture), c);
    this._bk = this._a1(a, b, c, d, e, false);
    if (nullableNotEquals(g, null)) {
      this._be(CustomDataValidationRule._bh[0], g.value, this._getFormula1("A1", c, 1, CultureInfo.invariantCulture));
    }
  }
  /**
   * @hidden
   */
  static _bj($tContext, $tValue, a, b, c, d = null, e = true, f = false, g = 2048) {
    return new ChangeInfo$2($tContext, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bi() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, CustomDataValidationRule._bj(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, "Formula", (b) => b.c, (b, c) => (b.a)._setFormula1(c, "A1", b.b, 1, CultureInfo.invariantCulture)));
    return a;
  }
}
CustomDataValidationRule.$t = markType(CustomDataValidationRule, 'CustomDataValidationRule', LimitedValueDataValidationRule.$);
/**
 * @hidden
 */
CustomDataValidationRule._bm = 0;
/**
 * @hidden
 */
CustomDataValidationRule._bn = 1;
/**
 * @hidden
 */
CustomDataValidationRule._bh = CustomDataValidationRule._bi();
/**
 * Represents an error value in Microsoft Excel.
 */
export class ErrorValue extends Base {
  constructor(a) {
    super();
    this._x = 0;
    this._x = a;
  }
  /**
   * Gets the string representation of the error value.
   * @return The string representation of the error value.
   */
  toString() {
    switch (this._x) {
      case 0: return "#NULL!";
      case 7: return "#DIV/0!";
      case 15: return "#VALUE!";
      case 23: return "#REF!";
      case 29: return "#NAME?";
      case 36: return "#NUM!";
      case 42: return "#N/A";
      case 255: return "#CIRCULARITY!";
      default: break;
    }
    return intToString(this._x, ExcelUtils.cq);
  }
  /**
   * @hidden
   */
  static _j(a) {
    switch (a) {
      case 0: return ErrorValue.emptyCellRangeIntersection;
      case 7: return ErrorValue.divisionByZero;
      case 15: return ErrorValue.wrongOperandType;
      case 23: return ErrorValue.invalidCellReference;
      case 29: return ErrorValue.wrongFunctionName;
      case 36: return ErrorValue.valueRangeOverflow;
      case 42: return ErrorValue.argumentOrFunctionNotAvailable;
      case 255: return ErrorValue.circularity;
      default: return null;
    }
  }
  /**
   * @hidden
   */
  _a() {
    return new ExcelCalcErrorValue(CalcUtilities.b(this._x));
  }
  /**
   * Gets the ErrorValue representing the #N/A error.
   * <p class="body">
   * This error occurs when a value isn't available for some part of a formula.
   * </p>
   * The ErrorValue representing the #N/A error.
   */
  static get argumentOrFunctionNotAvailable() {
    if (ErrorValue._b == null) {
      if (ErrorValue._b == null) {
        ErrorValue._b = new ErrorValue(42);
      }
    }
    return ErrorValue._b;
  }
  /**
   * Gets the ErrorValue representing a circularity error.
   * <p class="body">
   * There is no error constant for a circularity in Microsoft Excel and a circularity cannot be the result of a formula in Microsoft Excel.
   * However, for run-time purposes, after loading or before saving a workbook, this error value will be used for the result of formulas
   * which cause circular references when the owning workbook has [[Workbook.iterativeCalculationsEnabled]] set to False.
   * </p>
   * <p class="body">
   * In Microsoft Excel, setting a circular reference formula on a cell will show an error dialog the first time the problem occurs. Subsequent
   * formulas violating the circular reference restriction will just evaluate to zero. Therefore, when this value is encountered in a cell, it
   * can be treated as a zero for calculation purposes. This error value will be returned though so an actual zero value in a cell can be
   * differentiated from a circularity error.
   * </p>
   * <p class="note">
   * <B>Note:</B> Because there is no circularity error constant in Microsoft Excel, this error value cannot be assigned to a cell manually.
   * Attempting to assign this error value to a cell will result in an InvalidOperationException to be thrown. This error value will only be
   * valid as the result of a formula which has been applied to a cell.
   * </p>
   * The ErrorValue representing a circularity error.
   */
  static get circularity() {
    if (ErrorValue._d == null) {
      if (ErrorValue._d == null) {
        ErrorValue._d = new ErrorValue(255);
      }
    }
    return ErrorValue._d;
  }
  /**
   * Gets the ErrorValue representing the #DIV/0! error.
   * <p class="body">
   * This error occurs when a number is divided by zero.
   * </p>
   * The ErrorValue representing the #DIV/0! error.
   */
  static get divisionByZero() {
    if (ErrorValue._f == null) {
      if (ErrorValue._f == null) {
        ErrorValue._f = new ErrorValue(7);
      }
    }
    return ErrorValue._f;
  }
  /**
   * Gets the ErrorValue representing the #NULL! error.
   * <p class="body">
   * This error occurs when there is an intersection of two references that do not contain any common cells.
   * The intersection operator is a space between two references.
   * </p>
   * The ErrorValue representing the #NULL! error.
   */
  static get emptyCellRangeIntersection() {
    if (ErrorValue._h == null) {
      if (ErrorValue._h == null) {
        ErrorValue._h = new ErrorValue(0);
      }
    }
    return ErrorValue._h;
  }
  /**
   * Gets the ErrorValue representing the #REF! error.
   * <p class="body">
   * This error occurs when a cell reference or cell range reference is not valid.
   * </p>
   * The ErrorValue representing the #REF! error.
   */
  static get invalidCellReference() {
    if (ErrorValue._k == null) {
      if (ErrorValue._k == null) {
        ErrorValue._k = new ErrorValue(23);
      }
    }
    return ErrorValue._k;
  }
  /**
   * Gets the ErrorValue representing the #NUM! error.
   * <p class="body">
   * This error occurs when there are invalid numeric values in a formula.
   * </p>
   * The ErrorValue representing the #NUM! error.
   */
  static get valueRangeOverflow() {
    if (ErrorValue._m == null) {
      if (ErrorValue._m == null) {
        ErrorValue._m = new ErrorValue(36);
      }
    }
    return ErrorValue._m;
  }
  /**
   * Gets the ErrorValue representing the #NAME? error.
   * <p class="body">
   * This error occurs when text in a formula is not recognized.
   * </p>
   * The ErrorValue representing the #NAME? error.
   */
  static get wrongFunctionName() {
    if (ErrorValue._o == null) {
      if (ErrorValue._o == null) {
        ErrorValue._o = new ErrorValue(29);
      }
    }
    return ErrorValue._o;
  }
  /**
   * Gets the ErrorValue representing the #VALUE! error.
   * <p class="body">
   * This error occurs when an incorrect argument or operand is used in a function.
   * </p>
   * The ErrorValue representing the #VALUE! error.
   */
  static get wrongOperandType() {
    if (ErrorValue._q == null) {
      if (ErrorValue._q == null) {
        ErrorValue._q = new ErrorValue(15);
      }
    }
    return ErrorValue._q;
  }
  /**
   * @hidden
   */
  get _y() {
    return this._x;
  }
}
ErrorValue.$t = markType(ErrorValue, 'ErrorValue');
/**
 * @hidden
 */
ErrorValue._v = 0;
/**
 * @hidden
 */
ErrorValue._u = 7;
/**
 * @hidden
 */
ErrorValue._ab = 15;
/**
 * @hidden
 */
ErrorValue._w = 23;
/**
 * @hidden
 */
ErrorValue._aa = 29;
/**
 * @hidden
 */
ErrorValue._z = 36;
/**
 * @hidden
 */
ErrorValue._s = 42;
/**
 * @hidden
 */
ErrorValue._t = 255;
/**
 * @hidden
 */
ErrorValue._h = null;
/**
 * @hidden
 */
ErrorValue._f = null;
/**
 * @hidden
 */
ErrorValue._q = null;
/**
 * @hidden
 */
ErrorValue._k = null;
/**
 * @hidden
 */
ErrorValue._o = null;
/**
 * @hidden
 */
ErrorValue._m = null;
/**
 * @hidden
 */
ErrorValue._b = null;
/**
 * @hidden
 */
ErrorValue._d = null;
/**
 * @hidden
 */
ErrorValue._ac = {};
/**
 * @hidden
 */
export class StringElement extends GenericCacheElement {
  constructor(a) {
    super();
    this._z = 0;
    this._x = null;
    this._x = a;
  }
  g(a) {
    return this._q();
  }
  equals(a) {
    return this.c(typeCast(GenericCacheElement.$, a));
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._x);
  }
  c(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(StringElement.$, a);
    if (b == null) {
      return false;
    }
    if (b._x != this._x) {
      return false;
    }
    if (b._u != this._u) {
      return false;
    }
    return true;
  }
  toString() {
    return this._y;
  }
  compareTo(a) {
    let b = stringCompare1(this._y, a._y, 4);
    if (b != 0) {
      return b;
    }
    let c = typeCast(FormattedStringElement.$, a);
    let d = a._u ? 0 : c._ah.count;
    if (this._u == false) {
      if (d == 0) {
        return 0;
      }
      return -1;
    }
    let e = this;
    b = e._ah.count - d;
    if (b != 0) {
      return b;
    }
    for (let f = 0; f < e._ah.count; f++) {
      b = e._ah._inner[f].k - c._ah._inner[f].k;
      if (b != 0) {
        return b;
      }
      b = Base.getHashCodeStatic(e._ah._inner[f]) - Base.getHashCodeStatic(c._ah._inner[f]);
      if (b != 0) {
        return b;
      }
    }
    return b;
  }
  _t($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitStringElement$i(this, b);
  }
  static _r(a) {
    if (StringElement._v != null) {
      if (StringElement._v.f > 0) {
        let b = StringElement._v.e();
        b._y = a;
        return b;
      }
    }
    return new StringElement(a);
  }
  _ab() {
    if (StringElement._v == null) {
      StringElement._v = new Stack$1(StringElement.$);
    }
    if (StringElement._v.f < 10) {
      StringElement._v.h(this);
    }
  }
  _q() {
    return new StringElement(this._x);
  }
  _ac() {
  }
  _s(a) {
    let b = this._y;
    let c = b.indexOf('\r');
    if (c < 0) {
      return this;
    }
    let d = this.g(a);
    let e = typeCast(FormattedStringElement.$, d);
    let f = 0;
    while (c >= 0) {
      b = stringRemove(b, c, 1);
      if (c < b.length && b.charAt(c) != '\n') {
        b = stringInsert(b, c, "\n");
      }
      else if (e != null && e._u) {
        for (let g = f; g < e._ah.count; g++) {
          let h = e._ah._inner[g];
          if (h.k <= c) {
            f++;
            continue;
          }
          h.k--;
        }
      }
      c = b.indexOf('\r', c);
    }
    d._y = b;
    return d;
  }
  static _ad(a, b, c) {
    let d = StringElement._ae(a, null, b, c);
    b = d.p2;
    c = d.p3;
    return {
      p1: b,
      p2: c
    };
  }
  static _ae(a, b, c, d) {
    let e = (a == null || typeCast(WorksheetShape.$, b) !== null) ? null : a._bj;
    let f = a == null ? null : a._av;
    if (d._u) {
      for (let g of fromEnum(d._ah)) {
        if (g.h) {
          g.f(a).h(f);
        }
      }
    }
    let h = GenericCacheElement.o(StringElement.$, e, c, d);
    c = h.p1;
    d = h.p2;
    return {
      p2: c,
      p3: d
    };
  }
  get__u() {
    return false;
  }
  get _u() {
    return this.get__u();
  }
  get _aa() {
    return this._z;
  }
  set _aa(a) {
    this._z = a;
  }
  get _y() {
    return this._x;
  }
  set _y(a) {
    this._x = a;
    this._ac();
  }
  get _w() {
    return this._x.length;
  }
}
StringElement.$t = markType(StringElement, 'StringElement', GenericCacheElement.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
StringElement._p = new Array(0);
StringElement._v = null;
/**
 * @hidden
 */
export class FormattedStringElement extends StringElement {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = [""];
          {
            let e = c[0];
            super(e);
            this._ag = null;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c);
          this._ag = null;
        }
        break;
    }
  }
  _t($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitFormattedStringElement$i(this, b);
  }
  g(a) {
    let b = new FormattedStringElement(1, this._y);
    if (this._u) {
      for (let c of fromEnum(this._ah)) {
        b._ah.add(c.a(a, b));
      }
    }
    return b;
  }
  equals(a) {
    return super.equals(a);
  }
  _ab() {
  }
  getHashCode() {
    let a = Base.getHashCodeStatic(this._y);
    if (this._u) {
      a += this._ah.count;
    }
    return a;
  }
  c(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(FormattedStringElement.$, a);
    if (b == null) {
      return false;
    }
    if (b._y != this._y) {
      return false;
    }
    let c = this._u == false ? 0 : this._ah.count;
    let d = b._u == false ? 0 : b._ah.count;
    if (c != d) {
      return false;
    }
    if (c > 0) {
      for (let e = 0; e < c; e++) {
        if (Base.equalsStatic(this._ah._inner[e], b._ah._inner[e]) == false) {
          return false;
        }
      }
    }
    return true;
  }
  _ac() {
    if (this._u) {
      ExcelUtils.gd(this);
    }
  }
  addRun(a) {
    let b = typeCast(FormattedStringRun.$, a);
    if (b == null) {
      return;
    }
    this._ah.add(b);
  }
  createRun(a) {
    return new FormattedStringRun(this, a);
  }
  getFormattingRuns(a) {
    return this._ah;
  }
  insertRun(a, b) {
    let c = typeCast(FormattedStringRun.$, b);
    if (c == null) {
      return;
    }
    this._ah.insert(a, c);
  }
  get startIndex() {
    return 0;
  }
  _ai() {
    if (this._u == false) {
      return;
    }
    for (let a = 0; a < this._ag.count; a++) {
      let b = this._ag._inner[a];
      if (b.h) {
        b.e().i();
      }
    }
    this._ag = null;
  }
  static _af(a) {
    return new FormattedStringElement(1, a._y);
  }
  get _ah() {
    if (this._ag == null) {
      this._ag = new List$1(FormattingRunBase.$, 0);
    }
    return this._ag;
  }
  get__u() {
    return this._ag != null && this._ag.count > 0;
  }
  get unformattedString() {
    return this._y;
  }
}
FormattedStringElement.$t = markType(FormattedStringElement, 'FormattedStringElement', StringElement.$, [IFormattedRunOwner_$type]);
/**
 * @hidden
 */
export let IRegionBlockingSingleCellComponent_$type = new Type(null, 'IRegionBlockingSingleCellComponent');
/**
 * @hidden
 */
export class ArrayInteriorFormula extends SingleTargetFormula {
  constructor(a) {
    super(1, a);
    this._cy = null;
    this._cy = a;
  }
  get owningValue() {
    return this._cy;
  }
  _g() {
    return new ArrayInteriorFormula(this._cy);
  }
  get__i() {
    return this._cy;
  }
  get__ak() {
    return true;
  }
  get__cj() {
    let a = typeCast(CellCalcReference.$, this._ch);
    return a != null && this._cy.cellRange != null && a._w.index == this._cy.cellRange.firstRow && a._ao == this._cy.cellRange._v;
  }
  get _cz() {
    return this._cy;
  }
}
ArrayInteriorFormula.$t = markType(ArrayInteriorFormula, 'ArrayInteriorFormula', SingleTargetFormula.$, [IRegionBlockingSingleCellComponent_$type]);
/**
 * @hidden
 */
export class DataTableInteriorFormula extends SingleTargetFormula {
  constructor(a) {
    super(2, a);
    this._cy = null;
    this._cy = a;
    this._cd = new ExcelCalcValue(0);
  }
  get owningValue() {
    return this._cy;
  }
  _g() {
    return new DataTableInteriorFormula(this._cy);
  }
  get__am() {
    return true;
  }
  get__cj() {
    let a = typeCast(CellCalcReference.$, this._ch);
    let b = this._cy._h;
    return a != null && b != null && a._w.index == b.firstRow && a._ao == b._v;
  }
  get _cz() {
    return this._cy;
  }
}
DataTableInteriorFormula.$t = markType(DataTableInteriorFormula, 'DataTableInteriorFormula', SingleTargetFormula.$, [IRegionBlockingSingleCellComponent_$type]);
/**
 * @hidden
 */
export let ICellFormatOwner_$type = new Type(null, 'ICellFormatOwner');
/**
 * @hidden
 */
export let IWorksheetCellFormatProxyOwner_$type = new Type(null, 'IWorksheetCellFormatProxyOwner');
/**
 * Abstract base class for worksheet row and worksheet column.
 * @see [[WorksheetColumn]]
 * @see [[WorksheetRow]]
 */
export class RowColumnBase extends Base {
  constructor(a) {
    super();
    this._f = null;
    this._c = null;
    this._c = a;
  }
  /**
   * @hidden
   */
  get cellFormatInternal() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  get hasCellFormat() {
    return this._hasCellFormat;
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return this._getAdjacentFormatForBorderResolution(sender, borderValue);
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
    this._onCellFormatValueChanged(sender, values, options);
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
    this._onCellFormatValueChanging(sender, values);
  }
  /**
   * @hidden
   */
  _onCellFormatValueChanging(a, b) {
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
  }
  /**
   * @hidden
   */
  static _b($tValue, a, b, c, d, e = null, f = true, g = false, h = 0) {
    return new ChangeInfo$2(IChangeInfoContext_$type, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * Gets the resolved cell formatting for the cells in the row or column.
   * @return A format object describing the actual formatting that will be used when displayed the row or column in Microsoft Excel.
   * @throws [[InvalidOperationException]] If the object was removed from the worksheet.
   * @see [[cellFormat]]
   */
  getResolvedCellFormat() {
    this._ad();
    return new WorksheetCellFormatDataResolved(this._cellFormatInternal);
  }
  /**
   * @hidden
   */
  _t(a) {
    this._c = a;
  }
  /**
   * @hidden
   */
  _u() {
  }
  /**
   * @hidden
   */
  _x() {
  }
  /**
   * @hidden
   */
  _y() {
  }
  /**
   * @hidden
   */
  static _z(a, b) {
    ChangeInfo.f(a, 0, RowColumnBase._b(Boolean_$type, "Hidden", b, (c) => c.hidden, (c, d) => c.hidden = d, (c, d) => c._aa(d)));
    ChangeInfo.f(a, 1, RowColumnBase._b(Number_$type, "OutlineLevel", b, (c) => c.outlineLevel, (c, d) => c.outlineLevel = d, (c, d) => c._ab(d)));
  }
  /**
   * Gets the default cell format for cells in this row or column.
   * <p class="body">
   * Any default properties of the cell's format will take their value from this format when getting a resolved format.
   * </p>
   * The default cell format for cells in this row or column.
   */
  get cellFormat() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  get _hasCellFormat() {
    return this._f != null;
  }
  /**
   * Gets or sets the value indicating whether the row or column is hidden.
   * The Hidden state also controls the expanded state of rows or columns in outline groups. Basically, an outline group
   * simply provides an easy way to hide and unhide all rows or columns in the group at the same time, via the expansion
   * indicator.
   * The value indicating whether the row or column is hidden.
   * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
   * @see [[outlineLevel]]
   * @see [[CustomView.getHiddenColumns]]
   * @see [[CustomView.getHiddenRows]]
   */
  get hidden() {
    return this._l;
  }
  /**
   * Gets or sets the value indicating whether the row or column is hidden.
   * The Hidden state also controls the expanded state of rows or columns in outline groups. Basically, an outline group
   * simply provides an easy way to hide and unhide all rows or columns in the group at the same time, via the expansion
   * indicator.
   * The value indicating whether the row or column is hidden.
   * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
   * @see [[outlineLevel]]
   * @see [[CustomView.getHiddenColumns]]
   * @see [[CustomView.getHiddenRows]]
   */
  set hidden(a) {
    this._ad();
    if (this.hidden == a) {
      return;
    }
    this._a[0].h(IChangeInfoContext_$type, Boolean_$type, this, a);
  }
  /**
   * @hidden
   */
  _aa(a, b = true) {
    if (this.hidden == a) {
      return;
    }
    let c = null;
    if (b && this.worksheet._dy(this)) {
      c = WorksheetElementResizeContext.b(this);
    }
    this._l = a;
    this._y();
    if (c != null) {
      c.y();
    }
  }
  /**
   * Gets or sets the outline level for the row or column.
   * <p class="body">
   * Microsoft Excel supports hierarchical grouping of rows and columns with a maximum of seven levels of hierarchy.
   * To create a group, set adjacent rows or columns to same outline level. When rows or columns are grouped, an
   * outline indicator will provide a visual representation of the outline level.  In addition, an outline group has
   * an expansion indicator at one end of the group, which allows the user to easily hide and unhide all rows or column
   * in the group with a single click.
   * </p>
   * The outline level for the row or column.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid outline level range of 0 and 7.
   * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
   * @see [[hidden]]
   */
  get outlineLevel() {
    return this._n;
  }
  /**
   * Gets or sets the outline level for the row or column.
   * <p class="body">
   * Microsoft Excel supports hierarchical grouping of rows and columns with a maximum of seven levels of hierarchy.
   * To create a group, set adjacent rows or columns to same outline level. When rows or columns are grouped, an
   * outline indicator will provide a visual representation of the outline level.  In addition, an outline group has
   * an expansion indicator at one end of the group, which allows the user to easily hide and unhide all rows or column
   * in the group with a single click.
   * </p>
   * The outline level for the row or column.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid outline level range of 0 and 7.
   * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
   * @see [[hidden]]
   */
  set outlineLevel(a) {
    this._ad();
    if (this.outlineLevel != a) {
      this._a[1].h(IChangeInfoContext_$type, Number_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a < 0 || 7 < a) {
      throw ExcelUtils.x("value", a, ExcelUtils.ef("LER_ArgumentOutOfRangeException_OutlineLevel"));
    }
    this._n = a;
  }
  /**
   * Gets the worksheet to which the row or column belongs.
   * The worksheet to which the row or column belongs.
   */
  get worksheet() {
    return this._c;
  }
  /**
   * @hidden
   */
  get _cellFormatInternal() {
    if (this._f == null && this._c != null) {
      let a = this._c.workbook;
      let b = null;
      if (a != null) {
        b = a._ca;
      }
      this._f = this._h(b);
      this._u();
    }
    return this._f;
  }
  /**
   * @hidden
   */
  get__j() {
    if (this.outlineLevel != 0) {
      return true;
    }
    if (this._hasCellFormat && this._cellFormatInternal._z == false) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _ac(a, b) {
  }
}
RowColumnBase.$t = markType(RowColumnBase, 'RowColumnBase', Base.$, [ICellFormatOwner_$type, IWorksheetCellFormatProxyOwner_$type]);
/**
 * @hidden
 */
RowColumnBase._p = 0;
/**
 * @hidden
 */
RowColumnBase._s = 1;
/**
 * @hidden
 */
RowColumnBase._o = 2;
/**
 * @hidden
 */
export let IWorksheetRegionAddressContext_$type = new Type(null, 'IWorksheetRegionAddressContext');
/**
 * Represents a row in a Microsoft Excel worksheet.
 */
export class WorksheetRow extends RowColumnBase {
  constructor(a, b) {
    super(a);
    this._a3 = null;
    this._cl = -1;
    this._af = null;
    this._bq = null;
    this._ag = null;
    this._cn = 0;
    this._cw = 0;
    this._cc = 0;
    this._ce = 0;
    this._bn = 0;
    this._cd = 0;
    this._cw = b;
    this._cn = a.defaultRowHeight;
    this._l = a._dv;
    this._b5 = a._dt;
    this._b2 = a._ds;
    this._cc = a._rows$i._k;
    if (a._d4) {
      this._cl = this._cn;
      this._bz = true;
    }
  }
  /**
   * @hidden
   */
  get__a() {
    return WorksheetRow._ae;
  }
  /**
   * @hidden
   */
  get _a() {
    return this.get__a();
  }
  /**
   * @hidden
   */
  _h(a) {
    let b = a != null ? a._p : null;
    for (let c of fromEnum(this.worksheet._ff)) {
      if (c.b._ca(b) == false) {
        for (let d of fromEnum(this._ch(c.q, c.r, true))) {
          this._bc(d.r);
        }
      }
    }
    return new WorksheetRowOwnedCellFormatProxy(a, this);
  }
  /**
   * @hidden
   */
  _getAdjacentFormatForBorderResolution(a, b) {
    let c = typeCast(WorksheetCellOwnedFormatProxy.$, a);
    if (c != null) {
      let d = null;
      switch (b) {
        case 67108864:
        case 134217728:
          {
            if (this.index == 0) {
              return null;
            }
            let e = this.worksheet._rows$i._aj(this.index - 1);
            d = this.worksheet._b4(e, c._bv);
            break;
          }
        case 2:
        case 4:
          {
            if (this.index == this.worksheet._rows$i.maxCount - 1) {
              return null;
            }
            let f = this.worksheet._rows$i._aj(this.index + 1);
            d = this.worksheet._b4(f, c._bv);
            break;
          }
        case 262144:
        case 524288:
          if (c._bv == 0) {
            return null;
          }
          d = this._a7((c._bv - 1));
          break;
        case 2097152:
        case 4194304:
          if (c._bv == this.worksheet._columns$i.maxCount - 1) {
            return null;
          }
          d = this._a7((c._bv + 1));
          break;
        default: return null;
      }
      return d;
    }
    else {
      switch (b) {
        case 67108864:
        case 134217728:
          {
            if (this.index == 0) {
              return null;
            }
            let g = this.worksheet._rows$i._aj(this.index - 1);
            if (g == null || g._hasCellFormat == false) {
              return null;
            }
            return g._cellFormatInternal.d;
          }
        case 2:
        case 4:
          {
            if (this.index == this.worksheet._rows$i.maxCount - 1) {
              return null;
            }
            let h = this.worksheet._rows$i._aj(this.index + 1);
            if (h == null || h._hasCellFormat == false) {
              return null;
            }
            return h._cellFormatInternal.d;
          }
        case 262144:
        case 524288:
        case 2097152:
        case 4194304: return null;
        default: return null;
      }
    }
  }
  /**
   * @hidden
   */
  get__j() {
    if (super.get__j()) {
      return true;
    }
    if (this._bz) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  get__l() {
    return this._bw(1);
  }
  /**
   * @hidden
   */
  set__l(a) {
    this._d7(1, a);
  }
  /**
   * @hidden
   */
  get _l() {
    return this.get__l();
  }
  /**
   * @hidden
   */
  set _l(a) {
    this.set__l(a);
  }
  /**
   * Gets the 0-based index of the row in the worksheet.
   * The 0-based index of the row in the worksheet.
   */
  get_index() {
    let a = this.worksheet;
    if (a == null || this._bw(64)) {
      return -1;
    }
    let b = a._rows$i;
    let c = b._k;
    if (c != this._cc) {
      let d = b._q(this._cw, this._cc);
      this._cc = c;
      if (d < 0) {
        this._d7(64, true);
        return -1;
      }
      this._cw = d;
    }
    return this._cw;
  }
  /**
   * Gets the 0-based index of the row in the worksheet.
   * The 0-based index of the row in the worksheet.
   */
  get index() {
    return this.get_index();
  }
  /**
   * @hidden
   */
  get _cx() {
    if (this._bw(64)) {
      return this._cw;
    }
    return this.index;
  }
  /**
   * @hidden
   */
  _u() {
    super._u();
    let a = this.worksheet;
    if (a != null && a._t == false && this != WorksheetRow._bm) {
      for (let b of fromEnum(a._ff)) {
        if (b.b._cd == false) {
          for (let c = b.q; c <= b.r; c++) {
            this._bc(c);
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _onCellFormatValueChanged(a, b, c) {
    if (this.worksheet._t) {
      return;
    }
    let d = typeCast(WorksheetCellOwnedFormatProxy.$, a);
    if (d != null) {
      this._ds(d, b, c);
      return;
    }
    if (WorksheetRow._bs(b)) {
      this._dx();
    }
    for (let e = 1; e != 1073741824; e = (e << 1)) {
      if ((b & e) == 0) {
        continue;
      }
      if (this._cellFormatInternal._aa(e)) {
        continue;
      }
      let f = a._aj(e);
      let t1 = e;
      L0: while (true) {
        switch (t1) {
          case 2:
          case 4:
          case 67108864:
          case 134217728:
            {
              if (e == 4 || e == 134217728) {
                this._ei(a, e);
                this._di(void 0, (c & 64) == 0);
              }
              if ((c & 1) != 0) {
                t1 = void 0;
                continue L0;
              }
              let g = Nullable$1.toNullable(Number_$type, null);
              if (e == 67108864 || e == 134217728) {
                if (0 < this.index) {
                  g = Nullable$1.toNullable(Number_$type, this.index - 1);
                }
              }
              else {
                let h = this.worksheet._rows$i.maxCount - 1;
                if (this.index < h) {
                  g = Nullable$1.toNullable(Number_$type, this.index + 1);
                }
              }
              let i = g.hasValue ? this.worksheet._rows$i._aj(g.value) : null;
              if (i != null) {
                let j = ExcelUtils.o(e);
                if (i._hasCellFormat) {
                  ExcelUtils.gc(a, i._cellFormatInternal, e, f, c);
                }
                let k = ExcelUtils.m(j);
                for (let l of fromEnum(i._cg(j))) {
                  let m = l.c(i);
                  if (m._aj(j) != f) {
                    m._as(j, 1);
                    m._as(k, 1);
                  }
                }
              }
              t1 = void 0;
              continue L0;
            }
          default:
            {
              let n = false;
              let o = false;
              let p = 1;
              if (e == 16) {
                p = EnumUtil.getEnumValue(DiagonalBorders_$type, f);
                let q = a.d._ax;
                n = ExcelUtils.a0(p) == false && ExcelUtils.a0(q);
                o = ExcelUtils.a1(p) == false && ExcelUtils.a1(q);
              }
              if ((c & 8) != 0) {
                break;
              }
              for (let r of fromEnum(this._cg(e))) {
                let s = this._bl(r.e);
                if (s != null && s._aa != 1) {
                  continue;
                }
                let t = r.c(this);
                let u = f;
                if (e == 16) {
                  let v = p | t.diagonalBorders;
                  if (n) {
                    let w = ExcelUtils.f0(v);
                    v = w.p0;
                  }
                  if (o) {
                    let x = ExcelUtils.f1(v);
                    v = x.p0;
                  }
                  u = enumGetBox(DiagonalBorders_$type, v);
                }
                t._bk(e, u);
              }
            }
            break;
        }
        break;
      }
    }
    let y = a.formatOptions & ~this._cd;
    if (y != 0 && this != WorksheetRow._bm) {
      for (let z of fromEnum(this.worksheet._ff)) {
        if ((z.b.formatOptions & y) == 0) {
          continue;
        }
        for (let aa = z.q; aa <= z.r; aa++) {
          this._bc(aa);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _onCellFormatValueChanging(a, b) {
    if ((typeCast(WorksheetCellOwnedFormatProxy.$, a) !== null) == false) {
      this._cd = a.formatOptions;
    }
  }
  /**
   * @hidden
   */
  _y() {
    super._y();
    this.worksheet._rows$i._a0(this.index, true);
    this._dg();
  }
  /**
   * @hidden
   */
  get__n() {
    return this._ce;
  }
  /**
   * @hidden
   */
  set__n(a) {
    this._ce = a;
  }
  /**
   * @hidden
   */
  get _n() {
    return this.get__n();
  }
  /**
   * @hidden
   */
  set _n(a) {
    this.set__n(a);
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    super._ac(a, b);
    let c = this.worksheet.workbook;
    for (let d of fromEnum(this._ch(void 0, void 0, true))) {
      this._eh(c, d, a, b);
    }
    let e = Workbook.getMaxRowCount(b) - 1;
    if (e < this.index) {
      a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxRowIndex"), this.index, e));
    }
  }
  /**
   * @hidden
   */
  _ad() {
    if (this.worksheet == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_RowRemovedFromWorksheet"));
    }
  }
  /**
   * Applies a formula to the cell at the specified column index.
   * <p class="body">
   * 'formula' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
   * to which the row belongs. If the row's [[Worksheet]] has been removed from its parent collection,
   * the A1 CellReferenceMode will be used to parse the formula.
   * </p>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @param formula The formula to parse and apply to the cell.
   * @param cellReferenceMode The mode used to interpret cell references in the formula.
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[ArgumentNullException]] 'formula' is null or empty.
   * @throws [[FormulaParseException]] 'formula' is not a valid formula.
   * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
   * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @see [[getCellFormula]]
   * @see [[WorksheetCell.applyFormula]]
   */
  applyCellFormula(columnIndex, formula, cellReferenceMode) {
    if (arguments[2] !== void 0) {
      arguments[2] = wrapNullable(CellReferenceMode_$type, arguments[2]);
    }
    return this._applyCellFormula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _applyCellFormula$i(a, b, c = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    let d = a;
    let e = this.worksheet.workbook;
    let f = false;
    let g = !nullableIsNull(c) ? c.value : (e == null ? 1 : e.cellReferenceMode);
    if (g == 0) {
      let h;
      if (((() => { let i = e._d1.tryGetValue(b, h); h = i.p1; return i.ret; })())) {
        h._bp(this, d);
        return;
      }
      f = true;
    }
    let i = Formula._p(b, e, Nullable$1.toNullable(CellReferenceMode_$type, g));
    if (f) {
      e._d1.addItem(b, i);
    }
    i._bp(this, d);
  }
  /**
   * Gets the data table to which the cell at the specified index belongs.
   * <p class="body">
   * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
   * </p>
   * <p class="body">
   * If a data table is associated with the cell, getting the value of the cell with [[getCellValue]]
   * will return the calculated value for the cell.
   * </p>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The data table to which the cell belongs or null if the cell does not belong to a data table.
   * @see [[Worksheet.dataTables]]
   * @see [[WorksheetDataTableCollection.add]]
   * @see [[getCellValue]]
   * @see [[WorksheetCell.associatedDataTable]]
   */
  getCellAssociatedDataTable(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._bg(columnIndex);
  }
  /**
   * @hidden
   */
  _bg(a) {
    let b = this._a2(a);
    if (b == null) {
      return null;
    }
    if (b.r(a) == false) {
      return null;
    }
    let c = typeCast(DataTableInteriorFormula.$, b.aa(this, a));
    if (c == null) {
      return null;
    }
    return c._cz;
  }
  /**
   * Gets the merged cells region which contains the cell at the specified index, or null if the cell is not merged.
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The merged cells region which contains the cell at the specified index, or null if the cell is not merged.
   * @see [[WorksheetCell.associatedMergedCellsRegion]]
   */
  getCellAssociatedMergedCellsRegion(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._bl(columnIndex);
  }
  /**
   * @hidden
   */
  _bl(a) {
    if (this.worksheet == null) {
      return null;
    }
    return this.worksheet._cr(this.index, a);
  }
  /**
   * Gets the [[WorksheetTable]] to which the cell at the specified index belongs.
   * <p class="body">
   * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
   * </p>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @see [[WorksheetTable]]
   * @see [[Worksheet.tables]]
   */
  getCellAssociatedTable(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._bp(columnIndex);
  }
  /**
   * @hidden
   */
  _bp(a) {
    if (this.worksheet == null) {
      return null;
    }
    return this.worksheet._de(this.index, a);
  }
  getCellBoundsInTwips() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return rectToLiteral(this._getCellBoundsInTwips.apply(this, arguments));
      case 1: return rectToLiteral(this._getCellBoundsInTwips1.apply(this, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getCellBoundsInTwips(a) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    return this._el(a);
  }
  /**
   * @hidden
   */
  _el(a) {
    return this._em(a, 0);
  }
  /**
   * @hidden
   */
  _getCellBoundsInTwips1(a, b) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    return this._em(a, b);
  }
  /**
   * @hidden
   */
  _em(a, b) {
    return WorksheetShape._du(this.worksheet, this.index, a, ExcelUtils.g8, this.index, a, { $type: Point_$type, x: 100, y: 100 }, b);
  }
  /**
   * Gets or sets the comment applied to the cell at the specified column index.
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The comment applied to the cell.
   * @see [[WorksheetCell.comment]]
   */
  getCellComment(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._a6(columnIndex);
  }
  /**
   * @hidden
   */
  _a6(a) {
    if (this.worksheet._d2 == false) {
      return null;
    }
    let b = new WorksheetCellAddress(1, this.index, a);
    let c;
    if (((() => { let d = this.worksheet._eu.tryGetValue(b, c); c = d.p1; return d.ret; })())) {
      return c;
    }
    return null;
  }
  getCellText() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getCellText.apply(this, arguments);
      case 1: return this._getCellText1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getCellText(a) {
    return this._getCellText1(a, 0);
  }
  /**
   * @hidden
   */
  _getCellText1(a, b) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    return this._da(a, b);
  }
  /**
   * @hidden
   */
  _da(a, b) {
    let c = new GetCellTextParameters(a);
    c.b = b;
    c.a = 0;
    return this._av(c).g;
  }
  /**
   * @hidden
   */
  _av(a) {
    let b = this._a2(a.e);
    return this._aw(b, a);
  }
  /**
   * @hidden
   */
  _aw(a, b) {
    ExcelUtils.gq(b.b);
    if (a == null) {
      return new GetCellTextResult(1, stringEmpty());
    }
    if (b.g.hasValue == false) {
      b.g = Nullable$1.toNullable(Boolean_$type, (this.worksheet.displayOptions.showFormulasInCells == false));
    }
    return a.b(this, this._cw, b);
  }
  /**
   * Gets the cell conditional format for the cell at the specified column index.
   * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of the criteria an instance of [[CellConditionalFormat]]
   * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
   * conditional format region then this method will return null.</para>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
   * @see [[Worksheet.conditionalFormats]]
   * @see [[CellConditionalFormat]]
   */
  getCellConditionalFormat(columnIndex) {
    this._ad();
    return this.worksheet._getCellConditionalFormat1(this.index, columnIndex);
  }
  /**
   * Gets the cell formatting for the cell at the specified column index.
   * <p class="body">
   * Use this method to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
   * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
   * </p>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The cell formatting for the cell at the specified column index.
   * @see [[getResolvedCellFormat]]
   * @see [[WorksheetCell.cellFormat]]
   * @see [[tryGetCellFormat]]
   */
  getCellFormat(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._bc(columnIndex);
  }
  /**
   * Gets the formula which has been applied to the cell at the specified column index.
   * <p class="body">
   * If a formula has been applied to the cell, getting the value with the [[getCellValue]] method will return the
   * calculated value of the formula.
   * </p>
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @return The formula which has been applied to the cell or null if no formula has been applied.
   * @see [[Formula.applyTo]]
   * @see [[Formula.applyTo]]
   * @see [[Formula.applyTo]]
   * @see [[applyCellFormula]]
   * @see [[WorksheetRegion.applyFormula]]
   * @see [[WorksheetRegion.applyArrayFormula]]
   * @see [[WorksheetCell.formula]]
   */
  getCellFormula(columnIndex) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    return this._ar(columnIndex);
  }
  /**
   * @hidden
   */
  _ar(a) {
    let b = this._c6(a);
    let c = typeCast(Formula.$, b);
    if (c == null) {
      return null;
    }
    if (c._ak) {
      return c._cz;
    }
    return c;
  }
  /**
   * @hidden
   */
  _bi(a) {
    let b = this._ar(a);
    if (b != null && b._ai) {
      let c = this._da(a, 1);
      let d = this._a1(a);
      let e = (((f) => f != null ? f : c)(d.y(this, a, false)));
      let f = typeCast(HyperlinkResult.$, e);
      if (f != null) {
        return new WorksheetHyperlink(this._cells$i.item(a), f.b, f.a, true);
      }
      return new WorksheetHyperlink(this._cells$i.item(a), e.toString(), c, true);
    }
    return null;
  }
  /**
   * Gets the effective hyperlink on the cell at the specified index.
   * <p class="body">
   * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
   * collection will be used.
   * </p>
   * <p class="body">
   * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
   * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
   * </p>
   * <p class="body">
   * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
   * </p>
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @see [[Worksheet.hyperlinks]]
   * @see [[WorksheetHyperlink]]
   * @see [[WorksheetHyperlink.isSealed]]
   */
  getCellHyperlink(columnIndex) {
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    if (this.worksheet == null) {
      return null;
    }
    return this.worksheet._ck(this, this.index, columnIndex);
  }
  /**
   * Gets the value of the cell at the specified column index.
   * <p class="body">
   * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
   * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
   * will always return null. Setting the value of other cells in a merged cell region will have no effect.
   * </p>
   * <p class="body">
   * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
   * calculated value of the cell.
   * </p>
   * <p class="body">
   * The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * The value of the cell.
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @see [[setCellValue]]
   * @see [[getCellAssociatedMergedCellsRegion]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   * @see [[WorksheetMergedCellsRegion.value]]
   * @see [[getCellFormula]]
   * @see [[getCellAssociatedDataTable]]
   * @see [[WorksheetCell.value]]
   */
  getCellValue(columnIndex) {
    return this._getCellValue1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getCellValue1(a) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    return this._c5(a);
  }
  /**
   * @hidden
   */
  _c5(a) {
    return this._c4(a, false);
  }
  /**
   * @hidden
   */
  _bh(a) {
    let b = this.worksheet;
    if (b == null) {
      return null;
    }
    if (b._d5 && this._bv(a)) {
      for (let c of fromEnum(b._dataTables$i)) {
        let d;
        if (((() => { let e = c._n(this, a, d); d = e.p2; return e.ret; })())) {
          return c;
        }
        if (d) {
          break;
        }
      }
    }
    return null;
  }
  getResolvedCellFormat() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return RowColumnBase.prototype.getResolvedCellFormat.apply(this, arguments);
      case 1: return this._getResolvedCellFormat1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getResolvedCellFormat1(a) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    return this._az(a);
  }
  /**
   * @hidden
   */
  _az(a) {
    return new WorksheetCellFormatDataResolved(this._bc(a));
  }
  /**
   * Sets the comment applied to the cell at the specified column index.
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @param comment The comment to apply to the cell.
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
   * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
   * anchors set but they are from different worksheets.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @see [[WorksheetCell.comment]]
   */
  setCellComment(columnIndex, comment) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    this._d2(columnIndex, comment);
  }
  /**
   * @hidden
   */
  _d2(a, b) {
    let c = this._a6(a);
    if (c != b) {
      let d = this.worksheet;
      if (b != null) {
        if (WorksheetCell.l_op_Equality(b.topLeftCornerCell, null) && WorksheetCell.l_op_Equality(b.bottomRightCornerCell, null)) {
          this._dl(a, b);
        }
        if (WorksheetCell.l_op_Equality(b.topLeftCornerCell, null) || WorksheetCell.l_op_Equality(b.bottomRightCornerCell, null)) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_AnchorCommentBeforeApplyingToCell"));
        }
        b._c0(d);
      }
      if (c != null) {
        c.cell = null;
      }
      let e = new WorksheetCellAddress(1, this.index, a);
      if (b == null) {
        if (d._d2) {
          d._eu.removeItem(e);
        }
      }
      else {
        d._eu.item(e, b);
      }
      let f = d.workbook;
      if (b != null) {
        b.cell = this._cells$i.item(a);
        if (b.author == null) {
          if (f != null && f.documentProperties.author != null) {
            b.author = f.documentProperties.author;
          }
          else {
            b.author = stringEmpty();
          }
        }
      }
      if (f != null && f._cx && !f._c4) {
        let g = new WorksheetCellLocation(1, this, a);
        WorksheetCellLocation.a.x(g, c, b);
      }
    }
  }
  /**
   * Sets the value of a cell at the specified column index.
   * <p class="body">
   * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
   * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
   * will always return null. Setting the value of other cells in a merged cell region will have no effect.
   * </p>
   * <p class="body">
   * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
   * calculated value of the cell.
   * </p>
   * <p class="body">
   * The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * The value of the cell.
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @param value The value to assign to the cell.
   * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
   * @throws [[InvalidOperationException]] The value assigned is a [[Formula]]. Instead, [[Formula.applyTo]]
   * should be called on the Formula, passing in the cell.
   * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
   * should be set to a region containing the cell.
   * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
   * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @see [[getCellValue]]
   * @see [[getCellAssociatedMergedCellsRegion]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   * @see [[WorksheetMergedCellsRegion.value]]
   * @see [[getCellFormula]]
   * @see [[getCellAssociatedDataTable]]
   * @see [[WorksheetCell.value]]
   */
  setCellValue(columnIndex, value) {
    this._ad();
    ExcelUtils.gi(this.worksheet, columnIndex, "columnIndex");
    WorksheetCellBlock.ax(value);
    this._d6(columnIndex, value);
  }
  /**
   * @hidden
   */
  _b9(a, b) {
    this._ad();
    ExcelUtils.gi(this.worksheet, a, "columnIndex");
    let c = this._bd(a);
    if (c != null) {
      b = c;
      return {
        ret: true,
        p1: b
      };
    }
    b = null;
    return {
      ret: false,
      p1: b
    };
  }
  /**
   * Returns a boolean indicating if the value of the cell is valid considering its associated [[WorksheetCell.dataValidationRule]]
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @return Returns false if the cell has an associated [[WorksheetCell.dataValidationRule]] and the current [[WorksheetCell.value]] does not pass the validation defined by that rule; otherwise true is returned.
   * @see [[getCellValue]]
   * @see [[setCellValue]]
   * @see [[Worksheet.dataValidationRules]]
   * @see [[DataValidationRule]]
   * @see [[WorksheetCell.dataValidationRule]]
   */
  validateCellValue(columnIndex) {
    let a = this.worksheet;
    if (a == null) {
      return true;
    }
    return a._bi(this.index, columnIndex) == null;
  }
  /**
   * @hidden
   */
  _cj() {
    let a = this.worksheet.workbook;
    let b = 0;
    if (this._b4 || this._b1) {
      let c = Workbook._eu(a, true);
      if (this._b4 && this._b1) {
        c *= 2;
      }
      b = truncate(MathUtilities.f(c));
    }
    let d;
    if (this._cm < 0) {
      d = this.worksheet._gp;
      if (this.worksheet._dt || this.worksheet._ds) {
        let e = Workbook._eu(a, true);
        if (this.worksheet._dt && this.worksheet._ds) {
          e *= 2;
        }
        d -= truncate(MathUtilities.f(e));
      }
    }
    else {
      d = this._cm - b;
    }
    let f = a != null ? a._ab : null;
    if (f != null) {
      d = this._cq(d, f);
    }
    else {
      {
        let g = Workbook._br(a);
        try {
          let h = new CellSizeMeasurementContext(a, g);
          d = this._cq(d, h);
        }
        finally {
          if (g != null) {
            g.dispose();
          }
        }
      }
    }
    return Math.min(d + b, 8192);
  }
  /**
   * @hidden
   */
  _cq(a, b) {
    if (this._hasCellFormat) {
      let c = this._cellFormatInternal.d;
      a = b.k(c);
    }
    let d = truncate(Math.floor(this.worksheet._g0 * 0.35));
    let e = Workbook.getMaxColumnCount(this.worksheet._o);
    for (let f of fromEnum(this._ch(void 0, void 0, true))) {
      let g = f.r;
      let h = f.j || this._a7(g);
      let i = g;
      if (h._a4 == 6) {
        i = this._ck(g, e, Nullable$1.toNullable(HorizontalCellAlignment_$type, 6));
      }
      let j = 0;
      for (let k = g; k <= i; k++) {
        j += this.worksheet._gb(k);
      }
      let l = truncate(this.worksheet._fl(j, 3)) - (h._cm + h._cn) * this.worksheet._gl - this.worksheet._ge() - d;
      l = Math.max(l, 0);
      let m = this._db(g, f.d, h);
      let n = m == null ? b.k(h) : b.l(h, m, l);
      a = Math.max(a, n);
    }
    return a;
  }
  /**
   * @hidden
   */
  _db(a, b, c) {
    if (b != null && c._b8 && b.p(this, a) && this._bl(a) == null) {
      let d = new GetCellTextParameters(a);
      d.b = 1;
      d.a = 0;
      return this._aw(b, d).g;
    }
    return null;
  }
  /**
   * @hidden
   */
  _de() {
    let a = this.worksheet;
    let b = a._g4(60);
    for (let c of fromEnum(this._ch(0, a._columns$i.maxCount, true))) {
      if (c.d != null) {
        c.d.aj(this, c.r);
      }
    }
    a._h4(b);
  }
  /**
   * @hidden
   */
  _df(a, b, c, d = null, e = Nullable$1.toNullable(Number_$type, null), f = false, g = false, h = Nullable$1.toNullable(Number_$type, null)) {
    let i = nullableNotEquals(e, null) ? this._bc(e.value) : (f && this._hasCellFormat ? this._cellFormatInternal : null);
    for (let j of fromEnum(this._ch(a, b, true))) {
      if (j.d != null) {
        j.d.aj(this, j.r);
      }
    }
    let k = nullableNotEquals(h, null) && d != null && h.value < this.worksheet.workbook.maxRowCount ? this.worksheet._rows$i.item(h.value) : null;
    if (d != null && nullableEquals(e, null) && g) {
      for (let l of fromEnum(d._ch(a, b, true))) {
        if (l.n) {
          let m = this._bc(l.r);
          m._setFormatting1(l.j, 1);
          if (k != null) {
            m._a3(m.formatOptions & ~8, true, -97);
            let n = k._a8(l.r);
            if (n != null) {
              if (WorkbookColorInfo.l_op_Inequality(n.leftBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(n.leftBorderColorInfo, l.j.leftBorderColorInfo) && n.leftBorderStyle == l.j.leftBorderStyle) {
                m._a9(n.leftBorderColorInfo, true, -97);
                m._ba(n.leftBorderStyle, true, -97);
              }
              if (WorkbookColorInfo.l_op_Inequality(n.rightBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(n.rightBorderColorInfo, l.j.rightBorderColorInfo) && n.rightBorderStyle == l.j.rightBorderStyle) {
                m._bd(n.rightBorderColorInfo, true, -97);
                m._be(n.rightBorderStyle, true, -97);
              }
              if (!c) {
                if (WorkbookColorInfo.l_op_Inequality(n.topBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(n.topBorderColorInfo, l.j.topBorderColorInfo) && n.topBorderStyle == l.j.topBorderStyle) {
                  m._bi(n.topBorderColorInfo, true, -97);
                  m._bj(n.topBorderStyle, true, -97);
                }
                if (WorkbookColorInfo.l_op_Inequality(n.bottomBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(n.bottomBorderColorInfo, l.j.bottomBorderColorInfo) && n.bottomBorderStyle == l.j.bottomBorderStyle) {
                  m._av(n.bottomBorderColorInfo, true, -97);
                  m._aw(n.bottomBorderStyle, true, -97);
                }
              }
            }
          }
        }
      }
    }
    else {
      let o = null;
      if (i != null && nullableNotEquals(h, null)) {
        o = this._a8(h.value);
      }
      for (let p = a; p <= b; p++) {
        let q = this._bc(p);
        q._ar();
        if (i != null) {
          q.setFormatting(i);
          if (nullableNotEquals(h, null)) {
            q._a3(q.formatOptions & ~8, true, -97);
            if (o != null) {
              if (WorkbookColorInfo.l_op_Inequality(o.topBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(o.topBorderColorInfo, i.topBorderColorInfo) && o.topBorderStyle == i.topBorderStyle) {
                q._bi(o.topBorderColorInfo, true, -97);
                q._bj(o.topBorderStyle, true, -97);
              }
              if (WorkbookColorInfo.l_op_Inequality(o.bottomBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(o.bottomBorderColorInfo, i.bottomBorderColorInfo) && o.bottomBorderStyle == i.bottomBorderStyle) {
                q._av(o.bottomBorderColorInfo, true, -97);
                q._aw(o.bottomBorderStyle, true, -97);
              }
              if (!c) {
                if (WorkbookColorInfo.l_op_Inequality(o.leftBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(o.leftBorderColorInfo, i.leftBorderColorInfo) && o.leftBorderStyle == i.leftBorderStyle) {
                  q._a9(o.leftBorderColorInfo, true, -97);
                  q._ba(o.leftBorderStyle, true, -97);
                }
                if (WorkbookColorInfo.l_op_Inequality(o.rightBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(o.rightBorderColorInfo, i.rightBorderColorInfo) && o.rightBorderStyle == i.rightBorderStyle) {
                  q._bd(o.rightBorderColorInfo, true, -97);
                  q._be(o.rightBorderStyle, true, -97);
                }
              }
            }
          }
        }
        else if (d != null) {
          let r = d._bc(p);
          q.setFormatting(r);
          if (k != null) {
            q._a3(q.formatOptions & ~8, true, -97);
            let s = k._a8(p);
            if (s != null) {
              if (WorkbookColorInfo.l_op_Inequality(s.leftBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(s.leftBorderColorInfo, r.leftBorderColorInfo) && s.leftBorderStyle == r.leftBorderStyle) {
                q._a9(s.leftBorderColorInfo, true, -97);
                q._ba(s.leftBorderStyle, true, -97);
              }
              if (WorkbookColorInfo.l_op_Inequality(s.rightBorderColorInfo, null) && WorkbookColorInfo.l_op_Equality(s.rightBorderColorInfo, r.rightBorderColorInfo) && s.rightBorderStyle == r.rightBorderStyle) {
                q._bd(s.rightBorderColorInfo, true, -97);
                q._be(s.rightBorderStyle, true, -97);
              }
            }
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _dg() {
    if (this._bq == null) {
      return;
    }
    let a = this.worksheet.workbook;
    if (a == null || a._c4) {
      return;
    }
    for (let b of fromEnum(this._bq._j)) {
      for (let c = 0; c < 32; c++) {
        let d = b[c];
        if (d != null) {
          a._ht(d);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _dh() {
    if (this._a3 != null) {
      this._a3._aj();
    }
  }
  /**
   * @hidden
   */
  _di(a = true, b = true) {
    if (this._b3 && this._b6) {
      return;
    }
    this._b3 = true;
    this._b6 = true;
    if (b) {
      this._dx();
    }
    if (a) {
      if (0 < this.index) {
        let c = this.worksheet._rows$i._aj(this.index - 1);
        if (c != null) {
          c._di(false, b);
        }
      }
      let d = Workbook.getMaxRowCount(this.worksheet._o) - 1;
      if (this.index < d) {
        let e = this.worksheet._rows$i._aj(this.index + 1);
        if (e != null) {
          e._di(false, b);
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _bs(a) {
    return (a & 570457729) != 0;
  }
  /**
   * @hidden
   */
  _bt(a) {
    return this._a2(a) != null || this._a8(a) != null;
  }
  /**
   * @hidden
   */
  _a1(a) {
    let b = (intDivide(a, 32));
    let c = this._co(b);
    if (c < 0) {
      let d = new WorksheetCellBlockHalf(b);
      this._dp(~c, d);
      return d;
    }
    return this._af[c];
  }
  /**
   * @hidden
   */
  *__cf() {
    if (this._af != null) {
      for (let a = 0; a < this._af.length; a++) {
        let b = this._af[a];
        if (b == null) {
          return undefined;
        }
        let c = b.w * 32;
        for (let d = 0; d < 32; d++) {
          let e = (c + d);
          if (b.j(e)) {
            yield new KeyValuePair$2(Number_$type, WorksheetCellBlock.$, 1, e, b);
          }
        }
      }
    }
  }
  _cf() {
    return toEnum(() => this.__cf());
  }
  /**
   * @hidden
   */
  _as(a) {
    let b = (intDivide(a, 32));
    let c = (a % 32);
    let d = this._br;
    let e = d._l(b);
    let f;
    if (e < 0) {
      f = new Array(32);
      d._m(b, f);
    }
    else {
      f = d._j._inner[e];
    }
    let g = f[c];
    if (g == null) {
      g = new CellCalcReference(this, a);
      f[c] = g;
    }
    return g;
  }
  /**
   * @hidden
   */
  _am(a, b = false) {
    let c = this._a2(a);
    let d = this._a8(a);
    let e = null;
    let f = this.worksheet.workbook;
    if (f != null) {
      e = f._ca._p;
    }
    let g = e;
    if (this._hasCellFormat) {
      g = this._cellFormatInternal.d;
    }
    return this._al(c, d, g, e, a, b);
  }
  /**
   * @hidden
   */
  _al(a, b, c, d, e, f = false) {
    let g = 0;
    let h = new WorksheetCellBlock_CellValue();
    let i = false;
    if (a != null) {
      let j = a.al(e, g, h, i);
      g = j.p1;
      h = j.p2;
      i = j.p3;
    }
    let k = false;
    if (b != null && b._ca(c) == false) {
      k = true;
    }
    else {
      let l = this._bl(e);
      if (l != null && l._hasCellFormat) {
        if (l._cellFormatInternal.d._ca(d) == false) {
          k = true;
        }
      }
    }
    if (f || k || i || g != 0) {
      return CellDataContext.b(e, a, b, k, g, h);
    }
    return null;
  }
  /**
   * @hidden
   */
  _aj(a) {
    let b = (intDivide(a, 32));
    let c = new WorksheetCellFormatBlock();
    let d = this._cp(b);
    if (d < 0) {
      c = new WorksheetCellFormatBlock(1, b, new Array(32));
      this._dq(~d, c);
    }
    else {
      c = this._ag[d];
    }
    return c.a;
  }
  /**
   * @hidden
   */
  _bc(a) {
    let b = this._aj(a);
    return this._bb(b, a);
  }
  /**
   * @hidden
   */
  _bb(a, b) {
    let c = b % 32;
    let d = a[c];
    let e;
    if (d == null) {
      let f = this.worksheet.workbook;
      let g = f == null ? null : f._ca;
      if (g == null) {
        d = new WorksheetCellFormatData(null, 0);
      }
      else {
        d = f._ca._p._bu();
      }
      this._dk(b, d);
      e = new WorksheetCellOwnedFormatProxy(d, g, this, b, a);
      a[c] = e._bt;
      if (this._a3 != null) {
        this._a3._aj();
      }
    }
    else {
      e = this._be(b, d, a, false);
    }
    return e;
  }
  /**
   * @hidden
   */
  _c7(a, b, c, d = false, e = false) {
    return WorksheetCell._getCellAddressString1(this, a, b, c, d, e);
  }
  /**
   * @hidden
   */
  _a7(a) {
    return this.worksheet._b4(this, a);
  }
  /**
   * @hidden
   */
  _be(a, b, c, d) {
    let e = null;
    let f = this.worksheet.workbook;
    if (f != null) {
      e = f._ca;
    }
    let g = new WorksheetCellOwnedFormatProxy(null, e, this, a, c);
    g._bt = b;
    return g;
  }
  /**
   * @hidden
   */
  _dj(a, b, c) {
    if (this._by) {
      let d = this._ah;
      let e = (intDivide(a, 32));
      let f = this._cp(e);
      let g = a % 32;
      if (f < 0) {
        f = ~f;
        g = 0;
      }
      let h = (intDivide(b, 32));
      let i = this._cp(h);
      let j = (b % 32) + 1;
      if (i < 0) {
        i = ~i - 1;
        j = 32;
      }
      for (let k = f; k <= i; k++) {
        let l = d[k].a;
        if (l != null) {
          let m = 0;
          let n = 32;
          if (k == f) {
            m = g;
          }
          if (k == i) {
            n = j;
          }
          for (; m < n; m++) {
            let o = l[m];
            if (o != null) {
              let p = (k * 32 + m);
              c(this, o, p);
            }
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _bv(a) {
    let b = (intDivide(a, 32));
    let c = this._a2(a);
    if (c == null) {
      return false;
    }
    return c.r(a);
  }
  /**
   * @hidden
   */
  *__ch(a = 0, b = 0x7FFFFFFF, c = false) {
    let d = this._af;
    let e = -1;
    b = Math.min(b, this.worksheet.workbook.maxColumnCount - 1);
    let f = null;
    let g = null;
    let h = this.worksheet.workbook;
    if (h != null) {
      if (this._by) {
        f = getEnumerator(this._ah);
      }
      g = h._ca._p;
    }
    let i = g;
    if (this._hasCellFormat) {
      i = this._cellFormatInternal.d;
    }
    let j = null;
    let k = Nullable$1.toNullable(WorksheetCellFormatBlock.$, null);
    while (d != null || f != null) {
      if (j == null && d != null) {
        if (++e < this._af.length) {
          j = this._af[e];
        }
        if (j == null) {
          d = null;
        }
      }
      if (nullableEquals(k, null) && f != null) {
        if (f.moveNext() && f.current.a != null) {
          k = Nullable$1.toNullable(WorksheetCellFormatBlock.$, f.current);
        }
        else {
          f.dispose();
          f = null;
        }
      }
      let l = 32767;
      if (j != null) {
        l = Math.min(l, j.w);
      }
      if (k.hasValue) {
        l = Math.min(l, k.value.b);
      }
      let m = null;
      if (j != null && j.w == l) {
        m = j;
        j = null;
      }
      let n = null;
      if (k.hasValue && k.value.b == l) {
        n = k.value.a;
        k = Nullable$1.toNullable(WorksheetCellFormatBlock.$, null);
      }
      let o = l * 32;
      if (b < o) {
        return undefined;
      }
      for (let p = Math.max(0, a - o); p < 32; p++) {
        let q = (o + p);
        if (b < q) {
          return undefined;
        }
        let r = this._al(m, n == null ? null : n[p], i, g, q);
        if (r == null) {
          continue;
        }
        yield r;
        m = r.d;
        if (r.l && n != null) {
          n[p] = null;
        }
        if (c) {
          r.u();
        }
      }
    }
  }
  _ch(a = 0, b = 0x7FFFFFFF, c = false) {
    return toEnum(() => this.__ch(a, b, c));
  }
  /**
   * @hidden
   */
  static _c2(a, b) {
    if (a == null) {
      return null;
    }
    return a._c5(b);
  }
  /**
   * @hidden
   */
  _c4(a, b) {
    let c = this._a2(a);
    if (c == null) {
      return null;
    }
    if (b) {
      return c.aa(this, a);
    }
    return c.z(this, a);
  }
  /**
   * @hidden
   */
  _c6(a) {
    return this._c4(a, true);
  }
  /**
   * @hidden
   */
  *__ci(a) {
    if (this._bq != null) {
      if (a) {
        for (let b of fromEnum(this._bq)) {
          let c = b.key * 32;
          let d = b.value;
          for (let e = 0; e < 32; e++) {
            let f = d[e];
            if (f == null) {
              continue;
            }
            yield (c + e);
          }
        }
      }
      else {
        for (let g = this._bq._k - 1; g >= 0; g--) {
          let h = this._bq._h._inner[g] * 32;
          let i = this._bq._j._inner[g];
          for (let j = 32 - 1; j >= 0; j--) {
            let k = i[j];
            if (k == null) {
              continue;
            }
            yield (h + j);
          }
        }
      }
    }
  }
  _ci(a) {
    return toEnum(() => this.__ci(a));
  }
  /**
   * @hidden
   */
  _dv(a, b) {
    if (this._bq != null) {
      for (let c of fromEnum(this._bq._j)) {
        for (let d = 0; d < c.length; d++) {
          let e = c[d];
          if (e == null) {
            continue;
          }
          let f;
          if (((() => { let g = b.tryGetValue(new WorksheetCellAddress(1, this._cx, e._ao), f); f = g.p1; return g.ret; })())) {
            let g = new FormulaContext(3, a.workbook, a, this, e._ao, f);
            f._b5(g);
            e._a0(f, true);
            a.workbook._ht(e);
          }
        }
      }
    }
    if (this._hasCellFormat) {
      this._cellFormatInternal.h(a.workbook._ca);
    }
    this._dy(a.workbook._ca);
    let h = a.workbook._bj;
    let i = a.workbook._bh(false);
    for (let j of fromEnum(this._cf())) {
      let k = j.value;
      let l = j.key;
      let m;
      let n = new WorksheetCellBlock_CellValue();
      let o;
      let p = k.al(l, m, n, o);
      m = p.p1;
      n = p.p2;
      o = p.p3;
      if (m == 6 || m == 5) {
        if (i != null) {
          let q = i._o(n.c, n.h);
          let r = q.g(h._d);
          let s = null;
          let t = GenericCacheElement.o(StringElement.$, h, s, r);
          s = t.p1;
          r = t.p2;
          k.av(l, r);
        }
        else {
        }
      }
      let u = k.aa(this, l);
      let v = typeCast(IFormattedString_$type, u);
      if (v != null) {
        v.setWorkbook(a.workbook);
      }
    }
  }
  /**
   * @hidden
   */
  _dn(a, b) {
    let c = this.worksheet;
    if (a < 0) {
      this._d7(64, true);
    }
    else {
      this._cw = a;
    }
    this._cc = c != null ? c._rows$i._k : 0;
  }
  /**
   * @hidden
   */
  _c0(a, b) {
    if (this._by) {
      let c = (intDivide(b, 32));
      let d = this._ah;
      let e = this._cp(c);
      let f = this.worksheet != null ? this.worksheet._b3 : null;
      if (e >= 0) {
        let g = d[e];
        let h = b % 32;
        for (let i = h; i >= 0; i--) {
          if (g.a[i] != null && !Base.equalsStatic(f, g.a[i])) {
            return Nullable$1.toNullable(Number_$type, g.b * 32 + i);
          }
        }
      }
      else {
        e = ~e;
      }
      let j = (intDivide(a, 32));
      let k = this._cp(j);
      if (k < 0) {
        k = ~k;
      }
      for (let l = e - 1; l >= k; l--) {
        let m = d[l];
        for (let n = 32 - 1; n >= 0; n--) {
          if (m.a[n] != null && !Base.equalsStatic(f, m.a[n])) {
            let o = m.b * 32 + n;
            if (o > a) {
              return Nullable$1.toNullable(Number_$type, o);
            }
            return Nullable$1.toNullable(Number_$type, null);
          }
        }
      }
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  _ck(a, b, c = Nullable$1.toNullable(HorizontalCellAlignment_$type, null)) {
    let d = Nullable$1.toNullable(Number_$type, a);
    do {
      d = this._c1(d.value, true);
      if (nullableEquals(d, null) || nullableGreaterThan(d, b)) {
        break;
      }
    } while (this.worksheet._cb(d.value).i);
    let e;
    if (nullableNotEquals(d, null)) {
      e = Math.min(b, d.value - 1);
    }
    else {
      e = b;
    }
    for (let f = (a + 1), g = e; f <= g; f++) {
      if (this.worksheet._cr(this.index, f) != null) {
        e = f - 1;
        break;
      }
      let h = this.worksheet._cb(f);
      if (h.i) {
        f = h.r;
      }
      else if (nullableNotEquals(c, null)) {
        let i = this._a7(f);
        if (nullableNotEquals(i._a4, c)) {
          e = f - 1;
          break;
        }
      }
    }
    return e;
  }
  /**
   * @hidden
   */
  _c1(a, b) {
    if (this._af == null || this.worksheet == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    let c;
    let d;
    let e = (intDivide(a, 32));
    let f = this._co(e);
    if (b) {
      let g = (h, i) => {
        let j = ((h.w * 32) + i);
        for (; i < 32; j++ , i++) {
          if (h.j(j)) {
            return Nullable$1.toNullable(Number_$type, j);
          }
        }
        return Nullable$1.toNullable(Number_$type, null);
      };
      if (0 <= f) {
        let h = this._af[f];
        let i = a % 32;
        c = g(h, i + 1);
        if (nullableNotEquals(c, null)) {
          return c;
        }
        d = f + 1;
      }
      else {
        d = ~f;
      }
      for (let j = d; j < this._af.length && this._af[j] != null; j++) {
        c = g(this._af[j], 0);
        if (nullableNotEquals(c, null)) {
          return c;
        }
      }
    }
    else {
      let k = (l, m) => {
        let n = ((l.w * 32) + m);
        for (; m >= 0; n-- , m--) {
          if (l.j(n)) {
            return Nullable$1.toNullable(Number_$type, n);
          }
        }
        return Nullable$1.toNullable(Number_$type, null);
      };
      if (0 <= f) {
        let l = this._af[f];
        let m = a % 32;
        c = k(l, m - 1);
        if (nullableNotEquals(c, null)) {
          return c;
        }
        d = f - 1;
      }
      else {
        d = (~f) - 1;
      }
      for (let n = d; n >= 0; n--) {
        c = k(this._af[n], 32 - 1);
        if (nullableNotEquals(c, null)) {
          return c;
        }
      }
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  _ct(a = false) {
    if (a == false && this.hidden) {
      return 0;
    }
    if (this._m) {
      return 0;
    }
    if (this._cn < 0) {
      let b = this._cs(true);
      if (0 <= b) {
        this._cn = b;
      }
      else {
        this._cn = this._cj();
      }
    }
    return this._cn;
  }
  /**
   * @hidden
   */
  _dm(a) {
    this._cl = a._cl;
    this._ce = a._ce;
    this._bn = a._bn & 32;
    if (a._hasCellFormat) {
      let b = a.worksheet != null ? a.worksheet.workbook : null;
      let c = false;
      if (b != null) {
        c = b._df;
        b._df = true;
      }
      let d = WorksheetRow._bm;
      WorksheetRow._bm = this;
      try {
        this._cellFormatInternal._setFormatting1(a._cellFormatInternal.d, -97);
        this._cellFormatInternal._a3(this._cellFormatInternal.formatOptions & ~8, true, -97);
      }
      finally {
        WorksheetRow._bm = d;
      }
      if (b != null) {
        b._df = c;
      }
    }
  }
  /**
   * @hidden
   */
  _ds(a, b, c) {
    if (this._a3 != null) {
      this._a3._aj();
    }
    if ((c & 64) == 0 && WorksheetRow._bs(b)) {
      this._dx();
    }
    let d = null;
    if ((c & 2) == 0) {
      d = this._bl(a._bv);
    }
    let e = new Dictionary$2(CellFormatValue_$type, WorksheetCellFormatProxy.$, 1, 8);
    let f = this._a2(a._bv);
    for (let g = 1; g != 1073741824; g = (g << 1)) {
      if ((b & g) == 0) {
        continue;
      }
      switch (g) {
        case 1:
        case 8:
        case 16:
        case 32:
        case 64:
        case 65536:
        case 131072:
        case 1048576:
        case 8388608:
        case 16777216:
        case 268435456:
        case 536870912:
        case 32768:
          if (d != null) {
            ExcelUtils.fb(a, d._cellFormatInternal, g);
          }
          break;
        case 33554432:
          {
            if (d != null) {
              ExcelUtils.fb(a, d._cellFormatInternal, g);
            }
            let h = a.style;
            if (h != null && ExcelUtils.bx(h._i.formatOptions, 4)) {
              if (f != null && (c & 16) == 0) {
                let i = typeCast(FormattedStringElement.$, f.c(this, a._bv));
                if (i != null) {
                  i._ai();
                }
              }
            }
          }
          break;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
          {
            if (d != null) {
              ExcelUtils.fb(a, d._cellFormatInternal, g);
            }
            if (f != null && (c & 16) == 0) {
              let j = f.c(this, a._bv);
              if (j != null && j._u) {
                let k = this.worksheet.workbook;
                let l = k != null ? k._bj : null;
                let m = GenericCacheElement.i(StringElement.$, l, j, true);
                j = m.p1;
                let n = j;
                for (let o of fromEnum(n._ah)) {
                  if (o.h == false) {
                    continue;
                  }
                  let p = o.d(k);
                  switch (g) {
                    case 128:
                      p._bold$i = a.font._bold$i;
                      break;
                    case 256:
                      p.colorInfo = a.font.colorInfo;
                      break;
                    case 512:
                      p.height = a.font.height;
                      break;
                    case 1024:
                      p._italic$i = a.font._italic$i;
                      break;
                    case 2048:
                      p.name = a.font.name;
                      break;
                    case 4096:
                      p._strikeout$i = a.font._strikeout$i;
                      break;
                    case 8192:
                      p.superscriptSubscriptStyle = a.font.superscriptSubscriptStyle;
                      break;
                    case 16384:
                      p.underlineStyle = a.font.underlineStyle;
                      break;
                    default: break;
                  }
                }
                let q = GenericCacheElement.h(StringElement.$, l, j);
                j = q.p1;
                f.av(a._bv, j);
              }
            }
          }
          break;
        case 2:
        case 4:
        case 262144:
        case 524288:
        case 2097152:
        case 4194304:
        case 67108864:
        case 134217728:
          {
            if (g == 4 || g == 134217728) {
              this._ei(a, g);
              this._di(void 0, (c & 64) == 0);
            }
            if (d != null) {
              d._a7(this, a._bv, g);
            }
            if ((c & 1) != 0) {
              break;
            }
            if (a._aa(g)) {
              break;
            }
            let r;
            if (((() => { let s = e.tryGetValue(g, r); r = s.p1; return s.ret; })()) == false) {
              r = this._ba(a._bv, g, this.worksheet._o);
              e.item(g, r);
              e.item(ExcelUtils.m(g), r);
            }
            if (r == null) {
              break;
            }
            ExcelUtils.gc(a, r, g, a._aj(g), c);
          }
          break;
        default: break;
      }
    }
    if (f != null && f.r(a._bv)) {
      let s = this._bp(a._bv);
      if (s != null && s._cv == false) {
        let t = a._bv - s._by._w;
        if (t < 0 || s._columns$i.count <= t) {
        }
        else {
          let u = b;
          let v = this.worksheet.workbook;
          let w = s._columns$i._item(t);
          let x = w.headerCell;
          if (WorksheetCell.l_op_Inequality(x, null) && x._o == this && x.columnIndex == a._bv) {
            u &= ~67108864;
            u &= ~134217728;
            ExcelUtils.fc(a, w._areaFormats$i._d(v, 1), u);
          }
          else {
            let y = w.totalCell;
            if (WorksheetCell.l_op_Inequality(y, null) && y._o == this && y.columnIndex == a._bv) {
              u &= ~2;
              u &= ~4;
              ExcelUtils.fc(a, w._areaFormats$i._d(v, 2), u);
            }
            else {
            }
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _x() {
    super._x();
    this._cells$i._ab();
  }
  /**
   * @hidden
   */
  _dr(a, b) {
    this._cc = b;
    this._t(a);
    this._d7(64, false);
  }
  /**
   * @hidden
   */
  _dt(a, b) {
    this._dv(a, b);
  }
  /**
   * @hidden
   */
  _du(a) {
    this._cc = 0;
    this._d7(64, true);
    this._ea(this.worksheet.workbook._bj, a);
    this._t(null);
  }
  /**
   * @hidden
   */
  _dw(a, b) {
    let c = (intDivide(a, 32));
    let d = this._co(c);
    if (d < 0) {
      this._dp(~d, b);
    }
    else {
      this._af[d] = b;
    }
  }
  /**
   * @hidden
   */
  _dx(a = true) {
    if (this._cn < 0) {
      return;
    }
    let b = null;
    if (a && this.worksheet._dz(true)) {
      b = WorksheetElementResizeContext.b(this);
    }
    this._cn = -1;
    this.worksheet._rows$i._a0(this.index, false);
    if (b != null) {
      b.y();
    }
  }
  /**
   * @hidden
   */
  _dy(a) {
    if (this._by == false) {
      return;
    }
    let d = this._ah;
    for (let c = 0; c < d.length; c++) {
      let b = d[c];
      let e = b.a;
      if (e == null) {
        break;
      }
      let f = b.b * 32;
      for (let g = 0; g < 32; g++) {
        if (e[g] == null) {
          continue;
        }
        let h = GenericCacheElementEx.ad(WorksheetCellFormatData.$, a, e[g]);
        e[g] = h.p1;
      }
    }
  }
  /**
   * @hidden
   */
  _dz(a, b) {
    let c = new WorksheetCellAddress(1, this.index, a);
    if (b == null) {
      if (this.worksheet._d1) {
        this.worksheet._es.removeItem(c);
      }
    }
    else {
      this.worksheet._es.item(c, b);
    }
  }
  /**
   * @hidden
   */
  _d0(a, b, c = false) {
    let d = this._as(a);
    d.value = b;
    let e = this.worksheet.workbook;
    if (e == null) {
      return;
    }
    e._w.aq(d, c);
  }
  /**
   * @hidden
   */
  _d3(a, b) {
    let c = (intDivide(a, 32));
    let d = a % 32;
    let e = new WorksheetCellFormatBlock();
    let f = this._cp(c);
    if (f < 0) {
      e = new WorksheetCellFormatBlock(1, c, new Array(32));
      this._dq(~f, e);
    }
    else {
      e = this._ag[f];
    }
    let g = e.a[d];
    if (g != null) {
      this._be(a, g, e.a, true).setFormatting(b);
      return;
    }
    this._dd(a, e.a, d, b);
  }
  /**
   * @hidden
   */
  _d4(a, b) {
    let c = (intDivide(a, 32));
    let d;
    if (b == false) {
      d = this._a2(a);
    }
    else {
      d = this._a1(a);
    }
    if (d != null) {
      let e;
      let f = d.as(this, a, b, e);
      e = f.p3;
    }
  }
  /**
   * @hidden
   */
  _d6(a, b, c = true) {
    let d = (intDivide(a, 32));
    let e;
    if (b == null) {
      e = this._a2(a);
      if (e == null) {
        this._ed(a, b, true);
        return;
      }
    }
    else {
      e = this._a1(a);
    }
    let f;
    let g = e.ao(this, a, b, f, c);
    f = g.p3;
  }
  /**
   * @hidden
   */
  _d9(a, b) {
    if (b != null) {
      if (b.firstRow != this.index || b._v != a) {
        this._d2(a, null);
        this._d6(a, null);
      }
    }
    else {
    }
    this._dz(a, b);
  }
  /**
   * @hidden
   */
  _a2(a) {
    if (a < 0 || this._af == null) {
      return null;
    }
    let b = (intDivide(a, 32));
    let c = this._co(b);
    if (c < 0) {
      return null;
    }
    return this._af[c];
  }
  /**
   * @hidden
   */
  _at(a, b = false) {
    if (b == false && this._bq == null) {
      return null;
    }
    let c = (intDivide(a, 32));
    let d = this._br;
    let e = d._l(c);
    let f;
    if (e < 0) {
      if (b == false || this._bu(a) == false) {
        return null;
      }
      f = new Array(32);
      d._m(c, f);
    }
    else {
      f = d._j._inner[e];
    }
    let g = (a % 32);
    let h = f[g];
    if (h == null && b && this._bu(a)) {
      h = new CellCalcReference(this, a);
      f[g] = h;
    }
    return h;
  }
  /**
   * @hidden
   */
  _a8(a) {
    let b = this._ak(a);
    return this._a9(a, b);
  }
  /**
   * @hidden
   */
  _bd(a) {
    let b = this._ak(a);
    let c = this._a9(a, b);
    if (c != null) {
      return this._be(a, c, b, true);
    }
    return null;
  }
  /**
   * @hidden
   */
  _ak(a) {
    if (this._ag == null || a < 0) {
      return null;
    }
    let b = (intDivide(a, 32));
    let c = this._cp(b);
    if (c < 0) {
      return null;
    }
    return this._ag[c].a;
  }
  /**
   * @hidden
   */
  _a9(a, b) {
    if (b != null) {
      let c = (a % 32);
      return b[c];
    }
    return null;
  }
  /**
   * @hidden
   */
  _eb() {
    if (this._by == false) {
      return;
    }
    let c = this._ah;
    for (let b = 0; b < c.length; b++) {
      let a = c[b];
      let d = a.a;
      if (d == null) {
        break;
      }
      let e = a.b * 32;
      for (let f = 0; f < 32; f++) {
        let g = d[f];
        if (g == null) {
          continue;
        }
        GenericCacheElementEx.q(WorksheetCellFormatData.$, g);
        if (g.f > 0) {
          d[f] = g._bu();
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ea(a, b = null) {
    if (this._hasCellFormat) {
      this._cellFormatInternal.i();
    }
    this._eb();
    let c = b != null && a._d._cx ? a._d._bh(true) : null;
    for (let d of fromEnum(this._cf())) {
      let e = d.value;
      let f = d.key;
      let g;
      let h = new WorksheetCellBlock_CellValue();
      let i = ((() => { let j = e.ac(this, f, g, h); g = j.p2; h = j.p3; return j.ret; })());
      let j = ExcelUtils.aa(i);
      if (j != null) {
        let k = typeCast(IFormattedString_$type, i);
        if (k != null) {
          k.setWorkbook(null);
          j = ExcelUtils.aa(k);
        }
        else {
          let l = a;
          let m = GenericCacheElement.o(StringElement.$, null, l, j);
          l = m.p1;
          j = m.p2;
        }
        if (g == 6 || g == 5) {
          if (c != null) {
            let n;
            let o = c._k(j.g(null), n);
            n = o.p1;
            j = n;
          }
          e.av(f, j);
        }
      }
    }
    if (this._bq != null) {
      for (let p of fromEnum(this._bq._j)) {
        for (let q = 0; q < p.length; q++) {
          let r = p[q];
          if (r == null) {
            continue;
          }
          let s = r._formula;
          if (s != null) {
            if (b != null) {
              b.addItem(new WorksheetCellAddress(1, this._cx, r._ao), s);
            }
            if (s._cj) {
              s._i._bu();
            }
            r._a0(null, false);
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ec(a, b) {
    let c = this._a2(a);
    if (c == null) {
      return;
    }
    c.av(a, b);
  }
  /**
   * @hidden
   */
  _ed(a, b, c, d = false) {
    let e = typeCast(SingleTargetFormula.$, b);
    let f;
    if (e == null) {
      f = this._at(a);
    }
    else {
      f = this._as(a);
    }
    if (f != null) {
      f._a0(e, c, void 0, d);
    }
    let g = this.worksheet.workbook;
    if (g == null || g._c4) {
      return;
    }
    let h = (intDivide(a, 32));
    let i = f;
    if (i == null) {
      i = CellCalcReference._bd(this, a);
    }
    g._ht(i);
    if (f == null) {
      if (i._ag) {
        let j = (a % 32);
        let k = this._br._l(h);
        let l;
        if (0 <= k) {
          l = this._br._j._inner[k];
        }
        else {
          l = new Array(32);
          this._br._m(h, l);
        }
        l[j] = i;
      }
      else {
        i._bg();
      }
    }
  }
  /**
   * @hidden
   */
  _a0(a, b, c) {
    let d = false;
    if (this._hasCellFormat && !this._cellFormatInternal._z) {
      d = true;
    }
    else if (this._bz) {
      d = true;
    }
    if (this._af != null) {
      let e = false;
      for (let f = 0; f < this._af.length; f++) {
        let g = this._af[f];
        if (g == null) {
          break;
        }
        let h = g.w * 32;
        if (d) {
          if (h + 32 <= b) {
            continue;
          }
          else if (h > c) {
            break;
          }
        }
        for (let i = 0; i < 32; i++) {
          let j = (h + i);
          if (g.j(j)) {
            if (!e) {
              d = true;
              if (j > c) {
                break;
              }
              e = true;
              if (j >= a.a) {
                break;
              }
              if (j >= b) {
                a.a = j;
                if (j > a.b) {
                  a.b = j;
                }
                break;
              }
            }
          }
        }
      }
      if (e) {
        for (let k = (this._af.length - 1); k >= 0; k--) {
          let l = this._af[k];
          if (l == null) {
            continue;
          }
          let m = l.w * 32;
          if (m > c) {
            continue;
          }
          if (m + 32 <= a.b) {
            break;
          }
          for (let n = 32 - 1; n >= 0; n--) {
            let o = (m + n);
            if (o > c) {
              continue;
            }
            if (l.j(o)) {
              if (o > a.b) {
                a.b = o;
              }
              break;
            }
          }
        }
      }
    }
    if (this._by) {
      let p = this._ah;
      for (let q = 0; q < p.length; q++) {
        let r = p[q];
        let s = r.a;
        if (s != null) {
          let t = r.b * 32;
          if (t > a.a || t > c) {
            break;
          }
          for (let u = 0; u < 32; u++) {
            if (s[u] != null && !s[u]._cd) {
              let v = t + u;
              if (v >= b) {
                if (v < a.a) {
                  a.a = v;
                }
                break;
              }
            }
          }
        }
      }
      let w = this._c0(a.b, c);
      if (nullableNotEquals(w, null)) {
        d = true;
        a.b = w.value;
      }
      if (!d && b < a.b) {
        let x = this._c0(b, a.b);
        if (nullableNotEquals(x, null)) {
          d = true;
        }
      }
    }
    return d ? a : null;
  }
  /**
   * @hidden
   */
  _cb() {
    if (this._b3 == false && this._b6 == false) {
      return false;
    }
    this._ee();
    return true;
  }
  /**
   * @hidden
   */
  _co(a) {
    if (this._af == null) {
      return -1;
    }
    let b = 0;
    let c = this._af.length - 1;
    while (b <= c) {
      let d = b + (intDivide((c - b), 2));
      let e = this._af[d];
      if (e == null) {
        c = d - 1;
        continue;
      }
      let f = e.w - a;
      if (f == 0) {
        return d;
      }
      if (f < 0) {
        b = d + 1;
      }
      else {
        c = d - 1;
      }
    }
    return ~b;
  }
  /**
   * @hidden
   */
  _cp(a) {
    if (this._ag == null) {
      return -1;
    }
    let b = 0;
    let c = this._ag.length - 1;
    while (b <= c) {
      let d = b + (intDivide((c - b), 2));
      let e = this._ag[d];
      if (e.a == null) {
        c = d - 1;
        continue;
      }
      let f = e.b - a;
      if (f == 0) {
        return d;
      }
      if (f < 0) {
        b = d + 1;
      }
      else {
        c = d - 1;
      }
    }
    return ~b;
  }
  /**
   * @hidden
   */
  _dd(a, b, c, d) {
    let e = this.worksheet.workbook;
    let f = e != null ? e._ca : null;
    if (d == null) {
      if (f == null) {
        return;
      }
      d = f._p._bu();
    }
    b[a % 32] = GenericCacheElementEx.r(WorksheetCellFormatData.$, d, f);
    if (this._cs(true) < 0 && 0 <= this._cn && f != null && WorksheetCellFormatProxy._y(d, f._p, 570457729)) {
      this._dx();
    }
  }
  /**
   * @hidden
   */
  static _ao($tValue, a, b, c, d = null, e = true, f = false, g = 0) {
    return new ChangeInfo$2(WorksheetRow.$, $tValue, a, 60, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _ai() {
    let a = new Array(3);
    RowColumnBase._z(a, 60);
    ChangeInfo.f(a, 2, WorksheetRow._ao(Number_$type, "Height", (b) => b.height, (b, c) => b.height = c, (b, c) => b._d8(c)));
    return a;
  }
  /**
   * @hidden
   */
  _bu(a) {
    let b = this._a2(a);
    return b != null && b.j(a);
  }
  /**
   * @hidden
   */
  _ba(a, b, c) {
    let d = null;
    let e = 0;
    switch (b) {
      case 2:
      case 4:
        if ((this.index + 1) < Workbook.getMaxRowCount(c)) {
          d = this.worksheet._rows$i._aj(this.index + 1);
          e = a;
        }
        break;
      case 262144:
      case 524288:
        if (a > 0) {
          d = this;
          e = (a - 1);
        }
        break;
      case 2097152:
      case 4194304:
        if ((a + 1) < Workbook.getMaxColumnCount(c)) {
          d = this;
          e = (a + 1);
        }
        break;
      case 67108864:
      case 134217728:
        if (this.index > 0) {
          d = this.worksheet._rows$i._aj(this.index - 1);
          e = a;
        }
        break;
    }
    if (d == null) {
      return null;
    }
    return d._bd(e);
  }
  /**
   * @hidden
   */
  *__cg(a) {
    let d = this._ah;
    for (let c = 0; c < d.length; c++) {
      let b = d[c];
      let e = b.a;
      if (e == null) {
        break;
      }
      let f = b.b * 32;
      for (let g = 0; g < 32; g++) {
        let h = e[g];
        if (h == null) {
          continue;
        }
        let i = (f + g);
        yield new CellFormatContext(i, h, e);
      }
    }
  }
  _cg(a) {
    return toEnum(() => this.__cg(a));
  }
  /**
   * @hidden
   */
  _bw(a) {
    return (this._bn & a) == a;
  }
  /**
   * @hidden
   */
  _dk(a, b) {
    let c = this.worksheet;
    let d = c._cb(a);
    let e = d.b;
    if (!WorksheetRow._b7(b, this, 33554432)) {
      if (!WorksheetRow._b8(b, e, 33554432)) {
      }
    }
    for (let f = 1; f != 1073741824; f = (f << 1)) {
      if (f == 32768 || f == 33554432) {
        continue;
      }
      if (WorksheetRow._b7(b, this, f)) {
        continue;
      }
      if (WorksheetRow._b8(b, e, f)) {
        continue;
      }
    }
  }
  /**
   * @hidden
   */
  _dl(a, b) {
    let c = 150;
    let d = 120;
    let e = 2160;
    let f = 1185;
    let g = 240;
    let h = 30;
    let i = this.worksheet;
    let j = i._o;
    let k = Workbook.getMaxRowCount(j);
    let l = Workbook.getMaxColumnCount(j);
    let m = this._el(a);
    let n = truncate(m.right) + g;
    let o = Math.max(h, truncate(m.top) - c);
    let p = i._rows$i.item(0)._el((l - 1));
    let q = truncate(p.right);
    if (n + e + h > q) {
      n = truncate(m.left) - g - e;
    }
    let r = i._rows$i.item(k - 1)._el(0);
    let s = truncate(r.bottom);
    if (o + f + h > s) {
      let t = truncate(Math.min(s - h, m.top + d));
      o = t - f;
    }
    let u = new Rect(0, n, o, e, f);
    b._setBoundsInTwips(i, u);
  }
  /**
   * @hidden
   */
  _dp(a, b) {
    if (this._af == null) {
      this._af = [b];
      return;
    }
    if (this._af[this._af.length - 1] == null) {
      arrayCopy1(this._af, a, this._af, a + 1, this._af.length - a - 1);
      this._af[a] = b;
      return;
    }
    let c = new Array(this._af.length * 2);
    arrayCopy2(this._af, c, a);
    c[a] = b;
    arrayCopy1(this._af, a, c, a + 1, this._af.length - a);
    this._af = c;
  }
  /**
   * @hidden
   */
  _dq(a, b) {
    if (this._ag == null) {
      this._ag = [b];
      return;
    }
    if (this._ag[this._ag.length - 1].a == null) {
      arrayCopy1(this._ag, a, this._ag, a + 1, this._ag.length - a - 1);
      this._ag[a] = b;
      return;
    }
    let c = new Array(this._ag.length * 2);
    arrayCopy2(this._ag, c, a);
    c[a] = b;
    arrayCopy1(this._ag, a, c, a + 1, this._ag.length - a);
    for (let d = this._ag.length + 1; d < c.length; d++) {
      c[d] = new WorksheetCellFormatBlock();
    }
    this._ag = c;
  }
  /**
   * @hidden
   */
  static _b7(a, b, c) {
    if (b.hasCellFormat == false) {
      return false;
    }
    return WorksheetRow._b8(a, b.cellFormatInternal.d, c);
  }
  /**
   * @hidden
   */
  static _b8(a, b, c) {
    if (WorksheetCellFormatData._cf(c, b._dd(c))) {
      return false;
    }
    ExcelUtils.e9(b, a, c);
    return true;
  }
  /**
   * @hidden
   */
  _d7(a, b) {
    if (b) {
      this._bn |= a;
    }
    else {
      this._bn &= ~a;
    }
  }
  /**
   * @hidden
   */
  _ee() {
    let a = 0;
    let b = 0;
    let c = Workbook.getMaxRowCount(this.worksheet._o);
    let d = Workbook.getMaxColumnCount(this.worksheet._o);
    let e = 0 < this.index;
    let f = e ? this.worksheet._rows$i._aj(this.index - 1) : null;
    let g = this.index < c - 1;
    let h = g ? this.worksheet._rows$i._aj(this.index + 1) : null;
    let i = this._ef(a, b, d);
    a = i.p0;
    b = i.p1;
    if (a == 0) {
      let j = this._eg(f, a, d, (j) => j._al);
      a = j.p1;
    }
    if (b == 0) {
      let k = this._eg(h, b, d, (k) => k._ap);
      b = k.p1;
    }
    this._b4 = a == 2;
    this._b1 = b >= 1;
    if (e) {
      let l = f != null ? f._b2 : this.worksheet._ds;
      let m = a >= 1;
      if (l != m) {
        this.worksheet._rows$i.item(this.index - 1)._b1 = m;
      }
    }
    if (g) {
      let n = h != null ? h._b5 : this.worksheet._dt;
      let o = b == 2;
      if (n != o) {
        this.worksheet._rows$i.item(this.index + 1)._b4 = o;
      }
    }
  }
  /**
   * @hidden
   */
  _ef(a, b, c) {
    let d = false;
    let e = 0;
    let f = null;
    let g = !this._hasCellFormat && this.worksheet != null;
    let j = this._ah;
    for (let i = 0; i < j.length; i++) {
      let h = j[i];
      if (h.a == null) {
        break;
      }
      let k = h.b * 32;
      if (k != e) {
        if (g && (f == null || f.r < e)) {
          while (e < c) {
            f = this.worksheet._cb(e);
            a = ExcelUtils.i(a, ExcelUtils.h(f.b._ap));
            b = ExcelUtils.i(b, ExcelUtils.h(f.b._al));
            if (f.r >= k) {
              break;
            }
            e = f.r + 1;
          }
        }
        else {
          d = true;
        }
      }
      let l = h.a;
      for (let m = 0; m < 32; m++) {
        if (l[m] == null) {
          if (g && (f == null || f.r < m + k)) {
            f = this.worksheet._cb((m + k));
            a = ExcelUtils.i(a, ExcelUtils.h(f.b._ap));
            b = ExcelUtils.i(b, ExcelUtils.h(f.b._al));
          }
          else {
            d = true;
          }
        }
        else {
          if (a != 2) {
            a = ExcelUtils.i(a, ExcelUtils.h(l[m]._ap));
          }
          if (b != 2) {
            b = ExcelUtils.i(b, ExcelUtils.h(l[m]._al));
          }
        }
        if (a == 2 && b == 2) {
          break;
        }
      }
      if (a == 2 && b == 2) {
        break;
      }
      e = k + 32;
    }
    if (e != c) {
      d = true;
    }
    if (d) {
      if (!g) {
        if (a != 2) {
          a = ExcelUtils.i(a, ExcelUtils.h(this._cellFormatInternal.d._ap));
        }
        if (b != 2) {
          b = ExcelUtils.i(b, ExcelUtils.h(this._cellFormatInternal.d._al));
        }
      }
      else if (e < c) {
        do {
          f = this.worksheet._cb(e);
          a = ExcelUtils.i(a, ExcelUtils.h(f.b._ap));
          b = ExcelUtils.i(b, ExcelUtils.h(f.b._al));
          e = f.r + 1;
        } while (e < c);
      }
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _eg(a, b, c, d) {
    if (a != null) {
      let e = false;
      let f = 0;
      let g = null;
      let h = !a._hasCellFormat && this.worksheet != null;
      let k = a._ah;
      for (let j = 0; j < k.length; j++) {
        let i = k[j];
        if (i.a == null) {
          break;
        }
        let l = i.b * 32;
        if (l != f) {
          if (h && (g == null || g.r < f)) {
            while (f < c) {
              g = this.worksheet._cb(f);
              b = ExcelUtils.i(b, ExcelUtils.h(d(g.b)));
              if (g.r >= l) {
                break;
              }
              f = g.r + 1;
            }
          }
          else {
            e = true;
          }
        }
        let m = i.a;
        for (let n = 0; n < 32 && b != 2; n++) {
          if (m[n] == null) {
            if (h && (g == null || g.r < n + l)) {
              g = this.worksheet._cb((n + l));
              b = ExcelUtils.i(b, ExcelUtils.h(d(g.b)));
            }
            else {
              e = true;
            }
          }
          else {
            b = ExcelUtils.i(b, ExcelUtils.h(d(m[n])));
          }
        }
        if (b == 2) {
          break;
        }
        f = l + 32;
      }
      if (f != c) {
        e = true;
      }
      if (e && b != 2) {
        if (!h) {
          b = ExcelUtils.i(b, ExcelUtils.h(d(a._cellFormatInternal.d)));
        }
        else if (f < c) {
          do {
            g = this.worksheet._cb(f);
            b = ExcelUtils.i(b, ExcelUtils.h(d(g.b)));
            f = g.r + 1;
          } while (f < c);
        }
      }
    }
    else if (this.worksheet._dt) {
      b = 2;
    }
    else if (this.worksheet._ds) {
      b = 1;
    }
    return {
      p1: b
    };
  }
  /**
   * @hidden
   */
  _eh(a, b, c, d) {
    let e = Workbook.getMaxColumnCount(d) - 1;
    if (e < b.r) {
      c.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxColumnIndex"), b.r, e));
    }
    let f = b.t(this);
    if (f != null) {
      let g = typeCast(Formula.$, f);
      if (g != null) {
        let h = this.worksheet._c;
        g._ca(a, c, d, h, true);
      }
    }
  }
  /**
   * @hidden
   */
  _ei(a, b) {
    if (b == 134217728) {
      if (this.index != 0 && ExcelUtils.h(a.topBorderStyle) != 0) {
        this.worksheet._rows$i._g(this.index - 1);
      }
    }
    else {
      if (this.index != this.worksheet._rows$i.maxCount - 1 && ExcelUtils.h(a.bottomBorderStyle) == 2) {
        this.worksheet._rows$i._g(this.index + 1);
      }
    }
  }
  cells() {
    if (arguments.length !== 0) {
      let a = this._cells$i;
      return a.item.apply(a, arguments);
    }
    return this._cells$i;
  }
  /**
   * @hidden
   */
  get _cells$i() {
    if (this._a3 == null) {
      this._a3 = new WorksheetCellCollection(this);
    }
    return this._a3;
  }
  /**
   * Gets or sets the height of the row in twips (1/20th of a point).
   * <p class="body">
   * If the height of the row is less than zero, the [[Worksheet.defaultRowHeight]] of the
   * owning worksheet will be used as the row's height.
   * </p>
   * <p class="body">
   * The value assigned must be between -1 and 8192. Invalid values will be automatically adjusted to valid values.
   * </p>
   * The height of the row in twips (1/20th of a point).
   * @throws [[InvalidOperationException]] From the setter if the row was removed from the worksheet.
   */
  get height() {
    return this._cs();
  }
  /**
   * Gets or sets the height of the row in twips (1/20th of a point).
   * <p class="body">
   * If the height of the row is less than zero, the [[Worksheet.defaultRowHeight]] of the
   * owning worksheet will be used as the row's height.
   * </p>
   * <p class="body">
   * The value assigned must be between -1 and 8192. Invalid values will be automatically adjusted to valid values.
   * </p>
   * The height of the row in twips (1/20th of a point).
   * @throws [[InvalidOperationException]] From the setter if the row was removed from the worksheet.
   */
  set height(a) {
    this._ad();
    if (this.height != a) {
      WorksheetRow._ae[2].h(WorksheetRow.$, Number_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  _d8(a) {
    this._ad();
    if (a == 0) {
      this.hidden = true;
      return;
    }
    if (a < -1) {
      a = -1;
    }
    if (8192 < a) {
      a = 8192;
    }
    let b = null;
    if (this.worksheet._dz(true)) {
      b = WorksheetElementResizeContext.b(this);
    }
    this._cl = a;
    if (this._l) {
      this._l = false;
      this._y();
    }
    this._bz = a >= 0;
    this._dx(false);
    if (b != null) {
      b.y();
    }
  }
  /**
   * @hidden
   */
  _cs(a = false) {
    if (a == false && this.hidden) {
      return 0;
    }
    if (this._bz == false) {
      return -1;
    }
    return this._cl;
  }
  /**
   * @hidden
   */
  get _cm() {
    return this._cl;
  }
  /**
   * @hidden
   */
  set _cm(a) {
    this._cl = a;
    this._dx();
  }
  /**
   * @hidden
   */
  get _br() {
    if (this._bq == null) {
      this._bq = new SortedList$2(Number_$type, Array_$type, 1, Utilities_Int16Comparer._c);
    }
    return this._bq;
  }
  /**
   * @hidden
   */
  get _bx() {
    return this._bq != null && this._bq._k > 0;
  }
  /**
   * @hidden
   */
  get _ah() {
    if (this._ag == null) {
      this._ag = new Array(1);
      this._ag[0] = new WorksheetCellFormatBlock();
    }
    return this._ag;
  }
  /**
   * @hidden
   */
  get _by() {
    return this._ag != null && this._ag.length != 0 && this._ag[0].a != null;
  }
  /**
   * @hidden
   */
  get _bz() {
    return this._bw(32);
  }
  /**
   * @hidden
   */
  set _bz(a) {
    this._d7(32, a);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this._cn >= 0;
  }
  /**
   * @hidden
   */
  get _b1() {
    this._cb();
    return this._b2;
  }
  /**
   * @hidden
   */
  set _b1(a) {
    this._b3 = false;
    if (this._b2 == a) {
      return;
    }
    this._b2 = a;
    this._dx();
  }
  /**
   * @hidden
   */
  get _b4() {
    this._cb();
    return this._b5;
  }
  /**
   * @hidden
   */
  set _b4(a) {
    this._b6 = false;
    if (this._b5 == a) {
      return;
    }
    this._b5 = a;
    this._dx();
  }
  /**
   * @hidden
   */
  get__m() {
    return this._bw(64);
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * @hidden
   */
  get _au() {
    let a = this.worksheet.workbook;
    if (a == null) {
      return null;
    }
    return a._bj;
  }
  /**
   * @hidden
   */
  get _b2() {
    return this._bw(4);
  }
  /**
   * @hidden
   */
  set _b2(a) {
    this._d7(4, a);
  }
  /**
   * @hidden
   */
  get _b6() {
    return this._bw(8);
  }
  /**
   * @hidden
   */
  set _b6(a) {
    this._d7(8, a);
  }
  /**
   * @hidden
   */
  get _b5() {
    return this._bw(2);
  }
  /**
   * @hidden
   */
  set _b5(a) {
    this._d7(2, a);
  }
  /**
   * @hidden
   */
  get _b3() {
    return this._bw(16);
  }
  /**
   * @hidden
   */
  set _b3(a) {
    this._d7(16, a);
  }
  /**
   * @hidden
   */
  get workbook() {
    let a = this.worksheet;
    return a != null ? a.workbook : null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
  /**
   * @hidden
   */
  getRegionAddress() {
    let a = this.worksheet;
    return a != null ? new WorksheetRegionAddress(1, this.index, this.index, 0, (a._columns$i.maxCount - 1)) : WorksheetRegionAddress._b;
  }
}
WorksheetRow.$t = markType(WorksheetRow, 'WorksheetRow', RowColumnBase.$, [IChangeInfoContext_$type, IWorksheetRegionAddressContext_$type]);
/**
 * @hidden
 */
WorksheetRow._cr = 32;
/**
 * @hidden
 */
WorksheetRow._cy = 8192;
/**
 * @hidden
 */
WorksheetRow._cv = 2;
/**
 * @hidden
 */
WorksheetRow._cz = 2 + 1;
/**
 * @hidden
 */
WorksheetRow._ae = WorksheetRow._ai();
/**
 * @hidden
 */
WorksheetRow._an = 1 | 128 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 33554432 | 536870912;
/**
 * @hidden
 */
WorksheetRow._bm = null;
/**
 * @hidden
 */
export let IWorksheetProvider_$type = new Type(null, 'IWorksheetProvider');
/**
 * @hidden
 */
export let ISortSettingsOwner_$type = new Type(null, 'ISortSettingsOwner', null, [IWorkbookProvider_$type, IWorksheetProvider_$type]);
/**
 * @hidden
 */
export let ISupportFormulaShifts_$type = new Type(null, 'ISupportFormulaShifts');
/**
 * @hidden
 */
export class ConditionBase_RegionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
          this.c = c._a0();
        }
        break;
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a.worksheet;
  }
  get source() {
    return this.a;
  }
}
ConditionBase_RegionChangeContext.$t = markStruct(ConditionBase_RegionChangeContext, 'ConditionBase_RegionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Abstract base class which encapsulates the condition for a formatting rule.
 */
export class ConditionBase extends Base {
  constructor(..._rest) {
    super();
    this._k = 0;
    this._w = false;
    this._v = false;
    this._ap = null;
    this._aq = null;
    this._q = null;
    this._u = false;
    this._t = false;
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0: break;
      case 1:
        {
          let regions = _rest[0];
          let conditionType = _rest[1];
          this._a8(regions);
          this._k = conditionType;
          this._w = false;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  static staticInit() {
    ConditionBase._a = ConditionBase._b();
  }
  /**
   * Returns a reference to the associated worksheet.
   */
  get worksheet() {
    return this._q;
  }
  /**
   * Returns a reference to the associated workbook.
   */
  get workbook() {
    return this._q != null ? this._q.workbook : null;
  }
  /**
   * Returns the [[WorksheetRegion]] which identifies the cell range
   * with which this condition is associated.
   */
  get regions() {
    return this._aq;
  }
  /**
   * @hidden
   */
  get__x() {
    return false;
  }
  /**
   * @hidden
   */
  get _x() {
    return this.get__x();
  }
  /**
   * Returns a [[FormatConditionType]] value which identifies the
   * type of condition for this instance.
   */
  get conditionType() {
    return this._k;
  }
  /**
   * @hidden
   */
  get _ag() {
    return this._v;
  }
  /**
   * @hidden
   */
  get__j() {
    return 0;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * Returns or sets a value which determines the order of evaluation
   * when multiple conditional formatting rules exist.
   * <p class="body">
   * By default, <see cref="ConditionalFormatBase">conditions</see> are evaluated
   * in the order in which they appear within the containing
   * <see cref="ConditionalFormatCollection">collection</see>.
   * </p>
   * <p class="body">
   * This property makes it possible to weight one condition over another, essentially
   * overriding the condition's ordinal position within the collection.
   * </p>
   * <p class="body">
   * A lower number means a higher priority; for example, a condition with a
   * priority of 1 is evaluated before one with a priority of 2.
   * </p>
   * <p class="body">
   * If a cell value meets more than one condition, the format defined by the first
   * condition to be evaluated takes precedence.
   * </p>
   * <p class="body">
   * Setting the priority on one condition may cause the value of other conditions
   * in the collection to be changed to ensure that each condition has a unique value.
   * </p>
   */
  get priority() {
    return this.worksheet._conditionalFormats$i.indexOf(this) + 1;
  }
  /**
   * Returns or sets a value which determines the order of evaluation
   * when multiple conditional formatting rules exist.
   * <p class="body">
   * By default, <see cref="ConditionalFormatBase">conditions</see> are evaluated
   * in the order in which they appear within the containing
   * <see cref="ConditionalFormatCollection">collection</see>.
   * </p>
   * <p class="body">
   * This property makes it possible to weight one condition over another, essentially
   * overriding the condition's ordinal position within the collection.
   * </p>
   * <p class="body">
   * A lower number means a higher priority; for example, a condition with a
   * priority of 1 is evaluated before one with a priority of 2.
   * </p>
   * <p class="body">
   * If a cell value meets more than one condition, the format defined by the first
   * condition to be evaluated takes precedence.
   * </p>
   * <p class="body">
   * Setting the priority on one condition may cause the value of other conditions
   * in the collection to be changed to ensure that each condition has a unique value.
   * </p>
   */
  set priority(a) {
    if (a != this.priority) {
      if (this.worksheet != null && !this._ag) {
        this.worksheet._conditionalFormats$i._a5(a, this);
      }
    }
  }
  /**
   * @hidden
   */
  get__ah() {
    return false;
  }
  /**
   * @hidden
   */
  get _ah() {
    return this.get__ah();
  }
  /**
   * @hidden
   */
  get__ai() {
    return false;
  }
  /**
   * @hidden
   */
  get _ai() {
    return this.get__ai();
  }
  /**
   * Returns or sets a boolean indicating whether additional formatting rules
   * are evaluated if this rule evaluates to true. Applicable only in the case
   * where the containing <see cref="ConditionalFormatCollection">collection</see>
   * contains more than one element.
   * <p class="body">
   * If a cell value meets more than one condition, the format defined by the
   * first condition takes precedence. Individual format properties are "merged"
   * during the resolution process; for example, if one format has red borders
   * and another has a red foreground color, a cell value which meets both conditions
   * may be formatted with both red borders <b>and</b> a red foreground color.
   * </p>
   * <p class="body">
   * This property makes it possible to short-circuit the resolution process, so that
   * no other conditional formats are applied after the first condition evaluates to true.
   * </p>
   * <p class="body">
   * Using the above example, assume <i>StopIfTrue</i> is set to a value of true on the
   * conditional format with red borders, a second conditional format exists with a red
   * foreground color, and a cell value meets both conditions. Because the StopIfTrue
   * setting prevents additional formats from being evaluated, the cell will not show
   * a red foreground color, whereas with <i>StopIfTrue</i> being set to false, it
   * would show both red borders and a red foreground color.
   * </p>
   * <p class="body">
   * In addition to preventing subsequent conditions from being evaluated, the order
   * in which conditions are evaluated can be controlled using the [[priority]]
   * property.
   * </p>
   */
  get stopIfTrue() {
    return this._w;
  }
  /**
   * Returns or sets a boolean indicating whether additional formatting rules
   * are evaluated if this rule evaluates to true. Applicable only in the case
   * where the containing <see cref="ConditionalFormatCollection">collection</see>
   * contains more than one element.
   * <p class="body">
   * If a cell value meets more than one condition, the format defined by the
   * first condition takes precedence. Individual format properties are "merged"
   * during the resolution process; for example, if one format has red borders
   * and another has a red foreground color, a cell value which meets both conditions
   * may be formatted with both red borders <b>and</b> a red foreground color.
   * </p>
   * <p class="body">
   * This property makes it possible to short-circuit the resolution process, so that
   * no other conditional formats are applied after the first condition evaluates to true.
   * </p>
   * <p class="body">
   * Using the above example, assume <i>StopIfTrue</i> is set to a value of true on the
   * conditional format with red borders, a second conditional format exists with a red
   * foreground color, and a cell value meets both conditions. Because the StopIfTrue
   * setting prevents additional formats from being evaluated, the cell will not show
   * a red foreground color, whereas with <i>StopIfTrue</i> being set to false, it
   * would show both red borders and a red foreground color.
   * </p>
   * <p class="body">
   * In addition to preventing subsequent conditions from being evaluated, the order
   * in which conditions are evaluated can be controlled using the [[priority]]
   * property.
   * </p>
   */
  set stopIfTrue(a) {
    if (a != this._w) {
      let b = ConditionBase._a[1].g(ConditionBase.$, Boolean_$type, this, this._w, a);
      this._w = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__al() {
    return true;
  }
  /**
   * @hidden
   */
  get _al() {
    return this.get__al();
  }
  /**
   * @hidden
   */
  get__am() {
    return false;
  }
  /**
   * @hidden
   */
  get _am() {
    return this.get__am();
  }
  /**
   * @hidden
   */
  get _af() {
    return this._u;
  }
  /**
   * @hidden
   */
  set _af(a) {
    this._u = a;
  }
  /**
   * @hidden
   */
  get__z() {
    return false;
  }
  /**
   * @hidden
   */
  get _z() {
    return this.get__z();
  }
  /**
   * @hidden
   */
  get _ao() {
    return ConditionBase._an(this.worksheet);
  }
  /**
   * @hidden
   */
  static _an(a) {
    let b = a != null ? a._y : CultureInfo.currentCulture;
    return FormulaParser.bx(b);
  }
  /**
   * @hidden
   */
  _g(a, b = false) {
    let c = this._h();
    c._a8(a);
    c._k = this._k;
    c._w = this._w;
    c._t = true;
    c._a7(this, b);
    c._t = false;
    return c;
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(ConditionBase.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _e($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ConditionBase_RegionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _f($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ConditionBase_ShiftChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, ConditionBase._e(ConditionBase.$, "Regions", 28, (b) => b.a, (b, c) => ConditionBase._br(b, c)));
    ChangeInfo.f(a, 1, ConditionBase._d(Boolean_$type, "StopIfTrue", (b) => b.stopIfTrue, (b, c) => b.stopIfTrue = c));
    return a;
  }
  /**
   * @hidden
   */
  _y(a, b, c) {
    for (let d = 0; d < this._ap.count; d++) {
      let e = this._ap._inner[d];
      let f = false;
      let g = false;
      if (c) {
        if (e.firstColumn <= b && e.lastColumn >= b && e._aa > 2) {
          g = true;
          if (a == e.lastRow + 1 && e.firstColumn == e.lastColumn) {
            f = true;
          }
        }
      }
      else {
        if (e.firstRow <= a && e.lastRow >= a && e._ad > 2) {
          g = true;
          if (b == e.lastColumn + 1 && e.firstRow == e.lastRow) {
            f = true;
          }
        }
      }
      if (g) {
        let h = new List$1(WorksheetRegion.$, 0);
        for (let i = 0; i < this._ap.count; i++) {
          if (f && i == d) {
            let j = this._ap._inner[i]._h;
            if (c) {
              j = j._f(a);
            }
            else {
              j = j._e(b);
            }
            h.add(this.worksheet._cw(j));
          }
          else {
            h.add(this._ap._inner[i]);
          }
        }
        if (!f) {
          h.add(this.worksheet._cx(a, b, a, b));
        }
        this._bl(h, true);
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _a6(a) {
    let b = new List$1(WorksheetRegion.$, 0);
    for (let c of fromEnum(a)) {
      b.add(this._q._cw(c));
    }
    this._a8(b);
  }
  /**
   * @hidden
   */
  static _at(a, b) {
    if (typeof b === 'string') {
      return NaN;
    }
    let c = typeCast(IConvertible_$type, b);
    if (c == null) {
      return NaN;
    }
    let d;
    let e = ExcelUtils.b0(a, b, d);
    d = e.p2;
    return d;
  }
  /**
   * @hidden
   */
  static _as(a, b, c, d) {
    if (b == null && d == null) {
      return NaN;
    }
    if (d != null) {
      if (c != null) {
        d._cx(c, a);
      }
      let e = d.evaluateCore(a);
      if (e.isError || e.isNull) {
        return NaN;
      }
      let f;
      if (((() => { let g = e._toDouble1(f); f = g.p0; return g.ret; })())) {
        return f;
      }
      return NaN;
    }
    return ConditionBase._at(a, b);
  }
  /**
   * @hidden
   */
  _au(a, b, c, d) {
    if (a != null) {
      if (d == null) {
        d = new TempCellCalcReference(true, this.worksheet, new WorksheetCellAddress(1, b, c));
      }
      if (a._s != 7) {
        a._cx(d, this.workbook);
      }
      let e = a._cf(this.workbook, d, false);
      if (false == e.isError && false == e.isNull) {
        let f;
        if (((() => { let g = e._toDouble1(f); f = g.p0; return g.ret; })())) {
          return {
            ret: f,
            p3: d
          };
        }
      }
    }
    return {
      ret: NaN,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _s() {
    if (this._ap.count == 0) {
      return WorksheetCellAddress.b;
    }
    let a = this.regions.item(0).firstRow;
    let b = this.regions.item(0)._v;
    for (let c = 1; c < this.regions.count; c++) {
      let d = this.regions.item(c);
      if (a > d.firstRow) {
        a = d.firstRow;
      }
      if (b > d._v) {
        b = d._v;
      }
    }
    return new WorksheetCellAddress(1, a, b);
  }
  /**
   * @hidden
   */
  _p() {
    return this.workbook;
  }
  /**
   * @hidden
   */
  static _aa(a, b) {
    if (a == null || b == null) {
      return false;
    }
    let e = a._e;
    for (let d = 0; d < e.length; d++) {
      let c = e[d];
      let f = typeCast(ReferenceToken.$, c);
      let g = f != null ? typeCast(WorksheetReferenceLocal.$, f.o) : null;
      if (g != null && g.u != b) {
        return true;
      }
      let h = f != null ? typeCast(WorksheetReferenceSingleUnconnected.$, f.o) : null;
      if (h != null && h.s != b.name) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _a7(a, b) {
  }
  /**
   * @hidden
   */
  _a8(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "regions");
    }
    if (this._ap != null) {
      this._ap.clear();
    }
    for (let b of fromEnum(a)) {
      if (this._q == null) {
        this._q = b.worksheet;
        if (this._q == null) {
          throw new ArgumentException(1, "regions");
        }
      }
      else if (b.worksheet != this._q) {
        throw new ArgumentException(1, "regions");
      }
      if (this._ap != null) {
        this._ap.add(new WorksheetRegion(this._q, b.firstRow, b.firstColumn, b.lastRow, b.lastColumn, false));
      }
    }
    if (this._q == null) {
      throw new ArgumentException(1, "regions");
    }
    if (this._ap != null) {
      return;
    }
    this._ap = new ObservableCollection$1(WorksheetRegion.$, 0);
    for (let c of fromEnum(a)) {
      this._ap.add(new WorksheetRegion(this._q, c.firstRow, c.firstColumn, c.lastRow, c.lastColumn, false));
    }
    this._aq = new ReadOnlyCollection$1(WorksheetRegion.$, 1, this._ap);
  }
  /**
   * @hidden
   */
  _ac(a) {
    if (this._ap != null) {
      for (let b = 0, c = this._ap.count; b < c; b++) {
        if (this._ap._inner[b]._t(a._ac, a._w, a._ae, a._x)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a != null && this._ap != null) {
      for (let b = 0; b < a.length; b++) {
        if (this._ac(a[b])) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _ad(a, b) {
    for (let c = 0; c < this._ap.count; c++) {
      let d = this._ap._inner[c];
      if (d._q(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  static _ae(a) {
    return a >= 0 && a <= 100;
  }
  /**
   * @hidden
   */
  _a9(a) {
  }
  /**
   * @hidden
   */
  _ba() {
    if (this._q != null && !this._q._t && !this._t) {
      this._bb();
      this._a5();
      let a = this.workbook;
      for (let b of fromEnum(this._aq)) {
        a._hv(b);
      }
    }
  }
  /**
   * @hidden
   */
  _bb() {
  }
  /**
   * @hidden
   */
  _bc() {
    let a = this._q._rows$i.maxCount;
    let b = this._q._columns$i.maxCount;
    for (let c = 0; c < this._ap.count; c++) {
      let d = this._ap._inner[c];
      if (d.firstRow >= a || d.firstColumn >= b) {
        this._ap.removeAt(c);
        c--;
        continue;
      }
      if (d.lastRow >= a || d.lastColumn >= b) {
        let e = d._h;
        if (d.lastRow >= a) {
          e = e._f(a - 1);
        }
        if (d.lastColumn >= b) {
          e = e._e((b - 1));
        }
        this._ap.item(c, this._q._cw(e));
      }
    }
  }
  /**
   * @hidden
   */
  _be(a) {
    if (this._q != null && !this._q._t) {
      this._a5();
      this._ba();
    }
  }
  /**
   * @hidden
   */
  _bf() {
  }
  /**
   * @hidden
   */
  _bg() {
  }
  /**
   * @hidden
   */
  _o(a, b) {
    let c = this._s();
    let d = ConditionBase._n(a, this.workbook, b, 7, c.o, c.m);
    return this._m(d);
  }
  /**
   * @hidden
   */
  _m(a) {
    if (a != null) {
      let b = this._s();
      let c = new TempCellCalcReference(true, this.worksheet, b);
      a._cx(c, this.workbook);
    }
    return a;
  }
  /**
   * @hidden
   */
  static _n(a, b, c, d = 0, e = 0, f = 0, g = null) {
    if (a == null) {
      return null;
    }
    c = Nullable$1.toNullable(CellReferenceMode_$type, ConditionBase._c(c, b));
    let h = null;
    let i = b._c4 ? CultureInfo.invariantCulture : b._e6;
    let j = d == 0 ? Formula._k(a, c.value, d, b.currentFormat, i, g) : ((() => { let k = FormulaParser.e(a, c.value, d, b.currentFormat, i, g, e, f, h); h = k.p8; return k.ret; })());
    if (h != null) {
      throw h;
    }
    let k = typeCast(SingleTargetFormula.$, j);
    if (j != null && k == null) {
      throw new FormulaParseException(ExcelUtils.ef("LE_NotSingleTargetFormula"));
    }
    return k;
  }
  /**
   * @hidden
   */
  _bh(a, b) {
    let c = null;
    for (let d = 0; d < this._ap.count; d++) {
      let e = this._aq.item(d);
      let f = false;
      for (let g = 0; g < b._t.count; g++) {
        let h = b._t._inner[g];
        f = h._j(e._h);
        if (f) {
          break;
        }
      }
      if (f) {
        if (c == null) {
          c = new List$1(WorksheetRegion.$, 0);
          if (d > 0) {
            for (let i = 0; i < d; i++) {
              c.add(this._ap._inner[i]);
            }
          }
        }
        let j = new WorksheetReferenceCollection(e);
        for (let k = 0; k < b._t.count; k++) {
          j._remove2(b._t._inner[k]);
        }
        c.o(j);
      }
      else {
        if (c != null) {
          c.add(e);
        }
      }
    }
    if (c == null) {
      return;
    }
    this._bl(c, false);
  }
  /**
   * @hidden
   */
  _bi(a) {
    this._be(a);
  }
  /**
   * @hidden
   */
  _bj() {
    this._v = true;
    this._bf();
    this._ap.clear();
  }
  /**
   * @hidden
   */
  _bk(a, b) {
    this._ap.clear();
    for (let c = 0; c < b.length; c++) {
      let d = b[c];
      this._ap.add(new WorksheetRegion(a, d._ac, d._w, d._ae, d._x, false));
    }
  }
  /**
   * @hidden
   */
  _bl(a, b) {
    let c = ConditionBase._a[0];
    let d = new ConditionBase_RegionChangeContext(1, this, b);
    let e = c.b(this._q.workbook, this._q, c.c);
    let f = this._s();
    this._ap.clear();
    for (let g = 0; g < a.count; g++) {
      this._ap.add(a._inner[g]);
    }
    let h = this._s();
    if (h.e) {
      if (!f.e || WorksheetCellAddress.h(f, h)) {
        this._bd();
      }
    }
    c.e(ConditionBase_RegionChangeContext.$, ConditionBase.$, d, this, null);
    if (e != null) {
      c.d(this._q.workbook, e);
    }
    this._ba();
  }
  /**
   * @hidden
   */
  _bd() {
  }
  /**
   * @hidden
   */
  _bs(a) {
    this._v = false;
    this._a6(a);
    this._bg();
  }
  /**
   * Sets the [[priority]] value for this rule such that it
   * is the first condition to be evaluated. Applicable only in the case
   * where there is more than one element contained within the associated
   * <see cref="ConditionalFormatCollection">collection</see>.
   * <p class="body">
   * When multiple <see cref="ConditionalFormatBase">conditions</see> exist
   * in the same <see cref="ConditionalFormatCollection">collection</see>,
   * the order in which they are evaluated has bearing on which format is applied
   * to cells which meet those conditions.
   * </p>
   * <p class="body">
   * This method ensures that the associated condition is the first one to be
   * evaluated.
   * </p>
   * <p class="body">
   * To make a condition the last one to be evaluated, use the [[setLastPriority]]
   * method.
   * </p>
   * @see [[priority]]
   * @see [[setLastPriority]]
   */
  setFirstPriority() {
    if (!this._ag) {
      this.worksheet._conditionalFormats$i._a5(0, this);
    }
  }
  /**
   * Sets the [[priority]] value for this rule such that it
   * is the last condition to be evaluated. Applicable only in the case
   * where there is more than one element contained within the associated
   * [[ConditionalFormatCollection]].
   * <p class="body">
   * Just as the [[setFirstPriority]] method ensures that the associated
   * condition is evalulated first, the <i>SetLastPriority</i> method ensures that
   * the associated condition is evaluated last.
   * </p>
   * <p class="body">
   * Calling this method on more than one condition essentially replaces the previously
   * designated condition as the last one to be evaluated with this one.
   * </p>
   * @see [[priority]]
   * @see [[setLastPriority]]
   * @see [[stopIfTrue]]
   */
  setLastPriority() {
    if (!this._ag) {
      this.worksheet._conditionalFormats$i._a5(this.worksheet._conditionalFormats$i.count + 1, this);
    }
  }
  /**
   * Replaces the existing regions with new ones
   * @param regionAddress A string with one or more comma separated region address
   * @param cellReferenceMode An optional cell reference mode
   * @throws [[ArgumentException]] If regionAddress is invalid or contains a region from another worksheet
   */
  setRegions(regionAddress, cellReferenceMode) {
    arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    return this._setRegions$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setRegions$i(a, b) {
    let c = new List$1(WorksheetRegion.$, 0);
    let f = this._q._getRegions1(a, nullableNotEquals(b, null) ? b.value : this._q._c);
    for (let e = 0; e < f.length; e++) {
      let d = f[e];
      if (d.worksheet != this._q) {
        throw new ArgumentException(1, "regionAddress");
      }
      c.add(new WorksheetRegion(this._q, d.firstRow, d.firstColumn, d.lastRow, d.lastColumn, false));
    }
    if (c.count == 0) {
      throw new ArgumentException(1, "regionAddress");
    }
    this._bl(c, true);
  }
  /**
   * @hidden
   */
  _aj(a, b, c, d) {
    let e = false;
    for (let f = 0; f < this._ap.count; f++) {
      let g = this._ap._inner[f]._h._a();
      let h = ((() => { let i = b.e(g, false); g = i.p0; return i.ret; })());
      if (h.f) {
        e = true;
        if (h.g) {
          this._ap.removeAt(f);
          f--;
        }
        else {
          this._ap.item(f, new WorksheetRegion(this.worksheet, g._ac, g._w, g._ae, g._x, false));
        }
      }
    }
    if (e) {
      this._bb();
    }
    if (this._ap.count == 0 || !a) {
      return e;
    }
    let i = b.w;
    let j = b.o;
    let k = i < 0;
    let l = b.l;
    let m = b.k;
    let n = this.worksheet._columns$i.maxCount;
    let o = this.worksheet._rows$i.maxCount;
    let p = 0;
    let q = b.u;
    for (let r = 0; r < this._ap.count; r++) {
      let s = this._ap._inner[r];
      let t = d != null ? d._inner[r] : this._ap._inner[r]._h;
      let u = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      let v = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      let w = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      let x = true;
      if (j) {
        if (l._ac > s.lastRow || l._x < s.firstColumn || l._w > s.lastColumn) {
          x = false;
        }
        if (x) {
          if (l._w <= s.firstColumn && l._x >= s.lastColumn) {
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t);
          }
          else {
            if (l._w <= s.firstColumn) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e(l._x));
              w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c((l._x + 1)));
            }
            else if (l._w > s.firstColumn && l._x >= s.lastColumn) {
              u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e((l._w - 1)));
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c(l._w));
            }
            else {
              u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e((l._w - 1)));
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c(l._w)._e(l._x));
              w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c((l._x + 1)));
            }
          }
          let y = t._ac;
          if (k) {
            let z = (l._ac + i) - t._ac;
            if (z > i) {
              if (z < 0) {
                y += z;
              }
            }
            else {
              y = t._ac + i;
            }
          }
          else {
            if (l._ac <= t._ac) {
              y = t._ac + i;
            }
          }
          v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._f(t._ae + i)._d(y));
        }
      }
      else {
        if (l._w > s.lastColumn || l._ae < s.firstRow || l._ac > s.lastRow) {
          x = false;
        }
        if (x) {
          if (l._ac <= s.firstRow && l._ae >= s.lastRow) {
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t);
          }
          else {
            if (l._ac <= s.firstRow) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(l._ae));
              w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(l._ae + 1));
            }
            else if (l._ac > s.firstRow && l._ae >= s.lastRow) {
              u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(l._ac - 1));
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(l._ac));
            }
            else {
              u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(l._ac - 1));
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(l._ac)._f(l._ae));
              w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(l._ae + 1));
            }
          }
          let aa = t._w;
          if (k) {
            let ab = (l._w + i) - t._w;
            if (ab > i) {
              if (ab < 0) {
                aa += ab;
              }
            }
            else {
              aa = t._w + i;
            }
          }
          else {
            if (l._w <= t._w) {
              aa = t._w + i;
            }
          }
          v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._e((t._x + i))._c(aa));
        }
      }
      if (WorksheetRegionAddress._p(v, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && k && WorksheetRegionAddress._r(b.x, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && b.x.value._j(t)) {
        let ac = b.x.value;
        if (j) {
          if (ac._w <= s.firstColumn) {
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e(ac._x));
            w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c((ac._x + 1)));
          }
          else if (ac._w > s.firstColumn && ac._x >= s.lastColumn) {
            u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e((ac._w - 1)));
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c(ac._w));
          }
          else {
            u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._e((ac._w - 1)));
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c(ac._w)._e(ac._x));
            w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._c((ac._x + 1)));
          }
          v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._f(ac._ac - 1));
        }
        else {
          if (ac._ac <= s.firstRow) {
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(ac._ae));
            w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(ac._ae + 1));
          }
          else if (ac._ac > s.firstRow && ac._ae >= s.lastRow) {
            u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(ac._ac - 1));
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(ac._ac));
          }
          else {
            u = Nullable$1.toNullable(WorksheetRegionAddress.$, t._f(ac._ac - 1));
            v = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(ac._ac)._f(ac._ae));
            w = Nullable$1.toNullable(WorksheetRegionAddress.$, t._d(ac._ae + 1));
          }
          v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._e((ac._w - 1)));
        }
      }
      if (WorksheetRegionAddress._p(v, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        q.add(s);
      }
      else {
        e = true;
        if (WorksheetRegionAddress._r(u, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && u.value._x >= u.value._w && u.value._ae >= u.value._ac) {
          q.add(this.worksheet._cw(u.value));
          p++;
        }
        if (WorksheetRegionAddress._r(v, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && v.value._x >= v.value._w && v.value._ae >= v.value._ac) {
          if (j) {
            if (v.value._ae < 0) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._d(0));
            }
            if (v.value._ac < 0) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._d(0));
            }
            else if (v.value._ac >= o) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._d(o - 1));
            }
            if (v.value._ae >= o) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._d(o - 1));
            }
          }
          else {
            if (v.value._x < 0) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._c(0));
            }
            if (v.value._w < 0) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._c(0));
            }
            else if (v.value._w >= n) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._c((n - 1)));
            }
            if (v.value._x >= n) {
              v = Nullable$1.toNullable(WorksheetRegionAddress.$, v.value._c((n - 1)));
            }
          }
          q.add(this.worksheet._cw(v.value));
        }
        if (WorksheetRegionAddress._r(w, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && w.value._x >= w.value._w && w.value._ae >= w.value._ac) {
          q.add(this.worksheet._cw(w.value));
          p++;
        }
      }
    }
    if (e) {
      this._a8(q);
      this._bb();
    }
    q.clear();
    return e;
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
  }
  /**
   * @hidden
   */
  _bp(a, b, c, d, e) {
    if (c != null) {
      let f = c._ch;
      if (f != null) {
        c._cx(null, this.workbook);
      }
      let g = c._toString1(1);
      if (c._av(this.worksheet, d, 0)) {
        a(this, b, g);
      }
      if (f != null) {
        c._cx(f, this.workbook);
      }
    }
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  _a0(a = 1, b = false) {
    return ConditionBase._a1(this.worksheet, this.regions, a, b);
  }
  /**
   * @hidden
   */
  static _a1(a, b, c = 1, d = false, e = false, f = null, g = Nullable$1.toNullable(String_$type, null)) {
    if (b == null) {
      return stringEmpty();
    }
    let h = null;
    if (b.count == 1) {
      h = b.item(0)._toString2(c, d, e, e);
      if (f != null) {
        f.add(h);
      }
      return h;
    }
    let i = g.hasValue ? g.value : ConditionBase._an(a);
    let j = new StringBuilder(0);
    for (let k = 0; k < b.count; k++) {
      let l = b.item(k);
      if (k > 0) {
        j.h(i);
      }
      h = l._toString2(c, d, e, e);
      j.l(h);
      if (f != null) {
        f.add(h);
      }
    }
    return j.toString();
  }
  /**
   * @hidden
   */
  static _c(a, b) {
    return a.hasValue ? a.value : b != null ? b.cellReferenceMode : 1;
  }
  /**
   * @hidden
   */
  _a4(a, b) {
    return null;
  }
  /**
   * @hidden
   */
  _a3(a, b) {
    let c = b != null ? b._toString2(1, this.workbook._e6) : null;
    b = this._o(a, Nullable$1.toNullable(CellReferenceMode_$type, 1));
    if (b != null && b._ch == null) {
      this._m(b);
    }
    return {
      ret: c,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _br(a, b) {
    let c = a.a;
    let d = a.sheet._getRegions1(a.c, 1);
    if (a.b) {
      let e = new List$1(WorksheetRegion.$, 0);
      e.o(d);
      c._bl(e, true);
    }
    else {
      c._ap.clear();
      for (let g = 0; g < d.length; g++) {
        let f = d[g];
        c._ap.add(f);
      }
    }
  }
  /**
   * @hidden
   */
  shiftFormulas(callback, shiftOperation, operationOverride) {
    this._bq(callback, shiftOperation, operationOverride);
  }
  /**
   * @hidden
   */
  undoFormulaShift(context, originalFormula) {
    return this._a4(context, originalFormula);
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._q;
  }
}
ConditionBase.$t = markType(ConditionBase, 'ConditionBase', Base.$, [ISupportFormulaShifts_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
ConditionBase._a2 = "StopIfTrue";
/**
 * @hidden
 */
ConditionBase._az = "Priority";
/**
 * @hidden
 */
ConditionBase._ax = 0;
/**
 * @hidden
 */
ConditionBase._ay = 1;
/**
 * @hidden
 */
ConditionBase._av = 2;
/**
 * @hidden
 */
ConditionBase._a = null;
/**
 * @hidden
 */
export class Worksheet_CellCommentDeleteChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d.toArray();
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b;
  }
  get source() {
    return this.b;
  }
}
Worksheet_CellCommentDeleteChangeContext.$t = markStruct(Worksheet_CellCommentDeleteChangeContext, 'Worksheet_CellCommentDeleteChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class Worksheet_CellInsertDeleteChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = new WorksheetRegionAddress();
    this.c = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a;
  }
  get source() {
    return this.a;
  }
}
Worksheet_CellInsertDeleteChangeContext.$t = markStruct(Worksheet_CellInsertDeleteChangeContext, 'Worksheet_CellInsertDeleteChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export let IWorksheetElementResizeContext_$type = new Type(null, 'IWorksheetElementResizeContext');
/**
 * @hidden
 */
export class Worksheet_HideUnhideChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.f = null;
    this.g = 0;
    this.d = false;
    this.h = 0;
    this.c = null;
    this.e = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          this.a = c;
          this.g = d;
          this.h = e;
          this.d = f;
          this.f = h;
          this.c = i;
          this.e = g;
        }
        break;
    }
  }
  i() {
    return this.b().toString();
  }
  b() {
    if (this.e) {
      return new WorksheetRegionAddress(1, this.g, this.h, 0, (this.a._columns$i.maxCount - 1));
    }
    else {
      return new WorksheetRegionAddress(1, 0, this.a._c7.maxCount - 1, this.g, this.h);
    }
  }
  j(a, b) {
    let c = this.e;
    let d = a.b(this.a.workbook, this.a, null);
    let e = false;
    if (this.a.workbook != null) {
      e = this.workbook._df;
      this.a.workbook._df = true;
    }
    this.a._i0(this.c, false);
    if (c) {
      this.a._ix(true, false);
    }
    else {
      this.a._iv(true, false);
    }
    if (c) {
      if (this.d) {
        this.a._iu(this.a._dv == false, false);
      }
      for (let f of fromEnum(this.f)) {
        for (let g of fromEnum(this.a._rows$i._m(f.a, f.b))) {
          g._aa(g.hidden == false, false);
        }
      }
    }
    else {
      this.a._cc(this.g, this.g);
      this.a._cc(this.h, this.h);
      for (let h of fromEnum(this.a._ff)) {
        let i = false;
        for (let j of fromEnum(this.f)) {
          if (j.a <= h.r && h.q <= j.b) {
            i = true;
            break;
          }
        }
        if (i) {
          h.i = (h.i == false);
        }
      }
    }
    if (c) {
      this.a._ix(false, false);
    }
    else {
      this.a._iv(false, false);
    }
    this.a._i0(null, false);
    if (this.a.workbook != null) {
      this.a.workbook._df = e;
    }
    a.e(Worksheet_HideUnhideChangeContext.$, String_$type, this, null, this.i());
    if (d != null) {
      a.d(this.a.workbook, d);
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a;
  }
  get source() {
    return this.a;
  }
  getRegionAddress() {
    return this.b();
  }
  get hasHiddenChanges() {
    return true;
  }
}
Worksheet_HideUnhideChangeContext.$t = markStruct(Worksheet_HideUnhideChangeContext, 'Worksheet_HideUnhideChangeContext', ValueType.$, [IChangeInfoContext_$type, IWorksheetRegionAddressContext_$type, IWorksheetElementResizeContext_$type]);
/**
 * @hidden
 */
export class Worksheet_SharedFormulaGroupChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = null;
    this.b = new WorksheetRegionAddress();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = e;
          this.c = d;
          this.b = c;
        }
        break;
    }
  }
  d() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    a._eq.item(this.c, this.b);
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a;
  }
  get source() {
    return this.b;
  }
}
Worksheet_SharedFormulaGroupChangeContext.$t = markStruct(Worksheet_SharedFormulaGroupChangeContext, 'Worksheet_SharedFormulaGroupChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class Worksheet_SharedFormulasShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.b = null;
    this.c = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.d = c;
          this.b = d != null ? d.toArray() : null;
          this.c = e != null ? e.toArray() : null;
          this.a = f != null ? f.toArray() : null;
        }
        break;
    }
  }
  e() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    let b = this.workbook._df;
    this.workbook._df = false;
    let c = this.b != null ? new List$1(Base.$, 2, this.b.length) : null;
    let d = this.a != null ? new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 2, this.a.length) : null;
    let e = this.c != null ? new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 2, this.c.length) : null;
    if (this.a != null) {
      let h = this.a;
      for (let g = 0; g < h.length; g++) {
        let f = h[g];
        let i = new WorksheetRegionAddress();
        if (((() => { let j = this.d._eq.tryGetValue(f, i); i = j.p1; return j.ret; })())) {
          this.d._eq.removeItem(f);
          d.add(new KeyValuePair$2(Base.$, WorksheetRegionAddress.$, 1, f, i));
        }
      }
    }
    if (this.b != null) {
      let l = this.b;
      for (let k = 0; k < l.length; k++) {
        let j = l[k];
        this.d._eq.item(j.key, j.value);
        c.add1(j.key);
      }
    }
    if (this.c != null) {
      let o = this.c;
      for (let n = 0; n < o.length; n++) {
        let m = o[n];
        let p = new WorksheetRegionAddress();
        if (((() => { let q = this.d._eq.tryGetValue(m.key, p); p = q.p1; return q.ret; })())) {
          this.d._eq.item(m.key, m.value);
          e.add(new KeyValuePair$2(Base.$, WorksheetRegionAddress.$, 1, m.key, p));
        }
      }
    }
    let q = Worksheet._ax[13];
    let r = new Worksheet_SharedFormulasShiftChangeContext(1, this.d, d, e, c);
    q.x(r, null, null);
    this.workbook._df = b;
  }
  get workbook() {
    return this.d.workbook;
  }
  get sheet() {
    return this.d;
  }
  get source() {
    return this.d;
  }
}
Worksheet_SharedFormulasShiftChangeContext.$t = markStruct(Worksheet_SharedFormulasShiftChangeContext, 'Worksheet_SharedFormulasShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class Worksheet_ResizeItemChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.e = null;
    this.d = false;
    this.b = null;
    this.c = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          this.a = c;
          this.e = d;
          this.d = e;
          this.b = f;
          this.c = g;
        }
        break;
    }
  }
  f() {
    if (this.d) {
      this.a._io(this.e, this.b);
    }
    else {
      this.a._il(this.e, this.b);
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a;
  }
  get source() {
    return this.a;
  }
  getRegionAddress() {
    if (this.d) {
      return new WorksheetRegionAddress(1, this.e._inner[0].d, this.e._inner[this.e.count - 1].e, 0, (this.a._columns$i.maxCount - 1));
    }
    else {
      return new WorksheetRegionAddress(1, 0, this.a._c7.maxCount - 1, this.e._inner[0].d, this.e._inner[this.e.count - 1].e);
    }
  }
  get hasHiddenChanges() {
    return this.c;
  }
}
Worksheet_ResizeItemChangeContext.$t = markStruct(Worksheet_ResizeItemChangeContext, 'Worksheet_ResizeItemChangeContext', ValueType.$, [IChangeInfoContext_$type, IWorksheetRegionAddressContext_$type, IWorksheetElementResizeContext_$type]);
/**
 * @hidden
 */
export class WorksheetShapePosition extends Base {
  constructor(a) {
    super();
    this.e = null;
    this.d = null;
    this.b = new WorksheetCellAddress();
    this.a = new WorksheetCellAddress();
    this.c(a);
  }
  c(a) {
    this.b = a._ah;
    this.e = a._topLeftCornerPosition$i;
    this.a = a._ad;
    this.d = a._bottomRightCornerPosition$i;
  }
}
WorksheetShapePosition.$t = markType(WorksheetShapePosition, 'WorksheetShapePosition');
/**
 * @hidden
 */
export class WorksheetResizeInfo extends Base {
  constructor() {
    super();
    this.c = null;
    this.d = null;
    this.b = true;
    this.d = new Dictionary$2(WorksheetShape.$, WorksheetShapePosition.$, 0);
    this.c = new Dictionary$2(WorksheetShape.$, WorksheetShapePosition.$, 0);
  }
  h() {
    if (this.b) {
      this.b = false;
    }
    else {
      for (let a of fromEnum(this.c)) {
        a.key._dd(a.value);
      }
    }
  }
  static g(a) {
    if (WorksheetResizeInfo.e == null) {
      WorksheetResizeInfo.e = new List$1(WorksheetShapePosition.$, 0);
    }
    WorksheetResizeInfo.e.o(a);
    if (WorksheetResizeInfo.e.count > 500) {
      WorksheetResizeInfo.e.v(500, WorksheetResizeInfo.e.count - 500);
    }
  }
  static a(a) {
    if (WorksheetResizeInfo.e.count > 0) {
      let b = WorksheetResizeInfo.e.count - 1;
      let c = WorksheetResizeInfo.e._inner[b];
      WorksheetResizeInfo.e.removeAt(b);
      c.c(a);
      return c;
    }
    return new WorksheetShapePosition(a);
  }
  i(a, b) {
    this.d.item(a, new WorksheetShapePosition(a));
  }
  j() {
    if (this.b) {
    }
    else {
      let a = this.c;
      this.c = this.d;
      this.d = a;
      WorksheetResizeInfo.g(this.d.values);
      this.d.clear();
      for (let b of fromEnum(this.c)) {
        this.d.item(b.key, WorksheetResizeInfo.a(b.key));
      }
    }
  }
}
WorksheetResizeInfo.$t = markType(WorksheetResizeInfo, 'WorksheetResizeInfo');
WorksheetResizeInfo.e = null;
/**
 * Represents one worksheet in a Microsoft Excel workbook.
 * <p class="body">
 * An Excel worksheet is essentially a table with a limited number of rows and columns. To create new worksheet, use
 * [[WorksheetCollection.add]] method of the [[Workbook.worksheets]]
 * collection on a [[Workbook]] instance.
 * </p>
 */
export class Worksheet extends Sheet {
  constructor(a, b, c) {
    super(a, b, c);
    this._fa = new List$1(WeakReference.$, 0);
    this._er = null;
    this._et = null;
    this._ev = null;
    this._ce = null;
    this._cg = null;
    this._fx = 0;
    this._go = 0;
    this._gq = 0;
    this._f0 = 0;
    this._du = false;
    this._ci = null;
    this._jd = null;
    this._cs = null;
    this._bn = null;
    /**
     * @hidden
     */
    this._c7 = null;
    this._db = null;
    this._bq = 0;
    this._el = false;
    this._bj = null;
    /**
     * @hidden
     */
    this._d7 = false;
    this._df = null;
    this._fb = null;
    this._fe = new List$1(WorksheetColumnBlock.$, 0);
    this._ej = true;
    this._b1 = null;
    this._bw = null;
    this._g2 = null;
    this._e5 = null;
    this._e6 = null;
    this._dj = false;
    this._dk = false;
    this._ay = null;
    this._az = null;
    this._dn = false;
    /**
     * @hidden
     */
    this._g1 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._cl = null;
    this._e9 = null;
    this._cu = null;
    this._jf = null;
    this._e4 = null;
    /**
     * @hidden
     */
    this._eq = null;
    this._bl = null;
    this._bs = null;
    this._di = false;
    /**
     * @hidden
     */
    this._bp = null;
    this._bg = null;
    this._bu = null;
    this._dl = false;
    this._dm = false;
    /**
     * @hidden
     */
    this._dh = null;
    /**
     * @hidden
     */
    this._eh = false;
    this._c5 = null;
    this._bl = new WorksheetFilterSettings(this);
    this._bs = new WorksheetSortSettings(this, (d) => d._c(this._bs.region, this._bs.sortType));
    this._f0 = -1;
    this._ca();
    this._iq(8, 2, true, false);
    this._cu = new WorksheetProtection(this);
    this._eq = new Dictionary$2(Base.$, WorksheetRegionAddress.$, 0);
    this._bp = new RegionLookupTable$1(WorksheetShape.$, this);
    this._c7 = new WorksheetRowCollection(this);
    this._bu = new SparklineGroupCollection(this);
  }
  static staticInit() {
    Worksheet._ax = Worksheet._a1();
  }
  /**
   * @hidden
   */
  onSortSettingsModified() {
    this._bs.reapplySortConditions();
  }
  /**
   * @hidden
   */
  get culture() {
    return (((t) => t == null ? null : t.name)(this._culture$i));
  }
  /**
   * @hidden
   */
  get _culture$i() {
    return this._y;
  }
  /**
   * @hidden
   */
  get sortRegion() {
    return this._bs.region;
  }
  /**
   * @hidden
   */
  get worksheet() {
    return this;
  }
  /**
   * @hidden
   */
  get areChildrenTopMost() {
    return true;
  }
  /**
   * @hidden
   */
  onChildShapeBoundsChanged(childShape, oldTopLeftCell, oldBottomRightCell, isNotifyOnly) {
    let a = childShape._ah;
    let b = childShape._ad;
    if (WorksheetCellAddress.h(oldTopLeftCell, a) || WorksheetCellAddress.h(b, oldBottomRightCell)) {
      this._bp.ae(oldTopLeftCell.m, oldTopLeftCell.o, oldBottomRightCell.m, oldBottomRightCell.o, childShape);
      this._bp.z(a.m, a.o, b.m, b.o, childShape);
    }
  }
  /**
   * @hidden
   */
  onShapeAdded(shape) {
    let a = shape._ah;
    let b = shape._ad;
    this._bp.z(a.m, a.o, b.m, b.o, shape);
  }
  /**
   * @hidden
   */
  onShapeRemoved(shape) {
    let a = shape._ah;
    let b = shape._ad;
    this._bp.ae(a.m, a.o, b.m, b.o, shape);
  }
  /**
   * @hidden
   */
  get sheet() {
    return this;
  }
  /**
   * Clears all conditional formatting rules from the [[Worksheet]] so they do not get saved.
   * <para class="note"><b>Note:</b> this method is obsolete. Use the Worksheet.ConditionalFormats.Clear() method instead.</para>
   */
  clearConditionalFormattingData() {
    this._conditionalFormats$i.clear();
  }
  deleteCells() {
    let n;
    if (arguments.length === 2) {
      if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._deleteCells.apply(this, arguments);
      case 1: return this._deleteCells3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _deleteCells(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    this._he(a._h, b);
  }
  /**
   * @hidden
   */
  _deleteCells3(a, b) {
    let c = stringIsNullOrEmpty(a) ? null : this._getRegion(a);
    if (c == null) {
      throw new ArgumentException(1, "address");
    }
    this._he(c._h, b);
  }
  /**
   * @hidden
   */
  _he(a, b) {
    this._hf(a, b, Nullable$1.toNullable(Worksheet_CellInsertDeleteChangeContext.$, null));
  }
  /**
   * @hidden
   */
  _hf(a, b, c) {
    let d = Worksheet._ax[4];
    let e = new Worksheet_CellInsertDeleteChangeContext(1, this, a, b);
    let f = new Worksheet_InsertRemoveOperationWrapper(d, e, false, nullableNotEquals(c, null));
    this._conditionalFormats$i._a6(true);
    let g = new CellShiftOperation();
    if (b) {
      g = new CellShiftOperation(2, this, 0, null, a._ac, a._ae, (a._x + 1), (Workbook.getMaxColumnCount(this._o) - 1), -a._af, false);
    }
    else {
      g = new CellShiftOperation(2, this, 3, null, a._ae + 1, Workbook.getMaxRowCount(this._o) - 1, a._w, a._x, -a._ad, false);
    }
    this._hz(true);
    let h = this._b8(g, 2, f, true);
    this._rows$i._ac(h.a);
    this._h0();
    this._h7();
    this._conditionalFormats$i._a7();
    d.e(Worksheet_CellInsertDeleteChangeContext.$, String_$type, e, null, a.toString());
    if (f.f != null) {
      d.d(this.workbook, f.f);
    }
    this._ie();
    this._ig();
  }
  getCell() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
        n = 3;
      }
      else if (typeof arguments[1] === 'number') {
        n = 1;
      }
      else if (arguments[1] == null) {
        n = 3;
      }
    }
    else if (arguments.length === 3) {
      n = 2;
    }
    switch (n) {
      case 0: return this._getCell.apply(this, arguments);
      case 1: return this._getCell1.apply(this, arguments);
      case 2: return this._getCell2.apply(this, arguments);
      case 3: return this._getCell3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getCell(a) {
    return this._getCell2(a, this._c, null);
  }
  /**
   * @hidden
   */
  _getCell1(a, b) {
    return this._getCell2(a, b, null);
  }
  /**
   * @hidden
   */
  _getCell3(a, b) {
    return this._getCell2(a, this._c, b);
  }
  /**
   * @hidden
   */
  _getCell2(a, b, c) {
    let d;
    let e;
    let f;
    let g = this._hk(a, b, c, e, d, f);
    e = g.p3;
    d = g.p4;
    f = g.p5;
    if (WorksheetCell.l_op_Inequality(e, null)) {
      return e;
    }
    if (d != null && d.length != 0) {
      let h = d[0];
      return h._k._cells$i.item(h._v);
    }
    if (f == false) {
      return null;
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidCellAddress"), "address");
  }
  /**
   * Gets the cell conditional format for the cell at the specified row and column index.
   * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of thse criteria an instance of [[CellConditionalFormat]]
   * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
   * conditional format region then this method will return null.</para>
   * @param rowIndex The 0-based index of the WorksheetRow within the [[rows]] collection.
   * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
   * @throws [[ArgumentOutOfRangeException]] 'rowIndex' is less than zero or greater than or equal to the number of rows in the worksheet.
   * 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
   * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
   * @see [[conditionalFormats]]
   * @see [[CellConditionalFormat]]
   */
  getCellConditionalFormat(rowIndex, columnIndex) {
    return this._getCellConditionalFormat1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getCellConditionalFormat1(a, b) {
    return this._be(a, b, false);
  }
  /**
   * @hidden
   */
  _be(a, b, c) {
    ExcelUtils.gp(this, a, "rowIndex");
    ExcelUtils.gi(this, b, "columnIndex");
    if (c && !this._conditionalFormats$i._ac(a, b)) {
      return null;
    }
    let d = Worksheet._e8;
    Worksheet._e8 = null;
    if (d == null) {
      d = new List$1(ConditionBase.$, 0);
    }
    this._conditionalFormats$i._av(d, a, b);
    try {
      if (d == null || d.count == 0) {
        return null;
      }
      let e = d.count;
      let f = this._rows$i._g(a, false);
      let g = f != null ? f._c5(b) : null;
      let h = null;
      let i = null;
      let j = null;
      let k = null;
      let l = false;
      for (let m = 0; m < e; m++) {
        let n = d._inner[m];
        if (k == null && (n._ah || n._ai)) {
          if (f == null && !n._x) {
            continue;
          }
          if (n._ah) {
            k = new TempCellCalcReference(true, this, new WorksheetCellAddress(1, a, b));
          }
        }
        let o = n._i(g, a, b, k);
        if (!o.i) {
          continue;
        }
        if (i == null && o.b != null) {
          i = o.b;
        }
        if (j == null && o.d != null) {
          j = o.d;
        }
        if (WorkbookColorInfo.l_op_Inequality(o.h, null)) {
          if (h == null) {
            h = this.workbook._cd(0);
          }
          h.fill = CellFill._createSolidFill(o.h);
        }
        l = true;
        let p = typeCast(ConditionalFormatBase.$, n);
        if (p != null) {
          let q = h != null;
          if (h == null) {
            h = this.workbook._cd(0);
          }
          let r = p._bw;
          for (let s = 1; s != 1073741824; s = (s << 1)) {
            if (q == false || WorksheetCellFormatData._cf(s, h._dd(s))) {
              let t = r._dd(s);
              if (WorksheetCellFormatData._cf(s, t) == false) {
                h._dv(s, t);
              }
            }
          }
        }
        if (n.stopIfTrue) {
          break;
        }
      }
      if (l) {
        return new CellConditionalFormat(1, h, i, j);
      }
      return CellConditionalFormat._a;
    }
    finally {
      d.clear();
      Worksheet._e8 = d;
    }
  }
  /**
   * Gets the default column width in the specified units.
   * <p class="body">
   * If 'units' is Character256th, the value returned will be the same as the value of the
   * [[defaultColumnWidth]] property.
   * </p>
   * @param units The units in which the width should be returned.
   * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
   * @return The default column width in the specified units.
   * @see [[defaultColumnWidth]]
   * @see [[setDefaultColumnWidth]]
   * @see [[WorksheetColumn.getWidth]]
   */
  getDefaultColumnWidth(units) {
    let a = this._fl(this.defaultColumnWidth, units);
    if (isNaN_(a)) {
      return 0;
    }
    return a;
  }
  getRegion() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
        n = 3;
      }
      else if (typeof arguments[1] === 'number') {
        n = 1;
      }
      else if (arguments[1] == null) {
        n = 3;
      }
    }
    else if (arguments.length === 3) {
      n = 2;
    }
    switch (n) {
      case 0: return this._getRegion.apply(this, arguments);
      case 1: return this._getRegion1.apply(this, arguments);
      case 2: return this._getRegion2.apply(this, arguments);
      case 3: return this._getRegion3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getRegion(a) {
    return this._getRegion2(a, this._c, null);
  }
  /**
   * @hidden
   */
  _getRegion1(a, b) {
    return this._getRegion2(a, b, null);
  }
  /**
   * @hidden
   */
  _getRegion3(a, b) {
    return this._getRegion2(a, this._c, b);
  }
  /**
   * @hidden
   */
  _getRegion2(a, b, c) {
    let d;
    let e;
    let f;
    let g = this._hk(a, b, c, e, d, f);
    e = g.p3;
    d = g.p4;
    f = g.p5;
    if (d != null && d.length != 0) {
      return d[0];
    }
    if (WorksheetCell.l_op_Inequality(e, null)) {
      return this._cx(e.rowIndex, e._ab, e.rowIndex, e._ab);
    }
    if (f == false) {
      return null;
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidRegionAddress"), "address");
  }
  getRegions() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
        n = 3;
      }
      else if (typeof arguments[1] === 'number') {
        n = 1;
      }
      else if (arguments[1] == null) {
        n = 3;
      }
    }
    else if (arguments.length === 3) {
      n = 2;
    }
    switch (n) {
      case 0: return this._getRegions.apply(this, arguments);
      case 1: return this._getRegions1.apply(this, arguments);
      case 2: return this._getRegions2.apply(this, arguments);
      case 3: return this._getRegions3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getRegions(a) {
    return this._getRegions2(a, this._c, null);
  }
  /**
   * @hidden
   */
  _getRegions1(a, b) {
    return this._getRegions2(a, b, null);
  }
  /**
   * @hidden
   */
  _getRegions3(a, b) {
    return this._getRegions2(a, this._c, b);
  }
  /**
   * @hidden
   */
  _getRegions2(a, b, c) {
    let d;
    let e;
    let f;
    let g = this._hk(a, b, c, e, d, f);
    e = g.p3;
    d = g.p4;
    f = g.p5;
    if (d != null) {
      return d;
    }
    if (WorksheetCell.l_op_Inequality(e, null)) {
      return [this._cx(e.rowIndex, e._ab, e.rowIndex, e._ab)];
    }
    if (f == false) {
      return null;
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidRegionAddress"), "address");
  }
  insertCells() {
    let n;
    if (arguments.length === 2) {
      if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._insertCells.apply(this, arguments);
      case 1: return this._insertCells3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _insertCells(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    this._hr(a._h, b);
  }
  /**
   * @hidden
   */
  _insertCells3(a, b) {
    let c = stringIsNullOrEmpty(a) ? null : this._getRegion(a);
    if (c == null) {
      throw new ArgumentException(1, "address");
    }
    this._hr(c._h, b);
  }
  /**
   * @hidden
   */
  _hr(a, b) {
    this._hs(a, b, Nullable$1.toNullable(Worksheet_CellInsertDeleteChangeContext.$, null));
  }
  /**
   * @hidden
   */
  _hs(a, b, c) {
    let d = Worksheet._ax[8];
    let e = new Worksheet_CellInsertDeleteChangeContext(1, this, a, b);
    let f = new Worksheet_InsertRemoveOperationWrapper(d, e, true, nullableNotEquals(c, null));
    this._conditionalFormats$i._a6(true);
    let g = new CellShiftOperation();
    if (b) {
      g = new CellShiftOperation(2, this, 0, null, a._ac, a._ae, a._w, (Workbook.getMaxColumnCount(this._o) - (1 + a._af)), a._af, false);
    }
    else {
      g = new CellShiftOperation(2, this, 3, null, a._ac, Workbook.getMaxRowCount(this._o) - (1 + a._ad), a._w, a._x, a._ad, false);
    }
    this._hz(true);
    let h = this._b8(g, 2, f, true);
    this._rows$i._ac(h.a);
    this._h0();
    this._h7();
    this._conditionalFormats$i._a7();
    d.e(Worksheet_CellInsertDeleteChangeContext.$, String_$type, e, null, a.toString());
    if (f.f != null) {
      d.d(this.workbook, f.f);
    }
  }
  /**
   * Hides the columns in the specified range.
   * @param startIndex The index of the first column to hide, or null to start hiding at the first column.
   * @param count The number of columns to hide. If null, a single column will be hidden when 'startIndex' is specified and
   * otherwise, all columns will be hidden.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
   */
  hideColumns(startIndex, count) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Number_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Number_$type, arguments[1]);
    }
    return this._hideColumns$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _hideColumns$i(a = Nullable$1.toNullable(Number_$type, null), b = Nullable$1.toNullable(Number_$type, null)) {
    this._hp(a, b, false, true);
  }
  /**
   * Hides the rows in the specified range.
   * @param startIndex The index of the first row to hide, or null to start hiding at the first row.
   * @param count The number of rows to hide. If null, a single row will be hidden when 'startIndex' is specified and
   * otherwise, all rows will be hidden.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
   */
  hideRows(startIndex, count) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Number_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Number_$type, arguments[1]);
    }
    return this._hideRows$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _hideRows$i(a = Nullable$1.toNullable(Number_$type, null), b = Nullable$1.toNullable(Number_$type, null)) {
    this._hp(a, b, true, true);
  }
  /**
   * Moves the worksheet to a new position in the owning workbook's collections of worksheets.
   * @param index The new 0-based index to where the worksheet should be moved.
   * @throws [[InvalidOperationException]] The worksheet has previously been removed from its workbook.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of worksheets in the owning workbook.
   * @see [[Workbook.worksheets]]
   * @see [[WorksheetCollection.indexOf]]
   * @see [[index]]
   */
  moveToIndex(index) {
    if (this.workbook == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotMoveDisconnectedWorksheet"));
    }
    if (index < 0 || this.workbook._worksheets$i.count <= index) {
      throw new ArgumentOutOfRangeException(1, "index");
    }
    this.workbook._worksheets$i._o(this.index, index);
  }
  /**
   * Protects the worksheet without a password.
   * <p class="body">When a Worksheet is protected without a password, the end user may unprotect the Worksheet in Excel without
   * having to supply a password. To programatically unprotect a Worksheet, one may use the Unprotect() method.</p>
   * <p class="body">The optional parameters are used to update the property values of the [[WorksheetProtection]] instance from
   * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
   * be retained; otherwise the property will be updated with the specified value. For example, if the [[WorksheetProtection.allowDeletingColumns]]
   * is currently true and the 'allowDeletingColumns' is null, then the property will continue to be true but if the
   * 'allowDeletingColumns' is false the [[WorksheetProtection.allowDeletingColumns]] will be changed to false.</p>
   * <p class="body">When one protects a Worksheet in Excel, the UI allows one to choose which cells may be selected. To affect this state one would
   * change the [[WorksheetProtection.selectionMode]] property before or after protecting the Worksheet.</p>
   * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
   * @param allowDeletingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingColumns]].
   * @param allowDeletingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingRows]].
   * @param allowEditObjects Optional boolean indicating the new value for the [[WorksheetProtection.allowEditObjects]].
   * @param allowEditScenarios Optional boolean indicating the new value for the [[WorksheetProtection.allowEditScenarios]].
   * @param allowFiltering Optional boolean indicating the new value for the [[WorksheetProtection.allowFiltering]].
   * @param allowFormattingCells Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingCells]].
   * @param allowFormattingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingColumns]].
   * @param allowFormattingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingRows]].
   * @param allowInsertingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingColumns]].
   * @param allowInsertingHyperlinks Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingHyperlinks]].
   * @param allowInsertingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingRows]].
   * @param allowSorting Optional boolean indicating the new value for the [[WorksheetProtection.allowSorting]].
   * @param allowUsingPivotTables Optional boolean indicating the new value for the [[WorksheetProtection.allowUsingPivotTables]].
   * @see@see@see [[protection]]
   * @see [[WorksheetProtection]]
   * @see */
  protect(allowDeletingColumns, allowDeletingRows, allowEditObjects, allowEditScenarios, allowFiltering, allowFormattingCells, allowFormattingColumns, allowFormattingRows, allowInsertingColumns, allowInsertingHyperlinks, allowInsertingRows, allowSorting, allowUsingPivotTables) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Boolean_$type, arguments[1]);
    }
    if (arguments[2] !== void 0) {
      arguments[2] = wrapNullable(Boolean_$type, arguments[2]);
    }
    if (arguments[3] !== void 0) {
      arguments[3] = wrapNullable(Boolean_$type, arguments[3]);
    }
    if (arguments[4] !== void 0) {
      arguments[4] = wrapNullable(Boolean_$type, arguments[4]);
    }
    if (arguments[5] !== void 0) {
      arguments[5] = wrapNullable(Boolean_$type, arguments[5]);
    }
    if (arguments[6] !== void 0) {
      arguments[6] = wrapNullable(Boolean_$type, arguments[6]);
    }
    if (arguments[7] !== void 0) {
      arguments[7] = wrapNullable(Boolean_$type, arguments[7]);
    }
    if (arguments[8] !== void 0) {
      arguments[8] = wrapNullable(Boolean_$type, arguments[8]);
    }
    if (arguments[9] !== void 0) {
      arguments[9] = wrapNullable(Boolean_$type, arguments[9]);
    }
    if (arguments[10] !== void 0) {
      arguments[10] = wrapNullable(Boolean_$type, arguments[10]);
    }
    if (arguments[11] !== void 0) {
      arguments[11] = wrapNullable(Boolean_$type, arguments[11]);
    }
    if (arguments[12] !== void 0) {
      arguments[12] = wrapNullable(Boolean_$type, arguments[12]);
    }
    return this._protect$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _protect$i(a = Nullable$1.toNullable(Boolean_$type, null), b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Boolean_$type, null)) {
    this.protection._ah(null, a, b, c, d, e, f, g, h, i, j, k, l, m);
  }
  /**
   * Sets the default column width in the specified units.
   * @param value The default column width to set on the worksheet, expressed in the specified 'units'.
   * @param units The units in which the 'value' is expressed.
   * @throws [[ArgumentException]] 'value' is infinity or NaN.
   * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
   * @see [[defaultColumnWidth]]
   * @see [[getDefaultColumnWidth]]
   * @see [[WorksheetColumn.setWidth]]
   */
  setDefaultColumnWidth(value, units) {
    this._iq(value, units, false, true);
  }
  /**
   * @hidden
   */
  _iq(a, b, c, d) {
    if (isNaN_(a)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NaNDefaultColumnWidth"), "value");
    }
    let e = null;
    if (d && this.workbook != null) {
      e = this.workbook._go(this, 90, "ColumnWidth");
    }
    this._ir(this._fw(a, b), d);
    if (this.workbook != null && this.workbook._c4 == false) {
      this._ek = true;
    }
    if (c) {
      let f = this.getDefaultColumnWidth(3);
      f = Math.ceil(f / 8) * 8;
      this._ir(this._fw(f, 3), d);
    }
    this._bw = new Worksheet_SetColumnWidthInfo(a, b, c);
    if (e != null) {
      this.workbook._ic(e);
    }
  }
  /**
   * Unhides the columns in the specified range.
   * @param startIndex The index of the first column to unhide, or null to start unhiding at the first column.
   * @param count The number of columns to unhide. If null, a single column will be unhidden when 'startIndex' is specified and
   * otherwise, all columns will be unhidden.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
   */
  unhideColumns(startIndex, count) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Number_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Number_$type, arguments[1]);
    }
    return this._unhideColumns$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _unhideColumns$i(a = Nullable$1.toNullable(Number_$type, null), b = Nullable$1.toNullable(Number_$type, null)) {
    this._hp(a, b, false, false);
  }
  /**
   * Unhides the rows in the specified range.
   * @param startIndex The index of the first row to unhide, or null to start unhiding at the first row.
   * @param count The number of rows to unhide. If null, a single row will be unhidden when 'startIndex' is specified and
   * otherwise, all rows will be unhidden.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
   * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
   */
  unhideRows(startIndex, count) {
    if (arguments[0] !== void 0) {
      arguments[0] = wrapNullable(Number_$type, arguments[0]);
    }
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(Number_$type, arguments[1]);
    }
    return this._unhideRows$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _unhideRows$i(a = Nullable$1.toNullable(Number_$type, null), b = Nullable$1.toNullable(Number_$type, null)) {
    this._hp(a, b, true, false);
  }
  /**
   * @hidden
   */
  _g5(a, b, c = false) {
    let d = ((() => { let e = ExcelUtils.cw(WorksheetRegion.$, this._fa, a, WorksheetRegion_HorizontalSorter._a, c, b); b = e.p4; return e.ret; })());
    if (d < 0) {
      this._fa.insert(~d, new WeakReference(a));
    }
    return {
      p1: b
    };
  }
  /**
   * @hidden
   */
  _dp(a, b, c) {
    return this._dq(a, a, b, c, false);
  }
  /**
   * @hidden
   */
  _dq(a, b, c, d, e) {
    let f = new WorksheetRegionAddress(1, a, b, c, d);
    let g = this.workbook;
    if (g != null) {
      g._w.ax();
      for (let h of fromEnum(this._rows$i._m(a, b))) {
        if (h != null) {
          for (let i = c; i <= d; i++) {
            let j = h._at(i);
            if (j == null) {
              continue;
            }
            if (e == false && g._w.n(j)) {
              return true;
            }
          }
        }
      }
    }
    if (this._d9) {
      for (let k = 0; k < this._mergedCellsRegions$i.count; k++) {
        let l = this._mergedCellsRegions$i.item(k);
        if (l.firstRow <= b && a <= l.lastRow) {
          if (c <= l._w && l._v <= d) {
            return true;
          }
        }
      }
    }
    for (let m = 0; m < this._tables$i.count; m++) {
      let n = this._tables$i._item(m);
      let o = n._by;
      if (o._ac <= b && a <= o._ae) {
        if (c <= o._x && o._w <= d) {
          return true;
        }
      }
    }
    for (let p = 0; p < this._dataTables$i.count; p++) {
      let q = this._dataTables$i.item(p);
      let r = q.cellsInTable;
      if (r == null || r.worksheet == null) {
        continue;
      }
      if (r.firstRow <= b && a <= r.lastRow) {
        if (c <= r._w && r._v <= d) {
          return true;
        }
      }
    }
    if (this._ed(a, b, c, d)) {
      return true;
    }
    if (e == false && this._d6 && this._dataValidationRules$i._contains5(f)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _g6(a) {
    if (this._e5 == null) {
      this._e5 = new List$1(PivotTableInfo.$, 0);
    }
    this._e5.add(a);
  }
  /**
   * @hidden
   */
  _g7(a) {
    if (this._e6 == null) {
      this._e6 = new List$1(BinaryData.$, 0);
    }
    this._e6.add(a);
  }
  /**
   * @hidden
   */
  _hc() {
    if (this._e5 != null) {
      this._e5.clear();
    }
    if (this._e6 != null) {
      this._e6.clear();
    }
    if (this._db != null) {
      this._db._ag();
    }
  }
  /**
   * @hidden
   */
  _a0(a, b) {
    let c;
    let d = ((() => { let e = this._f8(a, b, false, c); c = e.p3; return e.ret; })());
    let e = a;
    let f = (a + b - 1);
    let g;
    if (c.r >= f) {
      g = new Array(1);
      g[0] = c.d(this.workbook, e, f);
    }
    else {
      let h = new List$1(WorksheetColumnBlock.$, 0);
      let i = c.d(this.workbook, e, c.r);
      h.add(i);
      let j = b - i.t;
      e = (e + i.t);
      while (j > 0) {
        d++;
        c = this._fe._inner[d];
        i = c.d(this.workbook, e, Math.min(c.r, f));
        h.add(i);
        j -= i.t;
        e += i.t;
      }
      g = h.toArray();
    }
    return g;
  }
  /**
   * @hidden
   */
  _fj(a) {
    let b = this._g0;
    let c = Worksheet._gf(b);
    let d = b + c;
    let e;
    if (a < 1) {
      e = a * d;
    }
    else {
      e = (a * b) + c;
    }
    e = MathUtilities.f(e);
    if (this.displayOptions.showFormulasInCells) {
      e *= 2;
    }
    return e;
  }
  /**
   * @hidden
   */
  _fk(a, b) {
    let c = a * this._g0;
    if (b) {
      c = MathUtilities.f(c);
    }
    if (this.displayOptions.showFormulasInCells) {
      c *= 2;
    }
    return c;
  }
  /**
   * @hidden
   */
  _fl(a, b, c = true) {
    ExcelUtils.gr(b);
    if (a < 0) {
      return NaN;
    }
    let d = a;
    if (b == 1) {
      return d;
    }
    let e = d / 256;
    if (b == 0) {
      return e;
    }
    let f = this._fk(e, c);
    if (b == 3) {
      return f;
    }
    if (b == 2) {
      return this._fn(f);
    }
    let g = Workbook._ep(this.workbook, f, false);
    if (b == 5) {
      return g;
    }
    if (b == 4) {
      return Workbook._es(g);
    }
    return NaN;
  }
  /**
   * @hidden
   */
  _fm(a) {
    if (this.displayOptions.showFormulasInCells) {
      a = Math.floor(a / 2);
    }
    return a / this._g0;
  }
  /**
   * @hidden
   */
  _fn(a) {
    if (this.displayOptions.showFormulasInCells) {
      a = Math.floor(a / 2);
    }
    let b = this._g0;
    let c = Worksheet._gf(b);
    let d = b + c;
    let e;
    if (a < d) {
      e = a / d;
    }
    else {
      e = (a - c) / b;
    }
    return MathUtilities.g(e, 2);
  }
  /**
   * @hidden
   */
  _fw(a, b, c = true) {
    if (isInfinity(a)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InfiniteColumnWidth"), "value");
    }
    ExcelUtils.gr(b);
    if (isNaN_(a)) {
      return -1;
    }
    let t1 = b;
    L0: while (true) {
      switch (t1) {
        case 0:
          a *= 256;
          t1 = 1;
          continue L0;
        case 1: return truncate(MathUtilities.j(a));
        case 2:
          a = this._fj(a);
          t1 = 3;
          continue L0;
        case 3:
          a = this._fm(a);
          t1 = 0;
          continue L0;
        case 4:
          a = Workbook._eq(a);
          t1 = 5;
          continue L0;
        case 5:
          a = Workbook._er(this.workbook, a, false, c);
          t1 = 3;
          continue L0;
        default:
          t1 = 1;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    return new CustomViewDisplayOptions(this, a);
  }
  /**
   * @hidden
   */
  _f() {
    return new PrintOptions(this, true);
  }
  /**
   * @hidden
   */
  _b6(a, b, c) {
    return this._b9(a + 1, this._rows$i.maxCount - 1, b, c, -1, 0);
  }
  /**
   * @hidden
   */
  _hh() {
    this._gq = -1;
  }
  /**
   * @hidden
   */
  _hi(a, b = null) {
    if (this._d9) {
      let c = a;
      for (let d of fromEnum(this._mergedCellsRegions$i)) {
        let e = d._h;
        if (e._j(a)) {
          if (b != null) {
            b.add_1(d);
          }
          let f = a._w;
          let g = a._ac;
          let h = a._x;
          let i = a._ae;
          if (e._w < f) {
            f = e._w;
          }
          if (e._ac < g) {
            g = e._ac;
          }
          if (e._x > h) {
            h = e._x;
          }
          if (e._ae > i) {
            i = e._ae;
          }
          a = new WorksheetRegionAddress(1, g, i, f, h);
        }
      }
      if (WorksheetRegionAddress._q(a, c) && (b == null || b.count < this._mergedCellsRegions$i.count)) {
        let j = this._hi(a, b);
        a = j.p0;
      }
    }
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _cw(a) {
    return this._cx(a._ac, a._w, a._ae, a._x);
  }
  /**
   * @hidden
   */
  _cx(a, b, c, d) {
    let e = new WorksheetRegion(this, a, b, c, d, false);
    let f;
    let g = this._g5(e, f);
    f = g.p1;
    return f || e;
  }
  /**
   * @hidden
   */
  _de(a, b) {
    let c = this._tables$i;
    for (let d = 0; d < c.count; d++) {
      let e = c._item(d);
      if (e._cf(a, b)) {
        return e;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _b4(a, b) {
    if (a != null) {
      let c = a._a8(b);
      if (c != null) {
        return c;
      }
      if (a._hasCellFormat) {
        return a._cellFormatInternal.d;
      }
    }
    return this._cb(b).b;
  }
  /**
   * @hidden
   */
  _ck(a, b, c) {
    let d = c;
    let e = this._cr(b, d);
    let f = this._hyperlinks$i;
    for (let g = f.count - 1; g >= 0; g--) {
      let h = f.item(g);
      if (e != null) {
        if (e._s(h.sourceRegion)) {
          return h;
        }
      }
      else {
        if (h.sourceRegion._q(b, d)) {
          return h;
        }
      }
    }
    if (a != null) {
      return a._bi(d);
    }
    return null;
  }
  /**
   * @hidden
   */
  _cb(a) {
    let b = this._f9(a);
    return this._fe._inner[b];
  }
  /**
   * @hidden
   */
  _f9(a) {
    let b = this._fu(a);
    if (b < 0) {
      b = (~b - 1);
    }
    return b;
  }
  /**
   * @hidden
   */
  _cn(a) {
    let b;
    if (a == 0) {
      b = 0;
    }
    else {
      let c;
      let d = this._columns$i._aq(0, a, c, b, false);
      c = d.p2;
      b = d.p3;
    }
    let e = this._cb(a);
    let f = truncate(MathUtilities.f(e.n(this, 1)));
    return new WorksheetItemPosition(1, a, b, f);
  }
  /**
   * @hidden
   */
  _co(a) {
    let b = 0;
    let c = a;
    let d;
    let e;
    let f = this._columns$i._ar(b, c, d, e);
    b = f.p0;
    c = f.p1;
    d = f.p2;
    e = f.p3;
    let g = this._cb(e);
    let h = truncate(MathUtilities.f(g.n(this, 1)));
    return new WorksheetItemPosition(1, e, a - c, h);
  }
  /**
   * @hidden
   */
  _e1(a, b, c = 0x7FFFFFFF) {
    let d = new List$1(WorksheetItemPosition.$, 0);
    let e = a;
    let f = a + b;
    let g;
    let h;
    let i = this._columns$i._ar(e, f, g, h);
    e = i.p0;
    f = i.p1;
    g = i.p2;
    h = i.p3;
    let j = a - e;
    let k = Math.min(h, c);
    for (let l = g; l <= k; l++) {
      let m = this._cb(l);
      let n = truncate(MathUtilities.f(m.n(this, 1)));
      if (n != 0) {
        d.add(new WorksheetItemPosition(1, l, j, n));
      }
      j += n;
    }
    return d;
  }
  /**
   * @hidden
   */
  _e0(a, b, c = 0x7FFFFFFF) {
    return this._e1(this._cn(a)._m, b, c);
  }
  /**
   * @hidden
   */
  *__ex(a, b, c) {
    let d = c ? 1 : -1;
    let e = c ? a : b;
    let f = c ? b : a;
    let g = this._columns$i;
    for (let h = e; c ? h <= f : h >= f; h += d) {
      let i = this._cb(h);
      if (i.k) {
        continue;
      }
      let j = c ? i.r : i.q;
      while (true) {
        yield g.item(h);
        if (h == j) {
          break;
        }
        h += d;
      }
    }
  }
  _ex(a, b, c) {
    return toEnum(() => this.__ex(a, b, c));
  }
  /**
   * @hidden
   */
  _gb(a, b = false) {
    let c = a < 0 ? null : this._cb(a);
    return this._ga(c, b);
  }
  /**
   * @hidden
   */
  _ga(a, b = false) {
    if (a != null) {
      if (b == false && a.i) {
        return 0;
      }
      if (a.v >= 0) {
        return a.v;
      }
    }
    return this.defaultColumnWidth;
  }
  /**
   * @hidden
   */
  _gd(a, b = false) {
    let c = this._fp(a, b);
    return truncate(Workbook._ep(this.workbook, c, false));
  }
  /**
   * @hidden
   */
  _gc(a, b) {
    let c = this._fo(a, b);
    return truncate(Workbook._ep(this.workbook, c, false));
  }
  /**
   * @hidden
   */
  _fp(a, b = false) {
    let c = null;
    if (a >= 0) {
      c = this._cb(a);
    }
    return this._fo(c, b);
  }
  /**
   * @hidden
   */
  _fo(a, b) {
    if (a != null) {
      return a.n(this, 3, b);
    }
    return this.getDefaultColumnWidth(3);
  }
  /**
   * @hidden
   */
  _fq(a, b, c = false) {
    let d, e;
    let f = this._columns$i._aq(a, b + 1, d, e, c);
    d = f.p2;
    e = f.p3;
    return MathUtilities.f(this._fl(e - d, 3));
  }
  /**
   * @hidden
   */
  _ge() {
    return Worksheet._gf(this._g0);
  }
  /**
   * @hidden
   */
  _cr(a, b) {
    if (this._d1 == false) {
      return null;
    }
    let c = new WorksheetCellAddress(1, a, b);
    let d;
    if (((() => { let e = this._es.tryGetValue(c, d); d = e.p1; return e.ret; })())) {
      return d;
    }
    return null;
  }
  /**
   * @hidden
   */
  _ey() {
    if (this._e5 == null) {
      return Enumerable.k(PivotTableInfo.$);
    }
    return this._e5;
  }
  /**
   * @hidden
   */
  _gh(a, b = false) {
    let c = null;
    if (a >= 0 && this._c7 != null) {
      c = this._c7._aj(a);
      if (c == null) {
        let d = false;
        if (0 < a) {
          let e = this._c7._aj(a - 1);
          if (e != null) {
            d = e._cb() || d;
          }
        }
        let f = Workbook.getMaxRowCount(this._o) - 1;
        if (a < f) {
          let g = this._c7._aj(a + 1);
          if (g != null) {
            d = g._cb() || d;
          }
        }
        if (d) {
          c = this._c7._aj(a);
        }
      }
    }
    return this._gg(c, b);
  }
  /**
   * @hidden
   */
  _gg(a, b) {
    if (a == null) {
      if (b == false && this._dv) {
        return 0;
      }
      return this.defaultRowHeight;
    }
    return a._ct(b);
  }
  /**
   * @hidden
   */
  _fs(a, b = false) {
    let c = this._gh(a, b);
    return Workbook._er(this.workbook, c, true);
  }
  /**
   * @hidden
   */
  _ft(a, b, c) {
    {
      let d = Workbook._fc(this.workbook);
      try {
        let e, f;
        let g = this._rows$i._aq(a, b + 1, e, f, c);
        e = g.p2;
        f = g.p3;
        return MathUtilities.f(Workbook._er(this.workbook, f - e, false));
      }
      finally {
        if (d != null) {
          d.dispose();
        }
      }
    }
  }
  /**
   * @hidden
   */
  _cp(a) {
    {
      let b = Workbook._fc(this.workbook);
      try {
        let c;
        if (a == 0) {
          c = 0;
        }
        else {
          let d;
          let e = this._rows$i._aq(0, a, d, c, false);
          d = e.p2;
          c = e.p3;
        }
        return new WorksheetItemPosition(1, a, c, this._gh(a));
      }
      finally {
        if (b != null) {
          b.dispose();
        }
      }
    }
  }
  /**
   * @hidden
   */
  _cq(a) {
    let b = 0;
    let c = a;
    let d;
    let e;
    let f = this._rows$i._ar(b, c, d, e);
    b = f.p0;
    c = f.p1;
    d = f.p2;
    e = f.p3;
    return new WorksheetItemPosition(1, e, a - c, this._gh(e));
  }
  /**
   * @hidden
   */
  _e3(a, b, c = 0x7FFFFFFF) {
    let d = new List$1(WorksheetItemPosition.$, 0);
    let e = a;
    let f = a + b;
    let g;
    let h;
    let i = this._rows$i._ar(e, f, g, h);
    e = i.p0;
    f = i.p1;
    g = i.p2;
    h = i.p3;
    let j = a - e;
    let k = Math.min(h, c);
    if (this._dv) {
      for (let l of fromEnum(this._rows$i._m(g, k))) {
        let m = this._gg(l, false);
        if (m != 0) {
          d.add(new WorksheetItemPosition(1, l.index, j, m));
        }
        j += m;
      }
    }
    else {
      for (let n = g; n <= k; n++) {
        let o = this._gh(n);
        if (o != 0) {
          d.add(new WorksheetItemPosition(1, n, j, o));
        }
        j += o;
      }
    }
    return d;
  }
  /**
   * @hidden
   */
  _e2(a, b, c = 0x7FFFFFFF) {
    return this._e3(this._cp(a)._m, b, c);
  }
  /**
   * @hidden
   */
  _da(a, b) {
    return {
      ret: ((() => { let c = Worksheet._c9(this._db, a, b); b = c.p2; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _c9(a, b, c) {
    c = null;
    if (a == null) {
      return {
        ret: null,
        p2: c
      };
    }
    for (let d of fromEnum(a)) {
      if (d._cn == b) {
        c = a;
        return {
          ret: d,
          p2: c
        };
      }
      let e = typeCast(WorksheetShapeGroupBase.$, d);
      if (e != null) {
        let f = ((() => { let g = e._dv(b, c); c = g.p1; return g.ret; })());
        if (f != null) {
          return {
            ret: f,
            p2: c
          };
        }
      }
    }
    return {
      ret: null,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _c2(a) {
    return this._c3(a._bg);
  }
  /**
   * @hidden
   */
  _c3(a) {
    let b = new WorksheetRegionAddress();
    if (((() => { let c = this._eq.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return this._cw(b);
    }
    return null;
  }
  /**
   * @hidden
   */
  _ez() {
    if (this._e6 == null) {
      return Enumerable.k(BinaryData.$);
    }
    return this._e6;
  }
  /**
   * @hidden
   */
  _fg() {
    let a = new List$1(IEscherRecord_$type, 0);
    Worksheet._hm(this._db, a);
    return a;
  }
  /**
   * @hidden
   */
  static _hm(a, b) {
    if (a == null) {
      return;
    }
    for (let c of fromEnum(a)) {
      if (c._f != null) {
        b.add(c._f);
      }
      let d = typeCast(WorksheetShapeGroupBase.$, c);
      if (d != null) {
        d._d2(b);
      }
    }
  }
  /**
   * @hidden
   */
  _b5(a, b, c) {
    let d = this._de(b, c);
    if (d == null || a == null) {
      return null;
    }
    let e = new WorksheetDummyCellFormatProxy(a._bv(null));
    d._dv(b, c, e);
    return e.d;
  }
  /**
   * @hidden
   */
  _c4(a, b, c, d, e) {
    let f = c;
    let g = a;
    let h = d;
    let i = b;
    let j = this._ff;
    let k = this._b3;
    for (let l = j.count - 1; l >= 0; l--) {
      let m = j._inner[l];
      if (m.m != 0) {
        f = m.r + 1;
        break;
      }
      else if (!Base.equalsStatic(m.b, k)) {
        f = m.r;
        break;
      }
    }
    for (let n = 0; n < j.count; n++) {
      let o = j._inner[n];
      if (o.m != 0) {
        h = o.q;
        break;
      }
      else if (!Base.equalsStatic(o.b, k)) {
        h = o.q;
        break;
      }
    }
    let p = new MutableItemRange(h, f);
    for (let q of fromEnum(this._rows$i._n(a, b, true))) {
      let r = q._a0(p, c, d);
      if (r != null) {
        p = r;
        g = q.index;
        if (i > g) {
          i = g;
        }
      }
    }
    h = p.a;
    f = p.b;
    let s = new WorksheetRegionAddress(1, a, b, c, d);
    for (let t of fromEnum(this._tables$i)) {
      let u = t._by;
      if (u._j(s)) {
        if (u._ac < i) {
          i = u._ac;
        }
        if (u._w < h) {
          h = u._w;
        }
        if (u._x > f) {
          f = u._x;
        }
        if (u._ae > g) {
          g = u._ae;
        }
      }
    }
    if (this._d2) {
      for (let v of fromEnum(this._eu.keys)) {
        if (v.o >= a && v.o <= b) {
          if (v.o < i) {
            i = v.o;
          }
          if (v.m < h) {
            h = v.m;
          }
          if (v.m > f) {
            f = v.m;
          }
          if (v.o > g) {
            g = v.o;
          }
        }
      }
    }
    if (this._d1) {
      for (let w of fromEnum(this._es)) {
        let x = w.value._h;
        if (x._j(s)) {
          if (x._ac < i) {
            i = x._ac;
          }
          if (x._w < h) {
            h = x._w;
          }
          if (x._x > f) {
            f = x._x;
          }
          if (x._ae > g) {
            g = x._ae;
          }
        }
      }
    }
    if (e && (f < d || g < b)) {
      for (let y of fromEnum(this._shapes$i)) {
        let z = y._ah;
        if (z.o < i) {
          i = z.o;
        }
        if (z.m < h) {
          h = z.m;
        }
        let aa = y._ad;
        if (aa.o > g) {
          g = Math.min(aa.o, b);
        }
        if (aa.m > f) {
          f = Math.min(aa.m, d);
        }
      }
    }
    if (h < c) {
      h = c;
    }
    if (i < a) {
      i = a;
    }
    if (f > d) {
      f = d;
    }
    if (g > b) {
      g = b;
    }
    if (h > f) {
      h = f;
    }
    if (i > g) {
      i = g;
    }
    return new WorksheetRegionAddress(1, i, g, h, f);
  }
  /**
   * @hidden
   */
  _dd(a, b, c, d = Nullable$1.toNullable(CellReferenceMode_$type, null), e = false) {
    let f = nullableNotEquals(d, null) ? this._getRegion1(c, d.value) : this._getRegion(c);
    let g = a.style;
    if (g != null) {
      if (g.isCustom) {
        let h = g.name;
        while (this.workbook._customTableStyles$i._item1(h) != null) {
          h += " 2";
        }
        g = g._m(h, e);
        this.workbook._customTableStyles$i.add(g);
      }
      else {
        g = this.workbook._standardTableStyles$i._item1(g.name);
      }
    }
    let i = this._tables$i._add1(f, b, g, a, e);
    return i;
  }
  /**
   * @hidden
   */
  _g8() {
    let a = this._fd;
    a.clear();
    if (this._d6) {
      let b = this._d9;
      for (let c of fromEnum(this._dataValidationRules$i)) {
        for (let d of fromEnum(c.value._t)) {
          for (let e = d._ac; e <= d._ae; e++) {
            for (let f = d._w; f <= d._x; f++) {
              if (this._bi(e, f) != null) {
                let g = this._rows$i.item(e)._cells$i.item(f);
                a.add(g);
                if (b) {
                  let h = g.associatedMergedCellsRegion;
                  if (h != null) {
                    f = h._h._x;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _b7(a, b, c, d) {
    return this._b9(a, this._rows$i.maxCount - 2, b, c, 1, d);
  }
  /**
   * @hidden
   */
  _ec(a) {
    return this._cb(a).i;
  }
  /**
   * @hidden
   */
  _ed(a, b, c, d) {
    for (let e of fromEnum(this._rows$i._m(a, b))) {
      for (let f of fromEnum(e._ch(c, d, true))) {
        if (f.o) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _eg(a) {
    let b = this._rows$i._aj(a);
    return this._ef(b);
  }
  /**
   * @hidden
   */
  _ef(a) {
    if (a == null) {
      return this._dv;
    }
    return a.hidden;
  }
  /**
   * @hidden
   */
  _hw(a, b, c, d, e, f, g = false) {
    let h = this._cc(a, b);
    if (f != null && f._cd == false) {
      let i = GenericCacheElementEx.q(WorksheetCellFormatData.$, h.b);
      h.b = GenericCacheElementEx.r(WorksheetCellFormatData.$, f, i);
      this._hh();
    }
    h.i = d;
    h.m = e;
    h.v = c;
    h.j = g;
  }
  /**
   * @hidden
   */
  _hx(a, b) {
    let c;
    let d = ((() => { let e = this._f8(a, b, true, c); c = e.p3; return e.ret; })());
    let e = this.workbook._ff;
    let f = d;
    let g = (c.r + 1);
    let h = 0;
    for (let i = d + 1; i < this._fe.count; i++) {
      if (g >= e) {
        h++;
        continue;
      }
      let j = this._fe._inner[i];
      let k = j.r + 1 - j.q;
      j.q = g;
      j.r = Math.min(g + k - 1, e - 1);
      g = (j.r + 1);
    }
    while (h > 0) {
      d = this._fe.count - 1;
      this._id(d, this._fe._inner[d]);
      h--;
    }
    this._hj(f);
  }
  /**
   * @hidden
   */
  _hy(a, b) {
    let c = this._fu(a);
    if (c < 0) {
      c = (~c - 1);
    }
    let d = this._fe._inner[c];
    let e = b;
    let f = c;
    if (d.q == a && d.q + b >= d.r + 1) {
      e -= d.t;
      this._id(c, d);
      if (c < this._fe.count) {
        let g = this._fe._inner[c];
        let h = g.t;
        g.q = a;
        g.r = (a + h - 1);
      }
      if (f > 0) {
        f--;
      }
    }
    else {
      let i = Math.min(d.r + 1 - a, b);
      d.r -= i;
      e -= i;
      c++;
    }
    while (e > 0) {
      d = this._fe._inner[c];
      let j = d.t;
      if (j <= e) {
        e -= j;
        this._id(c, d);
      }
      else {
        j -= e;
        e = 0;
        d.r = (d.q + j - 1);
      }
    }
    if (this._fe.count == 0) {
      this._ca();
    }
    this._hj(f);
  }
  /**
   * @hidden
   */
  _ao(a) {
    let b = this._fe._inner[this._fe.count - 1];
    let c = (this.workbook._ff - 1);
    do {
      if (b.r <= c) {
        break;
      }
      if (this._fe.count == 1) {
        b.r = c;
        break;
      }
      GenericCacheElementEx.q(WorksheetCellFormatData.$, b.b);
      this._fe.removeAt(this._fe.count - 1);
      b = this._fe._inner[this._fe.count - 1];
    } while (true);
    if (b.r < c) {
      if (b.k) {
        b.r = c;
      }
      else {
        let d = new WorksheetColumnBlock(0, (b.r + 1), c, this.workbook._ca._p);
        d.b.k();
        this._fe.add(d);
      }
    }
    this._rows$i._ab();
    this._columns$i._ab();
    if (this._ci != null) {
      this._ci._o();
    }
    if (this._bg != null) {
      this._bg._a0(a);
    }
    if (this._bl != null) {
      this._bl._ba(a);
    }
    if (this._bs != null) {
      this._bs._bb(a);
    }
    super._ao(a);
  }
  /**
   * @hidden
   */
  _hz(a) {
    this._dn = true;
  }
  /**
   * @hidden
   */
  _h0() {
    this._h5();
    if (this._cl != null) {
      this._cl._o();
    }
  }
  /**
   * @hidden
   */
  _aq() {
    let a = this.workbook;
    let b = a._bj;
    for (let c of fromEnum(this._rows$i)) {
      c._ea(b);
    }
    for (let d of fromEnum(this._fe)) {
      GenericCacheElementEx.q(WorksheetCellFormatData.$, d.b);
    }
    for (let e of fromEnum(this._mergedCellsRegions$i)) {
      if (e._hasCellFormat) {
        e._cellFormatInternal.i();
      }
    }
    Worksheet._jb(this);
    for (let f of fromEnum(this._tables$i)) {
      f._ej(a);
    }
    this._g1 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    super._aq();
  }
  /**
   * @hidden
   */
  _h2(a, b) {
    let c = b != null ? b._h : WorksheetRegionAddress._b;
    this._eq.item(a._bg, c);
  }
  /**
   * @hidden
   */
  _h3(a, b = true) {
    let c = a._bg;
    let d = new WorksheetRegionAddress();
    if (((() => { let e = this._eq.tryGetValue(c, d); d = e.p1; return e.ret; })())) {
      let e = false;
      for (let f of fromEnum(this._rows$i._m(d._ac, d._ae))) {
        for (let g = d._w; g <= d._x; g++) {
          let h = f.getCellFormula(g);
          if (h != null && h != a && h._as && h._bg == c) {
            e = true;
            break;
          }
        }
        if (e) {
          break;
        }
      }
      if (e == false) {
        if (!this._dn) {
          this._eq.removeItem(c);
        }
        a._bu();
        if (b && this.workbook != null && !this._dn) {
          let i = Worksheet._ax[12];
          let j = new Worksheet_SharedFormulaGroupChangeContext(1, d, c, this);
          i.x(j, null, null);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _g4(a, b = null) {
    return this.workbook != null && this.workbook._cx ? this.workbook._go(this, a, b) : null;
  }
  /**
   * @hidden
   */
  _h4(a) {
    if (a != null) {
      if (this.workbook != null) {
        this.workbook._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _h5() {
    let a = null;
    let b = null;
    for (let c of fromEnum(this._eu)) {
      if (WorksheetCell.l_op_Equality(c.value.cell, null) || !c.value.cell._e.e) {
        if (a == null) {
          a = new List$1(KeyValuePair$2.$.specialize(WorksheetCellAddress.$, WorksheetCellComment.$), 0);
        }
        a.add(c);
        continue;
      }
      if (WorksheetCellAddress.h(c.value.cell._e, c.key)) {
        if (b == null) {
          b = new List$1(KeyValuePair$2.$.specialize(WorksheetCellAddress.$, WorksheetCellComment.$), 0);
        }
        b.add(c);
        continue;
      }
    }
    if (b != null) {
      for (let d of fromEnum(b)) {
        this._eu.removeItem(d.key);
        this._eu.item(d.value.cell._e, d.value);
      }
    }
    if (a != null) {
      for (let e of fromEnum(a)) {
        this._eu.removeItem(e.key);
        e.value.cell = null;
      }
    }
    if (a != null) {
      let f = Worksheet._ax[3];
      let g = new Worksheet_CellCommentDeleteChangeContext(1, this, a);
      let h = f.b(this.workbook, this, null);
      f.e(Worksheet_CellCommentDeleteChangeContext.$, Number_$type, g, 0, g.a.length);
      if (h != null) {
        f.d(this.workbook, h);
      }
    }
  }
  /**
   * @hidden
   */
  _h7() {
    if (this._ay != null) {
      this._h6(this._ay, false);
      this._ay = null;
    }
    if (this._az != null) {
      let c = this._az;
      for (let b = 0; b < c.length; b++) {
        let a = c[b];
        if (WorksheetCell.l_op_Inequality(a.value.cell, null) && WorksheetCellAddress.h(a.value.cell._e, a.key)) {
          let d = a.value;
          let e = this._getCell1(a.key.p(true, true, this.workbook.currentFormat, 1), 1);
          d._c4(e, d._aj, d._af);
          continue;
        }
      }
      this._az = null;
    }
    this._dn = false;
  }
  /**
   * @hidden
   */
  _h6(a, b) {
    if (a != null) {
      if (b) {
        this._az = a;
      }
      for (let d = 0; d < a.length; d++) {
        let c = a[d];
        let e = c.value;
        let f = this._getCell1(e._d4.p(true, true, this.workbook.currentFormat, 1), 1);
        e._c4(f, e._aj, e._af);
        this._eu.item(e._d4, e);
      }
    }
  }
  /**
   * @hidden
   */
  _ia(a) {
    for (let c = 0; c < a.length; c++) {
      let b = a[c];
      this._h9(b);
    }
  }
  /**
   * @hidden
   */
  _h9(a) {
    let b = a.q;
    let c = a.r;
    let d;
    let e = ((() => { let f = this._f8(b, (c - (b + 1)), false, d); d = f.p3; return f.ret; })());
    let f = d == a;
    let g = 0;
    if (f) {
      if (d.r >= a.r) {
        return;
      }
      g = a.r - d.r;
      d.r = a.r;
    }
    else {
      if (d.q == a.q) {
        if (d.r == a.r) {
          this._fe._inner[e] = a;
          return;
        }
        if (d.r > a.r) {
          this._fe.insert(e, a);
          d.q = (a.r + 1);
          return;
        }
        g = a.r - d.r;
        this._fe._inner[e] = a;
      }
      else {
        if (a.r >= d.r) {
          g = a.r - d.r;
          d.r = (a.q - 1);
          this._fe.insert(e + 1, a);
        }
        else {
          let h = d.r;
          d.r = (a.q - 1);
          this._fe.insert(e + 1, a);
          if (h > a.r) {
            this._fe.insert(e + 2, d.d(this.workbook, (a.r + 1), h));
          }
        }
      }
    }
    while (g > 0) {
      e++;
      d = this._fe._inner[e];
      if (g >= d.t) {
        g -= d.t;
        this._fe.removeAt(e);
      }
      else {
        d.q += g;
        g = 0;
      }
    }
  }
  /**
   * @hidden
   */
  _ib(a, b, c) {
    if (this.workbook != null && this.workbook._c4) {
      return;
    }
    if (c.count == 0) {
      if (this._dv) {
        for (let d = a; d <= b; d++) {
          this._rows$i.item(d).hidden = false;
        }
      }
      else {
        for (let e of fromEnum(this._rows$i._m(a, b))) {
          e.hidden = false;
        }
      }
      return;
    }
    for (let f = 0; f < c.count; f++) {
      let g = c._inner[f];
      if (g.filter._f(this, a, b, g.columnIndex) == false) {
        return;
      }
    }
    for (let h = a; h <= b; h++) {
      let i = this._rows$i._aj(h);
      let j = false;
      for (let k = 0; k < c.count; k++) {
        let l = c._inner[k];
        if (l.filter._e(this, i, h, l.columnIndex) == false) {
          j = true;
          break;
        }
      }
      if (j != this._ef(i)) {
        if (i == null) {
          i = this._rows$i.item(h);
        }
        i.hidden = j;
      }
    }
  }
  /**
   * @hidden
   */
  _ic(a) {
    if (this._d9) {
      for (let b of fromEnum(this._mergedCellsRegions$i)) {
        let c = b._h;
        if (c._j(a) && !a._h(c)) {
          let d = a._w;
          let e = a._ac;
          let f = a._x;
          let g = a._ae;
          if (c._w < d) {
            d = (c._x + 1);
          }
          if (c._ac < e) {
            e = c._ae + 1;
          }
          if (c._x > f) {
            f = (c._w - 1);
          }
          if (c._ae > g) {
            g = c._ac - 1;
          }
          if (d > f || e > g) {
            a = WorksheetRegionAddress._b;
            break;
          }
          a = new WorksheetRegionAddress(1, e, g, d, f);
        }
      }
    }
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _ei(a, b) {
    if (this._e4 != null && this._e4.count > 0) {
      let c = this._rows$i._aj(a);
      return ExcelUtils.bq(this._e4, c, b);
    }
    return false;
  }
  /**
   * @hidden
   */
  _ie() {
    ExcelUtils.f2(this._e4);
  }
  /**
   * @hidden
   */
  _ig() {
    ExcelUtils.f2(this._e9);
  }
  /**
   * @hidden
   */
  _ih(a, b = null) {
    if (this._d9) {
      for (let c = this._mergedCellsRegions$i.count - 1; c >= 0; c--) {
        let d = this._cs.item(c);
        if (b != null && b.contains(d)) {
          continue;
        }
        if (a._j(d._h)) {
          this._cs.removeAt(c);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ii(a, b) {
    ExcelUtils.bq(this._e9, a, b);
  }
  /**
   * @hidden
   */
  _ik(a, b) {
    if (b == 0) {
      for (let c of fromEnum(a)) {
        this._hideColumns$i(Nullable$1.toNullable(Number_$type, c.a), Nullable$1.toNullable(Number_$type, c.b - c.a + 1));
      }
      return;
    }
    let d = WorksheetElementResizeContext.j(a, b, 65535);
    this._il(d, null);
  }
  /**
   * @hidden
   */
  _il(a, b) {
    let c = false;
    let d = null;
    let e = null;
    if (b != null) {
      this._iv(true, false);
    }
    else if (this._dz(false)) {
      if (d == null) {
        d = ((() => { let f = WorksheetElementResizeContext.o(this, a, c); c = f.p2; return f.ret; })());
      }
      e = WorksheetElementResizeContext.d(this, d, false, this.defaultColumnWidth);
      this._iv(true, false);
    }
    if (d == null) {
      d = ((() => { let f = WorksheetElementResizeContext.o(this, a, c); c = f.p2; return f.ret; })());
    }
    let f = Worksheet._ax[14];
    let g = b != null ? b : new WorksheetResizeInfo();
    let h = new Worksheet_ResizeItemChangeContext(1, this, d, false, g, c);
    let i = f.b(this.workbook, this, null);
    this._i0(g, false);
    let j = false;
    if (this.workbook != null) {
      j = this.workbook._df;
      this.workbook._df = true;
    }
    for (let k = 0; k < a.count; k++) {
      let l = a._inner[k];
      let m = l.d;
      let n = l.e;
      let o = this._f9(m);
      let p = this._ff._inner[o];
      if (p.q < m) {
        this._cc(m, Math.min(p.r, n));
        o++;
      }
      let q = this._f9(n);
      p = this._ff._inner[q];
      if (p.r > n) {
        this._cc(Math.max(p.q, m), n);
      }
      for (let r = o; r <= q; r++) {
        p = this._fe._inner[r];
        p.v = l.c;
        p.j = l.a;
        p.i = l.b;
      }
      this._cd(n);
      this._cd(m);
    }
    if (b != null) {
      this._iv(false, false);
    }
    else if (e != null) {
      this._iv(false, false);
      e.y();
    }
    if (this.workbook != null) {
      this.workbook._df = j;
    }
    this._i0(null, false);
    f.e(Worksheet_ResizeItemChangeContext.$, Base.$, h, null, null);
    if (i != null) {
      f.d(this.workbook, i);
    }
  }
  /**
   * @hidden
   */
  _im(a, b) {
    if (b == 0) {
      for (let c of fromEnum(a)) {
        this._hideRows$i(Nullable$1.toNullable(Number_$type, c.a), Nullable$1.toNullable(Number_$type, c.b - c.a + 1));
      }
      return;
    }
    let d = WorksheetElementResizeContext.j(a, b, 8192);
    this._io(d, null);
  }
  /**
   * @hidden
   */
  _io(a, b) {
    let c = null;
    let d = false;
    let e = null;
    if (b != null) {
      this._ix(true, false);
    }
    else if (this._dz(true)) {
      if (c == null) {
        c = ((() => { let f = WorksheetElementResizeContext.p(this, a, d); d = f.p2; return f.ret; })());
      }
      e = WorksheetElementResizeContext.d(this, c, true, this.defaultRowHeight);
      this._ix(true, false);
    }
    if (c == null) {
      c = ((() => { let f = WorksheetElementResizeContext.p(this, a, d); d = f.p2; return f.ret; })());
    }
    let f = Worksheet._ax[15];
    let g = b != null ? b : new WorksheetResizeInfo();
    let h = new Worksheet_ResizeItemChangeContext(1, this, c, true, g, d);
    let i = f.b(this.workbook, this, null);
    this._i0(g, false);
    let j = false;
    if (this.workbook != null) {
      j = this.workbook._df;
      this.workbook._df = true;
    }
    for (let k = 0; k < a.count; k++) {
      let l = a._inner[k];
      let m = l.c == -1 && l.a == false && l.b == this._dv;
      if (m) {
        for (let n of fromEnum(this._rows$i._m(l.d, l.e))) {
          n._cm = l.c;
          n._bz = l.a;
          n._l = l.b;
        }
      }
      else {
        for (let o = l.d; o <= l.e; o++) {
          let p = this._rows$i.item(o);
          p._cm = l.c;
          p._bz = l.a;
          p._l = l.b;
        }
      }
    }
    if (b != null) {
      this._ix(false, false);
    }
    else if (e != null) {
      this._ix(false, false);
      e.y();
    }
    if (this.workbook != null) {
      this.workbook._df = j;
    }
    this._i0(null, false);
    f.e(Worksheet_ResizeItemChangeContext.$, Base.$, h, null, null);
    if (i != null) {
      f.d(this.workbook, i);
    }
  }
  /**
   * @hidden
   */
  _b8(a, b, c = null, d = false) {
    let e = new List$1(ArrayFormula.$, 0);
    let f = new Dictionary$2(ArrayFormula.$, ShiftingArrayFormulaInfo.$, 0);
    let g = new List$1(WorksheetTable.$, 0);
    let h = new List$1(WorksheetMergedCellsRegion.$, 0);
    let i = this._a6(a, e, g, h, c);
    if (i != 0) {
      return new WorksheetCellShiftResult(1, i, null);
    }
    let j = new WorksheetCellShiftResult();
    let k = this._eh;
    let l = c != null && c.isUndoOperation;
    let m = this._dx;
    let n = this._dw;
    try {
      this._eh = true;
      if (c != null) {
        c.onBeforeShift(a);
      }
      this.workbook._ij(() => {
        this._ix(true, !l);
        this._iv(true, !l);
        if (!l) {
          this._i0(new WorksheetResizeInfo(), true);
        }
      });
      let o = a.x;
      let p = false;
      if (c != null) {
        if (c.shiftsRows) {
          p = c.isRemoveOperation;
        }
      }
      this.workbook._df = true;
      let q = null;
      if (c == null || !c.isUndoOperation) {
        if (this._eq.count > 0) {
          q = new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 2, this._eq.count);
          for (let r of fromEnum(this._eq)) {
            q.add(r);
          }
        }
      }
      let s = new Dictionary$2(WorksheetShape.$, Rect.$, 0);
      if (!l) {
        let t = (u) => s.item(u, u._getBoundsInTwips());
        for (let u = 0; u < this._shapes$i.count; u++) {
          let v = this._shapes$i.item(u);
          s.addItem(v, v._getBoundsInTwips());
          if (v._ap != null) {
            v._ap._ah(t);
          }
        }
        for (let w of fromEnum(this._eu.values)) {
          s.item(w, w._getBoundsInTwips());
          w._dc();
        }
      }
      else {
        for (let x of fromEnum(this._eu.values)) {
          x._dc();
        }
      }
      if (this._d5) {
        let y = this._dataTables$i;
        for (let z = 0; z < y.count; z++) {
          let aa = y.item(z);
          if (aa._p(a, o)) {
            z--;
          }
        }
      }
      for (let ab = 0; ab < e.count; ab++) {
        let ac = e._inner[ab];
        let ad;
        if (((() => { let ae = ac._cm(a, o, ad); ad = ae.p2; return ae.ret; })())) {
          e.removeAt(ab);
          ab--;
        }
        f.item(ac, ad);
      }
      if (WorksheetRegionAddress._r(o, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        for (let ae = 0; ae < g.count; ae++) {
          let af = g._inner[ae];
          if (af._cy(a, o.value)) {
            g.removeAt(ae);
            ae--;
          }
        }
        if (c == null || !c.isUndoOperation) {
          for (let ag = 0; ag < this._shapes$i.count; ag++) {
            let ah = this._shapes$i.item(ag);
            if (ah._a9(a, o.value)) {
              ag--;
              continue;
            }
          }
        }
        if (this._d6) {
          let ai = new List$1(DataValidationRule.$, 0);
          for (let aj of fromEnum(this._dataValidationRules$i)) {
            if (aj.value._l(a, o.value)) {
              ai.add(aj.key);
            }
          }
          if (ai.count > 0) {
            this.workbook._df = false;
            for (let ak = 0; ak < ai.count; ak++) {
              this._dataValidationRules$i.removeItem(ai._inner[ak]);
            }
            this.workbook._df = true;
          }
        }
      }
      else {
      }
      if (this.workbook != null) {
        let al = null;
        for (let am of fromEnum(this.workbook._worksheets$i)) {
          for (let an of fromEnum(am._eq)) {
            let ao = an.value;
            for (let ap of fromEnum(am._rows$i._m(ao._ac, ao._ae))) {
              for (let aq = ao._w; aq <= ao._x; aq++) {
                let ar = ap.getCellFormula(aq);
                if (ar != null && ar._as && ar._bg == an.key) {
                  if ((a.l._i(ap.index, aq) && a.l._h(ao) == false) || ar._ar(this.workbook, this, a.l)) {
                    if (al == null) {
                      al = new List$1(Formula.$, 0);
                    }
                    al.add(ar);
                  }
                }
              }
            }
          }
          if (al != null) {
            for (let as of fromEnum(al)) {
              am._h3(as, false);
              as._bt(this.workbook);
            }
            al.clear();
          }
        }
      }
      if (WorksheetRegionAddress._r(o, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && !p) {
        this.workbook._df = c != null && c.isUndoOperation;
        this._ha(o.value, d, a.o, c != null && c.shiftsRows, Nullable$1.toNullable(Number_$type, null), c != null && c.shiftsColumns && !c.shiftsRows);
        this.workbook._df = true;
      }
      if (this._cl != null) {
        this._cl._q(a, c);
      }
      a.af(c);
      if (h.count > 1) {
        h.z(new RegionShiftComparer$1(WorksheetMergedCellsRegion.$, a));
      }
      this._mergedCellsRegions$i._s(a, c, h);
      this._hu(runOn(new Worksheet_ShiftRegionHelper(a), new Worksheet_ShiftRegionHelper(a).b));
      if (a.o) {
        this.printOptions._horizontalPageBreaks$i._t(a);
        if (this.workbook != null) {
          for (let at of fromEnum(this.workbook._customViews$i)) {
            let au = at.getPrintOptions(this, false);
            if (au != null) {
              au._horizontalPageBreaks$i._t(a);
            }
          }
        }
      }
      else {
      }
      if (!l) {
        for (let av = this._shapes$i.count - 1; av >= 0; av--) {
          let aw = this._shapes$i.item(av);
          let ax = aw._s(a, c, s);
        }
        for (let ay of fromEnum(this._eu.values)) {
          let az = ay._s(a, c, s);
        }
      }
      if (this._d6) {
        let a0 = new List$1(DataValidationRule.$, 0);
        for (let a1 of fromEnum(this._dataValidationRules$i)) {
          let a2;
          let a3 = a1.value._ap(a, a2);
          a2 = a3.p1;
        }
      }
      let a4 = a.y;
      if (WorksheetRegionAddress._r(a4, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && !p) {
        let a5 = a4.value;
        let a6 = a.k;
        let a7;
        let a8 = Nullable$1.toNullable(Number_$type, null);
        let t1 = b;
        L0: while (true) {
          switch (t1) {
            case 0:
              a7 = Nullable$1.toNullable(Number_$type, null);
              break;
            case 1:
              if (a.o) {
                if (a5._ac < a6._ac) {
                  a7 = Nullable$1.toNullable(Number_$type, a6._ac);
                }
                else {
                  a7 = Nullable$1.toNullable(Number_$type, a6._ae);
                }
              }
              else {
                if (a5._w < a6._w) {
                  a7 = Nullable$1.toNullable(Number_$type, a6._w);
                }
                else {
                  a7 = Nullable$1.toNullable(Number_$type, a6._x);
                }
              }
              break;
            case 2:
              if (a.o) {
                if (a5._ac < a6._ac) {
                  if (0 < a5._ac) {
                    a7 = Nullable$1.toNullable(Number_$type, a5._ac - 1);
                    a8 = Nullable$1.toNullable(Number_$type, a6._ac);
                  }
                  else {
                    a7 = Nullable$1.toNullable(Number_$type, null);
                  }
                }
                else {
                  if (a5._ae < this._rows$i.maxCount - 1) {
                    a7 = Nullable$1.toNullable(Number_$type, a5._ae + 1);
                  }
                  else {
                    a7 = Nullable$1.toNullable(Number_$type, null);
                  }
                }
              }
              else {
                if (a5._w < a6._w) {
                  if (0 < a5._w) {
                    a7 = Nullable$1.toNullable(Number_$type, a5._w - 1);
                    a8 = Nullable$1.toNullable(Number_$type, a6._w);
                  }
                  else {
                    a7 = Nullable$1.toNullable(Number_$type, null);
                  }
                }
                else {
                  if (a5._x < this._columns$i.maxCount - 1) {
                    a7 = Nullable$1.toNullable(Number_$type, a5._x + 1);
                  }
                  else {
                    a7 = Nullable$1.toNullable(Number_$type, null);
                  }
                }
              }
              break;
            default:
              t1 = 0;
              continue L0;
          }
          break;
        }
        this._ha(a5, d, a.o, c != null && c.shiftsRows, a7, c != null && c.shiftsColumns && !c.shiftsRows, a8);
      }
      for (let a9 of fromEnum(g)) {
        let ba = a9._bk(a, c, c == null || false == c.shiftsColumns || !c.isUndoOperation);
      }
      for (let bb of fromEnum(e)) {
        bb._c0(a, c, f.item(bb));
      }
      j = new WorksheetCellShiftResult(1, 0, g);
      if (this.workbook != null) {
        let bc = new HashSet$1(Base.$, 0);
        this.workbook._df = false;
        this._bl._z(a, c);
        this._bs._aq(a, c);
        if (this._bg != null) {
          this._bg._a2(a, c);
        }
        if (c == null || !c.isUndoOperation) {
          for (let bd of fromEnum(this.workbook._sheets$i)) {
            let be = typeCast(Worksheet.$, bd);
            if (be != null) {
              be._bu._ae(a, c);
            }
            if (bd._p != null) {
              bd._p._al(a, c);
            }
          }
        }
        this.workbook._hm((bf, bg) => {
          if (bg._as && bc.add_1(bg._bg) == false) {
            return;
          }
          bg._av(bf, a, 0);
        }, false);
        this.workbook._df = true;
      }
      if (this._d5) {
        for (let bf of fromEnum(this._dataTables$i)) {
          bf._o(a);
        }
      }
      if (q != null) {
        let bg = null;
        let bh = null;
        for (let bi of fromEnum(q)) {
          let bj = new WorksheetRegionAddress();
          if (((() => { let bk = this._eq.tryGetValue(bi.key, bj); bj = bk.p1; return bk.ret; })())) {
            let bk = ((() => { let bl = a.e(bj, false); bj = bl.p0; return bl.ret; })());
            if (bk.f) {
              if (bk.g) {
                if (bg == null) {
                  bg = new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 0);
                }
                bg.add(bi);
              }
              else {
                if (bh == null) {
                  bh = new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 0);
                }
                bh.add(bi);
                this._eq.item(bi.key, bj);
              }
            }
          }
          else {
            if (bg == null) {
              bg = new List$1(KeyValuePair$2.$.specialize(Base.$, WorksheetRegionAddress.$), 0);
            }
            bg.add(bi);
          }
        }
        if (bg != null) {
          for (let bl of fromEnum(bg)) {
            this._eq.removeItem(bl.key);
          }
        }
        if (bg != null || bh != null) {
          let bm = this.workbook._df;
          this.workbook._df = false;
          let bn = Worksheet._ax[13];
          let bo = new Worksheet_SharedFormulasShiftChangeContext(1, this, bg, bh, null);
          bn.x(bo, null, null);
          this.workbook._df = bm;
        }
      }
    }
    finally {
      this.workbook._ij(() => {
        if (!l) {
          this._i0(null, true);
        }
        this._ix(m, !l);
        this._iv(n, !l);
      });
      this._eh = k;
    }
    this._fc.add(a);
    this.workbook._df = false;
    return j;
  }
  /**
   * @hidden
   */
  _b9(a, b, c, d, e, f) {
    let g = new CellShiftOperation(1, this, 3, a, b, c, d, e);
    this._hz(true);
    let h = this._b8(g, f);
    this._h0();
    this._h7();
    return h;
  }
  /**
   * @hidden
   */
  _cc(a, b) {
    let c = this._f9(a);
    let d = this._fe._inner[c];
    let e = d.r;
    if (d.q != a) {
      d.r = (a - 1);
      let f = new WorksheetColumnBlock(1, a, e, d);
      c++;
      this._fe.insert(c, f);
      d = f;
    }
    if (d.r != b) {
      d.r = b;
      let g = new WorksheetColumnBlock(1, (b + 1), e, d);
      this._fe.insert(c + 1, g);
    }
    return d;
  }
  /**
   * @hidden
   */
  _en(a, b, c, d = true) {
    c = dateMinValue();
    let e = this.workbook;
    let f;
    if (a == null || ((() => { let g = ExcelUtils.b0(e, a._c5(b), f); f = g.p2; return g.ret; })()) == false) {
      return {
        ret: false,
        p2: c
      };
    }
    let g = ExcelCalcValue._excelDateToDateTime(e, f);
    if (g.hasValue == false) {
      return {
        ret: false,
        p2: c
      };
    }
    if (d) {
      let h = this._b4(a, b);
      let i;
      if (e == null) {
        i = new ValueFormatter(0, null, h._dg, this._y);
      }
      else {
        i = e._b2.a(h._cs);
      }
      if (i.o == false || i.e(f) != 1) {
        return {
          ret: false,
          p2: c
        };
      }
    }
    c = g.value;
    return {
      ret: true,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _cd(a) {
    let b = this._f9(a);
    let c = this._fe._inner[b];
    if (c.q != 0) {
      let d = this._cb((c.q - 1));
      if (c.equals(d)) {
        this._ff.removeAt(b);
        GenericCacheElementEx.q(WorksheetCellFormatData.$, c.b);
        d.r = c.r;
        c = d;
      }
    }
    let e = this._columns$i.maxCount - 1;
    if (c.r != e) {
      let f = this._f9((c.r + 1));
      let g = this._fe._inner[f];
      if (c.equals(g)) {
        this._ff.removeAt(f);
        GenericCacheElementEx.q(WorksheetCellFormatData.$, g.b);
        c.r = g.r;
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  _bi(a, b) {
    if (this._d6) {
      let c = this._dataValidationRules$i._e(new WorksheetRegionAddress(1, a, a, b, b));
      if (c != null && !c._x(new WorksheetCellAddress(1, a, b))) {
        return c;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _eo(a, b, c) {
    if (this._fv == c) {
      return {
        ret: true,
        p0: a,
        p1: b,
        p2: c
      };
    }
    let d = this._fv;
    let e = a.index;
    let f = false;
    for (let g = c; g < d; g++) {
      let h = this._fc._inner[g];
      if (h.q) {
        continue;
      }
      let i = ((() => { let j = h.d(e, b); e = j.p0; b = j.p1; return j.ret; })());
      f = i.f || f;
      if (i.g) {
        return {
          ret: false,
          p0: a,
          p1: b,
          p2: c
        };
      }
    }
    if (f && e != a.index) {
      a = this._rows$i.item(e);
    }
    c = d;
    return {
      ret: true,
      p0: a,
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _a7(a, b, c, d, e, f) {
    let g = new CellShiftOperation(1, this, f, a, b, c, d, e);
    return this._a6(g, null, null, null, null);
  }
  /**
   * @hidden
   */
  _a6(a, b, c, d, e) {
    let f = a.l;
    let g = a.k;
    if (WorksheetRegionAddress._q(g, f)) {
      let h;
      if (a.o) {
        let i = this._rows$i.maxCount - 1;
        h = f._ae < g._ae && i <= g._ae;
      }
      else {
        let j = this._columns$i.maxCount - 1;
        h = f._x < g._x && j <= g._x;
      }
      if (h) {
        let k = a.x;
        if (WorksheetRegionAddress._r(k, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
          let l = k.value;
          if (this._dq(l._ac, l._ae, l._w, l._x, true)) {
            return 1;
          }
        }
        else if (g._ac < 0 || g._w < 0) {
          return 1;
        }
      }
    }
    if (this._bl.region != null) {
      let m = true;
      switch (a.b) {
        case 0:
          m = f._ac > 0 || f._ae < this._rows$i.maxCount - 1;
          break;
        case 3:
          m = f._w > 0 || f._x < this._columns$i.maxCount - 1;
          break;
      }
      if (m && false == a.s(WorksheetFilterSettings.$, e, null, this._bl, this._bl.region._h)) {
        return 4;
      }
    }
    for (let n of fromEnum(this._tables$i)) {
      if (n._cv == false && a.s(WorksheetTable.$, e, c, n, n._by) == false) {
        return 3;
      }
    }
    for (let o of fromEnum(this._mergedCellsRegions$i)) {
      if (a.s(WorksheetMergedCellsRegion.$, e, d, o, o._h) == false) {
        return 5;
      }
    }
    for (let p of fromEnum(this._dataTables$i)) {
      let q = p._j;
      if (q._n == false) {
        continue;
      }
      if (a.s(WorksheetDataTable.$, e, null, p, q) == false) {
        return 6;
      }
    }
    let r = Math.min(f._ac, g._ac);
    let s = Math.max(f._ae, g._ae);
    let t = Math.min(f._w, g._w);
    let u = Math.max(f._x, g._x);
    let v = new HashSet$1(IRegionBlockingValue_$type, 0);
    for (let w of fromEnum(this._rows$i._m(r, s))) {
      if (!w._bx) {
        continue;
      }
      for (let x of fromEnum(w._ch(t, u, true))) {
        let y = typeCast(IRegionBlockingSingleCellComponent_$type, w._c6(x.r));
        if (y != null && y.owningValue.blockedRegion != null && v.add_1(y.owningValue)) {
          let z = y.owningValue.blockedRegion;
          let aa = typeCast(ArrayInteriorFormula.$, y);
          if (aa != null) {
            if (a.s(ArrayFormula.$, e, b, aa._cz, z._h) == false) {
              return 6;
            }
          }
          else {
            if (a.s(IRegionBlockingSingleCellComponent_$type, e, null, y, z._h) == false) {
              return 6;
            }
          }
        }
      }
    }
    for (let ab of fromEnum(this._shapes$i)) {
      if (this._ep(ab, a) == false) {
        return 2;
      }
    }
    for (let ac of fromEnum(this._eu.values)) {
      if (this._ep(ac, a) == false) {
        return 2;
      }
    }
    if (a.w != 0) {
      if (a.q) {
        this._rows$i._x(a);
      }
      else {
        this._columns$i._x(a);
      }
    }
    return 0;
  }
  /**
   * @hidden
   */
  _ep(a, b) {
    let c = new WorksheetCellAddress();
    let d;
    let e = new WorksheetCellAddress();
    let f;
    let g = ((() => { let h = a._t(b, a._getBoundsInTwips(), true, c, d, e, f); c = h.p3; d = h.p4; e = h.p5; f = h.p6; return h.ret; })());
    if (g.f) {
      if (g.g && g.b == 3) {
        return false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _av(a, b) {
    this._columns$i._af(a, b);
    this._rows$i._af(a, b);
    if (this._d9) {
      this._mergedCellsRegions$i._x(a, b);
    }
    this.printOptions._b1(a, b);
    super._av(a, b);
  }
  /**
   * @hidden
   */
  _jc(a, b, c) {
    if (!this._di) {
      let d = this.workbook;
      if (d != null) {
        d._jb(a, b, c);
      }
    }
  }
  /**
   * @hidden
   */
  _ca(a = 0) {
    let b = new WorksheetColumnBlock(0, a, (this.workbook._ff - 1), this.workbook._ca._p);
    b.b.k();
    this._fe.add(b);
    return b;
  }
  /**
   * @hidden
   */
  _fu(a) {
    if (this._fe == null) {
      return -1;
    }
    let b = 0;
    let c = this._fe.count - 1;
    while (b <= c) {
      let d = b + (intDivide((c - b), 2));
      let e = this._fe._inner[d];
      if (e == null) {
        c = d - 1;
        continue;
      }
      if (e.g(a)) {
        return d;
      }
      let f = e.q - a;
      if (f < 0) {
        b = d + 1;
      }
      else {
        c = d - 1;
      }
    }
    return ~b;
  }
  /**
   * @hidden
   */
  _ha(a, b, c, d, e, f, g = Nullable$1.toNullable(Number_$type, null)) {
    let h = e.hasValue && c ? this._rows$i._aj(e.value) : null;
    if (h != null && h._cells$i._count > 0) {
      for (let i = a._ac; i <= a._ae; i++) {
        let j = this._rows$i.item(i);
        j._df(a._w, a._x, b, h, Nullable$1.toNullable(Number_$type, null), f, d, g);
      }
      return;
    }
    for (let k of fromEnum(this._rows$i._m(a._ac, a._ae))) {
      if (c) {
        k._df(a._w, a._x, b, h, Nullable$1.toNullable(Number_$type, null), f, d, g);
      }
      else {
        k._df(a._w, a._x, b, null, e, f, d, g);
      }
    }
  }
  /**
   * @hidden
   */
  _g9() {
    this._hu(null);
  }
  /**
   * @hidden
   */
  static _a9($tValue, a, b, c, d, e = null, f = true, g = true, h = 0) {
    return new ChangeInfo$2(Worksheet_CellCommentDeleteChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _a8($tValue, a, b, c, d, e = null, f = true, g = true, h = 0) {
    return new ChangeInfo$2(Worksheet_CellInsertDeleteChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _ba($tValue, a, b, c, d, e = null, f = true, g = true, h = 0) {
    return new ChangeInfo$2(Worksheet_HideUnhideChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _bb($tValue, a, b, c, d = null, e = 0) {
    return new ChangeInfo$2(Worksheet_ResizeItemChangeContext.$, $tValue, a, 90, b, c, d, true, e, true, null, null);
  }
  /**
   * @hidden
   */
  static _bc($tValue, a, b, c, d = null, e = true, f = true, g = 0) {
    return new ChangeInfo$2(Worksheet_SharedFormulaGroupChangeContext.$, $tValue, a, 90, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bd($tValue, a, b, c, d = null, e = true, f = false, g = 0) {
    return new ChangeInfo$2(Worksheet_SharedFormulasShiftChangeContext.$, $tValue, a, 90, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _a1() {
    let a = new Array(19);
    ChangeInfo.f(a, 0, SheetChangeInfoContext.a(Worksheet.$, Number_$type, "DefaultColumnWidth", 90, (b) => b.defaultColumnWidth, (b, c) => b._is(c, true), (b, c) => b._is(c, false), true, false));
    ChangeInfo.f(a, 1, SheetChangeInfoContext.a(Worksheet.$, Number_$type, "DefaultRowHeight", 90, (b) => b.defaultRowHeight, (b, c) => b._it(c, true), (b, c) => b._it(c, false), true, false));
    ChangeInfo.f(a, 2, SheetChangeInfoContext.a(Worksheet.$, Boolean_$type, "DefaultRowHidden", 90, (b) => b._dv, (b, c) => b._dv = c, (b, c) => b._iu(c)));
    ChangeInfo.f(a, 3, Worksheet._a9(Number_$type, "DeleteCellComments", 3, (b) => b.a.length, (b, c) => Worksheet._i2(b, c), null, true, true));
    ChangeInfo.f(a, 4, Worksheet._a8(String_$type, "DeleteCells", 94, (b) => b.b.toString(), (b, c) => Worksheet._i3(b, c), null, true, true));
    ChangeInfo.f(a, 5, Worksheet._ba(String_$type, "Hidden", 26, (b) => b.i(), (b, c) => Worksheet._i5(b, c), null, true, true));
    ChangeInfo.f(a, 6, Worksheet._ba(String_$type, "Hidden", 60, (b) => b.i(), (b, c) => Worksheet._i6(b, c), null, true, true));
    ChangeInfo.f(a, 7, SheetChangeInfoContext.a(Worksheet.$, WBitmap.$, "ImageBackground", 90, (b) => b._je, (b, c) => b._je = c, (b, c) => b._iz(c)));
    ChangeInfo.f(a, 8, Worksheet._a8(String_$type, "InsertCells", 93, (b) => b.b.toString(), (b, c) => Worksheet._i4(b, c), null, true, true));
    ChangeInfo.f(a, 9, Worksheet._ba(String_$type, "Hidden", 26, (b) => b.i(), (b, c) => Worksheet._i7(b, c), null, true, true));
    ChangeInfo.f(a, 10, Worksheet._ba(String_$type, "Hidden", 60, (b) => b.i(), (b, c) => Worksheet._i8(b, c), null, true, true));
    ChangeInfo.f(a, 11, SheetChangeInfoContext.a(Worksheet.$, Point_$type, "ValidationInputMessagePosition", 90, (b) => b._jg, (b, c) => b._jg = c, null, false, false));
    ChangeInfo.f(a, 12, Worksheet._bc(Base.$, "SharedFormulaGroupRemoved", (b) => null, (b, c) => b.d()));
    ChangeInfo.f(a, 13, Worksheet._bd(Base.$, "SharedFormulasShift", (b) => null, (b, c) => b.e()));
    ChangeInfo.f(a, 14, Worksheet._bb(Base.$, "ResizeColumns", (b) => null, (b, c) => b.f()));
    ChangeInfo.f(a, 15, Worksheet._bb(Base.$, "ResizeRows", (b) => null, (b, c) => b.f()));
    ChangeInfo.f(a, 16, SheetChangeInfoContext.a(Worksheet.$, WorksheetResizeInfo.$, "ResizeInfo", 90, (b) => b._c6, (b, c) => b._i0(c, true), (b, c) => b._i1(c), true, false));
    ChangeInfo.f(a, 17, SheetChangeInfoContext.a(Worksheet.$, Boolean_$type, "DisableRowResizeNotifications", 90, (b) => b._dx, (b, c) => b._ix(c, true), (b, c) => b._iy(c), true, false));
    ChangeInfo.f(a, 18, SheetChangeInfoContext.a(Worksheet.$, Boolean_$type, "DisableColumnResizeNotifications", 90, (b) => b._dw, (b, c) => b._iv(c, true), (b, c) => b._iw(c), true, false));
    return a;
  }
  /**
   * @hidden
   */
  _hj(a) {
    let b = this._fe._inner[a];
    if (a == 0) {
      b.r -= b.q;
      b.q = 0;
    }
    for (let c = a + 1; c < this._fe.count; c++) {
      let d = this._fe._inner[c];
      let e = d.t;
      d.q = (b.r + 1);
      d.r = (d.q + e - 1);
      b = d;
    }
    if (b.r < this.workbook._ff - 1 && false == b.k) {
      b = this._ca((b.r + 1));
    }
    b.r = (this.workbook._ff - 1);
  }
  /**
   * @hidden
   */
  _f8(a, b, c, d) {
    let e;
    let f = this.workbook._ff;
    if (a == 0) {
      d = this._fe._inner[0];
      if (c) {
        if (d.k) {
          d.r = Math.min(d.r + b, f - 1);
        }
        else {
          d = new WorksheetColumnBlock(0, a, (a + b - 1), this.workbook._ca._p);
          this._fe.insert(0, d);
        }
      }
      e = 0;
    }
    else {
      if (c) {
        e = this._fu((a - 1));
      }
      else {
        e = this._fu(a);
      }
      if (e < 0) {
        e = (~e - 1);
      }
      d = this._fe._inner[e];
      if (c) {
        d.r = Math.min(d.r + b, f - 1);
      }
    }
    return {
      ret: e,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _hk(a, b, c, d, e, f) {
    if (WorksheetCell.l_op_Inequality(c, null) && c.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "originCell");
    }
    f = true;
    if (a == null) {
      throw new ArgumentNullException(0, "address");
    }
    a = trimStart(a);
    let g;
    let h;
    let i;
    let j;
    let k = this._hl(a, b, c, g, h, i, j);
    g = k.p3;
    h = k.p4;
    i = k.p5;
    j = k.p6;
    d = null;
    e = null;
    if (0 <= i) {
      e = [this._cx(g, h, i, j)];
      return {
        p3: d,
        p4: e,
        p5: f
      };
    }
    if (0 <= g) {
      d = this._rows$i.item(g)._cells$i.item(h);
      return {
        p3: d,
        p4: e,
        p5: f
      };
    }
    if (this.workbook == null) {
      return {
        p3: d,
        p4: e,
        p5: f
      };
    }
    d = null;
    e = null;
    let l = null;
    let m = -1;
    if (WorksheetCell.l_op_Inequality(c, null)) {
      l = c._o;
      m = c._ab;
    }
    let n;
    let o = ((() => { let p = this.workbook._ar(a.trim(), b, this, l, m, n); n = p.p5; return p.ret; })());
    if (n) {
      f = false;
    }
    if (o == null) {
      return {
        p3: d,
        p4: e,
        p5: f
      };
    }
    let p = typeCast(CellCalcReference.$, o);
    if (p != null) {
      if (o._u == this) {
        d = p._w._cells$i.item(p._ao);
      }
      return {
        p3: d,
        p4: e,
        p5: f
      };
    }
    let q = o.context;
    let r = typeCast(NamedReference.$, q);
    if (r != null) {
      d = r.referencedCell;
      if (WorksheetCell.l_op_Equality(d, null)) {
        let s = r.referencedRegion;
        if (s != null) {
          e = [s];
        }
        else {
          e = r.referencedRegions;
        }
      }
    }
    else {
      d = typeCast(WorksheetCell.$, q);
      if (WorksheetCell.l_op_Equality(d, null)) {
        let t = typeCast(WorksheetRegion.$, q);
        let u = typeCast(IEnumerable$1_$type.specialize(WorksheetRegion.$), q);
        if (t != null) {
          e = [t];
        }
        else if (u != null) {
          e = new List$1(WorksheetRegion.$, 1, u).toArray();
        }
      }
    }
    if (WorksheetCell.l_op_Inequality(d, null) && d.worksheet != this) {
      d = null;
    }
    if (e != null && e.length != 0 && e[0].worksheet != this) {
      e = null;
    }
    return {
      p3: d,
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  _hl(a, b, c, d, e, f, g) {
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, b)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", b, CellReferenceMode_$type);
    }
    let h = null;
    let i = -1;
    if (WorksheetCell.l_op_Inequality(c, null)) {
      h = c._o;
      i = c._ab;
    }
    let j = this._o;
    let k = this._y;
    let l = ExcelUtils.fv(a, j, b, k, h, i, d, e, f, g);
    d = l.p6;
    e = l.p7;
    f = l.p8;
    g = l.p9;
    if (d < 0 && b == 0 && WorksheetCell.l_op_Equality(c, null)) {
      let m = ExcelUtils.fv(a, j, b, k, this._rows$i.item(0), 0, d, e, f, g);
      d = m.p6;
      e = m.p7;
      f = m.p8;
      g = m.p9;
      if (0 <= d) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_RelativeR1C1AddressNeedsOriginCell"));
      }
    }
    return {
      p3: d,
      p4: e,
      p5: f,
      p6: g
    };
  }
  /**
   * @hidden
   */
  static _gf(a) {
    return truncate(Math.ceil(a / 4)) * 2 + 1;
  }
  /**
   * @hidden
   */
  _hp(a, b, c, d) {
    let e = c ? this._rows$i.maxCount : this._columns$i.maxCount;
    let f = !nullableIsNull(a) ? a.value : 0;
    let g = !nullableIsNull(b) ? b.value : (nullableEquals(a, null) ? e : 1);
    let h = f + g - 1;
    if (f < 0 || g < 0 || e <= h) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_InvalidRowOrColumnRange"));
    }
    let i = false;
    if (c && this._dv != d) {
      let j = h - f;
      if ((intDivide(this._rows$i.maxCount, 2)) < j) {
        i = true;
      }
    }
    let k = null;
    if (this._dz(c)) {
      k = c ? WorksheetElementResizeContext.e(this, f, h, Nullable$1.toNullable(Boolean_$type, d), i) : WorksheetElementResizeContext.c(this, f, h, d);
      if (c) {
        this._ix(true, false);
      }
      else {
        this._iv(true, false);
      }
    }
    let l = k != null ? k.i : (c ? WorksheetElementResizeContext.n(this, f, h, Nullable$1.toNullable(Boolean_$type, d), i) : WorksheetElementResizeContext.k(this, f, h, d));
    let m = c ? (d ? 6 : 10) : (d ? 5 : 9);
    let n = Worksheet._ax[m];
    let o = new WorksheetResizeInfo();
    let p = new Worksheet_HideUnhideChangeContext(1, this, f, h, i, c, l, o);
    let q = n.b(this.workbook, this, null);
    let r = false;
    if (this.workbook != null) {
      r = this.workbook._df;
      this.workbook._df = true;
    }
    this._i0(o, false);
    if (i) {
      this._iu(d, false);
    }
    if (c) {
      if (this._dv == d) {
        for (let s of fromEnum(this._rows$i._m(f, h))) {
          s._aa(d, false);
        }
      }
      else {
        for (let t = f; t <= h; t++) {
          this._rows$i.item(t)._aa(d, false);
        }
      }
    }
    else {
      this._cc(f, f);
      this._cc(h, h);
      for (let u of fromEnum(this._ff)) {
        if (f <= u.q && u.r <= h) {
          u.i = d;
        }
      }
    }
    if (k != null) {
      if (c) {
        this._ix(false, false);
      }
      else {
        this._iv(false, false);
      }
      k.y();
    }
    this._i0(null, false);
    if (this.workbook != null) {
      this.workbook._df = r;
    }
    n.e(Worksheet_HideUnhideChangeContext.$, String_$type, p, null, p.i());
    if (q != null) {
      n.d(this.workbook, q);
    }
  }
  /**
   * @hidden
   */
  _hu(a) {
    if (this._fa == null) {
      return;
    }
    let b = null;
    for (let c = this._fa.count - 1; c >= 0; c--) {
      let d = ExcelUtils.dy(this._fa._inner[c]);
      if (d == null) {
        this._fa.removeAt(c);
        continue;
      }
      if (a != null) {
        let e;
        let f = a(d, e);
        e = f.p1;
        if (e) {
          this._fa.removeAt(c);
          if (d.worksheet != null) {
            if (b == null) {
              b = new List$1(WorksheetRegion.$, 0);
            }
            b.add(d);
          }
        }
      }
    }
    if (b != null) {
      for (let g = 0; g < b.count; g++) {
        let h = b._inner[g];
        let i;
        let j = this._g5(h, i, true);
        i = j.p1;
      }
    }
  }
  /**
   * @hidden
   */
  _h1() {
    if (this._bw == null) {
      return;
    }
    this._iq(this._bw.c, this._bw.a, this._bw.b, false);
  }
  /**
   * @hidden
   */
  _id(a, b) {
    let c = b.b;
    if (c != null) {
      GenericCacheElementEx.q(WorksheetCellFormatData.$, c);
      if (c.f > 0) {
        b.b = c._bu();
      }
    }
    this._fe.removeAt(a);
  }
  /**
   * @hidden
   */
  static _i4(a, b) {
    let c = a.b;
    a.sheet._hf(c, a.c, Nullable$1.toNullable(Worksheet_CellInsertDeleteChangeContext.$, a));
  }
  /**
   * @hidden
   */
  static _i2(a, b) {
    if (a.b._dn) {
      a.b._ay = a.a;
    }
    else {
      a.b._h6(a.a, true);
    }
  }
  /**
   * @hidden
   */
  static _i3(a, b) {
    let c = a.b;
    a.sheet._hs(c, a.c, Nullable$1.toNullable(Worksheet_CellInsertDeleteChangeContext.$, a));
  }
  /**
   * @hidden
   */
  static _i5(a, b) {
    a.j(Worksheet._ax[9], false);
  }
  /**
   * @hidden
   */
  static _i6(a, b) {
    a.j(Worksheet._ax[10], false);
  }
  /**
   * @hidden
   */
  static _i7(a, b) {
    a.j(Worksheet._ax[5], true);
  }
  /**
   * @hidden
   */
  static _i8(a, b) {
    a.j(Worksheet._ax[6], true);
  }
  /**
   * @hidden
   */
  static _jb(a) {
    for (let b of fromEnum(a.ChildShapes)) {
      let c = typeCast(WorksheetShapeWithText.$, b);
      if (c != null && c.text != null) {
        c.text._aa(null);
      }
      let d = typeCast(WorksheetShapeGroupBase.$, b);
      if (d != null) {
        Worksheet._jb(d);
      }
    }
  }
  columns() {
    if (arguments.length !== 0) {
      let a = this._columns$i;
      return a.item.apply(a, arguments);
    }
    return this._columns$i;
  }
  /**
   * @hidden
   */
  get _columns$i() {
    if (this._ce == null) {
      this._ce = new WorksheetColumnCollection(this);
    }
    return this._ce;
  }
  conditionalFormats() {
    if (arguments.length !== 0) {
      let a = this._conditionalFormats$i;
      return a.item.apply(a, arguments);
    }
    return this._conditionalFormats$i;
  }
  /**
   * @hidden
   */
  get _conditionalFormats$i() {
    if (this._bg == null) {
      this._bg = new ConditionalFormatCollection(this);
    }
    return this._bg;
  }
  dataTables() {
    if (arguments.length !== 0) {
      let a = this._dataTables$i;
      return a.item.apply(a, arguments);
    }
    return this._dataTables$i;
  }
  /**
   * @hidden
   */
  get _dataTables$i() {
    if (this._cg == null) {
      this._cg = new WorksheetDataTableCollection(this);
    }
    return this._cg;
  }
  /**
   * @hidden
   */
  get _d5() {
    return this._cg != null && this._cg.count > 0;
  }
  dataValidationRules() {
    if (arguments.length !== 0) {
      let a = this._dataValidationRules$i;
      return a.item.apply(a, arguments);
    }
    return this._dataValidationRules$i;
  }
  /**
   * @hidden
   */
  get _dataValidationRules$i() {
    if (this._bj == null) {
      this._bj = new DataValidationRuleCollection(this);
    }
    return this._bj;
  }
  /**
   * @hidden
   */
  get _d6() {
    return this._bj != null && this._bj.count > 0;
  }
  /**
   * Gets or sets the default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * <p class="body">
   * The default column width is the width of all columns which do not have their width set.
   * </p>
   * <p class="body">
   * The value assigned must be between 0 and 65535. Invalid values will be automatically adjusted to valid values.
   * </p>
   * <p class="body">
   * Setting or getting this property is equivalent to calling [[setDefaultColumnWidth]]
   * or [[getDefaultColumnWidth]] using the [[WorksheetColumnWidthUnit]] value of Character256th.
   * </p>
   * The default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * @see [[getDefaultColumnWidth]]
   * @see [[setDefaultColumnWidth]]
   * @see [[WorksheetColumn.width]]
   * @see [[Workbook.characterWidth256thsToPixels]]
   * @see [[Workbook.pixelsToCharacterWidth256ths]]
   */
  get defaultColumnWidth() {
    return this._fx;
  }
  /**
   * Gets or sets the default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * <p class="body">
   * The default column width is the width of all columns which do not have their width set.
   * </p>
   * <p class="body">
   * The value assigned must be between 0 and 65535. Invalid values will be automatically adjusted to valid values.
   * </p>
   * <p class="body">
   * Setting or getting this property is equivalent to calling [[setDefaultColumnWidth]]
   * or [[getDefaultColumnWidth]] using the [[WorksheetColumnWidthUnit]] value of Character256th.
   * </p>
   * The default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * @see [[getDefaultColumnWidth]]
   * @see [[setDefaultColumnWidth]]
   * @see [[WorksheetColumn.width]]
   * @see [[Workbook.characterWidth256thsToPixels]]
   * @see [[Workbook.pixelsToCharacterWidth256ths]]
   */
  set defaultColumnWidth(a) {
    this._ir(a, true);
  }
  /**
   * @hidden
   */
  _ir(a, b) {
    if (a < 0) {
      a = 0;
    }
    if (65535 < a) {
      a = 65535;
    }
    if (this.defaultColumnWidth != a) {
      let c = null;
      if (this._dz(false)) {
        let d = WorksheetElementResizeContext.l(this, 0, this._columns$i.maxCount - 1);
        c = WorksheetElementResizeContext.d(this, d, false, this._fx);
      }
      let e = null;
      if (b) {
        e = this._g4(90, "DefaultColumnWidth");
        this._i0(new WorksheetResizeInfo(), true);
      }
      if (c != null) {
        this._iv(true, b);
      }
      this._is(a, b);
      if (c != null) {
        c.y();
        this._iv(false, b);
      }
      if (b) {
        this._i0(null, true);
        this._h4(e);
      }
      else {
      }
    }
  }
  /**
   * @hidden
   */
  _is(a, b) {
    if (b) {
      Worksheet._ax[0].h(SheetChangeInfoContext.$, Number_$type, this._h, a);
      return;
    }
    this._fx = a;
    this._bw = new Worksheet_SetColumnWidthInfo(a, 1, false);
  }
  /**
   * Gets or sets the default row height in twips (1/20th of a point).
   * <p class="body">
   * The default row height is the height of all rows which do not have their height explicitly set
   * to a positive number.
   * </p>
   * <p class="body">
   * If the assigned value is -1, the default row height will then be calculated based on the default font
   * for the workbook, and subsequently getting this property will return the font-based default row height.
   * </p>
   * The default row height in twips (1/20th of a point).
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the value range of -1 and 8192.
   */
  get defaultRowHeight() {
    if (this._f0 < 0) {
      return this._gp;
    }
    return this._f0;
  }
  /**
   * Gets or sets the default row height in twips (1/20th of a point).
   * <p class="body">
   * The default row height is the height of all rows which do not have their height explicitly set
   * to a positive number.
   * </p>
   * <p class="body">
   * If the assigned value is -1, the default row height will then be calculated based on the default font
   * for the workbook, and subsequently getting this property will return the font-based default row height.
   * </p>
   * The default row height in twips (1/20th of a point).
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the value range of -1 and 8192.
   */
  set defaultRowHeight(a) {
    if (this._f0 != a) {
      if (a < -1 || 8192 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_DefaultRowHeight"));
      }
      let b = null;
      if (this._dz(true)) {
        let c = WorksheetElementResizeContext.m(this, 0, this._rows$i.maxCount - 1);
        b = WorksheetElementResizeContext.d(this, c, true, this._f0);
      }
      let d = this._g4(90, "DefaultRowHeight");
      this._i0(new WorksheetResizeInfo(), true);
      if (b != null) {
        this._ix(true, true);
      }
      let e = this._f0;
      this._it(a, true);
      for (let f of fromEnum(this._rows$i)) {
        if (f.height < 0 || f.height == e) {
          f.height = a;
        }
        else {
          f._dx(false);
        }
      }
      if (b != null) {
        b.y();
        this._ix(false, true);
      }
      this._i0(null, true);
      this._h4(d);
    }
  }
  /**
   * @hidden
   */
  _it(a, b) {
    if (b) {
      Worksheet._ax[1].h(SheetChangeInfoContext.$, Number_$type, this._h, a);
      return;
    }
    this._f0 = a;
    this._rows$i._av();
  }
  /**
   * @hidden
   */
  get _d4() {
    return 0 <= this._f0;
  }
  /**
   * Gets the object which controls the display of the worksheet.
   * <p class="body">
   * The display options include any settings which affect the display of the worksheet when viewed in Microsoft Excel.
   * These settings will not affect the printed worksheet or the data stored in the worksheet.
   * </p>
   * The object which controls the display of the worksheet.
   * @see [[CustomView.getDisplayOptions]]
   */
  get displayOptions() {
    if (this._ci == null) {
      this._ci = new WorksheetDisplayOptions(this, true);
    }
    return this._ci;
  }
  /**
   * Exposes methods to identify a region in the worksheet and to apply filters and optionally sort criteria to that region.
   */
  get filterSettings() {
    return this._bl;
  }
  hyperlinks() {
    if (arguments.length !== 0) {
      let a = this._hyperlinks$i;
      return a.item.apply(a, arguments);
    }
    return this._hyperlinks$i;
  }
  /**
   * @hidden
   */
  get _hyperlinks$i() {
    if (this._cl == null) {
      this._cl = new WorksheetHyperlinkCollection(this);
    }
    return this._cl;
  }
  /**
   * @hidden
   */
  get _d8() {
    return this._cl != null && this._cl.count != 0;
  }
  /**
   * @hidden
   */
  get _je() {
    return this._jd;
  }
  /**
   * @hidden
   */
  set _je(a) {
    if (a != this._jd) {
      Worksheet._ax[7].h(SheetChangeInfoContext.$, WBitmap.$, this._h, a);
    }
  }
  /**
   * @hidden
   */
  _iz(a) {
    this._jd = a;
    this._dh = null;
  }
  /**
   * Gets the zero-based index of this worksheet in its parent [[Workbook.worksheets]] collection.
   * <p class="body">
   * Negative one indicates the worksheet has been removed from its parent collection.
   * </p>
   * The zero-based index of this worksheet in its parent Worksheets collection.
   * @see [[WorksheetCollection.indexOf]]
   * @see [[moveToIndex]]
   */
  get index() {
    if (this.workbook == null) {
      return -1;
    }
    return this.workbook._worksheets$i.indexOf(this);
  }
  mergedCellsRegions() {
    if (arguments.length !== 0) {
      let a = this._mergedCellsRegions$i;
      return a.item.apply(a, arguments);
    }
    return this._mergedCellsRegions$i;
  }
  /**
   * @hidden
   */
  get _mergedCellsRegions$i() {
    if (this._cs == null) {
      this._cs = new WorksheetMergedCellsRegionCollection(this);
    }
    return this._cs;
  }
  /**
   * @hidden
   */
  get _d9() {
    return this._cs != null && this._cs.count > 0;
  }
  /**
   * Gets the object which controls how the worksheet prints.
   * <p class="body">
   * The print options include any settings which affect the printed appearance of the worksheet.  These settings will
   * not affect the data in the worksheet.  Although these are not display settings, some worksheet display styles will
   * display all or some of the print options, so these settings may affect the display of the worksheet when viewed in
   * Microsoft Excel.
   * </p>
   * The object which controls how the worksheet prints.
   * @see [[CustomView.getPrintOptions]]
   */
  get printOptions() {
    if (this._bn == null) {
      this._bn = new PrintOptions(this, false);
    }
    return this._bn;
  }
  /**
   * Returns an object that provides information used when the Worksheet has been protected.
   * @see@see@see [[WorksheetProtection]]
   * @see [[protect]]
   * @see */
  get protection() {
    return this._cu;
  }
  rows() {
    if (arguments.length !== 0) {
      let a = this._rows$i;
      return a.item.apply(a, arguments);
    }
    return this._rows$i;
  }
  /**
   * @hidden
   */
  get _rows$i() {
    return this._c7;
  }
  /**
   * Exposes methods to identify a region in the worksheet and to apply sort criteria to that region.
   */
  get sortSettings() {
    return this._bs;
  }
  shapes() {
    if (arguments.length !== 0) {
      let a = this._shapes$i;
      return a.item.apply(a, arguments);
    }
    return this._shapes$i;
  }
  /**
   * @hidden
   */
  get _shapes$i() {
    if (this._db == null) {
      this._db = new WorksheetShapeCollection(this);
    }
    return this._db;
  }
  /**
   * @hidden
   */
  get ChildShapes() {
    return this._shapes$i;
  }
  sparklineGroups() {
    if (arguments.length !== 0) {
      let a = this._sparklineGroups$i;
      return a.item.apply(a, arguments);
    }
    return this._sparklineGroups$i;
  }
  /**
   * @hidden
   */
  get _sparklineGroups$i() {
    return this._bu;
  }
  tables() {
    if (arguments.length !== 0) {
      let a = this._tables$i;
      return a.item.apply(a, arguments);
    }
    return this._tables$i;
  }
  /**
   * @hidden
   */
  get _tables$i() {
    if (this._df == null) {
      this._df = new WorksheetTableCollection(this);
    }
    return this._df;
  }
  /**
   * Returns a value indicating the type of sheet
   */
  get_type() {
    return 0;
  }
  /**
   * Returns a value indicating the type of sheet
   */
  get type() {
    return this.get_type();
  }
  /**
   * @hidden
   */
  get _dr() {
    return this._di;
  }
  /**
   * @hidden
   */
  set _dr(a) {
    this._di = a;
  }
  /**
   * @hidden
   */
  get _es() {
    if (this._er == null) {
      this._er = new Dictionary$2(WorksheetCellAddress.$, WorksheetMergedCellsRegion.$, 0);
    }
    return this._er;
  }
  /**
   * @hidden
   */
  get _d1() {
    return this._er != null && this._er.count > 0;
  }
  /**
   * @hidden
   */
  get _fc() {
    if (this._fb == null) {
      this._fb = new List$1(CellShiftOperation.$, 0);
    }
    return this._fb;
  }
  /**
   * @hidden
   */
  get _fv() {
    if (this._fb == null) {
      return 0;
    }
    return this._fb.count;
  }
  /**
   * @hidden
   */
  get _eu() {
    if (this._et == null) {
      this._et = new Dictionary$2(WorksheetCellAddress.$, WorksheetCellComment.$, 0);
    }
    return this._et;
  }
  /**
   * @hidden
   */
  get _d2() {
    return this._et != null && this._et.count > 0;
  }
  /**
   * @hidden
   */
  get _ew() {
    if (this._ev == null) {
      this._ev = new Dictionary$2(ValueTuple$2.$.specialize(WorksheetRow.$, Number_$type), Base.$, 0);
    }
    return this._ev;
  }
  /**
   * @hidden
   */
  get _d3() {
    return this._ev != null && this._ev.count > 0;
  }
  /**
   * @hidden
   */
  get _fd() {
    if (this._e4 == null) {
      this._e4 = new List$1(WorksheetCell.$, 0);
    }
    return this._e4;
  }
  /**
   * @hidden
   */
  get _ff() {
    return this._fe;
  }
  /**
   * @hidden
   */
  get _b2() {
    return this._b1;
  }
  /**
   * @hidden
   */
  set _b2(a) {
    this._b1 = a;
  }
  /**
   * @hidden
   */
  get _b3() {
    let a = 0;
    let b = this._ff._inner[0].b;
    for (let c = 0; c < this._ff.count; c++) {
      let d = this._ff._inner[c];
      if (a <= d.t) {
        a = d.t;
        b = d.b;
      }
    }
    if (b._cd) {
      b = this.workbook != null ? this.workbook._ca._p : null;
    }
    return b;
  }
  /**
   * @hidden
   */
  get__e() {
    return this.displayOptions;
  }
  /**
   * @hidden
   */
  get _e() {
    return this.get__e();
  }
  /**
   * @hidden
   */
  get _gp() {
    if (this._go == 0 || this._gq != this.workbook._fp) {
      this._gq = this.workbook._fp;
      let a = this.workbook._styles$i.normalStyle._i;
      let b = a._df;
      let c = a._cq;
      let d = 0;
      let e = new Dictionary$2(Worksheet_FontNameHeightPair.$, Boolean_$type, 0);
      let f = this.workbook;
      let g = f != null ? f._bq : null;
      let h = g || Workbook._br(f);
      try {
        for (let i of fromEnum(this._ff)) {
          let j = i.b;
          let k = j._df;
          let l = j._cq;
          let m = new Worksheet_FontNameHeightPair(1, k, l);
          if (e.containsKey(m)) {
            continue;
          }
          e.addItem(m, true);
          d = Math.max(d, h._d(j));
        }
      }
      finally {
        if (g == null) {
          h.dispose();
        }
      }
      if (this._dt) {
        d++;
      }
      if (this._ds) {
        d++;
      }
      this._go = Math.min(truncate(Workbook._ep(this.workbook, d, true)), 8192);
    }
    return this._go;
  }
  /**
   * @hidden
   */
  _ij() {
    this._go = 0;
  }
  /**
   * @hidden
   */
  get _ds() {
    return this._dj;
  }
  /**
   * @hidden
   */
  set _ds(a) {
    if (this._dj == a) {
      return;
    }
    this._dj = a;
    this._ij();
  }
  /**
   * @hidden
   */
  get _dt() {
    return this._dk;
  }
  /**
   * @hidden
   */
  set _dt(a) {
    if (this._dk == a) {
      return;
    }
    this._dk = a;
    this._ij();
  }
  /**
   * @hidden
   */
  get _dv() {
    return this._du;
  }
  /**
   * @hidden
   */
  set _dv(a) {
    if (this._dv == a) {
      return;
    }
    Worksheet._ax[2].h(SheetChangeInfoContext.$, Boolean_$type, this._h, a);
  }
  /**
   * @hidden
   */
  _iu(a, b = true) {
    if (this._dv == a) {
      return;
    }
    let c = null;
    if (b && this._dz(true)) {
      c = WorksheetElementResizeContext.e(this, 0, this._c7.maxCount - 1, Nullable$1.toNullable(Boolean_$type, null), true);
    }
    this._du = a;
    this._rows$i._az(true);
    if (c != null) {
      c.y();
    }
  }
  /**
   * @hidden
   */
  get _dw() {
    return this._dl;
  }
  /**
   * @hidden
   */
  _iv(a, b) {
    if (b) {
      Worksheet._ax[18].h(SheetChangeInfoContext.$, Boolean_$type, this._h, a);
    }
    else {
      this._iw(a);
    }
  }
  /**
   * @hidden
   */
  _iw(a) {
    this._dl = a;
  }
  /**
   * @hidden
   */
  get _dx() {
    return this._dm;
  }
  /**
   * @hidden
   */
  _ix(a, b) {
    if (b) {
      Worksheet._ax[17].h(SheetChangeInfoContext.$, Boolean_$type, this._h, a);
    }
    else {
      this._iy(a);
    }
  }
  /**
   * @hidden
   */
  _iy(a) {
    this._dm = a;
  }
  /**
   * @hidden
   */
  _dy(a) {
    if (!this._d0) {
      return false;
    }
    let b = typeCast(WorksheetRow.$, a) !== null ? this._dm : this._dl;
    if (b) {
      return false;
    }
    return true;
  }
  /**
   * @hidden
   */
  _dz(a) {
    if (!this._d0) {
      return false;
    }
    let b = a ? this._dm : this._dl;
    if (b) {
      return false;
    }
    return true;
  }
  /**
   * @hidden
   */
  get _d0() {
    if (this._t) {
      return false;
    }
    return (this._db != null && this._db.count != 0) || (this._et != null && this._et.count != 0);
  }
  /**
   * @hidden
   */
  get _ea() {
    return this._eq.count != 0;
  }
  /**
   * @hidden
   */
  get _eb() {
    return this._e6 != null && this._e6.count != 0;
  }
  /**
   * @hidden
   */
  get _gl() {
    return 9;
  }
  /**
   * @hidden
   */
  get _ee() {
    return this._dn;
  }
  /**
   * @hidden
   */
  get _g3() {
    return this._g2;
  }
  /**
   * @hidden
   */
  set _g3(a) {
    this._g2 = a;
  }
  /**
   * @hidden
   */
  get__g() {
    return this.printOptions;
  }
  /**
   * @hidden
   */
  get _g() {
    return this.get__g();
  }
  /**
   * @hidden
   */
  get _c6() {
    return this._c5;
  }
  /**
   * @hidden
   */
  _i0(a, b) {
    if (b) {
      Worksheet._ax[16].h(SheetChangeInfoContext.$, WorksheetResizeInfo.$, this._h, a);
    }
    else {
      this._i1(a);
    }
  }
  /**
   * @hidden
   */
  _i1(a) {
    if (this._c5 != null) {
      this._c5.h();
    }
    this._c5 = a;
    if (this._c5 != null) {
      this._c5.j();
    }
  }
  /**
   * @hidden
   */
  get__p() {
    return this._shapes$i;
  }
  /**
   * @hidden
   */
  get _p() {
    return this.get__p();
  }
  /**
   * @hidden
   */
  get__i() {
    return this.protection;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * @hidden
   */
  get _ek() {
    return this._ej;
  }
  /**
   * @hidden
   */
  set _ek(a) {
    this._ej = a;
  }
  /**
   * @hidden
   */
  get _em() {
    return this._el;
  }
  /**
   * @hidden
   */
  set _em(a) {
    this._el = a;
  }
  /**
   * @hidden
   */
  static get _fh() {
    if (Worksheet._e7 == null) {
      Worksheet._e7 = new List$1(Tuple$3.$.specialize(Worksheet.$, WorksheetRegionAddress.$, String_$type), 0);
    }
    return Worksheet._e7;
  }
  /**
   * @hidden
   */
  get _br() {
    return this._bq;
  }
  /**
   * @hidden
   */
  set _br(a) {
    this._bq = a;
  }
  /**
   * @hidden
   */
  get__ag() {
    return this.index;
  }
  /**
   * @hidden
   */
  get _jg() {
    return this._jf;
  }
  /**
   * @hidden
   */
  set _jg(a) {
    if (PointUtil.equals(this._jg, a)) {
      return;
    }
    let b = Worksheet._ax[11].g(SheetChangeInfoContext.$, Point_$type, this._h, this._jf, a);
    this._jf = b.p1;
  }
  /**
   * @hidden
   */
  get _fi() {
    if (this._e9 == null) {
      this._e9 = new List$1(WorksheetCell.$, 0);
    }
    return this._e9;
  }
  /**
   * @hidden
   */
  get _g0() {
    if (this.workbook == null) {
      return 7;
    }
    return this.workbook._gj;
  }
}
Worksheet.$t = markType(Worksheet, 'Worksheet', Sheet.$, [IWorksheetShapeOwner_$type, ISortSettingsOwner_$type]);
/**
 * @hidden
 */
Worksheet._fz = 0;
/**
 * @hidden
 */
Worksheet._f2 = 1;
/**
 * @hidden
 */
Worksheet._f3 = 2;
/**
 * @hidden
 */
Worksheet._f4 = 3;
/**
 * @hidden
 */
Worksheet._f5 = 4;
/**
 * @hidden
 */
Worksheet._gi = 5;
/**
 * @hidden
 */
Worksheet._gj = 6;
/**
 * @hidden
 */
Worksheet._gk = 7;
/**
 * @hidden
 */
Worksheet._gn = 8;
/**
 * @hidden
 */
Worksheet._gx = 9;
/**
 * @hidden
 */
Worksheet._gy = 10;
/**
 * @hidden
 */
Worksheet._gz = 11;
/**
 * @hidden
 */
Worksheet._gv = 12;
/**
 * @hidden
 */
Worksheet._gw = 13;
/**
 * @hidden
 */
Worksheet._gs = 14;
/**
 * @hidden
 */
Worksheet._gu = 15;
/**
 * @hidden
 */
Worksheet._gt = 16;
/**
 * @hidden
 */
Worksheet._f7 = 17;
/**
 * @hidden
 */
Worksheet._f6 = 18;
/**
 * @hidden
 */
Worksheet._gr = 19;
/**
 * @hidden
 */
Worksheet._ax = null;
/**
 * @hidden
 */
Worksheet._e8 = null;
/**
 * @hidden
 */
Worksheet._e7 = null;
/**
 * Represents a cell in a Microsoft Excel worksheet.
 */
export class WorksheetCell extends Base {
  constructor(a, b) {
    super();
    this._h = null;
    this._ac = 0;
    this._aa = 0;
    this._n = null;
    this._aa = b;
    this._n = a;
    if (this._n != null) {
      this._ac = this._n.worksheet._fv;
    }
  }
  /**
   * @hidden
   */
  get cellFormatInternal() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  compareTo(other) {
    if (Base.referenceEquals(this, other)) {
      return 0;
    }
    if (WorksheetCell.l_op_Equality(other, null)) {
      return -1;
    }
    let a = this._o;
    let b = other._o;
    if (a == null && b == null) {
      return 0;
    }
    if (a == null) {
      return 1;
    }
    else if (b == null) {
      return -1;
    }
    let c = a.index - b.index;
    if (c != 0) {
      return c;
    }
    return this._aa - other._aa;
  }
  /**
   * @hidden
   */
  get allowDefaultValues() {
    return false;
  }
  /**
   * @hidden
   */
  getDefaultFont() {
    if (this._o == null) {
      return null;
    }
    return this._o._az(this._ab).font;
  }
  /**
   * @hidden
   */
  getFontDefaultsResolver() {
    let a = this.worksheet;
    if (a == null) {
      return null;
    }
    return this._o._a7(this._ab);
  }
  /**
   * @hidden
   */
  onUnformattedStringChanged(sender) {
    let a = this._o;
    if (a != null) {
      a._ec(this._aa, sender._m);
    }
  }
  /**
   * @hidden
   */
  onFormattingChanged() {
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
  /**
   * Determines whether the specified object is another [[WorksheetCell]] instance which refers
   * to the same location on the same worksheet as this cell.
   * @param obj The instance to check for equality.
   * @return True if the cells refer to the same location on the same worksheet; False otherwise.
   */
  equals(obj) {
    return CompareUtil.compareTo(this, typeCast(WorksheetCell.$, obj)) == 0;
  }
  /**
   * Gets the hash code of the [[WorksheetCell]].
   * @return The hash code of the [[WorksheetCell]].
   */
  getHashCode() {
    let a = this._o;
    if (a == null) {
      return 0;
    }
    return Base.getHashCodeStatic(a) ^ (this._aa);
  }
  toString() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 4) {
      n = 2;
    }
    switch (n) {
      case 0: return this._toString.apply(this, arguments);
      case 1: return this._toString1.apply(this, arguments);
      case 2: return this._toString2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toString() {
    let a = 1;
    let b = this.worksheet;
    if (b != null) {
      a = b._c;
    }
    return this._toString1(a, true);
  }
  /**
   * Applies a formula to the cell.
   * <p class="body">
   * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
   * to which the cell belongs. If the cell's [[worksheet]] has been removed from its parent collection,
   * the A1 CellReferenceMode will be used to parse the formula.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.applyCellFormula]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this method is equivalent to using the WorksheetRow.ApplyCellFormula method.
   * </p>
   * @param value The formula to parse and apply to the cell.
   * @throws [[ArgumentNullException]] 'value' is null or empty.
   * @throws [[FormulaParseException]] 'value' is not a valid formula.
   * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
   * @see [[formula]]
   * @see [[WorksheetRow.applyCellFormula]]
   */
  applyFormula(value) {
    let a = this._o;
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    a._applyCellFormula$i(this._aa, value);
  }
  /**
   * Removes the comment associated with the cell.
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.setCellComment]] method and pass in null as the
   * comment parameter, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
   * WorksheetCell instance already exists, using this method is equivalent to using the WorksheetRow.SetCellComment method and
   * passing in null as the comment parameter.
   * </p>
   * @see [[comment]]
   * @see [[hasComment]]
   * @see [[WorksheetRow.setCellComment]]
   */
  clearComment() {
    let a = this._o;
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    a._d2(this._aa, null);
  }
  getBoundsInTwips() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return rectToLiteral(this._getBoundsInTwips.apply(this, arguments));
      case 1: return rectToLiteral(this._getBoundsInTwips1.apply(this, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getBoundsInTwips() {
    return this._getBoundsInTwips1(0);
  }
  /**
   * @hidden
   */
  _getBoundsInTwips1(a) {
    let b = this._o;
    if (b == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    return b._em(this._aa, a);
  }
  static getCellAddressString() {
    let n;
    if (arguments.length === 4) {
      n = 0;
    }
    else if (arguments.length === 6) {
      n = 1;
    }
    switch (n) {
      case 0: return WorksheetCell._getCellAddressString.apply(null, arguments);
      case 1: return WorksheetCell._getCellAddressString1.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _getCellAddressString(a, b, c, d) {
    return WorksheetCell._getCellAddressString1(a, b, c, d, false, false);
  }
  /**
   * @hidden
   */
  static _getCellAddressString1(a, b, c, d, e, f) {
    let g = a.worksheet;
    return (d ? ExcelUtils.d5(null, g.name) : stringEmpty()) + CellAddress.u(a.index, b, g._o, f, e, a.index, b, false, c);
  }
  /**
   * Gets the effective hyperlink on the cell.
   * <p class="body">
   * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
   * collection will be used.
   * </p>
   * <p class="body">
   * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
   * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
   * </p>
   * <p class="body">
   * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
   * </p>
   * @see [[Worksheet.hyperlinks]]
   * @see [[WorksheetHyperlink]]
   * @see [[WorksheetHyperlink.isSealed]]
   */
  getHyperlink() {
    let a = this._o;
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    return a.getCellHyperlink(this._aa);
  }
  getText() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getText.apply(this, arguments);
      case 1: return this._getText1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getText() {
    return this._getText1(0);
  }
  /**
   * @hidden
   */
  _getText1(a) {
    let b = this._o;
    if (b == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    return b._da(this._aa, a);
  }
  /**
   * Gets the resolved cell formatting for this cell.
   * <p class="body">
   * If any cell format properties are the default values on the cell, the values from the owning row's cell format will be used.
   * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
   * will be used.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getResolvedCellFormat]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this method is equivalent to using the WorksheetRow.GetResolvedCellFormat method.
   * </p>
   * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
   * @see [[cellFormat]]
   * @see [[RowColumnBase.cellFormat]]
   * @see [[WorksheetRow.getResolvedCellFormat]]
   */
  getResolvedCellFormat() {
    let a = this._o;
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    return a._getResolvedCellFormat1(this._aa);
  }
  /**
   * Returns True if a particular type of value can be exported to excel.
   * @param cellType The type to test.
   * @throws [[ArgumentNullException]] 'cellType' is null.
   * @return True if the type is supported as a cell value, False otherwise.
   */
  static isCellTypeSupported(cellType) {
    if (cellType == null) {
      throw new ArgumentNullException(0, "cellType");
    }
    return WorksheetCell._z.contains(cellType) || ExcelUtils.a3(cellType);
  }
  /**
   * @hidden
   */
  _toString1(a, b) {
    let c = this._o;
    if (c == null) {
      return ErrorValue.invalidCellReference.toString();
    }
    return c._c7(this._aa, a, b);
  }
  /**
   * @hidden
   */
  _toString2(a, b, c, d) {
    let e = this._o;
    if (e == null) {
      return ErrorValue.invalidCellReference.toString();
    }
    return e._c7(this._aa, a, b, c, d);
  }
  /**
   * Returns a boolean indicating if the value of the cell is valid considering the associated [[dataValidationRule]]
   * @return Returns false if the cell has an associated [[dataValidationRule]] and the current [[value]] does not pass the validation defined by that rule; otherwise true is returned.
   * @see [[value]]
   * @see [[dataValidationRule]]
   * @see [[Worksheet.dataValidationRules]]
   */
  validateValue() {
    let a = this._o;
    if (a == null) {
      return true;
    }
    return a.validateCellValue(this.columnIndex);
  }
  /**
   * @hidden
   */
  _l() {
    let a = this._o;
    if (a == null || a.worksheet == null) {
      return null;
    }
    return a.worksheet._cx(a.index, this._aa, a.index, this._aa);
  }
  /**
   * @hidden
   */
  _aq() {
    this._n = null;
    this._aa = -1;
  }
  /**
   * @hidden
   */
  _ar() {
    if (this._n == null) {
      return;
    }
    let a = this._n.worksheet;
    if (a == null || ((() => { let b = a._eo(this._n, this._aa, this._ac); this._n = b.p0; this._aa = b.p1; this._ac = b.p2; return b.ret; })()) == false) {
      this._aq();
    }
  }
  /**
   * Gets the data table to which the cell belongs.
   * <p class="body">
   * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
   * </p>
   * <p class="body">
   * If a data table is associated with the cell, getting the [[value]] will return the calculated value for the cell.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedDataTable]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedDataTable method.
   * </p>
   * The data table to which the cell belongs or null if the cell does not belong to a data table.
   * @see [[Worksheet.dataTables]]
   * @see [[WorksheetDataTableCollection.add]]
   * @see [[WorksheetRow.getCellAssociatedDataTable]]
   */
  get associatedDataTable() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._bg(this._aa);
  }
  /**
   * Gets the merged cells region which contains the cell, or null if the cell is not merged.
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedMergedCellsRegion]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedMergedCellsRegion method.
   * </p>
   * The merged cells region which contains the cell, or null if the cell is not merged.
   * @see [[WorksheetRow.getCellAssociatedMergedCellsRegion]]
   */
  get associatedMergedCellsRegion() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._bl(this._aa);
  }
  /**
   * Gets the [[WorksheetTable]] to which this cell belongs.
   * <p class="body">
   * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedTable]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedTable method.
   * </p>
   * @see [[WorksheetTable]]
   * @see [[Worksheet.tables]]
   */
  get associatedTable() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._bp(this._aa);
  }
  /**
   * Gets the cell formatting for this cell.
   * <p class="body">
   * Use this property to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
   * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
   * </p>
   * <p class="body">
   * If this cell belongs to a merged cell region, getting the CellFormat will get the CellFormat of the associated merged
   * cell region.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormat]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormat method.
   * </p>
   * The cell formatting for this cell.
   * @see [[getResolvedCellFormat]]
   * @see [[WorksheetRow.getCellFormat]]
   */
  get cellFormat() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  get _cellFormatInternal() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    if (this._h == null) {
      this._h = a._bc(this._aa);
    }
    return this._h;
  }
  /**
   * Gets the value which indicates whether the cell's format has been initialized yet.
   * @see [[cellFormat]]
   */
  get hasCellFormat() {
    let a = this._o;
    if (a == null) {
      return false;
    }
    return a._a8(this._aa) != null;
  }
  /**
   * Gets the column index of the cell.
   * The column index of the cell.
   */
  get columnIndex() {
    return this._ab;
  }
  /**
   * @hidden
   */
  get _ab() {
    this._ar();
    return this._aa;
  }
  /**
   * Gets or sets the comment applied to the cell.
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] or
   * [[WorksheetRow.setCellComment]] methods, which do not create [[WorksheetCell]] instances internally. However,
   * if a reference to the WorksheetCell instance already exists, using this property is equivalent to using the
   * WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
   * </p>
   * The comment applied to the cell.
   * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
   * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
   * anchors set but they are from different worksheets.
   * @see [[WorksheetRow.getCellComment]]
   * @see [[WorksheetRow.setCellComment]]
   */
  get comment() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._a6(this._aa);
  }
  /**
   * Gets or sets the comment applied to the cell.
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] or
   * [[WorksheetRow.setCellComment]] methods, which do not create [[WorksheetCell]] instances internally. However,
   * if a reference to the WorksheetCell instance already exists, using this property is equivalent to using the
   * WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
   * </p>
   * The comment applied to the cell.
   * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
   * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
   * anchors set but they are from different worksheets.
   * @see [[WorksheetRow.getCellComment]]
   * @see [[WorksheetRow.setCellComment]]
   */
  set comment(a) {
    let b = this._o;
    if (b == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    b._d2(this._aa, a);
  }
  /**
   * Gets or sets the data validation rule for the [[WorksheetCell]].
   * @throws [[ArgumentException]] Occurs when the value specified is already applied to cells in another worksheet.
   * @throws [[ArgumentException]] Occurs when the value specified is invalid based on its rule type's requirements.
   * @see [[Worksheet.dataValidationRules]]
   * @see [[AnyValueDataValidationRule]]
   * @see [[ListDataValidationRule]]
   * @see [[CustomDataValidationRule]]
   * @see [[OneConstraintDataValidationRule]]
   * @see [[TwoConstraintDataValidationRule]]
   */
  get dataValidationRule() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    let b = a.worksheet;
    if (b._d6 == false) {
      return null;
    }
    return b._dataValidationRules$i.findRule(this);
  }
  /**
   * Gets or sets the data validation rule for the [[WorksheetCell]].
   * @throws [[ArgumentException]] Occurs when the value specified is already applied to cells in another worksheet.
   * @throws [[ArgumentException]] Occurs when the value specified is invalid based on its rule type's requirements.
   * @see [[Worksheet.dataValidationRules]]
   * @see [[AnyValueDataValidationRule]]
   * @see [[ListDataValidationRule]]
   * @see [[CustomDataValidationRule]]
   * @see [[OneConstraintDataValidationRule]]
   * @see [[TwoConstraintDataValidationRule]]
   */
  set dataValidationRule(a) {
    let b = this._o;
    if (b == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    let c = b.worksheet;
    if (a == null) {
      if (c._d6) {
        c._dataValidationRules$i._remove2(this);
      }
    }
    else {
      c._dataValidationRules$i._add5(a, WorksheetReferenceCollection._e(this));
    }
  }
  /**
   * Get the value indicating whether the cell has an associated comment.
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] method and check for a non null
   * return value, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
   * WorksheetCell instance already exists, using this property is equivalent to using the WorksheetRow.GetCellComment method
   * and checking for a non null return value.
   * </p>
   * True if the cell has an associated comment; False otherwise.
   * @see [[comment]]
   * @see [[WorksheetRow.getCellComment]]
   */
  get hasComment() {
    let a = this._o;
    if (a == null) {
      return false;
    }
    return a._a6(this._aa) != null;
  }
  /**
   * Gets the formula which has been applied to the cell.
   * <p class="body">
   * If a formula has been applied to the cell, getting the [[value]] will return the calculated value of the formula.
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormula]] method, which does not
   * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormula method.
   * </p>
   * The formula which has been applied to the cell or null if no formula has been applied.
   * @see [[Formula.applyTo]]
   * @see [[Formula.applyTo]]
   * @see [[Formula.applyTo]]
   * @see [[applyFormula]]
   * @see [[WorksheetRegion.applyFormula]]
   * @see [[WorksheetRegion.applyArrayFormula]]
   * @see [[WorksheetRow.getCellFormula]]
   */
  get formula() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._ar(this._aa);
  }
  /**
   * Gets the row index of the cell.
   * The row index of the cell.
   */
  get rowIndex() {
    let a = this._o;
    if (a == null) {
      return -1;
    }
    return a.index;
  }
  /**
   * Gets or sets the value of the cell.
   * <p class="body">
   * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
   * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
   * will always return null. Setting the value of other cells in a merged cell region will have no effect.
   * </p>
   * <p class="body">
   * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
   * calculated value of the cell.
   * </p>
   * <p class="body">
   * The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellValue]] or [[WorksheetRow.setCellValue]]
   * methods, which do not create [[WorksheetCell]] instances internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
   * </p>
   * The value of the cell.
   * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
   * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
   * should be called on the Formula, passing in the cell.
   * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
   * should be set to a region containing the cell.
   * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
   * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
   * @see [[associatedMergedCellsRegion]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   * @see [[WorksheetMergedCellsRegion.value]]
   * @see [[formula]]
   * @see [[associatedDataTable]]
   * @see [[WorksheetRow.getCellValue]]
   * @see [[WorksheetRow.setCellValue]]
   */
  get value() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a._c5(this._aa);
  }
  /**
   * Gets or sets the value of the cell.
   * <p class="body">
   * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
   * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
   * will always return null. Setting the value of other cells in a merged cell region will have no effect.
   * </p>
   * <p class="body">
   * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
   * calculated value of the cell.
   * </p>
   * <p class="body">
   * The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * <p class="note">
   * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellValue]] or [[WorksheetRow.setCellValue]]
   * methods, which do not create [[WorksheetCell]] instances internally. However, if a reference to the WorksheetCell instance
   * already exists, using this property is equivalent to using the WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
   * </p>
   * The value of the cell.
   * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
   * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
   * should be called on the Formula, passing in the cell.
   * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
   * should be set to a region containing the cell.
   * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
   * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
   * @see [[associatedMergedCellsRegion]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   * @see [[WorksheetMergedCellsRegion.value]]
   * @see [[formula]]
   * @see [[associatedDataTable]]
   * @see [[WorksheetRow.getCellValue]]
   * @see [[WorksheetRow.setCellValue]]
   */
  set value(a) {
    let b = this._o;
    if (b == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
    b.setCellValue(this._aa, a);
  }
  /**
   * Gets the worksheet to which the cell belongs.
   * The worksheet to which the cell belongs.
   */
  get worksheet() {
    let a = this._o;
    if (a == null) {
      return null;
    }
    return a.worksheet;
  }
  /**
   * @hidden
   */
  get _e() {
    let a = this._o;
    if (a == null) {
      return WorksheetCellAddress.b;
    }
    return new WorksheetCellAddress(1, a.index, this._aa);
  }
  /**
   * @hidden
   */
  get _m() {
    let a = this._o;
    if (a == null) {
      return WorksheetRegionAddress._b;
    }
    return new WorksheetRegionAddress(1, a.index, a.index, this._aa, this._aa);
  }
  /**
   * @hidden
   */
  get _o() {
    this._ar();
    return this._n;
  }
  /**
   * @hidden
   */
  static l_op_Equality(a, b) {
    if (Base.referenceEquals(a, b)) {
      return true;
    }
    let c = a == null;
    let d = b == null;
    if (c && d) {
      return true;
    }
    if (c || d) {
      return false;
    }
    a._ar();
    b._ar();
    return a._n == b._n && a._aa == b._aa;
  }
  /**
   * @hidden
   */
  static l_op_Inequality(a, b) {
    return !(WorksheetCell.l_op_Equality(a, b));
  }
}
WorksheetCell.$t = markType(WorksheetCell, 'WorksheetCell', Base.$, [ICellFormatOwner_$type, IComparable$1_$type.specialize(-1), IFormattedStringOwner_$type]).initSelfReferences();
/**
 * @hidden
 */
WorksheetCell._d = new WorksheetCell(null, -1);
/**
 * @hidden
 */
WorksheetCell._z = ((() => {
  let $ret = new HashSet$1(Type.$, 0);
  $ret.add_1(Boolean_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(String_$type);
  $ret.add_1(String_$type);
  $ret.add_1(Enum.$);
  $ret.add_1(Date_$type);
  $ret.add_1(Number_$type);
  $ret.add_1(StringBuilder.$);
  $ret.add_1(Guid.$);
  $ret.add_1(ErrorValue.$);
  $ret.add_1(FormattedString.$);
  $ret.add_1(StringElement.$);
  $ret.add_1(FormattedStringElement.$);
  $ret.add_1(SingleTargetFormula.$);
  $ret.add_1(ArrayInteriorFormula.$);
  $ret.add_1(DataTableInteriorFormula.$);
  return $ret;
})());
/**
 * Represents a rectangular region of cells on a worksheet.
 */
export class WorksheetRegion extends Base {
  constructor(..._rest) {
    super();
    this._b = null;
    this._i = new WorksheetRegionAddress();
    this._j = null;
    this._e = null;
    let a;
    if (arguments.length === 5) {
      a = 0;
    }
    else if (arguments.length === 6) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let worksheet = _rest[0];
          let firstRow = _rest[1];
          let firstColumn = _rest[2];
          let lastRow = _rest[3];
          let lastColumn = _rest[4];
          let b = [worksheet, firstRow, firstColumn, lastRow, lastColumn, true];
          {
            let worksheet = b[0];
            let firstRow = b[1];
            let firstColumn = b[2];
            let lastRow = b[3];
            let lastColumn = b[4];
            let addCachedRegion = b[5];
            if (worksheet == null) {
              throw new ArgumentNullException(0, "worksheet");
            }
            WorksheetRegion._ap(firstRow, lastRow);
            WorksheetRegion._am(firstColumn, lastColumn);
            ExcelUtils.gp(worksheet, firstRow, "firstRow");
            ExcelUtils.gp(worksheet, lastRow, "lastRow");
            ExcelUtils.gi(worksheet, firstColumn, "firstColumn");
            ExcelUtils.gi(worksheet, lastColumn, "lastColumn");
            this._e = worksheet;
            this._i = new WorksheetRegionAddress(1, firstRow, lastRow, firstColumn, lastColumn);
            if (addCachedRegion) {
              let c;
              let d = this._e._g5(this, c);
              c = d.p1;
            }
          }
        }
        break;
      case 1:
        {
          let worksheet = _rest[0];
          let firstRow = _rest[1];
          let firstColumn = _rest[2];
          let lastRow = _rest[3];
          let lastColumn = _rest[4];
          let addCachedRegion = _rest[5];
          if (worksheet == null) {
            throw new ArgumentNullException(0, "worksheet");
          }
          WorksheetRegion._ap(firstRow, lastRow);
          WorksheetRegion._am(firstColumn, lastColumn);
          ExcelUtils.gp(worksheet, firstRow, "firstRow");
          ExcelUtils.gp(worksheet, lastRow, "lastRow");
          ExcelUtils.gi(worksheet, firstColumn, "firstColumn");
          ExcelUtils.gi(worksheet, lastColumn, "lastColumn");
          this._e = worksheet;
          this._i = new WorksheetRegionAddress(1, firstRow, lastRow, firstColumn, lastColumn);
          if (addCachedRegion) {
            let b;
            let c = this._e._g5(this, b);
            b = c.p1;
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Determines whether the specified value equals this [[WorksheetRegion]].
   * @param obj The value to test for equality.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(WorksheetRegion.$, obj);
    if (a == null) {
      return false;
    }
    if (this._e != a._e) {
      return false;
    }
    if (this._e == null) {
      return true;
    }
    return WorksheetRegionAddress._o(this._i, a._i);
  }
  /**
   * Gtes the hash code for the [[WorksheetRegion]].
   */
  getHashCode() {
    if (this._e == null) {
      return 0;
    }
    let a = Base.getHashCodeStatic(this._e);
    a ^= this._i.getHashCode();
    return a;
  }
  toString() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 4) {
      n = 2;
    }
    switch (n) {
      case 0: return this._toString.apply(this, arguments);
      case 1: return this._toString1.apply(this, arguments);
      case 2: return this._toString2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toString() {
    let a = 1;
    if (this._e != null) {
      a = this._e._c;
    }
    return this._toString1(a, true);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    if (this._e == null) {
      return undefined;
    }
    for (let a = this._i._ac; a <= this._i._ae; a++) {
      let b = this._e._rows$i.item(a);
      for (let c = this._i._w; c <= this._i._x; c++) {
        yield b._cells$i.item(c);
      }
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Applies a array formula to the region of cells.
   * <p class="body">
   * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
   * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
   * the A1 CellReferenceMode will be used to parse the formula.
   * </p>
   * @param value The array formula to parse and apply to the region.
   * @throws [[ArgumentNullException]] 'value' is null or empty.
   * @throws [[FormulaParseException]] 'value' is not a valid formula.
   * @throws [[InvalidOperationException]] The region contains another array formula or data table which extends outside the region.
   * @see [[ArrayFormula]]
   */
  applyArrayFormula(value) {
    this._ao();
    let a = ArrayFormula._ci(value, this._e.workbook);
    a._applyTo3(this);
  }
  /**
   * Applies a formula to the region of cells.
   * <p class="body">
   * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
   * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
   * the A1 CellReferenceMode will be used to parse the formula.
   * </p>
   * @param value The formula to parse and apply to the region.
   * @throws [[ArgumentNullException]] 'value' is null or empty.
   * @throws [[FormulaParseException]] 'value' is not a valid formula.
   * @throws [[InvalidOperationException]] The region contains an array formula or data table which extends outside the region.
   * @see [[Formula]]
   */
  applyFormula(value) {
    this._ao();
    let a = this.worksheet.workbook;
    let b = false;
    if (a != null && a.cellReferenceMode == 0) {
      let c;
      if (((() => { let d = a._d1.tryGetValue(value, c); c = d.p1; return d.ret; })())) {
        c._applyTo3(this);
        return;
      }
      b = true;
    }
    let d = Formula._p(value, a);
    if (b) {
      a._d1.addItem(value, d);
    }
    d._applyTo3(this);
  }
  formatAsTable() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._formatAsTable.apply(this, arguments);
      case 1: return this._formatAsTable1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _formatAsTable(a) {
    return this._formatAsTable1(a, null);
  }
  /**
   * @hidden
   */
  _formatAsTable1(a, b) {
    this._ao();
    return this.worksheet._tables$i._add1(this, a, b);
  }
  getBoundsInTwips() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return rectToLiteral(this._getBoundsInTwips.apply(this, arguments));
      case 1: return rectToLiteral(this._getBoundsInTwips1.apply(this, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getBoundsInTwips() {
    return this._getBoundsInTwips1(0);
  }
  /**
   * @hidden
   */
  _getBoundsInTwips1(a) {
    this._ao();
    return WorksheetShape._du(this._e, this._i._ac, this._i._w, ExcelUtils.g8, this._i._ae, this._i._x, { $type: Point_$type, x: 100, y: 100 }, a);
  }
  /**
   * @hidden
   */
  _toString1(a, b) {
    return this._toString2(a, b, false, false);
  }
  /**
   * @hidden
   */
  _toString2(a, b, c, d) {
    if (this.worksheet == null) {
      return ErrorValue.invalidCellReference.toString();
    }
    return stringFormat("{0}{1}", (b ? ExcelUtils.d5(null, this._e.name) : stringEmpty()), this._i._ah(d, c, this._e._o, a));
  }
  /**
   * @hidden
   */
  _aj(a, b, c, d = 0) {
    let e = this._v;
    if (b == null) {
      b = this._k;
      c = e;
    }
    else {
      let f = ExcelUtils.g5(this._k.index - b.index, this._v - c);
      if (a._ad(this.worksheet.workbook, this._k, this._v, f) == false) {
        a = a._w(b.index, c, b.worksheet._o);
        for (let g = this.firstRow; g <= this.lastRow; g++) {
          let h = this._e._rows$i.item(g);
          for (let i = this._v; i <= this._w; i++) {
            a._bq(b, c, h, i, d);
          }
        }
        return {
          p1: b,
          p2: c
        };
      }
    }
    if (this._aa == 1) {
      let j = this._ad > 48;
      let k = this.firstColumn;
      let l = a._x(b.index, c, b.worksheet._o);
      let m = this._e._rows$i.item(this.firstRow);
      for (let n = e; n <= this._w; n++) {
        if (j && (n - k) >= 32) {
          this._e._h2(l, this._e._cx(this.firstRow, k, this.firstRow, n - 1));
          l = new SingleTargetFormula(3, l, true);
          k = n;
        }
        l._bq(b, c, m, n, d);
      }
      this._e._h2(l, this._e._cx(this.firstRow, k, this.firstRow, this.lastColumn));
    }
    else {
      let o = this._aa > 48;
      let p = this.firstRow;
      let q = new Array(this._ad);
      for (let r = 0; r < q.length; r++) {
        q[r] = a._x(b.index, c, b.worksheet._o);
      }
      for (let s = this.firstRow; s <= this.lastRow; s++) {
        let t = this._e._rows$i.item(s);
        if (o && (s - p) >= 32) {
          for (let u = 0; u < q.length; u++) {
            let v = e + u;
            this._e._h2(q[u], this._e._cx(p, v, s - 1, v));
            q[u] = new SingleTargetFormula(3, q[u], true);
          }
          p = s;
        }
        for (let w = e; w <= this._w; w++) {
          q[w - e]._bq(b, c, t, w, d);
        }
      }
      for (let x = 0; x < q.length; x++) {
        let y = e + x;
        this._e._h2(q[x], this._e._cx(p, y, this.lastRow, y));
      }
    }
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _q(a, b) {
    if (this.worksheet == null) {
      return false;
    }
    return this._i._i(a, b);
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = a._o;
    if (b == null) {
      return false;
    }
    return this._p(b, a._ab);
  }
  /**
   * @hidden
   */
  _o(a) {
    if (this.worksheet == null) {
      return false;
    }
    if (a.worksheet != this.worksheet) {
      return false;
    }
    return this._i._h(a._i);
  }
  /**
   * @hidden
   */
  _p(a, b) {
    if (this.worksheet == null) {
      return false;
    }
    if (a.worksheet != this.worksheet) {
      return false;
    }
    return this._i._i(a.index, b);
  }
  /**
   * @hidden
   */
  _s(a) {
    if (this.worksheet == null) {
      return false;
    }
    if (this.worksheet != a.worksheet) {
      return false;
    }
    return this._i._j(a._i);
  }
  /**
   * @hidden
   */
  _t(a, b, c, d) {
    if (this.worksheet == null) {
      return false;
    }
    return this._i._j(new WorksheetRegionAddress(1, a, c, b, d));
  }
  /**
   * @hidden
   */
  _al(a) {
    this._i = a;
  }
  /**
   * @hidden
   */
  _d(a, b) {
    let c = ((() => { let d = a.e(this._i, b); this._i = d.p0; return d.ret; })());
    if (c.f) {
      this._j = null;
      if (c.g) {
        this._ak();
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  static _g(a, b) {
    if (a == null) {
      return b;
    }
    if (b == null) {
      return a;
    }
    if (a.worksheet == null) {
      return a;
    }
    return a.worksheet._cx(Math.min(a.firstRow, b.firstRow), Math.min(a.firstColumn, b.firstColumn), Math.max(a.lastRow, b.lastRow), Math.max(a.lastColumn, b.lastColumn));
  }
  /**
   * @hidden
   */
  static _am(a, b) {
    if (b < a) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_LastColumnBeforeFirst"));
    }
  }
  /**
   * @hidden
   */
  _an(a, b) {
    let c = Workbook.getMaxColumnCount(b) - 1;
    if (c < this._i._x) {
      a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxColumnIndex"), this._i._x, c));
      return;
    }
    let d = Workbook.getMaxRowCount(b) - 1;
    if (d < this._i._ae) {
      a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxRowIndex"), this._i._ae, d));
    }
  }
  /**
   * @hidden
   */
  static _ap(a, b) {
    if (b < a) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_LastRowBeforeFirst"));
    }
  }
  /**
   * @hidden
   */
  _ak() {
    this._e = null;
    this._j = null;
    this._b = null;
    this._i = WorksheetRegionAddress._b;
  }
  /**
   * @hidden
   */
  _ao() {
    if (this._e == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
  }
  /**
   * @hidden
   */
  get _h() {
    return this._i;
  }
  /**
   * @hidden
   */
  get _c() {
    if (this._e == null) {
      return null;
    }
    if (this._b == null) {
      if (this._u) {
        this._b = this._k._as(this._v);
      }
      else {
        this._b = new RegionCalcReference(this);
      }
    }
    return this._b;
  }
  /**
   * Gets the index of the first column in the region.
   * The index of the first column in the region.
   */
  get firstColumn() {
    return this._v;
  }
  /**
   * @hidden
   */
  get _v() {
    return this._i._w;
  }
  /**
   * Gets the index of the first row in the region.
   * The index of the first row in the region.
   */
  get firstRow() {
    return this._i._ac;
  }
  /**
   * @hidden
   */
  get _aa() {
    return this.lastRow - this.firstRow + 1;
  }
  /**
   * @hidden
   */
  get _u() {
    return this.firstRow == this.lastRow && this.firstColumn == this.lastColumn;
  }
  /**
   * Gets the index of the last column in the region.
   * The index of the last column in the region.
   */
  get lastColumn() {
    return this._w;
  }
  /**
   * @hidden
   */
  get _w() {
    return this._i._x;
  }
  /**
   * Gets the index of the last row in the region.
   * The index of the last row in the region.
   */
  get lastRow() {
    return this._i._ae;
  }
  /**
   * @hidden
   */
  get _k() {
    if (this._j == null && this._e != null) {
      this._j = this.worksheet._rows$i.item(this.firstRow);
    }
    return this._j;
  }
  /**
   * @hidden
   */
  get _ad() {
    return this.lastColumn - this.firstColumn + 1;
  }
  /**
   * Gets the worksheet on which the region resides.
   * The worksheet on which the region resides or null if the region has been shifted off the worksheet.
   */
  get worksheet() {
    return this._e;
  }
}
WorksheetRegion.$t = markType(WorksheetRegion, 'WorksheetRegion', Base.$, [IEnumerable$1_$type.specialize(WorksheetCell.$)]);
/**
 * @hidden
 */
WorksheetRegion._a = new Array(0);
/**
 * A collection of cells or regions which are all on the same [[worksheet]].
 */
export class WorksheetReferenceCollection extends Base {
  constructor(..._rest) {
    super();
    this._w = Nullable$1.toNullable(Number_$type, null);
    this._x = null;
    this._y = null;
    this._u = null;
    this._a = null;
    this._b = null;
    let a;
    if (arguments.length === 1) {
      if (typeCast(Worksheet.$, arguments[0]) !== null) {
        a = 0;
      }
      else if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        a = 3;
      }
      else if (arguments[0] == null) {
        a = 2;
      }
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let worksheet = _rest[0];
          if (worksheet == null) {
            throw new ArgumentNullException(0, "worksheet");
          }
          this._am(worksheet);
        }
        break;
      case 1:
        {
          let worksheet = _rest[0];
          let references = _rest[1];
          let b = [worksheet];
          {
            let worksheet = b[0];
            if (worksheet == null) {
              throw new ArgumentNullException(0, "worksheet");
            }
            this._am(worksheet);
          }
          this._add3(references);
        }
        break;
      case 2:
        {
          let cell = _rest[0];
          if (WorksheetCell.l_op_Equality(cell, null)) {
            throw new ArgumentNullException(0, "cell");
          }
          if (cell.worksheet == null) {
            throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
          }
          this._am(cell.worksheet);
          this._ah(cell._m);
        }
        break;
      case 3:
        {
          let region = _rest[0];
          if (region == null) {
            throw new ArgumentNullException(0, "region");
          }
          if (region.worksheet == null) {
            throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
          }
          this._am(region.worksheet);
          this._ah(region._h);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  toString() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._toString.apply(this, arguments);
      case 1: return this._toString1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toString() {
    return this._toString1(this.worksheet._c);
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    let a = arrayIndex;
    for (let b of fromEnum(this)) {
      array[a++] = b;
    }
  }
  /**
   * @hidden
   */
  get count() {
    return this._u.count;
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    for (let a of fromEnum(this._u)) {
      yield this._b._cw(a);
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    else if (arguments.length === 2) {
      n = 3;
    }
    switch (n) {
      case 0: return this._add.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      case 2: return this._add3.apply(this, arguments);
      case 3: return this._add4.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add3(a) {
    this._add4(a, this._b._c);
  }
  /**
   * @hidden
   */
  _add4(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "references");
    }
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, b)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", b, CellReferenceMode_$type);
    }
    let c = this._s(a, b, this._b._y);
    if (c.count == 0) {
      return;
    }
    let d = false;
    let e = false;
    for (let f = 0; f < c.count; f++) {
      let g;
      d = ((() => { let h = this._h(c._inner[f]._h, g); g = h.p1; return h.ret; })()) || d;
      e = g || e;
    }
    if (d) {
      if (e) {
        this._aj();
      }
      else {
        this._as();
      }
    }
  }
  /**
   * @hidden
   */
  _add1(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    if (a.worksheet != this._b) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellMustBeOnSameWorksheetAsReferencesCollection"), "cell");
    }
    this._add(a._l());
  }
  /**
   * @hidden
   */
  _add(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
    if (a.worksheet != this._b) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionMustBeOnSameWorksheetAsReferencesCollection"), "region");
    }
    let b;
    if (((() => { let c = this._h(a._h, b); b = c.p1; return c.ret; })())) {
      if (b) {
        this._aj();
      }
      else {
        this._as();
      }
    }
  }
  /**
   * Clears all references from the collection.
   */
  clear() {
    this._a.aa();
    this._u.clear();
    this._as();
  }
  contains() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._contains.apply(this, arguments);
      case 1: return this._contains1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _contains1(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    if (a.worksheet != this.worksheet) {
      return false;
    }
    return this._contains2(a._m);
  }
  /**
   * @hidden
   */
  _contains(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
    if (a.worksheet != this.worksheet) {
      return false;
    }
    return this._contains2(a._h);
  }
  /**
   * @hidden
   */
  _contains2(a) {
    {
      let b = this._a.g(a);
      try {
        if (b._c) {
          return true;
        }
      }
      finally {
        b.dispose();
      }
    }
    {
      let c = this._a.j(a);
      try {
        if (c._c) {
          let d;
          let e = WorksheetReferenceCollection._at(a, c._d._inner[0], d);
          d = e.p2;
          for (let f = 0; f < d.count; f++) {
            if (this._contains2(d._inner[f]) == false) {
              return false;
            }
          }
          return true;
        }
      }
      finally {
        c.dispose();
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _k(a) {
    {
      let b = this._a.j(a);
      try {
        return b._c;
      }
      finally {
        b.dispose();
      }
    }
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    else if (arguments.length === 2) {
      n = 3;
    }
    switch (n) {
      case 0: return this._remove.apply(this, arguments);
      case 1: return this._remove1.apply(this, arguments);
      case 2: return this._remove3.apply(this, arguments);
      case 3: return this._remove4.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove3(a) {
    return this._remove4(a, this._b._c);
  }
  /**
   * @hidden
   */
  _remove4(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "references");
    }
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, b)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", b, CellReferenceMode_$type);
    }
    let c = this._s(a, b, this._b._y);
    if (c.count == 0) {
      return false;
    }
    let d = false;
    for (let e = 0; e < c.count; e++) {
      d = this._q(c._inner[e]._h) || d;
    }
    if (d == false) {
      return false;
    }
    this._aj();
    return true;
  }
  /**
   * @hidden
   */
  _remove1(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    if (a.worksheet != this._b) {
      return false;
    }
    {
      let b = this._a.f(a.rowIndex, a._ab);
      try {
        if (b._c) {
          let c = b._d._inner[0];
          this._ar(c);
          let d = a._o.index;
          let e = a._ab;
          let f = new WorksheetRegionAddress(1, d, d, e, e);
          let g;
          let h = WorksheetReferenceCollection._at(c, f, g);
          g = h.p2;
          if (g.count > 0) {
            this._ai(g);
            this._u.z(WorksheetRegion_HorizontalAddressSorter._a);
          }
          this._aj();
          return true;
        }
      }
      finally {
        b.dispose();
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _remove(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
    if (a.worksheet != this._b) {
      return false;
    }
    return this._remove2(a._h);
  }
  /**
   * @hidden
   */
  _remove2(a) {
    if (this._q(a)) {
      this._aj();
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _toString1(a) {
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, a)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", a, CellReferenceMode_$type);
    }
    if (a == 1) {
      return ((() => { let b = this._ac(a, this._x); this._x = b.p1; return b.ret; })());
    }
    return ((() => { let b = this._ac(a, this._y); this._y = b.p1; return b.ret; })());
  }
  /**
   * @hidden
   */
  static _e(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    let b = new WorksheetReferenceCollection(a.worksheet);
    b._ah(a._m);
    return b;
  }
  /**
   * @hidden
   */
  static _f(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
    let b = new WorksheetReferenceCollection(a.worksheet);
    b._ah(a._h);
    return b;
  }
  /**
   * @hidden
   */
  _al(a, b) {
    let c;
    let d;
    let e;
    let f;
    let g = this._a.ab(c, d, e, f);
    c = g.p0;
    d = g.p1;
    e = g.p2;
    f = g.p3;
    if (c == -1 || d == -1 || e == -1 || f == -1) {
      a = b = null;
    }
    else {
      a = this._b._rows$i.item(c)._cells$i.item(d);
      b = this._b._rows$i.item(e)._cells$i.item(f);
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _l(a, b) {
    if (WorksheetRegionAddress._p(Nullable$1.toNullable(WorksheetRegionAddress.$, b), Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return false;
    }
    for (let c of fromEnum(this._t)) {
      if (c._w < b._w || c._ac < b._ac || c._x > b._x || c._ae > b._ae) {
        return false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _ap(a, b) {
    let c = new List$1(WorksheetRegionAddress.$, 0);
    for (let d = this._u.count - 1; d >= 0; d--) {
      let e = this._u._inner[d];
      let f;
      let g = ((() => { let h = a.f(e, true, true, f); e = h.p0; f = h.p3; return h.ret; })());
      if (g.f) {
        this._aq(this._u._inner[d], d);
        if (g.g) {
          continue;
        }
        if (e._n) {
          c.add(e);
        }
        if (f != null) {
          for (let h = 0; h < f.count; h++) {
            let i = f._inner[h];
            if (i._n) {
              c.add(i);
            }
          }
        }
      }
    }
    if (c.count != 0) {
      this._ai(c);
      this._aj();
    }
    b = this._u.count == 0;
    return {
      p1: b
    };
  }
  /**
   * @hidden
   */
  _add2(a) {
    let b = false;
    let c = false;
    for (let d = 0; d < a._u.count; d++) {
      let e;
      b = ((() => { let f = this._h(a._u._inner[d], e); e = f.p1; return f.ret; })()) || b;
      c = e || c;
    }
    if (b) {
      if (c) {
        this._aj();
      }
      else {
        this._as();
      }
    }
  }
  /**
   * @hidden
   */
  _ah(a) {
    this._u.add(a);
    this._a.y(a, a);
  }
  /**
   * @hidden
   */
  _ai(a) {
    for (let b of fromEnum(a)) {
      this._ah(b);
    }
  }
  /**
   * @hidden
   */
  _h(a, b) {
    b = false;
    {
      let c = this._a.g(a);
      try {
        if (c._c) {
          return {
            ret: false,
            p1: b
          };
        }
      }
      finally {
        c.dispose();
      }
    }
    {
      let d = this._a.k(a._ac, (a._w - 1), a._ae, (a._x + 1));
      try {
        if (d._c) {
          b = true;
        }
      }
      finally {
        d.dispose();
      }
    }
    if (b == false) {
      {
        let e = this._a.k(a._ac - 1, a._w, a._ae + 1, a._x);
        try {
          if (e._c) {
            b = true;
          }
        }
        finally {
          e.dispose();
        }
      }
    }
    this._q(a);
    this._ao(a);
    return {
      ret: true,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _aj() {
    if (this._u.count > 1) {
      this._ak(this._b, true);
    }
    this._as();
  }
  /**
   * @hidden
   */
  _ak(a, b) {
    let c = new Dictionary$2(WorksheetRegionAddress.$, Boolean_$type, 0);
    while (true) {
      let d = false;
      for (let e = 0; e < this._u.count; e++) {
        let f = this._u._inner[e];
        if (c.containsKey(f)) {
          continue;
        }
        let g = new WorksheetRegionAddress(1, f._ac, f._ae, f._w, f._x);
        g = this._g(g, e, b);
        if (g.equals(f)) {
          continue;
        }
        c.item(f, false);
        this._q(g);
        this._ao(g);
        d = true;
        break;
      }
      if (d == false) {
        break;
      }
    }
  }
  /**
   * @hidden
   */
  _g(a, b, c) {
    let d = new SortedIntRangeList();
    let e = new SortedIntRangeList();
    let f = false;
    let g = false;
    while (f == false || g == false) {
      d.o();
      e.o();
      let h = a._ae + 1;
      let i = a._x + 1;
      if (g == false) {
        d.n(a._w, a._x);
      }
      if (f == false) {
        e.n(a._ac, a._ae);
      }
      let j = this._a.k(a._ac, a._x + 1, a._ae, a._x + 1);
      let k = this._a.k(a._ae + 1, a._w, a._ae + 1, a._x);
      if (j._c) {
        for (let l = 0; l < j._d.count; l++) {
          let m = j._d._inner[l];
          if (e.a(m._ac)) {
            e.q(m._ac, m._ae);
          }
        }
      }
      if (k._c) {
        for (let n = 0; n < k._d.count; n++) {
          let o = k._d._inner[n];
          if (d.a(o._w)) {
            d.q(o._w, o._x);
          }
        }
      }
      j.dispose();
      k.dispose();
      g = (d.k > 0) || g;
      f = (e.k > 0) || f;
      if (g == false && f == false) {
        {
          let p = this._a.f(a._ae + 1, a._x + 1);
          try {
            if (p._c) {
              a = new WorksheetRegionAddress(1, a._ac, a._ae + 1, a._w, (a._x + 1));
            }
            else if (c) {
              a = a._e((a._x + 1));
            }
            else {
              a = a._f(a._ae + 1);
            }
          }
          finally {
            p.dispose();
          }
        }
      }
      else if (f == false) {
        a = a._e((a._x + 1));
      }
      else if (g == false) {
        a = a._f(a._ae + 1);
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  _s(a, b, c) {
    return WorksheetReferenceCollection._r(this.worksheet, a, b, c);
  }
  /**
   * @hidden
   */
  static _r(a, b, c, d) {
    let e = a._o;
    let f = stringSplit(b, [' '], 1);
    let g = new List$1(WorksheetRegion.$, 2, f.length);
    for (let h = 0; h < f.length; h++) {
      let i = f[h].trim();
      let j = a._getRegion1(i, c);
      if (j == null) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidReferencesString"), "references");
      }
      g.add(j);
    }
    return g;
  }
  /**
   * @hidden
   */
  _am(a) {
    this._b = a;
    this._u = new List$1(WorksheetRegionAddress.$, 0);
    this._a = new RegionLookupTable$1(WorksheetRegionAddress.$, this._b);
  }
  /**
   * @hidden
   */
  _an(a, b) {
    this._u.insert(a, b);
    this._a.y(b, b);
  }
  /**
   * @hidden
   */
  _ao(a) {
    let b = this._u.g(a, WorksheetRegion_HorizontalAddressSorter._a);
    if (b < 0) {
      this._an(~b, a);
    }
    else {
    }
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    this._u.removeAt(b);
    this._a.ad(a, a);
  }
  /**
   * @hidden
   */
  _ar(a) {
    let b = this._u.g(a, WorksheetRegion_HorizontalAddressSorter._a);
    if (b < 0) {
      return;
    }
    this._aq(a, b);
  }
  /**
   * @hidden
   */
  _q(a) {
    {
      let b = this._a.j(a);
      try {
        if (b._c == false) {
          return false;
        }
        let c = false;
        for (let d = b._d.count - 1; d >= 0; d--) {
          let e = b._d._inner[d];
          this._ar(e);
          let f;
          let g = WorksheetReferenceCollection._at(e, a, f);
          f = g.p2;
          this._ai(f);
          c = f.count > 0 || c;
        }
        if (c) {
          this._u.z(WorksheetRegion_HorizontalAddressSorter._a);
        }
      }
      finally {
        b.dispose();
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _as() {
    this._w = Nullable$1.toNullable(Number_$type, null);
    this._x = null;
    this._y = null;
  }
  /**
   * @hidden
   */
  static _at(a, b, c) {
    c = new List$1(WorksheetRegionAddress.$, 0);
    if (a._ac < b._ac) {
      c.add(new WorksheetRegionAddress(1, a._ac, b._ac - 1, a._w, a._x));
    }
    if (b._ae < a._ae) {
      c.add(new WorksheetRegionAddress(1, b._ae + 1, a._ae, a._w, a._x));
    }
    let d = Math.max(b._ac, a._ac);
    let e = Math.min(b._ae, a._ae);
    if (a._w < b._w) {
      c.add(new WorksheetRegionAddress(1, d, e, a._w, (b._w - 1)));
    }
    if (b._x < a._x) {
      c.add(new WorksheetRegionAddress(1, d, e, (b._x + 1), a._x));
    }
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    if (b == null) {
      b = WorksheetReferenceCollection._ab(a, this.worksheet, this._u);
    }
    return {
      ret: b,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _ab(a, b, c, d = " ") {
    let e = (a == 1);
    let f = b._o;
    let g = new StringBuilder(0);
    for (let h of fromEnum(c)) {
      if (g.c != 0) {
        g.l(d);
      }
      if (h._m) {
        let i = new WorksheetCellAddress(1, h._ac, h._w);
        g.l(i.p(e, e, f, a));
        continue;
      }
      g.l(h._ah(e, e, f, a));
    }
    return g.toString();
  }
  /**
   * Gets the number of cells contains in all references in this collection.
   */
  get cellsCount() {
    if (this._w.hasValue == false) {
      let a = 0;
      for (let b = 0; b < this._u.count; b++) {
        let c = this._u._inner[b];
        a += c._ad * c._af;
      }
      this._w = Nullable$1.toNullable(Number_$type, a);
    }
    return this._w.value;
  }
  /**
   * Gets the worksheet for which this collection contains references.
   */
  get worksheet() {
    return this._b;
  }
  /**
   * @hidden
   */
  get _t() {
    return this._u;
  }
  /**
   * @hidden
   */
  get _d() {
    if (this._u.count == 0) {
      return null;
    }
    let a = this._u._inner[0];
    return this._b._rows$i.item(a._ac)._cells$i.item(a._w);
  }
}
WorksheetReferenceCollection.$t = markType(WorksheetReferenceCollection, 'WorksheetReferenceCollection', Base.$, [ICollection$1_$type.specialize(WorksheetRegion.$)]);
/**
 * @hidden
 */
export class DataValidationRuleCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), d);
        }
        break;
    }
  }
  get workbook() {
    return this.a._f.workbook;
  }
  get sheet() {
    return this.a._f;
  }
  get source() {
    return this.a._f;
  }
}
DataValidationRuleCollection_CollectionChangeContext.$t = markStruct(DataValidationRuleCollection_CollectionChangeContext, 'DataValidationRuleCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[DataValidationRule]] instances in a worksheet.
 * @see [[Worksheet.dataValidationRules]]
 */
export class DataValidationRuleCollection extends Base {
  constructor(a) {
    super();
    this._s = null;
    /**
     * @hidden
     */
    this._f = null;
    this._s = new Dictionary$2(DataValidationRule.$, WorksheetReferenceCollection.$, 0);
    this._f = a;
  }
  static staticInit() {
    DataValidationRuleCollection._a = DataValidationRuleCollection._b();
  }
  /**
   * @hidden
   */
  addItem(key, value) {
    this._add5(key, value);
  }
  /**
   * @hidden
   */
  containsKey(key) {
    return this._contains1(key);
  }
  /**
   * @hidden
   */
  tryGetValue(key, value) {
    return {
      ret: ((() => { let a = this._r(key, value); value = a.p1; return a.ret; })()),
      p1: value
    };
  }
  /**
   * @hidden
   */
  get keys() {
    return this._s.keys;
  }
  /**
   * @hidden
   */
  get values() {
    return this._s.values;
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      if (typeCast(AnyValueDataValidationRule.$, arguments[0]) !== null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 1;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 2;
        }
        else if (arguments[1] == null) {
          n = 1;
        }
      }
      else if (typeCast(CustomDataValidationRule.$, arguments[0]) !== null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 3;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 4;
        }
        else if (arguments[1] == null) {
          n = 3;
        }
      }
      else if (typeCast(ListDataValidationRule.$, arguments[0]) !== null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 7;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 8;
        }
        else if (arguments[1] == null) {
          n = 7;
        }
      }
      else if (typeCast(OneConstraintDataValidationRule.$, arguments[0]) !== null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 9;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 10;
        }
        else if (arguments[1] == null) {
          n = 9;
        }
      }
      else if (typeCast(TwoConstraintDataValidationRule.$, arguments[0]) !== null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 11;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 12;
        }
        else if (arguments[1] == null) {
          n = 11;
        }
      }
      else if (typeCast(DataValidationRule.$, arguments[0]) !== null) {
        n = 5;
      }
      else if (arguments[0] == null) {
        if (typeCast(WorksheetCell.$, arguments[1]) !== null) {
          n = 1;
        }
        else if (typeCast(WorksheetReferenceCollection.$, arguments[1]) !== null) {
          n = 5;
        }
        else if (typeCast(WorksheetRegion.$, arguments[1]) !== null) {
          n = 2;
        }
        else if (arguments[1] == null) {
          n = 1;
        }
      }
    }
    else if (arguments.length === 3) {
      n = 6;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      case 2: return this._add2.apply(this, arguments);
      case 3: return this._add3.apply(this, arguments);
      case 4: return this._add4.apply(this, arguments);
      case 5: return this._add5.apply(this, arguments);
      case 6: return this._add6.apply(this, arguments);
      case 7: return this._add7.apply(this, arguments);
      case 8: return this._add8.apply(this, arguments);
      case 9: return this._add9.apply(this, arguments);
      case 10: return this._add10.apply(this, arguments);
      case 11: return this._add11.apply(this, arguments);
      case 12: return this._add12.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    if (a.value == null) {
      throw new ArgumentNullException(0, "references");
    }
    this._add5(a.key, a.value);
  }
  contains() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(DataValidationRule.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 2;
      }
      else if (typeCast(WorksheetReferenceCollection.$, arguments[0]) !== null) {
        n = 3;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 4;
      }
      else if (typeCast(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._contains$e.apply(this, arguments);
      case 1: return this._contains1.apply(this, arguments);
      case 2: return this._contains2.apply(this, arguments);
      case 3: return this._contains3.apply(this, arguments);
      case 4: return this._contains4.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _contains$e(a) {
    let b;
    if (((() => { let c = this._r(a.key, b); b = c.p1; return c.ret; })())) {
      return EqualityComparer$1.defaultEqualityComparerValue(WorksheetReferenceCollection.$).equalsC(b, a.value);
    }
    return false;
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._s.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetReferenceCollection.$, arguments[0]) !== null) {
        n = 2;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 3;
      }
      else if (typeCast(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._remove$e.apply(this, arguments);
      case 1: return this._remove2.apply(this, arguments);
      case 2: return this._remove3.apply(this, arguments);
      case 3: return this._remove4.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove$e(a) {
    return this._s.remove(a);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._s.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _add5(a, b) {
    this._add6(a, b, true);
  }
  /**
   * @hidden
   */
  _add6(a, b, c) {
    if (b == null) {
      throw new ArgumentNullException(0, "references");
    }
    this._ap(a, b);
    if (c == false && this._contains3(b)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_ReferencesAlreadyContainDVs"), "references");
    }
    for (let d = 0; d < b._t.count; d++) {
      let e = b._t._inner[d];
      for (let f = 0; f < this._f._tables$i.count; f++) {
        let g = this._f._tables$i._item(f);
        let h = g.totalsRowRegion;
        if (h != null && h._h._j(e)) {
          throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CannotApplyDVRuleToTotalCell"), "references");
        }
      }
    }
    let i = this._w(32);
    this._remove3(b);
    this._al(a, b);
    this._am(i);
  }
  /**
   * @hidden
   */
  _add1(a, b) {
    this._aj(a, b);
  }
  /**
   * @hidden
   */
  _add2(a, b) {
    this._ak(a, b);
  }
  /**
   * @hidden
   */
  _add3(a, b) {
    this._aj(a, b);
  }
  /**
   * @hidden
   */
  _add4(a, b) {
    this._ak(a, b);
  }
  /**
   * @hidden
   */
  _add7(a, b) {
    this._aj(a, b);
  }
  /**
   * @hidden
   */
  _add8(a, b) {
    this._ak(a, b);
  }
  /**
   * @hidden
   */
  _add9(a, b) {
    this._aj(a, b);
  }
  /**
   * @hidden
   */
  _add10(a, b) {
    this._ak(a, b);
  }
  /**
   * @hidden
   */
  _add11(a, b) {
    this._aj(a, b);
  }
  /**
   * @hidden
   */
  _add12(a, b) {
    this._ak(a, b);
  }
  /**
   * Removes all data validation rules from the [[worksheet]].
   */
  clear() {
    if (this._s.count == 0) {
      return;
    }
    let a = new List$1(DataValidationRule.$, 1, this._s.keys);
    let b = this._w(12);
    for (let c = 0; c < a.count; c++) {
      this.removeItem(a._inner[c]);
    }
    this._am(b);
  }
  /**
   * @hidden
   */
  _contains1(a) {
    return this._s.containsKey(a);
  }
  /**
   * @hidden
   */
  _contains2(a) {
    this._aq(a);
    for (let b of fromEnum(this._s)) {
      let c = b.value;
      if (c._contains1(a)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _contains3(a) {
    this._ar(a);
    for (let b = 0; b < a._t.count; b++) {
      if (this._contains5(a._t._inner[b])) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _contains4(a) {
    this._as(a);
    return this._contains5(a._h);
  }
  /**
   * @hidden
   */
  _contains5(a) {
    for (let b of fromEnum(this._s)) {
      if (b.value._k(a)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Find the data validation rule applied to the specified cell.
   * @param cell The cell to test.
   * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
   * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
   * @return A [[DataValidationRule]]-derived instance or null if the cell has no rule applied.
   */
  findRule(cell) {
    this._aq(cell);
    return this._e(cell._m);
  }
  /**
   * Gets a collection of all the references which have the specified or an equivalent rule applied to them.
   * @param rule The rule to test.
   * @return A collection of references in the [[worksheet]] with a rule applied to it that is equivalent to the specified 'rule'.
   */
  getAllReferences(rule) {
    let a = new WorksheetReferenceCollection(this._f);
    for (let b of fromEnum(this._s)) {
      if (b.key.isEquivalentTo(rule)) {
        a._add2(b.value);
      }
    }
    return a;
  }
  /**
   * Removes the specified rule from the [[worksheet]].
   * @param rule The rule which should be removed.
   * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
   * @return True if the rule was contained on the Worksheet before removal; False otherwise.
   */
  removeItem(rule) {
    if (rule == null) {
      throw new ArgumentNullException(0, "rule");
    }
    if (rule._h != this) {
      return false;
    }
    let a = DataValidationRuleCollection._a[1];
    let b = null;
    let c = Nullable$1.toNullable(DataValidationRuleCollection_CollectionChangeContext.$, null);
    let d = Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), null);
    let e = this._f.workbook;
    if (e != null && e._cx) {
      b = a.b(this._f.workbook, this._f, a.c);
      let f;
      if (((() => { let g = this._s.tryGetValue(rule, f); f = g.p1; return g.ret; })())) {
        d = Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), new KeyValuePair$2(DataValidationRule.$, WorksheetReferenceCollection.$, 1, rule, f));
        c = Nullable$1.toNullable(DataValidationRuleCollection_CollectionChangeContext.$, new DataValidationRuleCollection_CollectionChangeContext(1, this, d.value));
      }
    }
    this._s.removeItem(rule);
    rule._ap();
    if (nullableNotEquals(c, null)) {
      a.e(DataValidationRuleCollection_CollectionChangeContext.$, Nullable$1.$.specialize(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$)), c.value, d, Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), null));
      if (b != null) {
        a.d(this._f.workbook, b);
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _remove2(a) {
    this._aq(a);
    let b = this._w(33);
    let c = false;
    for (let d of fromEnum(this._s)) {
      let e = d.value;
      if (e._contains1(a)) {
        e._remove1(a);
        if (e.cellsCount == 0) {
          this.removeItem(d.key);
        }
        c = true;
        break;
      }
    }
    this._am(b);
    return c;
  }
  /**
   * @hidden
   */
  _remove3(a) {
    this._ar(a);
    let b = this._w(33);
    let c = false;
    for (let d = 0; d < a._t.count; d++) {
      c = this._remove5(a._t._inner[d]) || c;
    }
    this._am(b);
    return c;
  }
  /**
   * @hidden
   */
  _remove4(a) {
    this._as(a);
    return this._remove5(a._h);
  }
  /**
   * @hidden
   */
  _remove5(a) {
    let b = false;
    let c = new List$1(DataValidationRule.$, 0);
    for (let d of fromEnum(this._s)) {
      let e = d.value;
      if (e._k(a)) {
        e._remove2(a);
        if (e.cellsCount == 0) {
          c.add(d.key);
        }
        b = true;
      }
    }
    if (!b) {
      return b;
    }
    let f = this._w(33);
    for (let g = 0; g < c.count; g++) {
      this.removeItem(c._inner[g]);
    }
    this._am(f);
    return b;
  }
  /**
   * @hidden
   */
  _r(a, b) {
    return {
      ret: ((() => { let c = this._s.tryGetValue(a, b); b = c.p1; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  _aj(a, b) {
    this._aq(b);
    this._add5(a, WorksheetReferenceCollection._e(b));
  }
  /**
   * @hidden
   */
  _ak(a, b) {
    this._as(b);
    this._add5(a, WorksheetReferenceCollection._f(b));
  }
  /**
   * @hidden
   */
  _al(a, b) {
    let c = DataValidationRuleCollection._a[0];
    let d = null;
    if (this._f.workbook != null) {
      d = c.b(this._f.workbook, this._f, c.c);
    }
    let e = Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), new KeyValuePair$2(DataValidationRule.$, WorksheetReferenceCollection.$, 1, a, b));
    let f = new DataValidationRuleCollection_CollectionChangeContext(1, this, e.value);
    let g;
    if (((() => { let h = this._s.tryGetValue(a, g); g = h.p1; return h.ret; })())) {
      g._add2(b);
    }
    else {
      this._s.addItem(a, b);
      a._ao(this, b);
    }
    if (this._f.workbook != null) {
      c.e(DataValidationRuleCollection_CollectionChangeContext.$, Nullable$1.$.specialize(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$)), f, Nullable$1.toNullable(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), null), e);
      if (d != null) {
        c.d(this._f.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _e(a) {
    for (let b of fromEnum(this._s)) {
      if (b.value._contains2(a)) {
        return b.key;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(DataValidationRuleCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, DataValidationRuleCollection._c(Nullable$1.$.specialize(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$)), "Add", 32, (b) => b.b, (b, c) => DataValidationRuleCollection._an(b, c)));
    ChangeInfo.f(a, 1, DataValidationRuleCollection._c(Nullable$1.$.specialize(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$)), "Remove", 33, (b) => b.b, (b, c) => DataValidationRuleCollection._ao(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _w(a) {
    let b = this._f.workbook;
    return b != null && b._cx ? b._go(this._f, a, null) : null;
  }
  /**
   * @hidden
   */
  _am(a) {
    if (a != null) {
      let b = this._f.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _an(a, b) {
    a.a.removeItem(a.b.value.key);
  }
  /**
   * @hidden
   */
  static _ao(a, b) {
    a.a._add5(a.b.value.key, a.b.value.value);
  }
  /**
   * @hidden
   */
  _ap(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "rule");
    }
    if (a._h != null && a._h != this) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_RuleAppliedOnOtherWorksheet"), "rule");
    }
    a._at(this, b);
    if (b != null && b.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_ReferencesFromOtherWorksheet"), "references");
    }
  }
  /**
   * @hidden
   */
  _aq(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    if (a.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_CellFromOtherWorksheet"), "cell");
    }
  }
  /**
   * @hidden
   */
  _ar(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "references");
    }
    if (a.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_ReferencesFromOtherWorksheet"), "references");
    }
  }
  /**
   * @hidden
   */
  _as(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "region");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), "region");
    }
    if (a.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_RegionFromOtherWorksheet"), "region");
    }
  }
  /**
   * Gets the number of data validation rules applied on the [[worksheet]].
   */
  get count() {
    return this._s.count;
  }
  /**
   * Gets or sets the references which have the data validation rule applied to it.
   * @param rule A data validation rule.
   * @throws [[ArgumentNullException]] Occurs when the 'rule' is null.
   * @throws [[KeyNotFoundException]] Occurs when the property is retrieved and the 'rule' is not applied to the [[worksheet]].
   * @throws [[ArgumentException]] Occurs when the property is set and the value is from a Worksheet other than this collection.
   * @throws [[ArgumentException]] Occurs when the property is set and the 'rule' is invalid based on its rule type's requirements.
   */
  item(a, b) {
    if (arguments.length === 2) {
      if (b == null) {
        this.removeItem(a);
        return;
      }
      this._ap(a, b);
      this._remove3(b);
      this._s.item(a, b);
      a._ao(this, b);
      return b;
    }
    else {
      return this._s.item(a);
    }
  }
  /**
   * @hidden
   */
  get _g() {
    return this._f;
  }
}
DataValidationRuleCollection.$t = markType(DataValidationRuleCollection, 'DataValidationRuleCollection', Base.$, [IDictionary$2_$type.specialize(DataValidationRule.$, WorksheetReferenceCollection.$)]);
/**
 * @hidden
 */
DataValidationRuleCollection._t = 0;
/**
 * @hidden
 */
DataValidationRuleCollection._v = 1;
/**
 * @hidden
 */
DataValidationRuleCollection._u = 2;
/**
 * @hidden
 */
DataValidationRuleCollection._a = null;
/**
 * Represents a data validation rule which allows a value from a list of accepted values to be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export class ListDataValidationRule extends LimitedValueDataValidationRule {
  constructor() {
    super();
    this._bq = false;
    this._bo = null;
    this._bq = true;
  }
  /**
   * @hidden
   */
  get__i() {
    return 5;
  }
  /**
   * @hidden
   */
  _l(a) {
    return this._bn(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _m(a) {
    return null;
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(ListDataValidationRule.$, other);
    return a != null && super.isEquivalentTo(other) && a._bq == this._bq && DataValidationRule._q(a._bo, this._bo);
  }
  /**
   * @hidden
   */
  _a6(a, b, c, d, e) {
    if (super._a6(a, b, c, d, e) == false) {
      return false;
    }
    if (b) {
      if (a.f == 23) {
        return true;
      }
      let f = a.h == 64 || a.h == 96;
      if (f) {
        return false;
      }
    }
    if (ExcelUtils.au(e)) {
      switch (a.f) {
        case 123:
        case 59:
        case 91:
        case 125:
        case 61:
        case 93: return c;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    super._ao(a, b);
    let c = this._bd(this._bo, b);
    this._bo = c.p0;
  }
  /**
   * @hidden
   */
  _ap() {
    if (this._bo != null) {
      this._bo._bu();
    }
    super._ap();
  }
  /**
   * @hidden
   */
  get__j() {
    return 0;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    this._b4(a, b, this._a2, this._ax, this._a9, true);
  }
  /**
   * @hidden
   */
  _ar(a, b) {
  }
  /**
   * @hidden
   */
  _a8(a, b) {
    if (typeCast(FormattedString.$, b) !== null) {
      b = b.unformattedString;
    }
    let c = new ExcelCalcValue(b);
    let d;
    if (((() => { let e = this._bs(d); d = e.p0; return e.ret; })())) {
      let e = true;
      if (typeof b === 'string') {
        let f = b;
        let g = this._o._b4(this._o._rows$i.item(a.o), a.m);
        let h = this._workbook._b2.a(g._cs);
        if (h.o) {
          e = false;
          f = f.trim();
          for (let i = 0; i < d.length; i++) {
            let j = d[i];
            let k;
            if (typeof j === 'string') {
              k = j;
              if (k != null) {
                k = trimStart(k);
              }
            }
            else if (typeCast(FormattedString.$, j) !== null) {
              k = j.unformattedString;
            }
            else {
              let l = WorksheetCellBlock.ah(j);
              let m;
              if (!((() => { let n = ExcelUtils.b0(this._workbook, j, m); m = n.p2; return n.ret; })())) {
                m = NaN;
              }
              k = h.h(m, l, j, -1, null, null, false).g;
            }
            if (stringEquals1(k, f, 0)) {
              return true;
            }
          }
        }
      }
      if (e) {
        for (let o = 0; o < d.length; o++) {
          let n = d[o];
          if (ExcelCalcValue.areValuesEqual(c, new ExcelCalcValue(n))) {
            return true;
          }
        }
      }
    }
    else {
      let p = this._bl(a);
      for (let q of fromEnum(p)) {
        let r = new ExcelCalcValue(CalcUtilities.m(q._bj(false, false), true));
        if (ExcelCalcValue.areValuesEqual(c, r)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  get__k() {
    return 3;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  _bf(a, b, c, d, e, f, g) {
    super._bf(a, b, c, d, e, f, g);
    if (a == null) {
      return;
    }
    let h = a._e[0];
    let i = typeCast(StrToken.$, h);
    let j = typeCast(ReferenceToken.$, h);
    if (i != null) {
      if (i.p.length == 0) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_DV_ListFormulaCannotHaveEmptyString"));
      }
    }
    else if (j != null) {
      if (typeCast(NameToken.$, j) !== null) {
        return;
      }
      let k = ExcelUtils.dr(j);
      if (CellAddressRange.p(k, Nullable$1.toNullable(CellAddressRange.$, null))) {
        let l = k.getValueOrDefault();
        if (l.d.t != l.b.t && l.d.r != l.b.r) {
          throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_DV_ListFormulaReferenceMustBeOneDimensional"));
        }
      }
    }
  }
  /**
   * @hidden
   */
  _at(a, b) {
    this._bf(this._bo, a, b, "valuesFormula", true, true, this._a2);
  }
  getValuesFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getValuesFormula.apply(this, arguments);
      case 1:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return this._getValuesFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getValuesFormula(a) {
    return this._getValuesFormula1(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _getValuesFormula1(a, b, c, d) {
    let e = this._bn(a, b, c, d);
    if (e == null) {
      return null;
    }
    let f = d || this._a9;
    if (e._e.length == 1) {
      let g = typeCast(StrToken.$, e._e[0]);
      if (g != null) {
        if (ListDataValidationRule._bp(CultureInfo.invariantCulture, f)) {
          let h = ListDataValidationRule._bk(g.p, CultureInfo.invariantCulture, f);
          return ListDataValidationRule._bx(h, f, f);
        }
      }
    }
    return e._toString2(c, d);
  }
  /**
   * Sets the list of accepted values the cell can accept.
   * <p class="body">
   * If [[LimitedValueDataValidationRule.allowNull]] is True, null values are allowed in addition to the list of accepted values.
   * </p>
   * <p class="body">
   * All values will have ToString called on them to covert the accepted values list to a formula.
   * </p>
   * <p class="note">
   * <b>Note:</b> the formula of accepted values is created by separating each value with a function parameter separator and concatenating
   * them into a single string. So a list of 1, 2, and 3 would have the following formula created: ="1,2,3". However, if the decimal separator
   * of the current culture is a comma (,) then a semicolon (;) will be used to separate the values instead. Because of this, if the ToString
   * of a value returns a string which contains one of these separators, the value will be split into two or more allowed values.
   * </p>
   * @param values The list of accepted values.
   * @throws [[ArgumentNullException]] Occurs when 'values' is null and the rule is currently applied to a [[Worksheet]].
   * @throws [[ArgumentException]] Occurs when the 'values' array is empty.
   * @see [[getValuesFormula]]
   * @see [[getValuesFormula]]
   * @see [[setValuesFormula]]
   * @see [[setValuesFormula]]
   */
  setValues(...values) {
    if (values == null) {
      this._setValuesFormula(null, null);
      return;
    }
    if (values.length == 0) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_DV_MustHaveOneAcceptedValue"));
    }
    let a = ListDataValidationRule._bx(values, this._a9, CultureInfo.invariantCulture);
    this._setValuesFormula1(a, null, this._a2, this._ax, CultureInfo.invariantCulture);
  }
  setValuesFormula() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setValuesFormula.apply(this, arguments);
      case 1:
        arguments[4] = typeof arguments[4] === 'string' ? new CultureInfo(arguments[4]) : arguments[4];
        return this._setValuesFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setValuesFormula(a, b) {
    this._setValuesFormula1(a, b, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _setValuesFormula1(a, b, c, d, e) {
    let f = e || this._a9;
    let g = this._az(a, c, d, f);
    if (g != null && g._e.length == 1) {
      let h = typeCast(StrToken.$, g._e[0]);
      if (h != null) {
        if (ListDataValidationRule._bp(f, CultureInfo.invariantCulture)) {
          let i = ListDataValidationRule._bk(h.p, f, CultureInfo.invariantCulture);
          let j = ListDataValidationRule._bx(i, CultureInfo.invariantCulture, CultureInfo.invariantCulture);
          g = this._az(j, c, d, CultureInfo.invariantCulture);
        }
      }
    }
    this._b4(g, b, c, d, e);
  }
  /**
   * @hidden
   */
  _bs(a) {
    a = this._bj(null);
    return {
      ret: a != null,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _bj(a = null) {
    let b = null;
    if (this._bo == null) {
      return null;
    }
    let c = typeCast(StrToken.$, this._bo._e[0]);
    if (c == null) {
      return null;
    }
    b = ListDataValidationRule._bk(c.p, CultureInfo.invariantCulture, this._a9, a);
    return b;
  }
  /**
   * @hidden
   */
  static _bx(a, b, c) {
    let d = new StringBuilder(2, "=\"");
    let e = ListDataValidationRule._bp(b, c);
    let f = c.numberFormat.numberDecimalSeparator;
    let g = FormulaParser.by(f);
    let h = false;
    for (let i = 0; i < a.length; i++) {
      let j = a[i];
      if (j == null) {
        continue;
      }
      h = true;
      let k = (((l) => l != null ? l : stringEmpty())(ExcelUtils.d3(j, b)));
      if (typeCast(Boolean_$type, j) !== null) {
        k = k.toUpperCase();
      }
      k = stringReplace(k, "\"", "\"\"");
      if (e) {
        k = ListDataValidationRule._b0(k);
      }
      if (ListDataValidationRule._bt(j, k, c)) {
        d.h('\'');
      }
      d.l(k);
      if (i != a.length - 1) {
        d.h(g);
      }
    }
    if (h == false) {
      d.h(g);
    }
    d.h('\"');
    return d.toString();
  }
  /**
   * @hidden
   */
  _bl(a) {
    let b = this._aw(this._bo, a, false);
    return b._d(false);
  }
  /**
   * @hidden
   */
  _bn(a, b, c, d) {
    return this._a1(this._bo, a, b, c, d, true);
  }
  /**
   * @hidden
   */
  static _bk(a, b, c, d = null) {
    let e = FormulaParser.by(b.numberFormat.numberDecimalSeparator);
    let f = stringSplit(a, [e], 1);
    if (f.length == 0) {
      return new Array(0);
    }
    let g = ListDataValidationRule._bp(b, c);
    let h = new Array(f.length);
    for (let i = 0; i < h.length; i++) {
      let j = f[i];
      if (d != null) {
        let k = d(j);
        if (k != null) {
          h[i] = k;
          continue;
        }
      }
      else {
        let l;
        if (((() => { let m = MathUtilities.c(j, b, l); l = m.p2; return m.ret; })())) {
          h[i] = l;
          continue;
        }
        let m;
        if (((() => { let n = FormulaParser.bu(j, m); m = n.p1; return n.ret; })())) {
          h[i] = m;
          continue;
        }
        let n = FormulaParser.b(j, b);
        if (n != null) {
          h[i] = n;
          continue;
        }
      }
      j = stringReplace(j, "\"\"", "\"");
      if (stringStartsWith(j, "'")) {
        j = j.substr(1);
      }
      if (g) {
        j = ListDataValidationRule._b0(j);
      }
      h[i] = j;
    }
    return h;
  }
  /**
   * @hidden
   */
  _b4(a, b, c, d, e, f = false) {
    if (!f) {
      this._bf(a, this._h, null, "valuesFormula", true, true, c);
    }
    let g = this._bc(() => this._getValuesFormula1("A1", c, 1, CultureInfo.invariantCulture), c);
    this._bo = this._a1(a, b, c, d, e, false);
    if (nullableNotEquals(g, null)) {
      this._be(ListDataValidationRule._bh[1], g.value, this._getValuesFormula1("A1", c, 1, CultureInfo.invariantCulture));
    }
  }
  /**
   * @hidden
   */
  static _bt(a, b, c) {
    if (b.length == 0) {
      return true;
    }
    if (typeCast(ErrorValue.$, a) !== null == false) {
      if (FormulaParser.b(b, c) != null) {
        return true;
      }
    }
    if (typeCast(Boolean_$type, a) !== null == false) {
      let d;
      if (((() => { let e = FormulaParser.bu(b, d); d = e.p1; return e.ret; })())) {
        return true;
      }
    }
    if (ExcelUtils.bb(a) == false) {
      let e;
      if (((() => { let f = MathUtilities.c(b, c, e); e = f.p2; return f.ret; })())) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  static _bm($tContext, $tValue, a, b, c, d = null, e = true, f = false, g = 2048) {
    return new ChangeInfo$2($tContext, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bi() {
    let a = new Array(2);
    ChangeInfo.f(a, 1, ListDataValidationRule._bm(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, "ValuesFormula", (b) => b.c, (b, c) => (b.a)._setValuesFormula1(c, "A1", b.a._a2, 1, CultureInfo.invariantCulture)));
    ChangeInfo.f(a, 0, ListDataValidationRule._bm(ListDataValidationRule.$, Boolean_$type, "ShowDropdown", (b) => b.showDropdown, (b, c) => b.showDropdown = c));
    return a;
  }
  /**
   * @hidden
   */
  static _bp(a, b) {
    return (b.numberFormat.numberDecimalSeparator == ",") != (a.numberFormat.numberDecimalSeparator == ",");
  }
  /**
   * @hidden
   */
  static _b0(a) {
    let b = new StringBuilder(2, a);
    for (let c = 0; c < b.c; c++) {
      switch (b.item(c)) {
        case ',':
          b.item(c, ';');
          break;
        case ';':
          b.item(c, ',');
          break;
      }
    }
    return b.toString();
  }
  /**
   * Gets or sets the value which indicates whether a drop down should be displayed in Microsoft Excel with the list of accepted values.
   * <p class="body">
   * If this is True, a drop down arrow will be displayed next to the cell when it is selected. When the user clicks the drop down arrow,
   * a drop down will be displayed with the list of accepted values.
   * </p>
   */
  get showDropdown() {
    return this._bq;
  }
  /**
   * Gets or sets the value which indicates whether a drop down should be displayed in Microsoft Excel with the list of accepted values.
   * <p class="body">
   * If this is True, a drop down arrow will be displayed next to the cell when it is selected. When the user clicks the drop down arrow,
   * a drop down will be displayed with the list of accepted values.
   * </p>
   */
  set showDropdown(a) {
    if (this._bq != a) {
      let b = ListDataValidationRule._bh[0].g(ListDataValidationRule.$, Boolean_$type, this, this._bq, a);
      this._bq = b.p1;
    }
  }
}
ListDataValidationRule.$t = markType(ListDataValidationRule, 'ListDataValidationRule', LimitedValueDataValidationRule.$);
/**
 * @hidden
 */
ListDataValidationRule._bv = 0;
/**
 * @hidden
 */
ListDataValidationRule._bw = 1;
/**
 * @hidden
 */
ListDataValidationRule._bu = 2;
/**
 * @hidden
 */
ListDataValidationRule._bh = ListDataValidationRule._bi();
/**
 * Base class for all data validations rules which compare the cell value against one or more constraint when determining
 * the validity of the cell value.
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export class ValueConstraintDataValidationRule extends LimitedValueDataValidationRule {
  constructor() {
    super();
    this._bk = 2;
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(ValueConstraintDataValidationRule.$, other);
    return a != null && super.isEquivalentTo(other) && a._bk == this._bk;
  }
  /**
   * @hidden
   */
  _a6(a, b, c, d, e) {
    if (super._a6(a, b, c, d, e) == false) {
      return false;
    }
    return LimitedValueDataValidationRule._a7(a, b, c, d);
  }
  /**
   * @hidden
   */
  _a8(a, b) {
    if (typeCast(ErrorValue.$, b) !== null) {
      return false;
    }
    let c;
    if (typeof b === 'string' || typeCast(FormattedString.$, b) !== null) {
      if (this.validationCriteria != 6) {
        return false;
      }
      c = typeof b === 'string' ? b.length : b.unformattedString.length;
    }
    else {
      if (!((() => { let d = ExcelUtils.b0(this._workbook, b, c); c = d.p2; return d.ret; })())) {
        return false;
      }
      if (this.validationCriteria == 6) {
        let d = WorksheetCellBlock.ah(b);
        let e = this._workbook._b2.a(0);
        let f = e.h(c, d, b, -1, null, null, false).g;
        c = (f != null ? f : stringEmpty()).length;
      }
    }
    switch (this.validationCriteria) {
      case 1:
        if (c % 1 != 0) {
          return false;
        }
        break;
      case 2:
      case 4:
      case 5:
      case 6: break;
    }
    return this._bm(a, c);
  }
  /**
   * @hidden
   */
  get__k() {
    return this._bk;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  _bf(a, b, c, d, e, f, g) {
    super._bf(a, b, c, d, e, f, g);
    if (a == null) {
      return;
    }
    if (a._e.length != 1) {
      return;
    }
    let h = a._e[0];
    let i = typeCast(NumberToken.$, h);
    let j = typeCast(IntToken.$, h);
    let k = typeCast(ReferenceToken.$, h);
    if (k != null) {
      if (typeCast(NameToken.$, k) !== null) {
        return;
      }
      if (typeCast(Area3DNToken.$, k) !== null || typeCast(Area3DToken.$, k) !== null || typeCast(AreaErr3DToken.$, k) !== null || typeCast(AreaErrToken.$, k) !== null || typeCast(AreaNToken.$, k) !== null || typeCast(AreaToken.$, k) !== null) {
        throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_ConstraintFormulaMustBeNumberOrReference", d));
      }
    }
    else if (i == null && j == null) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DV_ConstraintFormulaMustBeNumberOrReference", d));
    }
  }
  /**
   * @hidden
   */
  _bq(a, b) {
    if (EnumUtil.isDefined(DataValidationCriteria_$type, enumGetBox(DataValidationCriteria_$type, a)) == false) {
      throw new InvalidEnumArgumentException(b, a, DataValidationCriteria_$type);
    }
    this._bk = a;
  }
  /**
   * @hidden
   */
  static _bp(a) {
    if (a == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (a._e.length != 1) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    let b = a._e[0];
    let c = typeCast(IntToken.$, b);
    if (c != null) {
      return Nullable$1.toNullable(Number_$type, c.p);
    }
    let d = typeCast(NumberToken.$, b);
    if (d != null) {
      return Nullable$1.toNullable(Number_$type, d.p);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  static _bj($tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2(ValueConstraintDataValidationRule.$, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bi() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, ValueConstraintDataValidationRule._bj(DataValidationCriteria_$type, "ValidationCriteria", (b) => b.validationCriteria, (b, c) => b.validationCriteria = c, (b, c) => b._br(c)));
    return a;
  }
  /**
   * Gets or sets the criteria to use when validating the cell value against the constraint(s).
   * <p class="body">
   * Depending on the value specified, either then cell value or the length of its text equivalent will be compared against the
   * constraint(s). In addition, certain ValidationCriteria values may disallow a cell value even if it is valid when compared to
   * the constraint. For example, the ValidationCriteria.WholeNumber value will not allow any number with a fractional portion.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationCriteria]] enumeration.
   */
  get validationCriteria() {
    return this._bk;
  }
  /**
   * Gets or sets the criteria to use when validating the cell value against the constraint(s).
   * <p class="body">
   * Depending on the value specified, either then cell value or the length of its text equivalent will be compared against the
   * constraint(s). In addition, certain ValidationCriteria values may disallow a cell value even if it is valid when compared to
   * the constraint. For example, the ValidationCriteria.WholeNumber value will not allow any number with a fractional portion.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationCriteria]] enumeration.
   */
  set validationCriteria(a) {
    if (a != this._bk) {
      ValueConstraintDataValidationRule._bh[0].h(ValueConstraintDataValidationRule.$, DataValidationCriteria_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  _br(a) {
    this._bq(a, "value");
  }
}
ValueConstraintDataValidationRule.$t = markType(ValueConstraintDataValidationRule, 'ValueConstraintDataValidationRule', LimitedValueDataValidationRule.$);
/**
 * @hidden
 */
ValueConstraintDataValidationRule._bo = 0;
/**
 * @hidden
 */
ValueConstraintDataValidationRule._bn = 1;
/**
 * @hidden
 */
ValueConstraintDataValidationRule._bh = ValueConstraintDataValidationRule._bi();
/**
 * Represents a data validation rule which can validate the cell value against a single constraint value or formula.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[OneConstraintDataValidationOperator]]
 */
export class OneConstraintDataValidationRule extends ValueConstraintDataValidationRule {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super();
          this._bx = null;
          this._bv = 2;
        }
        break;
      case 1:
        {
          let validationOperator = _rest[0];
          let validationCriteria = _rest[1];
          super();
          this._bx = null;
          this._bv = 2;
          this._bv = validationOperator;
          this._bq(validationCriteria, "validationCriteria");
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _l(a) {
    return this._by(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _m(a) {
    return null;
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(OneConstraintDataValidationRule.$, other);
    return a != null && super.isEquivalentTo(other) && a._bv == this._bv && DataValidationRule._q(a._bx, this._bx);
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    super._ao(a, b);
    let c = this._bd(this._bx, b);
    this._bx = c.p0;
  }
  /**
   * @hidden
   */
  _ap() {
    if (this._bx != null) {
      this._bx._bu();
    }
    super._ap();
  }
  /**
   * @hidden
   */
  get__j() {
    return this._bv;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    this._ca(a, b, this._a2, this._ax, this._a9, true);
  }
  /**
   * @hidden
   */
  _ar(a, b) {
  }
  /**
   * @hidden
   */
  _bm(a, b) {
    let c;
    if (!((() => { let d = this._b0(c); c = d.p0; return d.ret; })())) {
      let d = this._aw(this._bx, a);
      if (d == null || ((() => { let e = d._toDouble1(c); c = e.p0; return e.ret; })()) == false) {
        return false;
      }
    }
    switch (this.validationOperator) {
      case 2: return b == c;
      case 4: return b > c;
      case 6: return b >= c;
      case 5: return b < c;
      case 7: return b <= c;
      case 3: return b != c;
      default: return false;
    }
  }
  /**
   * @hidden
   */
  _at(a, b) {
    this._bf(this._bx, a, b, "constraintFormula", true, true, this._a2);
  }
  getConstraintFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getConstraintFormula.apply(this, arguments);
      case 1:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return this._getConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getConstraintFormula(a) {
    return this._getConstraintFormula1(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _getConstraintFormula1(a, b, c, d) {
    let e = this._by(a, b, c, d);
    if (e == null) {
      return null;
    }
    return e._toString2(c, d);
  }
  setConstraint() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeCast(Date_$type, arguments[0]) !== null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._setConstraint.apply(this, arguments);
      case 1: return this._setConstraint1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setConstraint1(a) {
    this._setConstraintFormula("=" + ExcelUtils.ej(a, this._a9), null);
  }
  /**
   * @hidden
   */
  _setConstraint(a) {
    let b = ExcelCalcValue._dateTimeToExcelDate(this._workbook, a);
    if (b.hasValue == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_InvalidExcelDate"), "value");
    }
    this._setConstraint1(b.value);
  }
  setConstraintFormula() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setConstraintFormula.apply(this, arguments);
      case 1:
        arguments[4] = typeof arguments[4] === 'string' ? new CultureInfo(arguments[4]) : arguments[4];
        return this._setConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setConstraintFormula(a, b) {
    this._setConstraintFormula1(a, b, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _setConstraintFormula1(a, b, c, d, e) {
    let f = this._az(a, c, d, e);
    this._ca(f, b, c, d, e);
  }
  /**
   * @hidden
   */
  _b0(a) {
    a = 0;
    let b = ValueConstraintDataValidationRule._bp(this._bx);
    if (b.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = b.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _bz(a) {
    a = dateMinValue();
    let b;
    if (((() => { let c = this._b0(b); b = c.p0; return c.ret; })()) == false) {
      return {
        ret: false,
        p0: a
      };
    }
    let c = ExcelCalcValue._excelDateToDateTime(this._workbook, b);
    if (c.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = c.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _by(a, b, c, d) {
    return this._a1(this._bx, a, b, c, d, true);
  }
  /**
   * @hidden
   */
  _ca(a, b, c, d, e, f = false) {
    if (!f) {
      this._bf(a, this._h, null, "constraintFormula", true, true, c);
    }
    let g = this._bc(() => this._getConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture), c);
    this._bx = this._a1(a, b, c, d, e, false);
    if (nullableNotEquals(g, null)) {
      this._be(OneConstraintDataValidationRule._bs[0], g.value, this._getConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture));
    }
  }
  /**
   * @hidden
   */
  static _bu($tContext, $tValue, a, b, c, d = null, e = true, f = false, g = 2048) {
    return new ChangeInfo$2($tContext, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bt() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, OneConstraintDataValidationRule._bu(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, "ConstraintFormula", (b) => b.c, (b, c) => (b.a)._setConstraintFormula1(c, "A1", b.b, 1, CultureInfo.invariantCulture)));
    ChangeInfo.f(a, 1, OneConstraintDataValidationRule._bu(OneConstraintDataValidationRule.$, OneConstraintDataValidationOperator_$type, "ValidationOperator", (b) => b.validationOperator, (b, c) => b.validationOperator = c));
    return a;
  }
  /**
   * Gets or sets the validation operator to use when comparing the cell value against the constraint value or formula.
   * <p class="body">
   * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
   * length of the cell value's text equivalent is compared to the constraint value or formula.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[OneConstraintDataValidationOperator]] enumeration.
   * @see [[setConstraint]]
   * @see [[setConstraint]]
   * @see [[getConstraintFormula]]
   * @see [[getConstraintFormula]]
   * @see [[setConstraintFormula]]
   * @see [[setConstraintFormula]]
   * @see [[ValueConstraintDataValidationRule.validationCriteria]]
   */
  get validationOperator() {
    return this._bv;
  }
  /**
   * Gets or sets the validation operator to use when comparing the cell value against the constraint value or formula.
   * <p class="body">
   * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
   * length of the cell value's text equivalent is compared to the constraint value or formula.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[OneConstraintDataValidationOperator]] enumeration.
   * @see [[setConstraint]]
   * @see [[setConstraint]]
   * @see [[getConstraintFormula]]
   * @see [[getConstraintFormula]]
   * @see [[setConstraintFormula]]
   * @see [[setConstraintFormula]]
   * @see [[ValueConstraintDataValidationRule.validationCriteria]]
   */
  set validationOperator(a) {
    if (this._bv == a) {
      return;
    }
    if (EnumUtil.isDefined(OneConstraintDataValidationOperator_$type, enumGetBox(OneConstraintDataValidationOperator_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, OneConstraintDataValidationOperator_$type);
    }
    let b = OneConstraintDataValidationRule._bs[1].g(OneConstraintDataValidationRule.$, OneConstraintDataValidationOperator_$type, this, this._bv, a);
    this._bv = b.p1;
  }
}
OneConstraintDataValidationRule.$t = markType(OneConstraintDataValidationRule, 'OneConstraintDataValidationRule', ValueConstraintDataValidationRule.$);
/**
 * @hidden
 */
OneConstraintDataValidationRule._b1 = 0;
/**
 * @hidden
 */
OneConstraintDataValidationRule._b3 = 1;
/**
 * @hidden
 */
OneConstraintDataValidationRule._b2 = 2;
/**
 * @hidden
 */
OneConstraintDataValidationRule._bs = OneConstraintDataValidationRule._bt();
/**
 * Represents a data validation rule which can validate the cell value against two constraint values or formulas.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[TwoConstraintDataValidationOperator]]
 */
export class TwoConstraintDataValidationRule extends ValueConstraintDataValidationRule {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super();
          this._bx = null;
          this._by = null;
          this._bz = 0;
        }
        break;
      case 1:
        {
          let validationOperator = _rest[0];
          let validationCriteria = _rest[1];
          super();
          this._bx = null;
          this._by = null;
          this._bz = 0;
          this._bz = validationOperator;
          this._bq(validationCriteria, "validationCriteria");
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _l(a) {
    return this._bv(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _m(a) {
    return this._bw(a, this._a2, this._ax, this._a9);
  }
  /**
   * Indicates if this rule is structurally equivalent to another.
   * @param other The rule to compare against
   * @return Returns true if the specified 'other' has the same settings as this rule.
   */
  isEquivalentTo(other) {
    let a = typeCast(TwoConstraintDataValidationRule.$, other);
    return a != null && super.isEquivalentTo(other) && a._bz == this._bz && DataValidationRule._q(a._bx, this._bx) && DataValidationRule._q(a._by, this._by);
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    super._ao(a, b);
    let c = this._bd(this._bx, b);
    this._bx = c.p0;
    let d = this._bd(this._by, b);
    this._by = d.p0;
  }
  /**
   * @hidden
   */
  _ap() {
    if (this._bx != null) {
      this._bx._bu();
    }
    if (this._by != null) {
      this._by._bu();
    }
    super._ap();
  }
  /**
   * @hidden
   */
  get__j() {
    return this._bz;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    this._ch(a, b, this._a2, this._ax, this._a9, true);
  }
  /**
   * @hidden
   */
  _ar(a, b) {
    this._cm(a, b, this._a2, this._ax, this._a9, true);
  }
  /**
   * @hidden
   */
  _bm(a, b) {
    let c, d;
    if (!((() => { let e = this._b2(c); c = e.p0; return e.ret; })())) {
      let e = this._aw(this._bx, a);
      if (e == null || ((() => { let f = e._toDouble1(c); c = f.p0; return f.ret; })()) == false) {
        return false;
      }
    }
    if (!((() => { let f = this._b4(d); d = f.p0; return f.ret; })())) {
      let f = this._aw(this._by, a);
      if (f == null || ((() => { let g = f._toDouble1(d); d = g.p0; return g.ret; })()) == false) {
        return false;
      }
    }
    let g = c <= b && b <= d;
    return g == (this.validationOperator == 0);
  }
  /**
   * @hidden
   */
  _at(a, b) {
    let c = this._a2;
    this._bf(this._bx, a, b, "lowerConstraintFormula", true, true, c);
    this._bf(this._by, a, b, "upperConstraintFormula", true, false, c);
  }
  getLowerConstraintFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getLowerConstraintFormula.apply(this, arguments);
      case 1:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return this._getLowerConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getLowerConstraintFormula(a) {
    return this._getLowerConstraintFormula1(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _getLowerConstraintFormula1(a, b, c, d) {
    let e = this._bv(a, b, c, d);
    if (e == null) {
      return null;
    }
    return e._toString2(c, d);
  }
  getUpperConstraintFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getUpperConstraintFormula.apply(this, arguments);
      case 1:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return this._getUpperConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getUpperConstraintFormula(a) {
    return this._getUpperConstraintFormula1(a, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _getUpperConstraintFormula1(a, b, c, d) {
    let e = this._bw(a, b, c, d);
    if (e == null) {
      return null;
    }
    return e._toString2(c, d);
  }
  setLowerConstraint() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeCast(Date_$type, arguments[0]) !== null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._setLowerConstraint.apply(this, arguments);
      case 1: return this._setLowerConstraint1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setLowerConstraint1(a) {
    this._setLowerConstraintFormula("=" + ExcelUtils.ej(a, this._a9), null);
  }
  /**
   * @hidden
   */
  _setLowerConstraint(a) {
    let b = ExcelCalcValue._dateTimeToExcelDate(this._workbook, a);
    if (b.hasValue == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_InvalidExcelDate"), "value");
    }
    this._setLowerConstraint1(b.value);
  }
  setLowerConstraintFormula() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setLowerConstraintFormula.apply(this, arguments);
      case 1:
        arguments[4] = typeof arguments[4] === 'string' ? new CultureInfo(arguments[4]) : arguments[4];
        return this._setLowerConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setLowerConstraintFormula(a, b) {
    this._setLowerConstraintFormula1(a, b, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _setLowerConstraintFormula1(a, b, c, d, e) {
    let f = this._az(a, c, d, e);
    this._ch(f, b, c, d, e);
  }
  setUpperConstraint() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeCast(Date_$type, arguments[0]) !== null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._setUpperConstraint.apply(this, arguments);
      case 1: return this._setUpperConstraint1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setUpperConstraint1(a) {
    this._setUpperConstraintFormula("=" + ExcelUtils.ej(a, this._a9), null);
  }
  /**
   * @hidden
   */
  _setUpperConstraint(a) {
    let b = ExcelCalcValue._dateTimeToExcelDate(this._workbook, a);
    if (b.hasValue == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_InvalidExcelDate"), "value");
    }
    this._setUpperConstraint1(b.value);
  }
  setUpperConstraintFormula() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setUpperConstraintFormula.apply(this, arguments);
      case 1:
        arguments[4] = typeof arguments[4] === 'string' ? new CultureInfo(arguments[4]) : arguments[4];
        return this._setUpperConstraintFormula1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setUpperConstraintFormula(a, b) {
    this._setUpperConstraintFormula1(a, b, this._a2, this._ax, this._a9);
  }
  /**
   * @hidden
   */
  _setUpperConstraintFormula1(a, b, c, d, e) {
    let f = this._az(a, c, d, e);
    this._cm(f, b, c, d, e);
  }
  /**
   * @hidden
   */
  _b2(a) {
    a = 0;
    let b = ValueConstraintDataValidationRule._bp(this._bx);
    if (b.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = b.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _b1(a) {
    a = dateMinValue();
    let b;
    if (((() => { let c = this._b2(b); b = c.p0; return c.ret; })()) == false) {
      return {
        ret: false,
        p0: a
      };
    }
    let c = ExcelCalcValue._excelDateToDateTime(this._workbook, b);
    if (c.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = c.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _b4(a) {
    a = 0;
    let b = ValueConstraintDataValidationRule._bp(this._by);
    if (b.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = b.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _b3(a) {
    a = dateMinValue();
    let b;
    if (((() => { let c = this._b4(b); b = c.p0; return c.ret; })()) == false) {
      return {
        ret: false,
        p0: a
      };
    }
    let c = ExcelCalcValue._excelDateToDateTime(this._workbook, b);
    if (c.hasValue == false) {
      return {
        ret: false,
        p0: a
      };
    }
    a = c.value;
    return {
      ret: true,
      p0: a
    };
  }
  /**
   * @hidden
   */
  _bv(a, b, c, d) {
    return this._a1(this._bx, a, b, c, d, true);
  }
  /**
   * @hidden
   */
  _bw(a, b, c, d) {
    return this._a1(this._by, a, b, c, d, true);
  }
  /**
   * @hidden
   */
  _ch(a, b, c, d, e, f = false) {
    if (!f) {
      this._bf(a, this._h, null, "lowerConstraintFormula", true, true, c);
    }
    let g = ValueConstraintDataValidationRule._bp(a);
    let h = ValueConstraintDataValidationRule._bp(this._by);
    if (g.hasValue && h.hasValue) {
      if (h.value < g.value) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_LowerGreaterThanUpperContraint"), "lowerConstraintFormula");
      }
    }
    let i = this._bc(() => this._getLowerConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture), c);
    this._bx = this._a1(a, b, c, d, e, false);
    if (nullableNotEquals(i, null)) {
      this._be(TwoConstraintDataValidationRule._bs[0], i.value, this._getLowerConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture));
    }
  }
  /**
   * @hidden
   */
  _cm(a, b, c, d, e, f = false) {
    if (!f) {
      this._bf(a, this._h, null, "upperConstraintFormula", true, false, c);
    }
    let g = ValueConstraintDataValidationRule._bp(this._bx);
    let h = ValueConstraintDataValidationRule._bp(a);
    if (g.hasValue && h.hasValue) {
      if (h.value < g.value) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DV_UpperLessThanLowerContraint"), "upperConstraintFormula");
      }
    }
    let i = this._bc(() => this._getUpperConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture), c);
    this._by = this._a1(a, b, c, d, e, false);
    if (nullableNotEquals(i, null)) {
      this._be(TwoConstraintDataValidationRule._bs[1], i.value, this._getUpperConstraintFormula1("A1", c, 1, CultureInfo.invariantCulture));
    }
  }
  /**
   * @hidden
   */
  static _bu($tContext, $tValue, a, b, c, d = null, e = true, f = false, g = 2048) {
    return new ChangeInfo$2($tContext, $tValue, a, 31, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bt() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, TwoConstraintDataValidationRule._bu(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, "LowerConstraintFormula", (b) => b.c, (b, c) => (b.a)._setLowerConstraintFormula1(c, "A1", b.b, 1, CultureInfo.invariantCulture)));
    ChangeInfo.f(a, 1, TwoConstraintDataValidationRule._bu(LimitedValueDataValidationRule_FormulaChangeContext.$, String_$type, "UpperConstraintFormula", (b) => b.c, (b, c) => (b.a)._setUpperConstraintFormula1(c, "A1", b.b, 1, CultureInfo.invariantCulture)));
    ChangeInfo.f(a, 2, TwoConstraintDataValidationRule._bu(TwoConstraintDataValidationRule.$, TwoConstraintDataValidationOperator_$type, "ValidationOperator", (b) => b.validationOperator, (b, c) => b.validationOperator = c));
    return a;
  }
  /**
   * Gets or sets the validation operator to use when comparing the cell value against the constraint values or formulas.
   * <p class="body">
   * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
   * length of the cell value's text equivalent is compared to the constraint values or formulas.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[TwoConstraintDataValidationOperator]] enumeration.
   * @see [[setLowerConstraint]]
   * @see [[setLowerConstraint]]
   * @see [[setUpperConstraint]]
   * @see [[setUpperConstraint]]
   * @see [[getLowerConstraintFormula]]
   * @see [[getLowerConstraintFormula]]
   * @see [[getUpperConstraintFormula]]
   * @see [[getUpperConstraintFormula]]
   * @see [[setLowerConstraintFormula]]
   * @see [[setLowerConstraintFormula]]
   * @see [[setUpperConstraintFormula]]
   * @see [[setUpperConstraintFormula]]
   * @see [[ValueConstraintDataValidationRule.validationCriteria]]
   */
  get validationOperator() {
    return this._bz;
  }
  /**
   * Gets or sets the validation operator to use when comparing the cell value against the constraint values or formulas.
   * <p class="body">
   * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
   * length of the cell value's text equivalent is compared to the constraint values or formulas.
   * </p>
   * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[TwoConstraintDataValidationOperator]] enumeration.
   * @see [[setLowerConstraint]]
   * @see [[setLowerConstraint]]
   * @see [[setUpperConstraint]]
   * @see [[setUpperConstraint]]
   * @see [[getLowerConstraintFormula]]
   * @see [[getLowerConstraintFormula]]
   * @see [[getUpperConstraintFormula]]
   * @see [[getUpperConstraintFormula]]
   * @see [[setLowerConstraintFormula]]
   * @see [[setLowerConstraintFormula]]
   * @see [[setUpperConstraintFormula]]
   * @see [[setUpperConstraintFormula]]
   * @see [[ValueConstraintDataValidationRule.validationCriteria]]
   */
  set validationOperator(a) {
    if (this._bz == a) {
      return;
    }
    if (EnumUtil.isDefined(TwoConstraintDataValidationOperator_$type, enumGetBox(TwoConstraintDataValidationOperator_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, TwoConstraintDataValidationOperator_$type);
    }
    let b = TwoConstraintDataValidationRule._bs[2].g(TwoConstraintDataValidationRule.$, TwoConstraintDataValidationOperator_$type, this, this._bz, a);
    this._bz = b.p1;
  }
}
TwoConstraintDataValidationRule.$t = markType(TwoConstraintDataValidationRule, 'TwoConstraintDataValidationRule', ValueConstraintDataValidationRule.$);
/**
 * @hidden
 */
TwoConstraintDataValidationRule._b5 = 0;
/**
 * @hidden
 */
TwoConstraintDataValidationRule._b7 = 1;
/**
 * @hidden
 */
TwoConstraintDataValidationRule._b8 = 2;
/**
 * @hidden
 */
TwoConstraintDataValidationRule._b6 = 3;
/**
 * @hidden
 */
TwoConstraintDataValidationRule._bs = TwoConstraintDataValidationRule._bt();
/**
 * @hidden
 */
export class DisplayValueCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.c = d;
          this.b = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._d._b == null ? null : this.a._d._b.workbook;
  }
  get sheet() {
    return this.a._d._b == null ? null : this.a._d._b.worksheet;
  }
  get source() {
    return this.a._d._b;
  }
}
DisplayValueCollection_CollectionChangeContext.$t = markStruct(DisplayValueCollection_CollectionChangeContext, 'DisplayValueCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of display text values.
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 * @see [[FixedValuesFilter.displayValues]]
 */
export class DisplayValueCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._d = null;
    this._e = new List$1(String_$type, 0);
    this._d = a;
  }
  static staticInit() {
    DisplayValueCollection._a = DisplayValueCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._e.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._e.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a display text value to the collection.
   * @param item The display text value to add to the collection.
   * @throws [[ArgumentNullException]] 'item' is null or empty.
   * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
   */
  add(item) {
    this._s(item);
    this._k(this._e.count, item);
  }
  /**
   * Clears the collection.
   * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
   * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
   */
  clear() {
    if (this._d._aa() == this._e.count) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    let a = this._e.count > 0 ? this._j(13) : null;
    for (let b = this._e.count - 1; b >= 0; b--) {
      this._l(b, false);
    }
    this._d._i();
    this._o(a);
  }
  /**
   * Determines whether the specified value is in the collection.
   * <p class="body">
   * Display text values are compared case-insensitively.
   * </p>
   * @param item The display text value to find in the collection.
   * @return
   */
  contains(item) {
    return this.indexOf(item) >= 0;
  }
  /**
   * Gets the index of the specified display text value in the collection.
   * @param item The display text value to find in the collection.
   * @return The 0-based index of the specified display text value in the collection or -1 if the item is not in the collection.
   */
  indexOf(item) {
    let a = this._d._h;
    for (let b = 0; b < this._e.count; b++) {
      if (StringUtilities.c(item, this._e._inner[b], a, 1) == 0) {
        return b;
      }
    }
    return -1;
  }
  /**
   * Inserts a display text value into the collection.
   * @param index The 0-based index where the value should be inserted.
   * @param item The display text value to insert into the collection.
   * @throws [[ArgumentNullException]] 'item' is null or empty.
   * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
   */
  insert(index, item) {
    this._s(item);
    this._k(index, item);
  }
  /**
   * Removes a display text value from the collection.
   * <p class="body">
   * Display text values are compared case-insensitively.
   * </p>
   * @param item The display text value to remove from the collection.
   * @return True if the value was found and removed; False otherwise.
   */
  remove(item) {
    let a = this.indexOf(item);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the display text value at the specified index.
   * @param index The 0-based index of the value to remove.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
   * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
   * is not allowed for a FixedValuesFilter.
   */
  removeAt(index) {
    if (this._d._aa() == 1) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this._m(index);
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(DisplayValueCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, DisplayValueCollection._c(String_$type, "Add", 36, (b) => b.c, (b, c) => DisplayValueCollection._p(b, c)));
    ChangeInfo.f(a, 1, DisplayValueCollection._c(String_$type, "Remove", 37, (b) => b.c, (b, c) => DisplayValueCollection._q(b, c)));
    ChangeInfo.f(a, 2, DisplayValueCollection._c(String_$type, "Set", 36, (b) => b.c, (b, c) => DisplayValueCollection._r(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _k(a, b) {
    let c = DisplayValueCollection._a[0];
    let d = null;
    if (this._d._b != null) {
      d = c.b(this._d._b.workbook, this._d._b.worksheet, c.c);
    }
    let e = new DisplayValueCollection_CollectionChangeContext(1, this, b, a);
    this._e.insert(a, b);
    this._d._i();
    if (this._d._b != null) {
      c.e(DisplayValueCollection_CollectionChangeContext.$, String_$type, e, null, b);
      if (d != null) {
        c.d(this._d._b.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _l(a, b) {
    let c = this._e._inner[a];
    let d = DisplayValueCollection._a[1];
    let e = null;
    if (this._d._b != null) {
      e = d.b(this._d._b.workbook, this._d._b.worksheet, d.c);
    }
    let f = new DisplayValueCollection_CollectionChangeContext(1, this, c, a);
    this._e.removeAt(a);
    if (b) {
      this._d._i();
    }
    if (this._d._b != null) {
      d.e(DisplayValueCollection_CollectionChangeContext.$, String_$type, f, c, null);
      if (e != null) {
        d.d(this._d._b.workbook, e);
      }
    }
  }
  /**
   * @hidden
   */
  _m(a) {
    let b = this._e._inner[a];
    let c = DisplayValueCollection._a[1];
    let d = null;
    if (this._d._b != null) {
      d = c.b(this._d._b.workbook, this._d._b.worksheet, c.c);
    }
    let e = new DisplayValueCollection_CollectionChangeContext(1, this, b, a);
    this._e.removeAt(a);
    this._d._i();
    if (this._d._b != null) {
      c.e(DisplayValueCollection_CollectionChangeContext.$, String_$type, e, b, null);
      if (d != null) {
        c.d(this._d._b.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _n(a, b) {
    if (a == this._e.count) {
      this.add(b);
      return;
    }
    let c = this._e._inner[a];
    if (c == b) {
      return;
    }
    let d = DisplayValueCollection._a[2];
    let e = null;
    if (this._d._b != null) {
      e = d.b(this._d._b.workbook, this._d._b.worksheet, d.c);
    }
    let f = new DisplayValueCollection_CollectionChangeContext(1, this, c, a);
    this._e._inner[a] = b;
    if (this._d._b != null) {
      d.e(DisplayValueCollection_CollectionChangeContext.$, String_$type, f, c, null);
      if (e != null) {
        d.d(this._d._b.workbook, e);
      }
    }
    this._d._i();
  }
  /**
   * @hidden
   */
  _j(a) {
    let b = this._d._b == null ? null : this._d._b.workbook;
    return b != null && b._cx ? b._go(this._d._b.worksheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _o(a) {
    if (a != null) {
      let b = this._d._b.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _p(a, b) {
    let c = a.a._e.indexOf(a.c);
    if (c >= 0) {
      a.a._m(c);
    }
  }
  /**
   * @hidden
   */
  static _q(a, b) {
    a.a._k(a.b, a.c);
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    a.a._n(a.b, a.c);
  }
  /**
   * @hidden
   */
  _s(a) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(0, "item");
    }
    if (this.contains(a)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateDisplayValue"), "item");
    }
  }
  /**
   * Gets the number of display text values in the collection.
   */
  get count() {
    return this._e.count;
  }
  /**
   * Gets or sets the display text value at the specified index.
   * @param index The 0-based index of the value to get or set.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @throws [[ArgumentException]] The value assigned matches another value in the collection. Values are compared case-insensitively.
   */
  item(a, b) {
    if (arguments.length === 2) {
      if (b == null) {
        throw new ArgumentNullException(0, "item");
      }
      if (a < 0 || a > this._e.count) {
        this._e._inner[a] = b;
        return;
      }
      let c = this.indexOf(b);
      if (c < 0 || c == a) {
        this._n(a, b);
        return;
      }
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateDisplayValue"), "item");
      return b;
    }
    else {
      return this._e._inner[a];
    }
  }
}
DisplayValueCollection.$t = markType(DisplayValueCollection, 'DisplayValueCollection', Base.$, [IList$1_$type.specialize(String_$type)]);
/**
 * @hidden
 */
DisplayValueCollection._f = 0;
/**
 * @hidden
 */
DisplayValueCollection._h = 1;
/**
 * @hidden
 */
DisplayValueCollection._i = 2;
/**
 * @hidden
 */
DisplayValueCollection._g = 3;
/**
 * @hidden
 */
DisplayValueCollection._a = null;
/**
 * Class which exposes the document level properties for a Microsoft Excel file.
 * <p class="body">
 * The properties exposed by this class can be changed on a Microsoft Excel file by right-clicking it
 * in Windows Explorer and editing the properties on the Summary tab.
 * </p>
 */
export class DocumentProperties extends Base {
  constructor(a) {
    super();
    this._d = null;
    this._o = null;
    this._p = null;
    this._q = null;
    this._r = null;
    this._s = null;
    this._t = null;
    this._u = null;
    this._v = null;
    this._w = null;
    this._d = a;
  }
  /**
   * @hidden
   */
  _ag(a, b) {
    let c = a.t.item(4);
    let d = b.t.item(2);
    let e = a.t.item(6);
    let f = b.t.item(15);
    let g = a.t.item(5);
    let h = b.t.item(14);
    let i = a.t.item(3);
    let j = b.t.item(27);
    let k = a.t.item(2);
    this._o = c;
    this._p = d;
    this._q = e;
    this._r = f;
    this._s = g;
    this._t = h;
    this._v = i;
    this._u = j;
    this._w = k;
  }
  /**
   * @hidden
   */
  _ah(a) {
    let b = new SummaryInformation();
    let c = new DocumentSummaryInformation();
    b.t.item(4, this._o == null ? null : this._o.trim());
    c.t.item(2, this._p);
    b.t.item(6, this._q);
    c.t.item(15, this._r);
    b.t.item(5, this._s);
    c.t.item(14, this._t == null ? null : this._t.trim());
    b.t.item(3, this._v);
    c.t.item(27, this._u);
    b.t.item(2, this._w);
    let d = a._ab("\u0005DocumentSummaryInformation");
    if (d != null) {
      c.o(d);
    }
    let e = a._ab("\u0005SummaryInformation");
    if (e != null) {
      b.o(e);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c) {
    return new ChangeInfo$2(DocumentProperties.$, $tValue, a, 34, b, c, null, true, 0, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(9);
    ChangeInfo.f(a, 0, DocumentProperties._c(String_$type, "Author", (b) => b.author, (b, c) => b.author = c));
    ChangeInfo.f(a, 1, DocumentProperties._c(String_$type, "Category", (b) => b.category, (b, c) => b.category = c));
    ChangeInfo.f(a, 2, DocumentProperties._c(String_$type, "Comments", (b) => b.comments, (b, c) => b.comments = c));
    ChangeInfo.f(a, 3, DocumentProperties._c(String_$type, "Company", (b) => b.company, (b, c) => b.company = c));
    ChangeInfo.f(a, 4, DocumentProperties._c(String_$type, "Keywords", (b) => b.keywords, (b, c) => b.keywords = c));
    ChangeInfo.f(a, 5, DocumentProperties._c(String_$type, "Manager", (b) => b.manager, (b, c) => b.manager = c));
    ChangeInfo.f(a, 6, DocumentProperties._c(String_$type, "Status", (b) => b.status, (b, c) => b.status = c));
    ChangeInfo.f(a, 7, DocumentProperties._c(String_$type, "Subject", (b) => b.subject, (b, c) => b.subject = c));
    ChangeInfo.f(a, 8, DocumentProperties._c(String_$type, "Title", (b) => b.title, (b, c) => b.title = c));
    return a;
  }
  /**
   * Gets or sets the author of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the author of the document.
   */
  get author() {
    return this._o;
  }
  /**
   * Gets or sets the author of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the author of the document.
   */
  set author(a) {
    let b = DocumentProperties._a[0].g(DocumentProperties.$, String_$type, this, this._o, a);
    this._o = b.p1;
  }
  /**
   * Gets or sets the category of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the category of the document.
   */
  get category() {
    return this._p;
  }
  /**
   * Gets or sets the category of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the category of the document.
   */
  set category(a) {
    let b = DocumentProperties._a[1].g(DocumentProperties.$, String_$type, this, this._p, a);
    this._p = b.p1;
  }
  /**
   * Gets or sets the comments associated with the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the comments associated with the document.
   */
  get comments() {
    return this._q;
  }
  /**
   * Gets or sets the comments associated with the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the comments associated with the document.
   */
  set comments(a) {
    let b = DocumentProperties._a[2].g(DocumentProperties.$, String_$type, this, this._q, a);
    this._q = b.p1;
  }
  /**
   * Gets or sets the company to which the document belongs.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the company to which the document belongs.
   */
  get company() {
    return this._r;
  }
  /**
   * Gets or sets the company to which the document belongs.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the company to which the document belongs.
   */
  set company(a) {
    let b = DocumentProperties._a[3].g(DocumentProperties.$, String_$type, this, this._r, a);
    this._r = b.p1;
  }
  /**
   * Gets or sets the keywords which describe the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the keywords which describe the document.
   */
  get keywords() {
    return this._s;
  }
  /**
   * Gets or sets the keywords which describe the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the keywords which describe the document.
   */
  set keywords(a) {
    let b = DocumentProperties._a[4].g(DocumentProperties.$, String_$type, this, this._s, a);
    this._s = b.p1;
  }
  /**
   * Gets or sets the manager associated with the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the manager associated with the document.
   */
  get manager() {
    return this._t;
  }
  /**
   * Gets or sets the manager associated with the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the manager associated with the document.
   */
  set manager(a) {
    let b = DocumentProperties._a[5].g(DocumentProperties.$, String_$type, this, this._t, a);
    this._t = b.p1;
  }
  /**
   * Gets or sets the current status of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string representing the current status of the document.
   */
  get status() {
    return this._u;
  }
  /**
   * Gets or sets the current status of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string representing the current status of the document.
   */
  set status(a) {
    let b = DocumentProperties._a[6].g(DocumentProperties.$, String_$type, this, this._u, a);
    this._u = b.p1;
  }
  /**
   * Gets or sets the subject of the contents of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the subject of the contents of the document.
   */
  get subject() {
    return this._v;
  }
  /**
   * Gets or sets the subject of the contents of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the subject of the contents of the document.
   */
  set subject(a) {
    let b = DocumentProperties._a[7].g(DocumentProperties.$, String_$type, this, this._v, a);
    this._v = b.p1;
  }
  /**
   * Gets or sets the title of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the title of the document.
   */
  get title() {
    return this._w;
  }
  /**
   * Gets or sets the title of the document.
   * <p class="body">
   * The value of the property has no effect on the contents of the file when opened in a host application.
   * It is simply extra data associated with the document.
   * </p>
   * A string specifying the title of the document.
   */
  set title(a) {
    let b = DocumentProperties._a[8].g(DocumentProperties.$, String_$type, this, this._w, a);
    this._w = b.p1;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._d;
  }
  /**
   * @hidden
   */
  get sheet() {
    return null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
DocumentProperties.$t = markType(DocumentProperties, 'DocumentProperties', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
DocumentProperties._e = 0;
/**
 * @hidden
 */
DocumentProperties._f = 1;
/**
 * @hidden
 */
DocumentProperties._g = 2;
/**
 * @hidden
 */
DocumentProperties._h = 3;
/**
 * @hidden
 */
DocumentProperties._i = 4;
/**
 * @hidden
 */
DocumentProperties._j = 5;
/**
 * @hidden
 */
DocumentProperties._l = 6;
/**
 * @hidden
 */
DocumentProperties._m = 7;
/**
 * @hidden
 */
DocumentProperties._n = 8;
/**
 * @hidden
 */
DocumentProperties._k = 9;
/**
 * @hidden
 */
DocumentProperties._a = DocumentProperties._b();
/**
 * @hidden
 */
export class FixedLengthSegmentTree$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this.b = null;
    this.k = 0;
    this.c = null;
    this.l = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.c = a;
    this.k = b;
  }
  m() {
    this.b = null;
  }
  a(a, b, c) {
    while (true) {
      let d = a - (a % c);
      let e = d + c - 1;
      if (this.k <= e) {
        return null;
      }
      if (b <= e) {
        return new FixedLengthSegmentTree_SegmentTreeNode$1(this.$t, d, e);
      }
      c *= 2;
    }
  }
  n(a, b) {
    a = -1;
    b = -1;
    if (this.b != null) {
      let c = this.b.h(true, a);
      a = c.p1;
      let d = this.b.h(false, b);
      b = d.p1;
    }
    else {
      a = -1;
      b = -1;
    }
    return {
      p0: a,
      p1: b
    };
  }
  h(a, b, c, d) {
    let e = null;
    if (this.b != null && this.b.e <= a && b <= this.b.d) {
      let f = this.b.i(List$1.$.specialize(this.$t), this, a, b, c, e, this.c.u, d);
      e = f.p4;
    }
    return e;
  }
  e(a, b, c) {
    let d = null;
    if (this.b != null && this.b.e <= a && b <= this.b.d) {
      let e = this.b.i(HashSet$1.$.specialize(this.$t), this, a, b, null, d, this.c.t, c);
      d = e.p4;
    }
    return d;
  }
  i(a, b, c) {
    let d = null;
    if (this.b != null && this.b.e <= a && a <= this.b.d) {
      let e = this.b.j(List$1.$.specialize(this.$t), a, b, d, this.c.u, c);
      d = e.p2;
    }
    return d;
  }
  f(a, b) {
    let c = null;
    if (this.b != null && this.b.e <= a && a <= this.b.d) {
      let d = this.b.j(HashSet$1.$.specialize(this.$t), a, null, c, this.c.t, b);
      c = d.p2;
    }
    return c;
  }
  j(a, b, c, d) {
    let e = null;
    if (this.b != null && a <= this.b.d && this.b.e <= b) {
      let f = this.b.k(List$1.$.specialize(this.$t), a, b, c, e, this.c.u, d);
      e = f.p3;
    }
    return e;
  }
  g(a, b, c) {
    let d = null;
    if (this.b != null && a <= this.b.d && this.b.e <= b) {
      let e = this.b.k(HashSet$1.$.specialize(this.$t), a, b, null, d, this.c.t, c);
      d = e.p3;
    }
    return d;
  }
  o(a, b, c) {
    if (this.b == null) {
      let d = 8;
      this.b = this.a(b, c, d);
    }
    else if (b < this.b.e || this.b.d < c) {
      let e = this.b.d - this.b.e + 1;
      let f = this.b;
      this.b = this.a(Math.min(b, this.b.e), Math.max(c, this.b.d), e);
      this.b.n(f);
    }
    this.b.l(this, a, b, c);
  }
  p(a, b, c) {
    if (this.b != null) {
      this.b.m(this, a, b, c);
    }
  }
  get d() {
    return this.l == 0;
  }
}
FixedLengthSegmentTree$1.$t = markType(FixedLengthSegmentTree$1, 'FixedLengthSegmentTree$1');
/**
 * @hidden
 */
export class FixedLengthSegmentTree_SegmentTreeNode$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this.e = 0;
    this.d = 0;
    this.c = null;
    this.a = null;
    this.b = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.e = a;
    this.d = b;
  }
  f($tCol, a, b, c, d) {
    let e = FixedLengthSegmentTree_SegmentTreeNode$1.g(this.$t, $tCol, this.c, a, b, c, d);
    b = e.p2;
    return {
      p1: b
    };
  }
  static g($t, $tCol, a, b, c, d, e) {
    if (a == null || a.count == 0) {
      return {
        p2: c
      };
    }
    for (let f of fromEnum(a)) {
      if (b == null || b.remove(f)) {
        if (getBoxIfEnum($tCol, c) == null) {
          c = d();
        }
        if (e == null || e(f)) {
          c.add(f);
        }
      }
    }
    return {
      p2: c
    };
  }
  h(a, b) {
    let c = a ? this.a : this.b;
    if (c != null) {
      let d = c.h(a, b);
      b = d.p1;
    }
    if (b < 0 && this.c != null && this.c.count != 0) {
      b = a ? this.e : this.d;
      return {
        p1: b
      };
    }
    c = a ? this.b : this.a;
    if (c != null) {
      let e = c.h(a, b);
      b = e.p1;
    }
    return {
      p1: b
    };
  }
  i($tCol, a, b, c, d, e, f, g) {
    if (b < this.e || this.d < c) {
      return {
        p4: e
      };
    }
    let h = this.f($tCol, d, e, f, g);
    e = h.p1;
    if (this.e == this.d) {
      return {
        p4: e
      };
    }
    let i = intDivide((this.d + this.e), 2);
    let j = b <= i;
    let k = c <= i;
    if (j == k) {
      if (j) {
        if (this.a != null) {
          let l = this.a.i($tCol, a, b, c, d, e, f, g);
          e = l.p4;
        }
      }
      else {
        if (this.b != null) {
          let m = this.b.i($tCol, a, b, c, d, e, f, g);
          e = m.p4;
        }
      }
      return {
        p4: e
      };
    }
    if (this.a == null || this.b == null) {
      return {
        p4: e
      };
    }
    let n = null;
    let o = this.a.j(HashSet$1.$.specialize(this.$t), b, d, n, a.c.t, g);
    n = o.p2;
    if (n == null) {
      return {
        p4: e
      };
    }
    let p = null;
    let q = this.b.j(List$1.$.specialize(this.$t), c, n, p, a.c.u, g);
    p = q.p2;
    let r = FixedLengthSegmentTree_SegmentTreeNode$1.g(this.$t, $tCol, p, d, e, f, g);
    e = r.p2;
    return {
      p4: e
    };
  }
  j($tCol, a, b, c, d, e) {
    let f = this.f($tCol, b, c, d, e);
    c = f.p1;
    if (this.e == this.d) {
      return {
        p2: c
      };
    }
    let g = intDivide((this.d + this.e), 2);
    if (a <= g) {
      if (this.a != null) {
        let h = this.a.j($tCol, a, b, c, d, e);
        c = h.p2;
      }
    }
    else {
      if (this.b != null) {
        let i = this.b.j($tCol, a, b, c, d, e);
        c = i.p2;
      }
    }
    return {
      p2: c
    };
  }
  k($tCol, a, b, c, d, e, f) {
    if (b < this.e || this.d < a) {
      return {
        p3: d
      };
    }
    let g = this.f($tCol, c, d, e, f);
    d = g.p1;
    if (this.e == this.d) {
      return {
        p3: d
      };
    }
    let h = intDivide((this.d + this.e), 2);
    if (a <= h && this.a != null) {
      let i = this.a.k($tCol, a, b, c, d, e, f);
      d = i.p3;
    }
    if (h < b && this.b != null) {
      let j = this.b.k($tCol, a, b, c, d, e, f);
      d = j.p3;
    }
    return {
      p3: d
    };
  }
  l(a, b, c, d) {
    if (c <= this.e && this.d <= d) {
      if (this.c == null) {
        this.c = new List$1(this.$t, 0);
      }
      this.c.add(b);
      a.l++;
      return;
    }
    let e = intDivide((this.d + this.e), 2);
    if (c <= e) {
      if (this.a == null) {
        this.a = new FixedLengthSegmentTree_SegmentTreeNode$1(this.$t, this.e, e);
      }
      this.a.l(a, b, c, d);
    }
    if (e < d) {
      if (this.b == null) {
        this.b = new FixedLengthSegmentTree_SegmentTreeNode$1(this.$t, e + 1, this.d);
      }
      this.b.l(a, b, c, d);
    }
  }
  m(a, b, c, d) {
    if (c <= this.e && this.d <= d) {
      if (this.c != null) {
        if (this.c.remove(b)) {
          a.l--;
        }
      }
      return;
    }
    let e = intDivide((this.d + this.e), 2);
    if (c <= e) {
      if (this.a != null) {
        this.a.m(a, b, c, d);
      }
    }
    if (e < d) {
      if (this.b != null) {
        this.b.m(a, b, c, d);
      }
    }
  }
  n(a) {
    let b = intDivide((this.d + this.e), 2);
    if (a.d <= b) {
      if (a.e == this.e && a.d == b) {
        this.a = a;
      }
      else {
        this.a = new FixedLengthSegmentTree_SegmentTreeNode$1(this.$t, this.e, b);
        this.a.n(a);
      }
    }
    else if (b < a.e) {
      if (a.e == (b + 1) && a.d == this.d) {
        this.b = a;
      }
      else {
        this.b = new FixedLengthSegmentTree_SegmentTreeNode$1(this.$t, b + 1, this.d);
        this.b.n(a);
      }
    }
  }
}
FixedLengthSegmentTree_SegmentTreeNode$1.$t = markType(FixedLengthSegmentTree_SegmentTreeNode$1, 'FixedLengthSegmentTree_SegmentTreeNode$1');
/**
 * @hidden
 */
export class FormatLimitErrors extends Base {
  constructor(a) {
    super();
    this.c = false;
    this.e = null;
    this.a = null;
    this.a = a;
  }
  g(a) {
    this.c = true;
    this.f.add(a);
  }
  h() {
    this.c = false;
    if (this.e != null) {
      this.e.clear();
    }
  }
  get f() {
    if (this.e == null) {
      this.e = new List$1(String_$type, 0);
    }
    return this.e;
  }
  get d() {
    return this.c;
  }
  get b() {
    return this.a;
  }
}
FormatLimitErrors.$t = markType(FormatLimitErrors, 'FormatLimitErrors');
/**
 * Abstract base class which controls the formatting of a range of characters in a [[FormattedString]] or [[FormattedText]].
 * @see [[FormattedStringFont]]
 * @see [[FormattedTextFont]]
 */
export class FormattedFontBase extends Base {
  constructor(a, b, c) {
    super();
    this._f = null;
    this._u = 0;
    this._q = 0;
    this._f = a;
    this._u = b;
    this._q = c;
  }
  /**
   * Sets all properties of this font to the properties of the specified font.
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, any default values on the specified font will be ignored.
   * </p>
   * @throws [[ArgumentNullException]] 'source' is null.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   * @param source The font whose properties should be copied over to this font.
   */
  setFontFormatting(source) {
    if (source == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFont"));
    }
    let a = this._g.workbook;
    let b = null;
    if (a != null) {
      b = a._go(null, 88, null);
    }
    this.name = source.name;
    this.height = source.height;
    this.colorInfo = source.colorInfo;
    this._bold$i = source._bold$i;
    this._italic$i = source._italic$i;
    this._strikeout$i = source._strikeout$i;
    this.superscriptSubscriptStyle = source.superscriptSubscriptStyle;
    this.underlineStyle = source.underlineStyle;
    if (b != null) {
      a._ic(b);
    }
  }
  /**
   * @hidden
   */
  _z() {
    this._f.onFormattingChanged();
  }
  /**
   * @hidden
   */
  _aa() {
  }
  /**
   * @hidden
   */
  _h(a) {
    return null;
  }
  /**
   * @hidden
   */
  _ab(a, b, c, d, e, f) {
    let g = Math.max(a.startIndex, this._u);
    let h = a.getFormattingRuns(b);
    for (let i = 0; i < h.count; i++) {
      let j = h._inner[i];
      try {
        if (j.i < g) {
          continue;
        }
        if (c.count == 0 && g < j.i) {
          let k = a.createRun(g);
          if (f != null) {
            k.m(f, b);
          }
          else if (e != null) {
            e.resolveDefaults(k.f(b).d);
          }
          a.insertRun(i, k);
          j = k;
        }
        if (d <= j.i) {
          break;
        }
        c.add(j);
      }
      finally {
        f = j;
      }
    }
    return {
      p5: f
    };
  }
  /**
   * @hidden
   */
  _ad() {
  }
  /**
   * @hidden
   */
  _e(a, b) {
    for (let c = a.count - 1; c >= 0; c--) {
      let d = a._inner[c];
      if (d.i <= b) {
        return d;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  static _ae($tValue, a, b, c, d, e) {
    ChangeInfo.f(a, b, new ChangeInfo$2(FormattedFontBase.$, $tValue, c, 88, d, e, null, true, 4, false, null, null));
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(8);
    FormattedFontBase._ae(Nullable$1.$.specialize(Boolean_$type), a, 0, "Bold", (b) => b._bold$i, (b, c) => b._bold$i = c);
    FormattedFontBase._ae(WorkbookColorInfo.$, a, 1, "ColorInfo", (b) => b.colorInfo, (b, c) => b.colorInfo = c);
    FormattedFontBase._ae(Number_$type, a, 2, "Height", (b) => b.height, (b, c) => b.height = c);
    FormattedFontBase._ae(Nullable$1.$.specialize(Boolean_$type), a, 3, "Italic", (b) => b._italic$i, (b, c) => b._italic$i = c);
    FormattedFontBase._ae(String_$type, a, 4, "Name", (b) => b.name, (b, c) => b.name = c);
    FormattedFontBase._ae(Nullable$1.$.specialize(Boolean_$type), a, 5, "Strikeout", (b) => b._strikeout$i, (b, c) => b._strikeout$i = c);
    FormattedFontBase._ae(FontSuperscriptSubscriptStyle_$type, a, 6, "SuperscriptSubscriptStyle", (b) => b.superscriptSubscriptStyle, (b, c) => b.superscriptSubscriptStyle = c);
    FormattedFontBase._ae(FontUnderlineStyle_$type, a, 7, "UnderlineStyle", (b) => b.underlineStyle, (b, c) => b.underlineStyle = c);
    return a;
  }
  /**
   * @hidden
   */
  _l(a) {
    let b = this._f.workbook;
    let c = new List$1(FormattingRunBase.$, 0);
    let d = this._f.toString();
    let e = (this.length != 0) ? this.startIndex + this.length : d.length;
    let f;
    let g = this._ac(b, c, e, a, f);
    f = g.p4;
    if (c.count == 0) {
      let h = this._f.getOwnerAt(this._u);
      if (h != null) {
        let i = h.createRun(this._u);
        if (f != null) {
          i.m(f, b);
        }
        else if (a != null) {
          a.resolveDefaults(i.f(b).d);
        }
        c.add(i);
        h.addRun(i);
      }
    }
    if (c.count > 0 && e < d.length) {
      let j = this._f.getOwnerAt(e);
      if (j != null) {
        let k = j.getFormattingRuns(b);
        let l = this._e(k, e);
        if (l == null || l.i < e) {
          let m = c._inner[c.count - 1];
          let n = j.createRun(e);
          n.m(m, b);
          let o = 0;
          if (l != null) {
            o = k.indexOf(l) + 1;
          }
          j.insertRun(o, n);
        }
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  _c($tValue, a, b) {
    this._ag();
    let c = this._d;
    if (c != null) {
      return a(c.d(this._g.workbook));
    }
    return b;
  }
  /**
   * @hidden
   */
  _af($tValue, a, b, c, d, e) {
    if (this._k == false && Base.equalsStatic(getBoxIfEnum($tValue, a), getBoxIfEnum($tValue, b))) {
      return;
    }
    this._ag();
    this._aa();
    let f = this._f.workbook;
    let g;
    let h = f != null && f._cx;
    if (h) {
      g = c(this);
    }
    else {
      g = b;
    }
    let i = this._h(f);
    for (let j of fromEnum(this._l(i))) {
      if (j != null) {
        d(j.d(f), a);
      }
    }
    this._z();
    if (h) {
      FormattedFontBase._a[e].e(FormattedFontBase.$, $tValue, this, g, a);
    }
  }
  /**
   * @hidden
   */
  _ag() {
    if (this._f.owner == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FormattedStringNotOwned"));
    }
    let a = this._u;
    if (0 < this._q) {
      a += this._q;
    }
    if (this._f.toString().length < a) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InvalidCharacterRange"));
    }
  }
  /**
   * Gets or sets the value indicating whether the font is bold.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is bold.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get bold() {
    return unwrapNullable(this._bold$i);
  }
  /**
   * Gets or sets the value indicating whether the font is bold.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is bold.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set bold(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._bold$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _bold$i() {
    return this._c(Nullable$1.$.specialize(Boolean_$type), (a) => a._bold$i, ExcelUtils.dq);
  }
  /**
   * @hidden
   */
  set _bold$i(a) {
    ExcelUtils.gj(a);
    this._af(Nullable$1.$.specialize(Boolean_$type), a, ExcelUtils.dq, (b) => b._bold$i, (b, c) => b._bold$i = c, 0);
  }
  /**
   * Gets or sets the fore color of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The fore color of the font.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get colorInfo() {
    return this._c(WorkbookColorInfo.$, (a) => a.colorInfo, null);
  }
  /**
   * Gets or sets the fore color of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The fore color of the font.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set colorInfo(a) {
    this._af(WorkbookColorInfo.$, a, null, (b) => b.colorInfo, (b, c) => b.colorInfo = c, 1);
  }
  /**
   * Gets or sets the height of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The height of the font.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is positive and outside the valid font height range of 20 and 8180.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get height() {
    return this._c(Number_$type, (a) => a.height, -1);
  }
  /**
   * Gets or sets the height of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The height of the font.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is positive and outside the valid font height range of 20 and 8180.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set height(a) {
    this._af(Number_$type, a, -1, (b) => b.height, (b, c) => b.height = c, 2);
  }
  /**
   * Gets or sets the value indicating whether the font is italic.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is italic.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get italic() {
    return unwrapNullable(this._italic$i);
  }
  /**
   * Gets or sets the value indicating whether the font is italic.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is italic.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set italic(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._italic$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _italic$i() {
    return this._c(Nullable$1.$.specialize(Boolean_$type), (a) => a._italic$i, ExcelUtils.dq);
  }
  /**
   * @hidden
   */
  set _italic$i(a) {
    ExcelUtils.gj(a);
    this._af(Nullable$1.$.specialize(Boolean_$type), a, ExcelUtils.dq, (b) => b._italic$i, (b, c) => b._italic$i = c, 3);
  }
  /**
   * Gets the number of characters covered by this font. Zero indicates the font controls from
   * the [[startIndex]] to the end of the string.
   * The number of characters covered by this font. Zero indicates the font controls from the
   * StartIndex to the end of the string.
   */
  get length() {
    return this._q;
  }
  /**
   * Gets or sets the name of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The name of the font.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get name() {
    return this._c(String_$type, (a) => a.name, null);
  }
  /**
   * Gets or sets the name of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The name of the font.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set name(a) {
    this._af(String_$type, a, null, (b) => b.name, (b, c) => b.name = c, 4);
  }
  /**
   * Gets the index of the first character covered by this font.
   * The index of the first character covered by this font.
   */
  get startIndex() {
    return this._u;
  }
  /**
   * Gets or sets the value indicating whether the font is struck out.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is struck out.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get strikeout() {
    return unwrapNullable(this._strikeout$i);
  }
  /**
   * Gets or sets the value indicating whether the font is struck out.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is struck out.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set strikeout(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._strikeout$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _strikeout$i() {
    return this._c(Nullable$1.$.specialize(Boolean_$type), (a) => a._strikeout$i, ExcelUtils.dq);
  }
  /**
   * @hidden
   */
  set _strikeout$i(a) {
    ExcelUtils.gj(a);
    this._af(Nullable$1.$.specialize(Boolean_$type), a, ExcelUtils.dq, (b) => b._strikeout$i, (b, c) => b._strikeout$i = c, 5);
  }
  /**
   * Gets or sets the value indicating whether the font is superscript or subscript.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is superscript or subscript.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontSuperscriptSubscriptStyle]] enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get superscriptSubscriptStyle() {
    return this._c(FontSuperscriptSubscriptStyle_$type, (a) => a.superscriptSubscriptStyle, -1);
  }
  /**
   * Gets or sets the value indicating whether the font is superscript or subscript.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The value indicating whether the font is superscript or subscript.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontSuperscriptSubscriptStyle]] enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set superscriptSubscriptStyle(a) {
    ExcelUtils.gl(FontSuperscriptSubscriptStyle_$type, a);
    this._af(FontSuperscriptSubscriptStyle_$type, a, -1, (b) => b.superscriptSubscriptStyle, (b, c) => b.superscriptSubscriptStyle = c, 6);
  }
  /**
   * Gets or sets the underline style of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The underline style of the font.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontUnderlineStyle]] enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  get underlineStyle() {
    return this._c(FontUnderlineStyle_$type, (a) => a.underlineStyle, -1);
  }
  /**
   * Gets or sets the underline style of the font.
   * <p class="body">
   * All characters in the selection range of this font will be affected by setting this property.
   * Getting this property will return a value which indicates the formatting of the first character
   * in this font's range.
   * </p>
   * <p class="note">
   * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
   * which is the value of a cell, and a default value is assigned, it will be ignored.
   * </p>
   * The underline style of the font.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontUnderlineStyle]] enumeration.
   * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
   * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
   */
  set underlineStyle(a) {
    ExcelUtils.gl(FontUnderlineStyle_$type, a);
    this._af(FontUnderlineStyle_$type, a, -1, (b) => b.underlineStyle, (b, c) => b.underlineStyle = c, 7);
  }
  /**
   * @hidden
   */
  get__k() {
    return true;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  get _g() {
    return this._f;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._sheet;
  }
  /**
   * @hidden
   */
  get source() {
    return this._g;
  }
}
FormattedFontBase.$t = markType(FormattedFontBase, 'FormattedFontBase', Base.$, [IWorkbookFont_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
FormattedFontBase._m = 0;
/**
 * @hidden
 */
FormattedFontBase._n = 1;
/**
 * @hidden
 */
FormattedFontBase._o = 2;
/**
 * @hidden
 */
FormattedFontBase._p = 3;
/**
 * @hidden
 */
FormattedFontBase._s = 4;
/**
 * @hidden
 */
FormattedFontBase._w = 5;
/**
 * @hidden
 */
FormattedFontBase._x = 6;
/**
 * @hidden
 */
FormattedFontBase._y = 7;
/**
 * @hidden
 */
FormattedFontBase._t = 8;
/**
 * @hidden
 */
FormattedFontBase._a = FormattedFontBase._b();
/**
 * @hidden
 */
export class FormattedStringValueReference extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.a = null;
    this.d = null;
    this.a = b == null ? null : b._bj;
    this.d = a;
    let c = this.d.toString();
    if (typeCast(String_$type, a) !== null && a.charCodeAt(0) == 0) {
      c = stringEmpty();
    }
    this.b = GenericCacheElement.a(StringElement.$, new StringElement(c), this.a);
  }
  setWorkbook(a) {
    let b = StringElement._ad(a, this.a, this.b);
    this.a = b.p1;
    this.b = b.p2;
  }
  toString() {
    return this.b.toString();
  }
  get c() {
    return this.b;
  }
  get e() {
    return this.d;
  }
}
FormattedStringValueReference.$t = markType(FormattedStringValueReference, 'FormattedStringValueReference', Base.$, [IFormattedString_$type]);
/**
 * @hidden
 */
export let IStringElementVisitor$2_$type = new Type(null, 'IStringElementVisitor$2');
/**
 * Controls the formatting of a range of characters in a [[formattedString]].
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the [[formattedString]], a portion of the string is "selected" by calling either
 * <see cref="Excel.FormattedString.GetFont(int)">GetFont(int)</see> or
 * <see cref="Excel.FormattedString.GetFont(int,int)">GetFont(int,int)</see>. Formatting properties
 * are then set on the returned FormattedStringFont and all characters in the font's selection range are given these
 * properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedStringFont will return the formatting of the first character in font's
 * selection range. This is similar to Excel, which will update the formatting interface to reflect the formatting of the
 * first character in a selection range when a cell's text is selected.
 * </p>
 * @see@see@see */
export class FormattedStringFont extends FormattedFontBase {
  constructor(a, b, c) {
    super(a, b, c);
  }
  /**
   * @hidden
   */
  get__k() {
    let a = this.formattedString._owner;
    return a != null && a.allowDefaultValues;
  }
  /**
   * @hidden
   */
  _h(a) {
    let b = this.formattedString._owner;
    return b == null ? null : b.getFontDefaultsResolver();
  }
  /**
   * @hidden
   */
  _ac(a, b, c, d, e) {
    e = null;
    let f = this.formattedString;
    let g = typeCast(FormattedStringElement.$, f._m);
    if (g != null && g._u) {
      let h = this._ab(g, a, b, c, d, e);
      e = h.p5;
    }
    if (e == null) {
      let i = f._owner;
      if (i != null && !i.allowDefaultValues) {
        e = this._d;
      }
    }
    return {
      p4: e
    };
  }
  /**
   * @hidden
   */
  get__d() {
    let a = this.formattedString;
    let b = typeCast(FormattedStringElement.$, a._m);
    if (b != null && b._u) {
      let c = this._e(b._ah, this.startIndex);
      if (c != null) {
        return c;
      }
    }
    let d = a._owner;
    let e = d != null ? d.getDefaultFont() : null;
    if (e != null) {
      return new CellFormattingRunPlaceholder(a._m, e);
    }
    return null;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  get__sheet() {
    let a = this.formattedString;
    if (a != null) {
      return a._sheet;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _sheet() {
    return this.get__sheet();
  }
  /**
   * @hidden
   */
  get__workbook() {
    let a = this.formattedString;
    if (a != null) {
      return a._workbook;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _workbook() {
    return this.get__workbook();
  }
  /**
   * @hidden
   */
  _z() {
    let a = this.formattedString;
    let b = a._m._aa;
    a._w();
    let c = typeCast(WorksheetCell.$, a._owner);
    if (WorksheetCell.l_op_Inequality(c, null) && c._o != null) {
      let d = a._m._aa;
      if (b != d) {
        c._o._ec(c._ab, a._m);
      }
    }
    super._z();
  }
  /**
   * @hidden
   */
  _aa() {
    this.formattedString._x();
  }
  /**
   * Gets the formatted string which is controlled by this font.
   * The formatted string which is controlled by this font.
   */
  get formattedString() {
    return this._g;
  }
}
FormattedStringFont.$t = markType(FormattedStringFont, 'FormattedStringFont', FormattedFontBase.$);
/**
 * @hidden
 */
export class FormattedStringRun extends FormattingRunBase {
  constructor(a, b) {
    super(a, b);
    this._n = null;
  }
  equals(a) {
    let b = typeCast(FormattedStringRun.$, a);
    if (b == null) {
      return false;
    }
    if (this.k != b.k) {
      return false;
    }
    if (Base.equalsStatic(this._n, b._n) == false) {
      return false;
    }
    return true;
  }
  d(a) {
    return this.f(a);
  }
  f(a) {
    return ((() => { let b = this.g(a, this._n); this._n = b.p1; return b.ret; })());
  }
  getHashCode() {
    return this.e().getHashCode() + this.i;
  }
  get_h() {
    return this._n != null || this.i == 0;
  }
  get h() {
    return this.get_h();
  }
  compareTo(a) {
    return this.k - a.k;
  }
  get_i() {
    return this.k;
  }
  set_i(a) {
    this.k = a;
  }
  get i() {
    return this.get_i();
  }
  set i(a) {
    this.set_i(a);
  }
}
FormattedStringRun.$t = markType(FormattedStringRun, 'FormattedStringRun', FormattingRunBase.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * Represents text with multiple paragraphs and mixed formatting in a shape.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedText, a portion of the text is "selected" by calling either [[getFont]]
 * or [[getFont]]. Formatting properties are then set on the returned
 * [[FormattedTextFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedTextFont]] will return the formatting of the first
 * character in font's selection range.
 * </p>
 * @see [[WorksheetShapeWithText.text]]
 */
export class FormattedText extends Base {
  constructor(..._rest) {
    super();
    this._t = null;
    this._h = null;
    this._f = null;
    this._n = null;
    this._k = 2;
    /**
     * @hidden
     */
    this._s = Nullable$1.toNullable(HorizontalTextAlignment_$type, null);
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          this._f = new FormattedTextParagraphCollection(this);
          this._n = ((() => {
            let $ret = new CT_TextBodyPropertiesBase();
            $ret.a = Nullable$1.toNullable(Boolean_$type, false);
            return $ret;
          })());
        }
        break;
      case 1:
        {
          let unformattedString = _rest[0];
          {
            this._f = new FormattedTextParagraphCollection(this);
            this._n = ((() => {
              let $ret = new CT_TextBodyPropertiesBase();
              $ret.a = Nullable$1.toNullable(Boolean_$type, false);
              return $ret;
            })());
          }
          if (unformattedString == null) {
            throw new ArgumentNullException(2, "unformattedString", ExcelUtils.ef("LE_ArgumentNullException_UnformattedString"));
          }
          let b;
          let c;
          let d = ((() => { let e = ExcelUtils.cc(unformattedString, b, c); b = e.p1; c = e.p2; return e.ret; })());
          for (let e = 0; e < b.count; e++) {
            let f = b._inner[e];
            let g = d._inner[e];
            let h = null;
            if (e < c.count) {
              h = c._inner[e];
            }
            let i = new FormattedTextParagraph(this, f, g, h);
            this._f._o(e, i, h);
          }
          this._w();
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Returns the string that represents the [[FormattedText]], which is the unformatted string.
   * @return The string that represents the FormattedText.
   */
  toString() {
    if (this._t == null) {
      let a = new StringBuilder(0);
      for (let b = 0; b < this._f.count; b++) {
        let c = this._f.item(b);
        a.l(c.unformattedString);
        if (b < this._f.count - 1) {
          a.l(c._s);
        }
      }
      this._t = a.toString();
    }
    return this._t;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._sheet;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get owner() {
    return this._owner;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  getOwnerAt(startIndex) {
    for (let a = this._f.count - 1; a >= 0; a--) {
      let b = this._f.item(a);
      if (b.startIndex <= startIndex) {
        return b;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  onFormattingChanged() {
    this._onFormattingChanged();
  }
  /**
   * Creates a new [[FormattedText]] that is a copy of this one.
   * <p class="body">
   * This should be used if the same formatted text needs to be used in multiple shapes.
   * The FormattedText class can only exist as the [[WorksheetShapeWithText.text]]
   * of one shape at a time. If the FormattedText is already the text of a shape, and needs
   * to be set as the text of another shape, clone the FormattedText and set the returned
   * clone as text of the shape.
   * </p>
   * <p class="body">
   * The cloned FormattedText only takes its original configuration for this instance.
   * If this instance is cloned and than changed, the clone will not be changed as well; it will
   * remain as it was when it was cloned.
   * </p>
   * @return A new FormattedText that is a copy of this one.
   */
  clone() {
    let a = new FormattedText();
    a._k = this._k;
    a._paragraphs$i._n(this._paragraphs$i);
    a._w();
    return a;
  }
  getFont() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getFont.apply(this, arguments);
      case 1: return this._getFont1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getFont(a) {
    if (a < 0) {
      throw ExcelUtils.x("startIndex", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_NegativeStartIndex"));
    }
    return new FormattedTextFont(this, a, 0);
  }
  /**
   * @hidden
   */
  _getFont1(a, b) {
    if (a < 0) {
      throw ExcelUtils.x("startIndex", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_NegativeStartIndex"));
    }
    if (b < 1) {
      throw ExcelUtils.x("length", b, ExcelUtils.ef("LE_ArgumentOutOfRangeException_LengthMustBePositive"));
    }
    return new FormattedTextFont(this, a, b);
  }
  /**
   * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
   */
  *_getFormattingRuns() {
    let a = this.toString().length;
    let b = null;
    for (let c of fromEnum(this._paragraphs$i)) {
      for (let d of fromEnum(c._getFormattingRuns(this._workbook))) {
        if (b == null) {
          if (d.i != 0) {
            yield this._getFont1(0, d.i);
          }
          b = d;
          continue;
        }
        if ((b.h == false && d.h == false) || b.e().d.c(d.e().d)) {
          continue;
        }
        let e = b.i;
        let f = d.i - e;
        yield this._getFont1(e, f);
        b = d;
      }
    }
    if (b != null) {
      let g = b.i;
      yield this._getFont1(b.i, a - g);
    }
  }
  getFormattingRuns() {
    return toEnum(() => this._getFormattingRuns());
  }
  /**
   * @hidden
   */
  _w() {
    this._t = null;
  }
  /**
   * @hidden
   */
  _onFormattingChanged() {
    if (this._owner != null) {
      this._owner.onFormattingChanged(this);
    }
  }
  /**
   * @hidden
   */
  _y(a, b, c) {
    let d = this._f.indexOf(a);
    if (d < 0) {
      return;
    }
    let e = c - b;
    for (let f = d + 1; f < this._f.count; f++) {
      this._f.item(f).startIndex += e;
    }
    this._w();
    if (this._h != null) {
      this._h.onUnformattedStringChanged(this);
    }
  }
  /**
   * @hidden
   */
  _aa(a) {
    let b = null;
    if (a != null) {
      b = a.workbook;
    }
    let c = b == null ? null : b._bj;
    let d = b == null ? null : b._av;
    for (let e of fromEnum(this._paragraphs$i)) {
      for (let f of fromEnum(e._getFormattingRuns(b))) {
        if (f.h) {
          f.f(b).h(d);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ac(a) {
    if (this._h != null && this._h != a) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FormattedTextAlreadyOwned"));
    }
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e, f) {
    ChangeInfo.f(a, b, new ChangeInfo$2(FormattedText.$, $tValue, c, 42, d, e, f, true, 8192, true, null, null));
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(1);
    FormattedText._z(VerticalTextAlignment_$type, a, 0, "VerticalAlignment", (b) => b.verticalAlignment, (b, c) => b.verticalAlignment = c, (b, c) => b._ab(c));
    return a;
  }
  paragraphs() {
    if (arguments.length !== 0) {
      let a = this._paragraphs$i;
      return a.item.apply(a, arguments);
    }
    return this._paragraphs$i;
  }
  /**
   * @hidden
   */
  get _paragraphs$i() {
    return this._f;
  }
  /**
   * Gets or sets the vertical alignment of the formatted text in the owning shape.
   * @throws [[InvalidEnumArgumentException]] The specified value is not defined in the [[VerticalTextAlignment]] enumeration.
   */
  get verticalAlignment() {
    return this._k;
  }
  /**
   * Gets or sets the vertical alignment of the formatted text in the owning shape.
   * @throws [[InvalidEnumArgumentException]] The specified value is not defined in the [[VerticalTextAlignment]] enumeration.
   */
  set verticalAlignment(a) {
    if (this.verticalAlignment == a) {
      return;
    }
    if (EnumUtil.isDefined(VerticalTextAlignment_$type, enumGetBox(VerticalTextAlignment_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, VerticalTextAlignment_$type);
    }
    FormattedText._a[0].h(FormattedText.$, VerticalTextAlignment_$type, this, a);
  }
  /**
   * @hidden
   */
  _ab(a) {
    this._k = a;
    this._onFormattingChanged();
  }
  /**
   * @hidden
   */
  get _owner() {
    return this._h;
  }
  /**
   * @hidden
   */
  set _owner(a) {
    if (this._h == a) {
      return;
    }
    this._h = a;
    let b = this._h == null ? null : this._h.sheet;
    this._aa(b);
  }
  /**
   * @hidden
   */
  get _o() {
    return this._n;
  }
  /**
   * @hidden
   */
  set _o(a) {
    this._n = a;
  }
  /**
   * @hidden
   */
  get _sheet() {
    if (this._h == null) {
      return null;
    }
    return this._h.sheet;
  }
  /**
   * @hidden
   */
  get _workbook() {
    if (this._h == null) {
      return null;
    }
    let a = this._h.sheet;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
}
FormattedText.$t = markType(FormattedText, 'FormattedText', Base.$, [IFormattedItem_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
FormattedText._u = "\n";
/**
 * @hidden
 */
FormattedText._r = 0;
/**
 * @hidden
 */
FormattedText._q = 1;
/**
 * @hidden
 */
FormattedText._a = FormattedText._b();
/**
 * Controls the formatting of a range of characters in .
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the , a portion of the string is "selected" by calling either
 *  or .
 * Formatting properties are then set on the returned FormattedTextFont and all characters in the font's
 * selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedTextFont will return the formatting of the first character
 * in font's selection range.
 * </p>
 * @see@see@see */
export class FormattedTextFont extends FormattedFontBase {
  constructor(a, b, c) {
    super(a, b, c);
  }
  /**
   * @hidden
   */
  _ac(a, b, c, d, e) {
    e = null;
    let f = this.formattedText;
    let g = 0;
    for (; g < f._paragraphs$i.count; g++) {
      let h = f._paragraphs$i.item(g);
      let i = this._ab(h, a, b, c, d, e);
      e = i.p5;
      if (e != null && c <= e.i) {
        break;
      }
    }
    return {
      p4: e
    };
  }
  /**
   * @hidden
   */
  get__d() {
    let a = this.formattedText;
    let b = a._workbook;
    let c = null;
    for (let d = a._paragraphs$i.count - 1; d >= 0; d--) {
      let e = a._paragraphs$i.item(d);
      let f = e._getFormattingRuns(b);
      let g = this._e(f, this.startIndex);
      if (g != null) {
        if (e.startIndex + e.unformattedString.length <= this.startIndex && c != null && c.count != 0) {
          return c._inner[0];
        }
        return g;
      }
      c = f;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  get__sheet() {
    let a = this.formattedText;
    if (a != null) {
      return a._sheet;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _sheet() {
    return this.get__sheet();
  }
  /**
   * @hidden
   */
  get__workbook() {
    let a = this.formattedText;
    if (a != null) {
      return a._workbook;
    }
    return null;
  }
  /**
   * @hidden
   */
  get _workbook() {
    return this.get__workbook();
  }
  /**
   * Gets the  which is controlled by this font.
   * The FormattedText which is controlled by this font.
   */
  get formattedText() {
    return this._g;
  }
}
FormattedTextFont.$t = markType(FormattedTextFont, 'FormattedTextFont', FormattedFontBase.$);
/**
 * Represents a paragraph in .
 * @see */
export class FormattedTextParagraph extends Base {
  constructor(a, b, c, d) {
    super();
    this._f = 4;
    this._r = null;
    this._j = null;
    this._c = null;
    this._p = 0;
    this._t = null;
    if (c == null) {
      c = stringEmpty();
    }
    this._c = a;
    this.startIndex = b;
    this._t = c;
    this._r = d != null ? d : "\n";
    this._j = new List$1(FormattingRunBase.$, 0);
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._sheet;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  addRun(run) {
    let a = typeCast(FormattedTextRun.$, run);
    if (a == null) {
      return;
    }
    this._j.add(a);
  }
  /**
   * @hidden
   */
  createRun(absoluteStartIndex) {
    return new FormattedTextRun(this, absoluteStartIndex - this._p);
  }
  /**
   * @hidden
   */
  getFormattingRuns(workbook) {
    return this._getFormattingRuns(workbook);
  }
  /**
   * @hidden
   */
  insertRun(runIndex, run) {
    let a = typeCast(FormattedTextRun.$, run);
    if (a == null) {
      return;
    }
    this._j.insert(runIndex, a);
  }
  /**
   * @hidden
   */
  _u(a) {
    this._v(this._j.count, a);
  }
  /**
   * @hidden
   */
  _e(a) {
    let b = new FormattedTextParagraph(a, this._p, this._t, this._r);
    b._f = this._f;
    for (let c = 0; c < this._j.count; c++) {
      b._j.add(this._j._inner[c].a(this._workbook, b));
    }
    return b;
  }
  /**
   * @hidden
   */
  _getFormattingRuns(a) {
    this._ab(a);
    return this._j;
  }
  /**
   * @hidden
   */
  _v(a, b) {
    this._j.insert(a, b);
    this._ab(null);
  }
  /**
   * @hidden
   */
  _w(a) {
    this._c = a;
  }
  /**
   * @hidden
   */
  _x() {
    this._c = null;
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e, f) {
    ChangeInfo.f(a, b, new ChangeInfo$2(FormattedTextParagraph.$, $tValue, c, 43, d, e, f, true, 8192, true, null, null));
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    FormattedTextParagraph._y(HorizontalTextAlignment_$type, a, 0, "Alignment", (b) => b.alignment, (b, c) => b.alignment = c, (b, c) => b._z(c));
    FormattedTextParagraph._y(String_$type, a, 1, "UnformattedString", (b) => b.unformattedString, (b, c) => b.unformattedString = c, (b, c) => b._aa(c));
    return a;
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a == null) {
      a = this._workbook;
    }
    if (this._j.count == 0 || this._j._inner[0].i != this._p) {
      this._j.insert(0, new FormattedTextRun(this, 0));
    }
  }
  /**
   * Gets or sets the alignment of the paragraph.
   */
  get alignment() {
    return this._f;
  }
  /**
   * Gets or sets the alignment of the paragraph.
   */
  set alignment(a) {
    if (this._f == a) {
      return;
    }
    if (EnumUtil.isDefined(HorizontalTextAlignment_$type, enumGetBox(HorizontalTextAlignment_$type, a)) == false) {
      throw new InvalidEnumArgumentException("value", a, HorizontalTextAlignment_$type);
    }
    FormattedTextParagraph._a[0].h(FormattedTextParagraph.$, HorizontalTextAlignment_$type, this, a);
  }
  /**
   * @hidden
   */
  _z(a) {
    this._f = a;
    this._c._onFormattingChanged();
  }
  /**
   * Gets the owning  to which the paragraph belongs or null if the
   * paragraph has been removed from its owning formatted text.
   */
  get formattedText() {
    return this._c;
  }
  /**
   * Gets the zero-based index of the paragraph's first character in the overall formatted text.
   */
  get startIndex() {
    if (this._c == null) {
      return 0;
    }
    return this._p;
  }
  /**
   * Gets the zero-based index of the paragraph's first character in the overall formatted text.
   */
  set startIndex(a) {
    this._p = a;
  }
  /**
   * Gets or sets the raw string of the paragraph.
   * <p class="body">
   * If the new unformatted string assigned is shorter than the previous unformatted string, all formatting
   * outside the range of the new value will be lost.
   * </p>
   * The unformatted string.
   * @throws [[ArgumentNullException]] The value assigned is a null string.
   */
  get unformattedString() {
    return this._t;
  }
  /**
   * Gets or sets the raw string of the paragraph.
   * <p class="body">
   * If the new unformatted string assigned is shorter than the previous unformatted string, all formatting
   * outside the range of the new value will be lost.
   * </p>
   * The unformatted string.
   * @throws [[ArgumentNullException]] The value assigned is a null string.
   */
  set unformattedString(a) {
    if (this.unformattedString == a) {
      return;
    }
    if (a == null) {
      throw new ArgumentNullException(2, "unformattedString", ExcelUtils.ef("LE_ArgumentNullException_UnformattedString"));
    }
    FormattedTextParagraph._a[1].h(FormattedTextParagraph.$, String_$type, this, a);
  }
  /**
   * @hidden
   */
  _aa(a) {
    let b = this._n;
    this._t = a;
    ExcelUtils.gd(this);
    if (this._c != null) {
      this._c._y(this, b, this._n);
    }
  }
  /**
   * @hidden
   */
  get _s() {
    return this._r;
  }
  /**
   * @hidden
   */
  get _n() {
    return this._m(Nullable$1.toNullable(Boolean_$type, null));
  }
  /**
   * @hidden
   */
  _m(a) {
    if (a.hasValue == false) {
      if (this._c != null) {
        let b = this._c._paragraphs$i;
        a = Nullable$1.toNullable(Boolean_$type, (b.item(b.count - 1) == this));
      }
      else {
        a = Nullable$1.toNullable(Boolean_$type, false);
      }
    }
    let c = this._t.length;
    if (a.value == false) {
      c += this._r.length;
    }
    return c;
  }
  /**
   * @hidden
   */
  get _sheet() {
    if (this._c == null) {
      return null;
    }
    return this._c._sheet;
  }
  /**
   * @hidden
   */
  get _workbook() {
    if (this._c == null) {
      return null;
    }
    return this._c._workbook;
  }
}
FormattedTextParagraph.$t = markType(FormattedTextParagraph, 'FormattedTextParagraph', Base.$, [IFormattedRunOwner_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
FormattedTextParagraph._l = 0;
/**
 * @hidden
 */
FormattedTextParagraph._q = 1;
/**
 * @hidden
 */
FormattedTextParagraph._o = 2;
/**
 * @hidden
 */
FormattedTextParagraph._a = FormattedTextParagraph._b();
/**
 * @hidden
 */
export class FormattedTextParagraphCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._d._workbook;
  }
  get sheet() {
    return this.b._d._sheet;
  }
  get source() {
    return this.b._d;
  }
}
FormattedTextParagraphCollection_CollectionChangeContext.$t = markStruct(FormattedTextParagraphCollection_CollectionChangeContext, 'FormattedTextParagraphCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[FormattedTextParagraph]] instances in .
 * @see [[FormattedText.paragraphs]]
 */
export class FormattedTextParagraphCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._d = null;
    this._h = new List$1(FormattedTextParagraph.$, 0);
    this._d = a;
  }
  static staticInit() {
    FormattedTextParagraphCollection._a = FormattedTextParagraphCollection._b();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(FormattedTextParagraph.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new NotSupportedException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotAddParagraphDirectly"));
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._h.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  /**
   * @hidden
   */
  _add1(a) {
    return this.insert(this._h.count, a);
  }
  /**
   * Removes all paragraphs from the formatted text.
   */
  clear() {
    let a = this._h.count > 0 ? this._m(14) : null;
    for (let b = this._h.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._p(a);
  }
  /**
   * Determines whether the specified paragraph exists in the collection.
   * @param paragraph The paragraph to find in the collection.
   * @return True if the paragraph exists in the collection; False otherwise.
   */
  contains(paragraph) {
    return this._h.contains(paragraph);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * Gets the enumerator to iterate over all paragraphs.
   */
  getEnumerator() {
    return this._h.getEnumerator();
  }
  /**
   * Gets the zero-based index of the specified paragraph in the collection.
   * @param paragraph The paragraph to find in the collection.
   * @return The zero-based index of the paragraph in the collection or -1 if the paragraph doesn't exist in the collection.
   */
  indexOf(paragraph) {
    return this._h.indexOf(paragraph);
  }
  /**
   * Inserts a paragraph with the specified text and returns the [[FormattedTextParagraph]]
   * representing the new paragraph.
   * @param index The zero-based index in the collection where the paragraph should be inserted.
   * @param paragraphText The text in the paragraph.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than the number of paragraphs in the collection.
   * @return The FormattedTextParagraph representing the new paragraph.
   */
  insert(index, paragraphText) {
    if (index < 0 || this._h.count < index) {
      throw new ArgumentOutOfRangeException(2, "index", ExcelUtils.ef("LE_ArgumentOutOfRangeException_BadInsertIndex"));
    }
    let a = 0;
    if (0 < index) {
      let b = this._h._inner[index - 1];
      a = b.startIndex + b._m(Nullable$1.toNullable(Boolean_$type, false));
    }
    let c = new FormattedTextParagraph(this._d, a, paragraphText, null);
    this._o(index, c, null);
    return c;
  }
  /**
   * Removes the specified paragraph from the collection.
   * @param paragraph The paragraph to remove from the collection.
   * @return True if the paragraph was in the collection and was removed; False otherwise.
   */
  remove(paragraph) {
    if (paragraph.formattedText != this._d) {
      return false;
    }
    let a = this._h.indexOf(paragraph);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the paragraph at the specified zero-based index in the collection.
   * @param index The zero-based index of the paragraph to remove.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
   */
  removeAt(index) {
    if (index < 0 || this._h.count <= index) {
      throw new ArgumentOutOfRangeException(1, ExcelUtils.ef("LE_ArgumentOutOfRangeException_BadRemoveAtIndex"));
    }
    let a = this._h._inner[index];
    let b = null;
    let c = Nullable$1.toNullable(FormattedTextParagraphCollection_CollectionChangeContext.$, null);
    let d = null;
    let e = this._d._workbook != null && this._d._workbook._cx;
    if (e) {
      b = FormattedTextParagraphCollection._a[1];
      d = b.b(this._d._workbook, this._d._sheet, b.c);
      c = Nullable$1.toNullable(FormattedTextParagraphCollection_CollectionChangeContext.$, new FormattedTextParagraphCollection_CollectionChangeContext(1, this, a, index));
    }
    let f = a._n;
    this._h.removeAt(index);
    a._x();
    for (let g = index; g < this._h.count; g++) {
      this._h._inner[g].startIndex -= f;
    }
    this._d._w();
    if (e) {
      b.e(FormattedTextParagraphCollection_CollectionChangeContext.$, FormattedTextParagraph.$, c.value, a, null);
      if (d != null) {
        b.d(this._d._workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _n(a) {
    for (let b = 0; b < a._h.count; b++) {
      this._h.add(a._h._inner[b]._e(this._d));
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    let d = null;
    let e = Nullable$1.toNullable(FormattedTextParagraphCollection_CollectionChangeContext.$, null);
    let f = null;
    let g = this._d._workbook != null && this._d._workbook._cx;
    if (g) {
      d = FormattedTextParagraphCollection._a[0];
      f = d.b(this._d._workbook, this._d._sheet, d.c);
      e = Nullable$1.toNullable(FormattedTextParagraphCollection_CollectionChangeContext.$, new FormattedTextParagraphCollection_CollectionChangeContext(1, this, b, a));
    }
    if (0 < a) {
      b.alignment = this._h._inner[a - 1].alignment;
    }
    else if (a < this._h.count) {
      b.alignment = this._h._inner[a].alignment;
    }
    let h = b._m(Nullable$1.toNullable(Boolean_$type, a == this._h.count));
    for (let i = a; i < this._h.count; i++) {
      this._h._inner[i].startIndex += h;
    }
    this._h.insert(a, b);
    this._d._w();
    if (g) {
      d.e(FormattedTextParagraphCollection_CollectionChangeContext.$, FormattedTextParagraph.$, e.value, null, b);
      if (f != null) {
        d.d(this._d._workbook, f);
      }
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(FormattedTextParagraphCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, FormattedTextParagraphCollection._c(FormattedTextParagraph.$, "Add", 44, (b) => b.a, (b, c) => FormattedTextParagraphCollection._r(b, c)));
    ChangeInfo.f(a, 1, FormattedTextParagraphCollection._c(FormattedTextParagraph.$, "Remove", 45, (b) => b.a, (b, c) => FormattedTextParagraphCollection._s(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _m(a) {
    let b = this._d._workbook;
    return b != null && b._cx ? b._go(this._d._sheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _p(a) {
    if (a != null) {
      let b = this._d._workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    let c = a.b._h.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _s(a, b) {
    a.a._w(a.b._d);
    a.b._o(a.c, a.a, null);
  }
  /**
   * Gets the number of paragraphs in the collection.
   */
  get count() {
    return this._h.count;
  }
  /**
   * Gets the paragraph at the specified zero-based index.
   * @param index The zero-based index of the paragraph to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
   * @return The [[FormattedTextParagraph]] representing the paragraph at the specified index.
   */
  item(a) {
    return this._h._inner[a];
  }
}
FormattedTextParagraphCollection.$t = markType(FormattedTextParagraphCollection, 'FormattedTextParagraphCollection', Base.$, [ICollection$1_$type.specialize(FormattedTextParagraph.$)]);
/**
 * @hidden
 */
FormattedTextParagraphCollection._i = 0;
/**
 * @hidden
 */
FormattedTextParagraphCollection._l = 1;
/**
 * @hidden
 */
FormattedTextParagraphCollection._k = 2;
/**
 * @hidden
 */
FormattedTextParagraphCollection._a = null;
/**
 * @hidden
 */
export class FormattedTextRun extends FormattingRunBase {
  constructor(a, b) {
    super(a, b);
    this.q = null;
    this.n = null;
  }
  d(a) {
    return this.f(a);
  }
  f(a) {
    return ((() => { let b = this.g(a, this.q); this.q = b.p1; return b.ret; })());
  }
  get_h() {
    return this.q != null;
  }
  get h() {
    return this.get_h();
  }
  m(a, b) {
    let c = a;
    if (this.n != null) {
      c.n = this.n.cloneShallow();
    }
    super.m(a, b);
  }
  get_i() {
    return this.p.startIndex + this.k;
  }
  set_i(a) {
    let b = a - this.p.startIndex;
    if (b <= 0) {
      return;
    }
    this.k = b;
  }
  get i() {
    return this.get_i();
  }
  set i(a) {
    this.set_i(a);
  }
  get p() {
    return this.c;
  }
  get o() {
    return this.n;
  }
  set o(a) {
    this.n = a;
  }
}
FormattedTextRun.$t = markType(FormattedTextRun, 'FormattedTextRun', FormattingRunBase.$);
/**
 * @hidden
 */
export let IRegionBlockingValue_$type = new Type(null, 'IRegionBlockingValue');
/**
 * @hidden
 */
export class ArrayFormula_FormulaChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = null;
    this.d = new WorksheetRegionAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.d = d._h;
          this.b = d.worksheet;
        }
        break;
    }
  }
  c() {
    return new WorksheetRegion(this.b, this.d._ac, this.d._w, this.d._ae, this.d._x);
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b;
  }
  get source() {
    return this.a;
  }
}
ArrayFormula_FormulaChangeContext.$t = markStruct(ArrayFormula_FormulaChangeContext, 'ArrayFormula_FormulaChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents an array formula for a group of cells.
 * <p class="body">
 * Array formulas are similar to regular formula in that they have the same grammar. However, array formulas must be set
 * on a single region of cells only. When the array formula is applied to a region of cells, each cell's
 * <see cref="WorksheetCell.Formula">Formula</see> property will be the array formula. The
 * <see cref="WorksheetCell.Formula">Value</see> of each cell cannot be changed unless [[clearCellRange]] is
 * called on the array formula or another value is applied to a region of cells which completely contains the array
 * formula's region.
 * </p>
 * <p class="body">
 * Because the array formula stores the region of the cells to which it is applied in the [[cellRange]] property,
 * the array formula can only be applied to one region of cells.
 * </p>
 * <p class="body">
 * Array formulas are created through Microsoft Excel by selecting a region of cells, entering a formula for
 * that range, and pressing Ctrl+Shift+Enter. This causes the formula of each cell in the region to appear as follows:
 * {=Formula}.
 * </p>
 * <p class="body">
 * See the Microsoft Excel documentation for more information on array formulas.
 * </p>
 */
export class ArrayFormula extends Formula {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c, 1);
          this._ck = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(3, c, false);
          this._ck = null;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _bp(a, b, c = 0) {
    this._applyTo3(new WorksheetRegion(a.worksheet, a.index, b, a.index, b));
  }
  /**
   * @hidden
   */
  _bm(a, b, c, d = 0) {
    if (a == null) {
      throw new ArgumentNullException(0, "regions");
    }
    if (a.length != 1) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ArrayFormulaMustHaveSingleRegion"), "regions");
    }
    if (this._ck != null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ArrayFormulaAlreadyApplied"));
    }
    let e = a[0];
    this._cy(e);
  }
  /**
   * @hidden
   */
  _br(a, b, c) {
    this._cy(a.worksheet._cx(a.index, b, a.index, b));
  }
  /**
   * @hidden
   */
  _g() {
    return new ArrayFormula(1, this);
  }
  /**
   * @hidden
   */
  get__z() {
    if (this._ck != null && this._ck.worksheet != null) {
      return this._ck.worksheet._o;
    }
    return super.get__z();
  }
  /**
   * @hidden
   */
  set__z(a) {
    super.set__z(a);
  }
  /**
   * @hidden
   */
  get__ap() {
    return false;
  }
  /**
   * @hidden
   */
  get__bb() {
    return this._ck != null ? this._ck._v : -1;
  }
  /**
   * @hidden
   */
  get _bb() {
    return this.get__bb();
  }
  /**
   * @hidden
   */
  get__ab() {
    return this._ck != null ? this._ck._k : null;
  }
  /**
   * @hidden
   */
  get _ab() {
    return this.get__ab();
  }
  /**
   * @hidden
   */
  get__aa() {
    return this._ck != null ? new WorksheetCellAddress(1, this._ck.firstRow, this._ck._v) : WorksheetCellAddress.b;
  }
  /**
   * @hidden
   */
  get _aa() {
    return this.get__aa();
  }
  /**
   * @hidden
   */
  _b7() {
  }
  /**
   * @hidden
   */
  get__t() {
    return this._ck != null ? this._ck.worksheet : null;
  }
  /**
   * @hidden
   */
  get _t() {
    return this.get__t();
  }
  /**
   * @hidden
   */
  removeFromRegion() {
    this.clearCellRange();
  }
  /**
   * @hidden
   */
  throwBlockingException() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantChangeArrayFormula"));
  }
  /**
   * @hidden
   */
  throwExceptionWhenMergedCellsInRegion() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ArrayFormulaInMergedCell"));
  }
  /**
   * @hidden
   */
  throwExceptionWhenTableInRegion() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ArrayFormulaAppliedInTable"));
  }
  /**
   * @hidden
   */
  get blockedRegion() {
    return this._ck;
  }
  /**
   * Removes this array formula as the formula for the cells to which it was applied.
   * <p class="body">
   * After this method returns, the [[cellRange]] will be null.
   * </p>
   */
  clearCellRange() {
    if (this._ck == null) {
      return;
    }
    let a = this._t;
    let b = ArrayFormula._cc[1];
    let c = this._ck;
    let d = new ArrayFormula_FormulaChangeContext(1, this, c);
    let e = a != null ? a.workbook : null;
    let f = null;
    let g = false;
    if (e != null) {
      f = b.b(e, a, b.c);
      g = e._df;
      e._df = true;
    }
    if (a != null) {
      for (let h = this._ck.lastRow; h >= this._ck.firstRow; h--) {
        let i = a._rows$i.item(h);
        for (let j = this._ck._w; j >= this._ck._v; j--) {
          i._d6(j, null, false);
        }
      }
    }
    this._ck = null;
    if (e != null) {
      e._df = g;
    }
    b.e(ArrayFormula_FormulaChangeContext.$, WorksheetRegion.$, d, c, null);
    if (f != null) {
      b.d(e, f);
    }
  }
  /**
   * @hidden
   */
  static _ci(a, b) {
    let c;
    let d;
    let e;
    let f = Workbook._hl(b, c, d, e);
    c = f.p1;
    d = f.p2;
    e = f.p3;
    return ArrayFormula._parse9(a, c, d, e);
  }
  static parse() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      if (typeof arguments[2] === 'string' || typeCast(CultureInfo.$, arguments[2]) !== null) {
        n = 3;
      }
      else if (typeof arguments[2] === 'number') {
        n = 1;
      }
      else if (arguments[2] == null) {
        n = 3;
      }
    }
    else if (arguments.length === 4) {
      n = 2;
    }
    switch (n) {
      case 0: return ArrayFormula._parse7.apply(null, arguments);
      case 1: return ArrayFormula._parse8.apply(null, arguments);
      case 2:
        arguments[3] = typeof arguments[3] === 'string' ? new CultureInfo(arguments[3]) : arguments[3];
        return ArrayFormula._parse9.apply(null, arguments);
      case 3:
        arguments[2] = typeof arguments[2] === 'string' ? new CultureInfo(arguments[2]) : arguments[2];
        return ArrayFormula._parse10.apply(null, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _parse7(a, b) {
    return ArrayFormula._parse10(a, b, ExcelUtils.cq);
  }
  /**
   * @hidden
   */
  static _parse10(a, b, c) {
    return ArrayFormula._parse9(a, b, 2, c);
  }
  /**
   * @hidden
   */
  static _parse8(a, b, c) {
    return ArrayFormula._parse9(a, b, c, ExcelUtils.cq);
  }
  /**
   * @hidden
   */
  static _parse9(a, b, c, d) {
    let e;
    let f;
    if (((() => { let g = ArrayFormula._cs(a, b, c, d, e, f); e = g.p4; f = g.p5; return g.ret; })())) {
      return e;
    }
    throw f;
  }
  /**
   * @hidden
   */
  static _cn(a, b, c) {
    return {
      ret: ((() => { let d = ArrayFormula._ct(a, b, ExcelUtils.cq, c); c = d.p3; return d.ret; })()),
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _ct(a, b, c, d) {
    return {
      ret: ((() => { let e = ArrayFormula._cr(a, b, 2, c, d); d = e.p4; return e.ret; })()),
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _co(a, b, c, d) {
    return {
      ret: ((() => { let e = ArrayFormula._cu(a, b, ExcelUtils.cq, c, d); c = e.p3; d = e.p4; return e.ret; })()),
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _cu(a, b, c, d, e) {
    return {
      ret: ((() => { let f = ArrayFormula._cs(a, b, 2, c, d, e); d = f.p4; e = f.p5; return f.ret; })()),
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _cp(a, b, c, d) {
    return {
      ret: ((() => { let e = ArrayFormula._cr(a, b, c, ExcelUtils.cq, d); d = e.p4; return e.ret; })()),
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _cr(a, b, c, d, e) {
    let f;
    return {
      ret: ((() => { let g = ArrayFormula._cs(a, b, c, d, e, f); e = g.p4; f = g.p5; return g.ret; })()),
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _cq(a, b, c, d, e) {
    return {
      ret: ((() => { let f = ArrayFormula._cs(a, b, c, ExcelUtils.cq, d, e); d = f.p4; e = f.p5; return f.ret; })()),
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  static _cs(a, b, c, d, e, f) {
    let g;
    let h = ((() => { let i = Formula._a0(a, b, 1, c, d, null, g, f); g = i.p6; f = i.p7; return i.ret; })());
    let i = typeCast(ArrayFormula.$, g);
    e = i;
    return {
      ret: h,
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  _c0(a, b, c) {
    if (c != null) {
      c.c(a, this);
    }
  }
  /**
   * @hidden
   */
  _cm(a, b, c) {
    c = null;
    if (this._ck == null || this._ck.worksheet == null) {
      return {
        ret: false,
        p2: c
      };
    }
    if (WorksheetRegionAddress._r(b, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && this._ck.firstColumn >= b.value._w && this._ck.firstRow >= b.value._ac && this._ck.lastColumn <= b.value._x && this._ck.lastRow <= b.value._ae) {
      let d = this._t.workbook;
      let e = d._df;
      d._df = false;
      this.clearCellRange();
      d._df = e;
      return {
        ret: true,
        p2: c
      };
    }
    if (this._ck != null && this._ck.worksheet != null) {
      c = new ShiftingArrayFormulaInfo(this);
      this.clearCellRange();
    }
    return {
      ret: false,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _cy(a) {
    let b = a.worksheet;
    if (b == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionsShiftedOffWorksheet"), "regions");
    }
    let c = this._ck;
    let d = ArrayFormula._cc[0];
    let e = new ArrayFormula_FormulaChangeContext(1, this, a);
    let f = b != null ? b.workbook : null;
    let g = null;
    if (f != null) {
      g = d.b(f, b, d.c);
    }
    try {
      WorksheetCellBlock.az(this, a, a);
      b._jc(this, a._k, a._v);
      this._ck = a;
      for (let h = a.lastRow; h >= a.firstRow; h--) {
        let i = b._rows$i.item(h);
        for (let j = a._w; j >= a._v; j--) {
          i._d6(j, new ArrayInteriorFormula(this), false);
        }
      }
    }
    finally {
      d.e(ArrayFormula_FormulaChangeContext.$, WorksheetRegion.$, e, c, a);
      if (g != null) {
        d.d(f, g);
      }
    }
  }
  /**
   * @hidden
   */
  static _cj($tValue, a, b, c, d, e, f, g = true, h = true) {
    return new ChangeInfo$2(ArrayFormula_FormulaChangeContext.$, $tValue, a, b, c, d, e, g, f, h, null, null);
  }
  /**
   * @hidden
   */
  static _cd() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, ArrayFormula._cj(WorksheetRegion.$, "Apply", 0, (b) => b.c(), (b, c) => ArrayFormula._c1(b, c), null, 8192));
    ChangeInfo.f(a, 1, ArrayFormula._cj(WorksheetRegion.$, "Clear", 10, (b) => b.c(), (b, c) => ArrayFormula._c2(b, c), null, 8192));
    return a;
  }
  /**
   * @hidden
   */
  static _c1(a, b) {
    a.a.clearCellRange();
  }
  /**
   * @hidden
   */
  static _c2(a, b) {
    a.a._cy(b);
  }
  /**
   * Gets the cells to which the array formula is applied.
   * <p class="body">
   * If this is null, the formula has not yet been applied.
   * </p>
   * The cells to which the array formula is applied.
   */
  get cellRange() {
    return this._ck;
  }
}
ArrayFormula.$t = markType(ArrayFormula, 'ArrayFormula', Formula.$, [IRegionBlockingValue_$type]);
/**
 * @hidden
 */
ArrayFormula._cv = 0;
/**
 * @hidden
 */
ArrayFormula._cw = 1;
/**
 * @hidden
 */
ArrayFormula._cx = 2;
/**
 * @hidden
 */
ArrayFormula._cc = ArrayFormula._cd();
/**
 * @hidden
 */
export class ShiftingArrayFormulaInfo extends Base {
  constructor(a) {
    super();
    this.b = null;
    this.a = null;
    this.a = a.cellRange;
    let b = a._y;
    if (b != null && b.calculationMode == 0) {
      this.b = new Dictionary$2(WorksheetCellAddress.$, ExcelCalcValue.$, 0);
      for (let c of fromEnum(this.a)) {
        this.b.addItem(c._e, c._o._as(c._ab).value);
      }
    }
  }
  c(a, b) {
    b._applyTo3(this.a);
    if (this.b != null) {
      for (let c of fromEnum(this.b)) {
        let d = c.key;
        let e = ((() => { let f = a.c(d); d = f.p0; return f.ret; })());
        let f = this.a.worksheet._rows$i.item(d.o);
        let g = f._as(d.m)._formula;
        if (g != null) {
          g._cd = c.value;
        }
        else {
        }
      }
    }
  }
}
ShiftingArrayFormulaInfo.$t = markType(ShiftingArrayFormulaInfo, 'ShiftingArrayFormulaInfo');
/**
 * @hidden
 */
export class FormulaTokenVisitor extends Base {
  constructor() {
    super();
    this.a = null;
    this.c = 0;
  }
  e(a) {
  }
  g() {
    this.a = null;
    this.c = 0;
  }
  f() {
  }
  h() {
    let a = this.b.d._e;
    let b = a.length;
    for (let c = 0; c < b; c++) {
      this.c = c;
      a[c].m(this);
      c = this.c;
    }
    this.f();
    this.g();
  }
  i(a) {
    this.m(a);
  }
  j(a) {
    this.n(a);
  }
  k(a) {
    this.j(a);
  }
  l(a) {
    this.x(a);
  }
  m(a) {
    this.n(a);
  }
  n(a) {
    this.x(a);
  }
  o(a) {
    this.am(a);
  }
  p(a) {
    this.e(a);
  }
  q(a) {
    this.e(a);
  }
  r(a) {
    this.e(a);
  }
  s(a) {
    this.e(a);
  }
  t(a) {
    this.ab(a);
  }
  u(a) {
    this.e(a);
  }
  v(a) {
    this.e(a);
  }
  w(a) {
    this.am(a);
  }
  x(a) {
    this.aq(a);
  }
  y(a) {
    this.am(a);
  }
  z(a) {
    this.e(a);
  }
  aa(a) {
    this.ab(a);
  }
  ab(a) {
    this.e(a.formulaToken);
  }
  ac(a) {
    this.aa(a);
  }
  ad(a) {
    this.am(a);
  }
  ae(a) {
    this.e(a);
  }
  af(a) {
    this.e(a);
  }
  ag(a) {
    this.e(a);
  }
  ah(a) {
    this.e(a);
  }
  ai(a) {
    this.am(a);
  }
  aj(a) {
    this.aq(a);
  }
  ak(a) {
    this.aj(a);
  }
  al(a) {
    this.am(a);
  }
  am(a) {
    this.e(a);
  }
  an(a) {
    this.e(a);
  }
  aq(a) {
    this.am(a);
  }
  ao(a) {
    this.at(a);
  }
  ap(a) {
    this.au(a);
  }
  ar(a) {
    this.ap(a);
  }
  as(a) {
    this.x(a);
  }
  at(a) {
    this.au(a);
  }
  au(a) {
    this.x(a);
  }
  av(a) {
    this.am(a);
  }
  aw(a) {
    this.aq(a);
  }
  ax(a) {
    this.e(a);
  }
  ay(a) {
    this.e(a);
  }
  get b() {
    return this.a;
  }
  set b(a) {
    this.a = a;
  }
  get d() {
    return this.c;
  }
  set d(a) {
    this.c = a;
  }
}
FormulaTokenVisitor.$t = markType(FormulaTokenVisitor, 'FormulaTokenVisitor');
/**
 * @hidden
 */
export class Formula_CanShiftSafelyChecker extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a1 = false;
    this.a3 = null;
  }
  g() {
    this.a3 = ExcelUtils.g7;
    super.g();
  }
  n(a) {
    let b = a.x;
    if (a.v == false) {
      b = b.e(this.b, this.a3, false);
    }
    let c = b.k(this.b, a.v, false);
    if (c._w < 0 || c._ac < 0 || this.b.f.maxColumnCount <= c._x || this.b.f.maxRowCount <= c._ae) {
      this.a1 = false;
    }
  }
  au(a) {
    let b = a.y;
    if (a.v == false) {
      b = b.a(this.b, this.a3, false);
    }
    let c = b.e(this.b, a.v, false);
    if (c.m < 0 || c.o < 0 || this.b.f.maxColumnCount <= c.m || this.b.f.maxRowCount <= c.o) {
      this.a1 = false;
    }
  }
  static a2(a, b) {
    let c = Formula_CanShiftSafelyChecker.a0(a, b);
    c.h();
    return c.a1;
  }
  static a0(a, b) {
    if (Formula_CanShiftSafelyChecker.az == null) {
      Formula_CanShiftSafelyChecker.az = new Formula_CanShiftSafelyChecker();
    }
    Formula_CanShiftSafelyChecker.az.a3 = b;
    Formula_CanShiftSafelyChecker.az.a1 = true;
    Formula_CanShiftSafelyChecker.az.b = a;
    return Formula_CanShiftSafelyChecker.az;
  }
}
Formula_CanShiftSafelyChecker.$t = markType(Formula_CanShiftSafelyChecker, 'Formula_CanShiftSafelyChecker', FormulaTokenVisitor.$);
Formula_CanShiftSafelyChecker.az = null;
/**
 * @hidden
 */
export class FormulaTokenVisitor$1 extends Base {
  constructor($tResult) {
    super();
    this.$tResult = null;
    this.b = null;
    this.az = 0;
    this.av = false;
    this.$tResult = $tResult;
    this.$type = this.$type.specialize(this.$tResult);
  }
  d(a) {
    return Type.getDefaultValue(this.$tResult);
  }
  a0() {
    this.av = true;
  }
  a1() {
    this.b = null;
    this.av = false;
  }
  ax() {
    let a;
    let b = ((() => { let c = this.ay(a); a = c.p0; return c.ret; })());
    this.a1();
    return b;
  }
  ay(a) {
    a = Nullable$1.toNullable(Number_$type, null);
    let b = this.a;
    let c = b.length;
    for (let d = 0; d < c; d++) {
      this.az = d;
      b[d].d(this.$tResult, this);
      d = this.az;
      if (this.av) {
        a = Nullable$1.toNullable(Number_$type, this.az);
        return {
          ret: false,
          p0: a
        };
      }
    }
    return {
      ret: true,
      p0: a
    };
  }
  e(a) {
    return this.i(a);
  }
  f(a) {
    return this.j(a);
  }
  g(a) {
    return this.f(a);
  }
  h(a) {
    return this.t(a);
  }
  i(a) {
    return this.j(a);
  }
  j(a) {
    return this.t(a);
  }
  k(a) {
    return this.ai(a);
  }
  l(a) {
    return this.d(a);
  }
  m(a) {
    return this.d(a);
  }
  n(a) {
    return this.d(a);
  }
  o(a) {
    return this.d(a);
  }
  p(a) {
    return this.x(a);
  }
  q(a) {
    return this.d(a);
  }
  r(a) {
    return this.d(a);
  }
  s(a) {
    return this.ai(a);
  }
  t(a) {
    return this.am(a);
  }
  u(a) {
    return this.ai(a);
  }
  v(a) {
    return this.d(a);
  }
  w(a) {
    return this.x(a);
  }
  x(a) {
    return this.d(a.formulaToken);
  }
  y(a) {
    return this.w(a);
  }
  z(a) {
    return this.ai(a);
  }
  aa(a) {
    return this.d(a);
  }
  ab(a) {
    return this.d(a);
  }
  ac(a) {
    return this.d(a);
  }
  ad(a) {
    return this.d(a);
  }
  ae(a) {
    return this.ai(a);
  }
  af(a) {
    return this.am(a);
  }
  ag(a) {
    return this.af(a);
  }
  ah(a) {
    return this.ai(a);
  }
  ai(a) {
    return this.d(a);
  }
  aj(a) {
    return this.d(a);
  }
  am(a) {
    return this.ai(a);
  }
  ak(a) {
    return this.ap(a);
  }
  al(a) {
    return this.aq(a);
  }
  an(a) {
    return this.al(a);
  }
  ao(a) {
    return this.t(a);
  }
  ap(a) {
    return this.aq(a);
  }
  aq(a) {
    return this.t(a);
  }
  ar(a) {
    return this.ai(a);
  }
  as(a) {
    return this.am(a);
  }
  at(a) {
    return this.d(a);
  }
  au(a) {
    return this.d(a);
  }
  get c() {
    return this.b;
  }
  set c(a) {
    this.b = a;
  }
  get aw() {
    return this.av;
  }
  get_a() {
    return this.b.d._e;
  }
  get a() {
    return this.get_a();
  }
}
FormulaTokenVisitor$1.$t = markType(FormulaTokenVisitor$1, 'FormulaTokenVisitor$1');
/**
 * @hidden
 */
export class FormulaTokenModifierVisitor extends FormulaTokenVisitor$1 {
  constructor() {
    super(Boolean_$type);
    this.a2 = null;
    this.a4 = false;
    this.a7 = new List$1(FormulaToken.$, 0);
    this.a6 = new List$1(Number_$type, 0);
  }
  a1() {
    this.a7.clear();
    this.a6.clear();
    this.a2 = null;
    super.a1();
  }
  ay(a) {
    this.a7.clear();
    this.a6.clear();
    this.a4 = false;
    a = Nullable$1.toNullable(Number_$type, null);
    let b = this.a;
    let c = b.length;
    for (this.az = 0; this.az < c; this.az++) {
      let d = b[this.az].d(Boolean_$type, this);
      if (d) {
        this.a4 = true;
      }
      if (this.a2 != null) {
        this.a7.add(b[this.az]);
        this.a6.add(this.az);
        this.a4 = true;
        b[this.az] = this.a2;
        this.a2 = null;
      }
      if (this.aw) {
        a = Nullable$1.toNullable(Number_$type, this.az);
        return {
          ret: false,
          p0: a
        };
      }
    }
    if (this.a4 && this.a7.count != 0) {
      this.c.d._b2(this.a7.toArray(), this.a6.toArray());
      this.a7.clear();
      this.a6.clear();
    }
    return {
      ret: true,
      p0: a
    };
  }
  get a3() {
    return this.a2;
  }
  set a3(a) {
    this.a2 = a;
  }
  get a5() {
    return this.a4;
  }
}
FormulaTokenModifierVisitor.$t = markType(FormulaTokenModifierVisitor, 'FormulaTokenModifierVisitor', FormulaTokenVisitor$1.$.specialize(Boolean_$type));
/**
 * @hidden
 */
export class Formula_ConnectReferencesVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.ba = false;
  }
  a1() {
    super.a1();
  }
  f(a) {
    return this.bd(a);
  }
  j(a) {
    return this.bd(a);
  }
  t(a) {
    return this.bd(a);
  }
  af(a) {
    if (this.ba) {
      return Formula_ConnectReferencesVisitor.bb(this.c, a);
    }
    else {
      if (a.u._t == false) {
        return false;
      }
      let b = a.u;
      a.u = new NamedReferenceUnconnected(0, b.name, b._l, b._g, true);
      return true;
    }
  }
  ag(a) {
    if (this.ba) {
      return Formula_ConnectReferencesVisitor.bc(this.c, a);
    }
    else {
      if (a.u._t == false) {
        return false;
      }
      let b = a.u;
      a.o = a.o.h();
      a.u = new NamedReferenceUnconnected(0, b.name, b._l, b._g, true);
      return true;
    }
  }
  al(a) {
    return this.bd(a);
  }
  aq(a) {
    return this.bd(a);
  }
  as(a) {
    let b = a.y;
    let c = a.w;
    if (this.ba) {
      a.y = b.d(this.c);
      let d = a.z(this.c);
      if (d != null) {
        a.w = d;
      }
    }
    else {
      a.y = b.e();
      a.w = new NamedReferenceUnconnected(1, c.name, a.y, false, c._l, true);
    }
    return c != a.w || b != a.y;
  }
  static bb(a, b) {
    let c = b.u;
    let d = c.name;
    if (d == null) {
      return false;
    }
    let e = null;
    switch (c._g) {
      case 0:
        {
          if (a.j != null) {
            e = a.f._a2(d, a.j);
          }
          if (e == null && a.f != null) {
            e = a.f._a2(d, null);
          }
        }
        break;
      case 1:
        {
          if (a.f == null) {
            return false;
          }
          let f = a.f._a9;
          e = f.c(d, f, true);
        }
        break;
      default: break;
    }
    if (e != null) {
      b.u = e;
    }
    return c != b.u;
  }
  static bc(a, b) {
    let c = b.u;
    b.o = b.o.f(a);
    switch (c._g) {
      case 0:
      case 2:
        {
          let d = b.o.c(b.w);
          if (d != null) {
            b.u = d;
          }
        }
        break;
      case 1:
        {
          if (a.f == null) {
            return false;
          }
          let e = a.f._a9;
          b.u = e.c(c.name, e, true);
        }
        break;
      default: break;
    }
    return c != b.u;
  }
  static a9(a, b) {
    if (Formula_ConnectReferencesVisitor.a8 == null) {
      Formula_ConnectReferencesVisitor.a8 = new Formula_ConnectReferencesVisitor();
    }
    let c = Formula_ConnectReferencesVisitor.a8;
    if (c.c != null) {
      c = new Formula_ConnectReferencesVisitor();
    }
    c.c = a;
    c.ba = b;
    return c;
  }
  bd(a) {
    let b = a.o;
    if (b != null) {
      if (this.ba) {
        a.o = b.f(this.c);
      }
      else {
        a.o = b.h();
      }
    }
    return b != a.o;
  }
}
Formula_ConnectReferencesVisitor.$t = markType(Formula_ConnectReferencesVisitor, 'Formula_ConnectReferencesVisitor', FormulaTokenModifierVisitor.$);
Formula_ConnectReferencesVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_ConvertTableReferencesToRangesVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.ba = null;
  }
  a1() {
    this.ba = null;
    super.a1();
  }
  af(a) {
    if ((a.v == null || a.v == this.c.f) && a.u == this.ba) {
      let b = this.ba.dataAreaRegion;
      if (b != null) {
        this.a3 = new Area3DToken(2, this.ba._k._bb.g(this.ba.worksheet.name, null), new CellAddressRange(2, b), a.h);
        return true;
      }
    }
    return false;
  }
  as(a) {
    if (this.c.f != null && a.y == this.c.f._bb && this.ba == a.w) {
      let b = typeCast(TableCalcReferenceBase.$, a.n(this.c));
      if (b != null) {
        let c = b._a3;
        if (c != null) {
          this.a3 = new Area3DToken(2, a.y.g(this.ba.worksheet.name, null), new CellAddressRange(2, c), a.h);
          return true;
        }
      }
    }
    return false;
  }
  static a9(a, b) {
    if (Formula_ConvertTableReferencesToRangesVisitor.a8 == null) {
      Formula_ConvertTableReferencesToRangesVisitor.a8 = new Formula_ConvertTableReferencesToRangesVisitor();
    }
    Formula_ConvertTableReferencesToRangesVisitor.a8.ba = b;
    Formula_ConvertTableReferencesToRangesVisitor.a8.c = a;
    return Formula_ConvertTableReferencesToRangesVisitor.a8;
  }
}
Formula_ConvertTableReferencesToRangesVisitor.$t = markType(Formula_ConvertTableReferencesToRangesVisitor, 'Formula_ConvertTableReferencesToRangesVisitor', FormulaTokenModifierVisitor.$);
Formula_ConvertTableReferencesToRangesVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_AllReferencedRegionsChecker extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a3 = new List$1(WorksheetRegionAddress.$, 0);
    this.a2 = null;
  }
  g() {
    this.a2 = null;
    super.g();
  }
  x(a) {
    let b = typeCast(RefBase.$, a.n(this.b));
    if (b != null) {
      let c = b._am();
      if (c != null) {
        for (let d of fromEnum(c)) {
          if (d.worksheet == this.a2) {
            this.a3.add(d._h);
          }
        }
      }
    }
  }
  static az(a, b) {
    let c = Formula_AllReferencedRegionsChecker.a1(a, b);
    c.h();
    return c.a3.toArray();
  }
  static a1(a, b) {
    if (Formula_AllReferencedRegionsChecker.a0 == null) {
      Formula_AllReferencedRegionsChecker.a0 = new Formula_AllReferencedRegionsChecker();
    }
    Formula_AllReferencedRegionsChecker.a0.b = a;
    Formula_AllReferencedRegionsChecker.a0.a2 = b;
    Formula_AllReferencedRegionsChecker.a0.a3.clear();
    return Formula_AllReferencedRegionsChecker.a0;
  }
}
Formula_AllReferencedRegionsChecker.$t = markType(Formula_AllReferencedRegionsChecker, 'Formula_AllReferencedRegionsChecker', FormulaTokenVisitor.$);
Formula_AllReferencedRegionsChecker.a0 = null;
/**
 * @hidden
 */
export class Formula_FixPasteReferencesVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.bc = null;
    this.bf = null;
    this.bb = null;
    this.be = null;
    this.bd = null;
    this.a8 = null;
    this.bg = Nullable$1.toNullable(Boolean_$type, null);
    this.bd = (a) => {
      if (this.a8 == null) {
        this.a8 = new Formula_FixPasteReferencesVisitor();
      }
      let b = new FormulaContext(3, this.c.f, this.c.j, null, -1, a);
      this.a8.bb = this.bb;
      this.a8.bc = this.bc;
      this.a8.bg = Nullable$1.toNullable(Boolean_$type, null);
      this.a8.bf = this.bf;
      this.a8.be = this.be;
      this.a8.c = b;
      a._au(this.a8);
    };
  }
  a1() {
    this.bc = null;
    this.bf = null;
    this.be = null;
    this.bb = null;
    super.a1();
  }
  f(a) {
    if (this.c.d._s == 3) {
      if (a.o != null && this.c.j != null && !a.o.j && typeCast(WorksheetReferenceLocal.$, a.o) !== null && a.o.u == this.bc) {
        let b = this.c.f._bb.j(this.c.j.name);
        this.a3 = new Area3DToken(2, b, a.x, a.h);
        return true;
      }
    }
    return super.f(a);
  }
  t(a) {
    if (!a.r && a.o != null) {
      let b = a.o.h();
      if (this.bb != null) {
        a.o = b.g(this.bb);
      }
      else {
        a.o = b.f(this.c);
      }
    }
    return super.t(a);
  }
  af(a) {
    if (!a.r) {
      let b = this.be(a.u, this.bd);
      if (b != null) {
        let c = new NameToken(1, b.name, this.c, a.u._g, true);
        c.u = b;
        this.a3 = c;
        return true;
      }
      else if (this.bb != null) {
        this.bh(a);
      }
      else if (a.u._t) {
        let d = a.w;
        if (this.bf != null && typeCast(WorksheetTable.$, a.u) !== null) {
          let e = this.bf(a.w);
          if (!stringIsNullOrEmpty(e)) {
            d = e;
          }
        }
        this.a3 = new NameToken(1, d, this.c, a.u._g, true);
        return true;
      }
    }
    return super.af(a);
  }
  ag(a) {
    if (!a.r) {
      let b = this.be(a.u, this.bd);
      if (b != null) {
        let c = b.name;
        let d = typeCast(Worksheet.$, b.scope) !== null ? b.scope.name : null;
        this.a3 = new NameXToken(1, null, d, c, this.c, a.u._g, true);
        return true;
      }
      else if (this.bb != null) {
        this.bh(a);
      }
      else if (a.u._t) {
        let e = a.w;
        let f = a.o != null ? a.o.p : null;
        if (this.bf != null && typeCast(WorksheetTable.$, a.u) !== null) {
          let g = this.bf(a.w);
          if (!stringIsNullOrEmpty(g)) {
            e = g;
          }
        }
        this.a3 = new NameXToken(1, null, f, e, this.c, a.u._g, true);
        return true;
      }
    }
    return super.ag(a);
  }
  al(a) {
    if (this.c.d._s == 3) {
      if (a.o != null && this.c.j != null && !a.o.j && typeCast(WorksheetReferenceLocal.$, a.o) !== null && a.o.u == this.bc) {
        let b = this.c.f._bb.j(this.c.j.name);
        this.a3 = new Ref3DToken(2, b, a.y, a.h);
        return true;
      }
    }
    return super.al(a);
  }
  as(a) {
    if (!a.r) {
      let b = null;
      if (this.bf != null && a.ah != null) {
        b = this.bf(a.ah);
      }
      if (this.bb != null && stringIsNullOrEmpty(b) && a.ah != null) {
        let c = a.ah;
        a = new StructuredTableReference(4, a);
        a.w = new NamedReferenceUnconnected(1, c, this.bb, false, this.c.h, true);
        a.y = this.bb;
        this.a3 = a;
        return true;
      }
      else {
        a = new StructuredTableReference(4, a);
        a.y = this.c.f._bb;
        if (!stringIsNullOrEmpty(b) && b != a.ah) {
          a.w = new NamedReferenceUnconnected(1, b, a.y, false, this.c.h, true);
        }
        let d = a.z(this.c);
        let e = false;
        if (d == null) {
          if (a.ah != null || !this.bg.hasValue || !this.bg.value) {
            e = true;
          }
        }
        else {
          let f = true;
          if (a.ag != null) {
            f = (d._columns$i._item1(a.ag) != null);
          }
          else if (a.u != null) {
            let g = a.u.p;
            let h = a.u.q;
            f = (g == null || d._columns$i._item1(g) != null) && (h == null || d._columns$i._item1(h) != null);
          }
          if (!f) {
            e = true;
          }
        }
        if (e) {
          this.a3 = new ErrToken(1, ErrorValue.invalidCellReference);
          return true;
        }
        else {
          if (d != null) {
            a.w = d;
          }
          this.a3 = a;
          return true;
        }
      }
    }
    return super.as(a);
  }
  static ba(a, b, c, d, e, f) {
    if (Formula_FixPasteReferencesVisitor.a9 == null) {
      Formula_FixPasteReferencesVisitor.a9 = new Formula_FixPasteReferencesVisitor();
    }
    Formula_FixPasteReferencesVisitor.a9.bc = a;
    Formula_FixPasteReferencesVisitor.a9.bb = b;
    Formula_FixPasteReferencesVisitor.a9.bg = d;
    Formula_FixPasteReferencesVisitor.a9.bf = e;
    Formula_FixPasteReferencesVisitor.a9.be = f;
    Formula_FixPasteReferencesVisitor.a9.c = c;
    return Formula_FixPasteReferencesVisitor.a9;
  }
  bh(a) {
    if (this.bb != null && a.o != null) {
      let b = a.o.h();
      a.o = b.g(this.bb);
    }
  }
}
Formula_FixPasteReferencesVisitor.$t = markType(Formula_FixPasteReferencesVisitor, 'Formula_FixPasteReferencesVisitor', FormulaTokenModifierVisitor.$);
Formula_FixPasteReferencesVisitor.a9 = null;
/**
 * @hidden
 */
export class Formula_IsReferencingAnythingInRegionChecker extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a3 = false;
    this.a2 = new WorksheetRegionAddress();
    this.a1 = null;
  }
  g() {
    this.a1 = null;
    super.g();
  }
  x(a) {
    if (this.a3) {
      return;
    }
    let b = typeCast(RefBase.$, a.n(this.b));
    if (b != null) {
      this.a3 = b._ae(this.a1, this.a2);
    }
  }
  static a4(a, b, c) {
    let d = Formula_IsReferencingAnythingInRegionChecker.a0(a, b, c);
    d.h();
    return d.a3;
  }
  static a0(a, b, c) {
    if (Formula_IsReferencingAnythingInRegionChecker.az == null) {
      Formula_IsReferencingAnythingInRegionChecker.az = new Formula_IsReferencingAnythingInRegionChecker();
    }
    Formula_IsReferencingAnythingInRegionChecker.az.b = a;
    Formula_IsReferencingAnythingInRegionChecker.az.a1 = b;
    Formula_IsReferencingAnythingInRegionChecker.az.a2 = c;
    Formula_IsReferencingAnythingInRegionChecker.az.a3 = false;
    return Formula_IsReferencingAnythingInRegionChecker.az;
  }
}
Formula_IsReferencingAnythingInRegionChecker.$t = markType(Formula_IsReferencingAnythingInRegionChecker, 'Formula_IsReferencingAnythingInRegionChecker', FormulaTokenVisitor.$);
Formula_IsReferencingAnythingInRegionChecker.az = null;
/**
 * @hidden
 */
export class Formula_OffsetReferencesVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.ba = null;
  }
  a1() {
    this.ba = ExcelUtils.g7;
    super.a1();
  }
  j(a) {
    let b;
    if (a.v == false) {
      a.x = a.x.e(this.c, this.ba, false);
      b = true;
    }
    else {
      b = false;
    }
    let c = a.x.k(this.c, a.v, false);
    if (c._w < 0 || c._ac < 0 || this.c.f.maxColumnCount <= c._x || this.c.f.maxRowCount <= c._ae) {
      this.a3 = a.t();
      return true;
    }
    return b;
  }
  v(a) {
    a.p = a.p.a(this.c, this.ba);
    return true;
  }
  aa(a) {
    for (let b = 0; b < a.r.length; b++) {
      a.r[b] = a.r[b].e(this.c, this.ba);
    }
    return true;
  }
  aq(a) {
    let b;
    if (a.v == false) {
      a.y = a.y.a(this.c, this.ba, false);
      b = true;
    }
    else {
      b = false;
    }
    let c = a.y.e(this.c, a.v, false);
    if (c.m < 0 || c.o < 0 || this.c.f.maxColumnCount <= c.m || this.c.f.maxRowCount <= c.o) {
      this.a3 = a.t();
      return true;
    }
    return b;
  }
  at(a) {
    a.p = a.p.a(this.c, this.ba);
    return true;
  }
  static a9(a, b) {
    if (Formula_OffsetReferencesVisitor.a8 == null) {
      Formula_OffsetReferencesVisitor.a8 = new Formula_OffsetReferencesVisitor();
    }
    Formula_OffsetReferencesVisitor.a8.ba = b;
    Formula_OffsetReferencesVisitor.a8.c = a;
    return Formula_OffsetReferencesVisitor.a8;
  }
}
Formula_OffsetReferencesVisitor.$t = markType(Formula_OffsetReferencesVisitor, 'Formula_OffsetReferencesVisitor', FormulaTokenModifierVisitor.$);
Formula_OffsetReferencesVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_CellsShiftedVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.a8 = new CellShiftOperation();
    this.bb = 0;
  }
  a1() {
    this.a8 = new CellShiftOperation();
    super.a1();
  }
  j(a) {
    let b = this.c.l;
    let c = b.a();
    if (this.c.j == this.a8.h) {
      let d = this.a8.c(c);
      c = d.p0;
    }
    let e = (WorksheetCellAddress.h(b, c));
    let f = a.x.k(this.c, a.v);
    let g = f._a();
    let h = false;
    if (a.u(this.c) == this.a8.h) {
      let i = ((() => { let j = this.a8.e(g, true); g = j.p0; return j.ret; })());
      h = i.f;
      if (i.g && this.bb == 0) {
        this.a3 = a.t();
        return true;
      }
    }
    if (e == false && h == false) {
      return false;
    }
    let j;
    let k;
    let l = ((() => { let m = this.bc(a, a.x.d, b, c, g._ac - f._ac, g._w - f._w, j, k); j = m.p6; k = m.p7; return m.ret; })());
    let m;
    let n;
    let o = ((() => { let p = this.bc(a, a.x.b, b, c, g._ae - f._ae, g._x - f._x, m, n); m = p.p6; n = p.p7; return p.ret; })());
    if (l == false && o == false) {
      return false;
    }
    let p = a.x.d;
    let q = a.x.b;
    let r = new CellAddress(1, p.t + j, p.p, (p.r + k), p.g);
    let s = new CellAddress(1, q.t + m, q.p, (q.r + n), q.g);
    let t = r.e(this.c, a.v);
    let u = s.e(this.c, a.v);
    if (u.o < t.o || u.m < t.m) {
      this.a3 = a.t();
      return true;
    }
    if (l == false) {
      let v = a.d(FormulaToken.$, CloneTokenVisitor.a2);
      v.x = new CellAddressRange(1, r, s);
      this.a3 = v;
      return true;
    }
    a.x = new CellAddressRange(1, r, s);
    return true;
  }
  aq(a) {
    let b = this.c.l;
    let c = b.a();
    if (this.c.j == this.a8.h) {
      let d = this.a8.c(c);
      c = d.p0;
    }
    let e = (WorksheetCellAddress.h(b, c));
    let f = a.y.e(this.c, a.v);
    let g = f.a();
    let h = false;
    if (a.u(this.c) == this.a8.h) {
      let i = ((() => { let j = this.a8.c(g); g = j.p0; return j.ret; })());
      h = i.f;
      if (i.g && this.bb == 0) {
        this.a3 = a.t();
        return true;
      }
    }
    if (e == false && h == false) {
      return false;
    }
    let j;
    let k;
    if (((() => { let l = this.bc(a, a.y, b, c, g.o - f.o, g.m - f.m, j, k); j = l.p6; k = l.p7; return l.ret; })()) == false) {
      return false;
    }
    a.y = new CellAddress(1, a.y.t + j, a.y.p, (a.y.r + k), a.y.g);
    return true;
  }
  bc(a, b, c, d, e, f, g, h) {
    let i = ((() => { let j = this.be(a, b, c, d, e, g); b = j.p1; c = j.p2; d = j.p3; g = j.p5; return j.ret; })());
    let j = ((() => { let k = this.bd(a, b, c, d, f, h); b = k.p1; c = k.p2; d = k.p3; h = k.p5; return k.ret; })());
    return {
      ret: i || j,
      p6: g,
      p7: h
    };
  }
  bd(a, b, c, d, e, f) {
    f = 0;
    let g = d.m - c.m;
    let h = b.r;
    let i = a.v && b.g;
    let t1 = this.bb;
    L0: while (true) {
      switch (t1) {
        case 0:
          if (i) {
            h -= (g - e);
          }
          else {
            h += e;
          }
          break;
        case 1:
          if (b.g == false) {
            t1 = 0;
            continue L0;
          }
          if (g == 0) {
            return {
              ret: false,
              p1: b,
              p2: c,
              p3: d,
              p5: f
            };
          }
          if (i) {
            return {
              ret: true,
              p1: b,
              p2: c,
              p3: d,
              p5: f
            };
          }
          else {
            h += g;
          }
          break;
        default: break;
      }
      break;
    }
    f = h - b.r;
    return {
      ret: f != 0,
      p1: b,
      p2: c,
      p3: d,
      p5: f
    };
  }
  be(a, b, c, d, e, f) {
    f = 0;
    let g = d.o - c.o;
    let h = b.t;
    let i = a.v && b.p;
    let t1 = this.bb;
    L0: while (true) {
      switch (t1) {
        case 0:
          if (i) {
            h -= (g - e);
          }
          else {
            h += e;
          }
          break;
        case 1:
          if (b.p == false) {
            t1 = 0;
            continue L0;
          }
          if (g == 0) {
            return {
              ret: false,
              p1: b,
              p2: c,
              p3: d,
              p5: f
            };
          }
          if (i) {
            return {
              ret: true,
              p1: b,
              p2: c,
              p3: d,
              p5: f
            };
          }
          else {
            h += g;
          }
          break;
        default: break;
      }
      break;
    }
    f = h - b.t;
    return {
      ret: f != 0,
      p1: b,
      p2: c,
      p3: d,
      p5: f
    };
  }
  static ba(a, b, c) {
    if (Formula_CellsShiftedVisitor.a9 == null) {
      Formula_CellsShiftedVisitor.a9 = new Formula_CellsShiftedVisitor();
    }
    Formula_CellsShiftedVisitor.a9.a8 = b;
    Formula_CellsShiftedVisitor.a9.bb = c;
    Formula_CellsShiftedVisitor.a9.c = a;
    return Formula_CellsShiftedVisitor.a9;
  }
}
Formula_CellsShiftedVisitor.$t = markType(Formula_CellsShiftedVisitor, 'Formula_CellsShiftedVisitor', FormulaTokenModifierVisitor.$);
Formula_CellsShiftedVisitor.a9 = null;
/**
 * @hidden
 */
export class Formula_CurrentFormatChangedVisitor extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a2 = 0;
    this.a1 = 0;
  }
  g() {
    super.g();
  }
  n(a) {
    a.x = a.x.f(this.a2, this.a1, a.v);
  }
  at(a) {
    a.y = a.y.b(this.a2, this.a1, a.v);
  }
  static a0(a, b, c) {
    if (Formula_CurrentFormatChangedVisitor.az == null) {
      Formula_CurrentFormatChangedVisitor.az = new Formula_CurrentFormatChangedVisitor();
    }
    Formula_CurrentFormatChangedVisitor.az.b = a;
    Formula_CurrentFormatChangedVisitor.az.a2 = b;
    Formula_CurrentFormatChangedVisitor.az.a1 = c;
    return Formula_CurrentFormatChangedVisitor.az;
  }
}
Formula_CurrentFormatChangedVisitor.$t = markType(Formula_CurrentFormatChangedVisitor, 'Formula_CurrentFormatChangedVisitor', FormulaTokenVisitor.$);
Formula_CurrentFormatChangedVisitor.az = null;
/**
 * @hidden
 */
export class Formula_NamedReferenceRemovedVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.a8 = null;
    this.bb = null;
  }
  a1() {
    if (this.a8 != null) {
      this.a8.a1();
      this.a8 = null;
    }
    this.bb = null;
    super.a1();
  }
  af(a) {
    return this.bc(a, a.u);
  }
  as(a) {
    return this.bc(a, a.w);
  }
  static ba(a, b) {
    if (Formula_NamedReferenceRemovedVisitor.a9 == null) {
      Formula_NamedReferenceRemovedVisitor.a9 = new Formula_NamedReferenceRemovedVisitor();
    }
    Formula_NamedReferenceRemovedVisitor.a9.bb = b;
    Formula_NamedReferenceRemovedVisitor.a9.c = a;
    return Formula_NamedReferenceRemovedVisitor.a9;
  }
  bc(a, b) {
    if (b == this.bb) {
      if (this.a8 == null) {
        this.a8 = Formula_ConnectReferencesVisitor.a9(this.c, false);
      }
      a.d(Boolean_$type, this.a8);
      return true;
    }
    return false;
  }
}
Formula_NamedReferenceRemovedVisitor.$t = markType(Formula_NamedReferenceRemovedVisitor, 'Formula_NamedReferenceRemovedVisitor', FormulaTokenModifierVisitor.$);
Formula_NamedReferenceRemovedVisitor.a9 = null;
/**
 * @hidden
 */
export class Formula_TableResizingVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.bd = null;
    this.bb = false;
    this.ba = null;
  }
  a1() {
    this.bd = null;
    this.ba = null;
    super.a1();
  }
  ay(a) {
    this.bb = false;
    return {
      ret: ((() => { let b = super.ay(a); a = b.p0; return b.ret; })()),
      p0: a
    };
  }
  af(a) {
    this.bb = (this.ba == a.u);
    return false;
  }
  as(a) {
    let b = (this.ba == a.w);
    if (b == false) {
      return false;
    }
    this.bb = true;
    if (a.ag == null && a.u == null) {
      return false;
    }
    let c = this.ba._z;
    let d = false;
    for (let e = 0; e < this.bd.count; e++) {
      let f = this.bd._inner[e];
      if (a.ag != null && StringUtilities.c(f.name, a.ag, c, 1) == 0) {
        d = true;
        break;
      }
      if (a.u != null) {
        if (a.u.p != null && StringUtilities.c(f.name, a.u.p, c, 1) == 0) {
          d = true;
          break;
        }
        if (a.u.q != null && StringUtilities.c(f.name, a.u.q, c, 1) == 0) {
          d = true;
          break;
        }
      }
    }
    if (d) {
      this.a3 = new RefErrToken(a.h);
      return true;
    }
    return false;
  }
  static a9(a, b, c) {
    if (Formula_TableResizingVisitor.a8 == null) {
      Formula_TableResizingVisitor.a8 = new Formula_TableResizingVisitor();
    }
    Formula_TableResizingVisitor.a8.bd = c;
    Formula_TableResizingVisitor.a8.ba = b;
    Formula_TableResizingVisitor.a8.c = a;
    return Formula_TableResizingVisitor.a8;
  }
  get bc() {
    return this.bb;
  }
}
Formula_TableResizingVisitor.$t = markType(Formula_TableResizingVisitor, 'Formula_TableResizingVisitor', FormulaTokenModifierVisitor.$);
Formula_TableResizingVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_WorksheetMovedVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.bb = 0;
    this.ba = null;
  }
  a1() {
    this.bb = -1;
    this.ba = null;
    super.a1();
  }
  t(a) {
    let b = typeCast(WorksheetReferenceMulti.$, a.o);
    if (b != null && b.j == false && b.i) {
      let c = b.l;
      let d = b.m;
      if (d < c) {
        let e;
        if (this.ba.index == c) {
          e = this.ba.workbook._worksheets$i._item(d);
        }
        else {
          e = this.ba.workbook._worksheets$i._item(c);
        }
        let f = this.ba.workbook._bb;
        let g = Math.min(this.bb, e.index);
        let h = Math.max(this.bb, e.index);
        let i = f.aa(g);
        let j;
        if (g == h) {
          j = null;
        }
        else {
          j = f.aa(h);
        }
        a.o = f.g(i, j);
        return true;
      }
      else {
        if (c <= this.ba.index && this.ba.index <= d) {
          return true;
        }
        if (c <= this.bb && this.bb <= d) {
          return true;
        }
      }
    }
    return false;
  }
  static a9(a, b, c) {
    if (Formula_WorksheetMovedVisitor.a8 == null) {
      Formula_WorksheetMovedVisitor.a8 = new Formula_WorksheetMovedVisitor();
    }
    Formula_WorksheetMovedVisitor.a8.ba = b;
    Formula_WorksheetMovedVisitor.a8.bb = c;
    Formula_WorksheetMovedVisitor.a8.c = a;
    return Formula_WorksheetMovedVisitor.a8;
  }
}
Formula_WorksheetMovedVisitor.$t = markType(Formula_WorksheetMovedVisitor, 'Formula_WorksheetMovedVisitor', FormulaTokenModifierVisitor.$);
Formula_WorksheetMovedVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_WorksheetRemovedVisitor extends FormulaTokenModifierVisitor {
  constructor() {
    super();
    this.bb = 0;
    this.ba = null;
  }
  a1() {
    this.bb = -1;
    this.ba = null;
    super.a1();
  }
  af(a) {
    let b = typeCast(WorksheetReferenceLocal.$, a.o);
    if (b != null && b.u == this.ba) {
      a.o = b.e.i(-2);
      return true;
    }
    if (a.u._t == false && Formula_ConnectReferencesVisitor.bb(this.c, a)) {
      return true;
    }
    return false;
  }
  t(a) {
    let b = a.o;
    if (b != null && b.j == false && b.i) {
      let c = typeCast(WorksheetReferenceLocal.$, b);
      if (c != null && c.u == this.ba) {
        this.a3 = a.t();
        return true;
      }
      else {
        let d = typeCast(WorksheetReferenceMulti.$, b);
        if (d != null) {
          let e = d.e;
          let f;
          let g;
          if (d.l == -1) {
            f = e.aa(this.bb);
            g = d.t.s;
          }
          else if (d.m == -1) {
            f = d.r.s;
            g = e.aa(this.bb - 1);
          }
          else {
            return d.l <= this.bb && this.bb <= d.m;
          }
          if (f == g) {
            g = null;
          }
          a.o = e.g(f, g);
          return true;
        }
      }
    }
    return false;
  }
  static a9(a, b, c) {
    if (Formula_WorksheetRemovedVisitor.a8 == null) {
      Formula_WorksheetRemovedVisitor.a8 = new Formula_WorksheetRemovedVisitor();
    }
    Formula_WorksheetRemovedVisitor.a8.ba = b;
    Formula_WorksheetRemovedVisitor.a8.bb = c;
    Formula_WorksheetRemovedVisitor.a8.c = a;
    return Formula_WorksheetRemovedVisitor.a8;
  }
}
Formula_WorksheetRemovedVisitor.$t = markType(Formula_WorksheetRemovedVisitor, 'Formula_WorksheetRemovedVisitor', FormulaTokenModifierVisitor.$);
Formula_WorksheetRemovedVisitor.a8 = null;
/**
 * @hidden
 */
export class Formula_VerifyFormatLimitsVisitor extends FormulaTokenVisitor {
  constructor() {
    super();
    this.az = null;
    this.a2 = 0;
  }
  g() {
    Formula_VerifyFormatLimitsVisitor.a0.az = null;
    super.g();
  }
  n(a) {
    a.x.g(this.b, a.v).t(this.az, this.a2);
  }
  au(a) {
    a.y.c(this.b, a.v).aa(this.az, this.a2);
  }
  static a1(a, b, c) {
    if (Formula_VerifyFormatLimitsVisitor.a0 == null) {
      Formula_VerifyFormatLimitsVisitor.a0 = new Formula_VerifyFormatLimitsVisitor();
    }
    Formula_VerifyFormatLimitsVisitor.a0.b = a;
    Formula_VerifyFormatLimitsVisitor.a0.az = b;
    Formula_VerifyFormatLimitsVisitor.a0.a2 = c;
    return Formula_VerifyFormatLimitsVisitor.a0;
  }
}
Formula_VerifyFormatLimitsVisitor.$t = markType(Formula_VerifyFormatLimitsVisitor, 'Formula_VerifyFormatLimitsVisitor', FormulaTokenVisitor.$);
Formula_VerifyFormatLimitsVisitor.a0 = null;
/**
 * @hidden
 */
export class FormulaToken extends Base {
  constructor(a) {
    super();
    this.g = 0;
    this.g = a;
  }
  toString() {
    return this.l(new FormulaContext(0, null), GetFormulaStringInfo.a);
  }
  j(a, b, c) {
    return getInstanceType(b) == getInstanceType(this);
  }
  get_h() {
    return this.g;
  }
  set_h(a) {
    if (this.f < 32) {
      let b = typeCast(AttrSumToken.$, this);
      if (b != null) {
        this.g = a;
      }
      else if (this.f == 21) {
        this.g = a;
      }
      return;
    }
    this.g = a;
  }
  get h() {
    return this.get_h();
  }
  set h(a) {
    this.set_h(a);
  }
  static c(a, b) {
    switch (b) {
      case 1: return new ExpToken(0);
      case 2: return new TblToken(0);
      case 3: return AddOperator.z;
      case 4: return SubOperator.z;
      case 5: return MulOperator.z;
      case 6: return DivOperator.z;
      case 7: return PowerOperator.z;
      case 8: return ConcatOperator.z;
      case 9: return LTOperator.z;
      case 10: return LEOperator.z;
      case 11: return EQOperator.z;
      case 12: return GEOperator.z;
      case 13: return GTOperator.z;
      case 14: return NEOperator.z;
      case 15: return IsectOperator.z;
      case 16: return UnionOperator.z;
      case 17: return RangeOperator.z;
      case 18: return UplusOperator.y;
      case 19: return UminusOperator.y;
      case 20: return PercentOperator.y;
      case 21: return new ParenToken();
      case 22: return MissArgToken.o;
      case 23: return new StrToken(0);
      case 24: break;
      case 28: return new ErrToken(0);
      case 29: return new BoolToken(0);
      case 30: return new IntToken(0);
      case 31: return new NumberToken(0);
      case 32:
      case 64:
      case 96: return new ArrayToken(0, FormulaToken.i(b));
      case 33:
      case 65:
      case 97: return new FunctionOperator(0, FormulaToken.i(b));
      case 34:
      case 66:
      case 98: return new FunctionVOperator(0, FormulaToken.i(b));
      case 35:
      case 67:
      case 99: return new NameToken(0, FormulaToken.i(b), true);
      case 36:
      case 68:
      case 100: return new RefToken(0, FormulaToken.i(b));
      case 37:
      case 69:
      case 101: return new AreaToken(0, FormulaToken.i(b));
      case 38:
      case 70:
      case 102: return new MemAreaOperator(FormulaToken.i(b));
      case 39:
      case 71:
      case 103: return new MemErrOperator(FormulaToken.i(b));
      case 40:
      case 72:
      case 104: return new MemNoMemOperator(FormulaToken.i(b));
      case 41:
      case 73:
      case 105: return new MemFuncOperator(FormulaToken.i(b));
      case 42:
      case 74:
      case 106: return new RefErrToken(FormulaToken.i(b));
      case 43:
      case 75:
      case 107: return new AreaErrToken(FormulaToken.i(b));
      case 44:
      case 76:
      case 108: return new RefNToken(0, FormulaToken.i(b));
      case 45:
      case 77:
      case 109: return new AreaNToken(0, FormulaToken.i(b));
      case 57:
      case 89:
      case 121: return new NameXToken(0, FormulaToken.i(b), true);
      case 58:
      case 90:
      case 122: return new Ref3DToken(0, FormulaToken.i(b));
      case 59:
      case 91:
      case 123: return new Area3DToken(0, FormulaToken.i(b));
      case 60:
      case 92:
      case 124: return new RefErr3dToken(0, FormulaToken.i(b));
      case 61:
      case 93:
      case 125: return new AreaErr3DToken(0, FormulaToken.i(b));
    }
    return null;
  }
  static b(a, b, c, d) {
    return {
      ret: ((() => { let e = AttrTokenBase.o(a, c, d); c = e.p1; d = e.p2; return e.ret; })()),
      p2: c,
      p3: d
    };
  }
  static i(a) {
    let b = ((a & 96) >> 5);
    switch (b) {
      case 1: return 32;
      case 2: return 64;
      case 3: return 96;
      default: return 32;
    }
  }
}
FormulaToken.$t = markType(FormulaToken, 'FormulaToken');
FormulaToken.a = new Array(0);
/**
 * @hidden
 */
export class SharedTokenConverter extends FormulaTokenVisitor$1 {
  constructor() {
    super(FormulaToken.$);
    this.a4 = false;
  }
  d(a) {
    return a;
  }
  e(a) {
    if (this.a4 == false) {
      return new Area3DToken(2, a.o, a.x.g(this.c, a.v), a.h);
    }
    return a;
  }
  f(a) {
    if (this.a4 && a.x.l) {
      return new Area3DNToken(1, a.o, a.x.h(this.c), a.h);
    }
    return a;
  }
  i(a) {
    if (this.a4 == false) {
      return new AreaToken(2, a.x.g(this.c, a.v), a.h);
    }
    return a;
  }
  j(a) {
    if (this.a4 && a.x.l) {
      return new AreaNToken(2, a.x.h(this.c), a.h);
    }
    return a;
  }
  ak(a) {
    if (this.a4 == false) {
      return new Ref3DToken(2, a.o, a.y.c(this.c, a.v), a.h);
    }
    return a;
  }
  al(a) {
    if (this.a4 && a.y.h) {
      return new Ref3DNToken(1, a.o, a.y.d(this.c), a.h);
    }
    return a;
  }
  ap(a) {
    if (this.a4 == false) {
      return new RefToken(2, a.y.c(this.c, a.v), a.h);
    }
    return a;
  }
  aq(a) {
    if (this.a4 && a.y.h) {
      return new RefNToken(2, a.y.d(this.c), a.h);
    }
    return a;
  }
  static a3(a, b) {
    if (SharedTokenConverter.a2 == null) {
      SharedTokenConverter.a2 = new SharedTokenConverter();
    }
    SharedTokenConverter.a2.c = a;
    SharedTokenConverter.a2.a4 = b;
    return SharedTokenConverter.a2;
  }
}
SharedTokenConverter.$t = markType(SharedTokenConverter, 'SharedTokenConverter', FormulaTokenVisitor$1.$.specialize(FormulaToken.$));
SharedTokenConverter.a2 = null;
/**
 * The exception thrown when a formula parse error occurs.
 */
export class FormulaParseException extends BaseError {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    else if (arguments.length === 2) {
      a = 2;
    }
    else if (arguments.length === 4) {
      a = 3;
    }
    switch (a) {
      case 0:
        {
          super(0);
          this._c = 0;
          this._e = null;
          this._g = null;
        }
        break;
      case 1:
        {
          let message = _rest[0];
          super(1, message);
          this._c = 0;
          this._e = null;
          this._g = null;
        }
        break;
      case 2:
        {
          let message = _rest[0];
          let innerException = _rest[1];
          super(2, message, innerException);
          this._c = 0;
          this._e = null;
          this._g = null;
        }
        break;
      case 3:
        {
          let charIndexOfError = _rest[0];
          let formulaValue = _rest[1];
          let message = _rest[2];
          let portionWithError = _rest[3];
          let b = [message];
          {
            let message = b[0];
            super(1, message);
            this._c = 0;
            this._e = null;
            this._g = null;
          }
          this._c = charIndexOfError;
          this._e = formulaValue;
          this._g = portionWithError;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Gets the character index in the [[formulaValue]] at which the parse error occurred.
   * The character index in the FormulaValue at which the parse error occurred.
   */
  get charIndexOfError() {
    return this._c;
  }
  /**
   * Gets the formula string which had the error being parsed.
   * The formula string which had the error being parsed.
   */
  get formulaValue() {
    return this._e;
  }
  /**
   * Gets the error message and the portion of the formula with the error.
   */
  get_message() {
    let a = super.get_message();
    if (this._g == null) {
      return a;
    }
    let b = ExcelUtils.eg("LE_FormulaParseException_Message_PortionWithError", this._g);
    if (a == null) {
      return b;
    }
    return a + Environment.newLine + b;
  }
  /**
   * Gets the portion of the formula which contains the error.
   */
  get portionWithError() {
    return this._g;
  }
}
FormulaParseException.$t = markType(FormulaParseException, 'FormulaParseException', BaseError.$);
/**
 * @hidden
 */
export class NamedReferenceFormula extends SingleTargetFormula {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(0, c, d);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(3, c, false);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super(0, c._y.cellReferenceMode, 3);
          let d = new FormulaContext(1, c._y, c);
          let e = c._t != null && c._t.type == 0 ? To3DTokenConverter.a4(d) : null;
          let f = new Array(c._e.length);
          for (let g = 0; g < f.length; g++) {
            let h = c._e[g];
            let i = h.d(FormulaToken.$, CloneTokenVisitor.a2);
            if (e != null) {
              i = i.d(FormulaToken.$, e);
            }
            f[g] = i;
          }
          if (e != null) {
            e.a1();
          }
          this._e = f;
        }
        break;
    }
  }
  _g() {
    return new NamedReferenceFormula(1, this);
  }
  _b7() {
    let a = this._ch;
    if (a != null && a._formula == this) {
      a._a0(this, false, true);
    }
  }
}
NamedReferenceFormula.$t = markType(NamedReferenceFormula, 'NamedReferenceFormula', SingleTargetFormula.$);
/**
 * @hidden
 */
export class To3DTokenConverter extends FormulaTokenVisitor$1 {
  constructor() {
    super(FormulaToken.$);
    this.a2 = null;
  }
  d(a) {
    return a;
  }
  i(a) {
    return new Area3DNToken(1, this.a2, a.x, a.h);
  }
  j(a) {
    return new Area3DToken(2, this.a2, a.x, a.h);
  }
  ap(a) {
    return new Ref3DNToken(1, this.a2, a.y, a.h);
  }
  aq(a) {
    return new Ref3DToken(2, this.a2, a.y, a.h);
  }
  static a4(a) {
    if (To3DTokenConverter.a3 == null) {
      To3DTokenConverter.a3 = new To3DTokenConverter();
    }
    To3DTokenConverter.a3.c = a;
    To3DTokenConverter.a3.a2 = a.f._bb.i(a.j.index);
    return To3DTokenConverter.a3;
  }
}
To3DTokenConverter.$t = markType(To3DTokenConverter, 'To3DTokenConverter', FormulaTokenVisitor$1.$.specialize(FormulaToken.$));
To3DTokenConverter.a3 = null;
/**
 * @hidden
 */
export class SingleTargetFormula_DynamicReferenceCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  *_getEnumeratorObject() {
    for (let a = this._a._cm; a < this._a._cl.count; a++) {
      yield this._a._cl._inner[a];
    }
  }
  getEnumeratorObject() {
    return toEnum(() => this._getEnumeratorObject()).getEnumeratorObject();
  }
  equals(a) {
    let b = typeCast(SingleTargetFormula_DynamicReferenceCollection.$, a);
    if (b == null) {
      return false;
    }
    return this._a == b._a;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a) + 1;
  }
}
SingleTargetFormula_DynamicReferenceCollection.$t = markType(SingleTargetFormula_DynamicReferenceCollection, 'SingleTargetFormula_DynamicReferenceCollection', Base.$, [IExcelCalcReferenceCollection_$type]);
/**
 * @hidden
 */
export class SingleTargetFormula_StaticReferenceCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  *_getEnumeratorObject() {
    for (let a = 0; a < this._a._cm; a++) {
      yield this._a._cl._inner[a];
    }
  }
  getEnumeratorObject() {
    return toEnum(() => this._getEnumeratorObject()).getEnumeratorObject();
  }
  equals(a) {
    let b = typeCast(SingleTargetFormula_StaticReferenceCollection.$, a);
    if (b == null) {
      return false;
    }
    return this._a == b._a;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a) + 1;
  }
}
SingleTargetFormula_StaticReferenceCollection.$t = markType(SingleTargetFormula_StaticReferenceCollection, 'SingleTargetFormula_StaticReferenceCollection', Base.$, [IExcelCalcReferenceCollection_$type]);
/**
 * @hidden
 */
export class SingleTargetFormula_StaticReferenceFinder extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a1 = null;
    this.a0 = null;
    this.a5 = null;
    this.az = null;
    this.a4 = null;
    this.a5 = new Stack$1(Number_$type);
    this.a4 = new Dictionary$2(Number_$type, TokenClass_$type, 0);
  }
  g() {
    this.a4.clear();
    this.a0 = null;
    this.az = null;
    this.a1 = null;
    super.g();
  }
  f() {
    if (this.a5.f != 0) {
      this.a7(this.a5.e(), true, CalcUtilities.h(this.a1._ch));
    }
    for (let a = 0; a < this.az.length; a++) {
      let b;
      if (((() => { let c = this.a4.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
        this.a6(a, b);
      }
    }
    super.f();
  }
  p(a) {
    this.a7(this.a5.e(), true, 64);
    this.a5.h(a.t);
    this.d = a.t;
  }
  q(a) {
    this.a7(this.a5.e(), true, 64);
    this.a5.h(a.v);
    this.d = a.v;
  }
  r(a) {
  }
  v(a) {
    this.a8(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a0), 2);
  }
  aa(a) {
    this.a8(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a0), a.argumentCount);
  }
  ab(a) {
    this.a8(a.formulaToken.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a0), a.argumentCount);
  }
  ac(a) {
    this.a8(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a0), a.argumentCount);
  }
  aj(a) {
    if (a.u._g == 1) {
      return;
    }
    super.aj(a);
  }
  am(a) {
    this.a5.h(this.d);
  }
  ay(a) {
    this.a8(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a0), 1);
  }
  a6(a, b) {
    let c = typeCast(IExcelCalcReference_$type, this.az[a].n(this.b));
    if (c == null) {
      return;
    }
    if (this.b.d._s == 1 && b == 64) {
      let d = c.context;
      let e = typeCast(WorksheetRegion.$, d);
      if (e != null && e._u == false) {
        return;
      }
      let f = typeCast(List$1.$.specialize(WorksheetRegion.$), d);
      if (f != null) {
        if (f.count != 1 || f._inner[0]._u == false) {
          return;
        }
      }
    }
    else if (b == 64 && this.b.l.e) {
      let g = c.context;
      let h = typeCast(WorksheetRegion.$, g);
      if (h != null && h.worksheet == this.b.j) {
        let i = this.b.l.o;
        let j = this.b.l.m;
        if (!h._t(i, j, i, j)) {
          if (h.firstRow <= i && h.lastRow >= i) {
            c = h.worksheet._rows$i.item(i)._as(h.firstColumn);
          }
          else if (h.firstColumn <= j && h.lastColumn >= j) {
            c = h.worksheet._rows$i.item(h.firstRow)._as(j);
          }
        }
      }
    }
    this.a1._cl.add(c);
  }
  static a3(a, b) {
    if (SingleTargetFormula_StaticReferenceFinder.a2 == null) {
      SingleTargetFormula_StaticReferenceFinder.a2 = new SingleTargetFormula_StaticReferenceFinder();
    }
    let c = SingleTargetFormula_StaticReferenceFinder.a2;
    if (c.b != null) {
      c = new SingleTargetFormula_StaticReferenceFinder();
    }
    c.b = a;
    c.a1 = b;
    c.a0 = a.f._w.d;
    c.az = a.d._e;
    c.a4.clear();
    c.b.d._cb();
    return c;
  }
  a7(a, b, c) {
    if (b == false) {
      return;
    }
    let d = typeCast(ReferenceToken.$, this.az[a]);
    if (d == null) {
      return;
    }
    if (this.a1._ch._aj && d.p) {
      return;
    }
    let e = typeCast(NameToken.$, d);
    if (e != null && e.u._g == 1) {
      return;
    }
    this.a4.addItem(a, c);
  }
  a8(a, b) {
    if (a == null) {
      this.b.d._aj = true;
      for (let c = b - 1; c >= 0; c--) {
        this.a5.e();
      }
    }
    else {
      for (let d = b - 1; d >= 0; d--) {
        this.a7(this.a5.e(), a._v(d), a._j(d));
      }
    }
    this.a5.h(this.d);
  }
}
SingleTargetFormula_StaticReferenceFinder.$t = markType(SingleTargetFormula_StaticReferenceFinder, 'SingleTargetFormula_StaticReferenceFinder', FormulaTokenVisitor.$);
SingleTargetFormula_StaticReferenceFinder.a2 = null;
/**
 * Abstract base class for classes which control pane settings.
 * @see [[FrozenPaneSettings]]
 * @see [[UnfrozenPaneSettings]]
 */
export class PaneSettingsBase extends Base {
  constructor(a) {
    super();
    this._d = null;
    this._k = 0;
    this._n = 0;
    this._d = a;
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(PaneSettingsBase.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, PaneSettingsBase._c(PaneSettingsBase.$, "Reset", (b) => b, (b, c) => b._v(c)));
    ChangeInfo.f(a, 1, PaneSettingsBase._c(Number_$type, "FirstColumnInRightPane", (b) => b.firstColumnInRightPane, (b, c) => b.firstColumnInRightPane = c));
    ChangeInfo.f(a, 2, PaneSettingsBase._c(Number_$type, "FirstRowInBottomPane", (b) => b.firstRowInBottomPane, (b, c) => b.firstRowInBottomPane = c));
    return a;
  }
  /**
   * @hidden
   */
  _s(a) {
    this._k = a._k;
    this._n = a._n;
  }
  /**
   * Resets the pane settings to their defaults.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  reset() {
    let a = this._f();
    this.resetCore();
    (PaneSettingsBase._a[0]).x(this, a, this);
  }
  /**
   * Resets the pane settings to their defaults.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    this._k = 0;
    this._n = 0;
  }
  /**
   * Gets or sets the first visible column in the right pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the right pane(s) of the worksheet and
   * is only used if the worksheet is split vertically.
   * </p>
   * The zero-based index of the first visible column in the right pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get firstColumnInRightPane() {
    return this._k;
  }
  /**
   * Gets or sets the first visible column in the right pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the right pane(s) of the worksheet and
   * is only used if the worksheet is split vertically.
   * </p>
   * The zero-based index of the first visible column in the right pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set firstColumnInRightPane(a) {
    if (this._k != a) {
      ExcelUtils.gi(this._d._ad, a, "value");
      let b = PaneSettingsBase._a[1].g(PaneSettingsBase.$, Number_$type, this, this._k, a);
      this._k = b.p1;
    }
  }
  /**
   * Gets or sets the first visible row in the bottom pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the bottom pane(s) of the worksheet and
   * is only used if the worksheet is split horizontally.
   * </p>
   * The zero-based index of the first visible row in the bottom pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get firstRowInBottomPane() {
    return this._n;
  }
  /**
   * Gets or sets the first visible row in the bottom pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the bottom pane(s) of the worksheet and
   * is only used if the worksheet is split horizontally.
   * </p>
   * The zero-based index of the first visible row in the bottom pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set firstRowInBottomPane(a) {
    if (this._n != a) {
      ExcelUtils.gp(this._d._ad, a, "value");
      let b = PaneSettingsBase._a[2].g(PaneSettingsBase.$, Number_$type, this, this._n, a);
      this._n = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
  /**
   * @hidden
   */
  _f() {
    let a = this._g();
    a._s(this);
    return a;
  }
  /**
   * @hidden
   */
  _j() {
    return this._k != 0 || this._n != 0;
  }
  /**
   * @hidden
   */
  _v(a) {
    let b = this._f();
    this._s(a);
    (PaneSettingsBase._a[0]).x(this, b, this);
  }
  /**
   * @hidden
   */
  get workbook() {
    let a = this._d._ad;
    return a != null ? a.workbook : null;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._d._ad;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
PaneSettingsBase.$t = markType(PaneSettingsBase, 'PaneSettingsBase', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
PaneSettingsBase._r = 0;
/**
 * @hidden
 */
PaneSettingsBase._m = 1;
/**
 * @hidden
 */
PaneSettingsBase._p = 2;
/**
 * @hidden
 */
PaneSettingsBase._q = 3;
/**
 * @hidden
 */
PaneSettingsBase._a = PaneSettingsBase._b();
/**
 * Class which controls the way frozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[UnfrozenPaneSettings]]
 */
export class FrozenPaneSettings extends PaneSettingsBase {
  constructor(a) {
    super(a);
    this._aa = 0;
    this._ad = 0;
    /**
     * @hidden
     */
    this._z = false;
  }
  /**
   * @hidden
   */
  _g() {
    return new FrozenPaneSettings(this._e);
  }
  /**
   * @hidden
   */
  get__h() {
    return this._ad > 0;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
  /**
   * @hidden
   */
  get__i() {
    return this._aa > 0;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * @hidden
   */
  _s(a) {
    super._s(a);
    let b = a;
    this._aa = b._aa;
    this._ad = b._ad;
    this._z = b._z;
  }
  /**
   * Resets the frozen pane settings to their defaults.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    super.resetCore();
    this._aa = 0;
    this._ad = 0;
    this._z = false;
  }
  /**
   * Gets or sets the number of columns frozen at the left of the worksheet.
   * <p class="body">
   * The frozen columns will always remain in view, regardless of the horizontal scroll position of
   * the worksheet.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the number of frozen columns specified is more than the amount of visible columns
   * in the worksheet, the worksheet may not scroll correctly.
   * </p>
   * The number of columns frozen at the left of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid column count (0 to [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get frozenColumns() {
    return this._aa;
  }
  /**
   * Gets or sets the number of columns frozen at the left of the worksheet.
   * <p class="body">
   * The frozen columns will always remain in view, regardless of the horizontal scroll position of
   * the worksheet.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the number of frozen columns specified is more than the amount of visible columns
   * in the worksheet, the worksheet may not scroll correctly.
   * </p>
   * The number of columns frozen at the left of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid column count (0 to [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set frozenColumns(a) {
    if (this._aa != a) {
      ExcelUtils.gh(this._e._ad, a, "value");
      let b = FrozenPaneSettings._w[0].g(FrozenPaneSettings.$, Number_$type, this, this._aa, a);
      this._aa = b.p1;
    }
  }
  /**
   * Gets or sets the number of rows frozen at the top of the worksheet.
   * <p class="body">
   * The frozen rows will always remain in view, regardless of the vertical scroll position of
   * the worksheet.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the number of frozen rows specified is more than the amount of visible rows
   * in the worksheet, the worksheet may not scroll correctly.
   * </p>
   * The number of rows frozen at the top of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid row count (0 to [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get frozenRows() {
    return this._ad;
  }
  /**
   * Gets or sets the number of rows frozen at the top of the worksheet.
   * <p class="body">
   * The frozen rows will always remain in view, regardless of the vertical scroll position of
   * the worksheet.
   * </p>
   * <p class="note">
   * <B>Note:</B> If the number of frozen rows specified is more than the amount of visible rows
   * in the worksheet, the worksheet may not scroll correctly.
   * </p>
   * The number of rows frozen at the top of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid row count (0 to [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set frozenRows(a) {
    if (this._ad != a) {
      ExcelUtils.go(this._e._ad, a, "value");
      let b = FrozenPaneSettings._w[1].g(FrozenPaneSettings.$, Number_$type, this, this._ad, a);
      this._ad = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(FrozenPaneSettings.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, FrozenPaneSettings._y(Number_$type, "FrozenColumns", (b) => b.frozenColumns, (b, c) => b.frozenColumns = c));
    ChangeInfo.f(a, 1, FrozenPaneSettings._y(Number_$type, "FrozenRows", (b) => b.frozenRows, (b, c) => b.frozenRows = c));
    return a;
  }
  /**
   * @hidden
   */
  _j() {
    return super._j() || this._ad != 0 || this._aa != 0;
  }
}
FrozenPaneSettings.$t = markType(FrozenPaneSettings, 'FrozenPaneSettings', PaneSettingsBase.$);
/**
 * @hidden
 */
FrozenPaneSettings._ac = 0;
/**
 * @hidden
 */
FrozenPaneSettings._af = 1;
/**
 * @hidden
 */
FrozenPaneSettings._ag = 2;
/**
 * @hidden
 */
FrozenPaneSettings._w = FrozenPaneSettings._x();
/**
 * @hidden
 */
export class GenericCachedCollection$1 extends Base {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this._b = null;
    this._c = null;
    this._h = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c, d, 0.2];
          {
            let g = e[0];
            let h = e[1];
            let i = e[2];
            this._b = new GenericElementHashSet$1(this.$t, i);
            this._c = g;
            this._h = h;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this._b = new GenericElementHashSet$1(this.$t, e);
          this._c = c;
          this._h = d;
        }
        break;
    }
  }
  add(a) {
    this._add(a);
  }
  clear() {
  }
  contains(a) {
    let b;
    return ((() => { let c = this._b.g(a, b); b = c.p1; return c.ret; })());
  }
  copyTo(a, b) {
    this._b.p(a, b);
  }
  get count() {
    return this._count;
  }
  get isReadOnly() {
    return false;
  }
  remove(a) {
    return this._remove(a);
  }
  getEnumerator() {
    return this._b.j();
  }
  getEnumeratorObject() {
    return this._b.j();
  }
  _add(a) {
    let b;
    if (((() => { let c = this._b.f(a, b); b = c.p1; return c.ret; })())) {
      this._l(a);
    }
  }
  _a(a) {
    let b;
    if (((() => { let c = this._b.g(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    return null;
  }
  _g(a) {
    let b = HashHelpers.d(a);
    let c;
    let d;
    let e = ((() => { let f = this._b.e(b, c, d); c = f.p1; d = f.p2; return f.ret; })());
    if (e != null) {
      for (let f = 0; f < c; f++) {
        let g = e[f];
        if (g.b != b) {
          continue;
        }
        let h = g.a;
        if (h == null) {
          break;
        }
        if (Base.equalsStatic(a, h)) {
          return d + f;
        }
      }
    }
    return -1;
  }
  _k(a, b) {
    if (((() => { let c = this._b.f(a, b); b = c.p1; return c.ret; })())) {
      b = a;
      this._l(a);
    }
    return {
      p1: b
    };
  }
  _l(a) {
    if (this._b.m > this._h) {
      if (typeCast(WorksheetCellFormatData.$, a) !== null) {
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxCellFormats", this._h));
      }
      else if (typeCast(StringElement.$, a) !== null) {
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxFormattedStrings", this._h));
      }
      else {
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxFonts", this._h));
      }
    }
  }
  _n(a) {
    this._b.u(a);
  }
  _m() {
    this._b.t();
  }
  _remove(a) {
    return this._b.i(a);
  }
  get _count() {
    return this._b.m;
  }
  get _i() {
    return this._h;
  }
  set _i(a) {
    if (this._count > a) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CollectionLongerThanMaxValue"));
    }
    this._h = a;
  }
  get _d() {
    return this._c;
  }
}
GenericCachedCollection$1.$t = markType(GenericCachedCollection$1, 'GenericCachedCollection$1', Base.$, [ICollection$1_$type.specialize(0)]);
/**
 * @hidden
 */
export let IGenericCachedCollectionEx_$type = new Type(null, 'IGenericCachedCollectionEx', null, [IWorkbookProvider_$type]);
/**
 * @hidden
 */
export class GenericCachedCollectionEx$1 extends GenericCachedCollection$1 {
  constructor($t, a, b, c) {
    super($t, 0, b, c);
    this.$t = null;
    this._o = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    if (a != null) {
      this._p = a;
    }
  }
  _l(a) {
    a.ab(this);
    super._l(a);
  }
  _remove(a) {
    if (super._remove(a) == false) {
      return false;
    }
    a.ac();
    return true;
  }
  get _p() {
    return this._o;
  }
  set _p(a) {
    if (this._o != null) {
      GenericCacheElementEx.q(this.$t, this._o);
    }
    if (this._o != null && this._o.f > 0) {
      this._b.i(this._o);
      this._o.aa(a);
      this._o.k();
      let b;
      if (((() => { let c = this._b.f(this._o, b); b = c.p1; return c.ret; })()) == false) {
        this._o = b;
      }
    }
    else {
      this._o = GenericCacheElementEx.r(this.$t, a, this);
    }
  }
  get workbook() {
    return this._d;
  }
}
GenericCachedCollectionEx$1.$t = markType(GenericCachedCollectionEx$1, 'GenericCachedCollectionEx$1', GenericCachedCollection$1.$.specialize(0), [IGenericCachedCollectionEx_$type]);
/**
 * @hidden
 */
export class GenericElementHashSet$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this.l = 0;
    this.a = null;
    this.b = null;
    this.c = null;
    this.h = false;
    this.k = 0;
    this.o = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.k = a;
    let b = truncate((5 / this.k));
    let c = HashHelpers.c(b);
    this.s(c);
  }
  s(a) {
    this.b = new Array(a);
    this.c = new Array(a);
    for (let b = 0; b < this.c.length; b++) {
      this.c[b] = 0;
    }
  }
  f(a, b) {
    b = Type.getDefaultValue(this.$t);
    if (this.h) {
      b = a;
      return {
        ret: false,
        p1: b
      };
    }
    if (a == null) {
      return {
        ret: false,
        p1: b
      };
    }
    let c = HashHelpers.d(a);
    let d = c % this.b.length;
    let e = this.b[d];
    let f = this.c[d];
    if (e != null) {
      for (let g = 0; g < f; g++) {
        let h = e[g];
        if (h.b == c && h.a.equals(a)) {
          b = h.a;
          return {
            ret: false,
            p1: b
          };
        }
      }
    }
    else {
      e = new Array(this.n(this.b.length));
      let i = new GenericElementHashSet_Entry$1(this.$t);
      for (let j = 0; j < e.length; j++) {
        e[j] = i;
      }
      this.b[d] = e;
    }
    let k = GenericElementHashSet$1.q(this.$t, this.b, e, f, d);
    e = k.p1;
    e[f++] = new GenericElementHashSet_Entry$1(this.$t, 1, a, c);
    this.c[d] = f;
    this.l++;
    this.o++;
    if (f > this.b.length * this.k) {
      this.r();
    }
    return {
      ret: true,
      p1: b
    };
  }
  g(a, b) {
    b = Type.getDefaultValue(this.$t);
    if (this.b == null || a == null) {
      return {
        ret: false,
        p1: b
      };
    }
    let c = HashHelpers.d(a);
    let d = c % this.b.length;
    let e = this.b[d];
    if (e != null) {
      let f = this.c[d];
      for (let g = 0; g < f; g++) {
        let h = e[g];
        if (h.b == c && h.a.equals(a)) {
          b = h.a;
          return {
            ret: true,
            p1: b
          };
        }
      }
    }
    return {
      ret: false,
      p1: b
    };
  }
  p(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "array");
    }
    if (b < 0) {
      throw new ArgumentOutOfRangeException(2, "arrayIndex", ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    if (b > a.length || this.l > (a.length - b)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ArrayTooSmall"), "array");
    }
    if (this.l == 0) {
      return;
    }
    let c = 0;
    for (let d = 0; d < this.b.length; d++) {
      let e = this.b[d];
      if (e == null) {
        continue;
      }
      let f = this.c[d];
      for (let g = 0; g < f; g++) {
        a[b + c] = e[g].a;
        c++;
      }
    }
  }
  d(a, b) {
    let c;
    return {
      ret: ((() => { let d = this.e(a, b, c); b = d.p1; c = d.p2; return d.ret; })()),
      p1: b
    };
  }
  e(a, b, c) {
    let d = a % this.b.length;
    if (this.a == null) {
      c = 0;
    }
    else {
      c = this.a[d];
    }
    b = this.c[d];
    return {
      ret: this.b[d],
      p1: b,
      p2: c
    };
  }
  *_j() {
    if (this.b == null) {
      return undefined;
    }
    let a = this.o;
    for (let b = 0; b < this.b.length; b++) {
      let c = this.b[b];
      if (c == null) {
        continue;
      }
      let d = this.c[b];
      for (let e = 0; e < d; e++) {
        yield c[e].a;
        if (a != this.o) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CollectionModifiedWhileEnumerating"));
        }
      }
    }
  }
  j() {
    return toEnum(() => this._j()).getEnumerator();
  }
  u(a) {
    let b = false;
    if (a) {
      for (let c = 0; c < this.c.length; c++) {
        let d = this.b[c];
        let e = this.c[c];
        for (let f = 0; f < e; f++) {
          let g = d[f];
          if (g.b != g.a.getHashCode()) {
            b = true;
            break;
          }
        }
        if (b) {
          break;
        }
      }
      if (b) {
        let h = this.c;
        let i = this.b;
        this.s(i.length);
        let j;
        for (let k = 0; k < h.length; k++) {
          let l = i[k];
          let m = h[k];
          for (let n = 0; n < m; n++) {
            let o = l[n];
            let p = this.f(o.a, j);
            j = p.p1;
          }
        }
      }
    }
    this.a = new Array(this.c.length);
    this.h = true;
    let q = 0;
    for (let r = 0; r < this.c.length; r++) {
      this.a[r] = q;
      q += this.c[r];
    }
  }
  t() {
    this.a = null;
    this.h = false;
  }
  i(a) {
    if (this.h) {
      return false;
    }
    if (this.b == null) {
      return false;
    }
    if (a == null) {
      return false;
    }
    let b = HashHelpers.d(a);
    let c = b % this.b.length;
    let d = this.b[c];
    if (d != null) {
      let e = new GenericElementHashSet_Entry$1(this.$t);
      let f = this.c[c];
      for (let g = 0; g < f; g++) {
        let h = d[g];
        if (h.b == b && h.a.equals(a)) {
          f--;
          this.c[c] = f;
          if (g < f) {
            arrayCopy1(d, g + 1, d, g, f - g);
          }
          d[f] = e;
          this.l--;
          this.o++;
          return true;
        }
      }
    }
    return false;
  }
  static q($t, a, b, c, d) {
    if (c < b.length) {
      return {
        p1: b
      };
    }
    let e = new Array(b.length * 2);
    arrayCopy2(b, e, c);
    let f = new GenericElementHashSet_Entry$1($t);
    for (let g = c; g < e.length; g++) {
      e[g] = f;
    }
    a[d] = e;
    b = e;
    return {
      p1: b
    };
  }
  n(a) {
    return truncate(Math.ceil(a * this.k / 2)) + 1;
  }
  r() {
    let a = this.b.length * 2;
    if (a < 0) {
      a = this.b.length + 1;
    }
    let b = HashHelpers.c(a);
    if (b <= this.b.length) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_HashSetFull"));
    }
    let c = new Array(b);
    let d = new Array(b);
    for (let e = 0; e < d.length; e++) {
      d[e] = 0;
    }
    for (let f = 0; f < this.b.length; f++) {
      let g = this.b[f];
      if (g == null) {
        continue;
      }
      let h = this.c[f];
      for (let i = 0; i < h; i++) {
        let j = g[i];
        let k = j.b % b;
        let l = c[k];
        if (l == null) {
          l = new Array(this.n(c.length));
          let m = new GenericElementHashSet_Entry$1(this.$t);
          for (let n = 0; n < l.length; n++) {
            l[n] = m;
          }
          c[k] = l;
        }
        let o = d[k];
        let p = GenericElementHashSet$1.q(this.$t, c, l, o, k);
        l = p.p1;
        l[o++] = j;
        d[k] = o;
      }
      this.b[f] = null;
    }
    this.b = c;
    this.c = d;
  }
  get m() {
    return this.l;
  }
}
GenericElementHashSet$1.$t = markType(GenericElementHashSet$1, 'GenericElementHashSet$1');
/**
 * @hidden
 */
export class GenericElementHashSet_Entry$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.b = 0;
    this.a = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
}
GenericElementHashSet_Entry$1.$t = markStruct(GenericElementHashSet_Entry$1, 'GenericElementHashSet_Entry$1');
/**
 * @hidden
 */
export class HashHelpers extends Base {
  static c(a) {
    for (let b = 0; b < HashHelpers.a.length; b++) {
      let c = HashHelpers.a[b];
      if (c >= a) {
        return c;
      }
    }
    for (let d = a | 1; d < 2147483647; d += 2) {
      if (HashHelpers.b(d)) {
        return d;
      }
    }
    return a;
  }
  static d(a) {
    return Base.getHashCodeStatic(a) & 2147483647;
  }
  static b(a) {
    if ((a & 1) == 0) {
      return (a == 2);
    }
    let b = truncate(Math.sqrt(a));
    for (let c = 3; c <= b; c += 2) {
      if ((a % c) == 0) {
        return false;
      }
    }
    return true;
  }
}
HashHelpers.$t = markType(HashHelpers, 'HashHelpers');
HashHelpers.a = [3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369];
/**
 * Represents a column in a Microsoft Excel worksheet.
 */
export class WorksheetColumn extends RowColumnBase {
  constructor(a, b) {
    super(a);
    this._ap = 0;
    this._an = 0;
    this._ai = 0;
    this._al = null;
    this._ap = b;
    this._an = a._columns$i._k;
  }
  /**
   * @hidden
   */
  get__a() {
    return WorksheetColumn._ae;
  }
  /**
   * @hidden
   */
  get _a() {
    return this.get__a();
  }
  /**
   * @hidden
   */
  _h(a) {
    return new WorksheetColumnOwnedFormatProxy(a, this);
  }
  /**
   * @hidden
   */
  _getAdjacentFormatForBorderResolution(a, b) {
    switch (b) {
      case 67108864:
      case 134217728:
      case 2:
      case 4: return null;
      case 262144:
      case 524288:
        if (this.index == 0) {
          return null;
        }
        return this.worksheet._cb((this._aq - 1)).b;
      case 2097152:
      case 4194304:
        if (this.index == this.worksheet._columns$i.maxCount - 1) {
          return null;
        }
        return this.worksheet._cb((this._aq + 1)).b;
      default: return null;
    }
  }
  /**
   * @hidden
   */
  get__l() {
    let a = this.index;
    if (a < 0) {
      return false;
    }
    let b = this.worksheet;
    if (b == null) {
      return false;
    }
    return b._cb(a).i;
  }
  /**
   * @hidden
   */
  set__l(a) {
    if (this.hidden == a) {
      return;
    }
    this._ad();
    this._ak();
    this.worksheet._cb(this.index).i = a;
    this._aj();
  }
  /**
   * @hidden
   */
  get _l() {
    return this.get__l();
  }
  /**
   * @hidden
   */
  set _l(a) {
    this.set__l(a);
  }
  /**
   * Gets the 0-based index of the column in the worksheet.
   * The 0-based index of the column in the worksheet.
   */
  get_index() {
    let a = this.worksheet;
    if (a == null || this._am(1)) {
      return -1;
    }
    let b = a._columns$i;
    let c = b._k;
    if (c != this._an) {
      let d = b._q(this._ap, this._an);
      this._an = c;
      if (d < 0) {
        this._a4();
        return -1;
      }
      this._ap = d;
    }
    return this._ap;
  }
  /**
   * Gets the 0-based index of the column in the worksheet.
   * The 0-based index of the column in the worksheet.
   */
  get index() {
    return this.get_index();
  }
  /**
   * @hidden
   */
  _onCellFormatValueChanging(a, b) {
    let c = this.worksheet;
    if (c != null && !c._t) {
      if (WorksheetRow._bs(b) && c._dz(true)) {
        let d = WorksheetElementResizeContext.m(c, 0, c._rows$i.maxCount - 1, (e) => !e._bz);
        this._al = WorksheetElementResizeContext.d(c, d, true, c.defaultRowHeight);
      }
    }
    super._onCellFormatValueChanging(a, b);
  }
  /**
   * @hidden
   */
  _onCellFormatValueChanged(a, b, c) {
    let d = this.worksheet;
    if (d == null || d._t) {
      return;
    }
    if (WorksheetRow._bs(b)) {
      for (let e of fromEnum(d._rows$i)) {
        e._dx(false);
      }
    }
    let f = this.index;
    for (let g = 1; g != 1073741824; g = (g << 1)) {
      if ((b & g) == 0) {
        continue;
      }
      if (this._cellFormatInternal._aa(g)) {
        continue;
      }
      let h = a._aj(g);
      let t1 = g;
      L0: while (true) {
        switch (t1) {
          case 262144:
          case 524288:
          case 2097152:
          case 4194304:
            {
              let i = ExcelUtils.o(g);
              let j = Nullable$1.toNullable(Number_$type, null);
              if (g == 262144 || g == 524288) {
                if (0 < f) {
                  j = Nullable$1.toNullable(Number_$type, (f - 1));
                }
              }
              else {
                let k = d._columns$i.maxCount - 1;
                if (f < k) {
                  j = Nullable$1.toNullable(Number_$type, (f + 1));
                }
              }
              if (j.hasValue && (c & 1) == 0) {
                let l = d._columns$i.item(j.value);
                ExcelUtils.gc(a, l._cellFormatInternal, g, h, c);
              }
              for (let m of fromEnum(d._rows$i)) {
                let n = m.getCellAssociatedMergedCellsRegion(this.index);
                if (n != null && n._ad != 1) {
                  continue;
                }
                let o = WorksheetColumn._ah(m, f, g);
                if (o != null) {
                  o._bl(g, h, true, c);
                  continue;
                }
                if ((c & 1) != 0) {
                  continue;
                }
                if (j.hasValue) {
                  o = WorksheetColumn._ah(m, j.value, i);
                  if (o != null && o._aj(i) != h) {
                    o._as(i, 1);
                    o._as(ExcelUtils.m(i), 1);
                  }
                }
              }
            }
            break;
          case 512:
          case 2048:
            d._ij();
            t1 = void 0;
            continue L0;
          default:
            let p = false;
            let q = false;
            let r = 1;
            if (g == 16) {
              r = EnumUtil.getEnumValue(DiagonalBorders_$type, h);
              let s = a.d._ax;
              p = ExcelUtils.a0(r) == false && ExcelUtils.a0(s);
              q = ExcelUtils.a1(r) == false && ExcelUtils.a1(s);
            }
            if ((c & 8) != 0) {
              break;
            }
            for (let t of fromEnum(d._rows$i)) {
              let u = WorksheetColumn._ah(t, f, g);
              if (u == null) {
                continue;
              }
              let v = t.getCellAssociatedMergedCellsRegion(this.index);
              if (v != null && v._ad != 1) {
                continue;
              }
              let w = h;
              if (g == 16) {
                let x = r | u.diagonalBorders;
                if (p) {
                  let y = ExcelUtils.f0(x);
                  x = y.p0;
                }
                if (q) {
                  let z = ExcelUtils.f1(x);
                  x = z.p0;
                }
                w = enumGetBox(DiagonalBorders_$type, x);
              }
              u._bk(g, w);
            }
            break;
        }
        break;
      }
    }
    if (this._al != null) {
      let aa = this._al;
      this._al = null;
      let ab = d.workbook;
      let ac = ab._df;
      ab._df = true;
      try {
        aa.y();
      }
      finally {
        ab._df = ac;
      }
    }
  }
  /**
   * @hidden
   */
  get__n() {
    let a = this.index;
    if (a < 0) {
      return 0;
    }
    let b = this.worksheet;
    if (b == null) {
      return 0;
    }
    return b._cb(a).m;
  }
  /**
   * @hidden
   */
  set__n(a) {
    if (this.outlineLevel == a) {
      return;
    }
    this._ad();
    this._ak();
    this.worksheet._cb(this.index).m = a;
    this._aj();
  }
  /**
   * @hidden
   */
  get _n() {
    return this.get__n();
  }
  /**
   * @hidden
   */
  set _n(a) {
    this.set__n(a);
  }
  /**
   * @hidden
   */
  _ad() {
    if (this.worksheet == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_ColumnRemovedFromWorksheet"));
    }
  }
  autoFitWidth() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._autoFitWidth.apply(this, arguments);
      case 1: return this._autoFitWidth1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _autoFitWidth() {
    this.width = this._calculateAutoFitWidth();
  }
  /**
   * @hidden
   */
  _autoFitWidth1(a, b) {
    this.width = this._calculateAutoFitWidth1(a, b);
  }
  calculateAutoFitWidth() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._calculateAutoFitWidth.apply(this, arguments);
      case 1: return this._calculateAutoFitWidth1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _calculateAutoFitWidth() {
    let a = this.worksheet;
    return this._calculateAutoFitWidth1(0, a != null ? a._rows$i.maxCount - 1 : 1048576 - 1);
  }
  /**
   * @hidden
   */
  _calculateAutoFitWidth1(a, b) {
    let c = this.worksheet;
    if (c == null || c.workbook == null) {
      throw new InvalidOperationException(0);
    }
    let d = c.workbook;
    {
      let e = Workbook._fc(d);
      try {
        let f = d._ab;
        return (((g) => !nullableIsNull(g) ? g.value : this.width)(this._ay(a, b, f)));
      }
      finally {
        if (e != null) {
          e.dispose();
        }
      }
    }
  }
  /**
   * Gets the column width in the specified units, or NaN if the column has the default width.
   * <p class="body">
   * If 'units' is Character256th, the value returned will be the same as the value of the [[width]]
   * property, with one exception: if the column has the default width, this method will return NaN and Width will return -1.
   * </p>
   * @param units The units in which the width should be returned.
   * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
   * @return The column width in the specified units, or NaN if the column has the default width.
   * @see [[width]]
   * @see [[setWidth]]
   * @see [[Worksheet.getDefaultColumnWidth]]
   */
  getWidth(units) {
    let a = this.worksheet;
    if (a == null) {
      return 0;
    }
    return a._fl(this.width, units);
  }
  /**
   * Sets the column width in the specified units.
   * <p class="body">
   * Setting a value of NaN will reset the column width so that the column uses the default column width of the worksheet.
   * </p>
   * @param value The width to set on the column, expressed in the specified 'units'.
   * @param units The units in which the 'value' is expressed.
   * @throws [[ArgumentException]] 'value' is infinity.
   * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
   * @throws [[InvalidOperationException]] If the column was removed from the worksheet.
   * @see [[width]]
   * @see [[getWidth]]
   * @see [[Worksheet.setDefaultColumnWidth]]
   */
  setWidth(value, units) {
    this._ad();
    this.width = this.worksheet._fw(value, units);
  }
  /**
   * @hidden
   */
  _ay(a, b, c) {
    let d = this.worksheet;
    if (d == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (a < 0) {
      throw new ArgumentOutOfRangeException(0);
    }
    else if (a > b) {
      throw new ArgumentOutOfRangeException(0);
    }
    else if (b > d._rows$i.maxCount - 1) {
      throw new ArgumentOutOfRangeException(0);
    }
    let e = 0;
    let f = this.index;
    let g = d._gb(f);
    let h = truncate(Math.floor(this.worksheet._g0 * 0.35));
    let i = truncate(this.worksheet._fl(g, 3));
    let j = i - d._ge() - h;
    let k = new GetCellTextParameters(f);
    k.b = 1;
    k.a = 0;
    k.c = true;
    let l = d.workbook;
    let m = false;
    let n = this.index;
    let o = new WorksheetRegionAddress(1, a, b, n, n);
    for (let p of fromEnum(d._conditionalFormats$i)) {
      if (typeCast(IconSetConditionalFormat.$, p) !== null) {
        for (let q of fromEnum(p.regions)) {
          if (q._h._j(o)) {
            m = true;
            break;
          }
        }
        if (m) {
          break;
        }
      }
    }
    let r = 17;
    let s = d.filterSettings.region != null && d.filterSettings.region._h._j(o) ? d.filterSettings.region.firstRow : -1;
    let t = new HashSet$1(Number_$type, 0);
    if (d.filterSettings.region != null && d.filterSettings.region._h._j(o)) {
      t.add_1(d.filterSettings.region.firstRow);
    }
    for (let u of fromEnum(d._tables$i)) {
      if (u.isHeaderRowVisible && u.isFilterUIVisible && o._i(u._by._ac, n)) {
        t.add_1(u._by._ac);
      }
    }
    for (let v of fromEnum(d._rows$i._m(a, b))) {
      let w = v._a2(f);
      if (w != null && w.j(f)) {
        let x = v._bl(f);
        if (x == null || x._ad == 1) {
          let y = v._aw(w, k).g;
          if (!stringIsNullOrEmpty(y)) {
            let z = v._a7(f);
            let aa = (z._cm + z._cn) * this.worksheet._gl;
            let ab = j - aa;
            let ac = v._ct(true);
            let ad = Math.ceil(c.e(z, y, ac, ab) + aa);
            if (m) {
              let ae = d._getCellConditionalFormat1(v.index, f);
              ad += ExcelUtils.dc(ae, z);
            }
            if (t.contains(v.index)) {
              ad += r;
            }
            if (ad > e) {
              e = ad;
            }
          }
        }
      }
    }
    if (e == 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    e += i - j;
    let af = 91;
    if (e >= af) {
      let ag = truncate(((e - af) / 28 + 1));
      e = MathUtilities.f(e + ag);
    }
    return Nullable$1.toNullable(Number_$type, this.worksheet._fw(e, 3));
  }
  /**
   * @hidden
   */
  _a1(a) {
  }
  /**
   * @hidden
   */
  _a2(a, b) {
    let c = this.worksheet;
    if (a < 0) {
      this._a5(1, true);
    }
    else {
      this._ap = a;
    }
    this._an = c != null ? c._columns$i._k : 0;
  }
  /**
   * @hidden
   */
  _aj() {
    let a = this.worksheet;
    if (a == null) {
      return null;
    }
    return a._cd(this.index);
  }
  /**
   * @hidden
   */
  _ak() {
    let a = this.worksheet;
    if (a == null) {
      return null;
    }
    return a._cc(this.index, this._ap);
  }
  /**
   * @hidden
   */
  _a3(a, b) {
    this._an = b;
    this._t(a);
    this._a5(1, false);
  }
  /**
   * @hidden
   */
  _a4() {
    this._an = 0;
    this._a5(1, true);
    this._t(null);
  }
  /**
   * @hidden
   */
  static _ag($tValue, a, b, c, d = null, e = true, f = false, g = 0) {
    return new ChangeInfo$2(WorksheetColumn.$, $tValue, a, 26, b, c, d, e, g, f, (h) => h._ap, null);
  }
  /**
   * @hidden
   */
  static _af() {
    let a = new Array(3);
    RowColumnBase._z(a, 26);
    ChangeInfo.f(a, 2, WorksheetColumn._ag(Number_$type, "Width", (b) => b.width, (b, c) => b.width = c, (b, c) => b._a7(c)));
    return a;
  }
  /**
   * @hidden
   */
  static _ah(a, b, c) {
    let d = a._bd(b);
    if (d != null) {
      return d;
    }
    if (a._hasCellFormat) {
      return a._bc(b);
    }
    return null;
  }
  /**
   * @hidden
   */
  _am(a) {
    return (this._ai & a) == a;
  }
  /**
   * @hidden
   */
  _a5(a, b) {
    if (b) {
      this._ai |= a;
    }
    else {
      this._ai &= ~a;
    }
  }
  /**
   * Gets or sets the column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * <p class="body">
   * If the width of the column is less than zero, the [[Worksheet.defaultColumnWidth]] of the
   * owning worksheet will be used as the column's width.
   * </p>
   * <p class="body">
   * The value assigned must be between -1 and 65535. Invalid values will be automatically adjusted to valid values.
   * </p>
   * <p class="body">
   * Setting or getting this property is equivalent to calling [[setWidth]] or [[getWidth]] using the
   * [[WorksheetColumnWidthUnit]] value of Character256th.
   * </p>
   * The column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * @throws [[InvalidOperationException]] From the setter if the column was removed from the worksheet.
   * @see [[getWidth]]
   * @see [[setWidth]]
   * @see [[Workbook.characterWidth256thsToPixels]]
   * @see [[Workbook.pixelsToCharacterWidth256ths]]
   */
  get width() {
    if (this.hidden) {
      return 0;
    }
    let a = this.worksheet;
    if (a == null) {
      return 0;
    }
    let b = this.index;
    if (b < 0) {
      return 0;
    }
    return a._cb(b).v;
  }
  /**
   * Gets or sets the column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * <p class="body">
   * If the width of the column is less than zero, the [[Worksheet.defaultColumnWidth]] of the
   * owning worksheet will be used as the column's width.
   * </p>
   * <p class="body">
   * The value assigned must be between -1 and 65535. Invalid values will be automatically adjusted to valid values.
   * </p>
   * <p class="body">
   * Setting or getting this property is equivalent to calling [[setWidth]] or [[getWidth]] using the
   * [[WorksheetColumnWidthUnit]] value of Character256th.
   * </p>
   * The column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
   * @throws [[InvalidOperationException]] From the setter if the column was removed from the worksheet.
   * @see [[getWidth]]
   * @see [[setWidth]]
   * @see [[Workbook.characterWidth256thsToPixels]]
   * @see [[Workbook.pixelsToCharacterWidth256ths]]
   */
  set width(a) {
    this._ad();
    if (a == 0) {
      this.hidden = true;
      return;
    }
    if (this.width != a) {
      WorksheetColumn._ae[2].h(WorksheetColumn.$, Number_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  _a7(a) {
    this._ad();
    if (a < -1) {
      a = -1;
    }
    if (65535 < a) {
      a = 65535;
    }
    let b = null;
    if (this.worksheet._dz(false)) {
      b = WorksheetElementResizeContext.b(this);
    }
    this._ak();
    let c = this.worksheet._cb(this.index);
    c.v = a;
    c.j = this.width >= 0;
    if (this._l) {
      c.i = false;
      this._y();
    }
    this._aj();
    if (b != null) {
      b.y();
    }
  }
  /**
   * @hidden
   */
  get _at() {
    if (this._am(1)) {
      return this._ap;
    }
    return this.index;
  }
  /**
   * @hidden
   */
  get _aq() {
    return this._ap;
  }
  /**
   * @hidden
   */
  get__m() {
    return this._am(1);
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * @hidden
   */
  get workbook() {
    let a = this.worksheet;
    return a != null ? a.workbook : null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
  /**
   * @hidden
   */
  getRegionAddress() {
    let a = this.worksheet;
    return a != null ? new WorksheetRegionAddress(1, 0, a._rows$i.maxCount - 1, this.index, this.index) : WorksheetRegionAddress._b;
  }
}
WorksheetColumn.$t = markType(WorksheetColumn, 'WorksheetColumn', RowColumnBase.$, [IChangeInfoContext_$type, IWorksheetRegionAddressContext_$type]);
/**
 * @hidden
 */
WorksheetColumn._ax = 2;
/**
 * @hidden
 */
WorksheetColumn._av = 2 + 1;
/**
 * @hidden
 */
WorksheetColumn._au = 65535;
/**
 * @hidden
 */
WorksheetColumn._ae = WorksheetColumn._af();
/**
 * A collection of hidden [[WorksheetColumn]] instances.
 * <p class="body">
 * The columns in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the columns in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other columns in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenColumns]]
 */
export class HiddenColumnCollection extends Base {
  constructor(a, b) {
    super();
    this._d = null;
    this._a = null;
    this._c = null;
    this._d = a;
    this._a = b;
    this._c = new SortedIntRangeList();
  }
  /**
   * @hidden
   */
  add(item) {
    this.add_1(item);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    for (let a of fromEnum(this._c.c())) {
      array[arrayIndex++] = this._d._columns$i.item(a);
    }
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    for (let a of fromEnum(this._c.c())) {
      yield this._d._columns$i.item(a);
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a column to the collection.
   * <p class="body">
   * This collection does not allow duplicate values. If the specified column already exists in the collection,
   * nothing will happen. This collection also keeps itself sorted, so the column added will not necessarily be
   * added at the end of the collection.
   * </p>
   * @throws [[ArgumentNullException]] 'column' is null.
   * @throws [[ArgumentException]] 'column' does not belong to the same worksheet this collection is associated with.
   * @param column The column to be added to the hidden columns collection.
   */
  add_1(column) {
    if (column == null) {
      throw new ArgumentNullException(2, "column", ExcelUtils.ef("LE_ArgumentNullException_HiddenColumn"));
    }
    if (column.worksheet != this._d) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ColumnFromDifferentWorksheet"), "column");
    }
    this._k(column.index);
  }
  /**
   * Clears all columns from the collection.
   */
  clear() {
    this._c.o();
  }
  /**
   * Determines whether the specified column exists in the collection.
   * @param column The column to search for in the collection.
   * @return True if the column exists in the collection; False otherwise or if the specified column is null.
   */
  contains(column) {
    if (column == null) {
      return false;
    }
    return this._c.a(column.index);
  }
  /**
   * Removes the specified column from the collection if it exists.
   * @param column The column to removed from the collection.
   * @return True if the column existed in the collection and was removed; False otherwise or if the
   * specified column is null.
   */
  remove_1(column) {
    if (column == null) {
      return false;
    }
    return this._c.b(column.index);
  }
  /**
   * Removes the column at the specified index in the collection.
   * @param index The zero-based index of the column in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._c.p(index);
  }
  /**
   * @hidden
   */
  _l(a, b) {
    this._c.n(a, b);
  }
  /**
   * @hidden
   */
  _b() {
    if (this.count == 0) {
      return null;
    }
    let a = new StringBuilder(2, "=");
    for (let b = 0; b < this._c.k; b++) {
      let c = this._c.i(b);
      let d = this._c.h(b);
      a.s("{0}C{1}:C{2},", ExcelUtils.d5(null, this._d.name), c + 1, d + 1);
    }
    a.y(a.c - 1, 1);
    let e;
    let f;
    if (((() => { let g = Formula._a0(a.toString(), 0, 3, this.worksheet._o, CultureInfo.invariantCulture, null, e, f); e = g.p6; f = g.p7; return g.ret; })()) == false) {
      return null;
    }
    let g = stringFormat2(CultureInfo.invariantCulture, "Z_{0}_.wvu.Cols", stringToLocaleUpper(stringReplace(this._a._t.toString2("D"), "-", "_"), CultureInfo.invariantCulture));
    let h = new NamedReference(1, this._d.workbook._namedReferences$i, this._d, true);
    h.name = g;
    h._j = e;
    return h;
  }
  /**
   * @hidden
   */
  _n(a) {
    for (let b of fromEnum(a._ff)) {
      if (b.i) {
        for (let c = b.q; c <= b.r; c++) {
          this.add_1(a._columns$i.item(c));
        }
      }
    }
  }
  /**
   * @hidden
   */
  _k(a) {
    this._c.m(a);
  }
  /**
   * Gets the number of columns in the collection.
   * The number of columns in the collection.
   */
  get count() {
    return this._c.j;
  }
  /**
   * Gets the column at the specified index.
   * The column at the specified index.
   * @param index The zero-based index of the column to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._d._columns$i.item(this._c.l(a).value);
  }
  /**
   * Gets the worksheet associated with this collection.
   * The worksheet associated with this collection.
   */
  get worksheet() {
    return this._d;
  }
}
HiddenColumnCollection.$t = markType(HiddenColumnCollection, 'HiddenColumnCollection', Base.$, [ICollection$1_$type.specialize(WorksheetColumn.$)]);
/**
 * A collection of hidden [[WorksheetRow]] instances.
 * <p class="body">
 * The rows in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the rows in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other rows in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenRows]]
 */
export class HiddenRowCollection extends Base {
  constructor(a, b) {
    super();
    this._d = null;
    this._a = null;
    this._c = null;
    this._d = a;
    this._a = b;
    this._c = new SortedIntRangeList();
  }
  /**
   * @hidden
   */
  add(item) {
    this.add_1(item);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    for (let a of fromEnum(this._c.c())) {
      array[arrayIndex++] = this._d._rows$i.item(a);
    }
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    for (let a of fromEnum(this._c.c())) {
      yield this._d._rows$i.item(a);
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a row to the collection.
   * <p class="body">
   * This collection does not allow duplicate values. If the specified row already exists in the collection,
   * nothing will happen. This collection also keeps itself sorted, so the row added will not necessarily be
   * added at the end of the collection.
   * </p>
   * @throws [[ArgumentNullException]] 'row' is null.
   * @throws [[ArgumentException]] 'row' does not belong to the same worksheet this collection is associated with.
   * @param row The row to be added to the hidden rows collection.
   */
  add_1(row) {
    if (row == null) {
      throw new ArgumentNullException(2, "row", ExcelUtils.ef("LE_ArgumentNullException_HiddenRow"));
    }
    if (row.worksheet != this._d) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RowFromDifferentWorksheet"), "row");
    }
    this._k(row.index);
  }
  /**
   * Clears all rows from the collection.
   */
  clear() {
    this._c.o();
  }
  /**
   * Determines whether the specified row exists in the collection.
   * @param row The row to search for in the collection.
   * @return True if the row exists in the collection; False otherwise or if the specified row is null.
   */
  contains(row) {
    if (row == null) {
      return false;
    }
    return this._c.a(row.index);
  }
  /**
   * Removes the specified row from the collection if it exists.
   * @param row The row to removed from the collection.
   * @return True if the row existed in the collection and was removed; False otherwise or if the
   * specified row is null.
   */
  remove_1(row) {
    if (row == null) {
      return false;
    }
    return this._c.b(row.index);
  }
  /**
   * Removes the row at the specified index in the collection.
   * @param index The zero-based index of the row in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._c.p(index);
  }
  /**
   * @hidden
   */
  _l(a, b) {
    this._c.n(a, b);
  }
  /**
   * @hidden
   */
  _b() {
    if (this.count == 0) {
      return null;
    }
    let a = new StringBuilder(2, "=");
    for (let b = 0; b < this._c.k; b++) {
      let c = this._c.i(b);
      let d = this._c.h(b);
      a.s("{0}R{1}:R{2},", ExcelUtils.d5(null, this._d.name), c + 1, d + 1);
    }
    a.y(a.c - 1, 1);
    let e;
    let f;
    if (((() => { let g = Formula._a0(a.toString(), 0, 3, this.worksheet._o, CultureInfo.invariantCulture, null, e, f); e = g.p6; f = g.p7; return g.ret; })()) == false) {
      return null;
    }
    let g = stringFormat2(CultureInfo.invariantCulture, "Z_{0}_.wvu.Rows", stringToLocaleUpper(stringReplace(this._a._t.toString2("D"), "-", "_"), CultureInfo.invariantCulture));
    let h = new NamedReference(1, this._d.workbook._namedReferences$i, this._d, true);
    h.name = g;
    h._j = e;
    return h;
  }
  /**
   * @hidden
   */
  _n(a) {
    if (a._dv) {
      for (let b = 0; b < a.workbook.maxRowCount - 1; b++) {
        let c = a._rows$i._aj(b);
        if (c == null || c.hidden) {
          this._k(b);
        }
      }
    }
    else {
      for (let d of fromEnum(a._rows$i)) {
        if (d.hidden) {
          this.add_1(d);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _k(a) {
    this._c.m(a);
  }
  /**
   * Gets the number of rows in the collection.
   * The number of rows in the collection.
   */
  get count() {
    return this._c.j;
  }
  /**
   * Gets the row at the specified index.
   * The row at the specified index.
   * @param index The zero-based index of the row to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._d._rows$i.item(this._c.l(a).value);
  }
  /**
   * Gets the worksheet associated with this collection.
   * The worksheet associated with this collection.
   */
  get worksheet() {
    return this._d;
  }
}
HiddenRowCollection.$t = markType(HiddenRowCollection, 'HiddenRowCollection', Base.$, [ICollection$1_$type.specialize(WorksheetRow.$)]);
/**
 * @hidden
 */
export let IFormattedTextOwner_$type = new Type(null, 'IFormattedTextOwner', null, [ISheetProvider_$type]);
/**
 * @hidden
 */
export class SheetCollection_ChangeInfoContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
        }
        break;
    }
  }
  get workbook() {
    return this.a;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.a;
  }
}
SheetCollection_ChangeInfoContext.$t = markStruct(SheetCollection_ChangeInfoContext, 'SheetCollection_ChangeInfoContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of sheets in a workbook.
 * @see [[Sheet]]
 * @see [[Worksheet]]
 * @see@see */
export class SheetCollection extends Base {
  constructor(a) {
    super();
    this._i = new SheetCollection_ChangeInfoContext();
    this._n = null;
    this._j = null;
    this._i = new SheetCollection_ChangeInfoContext(1, a);
    this._j = a;
    this._n = new List$1(Sheet.$, 0);
  }
  static staticInit() {
    SheetCollection._a = SheetCollection._b();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddWorksheet"));
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._n.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._n.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  insert(index, item) {
    throw new NotSupportedException(0);
  }
  item() {
    if (arguments.length === 2) {
      return this._item$e.apply(this, arguments);
    }
    else {
      let n;
      if (arguments.length === 1) {
        if (typeof arguments[0] === 'number') {
          n = 0;
        }
        else if (typeof arguments[0] === 'string') {
          n = 1;
        }
        else if (arguments[0] == null) {
          n = 1;
        }
      }
      switch (n) {
        case 0: return this._item.apply(this, arguments);
        case 1: return this._item1.apply(this, arguments);
        default: throw new Error('Invalid arguments');
      }
    }
  }
  /**
   * @hidden
   */
  _item$e(a, b) {
    if (arguments.length === 2) {
      throw new NotSupportedException(0);
      return b;
    }
    else {
      return this._item(a);
    }
  }
  /**
   * @hidden
   */
  _add1(a, b) {
    return this._add2(a, this._j._g2(), b);
  }
  /**
   * @hidden
   */
  _add2(a, b, c) {
    return this._insert1(this._n.count, a, b, c);
  }
  /**
   * Clears all sheets from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with a worksheet for a scope, they will be removed from the [[Workbook]].
   * </p>
   */
  clear() {
    for (let a = this._n.count - 1; a >= 0; a--) {
      this._w(a, false);
    }
    this._j._worksheets$i._n();
  }
  /**
   * @hidden
   */
  _t() {
    let a = false;
    for (let b = this._n.count - 1; b >= 0; b--) {
      let c = this._n._inner[b];
      if (c.type == 0) {
        a = true;
        this._w(b, false);
      }
    }
  }
  /**
   * Determines whether a sheet is in the collection.
   * @param sheet The sheet to locate in the collection.
   * @return True if the sheet is found; False otherwise.
   */
  contains(sheet) {
    return this._n.contains(sheet);
  }
  /**
   * Determines whether a sheet with the specified name exists in the collection.
   * @param name The name of the sheet to search for. The name is compared case-insensitively.
   * @return True if a sheet with the specified name is found; False otherwise.
   */
  exists(name) {
    for (let a of fromEnum(this._n)) {
      if (StringUtilities.c(a.name, name, this._j._e6, 1) == 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the index of the specified sheet in the collection.
   * @param sheet The sheet of which to get the index.
   * @return The index of the specified sheet in the collection.
   * @see [[Sheet.sheetIndex]]
   */
  indexOf(sheet) {
    return this._n.indexOf(sheet);
  }
  /**
   * @hidden
   */
  _insert1(a, b, c, d) {
    Sheet._aw(b, "name");
    this._j._jd(null, b, "name");
    let e;
    switch (d) {
      case 0:
        e = new Worksheet(b, this._j, c);
        break;
      case 1:
        if (!this._j._c4) {
          this._j._i9();
        }
        e = new Chartsheet(b, this._j, c);
        break;
      default: throw new InvalidEnumArgumentException("type", d, SheetType_$type);
    }
    this._u(e, a);
    return e;
  }
  /**
   * @hidden
   */
  _u(a, b) {
    this._n.insert(b, a);
    if (a.type == 0) {
      this._j._worksheets$i._n();
    }
    let c = a._ag;
    this._j._h4(a);
    SheetCollection._a[0].e(SheetCollection_ChangeInfoContext.$, Sheet.$, this._i, null, a);
  }
  /**
   * @hidden
   */
  _v(a, b) {
    let c = this._n._inner[a];
    let d = c._ag;
    this._n.removeAt(a);
    if (c.type == 0) {
      this._j._worksheets$i._n();
    }
    this._n.insert(b, c);
    if (c.type == 0) {
      this._j._worksheets$i._n();
    }
    let e = c._ag;
    this._j._h5(c, d);
  }
  /**
   * Removes the specified sheet from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
   * </p>
   * @param sheet The sheet to remove from the collection.
   * @return True if the sheet was successfully removed from the collection;
   * False if the sheet did not exist in the collection.
   */
  remove_1(sheet) {
    let a = this._n.indexOf(sheet);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the sheet at the specified index from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
   * </p>
   * @param index The index of the sheet to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._w(index, true);
  }
  /**
   * @hidden
   */
  _w(a, b) {
    let c = this._n._inner[a];
    let d = c._ag;
    this._n.removeAt(a);
    if (c.type == 0) {
      this._j._worksheets$i._n();
    }
    this._j._h7(c);
    c._aq();
    this._j._h6(c, d);
    SheetCollection._a[1].e(SheetCollection_ChangeInfoContext.$, Sheet.$, this._i, c, null);
  }
  /**
   * @hidden
   */
  _x(a, b) {
    for (let c of fromEnum(this)) {
      c._av(a, b);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c = 8192) {
    return new ChangeInfo$2(SheetCollection_ChangeInfoContext.$, $tValue, a, b, null, null, null, false, c, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, SheetCollection._c(Sheet.$, "Add", 91));
    ChangeInfo.f(a, 1, SheetCollection._c(Sheet.$, "Remove", 92));
    return a;
  }
  /**
   * Gets the number of sheets in the collection.
   * The number of sheets in the collection.
   */
  get count() {
    return this._n.count;
  }
  /**
   * @hidden
   */
  _item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._n._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    for (let b of fromEnum(this._n)) {
      if (StringUtilities.c(b.name, a, this._j._e6, 1) == 0) {
        return b;
      }
    }
    throw new InvalidOperationException(1, ExcelUtils.ef("LER_Exception_KeyNotFound"));
  }
}
SheetCollection.$t = markType(SheetCollection, 'SheetCollection', Base.$, [IList$1_$type.specialize(Sheet.$)]);
/**
 * @hidden
 */
SheetCollection._o = 0;
/**
 * @hidden
 */
SheetCollection._r = 1;
/**
 * @hidden
 */
SheetCollection._q = 2;
/**
 * @hidden
 */
SheetCollection._a = null;
/**
 * @hidden
 */
export class SortedIntRangeList extends Base {
  constructor() {
    super();
    this.e = 0;
    this.d = null;
    this.d = new List$1(SortedIntRangeList_IntRange.$, 0);
    this.e = -1;
  }
  get j() {
    if (this.e == -1) {
      this.e = 0;
      for (let a = 0; a < this.d.count; a++) {
        this.e += this.d._inner[a].a;
      }
    }
    return this.e;
  }
  get k() {
    return this.d.count;
  }
  m(a) {
    this.n(a, a);
  }
  n(a, b) {
    let c = this.g(a - 1);
    let d = this.g(b + 1);
    if (c == d) {
      if (c < 0) {
        let e = ~c;
        this.d.insert(e, new SortedIntRangeList_IntRange(1, a, b));
      }
    }
    else {
      if (c < 0) {
        c = ~c;
      }
      else {
        a = this.d._inner[c].c;
      }
      if (d < 0) {
        d = ~d - 1;
      }
      else {
        b = this.d._inner[d].b;
      }
      if (c == this.d.count) {
        this.d.add(new SortedIntRangeList_IntRange(1, a, b));
      }
      else {
        let f = this.d._inner[c];
        f.c = a;
        f.b = b;
        this.d._inner[c] = f;
        for (let g = d; g > c; g--) {
          this.d.removeAt(g);
        }
      }
    }
    this.e = -1;
  }
  o() {
    this.d.clear();
    this.e = 0;
  }
  a(a) {
    return this.g(a) >= 0;
  }
  g(a) {
    let b = this.d;
    let c = 0, d = b.count - 1;
    let e = 0;
    while (c <= d) {
      e = intDivide((c + d), 2);
      let f = b._inner[e];
      if (f.c > a) {
        d = e - 1;
      }
      else if (f.b < a) {
        c = e + 1;
      }
      else {
        return e;
      }
    }
    return ~c;
  }
  l(a) {
    for (let b = 0, c = this.d.count; b < c; b++) {
      let d = this.d._inner[b];
      if (d.a > a) {
        return Nullable$1.toNullable(Number_$type, d.c + a);
      }
      a -= d.a;
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  i(a) {
    return this.d._inner[a].c;
  }
  h(a) {
    return this.d._inner[a].b;
  }
  *_c() {
    for (let a of fromEnum(this.d)) {
      for (let b = a.c; b <= a.b; b++) {
        yield b;
      }
    }
  }
  c() {
    return toEnum(() => this._c());
  }
  b(a) {
    let b = this.g(a);
    if (b < 0) {
      return false;
    }
    this.e = -1;
    let c = this.d._inner[b];
    if (c.a == 1) {
      this.d.removeAt(b);
    }
    else {
      if (c.c == a) {
        c.c++;
      }
      else if (c.b == a) {
        c.b--;
      }
      else {
        let d = c.b;
        c.b = a - 1;
        this.d.insert(b + 1, new SortedIntRangeList_IntRange(1, a + 1, d));
      }
      this.d._inner[b] = c;
    }
    return true;
  }
  p(a) {
    let b = this.l(a);
    if (b.hasValue) {
      this.b(b.value);
    }
  }
  q(a, b) {
    if (b < a) {
      let c = b;
      b = a;
      a = c;
    }
    let d = this.g(a);
    let e = this.g(b);
    if (d == e) {
      if (d < 0) {
        return;
      }
      let f = this.d._inner[d];
      if (f.c < a) {
        if (b < f.b) {
          this.d.insert(d + 1, new SortedIntRangeList_IntRange(1, b + 1, f.b));
        }
        f.b = a - 1;
        this.d._inner[d] = f;
      }
      else if (b == f.b) {
        this.d.removeAt(d);
      }
      else {
        f.c = b + 1;
        this.d._inner[d] = f;
      }
    }
    else {
      if (d >= 0 && this.d._inner[d].c < a) {
        let g = this.d._inner[d];
        g.b = a - 1;
        this.d._inner[d] = g;
        d++;
      }
      else if (d < 0) {
        d = ~d;
      }
      if (e >= 0 && this.d._inner[e].b > b) {
        let h = this.d._inner[e];
        h.c = b + 1;
        this.d._inner[e] = h;
        e--;
      }
      else if (e < 0) {
        e = ~e - 1;
      }
      if (d <= e) {
        this.d.v(d, (e - d) + 1);
      }
    }
    this.e = -1;
  }
}
SortedIntRangeList.$t = markType(SortedIntRangeList, 'SortedIntRangeList');
/**
 * @hidden
 */
export class SortedIntRangeList_IntRange extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.c = c;
          this.b = d;
        }
        break;
    }
  }
  get a() {
    return this.b - this.c + 1;
  }
  toString() {
    return stringFormat("{0}-{1}", this.c, this.b);
  }
}
SortedIntRangeList_IntRange.$t = markStruct(SortedIntRangeList_IntRange, 'SortedIntRangeList_IntRange');
/**
 * @hidden
 */
export let IWorkbookOwner_$type = new Type(null, 'IWorkbookOwner');
/**
 * @hidden
 */
export class WeakWorkbookOwner extends Base {
  constructor(a) {
    super();
    this.b = null;
    this.b = new WeakReference(a);
  }
  get a() {
    return typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
  }
  get isUndoEnabled() {
    let a = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    return a != null && a.isUndoEnabled;
  }
  onCellValueChange(a, b) {
    let c = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (c != null) {
      c.onCellValueChange(a, b);
    }
  }
  _onChange$2$i($tContext, $tValue, a, b, c, d, e) {
    let f = ExcelUtils.dy(this.b);
    if (f != null) {
      f._onChange$2$i($tContext, $tValue, a, b, c, d, e);
    }
  }
  onConditionalFormatChange(a) {
    let b = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (b != null) {
      b.onConditionalFormatChange(a);
    }
  }
  onCustomViewApplied(a) {
    let b = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (b != null) {
      b.onCustomViewApplied(a);
    }
  }
  onSheetRemoving(a) {
    let b = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (b != null) {
      b.onSheetRemoving(a);
    }
  }
  onTransactionalChangeBegin(a, b) {
    let c = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    return c != null ? c.onTransactionalChangeBegin(a, b) : null;
  }
  onTransactionalChangeEnd(a) {
    let b = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (b != null) {
      b.onTransactionalChangeEnd(a);
    }
  }
  onTransactionalChangeRollback(a) {
    let b = typeCast(IWorkbookOwner_$type, ExcelUtils.dy(this.b));
    if (b != null) {
      b.onTransactionalChangeRollback(a);
    }
  }
}
WeakWorkbookOwner.$t = markType(WeakWorkbookOwner, 'WeakWorkbookOwner', Base.$, [IWorkbookOwner_$type]);
/**
 * @hidden
 */
export class KnownBoxes extends Base {
  static al(a) {
    switch (a) {
      case -1: return KnownBoxes.f;
      case 0: return KnownBoxes.n;
      case 9: return KnownBoxes.c;
      case 11: return KnownBoxes.d;
      case 3: return KnownBoxes.e;
      case 4: return KnownBoxes.g;
      case 6: return KnownBoxes.h;
      case 7: return KnownBoxes.i;
      case 2: return KnownBoxes.j;
      case 10: return KnownBoxes.k;
      case 12: return KnownBoxes.l;
      case 8: return KnownBoxes.m;
      case 13: return KnownBoxes.o;
      case 5: return KnownBoxes.p;
      case 1: return KnownBoxes.q;
      default: return enumGetBox(CellBorderLineStyle_$type, a);
    }
  }
  static am(a) {
    switch (a) {
      case 0: return KnownBoxes.s;
      case 7: return KnownBoxes.r;
      case 3: return KnownBoxes.t;
      case 5: return KnownBoxes.u;
      case 1: return KnownBoxes.v;
      default: return enumGetBox(DiagonalBorders_$type, a);
    }
  }
  static au(a) {
    return unwrapNullable(a);
  }
  static an(a) {
    switch (a) {
      case -1: return KnownBoxes.ab;
      case 0: return KnownBoxes.ac;
      case 2: return KnownBoxes.ad;
      case 1: return KnownBoxes.ae;
      default: return enumGetBox(FontSuperscriptSubscriptStyle_$type, a);
    }
  }
  static ao(a) {
    switch (a) {
      case -1: return KnownBoxes.af;
      case 0: return KnownBoxes.ai;
      case 2: return KnownBoxes.ag;
      case 34: return KnownBoxes.ah;
      case 1: return KnownBoxes.aj;
      case 33: return KnownBoxes.ak;
      default: return enumGetBox(FontUnderlineStyle_$type, a);
    }
  }
  static ap(a) {
    switch (a) {
      case -1: return KnownBoxes.ax;
      case 0: return KnownBoxes.a0;
      case 1: return KnownBoxes.a2;
      case 2: return KnownBoxes.av;
      case 3: return KnownBoxes.a3;
      case 4: return KnownBoxes.az;
      case 5: return KnownBoxes.a1;
      case 6: return KnownBoxes.aw;
      case 7: return KnownBoxes.ay;
      default: return enumGetBox(HorizontalCellAlignment_$type, a);
    }
  }
  static at(a) {
    switch (a) {
      case -1: return KnownBoxes.a4;
      case 0: return KnownBoxes.a5;
      default: return a;
    }
  }
  static as(a) {
    switch (a) {
      case 0: return KnownBoxes.a6;
      case 1: return KnownBoxes.a7;
      case 2: return KnownBoxes.ba;
      case 3: return KnownBoxes.a8;
      case 4: return KnownBoxes.bb;
      case 5: return KnownBoxes.bc;
      case 6: return KnownBoxes.a9;
      default: return enumGetBox(ST_CellType_$type, a);
    }
  }
  static aq(a) {
    switch (a) {
      case -1: return KnownBoxes.bf;
      case 2: return KnownBoxes.bd;
      case 1: return KnownBoxes.be;
      case 4: return KnownBoxes.bg;
      case 3: return KnownBoxes.bh;
      case 0: return KnownBoxes.bi;
      default: return enumGetBox(VerticalCellAlignment_$type, a);
    }
  }
  static b() {
    let a = new Dictionary$2(Number_$type, Base.$, 0);
    for (let b = 0; b <= 63; b++) {
      a.addItem(b, enumGetBox(WorksheetCellFormatOptions_$type, b));
    }
    return a;
  }
  static ar(a) {
    let b;
    if (((() => { let c = KnownBoxes.a.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      return enumGetBox(WorksheetCellFormatOptions_$type, a);
    }
    return b;
  }
}
KnownBoxes.$t = markType(KnownBoxes, 'KnownBoxes');
KnownBoxes.w = 1;
KnownBoxes.x = 0;
KnownBoxes.f = enumGetBox(CellBorderLineStyle_$type, -1);
KnownBoxes.n = enumGetBox(CellBorderLineStyle_$type, 0);
KnownBoxes.c = enumGetBox(CellBorderLineStyle_$type, 9);
KnownBoxes.d = enumGetBox(CellBorderLineStyle_$type, 11);
KnownBoxes.e = enumGetBox(CellBorderLineStyle_$type, 3);
KnownBoxes.g = enumGetBox(CellBorderLineStyle_$type, 4);
KnownBoxes.h = enumGetBox(CellBorderLineStyle_$type, 6);
KnownBoxes.i = enumGetBox(CellBorderLineStyle_$type, 7);
KnownBoxes.j = enumGetBox(CellBorderLineStyle_$type, 2);
KnownBoxes.k = enumGetBox(CellBorderLineStyle_$type, 10);
KnownBoxes.l = enumGetBox(CellBorderLineStyle_$type, 12);
KnownBoxes.m = enumGetBox(CellBorderLineStyle_$type, 8);
KnownBoxes.o = enumGetBox(CellBorderLineStyle_$type, 13);
KnownBoxes.p = enumGetBox(CellBorderLineStyle_$type, 5);
KnownBoxes.q = enumGetBox(CellBorderLineStyle_$type, 1);
KnownBoxes.s = enumGetBox(DiagonalBorders_$type, 0);
KnownBoxes.r = enumGetBox(DiagonalBorders_$type, 7);
KnownBoxes.t = enumGetBox(DiagonalBorders_$type, 3);
KnownBoxes.u = enumGetBox(DiagonalBorders_$type, 5);
KnownBoxes.v = enumGetBox(DiagonalBorders_$type, 1);
KnownBoxes.y = null;
KnownBoxes.z = false;
KnownBoxes.aa = true;
KnownBoxes.ab = enumGetBox(FontSuperscriptSubscriptStyle_$type, -1);
KnownBoxes.ac = enumGetBox(FontSuperscriptSubscriptStyle_$type, 0);
KnownBoxes.ad = enumGetBox(FontSuperscriptSubscriptStyle_$type, 2);
KnownBoxes.ae = enumGetBox(FontSuperscriptSubscriptStyle_$type, 1);
KnownBoxes.af = enumGetBox(FontUnderlineStyle_$type, -1);
KnownBoxes.ai = enumGetBox(FontUnderlineStyle_$type, 0);
KnownBoxes.ag = enumGetBox(FontUnderlineStyle_$type, 2);
KnownBoxes.ah = enumGetBox(FontUnderlineStyle_$type, 34);
KnownBoxes.aj = enumGetBox(FontUnderlineStyle_$type, 1);
KnownBoxes.ak = enumGetBox(FontUnderlineStyle_$type, 33);
KnownBoxes.ax = enumGetBox(HorizontalCellAlignment_$type, -1);
KnownBoxes.a0 = enumGetBox(HorizontalCellAlignment_$type, 0);
KnownBoxes.av = enumGetBox(HorizontalCellAlignment_$type, 2);
KnownBoxes.aw = enumGetBox(HorizontalCellAlignment_$type, 6);
KnownBoxes.ay = enumGetBox(HorizontalCellAlignment_$type, 7);
KnownBoxes.az = enumGetBox(HorizontalCellAlignment_$type, 4);
KnownBoxes.a1 = enumGetBox(HorizontalCellAlignment_$type, 5);
KnownBoxes.a2 = enumGetBox(HorizontalCellAlignment_$type, 1);
KnownBoxes.a3 = enumGetBox(HorizontalCellAlignment_$type, 3);
KnownBoxes.a4 = -1;
KnownBoxes.a5 = 0;
KnownBoxes.a6 = enumGetBox(ST_CellType_$type, 0);
KnownBoxes.a7 = enumGetBox(ST_CellType_$type, 1);
KnownBoxes.ba = enumGetBox(ST_CellType_$type, 2);
KnownBoxes.a8 = enumGetBox(ST_CellType_$type, 3);
KnownBoxes.bb = enumGetBox(ST_CellType_$type, 4);
KnownBoxes.bc = enumGetBox(ST_CellType_$type, 5);
KnownBoxes.a9 = enumGetBox(ST_CellType_$type, 6);
KnownBoxes.bf = enumGetBox(VerticalCellAlignment_$type, -1);
KnownBoxes.bd = enumGetBox(VerticalCellAlignment_$type, 2);
KnownBoxes.be = enumGetBox(VerticalCellAlignment_$type, 1);
KnownBoxes.bg = enumGetBox(VerticalCellAlignment_$type, 4);
KnownBoxes.bh = enumGetBox(VerticalCellAlignment_$type, 3);
KnownBoxes.bi = enumGetBox(VerticalCellAlignment_$type, 0);
KnownBoxes.a = KnownBoxes.b();
/**
 * @hidden
 */
export let ILoadOnDemandTreeOwner$1_$type = new Type(null, 'ILoadOnDemandTreeOwner$1');
/**
 * @hidden
 */
export let IBinaryTreeNodeOwner$1_$type = new Type(null, 'IBinaryTreeNodeOwner$1');
/**
 * @hidden
 */
export class LoadOnDemandTree$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this._a = null;
    this._aj = 0;
    this._h = null;
    this._i = null;
    this._ae = 0;
    this._n = false;
    this._q = 0;
    this._r = 0;
    this._s = 0;
    this._ab = null;
    this._aa = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._a = a;
    this._ae = b;
  }
  recalculateHeight() {
    return false;
  }
  verifyBalanceOfChild(a) {
    return ((() => { let b = LoadOnDemandTree_BinaryTreeNode$1.j(this.$t, this._h); this._h = b.p0; return b.ret; })());
  }
  add(a) {
  }
  clear() {
    this._h = null;
    this._aj = 0;
  }
  contains(a) {
    for (let b of fromEnum(this)) {
      if (Base.equalsStatic(b, a)) {
        return true;
      }
    }
    return false;
  }
  copyTo(a, b) {
    for (let c of fromEnum(this)) {
      a[b++] = c;
    }
  }
  get isReadOnly() {
    return false;
  }
  remove(a) {
    return false;
  }
  getEnumerator() {
    return getEnumerator(this._x(0, 0x7FFFFFFF, true));
  }
  *__x(a, b, c) {
    b = Math.min(b, this._ae - 1);
    let d = null;
    let e = null;
    let f = -1;
    let g = a;
    let h = b;
    if (this._aa != null && this._aa.count > 0) {
      g = this._ah(a);
      h = this._ah(b);
      let i = this._w(a, b, c);
      d = getEnumerator(i);
      if (d.moveNext()) {
        e = d.current;
        f = this._a._getItemIndex$i(e);
      }
    }
    let j = c ? (k, l) => k < l : (k, l) => k > l;
    for (let k of fromEnum(this._z(g, h, c))) {
      let l = k.b;
      let m = 0;
      if (k.l < g) {
        m = g - k.l;
      }
      let n = Math.min(h - k.l, 32 - 1);
      let o;
      let p;
      let q;
      if (c) {
        o = m;
        p = n + 1;
        q = 1;
      }
      else {
        o = n;
        p = m - 1;
        q = -1;
      }
      for (let r = o; r != p; r += q) {
        let s = l[r];
        if (s != null) {
          let t = Nullable$1.toNullable(Number_$type, null);
          if (this._ab != null) {
            t = Nullable$1.toNullable(Number_$type, this._a._getItemIndex$i(s));
            if (t.value < 0) {
              l[r] = null;
              continue;
            }
            while (e != null && j(f, t.value)) {
              if (f < a || f > b) {
                break;
              }
              yield e;
              if (!d.moveNext()) {
                e = null;
                break;
              }
              e = d.current;
              f = this._a._getItemIndex$i(e);
            }
          }
          let u = !(nullableLessThan(t, a) || nullableGreaterThan(t, b));
          if (nullableEquals(t, null)) {
            if (u) {
              yield s;
            }
          }
          else {
            if (u) {
              yield s;
            }
            else {
              if (nullableLessThan(t, 0) || nullableGreaterThanOrEqual(t, this._ae)) {
                l[r] = null;
                this._a._initializeItemIndex$i(s, -1, this._n);
              }
            }
          }
        }
      }
    }
    while (e != null) {
      f = this._a._getItemIndex$i(e);
      if (f >= 0) {
        if (f < a || f > b) {
          break;
        }
        yield e;
      }
      if (!d.moveNext()) {
        break;
      }
      e = d.current;
    }
  }
  _x(a, b, c) {
    return toEnum(() => this.__x(a, b, c));
  }
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  _af(a, b) {
    if (b == this._s) {
      b = 0;
    }
    if (b == this._q || a < 0) {
      return a;
    }
    let c;
    if (this._r > b) {
      c = b;
    }
    else {
      c = b - this._r;
    }
    let d = this._ad;
    let e = d.count;
    let f = a;
    for (let g = c; g < e; g++) {
      let h = d._inner[g];
      if (h.a) {
        if (h.f <= f) {
          f += h.c;
        }
      }
      else {
        let i = h.f + h.c - 1;
        if (i < f) {
          f -= h.c;
        }
        else {
          if (h.f <= f && i >= f) {
            return -1;
          }
        }
      }
    }
    return f;
  }
  _ah(a) {
    let b = 0;
    let c = this._aa != null ? this._aa.count : 0;
    for (let d = 0; d < c; d++) {
      let e = this._aa._inner[d];
      if (e.n > a) {
        break;
      }
      if (e.e) {
        if (e.l >= a) {
          b += e.n - a;
          continue;
        }
        b -= e.k;
      }
      else {
        b += e.k;
      }
    }
    return a + b;
  }
  _ai(a) {
    let b = a;
    let c = this._aa != null ? this._aa.count : 0;
    for (let d = 0; d < c; d++) {
      let e = this._aa._inner[d];
      if (e.n > b) {
        break;
      }
      if (e.e) {
        b += e.k;
      }
      else {
        b -= e.k;
      }
    }
    return b;
  }
  _j(a) {
    return this._k(a, 0, a.c);
  }
  _k(a, b, c) {
    return new LoadOnDemandTree_ChangeAdjustmentPoint$1(this.$t, this, a, b, c);
  }
  _l(a, b) {
    return new LoadOnDemandTree_ChangeHistoryItemAdd$1(this.$t, a, b);
  }
  _m(a, b) {
    return new LoadOnDemandTree_ChangeHistoryItemRemove$1(this.$t, a, b);
  }
  _f(a, b) {
    return new LoadOnDemandTree_BinaryTreeNode$1(this.$t, a, b, this);
  }
  *__w(a, b, c) {
    if (this._aa != null && this._aa.count > 0) {
      let d;
      let e;
      let f;
      let g;
      if (c) {
        d = 0;
        f = this._aa.count;
        e = 1;
      }
      else {
        d = this._aa.count - 1;
        f = -1;
        e = -1;
      }
      g = this._aa._inner[d];
      while (g != null) {
        if (g.d && g.f(a, b)) {
          let h;
          let i;
          if (c) {
            h = Math.max(0, a);
            i = Math.min(g.l, b) + 1;
          }
          else {
            h = Math.min(g.l, b);
            i = Math.max(0, a) - 1;
          }
          for (let j = h; j != i; j += e) {
            if (g.f(j, j)) {
              let k = g.item(j - g.n);
              if (k != null && this._a._getItemIndex$i(k) >= 0) {
                yield k;
              }
            }
          }
        }
        d += e;
        if (d == f) {
          g = null;
        }
        else {
          g = this._aa._inner[d];
        }
      }
    }
  }
  _w(a, b, c) {
    return toEnum(() => this.__w(a, b, c));
  }
  _y() {
    return this._z(0, 0x7FFFFFFF, true);
  }
  *__z(a, b, c) {
    let d = new Stack$1(LoadOnDemandTree_BinaryTreeNode$1.$.specialize(this.$t));
    let e = this._h;
    while (true) {
      LoadOnDemandTree$1._aq(this.$t, e, d, c);
      if (d.f == 0) {
        return undefined;
      }
      let f = d.e();
      if (a < (f.l + 32) && f.l <= b) {
        yield f;
      }
      if (c) {
        e = f.i;
      }
      else {
        e = f.g;
      }
    }
  }
  _z(a, b, c) {
    return toEnum(() => this.__z(a, b, c));
  }
  _b(a, b, c) {
    let d = this._aa != null ? this._aa.count : 0;
    let e = a;
    for (let f = 0; f < d; f++) {
      let g = this._aa._inner[f];
      if (g.n > a) {
        break;
      }
      if (g.e) {
        if (g.l >= a) {
          c = 0;
          if (false == b && false == g.d) {
            return {
              ret: null,
              p2: c
            };
          }
          let h = a - g.n;
          let i = g.item(h);
          if (i == null) {
            if (b) {
              i = this._a._createValue$i(a);
              g.item(h, i);
              c = 2;
              this._aj++;
            }
          }
          else {
            c = 1;
          }
          return {
            ret: i,
            p2: c
          };
        }
        e -= g.k;
      }
      else {
        e += g.k;
      }
    }
    let j = e % 32;
    let k = e - j;
    let l = null;
    if (this._h == null) {
      if (b == false) {
        c = 0;
        return {
          ret: null,
          p2: c
        };
      }
      c = 2;
      l = this._h = this._f(k, this);
      l.b[j] = this._a._createValue$i(a);
    }
    else {
      if (this._i != null) {
        if (k == this._i.l) {
          l = this._i;
        }
        else if (k == this._i.l + 32) {
          l = this._i.i;
          if (l != null) {
            while (true) {
              let m = l.g;
              if (m == null) {
                break;
              }
              l = m;
            }
          }
          else {
          }
        }
        else if (k == this._i.l - 32) {
          l = this._i.g;
          if (l != null) {
            while (true) {
              let n = l.i;
              if (n == null) {
                break;
              }
              l = n;
            }
          }
          else {
          }
        }
      }
      if (l == null) {
        l = this._h;
      }
      l = ((() => { let o = l.e(a, e, b, b, this, c); c = o.p5; return o.ret; })());
    }
    if (l == null) {
      return {
        ret: null,
        p2: c
      };
    }
    this._i = l;
    if (c == 2) {
      this._aj++;
    }
    let o = l.b[j];
    if (o != null) {
      if (!this._a._isItemStillValid$i(o)) {
        if (b) {
          o = this._a._createValue$i(a);
        }
        else {
          o = null;
        }
        l.b[j] = o;
      }
    }
    return {
      ret: o,
      p2: c
    };
  }
  _ao(a, b) {
    let c = Math.max(this._ae - b, a + b);
    let d = this._ae - 1;
    if (c <= d) {
      for (let e of fromEnum(this._x(c, d, true))) {
        this._aj--;
      }
    }
    this._am(this._l(a, b));
  }
  static _aq($t, a, b, c) {
    while (true) {
      if (a == null) {
        break;
      }
      b.h(a);
      if (c) {
        a = a.g;
      }
      else {
        a = a.i;
      }
    }
  }
  _ar(a, b) {
    for (let c of fromEnum(this._x(a, a + b - 1, true))) {
      this._aj--;
    }
    this._am(this._m(a, b));
  }
  _e(a, b) {
    let c = this._aa != null ? this._aa.count : 0;
    let d = b;
    for (let e = 0; e < c; e++) {
      let f = this._aa._inner[e];
      if (f.n > b) {
        break;
      }
      if (f.e) {
        if (f.l >= b) {
          let g = b - f.n;
          let h = f.item(g);
          f.item(g, a);
          return h;
        }
        d -= f.k;
      }
      else {
        d += f.k;
      }
    }
    let i = null;
    let j;
    return ((() => { let k = this._d(i, a, b, j); i = k.p0; j = k.p3; return k.ret; })());
  }
  _p(a, b) {
    let c;
    b = ((() => { let d = this._b(a, false, c); c = d.p2; return d.ret; })());
    return {
      ret: c == 1,
      p1: b
    };
  }
  _am(a) {
    this._i = null;
    let b = this._ad;
    b.add(a);
    this._q++;
    this._ap(a);
    this._as();
    if (this._aa == null) {
      return;
    }
    let c = this._aa.count - 1;
    for (; c >= 0; c--) {
      let d = this._aa._inner[c];
      if (d.l < this._ae) {
        break;
      }
      if (d.n < this._ae) {
        d.u(this._ae - d.n);
      }
      else {
        this._aa.removeAt(c);
      }
    }
    let e = this._aa.count;
    let f = 0;
    for (c = 0; c < e; c++) {
      let g = this._aa._inner[c];
      if (g.e) {
        f += g.k;
      }
      else {
        f -= g.k;
      }
    }
    if (f < 0) {
      let h = this._ae + f;
      let i = this._l(h, -f);
      b.add(i);
      this._q++;
      this._aa.add(this._j(i));
    }
  }
  _an() {
    if (this._ab == null) {
      return;
    }
    this._n = true;
    try {
      let a = new List$1(this.$t, 1, this._w(0, this._ae, true));
      let b = new List$1(LoadOnDemandTree_BinaryTreeNode$1.$.specialize(this.$t), 1, this._y());
      let c = null;
      let d = b.count;
      for (let e = 0; e < d; e++) {
        c = b._inner[e];
        for (let f = 0; f < 32; f++) {
          let g = c.b[f];
          if (g != null) {
            let h = c.l + f;
            let i = this._a._getItemIndex$i(g);
            this._a._initializeItemIndex$i(g, i, true);
            if (i < 0) {
              c.b[f] = null;
              continue;
            }
            if (h != i) {
              c.b[f] = null;
              let j;
              let k = c;
              let l = ((() => { let m = this._d(k, g, i, j); k = m.p0; j = m.p3; return m.ret; })());
              while (l != null) {
                let m = i;
                if (j < 0) {
                  this._a._initializeItemIndex$i(l, i, true);
                  break;
                }
                l = ((() => { let n = this._d(k, l, j, j); k = n.p0; j = n.p3; return n.ret; })());
              }
            }
          }
        }
      }
      for (let n of fromEnum(a)) {
        let o = this._a._getItemIndex$i(n);
        if (o < 0) {
          this._a._initializeItemIndex$i(n, o, true);
        }
        else {
          let p;
          let q = ((() => { let r = this._d(c, n, o, p); c = r.p0; p = r.p3; return r.ret; })());
        }
      }
    }
    finally {
      this._n = false;
      this._aa = null;
      this._ab = null;
      if (this._q >= 150) {
        this._s = this._q;
        this._q = 0;
      }
      this._r = this._q;
    }
  }
  _o(a, b) {
    if (this._aa == null) {
      return false;
    }
    let c = this._aa.count;
    for (let d = 0; d < c; d++) {
      let e = this._aa._inner[d];
      if (e.e) {
        if (e.n + e.k <= b) {
          continue;
        }
      }
      else if (e.m <= b) {
        continue;
      }
      if (e.e && a > 0 && b + a > e.n && b != e.m + 1 && b != e.n) {
        this._an();
        return true;
      }
    }
    return false;
  }
  _ap(a) {
    let b = this._j(a);
    if (this._aa == null) {
      this._aa = new List$1(LoadOnDemandTree_ChangeAdjustmentPoint$1.$.specialize(this.$t), 0);
      this._aa.add(b);
    }
    else {
      let c = false;
      let d = new List$1(LoadOnDemandTree_ChangeAdjustmentPoint$1.$.specialize(this.$t), 2, 3);
      let e = this._aa.count;
      for (let f = 0; f < e; f++) {
        let g = this._aa._inner[f];
        if (g.e) {
          if (g.n + g.k <= a.f) {
            continue;
          }
        }
        else if (g.m <= a.f) {
          continue;
        }
        let h = g.q(b, d, c);
        c = h.p2;
        if (d.count == 1) {
          this._aa._inner[f] = d._inner[0];
        }
        else {
          this._aa.removeAt(f);
          this._aa.s(f, d);
          e += d.count - 1;
          f += d.count - 1;
        }
      }
      if (!c) {
        this._aa.add(b);
      }
    }
  }
  _d(a, b, c, d) {
    d = -1;
    let e = !(c < 0 || c >= this._ae);
    let f = this._n ? c : this._ah(c);
    if (a == null || a.l > f || a.l + 32 <= f) {
      a = this._g(a, c, f);
    }
    if (a == null) {
      this._a._initializeItemIndex$i(b, -1, this._n);
      return {
        ret: null,
        p0: a,
        p3: d
      };
    }
    let g = f - a.l;
    let h = a.b[g];
    a.b[g] = b;
    this._a._initializeItemIndex$i(b, c, this._n);
    if (h == null || Base.equalsStatic(h, b)) {
      return {
        ret: null,
        p0: a,
        p3: d
      };
    }
    d = this._a._getItemIndex$i(h);
    if (d == c) {
      return {
        ret: null,
        p0: a,
        p3: d
      };
    }
    return {
      ret: h,
      p0: a,
      p3: d
    };
  }
  _g(a, b, c) {
    if (b < 0) {
      return null;
    }
    let d = a == null ? false : c >= a.l && c < a.l + 32;
    let e;
    if (!d) {
      if (this._h == null) {
        let f = c % 32;
        let g = c - f;
        a = this._h = this._f(g, this);
      }
      else {
        a = ((() => { let h = this._h.e(b, c, true, false, this, e); e = h.p5; return h.ret; })());
      }
    }
    return a;
  }
  _as() {
    let a = this._ad;
    if (a.count == 0) {
      return;
    }
    if (a.count > 60 || a._inner[a.count - 1].c > 100) {
      this._an();
    }
  }
  get _ac() {
    return this._aa;
  }
  get _u() {
    return this._q;
  }
  get count() {
    return this._aj;
  }
  _item(a) {
    let b;
    return ((() => { let c = this._b(a, true, b); b = c.p2; return c.ret; })());
  }
  get _al() {
    return this._ae;
  }
  set _al(a) {
    if (a != this._ae) {
      this._an();
      this._ae = a;
    }
  }
  get _ad() {
    if (this._ab == null) {
      this._ab = new List$1(LoadOnDemandTree_ChangeHistoryItem$1.$.specialize(this.$t), 0);
    }
    return this._ab;
  }
}
LoadOnDemandTree$1.$t = markType(LoadOnDemandTree$1, 'LoadOnDemandTree$1', Base.$, [ICollection$1_$type.specialize(0), IBinaryTreeNodeOwner$1_$type.specialize(0)]);
/**
 * @hidden
 */
export class LoadOnDemandTree_ChangeAdjustmentPoint$1 extends Base {
  constructor($t, a, b, c, d) {
    super();
    this.$t = null;
    this.a = null;
    this.i = 0;
    this.h = 0;
    this.j = 0;
    this.c = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.a = a;
    this.c = b;
    this.j = c;
    this.i = b.f + c;
    this.h = d;
  }
  get n() {
    return this.i;
  }
  get l() {
    return this.i + this.h - 1;
  }
  get m() {
    if (!this.e) {
      return this.i;
    }
    return this.l;
  }
  get k() {
    return this.h;
  }
  set k(a) {
    if (this.h != a) {
      this.h = a;
      this.t();
    }
  }
  get p() {
    return this.c.c;
  }
  get o() {
    return this.j;
  }
  get d() {
    if (!this.e) {
      return false;
    }
    return (this.c).j;
  }
  get e() {
    return this.c.a;
  }
  item(a, b) {
    if (arguments.length === 2) {
      if (!this.e) {
        throw new NotSupportedException(1, "Indexer is only supported on a add operation");
      }
      let c = typeCast(LoadOnDemandTree_ChangeHistoryItemAdd$1.$.specialize(this.$t), this.c);
      c.i[a + this.o] = b;
      return b;
    }
    else {
      if (!this.e) {
        throw new NotSupportedException(1, "Indexer is only supported on a add operation");
      }
      return this.c.i[a + this.o];
    }
  }
  q(a, b, c) {
    b.clear();
    let d = this.f(a.n, a.l);
    if (d) {
      if (a.c.a) {
        let e = this.r(a, b, c);
        c = e.p2;
        return {
          p2: c
        };
      }
      if (this.c.a) {
        let f = this.s(a, b, c);
        c = f.p2;
      }
      else {
        if (c) {
          this.i -= a.k;
        }
        else {
          let g = Math.min(this.i, a.n);
          this.i = g;
          this.k += a.h;
          c = true;
        }
        b.add(this);
      }
      return {
        p2: c
      };
    }
    if (a.n < this.i) {
      if (!c) {
        c = true;
        b.add(a);
      }
      b.add(this);
      if (a.c.a) {
        this.i += a.p;
      }
      else {
        this.i -= a.p;
      }
    }
    else {
      b.add(this);
      if (!c) {
        c = true;
        b.add(a);
      }
    }
    return {
      p2: c
    };
  }
  r(a, b, c) {
    if (a.n <= this.n) {
      if (!c) {
        c = true;
        if (false == this.e && a.i == this.i && a.h == this.h) {
          return {
            p2: c
          };
        }
        b.add(a);
      }
      this.i += a.k;
      b.add(this);
      return {
        p2: c
      };
    }
    if (c) {
      this.i += a.k;
      b.add(this);
      return {
        p2: c
      };
    }
    let d = a.n - this.n;
    b.o(this.g(d, 0, a));
    c = true;
    return {
      p2: c
    };
  }
  s(a, b, c) {
    let d = a.n - this.n;
    if (d == 0) {
      c = true;
      if (this.h == a.h) {
      }
      else if (this.h < a.h) {
        a.k -= this.h;
        b.add(a);
      }
      else {
        this.k -= a.h;
        this.j += a.h;
        b.add(this);
      }
      return {
        p2: c
      };
    }
    if (d > 0) {
      c = true;
      if (a.l <= this.l) {
        b.o(this.g(d, a.k, null));
      }
      else {
        let e = this.h;
        this.k = d;
        a.k -= e - this.h;
        b.add(this);
        b.add(a);
      }
      return {
        p2: c
      };
    }
    if (this.l <= a.l) {
      a.k -= this.h;
      if (!c) {
        b.add(a);
        c = true;
      }
    }
    else {
      d *= -1;
      let f = this.h;
      this.i -= d;
      this.k -= a.h - d;
      this.j += f - this.h;
      a.k = d;
      if (!c) {
        b.add(a);
        c = true;
      }
      b.add(this);
    }
    return {
      p2: c
    };
  }
  t() {
  }
  f(a, b) {
    let c = Math.max(a, this.i);
    let d = Math.min(b, this.m);
    return (c <= d);
  }
  g(a, b, c) {
    let d = new List$1(LoadOnDemandTree_ChangeAdjustmentPoint$1.$.specialize(this.$t), 2, 3);
    let e = this.a._k(this.c, this.o, a);
    let f = this.a._k(this.c, this.o + a + b, this.k - (a + b));
    if (e.k > 0) {
      d.add(e);
    }
    if (c != null) {
      c.i = e.i + a;
      d.add(c);
      f.i = c.l + 1;
    }
    if (f.k > 0) {
      f.i -= b;
      d.add(f);
    }
    return d;
  }
  u(a) {
    this.c.g(a + this.o);
    this.k = a;
  }
}
LoadOnDemandTree_ChangeAdjustmentPoint$1.$t = markType(LoadOnDemandTree_ChangeAdjustmentPoint$1, 'LoadOnDemandTree_ChangeAdjustmentPoint$1');
/**
 * @hidden
 */
export class LoadOnDemandTree_ChangeHistoryItem$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this.f = 0;
    this.b = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.f = a;
    this.b = b;
  }
  d(a, b, c, d) {
    return 0;
  }
  e(a, b, c) {
    return 0;
  }
  get c() {
    return this.b;
  }
}
LoadOnDemandTree_ChangeHistoryItem$1.$t = markType(LoadOnDemandTree_ChangeHistoryItem$1, 'LoadOnDemandTree_ChangeHistoryItem$1');
/**
 * @hidden
 */
export class LoadOnDemandTree_ChangeHistoryItemAdd$1 extends LoadOnDemandTree_ChangeHistoryItem$1 {
  constructor($t, a, b) {
    super($t, a, b);
    this.$t = null;
    this.h = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
  }
  get j() {
    return this.h != null;
  }
  get_a() {
    return true;
  }
  get a() {
    return this.get_a();
  }
  get i() {
    if (this.h == null) {
      this.h = new Array(this.c);
    }
    return this.h;
  }
  g(a) {
    this.b = a;
    if (this.h != null) {
      let b = this.h;
      this.h = new Array(this.b);
      arrayCopy1(b, 0, this.h, 0, this.b);
    }
  }
}
LoadOnDemandTree_ChangeHistoryItemAdd$1.$t = markType(LoadOnDemandTree_ChangeHistoryItemAdd$1, 'LoadOnDemandTree_ChangeHistoryItemAdd$1', LoadOnDemandTree_ChangeHistoryItem$1.$.specialize(0));
/**
 * @hidden
 */
export class LoadOnDemandTree_ChangeHistoryItemRemove$1 extends LoadOnDemandTree_ChangeHistoryItem$1 {
  constructor($t, a, b) {
    super($t, a, b);
    this.$t = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
  }
  get_a() {
    return false;
  }
  get a() {
    return this.get_a();
  }
  g(a) {
    this.b = a;
  }
}
LoadOnDemandTree_ChangeHistoryItemRemove$1.$t = markType(LoadOnDemandTree_ChangeHistoryItemRemove$1, 'LoadOnDemandTree_ChangeHistoryItemRemove$1', LoadOnDemandTree_ChangeHistoryItem$1.$.specialize(0));
/**
 * @hidden
 */
export class LoadOnDemandTree_BinaryTreeNode$1 extends Base {
  constructor($t, a, b, c) {
    super();
    this.$t = null;
    this.n = 0;
    this.k = 0;
    this.c = null;
    this.f = null;
    this.h = null;
    this.a = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.k = a;
    this.a = new Array(32);
    this.c = b;
  }
  verifyBalanceOfChild(a) {
    if (a == this.f) {
      return ((() => { let b = LoadOnDemandTree_BinaryTreeNode$1.j(this.$t, this.f); this.f = b.p0; return b.ret; })());
    }
    else if (a == this.h) {
      return ((() => { let b = LoadOnDemandTree_BinaryTreeNode$1.j(this.$t, this.h); this.h = b.p0; return b.ret; })());
    }
    else {
      return false;
    }
  }
  static j($t, a) {
    let b = a.f;
    let c = a.h;
    let d = LoadOnDemandTree_BinaryTreeNode$1.m($t, b);
    let e = LoadOnDemandTree_BinaryTreeNode$1.m($t, c);
    if (d < e - 1) {
      let f = c.f;
      let g = c.h;
      let h = LoadOnDemandTree_BinaryTreeNode$1.m($t, f);
      let i = LoadOnDemandTree_BinaryTreeNode$1.m($t, g);
      if (h < i) {
        let j = c.f;
        c.c = a.c;
        a.i = j;
        c.g = a;
        a.recalculateHeight();
        a = c;
      }
      else {
        let k = f.f;
        let l = f.h;
        f.c = a.c;
        f.g = a;
        f.i = c;
        a.i = k;
        c.g = l;
        a.recalculateHeight();
        c.recalculateHeight();
        f.recalculateHeight();
        a = f;
      }
      return {
        ret: true,
        p0: a
      };
    }
    if (e < d - 1) {
      let m = b.f;
      let n = b.h;
      let o = LoadOnDemandTree_BinaryTreeNode$1.m($t, m);
      let p = LoadOnDemandTree_BinaryTreeNode$1.m($t, n);
      if (p < o) {
        let q = b.h;
        b.c = a.c;
        a.g = q;
        b.i = a;
        a.recalculateHeight();
        a = b;
      }
      else {
        let r = n.f;
        let s = n.h;
        n.c = a.c;
        n.g = b;
        n.i = a;
        a.g = s;
        b.i = r;
        a.recalculateHeight();
        b.recalculateHeight();
        n.recalculateHeight();
        a = n;
      }
      return {
        ret: true,
        p0: a
      };
    }
    return {
      ret: false,
      p0: a
    };
  }
  e(a, b, c, d, e, f) {
    if (d) {
      c = true;
    }
    let g = b % 32;
    let h = b - g;
    f = 0;
    let i = this;
    let j = null;
    while (true) {
      if (h == i.k) {
        if (i.b[g] == null) {
          if (d) {
            i.b[g] = e._a._createValue$i(a);
            f = 2;
          }
          else {
            f = 0;
          }
        }
        else {
          f = 1;
        }
        return {
          ret: i,
          p5: f
        };
      }
      let k = i;
      if (h < i.k) {
        i = i.f;
        if (i == null) {
          if (c) {
            j = e._f(h, this);
            if (d) {
              j.b[g] = e._a._createValue$i(a);
              f = 2;
            }
            else {
              f = 0;
            }
            i = j;
            k.g = i;
          }
          break;
        }
      }
      else {
        i = i.h;
        if (i == null) {
          if (c) {
            j = e._f(h, this);
            if (d) {
              j.b[g] = e._a._createValue$i(a);
              f = 2;
            }
            else {
              f = 0;
            }
            i = j;
            k.i = i;
          }
          break;
        }
      }
    }
    if (f == 2) {
      let l = i.c;
      while (i != null) {
        l = i.c;
        if (l.verifyBalanceOfChild(i)) {
          break;
        }
        if (l.recalculateHeight() == false) {
          break;
        }
        i = typeCast(LoadOnDemandTree_BinaryTreeNode$1.$.specialize(this.$t), l);
      }
    }
    return {
      ret: j,
      p5: f
    };
  }
  static m($t, a) {
    return a == null ? -1 : a.n;
  }
  recalculateHeight() {
    let a = LoadOnDemandTree_BinaryTreeNode$1.m(this.$t, this.f);
    let b = LoadOnDemandTree_BinaryTreeNode$1.m(this.$t, this.h);
    let c = this.n;
    if (a < b) {
      this.n = b + 1;
    }
    else {
      this.n = a + 1;
    }
    return this.n != c;
  }
  get l() {
    return this.k;
  }
  get g() {
    return this.f;
  }
  set g(a) {
    if (this.f != a) {
      this.f = a;
      if (this.f != null) {
        this.f.c = this;
      }
    }
  }
  get d() {
    return this.c;
  }
  get i() {
    return this.h;
  }
  set i(a) {
    if (this.h != a) {
      this.h = a;
      if (this.h != null) {
        this.h.c = this;
      }
    }
  }
  get b() {
    return this.a;
  }
}
LoadOnDemandTree_BinaryTreeNode$1.$t = markType(LoadOnDemandTree_BinaryTreeNode$1, 'LoadOnDemandTree_BinaryTreeNode$1', Base.$, [IBinaryTreeNodeOwner$1_$type.specialize(0)]);
/**
 * Abstract base class for a named reference defined in the workbook.
 */
export class NamedReferenceBase extends Base {
  constructor(a, b) {
    super();
    this._i = null;
    this._at = null;
    this._ad = null;
    this._q = false;
    this._b = 0;
    this._al = null;
    this._o = false;
    this._u = false;
    this._w = false;
    this._ad = a;
    this._o = b;
    this._a2();
  }
  /**
   * @hidden
   */
  static _e($tValue, a, b, c, d, e = null, f = true, g = false, h = 0) {
    return new ChangeInfo$2(IChangeInfoContext_$type, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _a3(a, b) {
    let c = b._ck;
    c.filterSettings._bm(a.referencedRegion);
  }
  /**
   * @hidden
   */
  static _a4(a, b) {
    let c = b._ck;
    let d = ExcelUtils.cd(a._j);
    for (let e = 0; e < d.count; e++) {
      let f = d._inner[e].j(c, -1, -1, false);
      if (f != null) {
        b._printAreas$i._m(f);
      }
      else {
      }
    }
  }
  /**
   * @hidden
   */
  static _a5(a, b) {
    let c = b._ck;
    let d = ExcelUtils.cd(a._j);
    for (let e = 0; e < d.count; e++) {
      let f = d._inner[e];
      if (f.d.r == 0 && f.b.r == c._columns$i.maxCount - 1) {
        b.rowsToRepeatAtTop = new RepeatTitleRange(f.d.t, f.b.t);
      }
      if (f.d.t == 0 && f.b.t == c._rows$i.maxCount - 1) {
        b.columnsToRepeatAtLeft = new RepeatTitleRange(f.d.r, f.b.r);
      }
    }
  }
  /**
   * @hidden
   */
  static _av(a) {
    switch (a) {
      case 0: return "Consolidate_Area";
      case 1: return "Auto_Open";
      case 2: return "Auto_Close";
      case 3: return "Extract";
      case 4: return "Database";
      case 5: return "Criteria";
      case 6: return "Print_Area";
      case 7: return "Print_Titles";
      case 8: return "Recorder";
      case 9: return "Data_Form";
      case 10: return "Auto_Activate";
      case 11: return "Auto_Deactivate";
      case 12: return "Sheet_Title";
      case 13: return "_FilterDatabase";
      default: return null;
    }
  }
  /**
   * @hidden
   */
  _a6(a) {
  }
  /**
   * @hidden
   */
  _a7(a) {
    let b = this._k;
    if (b != null && a != null) {
      if (StringUtilities.c(this.name, a, b._e6, 1) != 0) {
        b._h2(this, a);
      }
    }
    this._a2();
  }
  /**
   * @hidden
   */
  _a8(a) {
    let b = this._k;
    if (b != null) {
      b._jc(a, this);
    }
  }
  /**
   * @hidden
   */
  static _a9(a, b) {
    switch (a._c) {
      case 13:
        NamedReferenceBase._a3(a, b);
        break;
      case 6:
        NamedReferenceBase._a4(a, b);
        break;
      case 7:
        NamedReferenceBase._a5(a, b);
        break;
      default: break;
    }
  }
  /**
   * @hidden
   */
  _aw() {
    let a;
    let b;
    let c;
    let d = Workbook._hl(this._k, a, b, c);
    a = d.p1;
    b = d.p2;
    c = d.p3;
    let e = this.name;
    if (FormulaParser.ab(e, b, c) == false) {
      e = stringFormat("'{0}'", stringReplace(e, "'", "''"));
    }
    return e;
  }
  /**
   * @hidden
   */
  static _ba(a, b) {
    ChangeInfo.f(a, 0, NamedReferenceBase._e(String_$type, "Comment", b, (c) => c.comment, (c, d) => c.comment = d));
    ChangeInfo.f(a, 1, NamedReferenceBase._e(String_$type, "Name", b, (c) => c.name, (c, d) => c.name = d, (c, d) => c._bc(d)));
  }
  /**
   * @hidden
   */
  _bd(a, b) {
    this._be(a, "value", this._l, b);
  }
  /**
   * @hidden
   */
  _be(a, b, c, d = true) {
    if (d) {
      if (stringIsNullOrEmpty(a)) {
        throw new ArgumentNullException(2, b, ExcelUtils.ef("LE_ArgumentNullException_NamedReferenceNameCantBeNull"));
      }
      if (a.length > 255) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NamedReferenceNameTooLong"), b);
      }
      if (this._g != 2 && FormulaParser.ab(a, c, this._z) == false) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidNamedReferenceName"), b);
      }
    }
    this._a8(a);
    let e = this._at;
    this._at = a;
    this._a7(e);
  }
  /**
   * @hidden
   */
  _a1(a, b = false) {
    return this.toString();
  }
  /**
   * @hidden
   */
  static _d(a) {
    if (stringCompare1(a, "Consolidate_Area", StringUtilities.g) == 0) {
      return 0;
    }
    if (stringCompare1(a, "Auto_Open", StringUtilities.g) == 0) {
      return 1;
    }
    if (stringCompare1(a, "Auto_Close", StringUtilities.g) == 0) {
      return 2;
    }
    if (stringCompare1(a, "Extract", StringUtilities.g) == 0) {
      return 3;
    }
    if (stringCompare1(a, "Database", StringUtilities.g) == 0) {
      return 4;
    }
    if (stringCompare1(a, "Criteria", StringUtilities.g) == 0) {
      return 5;
    }
    if (stringCompare1(a, "Print_Area", StringUtilities.g) == 0) {
      return 6;
    }
    if (stringCompare1(a, "Print_Titles", StringUtilities.g) == 0) {
      return 7;
    }
    if (stringCompare1(a, "Recorder", StringUtilities.g) == 0) {
      return 8;
    }
    if (stringCompare1(a, "Data_Form", StringUtilities.g) == 0) {
      return 9;
    }
    if (stringCompare1(a, "Auto_Activate", StringUtilities.g) == 0) {
      return 10;
    }
    if (stringCompare1(a, "Auto_Deactivate", StringUtilities.g) == 0) {
      return 11;
    }
    if (stringCompare1(a, "Sheet_Title", StringUtilities.g) == 0) {
      return 12;
    }
    if (stringCompare1(a, "_FilterDatabase", StringUtilities.g) == 0) {
      return 13;
    }
    return 6;
  }
  /**
   * @hidden
   */
  _a2() {
    this._q = NamedReferenceBase._s(this.name);
    if (this._q) {
      this._b = NamedReferenceBase._d(this.name);
    }
  }
  /**
   * @hidden
   */
  static _s(a) {
    if (stringCompare1(a, "Consolidate_Area", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Auto_Open", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Auto_Close", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Extract", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Database", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Criteria", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Print_Area", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Print_Titles", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Recorder", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Data_Form", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Auto_Activate", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Auto_Deactivate", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "Sheet_Title", StringUtilities.g) == 0) {
      return true;
    }
    if (stringCompare1(a, "_FilterDatabase", StringUtilities.g) == 0) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  get__a() {
    return null;
  }
  /**
   * @hidden
   */
  get _a() {
    return this.get__a();
  }
  /**
   * @hidden
   */
  get__l() {
    let a = this._k;
    if (a == null) {
      return 2;
    }
    return a.currentFormat;
  }
  /**
   * @hidden
   */
  get _l() {
    return this.get__l();
  }
  /**
   * Gets or sets the comment associated with the named reference or table.
   * The comment associated with the named reference or table.
   * @throws [[ArgumentException]] The value assigned is greater than 255 characters in length.
   */
  get comment() {
    return this._al;
  }
  /**
   * Gets or sets the comment associated with the named reference or table.
   * The comment associated with the named reference or table.
   * @throws [[ArgumentException]] The value assigned is greater than 255 characters in length.
   */
  set comment(a) {
    if (this._al != a) {
      if (a != null && 255 < a.length) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CommentTooLong"), "value");
      }
      if (this._n) {
        let b = this._a[0].g(IChangeInfoContext_$type, String_$type, this, this._al, a);
        this._al = b.p1;
      }
      else {
        this._al = a;
      }
    }
  }
  /**
   * Gets or sets the name of the reference.
   * <p class="body">
   * See the overview on [[scope]] for details on how to access a named reference by name in formulas.
   * </p>
   * The name of the reference.
   * @throws [[ArgumentNullException]] The value assigned is null or empty.
   * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
   * @throws [[ArgumentException]] The value assigned is not a valid named reference. The name must begin with a letter, underscore (_), or a backslash (\).
   * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
   * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
   * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
   * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
   * @throws [[InvalidOperationException]] The value assigned is the name of another named reference with the same Scope.
   * Names are compared case-insensitively.
   */
  get name() {
    return this._at;
  }
  /**
   * Gets or sets the name of the reference.
   * <p class="body">
   * See the overview on [[scope]] for details on how to access a named reference by name in formulas.
   * </p>
   * The name of the reference.
   * @throws [[ArgumentNullException]] The value assigned is null or empty.
   * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
   * @throws [[ArgumentException]] The value assigned is not a valid named reference. The name must begin with a letter, underscore (_), or a backslash (\).
   * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
   * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
   * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
   * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
   * @throws [[InvalidOperationException]] The value assigned is the name of another named reference with the same Scope.
   * Names are compared case-insensitively.
   */
  set name(a) {
    if (this._at != a) {
      if (this._n) {
        this._a[1].h(IChangeInfoContext_$type, String_$type, this, a);
      }
      else {
        this._bc(a);
      }
    }
  }
  /**
   * @hidden
   */
  _bc(a) {
    this._be(a, "value", this._l);
  }
  /**
   * Gets the scope of the named reference.
   * <p class="body">
   * This can either be the workbook which the named reference belongs to or one of the worksheets
   * in the workbook.
   * </p>
   * <p class="body">
   * The scope determines how formulas need to preface a name in order to use the named reference.
   * </p>
   * <p class="body">
   * If the scope is the workbook, formulas in any cell in the workbook can reference the named reference
   * by specifying just the name or the workbook's file name, an exclamation point, and the name:
   * <list type="bullet">
   * <item>=MyWorkbookName</item>
   * <item>='C:\MyWorkbook.xls'!MyWorkbookName</item>
   * </list>
   * When cells in other workbook's want to reference the named reference, they must use the second format
   * by first specifying the file name when the workbook-scoped named reference exists.
   * </p>
   * <p class="body">
   * If the scope is a worksheet, formulas in cells of the worksheet can reference the named reference
   * by specifying just the name. In addition, they can fully qualify the named reference with the worksheet name
   * and, optionally, the workbook file name:
   * <list type="bullet">
   * <item>=MyWorksheetName</item>
   * <item>=Sheet1!MyWorksheetName</item>
   * <item>='C:\[MyWorkbook.xls]Sheet1'!MyWorksheetName</item>
   * </list>
   * Formulas in cells of other worksheets in the same workbook can use the named reference as well, but they must
   * specify the worksheet name and, optionally, the workbook file name:
   * <list type="bullet">
   * <item>=Sheet2!OtherWorksheetName</item>
   * <item>='C:\[MyWorkbook.xls]Sheet2'!OtherWorksheetName</item>
   * </list>
   * Formulas in cells of other workbooks can also used the named reference, but they must specify the workbook file
   * name, worksheet name, and named reference name.
   * </p>
   * The scope of the named reference.
   */
  get scope() {
    return this._ad;
  }
  /**
   * @hidden
   */
  get _c() {
    return this._b;
  }
  /**
   * @hidden
   */
  get__m() {
    return true;
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * @hidden
   */
  get _j() {
    return this._i;
  }
  /**
   * @hidden
   */
  set _j(a) {
    this._bb(a, true);
  }
  /**
   * @hidden
   */
  _bb(a, b) {
    if (this._i == a) {
      return;
    }
    if (this._i != null) {
      this._i._bu();
    }
    this._i = a;
    if (this._i != null) {
      this._i._b5(new FormulaContext(3, this._k, typeCast(Worksheet.$, this._ad), null, -1, this._i));
    }
    this._a6(b);
  }
  /**
   * @hidden
   */
  get _p() {
    return this._o;
  }
  /**
   * @hidden
   */
  set _p(a) {
    this._o = a;
  }
  /**
   * @hidden
   */
  get _r() {
    return this._q;
  }
  /**
   * @hidden
   */
  get__t() {
    return true;
  }
  /**
   * @hidden
   */
  get _t() {
    return this.get__t();
  }
  /**
   * @hidden
   */
  get _v() {
    return this._u;
  }
  /**
   * @hidden
   */
  set _v(a) {
    this._u = a;
  }
  /**
   * @hidden
   */
  get _x() {
    return this._w;
  }
  /**
   * @hidden
   */
  set _x(a) {
    this._w = a;
  }
  /**
   * @hidden
   */
  get__y() {
    return false;
  }
  /**
   * @hidden
   */
  get _y() {
    return this.get__y();
  }
  /**
   * @hidden
   */
  get _af() {
    return this._ad;
  }
  /**
   * @hidden
   */
  set _af(a) {
    this._ad = a;
  }
  /**
   * @hidden
   */
  get__g() {
    return 0;
  }
  /**
   * @hidden
   */
  get _g() {
    return this.get__g();
  }
  /**
   * @hidden
   */
  get__h() {
    return null;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
}
NamedReferenceBase.$t = markType(NamedReferenceBase, 'NamedReferenceBase');
/**
 * @hidden
 */
NamedReferenceBase._ab = 0;
/**
 * @hidden
 */
NamedReferenceBase._ac = 1;
/**
 * @hidden
 */
NamedReferenceBase._aa = 2;
/**
 * @hidden
 */
NamedReferenceBase._an = "Consolidate_Area";
/**
 * @hidden
 */
NamedReferenceBase._aj = "Auto_Open";
/**
 * @hidden
 */
NamedReferenceBase._ah = "Auto_Close";
/**
 * @hidden
 */
NamedReferenceBase._ar = "Extract";
/**
 * @hidden
 */
NamedReferenceBase._ap = "Database";
/**
 * @hidden
 */
NamedReferenceBase._ao = "Criteria";
/**
 * @hidden
 */
NamedReferenceBase._ax = "Print_Area";
/**
 * @hidden
 */
NamedReferenceBase._ay = "Print_Titles";
/**
 * @hidden
 */
NamedReferenceBase._az = "Recorder";
/**
 * @hidden
 */
NamedReferenceBase._aq = "Data_Form";
/**
 * @hidden
 */
NamedReferenceBase._ag = "Auto_Activate";
/**
 * @hidden
 */
NamedReferenceBase._ai = "Auto_Deactivate";
/**
 * @hidden
 */
NamedReferenceBase._a0 = "Sheet_Title";
/**
 * @hidden
 */
NamedReferenceBase._as = "_FilterDatabase";
/**
 * @hidden
 */
NamedReferenceBase._ak = "_xlnm.";
/**
 * @hidden
 */
export class NamedReference_FormulaInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.c = null;
    this.a = 0;
    this.d = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.c = c._bp;
          this.a = d;
          this.d = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._k;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.b;
  }
}
NamedReference_FormulaInfo.$t = markStruct(NamedReference_FormulaInfo, 'NamedReference_FormulaInfo', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a named reference defined in the workbook.
 * <p class="body">
 * Named references allow for names to be used in formulas instead of complex formulas or cell references.
 * For example, instead of using the formula =SUM(E1:E20), a named reference with a name of 'Sales' can be
 * defined to point to the range of E1:E20 (the named reference's formula would be defined like this:
 * =Sheet1!$E$1:$E$20). Then the original formula could be expressed as =SUM(Sales).
 * </p>
 * <p class="body">
 * Each named reference has an associated scope, which can either be the [[workbook]]
 * to which the named reference belongs or one of the [[Worksheet]] instances in the Workbook. The scope
 * determines how the name must be referenced in formulas for different cells. A scope of the workbook means
 * the named reference must be accessed by a formula in any cell of the workbook by specifying only the name.
 * A scope of the worksheet means formulas used in other worksheets must reference the name by first
 * specifying the worksheet scope, such as =SUM( Sheet2!Sales ). If the formula is in the same worksheet as
 * the scope of the named reference, the formula can reference the name with or without the worksheet name.
 * </p>
 * <p class="body">
 * Named references from external workbooks must always be referenced with the scope first. If the named
 * reference's scope is the external workbook, the name is accessed by specifying the workbook file name
 * followed by the name, such as in the following formula: ='C:\ExternalWorkbook.xls'!SalesTax. If the named
 * reference has a scope of a worksheet in the workbook, it is referenced by specifying the file name,
 * worksheet, and name: ='C:\[ExternalWorkbook.xls]Sheet1'!SalesTax.
 * </p>
 * <p class="body">
 * Named references with different scopes can have the same names, but if two named references have the same
 * scope, they must have case-insensitively unique names.
 * </p>
 */
export class NamedReference extends NamedReferenceBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c, d, false];
          {
            let g = e[0];
            let h = e[1];
            let i = e[2];
            super(h, i);
            this._bm = null;
            this._bp = null;
            this._bu = false;
            this._bz = null;
            this._bp = g;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(d, e);
          this._bm = null;
          this._bp = null;
          this._bu = false;
          this._bz = null;
          this._bp = c;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__a() {
    return NamedReference._bf;
  }
  /**
   * @hidden
   */
  get__z() {
    let a = this._k;
    if (a != null) {
      return a._e6;
    }
    return ExcelUtils.cq;
  }
  /**
   * @hidden
   */
  get _z() {
    return this.get__z();
  }
  /**
   * @hidden
   */
  _a6(a) {
    if (this._bv) {
      return;
    }
    if (this._j == null || this._j._e.length == 0) {
      return;
    }
    this._f._a0(this._j, false);
    if (a) {
      this._ca(true);
    }
  }
  /**
   * Gets the string representation of the named reference.
   * @return The string representation of the named reference.
   */
  toString() {
    let a = this._aw();
    if (typeCast(Workbook.$, this.scope) !== null) {
      return a;
    }
    let b = typeCast(Worksheet.$, this.scope);
    if (b != null) {
      return ExcelUtils.d5(null, b.name) + a;
    }
    return a;
  }
  /**
   * @hidden
   */
  get__h() {
    let a = this._k;
    if (a == null) {
      return null;
    }
    return a._bb;
  }
  /**
   * @hidden
   */
  static _bl($tContext, $tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2($tContext, $tValue, a, 52, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bg() {
    let a = new Array(3);
    NamedReferenceBase._ba(a, 52);
    ChangeInfo.f(a, 2, NamedReference._bl(NamedReference_FormulaInfo.$, String_$type, "Formula", (b) => {
      let c = b.b._j;
      return c != null ? c._toString2(1, CultureInfo.invariantCulture) : null;
    }, (b, c) => {
      b.b._b2(b.c);
      NamedReference._b5(b, c);
    }, (b, c) => NamedReference._b9(b, c), true, true));
    return a;
  }
  /**
   * @hidden
   */
  _bi(a, b = null) {
    let c = this._bo(a);
    return this._bh(c, b);
  }
  /**
   * @hidden
   */
  _bh(a, b) {
    if (a != null) {
      if (typeCast(CellCalcReference.$, a) !== null) {
        let c = a;
        if (b == null || c._u == b) {
          return [new WorksheetRegionAddress(1, c._w.index, c._w.index, c._ao, c._ao)];
        }
      }
      else if (typeCast(RegionCalcReferenceBase.$, a) !== null) {
        let d = a;
        if (b == null || d._u == b) {
          return [d._a3._h];
        }
      }
      else if (typeCast(RegionGroupCalcReference.$, a) !== null) {
        let e = a;
        if (b == null || e._u == b) {
          let f = new Array(e._ba.count);
          for (let g = 0; g < f.length; g++) {
            f[g] = e._ba.item(g)._h;
          }
          return f;
        }
      }
      else {
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _bo(a, b = null) {
    let c = this._k;
    let d = this._j;
    if (d == null || c == null) {
      return null;
    }
    if (b == null && d._af() && c.windowOptions.selectedWorksheet != null) {
      b = c.windowOptions.selectedWorksheet._rows$i.item(0)._as(0);
    }
    let e = b != null ? new FormulaContext(3, c, b._u, b._w, b._ao, d) : new FormulaContext(1, c, d);
    let f;
    let g = ((() => { let h = c._ap(e, f, void 0, true); f = h.p1; return h.ret; })());
    if (g != null) {
      return g;
    }
    if (a == false) {
      return null;
    }
    c._hi();
    let h = new ExcelCalcNumberStack(b || this._bn, null);
    h.push(new ExcelCalcValue(this._bn));
    let i = h.pop();
    return typeCast(RefBase.$, i.value);
  }
  /**
   * @hidden
   */
  _b2(a) {
    if (this._bp == a) {
      return;
    }
    this._bp = a;
  }
  setFormula() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 3) {
      n = 2;
    }
    switch (n) {
      case 0: return this._setFormula1.apply(this, arguments);
      case 1: return this._setFormula2.apply(this, arguments);
      case 2:
        arguments[2] = typeof arguments[2] === 'string' ? new CultureInfo(arguments[2]) : arguments[2];
        return this._setFormula3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setFormula1(a) {
    let b = 1;
    let c = this._k;
    if (c != null) {
      b = c.cellReferenceMode;
    }
    this._setFormula2(a, b);
  }
  /**
   * @hidden
   */
  _setFormula2(a, b) {
    this._setFormula3(a, b, this._z);
  }
  /**
   * @hidden
   */
  _setFormula3(a, b, c) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, "formula", ExcelUtils.ef("LE_ArgumentNullException_FormulaCantBeNull"));
    }
    if (EnumUtil.isDefined(CellReferenceMode_$type, enumGetBox(CellReferenceMode_$type, b)) == false) {
      throw new InvalidEnumArgumentException("cellReferenceMode", b, CellReferenceMode_$type);
    }
    NamedReference._b5(new NamedReference_FormulaInfo(1, this, b, c), a);
  }
  /**
   * @hidden
   */
  static _b5(a, b) {
    if (a.b._n) {
      NamedReference._bf[2].h(NamedReference_FormulaInfo.$, String_$type, a, b);
    }
    else {
      NamedReference._b9(a, b);
    }
  }
  /**
   * @hidden
   */
  static _b9(a, b) {
    if (b == a.b._bz) {
      return;
    }
    a.b._bz = b;
    let c;
    let d;
    let e = a.b;
    if (((() => { let f = Formula._a0(b, a.a, 3, e._l, a.d, null, c, d); c = f.p6; d = f.p7; return f.ret; })()) == false) {
      throw ExcelUtils.w(ExcelUtils.ef("LE_ArgumentException_InvalidFormula"), "formula", d);
    }
    let f = e._k._an();
    c._ca(e._k, f, e._l, a.a, false);
    if (f.d) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_FormulaReferencesInvalidCells"), "formula");
    }
    if (e._k != null) {
      e._k._jb(c, null, -1);
    }
    e._j = c;
    a.b._bz = null;
  }
  /**
   * @hidden
   */
  _b3() {
    this._ca(false);
  }
  /**
   * @hidden
   */
  _b4() {
    if (this._j != null) {
      this._j._bu();
    }
    let a = this._k;
    if (a != null) {
      a._is(this._bn);
    }
    if (this._r) {
      let b = typeCast(Worksheet.$, this.scope);
      if (b != null) {
        switch (this._c) {
          case 13:
            b.filterSettings._bm(null);
            break;
          case 6:
            b.printOptions._printAreas$i.clear();
            break;
          case 7:
            b.printOptions.columnsToRepeatAtLeft = null;
            b.printOptions.rowsToRepeatAtTop = null;
            break;
          default: break;
        }
      }
      else if (this.scope == a) {
        a._h1(this);
      }
      else {
      }
    }
    this._bp = null;
  }
  /**
   * @hidden
   */
  _ca(a) {
    if (this._bu) {
      return;
    }
    if (this._r) {
      let b = typeCast(Worksheet.$, this.scope);
      let c = this._k;
      if (b != null && c != null) {
        switch (this._c) {
          case 13:
            b.filterSettings._bq(this, a);
            break;
          case 6:
            {
              let d = b.printOptions._printAreas$i;
              d._t(this._bo(true), a);
            }
            break;
          case 7:
            {
              let e = b.printOptions;
              let f = this._bo(true);
              let g = null;
              let h = null;
              if (typeCast(RegionGroupCalcReference.$, f) !== null) {
                let i = NamedReference._bj(typeCast(RegionGroupCalcReference.$, f));
                for (let j = 0; j < i.length; j++) {
                  let k = NamedReference._b1(i[j], g, h);
                  g = k.p1;
                  h = k.p2;
                }
              }
              else if (typeCast(RegionCalcReference.$, f) !== null) {
                let l = NamedReference._bs(typeCast(RegionCalcReference.$, f));
                let m = NamedReference._b1(l, g, h);
                g = m.p1;
                h = m.p2;
              }
              else if (typeCast(CellCalcReference.$, f) !== null) {
              }
              e._dl(g, true);
              e._dn(h, true);
            }
            break;
          default: break;
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _b1(a, b, c) {
    let d = a.lastColumn - a.firstColumn;
    let e = a.lastRow - a.firstRow;
    if (d < e) {
      b = new RepeatTitleRange(a.firstColumn, a.lastColumn);
    }
    else {
      c = new RepeatTitleRange(a.firstRow, a.lastRow);
    }
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _cb(a, b) {
    let c = this._j;
    if (c == null) {
      return;
    }
    let d = this._k != null ? this._k.cellReferenceMode : 1;
    c._ca(this._k, a, b, d, true);
  }
  /**
   * @hidden
   */
  get__n() {
    return this._bp != null && this._bp.workbook != null && !this._bv;
  }
  /**
   * @hidden
   */
  get _n() {
    return this.get__n();
  }
  /**
   * Gets the formula which defines the named reference.
   * The formula which defines the named reference.
   * @see [[setFormula]]
   * @see [[setFormula]]
   */
  get formula() {
    if (this._j == null) {
      return null;
    }
    let a = this._k;
    if (a == null) {
      return this._j._toString();
    }
    return this._j._toString2(a.cellReferenceMode, a._e6);
  }
  /**
   * Gets the value indicating whether the [[formula]] is a simple formula referring to a single cell, a single region,
   * or multiple regions in the same workbook as the named reference.
   * <p class="body">
   * If the reference is surrounded by parentheses or whitespace or the named reference has some other complex formula this will
   * return false.
   * </p>
   */
  get isSimpleReferenceFormula() {
    return this._bo(false) != null;
  }
  /**
   * Gets the [[WorksheetCell]] referenced by the [[formula]].
   * <p class="body">
   * If named reference is a reference to one or more regions, this will return null.
   * </p>
   * @see [[isSimpleReferenceFormula]]
   */
  get referencedCell() {
    let a = typeCast(CellCalcReference.$, this._bo(true));
    return NamedReference._bq(a);
  }
  /**
   * @hidden
   */
  static _bq(a) {
    if (a == null) {
      return null;
    }
    return a._w._cells$i.item(a._ao);
  }
  /**
   * Gets the [[WorksheetRegion]] referenced by the [[formula]].
   * <p class="body">
   * If the named reference is a reference to a single cell or multiple regions, this will return null.
   * </p>
   * @see [[isSimpleReferenceFormula]]
   */
  get referencedRegion() {
    let a = typeCast(RegionCalcReferenceBase.$, this._bo(true));
    return NamedReference._bs(a);
  }
  /**
   * @hidden
   */
  static _bs(a) {
    if (a == null) {
      return null;
    }
    return a._a3;
  }
  /**
   * Gets the array of [[WorksheetRegion]] instances referenced by the [[formula]].
   * <p class="body">
   * If the named reference is a reference to a single cell or region, this will return null.
   * </p>
   * @see [[isSimpleReferenceFormula]]
   */
  get referencedRegions() {
    let a = typeCast(RegionGroupCalcReference.$, this._bo(true));
    return NamedReference._bj(a);
  }
  /**
   * @hidden
   */
  static _bj(a) {
    if (a == null) {
      return null;
    }
    let b = new Array(a._ba.count);
    a._ba.copyTo(b, 0);
    return b;
  }
  /**
   * @hidden
   */
  get__f() {
    return this._bn;
  }
  /**
   * @hidden
   */
  get _f() {
    return this.get__f();
  }
  /**
   * @hidden
   */
  get _bn() {
    if (this._bm == null) {
      this._bm = new NamedCalcReference(this);
      let a = this._k;
      if (a != null) {
        a._ha(this._bm);
      }
    }
    return this._bm;
  }
  /**
   * @hidden
   */
  get _bv() {
    return this._bu;
  }
  /**
   * @hidden
   */
  set _bv(a) {
    this._bu = a;
  }
  /**
   * @hidden
   */
  get__k() {
    if (this._bp == null) {
      return null;
    }
    return this._bp.workbook;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._k;
  }
  /**
   * @hidden
   */
  get sheet() {
    return null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
NamedReference.$t = markType(NamedReference, 'NamedReference', NamedReferenceBase.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
NamedReference._bx = 2;
/**
 * @hidden
 */
NamedReference._by = 2 + 1;
/**
 * @hidden
 */
NamedReference._bf = NamedReference._bg();
/**
 * @hidden
 */
export class NamedReferenceCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._n;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.b._n;
  }
}
NamedReferenceCollection_CollectionChangeContext.$t = markStruct(NamedReferenceCollection_CollectionChangeContext, 'NamedReferenceCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[NamedReference]] instances in a workbook.
 * @see [[NamedReference]]
 * @see */
export class NamedReferenceCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._n = null;
    this._r = null;
    this._n = a;
    this._r = new List$1(NamedReference.$, 0);
  }
  static staticInit() {
    NamedReferenceCollection._a = NamedReferenceCollection._b();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 3) {
      if (typeCast(Worksheet.$, arguments[2]) !== null) {
        n = 4;
      }
      else if (typeof arguments[2] === 'number') {
        n = 2;
      }
      else if (arguments[2] == null) {
        n = 4;
      }
    }
    else if (arguments.length === 4) {
      n = 3;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      case 2: return this._add2.apply(this, arguments);
      case 3: return this._add3.apply(this, arguments);
      case 4: return this._add4.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddNamedReference"));
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._r.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._r.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _add1(a, b) {
    return this._add2(a, b, this._n.cellReferenceMode);
  }
  /**
   * @hidden
   */
  _add2(a, b, c) {
    return this._i(a, b, c, this._n);
  }
  /**
   * @hidden
   */
  _add4(a, b, c) {
    return this._add3(a, b, this._n.cellReferenceMode, c);
  }
  /**
   * @hidden
   */
  _add3(a, b, c, d) {
    if (d == null) {
      throw new ArgumentNullException(2, "worksheet", ExcelUtils.ef("LE_ArgumentNullException_WorksheetScope"));
    }
    if (d.workbook != this._n) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_WorksheetScopeFromOtherWorkbook"), "worksheet");
    }
    return this._i(a, b, c, d);
  }
  /**
   * Clears all named references from the collection.
   */
  clear() {
    let a = this._r.count > 0 ? this._w(17) : null;
    for (let b = this._r.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._ab(a);
  }
  /**
   * Determines whether a named reference is in the collection.
   * @param namedReference The named reference to locate in the collection.
   * @return True if the named reference is found; False otherwise.
   */
  contains(namedReference) {
    return this._r.contains(namedReference);
  }
  find() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._find.apply(this, arguments);
      case 1: return this._find1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _find(a) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, "name", ExcelUtils.ef("LE_ArgumentNullException_FindNamedReference"));
    }
    return typeCast(NamedReference.$, this.workbook._a3(a));
  }
  /**
   * @hidden
   */
  _find1(a, b) {
    if (b == null) {
      throw new ArgumentNullException(2, "worksheetScope", ExcelUtils.ef("LE_ArgumentNullException_WorksheetScope"));
    }
    return this._l(a, b);
  }
  /**
   * Finds all named references in the collection with the specified name.
   * <p class="body">
   * Named reference names are compared case-insensitively.
   * </p>
   * @param name The name of the named references to find.
   * @throws [[ArgumentNullException]] 'name' is null or empty.
   * @return An array of [[NamedReference]] instances with the specified name.
   */
  findAll(name) {
    if (stringIsNullOrEmpty(name)) {
      throw new ArgumentNullException(2, "name", ExcelUtils.ef("LE_ArgumentNullException_FindNamedReference"));
    }
    let a = new List$1(NamedReference.$, 0);
    for (let b of fromEnum(this._r)) {
      if (StringUtilities.c(name, b.name, this._n._e6, 1) == 0) {
        a.add(b);
      }
    }
    return a.toArray();
  }
  /**
   * Removes the specified named reference from the collection.
   * @param namedReference The named reference to remove fro the collection.
   * @return True if the named reference existed in the collection and was removed; False otherwise.
   */
  remove_1(namedReference) {
    if (namedReference == null) {
      return false;
    }
    let a = this._r.indexOf(namedReference);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the named reference at the specified index in the collection.
   * @param index The zero-based index of the named reference in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    let a = this._r._inner[index];
    let b = NamedReferenceCollection._a[1];
    let c = null;
    if (this._n != null) {
      c = b.b(this._n, null, b.c);
    }
    let d = new NamedReferenceCollection_CollectionChangeContext(1, this, a, index);
    this._r.removeAt(index);
    a._b4();
    this.workbook._h1(a);
    if (this._n != null) {
      b.e(NamedReferenceCollection_CollectionChangeContext.$, NamedReference.$, d, a, null);
      if (c != null) {
        b.d(this._n, c);
      }
    }
  }
  /**
   * @hidden
   */
  _x(a) {
    this._y(a, true);
  }
  /**
   * @hidden
   */
  _y(a, b) {
    this._aa(this._r.count, a, b);
  }
  /**
   * @hidden
   */
  _af(a, b) {
    for (let c of fromEnum(this)) {
      c._cb(a, b);
    }
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    let e = new NamedReference(0, this, d);
    e._bv = true;
    e._be(a, "name", this.workbook.currentFormat);
    e._setFormula2(b, c);
    this._x(e);
    e._bv = false;
    e._a6(true);
    return e;
  }
  /**
   * @hidden
   */
  _l(a, b) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, "name", ExcelUtils.ef("LE_ArgumentNullException_FindNamedReference"));
    }
    for (let c of fromEnum(this._r)) {
      if (c.scope == b && StringUtilities.c(a, c.name, this._n._e6, 1) == 0) {
        return c;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(NamedReferenceCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, NamedReferenceCollection._d(NamedReference.$, "Add", 53, (b) => b.a, (b, c) => NamedReferenceCollection._ad(b, c)));
    ChangeInfo.f(a, 1, NamedReferenceCollection._d(NamedReference.$, "Remove", 54, (b) => b.a, (b, c) => NamedReferenceCollection._ae(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _aa(a, b, c) {
    let d = NamedReferenceCollection._a[0];
    let e = null;
    if (this._n != null) {
      e = d.b(this._n, null, d.c);
    }
    let f = new NamedReferenceCollection_CollectionChangeContext(1, this, b, a);
    this._r.insert(a, b);
    b._b2(this);
    this.workbook._h0(b);
    let g = b._f;
    if (c && b._r) {
      let h = typeCast(Worksheet.$, b.scope);
      if (h != null) {
        NamedReferenceBase._a9(b, h.printOptions);
      }
    }
    if (this._n != null) {
      d.e(NamedReferenceCollection_CollectionChangeContext.$, NamedReference.$, f, null, b);
      if (e != null) {
        d.d(this._n, e);
      }
    }
  }
  /**
   * @hidden
   */
  _w(a) {
    return this._n != null && this._n._cx ? this._n._go(null, a, null) : null;
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a != null) {
      if (this._n != null) {
        this._n._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _ad(a, b) {
    let c = a.b._r.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _ae(a, b) {
    a.b._aa(a.c, a.a, false);
    a.a._b3();
  }
  /**
   * Gets the number of named references in the collection.
   * The number of named references in the collection.
   */
  get count() {
    return this._r.count;
  }
  /**
   * Gets the named reference at the specified index.
   * The named reference at the specified index.
   * @param index The zero-based index of the named reference to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._r._inner[a];
  }
  /**
   * Gets the workbook associated with this collection.
   * The workbook associated with this collection.
   */
  get workbook() {
    return this._n;
  }
}
NamedReferenceCollection.$t = markType(NamedReferenceCollection, 'NamedReferenceCollection', Base.$, [ICollection$1_$type.specialize(NamedReference.$)]);
/**
 * @hidden
 */
NamedReferenceCollection._s = 0;
/**
 * @hidden
 */
NamedReferenceCollection._v = 1;
/**
 * @hidden
 */
NamedReferenceCollection._u = 2;
/**
 * @hidden
 */
NamedReferenceCollection._a = null;
/**
 * @hidden
 */
export class NamedReferenceUnconnected extends NamedReferenceBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          super(null, false);
          this._bf = null;
          this._bh = 0;
          this._bg = 0;
          this._bg = e;
          this._bh = d;
          if (c != null) {
            this._be(c, "Name", d, f);
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          super(d, e);
          this._bf = null;
          this._bh = 0;
          this._bg = 0;
          this._bg = 0;
          this._bh = f;
          if (c != null) {
            this._be(c, "Name", f, g);
          }
        }
        break;
    }
  }
  get__f() {
    if (this._bf == null) {
      this._bf = new NamedCalcReferenceUnconnected(this);
    }
    return this._bf;
  }
  get _f() {
    return this.get__f();
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
  get__z() {
    return ExcelUtils.cq;
  }
  get _z() {
    return this.get__z();
  }
  get__l() {
    return this._bh;
  }
  equals(a) {
    let b = typeCast(NamedReferenceUnconnected.$, a);
    return b != null && this.name == b.name && this._af == b._af;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.name);
  }
  get__t() {
    return false;
  }
  _a1(a, b) {
    let c = this._aw();
    if (this._g == 2) {
      return this._h != null ? this._h.x + "!" + c : c;
    }
    let d = typeCast(WorkbookReferenceBase.$, this.scope);
    if (d != null) {
      return d.z(a, b) + c;
    }
    let e = typeCast(WorksheetReference.$, this.scope);
    if (e != null) {
      return e.o(a, b) + c;
    }
    if (b) {
      let f = typeCast(Workbook.$, this.scope);
      if (f != null) {
        return f._bb.z(a, b) + c;
      }
      let g = typeCast(Worksheet.$, this.scope);
      if (g != null && g.workbook != null) {
        return g.workbook._bb.j(g.name).o(a, b) + c;
      }
    }
    return c;
  }
  get__g() {
    return this._bg;
  }
  get__k() {
    return null;
  }
  get _k() {
    return this.get__k();
  }
  get__h() {
    return typeCast(WorkbookReferenceBase.$, this.scope);
  }
}
NamedReferenceUnconnected.$t = markType(NamedReferenceUnconnected, 'NamedReferenceUnconnected', NamedReferenceBase.$);
/**
 * Base class for horizontal and vertical page breaks in a [[Worksheet]].
 * @see [[PrintOptions.clearPageBreaks]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 * @see [[VerticalPageBreak]]
 */
export class PageBreak extends Base {
  constructor(a, b, c) {
    super();
    this._c = false;
    this._j = 0;
    this._f = true;
    this._n = Nullable$1.toNullable(Number_$type, null);
    this._p = Nullable$1.toNullable(Number_$type, null);
    this._a = null;
    this._j = a;
    this._p = b;
    this._n = c;
  }
  /**
   * Determines whether this [[PageBreak]] is equal to the specified object.
   * @param obj The object to test.
   * @return True if the object is the same type as this PageBreak and has the same data; False otherwise.
   */
  equals(obj) {
    if (obj == null) {
      return false;
    }
    if (getInstanceType(this) != getInstanceType(obj)) {
      return false;
    }
    let a = obj;
    if (this._c != a._c) {
      return false;
    }
    if (this._f != a._f) {
      return false;
    }
    return this._h(a) == 0;
  }
  /**
   * Gets the hash code for the [[PageBreak]].
   * @return A hash code for the instance.
   */
  getHashCode() {
    let a = 0;
    if (this._c) {
      a |= 4096;
    }
    if (this._f) {
      a |= 8192;
    }
    a ^= this._k ^ this._l ^ this._m;
    return a;
  }
  /**
   * @hidden
   */
  _h(a) {
    let b = this._k - a._k;
    if (b != 0) {
      return b;
    }
    b = this._m - a._m;
    if (b != 0) {
      return b;
    }
    b = this._l - a._l;
    if (b != 0) {
      return b;
    }
    if (this._a == a._a) {
      return 0;
    }
    if (this._a == null) {
      return 1;
    }
    if (a._a == null) {
      return -1;
    }
    return WorksheetRegion_HorizontalSorter._a.compare(this._a, a._a);
  }
  /**
   * Gets the print area in which the page break occurs.
   * A  instance that is the print area where the page break occurs or null if the
   * page break occurs across the entire sheet.
   * @see [[WorksheetRegion]]
   * @see [[PrintOptions.printAreas]]
   */
  get printArea() {
    return this._a;
  }
  /**
   * Gets the print area in which the page break occurs.
   * A  instance that is the print area where the page break occurs or null if the
   * page break occurs across the entire sheet.
   * @see [[WorksheetRegion]]
   * @see [[PrintOptions.printAreas]]
   */
  set printArea(a) {
    this._a = a;
  }
  /**
   * @hidden
   */
  get _d() {
    return this._c;
  }
  /**
   * @hidden
   */
  set _d(a) {
    this._c = a;
  }
  /**
   * @hidden
   */
  get _k() {
    return this._j;
  }
  /**
   * @hidden
   */
  set _k(a) {
    this._j = a;
  }
  /**
   * @hidden
   */
  get _g() {
    return this._f;
  }
  /**
   * @hidden
   */
  set _g(a) {
    this._f = a;
  }
  /**
   * @hidden
   */
  get _o() {
    return this._n;
  }
  /**
   * @hidden
   */
  get _l() {
    let a = this._o;
    return a.hasValue ? a.value : 0x7FFFFFFF;
  }
  /**
   * @hidden
   */
  get _q() {
    return this._p;
  }
  /**
   * @hidden
   */
  get _m() {
    let a = this._q;
    return a.hasValue ? a.value : 0;
  }
}
PageBreak.$t = markType(PageBreak, 'PageBreak');
/**
 * Represents a horizontal page break in a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 */
export class HorizontalPageBreak extends PageBreak {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    else if (arguments.length === 3) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let firstRowOnPage = _rest[0];
          let b = [firstRowOnPage, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null)];
          {
            let firstRowOnPage = b[0];
            let min = b[1];
            let max = b[2];
            super(firstRowOnPage, min, max);
          }
        }
        break;
      case 1:
        {
          let firstRowOnPage = _rest[0];
          let printArea = _rest[1];
          let b = [firstRowOnPage, HorizontalPageBreak._s(printArea, true), HorizontalPageBreak._s(printArea, false)];
          {
            let firstRowOnPage = b[0];
            let min = b[1];
            let max = b[2];
            super(firstRowOnPage, min, max);
          }
          this.printArea = printArea;
          if (printArea != null) {
            if (firstRowOnPage <= printArea.firstRow || printArea.lastRow < firstRowOnPage) {
              throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_MustBeWithinPrintArea"), "printArea");
            }
          }
        }
        break;
      case 2:
        {
          let firstRowOnPage = _rest[0];
          let min = _rest[1];
          let max = _rest[2];
          super(firstRowOnPage, min, max);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  compareTo(other) {
    return this._h(other);
  }
  /**
   * @hidden
   */
  static _s(a, b) {
    if (a == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (b) {
      return Nullable$1.toNullable(Number_$type, a.firstColumn);
    }
    else {
      return Nullable$1.toNullable(Number_$type, a.lastColumn);
    }
  }
  /**
   * Gets the 0-based index of the first row on the page after this break.
   */
  get firstRowOnPage() {
    return this._k;
  }
}
HorizontalPageBreak.$t = markType(HorizontalPageBreak, 'HorizontalPageBreak', PageBreak.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export class PageBreakCollection_CollectionChangeContext$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.a = null;
    this.b = null;
    this.c = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._e._ck == null ? null : this.a._e._ck.workbook;
  }
  get sheet() {
    return this.a._e._ck;
  }
  get source() {
    return this.a._e._ck;
  }
}
PageBreakCollection_CollectionChangeContext$1.$t = markStruct(PageBreakCollection_CollectionChangeContext$1, 'PageBreakCollection_CollectionChangeContext$1', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Base class for the collections of horizontal and vertical page breaks on a [[worksheet]].
 * @typedef T The type of page break the collection contains.
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreakCollection]]
 * @see [[VerticalPageBreakCollection]]
 */
export class PageBreakCollection$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    /**
     * @hidden
     */
    this._e = null;
    this._i = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._e = a;
    this._i = new List$1(this.$t, 0);
  }
  /**
   * @hidden
   */
  insert(index, item) {
    return this._insert$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _insert$i(a, b) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_PB_CantInsertBreakAtIndex"));
  }
  item() {
    if (arguments.length === 2) {
      return this._item$e.apply(this, arguments);
    }
    else {
      return this._item.apply(this, arguments);
    }
  }
  /**
   * @hidden
   */
  _item$e(a, b) {
    if (arguments.length === 2) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_PB_CantSetBreakAtIndex"));
      return b;
    }
    else {
      return this._item(a);
    }
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._i.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._i.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a page break to the [[worksheet]].
   * @param pageBreak The page break to add to the Worksheet.
   * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
   * @throws [[ArgumentException]] Occurs when 'pageBreak' overlaps with another page break already in the collection.
   * @see [[PrintOptions.insertPageBreak]]
   * @see [[PrintOptions.insertPageBreak]]
   * @see [[PrintOptions.insertPageBreak]]
   */
  add(pageBreak) {
    return this._add$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _add$i(a) {
    this._g(a, true);
  }
  /**
   * @hidden
   */
  _g(a, b) {
    if (a == null) {
      throw new ArgumentNullException(0, "pageBreak");
    }
    if (a.printArea != null) {
      if (a.printArea.worksheet == null) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PrintAreaShiftedOffWorksheet"), "pageBreak");
      }
      if (a.printArea.worksheet != this._f) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_PrintAreaMustBeOnSameWorksheet"), "pageBreak");
      }
      if (this._e._printAreas$i.contains(a.printArea) == false) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_PrintAreaMustBeInPrintAreas"), "pageBreak");
      }
    }
    let c = this._i.f(a);
    if (0 <= c) {
      if (b) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_PageBreaksCannotAddExistingInstance"), "pageBreak");
      }
      return false;
    }
    c = ~c;
    if (0 < c) {
      let d = this._i._inner[c - 1];
      if (a._k == d._k && a._q.hasValue && d._q.hasValue && a._m <= d._l) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_PageBreaksCannotOverlap"), "pageBreak");
      }
    }
    if (c < this._i.count) {
      let e = this._i._inner[c];
      if (a._k == e._k && a._o.hasValue && e._o.hasValue && e._m <= a._l) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_PageBreaksCannotOverlap"), "pageBreak");
      }
    }
    this._o(c, a);
    return true;
  }
  /**
   * Clears the collection of page breaks.
   * @see [[PrintOptions.clearPageBreaks]]
   */
  clear() {
    let a = false == this._e._v && this._i.count > 0 ? this._n(19) : null;
    for (let b = this._i.count - 1; b >= 0; b--) {
      this._p(b);
    }
    this._q(a);
  }
  /**
   * Determines whether the specified page break exists on the [[worksheet]].
   * @param pageBreak The page break to test.
   * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
   * @return True if the page break is on the Worksheet; False otherwise.
   */
  contains(pageBreak) {
    return this._contains$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _contains$i(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "pageBreak");
    }
    return this._i.contains(a);
  }
  /**
   * Gets the 0-based index of the specified page break.
   * @param pageBreak The page break for which the index should be obtained.
   * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
   * @return The 0-based index of the page break or -1 if the page break is no tin the collection.
   */
  indexOf(pageBreak) {
    return this._indexOf$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _indexOf$i(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "pageBreak");
    }
    return this._i.indexOf(a);
  }
  /**
   * Removes the specified page break from the [[worksheet]].
   * @param pageBreak The page break which should be removed.
   * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
   * @return True if the page break was contained on the Worksheet before removal; False otherwise.
   * @see [[PrintOptions.clearPageBreaks]]
   */
  remove(pageBreak) {
    return this._remove$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _remove$i(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "pageBreak");
    }
    return this._i.remove(a);
  }
  /**
   * Removes the page break at the specified index.
   * @param index The 0-based index of the page break to remove.
   * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than zero or greater than or equal to the number of page breaks in the collection.
   * @see [[PrintOptions.clearPageBreaks]]
   */
  removeAt(index) {
    this._p(index);
  }
  /**
   * @hidden
   */
  _k() {
    let a = 0;
    for (let b = 0; b < this._i.count; b++) {
      if (this._i._inner[b]._g) {
        a++;
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  static _c($t, $tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(PageBreakCollection_CollectionChangeContext$1.$.specialize($t), $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b($t) {
    let a = new Array(2);
    ChangeInfo.f(a, 0, PageBreakCollection$1._c($t, $t, "Add", 55, (b) => b.b, (b, c) => PageBreakCollection$1._r($t, b, c)));
    ChangeInfo.f(a, 1, PageBreakCollection$1._c($t, $t, "Remove", 56, (b) => b.b, (b, c) => PageBreakCollection$1._s($t, b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _o(a, b) {
    let c = this.$type.getStaticFields(PageBreakCollection$1.$)._a[0];
    let d = null;
    let e = false == this._e._v && this._e._ck.workbook != null;
    if (e) {
      d = c.b(this._e._ck.workbook, this._e._ck, c.c);
    }
    let f = new PageBreakCollection_CollectionChangeContext$1(this.$t, 1, this, b, a);
    this._i.insert(a, b);
    if (e) {
      c.e(PageBreakCollection_CollectionChangeContext$1.$.specialize(this.$t), this.$t, f, null, b);
      if (d != null) {
        c.d(this._e._ck.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _p(a) {
    let b = this._i._inner[a];
    let c = this.$type.getStaticFields(PageBreakCollection$1.$)._a[1];
    let d = null;
    let e = false == this._e._v && this._e._ck.workbook != null;
    if (e) {
      d = c.b(this._e._ck.workbook, this._e._ck, c.c);
    }
    let f = new PageBreakCollection_CollectionChangeContext$1(this.$t, 1, this, b, a);
    this._i.removeAt(a);
    if (e) {
      c.e(PageBreakCollection_CollectionChangeContext$1.$.specialize(this.$t), this.$t, f, b, null);
      if (d != null) {
        c.d(this._e._ck.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = this._e._ck == null ? null : this._e._ck.workbook;
    return b != null && b._cx ? b._go(this._e._ck, a, null) : null;
  }
  /**
   * @hidden
   */
  _q(a) {
    if (a != null) {
      let b = this._e._ck.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _r($t, a, b) {
    let c = a.a._i.indexOf(a.b);
    if (c >= 0) {
      a.a.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _s($t, a, b) {
    a.a._o(a.c, a.b);
  }
  /**
   * Gets the number of page breaks in this collection.
   */
  get count() {
    return this._i.count;
  }
  /**
   * @hidden
   */
  _item(a) {
    return this._i._inner[a];
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e._ck;
  }
}
PageBreakCollection$1.$t = markType(PageBreakCollection$1, 'PageBreakCollection$1', Base.$, [IList$1_$type.specialize(0)], function () {
  this._a = PageBreakCollection$1._b(arguments[0]);
});
/**
 * @hidden
 */
PageBreakCollection$1._j = 0;
/**
 * @hidden
 */
PageBreakCollection$1._m = 1;
/**
 * @hidden
 */
PageBreakCollection$1._l = 2;
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 */
export class HorizontalPageBreakCollection extends PageBreakCollection$1 {
  constructor(a) {
    super(HorizontalPageBreak.$, a);
  }
  /**
   * @hidden
   */
  get__h() {
    return false;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
  /**
   * @hidden
   */
  _t(a) {
    let b = new List$1(HorizontalPageBreak.$, 1, this);
    for (let c of fromEnum(b)) {
      let d = new WorksheetRegionAddress();
      if (c.printArea == null) {
        d = new WorksheetRegionAddress(1, c.firstRowOnPage, c.firstRowOnPage, 0, (this._f._columns$i.maxCount - 1));
      }
      else {
        let e = c.printArea;
        if (e.worksheet == null) {
          this._remove$i(c);
          continue;
        }
        d = new WorksheetRegionAddress(1, c.firstRowOnPage, c.firstRowOnPage, e._v, e._w);
      }
      let f = ((() => { let g = a.e(d, true); d = g.p0; return g.ret; })());
      if (f.f) {
        this._remove$i(c);
        if (f.g == false) {
          c._k = d._ac;
          this._g(c, false);
        }
      }
    }
  }
}
HorizontalPageBreakCollection.$t = markType(HorizontalPageBreakCollection, 'HorizontalPageBreakCollection', PageBreakCollection$1.$.specialize(HorizontalPageBreak.$));
/**
 * Represents a vertical page break in a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 */
export class VerticalPageBreak extends PageBreak {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    else if (arguments.length === 3) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let firstColumOnPage = _rest[0];
          let b = [firstColumOnPage, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null)];
          {
            let firstColumOnPage = b[0];
            let min = b[1];
            let max = b[2];
            super(firstColumOnPage, min, max);
          }
        }
        break;
      case 1:
        {
          let firstColumOnPage = _rest[0];
          let printArea = _rest[1];
          let b = [firstColumOnPage, VerticalPageBreak._s(printArea, true), VerticalPageBreak._s(printArea, false)];
          {
            let firstColumOnPage = b[0];
            let min = b[1];
            let max = b[2];
            super(firstColumOnPage, min, max);
          }
          this.printArea = printArea;
          if (printArea != null) {
            if (firstColumOnPage <= printArea.firstColumn || printArea.lastColumn < firstColumOnPage) {
              throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_PB_MustBeWithinPrintArea"), "printArea");
            }
          }
        }
        break;
      case 2:
        {
          let firstColumOnPage = _rest[0];
          let min = _rest[1];
          let max = _rest[2];
          super(firstColumOnPage, min, max);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  compareTo(other) {
    return this._h(other);
  }
  /**
   * @hidden
   */
  static _s(a, b) {
    if (a == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (b) {
      return Nullable$1.toNullable(Number_$type, a.firstRow);
    }
    else {
      return Nullable$1.toNullable(Number_$type, a.lastRow);
    }
  }
  /**
   * Gets the 0-based index of the first column on the page after this break.
   */
  get firstColumnOnPage() {
    return this._k;
  }
}
VerticalPageBreak.$t = markType(VerticalPageBreak, 'VerticalPageBreak', PageBreak.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[VerticalPageBreak]]
 */
export class VerticalPageBreakCollection extends PageBreakCollection$1 {
  constructor(a) {
    super(VerticalPageBreak.$, a);
  }
  /**
   * @hidden
   */
  get__h() {
    return true;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
}
VerticalPageBreakCollection.$t = markType(VerticalPageBreakCollection, 'VerticalPageBreakCollection', PageBreakCollection$1.$.specialize(VerticalPageBreak.$));
/**
 * @hidden
 */
export class PrintAreasCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._d._ck == null ? null : this.a._d._ck.workbook;
  }
  get sheet() {
    return this.a._d._ck;
  }
  get source() {
    return this.a._d._ck;
  }
}
PrintAreasCollection_CollectionChangeContext.$t = markStruct(PrintAreasCollection_CollectionChangeContext, 'PrintAreasCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Gets the collection of print areas in a [[Worksheet]] or a worksheet's print settings in a [[CustomView]].
 * @see [[PrintOptions.printAreas]]
 */
export class PrintAreasCollection extends Base {
  constructor(a) {
    super();
    this._g = false;
    this._h = null;
    /**
     * @hidden
     */
    this._d = null;
    this._d = a;
    this._h = new List$1(WorksheetRegion.$, 0);
  }
  static staticInit() {
    PrintAreasCollection._a = PrintAreasCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._h.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._h.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a print area to the collection.
   * @param printArea The print area to add to the collection.
   * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
   * @throws [[ArgumentException]] Occurs when 'printArea' overlaps with another print area in the collection.
   */
  add(printArea) {
    if (printArea == null) {
      throw new ArgumentNullException(0, "printArea");
    }
    for (let a = 0; a < this._h.count; a++) {
      if (this._h._inner[a]._s(printArea)) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_PA_PrintAreasCannotOverlap"));
      }
    }
    this._o(printArea, false);
  }
  /**
   * @hidden
   */
  _o(a, b) {
    this._p(this._h.count, a, b);
  }
  /**
   * Clears all print areas from the collection.
   * <p class="body">
   * If any page breaks are contained in a print area, they will be removed from their collection.
   * </p>
   * @see [[PrintOptions.horizontalPageBreaks]]
   * @see [[PrintOptions.verticalPageBreaks]]
   */
  clear() {
    if (this.count == 0) {
      return;
    }
    for (let a = this.count - 1; a >= 0; a--) {
      this._s(a, true);
    }
    this._q(false);
    if (false == this._d._v && this._d._ck.workbook != null) {
      PrintAreasCollection._a[1].e(PrintAreasCollection_CollectionChangeContext.$, WorksheetRegion.$, new PrintAreasCollection_CollectionChangeContext(1, this, null, -1), null, null);
    }
  }
  /**
   * Determines whether the specified print area is in the collection.
   * @param printArea The print area to search for in the collection.
   * @return True if the print area is in the collection; False otherwise.
   */
  contains(printArea) {
    if (printArea == null) {
      return false;
    }
    return this._h.contains(printArea);
  }
  /**
   * Removes the specified print area from the collection.
   * <p class="body">
   * If any page breaks are contained in the removed print area, they will be removed from their collection.
   * </p>
   * @param printArea The print area to remove from the collection.
   * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
   * @return True if the print area was found and removed; False otherwise.
   * @see [[PrintOptions.horizontalPageBreaks]]
   * @see [[PrintOptions.verticalPageBreaks]]
   */
  remove(printArea) {
    if (printArea == null) {
      throw new ArgumentNullException(0, "printArea");
    }
    let a = this._h.indexOf(printArea);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the print area at the specified index from the collection.
   * <p class="body">
   * If any page breaks are contained in the removed print area, they will be removed from their collection.
   * </p>
   * @param index The index of the print area to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
   * @see [[PrintOptions.horizontalPageBreaks]]
   * @see [[PrintOptions.verticalPageBreaks]]
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw new ArgumentOutOfRangeException(1, "index");
    }
    this._s(index, false);
    this._q(false);
  }
  /**
   * @hidden
   */
  _m(a) {
    this._h.add(a);
  }
  /**
   * @hidden
   */
  _n() {
    this._h.clear();
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    if (nullableEquals(b, null) && nullableEquals(c, null)) {
      return null;
    }
    let e = this._d._ck;
    let f = b.hasValue ? b.value : 0;
    let g = c.hasValue ? c.value : (d ? e._rows$i.maxCount : e._columns$i.maxCount) - 1;
    for (let h = 0; h < this._h.count; h++) {
      let i = this._h._inner[h];
      if (d) {
        if (nullableEquals(i.firstRow, b) && nullableEquals(i.lastRow, c)) {
          if (i.firstColumn <= a && a <= i.lastColumn) {
            return i;
          }
        }
      }
      else {
        if (nullableEquals(i.firstColumn, b) && nullableEquals(i.lastColumn, c)) {
          if (i.firstRow <= a && a <= i.lastRow) {
            return i;
          }
        }
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _t(a, b) {
    if (this._g) {
      return;
    }
    if (b) {
      this._n();
    }
    if (typeCast(RegionGroupCalcReference.$, a) !== null) {
      let c = NamedReference._bj(typeCast(RegionGroupCalcReference.$, a));
      for (let d = 0; d < c.length; d++) {
        this._o(c[d], true);
      }
    }
    else if (typeCast(RegionCalcReference.$, a) !== null) {
      let e = NamedReference._bs(typeCast(RegionCalcReference.$, a));
      this._o(e, true);
    }
    else if (typeCast(CellCalcReference.$, a) !== null) {
      let f = NamedReference._bq(typeCast(CellCalcReference.$, a));
      this._o(f._l(), true);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = false, g = false, h = 8192) {
    return new ChangeInfo$2(PrintAreasCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, PrintAreasCollection._c(WorksheetRegion.$, "Add", 57, (b) => b.b, (b, c) => {
    }));
    ChangeInfo.f(a, 1, PrintAreasCollection._c(WorksheetRegion.$, "Clear", 20, (b) => b.b, (b, c) => {
    }));
    ChangeInfo.f(a, 2, PrintAreasCollection._c(WorksheetRegion.$, "Remove", 58, (b) => b.b, (b, c) => {
    }));
    return a;
  }
  /**
   * @hidden
   */
  _p(a, b, c) {
    this._h.insert(a, b);
    this._q(c);
    if (false == this._d._v && this._d._ck.workbook != null) {
      PrintAreasCollection._a[0].e(PrintAreasCollection_CollectionChangeContext.$, WorksheetRegion.$, new PrintAreasCollection_CollectionChangeContext(1, this, b, a), null, b);
    }
  }
  /**
   * @hidden
   */
  _q(a) {
    this._g = true;
    try {
      this._d._ds(a);
    }
    finally {
      this._g = false;
    }
  }
  /**
   * @hidden
   */
  _s(a, b) {
    let c = this.item(a);
    for (let d = this._d._horizontalPageBreaks$i.count - 1; d >= 0; d--) {
      if (this._d._horizontalPageBreaks$i._item(d).printArea == c) {
        this._d._horizontalPageBreaks$i.removeAt(d);
      }
    }
    for (let e = this._d._verticalPageBreaks$i.count - 1; e >= 0; e--) {
      if (this._d._verticalPageBreaks$i._item(e).printArea == c) {
        this._d._verticalPageBreaks$i.removeAt(e);
      }
    }
    this._h.removeAt(a);
    if (false == this._d._v && this._d._ck.workbook != null) {
      PrintAreasCollection._a[2].e(PrintAreasCollection_CollectionChangeContext.$, WorksheetRegion.$, new PrintAreasCollection_CollectionChangeContext(1, this, c, a), c, null);
    }
  }
  /**
   * Gets the number of print areas in the collection.
   */
  get count() {
    return this._h.count;
  }
  /**
   * Gets the print area at the specified index.
   * @param index The index of the print area to get.
   * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
   * @return A [[WorksheetRegion]] instance representing a print area in the [[Worksheet]].
   */
  item(a) {
    return this._h._inner[a];
  }
}
PrintAreasCollection.$t = markType(PrintAreasCollection, 'PrintAreasCollection', Base.$, [ICollection$1_$type.specialize(WorksheetRegion.$)]);
/**
 * @hidden
 */
PrintAreasCollection._i = 0;
/**
 * @hidden
 */
PrintAreasCollection._j = 1;
/**
 * @hidden
 */
PrintAreasCollection._l = 2;
/**
 * @hidden
 */
PrintAreasCollection._k = 3;
/**
 * @hidden
 */
PrintAreasCollection._a = null;
/**
 * Base class which exposes the various print options available for a sheet which can be saved with both a
 * sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export class PrintOptionsBase extends Base {
  constructor(a, b) {
    super();
    this._t = null;
    this._at = 0.7;
    this._ax = 0.75;
    this._av = 0.7;
    this._ah = 0.75;
    this._ar = 0.3;
    this._ap = 0.3;
    this._ab = false;
    this._bv = stringEmpty();
    this._bx = stringEmpty();
    this._bb = 1;
    this._e = 2;
    this._i = 0;
    this._l = 1;
    this._o = 0;
    this._ad = false;
    this._r = 0;
    this._bk = 600;
    this._bo = 1;
    this._bs = 600;
    /**
     * @hidden
     */
    this._v = false;
    /**
     * @hidden
     */
    this._c = null;
    this._alignHeadersAndFootersWithMargins = false;
    this._scaleHeadersAndFootersWithDocument = false;
    this._t = a;
    this.alignHeadersAndFootersWithMargins = true;
    this.scaleHeadersAndFootersWithDocument = true;
    this._v = b;
  }
  /**
   * Resets the print options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  reset() {
    this._ah = 0.75;
    this._ab = false;
    this._bv = stringEmpty();
    this._ap = 0.3;
    this._bx = stringEmpty();
    this._ar = 0.3;
    this._at = 0.7;
    this._bb = 1;
    this._e = 2;
    this._i = 0;
    this._l = 1;
    this._o = 0;
    this._ad = false;
    this._r = 0;
    this._bk = 600;
    this._av = 0.7;
    this._bo = 1;
    this._ax = 0.75;
    this._bs = 600;
    this.alignHeadersAndFootersWithMargins = true;
    this.scaleHeadersAndFootersWithDocument = true;
  }
  /**
   * @hidden
   */
  _bz(a) {
    this._ah = a._ah;
    this._ab = a._ab;
    this._bv = a._bv;
    this._ap = a._ap;
    this._bx = a._bx;
    this._ar = a._ar;
    this._at = a._at;
    this._bb = a._bb;
    this._e = a._e;
    this._i = a._i;
    this._l = a._l;
    this._o = a._o;
    this._ad = a._ad;
    this._r = a._r;
    this._bk = a._bk;
    this._av = a._av;
    this._bo = a._bo;
    this._ax = a._ax;
    this._bs = a._bs;
    this.alignHeadersAndFootersWithMargins = a.alignHeadersAndFootersWithMargins;
    this.scaleHeadersAndFootersWithDocument = a.scaleHeadersAndFootersWithDocument;
    this._c = a._c;
  }
  /**
   * @hidden
   */
  _ag() {
    return this._l != 1 || this._bo != 1 || this._e != 2 || this._ad != false || this._ab != false || this._r != 0 || this._i != 0 || this._o != 0 || this._bk != 600 || this._bs != 600 || this._bb != 1 || this._c != null;
  }
  /**
   * @hidden
   */
  _b1(a, b) {
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d = null, e = false, f = false, g = 0) {
    return new ChangeInfo$2(PrintOptionsBase.$, $tValue, a, 59, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(19);
    ChangeInfo.f(a, 0, PrintOptionsBase._d(Number_$type, "BottomMargin", (b) => b.bottomMargin, (b, c) => b.bottomMargin = c));
    ChangeInfo.f(a, 1, PrintOptionsBase._d(Boolean_$type, "DraftQuality", (b) => b.draftQuality, (b, c) => b.draftQuality = c));
    ChangeInfo.f(a, 2, PrintOptionsBase._d(String_$type, "Footer", (b) => b.footer, (b, c) => b.footer = c));
    ChangeInfo.f(a, 3, PrintOptionsBase._d(Number_$type, "FooterMargin", (b) => b.footerMargin, (b, c) => b.footerMargin = c));
    ChangeInfo.f(a, 4, PrintOptionsBase._d(String_$type, "Header", (b) => b.header, (b, c) => b.header = c));
    ChangeInfo.f(a, 5, PrintOptionsBase._d(Number_$type, "HeaderMargin", (b) => b.headerMargin, (b, c) => b.headerMargin = c));
    ChangeInfo.f(a, 6, PrintOptionsBase._d(Number_$type, "LeftMargin", (b) => b.leftMargin, (b, c) => b.leftMargin = c));
    ChangeInfo.f(a, 7, PrintOptionsBase._d(Number_$type, "NumberOfCopies", (b) => b.numberOfCopies, (b, c) => b.numberOfCopies = c));
    ChangeInfo.f(a, 8, PrintOptionsBase._d(Orientation_$type, "Orientation", (b) => b.orientation, (b, c) => b.orientation = c));
    ChangeInfo.f(a, 9, PrintOptionsBase._d(PageNumbering_$type, "PageNumbering", (b) => b.pageNumbering, (b, c) => b.pageNumbering = c));
    ChangeInfo.f(a, 10, PrintOptionsBase._d(PaperSize_$type, "PaperSize", (b) => b.paperSize, (b, c) => b.paperSize = c));
    ChangeInfo.f(a, 11, PrintOptionsBase._d(PrintErrors_$type, "PrintErrors", (b) => b.printErrors, (b, c) => b.printErrors = c));
    ChangeInfo.f(a, 12, PrintOptionsBase._d(Boolean_$type, "PrintInBlackAndWhite", (b) => b.printInBlackAndWhite, (b, c) => b.printInBlackAndWhite = c));
    ChangeInfo.f(a, 13, PrintOptionsBase._d(PrintNotes_$type, "PrintNotes", (b) => b.printNotes, (b, c) => b.printNotes = c));
    ChangeInfo.f(a, 14, PrintOptionsBase._d(Number_$type, "Resolution", (b) => b.resolution, (b, c) => b.resolution = c));
    ChangeInfo.f(a, 15, PrintOptionsBase._d(Number_$type, "RightMargin", (b) => b.rightMargin, (b, c) => b.rightMargin = c));
    ChangeInfo.f(a, 16, PrintOptionsBase._d(Number_$type, "StartPageNumber", (b) => b.startPageNumber, (b, c) => b.startPageNumber = c));
    ChangeInfo.f(a, 17, PrintOptionsBase._d(Number_$type, "TopMargin", (b) => b.topMargin, (b, c) => b.topMargin = c));
    ChangeInfo.f(a, 18, PrintOptionsBase._d(Number_$type, "VerticalResolution", (b) => b.verticalResolution, (b, c) => b.verticalResolution = c));
    return a;
  }
  /**
   * @hidden
   */
  get _u() {
    return this._t;
  }
  /**
   * Gets or sets the value indicating whether to align header and footer margins with page margins.
   * @see [[header]]
   * @see [[footer]]
   * @see [[headerMargin]]
   * @see [[footerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   */
  get alignHeadersAndFootersWithMargins() {
    return this._alignHeadersAndFootersWithMargins;
  }
  /**
   * Gets or sets the value indicating whether to align header and footer margins with page margins.
   * @see [[header]]
   * @see [[footer]]
   * @see [[headerMargin]]
   * @see [[footerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   */
  set alignHeadersAndFootersWithMargins(a) {
    this._alignHeadersAndFootersWithMargins = a;
  }
  /**
   * Gets or sets the margin at the bottom of each printed page of the worksheet, specified in inches.
   * The margin at the bottom of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  get bottomMargin() {
    return this._ah;
  }
  /**
   * Gets or sets the margin at the bottom of each printed page of the worksheet, specified in inches.
   * The margin at the bottom of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  set bottomMargin(a) {
    if (this._ah != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._ah = a;
      }
      else {
        let b = PrintOptionsBase._a[0].g(PrintOptionsBase.$, Number_$type, this, this._ah, a);
        this._ah = b.p1;
      }
    }
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be printed using draft quality.
   * The value indicating whether the printed pages should be printed using draft quality.
   */
  get draftQuality() {
    return this._ab;
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be printed using draft quality.
   * The value indicating whether the printed pages should be printed using draft quality.
   */
  set draftQuality(a) {
    if (a != this._ab) {
      if (this._v) {
        this._ab = a;
      }
      else {
        let b = PrintOptionsBase._a[1].g(PrintOptionsBase.$, Boolean_$type, this, this._ab, a);
        this._ab = b.p1;
      }
    }
  }
  /**
   * Gets or sets the footer for each page of the printed worksheet.
   * <p class="body">
   * The '&' character in the header and footer is a special character. Depending on what is after it,
   * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
   * the available commands:
   * <list type="table">
   * 		<listheader>
   * 			<term>Section commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&L</term>
   * 			<description>
   * 				The following text will appear in the left section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&C</term>
   * 			<description>
   * 				The following text will appear in the center section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&R</term>
   * 			<description>
   * 				The following text will appear in the right section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 		<listheader>
   * 			<term>Replacement commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&&</term>
   * 			<description>Insert the '&' character.</description>
   * 		</item>
   * 		<item>
   * 			<term>&A</term>
   * 			<description>Insert the current worksheet name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&D</term>
   * 			<description>Insert the current date.</description>
   * 		</item>
   * 		<item>
   * 			<term>&F</term>
   * 			<description>Insert the current file name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&G</term>
   * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
   * 		</item>
   * 		<item>
   * 			<term>&N</term>
   * 			<description>Insert the  number of pages the worksheet will need to print.</description>
   * 		</item>
   * 		<item>
   * 			<term>&P</term>
   * 			<description>Insert the current page number.</description>
   * 		</item>
   * 		<item>
   * 			<term>&T</term>
   * 			<description>Insert the current time.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Z</term>
   * 			<description>Insert the current file path (without the file name).</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 	<listheader>
   * 			<term>Formatting commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&B</term>
   * 			<description>Toggle bold.</description>
   * 		</item>
   * 		<item>
   * 			<term>&E</term>
   * 			<description>Toggle double underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&I</term>
   * 			<description>Toggle italics.</description>
   * 		</item>
   * 		<item>
   * 			<term>&S</term>
   * 			<description>Toggle strikethrough.</description>
   * 		</item>
   * 		<item>
   * 			<term>&U</term>
   * 			<description>Toggle underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&X</term>
   * 			<description>Toggle superscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Y</term>
   * 			<description>Toggle subscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&<FontSize></term>
   * 			<description>
   * 				Sets a new font size for the following text. The size is expressed as a positive integer.
   * 				If a number is to follow this command in the header, it must be separated by a space.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>"</term>
   * 			<description>
   * 				Sets a new font for the following text. If the font name is not recognized, the default
   * 				font will be used.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>,<FontStyle>"</term>
   * 			<description>
   * 				Sets the new font and font style for the following text. The font style is usually "Regular",
   * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
   * 				available font styles can be seen in the font dialog when a font is selected.
   * 			</description>
   * 		</item>
   * 	</list>
   * </p>
   * <p class="body">
   * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
   * &N on &A&R&14&F.
   * </p>
   * The footer for each page of the worksheet.
   * @see [[header]]
   * @see [[footerMargin]]
   */
  get footer() {
    return this._bv;
  }
  /**
   * Gets or sets the footer for each page of the printed worksheet.
   * <p class="body">
   * The '&' character in the header and footer is a special character. Depending on what is after it,
   * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
   * the available commands:
   * <list type="table">
   * 		<listheader>
   * 			<term>Section commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&L</term>
   * 			<description>
   * 				The following text will appear in the left section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&C</term>
   * 			<description>
   * 				The following text will appear in the center section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&R</term>
   * 			<description>
   * 				The following text will appear in the right section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 		<listheader>
   * 			<term>Replacement commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&&</term>
   * 			<description>Insert the '&' character.</description>
   * 		</item>
   * 		<item>
   * 			<term>&A</term>
   * 			<description>Insert the current worksheet name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&D</term>
   * 			<description>Insert the current date.</description>
   * 		</item>
   * 		<item>
   * 			<term>&F</term>
   * 			<description>Insert the current file name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&G</term>
   * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
   * 		</item>
   * 		<item>
   * 			<term>&N</term>
   * 			<description>Insert the  number of pages the worksheet will need to print.</description>
   * 		</item>
   * 		<item>
   * 			<term>&P</term>
   * 			<description>Insert the current page number.</description>
   * 		</item>
   * 		<item>
   * 			<term>&T</term>
   * 			<description>Insert the current time.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Z</term>
   * 			<description>Insert the current file path (without the file name).</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 	<listheader>
   * 			<term>Formatting commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&B</term>
   * 			<description>Toggle bold.</description>
   * 		</item>
   * 		<item>
   * 			<term>&E</term>
   * 			<description>Toggle double underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&I</term>
   * 			<description>Toggle italics.</description>
   * 		</item>
   * 		<item>
   * 			<term>&S</term>
   * 			<description>Toggle strikethrough.</description>
   * 		</item>
   * 		<item>
   * 			<term>&U</term>
   * 			<description>Toggle underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&X</term>
   * 			<description>Toggle superscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Y</term>
   * 			<description>Toggle subscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&<FontSize></term>
   * 			<description>
   * 				Sets a new font size for the following text. The size is expressed as a positive integer.
   * 				If a number is to follow this command in the header, it must be separated by a space.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>"</term>
   * 			<description>
   * 				Sets a new font for the following text. If the font name is not recognized, the default
   * 				font will be used.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>,<FontStyle>"</term>
   * 			<description>
   * 				Sets the new font and font style for the following text. The font style is usually "Regular",
   * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
   * 				available font styles can be seen in the font dialog when a font is selected.
   * 			</description>
   * 		</item>
   * 	</list>
   * </p>
   * <p class="body">
   * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
   * &N on &A&R&14&F.
   * </p>
   * The footer for each page of the worksheet.
   * @see [[header]]
   * @see [[footerMargin]]
   */
  set footer(a) {
    if (a != this._bv) {
      if (this._v) {
        this._bv = a;
      }
      else {
        let b = PrintOptionsBase._a[2].g(PrintOptionsBase.$, String_$type, this, this._bv, a);
        this._bv = b.p1;
      }
    }
  }
  /**
   * Gets or sets the footer margin for each printed page of the worksheet, specified in inches.
   * The footer margin for each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[footer]]
   * @see [[bottomMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  get footerMargin() {
    return this._ap;
  }
  /**
   * Gets or sets the footer margin for each printed page of the worksheet, specified in inches.
   * The footer margin for each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[footer]]
   * @see [[bottomMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  set footerMargin(a) {
    if (this._ap != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._ap = a;
      }
      else {
        let b = PrintOptionsBase._a[3].g(PrintOptionsBase.$, Number_$type, this, this._ap, a);
        this._ap = b.p1;
      }
    }
  }
  /**
   * Gets or sets the header for each page of the printed worksheet.
   * <p class="body">
   * The '&' character in the header and footer is a special character. Depending on what is after it,
   * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
   * the available commands:
   * <list type="table">
   * 		<listheader>
   * 			<term>Section commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&L</term>
   * 			<description>
   * 				The following text will appear in the left section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&C</term>
   * 			<description>
   * 				The following text will appear in the center section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&R</term>
   * 			<description>
   * 				The following text will appear in the right section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 		<listheader>
   * 			<term>Replacement commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&&</term>
   * 			<description>Insert the '&' character.</description>
   * 		</item>
   * 		<item>
   * 			<term>&A</term>
   * 			<description>Insert the current worksheet name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&D</term>
   * 			<description>Insert the current date.</description>
   * 		</item>
   * 		<item>
   * 			<term>&F</term>
   * 			<description>Insert the current file name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&G</term>
   * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
   * 		</item>
   * 		<item>
   * 			<term>&N</term>
   * 			<description>Insert the  number of pages the worksheet will need to print.</description>
   * 		</item>
   * 		<item>
   * 			<term>&P</term>
   * 			<description>Insert the current page number.</description>
   * 		</item>
   * 		<item>
   * 			<term>&T</term>
   * 			<description>Insert the current time.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Z</term>
   * 			<description>Insert the current file path (without the file name).</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 	<listheader>
   * 			<term>Formatting commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&B</term>
   * 			<description>Toggle bold.</description>
   * 		</item>
   * 		<item>
   * 			<term>&E</term>
   * 			<description>Toggle double underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&I</term>
   * 			<description>Toggle italics.</description>
   * 		</item>
   * 		<item>
   * 			<term>&S</term>
   * 			<description>Toggle strikethrough.</description>
   * 		</item>
   * 		<item>
   * 			<term>&U</term>
   * 			<description>Toggle underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&X</term>
   * 			<description>Toggle superscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Y</term>
   * 			<description>Toggle subscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&<FontSize></term>
   * 			<description>
   * 				Sets a new font size for the following text. The size is expressed as a positive integer.
   * 				If a number is to follow this command in the header, it must be separated by a space.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>"</term>
   * 			<description>
   * 				Sets a new font for the following text. If the font name is not recognized, the default
   * 				font will be used.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>,<FontStyle>"</term>
   * 			<description>
   * 				Sets the new font and font style for the following text. The font style is usually "Regular",
   * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
   * 				available font styles can be seen in the font dialog when a font is selected.
   * 			</description>
   * 		</item>
   * 	</list>
   * </p>
   * <p class="body">
   * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
   * &N on &A&R&14&F.
   * </p>
   * The header for each page of the worksheet.
   * @see [[footer]]
   * @see [[headerMargin]]
   */
  get header() {
    return this._bx;
  }
  /**
   * Gets or sets the header for each page of the printed worksheet.
   * <p class="body">
   * The '&' character in the header and footer is a special character. Depending on what is after it,
   * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
   * the available commands:
   * <list type="table">
   * 		<listheader>
   * 			<term>Section commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&L</term>
   * 			<description>
   * 				The following text will appear in the left section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&C</term>
   * 			<description>
   * 				The following text will appear in the center section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&R</term>
   * 			<description>
   * 				The following text will appear in the right section. The formatting of new sections is
   * 				always the default formatting, regardless of the formatting of the previous section.
   * 			</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 		<listheader>
   * 			<term>Replacement commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&&</term>
   * 			<description>Insert the '&' character.</description>
   * 		</item>
   * 		<item>
   * 			<term>&A</term>
   * 			<description>Insert the current worksheet name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&D</term>
   * 			<description>Insert the current date.</description>
   * 		</item>
   * 		<item>
   * 			<term>&F</term>
   * 			<description>Insert the current file name.</description>
   * 		</item>
   * 		<item>
   * 			<term>&G</term>
   * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
   * 		</item>
   * 		<item>
   * 			<term>&N</term>
   * 			<description>Insert the  number of pages the worksheet will need to print.</description>
   * 		</item>
   * 		<item>
   * 			<term>&P</term>
   * 			<description>Insert the current page number.</description>
   * 		</item>
   * 		<item>
   * 			<term>&T</term>
   * 			<description>Insert the current time.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Z</term>
   * 			<description>Insert the current file path (without the file name).</description>
   * 		</item>
   * </list>
   * <list type="table">
   * 	<listheader>
   * 			<term>Formatting commands</term>
   * 		</listheader>
   * 		<item>
   * 			<term>&B</term>
   * 			<description>Toggle bold.</description>
   * 		</item>
   * 		<item>
   * 			<term>&E</term>
   * 			<description>Toggle double underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&I</term>
   * 			<description>Toggle italics.</description>
   * 		</item>
   * 		<item>
   * 			<term>&S</term>
   * 			<description>Toggle strikethrough.</description>
   * 		</item>
   * 		<item>
   * 			<term>&U</term>
   * 			<description>Toggle underlining.</description>
   * 		</item>
   * 		<item>
   * 			<term>&X</term>
   * 			<description>Toggle superscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&Y</term>
   * 			<description>Toggle subscript.</description>
   * 		</item>
   * 		<item>
   * 			<term>&<FontSize></term>
   * 			<description>
   * 				Sets a new font size for the following text. The size is expressed as a positive integer.
   * 				If a number is to follow this command in the header, it must be separated by a space.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>"</term>
   * 			<description>
   * 				Sets a new font for the following text. If the font name is not recognized, the default
   * 				font will be used.
   * 			</description>
   * 		</item>
   * 		<item>
   * 			<term>&"<FontName>,<FontStyle>"</term>
   * 			<description>
   * 				Sets the new font and font style for the following text. The font style is usually "Regular",
   * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
   * 				available font styles can be seen in the font dialog when a font is selected.
   * 			</description>
   * 		</item>
   * 	</list>
   * </p>
   * <p class="body">
   * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
   * &N on &A&R&14&F.
   * </p>
   * The header for each page of the worksheet.
   * @see [[footer]]
   * @see [[headerMargin]]
   */
  set header(a) {
    if (this._bx != a) {
      if (this._v) {
        this._bx = a;
      }
      else {
        let b = PrintOptionsBase._a[4].g(PrintOptionsBase.$, String_$type, this, this._bx, a);
        this._bx = b.p1;
      }
    }
  }
  /**
   * Gets or sets the header margin for each printed page of the worksheet, specified in inches.
   * The header margin for each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[header]]
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  get headerMargin() {
    return this._ar;
  }
  /**
   * Gets or sets the header margin for each printed page of the worksheet, specified in inches.
   * The header margin for each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[header]]
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  set headerMargin(a) {
    if (this._ar != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._ar = a;
      }
      else {
        let b = PrintOptionsBase._a[5].g(PrintOptionsBase.$, Number_$type, this, this._ar, a);
        this._ar = b.p1;
      }
    }
  }
  /**
   * Gets or sets the margin at the left of each printed page of the worksheet, specified in inches.
   * The margin at the left of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  get leftMargin() {
    return this._at;
  }
  /**
   * Gets or sets the margin at the left of each printed page of the worksheet, specified in inches.
   * The margin at the left of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[rightMargin]]
   * @see [[topMargin]]
   */
  set leftMargin(a) {
    if (this._at != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._at = a;
      }
      else {
        let b = PrintOptionsBase._a[6].g(PrintOptionsBase.$, Number_$type, this, this._at, a);
        this._at = b.p1;
      }
    }
  }
  /**
   * Gets or sets the number of copies to print.
   * The number of copies to print.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 65535.
   */
  get numberOfCopies() {
    return this._bb;
  }
  /**
   * Gets or sets the number of copies to print.
   * The number of copies to print.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 65535.
   */
  set numberOfCopies(a) {
    if (a < 1 || 65535 < a) {
      if (this._t._t == false) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_NumberOfCopies"));
      }
      a = 1;
    }
    if (this._bb != a) {
      if (this._v) {
        this._bb = a;
      }
      else {
        let b = PrintOptionsBase._a[7].g(PrintOptionsBase.$, Number_$type, this, this._bb, a);
        this._bb = b.p1;
      }
    }
  }
  /**
   * Gets or sets the orientation for each page of the printed worksheet.
   * The orientation for each page of the printed worksheet.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[orientation]] enumeration.
   */
  get orientation() {
    return this._e;
  }
  /**
   * Gets or sets the orientation for each page of the printed worksheet.
   * The orientation for each page of the printed worksheet.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[orientation]] enumeration.
   */
  set orientation(a) {
    if (this._e != a) {
      if (EnumUtil.isDefined(Orientation_$type, enumGetBox(Orientation_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, Orientation_$type);
      }
      if (this._v) {
        this._e = a;
      }
      else {
        let b = PrintOptionsBase._a[8].g(PrintOptionsBase.$, Orientation_$type, this, this._e, a);
        this._e = b.p1;
      }
    }
  }
  /**
   * Returns the resolved orientation for each page of the printed worksheet.
   */
  get orientationResolved() {
    if (this._e == 2) {
      return 1;
    }
    return this._e;
  }
  /**
   * Gets or sets the method with which pages are numbered.
   * <p class="body">
   * If this is set to a value of UseStartPageNumber, the first page is numbered using the [[startPageNumber]].
   * </p>
   * The method with which pages are numbered.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageNumbering]] enumeration.
   * @see [[startPageNumber]]
   */
  get pageNumbering() {
    return this._i;
  }
  /**
   * Gets or sets the method with which pages are numbered.
   * <p class="body">
   * If this is set to a value of UseStartPageNumber, the first page is numbered using the [[startPageNumber]].
   * </p>
   * The method with which pages are numbered.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageNumbering]] enumeration.
   * @see [[startPageNumber]]
   */
  set pageNumbering(a) {
    if (this._i != a) {
      if (EnumUtil.isDefined(PageNumbering_$type, enumGetBox(PageNumbering_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, PageNumbering_$type);
      }
      if (this._v) {
        this._i = a;
      }
      else {
        let b = PrintOptionsBase._a[9].g(PrintOptionsBase.$, PageNumbering_$type, this, this._i, a);
        this._i = b.p1;
      }
    }
  }
  /**
   * Gets or sets the paper size for each printed page of the worksheet.
   * The paper size for each printed page of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[paperSize]] enumeration.
   */
  get paperSize() {
    return this._l;
  }
  /**
   * Gets or sets the paper size for each printed page of the worksheet.
   * The paper size for each printed page of the worksheet.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[paperSize]] enumeration.
   */
  set paperSize(a) {
    if (this._l != a) {
      if (EnumUtil.isDefined(PaperSize_$type, enumGetBox(PaperSize_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, PaperSize_$type);
      }
      if (this._v) {
        this._l = a;
      }
      else {
        let b = PrintOptionsBase._a[10].g(PrintOptionsBase.$, PaperSize_$type, this, this._l, a);
        this._l = b.p1;
      }
    }
  }
  /**
   * Gets or sets the way error values of cells are printed.
   * <p class="body">
   * A cell can have an error value if its [[WorksheetCell.value]] is set directly to
   * an [[ErrorValue]] or if it is set to a [[Formula]] that evaluates to an
   * error.
   * </p>
   * The way error values of cells are printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printErrors]] enumeration.
   * @see [[ErrorValue]]
   * @see [[Formula]]
   */
  get printErrors() {
    return this._o;
  }
  /**
   * Gets or sets the way error values of cells are printed.
   * <p class="body">
   * A cell can have an error value if its [[WorksheetCell.value]] is set directly to
   * an [[ErrorValue]] or if it is set to a [[Formula]] that evaluates to an
   * error.
   * </p>
   * The way error values of cells are printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printErrors]] enumeration.
   * @see [[ErrorValue]]
   * @see [[Formula]]
   */
  set printErrors(a) {
    if (this._o != a) {
      if (EnumUtil.isDefined(PrintErrors_$type, enumGetBox(PrintErrors_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, PrintErrors_$type);
      }
      if (this._v) {
        this._o = a;
      }
      else {
        let b = PrintOptionsBase._a[11].g(PrintOptionsBase.$, PrintErrors_$type, this, this._o, a);
        this._o = b.p1;
      }
    }
  }
  /**
   * Gets or sets the value indicating whether the worksheet should be printed in black and white.
   * The value indicating whether the worksheet should be printed in black and white.
   */
  get printInBlackAndWhite() {
    return this._ad;
  }
  /**
   * Gets or sets the value indicating whether the worksheet should be printed in black and white.
   * The value indicating whether the worksheet should be printed in black and white.
   */
  set printInBlackAndWhite(a) {
    if (this._ad != a) {
      if (this._v) {
        this._ad = a;
      }
      else {
        let b = PrintOptionsBase._a[12].g(PrintOptionsBase.$, Boolean_$type, this, this._ad, a);
        this._ad = b.p1;
      }
    }
  }
  /**
   * Gets or sets the way cell comments are printed.
   * <p class="body">
   * If this is set to a value of PrintAsDisplayed, the comments will only print if they are displayed on the worksheet.
   * If comments are hidden but indicators are shown, neither the indicators nor the comments will print.
   * </p>
   * The way cell notes are printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printNotes]] enumeration.
   * @see [[WorksheetCell.comment]]
   * @see [[WorksheetCellComment]]
   */
  get printNotes() {
    return this._r;
  }
  /**
   * Gets or sets the way cell comments are printed.
   * <p class="body">
   * If this is set to a value of PrintAsDisplayed, the comments will only print if they are displayed on the worksheet.
   * If comments are hidden but indicators are shown, neither the indicators nor the comments will print.
   * </p>
   * The way cell notes are printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printNotes]] enumeration.
   * @see [[WorksheetCell.comment]]
   * @see [[WorksheetCellComment]]
   */
  set printNotes(a) {
    if (this._r != a) {
      if (EnumUtil.isDefined(PrintNotes_$type, enumGetBox(PrintNotes_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, PrintNotes_$type);
      }
      if (this._v) {
        this._r = a;
      }
      else {
        let b = PrintOptionsBase._a[13].g(PrintOptionsBase.$, PrintNotes_$type, this, this._r, a);
        this._r = b.p1;
      }
    }
  }
  /**
   * Gets or sets the horizontal print resolution in DPI.
   * The horizontal print resolution in DPI.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
   * @see [[verticalResolution]]
   */
  get resolution() {
    return this._bk;
  }
  /**
   * Gets or sets the horizontal print resolution in DPI.
   * The horizontal print resolution in DPI.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
   * @see [[verticalResolution]]
   */
  set resolution(a) {
    if (this._bk != a) {
      if (a < 0 || 65535 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Resolution"));
      }
      if (this._v) {
        this._bk = a;
      }
      else {
        let b = PrintOptionsBase._a[14].g(PrintOptionsBase.$, Number_$type, this, this._bk, a);
        this._bk = b.p1;
      }
    }
  }
  /**
   * Gets or sets the margin at the right of each printed page of the worksheet, specified in inches.
   * The margin at the right of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[topMargin]]
   */
  get rightMargin() {
    return this._av;
  }
  /**
   * Gets or sets the margin at the right of each printed page of the worksheet, specified in inches.
   * The margin at the right of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[topMargin]]
   */
  set rightMargin(a) {
    if (this._av != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._av = a;
      }
      else {
        let b = PrintOptionsBase._a[15].g(PrintOptionsBase.$, Number_$type, this, this._av, a);
        this._av = b.p1;
      }
    }
  }
  /**
   * Gets or sets the value indicating whether to scale the headers and footers with the document scaling.
   * @see [[header]]
   * @see [[footer]]
   * @see [[PrintOptions.scalingFactor]]
   * @see [[ScalingType]]
   */
  get scaleHeadersAndFootersWithDocument() {
    return this._scaleHeadersAndFootersWithDocument;
  }
  /**
   * Gets or sets the value indicating whether to scale the headers and footers with the document scaling.
   * @see [[header]]
   * @see [[footer]]
   * @see [[PrintOptions.scalingFactor]]
   * @see [[ScalingType]]
   */
  set scaleHeadersAndFootersWithDocument(a) {
    this._scaleHeadersAndFootersWithDocument = a;
  }
  /**
   * Gets or sets the page number for the first printed page of the worksheet.
   * <p class="body">
   * For this value to be used, [[pageNumbering]] must be set to a value of UseStartPageNumber.
   * </p>
   * The page number for the first printed page of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of -32765 and 32767.
   * @see [[pageNumbering]]
   */
  get startPageNumber() {
    return this._bo;
  }
  /**
   * Gets or sets the page number for the first printed page of the worksheet.
   * <p class="body">
   * For this value to be used, [[pageNumbering]] must be set to a value of UseStartPageNumber.
   * </p>
   * The page number for the first printed page of the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of -32765 and 32767.
   * @see [[pageNumbering]]
   */
  set startPageNumber(a) {
    if (this._bo != a) {
      if (a < -32765 || 32767 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_StartPageNumber"));
      }
      if (this._v) {
        this._bo = a;
      }
      else {
        let b = PrintOptionsBase._a[16].g(PrintOptionsBase.$, Number_$type, this, this._bo, a);
        this._bo = b.p1;
      }
    }
  }
  /**
   * Gets or sets the margin at the top of each printed page of the worksheet, specified in inches.
   * The margin at the top of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   */
  get topMargin() {
    return this._ax;
  }
  /**
   * Gets or sets the margin at the top of each printed page of the worksheet, specified in inches.
   * The margin at the top of each printed page of the worksheet, specified in inches.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
   * @see [[bottomMargin]]
   * @see [[footerMargin]]
   * @see [[headerMargin]]
   * @see [[leftMargin]]
   * @see [[rightMargin]]
   */
  set topMargin(a) {
    if (this._ax != a) {
      if (a < 0 || 100 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Margins"));
      }
      if (this._v) {
        this._ax = a;
      }
      else {
        let b = PrintOptionsBase._a[17].g(PrintOptionsBase.$, Number_$type, this, this._ax, a);
        this._ax = b.p1;
      }
    }
  }
  /**
   * Gets or sets the vertical print resolution in DPI.
   * The vertical print resolution in DPI.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
   * @see [[resolution]]
   */
  get verticalResolution() {
    return this._bs;
  }
  /**
   * Gets or sets the vertical print resolution in DPI.
   * The vertical print resolution in DPI.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
   * @see [[resolution]]
   */
  set verticalResolution(a) {
    if (this._bs != a) {
      if (a < 0 || 65535 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_Resolution"));
      }
      if (this._v) {
        this._bs = a;
      }
      else {
        let b = PrintOptionsBase._a[18].g(PrintOptionsBase.$, Number_$type, this, this._bs, a);
        this._bs = b.p1;
      }
    }
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._t.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._t;
  }
  /**
   * @hidden
   */
  get source() {
    return this._t;
  }
}
PrintOptionsBase.$t = markType(PrintOptionsBase, 'PrintOptionsBase', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
PrintOptionsBase._am = 0.7;
/**
 * @hidden
 */
PrintOptionsBase._ao = 0.75;
/**
 * @hidden
 */
PrintOptionsBase._an = 0.7;
/**
 * @hidden
 */
PrintOptionsBase._aj = 0.75;
/**
 * @hidden
 */
PrintOptionsBase._al = 0.3;
/**
 * @hidden
 */
PrintOptionsBase._ak = 0.3;
/**
 * @hidden
 */
PrintOptionsBase._k = 1;
/**
 * @hidden
 */
PrintOptionsBase._a2 = 1;
/**
 * @hidden
 */
PrintOptionsBase._z = false;
/**
 * @hidden
 */
PrintOptionsBase._y = false;
/**
 * @hidden
 */
PrintOptionsBase._q = 0;
/**
 * @hidden
 */
PrintOptionsBase._h = 0;
/**
 * @hidden
 */
PrintOptionsBase._n = 0;
/**
 * @hidden
 */
PrintOptionsBase._a1 = 600;
/**
 * @hidden
 */
PrintOptionsBase._a3 = 600;
/**
 * @hidden
 */
PrintOptionsBase._a0 = 1;
/**
 * @hidden
 */
PrintOptionsBase._x = true;
/**
 * @hidden
 */
PrintOptionsBase._aa = true;
/**
 * @hidden
 */
PrintOptionsBase._az = 0;
/**
 * @hidden
 */
PrintOptionsBase._a4 = 1;
/**
 * @hidden
 */
PrintOptionsBase._a5 = 2;
/**
 * @hidden
 */
PrintOptionsBase._a6 = 3;
/**
 * @hidden
 */
PrintOptionsBase._a7 = 4;
/**
 * @hidden
 */
PrintOptionsBase._a8 = 5;
/**
 * @hidden
 */
PrintOptionsBase._a9 = 6;
/**
 * @hidden
 */
PrintOptionsBase._bd = 7;
/**
 * @hidden
 */
PrintOptionsBase._be = 8;
/**
 * @hidden
 */
PrintOptionsBase._bf = 9;
/**
 * @hidden
 */
PrintOptionsBase._bg = 10;
/**
 * @hidden
 */
PrintOptionsBase._bh = 11;
/**
 * @hidden
 */
PrintOptionsBase._bi = 12;
/**
 * @hidden
 */
PrintOptionsBase._bj = 13;
/**
 * @hidden
 */
PrintOptionsBase._bm = 14;
/**
 * @hidden
 */
PrintOptionsBase._bn = 15;
/**
 * @hidden
 */
PrintOptionsBase._bq = 16;
/**
 * @hidden
 */
PrintOptionsBase._br = 17;
/**
 * @hidden
 */
PrintOptionsBase._bu = 18;
/**
 * @hidden
 */
PrintOptionsBase._ba = 19;
/**
 * @hidden
 */
PrintOptionsBase._a = PrintOptionsBase._b();
/**
 * Represents a range of contiguous rows or columns which should be repeated at the top or left or printed pages of the [[Worksheet]].
 * @see [[PrintOptions.columnsToRepeatAtLeft]]
 * @see [[PrintOptions.rowsToRepeatAtTop]]
 */
export class RepeatTitleRange extends Base {
  constructor(startIndex, endIndex) {
    super();
    this._b = 0;
    this._e = 0;
    if (startIndex < 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_StartIndexLessThanZero"), "startIndex");
    }
    if (endIndex < 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_EndIndexLessThanZero"), "endIndex");
    }
    this._e = Math.min(startIndex, endIndex);
    this._b = Math.max(startIndex, endIndex);
  }
  /**
   * Determines whether the specified value equals this [[RepeatTitleRange]].
   * @param obj The value to test for equality.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(RepeatTitleRange.$, obj);
    if (a == null) {
      return false;
    }
    return a._e == this._e && a._b == this._b;
  }
  /**
   * Gtes the hash code for the [[RepeatTitleRange]].
   */
  getHashCode() {
    return ((this._e) ^ ((this._b) >> 3));
  }
  /**
   * Gets the string representation of the range.
   * @return The string representation of the range.
   */
  toString() {
    return stringFormat("Repeat range from {0} to {1}", this._e, this._b);
  }
  /**
   * Gets the index of the last row or column in the range.
   * @see [[RowColumnBase.index]]
   */
  get endIndex() {
    return this._b;
  }
  /**
   * Gets the index of the first row or column in the range.
   * @see [[RowColumnBase.index]]
   */
  get startIndex() {
    return this._e;
  }
}
RepeatTitleRange.$t = markType(RepeatTitleRange, 'RepeatTitleRange');
/**
 * Class which exposes the various print options available for a worksheet which can be saved with both a
 * worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export class PrintOptions extends PrintOptionsBase {
  constructor(a, b) {
    super(a, b);
    this._cl = false;
    this._cn = false;
    this._c2 = 1;
    this._c5 = 1;
    this._b8 = 0;
    this._dd = 100;
    this._cg = 0;
    this._cs = false;
    this._cu = false;
    this._b5 = null;
    this._ci = null;
    this._cc = null;
    this._ca = null;
    this._ce = null;
  }
  /**
   * Clears all page breaks from the [[PrintOptions]].
   * @see [[PageBreakCollection`1.clear]]
   * @see [[PageBreakCollection`1.remove]]
   * @see [[PageBreakCollection`1.removeAt]]
   */
  clearPageBreaks() {
    if (this._b5 != null) {
      this._b5.clear();
    }
    if (this._ci != null) {
      this._ci.clear();
    }
  }
  insertPageBreak() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeCast(WorksheetColumn.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorksheetRow.$, arguments[0]) !== null) {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._insertPageBreak.apply(this, arguments);
      case 1: return this._insertPageBreak1.apply(this, arguments);
      case 2: return this._insertPageBreak2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _insertPageBreak(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "cell");
    }
    if (a.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), "cell");
    }
    let b = a.columnIndex;
    let c = a.rowIndex;
    if (b == 0 && c == 0) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_PB_PageBreakCantBeA1Cell"));
    }
    let d = a.worksheet;
    let e = 0;
    let f = 0;
    let g = d._columns$i.maxCount - 1;
    let h = d._rows$i.maxCount - 1;
    let i = null;
    if (this._ca != null) {
      for (let j = 0; j < this._ca.count; j++) {
        let k = this._ca.item(j);
        if (k._n(a)) {
          e = k.firstColumn;
          f = k.firstRow;
          g = k.lastColumn;
          h = k.lastRow;
          i = k;
          break;
        }
      }
    }
    if (b > e) {
      this._verticalPageBreaks$i._g(new VerticalPageBreak(b, i), false);
    }
    if (c > f) {
      this._horizontalPageBreaks$i._g(new HorizontalPageBreak(c, i), false);
    }
  }
  /**
   * @hidden
   */
  _insertPageBreak1(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "column");
    }
    if (a.index == 0) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_PB_PageBreakCantBeBeforeLeftColumn"));
    }
    let b = null;
    let c = this._ck._cx(0, a.index, this._ck._rows$i.maxCount - 1, a.index);
    if (this._ca != null) {
      for (let d = 0; d < this._ca.count; d++) {
        let e = this._ca.item(d);
        if (e._o(c)) {
          if (e.firstColumn == a.index) {
            return;
          }
          b = e;
          break;
        }
      }
    }
    this._verticalPageBreaks$i._g(new VerticalPageBreak(a.index, b), false);
  }
  /**
   * @hidden
   */
  _insertPageBreak2(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "row");
    }
    if (a.index == 0) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_PB_PageBreakCantBeBeforeTopRow"));
    }
    let b = null;
    let c = this._ck._cx(a.index, 0, a.index, this._ck._columns$i.maxCount - 1);
    if (this._ca != null) {
      for (let d = 0; d < this._ca.count; d++) {
        let e = this._ca.item(d);
        if (e._o(c)) {
          if (e.firstRow == a.index) {
            return;
          }
          b = e;
          break;
        }
      }
    }
    this._horizontalPageBreaks$i._g(new HorizontalPageBreak(a.index, b), false);
  }
  /**
   * Resets the print options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  reset() {
    this._cc = null;
    this._cl = false;
    this._cn = false;
    this._c2 = 1;
    this._c5 = 1;
    this._b8 = 0;
    this._cs = false;
    this._cu = false;
    this._dd = 100;
    this._cg = 0;
    this._ce = null;
    this.clearPageBreaks();
    if (this._ca != null) {
      this._ca.clear();
    }
    super.reset();
  }
  /**
   * @hidden
   */
  _bz(a) {
    let b = typeCast(PrintOptions.$, a);
    if (b != null) {
      this._cc = b._cc;
      this._cl = b._cl;
      this._cn = b._cn;
      this._c2 = b._c2;
      this._c5 = b._c5;
      this._b8 = b._b8;
      this._cs = b._cs;
      this._cu = b._cu;
      this._dd = b._dd;
      this._cg = b._cg;
      this._ce = b._ce;
      this.clearPageBreaks();
      if (this._ca != null) {
        this._ca.clear();
      }
      if (b._cq) {
        for (let c = 0; c < b._printAreas$i.count; c++) {
          this._printAreas$i.add(b._printAreas$i.item(c));
        }
      }
      if (b._cp) {
        for (let d = 0; d < b._horizontalPageBreaks$i.count; d++) {
          this._horizontalPageBreaks$i._add$i(b._horizontalPageBreaks$i._item(d));
        }
      }
      if (b._cr) {
        for (let e = 0; e < b._verticalPageBreaks$i.count; e++) {
          this._verticalPageBreaks$i._add$i(b._verticalPageBreaks$i._item(e));
        }
      }
    }
    super._bz(a);
  }
  /**
   * @hidden
   */
  _dq(a, b) {
    if (this._dd == a) {
      return;
    }
    let c = 10;
    let d = 400;
    if (b) {
      if (a < c || d < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_ScalingFactor"));
      }
    }
    else if (a == 0) {
      a = 100;
    }
    else if (a < c) {
      a = c;
    }
    else if (d < a) {
      a = d;
    }
    if (a != this._dd) {
      if (this._v) {
        this._dd = a;
      }
      else {
        let e = PrintOptions._b2[9].g(PrintOptions.$, Number_$type, this, this._dd, a);
        this._dd = e.p1;
      }
    }
  }
  /**
   * @hidden
   */
  _ag() {
    return super._ag() || this._dd != 100 || this._c2 != 1 || this._c5 != 1 || this._b8 != 0;
  }
  /**
   * @hidden
   */
  _ds(a) {
    let b = this._ck.workbook;
    if (b != null && !this._v) {
      let c = b._namedReferences$i._find1("Print_Area", this._ck);
      if (this._cq == false) {
        if (c != null) {
          b._namedReferences$i.remove_1(c);
        }
      }
      else {
        let d;
        let e = this._dr(b, "Print_Area", a, c, d);
        c = e.p3;
        d = e.p4;
        if (d) {
          b._namedReferences$i._y(c, false);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _dr(a, b, c, d, e) {
    e = (d == null);
    let f = ExcelUtils.d5(null, this._ck.name);
    let g = new StringBuilder(2, "=");
    let h = FormulaParser.bx(a._e6);
    for (let i = 0; i < this._printAreas$i.count; i++) {
      let j = this._printAreas$i.item(i);
      g.l(j._toString2(1, true, false, false));
      if (i != this._printAreas$i.count - 1) {
        g.h(h);
      }
    }
    let k = this._dv(b, g.toString(), c, d);
    d = k.p3;
    return {
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  _dt(a, b, c, d, e) {
    e = (d == null);
    let f = "=";
    if (this._cc != null) {
      let g = this._ck._cx(0, this._cc.startIndex, this._ck._rows$i.maxCount - 1, this._cc.endIndex);
      f += g._toString2(1, true, false, false);
      if (this._ce != null) {
        f += FormulaParser.bx(this._ck._y);
      }
    }
    if (this._ce != null) {
      let h = this._ck._cx(this._ce.startIndex, 0, this._ce.endIndex, this._ck._columns$i.maxCount - 1);
      f += h._toString2(1, true, false, false);
    }
    let i = this._dv(b, f, c, d);
    d = i.p3;
    return {
      p3: d,
      p4: e
    };
  }
  /**
   * @hidden
   */
  _dv(a, b, c, d) {
    if (d == null) {
      let e = null;
      if (this._ck.workbook != null) {
        e = this._ck.workbook._namedReferences$i;
      }
      d = new NamedReference(0, e, this._ck);
      d._bv = true;
      d._setFormula2(b, 1);
      d.name = a;
      d._bv = false;
    }
    else {
      if (c) {
        d._bv = true;
      }
      d._setFormula2(b, 1);
      if (c) {
        d._bv = false;
      }
    }
    return {
      p3: d
    };
  }
  /**
   * @hidden
   */
  _b1(a, b) {
    if (this._cc != null) {
      let c = Workbook.getMaxColumnCount(b);
      if (this._cc.endIndex >= c) {
        a.g(ExcelUtils.ef("LE_ColumnsToRepeatAtLeftAreOutsideAvailableRange"));
      }
    }
    if (this._ce != null) {
      let d = Workbook.getMaxRowCount(b);
      if (this._ce.endIndex >= d) {
        a.g(ExcelUtils.ef("LE_RowsToRepeatAtTopAreOutsideAvailableRange"));
      }
    }
    super._b1(a, b);
  }
  /**
   * @hidden
   */
  static _b4($tValue, a, b, c, d = null, e = false, f = false, g = 0) {
    return new ChangeInfo$2(PrintOptions.$, $tValue, a, 59, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b3() {
    let a = new Array(11);
    ChangeInfo.f(a, 0, PrintOptions._b4(Boolean_$type, "CenterHorizontally", (b) => b.centerHorizontally, (b, c) => b.centerHorizontally = c));
    ChangeInfo.f(a, 1, PrintOptions._b4(Boolean_$type, "CenterVertically", (b) => b.centerVertically, (b, c) => b.centerVertically = c));
    ChangeInfo.f(a, 2, PrintOptions._b4(RepeatTitleRange.$, "ColumnsToRepeatAtLeft", (b) => b.columnsToRepeatAtLeft, (b, c) => b.columnsToRepeatAtLeft = c, (b, c) => PrintOptions._dm(b, c)));
    ChangeInfo.f(a, 3, PrintOptions._b4(Number_$type, "MaxPagesHorizontally", (b) => b.maxPagesHorizontally, (b, c) => b.maxPagesHorizontally = c));
    ChangeInfo.f(a, 4, PrintOptions._b4(Number_$type, "MaxPagesVertically", (b) => b.maxPagesVertically, (b, c) => b.maxPagesVertically = c));
    ChangeInfo.f(a, 5, PrintOptions._b4(PageOrder_$type, "PageOrder", (b) => b.pageOrder, (b, c) => b.pageOrder = c));
    ChangeInfo.f(a, 6, PrintOptions._b4(Boolean_$type, "PrintGridlines", (b) => b.printGridlines, (b, c) => b.printGridlines = c));
    ChangeInfo.f(a, 7, PrintOptions._b4(Boolean_$type, "PrintRowAndColumnHeaders", (b) => b.printRowAndColumnHeaders, (b, c) => b.printRowAndColumnHeaders = c));
    ChangeInfo.f(a, 8, PrintOptions._b4(RepeatTitleRange.$, "RowsToRepeatAtTop", (b) => b.rowsToRepeatAtTop, (b, c) => b.rowsToRepeatAtTop = c, (b, c) => PrintOptions._dp(b, c)));
    ChangeInfo.f(a, 9, PrintOptions._b4(Number_$type, "ScalingFactor", (b) => b.scalingFactor, (b, c) => b.scalingFactor = c));
    ChangeInfo.f(a, 10, PrintOptions._b4(ScalingType_$type, "ScalingType", (b) => b.scalingType, (b, c) => b.scalingType = c));
    return a;
  }
  /**
   * @hidden
   */
  _du(a) {
    let b = this._ck.workbook;
    if (b != null && !this._v) {
      let c = b._namedReferences$i._find1("Print_Titles", this._ck);
      if (this._cc == null && this._ce == null) {
        if (c != null) {
          b._namedReferences$i.remove_1(c);
        }
      }
      else {
        let d;
        let e = this._dt(b, "Print_Titles", false, c, d);
        c = e.p3;
        d = e.p4;
        if (d) {
          b._namedReferences$i._y(c, a);
        }
      }
    }
  }
  /**
   * @hidden
   */
  get _ck() {
    return this._u;
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be centered horizontally.
   * The value indicating whether the printed pages should be centered horizontally.
   * @see [[centerVertically]]
   */
  get centerHorizontally() {
    return this._cl;
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be centered horizontally.
   * The value indicating whether the printed pages should be centered horizontally.
   * @see [[centerVertically]]
   */
  set centerHorizontally(a) {
    if (a != this._cl) {
      if (this._v) {
        this._cl = a;
      }
      else {
        let b = PrintOptions._b2[0].g(PrintOptions.$, Boolean_$type, this, this._cl, a);
        this._cl = b.p1;
      }
    }
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be centered vertically.
   * The value indicating whether the printed pages should be centered vertically.
   * @see [[centerHorizontally]]
   */
  get centerVertically() {
    return this._cn;
  }
  /**
   * Gets or sets the value indicating whether the printed pages should be centered vertically.
   * The value indicating whether the printed pages should be centered vertically.
   * @see [[centerHorizontally]]
   */
  set centerVertically(a) {
    if (a != this._cn) {
      if (this._v) {
        this._cn = a;
      }
      else {
        let b = PrintOptions._b2[1].g(PrintOptions.$, Boolean_$type, this, this._cn, a);
        this._cn = b.p1;
      }
    }
  }
  /**
   * Gets or sets the range of columns which should be printed on every page.
   * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
   * Occurs when the value specified is not null and its  value is greater than or equal
   * to the number of columns in the [[Worksheet]].
   * @see [[rowsToRepeatAtTop]]
   */
  get columnsToRepeatAtLeft() {
    return this._cc;
  }
  /**
   * Gets or sets the range of columns which should be printed on every page.
   * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
   * Occurs when the value specified is not null and its  value is greater than or equal
   * to the number of columns in the [[Worksheet]].
   * @see [[rowsToRepeatAtTop]]
   */
  set columnsToRepeatAtLeft(a) {
    if (this._cc == a) {
      return;
    }
    if (a != null && a.endIndex >= this._ck._columns$i.maxCount) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ColumnsToRepeatAtLeftOutsideRange"), "value");
    }
    if (this._v) {
      PrintOptions._dm(this, a);
    }
    else {
      PrintOptions._b2[2].h(PrintOptions.$, RepeatTitleRange.$, this, a);
    }
  }
  /**
   * @hidden
   */
  _dl(a, b) {
    if (this._cc == a) {
      return;
    }
    let c = this._cc;
    this._cc = a;
    this._du(b);
    if (false == this._v && c != this._cc) {
      PrintOptions._b2[2].e(PrintOptions.$, RepeatTitleRange.$, this, c, this._cc);
    }
  }
  /**
   * @hidden
   */
  static _dm(a, b) {
    a._cc = b;
    a._du(false);
  }
  horizontalPageBreaks() {
    if (arguments.length !== 0) {
      let a = this._horizontalPageBreaks$i;
      return a.item.apply(a, arguments);
    }
    return this._horizontalPageBreaks$i;
  }
  /**
   * @hidden
   */
  get _horizontalPageBreaks$i() {
    if (this._b5 == null) {
      this._b5 = new HorizontalPageBreakCollection(this);
    }
    return this._b5;
  }
  /**
   * @hidden
   */
  get _cp() {
    return this._b5 != null && this._b5.count > 0;
  }
  /**
   * Gets or sets the maximum number of pages allowed in the horizontal direction to print the worksheet.
   * <p class="body">
   * A value of zero indicates no maximum is used in the horizontal direction. As many pages as needed will be used.
   * </p>
   * <p class="note">
   * <B>Note:</B> For MaxPagesHorizontally and [[maxPagesVertically]] to affect the way the worksheet is printed,
   * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
   * and these values aren't used, they will still be saved with the worksheet.
   * </p>
   * The maximum number of pages allowed in the horizontal direction to print the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
   * @see [[maxPagesVertically]]
   * @see [[scalingType]]
   */
  get maxPagesHorizontally() {
    return this._c2;
  }
  /**
   * Gets or sets the maximum number of pages allowed in the horizontal direction to print the worksheet.
   * <p class="body">
   * A value of zero indicates no maximum is used in the horizontal direction. As many pages as needed will be used.
   * </p>
   * <p class="note">
   * <B>Note:</B> For MaxPagesHorizontally and [[maxPagesVertically]] to affect the way the worksheet is printed,
   * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
   * and these values aren't used, they will still be saved with the worksheet.
   * </p>
   * The maximum number of pages allowed in the horizontal direction to print the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
   * @see [[maxPagesVertically]]
   * @see [[scalingType]]
   */
  set maxPagesHorizontally(a) {
    if (this._c2 != a) {
      if (a < 0 || 32767 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MaxPagesHorizontally"));
      }
      if (this._v) {
        this._c2 = a;
      }
      else {
        let b = PrintOptions._b2[3].g(PrintOptions.$, Number_$type, this, this._c2, a);
        this._c2 = b.p1;
      }
    }
  }
  /**
   * Gets or sets the maximum number of pages allowed in the vertical direction to print the worksheet.
   * <p class="body">
   * A value of zero indicates no maximum is used in the vertical direction. As many pages as needed will be used.
   * </p>
   * <p class="note">
   * <B>Note:</B> For [[maxPagesHorizontally]] and MaxPagesVertically to affect the way the worksheet is printed,
   * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
   * and these values aren't used, they will still be saved with the worksheet.
   * </p>
   * The maximum number of pages allowed in the vertical direction to print the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
   * @see [[maxPagesHorizontally]]
   * @see [[scalingType]]
   */
  get maxPagesVertically() {
    return this._c5;
  }
  /**
   * Gets or sets the maximum number of pages allowed in the vertical direction to print the worksheet.
   * <p class="body">
   * A value of zero indicates no maximum is used in the vertical direction. As many pages as needed will be used.
   * </p>
   * <p class="note">
   * <B>Note:</B> For [[maxPagesHorizontally]] and MaxPagesVertically to affect the way the worksheet is printed,
   * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
   * and these values aren't used, they will still be saved with the worksheet.
   * </p>
   * The maximum number of pages allowed in the vertical direction to print the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
   * @see [[maxPagesHorizontally]]
   * @see [[scalingType]]
   */
  set maxPagesVertically(a) {
    if (this._c5 != a) {
      if (a < 0 || 32767 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MaxPagesVertically"));
      }
      if (this._v) {
        this._c5 = a;
      }
      else {
        let b = PrintOptions._b2[4].g(PrintOptions.$, Number_$type, this, this._c5, a);
        this._c5 = b.p1;
      }
    }
  }
  /**
   * Gets or sets the order in which to print pages for multiple page worksheets.
   * The order in which to print pages for multiple page worksheets.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageOrder]] enumeration.
   */
  get pageOrder() {
    return this._b8;
  }
  /**
   * Gets or sets the order in which to print pages for multiple page worksheets.
   * The order in which to print pages for multiple page worksheets.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageOrder]] enumeration.
   */
  set pageOrder(a) {
    if (this._b8 != a) {
      if (EnumUtil.isDefined(PageOrder_$type, enumGetBox(PageOrder_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, PageOrder_$type);
      }
      if (this._v) {
        this._b8 = a;
      }
      else {
        let b = PrintOptions._b2[5].g(PrintOptions.$, PageOrder_$type, this, this._b8, a);
        this._b8 = b.p1;
      }
    }
  }
  printAreas() {
    if (arguments.length !== 0) {
      let a = this._printAreas$i;
      return a.item.apply(a, arguments);
    }
    return this._printAreas$i;
  }
  /**
   * @hidden
   */
  get _printAreas$i() {
    if (this._ca == null) {
      this._ca = new PrintAreasCollection(this);
    }
    return this._ca;
  }
  /**
   * @hidden
   */
  get _cq() {
    return this._ca != null && this._ca.count != 0;
  }
  /**
   * Gets or sets the value which indicates whether to print the worksheet gridlines.
   * The value which indicates whether to print the worksheet gridlines.
   * @see [[DisplayOptions.showGridlines]]
   */
  get printGridlines() {
    return this._cs;
  }
  /**
   * Gets or sets the value which indicates whether to print the worksheet gridlines.
   * The value which indicates whether to print the worksheet gridlines.
   * @see [[DisplayOptions.showGridlines]]
   */
  set printGridlines(a) {
    if (this._cs != a) {
      if (this._v) {
        this._cs = a;
      }
      else {
        let b = PrintOptions._b2[6].g(PrintOptions.$, Boolean_$type, this, this._cs, a);
        this._cs = b.p1;
      }
    }
  }
  /**
   * Gets or sets the value indicating whether to print row and column headers.
   * <p class="body">
   * The row and column headers show the identifier of the row or column.
   * </p>
   * The value indicating whether to print row and column headers.
   * @see [[DisplayOptions.showRowAndColumnHeaders]]
   */
  get printRowAndColumnHeaders() {
    return this._cu;
  }
  /**
   * Gets or sets the value indicating whether to print row and column headers.
   * <p class="body">
   * The row and column headers show the identifier of the row or column.
   * </p>
   * The value indicating whether to print row and column headers.
   * @see [[DisplayOptions.showRowAndColumnHeaders]]
   */
  set printRowAndColumnHeaders(a) {
    if (this._cu != a) {
      if (this._v) {
        this._cu = a;
      }
      else {
        let b = PrintOptions._b2[7].g(PrintOptions.$, Boolean_$type, this, this._cu, a);
        this._cu = b.p1;
      }
    }
  }
  /**
   * Gets or sets the range of rows which should be printed on every page.
   * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
   * Occurs when the value specified is not null and its  value is greater than or equal
   * to the number of rows in the [[Worksheet]].
   * @see [[columnsToRepeatAtLeft]]
   */
  get rowsToRepeatAtTop() {
    return this._ce;
  }
  /**
   * Gets or sets the range of rows which should be printed on every page.
   * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
   * Occurs when the value specified is not null and its  value is greater than or equal
   * to the number of rows in the [[Worksheet]].
   * @see [[columnsToRepeatAtLeft]]
   */
  set rowsToRepeatAtTop(a) {
    if (this._ce == a) {
      return;
    }
    if (a != null && a.endIndex >= this._ck._rows$i.maxCount) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RowsToRepeatAtTopOutsideRange"), "value");
    }
    if (this._v) {
      PrintOptions._dp(this, a);
    }
    else {
      PrintOptions._b2[8].h(PrintOptions.$, RepeatTitleRange.$, this, a);
    }
  }
  /**
   * @hidden
   */
  _dn(a, b) {
    if (this._ce == a) {
      return;
    }
    let c = this._ce;
    this._ce = a;
    this._du(b);
    if (false == this._v && c != this._ce) {
      PrintOptions._b2[8].e(PrintOptions.$, RepeatTitleRange.$, this, c, this._ce);
    }
  }
  /**
   * @hidden
   */
  static _dp(a, b) {
    a._ce = b;
    a._du(false);
  }
  /**
   * Gets or sets the scaling factor to use when printing the worksheet.
   * <p class="body">
   * The scaling factor is similar to magnifications in that is it stored as a percentage of the normal scaling.
   * A value of 100 indicates normal scaling whereas a value of 200 indicates the worksheet is scaled to twice its
   * normal size.
   * </p>
   * <p class="note">
   * <B>Note:</B> For ScalingFactor to affect the way the worksheet is printed, [[scalingType]] must be
   * set to a value of UseScalingFactor.
   * </p>
   * The scaling factor to use when printing the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 10 and 400.
   * @see [[scalingType]]
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  get scalingFactor() {
    return this._dd;
  }
  /**
   * Gets or sets the scaling factor to use when printing the worksheet.
   * <p class="body">
   * The scaling factor is similar to magnifications in that is it stored as a percentage of the normal scaling.
   * A value of 100 indicates normal scaling whereas a value of 200 indicates the worksheet is scaled to twice its
   * normal size.
   * </p>
   * <p class="note">
   * <B>Note:</B> For ScalingFactor to affect the way the worksheet is printed, [[scalingType]] must be
   * set to a value of UseScalingFactor.
   * </p>
   * The scaling factor to use when printing the worksheet.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 10 and 400.
   * @see [[scalingType]]
   * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
   * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  set scalingFactor(a) {
    this._dq(a, true);
  }
  /**
   * Gets or sets the method for scaling the worksheet when it is printed.
   * <p class="body">
   * If this is set to a value of UseScalingFactor, [[scalingFactor]] is used to uniformly scale
   * the worksheet on the printed pages.
   * </p>
   * <p class="body">
   * If this is set to a value of FitToPages, [[maxPagesHorizontally]] and [[maxPagesVertically]]
   * are used to set the maximum number of pages to fit the printed worksheet into in both directions.
   * </p>
   * The method for scaling the worksheet when it is printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scalingType]] enumeration.
   * @see [[maxPagesHorizontally]]
   * @see [[maxPagesVertically]]
   * @see [[scalingFactor]]
   */
  get scalingType() {
    return this._cg;
  }
  /**
   * Gets or sets the method for scaling the worksheet when it is printed.
   * <p class="body">
   * If this is set to a value of UseScalingFactor, [[scalingFactor]] is used to uniformly scale
   * the worksheet on the printed pages.
   * </p>
   * <p class="body">
   * If this is set to a value of FitToPages, [[maxPagesHorizontally]] and [[maxPagesVertically]]
   * are used to set the maximum number of pages to fit the printed worksheet into in both directions.
   * </p>
   * The method for scaling the worksheet when it is printed.
   * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scalingType]] enumeration.
   * @see [[maxPagesHorizontally]]
   * @see [[maxPagesVertically]]
   * @see [[scalingFactor]]
   */
  set scalingType(a) {
    if (this._cg != a) {
      if (EnumUtil.isDefined(ScalingType_$type, enumGetBox(ScalingType_$type, a)) == false) {
        throw new InvalidEnumArgumentException("value", a, ScalingType_$type);
      }
      if (this._v) {
        this._cg = a;
      }
      else {
        let b = PrintOptions._b2[10].g(PrintOptions.$, ScalingType_$type, this, this._cg, a);
        this._cg = b.p1;
      }
    }
  }
  verticalPageBreaks() {
    if (arguments.length !== 0) {
      let a = this._verticalPageBreaks$i;
      return a.item.apply(a, arguments);
    }
    return this._verticalPageBreaks$i;
  }
  /**
   * @hidden
   */
  get _verticalPageBreaks$i() {
    if (this._ci == null) {
      this._ci = new VerticalPageBreakCollection(this);
    }
    return this._ci;
  }
  /**
   * @hidden
   */
  get _cr() {
    return this._ci != null && this._ci.count > 0;
  }
}
PrintOptions.$t = markType(PrintOptions, 'PrintOptions', PrintOptionsBase.$);
/**
 * @hidden
 */
PrintOptions._c1 = 100;
/**
 * @hidden
 */
PrintOptions._cz = 1;
/**
 * @hidden
 */
PrintOptions._c0 = 1;
/**
 * @hidden
 */
PrintOptions._b7 = 0;
/**
 * @hidden
 */
PrintOptions._cw = 0;
/**
 * @hidden
 */
PrintOptions._cx = 1;
/**
 * @hidden
 */
PrintOptions._cy = 2;
/**
 * @hidden
 */
PrintOptions._c4 = 3;
/**
 * @hidden
 */
PrintOptions._c7 = 4;
/**
 * @hidden
 */
PrintOptions._c9 = 5;
/**
 * @hidden
 */
PrintOptions._da = 6;
/**
 * @hidden
 */
PrintOptions._db = 7;
/**
 * @hidden
 */
PrintOptions._dc = 8;
/**
 * @hidden
 */
PrintOptions._df = 9;
/**
 * @hidden
 */
PrintOptions._dg = 10;
/**
 * @hidden
 */
PrintOptions._c8 = 11;
/**
 * @hidden
 */
PrintOptions._b2 = PrintOptions._b3();
/**
 * @hidden
 */
export class WorkbookPasswordInfo extends Base {
  constructor(a) {
    super();
    this.i = null;
    this.a = null;
    this.d = false;
    this.c = null;
    this.c = a;
  }
  get f() {
    if (this.b != null) {
      return true;
    }
    return this.i != null;
  }
  get g() {
    return this.d;
  }
  set g(a) {
    if (a != this.d) {
      this.d = a;
      if (this.c != null) {
        this.c();
      }
    }
  }
  get b() {
    return this.a;
  }
  set b(a) {
    if (a != this.a) {
      this.a = a;
      if (this.d == false) {
        this.g = true;
      }
      else if (this.f == false) {
        this.g = false;
      }
    }
  }
  e(a, b, c, d) {
    if (this.a != null) {
      return {
        ret: ((() => { let e = this.a.d(a, b, c, d); a = e.p0; b = e.p1; c = e.p2; d = e.p3; return e.ret; })()),
        p0: a,
        p1: b,
        p2: c,
        p3: d
      };
    }
    a = null;
    b = c = null;
    d = Nullable$1.toNullable(Number_$type, null);
    return {
      ret: false,
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  h() {
    if (this.a != null) {
      return this.a.f();
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  j(a) {
    this.d = a;
  }
  k(a) {
    if (this.g == false) {
      this.b = null;
      this.g = true;
    }
  }
  l() {
    this.i = null;
    this.a = null;
    this.g = false;
  }
}
WorkbookPasswordInfo.$t = markType(WorkbookPasswordInfo, 'WorkbookPasswordInfo');
/**
 * Provides information about the types of changes that are disabled when the associated Workbook is protected.
 * @see [[Workbook.hasProtectionPassword]]
 * @see [[Workbook.isProtected]]
 * @see [[Workbook.protection]]
 * @see [[Workbook.protect]]
 * @see [[Workbook.unprotect]]
 */
export class WorkbookProtection extends Base {
  constructor(a) {
    super();
    this._c = true;
    this._d = true;
    this._a = null;
    /**
     * @hidden
     */
    this._b = null;
    this._a = a;
    this._b = new WorkbookPasswordInfo(runOn(this, this._g));
  }
  /**
   * Returns a boolean indicating if the sheets displayed may be modified when the Workbook is protected.
   */
  get allowEditStructure() {
    return this._c;
  }
  /**
   * Returns a boolean indicating if the sheets displayed may be modified when the Workbook is protected.
   */
  set allowEditStructure(a) {
    this._c = a;
  }
  /**
   * Returns a boolean indicating if the Workbook windows may be modified when the Workbook is protected.
   */
  get allowEditWindows() {
    return this._d;
  }
  /**
   * Returns a boolean indicating if the Workbook windows may be modified when the Workbook is protected.
   */
  set allowEditWindows(a) {
    this._d = a;
  }
  /**
   * @hidden
   */
  _h(a, b = false, c = true) {
    if (this._b.g == false) {
      this.allowEditStructure = b;
      this.allowEditWindows = c;
      if (this.allowEditStructure == false || this.allowEditWindows == false) {
        this._b.k(a);
      }
      else {
        this._b.l();
      }
    }
  }
  /**
   * @hidden
   */
  _g() {
    if (this._b.g == false) {
      this.allowEditStructure = true;
      this.allowEditWindows = true;
    }
    this._a._hz();
  }
}
WorkbookProtection.$t = markType(WorkbookProtection, 'WorkbookProtection');
/**
 * @hidden
 */
export class WorksheetProtectedRangeRegionCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._b = null;
    this._a = a;
    this._b = new List$1(WorksheetRegion.$, 0);
  }
  add(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "item");
    }
    if (this._a.worksheet != null && a.worksheet != this._a.worksheet) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RangeFromOtherWorksheetThanProtectedRange"), "item");
    }
    this._b.add(a);
  }
  clear() {
    this._b.clear();
  }
  contains(a) {
    return this._b.contains(a);
  }
  copyTo(a, b) {
    this._b.copyTo(a, b);
  }
  get count() {
    return this._b.count;
  }
  get isReadOnly() {
    return false;
  }
  remove(a) {
    return this._b.remove(a);
  }
  getEnumerator() {
    return this._b.getEnumerator();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
}
WorksheetProtectedRangeRegionCollection.$t = markType(WorksheetProtectedRangeRegionCollection, 'WorksheetProtectedRangeRegionCollection', Base.$, [ICollection$1_$type.specialize(WorksheetRegion.$)]);
/**
 * A collection of [[WorksheetProtectedRange]] instances in a [[Worksheet]]
 */
export class WorksheetProtectedRangeCollection extends Base {
  constructor(a) {
    super();
    this._d = null;
    this._a = null;
    this._a = a;
    this._d = new List$1(WorksheetProtectedRange.$, 0);
  }
  /**
   * Gets the number of ranges in the collection.
   */
  get count() {
    return this._d.count;
  }
  /**
   * Gets the range at the specified index in the collection.
   * The range at the specified index.
   * @param index The zero-based index of the range to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._d._inner[a];
  }
  /**
   * Adds the specified range to the collection.
   * @param item The range to be added
   */
  add(item) {
    this.insert(this.count, item);
  }
  /**
   * Clears all ranges from the collection.
   */
  clear() {
    this._h();
    for (let a = this._d.count - 1; a >= 0; a--) {
      this._g(a);
    }
  }
  /**
   * Determines whether a range is in the collection.
   * @param range The range to locate in the collection.
   * @return True if the range is found; False otherwise.
   */
  contains(range) {
    return this._d.contains(range);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * Gets an enumerator which can iterator all ranges in the collection.
   */
  getEnumerator() {
    return this._d.getEnumerator();
  }
  /**
   * Inserts the specified range in the collection.
   * @param index The 0-based index in the collection where the range should be inserted.
   * @param range The range to insert in the collection.
   */
  insert(index, range) {
    if (index < 0 || this.count < index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    if (range == null) {
      throw new ArgumentNullException(0, "range");
    }
    if (range.worksheet != null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_EditRangeAlreadyOwned"), "range");
    }
    for (let a of fromEnum(range.ranges)) {
      if (a.worksheet != this._a) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_EditRangeHasRangeFromOtherWorksheet"));
      }
    }
    if (this._b(range.title) != null) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_ArgumentException_DuplicateWorksheetProtectedRangeTitle", range.title));
    }
    this._d.insert(index, range);
    range.worksheet = this._a;
    range.isProtected = this._a.isProtected && range.hasPassword;
  }
  /**
   * Removes the specified range from the collection.
   * @param range The range to remove from the collection.
   * @return True if the range was successfully removed from the collection;
   * False if the range did not exist in the collection.
   */
  remove(range) {
    let a = this._d.indexOf(range);
    if (a < 0) {
      return false;
    }
    this._g(a);
    return true;
  }
  /**
   * Removes the range at the specified index from the collection.
   * @param index The index of the range to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._g(index);
  }
  /**
   * @hidden
   */
  _b(a) {
    for (let b of fromEnum(this)) {
      if (stringEquals1(a, b.title, 1)) {
        return b;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _g(a) {
    let b = this._d._inner[a];
    this._d.removeAt(a);
    b.worksheet = null;
    b.isProtected = false;
  }
  /**
   * @hidden
   */
  _h() {
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._d.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
}
WorksheetProtectedRangeCollection.$t = markType(WorksheetProtectedRangeCollection, 'WorksheetProtectedRangeCollection', Base.$, [ICollection$1_$type.specialize(WorksheetProtectedRange.$)]);
/**
 * Provides information about the types of changes that are disabled when the associated Sheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Sheet.sheetProtection]]
 * @see@see [[Sheet.unprotect]]
 */
export class SheetProtection extends Base {
  constructor(a) {
    super();
    this._a = null;
    /**
     * @hidden
     */
    this._c = null;
    this._a = a;
    this._c = new WorkbookPasswordInfo(runOn(this, this._d));
  }
  /**
   * @hidden
   */
  get _sheet() {
    return this._a;
  }
  /**
   * @hidden
   */
  _d() {
    this._a._ap();
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._a.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._a;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
SheetProtection.$t = markType(SheetProtection, 'SheetProtection', Base.$, [IChangeInfoContext_$type]);
/**
 * Provides information about the types of changes that are disabled when the associated Worksheet is protected.
 * <p class="body">When a Worksheet is protected, the contents of unprotected cells may be edited by the end-user. One way to unprotect a
 * cell is to change the [[IWorksheetCellFormat.locked]] property to false. Such cells may be edited by all users. Another way to
 * unprotect cells is using the [[allowedEditRanges]]. This is a collection of [[WorksheetProtectedRange]] instances that
 * define a range of cells that is optionally protected by another password. For any other cells, the Worksheet would need to be unprotected first.
 * A Worksheet may be programatically unprotected using the Worksheet.Unprotect() method.</p>
 * <p class="body">The [[selectionMode]] property is used to control which cells the end user may select when the Worksheet has been
 * protected. This property may be set before or after protecting a Worksheet.</p>
 * <p class="body">Many of the other properties of this class are read-only (e.g. [[allowDeletingColumns]]). The state
 * of these properties are optionally set when the Worksheet is protected (e.g. using the [[Worksheet.protect]]
 * method.</p>
 * @see@see@see [[Worksheet.protection]]
 * @see [[Worksheet.protect]]
 * @see */
export class WorksheetProtection extends SheetProtection {
  constructor(a) {
    super(a);
    this._j = 0;
    this._h = null;
    this._l = 0;
    this._h = new WorksheetProtectedRangeCollection(a);
  }
  /**
   * Returns a boolean indicating if the deletion of columns is allowed in a protected worksheet.
   * @see [[allowDeletingRows]]
   * @see [[allowInsertingColumns]]
   * @see [[allowInsertingRows]]
   */
  get allowDeletingColumns() {
    return this._aa(256);
  }
  /**
   * Returns a boolean indicating if the deletion of columns is allowed in a protected worksheet.
   * @see [[allowDeletingRows]]
   * @see [[allowInsertingColumns]]
   * @see [[allowInsertingRows]]
   */
  set allowDeletingColumns(a) {
    this._ai(256, a);
  }
  /**
   * Returns a boolean indicating if the deletion of rows is allowed in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowInsertingColumns]]
   * @see [[allowInsertingRows]]
   */
  get allowDeletingRows() {
    return this._aa(512);
  }
  /**
   * Returns a boolean indicating if the deletion of rows is allowed in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowInsertingColumns]]
   * @see [[allowInsertingRows]]
   */
  set allowDeletingRows(a) {
    this._ai(512, a);
  }
  allowedEditRanges() {
    if (arguments.length !== 0) {
      let a = this._allowedEditRanges$i;
      return a.item.apply(a, arguments);
    }
    return this._allowedEditRanges$i;
  }
  /**
   * @hidden
   */
  get _allowedEditRanges$i() {
    return this._h;
  }
  /**
   * Returns a boolean indicating if objects such as shapes, comments, charts and controls may be created or changed when the worksheet is protected.
   */
  get allowEditObjects() {
    return this._aa(1);
  }
  /**
   * Returns a boolean indicating if objects such as shapes, comments, charts and controls may be created or changed when the worksheet is protected.
   */
  set allowEditObjects(a) {
    this._ai(1, a);
  }
  /**
   * Returns a boolean indicating if existing scenarios are protected when the worksheet is protected.
   */
  get allowEditScenarios() {
    return this._aa(2);
  }
  /**
   * Returns a boolean indicating if existing scenarios are protected when the worksheet is protected.
   */
  set allowEditScenarios(a) {
    this._ai(2, a);
  }
  /**
   * Returns a boolean indicating if the user may use an auto filter created before the worksheet was protected.
   */
  get allowFiltering() {
    return this._aa(2048);
  }
  /**
   * Returns a boolean indicating if the user may use an auto filter created before the worksheet was protected.
   */
  set allowFiltering(a) {
    this._ai(2048, a);
  }
  /**
   * Returns a boolean indicating if the user may change the formatting of cells in a protected worksheet.
   */
  get allowFormattingCells() {
    return this._aa(4);
  }
  /**
   * Returns a boolean indicating if the user may change the formatting of cells in a protected worksheet.
   */
  set allowFormattingCells(a) {
    this._ai(4, a);
  }
  /**
   * Returns a boolean indicating if the user may change column information such as its width or visibility in a protected worksheet.
   */
  get allowFormattingColumns() {
    return this._aa(8);
  }
  /**
   * Returns a boolean indicating if the user may change column information such as its width or visibility in a protected worksheet.
   */
  set allowFormattingColumns(a) {
    this._ai(8, a);
  }
  /**
   * Returns a boolean indicating if the user may change row information such as its height or visibility in a protected worksheet.
   */
  get allowFormattingRows() {
    return this._aa(16);
  }
  /**
   * Returns a boolean indicating if the user may change row information such as its height or visibility in a protected worksheet.
   */
  set allowFormattingRows(a) {
    this._ai(16, a);
  }
  /**
   * Returns a boolean indicating if the user may insert columns in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowDeletingRows]]
   * @see [[allowInsertingRows]]
   */
  get allowInsertingColumns() {
    return this._aa(32);
  }
  /**
   * Returns a boolean indicating if the user may insert columns in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowDeletingRows]]
   * @see [[allowInsertingRows]]
   */
  set allowInsertingColumns(a) {
    this._ai(32, a);
  }
  /**
   * Returns a boolean indicating if the user may insert hyperlinks in unlocked cells in a protected worksheet.
   */
  get allowInsertingHyperlinks() {
    return this._aa(128);
  }
  /**
   * Returns a boolean indicating if the user may insert hyperlinks in unlocked cells in a protected worksheet.
   */
  set allowInsertingHyperlinks(a) {
    this._ai(128, a);
  }
  /**
   * Returns a boolean indicating if the user may insert rows in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowInsertingColumns]]
   * @see [[allowDeletingRows]]
   */
  get allowInsertingRows() {
    return this._aa(64);
  }
  /**
   * Returns a boolean indicating if the user may insert rows in a protected worksheet.
   * @see [[allowDeletingColumns]]
   * @see [[allowInsertingColumns]]
   * @see [[allowDeletingRows]]
   */
  set allowInsertingRows(a) {
    this._ai(64, a);
  }
  /**
   * Returns a boolean indicating if the sorting is allowed in a protected worksheet.
   */
  get allowSorting() {
    return this._aa(1024);
  }
  /**
   * Returns a boolean indicating if the sorting is allowed in a protected worksheet.
   */
  set allowSorting(a) {
    this._ai(1024, a);
  }
  /**
   * Returns a boolean indicating if the user can change pivot tables in a protected worksheet.
   */
  get allowUsingPivotTables() {
    return this._aa(4096);
  }
  /**
   * Returns a boolean indicating if the user can change pivot tables in a protected worksheet.
   */
  set allowUsingPivotTables(a) {
    this._ai(4096, a);
  }
  /**
   * Returns or sets an enumeration used to indicate how cell selection should be affected when the associated Worksheet is protected.
   */
  get selectionMode() {
    return this._j;
  }
  /**
   * Returns or sets an enumeration used to indicate how cell selection should be affected when the associated Worksheet is protected.
   */
  set selectionMode(a) {
    if (a != this._j) {
      let b = WorksheetProtection._e[0].g(WorksheetProtection.$, WorksheetProtectedSelectionMode_$type, this, this._j, a);
      this._j = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _m() {
    return this._l;
  }
  /**
   * @hidden
   */
  get _ab() {
    return this.selectionMode == 0;
  }
  /**
   * @hidden
   */
  get _ac() {
    return this.selectionMode != 2;
  }
  /**
   * @hidden
   */
  _af() {
    for (let a of fromEnum(this._allowedEditRanges$i)) {
      a.isProtected = this._sheet.isProtected && a.hasPassword;
    }
  }
  /**
   * @hidden
   */
  _ag(a, b) {
    this.selectionMode = a ? 0 : b ? 1 : 2;
  }
  /**
   * @hidden
   */
  _ah(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Boolean_$type, null), n = Nullable$1.toNullable(Boolean_$type, null)) {
    if (this._c.g == false) {
      this._aj(256, b);
      this._aj(512, c);
      this._aj(1, d);
      this._aj(2, e);
      this._aj(2048, f);
      this._aj(4, g);
      this._aj(8, h);
      this._aj(16, i);
      this._aj(32, j);
      this._aj(128, k);
      this._aj(64, l);
      this._aj(1024, m);
      this._aj(4096, n);
      this._c.k(a);
    }
  }
  /**
   * @hidden
   */
  static _g($tValue, a, b, c, d = null, e = false, f = false, g = 0) {
    return new ChangeInfo$2(WorksheetProtection.$, $tValue, a, 103, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _f() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, WorksheetProtection._g(WorksheetProtectedSelectionMode_$type, "SelectionMode", (b) => b.selectionMode, (b, c) => b.selectionMode = c));
    return a;
  }
  /**
   * @hidden
   */
  _aa(a) {
    return (this._l & a) == a;
  }
  /**
   * @hidden
   */
  _d() {
    this._af();
    super._d();
  }
  /**
   * @hidden
   */
  _ai(a, b) {
    if (b) {
      this._l |= a;
    }
    else {
      this._l &= ~a;
    }
  }
  /**
   * @hidden
   */
  _aj(a, b) {
    if (b.hasValue) {
      this._ai(a, b.value);
    }
  }
}
WorksheetProtection.$t = markType(WorksheetProtection, 'WorksheetProtection', SheetProtection.$);
/**
 * @hidden
 */
WorksheetProtection._ae = 0;
/**
 * @hidden
 */
WorksheetProtection._ad = 1;
/**
 * @hidden
 */
WorksheetProtection._e = WorksheetProtection._f();
/**
 * @hidden
 */
export class RegionLookupTable$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this.a = new ObjectPool$1(HashSet$1.$.specialize(this.$t), () => new HashSet$1(this.$t, 0));
    this.b = new ObjectPool$1(List$1.$.specialize(this.$t), () => new List$1(this.$t, 0));
    this.t = null;
    this.u = null;
    this.c = null;
    this.d = null;
    this.m = null;
    this.e = new RegionLookupTable_Result$1(this.$t);
    this.r = null;
    this.s = null;
    this.v = 0;
    this.w = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.r = runOn(this, this.o);
    this.s = runOn(this, this.p);
    this.t = runOn(this.a, this.a.b);
    this.u = runOn(this.b, this.b.b);
    this.m = a;
    this.c = new FixedLengthSegmentTree$1(this.$t, this, 16384);
    this.d = new FixedLengthSegmentTree$1(this.$t, this, 1048576);
    this.e = RegionLookupTable_Result$1.$t.specialize(this.$t).getStaticFields()._b;
  }
  x(a, b) {
    if (a.worksheet != this.m) {
      if (a.worksheet != null) {
      }
      return;
    }
    this.y(a._h, b);
  }
  y(a, b) {
    this.c.o(b, a._w, a._x);
    this.d.o(b, a._ac, a._ae);
  }
  z(a, b, c, d, e) {
    this.c.o(e, a, c);
    this.d.o(e, b, d);
  }
  aa() {
    this.c.m();
    this.d.m();
  }
  n(a, b) {
    this.v = b;
    this.w = b;
    let c = this.d.i(a, null, this.r);
    let d = c != null && c.count > 0;
    if (c != null) {
      c.clear();
      this.b.f(c);
    }
    return d;
  }
  o(a) {
    return a.containsColumns(this.v, this.w);
  }
  p(a) {
    return a.intersectsWithColumns(this.v, this.w);
  }
  ab(a, b, c, d) {
    let e = this.d.n(a, c);
    a = e.p0;
    c = e.p1;
    let f = this.c.n(b, d);
    b = f.p0;
    d = f.p1;
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  f(a, b) {
    this.v = b;
    this.w = b;
    let c = this.d.i(a, null, this.r);
    return new RegionLookupTable_Result$1(this.$t, 1, this, c);
  }
  g(a) {
    this.v = a._w;
    this.w = a._x;
    if (this.v > this.w) {
      let b = this.v;
      this.v = this.w;
      this.w = b;
    }
    let c = this.d.e(a._ac, a._ae, this.r);
    if (c == null) {
      return this.e;
    }
    let d = this.u();
    d.o(c);
    c.clear();
    this.a.f(c);
    return new RegionLookupTable_Result$1(this.$t, 1, this, d);
  }
  h(a, b, c) {
    let d = a.g(b, c, null);
    if (d == null) {
      return this.e;
    }
    let e = this.u();
    e.o(d);
    d.clear();
    this.a.f(d);
    return new RegionLookupTable_Result$1(this.$t, 1, this, e);
  }
  i(a, b) {
    return this.h(this.c, a, b);
  }
  j(a) {
    return this.k(a._ac, a._w, a._ae, a._x);
  }
  k(a, b, c, d) {
    let e = this.c.g(b, d, null);
    if (e == null) {
      return this.e;
    }
    let f = this.d.j(a, c, e, null);
    e.clear();
    this.a.f(e);
    return new RegionLookupTable_Result$1(this.$t, 1, this, f);
  }
  l(a, b) {
    return this.h(this.d, a, b);
  }
  ac(a, b) {
    if (a.worksheet != this.m) {
      return;
    }
    this.ad(a._h, b);
  }
  ad(a, b) {
    this.c.p(b, a._w, a._x);
    this.d.p(b, a._ac, a._ae);
  }
  ae(a, b, c, d, e) {
    this.c.p(e, a, c);
    this.d.p(e, b, d);
  }
  get q() {
    return this.c.d;
  }
}
RegionLookupTable$1.$t = markType(RegionLookupTable$1, 'RegionLookupTable$1');
/**
 * @hidden
 */
export class RegionLookupTable_Result$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this._a = null;
    this._d = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this._a = c;
          this._d = d;
        }
        break;
    }
  }
  dispose() {
    if (this._d != null) {
      this._d.clear();
      this._a.b.f(this._d);
    }
  }
  get _c() {
    return this._d != null && this._d.count != 0;
  }
}
RegionLookupTable_Result$1.$t = markStruct(RegionLookupTable_Result$1, 'RegionLookupTable_Result$1', ValueType.$, [IDisposable_$type], function () {
  this._b = new RegionLookupTable_Result$1(arguments[0], 1, null, null);
});
/**
 * @hidden
 */
export class RowColumnBinaryTreeNode$1 extends LoadOnDemandTree_BinaryTreeNode$1 {
  constructor($t, a, b, c) {
    super($t, a, b, c);
    this.$t = null;
    this.r = -1;
    this.s = -1;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
  }
  o(a, b, c, d) {
    let e = 0;
    for (let f = 0; f < a; f++) {
      let g = this.a[f];
      if (g == null || g._m) {
        e += c;
        continue;
      }
      if (d == false && g.hidden) {
        continue;
      }
      let h = this.p(g, f);
      if (h < 0) {
        e += b;
      }
      else {
        e += h;
      }
    }
    return e;
  }
  q(a, b, c) {
    if (c) {
      if (this.s < 0) {
        this.s = this.o(32, a, b, true);
      }
      return this.s;
    }
    if (this.r < 0) {
      this.r = this.o(32, a, b, false);
    }
    return this.r;
  }
  t(a) {
    this.r = -1;
    if (a == false) {
      this.s = -1;
    }
  }
}
RowColumnBinaryTreeNode$1.$t = markType(RowColumnBinaryTreeNode$1, 'RowColumnBinaryTreeNode$1', LoadOnDemandTree_BinaryTreeNode$1.$.specialize(0));
/**
 * Abstract base class for collections of the main worksheet elements (rows, columns, and cells).
 * <p class="body">
 * Because of the large number of elements on a worksheet, this collection internally creates elements
 * when they are requested. Iterating this collection will only iterate the elements which have already
 * been created.
 * </p>
 * @typedef T The type of item contained in the collection.
 */
export class WorksheetItemCollection$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this._b = null;
    this._v = 0;
    this._d = null;
    this._t = -1;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._d = a;
    this._v = b;
    this._b = this._a();
  }
  /**
   * @hidden
   */
  add(item) {
    return this._add$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _add$i(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantModifyCollection"));
  }
  /**
   * @hidden
   */
  clear() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantModifyCollection"));
  }
  /**
   * @hidden
   */
  contains(item) {
    return this._contains$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _contains$i(a) {
    if (this._b == null) {
      return false;
    }
    return this._b.contains(a);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    if (this._b == null) {
      return;
    }
    this._b.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get count() {
    return this._count;
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return true;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this._remove$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _remove$i(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantModifyCollection"));
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._p();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _createValue$i(index) {
    return this._createValue(index);
  }
  /**
   * @hidden
   */
  _getItemIndex$i(item) {
    return this._getItemIndex(item);
  }
  /**
   * @hidden
   */
  _initializeItemIndex$i(item, index, applyingChangesToTree) {
    this._initializeItemIndex(item, index, applyingChangesToTree);
  }
  /**
   * @hidden
   */
  _isItemStillValid$i(item) {
    return this._isItemStillValid(item);
  }
  /**
   * @hidden
   */
  _q(a, b) {
    return this._b._af(a, b);
  }
  /**
   * @hidden
   */
  _y() {
    this._b._an();
  }
  /**
   * @hidden
   */
  _x(a) {
    if (this._b == null) {
      return;
    }
    let b = a.w;
    if (b == 0) {
      return;
    }
    let c = a.q ? a.l._ac : a.l._w;
    let d = b < 0 ? c - b : c;
    this._b._o(b, d);
  }
  /**
   * @hidden
   */
  _a() {
    return new LoadOnDemandTree$1(this.$t, this, this._v);
  }
  /**
   * @hidden
   */
  *__l() {
    if (this._b == null) {
      return undefined;
    }
    for (let a = 0; a < this._v; a++) {
      yield this._b._item(a);
    }
  }
  _l() {
    return toEnum(() => this.__l());
  }
  /**
   * @hidden
   */
  _p() {
    if (this._b == null) {
      return getEnumerator(this._l());
    }
    return getEnumerator(this._b);
  }
  /**
   * @hidden
   */
  _m(a, b) {
    return this._n(a, b, true);
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    return this._o(a, b, c);
  }
  /**
   * @hidden
   */
  _o(a, b, c = true) {
    if (this._b == null) {
      return this._l();
    }
    return this._b._x(a, b, c);
  }
  /**
   * @hidden
   */
  _g(a, b = true) {
    let c;
    return ((() => { let d = this._b._b(a, b, c); c = d.p2; return d.ret; })());
  }
  /**
   * @hidden
   */
  _aa(a, b) {
    this._b._ao(a, b);
  }
  /**
   * @hidden
   */
  _h(a) {
    if (a < 0) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_IndexNegative"));
    }
    if (a >= this._v) {
      this._ae(a);
    }
    return this._b._item(a);
  }
  /**
   * @hidden
   */
  _ab() {
    this._v = this.maxCount;
    if (this._b != null) {
      this._b._al = this._v;
    }
  }
  /**
   * @hidden
   */
  _ad(a, b) {
    this._b._ar(a, b);
  }
  /**
   * @hidden
   */
  _ac(a) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 0: break;
        case 1: throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotShift_LossOfData"));
        case 2: throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotShift_LossOfObject"));
        case 3: throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotShift_SplitTable"));
        case 4: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewRegionOverlapsFilterArea"));
        case 5: throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotShift_SplitMergedRegion"));
        case 6: throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotShift_SplitBlockingValue"));
        default:
          t1 = 1;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _i(a, b) {
    return this._b._e(a, b);
  }
  /**
   * @hidden
   */
  get _k() {
    return this._b._u;
  }
  /**
   * @hidden
   */
  get__count() {
    if (this._b == null) {
      return 0;
    }
    return this._b.count;
  }
  /**
   * @hidden
   */
  get _count() {
    return this.get__count();
  }
  /**
   * @hidden
   */
  get _c() {
    return this._b;
  }
  /**
   * @hidden
   */
  get _u() {
    return this._t;
  }
  /**
   * @hidden
   */
  set _u(a) {
    this._t = a;
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
}
WorksheetItemCollection$1.$t = markType(WorksheetItemCollection$1, 'WorksheetItemCollection$1', Base.$, [ICollection$1_$type.specialize(0), ILoadOnDemandTreeOwner$1_$type.specialize(0)]);
/**
 * Base class for row collection and column collection.
 * @typedef T The type of item contained in the collection.
 */
export class RowColumnCollectionBase$1 extends WorksheetItemCollection$1 {
  constructor($t, a, b) {
    super($t, a, b);
    this.$t = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
  }
}
RowColumnCollectionBase$1.$t = markType(RowColumnCollectionBase$1, 'RowColumnCollectionBase$1', WorksheetItemCollection$1.$.specialize(0));
/**
 * @hidden
 */
export class RowColumnLoadOnDemandTree$1 extends LoadOnDemandTree$1 {
  constructor($t, a) {
    super($t, a, a.maxCount);
    this.$t = null;
    this._at = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._at = a._e;
  }
  _au(a) {
    for (let b of fromEnum(this._y())) {
      b.t(a);
    }
  }
  _av(a, b) {
    if (this._h == null) {
      return;
    }
    let c;
    let d = ((() => { let e = this._h.e(a, this._ah(a), false, false, this, c); c = e.p5; return e.ret; })());
    if (c == 1) {
      d.t(b);
    }
  }
}
RowColumnLoadOnDemandTree$1.$t = markType(RowColumnLoadOnDemandTree$1, 'RowColumnLoadOnDemandTree$1', LoadOnDemandTree$1.$.specialize(0));
/**
 * @hidden
 */
export class ShapeFillNoFill extends ShapeFill {
  constructor() {
    super();
  }
  _c($tArg, $tResult, a, b) {
    return a._visitNoFill$i(this, b);
  }
  _d(a) {
    let b = 1048576;
    a._bi.add(new PropertyTableBase_PropertyValue(0, 447, b));
  }
}
ShapeFillNoFill.$t = markType(ShapeFillNoFill, 'ShapeFillNoFill', ShapeFill.$);
ShapeFillNoFill._e = new ShapeFillNoFill();
/**
 * Represents a shape fill with a solid color.
 * @see [[WorksheetShape.fill]]
 */
export class ShapeFillSolid extends ShapeFill {
  constructor(..._rest) {
    super();
    this._e = null;
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (arguments[0] == null) {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          this._e = WorkbookColorInfo.automatic;
        }
        break;
      case 1:
        {
          let color = _rest[0];
          color = Color.create(color);
          this._e = new WorkbookColorInfo(Nullable$1.toNullable(Color.$, color), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, true);
        }
        break;
      case 2:
        {
          let colorInfo = _rest[0];
          this._e = colorInfo;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _c($tArg, $tResult, a, b) {
    return a._visitSolid$i(this, b);
  }
  /**
   * @hidden
   */
  _d(a) {
    a._c2(this._e, 385, 386);
    let b = u32BitwiseOr(1048576, 16);
    a._bi.add(new PropertyTableBase_PropertyValue(0, 447, b));
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] describing the color of the fill.
   */
  get colorInfo() {
    return this._e;
  }
}
ShapeFillSolid.$t = markType(ShapeFillSolid, 'ShapeFillSolid', ShapeFill.$);
/**
 * @hidden
 */
export class ShapeFillImage extends ShapeFill {
  constructor(a) {
    super();
    this._e = null;
    this._e = a;
  }
  get _f() {
    return this._e;
  }
  _c($tArg, $tResult, a, b) {
    return a._visitImage$i(this, b);
  }
  _d(a) {
    let b = 1048576;
    a._bi.add(new PropertyTableBase_PropertyValue(0, 447, b));
  }
}
ShapeFillImage.$t = markType(ShapeFillImage, 'ShapeFillImage', ShapeFill.$);
/**
 * @hidden
 */
export let IShapeFillVisitor$2_$type = new Type(null, 'IShapeFillVisitor$2');
/**
 * @hidden
 */
export class ShapeOutlineNoOutline extends ShapeOutline {
  constructor() {
    super();
  }
  _c($tArg, $tResult, a, b) {
    return a._visitNoOutline$i(this, b);
  }
  _h(a) {
    let b = ShapeOutline._g(a);
    a._bi.add(new PropertyTableBase_PropertyValue(0, 511, b));
  }
}
ShapeOutlineNoOutline.$t = markType(ShapeOutlineNoOutline, 'ShapeOutlineNoOutline', ShapeOutline.$);
ShapeOutlineNoOutline._i = new ShapeOutlineNoOutline();
/**
 * Represents a shape outline with a solid color.
 * @see [[WorksheetShape.outline]]
 */
export class ShapeOutlineSolid extends ShapeOutline {
  constructor(..._rest) {
    super();
    this._i = null;
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (arguments[0] == null) {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          this._i = WorkbookColorInfo.automatic;
        }
        break;
      case 1:
        {
          let color = _rest[0];
          color = Color.create(color);
          this._i = new WorkbookColorInfo(Nullable$1.toNullable(Color.$, color), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), Nullable$1.toNullable(Number_$type, null), false, true);
        }
        break;
      case 2:
        {
          let colorInfo = _rest[0];
          this._i = colorInfo;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _c($tArg, $tResult, a, b) {
    return a._visitSolid$i(this, b);
  }
  /**
   * @hidden
   */
  _h(a) {
    let b = u32BitwiseOr(ShapeOutline._g(a), 8);
    a._c2(this._i, 448, 449);
    a._bi.add(new PropertyTableBase_PropertyValue(0, 511, b));
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] describing the color of the outline.
   */
  get colorInfo() {
    return this._i;
  }
}
ShapeOutlineSolid.$t = markType(ShapeOutlineSolid, 'ShapeOutlineSolid', ShapeOutline.$);
/**
 * @hidden
 */
export let IShapeOutlineVisitor$2_$type = new Type(null, 'IShapeOutlineVisitor$2');
/**
 * @hidden
 */
export class SharedStringTable extends GenericCachedCollection$1 {
  constructor(a) {
    super(StringElement.$, 1, a, 0x7FFFFFFF, 0.005);
    this._t = 1;
    this._p = new List$1(SharedStringTable_KeyGap.$, 0);
  }
  _s(a) {
    if (a == 0xFFFFFFFF) {
      if (this._p.count != 0) {
        let b = this._p._inner[0]._b;
        this._v(b);
        return {
          ret: b,
          p0: a
        };
      }
      return {
        ret: 0,
        p0: a
      };
    }
    else {
      return {
        ret: a++,
        p0: a
      };
    }
  }
  _l(a) {
    super._l(a);
    if (a._aa == 0) {
      a._aa = ((() => { let b = this._s(this._t); this._t = b.p0; return b.ret; })());
    }
  }
  _u(a) {
    let b = new SharedStringTable_KeyGap(1, a, a);
    let c = this._p.f(b);
    let d = Nullable$1.toNullable(SharedStringTable_KeyGap.$, null);
    let e = Nullable$1.toNullable(SharedStringTable_KeyGap.$, null);
    let f;
    let g;
    if (c < 0) {
      c = ~c;
      f = c - 1;
      if (0 <= f) {
        d = Nullable$1.toNullable(SharedStringTable_KeyGap.$, this._p._inner[f]);
      }
      g = c;
    }
    else {
      f = c;
      d = Nullable$1.toNullable(SharedStringTable_KeyGap.$, this._p._inner[f]);
      g = c + 1;
    }
    if (g < this._p.count) {
      e = Nullable$1.toNullable(SharedStringTable_KeyGap.$, this._p._inner[g]);
    }
    let h = d.hasValue && d.value._a + 1 == a;
    let i = e.hasValue && e.value._b - 1 == a;
    if (h) {
      if (i) {
        this._p.v(f, 2);
        this._p.insert(f, new SharedStringTable_KeyGap(1, d.value._b, e.value._a));
      }
      else {
        this._p._inner[f] = new SharedStringTable_KeyGap(1, d.value._b, a);
      }
    }
    else if (i) {
      this._p._inner[g] = new SharedStringTable_KeyGap(1, a, e.value._a);
    }
    else {
      this._p.insert(c, b);
    }
  }
  _v(a) {
    let b = this._p.f(new SharedStringTable_KeyGap(1, a, a));
    if (b < 0) {
      b = ~b - 1;
      if (b < 0) {
        return;
      }
      let c = this._p._inner[b];
      if (c._a < a) {
        return;
      }
      if (c._a == a) {
        this._p._inner[b] = new SharedStringTable_KeyGap(1, c._b, c._a - 1);
      }
      else {
        this._p.removeAt(b);
        this._p.s(b, [new SharedStringTable_KeyGap(1, c._b, a - 1), new SharedStringTable_KeyGap(1, a + 1, c._a)]);
      }
    }
    else {
      let d = this._p._inner[b];
      if (d._b == d._a) {
        this._p.removeAt(b);
      }
      else {
        this._p._inner[b] = new SharedStringTable_KeyGap(1, d._b + 1, d._a);
      }
    }
  }
  _remove(a) {
    if (super._remove(a) == false) {
      return false;
    }
    this._u(a._aa);
    a._aa = 0;
    return true;
  }
  _o(a, b) {
    let c;
    let d = ((() => { let e = this._b.d(a, c); c = e.p1; return e.ret; })());
    if (d != null) {
      for (let e = 0; e < c; e++) {
        let f = d[e];
        if (f.b != a) {
          continue;
        }
        let g = f.a;
        if (g._aa == b) {
          return g;
        }
      }
    }
    return null;
  }
  _q(a) {
    return this._r(HashHelpers.d(a), a._aa);
  }
  _r(a, b) {
    let c;
    let d;
    let e = ((() => { let f = this._b.e(a, c, d); c = f.p1; d = f.p2; return f.ret; })());
    if (e != null) {
      for (let f = 0; f < c; f++) {
        let g = e[f];
        if (g.b != a) {
          continue;
        }
        let h = g.a;
        if (h == null) {
          break;
        }
        if (h._aa == b) {
          return d + f;
        }
      }
    }
    return -1;
  }
}
SharedStringTable.$t = markType(SharedStringTable, 'SharedStringTable', GenericCachedCollection$1.$.specialize(StringElement.$));
/**
 * @hidden
 */
export class SharedStringTable_KeyGap extends ValueType {
  constructor(a, ..._rest) {
    super();
    this._b = 0;
    this._a = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this._b = c;
          this._a = d;
        }
        break;
    }
  }
  compareTo(a) {
    return Base.compareSimple(this._b, a._b);
  }
}
SharedStringTable_KeyGap.$t = markStruct(SharedStringTable_KeyGap, 'SharedStringTable_KeyGap', ValueType.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export let ISortable_$type = new Type(null, 'ISortable');
/**
 * Represents an index relative to a region
 * @see [[Worksheet.filterSettings]]
 * @see [[Worksheet.sortSettings]]
 */
export class RelativeIndex extends Base {
  constructor(index) {
    super();
    this._b = 0;
    this._a = 0;
    if (index < 0) {
      throw new ArgumentOutOfRangeException(0);
    }
    this._b = index;
    this._a = (index);
  }
  /**
   * Returns the relative index (read only)
   */
  get index() {
    return this._b;
  }
  /**
   * @hidden
   */
  _c(a, b = 0) {
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_NoRegionHasBeenSpecified"));
    }
    if (b == 0) {
      if (this._b >= a._ad) {
        throw new IndexOutOfRangeException(1, ExcelUtils.ef("LE_ArgumentOutOfRange_RelativeColumnIndex"));
      }
    }
    else {
      if (this._b >= a._aa) {
        throw new IndexOutOfRangeException(1, ExcelUtils.ef("LE_ArgumentOutOfRange_RelativeRowIndex"));
      }
    }
  }
  /**
   * @hidden
   */
  equals(other) {
    return this._b == other._b;
  }
  /**
   * Compares this instance of a [[RelativeIndex]] to another.
   * @param obj
   * @return
   */
  compareTo(obj) {
    if (typeCast(RelativeIndex.$, obj) !== null) {
      return Base.compareSimple(this._b, obj._b);
    }
    return -1;
  }
}
RelativeIndex.$t = markType(RelativeIndex, 'RelativeIndex', Base.$, [ISortable_$type, IEquatable$1_$type.specialize(-1), IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export let IAreaFormatsOwner$1_$type = new Type(null, 'IAreaFormatsOwner$1', null, [IWorksheetCellFormatProxyOwner_$type, IGenericCachedCollectionEx_$type]);
/**
 * Represents a style which can be applied to a [[WorksheetTable]].
 * @see [[WorksheetTable.style]]
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 * @see [[Workbook.standardTableStyles]]
 */
export class WorksheetTableStyle extends Base {
  constructor(..._rest) {
    super();
    this._v = 1;
    this._w = 1;
    this._j = null;
    this._x = 1;
    this._o = false;
    this._p = false;
    this._al = null;
    this._g = null;
    this._y = 1;
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let name = _rest[0];
          let b = [name, true];
          {
            let name = b[0];
            let isCustom = b[1];
            if (stringIsNullOrEmpty(name)) {
              throw new ArgumentNullException(0, "name");
            }
            this._o = isCustom;
            this._al = name;
          }
        }
        break;
      case 1:
        {
          let name = _rest[0];
          let isCustom = _rest[1];
          if (stringIsNullOrEmpty(name)) {
            throw new ArgumentNullException(0, "name");
          }
          this._o = isCustom;
          this._al = name;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return this._isReadOnly;
  }
  /**
   * @hidden
   */
  _onAreaFormatAdded$i(area, format) {
  }
  /**
   * @hidden
   */
  verifyCanBeModified() {
    this._verifyCanBeModified();
  }
  /**
   * @hidden
   */
  get sheet() {
    return null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return null;
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
    this._verifyCanBeModified();
    for (let a = 1; a != 1073741824; a = (a << 1)) {
      if ((values & a) == 0) {
        continue;
      }
      WorksheetTableStyle._ap(a);
    }
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
    let a = 2 | 1 | 32;
    if ((formatOptions & a) != 0) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InvalidTableStyleAreaFormatOptions"));
    }
  }
  /**
   * Duplicates the style and returns a deep copy.
   * <p class="body">
   * A cloned style must be added to the [[Workbook.customTableStyles]] collection before it can be applied to a
   * [[WorksheetTable]].
   * </p>
   * <p class="body">
   * The only value not cloned from the style is the [[isCustom]] value. Cloning a standard style creates a custom style with
   * the same style settings which can then be changed.
   * </p>
   * @param name The name to give to the cloned style.
   * @throws [[ArgumentNullException]] 'name' is null or empty.
   * @return The clone of the style.
   */
  clone(name) {
    let a = new WorksheetTableStyle(name, true);
    a._v = this._v;
    a._w = this._w;
    a._x = this._x;
    a._y = this._y;
    if (this._j != null) {
      for (let b of fromEnum(this._j)) {
        a._areaFormats$i.item(b.key).setFormatting(b.value);
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  _m(a, b) {
    let c = new WorksheetTableStyle(a, true);
    c._v = this._v;
    c._w = this._w;
    c._x = this._x;
    c._y = this._y;
    if (this._j != null) {
      let d = 0x7FFFFFFF & ~(865271865 | 10752 | 32768);
      for (let e of fromEnum(this._j._i())) {
        ExcelUtils.fc(e, c._areaFormats$i._d(null, e._bt), d, true, void 0, void 0, b);
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  static _q(a) {
    return (a & 865282617) == 0;
  }
  /**
   * @hidden
   */
  static _af(a) {
    switch (a) {
      case 0: return 0;
      case 7: return 1;
      case 8: return 2;
      case 5: return 3;
      case 6: return 4;
      case 4: return 5;
      case 3: return 6;
      case 1: return 7;
      case 2: return 8;
      case 9: return 9;
      case 10: return 10;
      case 11: return 11;
      case 12: return 12;
      default: return 13;
    }
  }
  /**
   * @hidden
   */
  _ak(a) {
    switch (a) {
      case 7: return Nullable$1.toNullable(Number_$type, intSToU(this.columnStripeWidth));
      case 8: return Nullable$1.toNullable(Number_$type, intSToU(this.alternateColumnStripeWidth));
      case 5: return Nullable$1.toNullable(Number_$type, intSToU(this.rowStripeHeight));
      case 6: return Nullable$1.toNullable(Number_$type, intSToU(this.alternateRowStripeHeight));
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  _n() {
    let a = new SortedList$2(Number_$type, WorksheetTableAreaFormatProxy$1.$.specialize(WorksheetTableStyleArea_$type), 1, UtilitiesInt32Comparer._c);
    for (let b of fromEnum(this._areaFormats$i._i())) {
      a._item(WorksheetTableStyle._af(b._bt), b);
    }
    return a;
  }
  /**
   * @hidden
   */
  _an(a) {
    this._g = a;
    if (this._j != null) {
      this._j._k(a._e);
    }
  }
  /**
   * @hidden
   */
  _ao() {
    this._g = null;
  }
  /**
   * @hidden
   */
  _verifyCanBeModified() {
    if (this._isReadOnly) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotModifyStandardTableStyle"));
    }
  }
  /**
   * @hidden
   */
  static _f($tValue, a, b, c, d = null, e = true, f = false, g = 0) {
    return new ChangeInfo$2(WorksheetTableStyle.$, $tValue, a, 81, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(5);
    ChangeInfo.f(a, 0, WorksheetTableStyle._f(Number_$type, "AlternateColumnStripeWidth", (b) => b.alternateColumnStripeWidth, (b, c) => b.alternateColumnStripeWidth = c));
    ChangeInfo.f(a, 1, WorksheetTableStyle._f(Number_$type, "AlternateRowStripeHeight", (b) => b.alternateRowStripeHeight, (b, c) => b.alternateRowStripeHeight = c));
    ChangeInfo.f(a, 2, WorksheetTableStyle._f(Number_$type, "ColumnStripeWidth", (b) => b.columnStripeWidth, (b, c) => b.columnStripeWidth = c));
    ChangeInfo.f(a, 3, WorksheetTableStyle._f(String_$type, "Name", (b) => b.name, (b, c) => b.name = c));
    ChangeInfo.f(a, 4, WorksheetTableStyle._f(Number_$type, "RowStripeHeight", (b) => b.rowStripeHeight, (b, c) => b.rowStripeHeight = c));
    return a;
  }
  /**
   * @hidden
   */
  static _ap(a) {
    let b;
    if (((() => { let c = WorksheetTableStyle._u(a, b); b = c.p1; return c.ret; })()) == false) {
      throw new InvalidOperationException(1, b);
    }
  }
  /**
   * @hidden
   */
  static _u(a, b) {
    if ((a & 865271865) != 0) {
      b = ExcelUtils.eg("LE_InvalidOperationException_InvalidTableStyleAreaFormatProperty", enumGetBox(CellFormatValue_$type, a));
      return {
        ret: false,
        p1: b
      };
    }
    if ((a & 10752) != 0) {
      b = ExcelUtils.eg("LE_InvalidOperationException_InvalidTableStyleAreaFontProperty", enumGetBox(CellFormatValue_$type, a));
      return {
        ret: false,
        p1: b
      };
    }
    b = null;
    return {
      ret: true,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _ar(a, b) {
    if (a < 1 || 9 < a) {
      throw ExcelUtils.x("value", a, ExcelUtils.eg("LE_ArgumentOutOfRangeException_InvalidTableStyleAreaStripeExtent", b));
    }
  }
  /**
   * Gets or sets the number of columns which will span each alternate column stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The alternate column stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].AlternateColumnStripe value.
   * </p>
   * The number of columns which will span each alternate column stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[columnStripeWidth]]
   */
  get alternateColumnStripeWidth() {
    return this._v;
  }
  /**
   * Gets or sets the number of columns which will span each alternate column stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The alternate column stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].AlternateColumnStripe value.
   * </p>
   * The number of columns which will span each alternate column stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[columnStripeWidth]]
   */
  set alternateColumnStripeWidth(a) {
    this._verifyCanBeModified();
    if (this._v == a) {
      return;
    }
    WorksheetTableStyle._ar(a, "AlternateColumnStripeWidth");
    let b = WorksheetTableStyle._a[0].g(WorksheetTableStyle.$, Number_$type, this, this._v, a);
    this._v = b.p1;
  }
  /**
   * Gets or sets the number of rows which will span each alternate row stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The alternate row stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].AlternateRowStripe value.
   * </p>
   * The number of rows which will span each alternate row stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[rowStripeHeight]]
   */
  get alternateRowStripeHeight() {
    return this._w;
  }
  /**
   * Gets or sets the number of rows which will span each alternate row stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The alternate row stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].AlternateRowStripe value.
   * </p>
   * The number of rows which will span each alternate row stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[rowStripeHeight]]
   */
  set alternateRowStripeHeight(a) {
    this._verifyCanBeModified();
    if (this._w == a) {
      return;
    }
    WorksheetTableStyle._ar(a, "AlternateRowStripeHeight");
    let b = WorksheetTableStyle._a[1].g(WorksheetTableStyle.$, Number_$type, this, this._w, a);
    this._w = b.p1;
  }
  areaFormats() {
    if (arguments.length !== 0) {
      let a = this._areaFormats$i;
      return a.item.apply(a, arguments);
    }
    return this._areaFormats$i;
  }
  /**
   * @hidden
   */
  get _areaFormats$i() {
    if (this._j == null) {
      this._j = new WorksheetTableAreaFormatsCollection$1(WorksheetTableStyleArea_$type, this);
    }
    return this._j;
  }
  /**
   * Gets or sets the number of columns which will span each column stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The column stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].ColumnStripe value.
   * </p>
   * The number of columns which will span each column stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[alternateColumnStripeWidth]]
   */
  get columnStripeWidth() {
    return this._x;
  }
  /**
   * Gets or sets the number of columns which will span each column stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The column stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].ColumnStripe value.
   * </p>
   * The number of columns which will span each column stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[alternateColumnStripeWidth]]
   */
  set columnStripeWidth(a) {
    this._verifyCanBeModified();
    if (this._x == a) {
      return;
    }
    WorksheetTableStyle._ar(a, "ColumnStripeWidth");
    let b = WorksheetTableStyle._a[2].g(WorksheetTableStyle.$, Number_$type, this, this._x, a);
    this._x = b.p1;
  }
  /**
   * Gets the value indicating whether the style is a custom style.
   * True id this is a custom table style; False if this is a read-only, standard table style.
   */
  get isCustom() {
    return this._o;
  }
  /**
   * Gets or sets the name of the style.
   * The name of the style.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentException]] The value assigned is null, empty, or greater than 255 characters in length.
   * @throws [[ArgumentException]] The value assigned matches the name of another custom style in the owning [[Workbook.customTableStyles]] collection.
   * Table names are compared case-insensitively.
   */
  get name() {
    return this._al;
  }
  /**
   * Gets or sets the name of the style.
   * The name of the style.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentException]] The value assigned is null, empty, or greater than 255 characters in length.
   * @throws [[ArgumentException]] The value assigned matches the name of another custom style in the owning [[Workbook.customTableStyles]] collection.
   * Table names are compared case-insensitively.
   */
  set name(a) {
    this._verifyCanBeModified();
    if (this._al == a) {
      return;
    }
    if (this._g != null) {
      this._g._o(this, a);
    }
    let b = WorksheetTableStyle._a[3].g(WorksheetTableStyle.$, String_$type, this, this._al, a);
    this._al = b.p1;
  }
  /**
   * Gets or sets the number of rows which will span each row stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The row stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].RowStripe value.
   * </p>
   * The number of rows which will span each row stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[alternateRowStripeHeight]]
   */
  get rowStripeHeight() {
    return this._y;
  }
  /**
   * Gets or sets the number of rows which will span each row stripe.
   * <p class="body">
   * The stripe sizes must be between 1 and 9, inclusive.
   * </p>
   * <p class="body">
   * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
   * stripe, then repeating.
   * </p>
   * <p class="body">
   * The row stripe format is defined in the [[areaFormats]] collection and keyed by the
   * [[WorksheetTableStyleArea]].RowStripe value.
   * </p>
   * The number of rows which will span each row stripe.
   * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
   * @see [[alternateRowStripeHeight]]
   */
  set rowStripeHeight(a) {
    this._verifyCanBeModified();
    if (this._y == a) {
      return;
    }
    WorksheetTableStyle._ar(a, "ColumnStripeWidth");
    let b = WorksheetTableStyle._a[4].g(WorksheetTableStyle.$, Number_$type, this, this._y, a);
    this._y = b.p1;
  }
  /**
   * @hidden
   */
  get _h() {
    return this._g;
  }
  /**
   * @hidden
   */
  get _s() {
    return this._p;
  }
  /**
   * @hidden
   */
  set _s(a) {
    if (this._p == a) {
      return;
    }
    this._p = a;
    if (this._p == a) {
      for (let b of fromEnum(this._areaFormats$i._i())) {
        b.d._dk();
      }
    }
  }
  /**
   * @hidden
   */
  get _isReadOnly() {
    return this._o == false && this._p == false;
  }
  /**
   * @hidden
   */
  get _workbook() {
    if (this._g != null) {
      return this._g._e;
    }
    return null;
  }
}
WorksheetTableStyle.$t = markType(WorksheetTableStyle, 'WorksheetTableStyle', Base.$, [IAreaFormatsOwner$1_$type.specialize(WorksheetTableStyleArea_$type), IChangeInfoContext_$type]);
/**
 * @hidden
 */
WorksheetTableStyle._aa = 0;
/**
 * @hidden
 */
WorksheetTableStyle._ac = 1;
/**
 * @hidden
 */
WorksheetTableStyle._ae = 2;
/**
 * @hidden
 */
WorksheetTableStyle._ag = 3;
/**
 * @hidden
 */
WorksheetTableStyle._aj = 4;
/**
 * @hidden
 */
WorksheetTableStyle._ah = 5;
/**
 * @hidden
 */
WorksheetTableStyle._a = WorksheetTableStyle._b();
/**
 * @hidden
 */
WorksheetTableStyle._c = 1 | 8 | 16 | 32 | 65536 | 131072 | 1048576 | 8388608 | 16777216 | 268435456 | 536870912 | 33554432 | 512 | 2048 | 8192;
/**
 * @hidden
 */
WorksheetTableStyle._e = 1 | 8 | 16 | 32 | 65536 | 131072 | 1048576 | 8388608 | 16777216 | 268435456 | 536870912 | 33554432;
/**
 * @hidden
 */
WorksheetTableStyle._d = 512 | 2048 | 8192;
/**
 * @hidden
 */
export class CustomTableStyleCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._d;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.a._d;
  }
}
CustomTableStyleCollection_CollectionChangeContext.$t = markStruct(CustomTableStyleCollection_CollectionChangeContext, 'CustomTableStyleCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of custom [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in the
 * [[workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 */
export class CustomTableStyleCollection extends Base {
  constructor(a) {
    super();
    this._h = null;
    /**
     * @hidden
     */
    this._d = null;
    this._d = a;
    this._h = new List$1(WorksheetTableStyle.$, 0);
  }
  static staticInit() {
    CustomTableStyleCollection._a = CustomTableStyleCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._h.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._h.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a custom [[WorksheetTableStyle]] to the collection.
   * @param style The custom table style to add to the collection.
   * @throws [[ArgumentNullException]] 'style' is null.
   * @throws [[ArgumentException]] 'style' is a standard table style.
   * @throws [[ArgumentException]] 'style' is already in a CustomTableStyleCollection.
   * @throws [[ArgumentException]] 'style' has a name which matches one of the other custom table styles in the collection.
   * Names are compared case-insensitively.
   * @see [[WorksheetTableStyle.isCustom]]
   * @see [[WorksheetTableStyle.name]]
   */
  add(style) {
    if (style == null) {
      throw new ArgumentNullException(0, "style");
    }
    if (style.isCustom == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CannotAddStandardTableStyle"), "style");
    }
    if (style._h != null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateTableStyle"), "style");
    }
    if (this._item1(style.name) != null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateTableStyleName_New"), "style");
    }
    this._n(this._h.count, style);
  }
  /**
   * Clears the collection.
   * <p class="body">
   * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
   * will be set to the [[Workbook.defaultTableStyle]].
   * </p>
   */
  clear() {
    let a = this._h.count > 1 ? this._m(24) : null;
    for (let b = this._h.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._p(a);
  }
  /**
   * Determines whether the specified [[WorksheetTableStyle]] is contained in the collection.
   * @param style The table style to find in the collection.
   * @return True if the style is in the collection; False otherwise.
   */
  contains(style) {
    return this._h.contains(style);
  }
  /**
   * Gets the index of the specified style in the collection.
   * @param style The style to find in the collection.
   * @throws [[ArgumentNullException]] 'style' is null.
   * @return The 0-based index of the specified style in the collection or -1 if the style is not in the collection.
   */
  indexOf(style) {
    if (style == null) {
      throw new ArgumentNullException(0, "style");
    }
    return this._h.indexOf(style);
  }
  /**
   * Removes the specified [[WorksheetTableStyle]] from the collection.
   * <p class="body">
   * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
   * will be set to the [[Workbook.defaultTableStyle]].
   * </p>
   * @param style The table style to remove from the collection.
   * @throws [[ArgumentNullException]] 'style' is null.
   * @return True if the style was in the collection and therefore removed; False otherwise.
   */
  remove(style) {
    if (style == null) {
      throw new ArgumentNullException(0, "style");
    }
    let a = this.indexOf(style);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the [[WorksheetTableStyle]] at the specified index.
   * <p class="body">
   * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
   * will be set to the [[Workbook.defaultTableStyle]].
   * </p>
   * @param index The index of the table style to remove.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   */
  removeAt(index) {
    ExcelUtils.gg(index, this.count);
    let a = this._item(index);
    let b = CustomTableStyleCollection._a[1];
    let c = new CustomTableStyleCollection_CollectionChangeContext(1, this, a, index);
    let d = b.b(this._d, null, b.c);
    this._h.removeAt(index);
    a._ao();
    if (a == this._e.defaultTableStyle) {
      this._e.defaultTableStyle = null;
    }
    for (let e of fromEnum(this._e._worksheets$i)) {
      for (let f of fromEnum(e._tables$i)) {
        if (f.style == a) {
          f.style = this._e.defaultTableStyle;
        }
      }
    }
    b.e(CustomTableStyleCollection_CollectionChangeContext.$, WorksheetTableStyle.$, c, a, null);
    if (d != null) {
      b.d(this._d, d);
    }
  }
  /**
   * @hidden
   */
  _n(a, b) {
    let c = CustomTableStyleCollection._a[0];
    let d = c.b(this._d, null, c.c);
    let e = new CustomTableStyleCollection_CollectionChangeContext(1, this, b, a);
    this._h.insert(a, b);
    b._an(this);
    c.e(CustomTableStyleCollection_CollectionChangeContext.$, WorksheetTableStyle.$, e, null, b);
    if (d != null) {
      c.d(this._d, d);
    }
  }
  /**
   * @hidden
   */
  _o(a, b) {
    let c = this._item1(b);
    if (c == null || c == a) {
      return;
    }
    throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateTableStyleName_Existing"), "value");
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(CustomTableStyleCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, CustomTableStyleCollection._c(WorksheetTableStyle.$, "Add", 82, (b) => b.b, (b, c) => CustomTableStyleCollection._r(b, c)));
    ChangeInfo.f(a, 1, CustomTableStyleCollection._c(WorksheetTableStyle.$, "Remove", 83, (b) => b.b, (b, c) => CustomTableStyleCollection._s(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _m(a) {
    return this._d != null && this._d._cx ? this._d._go(null, a, null) : null;
  }
  /**
   * @hidden
   */
  _p(a) {
    if (a != null) {
      if (this._d != null) {
        this._d._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    let c = a.a._h.indexOf(a.b);
    if (c >= 0) {
      a.a.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _s(a, b) {
    a.a._n(a.c, a.b);
  }
  /**
   * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
   */
  get count() {
    return this._h.count;
  }
  item() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._item.apply(this, arguments);
      case 1: return this._item1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _item(a) {
    ExcelUtils.gg(a, this.count);
    return this._h._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    if (stringIsNullOrEmpty(a)) {
      return null;
    }
    let b = this._d._e6;
    for (let c = 0; c < this._h.count; c++) {
      if (StringUtilities.c(a, this._h._inner[c].name, b, 1) == 0) {
        return this._h._inner[c];
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
}
CustomTableStyleCollection.$t = markType(CustomTableStyleCollection, 'CustomTableStyleCollection', Base.$, [ICollection$1_$type.specialize(WorksheetTableStyle.$)]);
/**
 * @hidden
 */
CustomTableStyleCollection._i = 0;
/**
 * @hidden
 */
CustomTableStyleCollection._l = 1;
/**
 * @hidden
 */
CustomTableStyleCollection._k = 2;
/**
 * @hidden
 */
CustomTableStyleCollection._a = null;
/**
 * A collection of standard [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in a
 * [[Workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.standardTableStyles]]
 */
export class StandardTableStyleCollection extends Base {
  constructor() {
    super();
    this._g = null;
  }
  static staticInit() {
    StandardTableStyleCollection._h = DefaultStyleHelper.a;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._g.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _a() {
    this._g = new List$1(WorksheetTableStyle.$, 0);
    return StandardTableStyleCollection._h(this._g);
  }
  /**
   * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
   */
  get count() {
    return this._g.count;
  }
  item() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._item.apply(this, arguments);
      case 1: return this._item1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _item(a) {
    return this._g._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    if (stringIsNullOrEmpty(a)) {
      return null;
    }
    let b = ExcelUtils.cq;
    for (let c = 0; c < this._g.count; c++) {
      if (StringUtilities.c(a, this._g._inner[c].name, b, 1) == 0) {
        return this._g._inner[c];
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  get _d() {
    return this._item1("TableStyleMedium2");
  }
  /**
   * @hidden
   */
  static get _c() {
    if (StandardTableStyleCollection._b == null) {
      if (StandardTableStyleCollection._b == null) {
        let a = new StandardTableStyleCollection();
        WorkItemScheduler.b().d(a._a());
        StandardTableStyleCollection._b = a;
      }
    }
    return StandardTableStyleCollection._b;
  }
}
StandardTableStyleCollection.$t = markType(StandardTableStyleCollection, 'StandardTableStyleCollection', Base.$, [IEnumerable$1_$type.specialize(WorksheetTableStyle.$)]);
/**
 * @hidden
 */
StandardTableStyleCollection._j = {};
/**
 * @hidden
 */
StandardTableStyleCollection._b = null;
/**
 * @hidden
 */
StandardTableStyleCollection._h = null;
/**
 * @hidden
 */
export class WorksheetTable_ResizeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.c = new WorksheetRegionAddress();
    this.a = null;
    this.b = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = [c.d, c.c];
          {
            let f = d[0];
            let g = d[1];
            this.d = f;
            this.c = f._bw;
            let h = g._w - this.c._w;
            if (h <= 0) {
              this.a = null;
            }
            else {
              this.a = new Array(h);
              for (let i = 0; i < h; i++) {
                this.a[i] = f._columns$i._item(i);
              }
            }
            let j = this.c._x - g._x;
            if (j <= 0) {
              this.b = null;
            }
            else {
              this.b = new Array(j);
              for (let k = 0; k < j; k++) {
                this.b[k] = f._columns$i._item(g._x + k + 1 - this.c._w);
              }
            }
          }
          if (c.a != null) {
            this.a = c.a;
          }
          if (c.b != null) {
            this.b = c.b;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.d = c;
          this.c = c._bw;
          let e = d._w - this.c._w;
          if (e <= 0) {
            this.a = null;
          }
          else {
            this.a = new Array(e);
            for (let f = 0; f < e; f++) {
              this.a[f] = c._columns$i._item(f);
            }
          }
          let g = this.c._x - d._x;
          if (g <= 0) {
            this.b = null;
          }
          else {
            this.b = new Array(g);
            for (let h = 0; h < g; h++) {
              this.b[h] = c._columns$i._item(d._x + h + 1 - this.c._w);
            }
          }
        }
        break;
    }
  }
  get workbook() {
    return this.d._k;
  }
  get sheet() {
    return this.d.worksheet;
  }
  get source() {
    return this.d;
    ;
  }
}
WorksheetTable_ResizeContext.$t = markStruct(WorksheetTable_ResizeContext, 'WorksheetTable_ResizeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetTable_ColumnChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.h = 0;
    this.g = 0;
    this.f = false;
    this.e = false;
    this.d = null;
    this.a = null;
    this.b = null;
    this.c = new WorksheetRegionAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          let j = _rest[7];
          this.d = c;
          this.h = d;
          this.g = e;
          this.a = h;
          this.f = f;
          this.e = g;
          this.b = i;
          if (WorksheetRegionAddress._r(j, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
            this.c = j.value;
          }
          else {
            this.c = c._by;
          }
        }
        break;
    }
  }
  get workbook() {
    return this.d._k;
  }
  get sheet() {
    return this.d.worksheet;
  }
  get source() {
    return this.d;
  }
}
WorksheetTable_ColumnChangeContext.$t = markStruct(WorksheetTable_ColumnChangeContext, 'WorksheetTable_ColumnChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetTable_RowChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.c = 0;
    this.b = null;
    this.a = new WorksheetRegionAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.b = c;
          this.d = d;
          this.c = e;
          if (WorksheetRegionAddress._r(f, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
            this.a = f.value;
          }
          else {
            this.a = c._by;
          }
        }
        break;
    }
  }
  get workbook() {
    return this.b._k;
  }
  get sheet() {
    return this.b.worksheet;
  }
  get source() {
    return this.b;
  }
}
WorksheetTable_RowChangeContext.$t = markStruct(WorksheetTable_RowChangeContext, 'WorksheetTable_RowChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a region of cells formatted as a table.
 * <p class="body">
 * Tables assist in managing and analyzing a range of related data. This management can be done separately from the rest of the
 * data in the worksheet.
 * </p>
 * <p class="body">
 * A table can have one or more columns sorted and filtered. There are various sorting and filtering criteria that can be applied
 * to the columns. The types pertaining to filtering can be found in the Infragistics.Documents.Excel.Filtering namespace and a filter
 * can be applied to a column by setting the [[WorksheetTableColumn.filter]] property. The types pertaining to sorting can
 * be found in the Infragistics.Documents.Excel.Sorting namespace and a column can be sorted by setting the
 * [[WorksheetTableColumn.sortCondition]] or by populating the
 * [[SortSettings`1.sortConditions]] collection on the [[sortSettings]].
 * </p>
 * <p class="body">
 * A table can contain calculated columns which dynamically determine their value based on a formula. A
 * [[WorksheetTableColumn]] can be made a calculated column by setting the [[WorksheetTableColumn.columnFormula]].
 * </p>
 * <p class="body">
 * A table can also contain a totals row which display total information about the table. This can be shown by setting
 * [[isTotalsRowVisible]] to True. When the totals row is displayed, each column can display text or a calculated value in the
 * totals row, by setting either the [[WorksheetTableColumn.totalLabel]] or [[WorksheetTableColumn.totalFormula]],
 * respectively.
 * </p>
 * @see [[Worksheet.tables]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetCell.associatedTable]]
 * @see [[WorksheetRow.getCellAssociatedTable]]
 */
export class WorksheetTable extends NamedReferenceBase {
  constructor(a, b, c, d, e, f) {
    super(null, false);
    this._b2 = null;
    this._b9 = null;
    this._c6 = null;
    this._b1 = 2;
    this._dq = 0;
    this._dr = 1;
    this._bl = null;
    this._cb = null;
    this._c7 = 0;
    this._bj = null;
    /**
     * @hidden
     */
    this._bw = new WorksheetRegionAddress();
    this._bn = null;
    this._bv = WorksheetRegionAddress._b;
    this.name = a;
    this._dq = b;
    this._bw = new WorksheetRegionAddress(1, c, d, e, f);
  }
  static staticInit() {
    WorksheetTable._bf = WorksheetTable._bg();
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  _onAreaFormatAdded$i(area, format) {
  }
  /**
   * @hidden
   */
  verifyCanBeModified() {
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._k;
  }
  /**
   * @hidden
   */
  onSortSettingsModified() {
    this.reapplySortConditions();
  }
  /**
   * @hidden
   */
  get culture() {
    return (((t) => t == null ? null : t.name)(this._culture$i));
  }
  /**
   * @hidden
   */
  get _culture$i() {
    return this._z;
  }
  /**
   * @hidden
   */
  get sortRegion() {
    return this.dataAreaRegion;
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return null;
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
    let a = sender;
    this._e7(a, values);
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
    let a = sender;
    for (let b = 1; b != 1073741824; b = (b << 1)) {
      if ((values & b) == 0) {
        continue;
      }
      WorksheetTable._fd(a._bt, b);
    }
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
    let a = sender;
    if (a._bt == 0) {
      let b = 63 & ~8;
      if ((formatOptions & b) != 0) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InvalidFormatOptionsInWholeTableArea"));
      }
    }
  }
  /**
   * @hidden
   */
  get__f() {
    if (this._bj == null) {
      this._bj = new TableCalcReference(null, this, Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null), Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null));
    }
    return this._bj;
  }
  /**
   * @hidden
   */
  get _f() {
    return this.get__f();
  }
  /**
   * @hidden
   */
  get__m() {
    return false;
  }
  /**
   * @hidden
   */
  get__n() {
    return this._k != null;
  }
  /**
   * @hidden
   */
  get _n() {
    return this.get__n();
  }
  /**
   * @hidden
   */
  get__a() {
    return WorksheetTable._bf;
  }
  /**
   * @hidden
   */
  get__z() {
    if (this.worksheet != null) {
      return this.worksheet._y;
    }
    return ExcelUtils.cq;
  }
  /**
   * @hidden
   */
  get _z() {
    return this.get__z();
  }
  /**
   * @hidden
   */
  get__y() {
    return true;
  }
  /**
   * @hidden
   */
  _a6(a) {
    super._a6(a);
  }
  /**
   * Gets the string representation of the table.
   * @return The string representation of the table.
   */
  toString() {
    return this.name;
  }
  /**
   * @hidden
   */
  _a1(a, b = false) {
    return this.name + "[]";
  }
  /**
   * @hidden
   */
  get__k() {
    let a = this.worksheet;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  get__h() {
    let a = this._k;
    if (a == null) {
      return null;
    }
    return a._bb;
  }
  /**
   * Clears all filters from the columns in the table.
   * <p class="body">
   * If any filters are present and removed when this is called, all hidden rows in the data area of the table will be unhidden.
   * </p>
   * @see [[reapplyFilters]]
   * @see [[WorksheetTableColumn.filter]]
   */
  clearFilters() {
    let a = this._dp(23);
    try {
      this._e6();
      for (let b of fromEnum(this._columns$i)) {
        b.clearFilter();
      }
    }
    finally {
      this._e0();
      this._eq(a);
    }
  }
  /**
   * Clears all sort conditions from the columns in the table.
   * <p class="note">
   * <b>Note:</b> Just as in Microsoft Excel, clearing the sort conditions will not revert the table back to its original unsorted
   * state. The table will remain in its last sorted order.
   * </p>
   * @see [[sortSettings]]
   * @see [[WorksheetTableColumn.sortCondition]]
   */
  clearSortConditions() {
    this.sortSettings._sortConditions$i.clear();
  }
  /**
   * Deletes one or more columns from the table
   * @param tableColumnIndex The deletion start relative to the first column in the table.
   * @param count The number of columns to delete.
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the columns in the table.
   */
  deleteColumns(tableColumnIndex, count = 1) {
    this._fe();
    if (tableColumnIndex < 0 || tableColumnIndex >= this._bw._af) {
      throw new IndexOutOfRangeException(1, "tableColumnIndex");
    }
    if (count < 1 || count >= this._bw._af) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (tableColumnIndex + count > this._bw._af) {
      throw new InvalidOperationException(1, "Can't remove the last column in the table");
    }
    this._d5(tableColumnIndex, count, true);
  }
  /**
   * Deletes one or more data rows from the table
   * @param dataRowIndex The deletion start relative to the first row in the [[dataAreaRegion]].
   * @param count The number of rows to delete.
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the rows (excluding header and total rows) in the table.
   */
  deleteDataRows(dataRowIndex, count = 1) {
    this._fe();
    let a = this.dataAreaRegion._aa;
    if (dataRowIndex < 0 || dataRowIndex >= a) {
      throw new IndexOutOfRangeException(1, "dataRowIndex");
    }
    if (count < 1 || count >= a) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (dataRowIndex + count > a) {
      throw new InvalidOperationException(1, "Can't remove the last data row in the table");
    }
    this._d6(dataRowIndex, count, true);
  }
  /**
   * Inserts one or more columns into the table
   * @param tableColumnIndex The insertion point relative to the first column in the table.
   * @param count The number of columns to insert
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
   */
  insertColumns(tableColumnIndex, count = 1) {
    this._fe();
    let a = this._bn._columns$i.maxCount;
    if (tableColumnIndex < 0 || tableColumnIndex > this._bw._af) {
      throw new IndexOutOfRangeException(1, "tableColumnIndex");
    }
    if (count < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (this._bw._w + tableColumnIndex + count > a) {
      throw new InvalidOperationException(1, "Max columns exceeded");
    }
    this._d5(tableColumnIndex, count, false);
  }
  /**
   * Inserts one or more data rows into the table
   * @param dataRowIndex The insertion point relative to the first row in the [[dataAreaRegion]].
   * @param count The number of columns to insert
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
   */
  insertDataRows(dataRowIndex, count = 1) {
    this._fe();
    let a = this._bn._rows$i.maxCount;
    let b = this.dataAreaRegion;
    if (dataRowIndex < 0 || dataRowIndex > b._aa) {
      throw new IndexOutOfRangeException(1, "dataRowIndex");
    }
    if (count < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (b.firstRow + dataRowIndex + count > a) {
      throw new InvalidOperationException(1, "Max rows exceeded");
    }
    this._d6(dataRowIndex, count, false);
  }
  /**
   * Re-filters all data cells in the table based on the filters from the columns in the table.
   * <p class="body">
   * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
   * added or removed on a column in the table or when the ReapplyFilters method is called.
   * </p>
   * <p class="body">
   * If no columns in the table have filters set, this method will not do anything to the data.
   * </p>
   * <p class="note">
   * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
   * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
   * same row will also be hidden.
   * </p>
   * @see [[clearFilters]]
   * @see [[WorksheetTableColumn.filter]]
   */
  reapplyFilters() {
    if (0 < this._c7) {
      this._c1 = true;
      return;
    }
    if (this._bn == null) {
      return;
    }
    let a = this._dp(1);
    let b;
    let c;
    let d = this._d8(b, c);
    b = d.p0;
    c = d.p1;
    let e = new List$1(IFilterable_$type, 0);
    for (let f = 0; f < this._columns$i.count; f++) {
      let g = this._columns$i._item(f);
      if (g.filter != null) {
        e.add(g);
      }
    }
    this._bn._ib(b, c, e);
    this._eq(a);
  }
  /**
   * Re-sorts all data cells in the table based on the sort conditions from the columns in the table.
   * @see [[sortSettings]]
   * @see [[WorksheetTableColumn.sortCondition]]
   */
  reapplySortConditions() {
    this.sortSettings._y();
  }
  resize() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    else if (arguments.length === 2) {
      n = 2;
    }
    switch (n) {
      case 0: return this._resize.apply(this, arguments);
      case 1: return this._resize1.apply(this, arguments);
      case 2: return this._resize2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _resize1(a) {
    if (this.worksheet == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ResizedTableMustBeOnWorksheet"));
    }
    this._ez(this.worksheet._getRegion(a), "headerAndDataRegionAddress");
  }
  /**
   * @hidden
   */
  _resize2(a, b) {
    if (this.worksheet == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ResizedTableMustBeOnWorksheet"));
    }
    this._ez(this.worksheet._getRegion1(a, b), "headerAndDataRegionAddress");
  }
  /**
   * @hidden
   */
  _resize(a) {
    if (this.worksheet == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ResizedTableMustBeOnWorksheet"));
    }
    if (a == null) {
      throw new ArgumentNullException(0, "headerAndDataRegion");
    }
    if (a.worksheet != this.worksheet) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NewTableRegionFromWrongWorksheet"), "headerAndDataRegion");
    }
    this._ez(a, "headerAndDataRegion");
  }
  /**
   * @hidden
   */
  _ez(a, b) {
    let c = this.wholeTableRegion;
    if (c == null) {
      return;
    }
    let d = this.worksheet;
    if (d == null || a._k != c._k) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NewTableRegionCannotMoveHeaders"), b);
    }
    if (this.isHeaderRowVisible && a._aa == 1) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NewTableRegionMustHaveDataRows"), b);
    }
    if (c._s(a) == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_NewTableRegionOverlapOld"), b);
    }
    let e = a._h;
    this._er(new WorksheetTable_ResizeContext(2, this, e), e);
  }
  /**
   * @hidden
   */
  _er(a, b) {
    let c = this.worksheet;
    let d = WorksheetTable._bf[9];
    let e = c != null ? d.b(c.workbook, c, d.c) : null;
    try {
      this._cv = true;
      let f = this.dataAreaRegion._h;
      let g = b;
      let h = new List$1(WorksheetTableColumn.$, 0);
      let i = this._columns$i;
      if (this._bw._w < g._w) {
        for (let j = this._bw._w; j < g._w; j++) {
          h.add(i._item(j - this._bw._w));
        }
      }
      if (g._x < this._bw._x) {
        for (let k = (g._x + 1); k < this._bw._x; k++) {
          h.add(i._item(k - this._bw._w));
        }
      }
      let l = new WorksheetTableResizeOperation(this, g);
      let m = Nullable$1.toNullable(CellShiftOperation.$, null);
      if (this.isTotalsRowVisible) {
        let n = this._b0.index;
        if (g._ae < n) {
          g = new WorksheetRegionAddress(1, g._ac, g._ae + 1, g._w, g._x);
          l = new WorksheetTableResizeOperation(this, g);
        }
        if (n < g._ae) {
          m = Nullable$1.toNullable(CellShiftOperation.$, new CellShiftOperation(2, c, 2, l, n, g._ae, this._bw._w, this._bw._x, -1, false));
        }
        else if (g._ae < n) {
          m = Nullable$1.toNullable(CellShiftOperation.$, new CellShiftOperation(2, c, 2, l, g._ae, n, this._bw._w, this._bw._x, 1, false));
        }
      }
      if (nullableEquals(m, null)) {
        m = Nullable$1.toNullable(CellShiftOperation.$, new CellShiftOperation(2, c, 1, l, this._bw._ac, this._bw._ae, this._bw._w, this._bw._x, 0, false));
      }
      this._bn._conditionalFormats$i._a6(true);
      this._bn._hz(true);
      let o = c._b8(m.value, 0);
      this._bn._conditionalFormats$i._a7();
      this._bn._h0();
      this._bn._h7();
      let t1 = o.a;
      L0: while (true) {
        switch (t1) {
          case 0: break;
          case 1:
          case 2: break;
          case 3: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewTableRegionOverlapsOtherTable"));
          case 4: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewRegionOverlapsFilterArea"));
          case 5: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewTableRegionOverlapsMergedRegion"));
          case 6: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewTableRegionOverlapsBlockingValue"));
          default:
            t1 = 1;
            continue L0;
        }
        break;
      }
      let p = new List$1(Formula.$, 0);
      let q = this._k;
      if (q != null) {
        q._ib(this, h, p);
      }
      let r = this._bw;
      this._bw = g;
      let s = 0;
      let t = r._w;
      let u = this._bw._w;
      if (t < u) {
        for (let v = r._w; v < this._bw._w; v++) {
          i._i(0);
        }
      }
      else if (u < t) {
        let w = t - u;
        let x = new Array(w);
        if (a.a != null) {
          let y = Math.min(w, a.a.length);
          let z = w - y;
          for (let aa = 0; aa < y; aa++) {
            x[aa + z] = a.a[aa];
          }
        }
        let ab = 0;
        for (let ac = this._bw._w; ac < r._w; ac++ , s++ , ab++) {
          this._ed(this._b7(s, x[ab]));
        }
      }
      if (this._bw._af < i.count) {
        for (; s < this._bw._af; s++) {
          i._item(s)._br();
        }
        while (this._bw._af < i.count) {
          i._i(i.count - 1);
        }
      }
      else {
        for (; s < i.count; s++) {
          i._item(s)._br();
        }
        let ad = this._bw._af - i.count;
        let ae = new Array(ad);
        if (a.b != null) {
          let af = Math.min(ad, a.b.length);
          for (let ag = 0; ag < af; ag++) {
            ae[ag] = a.b[ag];
          }
        }
        let ah = this._cz;
        this._cz = true;
        try {
          let ai = 0;
          for (; s < this._bw._af; s++ , ai++) {
            this._ed(this._b7(i.count, ae[ai]));
          }
        }
        finally {
          this._cz = ah;
        }
      }
      this._dz();
      if (this.isHeaderRowVisible) {
        this._du();
      }
      for (let aj = 0; aj < p.count; aj++) {
        p._inner[aj]._b0();
      }
      if (q != null) {
        q._hs(this);
      }
      let ak = this.dataAreaRegion;
      let al = null;
      if (f._ae < ak.lastRow) {
        al = c._cx(f._ae + 1, ak.firstColumn, ak.lastRow, ak.lastColumn);
      }
      for (let am = 0; am < this._columns$i.count; am++) {
        this._columns$i._item(am)._bm(f, al, ak);
      }
      if (this._cs && 1 < this.dataAreaRegion._aa) {
        this._cs = false;
      }
    }
    finally {
      this._cv = false;
      d.e(WorksheetTable_ResizeContext.$, WorksheetRegionAddress.$, a, a.c, b);
      if (e != null) {
        d.d(c.workbook, e);
      }
    }
  }
  /**
   * @hidden
   */
  _dv(a, b, c) {
    let d = this.style;
    if (d == null) {
      return;
    }
    this._dw(a, b, c, d._n(), this.dataAreaRegion);
  }
  /**
   * @hidden
   */
  _dz() {
    if (this._cz) {
      return;
    }
    try {
      this._cz = true;
      let a = new Dictionary$2(WorksheetTableColumn.$, String_$type, 0);
      let b = new List$1(KeyValuePair$2.$.specialize(WorksheetTableColumn.$, String_$type), 0);
      let c = ExcelUtils.ef("GenerateTableColumnName");
      let d = new Dictionary$2(String_$type, WorksheetTableColumn.$, 2, StringComparer.c);
      let e = this._z;
      for (let f = 0; f < this._columns$i.count; f++) {
        let g = this._columns$i._item(f);
        let h = g.name;
        if (!stringIsNullOrEmpty(h) && !d.containsKey(h)) {
          d.item(h, g);
        }
      }
      let i = this._columns$i.count;
      let j = e == ExcelUtils.cq;
      let k = 1;
      for (let l = 0; l < i; l++) {
        let m = this._columns$i._item(l);
        let n = m.name;
        let o = n;
        let p = stringIsNullOrEmpty(o);
        let q = true;
        if (!p) {
          let r;
          if (((() => { let s = d.tryGetValue(o, r); r = s.p1; return s.ret; })()) && r == m) {
            q = false;
          }
        }
        if (q) {
          if (p) {
            n = c;
            let s;
            do {
              o = n + k++;
              if (j) {
                s = d.containsKey(o);
              }
              else {
                s = false;
                for (let t = l + 1; t < this._columns$i.count; t++) {
                  if (StringUtilities.c(o, this._columns$i._item(t).name, e, 1) == 0) {
                    s = true;
                    break;
                  }
                }
              }
            } while (s);
          }
          while (d.containsKey(o)) {
            if (k == 1) {
              k++;
            }
            o = n + k++;
          }
          d.addItem(o, m);
        }
        a.addItem(m, o);
        if (this._c6 != null) {
          let u;
          if (((() => { let v = this._c6.tryGetValue(m, u); u = v.p1; return v.ret; })()) && u != o) {
            b.add(new KeyValuePair$2(WorksheetTableColumn.$, String_$type, 1, m, u));
          }
        }
      }
      for (let v = 0; v < this._columns$i.count; v++) {
        let w = this._columns$i._item(v);
        w.name = a.item(w);
      }
      this._c6 = a;
      if (b.count != 0) {
        let x = this._k;
        if (x != null) {
          x._h9(this, b);
        }
      }
    }
    finally {
      this._cz = false;
    }
  }
  /**
   * @hidden
   */
  static _cd(a, b) {
    let c;
    return ((() => { let d = WorksheetTable._c4(a, b, c); c = d.p2; return d.ret; })());
  }
  /**
   * @hidden
   */
  _ce(a, b) {
    if (this._bn == null || a.worksheet != this._bn) {
      return false;
    }
    return this._cf(a.index, b);
  }
  /**
   * @hidden
   */
  _cf(a, b) {
    return this._bw._i(a, b);
  }
  /**
   * @hidden
   */
  _cg(a, b) {
    return this._bw.containsColumns(a, b);
  }
  /**
   * @hidden
   */
  _d5(a, b, c, d = Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, null)) {
    let e = this._k;
    this._cv = true;
    let f = this.worksheet;
    let g = c ? WorksheetTable._bf[12] : WorksheetTable._bf[11];
    let h = f != null ? g.b(e, f, g.c) : null;
    let i = e._df;
    e._df = true;
    try {
      let j = this._bw;
      let k = new List$1(WorksheetTableColumn.$, 2, this._columns$i.count);
      for (let l of fromEnum(this._columns$i)) {
        l._b4();
        k.add(l);
      }
      let m = this._bo(a, b, c, true, nullableNotEquals(d, null));
      e._df = i;
      let n = nullableNotEquals(d, null) ? d.value.a : null;
      if (c) {
        this._bw = j._e((j._x - b));
        this._ev(a, b, true, Nullable$1.toNullable(WorksheetRegionAddress.$, j), Nullable$1.toNullable(WorksheetCellShiftResult.$, m), g, h, Nullable$1.toNullable(Boolean_$type, i), nullableNotEquals(d, null));
      }
      else {
        this._bw = j._e((j._x + b));
        this._ef(a, b, n, true, Nullable$1.toNullable(WorksheetRegionAddress.$, j), Nullable$1.toNullable(WorksheetCellShiftResult.$, m), g, h, Nullable$1.toNullable(Boolean_$type, i));
      }
      for (let o of fromEnum(k)) {
        o._bs();
      }
      e._df = true;
      e._hm((p, q) => q._b6(e), true);
    }
    finally {
      this._cv = false;
      e._df = i;
    }
  }
  /**
   * @hidden
   */
  _d6(a, b, c, d = Nullable$1.toNullable(WorksheetTable_RowChangeContext.$, null)) {
    let e = this._k;
    if (e == null) {
      return;
    }
    this._cv = true;
    let f = Nullable$1.toNullable(WorksheetTable_RowChangeContext.$, null);
    let g = WorksheetTable._bf[c ? 14 : 13];
    let h = this._bn != null ? g.b(e, this._bn, g.c) : null;
    let i = e._df;
    e._df = true;
    try {
      let j = this._bw;
      let k = this._bo(a, b, c, false, nullableNotEquals(d, null));
      if (c) {
        this._bw = j._f(j._ae - b);
      }
      else {
        this._bw = j._f(j._ae + b);
      }
      f = Nullable$1.toNullable(WorksheetTable_RowChangeContext.$, new WorksheetTable_RowChangeContext(1, this, a, b, Nullable$1.toNullable(WorksheetRegionAddress.$, j)));
      e._hm((l, m) => m._b6(e), true);
    }
    finally {
      this._cv = false;
      e._df = i;
      if (nullableNotEquals(f, null)) {
        g.e(WorksheetTable_RowChangeContext.$, Number_$type, f.value, -1, a);
        if (h != null) {
          g.d(e, h);
        }
      }
    }
    let l = !c;
    if (nullableNotEquals(d, null)) {
      l = false;
    }
    if (l) {
      let m;
      let n;
      let o = this._d7(this._bw, m, n);
      m = o.p1;
      n = o.p2;
      for (let p of fromEnum(this._columns$i)) {
        p._ba(m, m + a, b);
      }
    }
  }
  /**
   * @hidden
   */
  _d8(a, b) {
    let c = this._d7(this._bw, a, b);
    a = c.p1;
    b = c.p2;
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _d7(a, b, c) {
    b = a._ac;
    if (this.isHeaderRowVisible) {
      b++;
    }
    c = a._ae;
    if (this.isTotalsRowVisible) {
      c--;
    }
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _d9() {
    let a = this._k;
    for (let b = 0; b < this._columns$i.count; b++) {
      this._columns$i._item(b)._bd();
    }
    let c = this._columns$i._item(0);
    let d = c._areaFormats$i._c(1);
    let e = c._areaFormats$i._c(0);
    let f = c._areaFormats$i._c(2);
    for (let g = 1; g < this._columns$i.count; g++) {
      let h = this._columns$i._item(g);
      if (d != null) {
        let i = h._areaFormats$i._c(1);
        if (d.equals(i) == false) {
          d = null;
        }
      }
      if (e != null) {
        let j = h._areaFormats$i._c(0);
        if (e.equals(j) == false) {
          e = null;
        }
      }
      if (f != null) {
        let k = h._areaFormats$i._c(2);
        if (f.equals(k) == false) {
          f = null;
        }
      }
    }
    try {
      this._c3 = true;
      if (d != null) {
        this._areaFormats$i.item(2).setFormatting(d);
      }
      if (e != null) {
        this._areaFormats$i.item(1).setFormatting(e);
      }
      if (f != null) {
        this._areaFormats$i.item(3).setFormatting(f);
      }
      let l = WorksheetMergedCellsRegion._a0(this.worksheet, this._by, Nullable$1.toNullable(CellFormatValue_$type, null), false);
      if (l != null) {
        let m = this._areaFormats$i._d(a, 0);
        for (let n of fromEnum(l)) {
          m._bk(n.key, n.value);
        }
      }
    }
    finally {
      this._c3 = false;
    }
  }
  /**
   * @hidden
   */
  _ed(a) {
    a._bd();
    let b = this._k;
    let c = this._areaFormats$i._f(2);
    if (c != null) {
      let d = a._areaFormats$i._d(b, 1);
      d.formatOptions &= ~c.formatOptions;
      ExcelUtils.fc(c, d, 0x7FFFFFFF, true);
    }
    let e = this._areaFormats$i._f(1);
    if (e != null) {
      let f = a._areaFormats$i._d(b, 0);
      f.formatOptions &= ~e.formatOptions;
      ExcelUtils.fc(e, f, 0x7FFFFFFF, true);
    }
    let g = this._areaFormats$i._f(3);
    if (g != null) {
      let h = a._areaFormats$i._d(b, 2);
      h.formatOptions &= ~g.formatOptions;
      ExcelUtils.fc(g, h, 0x7FFFFFFF, true);
    }
  }
  /**
   * @hidden
   */
  _ea() {
    let a = this.dataAreaRegion;
    if (a == null || a.worksheet == null) {
      return;
    }
    for (let b = 0; b < this._columns$i.count; b++) {
      let c = this._columns$i._item(b);
      let d = null;
      let e = (intDivide(a._aa, 2)) + 1;
      let f = a.lastRow - e + 1;
      for (let g = f; g <= a.lastRow; g++) {
        let h = this._bn._rows$i._aj(g);
        if (h == null) {
          d = null;
        }
        else {
          let i = h._ar(c._at);
          if (d == null) {
            d = i;
          }
          else if (i == null || i._ao(d) == false) {
            d = null;
          }
        }
        if (d == null) {
          break;
        }
      }
      if (d != null) {
        d = d._g();
        d._bw(this._k, a._k, c._at, ExcelUtils.g5(0, a.firstRow - f));
        c._bz(d);
      }
    }
  }
  /**
   * @hidden
   */
  _ec(a, b) {
    let c = Math.min(a._columns$i.count, this._columns$i.count);
    let d = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 512 | 2048;
    this._b1 = a._b1 & d;
    if (a._bl != null) {
      this.sortSettings._v(a._bl);
      if (a._bl._sortConditions$i.count > 0) {
        for (let e of fromEnum(a._bl._sortConditions$i)) {
          let f = e.key.index;
          if (f < c) {
            let g = e.value._a();
            this._bl._sortConditions$i._s(this._columns$i._item(f), g);
          }
        }
      }
    }
    if (a._b2 != null) {
      for (let h of fromEnum(a._b2)) {
        let i = h.key;
        let j = typeCast(WorksheetCellFormatProxy.$, h.value);
        let k = typeCast(WorksheetCellFormatProxy.$, this._b2.item(i));
        ExcelUtils.fc(j, k, 0x7FFFFFFF, void 0, void 0, void 0, b);
      }
    }
    for (let l = 0; l < c; l++) {
      this._columns$i._item(l)._be(a._columns$i._item(l), b);
    }
  }
  /**
   * @hidden
   */
  _b4() {
    return this._b8(this._columns$i.count, this._dr);
  }
  /**
   * @hidden
   */
  _b5(a) {
    return this._b8(this._columns$i.count, a);
  }
  /**
   * @hidden
   */
  _b8(a, b) {
    this._dr = Math.max(b + 1, this._dr);
    let c = this._bw._w + a;
    let d = new WorksheetTableColumn(this, b, c);
    this._b9._h(a, d);
    return d;
  }
  /**
   * @hidden
   */
  _b6(a) {
    return this._b8(a, this._dr);
  }
  /**
   * @hidden
   */
  _b7(a, b) {
    if (b == null) {
      return this._b6(a);
    }
    let c = this._bw._w + a;
    this._b9._h(a, b);
    b._bj(this, c);
    return b;
  }
  /**
   * @hidden
   */
  _cn(a, b) {
    return this._bw.intersectsWithColumns(a, b);
  }
  /**
   * @hidden
   */
  _ct(a) {
    if (a == null || false == a.performsShift || false == a.isRemoveOperation || false == a.shiftsRows) {
      return true;
    }
    if (a != null && a.isUndoOperation && a.shiftsRows) {
      return true;
    }
    if (this.isHeaderRowVisible && false == ExcelUtils.aq(a, this._by)) {
      if (ExcelUtils.as(a, this.headerRowRegion._h)) {
        return false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _cy(a, b) {
    if (this._bw._w >= b._w && this._bw._ac >= b._ac && this._bw._x <= b._x && this._bw._ae <= b._ae) {
      let c = this.worksheet.workbook;
      let d = c._df;
      c._df = false;
      this.worksheet._tables$i.remove_1(this);
      c._df = d;
      return true;
    }
    if (this.isTotalsRowVisible && a.q) {
      let e = this.totalsRowRegion._h;
      if (b._h(e)) {
        this._k._ij(() => this._cx = false);
        if (b._ac == e._ac) {
          return true;
        }
      }
    }
    for (let f = 0; f < this._columns$i.count; f++) {
      this._columns$i._item(f)._b4();
    }
    return false;
  }
  /**
   * @hidden
   */
  _ej(a) {
    if (a != null) {
      a._ia(this);
    }
    if (this._b2 != null) {
      this._b2._l();
    }
    if (this._b9 != null) {
      for (let b = 0; b < this._b9.count; b++) {
        this._b9._item(b)._bq();
      }
    }
    this._af = null;
    this.style = null;
  }
  /**
   * @hidden
   */
  _ek(a) {
    this.clearFilters();
    if (a) {
      this._dx();
    }
    let b = this._k;
    let c = this._bz;
    if (c != null) {
      for (let d = this._bw._w; d <= this._bw._x; d++) {
        c._d4(d, false);
      }
    }
    let e = this._b0;
    if (e != null) {
      for (let f = this._bw._w; f <= this._bw._x; f++) {
        e._d4(f, false);
      }
    }
    this._ej(b);
    this._bn = null;
  }
  /**
   * @hidden
   */
  _el(a) {
    this._bn = a;
    let b = this._bn.workbook;
    if (b != null) {
      this._af = b;
      b._h0(this);
      if (this._b2 != null) {
        this._b2._k(b);
      }
    }
    if (this._b9 != null) {
      for (let c = 0; c < this._b9.count; c++) {
        this._b9._item(c)._bl(b);
      }
    }
    this._dz();
    if (this.isHeaderRowVisible) {
      this._du();
    }
    if (this.isTotalsRowVisible) {
      this._dy();
    }
  }
  /**
   * @hidden
   */
  _bo(a, b, c, d, e = false) {
    let f = new CellShiftOperation();
    this._bn._conditionalFormats$i._a6(true);
    if (d) {
      let g = this._bn._columns$i.maxCount;
      f = new CellShiftOperation(2, this._bn, 0, null, this._bw._ac, this._bw._ae, (c ? this._bw._w + a + b : this._bw._w + a), (c ? g - 1 : g - (1 + b)), c ? -b : b, false);
    }
    else {
      let h = this._bn._rows$i.maxCount;
      let i = this.dataAreaRegion;
      f = new CellShiftOperation(2, this._bn, 3, null, c ? i.firstRow + a + b : i.firstRow + a, c ? h - 1 : h - (1 + b), this._bw._w, this._bw._x, c ? -b : b, false);
    }
    let j = a == 0 && false == c && d ? 1 : 2;
    if (e) {
      j = 0;
    }
    this._bn._hz(true);
    let k = this._bn._b8(f, j, null);
    this._bn._conditionalFormats$i._a7();
    this._bn._h0();
    this._bn._h7();
    if (d) {
      this._bn._columns$i._ac(k.a);
    }
    else {
      this._bn._rows$i._ac(k.a);
    }
    return k;
  }
  /**
   * @hidden
   */
  static _es(a, b) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 0: break;
        case 1: throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_LossOfData", b));
        case 2: throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_LossOfObject", b));
        case 3: throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_SplitTable", b));
        case 4: throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_NewRegionOverlapsFilterArea"));
        case 5: throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_SplitMergedRegion", b));
        case 6: throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_SplitBlockingValue", b));
        default:
          t1 = 1;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _e0() {
    this._c7--;
    if (this._c7 <= 0 && this._c1) {
      this._c1 = false;
      this.reapplyFilters();
    }
  }
  /**
   * @hidden
   */
  _bk(a, b, c) {
    let d;
    if (b != null && b.shiftsRows) {
      if (!b.isUndoOperation) {
        this._bv = this._bw;
        d = ((() => { let e = a.e(this._bw, false); this._bw = e.p0; return e.ret; })());
        this.worksheet.workbook._ij(() => this._bx = this._bw);
      }
      else {
        d = ShiftAddressResult.c;
      }
    }
    else {
      let e = new WorksheetRegionAddress(1, this._bw._ac, this._bw._ae, this._bw._w, this._bw._x);
      d = ((() => { let f = a.e(this._bw, false); this._bw = f.p0; return f.ret; })());
      if (d.f && b != null && b.shiftsColumns && !b.isUndoOperation) {
        let f = this._k;
        if (f != null && e._af != this._bw._af) {
          let g = f._df;
          f._df = false;
          try {
            let h = this._bw._af - e._af;
            if (h < 0) {
              let i = Math.max(0, a.k._w - this._bw._w);
              this._ev(i, -h, true, Nullable$1.toNullable(WorksheetRegionAddress.$, e));
            }
            else {
              let j = a.l._w - e._w;
              this._ef(j, h, null, true, Nullable$1.toNullable(WorksheetRegionAddress.$, e));
            }
          }
          finally {
            f._df = g;
          }
        }
      }
    }
    if (c) {
      for (let k = 0; k < this._columns$i.count; k++) {
        this._columns$i._item(k)._bs();
      }
    }
    for (let l = 0; l < this._columns$i.count; l++) {
      this._columns$i._item(l)._bt((l + this._bw._w));
    }
    return d;
  }
  /**
   * @hidden
   */
  _e6() {
    this._c7++;
  }
  /**
   * @hidden
   */
  _du() {
    let a = this._bz;
    if (a == null) {
      return;
    }
    let b = false;
    let c = this._k;
    if (c != null) {
      b = c._c4;
    }
    if (false == b && this._cu) {
      b = true;
    }
    try {
      this._cz = true;
      for (let d = 0; d < this._columns$i.count; d++) {
        let e = this._columns$i._item(d);
        let f = (d + this._bw._w);
        a._d4(f, true);
        if (b == false) {
          a.setCellValue(f, e._a5);
        }
      }
    }
    finally {
      this._cz = false;
    }
  }
  /**
   * @hidden
   */
  _dw(a, b, c, d, e) {
    for (let f = d._k - 1; f >= 0; f--) {
      let g = d._j._inner[f];
      if (this._co(a, b, g._bt, e) == false) {
        continue;
      }
      if (g._bt == 0) {
        let h = 0x7FFFFFFF & ~208404486;
        if (a == this._bw._ac) {
          h |= 67108864;
          h |= 134217728;
        }
        if (a == this._bw._ae) {
          h |= 2;
          h |= 4;
        }
        if (b == this._bw._w) {
          h |= 262144;
          h |= 524288;
        }
        if (b == this._bw._x) {
          h |= 2097152;
          h |= 4194304;
        }
        WorksheetTable._eb(c, g, h);
        continue;
      }
      WorksheetTable._eb(c, g);
    }
  }
  /**
   * @hidden
   */
  _dx() {
    let a = this.style;
    if (a == null) {
      return;
    }
    let b = a._n();
    let c = this.dataAreaRegion;
    for (let d of fromEnum(this.wholeTableRegion)) {
      this._dw(d.rowIndex, d._ab, d._cellFormatInternal, b, c);
    }
  }
  /**
   * @hidden
   */
  _dy() {
    let a = this._b0;
    if (a == null) {
      return;
    }
    let b = false;
    let c = this._k;
    if (c != null) {
      b = c._c4;
    }
    if (false == b && this._cu) {
      b = true;
    }
    for (let d = 0; d < this._columns$i.count; d++) {
      let e = this._columns$i._item(d);
      let f = (d + this._bw._w);
      a._d4(f, true);
      if (b == false) {
        if (e._aa != null) {
          e._aa._bp(a, f);
        }
        else {
          let g = e._a7;
          if (stringIsNullOrEmpty(g) == false) {
            a.setCellValue(f, g);
          }
          else {
          }
        }
      }
    }
  }
  /**
   * @hidden
   */
  _d1(a) {
    let b = this.worksheet._rows$i._aj(a);
    if (b == null) {
      return;
    }
    for (let c = this._bw._w; c <= this._bw._x; c++) {
      b._d4(c, false);
      b.setCellValue(c, null);
      let d = b._bd(c);
      if (d != null) {
        d.style = null;
        d.formatOptions = 0;
      }
    }
  }
  /**
   * @hidden
   */
  static _bh($tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetTable.$, $tValue, a, 72, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _bi($tContext, $tValue, a, b, c, d, e = null, f = true, g = false, h = 8192 | 16384) {
    return new ChangeInfo$2($tContext, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _bg() {
    let a = new Array(17);
    NamedReferenceBase._ba(a, 72);
    ChangeInfo.f(a, 2, WorksheetTable._bh(Boolean_$type, "DisplayBandedColumns", (b) => b.displayBandedColumns, (b, c) => b.displayBandedColumns = c, (b, c) => b._e2(1, c), true));
    ChangeInfo.f(a, 3, WorksheetTable._bh(Boolean_$type, "DisplayBandedRows", (b) => b.displayBandedRows, (b, c) => b.displayBandedRows = c, (b, c) => b._e2(2, c), true));
    ChangeInfo.f(a, 4, WorksheetTable._bh(Boolean_$type, "DisplayFirstColumnFormatting", (b) => b.displayFirstColumnFormatting, (b, c) => b.displayFirstColumnFormatting = c, (b, c) => b._e2(4, c), true));
    ChangeInfo.f(a, 5, WorksheetTable._bh(Boolean_$type, "DisplayLastColumnFormatting", (b) => b.displayLastColumnFormatting, (b, c) => b.displayLastColumnFormatting = c, (b, c) => b._e2(8, c), true));
    ChangeInfo.f(a, 6, WorksheetTable._bh(Boolean_$type, "IsFilterUIVisible", (b) => b.isFilterUIVisible, (b, c) => b.isFilterUIVisible = c, (b, c) => b._e3(c), true, true));
    ChangeInfo.f(a, 7, WorksheetTable._bh(Boolean_$type, "IsHeaderRowVisible", (b) => b.isHeaderRowVisible, (b, c) => b.isHeaderRowVisible = c, (b, c) => b._e4(c), true, true));
    ChangeInfo.f(a, 8, WorksheetTable._bh(Boolean_$type, "IsTotalsRowVisible", (b) => b.isTotalsRowVisible, (b, c) => b.isTotalsRowVisible = c, (b, c) => b._e5(c), true, true));
    ChangeInfo.f(a, 9, WorksheetTable._bi(WorksheetTable_ResizeContext.$, WorksheetRegionAddress.$, "Resize", 79, (b) => b.d._by, (b, c) => WorksheetTable._fc(b, c), null, true, true));
    ChangeInfo.f(a, 10, WorksheetTable._bh(WorksheetTableStyle.$, "Style", (b) => b.style, (b, c) => b.style = c, null, true));
    ChangeInfo.f(a, 11, WorksheetTable._bi(WorksheetTable_ColumnChangeContext.$, Number_$type, "InsertColumns", 75, (b) => b.h, (b, c) => WorksheetTable._e8(b, c), null, true, true));
    ChangeInfo.f(a, 12, WorksheetTable._bi(WorksheetTable_ColumnChangeContext.$, Number_$type, "RemoveColumns", 76, (b) => b.h, (b, c) => WorksheetTable._fa(b, c), null, true, true));
    ChangeInfo.f(a, 13, WorksheetTable._bi(WorksheetTable_RowChangeContext.$, Number_$type, "InsertRows", 77, (b) => b.d, (b, c) => WorksheetTable._e9(b, c), null, true, true));
    ChangeInfo.f(a, 14, WorksheetTable._bi(WorksheetTable_RowChangeContext.$, Number_$type, "RemoveRows", 78, (b) => b.d, (b, c) => WorksheetTable._fb(b, c), null, true, true));
    ChangeInfo.f(a, 15, WorksheetTable._bh(Boolean_$type, "IsTotalsRowVisibleNoShift", (b) => b._cx, (b, c) => b._cx = c, (b, c) => b._e5(c, true), true, true));
    ChangeInfo.f(a, 16, WorksheetTable._bh(WorksheetRegionAddress.$, "AddressBeforeShiftRows", (b) => b._bx, (b, c) => b._bx = c, (b, c) => b._e1(c), true, true));
    return a;
  }
  /**
   * @hidden
   */
  _cl(a) {
    return (this._b1 & a) == a;
  }
  /**
   * @hidden
   */
  static _eb(a, b, c = 0x7FFFFFFF) {
    let d = a.a();
    let e = a.style;
    let f = e != null && e._n == false ? e._i._bz : 0;
    let g = a.d.v;
    let h = g != null ? g._styles$i.normalStyle._i : null;
    for (let i = 1; i != 1073741824; i = (i << 1)) {
      if ((c & i) == 0) {
        continue;
      }
      if (a._aa(i) == false) {
        switch (i) {
          case 64:
          case 256:
          case 4:
          case 134217728:
          case 4194304:
          case 524288:
          case 32:
            if (h == null || !Base.equalsStatic(h._dd(i), a._aj(i))) {
              continue;
            }
            break;
          default: continue;
        }
      }
      let j = WorksheetCellFormatData._by(i);
      if ((f & j) != 0 && (a.formatOptions & j) == 0) {
        continue;
      }
      let k = b._aj(i);
      if (WorksheetCellFormatData._cf(i, k) == false) {
        a._bl(i, k, false, 0);
      }
    }
    a.g(d);
  }
  /**
   * @hidden
   */
  _co(a, b, c, d) {
    switch (c) {
      case 0: return true;
      case 7:
      case 8:
        {
          if (this.displayBandedColumns == false || d._q(a, b) == false) {
            return false;
          }
          let e = this.style.columnStripeWidth + this.style.alternateColumnStripeWidth;
          let f = (b - this._by._w) % e;
          if (c == 7) {
            return f < this.style.columnStripeWidth;
          }
          return this.style.columnStripeWidth <= f;
        }
      case 5:
      case 6:
        {
          if (this.displayBandedRows == false || d._q(a, b) == false) {
            return false;
          }
          let g = this.style.rowStripeHeight + this.style.alternateRowStripeHeight;
          let h = (a - d.firstRow) % g;
          if (c == 5) {
            return h < this.style.rowStripeHeight;
          }
          return this.style.rowStripeHeight <= h;
        }
      case 4:
        {
          if (this.displayLastColumnFormatting == false) {
            return false;
          }
          return (b == this._by._x);
        }
      case 3:
        {
          if (this.displayFirstColumnFormatting == false) {
            return false;
          }
          return (b == this._by._w);
        }
      case 1: return (this.isHeaderRowVisible && a == this._by._ac);
      case 2: return (this.isTotalsRowVisible && a == this._by._ae);
      case 9:
        {
          if (this.displayFirstColumnFormatting == false) {
            return false;
          }
          return (this.isHeaderRowVisible && a == this._by._ac && b == this._by._w);
        }
      case 10:
        {
          if (this.displayLastColumnFormatting == false) {
            return false;
          }
          return (this.isHeaderRowVisible && a == this._by._ac && b == this._by._x);
        }
      case 11:
        {
          if (this.displayFirstColumnFormatting == false) {
            return false;
          }
          return (this.isTotalsRowVisible && a == this._by._ae && b == this._by._w);
        }
      case 12:
        {
          if (this.displayLastColumnFormatting == false) {
            return false;
          }
          return (this.isTotalsRowVisible && a == this._by._ae && b == this._by._x);
        }
      default: return false;
    }
  }
  /**
   * @hidden
   */
  _ef(a, b, c = null, d = false, e = Nullable$1.toNullable(WorksheetRegionAddress.$, null), f = Nullable$1.toNullable(WorksheetCellShiftResult.$, null), g = null, h = null, i = Nullable$1.toNullable(Boolean_$type, null)) {
    if (a < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (b < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    let j = this._k.maxColumnCount;
    if (a + b > j) {
      throw new InvalidOperationException(1, "Max columns exceeded");
    }
    let k = this.worksheet;
    let l = k != null ? k.workbook : null;
    let m = this._cz;
    this._cz = true;
    if (g == null) {
      g = WorksheetTable._bf[11];
      h = k != null ? g.b(k.workbook, k, g.c) : null;
    }
    let n = false;
    if (l != null) {
      if (nullableNotEquals(i, null)) {
        n = i.value;
      }
      else {
        n = l._df;
      }
      if (d) {
        l._df = true;
      }
    }
    let o = Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, null);
    try {
      for (let p = a; p < this._columns$i.count; p++) {
        this._columns$i._item(p)._bk(true);
      }
      for (let q = 0; q < b; q++) {
        if (c != null) {
          this._b7(a + q, c[q]);
        }
        else {
          this._b6(a + q);
        }
      }
      for (let r = a + b; r < this._columns$i.count; r++) {
        this._columns$i._item(r)._bj(this, (this._bw._w + r), true);
      }
      let s = new Array(b);
      for (let t = 0; t < b; t++) {
        s[t] = this._columns$i._item(a + t);
      }
      if (c == null || stringIsNullOrEmpty(c[0]._a5)) {
        let u = false;
        let v = 0;
        let w = ExcelUtils.ef("GenerateTableColumnName");
        if (a > 0) {
          let x = this._columns$i._item(a - 1).name;
          if (!stringIsNullOrEmpty(x)) {
            let y = 0;
            for (let z = x.length - 1; z >= 0; z--) {
              let aa = x.charAt(z);
              if ((aa.charCodeAt(0) >= '0'.charCodeAt(0)) && (aa.charCodeAt(0) <= '9'.charCodeAt(0))) {
                y++;
              }
              else {
                break;
              }
            }
            if (y > 0 && y < 10 && ((() => { let ab = tryParseInt32_1(x.substr(x.length - y), v); v = ab.p1; return ab.ret; })())) {
              w = x.substr(0, x.length - y);
              u = true;
            }
          }
        }
        if (!u) {
          while (true) {
            if (null == this._columns$i._item1(w + (v + 1))) {
              break;
            }
            v++;
          }
        }
        let ab = null;
        let ac = false;
        for (let ae = 0; ae < s.length; ae++) {
          let ad = s[ae];
          if (!ac) {
            v++;
            let af = w + v;
            ac = this._columns$i._item1(af) != null;
            if (ac) {
              if (ab == null) {
                ac = false;
                w = w + (v - 1);
                v = 2;
                while (ab == null) {
                  af = w + v;
                  if (this._columns$i._item1(af) == null) {
                    ab = af;
                    break;
                  }
                  v++;
                }
              }
            }
            else {
              ab = af;
            }
          }
          ad.name = ab;
        }
      }
      this._cz = m;
      this._dz();
      let ag = new List$1(Formula.$, 0);
      l._ib(this, new List$1(WorksheetTableColumn.$, 0), ag);
      for (let ah = 0; ah < ag.count; ah++) {
        ag._inner[ah]._b0();
      }
      o = Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, new WorksheetTable_ColumnChangeContext(1, this, a, b, d, this._cv, s, null, e));
    }
    finally {
      if (l != null && d) {
        l._df = n;
      }
      if (nullableNotEquals(o, null)) {
        g.e(WorksheetTable_ColumnChangeContext.$, Number_$type, o.value, -1, a);
      }
      if (h != null) {
        g.d(k.workbook, h);
      }
    }
  }
  /**
   * @hidden
   */
  _ev(a, b, c = false, d = Nullable$1.toNullable(WorksheetRegionAddress.$, null), e = Nullable$1.toNullable(WorksheetCellShiftResult.$, null), f = null, g = null, h = Nullable$1.toNullable(Boolean_$type, null), i = false) {
    if (a < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (b < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (a + b > this._columns$i.count) {
      throw new InvalidOperationException(1, "Max columns exceeded");
    }
    let j = this.worksheet;
    let k = j != null ? j.workbook : null;
    if (f == null) {
      f = WorksheetTable._bf[12];
      g = j != null ? f.b(j.workbook, j, f.c) : null;
    }
    let l = false;
    if (k != null) {
      if (h.hasValue) {
        l = h.value;
      }
      else {
        l = k._df;
      }
      if (c) {
        k._df = true;
      }
    }
    let m = Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, null);
    try {
      let n = new HashSet$1(WorksheetTableColumn.$, 0);
      let o = Math.min(this._columns$i.count, a + b) - 1;
      for (let p = a; p <= o; p++) {
        n.add_1(this._columns$i._item(p));
      }
      let q = new List$1(Tuple$3.$.specialize(WorksheetTableColumn.$, Number_$type, SortCondition.$), 0);
      for (let r = 0; r < this.sortSettings._sortConditions$i.count; r++) {
        let s = this.sortSettings._sortConditions$i._item1(r);
        if (n.contains(s.key)) {
          q.add(Tuple.b(WorksheetTableColumn.$, Number_$type, SortCondition.$, s.key, r + q.count, s.value));
          this.sortSettings._sortConditions$i.removeAt(r);
          r--;
        }
      }
      for (let t = a + b; t < this._columns$i.count; t++) {
        this._columns$i._item(t)._bk(true);
      }
      let u = new Array(b);
      for (let v = 0; v < b; v++) {
        u[v] = this._columns$i._item(a);
        this._columns$i._i(a);
      }
      for (let w = a; w < this._columns$i.count; w++) {
        this._columns$i._item(w)._bj(this, (this._bw._w + w), true);
      }
      let x = new List$1(Formula.$, 0);
      if (k != null && !i) {
        k._df = false;
      }
      k._ib(this, new List$1(WorksheetTableColumn.$, 1, n), x);
      if (k != null && !i) {
        k._df = true;
      }
      for (let y = 0; y < x.count; y++) {
        x._inner[y]._b0();
      }
      m = Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, new WorksheetTable_ColumnChangeContext(1, this, a, b, c, this._cv, u, q.toArray(), d));
    }
    finally {
      if (k != null && c) {
        k._df = l;
      }
      if (nullableNotEquals(m, null)) {
        f.e(WorksheetTable_ColumnChangeContext.$, Number_$type, m.value, -1, a);
      }
      if (g != null) {
        f.d(j.workbook, g);
      }
    }
  }
  /**
   * @hidden
   */
  _eh() {
    this.isFilterUIVisible = this.isHeaderRowVisible;
    if (this.worksheet == null) {
      return;
    }
    let a = this._k;
    if (a != null) {
      a._hs(this);
    }
    if (this.isHeaderRowVisible) {
      if (this._c2()) {
        if (this.worksheet._b7(this._bw._ac, this._bw._w, this._bw._x, 0).a != 0) {
        }
      }
      this._bw = this._bw._d(this._bw._ac - 1);
      this._du();
      for (let b of fromEnum(this._columns$i)) {
        b._bh();
      }
    }
    else {
      this.clearFilters();
      let c = this._bw._ac;
      this._bw = this._bw._d(c + 1);
      this._d1(c);
    }
  }
  /**
   * @hidden
   */
  _ei() {
    if (this.worksheet == null) {
      return;
    }
    if (this.isHeaderRowVisible) {
      for (let a of fromEnum(this._columns$i)) {
        a._bg();
      }
    }
    else {
      if (this._c2()) {
        let b = ExcelUtils.ef("TableHeaderRowDescription");
        let c = this.worksheet._rows$i.maxCount - 1;
        if (c == this._bw._ae) {
          throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_TableOnBottomOfWorksheet", b));
        }
        let d = this.worksheet._a7(this._bw._ae + 1, c - 1, this._bw._w, this._bw._x, 1, 3);
        WorksheetTable._es(d, b);
      }
    }
  }
  /**
   * @hidden
   */
  _em(a) {
    if (this.worksheet == null) {
      return;
    }
    let b = this._k;
    if (b != null) {
      b._hs(this);
    }
    let c = this._bw._ae;
    this._bw = this._bw._f(this._bw._ae - 1);
    if (a || this.worksheet._b6(c, this._bw._w, this._bw._x).a != 0) {
      this._d1(c);
    }
  }
  /**
   * @hidden
   */
  _en() {
    if (this.worksheet == null) {
      return;
    }
    for (let a of fromEnum(this._columns$i)) {
      a._bn();
    }
  }
  /**
   * @hidden
   */
  _eo(a) {
    a = true;
    if (this.worksheet == null) {
      return {
        p0: a
      };
    }
    let b = this._k;
    let c = this.worksheet._rows$i.maxCount - 1;
    if (this._bw._ae == c) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TotalsRowCannotBeShownInLastRow"));
    }
    let d = ExcelUtils.ef("TableTotalsRowDescription");
    let e = this.worksheet._a7(this._bw._ae + 1, c - 1, this._bw._w, this._bw._x, 1, 3);
    if (e != 0) {
      if (this.worksheet._dp(this._bw._ae + 1, this._bw._w, this._bw._x)) {
        WorksheetTable._es(e, d);
      }
      a = false;
    }
    if (b != null && this._cm == false) {
      if (this._columns$i.count > 1) {
        let f = this._columns$i._item(0);
        if (f.totalFormula == null && f.totalLabel == null) {
          f.totalLabel = ExcelUtils.ef("DefaultTotalLabel");
        }
      }
      let g = this._columns$i._item(this._columns$i.count - 1);
      if (g.totalFormula == null && g.totalLabel == null) {
        let h = 2;
        let i;
        let j;
        let k = this._d8(i, j);
        i = k.p0;
        j = k.p1;
        let l = this.worksheet;
        for (let m of fromEnum(l._rows$i._m(i, j))) {
          let n = m._c5(g._at);
          if (n == null) {
            continue;
          }
          let o;
          let p = ExcelUtils.ba(n) && ((() => { let q = l._en(m, g._at, o); o = q.p2; return q.ret; })()) == false;
          if (p) {
            h = 6;
            continue;
          }
          h = 2;
          break;
        }
        g.totalFormula = b._ao(g, h);
      }
    }
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _ep(a) {
    if (this.worksheet == null) {
      return;
    }
    let b = this._k;
    if (b != null) {
      b._hs(this);
    }
    if (a) {
      let c = this.worksheet._b7(this._bw._ae + 1, this._bw._w, this._bw._x, 0);
    }
    this._bw = this._bw._f(this._bw._ae + 1);
    this._dy();
    this._cm = true;
    for (let d of fromEnum(this._columns$i)) {
      d._bo();
    }
  }
  /**
   * @hidden
   */
  _dp(a) {
    let b = this._k;
    return b != null && b._cx ? b._go(this._bn, a, null) : null;
  }
  /**
   * @hidden
   */
  _eq(a) {
    if (a != null) {
      let b = this._k;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _e2(a, b) {
    if (b) {
      this._b1 |= a;
    }
    else {
      this._b1 &= ~a;
    }
  }
  /**
   * @hidden
   */
  _c2() {
    return this._bw._ac == 0 || this.worksheet._dp(this._bw._ac - 1, this._bw._w, this._bw._x);
  }
  /**
   * @hidden
   */
  _e7(a, b) {
    if (this._c3 || this._cu) {
      return;
    }
    if (a == null || a._z) {
      return;
    }
    let c = this._k;
    if (c != null && c._c4) {
      return;
    }
    let d = a._bt;
    let e;
    switch (d) {
      case 0: return;
      case 1:
        e = 0;
        break;
      case 2:
        e = 1;
        break;
      case 3:
        e = 2;
        break;
      default: return;
    }
    let f = 0;
    for (let g = 1; g != 1073741824; g = (g << 1)) {
      if ((b & g) == 0) {
        continue;
      }
      if (WorksheetTable._cd(d, g) && a._aa(g) == false) {
        f |= g;
      }
    }
    if (f == 0) {
      return;
    }
    for (let h = 0; h < this._columns$i.count; h++) {
      ExcelUtils.fc(a, this._columns$i._item(h)._areaFormats$i._d(c, e), f);
    }
  }
  /**
   * @hidden
   */
  static _e8(a, b) {
    if (a.e) {
      a.d._d5(a.h, a.g, true, Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, a));
      return;
    }
    for (let c = 0; c < a.a.length; c++) {
      a.a[c]._b4();
    }
    let d = a.d._k;
    let e = d._df;
    d._df = false;
    a.d._ev(a.h, a.g, a.f, Nullable$1.toNullable(WorksheetRegionAddress.$, null), Nullable$1.toNullable(WorksheetCellShiftResult.$, null), void 0, void 0, Nullable$1.toNullable(Boolean_$type, null), true);
    d._df = e;
  }
  /**
   * @hidden
   */
  static _e9(a, b) {
    a.b._d6(a.d, a.c, true, Nullable$1.toNullable(WorksheetTable_RowChangeContext.$, a));
  }
  /**
   * @hidden
   */
  static _fa(a, b) {
    if (a.e) {
      a.d._d5(a.h, a.g, false, Nullable$1.toNullable(WorksheetTable_ColumnChangeContext.$, a));
      return;
    }
    for (let c = 0; c < a.a.length; c++) {
      a.a[c]._b4();
    }
    let d = a.d._k;
    let e = d._df;
    d._df = false;
    a.d._bw = a.c;
    a.d._ef(a.h, a.g, a.a, a.f, Nullable$1.toNullable(WorksheetRegionAddress.$, a.c));
    if (a.b != null) {
      a.d.sortSettings._sortConditions$i._ag(a.b);
    }
    d._df = e;
  }
  /**
   * @hidden
   */
  static _fb(a, b) {
    a.b._d6(a.d, a.c, false, Nullable$1.toNullable(WorksheetTable_RowChangeContext.$, a));
  }
  /**
   * @hidden
   */
  static _fc(a, b) {
    a.d._er(new WorksheetTable_ResizeContext(1, a), a.c);
  }
  /**
   * @hidden
   */
  static _fd(a, b) {
    let c;
    if (((() => { let d = WorksheetTable._c4(a, b, c); c = d.p2; return d.ret; })()) == false) {
      throw new InvalidOperationException(1, c);
    }
  }
  /**
   * @hidden
   */
  static _c4(a, b, c) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 0:
          switch (b) {
            case 2:
            case 4:
            case 32768:
            case 262144:
            case 524288:
            case 2097152:
            case 4194304:
            case 67108864:
            case 134217728:
              c = null;
              return {
                ret: true,
                p2: c
              };
          }
          c = ExcelUtils.ef("LE_InvalidOperationException_InvalidWholeTableAreaFormatProperty");
          return {
            ret: false,
            p2: c
          };
        case 1:
          c = null;
          return {
            ret: true,
            p2: c
          };
        case 2:
          switch (b) {
            case 67108864:
            case 134217728:
              c = ExcelUtils.ef("LE_InvalidOperationException_InvalidHeaderRowAreaFormatProperty");
              return {
                ret: false,
                p2: c
              };
          }
          c = null;
          return {
            ret: true,
            p2: c
          };
        case 3:
          switch (b) {
            case 2:
            case 4:
              c = ExcelUtils.ef("LE_InvalidOperationException_InvalidTotalsRowAreaFormatProperty");
              return {
                ret: false,
                p2: c
              };
          }
          c = null;
          return {
            ret: true,
            p2: c
          };
        default:
          t1 = 1;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _fe() {
    if (this._bn == null) {
      throw new InvalidOperationException(1, "The table has been deleted");
    }
    if (this._bn.workbook == null) {
      throw new InvalidOperationException(1, "The worksheet has been deleted");
    }
  }
  /**
   * @hidden
   */
  get _bx() {
    return this._bv;
  }
  /**
   * @hidden
   */
  set _bx(a) {
    WorksheetTable._bf[16].h(WorksheetTable.$, WorksheetRegionAddress.$, this, a);
  }
  /**
   * @hidden
   */
  _e1(a) {
    this._bv = a;
    if (a._n) {
      this._bw = a;
    }
  }
  areaFormats() {
    if (arguments.length !== 0) {
      let a = this._areaFormats$i;
      return a.item.apply(a, arguments);
    }
    return this._areaFormats$i;
  }
  /**
   * @hidden
   */
  get _areaFormats$i() {
    if (this._b2 == null) {
      this._b2 = new WorksheetTableAreaFormatsCollection$1(WorksheetTableArea_$type, this);
    }
    return this._b2;
  }
  columns() {
    if (arguments.length !== 0) {
      let a = this._columns$i;
      return a.item.apply(a, arguments);
    }
    return this._columns$i;
  }
  /**
   * @hidden
   */
  get _columns$i() {
    if (this._b9 == null) {
      this._b9 = new WorksheetTableColumnCollection(this);
    }
    return this._b9;
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the table.
   * <p class="body">
   * The data area of the table can be changed by using one of the Resize overloads.
   * </p>
   * @see [[resize]]
   * @see [[resize]]
   */
  get dataAreaRegion() {
    if (this._bn == null) {
      return null;
    }
    let a;
    let b;
    let c = this._d8(a, b);
    a = c.p0;
    b = c.p1;
    return this._bn._cx(a, this._bw._w, b, this._bw._x);
  }
  /**
   * Gets or sets the value which indicates whether the alternate column format should be applied to the appropriate columns of the
   * [[WorksheetTable]].
   * <p class="body">
   * The column formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].ColumnStripe and
   * WorksheetTableStyleArea.AlternateColumnStripe values. If there is no area format applied for the AlternateColumnStripe value,
   * this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If this value is True and there is an area format for the alternate column stripe, the stripe widths are defined by the
   * [[WorksheetTableStyle.columnStripeWidth]] and [[WorksheetTableStyle.alternateColumnStripeWidth]] values.
   * </p>
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   * @see [[WorksheetTableStyle.columnStripeWidth]]
   * @see [[WorksheetTableStyle.alternateColumnStripeWidth]]
   */
  get displayBandedColumns() {
    return this._cl(1);
  }
  /**
   * Gets or sets the value which indicates whether the alternate column format should be applied to the appropriate columns of the
   * [[WorksheetTable]].
   * <p class="body">
   * The column formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].ColumnStripe and
   * WorksheetTableStyleArea.AlternateColumnStripe values. If there is no area format applied for the AlternateColumnStripe value,
   * this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If this value is True and there is an area format for the alternate column stripe, the stripe widths are defined by the
   * [[WorksheetTableStyle.columnStripeWidth]] and [[WorksheetTableStyle.alternateColumnStripeWidth]] values.
   * </p>
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   * @see [[WorksheetTableStyle.columnStripeWidth]]
   * @see [[WorksheetTableStyle.alternateColumnStripeWidth]]
   */
  set displayBandedColumns(a) {
    WorksheetTable._bf[2].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * Gets or sets the value which indicates whether the alternate row format should be applied to the appropriate rows of the
   * [[WorksheetTable]].
   * <p class="body">
   * The row formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].RowStripe and
   * WorksheetTableStyleArea.AlternateRowStripe values. If there is no area format applied for the AlternateRowStripe value,
   * this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If this value is True and there is an area format for the alternate row stripe, the stripe widths are defined by the
   * [[WorksheetTableStyle.rowStripeHeight]] and [[WorksheetTableStyle.alternateRowStripeHeight]] values.
   * </p>
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   * @see [[WorksheetTableStyle.rowStripeHeight]]
   * @see [[WorksheetTableStyle.alternateRowStripeHeight]]
   */
  get displayBandedRows() {
    return this._cl(2);
  }
  /**
   * Gets or sets the value which indicates whether the alternate row format should be applied to the appropriate rows of the
   * [[WorksheetTable]].
   * <p class="body">
   * The row formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].RowStripe and
   * WorksheetTableStyleArea.AlternateRowStripe values. If there is no area format applied for the AlternateRowStripe value,
   * this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If this value is True and there is an area format for the alternate row stripe, the stripe widths are defined by the
   * [[WorksheetTableStyle.rowStripeHeight]] and [[WorksheetTableStyle.alternateRowStripeHeight]] values.
   * </p>
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   * @see [[WorksheetTableStyle.rowStripeHeight]]
   * @see [[WorksheetTableStyle.alternateRowStripeHeight]]
   */
  set displayBandedRows(a) {
    WorksheetTable._bf[3].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * Gets or sets the value which indicates whether the first column format should be applied to the appropriate column of the
   * [[WorksheetTable]].
   * <p class="body">
   * The first column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].FirstColumn
   * value. If there is no area format applied for the FirstColumn value, this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
   * will take precedence.
   * </p>
   * @see [[displayLastColumnFormatting]]
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   */
  get displayFirstColumnFormatting() {
    return this._cl(4);
  }
  /**
   * Gets or sets the value which indicates whether the first column format should be applied to the appropriate column of the
   * [[WorksheetTable]].
   * <p class="body">
   * The first column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].FirstColumn
   * value. If there is no area format applied for the FirstColumn value, this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
   * will take precedence.
   * </p>
   * @see [[displayLastColumnFormatting]]
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   */
  set displayFirstColumnFormatting(a) {
    WorksheetTable._bf[4].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * Gets or sets the value which indicates whether the last column format should be applied to the appropriate column of the
   * [[WorksheetTable]].
   * <p class="body">
   * The last column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].LastColumn
   * value. If there is no area format applied for the LastColumn value, this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
   * will take precedence.
   * </p>
   * @see [[displayFirstColumnFormatting]]
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   */
  get displayLastColumnFormatting() {
    return this._cl(8);
  }
  /**
   * Gets or sets the value which indicates whether the last column format should be applied to the appropriate column of the
   * [[WorksheetTable]].
   * <p class="body">
   * The last column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
   * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].LastColumn
   * value. If there is no area format applied for the LastColumn value, this property has no effect on the display of the table.
   * </p>
   * <p class="body">
   * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
   * will take precedence.
   * </p>
   * @see [[displayFirstColumnFormatting]]
   * @see [[style]]
   * @see [[WorksheetTableStyle.areaFormats]]
   * @see [[WorksheetTableStyleArea]]
   */
  set displayLastColumnFormatting(a) {
    WorksheetTable._bf[5].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the header row of the table.
   * A WorksheetRegion which represents the region of cells in the header row of the table or null if the header row is not visible.
   * @see [[isHeaderRowVisible]]
   * @see [[resize]]
   * @see [[resize]]
   */
  get headerRowRegion() {
    if (this.worksheet == null || this.isHeaderRowVisible == false) {
      return null;
    }
    return this._bn._cx(this._bw._ac, this._bw._w, this._bw._ac, this._bw._x);
  }
  /**
   * Gets or sets the value indicating whether to allow filtering and show filter buttons in the table headers.
   * <p class="body">
   * If [[isHeaderRowVisible]] is False, this property must be False and setting it to True will cause an error.
   * If [[isHeaderRowVisible]] is set to True, this property will also be set to True automatically.
   * </p>
   * @throws [[InvalidOperationException]] The value assigned is True and [[isHeaderRowVisible]] is False.
   * @see [[isHeaderRowVisible]]
   */
  get isFilterUIVisible() {
    return this._cl(32);
  }
  /**
   * Gets or sets the value indicating whether to allow filtering and show filter buttons in the table headers.
   * <p class="body">
   * If [[isHeaderRowVisible]] is False, this property must be False and setting it to True will cause an error.
   * If [[isHeaderRowVisible]] is set to True, this property will also be set to True automatically.
   * </p>
   * @throws [[InvalidOperationException]] The value assigned is True and [[isHeaderRowVisible]] is False.
   * @see [[isHeaderRowVisible]]
   */
  set isFilterUIVisible(a) {
    if (this.isFilterUIVisible == a) {
      return;
    }
    WorksheetTable._bf[6].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * @hidden
   */
  _e3(a) {
    if (a && this.isHeaderRowVisible == false) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ShowFilterUIWhileHeaderRowHidden"));
    }
    this._e2(32, a);
    if (a == false) {
      this.clearFilters();
    }
  }
  /**
   * Gets or sets the value which indicates whether the row containing column headers should be displayed.
   * <p class="body">
   * When the header row is visible, the cell above each column of data will contain the [[WorksheetTableColumn.name]]
   * value. Therefore, all header cells always contain a string value. Additionally, they will all be unique.
   * </p>
   * True if the row containing column headers is visible; False if it is hidden.
   * @see [[WorksheetTableColumn.name]]
   */
  get isHeaderRowVisible() {
    return this._cl(64);
  }
  /**
   * Gets or sets the value which indicates whether the row containing column headers should be displayed.
   * <p class="body">
   * When the header row is visible, the cell above each column of data will contain the [[WorksheetTableColumn.name]]
   * value. Therefore, all header cells always contain a string value. Additionally, they will all be unique.
   * </p>
   * True if the row containing column headers is visible; False if it is hidden.
   * @see [[WorksheetTableColumn.name]]
   */
  set isHeaderRowVisible(a) {
    if (this.isHeaderRowVisible == a) {
      return;
    }
    WorksheetTable._bf[7].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * @hidden
   */
  _e4(a) {
    try {
      this._cp = true;
      this._ei();
      this._e2(64, a);
      this._eh();
    }
    finally {
      this._cp = false;
    }
  }
  /**
   * Gets or sets the value which indicates whether the row containing column totals should be displayed.
   * <p class="body">
   * When the totals row is visible, the cell below each column of data will contain either a calculated value, a text value, or nothing.
   * To display a calculated value in the cell, set the [[WorksheetTableColumn.totalFormula]]. To display a text label, set the
   * [[WorksheetTableColumn.totalLabel]]. If both are set, the calculated value takes precedence.
   * </p>
   * True if the row containing column totals is visible; False if it is hidden.
   * @throws [[InvalidOperationException]] The value is set to True and the table occupies the last row of the worksheet.
   * @see [[WorksheetTableColumn.totalFormula]]
   * @see [[WorksheetTableColumn.totalLabel]]
   */
  get isTotalsRowVisible() {
    return this._cl(512);
  }
  /**
   * Gets or sets the value which indicates whether the row containing column totals should be displayed.
   * <p class="body">
   * When the totals row is visible, the cell below each column of data will contain either a calculated value, a text value, or nothing.
   * To display a calculated value in the cell, set the [[WorksheetTableColumn.totalFormula]]. To display a text label, set the
   * [[WorksheetTableColumn.totalLabel]]. If both are set, the calculated value takes precedence.
   * </p>
   * True if the row containing column totals is visible; False if it is hidden.
   * @throws [[InvalidOperationException]] The value is set to True and the table occupies the last row of the worksheet.
   * @see [[WorksheetTableColumn.totalFormula]]
   * @see [[WorksheetTableColumn.totalLabel]]
   */
  set isTotalsRowVisible(a) {
    if (this.isTotalsRowVisible == a) {
      return;
    }
    WorksheetTable._bf[8].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * @hidden
   */
  _e5(a, b = false) {
    {
      try {
        this._cp = true;
        if (a) {
          let c;
          let d = this._eo(c);
          c = d.p0;
          this._e2(512, a);
          this._ep(c && !b);
        }
        else {
          this._en();
          this._e2(512, a);
          this._em(b);
        }
      }
      finally {
        this._cp = false;
      }
    }
  }
  /**
   * @hidden
   */
  get _cx() {
    return this._cl(512);
  }
  /**
   * @hidden
   */
  set _cx(a) {
    if (this._cx == a) {
      return;
    }
    WorksheetTable._bf[15].h(WorksheetTable.$, Boolean_$type, this, a);
  }
  /**
   * Gets the settings which determine how the data within the table should be sorted.
   * <p class="note">
   * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
   * only when they are are added or removed on a column in the table or when the [[reapplySortConditions]] method is called.
   * </p>
   * @see [[reapplySortConditions]]
   * @see [[WorksheetTableColumn.sortCondition]]
   */
  get sortSettings() {
    if (this._bl == null) {
      this._bl = new SortSettings$1(WorksheetTableColumn.$, this, (a) => {
        if (a.table != this) {
          throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ColumnNotInTable"), "sortableItem");
        }
      });
    }
    return this._bl;
  }
  /**
   * Gets or sets the style to use on the [[WorksheetTable]].
   * <p class="body">
   * The [[WorksheetTableStyle]] defines formats to use in various areas of the table. These formats are used as defaults
   * for cells which don't have their formatting properties already set.
   * </p>
   * <p class="body">
   * The area formats specified in the WorksheetTableStyle are differential formats. In other words, only the properties that are set
   * to non-default values will be applied to the appropriate cells. An area format can define only a background color or only font
   * information and that format will be applied to the cells while all other formatting properties on the cells will be maintained.
   * </p>
   * <p class="body">
   * If this value is set to null, the Style will be set to the [[Workbook.defaultTableStyle]].
   * </p>
   * The [[WorksheetTableStyle]] instance which defines the various default table area formats.
   * @throws [[ArgumentException]] The value specified is not in the [[Workbook.customTableStyles]] or [[Workbook.standardTableStyles]]
   * collections.
   * @see [[Workbook.defaultTableStyle]]
   * @see [[Workbook.customTableStyles]]
   * @see [[Workbook.standardTableStyles]]
   */
  get style() {
    return this._cb;
  }
  /**
   * Gets or sets the style to use on the [[WorksheetTable]].
   * <p class="body">
   * The [[WorksheetTableStyle]] defines formats to use in various areas of the table. These formats are used as defaults
   * for cells which don't have their formatting properties already set.
   * </p>
   * <p class="body">
   * The area formats specified in the WorksheetTableStyle are differential formats. In other words, only the properties that are set
   * to non-default values will be applied to the appropriate cells. An area format can define only a background color or only font
   * information and that format will be applied to the cells while all other formatting properties on the cells will be maintained.
   * </p>
   * <p class="body">
   * If this value is set to null, the Style will be set to the [[Workbook.defaultTableStyle]].
   * </p>
   * The [[WorksheetTableStyle]] instance which defines the various default table area formats.
   * @throws [[ArgumentException]] The value specified is not in the [[Workbook.customTableStyles]] or [[Workbook.standardTableStyles]]
   * collections.
   * @see [[Workbook.defaultTableStyle]]
   * @see [[Workbook.customTableStyles]]
   * @see [[Workbook.standardTableStyles]]
   */
  set style(a) {
    let b = this._k;
    if (a == null) {
      if (b == null) {
        a = StandardTableStyleCollection._c._d;
      }
      else {
        a = b.defaultTableStyle;
      }
    }
    if (this._cb == a) {
      return;
    }
    if (a.isCustom) {
      if (a._h == null || (b != null && a._h._e != b)) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_TableStyleFromOtherWorkbook"), "value");
      }
    }
    let c = WorksheetTable._bf[10].g(WorksheetTable.$, WorksheetTableStyle.$, this, this._cb, a);
    this._cb = c.p1;
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the totals row of the table.
   * A WorksheetRegion which represents the region of cells in the totals row of the table or null if the totals row is not visible.
   * @see [[isTotalsRowVisible]]
   * @see [[resize]]
   * @see [[resize]]
   */
  get totalsRowRegion() {
    if (this.worksheet == null || this.isTotalsRowVisible == false) {
      return null;
    }
    return this._bn._cx(this._bw._ae, this._bw._w, this._bw._ae, this._bw._x);
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the whole table, including the header and totals rows,
   * if visible.
   * <p class="body">
   * The table region can be changed by using one of the Resize overloads.
   * </p>
   * @see [[resize]]
   * @see [[resize]]
   */
  get wholeTableRegion() {
    if (this._bn == null) {
      return null;
    }
    return this._bn._cw(this._bw);
  }
  /**
   * Gets the [[worksheet]] to which the table belongs.
   * The Worksheet to which the table belongs or null if the table has been removed from the Worksheet.
   * @see [[Worksheet.tables]]
   */
  get worksheet() {
    return this._bn;
  }
  /**
   * @hidden
   */
  get _bq() {
    if (this._bn == null) {
      return null;
    }
    let a = this._bw._ae;
    if (this.isTotalsRowVisible) {
      a--;
    }
    return this._bn._cx(this._bw._ac, this._bw._w, a, this._bw._x);
  }
  /**
   * @hidden
   */
  get _cm() {
    return this._cl(16);
  }
  /**
   * @hidden
   */
  set _cm(a) {
    this._e2(16, a);
  }
  /**
   * @hidden
   */
  get _bz() {
    if (this.worksheet == null || this.isHeaderRowVisible == false) {
      return null;
    }
    return this._bn._rows$i.item(this._bw._ac);
  }
  /**
   * @hidden
   */
  get _ds() {
    return this._dq;
  }
  /**
   * @hidden
   */
  get _cp() {
    return this._cl(32768);
  }
  /**
   * @hidden
   */
  set _cp(a) {
    this._e2(32768, a);
  }
  /**
   * @hidden
   */
  get _cs() {
    return this._cl(128);
  }
  /**
   * @hidden
   */
  set _cs(a) {
    this._e2(128, a);
    if (a == false) {
      this._c5 = false;
    }
  }
  /**
   * @hidden
   */
  get _cu() {
    return this._cl(65536);
  }
  /**
   * @hidden
   */
  set _cu(a) {
    this._e2(65536, a);
  }
  /**
   * @hidden
   */
  get _cv() {
    return this._cl(256);
  }
  /**
   * @hidden
   */
  set _cv(a) {
    this._e2(256, a);
  }
  /**
   * @hidden
   */
  get _dt() {
    return this._dr;
  }
  /**
   * @hidden
   */
  set _dt(a) {
    this._dr = a;
  }
  /**
   * @hidden
   */
  get _c0() {
    return this._cl(2048);
  }
  /**
   * @hidden
   */
  set _c0(a) {
    this._e2(2048, a);
  }
  /**
   * @hidden
   */
  get _bs() {
    if (this._bn == null) {
      return null;
    }
    let a = this._bw._ae;
    if (this.isTotalsRowVisible) {
      a--;
    }
    while (a != this._bw._ac && this._bn._eg(a)) {
      a--;
    }
    return this._bn._cx(this._bw._ac, this._bw._w, a, this._bw._x);
  }
  /**
   * @hidden
   */
  get _b0() {
    if (this.worksheet == null || this.isTotalsRowVisible == false) {
      return null;
    }
    return this._bn._rows$i.item(this._bw._ae);
  }
  /**
   * @hidden
   */
  get _c5() {
    return this._cl(16384);
  }
  /**
   * @hidden
   */
  set _c5(a) {
    this._e2(16384, a);
  }
  /**
   * @hidden
   */
  get _by() {
    return this._bw;
  }
  /**
   * @hidden
   */
  get _cz() {
    return this._cl(1024);
  }
  /**
   * @hidden
   */
  set _cz(a) {
    this._e2(1024, a);
  }
  /**
   * @hidden
   */
  get _c1() {
    return this._cl(4096);
  }
  /**
   * @hidden
   */
  set _c1(a) {
    this._e2(4096, a);
  }
  /**
   * @hidden
   */
  get _c3() {
    return this._cl(8192);
  }
  /**
   * @hidden
   */
  set _c3(a) {
    this._e2(8192, a);
  }
}
WorksheetTable.$t = markType(WorksheetTable, 'WorksheetTable', NamedReferenceBase.$, [IAreaFormatsOwner$1_$type.specialize(WorksheetTableArea_$type), IChangeInfoContext_$type, ISortSettingsOwner_$type]);
/**
 * @hidden
 */
WorksheetTable._c9 = 2;
/**
 * @hidden
 */
WorksheetTable._da = 2 + 1;
/**
 * @hidden
 */
WorksheetTable._db = 2 + 2;
/**
 * @hidden
 */
WorksheetTable._dc = 2 + 3;
/**
 * @hidden
 */
WorksheetTable._dd = 2 + 4;
/**
 * @hidden
 */
WorksheetTable._de = 2 + 5;
/**
 * @hidden
 */
WorksheetTable._df = 2 + 6;
/**
 * @hidden
 */
WorksheetTable._di = 2 + 7;
/**
 * @hidden
 */
WorksheetTable._dj = 2 + 8;
/**
 * @hidden
 */
WorksheetTable._dk = 2 + 9;
/**
 * @hidden
 */
WorksheetTable._dl = 2 + 10;
/**
 * @hidden
 */
WorksheetTable._dm = 2 + 11;
/**
 * @hidden
 */
WorksheetTable._dn = 2 + 12;
/**
 * @hidden
 */
WorksheetTable._dg = 2 + 13;
/**
 * @hidden
 */
WorksheetTable._c8 = 2 + 14;
/**
 * @hidden
 */
WorksheetTable._dh = 2 + 15;
/**
 * @hidden
 */
WorksheetTable._bf = null;
/**
 * @hidden
 */
export class WorksheetTableResizeOperation extends Base {
  constructor(a, b) {
    super();
    this.a = new WorksheetRegionAddress();
    this.b = new WorksheetRegionAddress();
    this.c = new WorksheetRegionAddress();
    this.d = new WorksheetRegionAddress();
    let c;
    let d;
    let e = a._d7(b, c, d);
    c = e.p1;
    d = e.p2;
    this.a = new WorksheetRegionAddress(1, c, d, b._w, b._x);
    this.b = b;
    this.c = a.dataAreaRegion._h;
    this.d = a._by;
  }
}
WorksheetTableResizeOperation.$t = markType(WorksheetTableResizeOperation, 'WorksheetTableResizeOperation');
/**
 * A collection of formats for areas of a [[WorksheetTable]].
 * @typedef TArea An enumeration defining the various table areas which can contain formats.
 * @see [[WorksheetTable.areaFormats]]
 * @see [[WorksheetTableColumn.areaFormats]]
 * @see [[WorksheetTableStyle.areaFormats]]
 */
export class WorksheetTableAreaFormatsCollection$1 extends Base {
  constructor($tArea, a) {
    super();
    this.$tArea = null;
    this._h = null;
    this._a = null;
    this.$tArea = $tArea;
    this.$type = this.$type.specialize(this.$tArea);
    this._h = new Dictionary$2(this.$tArea, WorksheetTableAreaFormatProxy$1.$.specialize(this.$tArea), 0);
    this._a = a;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    for (let a of fromEnum(this._h)) {
      if (a.value._z == false) {
        yield new KeyValuePair$2(this.$tArea, IWorksheetCellFormat_$type, 1, a.key, a.value);
      }
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Determines whether the area has a non-default format applied.
   * @param area The area of which to test the format.
   * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
   * @return True if the area has a non-default format applied; False otherwise.
   */
  hasFormat(area) {
    return this._hasFormat$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _hasFormat$i(a) {
    ExcelUtils.gl(this.$tArea, a);
    let b;
    if (((() => { let c = this._h.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b._z == false;
    }
    return false;
  }
  /**
   * @hidden
   */
  _d(a, b) {
    return this._e(a, b, true);
  }
  /**
   * @hidden
   */
  _e(a, b, c) {
    let d;
    if (((() => { let e = this._h.tryGetValue(b, d); d = e.p1; return e.ret; })()) == false && c) {
      let e;
      if (a == null) {
        e = new WorksheetCellFormatData(null, 2);
      }
      else {
        e = a._cd(2);
      }
      d = new WorksheetTableAreaFormatProxy$1(this.$tArea, b, e, this._a);
      if (this._a.isReadOnly) {
        d.d._dk();
      }
      this._h.item(b, d);
      d.d.ab(this._a);
      this._a._onAreaFormatAdded$i(b, d.d);
    }
    return d;
  }
  /**
   * @hidden
   */
  _i() {
    return this._h.values;
  }
  /**
   * @hidden
   */
  _k(a) {
    for (let b of fromEnum(this._h.values)) {
      b.d.ae(a, false);
    }
  }
  /**
   * @hidden
   */
  _l() {
    for (let a of fromEnum(this._h.values)) {
      a.d.ac();
    }
  }
  /**
   * @hidden
   */
  _c(a) {
    let b = this._f(a);
    if (b == null) {
      return null;
    }
    return b.d;
  }
  /**
   * @hidden
   */
  _f(a) {
    return this._e(null, a, false);
  }
  /**
   * Gets the number of area formats in the collection.
   */
  get count() {
    return this._h.count;
  }
  /**
   * Gets the format for the specified area.
   * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
   * @param area The area for which to get the format.
   * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
   */
  item(a) {
    ExcelUtils.gl(this.$tArea, a);
    return this._d(this._a.workbook, a);
  }
}
WorksheetTableAreaFormatsCollection$1.$t = markType(WorksheetTableAreaFormatsCollection$1, 'WorksheetTableAreaFormatsCollection$1', Base.$, [IEnumerable$1_$type.specialize(KeyValuePair$2.$.specialize(0, IWorksheetCellFormat_$type))]);
/**
 * @hidden
 */
export class WorksheetTableAreaFormatProxy$1 extends WorksheetCellFormatProxy {
  constructor($tArea, a, b, c) {
    super(0, b, null, c);
    this.$tArea = null;
    this._bs = null;
    this.$tArea = $tArea;
    this.$type = this.$type.specialize(this.$tArea);
    this._bs = a;
  }
  get__l() {
    return this.$type.getStaticFields()._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 85;
  }
  get _q() {
    return this.get__q();
  }
  get__v() {
    let a = typeCast(WorksheetTable.$, this._s);
    if (a != null) {
      return a.worksheet;
    }
    let b = typeCast(WorksheetTableColumn.$, this._s);
    if (b != null) {
      return b._worksheet;
    }
    return null;
  }
  get _v() {
    return this.get__v();
  }
  get _bt() {
    return this._bs;
  }
}
WorksheetTableAreaFormatProxy$1.$t = markType(WorksheetTableAreaFormatProxy$1, 'WorksheetTableAreaFormatProxy$1', WorksheetCellFormatProxy.$, null, function () {
  this._br = WorksheetCellFormatProxy._m(85, 8 | 4);
});
/**
 * @hidden
 */
export class WorksheetTableCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.b = null;
    this.a = null;
    this.c = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.b = c;
          this.a = d;
          this.d = e;
          this.c = f;
        }
        break;
    }
  }
  get workbook() {
    return this.b._d.workbook;
  }
  get sheet() {
    return this.b._d;
  }
  get source() {
    return this.b._d;
  }
}
WorksheetTableCollection_CollectionChangeContext.$t = markStruct(WorksheetTableCollection_CollectionChangeContext, 'WorksheetTableCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * The collection of [[WorksheetTable]] instances on a [[Worksheet]].
 * @see [[Worksheet.tables]]
 */
export class WorksheetTableCollection extends Base {
  constructor(a) {
    super();
    this._n = null;
    this._m = null;
    /**
     * @hidden
     */
    this._d = null;
    this._n = new List$1(WorksheetTable.$, 0);
    this._m = new Dictionary$2(Number_$type, WorksheetTable.$, 0);
    this._d = a;
  }
  static staticInit() {
    WorksheetTableCollection._a = WorksheetTableCollection._b();
  }
  /**
   * @hidden
   */
  insert(index, item) {
    this._x();
  }
  item() {
    if (arguments.length === 2) {
      return this._item$e.apply(this, arguments);
    }
    else {
      let n;
      if (arguments.length === 1) {
        if (typeof arguments[0] === 'number') {
          n = 0;
        }
        else if (typeof arguments[0] === 'string') {
          n = 1;
        }
        else if (arguments[0] == null) {
          n = 1;
        }
      }
      switch (n) {
        case 0: return this._item.apply(this, arguments);
        case 1: return this._item1.apply(this, arguments);
        default: throw new Error('Invalid arguments');
      }
    }
  }
  /**
   * @hidden
   */
  _item$e(a, b) {
    if (arguments.length === 2) {
      this._x();
      return b;
    }
    else {
      return this._item(a);
    }
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    this._x();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._n.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._n.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _add2(a, b, c = null) {
    return this._add1(this._d._getRegion(a), b, c);
  }
  /**
   * @hidden
   */
  _add1(a, b, c, d = null, e = false) {
    let f = this._d.workbook;
    if (f == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotAddTableToRemovedWorksheet"));
    }
    if (c == null) {
      c = f.defaultTableStyle;
    }
    else if (c.isCustom && f._customTableStyles$i.contains(c) == false) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_TableStyleFromOtherWorkbook"));
    }
    let g = null;
    while (true) {
      let h = false;
      for (let i of fromEnum(this._d._mergedCellsRegions$i)) {
        if (i._s(a)) {
          if (g == null) {
            g = new List$1(WorksheetMergedCellsRegion.$, 0);
          }
          if (g.contains(i) == false) {
            if (a._o(i) == false) {
              h = true;
            }
            g.add(i);
            a = WorksheetRegion._g(a, i);
          }
        }
      }
      if (h == false) {
        break;
      }
    }
    for (let j of fromEnum(this._d._rows$i._m(a.firstRow, a.lastRow))) {
      for (let k = a._v; k <= a._w; k++) {
        if (j._bp(k) != null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_OverlappingTable"));
        }
        let l = typeCast(IRegionBlockingSingleCellComponent_$type, j._c5(k));
        if (l != null) {
          l.owningValue.throwBlockingException();
        }
      }
    }
    if (g != null) {
      for (let m = 0; m < g.count; m++) {
        this._d._mergedCellsRegions$i.remove_1(g._inner[m]);
      }
    }
    let n;
    let o = ExcelUtils.ef("GenerateTableName");
    let p = 1;
    while (true) {
      n = o + p++;
      if (f._a3(n) == null) {
        break;
      }
    }
    let q = false;
    let r = false;
    let s = a.firstRow;
    let t = a.lastRow;
    let u = a._v;
    let v = a._w;
    a = null;
    if (b == false) {
      let w = ExcelUtils.ef("TableHeaderRowDescription");
      if (t == f.maxRowCount - 1) {
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_TableOnBottomOfWorksheet", w));
      }
      let x = new WorksheetCellShiftResult();
      if (this._d._dp(t + 1, u, v)) {
        x = this._d._b7(s, u, v, 1);
      }
      else {
        x = this._d._b9(s, t, u, v, 1, 1);
      }
      WorksheetTable._es(x.a, w);
      t++;
      b = true;
    }
    else if (s == t) {
      let y = ExcelUtils.ef("TableInsertRowDescription");
      if (t == f.maxRowCount - 1) {
        throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_CannotInsertTableRow_TableOnBottomOfWorksheet", y));
      }
      if (this._d._dp(t + 1, u, v)) {
        let z = this._d._b7(t + 1, u, v, 2);
        WorksheetTable._es(z.a, y);
        r = true;
      }
      t++;
      q = true;
    }
    let aa = new WorksheetTable(n, f._g4(), s, t, u, v);
    let ab = this.count;
    let ac = v - u + 1;
    for (let ad = 0; ad < ac; ad++) {
      aa._b4();
    }
    this._s(this.count, aa, c, b, q, r, false, d, e);
    return aa;
  }
  /**
   * @hidden
   */
  _s(a, b, c, d, e, f, g, h = null, i = false) {
    let j = WorksheetTableCollection._a[0];
    let k = new WorksheetTableCollection_CollectionChangeContext(1, this, b, a, g);
    let l = j.b(this._d.workbook, this._d, j.c);
    b.style = c;
    b.isHeaderRowVisible = d;
    b._cs = e;
    b._c5 = f;
    this._u(a, b);
    if (!b._cu) {
      b._d9();
      b._ea();
    }
    if (h != null) {
      b._ec(h, i);
    }
    j.e(WorksheetTableCollection_CollectionChangeContext.$, WorksheetTable.$, k, null, b);
    if (l != null) {
      j.d(this._d.workbook, l);
    }
  }
  /**
   * Clears the collection and removes all tables from the worksheet.
   */
  clear() {
    let a = this._n.count > 1 ? this._r(25) : null;
    for (let b = this._n.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._v(a);
  }
  /**
   * Determines whether the specified [[WorksheetTable]] is in the collection.
   * @param table The WorksheetTable to find in the collection.
   * @return True if the WorksheetTable is in the collection; False otherwise.
   */
  contains(table) {
    return this._n.contains(table);
  }
  /**
   * Determines whether a [[WorksheetTable]] with the specified name is in the collection.
   * <p class="body">
   * Table names are compared case-insensitively.
   * </p>
   * @param name The name of the WorksheetTable to find.
   * @return True if a WorksheetTable with the specified name is in the collection; False otherwise.
   */
  exists(name) {
    if (stringIsNullOrEmpty(name)) {
      return false;
    }
    let a = this._d._y;
    for (let b of fromEnum(this._n)) {
      if (StringUtilities.c(b.name, name, a, 1) == 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the index of the specified [[WorksheetTable]] in the collection.
   * @param table The WorksheetTable to find in the collection.
   * @return The 0-based index of the specified WorksheetTable in the collection or -1 if the item is not in the collection.
   */
  indexOf(table) {
    return this._n.indexOf(table);
  }
  /**
   * Removes the [[WorksheetTable]] from the collection.
   * @param table The WorksheetTable to remove from the collection.
   * @param convertToRange True to apply the table style formatting to the cells
   * @return True if the WorksheetTable was found and removed; False otherwise.
   */
  remove_1(table, convertToRange = true) {
    let a = this._n.indexOf(table);
    if (a < 0) {
      return false;
    }
    this.removeAt(a, convertToRange);
    return true;
  }
  /**
   * Removes the [[WorksheetTable]] at the specified index.
   * @param index The 0-based index of the WorksheetTable to remove.
   * @param convertToRange True to apply the table style formatting to the cells
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   */
  removeAt(index, convertToRange = true) {
    let a = this._n._inner[index];
    let b = WorksheetTableCollection._a[1];
    let c = new WorksheetTableCollection_CollectionChangeContext(1, this, a, index, convertToRange);
    let d = b.b(this._d.workbook, this._d, b.c);
    this._n.removeAt(index);
    this._m.removeItem(a._ds);
    a._ek(convertToRange);
    b.e(WorksheetTableCollection_CollectionChangeContext.$, WorksheetTable.$, c, a, null);
    if (d != null) {
      b.d(this._d.workbook, d);
    }
  }
  /**
   * @hidden
   */
  _g(a) {
    let b;
    let c = this._m.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * @hidden
   */
  _t(a) {
    this._u(this.count, a);
  }
  /**
   * @hidden
   */
  _u(a, b) {
    let c = this._d.workbook;
    if (c != null) {
      c._jc(b.name, b);
      c._g6 = Math.max(c._g6, b._ds + 1);
    }
    this._n.insert(a, b);
    this._m.item(b._ds, b);
    b._el(this._d);
  }
  /**
   * @hidden
   */
  _k(a, b) {
    for (let c of fromEnum(this)) {
      if (c._by._i(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetTableCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, WorksheetTableCollection._c(WorksheetTable.$, "Add", 73, (b) => b.a, (b, c) => WorksheetTableCollection._y(b, c)));
    ChangeInfo.f(a, 1, WorksheetTableCollection._c(WorksheetTable.$, "Remove", 84, (b) => b.a, (b, c) => WorksheetTableCollection._z(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _r(a) {
    let b = this._d.workbook;
    return b != null && b._cx ? b._go(this._d, a, null) : null;
  }
  /**
   * @hidden
   */
  _v(a) {
    if (a != null) {
      let b = this._d.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _x() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotAddTableDirectly"));
  }
  /**
   * @hidden
   */
  static _y(a, b) {
    let c = a.b.indexOf(a.a);
    if (c >= 0) {
      a.a._cu = true;
      a.b.removeAt(c, a.c);
      a.a._cu = false;
    }
  }
  /**
   * @hidden
   */
  static _z(a, b) {
    let c = a.a;
    c._cu = true;
    a.b._s(a.d, c, c.style, c.isHeaderRowVisible, c._cs, c._c5, a.c);
    c._cu = false;
  }
  /**
   * Gets the number of tables in the collection.
   * The number of tables in the collection.
   */
  get count() {
    return this._n.count;
  }
  /**
   * @hidden
   */
  _item(a) {
    if (a < 0 || this.count <= a) {
      throw new ArgumentOutOfRangeException(2, "index", ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._n._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    let b = this._d._y;
    for (let c of fromEnum(this._n)) {
      if (StringUtilities.c(c.name, a, b, 1) == 0) {
        return c;
      }
    }
    throw new InvalidOperationException(1, ExcelUtils.ef("LER_Exception_KeyNotFound"));
  }
}
WorksheetTableCollection.$t = markType(WorksheetTableCollection, 'WorksheetTableCollection', Base.$, [IList$1_$type.specialize(WorksheetTable.$)]);
/**
 * @hidden
 */
WorksheetTableCollection._o = 0;
/**
 * @hidden
 */
WorksheetTableCollection._q = 1;
/**
 * @hidden
 */
WorksheetTableCollection._p = 2;
/**
 * @hidden
 */
WorksheetTableCollection._a = null;
/**
 * @hidden
 */
export let IFilterable_$type = new Type(null, 'IFilterable', null, [IWorkbookProvider_$type, IWorksheetProvider_$type]);
/**
 * Abstract base class for all filters which filters cells in a worksheet.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[CustomFilter]]
 * @see [[FixedValuesFilter]]
 * @see [[TopOrBottomFilter]]
 * @see [[DynamicValuesFilter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 * @see [[FontColorFilter]]
 * @see [[FillFilter]]
 */
export class Filter extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  /**
   * @hidden
   */
  static _c(a, b) {
    if (a == null) {
      return new GetCellTextResult(1, "");
    }
    let c = new GetCellTextParameters(b);
    c.b = 1;
    c.a = 0;
    c.g = Nullable$1.toNullable(Boolean_$type, true);
    return a._av(c);
  }
  /**
   * @hidden
   */
  _f(a, b, c, d) {
    return true;
  }
  /**
   * @hidden
   */
  _i() {
    if (this._a != null) {
      this._a.onFilterModified();
    }
  }
  /**
   * @hidden
   */
  _j(a) {
    this._a = a;
  }
  /**
   * @hidden
   */
  _g(a, b) {
    a = true;
    b = null;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  get _h() {
    if (this._a == null || this._a.worksheet == null) {
      return ExcelUtils.cq;
    }
    return this._a.worksheet._y;
  }
  /**
   * @hidden
   */
  get _b() {
    return this._a;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._a != null ? this._a.workbook : null;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._a != null ? this._a.worksheet : null;
  }
  /**
   * @hidden
   */
  get source() {
    return this._a;
  }
}
Filter.$t = markType(Filter, 'Filter', Base.$, [IChangeInfoContext_$type]);
/**
 * Represents a column in a [[WorksheetTable]].
 * <p class="body">
 * Each column contains various settings for controlling the contents, formatting, sorting, and filtering within it.
 * </p>
 */
export class WorksheetTableColumn extends Base {
  constructor(a, b, c) {
    super();
    this._as = 0;
    this._am = null;
    this._au = -1;
    this._w = null;
    this._i = null;
    this._a8 = 0;
    this._a2 = null;
    this._ak = null;
    this._x = null;
    this._a3 = null;
    this._ao = 0;
    this._as = c;
    this._a8 = b;
    this._ak = a;
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  _onAreaFormatAdded$i(area, format) {
    switch (area) {
      case 0: break;
      case 1:
        let a = this.headerCell;
        if (WorksheetCell.l_op_Inequality(a, null)) {
          let b = a._o._a8(a._ab);
          if (b != null) {
            b = b._bu();
            b._ds(67108864);
            b._ds(134217728);
            format.setFormatting(b);
          }
        }
        break;
      case 2:
        let c = this.totalCell;
        if (WorksheetCell.l_op_Inequality(c, null)) {
          let d = c._o._a8(c._ab);
          if (d != null) {
            d = d._bu();
            d._ds(2);
            d._ds(4);
            format.setFormatting(d);
          }
        }
        break;
      default: break;
    }
  }
  /**
   * @hidden
   */
  verifyCanBeModified() {
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._worksheet;
  }
  /**
   * @hidden
   */
  get columnIndex() {
    return this._at;
  }
  /**
   * @hidden
   */
  get worksheet() {
    return this.table != null ? this.table.worksheet : null;
  }
  /**
   * @hidden
   */
  getDataAreaRowIndexes(dataAreaTopRowIndex, dataAreaBottomRowIndex) {
    let a = this.table._d8(dataAreaTopRowIndex, dataAreaBottomRowIndex);
    dataAreaTopRowIndex = a.p0;
    dataAreaBottomRowIndex = a.p1;
    return {
      p0: dataAreaTopRowIndex,
      p1: dataAreaBottomRowIndex
    };
  }
  /**
   * @hidden
   */
  onFilterModified() {
    this._onFilterModified();
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._workbook;
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return null;
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
    let a = sender;
    this._b5(a, values, a._bt == 0);
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
    let a = sender;
    for (let b = 1; b != 1073741824; b = (b << 1)) {
      if ((values & b) == 0) {
        continue;
      }
      WorksheetTableColumn._b8(a._bt, b);
    }
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
  }
  /**
   * Applies an [[AverageFilter]] to the column.
   * @param type The value indicating whether to filter in values below or above the average of the data range.
   * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[AverageFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyAverageFilter(type) {
    let a = new AverageFilter(0, this, type);
    this.filter = a;
    return a;
  }
  applyCustomFilter() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._applyCustomFilter.apply(this, arguments);
      case 1: return this._applyCustomFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyCustomFilter(a) {
    return this._applyCustomFilter1(a, null, 0);
  }
  /**
   * @hidden
   */
  _applyCustomFilter1(a, b, c) {
    let d = new CustomFilter(1, this, a, b, c);
    this.filter = d;
    return d;
  }
  /**
   * Applies an [[DatePeriodFilter]] to the column.
   * <p class="body">
   * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
   * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
   * </p>
   * @param type The type of date period to filter in.
   * @param value The 1-based value of the month or quarter to filter in.
   * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
   * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
   * type is Month and value is less than 1 or greater than 12.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[DatePeriodFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyDatePeriodFilter(type, value) {
    let a = new DatePeriodFilter(this, type, value);
    this.filter = a;
    return a;
  }
  /**
   * Applies a [[FillFilter]] to the column.
   * @param fill A [[CellFill]] by which the cells should be filtered.
   * @throws [[ArgumentNullException]] 'fill' is null.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[FillFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyFillFilter(fill) {
    let a = new FillFilter(this, fill);
    this.filter = a;
    return a;
  }
  /**
   * @hidden
   */
  _j(a, ...b) {
    return this._m(a, b);
  }
  /**
   * @hidden
   */
  _m(a, b) {
    if (b == null) {
      throw new ArgumentNullException(0, "displayValues");
    }
    let c = new FixedValuesFilter(this);
    c.includeBlanks = a;
    for (let d of fromEnum(b)) {
      c._displayValues$i.add(d);
    }
    if (c._w) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this.filter = c;
    return c;
  }
  /**
   * @hidden
   */
  _n(a, b) {
    return this._l(a, 0, b);
  }
  /**
   * Applies a [[FixedValuesFilter]] to the column.
   * @param includeBlanks The value which indicates whether blank cells should be filtered in.
   * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
   * @param dateGroups The collection of fixed date groups which should be filtered in.
   * @throws [[ArgumentNullException]] 'dateGroups' is null.
   * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
   * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
   * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
   * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @see [[FixedValuesFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyFixedValuesFilter(includeBlanks, calendarType, ...dateGroups) {
    return this._applyFixedValuesFilter1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _applyFixedValuesFilter1(a, b, ...c) {
    return this._l(a, b, c);
  }
  /**
   * @hidden
   */
  _l(a, b, c) {
    if (c == null) {
      throw new ArgumentNullException(0, "dateGroups");
    }
    let d = new FixedValuesFilter(this);
    d.calendarType = b;
    d.includeBlanks = a;
    for (let e of fromEnum(c)) {
      d._dateGroups$i.add(e);
    }
    if (d._w) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this.filter = d;
    return d;
  }
  applyFontColorFilter() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'string' || typeCast(Color.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._applyFontColorFilter.apply(this, arguments);
      case 1:
        arguments[0] = Color.create(arguments[0]);
        return this._applyFontColorFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyFontColorFilter1(a) {
    return this._applyFontColorFilter(ExcelUtils.ag(a));
  }
  /**
   * @hidden
   */
  _applyFontColorFilter(a) {
    let b = new FontColorFilter(this, a);
    this.filter = b;
    return b;
  }
  /**
   * Applies a [[IconFilter]] to the column.
   * @param iconSet The icon set containing the icon.
   * @throws [[ArgumentException]] If the icon set is not valid.
   * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
   * @throws [[ArgumentOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
   * @see [[IconFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   * @see [[ConditionalFormatCollection.addIconSetCondition]]
   */
  applyIconFilter(iconSet, iconIndex) {
    arguments[1] = wrapNullable(Number_$type, arguments[1]);
    return this._applyIconFilter$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _applyIconFilter$i(a, b) {
    ExcelUtils.gl(FormatConditionIconSet_$type, a);
    if (nullableNotEquals(b, null)) {
      let c = IconSetConditionalFormat._b9(a);
      if (b.value < 0 || b.value >= c.length) {
        throw new ArgumentOutOfRangeException(1, "iconIndex");
      }
    }
    return this._r(ExcelUtils.aj(a), nullableNotEquals(b, null) ? Nullable$1.toNullable(Number_$type, b.value) : Nullable$1.toNullable(Number_$type, null));
  }
  /**
   * @hidden
   */
  _r(a, b) {
    let c = new IconFilter(this, a, b);
    this.filter = c;
    return c;
  }
  /**
   * Applies a [[RelativeDateRangeFilter]] to the column.
   * <p class="body">
   * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
   * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
   * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
   * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
   * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
   * dates in 1999, even if the workbook is opened in 2012.
   * </p>
   * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
   * @param duration The duration of the full range of accepted dates.
   * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
   * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[RelativeDateRangeFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyRelativeDateRangeFilter(offset, duration) {
    let a = new RelativeDateRangeFilter(0, this, offset, duration);
    this.filter = a;
    return a;
  }
  applyTopOrBottomFilter() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._applyTopOrBottomFilter.apply(this, arguments);
      case 1: return this._applyTopOrBottomFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyTopOrBottomFilter() {
    return this._applyTopOrBottomFilter1(0, 10);
  }
  /**
   * @hidden
   */
  _applyTopOrBottomFilter1(a, b) {
    let c = new TopOrBottomFilter(1, this, a, b);
    this.filter = c;
    return c;
  }
  /**
   * Applies a [[YearToDateFilter]] to the column.
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[YearToDateFilter]]
   * @see [[filter]]
   * @see [[clearFilter]]
   */
  applyYearToDateFilter() {
    let a = new YearToDateFilter(0, this);
    this.filter = a;
    return a;
  }
  /**
   * Removes the filter from the column if one is applied.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @see [[applyAverageFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyDatePeriodFilter]]
   * @see [[applyFillFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyRelativeDateRangeFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyYearToDateFilter]]
   * @see [[filter]]
   */
  clearFilter() {
    this.filter = null;
  }
  /**
   * Sets the formula to use in the data cells in the column.
   * <p class="body">
   * If any relative cell or region references are in the specified formula, it will be assumed that the actual formula is being applied to
   * the first data cell in the column. When the formula is applied to other cells in the column, the relative references will be offset by
   * the appropriate amount.
   * </p>
   * <p class="body">
   * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
   * applied to them.
   * </p>
   * <p class="body">
   * If there was a different column formula applied previously and it was applied to any of the cells in the column, setting it to a
   * different formula will overwrite the formulas on those cells, regardless of the value of 'overwriteExistingValues'.
   * </p>
   * @param formula The formula for the data cells of the column or null to remove the current column formula.
   * @param overwriteExistingValues True to overwrite the existing cells values and apply the formula to all data cells in the column.
   * False to only apply the formula to the cells with no value set.
   * @throws [[ArgumentException]] @throws [[InvalidOperationException]] If column was removed from the table.
   * 'formula' is already applied to something else, such as a cell or table column.
   * @see [[columnFormula]]
   */
  setColumnFormula(formula, overwriteExistingValues) {
    return this._setColumnFormula1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setColumnFormula1(a, b) {
    this._b9();
    this._by(4, b);
    this._bu(a);
    this._by(4, false);
  }
  /**
   * @hidden
   */
  _bu(a) {
    if (a != null && a._ab != null) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_ColumnFormulaAlreadyAppliedToCell"));
    }
    WorksheetTableColumn._a[0].h(WorksheetTableColumn.$, Formula.$, this, a);
  }
  /**
   * @hidden
   */
  _bw(a) {
    let b = this._aq(4);
    if (this._w == a) {
      return;
    }
    this._bb();
    let c = null;
    let d = -1;
    let e = this.dataAreaRegion;
    if (e != null) {
      let f = e.worksheet;
      if (f == null) {
        return;
      }
      c = e._k;
      d = e._v;
      let g = a == null ? null : a._x(c.index, d, c.worksheet._o);
      let h = e._aa > 48;
      let i = e.firstRow;
      let j = e.firstRow;
      for (let k = j; k <= e.lastRow; k++) {
        let l = f._rows$i.item(k);
        if (b == false && ExcelUtils.a9(l._c6(d)) == false) {
          continue;
        }
        if (g == null) {
          l._d6(d, null);
        }
        else {
          if (h && (k - i) >= 32) {
            f._h2(g, f._cx(i, this._as, k - 1, this._as));
            g = new SingleTargetFormula(3, g, true);
            i = k;
          }
          g._bq(c, d, l, d);
        }
      }
      if (g != null) {
        f._h2(g, f._cx(i, this._as, e.lastRow, this._as));
      }
    }
    this._w = a;
  }
  /**
   * @hidden
   */
  _ba(a, b, c) {
    if (this._w != null) {
      let d = this._worksheet;
      for (let e = 0; e < c; e++) {
        let f = b + e;
        let g = d._rows$i.item(f);
        if (g._getCellValue1(this._at) == null) {
          this._w._bq(d._rows$i.item(a), this._at, g, this._at);
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _ap(a, b) {
    let c;
    return ((() => { let d = WorksheetTableColumn._ar(a, b, c); c = d.p2; return d.ret; })());
  }
  /**
   * @hidden
   */
  _ah(a) {
    if (a == null) {
      return null;
    }
    if (a.worksheet == null) {
      return null;
    }
    let b = (a._v + this.index);
    return a.worksheet._cx(a.firstRow, b, a.lastRow, b);
  }
  /**
   * @hidden
   */
  _bd() {
    this._by(1, true);
    let a;
    if (this.table.isHeaderRowVisible) {
      a = this._areaFormats$i.item(1);
    }
    if (this.table.isTotalsRowVisible) {
      a = this._areaFormats$i.item(2);
    }
    let b = this.dataAreaRegion;
    if (b == null || b.worksheet == null) {
      return;
    }
    let c = new Dictionary$2(WorksheetCellFormatData.$, Number_$type, 0);
    let d = null;
    let e = b.worksheet._rows$i._aj(b.firstRow);
    if (e != null) {
      d = e._a8(b._v);
      if (d != null) {
        c.addItem(d, 1);
      }
    }
    for (let f = b.firstRow + 1; f <= b.lastRow; f++) {
      e = b.worksheet._rows$i._aj(f);
      if (e == null) {
        d = null;
        continue;
      }
      let g = e._a8(b._v);
      if (g == null) {
        d = null;
        continue;
      }
      if (d != null && d.equals(g) == false) {
        d = null;
      }
      let h;
      if (((() => { let i = c.tryGetValue(g, h); h = i.p1; return i.ret; })()) == false) {
        c.addItem(g, 1);
      }
      else {
        c.item(g, h + 1);
      }
    }
    if (this.table.isTotalsRowVisible == false) {
      let i;
      if (b._aa < 4) {
        i = b._aa;
      }
      else {
        i = (intDivide(b._aa, 2)) + 1;
      }
      for (let j of fromEnum(c)) {
        if (i <= j.value) {
          let k = j.key._bu();
          k._ds(2);
          k._ds(4);
          this._areaFormats$i.item(2).setFormatting(k);
          break;
        }
      }
    }
    if (d != null) {
      this._areaFormats$i.item(0).setFormatting(d);
    }
  }
  /**
   * @hidden
   */
  _be(a, b) {
    if (a._w != null) {
      this._w = a._w._g();
    }
    if (a._x != null) {
      this._x = a._x._g();
    }
    if (a._am != null) {
      for (let c of fromEnum(a._am)) {
        let d = c.key;
        let e = typeCast(WorksheetCellFormatProxy.$, c.value);
        let f = typeCast(WorksheetCellFormatProxy.$, this._am.item(d));
        ExcelUtils.fc(e, f, 0x7FFFFFFF, void 0, void 0, void 0, b);
      }
    }
    if (!stringIsNullOrEmpty(a._a2)) {
      this.name = a._a2;
    }
    if (!stringIsNullOrEmpty(a._a3)) {
      this.totalLabel = a._a3;
    }
  }
  /**
   * @hidden
   */
  _onFilterModified() {
    if (this.table != null) {
      this.table.reapplyFilters();
    }
  }
  /**
   * @hidden
   */
  _bg() {
    this._ca();
  }
  /**
   * @hidden
   */
  _bh() {
    this._b7(1);
  }
  /**
   * @hidden
   */
  _bi() {
    let a = this.headerCell;
    if (WorksheetCell.l_op_Inequality(a, null)) {
      a._o._d4(this._at, true);
    }
    let b = this.totalCell;
    if (WorksheetCell.l_op_Inequality(b, null)) {
      b._o._d4(this._at, true);
    }
  }
  /**
   * @hidden
   */
  _bj(a, b, c = false) {
    this._ak = a;
    this._as = b;
    let d = this._a2;
    this._br();
    if (c) {
      this._by(1, this._aq(2));
    }
    else {
      if (a._k != null) {
        this._bl(a._k);
      }
      if (!stringIsNullOrEmpty(d)) {
        this.name = d;
      }
    }
    let e = this.headerCell;
    if (WorksheetCell.l_op_Inequality(e, null)) {
      e._o._d4(this._at, true);
    }
    let f = this.totalCell;
    if (WorksheetCell.l_op_Inequality(f, null)) {
      f._o._d4(this._at, true);
    }
  }
  /**
   * @hidden
   */
  _bk(a = false) {
    let b = this.headerCell;
    if (WorksheetCell.l_op_Inequality(b, null)) {
      b._o._d4(this._at, false);
    }
    let c = this.totalCell;
    if (WorksheetCell.l_op_Inequality(c, null)) {
      c._o._d4(this._at, false);
    }
    this._ak = null;
    this._as = -1;
    this._br();
    if (a) {
      this._by(2, this._aq(1));
      this._by(1, false);
    }
    else {
      this._bq();
    }
  }
  /**
   * @hidden
   */
  _bl(a) {
    if (this._am != null) {
      this._am._k(a);
    }
  }
  /**
   * @hidden
   */
  _bm(a, b, c) {
    if (this._at < a._w || a._ae < this._at) {
      if (this._ak.isHeaderRowVisible) {
        this._b7(1);
      }
      this._b7(0);
      if (this._ak.isTotalsRowVisible) {
        this._b7(2);
      }
    }
    else if (b != null) {
      this._b6(this._areaFormats$i._f(0), 0x7FFFFFFF, true, b, null);
    }
    if (b != null && this._w != null) {
      if (c != null) {
        this._ba(c.firstRow, b.firstRow, b._aa);
      }
    }
  }
  /**
   * @hidden
   */
  _bn() {
    this._cb();
  }
  /**
   * @hidden
   */
  _bo() {
    this._b7(2);
  }
  /**
   * @hidden
   */
  _bq() {
    if (this._am != null) {
      this._am._l();
    }
  }
  /**
   * @hidden
   */
  _br() {
    this._au = -1;
  }
  /**
   * @hidden
   */
  _bs() {
    this._by(8, false);
  }
  /**
   * @hidden
   */
  _bt(a) {
    this._as = a;
  }
  /**
   * @hidden
   */
  _bz(a) {
    this._w = a;
  }
  /**
   * @hidden
   */
  _b4() {
    if (this.table != null && this.table._cp == false) {
      this._ca();
      this._cb();
    }
    this._by(8, true);
  }
  /**
   * @hidden
   */
  _b7(a) {
    if (this._am != null) {
      this._b5(this._areaFormats$i._f(a), 0x7FFFFFFF, true);
    }
  }
  /**
   * @hidden
   */
  _b6(a, b, c, d, e) {
    if (a == null || a._z) {
      return;
    }
    if ((d == null || d.worksheet == null) && (WorksheetCell.l_op_Equality(e, null) || e._o == null)) {
      return;
    }
    if (b == 0) {
      return;
    }
    if (d != null) {
      for (let f = d.firstRow; f <= d.lastRow; f++) {
        let g = d.worksheet._rows$i.item(f);
        ExcelUtils.fc(a, g._bc(this._at), b, c);
      }
    }
    else if (WorksheetCell.l_op_Inequality(e, null)) {
      ExcelUtils.fc(a, e._cellFormatInternal, b, c);
    }
  }
  /**
   * @hidden
   */
  _bb() {
    if (this._w == null) {
      return;
    }
    let a = this.dataAreaRegion;
    for (let b of fromEnum(this._worksheet._rows$i._m(a.firstRow, a.lastRow))) {
      let c = b._ar(this._at);
      if (c != null && this._w._ao(c)) {
        b.setCellValue(this._as, null);
      }
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = true, f = false, g = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetTableColumn.$, $tValue, a, 74, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(5);
    ChangeInfo.f(a, 0, WorksheetTableColumn._c(Formula.$, "ColumnFormula", (b) => b.columnFormula, (b, c) => b._bu(c), (b, c) => b._bw(c), true, true));
    ChangeInfo.f(a, 1, WorksheetTableColumn._c(Filter.$, "Filter", (b) => b.filter, (b, c) => b.filter = c, (b, c) => b._bx(c), true, true));
    ChangeInfo.f(a, 2, WorksheetTableColumn._c(String_$type, "Name", (b) => b.name, (b, c) => b.name = c, (b, c) => b._b0(c)));
    ChangeInfo.f(a, 3, WorksheetTableColumn._c(Formula.$, "TotalFormula", (b) => b.totalFormula, (b, c) => b.totalFormula = c, (b, c) => b._b2(c), true, true));
    ChangeInfo.f(a, 4, WorksheetTableColumn._c(String_$type, "TotalLabel", (b) => b.totalLabel, (b, c) => b.totalLabel = c, (b, c) => b._b3(c), true, true));
    return a;
  }
  /**
   * @hidden
   */
  _aq(a) {
    return (this._ao & a) == a;
  }
  /**
   * @hidden
   */
  _a1(a) {
    let b = this._workbook;
    return b != null && b._cx ? b._go(this._worksheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _bp(a) {
    if (a != null) {
      let b = this._workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _by(a, b) {
    if (b) {
      this._ao |= a;
    }
    else {
      this._ao &= ~a;
    }
  }
  /**
   * @hidden
   */
  _b5(a, b, c) {
    if (a == null || a._z) {
      return;
    }
    if (this.table == null || this.table._cu) {
      return;
    }
    let d = this.table._k;
    if (d != null && d._c4) {
      return;
    }
    let e = a._bt;
    let f = null;
    let g = null;
    switch (e) {
      case 0:
        f = this.dataAreaRegion;
        break;
      case 1:
        g = this.headerCell;
        break;
      case 2:
        g = this.totalCell;
        break;
      default: return;
    }
    this._b6(a, b, c, f, g);
  }
  /**
   * @hidden
   */
  static _b8(a, b) {
    let c;
    if (((() => { let d = WorksheetTableColumn._ar(a, b, c); c = d.p2; return d.ret; })()) == false) {
      throw new InvalidOperationException(1, c);
    }
  }
  /**
   * @hidden
   */
  static _ar(a, b, c) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 0:
          c = null;
          return {
            ret: true,
            p2: c
          };
        case 1:
          switch (b) {
            case 67108864:
            case 134217728:
              c = ExcelUtils.ef("LE_InvalidOperationException_InvalidHeaderCellColumnAreaFormatProperty");
              return {
                ret: false,
                p2: c
              };
          }
          c = null;
          return {
            ret: true,
            p2: c
          };
        case 2:
          switch (b) {
            case 2:
            case 4:
              c = ExcelUtils.ef("LE_InvalidOperationException_InvalidTotalsCellColumnAreaFormatProperty");
              return {
                ret: false,
                p2: c
              };
          }
          c = null;
          return {
            ret: true,
            p2: c
          };
        default:
          t1 = 0;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _b9() {
    if (this._aq(1) && this._ak == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_TableColumnRemovedFromTable"));
    }
  }
  /**
   * @hidden
   */
  _ca() {
    if (this._aq(8)) {
      return;
    }
    let a = this.headerCell;
    if (WorksheetCell.l_op_Inequality(a, null)) {
      let b = new GetCellTextParameters(a._ab);
      b.b = 1;
      b.a = 1;
      this._a2 = a._o._av(b).g;
    }
  }
  /**
   * @hidden
   */
  _cb() {
    if (this._aq(8)) {
      return;
    }
    let a = this.totalCell;
    if (WorksheetCell.l_op_Inequality(a, null)) {
      this._x = a.formula;
      if (this._x == null && a.value != null) {
        let b = new GetCellTextParameters(a._ab);
        b.b = 1;
        b.a = 1;
        this._a3 = a._o._av(b).g;
      }
      else {
        this._a3 = null;
      }
    }
  }
  areaFormats() {
    if (arguments.length !== 0) {
      let a = this._areaFormats$i;
      return a.item.apply(a, arguments);
    }
    return this._areaFormats$i;
  }
  /**
   * @hidden
   */
  get _areaFormats$i() {
    if (this._am == null) {
      this._am = new WorksheetTableAreaFormatsCollection$1(WorksheetTableColumnArea_$type, this);
    }
    return this._am;
  }
  /**
   * Gets the formula associated with the data area of the column.
   * <p class="body">
   * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
   * applied to them.
   * </p>
   * A [[Formula]] instance representing the formula for the data area of the column or null if no formula is applied.
   * @see [[setColumnFormula]]
   */
  get columnFormula() {
    return this._w;
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the column.
   */
  get dataAreaRegion() {
    if (this._ak == null) {
      return null;
    }
    return this._ah(this._ak.dataAreaRegion);
  }
  /**
   * Gets the filter applied to the column.
   * <p class="body">
   * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
   * added or removed on a column in the table or when the [[WorksheetTable.reapplyFilters]] method is called.
   * </p>
   * <p class="note">
   * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
   * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
   * same row will also be hidden.
   * </p>
   * A [[filter]]-derived instance if a filter is applied or null if the column is not filtered.
   * @see [[applyAverageFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyDatePeriodFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyRelativeDateRangeFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyYearToDateFilter]]
   * @see [[clearFilter]]
   * @see [[WorksheetTable.clearFilters]]
   * @see [[WorksheetTable.reapplyFilters]]
   */
  get filter() {
    return this._i;
  }
  /**
   * Gets the filter applied to the column.
   * <p class="body">
   * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
   * added or removed on a column in the table or when the [[WorksheetTable.reapplyFilters]] method is called.
   * </p>
   * <p class="note">
   * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
   * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
   * same row will also be hidden.
   * </p>
   * A [[filter]]-derived instance if a filter is applied or null if the column is not filtered.
   * @see [[applyAverageFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyCustomFilter]]
   * @see [[applyDatePeriodFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyFontColorFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyFixedValuesFilter]]
   * @see [[applyRelativeDateRangeFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyTopOrBottomFilter]]
   * @see [[applyYearToDateFilter]]
   * @see [[clearFilter]]
   * @see [[WorksheetTable.clearFilters]]
   * @see [[WorksheetTable.reapplyFilters]]
   */
  set filter(a) {
    if (this._i == a) {
      return;
    }
    this._b9();
    WorksheetTableColumn._a[1].h(WorksheetTableColumn.$, Filter.$, this, a);
  }
  /**
   * @hidden
   */
  _bx(a) {
    if (this.filter == a) {
      return;
    }
    if (a != null && this.table != null && this.table.isFilterUIVisible == false) {
      let b = this.table._k;
      if (b != null && b._c4 == false) {
        if (this.table.isHeaderRowVisible) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotApplyFilterWhileUIIsHidden"));
        }
        else {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotApplyFilterWhileHeaderRowIsHidden"));
        }
      }
    }
    this._i = a;
    this._onFilterModified();
  }
  /**
   * Gets the [[WorksheetCell]] which represents the header cell for the column.
   * A WorksheetCell which represents the header cell for the column or null if the header row is not visible in the table.
   * @see [[WorksheetTable.isHeaderRowVisible]]
   */
  get headerCell() {
    let a = this.table;
    if (a == null) {
      return null;
    }
    let b = a._bz;
    if (b == null) {
      return null;
    }
    return b._cells$i.item(this._at);
  }
  /**
   * Gets the 0-based index of the column in the owning [[WorksheetTable.columns]] collection.
   * The 0-based index of the column in its collection or -1 if the column has been removed from the table.
   * @see [[WorksheetTable.columns]]
   */
  get index() {
    if (this._ak == null) {
      return -1;
    }
    if (this._au == -1) {
      this._au = this._ak._columns$i.indexOf(this);
    }
    return this._au;
  }
  /**
   * Gets or sets the name of the column.
   * <p class="body">
   * If the header row is visible in the [[WorksheetTable]], the name of the column will be displayed in the cell of the
   * column in the header row.
   * </p>
   * <p class="body">
   * When the WorksheetTable is created, the column names will be taken from the cells in the header row. If the table does not
   * contain a header row, the column names will be generated.
   * </p>
   * <p class="body">
   * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
   * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
   * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
   * cells in the header row have no value, they will be given a generated column name.
   * </p>
   * <p class="body">
   * If the Name property is set to a null or empty string, a column name will be generated. If the value is set to a column name which
   * already exists in the table, the column with the higher index will have a number appended to its name so all column names can stay
   * unique.
   * </p>
   * The unique name of the column within the owning WorksheetTable.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[WorksheetTable.isHeaderRowVisible]]
   */
  get name() {
    this._ca();
    return this._a2;
  }
  /**
   * Gets or sets the name of the column.
   * <p class="body">
   * If the header row is visible in the [[WorksheetTable]], the name of the column will be displayed in the cell of the
   * column in the header row.
   * </p>
   * <p class="body">
   * When the WorksheetTable is created, the column names will be taken from the cells in the header row. If the table does not
   * contain a header row, the column names will be generated.
   * </p>
   * <p class="body">
   * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
   * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
   * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
   * cells in the header row have no value, they will be given a generated column name.
   * </p>
   * <p class="body">
   * If the Name property is set to a null or empty string, a column name will be generated. If the value is set to a column name which
   * already exists in the table, the column with the higher index will have a number appended to its name so all column names can stay
   * unique.
   * </p>
   * The unique name of the column within the owning WorksheetTable.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[WorksheetTable.isHeaderRowVisible]]
   */
  set name(a) {
    if (this._ak == null && this._a2 == a) {
      return;
    }
    this._b9();
    let b = this.headerCell;
    if (WorksheetCell.l_op_Inequality(b, null)) {
      this._b0(a);
    }
    else {
      WorksheetTableColumn._a[2].h(WorksheetTableColumn.$, String_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  _b0(a) {
    if (this.name == a) {
      return;
    }
    this._a2 = a;
    let b = this.headerCell;
    if (WorksheetCell.l_op_Inequality(b, null)) {
      b.value = a;
    }
  }
  /**
   * Gets or sets the sort condition used to sort the column in the table.
   * <p class="body">
   * When a sort condition is set on the column, the SortConditions collection on the [[WorksheetTable.sortSettings]] will be cleared
   * and the new sort condition will be added. To sort by multiple columns, the sort conditions must be added to the SortConditions collection
   * instead of set on the column. However, if a sort condition is cleared with this property, just the sort condition for the column will be
   * removed from the SortConditions collection. All other SortConditions will remain in the collection.
   * </p>
   * <p class="note">
   * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
   * only when they are are added or removed on a column in the table or when the [[WorksheetTable.reapplySortConditions]] method
   * is called.
   * </p>
   * The [[sortCondition]]-derived instance used to sort the column or null of the column is not sorted.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[WorksheetTable.sortSettings]]
   * @see [[SortSettings`1.sortConditions]]
   * @see [[SortConditionCollection`1]]
   * @see [[WorksheetTable.clearSortConditions]]
   * @see [[WorksheetTable.reapplySortConditions]]
   */
  get sortCondition() {
    if (this._ak == null) {
      return null;
    }
    return this._ak.sortSettings._sortConditions$i._item(this);
  }
  /**
   * Gets or sets the sort condition used to sort the column in the table.
   * <p class="body">
   * When a sort condition is set on the column, the SortConditions collection on the [[WorksheetTable.sortSettings]] will be cleared
   * and the new sort condition will be added. To sort by multiple columns, the sort conditions must be added to the SortConditions collection
   * instead of set on the column. However, if a sort condition is cleared with this property, just the sort condition for the column will be
   * removed from the SortConditions collection. All other SortConditions will remain in the collection.
   * </p>
   * <p class="note">
   * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
   * only when they are are added or removed on a column in the table or when the [[WorksheetTable.reapplySortConditions]] method
   * is called.
   * </p>
   * The [[sortCondition]]-derived instance used to sort the column or null of the column is not sorted.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[WorksheetTable.sortSettings]]
   * @see [[SortSettings`1.sortConditions]]
   * @see [[SortConditionCollection`1]]
   * @see [[WorksheetTable.clearSortConditions]]
   * @see [[WorksheetTable.reapplySortConditions]]
   */
  set sortCondition(a) {
    this._b9();
    if (this.sortCondition == a) {
      return;
    }
    if (this._ak != null) {
      if (a == null) {
        this._ak.sortSettings._sortConditions$i._item(this, null);
      }
      else {
        let b = this._ak.sortSettings._sortConditions$i.count;
        let c = b > 0 ? this._a1(80) : null;
        if (b > 0) {
          this._ak.sortSettings._sortConditions$i.clear();
        }
        this._ak.sortSettings._sortConditions$i._addItem$i(this, a);
        this._bp(c);
      }
    }
  }
  /**
   * @hidden
   */
  static _b1(a, b) {
  }
  /**
   * Gets the [[WorksheetTable]] to which the column belongs.
   * The WorksheetTable to which the column belongs or null if the column has been removed from the table.
   */
  get table() {
    return this._ak;
  }
  /**
   * Gets the [[WorksheetCell]] which represents the total cell for the column.
   * A WorksheetCell which represents the total cell for the column or null if the totals row is not visible in the table.
   * @see [[WorksheetTable.isTotalsRowVisible]]
   */
  get totalCell() {
    let a = this.table;
    if (a == null) {
      return null;
    }
    let b = a._b0;
    if (b == null) {
      return null;
    }
    return b._cells$i.item(this._at);
  }
  /**
   * Gets or sets the formula to use in the total cell of the column.
   * <p class="body">
   * The total formula can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
   * formula will not be applied anywhere. When the totals row is visible, it will be applied to the total cell of the column.
   * </p>
   * <p class="body">
   * Setting the TotalFormula to a non-null value will clear the [[totalLabel]], and vice versa.
   * </p>
   * @throws [[ArgumentException]] The value is already applied to something else, such as a cell or table column.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[totalLabel]]
   * @see [[WorksheetTable.isTotalsRowVisible]]
   */
  get totalFormula() {
    this._cb();
    return this._x;
  }
  /**
   * Gets or sets the formula to use in the total cell of the column.
   * <p class="body">
   * The total formula can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
   * formula will not be applied anywhere. When the totals row is visible, it will be applied to the total cell of the column.
   * </p>
   * <p class="body">
   * Setting the TotalFormula to a non-null value will clear the [[totalLabel]], and vice versa.
   * </p>
   * @throws [[ArgumentException]] The value is already applied to something else, such as a cell or table column.
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[totalLabel]]
   * @see [[WorksheetTable.isTotalsRowVisible]]
   */
  set totalFormula(a) {
    this._b9();
    WorksheetTableColumn._a[3].h(WorksheetTableColumn.$, Formula.$, this, a);
  }
  /**
   * @hidden
   */
  _b2(a) {
    let b = this.totalFormula;
    if (b == a) {
      return;
    }
    this._x = a;
    let c = this.totalCell;
    if (WorksheetCell.l_op_Inequality(c, null)) {
      if (this._x == null) {
        if (c.formula != null) {
          c.value = null;
        }
      }
      else {
        this._x._applyTo2(c);
      }
    }
    if (this._x != null) {
      this.totalLabel = null;
    }
  }
  /**
   * Gets or sets the text label to use in the total cell of the column.
   * <p class="body">
   * The total label can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
   * label will not be displayed anywhere. When the totals row is visible, it will be set as the value of the total cell of the column.
   * </p>
   * <p class="body">
   * Setting the [[totalFormula]] to a non-null value will clear the TotalLabel, and vice versa.
   * </p>
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[totalFormula]]
   * @see [[WorksheetTable.isTotalsRowVisible]]
   */
  get totalLabel() {
    this._cb();
    return this._a3;
  }
  /**
   * Gets or sets the text label to use in the total cell of the column.
   * <p class="body">
   * The total label can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
   * label will not be displayed anywhere. When the totals row is visible, it will be set as the value of the total cell of the column.
   * </p>
   * <p class="body">
   * Setting the [[totalFormula]] to a non-null value will clear the TotalLabel, and vice versa.
   * </p>
   * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
   * @see [[totalFormula]]
   * @see [[WorksheetTable.isTotalsRowVisible]]
   */
  set totalLabel(a) {
    this._b9();
    WorksheetTableColumn._a[4].h(WorksheetTableColumn.$, String_$type, this, a);
  }
  /**
   * @hidden
   */
  _b3(a) {
    let b = this.totalLabel;
    if (b == a) {
      return;
    }
    this._a3 = a;
    let c = this.totalCell;
    if (WorksheetCell.l_op_Inequality(c, null) && this._a3 != null) {
      c.value = this._a3;
    }
    if (this._a3 != null) {
      this.totalFormula = null;
    }
  }
  /**
   * Gets the [[WorksheetRegion]] which represents the region of cells in the whole column, including the header and total cells,
   * if visible.
   */
  get wholeColumnRegion() {
    if (this._ak == null) {
      return null;
    }
    return this._ah(this._ak.wholeTableRegion);
  }
  /**
   * @hidden
   */
  get _a9() {
    return this._a8;
  }
  /**
   * @hidden
   */
  get _a5() {
    return this._a2;
  }
  /**
   * @hidden
   */
  get _ai() {
    if (this._ak == null) {
      return null;
    }
    return this._ah(this._ak._bs);
  }
  /**
   * @hidden
   */
  get _a7() {
    return this._a3;
  }
  /**
   * @hidden
   */
  get _aa() {
    return this._x;
  }
  /**
   * @hidden
   */
  get _workbook() {
    if (this._ak == null) {
      return null;
    }
    return this._ak._k;
  }
  /**
   * @hidden
   */
  get _worksheet() {
    if (this._ak == null) {
      return null;
    }
    return this._ak.worksheet;
  }
  /**
   * @hidden
   */
  get _at() {
    return this._as;
  }
}
WorksheetTableColumn.$t = markType(WorksheetTableColumn, 'WorksheetTableColumn', Base.$, [IAreaFormatsOwner$1_$type.specialize(WorksheetTableColumnArea_$type), IChangeInfoContext_$type, IFilterable_$type, ISortable_$type]);
/**
 * @hidden
 */
WorksheetTableColumn._av = 0;
/**
 * @hidden
 */
WorksheetTableColumn._aw = 1;
/**
 * @hidden
 */
WorksheetTableColumn._ax = 2;
/**
 * @hidden
 */
WorksheetTableColumn._az = 3;
/**
 * @hidden
 */
WorksheetTableColumn._a0 = 4;
/**
 * @hidden
 */
WorksheetTableColumn._ay = 5;
/**
 * @hidden
 */
WorksheetTableColumn._a = WorksheetTableColumn._b();
/**
 * A read-only collection of all [[WorksheetTableColumn]] instances which exist in a [[WorksheetTable]].
 * @see [[WorksheetTable.columns]]
 */
export class WorksheetTableColumnCollection extends Base {
  constructor(a) {
    super();
    this._e = null;
    this._a = null;
    this._e = new List$1(WorksheetTableColumn.$, 0);
    this._a = a;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._e.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Determines whether the specified [[WorksheetTableColumn]] is in the collection.
   * @param column The column to find in the collection.
   * @return True if the specified column is in the collection; False otherwise.
   * @see [[WorksheetTableColumn]]
   */
  contains(column) {
    return this._e.contains(column);
  }
  /**
   * Gets the index of the specified [[WorksheetTableColumn]] in the collection.
   * @param column The WorksheetTableColumn to find in the collection.
   * @return The 0-based index of the specified WorksheetTableColumn in the collection or -1 if the item is not in the collection.
   */
  indexOf(column) {
    return this._e.indexOf(column);
  }
  /**
   * @hidden
   */
  _h(a, b) {
    this._e.insert(a, b);
    b._bi();
  }
  /**
   * @hidden
   */
  _i(a) {
    let b = this._e._inner[a];
    b._bk();
    this._e.removeAt(a);
  }
  /**
   * Gets the number of [[WorksheetTableColumn]] instances in the collection.
   * The number of columns in the collection.
   */
  get count() {
    return this._e.count;
  }
  item() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._item.apply(this, arguments);
      case 1: return this._item1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _item(a) {
    if (a < 0 || this.count <= a) {
      throw new ArgumentOutOfRangeException(2, "index", ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._e._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    let b = this._a._z;
    for (let c of fromEnum(this._e)) {
      if (StringUtilities.c(c.name, a, b, 1) == 0) {
        return c;
      }
    }
    return null;
  }
}
WorksheetTableColumnCollection.$t = markType(WorksheetTableColumnCollection, 'WorksheetTableColumnCollection', Base.$, [IEnumerable$1_$type.specialize(WorksheetTableColumn.$)]);
/**
 * Class which controls the way unfrozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[FrozenPaneSettings]]
 */
export class UnfrozenPaneSettings extends PaneSettingsBase {
  constructor(a) {
    super(a);
    this._af = 0;
    this._aj = 0;
    this._z = 0;
    this._ac = 0;
    this._am = null;
  }
  /**
   * @hidden
   */
  _g() {
    return new UnfrozenPaneSettings(this._e);
  }
  /**
   * @hidden
   */
  get__h() {
    return this._aj > 0;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
  /**
   * @hidden
   */
  get__i() {
    return this._af > 0;
  }
  /**
   * @hidden
   */
  get _i() {
    return this.get__i();
  }
  /**
   * @hidden
   */
  _s(a) {
    super._s(a);
    let b = a;
    this._af = b._af;
    this._aj = b._aj;
    this._z = b._z;
    this._ac = b._ac;
    this._am = null;
  }
  /**
   * Resets the unfrozen pane settings to their defaults.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    super.resetCore();
    this._af = 0;
    this._aj = 0;
    this._z = 0;
    this._ac = 0;
    this._am = null;
  }
  /**
   * Gets or sets the first visible column in the left pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the left pane(s) of the worksheet and is used regardless of whether or not the
   * worksheet is split vertically.
   * </p>
   * The zero-based index of the first visible column in the left pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get firstColumnInLeftPane() {
    return this._z;
  }
  /**
   * Gets or sets the first visible column in the left pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the left pane(s) of the worksheet and is used regardless of whether or not the
   * worksheet is split vertically.
   * </p>
   * The zero-based index of the first visible column in the left pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
   * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set firstColumnInLeftPane(a) {
    if (this._z != a) {
      ExcelUtils.gi(this._e._ad, a, "value");
      let b = UnfrozenPaneSettings._w[0].g(UnfrozenPaneSettings.$, Number_$type, this, this._z, a);
      this._z = b.p1;
    }
  }
  /**
   * Gets or sets the first visible row in the top pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the top pane(s) of the worksheet and is used regardless of whether or not
   * the worksheet is split horizontally.
   * </p>
   * The zero-based index of the first visible row in the top pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  get firstRowInTopPane() {
    return this._ac;
  }
  /**
   * Gets or sets the first visible row in the top pane(s) of the worksheet.
   * <p class="body">
   * This affects the scroll position for the top pane(s) of the worksheet and is used regardless of whether or not
   * the worksheet is split horizontally.
   * </p>
   * The zero-based index of the first visible row in the top pane(s).
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
   * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
   * [[Workbook.currentFormat]]).
   */
  set firstRowInTopPane(a) {
    if (this._ac != a) {
      ExcelUtils.gp(this._e._ad, a, "value");
      let b = UnfrozenPaneSettings._w[1].g(UnfrozenPaneSettings.$, Number_$type, this, this._ac, a);
      this._ac = b.p1;
    }
  }
  /**
   * Gets or sets the width of the left pane in twips (1/20th of a point).
   * <p class="body">
   * If this value is zero, the left pane occupies the entire visible area of the worksheet.
   * Otherwise, the left pane occupies the specified width and the right pane occupies
   * the remaining area of the worksheet.
   * </p>
   * The width of the left pane, or zero if there is no horizontal pane split.
   * @throws [[ArgumentOutOfRangeException]] Thrown when the width specified is outside the valid width range (0 to 65535).
   */
  get leftPaneWidth() {
    return this._af;
  }
  /**
   * Gets or sets the width of the left pane in twips (1/20th of a point).
   * <p class="body">
   * If this value is zero, the left pane occupies the entire visible area of the worksheet.
   * Otherwise, the left pane occupies the specified width and the right pane occupies
   * the remaining area of the worksheet.
   * </p>
   * The width of the left pane, or zero if there is no horizontal pane split.
   * @throws [[ArgumentOutOfRangeException]] Thrown when the width specified is outside the valid width range (0 to 65535).
   */
  set leftPaneWidth(a) {
    if (this._af != a) {
      if (a < 0 || 65535 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.eg("LE_ArgumentOutOfRangeException_LeftPaneWidth", 0, 65535));
      }
      UnfrozenPaneSettings._w[2].h(UnfrozenPaneSettings.$, Number_$type, this, a);
    }
  }
  /**
   * Gets or sets the height of the top pane in twips (1/20th of a point).
   * <p class="body">
   * If this value is zero, the top pane occupies the entire visible area of the worksheet.
   * Otherwise, the top pane occupies the specified height and the bottom pane occupies
   * the remaining area of the worksheet.
   * </p>
   * The height of the top pane, or zero if there is no vertical pane split.
   * @throws [[ArgumentOutOfRangeException]] Thrown when the height specified is outside the valid height range (0 to 65535).
   */
  get topPaneHeight() {
    return this._aj;
  }
  /**
   * Gets or sets the height of the top pane in twips (1/20th of a point).
   * <p class="body">
   * If this value is zero, the top pane occupies the entire visible area of the worksheet.
   * Otherwise, the top pane occupies the specified height and the bottom pane occupies
   * the remaining area of the worksheet.
   * </p>
   * The height of the top pane, or zero if there is no vertical pane split.
   * @throws [[ArgumentOutOfRangeException]] Thrown when the height specified is outside the valid height range (0 to 65535).
   */
  set topPaneHeight(a) {
    if (this._aj != a) {
      if (a < 0 || 65535 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.eg("LE_ArgumentOutOfRangeException_TopPaneHeight", 0, 65535));
      }
      UnfrozenPaneSettings._w[3].h(UnfrozenPaneSettings.$, Number_$type, this, a);
    }
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(UnfrozenPaneSettings.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, UnfrozenPaneSettings._y(Number_$type, "FirstColumnInLeftPane", (b) => b.firstColumnInLeftPane, (b, c) => b.firstColumnInLeftPane = c));
    ChangeInfo.f(a, 1, UnfrozenPaneSettings._y(Number_$type, "FirstRowInTopPane", (b) => b.firstRowInTopPane, (b, c) => b.firstRowInTopPane = c));
    ChangeInfo.f(a, 2, UnfrozenPaneSettings._y(Number_$type, "LeftPaneWidth", (b) => b.leftPaneWidth, (b, c) => b.leftPaneWidth = c, (b, c) => ((() => { let d = b._an(b._af, c); b._af = d.p0; })())));
    ChangeInfo.f(a, 3, UnfrozenPaneSettings._y(Number_$type, "TopPaneHeight", (b) => b.topPaneHeight, (b, c) => b.topPaneHeight = c, (b, c) => ((() => { let d = b._an(b._aj, c); b._aj = d.p0; })())));
    return a;
  }
  /**
   * @hidden
   */
  _an(a, b) {
    this._am = null;
    a = b;
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _j() {
    return super._j() || this._af != 0 || this._aj != 0 || this._z != 0 || this._ac != 0;
  }
  /**
   * @hidden
   */
  _ao(a, b) {
    let c = a;
    let d = this._af;
    let e = this._aj;
    let f = this._am;
    if (f == null) {
      f = Tuple.b(Number_$type, Number_$type, Number_$type, a, d, e);
    }
    else {
      c = f.c;
      d = f.d;
      e = f.e;
    }
    let g = truncate(Math.min(65535, MathUtilities.f((e / c) * b)));
    let h = truncate(Math.min(65535, MathUtilities.f((d / c) * b)));
    this.topPaneHeight = g;
    this.leftPaneWidth = h;
    this._am = f;
  }
}
UnfrozenPaneSettings.$t = markType(UnfrozenPaneSettings, 'UnfrozenPaneSettings', PaneSettingsBase.$);
/**
 * @hidden
 */
UnfrozenPaneSettings._ab = 0;
/**
 * @hidden
 */
UnfrozenPaneSettings._ae = 1;
/**
 * @hidden
 */
UnfrozenPaneSettings._ah = 2;
/**
 * @hidden
 */
UnfrozenPaneSettings._al = 3;
/**
 * @hidden
 */
UnfrozenPaneSettings._ai = 4;
/**
 * @hidden
 */
UnfrozenPaneSettings._w = UnfrozenPaneSettings._x();
/**
 * @hidden
 */
export class UnicodeStrings extends Base {
}
UnicodeStrings.$t = markType(UnicodeStrings, 'UnicodeStrings');
UnicodeStrings.a = " ";
/**
 * Abstract base class for all shapes that can display text.
 * <p class="body">
 * Primitive shapes, such as polygons, and cell comments can display regular text or text with mixed formatting and are derived from this class.
 * </p>
 * @see [[WorksheetCellComment]]
 * @see [[UnknownShape]]
 */
export class WorksheetShapeWithText extends WorksheetShape {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = [true];
          {
            let e = c[0];
            super(1, e);
            this._d1 = 72;
            this._d5 = 144;
            this._d9 = 144;
            this._dy = null;
            this._ec = 72;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c);
          this._d1 = 72;
          this._d5 = 144;
          this._d9 = 144;
          this._dy = null;
          this._ec = 72;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super(2, c);
          this._d1 = 72;
          this._d5 = 144;
          this._d9 = 144;
          this._dy = null;
          this._ec = 72;
          let d = typeCast(WorksheetShapeWithText.$, c);
          if (d != null) {
            this._d1 = d._d1;
            this._d5 = d._d5;
            this._d9 = d._d9;
            this._ec = d._ec;
            if (d.text != null) {
              this.text = d.text.clone();
            }
          }
        }
        break;
    }
  }
  /**
   * @hidden
   */
  onFormattingChanged(sender) {
  }
  /**
   * @hidden
   */
  onUnformattedStringChanged(sender) {
    if (this._dy != null) {
      let a = this._dy.toString();
      if (stringIsNullOrEmpty(a) == false && a.length > 32767) {
        throw new ArgumentException(1, stringFormat(ExcelUtils.ef("LE_ArgumentException_TextLengthGreaterThanMax"), 32767));
      }
    }
    this._ee();
  }
  /**
   * @hidden
   */
  resolveDefaults(font) {
    if (WorkbookColorInfo.l_op_Equality(font.colorInfo, null)) {
      font.colorInfo = new WorkbookColorInfo(0);
    }
    UltimateFontDefaultsResolver.a.resolveDefaults(font);
  }
  /**
   * @hidden
   */
  _ct(a) {
    super._ct(a);
    this._ee();
  }
  /**
   * @hidden
   */
  _cz() {
    super._cz();
    if (this._dy != null) {
      this._dy._aa(null);
    }
  }
  /**
   * @hidden
   */
  _c0(a) {
    super._c0(a);
    if (this._dy != null) {
      this._dy._aa(a);
    }
  }
  /**
   * @hidden
   */
  _ee() {
    if (this._dy == null) {
      return;
    }
    if (this._dy._paragraphs$i.count > 0) {
      return;
    }
    if (this.sheet == null) {
      return;
    }
    this._dy._paragraphs$i._add1(stringEmpty());
  }
  /**
   * @hidden
   */
  static _dx($tValue, a, b, c, d = null, e = true, f = false, g = 8192) {
    return new ChangeInfo$2(WorksheetShapeWithText.$, $tValue, a, 3, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _dw() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, WorksheetShapeWithText._dx(FormattedText.$, "Text", (b) => b.text, (b, c) => b.text = c, null, true, true));
    return a;
  }
  /**
   * @hidden
   */
  get _d0() {
    return this._dy != null && stringIsNullOrEmpty(this._dy.toString()) == false;
  }
  /**
   * Gets or sets the formatted text of the shape.
   * The formatted text of the shape.
   */
  get text() {
    return this._dy;
  }
  /**
   * Gets or sets the formatted text of the shape.
   * The formatted text of the shape.
   */
  set text(a) {
    if (this._dy == a) {
      return;
    }
    if (a != null) {
      a._ac(this);
    }
    let b = this._dy;
    let c = WorksheetShapeWithText._dv[0];
    let d = this.sheet;
    let e = d != null ? d.workbook : null;
    let f = null;
    if (e != null && e._cx) {
      f = c.b(e, d, c.c);
    }
    if (this._dy != null) {
      this._dy._owner = null;
    }
    this._dy = a;
    if (this._dy != null) {
      this._dy._owner = this;
    }
    this.onUnformattedStringChanged(this._dy);
    if (e != null && e._cx) {
      c.e(WorksheetShapeWithText.$, FormattedText.$, this, b, this._dy);
      if (f != null) {
        c.d(e, f);
      }
    }
  }
  /**
   * @hidden
   */
  get _d6() {
    return this._d5;
  }
  /**
   * @hidden
   */
  set _d6(a) {
    this._d5 = a;
  }
  /**
   * @hidden
   */
  get _ed() {
    return this._ec;
  }
  /**
   * @hidden
   */
  set _ed(a) {
    this._ec = a;
  }
  /**
   * @hidden
   */
  get _ea() {
    return this._d9;
  }
  /**
   * @hidden
   */
  set _ea(a) {
    this._d9 = a;
  }
  /**
   * @hidden
   */
  get _d2() {
    return this._d1;
  }
  /**
   * @hidden
   */
  set _d2(a) {
    this._d1 = a;
  }
}
WorksheetShapeWithText.$t = markType(WorksheetShapeWithText, 'WorksheetShapeWithText', WorksheetShape.$, [IFormattedTextOwner_$type, IWorkbookFontDefaultsResolver_$type]);
/**
 * @hidden
 */
WorksheetShapeWithText._d3 = 144;
/**
 * @hidden
 */
WorksheetShapeWithText._d4 = 72;
/**
 * @hidden
 */
WorksheetShapeWithText._d7 = 32767;
/**
 * @hidden
 */
WorksheetShapeWithText._eb = 0;
/**
 * @hidden
 */
WorksheetShapeWithText._d8 = 1;
/**
 * @hidden
 */
WorksheetShapeWithText._dv = WorksheetShapeWithText._dw();
/**
 * @hidden
 */
export let IWorksheetImage_$type = new Type(null, 'IWorksheetImage');
/**
 * Represents an unsupported shape which has been loaded from a workbook file.
 * <p class="body">
 * This class is used for round-tripping purposes, so unsupported shapes which have been
 * loaded can be saved back out with the workbook.  The class allows the unsupported shapes
 * to be identified in shape collections so they can be removed. This shape will become
 * obsolete in future versions when all shape types are supported.
 * </p>
 */
export class UnknownShape extends WorksheetShapeWithText {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(0);
          this._el = Nullable$1.toNullable(ShapeType_$type, null);
          this._em = Nullable$1.toNullable(ST_ShapeType_$type, null);
          this._eo = 0;
          this._eh = null;
          this._ej = false;
          this._ei = null;
          this._ef = null;
          this._en = null;
          this._eg = null;
          this._el = Nullable$1.toNullable(ShapeType_$type, c);
          this._em = WorksheetShape._by(c);
          this._eo = d;
        }
        break;
      case 1:
        {
          super(0);
          this._el = Nullable$1.toNullable(ShapeType_$type, null);
          this._em = Nullable$1.toNullable(ST_ShapeType_$type, null);
          this._eo = 0;
          this._eh = null;
          this._ej = false;
          this._ei = null;
          this._ef = null;
          this._en = null;
          this._eg = null;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super(2, c);
          this._el = Nullable$1.toNullable(ShapeType_$type, null);
          this._em = Nullable$1.toNullable(ST_ShapeType_$type, null);
          this._eo = 0;
          this._eh = null;
          this._ej = false;
          this._ei = null;
          this._ef = null;
          this._en = null;
          this._eg = null;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get image() {
    return this._eh;
  }
  /**
   * @hidden
   */
  set image(a) {
    this._eh = a;
  }
  /**
   * @hidden
   */
  get preferredFormat() {
    return this._ei;
  }
  /**
   * @hidden
   */
  set preferredFormat(a) {
    this._ei = a;
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitUnknownShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__aq() {
    return true;
  }
  /**
   * Throws an exception because all data in an unknown shape is unknown, and clearing that data would leave
   * no data with the shape.
   * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
   */
  clearUnknownData() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ClearUnknownShapeData"));
  }
  /**
   * @hidden
   */
  _cr() {
  }
  /**
   * @hidden
   */
  get__b0() {
    return this._el;
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return this._em;
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
  /**
   * @hidden
   */
  _eq(a, b) {
    this._el = a;
    this._em = Nullable$1.toNullable(ST_ShapeType_$type, b);
  }
  /**
   * @hidden
   */
  get _ek() {
    return this._ej;
  }
  /**
   * @hidden
   */
  set _ek(a) {
    this._ej = a;
  }
  /**
   * @hidden
   */
  get _ep() {
    return this._eo;
  }
}
UnknownShape.$t = markType(UnknownShape, 'UnknownShape', WorksheetShapeWithText.$, [IWorksheetImage_$type]);
/**
 * @hidden
 */
export let ILegacyShapeData_$type = new Type(null, 'ILegacyShapeData');
/**
 * @hidden
 */
export class ColorsInternal extends Base {
  static get a() {
    return Colors.a;
  }
  static get b() {
    return Colors.b;
  }
  static get d() {
    return Colors.g;
  }
  static get c() {
    return ExcelUtils.gv;
  }
  static get e() {
    return Colors.t;
  }
}
ColorsInternal.$t = markType(ColorsInternal, 'ColorsInternal');
/**
 * @hidden
 */
export class SystemColorsInternal extends Base {
  static get b() {
    if (SystemColorsInternal.a == null) {
      let a = new SystemColorsInternal_ColorResolver();
      ExcelUtils.fl(runOn(a, a.c));
      SystemColorsInternal.a = a.b;
    }
    return SystemColorsInternal.a;
  }
  static ad(a) {
    return ExcelUtils.g1(SystemColorsInternal.ae(a));
  }
  static ae(a) {
    let b = SystemColorsInternal.b[a];
    return b;
  }
  static c(a) {
    return false;
  }
  static get d() {
    return SystemColorsInternal.ad(0);
  }
  static get e() {
    return SystemColorsInternal.ae(0);
  }
  static get f() {
    return SystemColorsInternal.ad(1);
  }
  static get g() {
    return SystemColorsInternal.ae(1);
  }
  static get h() {
    return SystemColorsInternal.ad(2);
  }
  static get i() {
    return SystemColorsInternal.ae(2);
  }
  static get j() {
    return SystemColorsInternal.ad(3);
  }
  static get k() {
    return SystemColorsInternal.ae(3);
  }
  static get r() {
    return SystemColorsInternal.ad(7);
  }
  static get s() {
    return SystemColorsInternal.ae(7);
  }
  static get l() {
    return SystemColorsInternal.ad(4);
  }
  static get m() {
    return SystemColorsInternal.ae(4);
  }
  static get n() {
    return SystemColorsInternal.ad(5);
  }
  static get o() {
    return SystemColorsInternal.ae(5);
  }
  static get p() {
    return SystemColorsInternal.ad(6);
  }
  static get q() {
    return SystemColorsInternal.ae(6);
  }
  static get v() {
    return SystemColorsInternal.ad(10);
  }
  static get w() {
    return SystemColorsInternal.ae(10);
  }
  static get z() {
    return SystemColorsInternal.ad(12);
  }
  static get aa() {
    return SystemColorsInternal.ae(12);
  }
  static get x() {
    return SystemColorsInternal.ad(11);
  }
  static get y() {
    return SystemColorsInternal.ae(11);
  }
  static get t() {
    return SystemColorsInternal.ad(8);
  }
  static get u() {
    return SystemColorsInternal.ae(8);
  }
  static get ab() {
    return SystemColorsInternal.ad(13);
  }
  static get ac() {
    return SystemColorsInternal.ae(13);
  }
  static get af() {
    return SystemColorsInternal.ad(14);
  }
  static get ag() {
    return SystemColorsInternal.ae(14);
  }
  static get ah() {
    return SystemColorsInternal.ad(15);
  }
  static get ai() {
    return SystemColorsInternal.ae(15);
  }
  static get aj() {
    return SystemColorsInternal.ad(16);
  }
  static get ak() {
    return SystemColorsInternal.ae(16);
  }
  static get al() {
    return SystemColorsInternal.ad(17);
  }
  static get am() {
    return SystemColorsInternal.ae(17);
  }
  static get an() {
    return SystemColorsInternal.ad(18);
  }
  static get ao() {
    return SystemColorsInternal.ae(18);
  }
  static get ap() {
    return SystemColorsInternal.ad(19);
  }
  static get aq() {
    return SystemColorsInternal.ae(19);
  }
  static get ar() {
    return SystemColorsInternal.ad(20);
  }
  static get as() {
    return SystemColorsInternal.ae(20);
  }
  static get at() {
    return SystemColorsInternal.ad(21);
  }
  static get au() {
    return SystemColorsInternal.ae(21);
  }
  static get av() {
    return SystemColorsInternal.ad(22);
  }
  static get aw() {
    return SystemColorsInternal.ae(22);
  }
  static get ax() {
    return SystemColorsInternal.ad(23);
  }
  static get ay() {
    return SystemColorsInternal.ae(23);
  }
  static get az() {
    return SystemColorsInternal.ad(24);
  }
  static get a0() {
    return SystemColorsInternal.ae(24);
  }
  static get a3() {
    return SystemColorsInternal.ad(25);
  }
  static get a4() {
    return SystemColorsInternal.ae(25);
  }
  static get a1() {
    return SystemColorsInternal.ad(26);
  }
  static get a2() {
    return SystemColorsInternal.ae(26);
  }
  static get a5() {
    return SystemColorsInternal.ad(27);
  }
  static get a6() {
    return SystemColorsInternal.ae(27);
  }
  static get a7() {
    return SystemColorsInternal.ad(28);
  }
  static get a8() {
    return SystemColorsInternal.ae(28);
  }
  static get a9() {
    return SystemColorsInternal.ad(29);
  }
  static get ba() {
    return SystemColorsInternal.ae(29);
  }
  static get bb() {
    return SystemColorsInternal.ad(30);
  }
  static get bc() {
    return SystemColorsInternal.ae(30);
  }
  static get bd() {
    return SystemColorsInternal.ad(31);
  }
  static get be() {
    return SystemColorsInternal.ae(31);
  }
  static get bf() {
    return SystemColorsInternal.ad(32);
  }
  static get bg() {
    return SystemColorsInternal.ae(32);
  }
}
SystemColorsInternal.$t = markType(SystemColorsInternal, 'SystemColorsInternal');
SystemColorsInternal.a = null;
/**
 * @hidden
 */
export class SystemColorsInternal_ColorResolver extends Base {
  constructor() {
    super(...arguments);
    this.a = new Array(33);
  }
  c(a) {
    this.a[0] = ExcelUtils.gx(-4934476);
    this.a[1] = ExcelUtils.gx(-6703919);
    this.a[2] = ExcelUtils.gx(-16777216);
    this.a[3] = ExcelUtils.gx(-5526613);
    this.a[7] = ExcelUtils.gx(-986896);
    this.a[8] = ExcelUtils.gx(-6250336);
    this.a[9] = ExcelUtils.gx(-9868951);
    this.a[10] = ExcelUtils.gx(-1842205);
    this.a[11] = ExcelUtils.gx(-1);
    this.a[12] = ExcelUtils.gx(-16777216);
    this.a[13] = ExcelUtils.gx(-16777216);
    this.a[16] = ExcelUtils.gx(-9605779);
    this.a[17] = ExcelUtils.gx(-13395457);
    this.a[18] = ExcelUtils.gx(-1);
    this.a[20] = ExcelUtils.gx(-722948);
    this.a[21] = ExcelUtils.gx(-4207141);
    this.a[22] = ExcelUtils.gx(-16777216);
    this.a[23] = ExcelUtils.gx(-31);
    this.a[24] = ExcelUtils.gx(-16777216);
    this.a[25] = ExcelUtils.gx(-986896);
    this.a[28] = ExcelUtils.gx(-16777216);
    this.a[29] = ExcelUtils.gx(-3618616);
    this.a[30] = ExcelUtils.gx(-1);
    this.a[31] = ExcelUtils.gx(-10197916);
    this.a[32] = ExcelUtils.gx(-16777216);
  }
  get b() {
    return this.a;
  }
}
SystemColorsInternal_ColorResolver.$t = markType(SystemColorsInternal_ColorResolver, 'SystemColorsInternal_ColorResolver');
/**
 * @hidden
 */
export class UtilitiesInt32Comparer extends Comparer$1 {
  constructor() {
    super(Number_$type);
  }
  compare(a, b) {
    if (a < b) {
      return -1;
    }
    if (b < a) {
      return 1;
    }
    return 0;
  }
}
UtilitiesInt32Comparer.$t = markType(UtilitiesInt32Comparer, 'UtilitiesInt32Comparer', Comparer$1.$.specialize(Number_$type));
UtilitiesInt32Comparer._c = new UtilitiesInt32Comparer();
/**
 * @hidden
 */
export class ActiveCellChangedInfo extends Base {
  constructor(a) {
    super();
    this.a = null;
    this.b = null;
    this.d = 0;
    this.c = 0;
    this.a = a;
    this.e();
  }
  e() {
    let a = this.a.windowOptions.selectedWorksheet;
    this.b = a;
    if (a == null) {
      this.d = this.c = 0;
    }
    else {
      let b = a.displayOptions._af.a(a.displayOptions._z);
      this.d = b != null ? b.b.o : 0;
      this.c = b != null ? b.b.m : 0;
    }
  }
}
ActiveCellChangedInfo.$t = markType(ActiveCellChangedInfo, 'ActiveCellChangedInfo');
/**
 * @hidden
 */
export class ChartDeserializationCache extends Base {
  constructor() {
    super();
    this.a = null;
    this.b = null;
    this.d = null;
    this.c = null;
    this.a = new Dictionary$2(String_$type, Base.$, 0);
    this.b = new Dictionary$2(String_$type, Base.$, 0);
    this.c = new Dictionary$2(String_$type, Base.$, 0);
  }
}
ChartDeserializationCache.$t = markType(ChartDeserializationCache, 'ChartDeserializationCache');
/**
 * Represents the color palette used when the saved file is opened in Microsoft Excel 2003 and earlier versions.
 * @see [[Workbook.palette]]
 */
export class WorkbookColorPalette extends Base {
  constructor(a) {
    super();
    this._d = false;
    this._a = null;
    this._c = null;
    this._c = a;
    this._a = arrayShallowClone(WorkbookColorPalette._b);
  }
  /**
   * @hidden
   */
  add(item) {
    arguments[0] = Color.create(arguments[0]);
    return this._add$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _add$i(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotAddColorsToPaletteDirectly"));
  }
  /**
   * @hidden
   */
  clear() {
    this.reset();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    arrayCopyTo(this._a, array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    arguments[0] = Color.create(arguments[0]);
    return this._remove$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _remove$i(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotRemoveColorsToPaletteDirectly"));
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    for (let a = 0; a < this._a.length; a++) {
      yield this._a[a];
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Determines whether the specified color is in the color palette.
   * @param color The color to find in the palette.
   * @return Determines whether an equivalent color is in the palette.
   */
  contains(color) {
    arguments[0] = Color.create(arguments[0]);
    return this._contains$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _contains$i(a) {
    let b = this._getIndexOfNearestColor$i(a);
    return WorkbookColorPalette._e(a, this._item$i(b));
  }
  /**
   * Gets the index of the closest color in the color palette, which will be seen when the file is opened in Microsoft Excel 2003
   * and older versions.
   * @param color The color to match in the palette.
   * @return A 0-based index into the collection of the closest color available in the palette.
   */
  getIndexOfNearestColor(color) {
    arguments[0] = Color.create(arguments[0]);
    return this._getIndexOfNearestColor$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getIndexOfNearestColor$i(a) {
    let b = 0;
    let c = 1.7976931348623157E+308;
    let d;
    let e;
    let f;
    let g = ExcelUtils.f3(a, d, e, f);
    d = g.p1;
    e = g.p2;
    f = g.p3;
    for (let h = 0; h < this._a.length; h++) {
      let i = this._a[h];
      let j;
      let k;
      let l;
      let m = ExcelUtils.f3(i, j, k, l);
      j = m.p1;
      k = m.p2;
      l = m.p3;
      let n = (Math.pow(d - j, 2)) + (Math.pow(e - k, 2)) + (Math.pow(f - l, 2));
      if (n < c) {
        b = h;
        c = n;
      }
    }
    return b;
  }
  /**
   * Resets the palette back to the default colors for Microsoft Excel.
   * @see [[isCustom]]
   */
  reset() {
    if (this._d == false) {
      return;
    }
    this._a = arrayShallowClone(WorkbookColorPalette._b);
    this._d = false;
  }
  /**
   * @hidden
   */
  _l(a, b) {
    return this._m(a, b);
  }
  /**
   * @hidden
   */
  _m(a, b) {
    let c = a._aj(this._c);
    if (ExcelUtils.al(c)) {
      return -1;
    }
    if (b == 4) {
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._ab)) {
        return 0;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._al)) {
        return 1;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._ak)) {
        return 2;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._ai)) {
        return 3;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._ac)) {
        return 4;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._am)) {
        return 5;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._aj)) {
        return 6;
      }
      if (WorkbookColorPalette._e(c, WorkbookColorPalette._ad)) {
        return 7;
      }
    }
    if (ExcelUtils.am(c)) {
      if (WorkbookColorPalette._e(c, SystemColorsInternal.bg)) {
        if (b == 2) {
          return 32767;
        }
        return 64;
      }
      if (b != 3 && b != 4) {
        if (WorkbookColorPalette._e(c, SystemColorsInternal.bc)) {
          return 65;
        }
        if (ExcelUtils.au(this._c.currentFormat) == false && b != 0) {
          if (WorkbookColorPalette._e(c, SystemColorsInternal.s)) {
            return 67;
          }
        }
        if (b != 1) {
          if (WorkbookColorPalette._e(c, SystemColorsInternal.be)) {
            return 66;
          }
          if (b != 0) {
            if (WorkbookColorPalette._e(c, SystemColorsInternal.s)) {
              return 67;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.aa)) {
              return 68;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.y)) {
              return 69;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.u)) {
              return 70;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.am)) {
              return 71;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.ba)) {
              return 73;
            }
            if (WorkbookColorPalette._e(c, WorkbookColorPalette._ag(SystemColorsInternal.ba))) {
              return 74;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.ay)) {
              return 80;
            }
            if (WorkbookColorPalette._e(c, SystemColorsInternal.a0)) {
              return 81;
            }
          }
        }
      }
    }
    return this._getIndexOfNearestColor$i(ExcelUtils.g1(c)) + 8;
  }
  /**
   * @hidden
   */
  _ae(a) {
    return this._af(a);
  }
  /**
   * @hidden
   */
  _af(a) {
    switch (a) {
      case 0: return WorkbookColorPalette._ab;
      case 1: return WorkbookColorPalette._al;
      case 2: return WorkbookColorPalette._ak;
      case 3: return WorkbookColorPalette._ai;
      case 4: return WorkbookColorPalette._ac;
      case 5: return WorkbookColorPalette._am;
      case 6: return WorkbookColorPalette._aj;
      case 7: return WorkbookColorPalette._ad;
      case 64: return SystemColorsInternal.bg;
      case 65: return SystemColorsInternal.bc;
      case 66: return SystemColorsInternal.be;
      case 67: return SystemColorsInternal.s;
      case 68: return SystemColorsInternal.aa;
      case 69: return SystemColorsInternal.y;
      case 70: return SystemColorsInternal.u;
      case 71: return SystemColorsInternal.am;
      case 72: return SystemColorsInternal.bg;
      case 73: return SystemColorsInternal.ba;
      case 74: return WorkbookColorPalette._ag(SystemColorsInternal.ba);
      case 75: return SystemColorsInternal.bc;
      case 76: return SystemColorsInternal.be;
      case 77: return SystemColorsInternal.bg;
      case 78: return SystemColorsInternal.bc;
      case 79: return WorkbookColorPalette._ab;
      case 80: return SystemColorsInternal.ay;
      case 81: return SystemColorsInternal.a0;
      case 32767: return SystemColorsInternal.bg;
      default:
        if (81 < a) {
          return SystemColorsInternal.bc;
        }
        break;
    }
    let b = a - 8;
    if (b < 0 || 56 <= b) {
      return ExcelUtils.g2(ColorsInternal.c);
    }
    return ExcelUtils.g2(this._item$i(b));
  }
  /**
   * @hidden
   */
  static _e(a, b) {
    if (ExcelUtils.am(a) || ExcelUtils.am(b)) {
      return Color.b(a, b);
    }
    if (ExcelUtils.al(a) != ExcelUtils.al(b)) {
      return false;
    }
    return ExcelUtils.cx(a) == ExcelUtils.cx(b);
  }
  /**
   * @hidden
   */
  static _ag(a) {
    return Color.u(a.l, ~a.o, ~a.n, ~a.m);
  }
  /**
   * @hidden
   */
  _aa(a) {
    if (a < 0 || this._a.length <= a) {
      throw new ArgumentOutOfRangeException(1, "index");
    }
  }
  /**
   * Gets the number of colors in the palette, which is always 56.
   */
  get count() {
    return this._a.length;
  }
  /**
   * Gets or sets a color in the palette.
   * <p class="body">
   * When a color is set in the palette, [[isCustom]] will return True. The palette can than be reset with the
   * [[reset]] method.
   * </p>
   * <p class="body">
   * Colors added to the palette must be opaque.
   * </p>
   * @param index The index of the color to get or set in the palette.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than 55.
   * @throws [[ArgumentException]] The value assigned is an empty color, a system color, or is not opaque.
   * @see [[isCustom]]
   * @see [[reset]]
   */
  item(index, value) {
    if (arguments.length === 2) {
      arguments[1] = Color.create(arguments[1]);
      return this._item$i.apply(this, arguments).colorString;
    }
    else {
      return this._item$i.apply(this, arguments).colorString;
    }
  }
  /**
   * @hidden
   */
  _item$i(a, b) {
    if (arguments.length === 2) {
      this._aa(a);
      if (ExcelUtils.al(b) || ExcelUtils.am(b)) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_InvalidPaletteColor_EmptyOrSystem"));
      }
      if (b.l != 255) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_InvalidPaletteColor_NonOpaque"));
      }
      let c = this._a[a];
      this._a[a] = b;
      if (WorkbookColorPalette._e(c, b) == false) {
        this._d = true;
        this._c._h3();
      }
      return b;
    }
    else {
      this._aa(a);
      return this._a[a];
    }
  }
  /**
   * Gets the value which indicates whether the palette has been cusotmized.
   * @see [[reset]]
   */
  get isCustom() {
    return this._d;
  }
}
WorkbookColorPalette.$t = markType(WorkbookColorPalette, 'WorkbookColorPalette', Base.$, [ICollection$1_$type.specialize(Color.$)]);
/**
 * @hidden
 */
WorkbookColorPalette._g = 64;
/**
 * @hidden
 */
WorkbookColorPalette._n = 32767;
/**
 * @hidden
 */
WorkbookColorPalette._u = 56;
/**
 * @hidden
 */
WorkbookColorPalette._v = 8;
/**
 * @hidden
 */
WorkbookColorPalette._y = 64;
/**
 * @hidden
 */
WorkbookColorPalette._w = 65;
/**
 * @hidden
 */
WorkbookColorPalette._x = 66;
/**
 * @hidden
 */
WorkbookColorPalette._h = 67;
/**
 * @hidden
 */
WorkbookColorPalette._k = 68;
/**
 * @hidden
 */
WorkbookColorPalette._j = 69;
/**
 * @hidden
 */
WorkbookColorPalette._i = 70;
/**
 * @hidden
 */
WorkbookColorPalette._p = 71;
/**
 * @hidden
 */
WorkbookColorPalette._s = 73;
/**
 * @hidden
 */
WorkbookColorPalette._t = 74;
/**
 * @hidden
 */
WorkbookColorPalette._q = 80;
/**
 * @hidden
 */
WorkbookColorPalette._r = 81;
/**
 * @hidden
 */
WorkbookColorPalette._ab = ExcelUtils.g2(Color.u(255, 0, 0, 0));
/**
 * @hidden
 */
WorkbookColorPalette._al = ExcelUtils.g2(Color.u(255, 255, 255, 255));
/**
 * @hidden
 */
WorkbookColorPalette._ak = ExcelUtils.g2(Color.u(255, 255, 0, 0));
/**
 * @hidden
 */
WorkbookColorPalette._ai = ExcelUtils.g2(Color.u(255, 0, 255, 0));
/**
 * @hidden
 */
WorkbookColorPalette._ac = ExcelUtils.g2(Color.u(255, 0, 0, 255));
/**
 * @hidden
 */
WorkbookColorPalette._am = ExcelUtils.g2(Color.u(255, 255, 255, 0));
/**
 * @hidden
 */
WorkbookColorPalette._aj = ExcelUtils.g2(Color.u(255, 255, 0, 255));
/**
 * @hidden
 */
WorkbookColorPalette._ad = ExcelUtils.g2(Color.u(255, 0, 255, 255));
/**
 * @hidden
 */
WorkbookColorPalette._b = [Color.u(255, 0, 0, 0), Color.u(255, 255, 255, 255), Color.u(255, 255, 0, 0), Color.u(255, 0, 255, 0), Color.u(255, 0, 0, 255), Color.u(255, 255, 255, 0), Color.u(255, 255, 0, 255), Color.u(255, 0, 255, 255), Color.u(255, 128, 0, 0), Color.u(255, 0, 128, 0), Color.u(255, 0, 0, 128), Color.u(255, 128, 128, 0), Color.u(255, 128, 0, 128), Color.u(255, 0, 128, 128), Color.u(255, 192, 192, 192), Color.u(255, 128, 128, 128), Color.u(255, 153, 153, 255), Color.u(255, 153, 51, 102), Color.u(255, 255, 255, 204), Color.u(255, 204, 255, 255), Color.u(255, 102, 0, 102), Color.u(255, 255, 128, 128), Color.u(255, 0, 102, 204), Color.u(255, 204, 204, 255), Color.u(255, 0, 0, 128), Color.u(255, 255, 0, 255), Color.u(255, 255, 255, 0), Color.u(255, 0, 255, 255), Color.u(255, 128, 0, 128), Color.u(255, 128, 0, 0), Color.u(255, 0, 128, 128), Color.u(255, 0, 0, 255), Color.u(255, 0, 204, 255), Color.u(255, 204, 255, 255), Color.u(255, 204, 255, 204), Color.u(255, 255, 255, 153), Color.u(255, 153, 204, 255), Color.u(255, 255, 153, 204), Color.u(255, 204, 153, 255), Color.u(255, 255, 204, 153), Color.u(255, 51, 102, 255), Color.u(255, 51, 204, 204), Color.u(255, 153, 204, 0), Color.u(255, 255, 204, 0), Color.u(255, 255, 153, 0), Color.u(255, 255, 102, 0), Color.u(255, 102, 102, 153), Color.u(255, 150, 150, 150), Color.u(255, 0, 51, 102), Color.u(255, 51, 153, 102), Color.u(255, 0, 51, 0), Color.u(255, 51, 51, 0), Color.u(255, 153, 51, 0), Color.u(255, 153, 51, 102), Color.u(255, 51, 51, 153), Color.u(255, 51, 51, 51)];
/**
 * @hidden
 */
export class UltimateFontDefaultsResolver extends Base {
  constructor() {
    super();
  }
  resolveDefaults(a) {
    if (nullableEquals(a._bold$i, null)) {
      a._bold$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (WorkbookColorInfo.l_op_Equality(a.colorInfo, null)) {
      a.colorInfo = WorkbookColorInfo.automatic;
    }
    if (a.height < 0) {
      a.height = 220;
    }
    if (nullableEquals(a._italic$i, null)) {
      a._italic$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (a.name == null) {
      a.name = "Calibri";
    }
    if (nullableEquals(a._strikeout$i, null)) {
      a._strikeout$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (a.superscriptSubscriptStyle == -1) {
      a.superscriptSubscriptStyle = 0;
    }
    if (a.underlineStyle == -1) {
      a.underlineStyle = 0;
    }
  }
}
UltimateFontDefaultsResolver.$t = markType(UltimateFontDefaultsResolver, 'UltimateFontDefaultsResolver', Base.$, [IWorkbookFontDefaultsResolver_$type]);
UltimateFontDefaultsResolver.a = new UltimateFontDefaultsResolver();
/**
 * @hidden
 */
export class WorkbookFontDataResolved extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  equals(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(WorkbookFontDataResolved.$, a);
    if (b == null) {
      return false;
    }
    return this._a.equals(b._a);
  }
  getHashCode() {
    return this._a.getHashCode();
  }
  setFontFormatting(a) {
    this._e();
  }
  get bold() {
    return unwrapNullable(this._bold$i);
  }
  set bold(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._bold$i = arguments[0];
  }
  get _bold$i() {
    return this._a.d._c2;
  }
  set _bold$i(a) {
    this._e();
  }
  get colorInfo() {
    return this._a.d._bh;
  }
  set colorInfo(a) {
    this._e();
  }
  get height() {
    return this._a.d._cq;
  }
  set height(a) {
    this._e();
  }
  get italic() {
    return unwrapNullable(this._italic$i);
  }
  set italic(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._italic$i = arguments[0];
  }
  get _italic$i() {
    return this._a.d._c3;
  }
  set _italic$i(a) {
    this._e();
  }
  get name() {
    return this._a.d._df;
  }
  set name(a) {
    this._e();
  }
  get strikeout() {
    return unwrapNullable(this._strikeout$i);
  }
  set strikeout(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._strikeout$i = arguments[0];
  }
  get _strikeout$i() {
    return this._a.d._c4;
  }
  set _strikeout$i(a) {
    this._e();
  }
  get superscriptSubscriptStyle() {
    return this._a.d._a0;
  }
  set superscriptSubscriptStyle(a) {
    this._e();
  }
  get underlineStyle() {
    return this._a.d._a1;
  }
  set underlineStyle(a) {
    this._e();
  }
  _d(a) {
    this._a = a;
  }
  _e() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ResolvedFormatCannotBeModified"));
  }
}
WorkbookFontDataResolved.$t = markType(WorkbookFontDataResolved, 'WorkbookFontDataResolved', Base.$, [IWorkbookFont_$type]);
/**
 * @hidden
 */
export class WorkbookFontOwnerAccessor extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  setFontFormatting(a) {
    this._a._a1(a, true, 0);
  }
  _setFontFormatting1(a, b, c) {
    this._a._a1(a, b, c);
  }
  _e($tValue, a, b, c, d, e, f) {
    this._a._a2($tValue, a, b, c, d, e, f);
  }
  get bold() {
    return unwrapNullable(this._bold$i);
  }
  set bold(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._bold$i = arguments[0];
  }
  get _bold$i() {
    return this._a.d._bp._bold$i;
  }
  set _bold$i(a) {
    this._b(a, true, 0);
  }
  _b(a, b, c) {
    this._e(Nullable$1.$.specialize(Boolean_$type), a, 128, b, c, (d) => d._bold$i, (d, e) => d._bold$i = e);
    ;
  }
  get colorInfo() {
    return this._a.d._bp.colorInfo;
  }
  set colorInfo(a) {
    this._c(a, true, 0);
  }
  _c(a, b, c) {
    this._e(WorkbookColorInfo.$, a, 256, b, c, (d) => d.colorInfo, (d, e) => d.colorInfo = e);
  }
  get height() {
    return this._a.d._bp.height;
  }
  set height(a) {
    this._f(a, true, 0);
  }
  _f(a, b, c) {
    this._e(Number_$type, a, 512, b, c, (d) => d.height, (d, e) => d.height = e);
  }
  get italic() {
    return unwrapNullable(this._italic$i);
  }
  set italic(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._italic$i = arguments[0];
  }
  get _italic$i() {
    return this._a.d._bp._italic$i;
  }
  set _italic$i(a) {
    this._g(a, true, 0);
  }
  _g(a, b, c) {
    this._e(Nullable$1.$.specialize(Boolean_$type), a, 1024, b, c, (d) => d._italic$i, (d, e) => d._italic$i = e);
  }
  get name() {
    return this._a.d._bp.name;
  }
  set name(a) {
    this._h(a, true, 0);
  }
  _h(a, b, c) {
    this._e(String_$type, a, 2048, b, c, (d) => d.name, (d, e) => d.name = e);
  }
  get strikeout() {
    return unwrapNullable(this._strikeout$i);
  }
  set strikeout(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._strikeout$i = arguments[0];
  }
  get _strikeout$i() {
    return this._a.d._bp._strikeout$i;
  }
  set _strikeout$i(a) {
    this._i(a, true, 0);
  }
  _i(a, b, c) {
    this._e(Nullable$1.$.specialize(Boolean_$type), a, 4096, b, c, (d) => d._strikeout$i, (d, e) => d._strikeout$i = e);
  }
  get superscriptSubscriptStyle() {
    return this._a.d._bp.superscriptSubscriptStyle;
  }
  set superscriptSubscriptStyle(a) {
    this._j(a, true, 0);
  }
  _j(a, b, c) {
    this._e(FontSuperscriptSubscriptStyle_$type, a, 8192, b, c, (d) => d.superscriptSubscriptStyle, (d, e) => d.superscriptSubscriptStyle = e);
  }
  get underlineStyle() {
    return this._a.d._bp.underlineStyle;
  }
  set underlineStyle(a) {
    this._k(a, true, 0);
  }
  _k(a, b, c) {
    this._e(FontUnderlineStyle_$type, a, 16384, b, c, (d) => d.underlineStyle, (d, e) => d.underlineStyle = e);
  }
}
WorkbookFontOwnerAccessor.$t = markType(WorkbookFontOwnerAccessor, 'WorkbookFontOwnerAccessor', Base.$, [IWorkbookFont_$type]);
/**
 * @hidden
 */
export class WorkbookFontProxy extends GenericCacheElementProxy$1 {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = [c, WorksheetCellFormatData._a2(d, e)];
          {
            let h = f[0];
            let i = f[1];
            super(WorkbookFontData.$, 0, h, i);
            this._m = null;
            this._q = Nullable$1.toNullable(Number_$type, null);
            this._n = null;
          }
          this._m = e;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(WorkbookFontData.$, 0, c, d);
          this._m = null;
          this._q = Nullable$1.toNullable(Number_$type, null);
          this._n = null;
        }
        break;
    }
  }
  g(a) {
    super.g(a);
    if (this._m != null) {
      this._m._dm();
    }
  }
  static _l(a, b) {
    let c = 0;
    if (nullableNotEquals(a._bold$i, b._bold$i)) {
      c |= 128;
    }
    if (WorkbookColorInfo.l_op_Inequality(a.colorInfo, b.colorInfo)) {
      c |= 256;
    }
    if (a.height != b.height) {
      c |= 512;
    }
    if (nullableNotEquals(a._italic$i, b._italic$i)) {
      c |= 1024;
    }
    if (a.name != b.name) {
      c |= 2048;
    }
    if (nullableNotEquals(a._strikeout$i, b._strikeout$i)) {
      c |= 4096;
    }
    if (a.superscriptSubscriptStyle != b.superscriptSubscriptStyle) {
      c |= 8192;
    }
    if (a.underlineStyle != b.underlineStyle) {
      c |= 16384;
    }
    return c;
  }
  _s(a) {
    this._n = a;
  }
  setFontFormatting(a) {
    this._t(a, true);
  }
  _t(a, b) {
    if (a == null) {
      throw new ArgumentNullException(2, "source", ExcelUtils.ef("LE_ArgumentNullException_SourceFont"));
    }
    let c = typeCast(WorkbookFontData.$, a);
    if (c != null) {
      this.k(c);
      return;
    }
    let d = typeCast(WorkbookFontProxy.$, a);
    if (d != null) {
      this._q = d._q;
      this.k(d.d);
      return;
    }
    let e = this.a();
    this.d.setFontFormatting(a);
    this.g(e);
  }
  static _o(a, b, c) {
    if ((c & 32640) != 0) {
      if ((c & 128) != 0 && nullableNotEquals(a._bold$i, b._bold$i)) {
        return true;
      }
      if ((c & 256) != 0 && WorkbookColorInfo.l_op_Inequality(a.colorInfo, b.colorInfo)) {
        return true;
      }
      if ((c & 512) != 0 && a.height != b.height) {
        return true;
      }
      if ((c & 1024) != 0 && nullableNotEquals(a._italic$i, b._italic$i)) {
        return true;
      }
      if ((c & 2048) != 0 && a.name != b.name) {
        return true;
      }
      if ((c & 4096) != 0 && nullableNotEquals(a._strikeout$i, b._strikeout$i)) {
        return true;
      }
      if ((c & 8192) != 0 && a.superscriptSubscriptStyle != b.superscriptSubscriptStyle) {
        return true;
      }
      if ((c & 16384) != 0 && a.underlineStyle != b.underlineStyle) {
        return true;
      }
    }
    return false;
  }
  _u($tValue, a, b, c, d) {
    let e = c(this);
    if (EqualityComparer$1.defaultEqualityComparerValue($tValue).equalsC(a, e)) {
      return;
    }
    let f = this.a();
    d(this.c, a);
    if (this._n != null) {
      this._n(b);
    }
    this.g(f);
  }
  _p() {
    if (nullableNotEquals(this._bold$i, null)) {
      return true;
    }
    if (WorkbookColorInfo.l_op_Inequality(this.colorInfo, null)) {
      return true;
    }
    if (this.height >= 0) {
      return true;
    }
    if (nullableNotEquals(this._italic$i, null)) {
      return true;
    }
    if (stringIsNullOrEmpty(this.name) == false) {
      return true;
    }
    if (nullableNotEquals(this._strikeout$i, null)) {
      return true;
    }
    if (this.superscriptSubscriptStyle != -1) {
      return true;
    }
    if (this.underlineStyle != -1) {
      return true;
    }
    return false;
  }
  get bold() {
    return unwrapNullable(this._bold$i);
  }
  set bold(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._bold$i = arguments[0];
  }
  get _bold$i() {
    return this.d._bold$i;
  }
  set _bold$i(a) {
    this._u(Nullable$1.$.specialize(Boolean_$type), a, 0, (b) => b._bold$i, (b, c) => b._bold$i = c);
  }
  get colorInfo() {
    return this.d.colorInfo;
  }
  set colorInfo(a) {
    this._u(WorkbookColorInfo.$, a, 1, (b) => b.colorInfo, (b, c) => b.colorInfo = c);
  }
  get height() {
    return this.d.height;
  }
  set height(a) {
    this._u(Number_$type, a, 2, (b) => b.height, (b, c) => b.height = c);
  }
  get italic() {
    return unwrapNullable(this._italic$i);
  }
  set italic(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._italic$i = arguments[0];
  }
  get _italic$i() {
    return this.d._italic$i;
  }
  set _italic$i(a) {
    this._u(Nullable$1.$.specialize(Boolean_$type), a, 3, (b) => b._italic$i, (b, c) => b._italic$i = c);
  }
  get name() {
    return this.d.name;
  }
  set name(a) {
    this._u(String_$type, a, 4, (b) => b.name, (b, c) => b.name = c);
  }
  get strikeout() {
    return unwrapNullable(this._strikeout$i);
  }
  set strikeout(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._strikeout$i = arguments[0];
  }
  get _strikeout$i() {
    return this.d._strikeout$i;
  }
  set _strikeout$i(a) {
    this._u(Nullable$1.$.specialize(Boolean_$type), a, 5, (b) => b._strikeout$i, (b, c) => b._strikeout$i = c);
  }
  get superscriptSubscriptStyle() {
    return this.d.superscriptSubscriptStyle;
  }
  set superscriptSubscriptStyle(a) {
    this._u(FontSuperscriptSubscriptStyle_$type, a, 6, (b) => b.superscriptSubscriptStyle, (b, c) => b.superscriptSubscriptStyle = c);
  }
  get underlineStyle() {
    return this.d.underlineStyle;
  }
  set underlineStyle(a) {
    this._u(FontUnderlineStyle_$type, a, 7, (b) => b.underlineStyle, (b, c) => b.underlineStyle = c);
  }
  get _r() {
    return this._q;
  }
  set _r(a) {
    this._q = a;
  }
}
WorkbookFontProxy.$t = markType(WorkbookFontProxy, 'WorkbookFontProxy', GenericCacheElementProxy$1.$.specialize(WorkbookFontData.$), [IWorkbookFont_$type]);
/**
 * @hidden
 */
export class WorkbookFormatCollection extends Base {
  constructor(a) {
    super();
    this.i = null;
    this.j = null;
    this.s = 0;
    this.o = null;
    this.p = null;
    this.l = null;
    this.b = null;
    this.aa = null;
    this.ab = null;
    this.ag = null;
    this.f = false;
    this.n = null;
    this.g = null;
    this.v = 164;
    this.y = null;
    this.b = a;
    this.j = new Dictionary$2(Number_$type, String_$type, 0);
    this.i = new Dictionary$2(String_$type, Number_$type, 2, StringUtilities.d);
    this.g = new Dictionary$2(Number_$type, List$1.$.specialize(Number_$type), 0);
    this.at();
  }
  q(a) {
    this.at();
    let b;
    if (((() => { let c = this.i.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    let c = WorkbookFormatCollection.af(this.b._e6);
    if (stringEquals1(c, a, StringUtilities.f)) {
      return 14;
    }
    else if (stringEquals1(c + " h:mm", a, StringUtilities.f)) {
      return 22;
    }
    while (this.j.containsKey(this.v)) {
      this.v++;
    }
    b = this.v;
    this.am(b, a);
    return b;
  }
  am(a, b) {
    this.an(a, b, false);
  }
  an(a, b, c) {
    this.ao(a, b, c, true);
  }
  ao(a, b, c, d) {
    this.at();
    if (a == 14 || a == 22) {
      return;
    }
    let e = true;
    if (a >= 164 && this.i.containsKey(b)) {
      let f = this.i.item(b);
      if (f == 14 || f == 22) {
        e = false;
      }
    }
    let g;
    if (((() => { let h = this.j.tryGetValue(a, g); g = h.p1; return h.ret; })())) {
      if (StringUtilities.e.compare(b, g) == 0) {
        return;
      }
      this.j.removeItem(a);
      if (e) {
        this.i.removeItem(g);
      }
    }
    if (a >= 164) {
      this.s++;
    }
    if (c) {
      this.i.removeItem(b);
    }
    if (e) {
      this.i.addItem(b, a);
    }
    this.j.addItem(a, b);
    if (d) {
      this.aq(a, b);
    }
  }
  ap(a, b) {
    this.an(a, this.z(this.b, a, b, Workbook._fa, this.b._e6, true), true);
  }
  aq(a, b) {
    this.g.removeItem(a);
    let c = this.b._e6.numberFormat;
    let d = c.currencySymbol;
    if (stringIsNullOrEmpty(d)) {
      return;
    }
    let e = null;
    let f = 0;
    for (let g = 0; g < b.length; g++) {
      switch (b.charAt(g)) {
        case '\\':
          g++;
          break;
        case '[':
          {
            for (; g < b.length; g++) {
              if (b.charAt(g) == ']') {
                break;
              }
            }
            break;
          }
        case '\"':
          let h = g + 1;
          for (g++; g < b.length; g++) {
            if (b.charAt(g) == '\\') {
              g++;
            }
            else if (b.charAt(g) == '\"') {
              let i = b.substr(h, g - h);
              if (i != d) {
                if (e == null) {
                  e = new List$1(Number_$type, 0);
                }
                e.add(f);
              }
              f++;
              break;
            }
          }
          break;
      }
    }
    if (e != null && e.count != 0) {
      this.g.item(a, e);
    }
  }
  z(a, b, c, d, e, f) {
    let g = d.numberFormat;
    let h = g.numberDecimalSeparator;
    let i = g.numberGroupSeparator;
    let j = g.currencySymbol;
    if (stringIsNullOrEmpty(h)) {
      h = "\0";
    }
    if (stringIsNullOrEmpty(i)) {
      i = "\0";
    }
    if (stringIsNullOrEmpty(j)) {
      j = "\0";
    }
    let k = d.dateTimeFormat;
    let l = ExcelUtils.ec(k);
    if (stringIsNullOrEmpty(l)) {
      l = "\0";
    }
    if (indexOfAny(c, [h.charAt(0), i.charAt(0), j.charAt(0), l.charAt(0)]) < 0) {
      return c;
    }
    let m = new ValueFormatter(0, a, c, d);
    let n = 0;
    let o = false;
    let p = 0;
    let q = 0;
    let r;
    let s = this.g.tryGetValue(b, r);
    r = s.p1;
    let t = new StringBuilder(0);
    for (let u = 0; u < c.length; u++) {
      let v = c.charAt(u);
      switch (v) {
        case ';':
          if (o == false) {
            n++;
          }
          t.h(v);
          break;
        case '\\':
        case '_':
        case '*':
          {
            t.h(v);
            if (o == false) {
              u++;
              if (u < c.length) {
                t.h(c.charAt(u));
              }
            }
            break;
          }
        case '[':
          {
            if (o) {
              t.h(v);
            }
            else {
              for (; u < c.length; u++) {
                v = c.charAt(u);
                t.h(v);
                if (v == ']') {
                  break;
                }
              }
            }
            break;
          }
        case '\"':
          if (o) {
            let w = t.f(q, t.c - q);
            if (f == false && w == j) {
              if (r == null || r.contains(p) == false) {
                t.c = q;
                t.l(e.numberFormat.currencySymbol);
              }
            }
            o = false;
            p++;
          }
          else {
            o = true;
            q = t.c + 1;
          }
          t.h(v);
          break;
        default:
          {
            if (o == false) {
              let x = m.f(n);
              if (x == 2) {
                if (stringCompare3(c, u, h, 0, h.length) == 0) {
                  t.l(e.numberFormat.numberDecimalSeparator);
                  u += h.length - 1;
                  break;
                }
                if (stringCompare3(c, u, i, 0, i.length) == 0) {
                  t.l(e.numberFormat.numberGroupSeparator);
                  u += i.length - 1;
                  break;
                }
              }
              else if (x == 1) {
                if (stringCompare3(c, u, l, 0, l.length) == 0) {
                  if (l != "/" || !WorkbookFormatCollection.d(c, u)) {
                    t.l(ExcelUtils.ec(e.dateTimeFormat));
                    u += l.length - 1;
                    break;
                  }
                }
              }
            }
            t.h(v);
            break;
          }
      }
    }
    return t.toString();
  }
  static d(a, b) {
    if (b > 0 && b < a.length - 1) {
      if ((a.charAt(b - 1) == 'a' || a.charAt(b - 1) == 'A') && (a.charAt(b + 1) == 'p' || a.charAt(b + 1) == 'P')) {
        return true;
      }
      if (b > 1 && b < a.length - 2) {
        if ((a.charAt(b - 2) == 'a' || a.charAt(b - 2) == 'A') && (a.charAt(b - 1) == 'm' || a.charAt(b - 1) == 'M') && (a.charAt(b + 1) == 'p' || a.charAt(b + 1) == 'P') && (a.charAt(b + 2) == 'm' || a.charAt(b + 2) == 'M')) {
          return true;
        }
        if (a.charAt(b - 2) == '' && a.charAt(b - 1) == '' && a.charAt(b + 1) == '' && a.charAt(b + 2) == '') {
          return true;
        }
      }
    }
    return false;
  }
  static aj(a) {
    WorkbookFormatCollection.ar();
    let b;
    if (((() => { let c = WorkbookFormatCollection.h.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    return a;
  }
  *_m() {
    this.at();
    for (let a of fromEnum(this.j)) {
      let b = a.key;
      if (this.e(b)) {
        continue;
      }
      yield b;
    }
  }
  m() {
    return toEnum(() => this._m());
  }
  ad(a) {
    let b = this.item(a);
    if (Workbook._fa == this.n) {
      return b;
    }
    return this.z(this.b, a, b, this.n, Workbook._fa, true);
  }
  static af(a) {
    return stringReplace(a.dateTimeFormat.shortDatePattern, "M", "m");
  }
  static ae(a) {
    let b = WorkbookFormatCollection.af(a);
    return b + " h:mm";
  }
  a(a) {
    if (this.l == null) {
      this.l = new Dictionary$2(Number_$type, ValueFormatter.$, 0);
    }
    let b = this.b._e6;
    if (this.o != b || this.p != this.b._editingCulture$i) {
      this.l.clear();
      this.o = b;
      this.p = this.b._editingCulture$i;
    }
    let c;
    if (((() => { let d = this.l.tryGetValue(a, c); c = d.p1; return d.ret; })()) == false) {
      let d = (((e) => e != null ? e : "General")(this.item(a)));
      c = new ValueFormatter(0, this.b, d, b);
      this.l.item(a, c);
    }
    return c;
  }
  c(a) {
    return a >= 164 && this.j.containsKey(a);
  }
  static ar() {
    if (WorkbookFormatCollection.h != null) {
      return;
    }
    WorkbookFormatCollection.h = new Dictionary$2(Number_$type, Number_$type, 0);
    WorkbookFormatCollection.k = new Dictionary$2(Number_$type, Number_$type, 0);
    WorkbookFormatCollection.as(0, 0);
    WorkbookFormatCollection.as(1, 1);
    WorkbookFormatCollection.as(2, 2);
    WorkbookFormatCollection.as(3, 3);
    WorkbookFormatCollection.as(4, 4);
    WorkbookFormatCollection.as(5, 9);
    WorkbookFormatCollection.as(6, 10);
    WorkbookFormatCollection.as(7, 11);
    WorkbookFormatCollection.as(8, 12);
    WorkbookFormatCollection.as(9, 13);
    WorkbookFormatCollection.as(10, 14);
    WorkbookFormatCollection.as(11, 15);
    WorkbookFormatCollection.as(12, 17);
    WorkbookFormatCollection.as(13, 18);
    WorkbookFormatCollection.as(14, 19);
    WorkbookFormatCollection.as(15, 20);
    WorkbookFormatCollection.as(16, 21);
    WorkbookFormatCollection.as(17, 22);
    WorkbookFormatCollection.as(18, 23);
    WorkbookFormatCollection.as(19, 24);
    WorkbookFormatCollection.as(20, 25);
    WorkbookFormatCollection.as(21, 26);
    WorkbookFormatCollection.as(22, 27);
    WorkbookFormatCollection.as(37, 5);
    WorkbookFormatCollection.as(38, 6);
    WorkbookFormatCollection.as(39, 7);
    WorkbookFormatCollection.as(40, 8);
    WorkbookFormatCollection.as(41, 33);
    WorkbookFormatCollection.as(42, 32);
    WorkbookFormatCollection.as(43, 35);
    WorkbookFormatCollection.as(44, 34);
    WorkbookFormatCollection.as(45, 28);
    WorkbookFormatCollection.as(46, 31);
    WorkbookFormatCollection.as(47, 29);
    WorkbookFormatCollection.as(48, 16);
    WorkbookFormatCollection.as(49, 30);
  }
  static as(a, b) {
    WorkbookFormatCollection.h.addItem(b, a);
    WorkbookFormatCollection.k.addItem(a, b);
  }
  e(a) {
    if (0 <= a && a <= 22) {
      return true;
    }
    if (37 <= a && a <= 49) {
      return true;
    }
    return false;
  }
  static ak(a) {
    WorkbookFormatCollection.ar();
    let b;
    if (((() => { let c = WorkbookFormatCollection.k.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    return a;
  }
  at() {
    if (this.f) {
      return;
    }
    try {
      this.f = true;
      let a = this.b._e6.numberFormat;
      let b = a.numberDecimalSeparator;
      let c = a.numberGroupSeparator;
      let d = a.currencySymbol;
      if (d == this.aa && b == this.ab && c == this.ag) {
        return;
      }
      this.aa = d;
      this.ab = b;
      this.ag = c;
      let e = this.n || CultureInfo.invariantCulture;
      this.n = this.b._e6;
      let f = new List$1(KeyValuePair$2.$.specialize(Number_$type, String_$type), 1, this.j);
      this.i.clear();
      this.j.clear();
      this.am(0, "General");
      this.am(1, "0");
      this.am(2, stringFormat("0{0}00", this.ab));
      this.am(3, stringFormat("#{0}##0", this.ag));
      this.am(4, stringFormat("#{0}##0{1}00", this.ag, this.ab));
      this.am(5, stringFormat("\"{0}\"#{1}##0_);\\(\"{0}\"#{1}##0\\)", this.aa, this.ag));
      this.am(6, stringFormat("\"{0}\"#{1}##0_);[Red]\\(\"{0}\"#{1}##0\\)", this.aa, this.ag));
      this.am(7, stringFormat("\"{0}\"#{1}##0{2}00_);\\(\"{0}\"#{1}##0{2}00\\)", this.aa, this.ag, this.ab));
      this.am(8, stringFormat("\"{0}\"#{1}##0{2}00_);[Red]\\(\"{0}\"#{1}##0{2}00\\)", this.aa, this.ag, this.ab));
      this.am(9, "0%");
      this.am(10, stringFormat("0{0}00%", this.ab));
      this.am(11, stringFormat("0{0}00E+00", this.ab));
      this.am(12, "# ?/?");
      this.am(13, "# ??/??");
      this.am(15, "d-mmm-yy");
      this.am(16, "d-mmm");
      this.am(17, "mmm-yy");
      this.am(18, "h:mm AM/PM");
      this.am(19, "h:mm:ss AM/PM");
      this.am(20, "h:mm");
      this.am(21, "h:mm:ss");
      this.am(37, stringFormat("#{0}##0_);(#{0}##0)", this.ag));
      this.am(38, stringFormat("#{0}##0_);[Red](#{0}##0)", this.ag));
      this.am(39, stringFormat("#{0}##0{1}00_);(#{0}##0{1}00)", this.ag, this.ab));
      this.am(40, stringFormat("#{0}##0{1}00_);[Red](#{0}##0{1}00)", this.ag, this.ab));
      this.am(41, stringFormat("_(* #{0}##0_);_(* \\(#{0}##0\\);_(* \"-\"_);_(@_)", this.ag));
      this.am(42, stringFormat("_(\"{0}\"* #{1}##0_);_(\"{0}\"* \\(#{1}##0\\);_(\"{0}\"* \"-\"_);_(@_)", this.aa, this.ag));
      this.am(43, stringFormat("_(* #{0}##0{1}00_);_(* \\(#{0}##0{1}00\\);_(* \"-\"??_);_(@_)", this.ag, this.ab));
      this.am(44, stringFormat("_(\"{0}\"* #{1}##0{2}00_);_(\"{0}\"* \\(#{1}##0{2}00\\);_(\"{0}\"* \"-\"??_);_(@_)", this.aa, this.ag, this.ab));
      this.am(45, "mm:ss");
      this.am(46, "[h]:mm:ss");
      this.am(47, stringFormat("mm:ss{0}0", this.ab));
      this.am(48, stringFormat("##0{0}0E+0", this.ab));
      this.am(49, "@");
      this.al(this.b._e6);
      this.y = null;
      this.au();
      for (let g of fromEnum(f)) {
        if (this.j.containsKey(g.key)) {
          continue;
        }
        this.ao(g.key, this.z(this.b, g.key, g.value, e, this.n, false), true, false);
      }
    }
    finally {
      this.f = false;
    }
    this.au();
  }
  au() {
    let a = this.b._e6;
    let b = a.dateTimeFormat.shortDatePattern;
    if (b == this.y) {
      return;
    }
    this.y = b;
    let c = WorkbookFormatCollection.af(a);
    let d = WorkbookFormatCollection.ae(a);
    this.i.item(c, 14);
    this.i.item(d, 22);
    this.j.item(14, c);
    this.j.item(22, d);
  }
  get r() {
    return this.s;
  }
  item(a) {
    if (a < 0) {
      return null;
    }
    this.at();
    let b;
    if (((() => { let c = this.j.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    if (27 <= a && a <= 36) {
      if (a == 32 || a == 33) {
        return "h:mm:ss";
      }
      return "m/d/yyyy";
    }
    if (50 <= a && a <= 81) {
      return "m/d/yyyy";
    }
    return null;
  }
  al(a) {
    switch (a.name) {
      case "zh-TW":
        {
          this.an(27, "[$-404]e/m/d", true);
          this.an(28, "[$-404]e\"\"m\"\"d\"\"", true);
          this.an(29, "[$-404]e\"\"m\"\"d\"\"", true);
          this.an(30, "m/d/yy", true);
          this.an(31, "yyyy\"\"m\"\"d\"\"", true);
          this.an(32, "hh\"\"mm\"\"", true);
          this.an(33, "hh\"\"mm\"\"ss\"\"", true);
          this.an(34, "/hh\"\"mm\"\"", true);
          this.an(35, "/hh\"\"mm\"\"ss\"\"", true);
          this.an(36, "[$-404]e/m/d", true);
          this.an(50, "[$-404]e/m/d", true);
          this.an(51, "[$-404]e\"\"m\"\"d\"\"", true);
          this.an(52, "/hh\"\"mm\"\"", true);
          this.an(53, "/hh\"\"mm\"\"ss\"\"", true);
          this.an(54, "[$-404]e\"\"m\"\"d\"\"", true);
          this.an(55, "/hh\"\"mm\"\"", true);
          this.an(56, "/hh\"\"mm\"\"ss\"\"", true);
          this.an(57, "[$-404]e/m/d", true);
          this.an(58, "[$-404]e\"\"m\"\"d\"\"", true);
        }
        break;
      case "zh-CN":
        {
          this.an(27, "yyyy\"\"m\"\"", true);
          this.an(28, "m\"\"d\"\"", true);
          this.an(29, "m\"\"d\"\"", true);
          this.an(30, "m-d-yy", true);
          this.an(31, "yyyy\"\"m\"\"d\"\"", true);
          this.an(32, "h\"\"mm\"\"", true);
          this.an(33, "h\"\"mm\"\"ss\"\"", true);
          this.an(34, "/h\"\"mm\"\"", true);
          this.an(35, "/h\"\"mm\"\"ss\"\"", true);
          this.an(36, "yyyy\"\"m\"\"", true);
          this.an(50, "yyyy\"\"m\"\"", true);
          this.an(51, "m\"\"d\"\"", true);
          this.an(52, "yyyy\"\"m\"\"", true);
          this.an(53, "m\"\"d\"\"", true);
          this.an(54, "m\"\"d\"\"", true);
          this.an(55, "/h\"\"mm\"\"", true);
          this.an(56, "/h\"\"mm\"\"ss\"\"", true);
          this.an(57, "yyyy\"\"m\"\"", true);
          this.an(58, "m\"\"d\"\"", true);
        }
        break;
      case "ja-JP":
        {
          this.an(27, "[$-411]ge.m.d", true);
          this.an(28, "[$-411]ggge\"\"m\"\"d\"\"", true);
          this.an(29, "[$-411]ggge\"\"m\"\"d\"\"", true);
          this.an(30, "m/d/yy", true);
          this.an(31, "yyyy\"\"m\"\"d\"\"", true);
          this.an(32, "h\"\"mm\"\"", true);
          this.an(33, "h\"\"mm\"\"ss\"\"", true);
          this.an(34, "yyyy\"\"m\"\"", true);
          this.an(35, "m\"\"d\"\"", true);
          this.an(36, "[$-411]ge.m.d", true);
          this.an(50, "[$-411]ge.m.d", true);
          this.an(51, "[$-411]ggge\"\"m\"\"d\"\"", true);
          this.an(52, "yyyy\"\"m\"\"", true);
          this.an(53, "m\"\"d\"\"", true);
          this.an(54, "[$-411]ggge\"\"m\"\"d\"\"", true);
          this.an(55, "yyyy\"\"m\"\"", true);
          this.an(56, "m\"\"d\"\"", true);
          this.an(57, "[$-411]ge.m.d", true);
          this.an(58, "[$-411]ggge\"\"m\"\"d\"\"", true);
        }
        break;
      case "ko-KR":
        {
          this.an(27, "yyyy\"\" mm\"\" dd\"\"", true);
          this.an(28, "mm-dd", true);
          this.an(29, "mm-dd", true);
          this.an(30, "mm-dd-yy", true);
          this.an(31, "yyyy\"\" mm\"\" dd\"\"", true);
          this.an(32, "h\"\" mm\"\"", true);
          this.an(33, "h\"\" mm\"\" ss\"\"", true);
          this.an(34, "yyyy-mm-dd", true);
          this.an(35, "yyyy-mm-dd", true);
          this.an(36, "yyyy\"\" mm\"\" dd\"\"", true);
          this.an(50, "yyyy\"\" mm\"\" dd\"\"", true);
          this.an(51, "mm-dd", true);
          this.an(52, "yyyy-mm-dd", true);
          this.an(53, "yyyy-mm-dd", true);
          this.an(54, "mm-dd", true);
          this.an(55, "yyyy-mm-dd", true);
          this.an(56, "yyyy-mm-dd", true);
          this.an(57, "yyyy\"\" mm\"\" dd\"\"", true);
          this.an(58, "mm-dd", true);
        }
        break;
      case "th-TH":
        {
          this.an(59, "t0", true);
          this.an(60, stringFormat("t0{0}00", this.ab), true);
          this.an(61, stringFormat("t#{0}##0", this.ag), true);
          this.an(62, stringFormat("t#{0}##0{1}00", this.ag, this.ab), true);
          this.an(67, "t0%", true);
          this.an(68, stringFormat("t0{0}00%", this.ab), true);
          this.an(69, "t# ?/?", true);
          this.an(70, "t# ??/??", true);
          this.an(71, "//", true);
          this.an(72, "--", true);
          this.an(73, "-", true);
          this.an(74, "-", true);
          this.an(75, ":", true);
          this.an(76, "::", true);
          this.an(77, "// :", true);
          this.an(78, ":", true);
          this.an(79, "[]::", true);
          this.an(80, stringFormat(":{0}0", this.ab), true);
          this.an(81, "d/m/bb", true);
        }
        break;
    }
  }
}
WorkbookFormatCollection.$t = markType(WorkbookFormatCollection, 'WorkbookFormatCollection');
WorkbookFormatCollection.h = null;
WorkbookFormatCollection.k = null;
/**
 * #elif WINRT#elif TINYCLR
 * Contains the options related to saving a workbook to a file or stream.
 * @see [[Workbook.save]]
 */
export class WorkbookSaveOptions extends WorkbookOptionsBase {
  constructor() {
    super(null);
    this._f = null;
    this._type = null;
  }
  /**
   * @hidden
   */
  get _g() {
    return this._f;
  }
  /**
   * @hidden
   */
  set _g(a) {
    this._f = a;
  }
  /**
   * Gets or sets the format in which to save the workbook: "base64", "string", "uint8array", "arraybuffer", "blob"
   */
  get type() {
    return this._type;
  }
  /**
   * Gets or sets the format in which to save the workbook: "base64", "string", "uint8array", "arraybuffer", "blob"
   */
  set type(a) {
    this._type = a;
  }
  /**
   * @hidden
   */
  static _h(a) {
    if (a != null) {
      return a._f || DefaultWorkbookSaveFilter.f;
    }
    return DefaultWorkbookSaveFilter.f;
  }
}
WorkbookSaveOptions.$t = markType(WorkbookSaveOptions, 'WorkbookSaveOptions', WorkbookOptionsBase.$);
/**
 * @hidden
 */
export class WorkbookSaveFilter extends Base {
  a(a) {
    return a._mergedCellsRegions$i;
  }
}
WorkbookSaveFilter.$t = markType(WorkbookSaveFilter, 'WorkbookSaveFilter');
/**
 * @hidden
 */
export class DefaultWorkbookSaveFilter extends WorkbookSaveFilter {
  constructor() {
    super();
  }
  d(a) {
    return a._rows$i._count;
  }
  e(a) {
    return a._rows$i.maxCount;
  }
  b(a, b) {
    if (b) {
      return a._rows$i._l();
    }
    return a._rows$i;
  }
  c(a) {
    return a._sheets$i;
  }
}
DefaultWorkbookSaveFilter.$t = markType(DefaultWorkbookSaveFilter, 'DefaultWorkbookSaveFilter', WorkbookSaveFilter.$);
DefaultWorkbookSaveFilter.f = new DefaultWorkbookSaveFilter();
/**
 * @hidden
 */
export class WorkbookStyle_StyleChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
        }
        break;
    }
  }
  get workbook() {
    return this.a._g;
  }
  get sheet() {
    return null;
  }
  get source() {
    return this.a;
  }
}
WorkbookStyle_StyleChangeContext.$t = markStruct(WorkbookStyle_StyleChangeContext, 'WorkbookStyle_StyleChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a complex format which can be applied to a cell's format.
 * <p class="body">
 * When a style is applied to a cell by setting its CellFormat.Style property, the cell's format will pick up subsequent
 * changes to the format properties set by the style when it was applied. This will continue to happen until those format
 * properties are set to other values on the cell format.
 * </p>
 * @see [[IWorksheetCellFormat.style]]
 * @see [[Workbook.styles]]
 */
export class WorkbookStyle extends Base {
  constructor(a, b) {
    super();
    this._j = false;
    this._q = 0;
    this._h = null;
    this._f = null;
    this._f = a;
    let c = typeCast(WorksheetCellFormatData.$, b);
    if (c == null) {
      let d = typeCast(WorksheetCellFormatProxy.$, b);
      if (d != null) {
        c = d.d;
      }
      else {
        c = a._ca._p;
        c.setFormatting(b);
      }
    }
    if (c.f != 0 || this._f != c.v) {
      c = c._bv(a);
    }
    this._h = c;
    this._h._b1 = 1;
    this._h._b3 = runOn(this, this._w);
  }
  static staticInit() {
    WorkbookStyle._a = WorkbookStyle._b();
  }
  /**
   * @hidden
   */
  _v() {
    this._h.k();
  }
  /**
   * @hidden
   */
  _w(a) {
    let b = this._g;
    if (b != null) {
      if ((a & 8) != 0) {
        if (this._n) {
          let c;
          let d;
          let e = ExcelUtils.h(this.styleFormat.topBorderStyle);
          let f = ExcelUtils.h(this.styleFormat.bottomBorderStyle);
          if (e == 2 || f == 2) {
            c = true;
            d = true;
          }
          else if (e == 1 || f == 1) {
            c = false;
            d = true;
          }
          else {
            c = false;
            d = false;
          }
          for (let g of fromEnum(b._worksheets$i)) {
            g._dt = c;
            g._ds = d;
          }
        }
        for (let h of fromEnum(b._worksheets$i)) {
          for (let i of fromEnum(h._rows$i)) {
            i._di(false);
          }
        }
      }
      let j = WorkbookStyle._a[0];
      j.e(WorkbookStyle_StyleChangeContext.$, WorkbookStyle.$, new WorkbookStyle_StyleChangeContext(1, this), this, this);
    }
  }
  /**
   * @hidden
   */
  _x() {
    this._q++;
  }
  /**
   * @hidden
   */
  _y() {
    this._q--;
  }
  /**
   * @hidden
   */
  _z() {
    this._h.j();
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = false, f = false, g = 0) {
    return new ChangeInfo$2(WorkbookStyle_StyleChangeContext.$, $tValue, a, 89, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, WorkbookStyle._c(WorkbookStyle.$, "CellFormatValueChanged", (b) => typeCast(WorkbookStyle.$, b.source), null, null));
    return a;
  }
  /**
   * Gets the cell format which applies to the workbook style.
   * The cell format which applies to the workbook style.
   */
  get styleFormat() {
    return this._i;
  }
  /**
   * @hidden
   */
  get__k() {
    return false;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * @hidden
   */
  get _m() {
    return this._j;
  }
  /**
   * @hidden
   */
  set _m(a) {
    this._j = a;
  }
  /**
   * @hidden
   */
  get__o() {
    return this._q > 0;
  }
  /**
   * @hidden
   */
  get _o() {
    return this.get__o();
  }
  /**
   * @hidden
   */
  get__p() {
    return this._q > 0;
  }
  /**
   * @hidden
   */
  get _p() {
    return this.get__p();
  }
  /**
   * @hidden
   */
  get _i() {
    return this._h;
  }
  /**
   * @hidden
   */
  get _g() {
    return this._f;
  }
}
WorkbookStyle.$t = markType(WorkbookStyle, 'WorkbookStyle');
/**
 * @hidden
 */
WorkbookStyle._s = 255;
/**
 * @hidden
 */
WorkbookStyle._r = 0;
/**
 * @hidden
 */
WorkbookStyle._t = 1;
/**
 * @hidden
 */
WorkbookStyle._a = null;
/**
 * @hidden
 */
export class WorkbookBuiltInStyle extends WorkbookStyle {
  constructor(a, b, c, d) {
    super(a, b);
    this._af = false;
    this._ae = null;
    this._aj = 0;
    this._ab = 0;
    this._ab = c;
    if (this._ai) {
      this._aj = d;
    }
    else {
      this._aj = 255;
    }
    this._ae = this._i._bu();
  }
  compareTo(a) {
    if (this._ai && a._ai) {
      let b = this._aj - a._aj;
      if (b != 0) {
        return b;
      }
    }
    return this._ab - a._ab;
  }
  get__e() {
    switch (this._ac) {
      case 27:
      case 26:
      case 28:
      case 0: return 1;
      case 22:
      case 23:
      case 12:
      case 13:
      case 14:
      case 53:
      case 9:
      case 8:
      case 20:
      case 24:
      case 10:
      case 21:
      case 11: return 2;
      case 16:
      case 17:
      case 18:
      case 19:
      case 15:
      case 25: return 3;
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 2:
      case 1: return 4;
      case 3:
      case 4:
      case 5:
      case 6:
      case 7: return 5;
      default: return 0;
    }
  }
  get _e() {
    return this.get__e();
  }
  get__k() {
    switch (this._ac) {
      case 0:
      case 1:
      case 2:
      case 8:
      case 9: return true;
    }
    return false;
  }
  get_isBuiltIn() {
    return true;
  }
  get isBuiltIn() {
    return this.get_isBuiltIn();
  }
  get__n() {
    return this._ab == 0;
  }
  get _n() {
    return this.get__n();
  }
  get_name() {
    switch (this._ac) {
      case 29:
      case 33:
      case 37:
      case 41:
      case 45:
      case 49:
      case 27:
      case 22:
      case 3:
      case 4:
      case 26:
      case 8:
      case 20:
      case 28:
      case 0:
      case 10:
      case 21:
      case 5:
      case 15:
      case 25: return EnumUtil.getName(BuiltInStyleType_$type, this._ac);
      case 30:
      case 31:
      case 32:
        {
          let a = this._ac - 29;
          return stringFormat("{0}% - Accent1", a * 20);
        }
      case 34:
      case 35:
      case 36:
        {
          let b = this._ac - 33;
          return stringFormat("{0}% - Accent2", b * 20);
        }
      case 38:
      case 39:
      case 40:
        {
          let c = this._ac - 37;
          return stringFormat("{0}% - Accent3", c * 20);
        }
      case 42:
      case 43:
      case 44:
        {
          let d = this._ac - 41;
          return stringFormat("{0}% - Accent4", d * 20);
        }
      case 46:
      case 47:
      case 48:
        {
          let e = this._ac - 45;
          return stringFormat("{0}% - Accent5", e * 20);
        }
      case 50:
      case 51:
      case 52:
        {
          let f = this._ac - 49;
          return stringFormat("{0}% - Accent6", f * 20);
        }
      case 23: return "Check Cell";
      case 2: return "ColLevel_" + this._ak;
      case 6: return "Comma [0]";
      case 7: return "Currency [0]";
      case 12: return "Emphasis 1";
      case 13: return "Emphasis 2";
      case 14: return "Emphasis 3";
      case 53: return "Explanatory Text";
      case 9: return "Followed Hyperlink";
      case 16: return "Heading 1";
      case 17: return "Heading 2";
      case 18: return "Heading 3";
      case 19: return "Heading 4";
      case 24: return "Linked Cell";
      case 1: return "RowLevel_" + this._ak;
      case 11: return "Warning Text";
      default: return EnumUtil.getName(BuiltInStyleType_$type, this._ac);
    }
  }
  set_name(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_BuiltInStyleNameCannotBeChanged"));
  }
  get name() {
    return this.get_name();
  }
  set name(a) {
    this.set_name(a);
  }
  _w(a) {
    super._w(a);
    this._af = (this._i.equals(this._ae) == false);
    let b = this._g;
    if (b != null && (a & 4) != 0 && this._n) {
      b._hy();
    }
  }
  reset() {
    this._i.setFormatting(this._ae);
  }
  get__o() {
    if (super.get__o() || this._ah) {
      return true;
    }
    switch (this._ac) {
      case 3:
      case 6:
      case 4:
      case 7:
      case 0:
      case 5: return true;
    }
    if (this._ag == false) {
      return true;
    }
    return false;
  }
  get__p() {
    return super.get__p() || this._n || this._ah;
  }
  _ad(a) {
    return new WorkbookBuiltInStyle(a, this._i, this._ac, this._ak);
  }
  get _ag() {
    switch (this._ac) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9: return true;
    }
    return false;
  }
  get _ah() {
    return this._af;
  }
  set _ah(a) {
    this._af = a;
  }
  get _ak() {
    return this._aj;
  }
  get _ac() {
    return this._ab;
  }
  get _ai() {
    return this._ac == 2 || this._ac == 1;
  }
}
WorkbookBuiltInStyle.$t = markType(WorkbookBuiltInStyle, 'WorkbookBuiltInStyle', WorkbookStyle.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export class WorkbookUserDefinedStyle extends WorkbookStyle {
  constructor(a, b, c) {
    super(a, b);
    this._ab = null;
    this._ab = c;
  }
  get__e() {
    return 0;
  }
  get _e() {
    return this.get__e();
  }
  get_isBuiltIn() {
    return false;
  }
  get isBuiltIn() {
    return this.get_isBuiltIn();
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
  get_name() {
    return this._ab;
  }
  set_name(a) {
    if (this._ab == a) {
      return;
    }
    if (StringUtilities.c(this._ab, a, this._g._e6, 1) != 0) {
      this._g._styles$i._ah(a, "value");
    }
    let b = this._ab;
    this._ab = a;
    this._g._styles$i._ac(this, b);
  }
  get name() {
    return this.get_name();
  }
  set name(a) {
    this.set_name(a);
  }
  reset() {
    this._i.formatOptions = 0;
  }
  get__o() {
    return true;
  }
  get__p() {
    return true;
  }
}
WorkbookUserDefinedStyle.$t = markType(WorkbookUserDefinedStyle, 'WorkbookUserDefinedStyle', WorkbookStyle.$);
/**
 * @hidden
 */
export class BuiltInStyleInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
}
BuiltInStyleInfo.$t = markStruct(BuiltInStyleInfo, 'BuiltInStyleInfo');
/**
 * Introduce InvalidEnumArgumentException class to Silverlight
 */
export class InvalidEnumArgumentException extends ArgumentException {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      if (typeof arguments[1] === 'string') {
        a = 1;
      }
      else if (typeCast(BaseError.$, arguments[1]) !== null) {
        a = 0;
      }
      else if (arguments[1] == null) {
        a = 0;
      }
    }
    else if (arguments.length === 3) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let message = _rest[0];
          let innerException = _rest[1];
          super(3, message, innerException);
          message = (message !== void 0 ? message : null);
          innerException = (innerException !== void 0 ? innerException : null);
        }
        break;
      case 1:
        {
          let message = _rest[0];
          let paramName = _rest[1];
          super(2, message, paramName);
        }
        break;
      case 2:
        {
          let argumentName = _rest[0];
          let invalidValue = _rest[1];
          let enumClass = _rest[2];
          super(2, "Invalid Enum Argument: " + argumentName + " value: " + invalidValue, enumClass.toString());
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
}
InvalidEnumArgumentException.$t = markType(InvalidEnumArgumentException, 'InvalidEnumArgumentException', ArgumentException.$);
/**
 * @hidden
 */
export class ExcelCalcEngine extends Base {
  constructor(a) {
    super();
    this.p = null;
    this.t = null;
    this.e = null;
    this.f = null;
    this.a = null;
    this.r = null;
    this.s = null;
    this.c = null;
    this.j = false;
    this.k = false;
    this.q = null;
    this.g = null;
    this.h = null;
    this.i = null;
    this.i = a;
    this.p = new Dictionary$2(RefBase.$, Number_$type, 0);
    this.t = new List$1(RefBase.$, 0);
    this.a = new DependencyGraph(this);
    this.r = new HashSet$1(WorksheetDataTable.$, 0);
    this.s = new HashSet$1(SingleTargetFormula.$, 0);
    this.c = UltraCalcFunctionFactory._e;
    this.q = new Dictionary$2(WorksheetTable.$, List$1.$.specialize(RefBase.$), 0);
  }
  v(a, b) {
    let c = typeCast(RefBase.$, ExcelCalcEngine.b(a));
    if (c == null) {
      return;
    }
    this.a.ad(c, b);
  }
  w(a) {
    if (a == null) {
      return;
    }
    this.aw(a, a._ch, true);
    this.a.ae(a);
  }
  z() {
    this.a.am();
  }
  aa(a = true) {
    if (!this.a.n(a)) {
      this.i._ig();
    }
  }
  ab(a, b) {
    this.ar(a, b);
  }
  ac() {
    if (this.c == UltraCalcFunctionFactory._e) {
      this.c = new UltraCalcFunctionFactory();
    }
  }
  static b(a) {
    let b = typeCast(RefBase.$, a);
    if (b != null) {
      return b._l;
    }
    return a;
  }
  n(a) {
    return this.a.q(a);
  }
  ak(a) {
    if (this.j) {
      return;
    }
    this.r.add_1(a);
  }
  al(a) {
    this.r.remove(a);
  }
  am(a, b) {
    switch (b) {
      case 0:
        this.w(a._formula);
        break;
      case 1:
        this.au(a._formula);
        break;
    }
  }
  an(a) {
    let b;
    if (((() => { let c = this.q.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      return;
    }
    for (let c = 0; c < b.count; c++) {
      this.a.ao(b._inner[c]);
    }
  }
  ao(a) {
    this.q.removeItem(a);
  }
  ap(a) {
    if (this.j == false) {
      let b = a._w._bh(a._ao);
      if (b != null) {
        this.ak(b);
      }
    }
    if (this.a.p) {
      return;
    }
    this.aa();
    if (a._ag == false) {
      this.a.af(a);
    }
    this.a.ao(a);
  }
  aq(a, b) {
    this.a.at(a);
  }
  as(a) {
    this.ar(null, a);
  }
  at(a, b) {
    let c = typeCast(RefBase.$, ExcelCalcEngine.b(a));
    if (c == null) {
      return;
    }
    this.a.av(c, b);
  }
  au(a) {
    if (a == null) {
      return;
    }
    this.aw(a, a._ch, false);
    this.a.aw(a);
  }
  ax() {
    this.a.a2();
  }
  x(a, b) {
    if (a._ah && this.i.iterativeCalculationsEnabled) {
      let c = this.u(a);
      if (c < this.i.maxRecursionIterations) {
        let d = false;
        let e;
        let f;
        if (c > 1 && ((() => { let g = a.value._toDouble1(e); e = g.p0; return g.ret; })()) && ((() => { let g = b._toDouble1(f); f = g.p0; return g.ret; })())) {
          if (Math.abs(f - e) < Math.abs(this.i.maxChangeInIteration)) {
            d = true;
          }
        }
        if (d == false) {
          this.t.add(a);
        }
      }
    }
    a.value = b;
    if (this.h == null && this.f == null && a._w != null) {
      this.i._il(a._w, a._ao);
    }
  }
  y(a, b, c, d) {
    let e = a._as(b);
    let f = c._as(d);
    let g;
    if (e._formula != null) {
      g = e._formula._cd;
    }
    else {
      g = new ExcelCalcValue(a._getCellValue1(b));
    }
    f.value = g;
    this.a.ao(f);
    this.i._il(f._w, f._ao);
  }
  ad() {
    this.t.clear();
    while (true) {
      {
        let a = this.a.y();
        try {
          while (a.moveNext()) {
            this.ai(a.current);
          }
        }
        finally {
          if (a != null) {
            a.dispose();
          }
        }
      }
      if (this.t.count == 0) {
        break;
      }
      for (let b of fromEnum(this.t)) {
        this.a.ao(b);
      }
      this.t.clear();
    }
    this.p.clear();
  }
  ae(a) {
    let b = a.worksheet._rows$i;
    let c = a._h;
    let d = a.cellsInTable;
    let e = b.item(d.firstRow);
    let f = d._v;
    this.e = a._a();
    for (let g = c.firstRow; g <= c.lastRow; g++) {
      let h = b.item(g);
      this.a.aq();
      this.a.ao(this.e);
      this.f = h._as(f);
      this.ad();
      for (let i = c._v; i <= c._w; i++) {
        this.y(e, i, h, i);
      }
      this.f = null;
    }
    this.a.aq();
    this.a.ao(this.e);
    this.e = null;
  }
  af(a) {
    if (a.worksheet == null || a.cellsInTable == null) {
      return;
    }
    try {
      if (a._l) {
        if (a._m) {
          this.ah(a);
        }
        else {
          this.ae(a);
        }
      }
      else if (a._m) {
        this.ag(a);
      }
    }
    finally {
      this.e = null;
      this.f = null;
      this.g = null;
      this.h = null;
    }
  }
  ag(a) {
    let b = a.worksheet._rows$i;
    let c = a._h;
    let d = a.cellsInTable;
    let e = d._v;
    let f = b.item(d.firstRow);
    this.g = a._b();
    for (let g = c._v; g <= c._w; g++) {
      this.h = f._as(g);
      this.a.aq();
      this.a.ao(this.g);
      this.ad();
      for (let h = c.firstRow; h <= c.lastRow; h++) {
        let i = b.item(h);
        this.y(i, e, i, g);
      }
      this.h = null;
    }
    this.a.aq();
    this.a.ao(this.g);
    this.g = null;
  }
  ah(a) {
    let b = a.worksheet._rows$i;
    let c = a._h;
    let d = a.cellsInTable;
    let e = b.item(d.firstRow);
    let f = d._v;
    let g = c._v;
    let h = new Array(c._ad);
    this.e = a._a();
    this.g = a._b();
    for (let i = c.firstRow; i <= c.lastRow; i++) {
      let j = b.item(i);
      this.f = j._as(f);
      for (let k = g; k <= c._w; k++) {
        this.h = e._as(k);
        this.a.aq();
        this.a.ao(this.e);
        this.a.ao(this.g);
        this.ad();
        this.y(e, f, j, k);
        this.h = null;
      }
      this.f = null;
    }
    this.a.aq();
    this.a.ao(this.e);
    this.a.ao(this.g);
    this.e = null;
    this.g = null;
  }
  ai(a) {
    a._af = false;
    if (typeCast(NamedCalcReferenceBase.$, a) !== null) {
      return;
    }
    let b = a._formula;
    if (null == b) {
      return;
    }
    if (b._cq() != 0) {
      this.s.add_1(b);
    }
    let c;
    if (a._ah && this.i.iterativeCalculationsEnabled == false) {
      if (typeCast(NamedCalcReferenceBase.$, ExcelCalcEngine.b(a)) !== null) {
        c = null;
      }
      else {
        c = new ExcelCalcValue(new ExcelCalcErrorValue(5));
      }
    }
    else {
      c = b.evaluateCore(this.i);
    }
    if (a._ah) {
      this.aj(a);
    }
    this.x(a, c);
  }
  u(a) {
    let b;
    let c = this.p.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  aj(a) {
    let b;
    let c = this.p.tryGetValue(a, b);
    b = c.p1;
    this.p.item(a, ++b);
  }
  ar(a, b) {
    if (this.k) {
      return;
    }
    this.k = true;
    try {
      this.a.a2();
      if (this.o(a, b) == false) {
        return;
      }
      if (b && this.r.count != 0) {
        this.j = true;
        let c = this.r;
        this.r = new HashSet$1(WorksheetDataTable.$, 0);
        for (let d of fromEnum(c)) {
          this.af(d);
        }
        this.j = false;
      }
      this.ad();
      for (let e of fromEnum(this.s)) {
        e._cs(this);
      }
    }
    finally {
      this.s.clear();
      this.k = false;
    }
  }
  o(a, b) {
    if (a == null) {
      return true;
    }
    if (a._af) {
      return true;
    }
    if (b == false || this.r.count == 0) {
      return false;
    }
    let c = a._w._bg(a._ao);
    return c != null && this.r.contains(c);
  }
  av(a) {
    let b;
    if (this.e == a) {
      b = this.f;
    }
    else if (this.g == a) {
      b = this.h;
    }
    else {
      return {
        p0: a
      };
    }
    if (a._e.d) {
      let c = ((() => { let d = CalculationContext.b(a._e); a._e = d.p0; return d.ret; })());
      if (c != null) {
        c.formula.addDynamicReferenceI(b);
      }
    }
    a = b;
    return {
      p0: a
    };
  }
  aw(a, b, c) {
    let d = typeCast(SingleTargetFormula.$, a);
    if (d == null) {
      return;
    }
    let e = null;
    let f = d._e;
    for (let g = 0; g < f.length; g++) {
      let h = typeCast(ReferenceToken.$, f[g]);
      if (h == null) {
        continue;
      }
      let i = null;
      let j = typeCast(NameToken.$, h);
      if (j != null) {
        i = typeCast(WorksheetTable.$, j.u);
      }
      else {
        let k = typeCast(StructuredTableReference.$, h);
        if (k != null) {
          i = typeCast(WorksheetTable.$, k.w);
        }
      }
      if (i == null) {
        continue;
      }
      if (e == null) {
        e = new HashSet$1(WorksheetTable.$, 0);
      }
      if (e.add_1(i) == false) {
        continue;
      }
      let l;
      if (((() => { let m = this.q.tryGetValue(i, l); l = m.p1; return m.ret; })()) == false) {
        if (c == false) {
          continue;
        }
        l = new List$1(RefBase.$, 0);
        this.q.item(i, l);
      }
      if (c) {
        l.add(b);
      }
      else {
        l.remove(b);
      }
    }
  }
  get d() {
    return this.c;
  }
  get l() {
    return this.j;
  }
  get m() {
    return this.k;
  }
}
ExcelCalcEngine.$t = markType(ExcelCalcEngine, 'ExcelCalcEngine');
/**
 * @hidden
 */
export class RefBase extends Base {
  constructor() {
    super();
    this._ap = 0;
    this._p = 0;
    this._h = null;
    this._i = null;
    this._an = null;
    this._e = new CalculationContext();
  }
  get formula() {
    return this._formula;
  }
  get references() {
    return this._references;
  }
  equals(a) {
    let b = typeCast(IExcelCalcReference_$type, a);
    if (b == null) {
      return false;
    }
    return this._z(ExcelCalcEngine.b(b));
  }
  toString() {
    return getInstanceType(this).typeName + "-" + this.absoluteName;
  }
  _au(a) {
    if (this._an == null) {
      this._an = new List$1(RefBase.$, 2, 1);
    }
    this._an.add(a);
  }
  createReference(a) {
    return CalcUtilities.e(a, this._w, this._ao, this._u, this._t);
  }
  _v() {
    let a = this._am();
    return a == null || a.count == 0 ? null : a.item(a.count - 1);
  }
  _am() {
    return null;
  }
  _al() {
    return this._an || RefBase._a;
  }
  _ae(a, b) {
    let c = this._am();
    if (c != null) {
      for (let d = 0, e = c.count; d < e; d++) {
        let f = c.item(d);
        if (f.worksheet == a && f._h._j(b)) {
          return true;
        }
      }
    }
    return false;
  }
  _aw(a) {
    if (this._an != null) {
      this._an.remove(a);
    }
  }
  _ax() {
    this._j = null;
    this._k = null;
    this._ab = false;
    this._af = false;
    this._ah = false;
    this._ag = false;
    this._ai = false;
    this._d = 0;
    if (this._an != null) {
      this._an.clear();
    }
  }
  _m(a, b, c) {
    c = null;
    if (b == false) {
      return {
        ret: this,
        p0: a,
        p2: c
      };
    }
    if (a.c != 64) {
      return {
        ret: this,
        p0: a,
        p2: c
      };
    }
    let d = typeCast(CellCalcReference.$, ((() => { let e = CalculationContext.b(a); a = e.p0; return e.ret; })()));
    if (d == null || d._a4 == false) {
      return {
        ret: this,
        p0: a,
        p2: c
      };
    }
    return {
      ret: ((() => { let e = this._n(d, c); c = e.p1; return e.ret; })()),
      p0: a,
      p2: c
    };
  }
  _a0(a, b, c = false, d = false) {
    if (c == false && a == this._formula) {
      return;
    }
    if (this._x == false) {
      return;
    }
    this._av(d);
    let e = this._t;
    if (a == null || e == null) {
      return;
    }
    a._cx(this, e, d);
    this._az(a);
    if (this._ak) {
      e._g9(a);
    }
    if (b && e._cm == false && e.calculationMode == 0) {
      e._w.ax();
      this.value = a.evaluateCore(e);
    }
  }
  _o() {
    return new RefBase_DynamicReference(this);
  }
  _b(a) {
    let b = this;
    let c = this._t;
    if (c != null) {
      let d = c._w.av(b);
      b = d.p0;
    }
    if (a && this._e.d) {
      let e = ((() => { let f = CalculationContext.b(b._e); b._e = f.p0; return f.ret; })());
      if (e != null) {
        let f = typeCast(SingleTargetFormula.$, e.formula);
        if (f != null && c != null) {
          f._addDynamicReference1(b, c._w);
        }
        else if (e.formula != null) {
          e.formula.addDynamicReferenceI(b);
        }
      }
    }
    let g = b._c;
    if (g != null) {
      g._n = b._e;
    }
    else {
      g = ExcelCalcValue._g;
    }
    return g;
  }
  _n(a, b) {
    b = null;
    return {
      ret: this,
      p1: b
    };
  }
  _az(a) {
  }
  _a1(a) {
  }
  _aa(a) {
    return (this._p & a) == a;
  }
  _av(a = false) {
    let b = this._formula;
    if (b == null) {
      return;
    }
    let c = this._t;
    if (c != null) {
      c._ir(b);
    }
    b._cx(null, c, a);
    this._az(null);
  }
  _ay(a, b) {
    if (b) {
      this._p |= a;
    }
    else {
      this._p &= ~a;
    }
  }
  get absoluteName() {
    return "//" + this.elementName;
  }
  get__formula() {
    return null;
  }
  get _formula() {
    return this.get__formula();
  }
  get _aq() {
    return this._ap;
  }
  set _aq(a) {
    this._ap = a;
  }
  get _d() {
    return (this._p & 3);
  }
  set _d(a) {
    this._p &= ~3;
    this._p |= a;
  }
  get__x() {
    return false;
  }
  get _x() {
    return this.get__x();
  }
  get_context() {
    return null;
  }
  get context() {
    return this.get_context();
  }
  get _ab() {
    return this._aa(4);
  }
  set _ab(a) {
    this._ay(4, a);
  }
  get _ac() {
    return this._an != null && this._an.count != 0;
  }
  get _ad() {
    return this._aa(128);
  }
  set _ad(a) {
    this._ay(128, a);
  }
  get _af() {
    return this._aa(8);
  }
  set _af(a) {
    this._ay(8, a);
  }
  get_isEnumerable() {
    return false;
  }
  get isEnumerable() {
    return this.get_isEnumerable();
  }
  get _ag() {
    return this._aa(16);
  }
  set _ag(a) {
    this._ay(16, a);
  }
  get _ah() {
    return this._aa(32);
  }
  set _ah(a) {
    this._ay(32, a);
  }
  get__aj() {
    return false;
  }
  get _aj() {
    return this.get__aj();
  }
  get _ai() {
    return this._aa(64);
  }
  set _ai(a) {
    this._ay(64, a);
  }
  get _j() {
    return this._h;
  }
  set _j(a) {
    this._h = a;
  }
  get normalizedAbsoluteName() {
    return this.absoluteName.toLowerCase();
  }
  get__f() {
    return this._references || EmptyReferencesCollection._a;
  }
  get _f() {
    return this.get__f();
  }
  get _k() {
    return this._i;
  }
  set _k(a) {
    this._i = a;
  }
  get__references() {
    return null;
  }
  get _references() {
    return this.get__references();
  }
  get__l() {
    return this;
  }
  get _l() {
    return this.get__l();
  }
  get__as() {
    let a = this._w;
    return a != null ? a.index : -1;
  }
  get _as() {
    return this.get__as();
  }
  get__r() {
    return this._u;
  }
  get _r() {
    return this.get__r();
  }
  get__ak() {
    return true;
  }
  get _ak() {
    return this.get__ak();
  }
  get_value() {
    return this._b(false);
  }
  set_value(a) {
    this._a1(a);
  }
  get value() {
    return this.get_value();
  }
  set value(a) {
    this.set_value(a);
  }
  get__t() {
    let a = this._r;
    if (a == null) {
      return null;
    }
    return a.workbook;
  }
  get _t() {
    return this.get__t();
  }
  get__u() {
    let a = this._w;
    if (a == null) {
      return null;
    }
    return a.worksheet;
  }
  get _u() {
    return this.get__u();
  }
  get__q() {
    let a = this._t;
    let b = this._r;
    return a != null && b != null && b.type == 0 ? a._bb.i(b.index) : null;
  }
  get _q() {
    return this.get__q();
  }
}
RefBase.$t = markType(RefBase, 'RefBase', Base.$, [IExcelCalcReference_$type]);
RefBase._a = new Array(0);
/**
 * @hidden
 */
export class RegionCalcReferenceBase extends RefBase {
  constructor() {
    super();
    this._a2 = null;
  }
  get__x() {
    return false;
  }
  get__ao() {
    let a = this._a3;
    if (a == null) {
      return -1;
    }
    return a._v;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = this._a3;
    if (b == null) {
      return false;
    }
    return CalcUtilities.i(b, a);
  }
  get_context() {
    return this._a3;
  }
  _am() {
    let a = this._a3;
    if (a == null) {
      return boxArray$1(new Array(0));
    }
    return boxArray$1([a]);
  }
  _ae(a, b) {
    let c = this._a3;
    if (c == null) {
      return false;
    }
    if (c.worksheet != a) {
      return false;
    }
    return c._t(b._ac, b._w, b._ae, b._x);
  }
  get_isEnumerable() {
    return true;
  }
  isSubsetReference(a) {
    let b = this._a3;
    if (b == null) {
      return false;
    }
    return CalcUtilities.j(b, a);
  }
  get__references() {
    if (this._a2 == null) {
      this._a2 = new RegionCalcReferenceBase_RegionReferencesCollection(this);
    }
    return this._a2;
  }
  _n(a, b) {
    let c = this._a3;
    if (c == null) {
      b = null;
      return {
        ret: ExcelReferenceError._a2,
        p1: b
      };
    }
    return {
      ret: ((() => { let d = CalcUtilities.g(a, c, b); b = d.p2; return d.ret; })()),
      p1: b
    };
  }
  get__w() {
    let a = this._a3;
    if (a == null) {
      return null;
    }
    return a._k;
  }
  get _w() {
    return this.get__w();
  }
  containsColumns(a, b) {
    return this._a4(a, b);
  }
  intersectsWithColumns(a, b) {
    return this._a5(a, b);
  }
}
RegionCalcReferenceBase.$t = markType(RegionCalcReferenceBase, 'RegionCalcReferenceBase', RefBase.$, [IRegionAddress_$type]);
RegionCalcReferenceBase._a6 = new List$1(RegionCalcReferenceBase.$, 0);
/**
 * @hidden
 */
export class CellCalcReferenceBase extends RefBase {
  constructor(a, b) {
    super();
    this._a9 = null;
    this._a8 = 0;
    this._a2 = null;
    this._a3 = null;
    this._a3 = a;
    this._a8 = b;
  }
  get__x() {
    return true;
  }
  get__ao() {
    return this._a8;
  }
  get _ao() {
    return this.get__ao();
  }
  get_context() {
    return this;
  }
  get_elementName() {
    if (this._a9 != null) {
      let a = this._u.name;
      if (a.length + 1 < this._a9.length) {
        for (let b = 0, c = 0; b < this._a9.length; b++) {
          let d = this._a9.charAt(b);
          if (d == '\'') {
            if (c != 0 && c != a.length) {
              this._a9 = null;
              break;
            }
            continue;
          }
          if (a.length <= c) {
            if (d != '!') {
              this._a9 = null;
            }
            break;
          }
          if (d != a.charAt(c++)) {
            this._a9 = null;
            break;
          }
        }
        if (this._a9 != null) {
          return this._a9;
        }
      }
    }
    this._a9 = this._a3._c7(this._a8, 1, true);
    return this._a9;
  }
  get elementName() {
    return this.get_elementName();
  }
  get__formula() {
    return this._a2;
  }
  _am() {
    return boxArray$1([this._a3.worksheet._cx(this._a3.index, this._a8, this._a3.index, this._a8)]);
  }
  _ae(a, b) {
    if (this._a3.worksheet != a) {
      return false;
    }
    return b._i(this._a3.index, this._a8);
  }
  get__f() {
    return this._a2 || super.get__f();
  }
  get__w() {
    return this._a3;
  }
  get _w() {
    return this.get__w();
  }
  _az(a) {
    this._a2 = a;
  }
  _a1(a) {
    if (this._a2 == null) {
      return;
    }
    let b = a._getResolvedValue();
    if (ExcelUtils.a9(b)) {
      b = 0;
    }
    else if (typeCast(HyperlinkResult.$, b) !== null && (typeCast(HyperlinkResult.$, a.value) !== null) == false) {
      b = b.toString();
    }
    this._a2._cd = new ExcelCalcValue(b);
  }
  get__c() {
    if (this._a3.worksheet.workbook == null) {
      return ExcelReferenceError._a2.value;
    }
    if (this._a2 != null) {
      return this._a2._cd;
    }
    return CalcUtilities.c(this._a3._c5(this._a8));
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a3.worksheet.workbook;
  }
  _ba(a, b) {
    let c = typeCast(ArrayInteriorFormula.$, this._formula);
    if (c == null) {
      b = 0;
      a = 0;
      return {
        p0: a,
        p1: b
      };
    }
    let d = c._cz.cellRange;
    b = this._a3.index - d.firstRow;
    a = this._a8 - d.firstColumn;
    return {
      p0: a,
      p1: b
    };
  }
  _bb(a, b) {
    this._a9 = null;
    this._a3 = a;
    this._a8 = b;
  }
  get _a4() {
    return this._a2 != null && this._a2._ak;
  }
  get _a5() {
    return this._a3.worksheet._ec(this._a8);
  }
  get _a6() {
    if (this._a3.hidden) {
      return true;
    }
    return this._a3.worksheet._ec(this._a8);
  }
  get _a7() {
    return this._a3.hidden;
  }
}
CellCalcReferenceBase.$t = markType(CellCalcReferenceBase, 'CellCalcReferenceBase', RefBase.$);
/**
 * @hidden
 */
export class CellCalcReference extends CellCalcReferenceBase {
  constructor(a, b) {
    super(a, b);
  }
  containsReference(a) {
    let b = typeCast(RefBase.$, ExcelCalcEngine.b(a));
    if (b == null || typeCast(NamedCalcReferenceBase.$, b) !== null) {
      return false;
    }
    let c = typeCast(CellCalcReference.$, b);
    if (c != null) {
      return this == c;
    }
    let d = CalcUtilities.l(b);
    for (let e = 0; e < d.count; e++) {
      if (d.item(e)._p(this._a3, this._a8)) {
        return true;
      }
    }
    return false;
  }
  _z(a) {
    let b = typeCast(CellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a3 == b._a3 && this._a8 == b._a8;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a3) ^ (this._a8 << 16);
  }
  isSubsetReference(a) {
    return this.containsReference(a);
  }
  _bf() {
    let a = this._t;
    if (a != null) {
      a._hj(this);
    }
  }
  _bg() {
    this._bb(null, 0);
    CellCalcReference._bc = this;
  }
  static _bd(a, b) {
    let c = CellCalcReference._bc;
    if (c != null) {
      CellCalcReference._bc = null;
      c._bb(a, b);
    }
    else {
      c = new CellCalcReference(a, b);
    }
    return c;
  }
  _be() {
    if (this._af || this._ah) {
      return true;
    }
    let a = this._formula;
    if (a != null && a.hasAlwaysDirty) {
      return true;
    }
    return false;
  }
}
CellCalcReference.$t = markType(CellCalcReference, 'CellCalcReference', CellCalcReferenceBase.$);
CellCalcReference._bc = null;
/**
 * @hidden
 */
export class DependencyGraph extends Base {
  constructor(a) {
    super();
    this.b = null;
    this.e = null;
    this.c = null;
    this.j = false;
    this.s = null;
    this.r = null;
    this.k = false;
    this.z = null;
    this.t = null;
    this.i = false;
    this.ab = null;
    this.e = a;
    this.s = new HashSet$1(RefBase.$, 0);
    this.b = new CalculationNetworkLinkedList();
    this.r = new Dictionary$2(Worksheet.$, RegionLookupTable$1.$.specialize(RegionCalcReferenceBase.$), 0);
    this.z = new List$1(DependencyGraph_StronglyConnectedComponent.$, 0);
    this.t = new HashSet$1(RefBase.$, 0);
    this.ab = runOn(this, this.x);
  }
  ad(a, b) {
    DependencyGraph.ah(a, b);
    if (a._ag == false) {
      this.a1(a, b, true);
    }
    if (a._aq < b._aq) {
    }
    else if (this.l(a, b)) {
    }
    else {
      let c = this.v(b);
      if (this.c != null) {
        this.c._e(c);
      }
      for (let d of fromEnum(c)) {
        d._d = 0;
        this.b._i(d);
      }
      if (c.contains(a)) {
        this.ai();
        let e = 0;
        if (this.b._d != null) {
          e = this.b._d._aq + 2;
        }
        this.ag(c, null, true, e);
      }
      else {
        let f = new List$1(RefBase.$, 1, c);
        f.z(DependencyGraph_FinishTimeSorter._a);
        for (let g of fromEnum(f)) {
          this.b._h(g);
        }
        DependencyGraph.ar(f._inner[0]);
      }
      b._af = true;
    }
  }
  ae(a) {
    this.an();
    let b = a._ch;
    if ((typeCast(NamedCalcReferenceBase.$, b) !== null) == false) {
      b._ab = true;
    }
    this.s.add_1(b);
    if (a.hasAlwaysDirty) {
      this.t.add_1(b);
    }
  }
  af(a) {
    this.a1(a, null, false);
  }
  am() {
    this.a3();
    for (let a of fromEnum(this.s)) {
      a._af = true;
    }
  }
  ao(a) {
    let b = new Queue$1(RefBase.$);
    b.g(a);
    while (b.count != 0) {
      let c = b.b();
      if (c._af) {
        continue;
      }
      if (c._ag) {
        this.ap(c);
      }
      for (let d of fromEnum(this.x(c))) {
        if (d._af == false) {
          b.g(d);
        }
      }
    }
  }
  aq() {
    for (let a of fromEnum(this.t)) {
      this.ao(a);
    }
    for (let b of fromEnum(this.z)) {
      b.f(this);
    }
    this.k = false;
  }
  n(a) {
    if (a && this.i) {
      this.i = false;
      for (let b of fromEnum(this.s)) {
        b._ad = false;
      }
    }
    let c = this.k;
    this.k = true;
    return c;
  }
  y() {
    this.c = new DependencyGraph_EvaluationEnumerator(this);
    return this.c;
  }
  q(a) {
    this.a3();
    return a._ag && this.o(a);
  }
  at(a) {
    let b = a._formula;
    if (b != null && b._an == false && b._ai == false) {
      if (!b._at) {
        a._ab = false;
      }
      else {
        this.i = true;
        a._ad = true;
      }
    }
  }
  av(a, b) {
    a._aw(b);
    let c;
    if (((() => { let d = this.m(a, b, c); c = d.p2; return d.ret; })()) && c != null) {
      let d = a._aq < b._aq;
      let e = c.b(d ? a : b);
      let f = c.a(d ? b : a);
      this.ax(e, f);
    }
    if (this.o(a) == false && Enumerable.c(IExcelCalcReference_$type, a._f) == false) {
      this.b._i(a);
      a._ax();
    }
  }
  aw(a) {
    this.an();
    let b = a._ch;
    b._ab = false;
    this.ao(b);
    if (!this.s.remove(b)) {
    }
    this.t.remove(b);
  }
  a2() {
    this.a3();
    if (this.k) {
      this.aq();
    }
  }
  a3() {
    if (this.j == false) {
      return;
    }
    let a = this.w();
    this.b._j();
    this.r.clear();
    this.z.clear();
    let b = 0;
    this.ag(this.s, null, false, b);
    for (let c of fromEnum(a)) {
      if (c._ag) {
        c._af = true;
      }
    }
    for (let d of fromEnum(this.s)) {
      if (d._ab) {
        this.ao(d);
        d._ab = false;
      }
    }
    this.j = false;
  }
  ag(a, b, c, d) {
    let e = new List$1(RefBase.$, 0);
    let f = d;
    let g = (c == false);
    for (let h of fromEnum(a)) {
      if (h._d == 0) {
        let i = this.ak(h, g, f, e);
        f = i.p2;
      }
    }
    for (let j of fromEnum(e)) {
      j._d = 0;
      if (c == false) {
        let k = typeCast(RegionCalcReferenceBase.$, j);
        if (k != null) {
          this.au(k);
        }
      }
    }
    let l = b;
    let m = new List$1(RefBase.$, 0);
    for (let n = e.count - 1; n >= 0; n--) {
      let o = e._inner[n];
      if (o._ag) {
        continue;
      }
      let p;
      let q = this.al(o, f, p, m);
      f = q.p1;
      p = q.p2;
      if (m.count != 1) {
        this.az(m);
      }
      if (p) {
        this.z.add(new DependencyGraph_StronglyConnectedComponent(m));
      }
      let r = true;
      if (p) {
        for (let s = m.count - 1; s >= 0; s--) {
          let t = m._inner[s];
          if ((typeCast(NamedCalcReference.$, t) !== null) == false) {
            r = false;
          }
        }
      }
      for (let u = m.count - 1; u >= 0; u--) {
        let v = m._inner[u];
        if (v == ExcelReferenceError._a2) {
          continue;
        }
        this.b._f(b, v);
        b = v;
        if (p) {
          v._ah = true;
          v._ai = r;
        }
      }
      m.clear();
    }
    DependencyGraph.ar(b);
    DependencyGraph.ar(l);
  }
  static ah(a, b) {
    if (typeCast(CellCalcReference.$, a) !== null && typeCast(RegionCalcReferenceBase.$, b) !== null) {
    }
    else {
      a._au(b);
    }
  }
  l(a, b) {
    let c;
    return ((() => { let d = this.m(a, b, c); c = d.p2; return d.ret; })());
  }
  m(a, b, c) {
    c = null;
    if (a._ah == false || b._ah == false) {
      return {
        ret: false,
        p2: c
      };
    }
    if (a == b) {
      return {
        ret: true,
        p2: c
      };
    }
    c = this.d(a);
    return {
      ret: c != null && c.c(b),
      p2: c
    };
  }
  ai() {
    for (let a = this.z.count - 1; a >= 0; a--) {
      if (this.z._inner[a].d() == false) {
        this.z.removeAt(a);
      }
    }
  }
  aj($tRef, a, b, c, d, e, f, g) {
    d = false;
    if (a._ag) {
      return {
        p2: c,
        p3: d
      };
    }
    let h = new Stack$1(RefBase.$);
    let i = new Stack$1(IEnumerator$1_$type.specialize($tRef));
    let j = DependencyGraph.a0($tRef, a, b, c, f, h, i);
    c = j.p2;
    while (h.f != 0) {
      let k = h.d();
      let l = i.d();
      let m = false;
      while (m == false && l.moveNext()) {
        let n = typeCast(RefBase.$, l.current);
        if (n == null) {
          continue;
        }
        if (g != null) {
          g(n, k);
        }
        switch (n._d) {
          case 2: break;
          case 0:
            if (n._ag) {
              break;
            }
            let o = DependencyGraph.a0($tRef, n, b, c, f, h, i);
            c = o.p2;
            m = true;
            break;
          case 1:
            d = true;
            break;
          default: break;
        }
      }
      if (m) {
        continue;
      }
      e.add(k);
      let p = DependencyGraph.as($tRef, k, b, c, l, h, i);
      c = p.p2;
    }
    if (b == false && e.count != 1) {
      e.w();
    }
    return {
      p2: c,
      p3: d
    };
  }
  ak(a, b, c, d) {
    let e;
    let f = this.aj(IExcelCalcReference_$type, a, true, c, e, d, DependencyGraph.aa, b ? DependencyGraph.h : null);
    c = f.p2;
    e = f.p3;
    return {
      p2: c
    };
  }
  al(a, b, c, d) {
    let e = this.aj(RefBase.$, a, false, b, c, d, this.ab, null);
    b = e.p2;
    c = e.p3;
    return {
      p1: b,
      p2: c
    };
  }
  an() {
    this.j = true;
  }
  ap(a) {
    if (a._af) {
      return;
    }
    a._af = true;
    if (this.e.l == false) {
      let b = typeCast(CellCalcReference.$, a);
      if (b != null) {
        let c = b._w._bh(b._ao);
        if (c != null) {
          this.e.ak(c);
        }
      }
    }
  }
  static ar(a) {
    if (a == null) {
      return;
    }
    let b = a._k;
    if (b == null) {
      return;
    }
    while (a != null && a._aq <= b._aq) {
      let c = a._j;
      let d = b._aq + (2 - 1);
      if (c != null && d < c._aq) {
        a._aq = d;
      }
      else {
        a._aq = b._aq + 2;
      }
      b = a;
      a = a._j;
    }
  }
  static as($tRef, a, b, c, d, e, f) {
    d.dispose();
    if (b) {
      a._aq = ++c;
    }
    else {
      a._aq = c--;
    }
    a._d = 2;
    e.e();
    f.e();
    return {
      p2: c
    };
  }
  u(a) {
    let b = new HashSet$1(RefBase.$, 0);
    b.add_1(a);
    let c = new Queue$1(RefBase.$);
    c.g(a);
    while (c.count != 0) {
      let d = c.b();
      for (let e of fromEnum(d._f)) {
        let f = typeCast(RefBase.$, e);
        if (f != null && b.add_1(f)) {
          c.g(f);
        }
      }
    }
    return b;
  }
  v(a) {
    let b = new HashSet$1(RefBase.$, 0);
    b.add_1(a);
    let c = new Queue$1(RefBase.$);
    c.g(a);
    while (c.count != 0) {
      let d = c.b();
      for (let e of fromEnum(this.x(d))) {
        if (b.add_1(e)) {
          c.g(e);
        }
      }
    }
    return b;
  }
  w() {
    let a = new HashSet$1(RefBase.$, 0);
    let b = this.b._c;
    while (b != null) {
      if (b._af) {
        a.add_1(b);
      }
      b = b._j;
    }
    return a;
  }
  g(a) {
    let b;
    if (a._u == null || ((() => { let c = this.r.tryGetValue(a._u, b); b = c.p1; return c.ret; })()) == false) {
      return DependencyGraph.f;
    }
    return b.f(a._w.index, a._ao);
  }
  d(a) {
    for (let b of fromEnum(this.z)) {
      if (b.c(a)) {
        return b;
      }
    }
    return null;
  }
  x(a) {
    let b = a._al();
    let c = typeCast(CellCalcReference.$, a);
    if (c == null) {
      return b;
    }
    let d = this.g(c);
    if (d._c == false) {
      d.dispose();
      return b;
    }
    return new DependencyGraph_SuccessorsResolvedEnumerable(b, d);
  }
  o(a) {
    if (a._ac) {
      return true;
    }
    let b = typeCast(CellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    {
      let c = this.g(b);
      try {
        return c._c;
      }
      finally {
        c.dispose();
      }
    }
  }
  au(a) {
    let b = a._u;
    if (b == null) {
      return;
    }
    let c;
    if (((() => { let d = this.r.tryGetValue(b, c); c = d.p1; return d.ret; })()) == false) {
      c = new RegionLookupTable$1(RegionCalcReferenceBase.$, b);
      this.r.item(b, c);
    }
    c.x(a._a3, a);
  }
  ax(a, b) {
    let c = b._j;
    let d = a._aq;
    let e = new List$1(RefBase.$, 0);
    let f = a;
    while (f != c) {
      let g = f._j;
      f._d = 0;
      this.b._i(f);
      e.add(f);
      f = g;
    }
    this.ai();
    let h = d - 1;
    this.ag(e, c, true, h);
  }
  ay(a, b) {
    let e = DependencyGraph.a;
    for (let d = 0; d < e.length; d++) {
      let c = e[d];
      for (let f = c; f < a.count; f++) {
        let g = a._inner[f];
        let h = g._aq;
        let i;
        for (i = f; i >= c && b.compare(a._inner[i - c], g) > 0; i -= c) {
          let j = a._inner[i - c];
          let k = j._aq;
          j._aq = h;
          h = k;
          a._inner[i] = j;
        }
        g._aq = h;
        a._inner[i] = g;
      }
    }
  }
  az(a) {
    this.ay(a, DependencyGraph_StronglyConnectedComponentSorter._a);
  }
  static a0($tRef, a, b, c, d, e, f) {
    a._d = 1;
    if (b) {
      ++c;
    }
    else {
      c--;
    }
    e.h(a);
    f.h(getEnumerator(d(a)));
    return {
      p2: c
    };
  }
  a1(a, b, c) {
    if (c == false && this.o(a) == false) {
      return;
    }
    let d = typeCast(CellCalcReference.$, a);
    if (d != null) {
      a._aq = this.b._c._aq - 2;
      this.b._g(a);
      return;
    }
    let e = null;
    let f = this.u(a);
    for (let g of fromEnum(f)) {
      if (g._ag == false) {
        g._d = 0;
      }
      else if (e == null || e._aq < g._aq) {
        e = g;
      }
    }
    let h;
    let i;
    if (e != null) {
      h = e._j;
      i = e._aq + 2;
    }
    else if (b != null) {
      h = b;
      let j = b._k;
      if (j != null) {
        i = j._aq + 2;
      }
      else {
        i = h._aq - (f.count * 2);
      }
    }
    else {
      h = this.b._c;
      i = h._aq - (f.count * 2);
    }
    this.ag(f, h, false, i);
  }
  get p() {
    return this.b._c == null;
  }
}
DependencyGraph.$t = markType(DependencyGraph, 'DependencyGraph');
DependencyGraph.f = RegionLookupTable_Result$1.$t.specialize(RegionCalcReferenceBase.$).getStaticFields()._b;
DependencyGraph.h = DependencyGraph.ah;
DependencyGraph.aa = (a) => a._f;
DependencyGraph.a = [701, 301, 132, 57, 23, 10, 4, 1];
/**
 * @hidden
 */
export class CalculationNetworkLinkedList extends Base {
  constructor() {
    super();
    this._a = null;
    this._b = null;
  }
  *_getEnumerator() {
    let a = this._a;
    while (a != null) {
      yield a;
      a = a._j;
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  _e(a, b) {
    if (a == null) {
      if (this._a != null) {
        this._a._k = b;
      }
      b._j = this._a;
      this._a = b;
      if (this._b == null) {
        this._b = b;
      }
    }
    else {
      b._k = a;
      if (a._j != null) {
        a._j._k = b;
        b._j = a._j;
      }
      a._j = b;
      if (this._b == a) {
        this._b = b;
      }
    }
    b._ag = true;
  }
  _f(a, b) {
    if (a == null) {
      if (this._b != null) {
        this._b._j = b;
      }
      b._k = this._b;
      this._b = b;
      if (this._a == null) {
        this._a = b;
      }
    }
    else {
      b._j = a;
      if (a._k != null) {
        a._k._j = b;
        b._k = a._k;
      }
      a._k = b;
      if (this._a == a) {
        this._a = b;
      }
    }
    b._ag = true;
  }
  _g(a) {
    this._e(null, a);
  }
  _h(a) {
    this._f(null, a);
  }
  _i(a) {
    if (a._ag == false) {
      return;
    }
    if (this._a == a) {
      this._a = a._j;
    }
    if (this._b == a) {
      this._b = a._k;
    }
    if (a._j != null) {
      a._j._k = a._k;
    }
    if (a._k != null) {
      a._k._j = a._j;
    }
    a._j = null;
    a._k = null;
    a._ag = false;
  }
  _j() {
    let a = this._a;
    while (a != null) {
      let b = a._j;
      a._ax();
      a = b;
    }
    this._a = null;
    this._b = null;
  }
  get _c() {
    return this._a;
  }
  get _d() {
    return this._b;
  }
}
CalculationNetworkLinkedList.$t = markType(CalculationNetworkLinkedList, 'CalculationNetworkLinkedList', Base.$, [IEnumerable$1_$type.specialize(RefBase.$)]);
/**
 * @hidden
 */
export class DependencyGraph_StronglyConnectedComponent extends Base {
  constructor(a) {
    super();
    this.e = null;
    this.e = new HashSet$1(RefBase.$, 1, a);
  }
  c(a) {
    return this.e.contains(a);
  }
  f(a) {
    for (let b of fromEnum(this.e)) {
      a.ao(b);
    }
  }
  b(a) {
    let b = a._k;
    while (b != null && b._ah && this.c(b)) {
      a = b;
      b = a._k;
    }
    return a;
  }
  a(a) {
    let b = a._j;
    while (b != null && b._ah && this.c(b)) {
      a = b;
      b = a._j;
    }
    return a;
  }
  d() {
    for (let a of fromEnum(this.e)) {
      return a._ag;
    }
    return false;
  }
}
DependencyGraph_StronglyConnectedComponent.$t = markType(DependencyGraph_StronglyConnectedComponent, 'DependencyGraph_StronglyConnectedComponent');
/**
 * @hidden
 */
export class ObjectPool$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this.a = new Array(1024);
    this.c = null;
    this.d = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.c = a;
  }
  b() {
    if (this.d == 0) {
      return this.c();
    }
    return this.a[--this.d];
  }
  f(a) {
    if (this.d == 1024) {
      return;
    }
    this.a[this.d++] = a;
  }
}
ObjectPool$1.$t = markType(ObjectPool$1, 'ObjectPool$1');
/**
 * @hidden
 */
export class DependencyGraph_SuccessorsResolvedEnumerable extends Base {
  constructor(a, b) {
    super();
    this._b = false;
    this._c = null;
    this._e = null;
    this._a = new RegionLookupTable_Result$1(RegionCalcReferenceBase.$);
    this._d = null;
    this._c = a;
    this._a = b;
  }
  getEnumerator() {
    if (this._e != null) {
      return new DependencyGraph_SuccessorsResolvedEnumerable(this._c, this._a).getEnumerator();
    }
    this._e = getEnumerator(this._c);
    if (this._a._c) {
      this._d = this._a._d.getEnumerator();
    }
    return this;
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  get current() {
    return this._b ? this._d.current : this._e.current;
  }
  dispose() {
    this._a.dispose();
  }
  get currentObject() {
    return this.current;
  }
  moveNext() {
    if (this._b == false) {
      if (this._e.moveNext()) {
        return true;
      }
      if (this._a._c == false) {
        return false;
      }
      this._b = true;
    }
    return this._d.moveNext();
  }
  reset() {
    throw new NotImplementedException(0);
  }
}
DependencyGraph_SuccessorsResolvedEnumerable.$t = markType(DependencyGraph_SuccessorsResolvedEnumerable, 'DependencyGraph_SuccessorsResolvedEnumerable', Base.$, [IEnumerable$1_$type.specialize(RefBase.$), IEnumerator$1_$type.specialize(RefBase.$)]);
/**
 * Represents a data table for a range of cells.
 * <p class="body">
 * Data tables are a way to show the results of one or more formulas by trying many different values in the variables
 * of the formulas at the same time, and showing the different results in a table.  An excellent example of a data table
 * application would be for a multiplication table.  A multiplication table shows results for the formula =X*Y.  However,
 * it shows many different results for the formula, where each result is determined by using different values for X and Y.
 * These results are displayed in a table, where each cell in the table shows the formula's result for specific values of
 * X and Y, which are labeled in the row and column headers, respectively.  Therefore, each cell in a row will use the
 * same X value, and each cell in a column will use the same Y value.
 * </p>
 * <p class="body">
 * The multiplication table is known as a two-variable data table. Two-variable data tables are characterized by having a
 * single formula and values in the row and column headers of the table.  The formula is entered into the top-left cell of
 * the data table and usually references at least two cells outside the data table, known as the column-input and row-input
 * cells.  When the formula is evaluated for a specific cell in the data table, the reference to the column-input cell in the
 * formula is replaced with the value in the cell's row header (this may seem backwards, but the values in the row headers
 * run down the left column of the data table, which is why they are used for the column-input cell), and the reference to
 * the row-input cell is replaced with the value in the cell's column header.
 * </p>
 * <p class="body">
 * Another type of data table is the one-variable data table.  A one-variable data table can be a column-oriented or
 * a row-oriented data table.  A column-oriented data table has data in the cells of the left column and formulas in the
 * cells of the top row (anything in the top-left cell of the data table is ignored in this type of data table).  Usually,
 * the formulas in the top row all reference the same cell outside the data table, known as the column-input cell.  When a
 * cell in the table is evaluated, the formula in its column header is used, with the reference to the column-input cell
 * replaced by the value in cell's row header.
 * </p>
 * <p class="body">
 * A row-oriented one-variable data table is formed like a column-oriented data table, except the values run along the top
 * row, the formulas run down the left column, and the cell referenced by all formulas is known as the row-input cell.
 * </p>
 */
export class WorksheetDataTable extends Base {
  constructor(a, b, c, d) {
    super();
    this._c = null;
    this._i = new WorksheetRegionAddress();
    this._k = false;
    this._t = 0;
    this._r = 0;
    this._q = false;
    this._u = 0;
    this._s = 0;
    this._x(a, b, c, d);
  }
  /**
   * @hidden
   */
  removeFromRegion() {
    if (this._c != null) {
      this._c._dataTables$i.remove_1(this);
    }
  }
  /**
   * @hidden
   */
  throwBlockingException() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantChangeDataTable"));
  }
  /**
   * @hidden
   */
  throwExceptionWhenMergedCellsInRegion() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_DataTableInMergedCell"));
  }
  /**
   * @hidden
   */
  throwExceptionWhenTableInRegion() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_DataTableAppliedInTable"));
  }
  /**
   * @hidden
   */
  get blockedRegion() {
    return this._h;
  }
  /**
   * @hidden
   */
  _a() {
    if (this._c == null || this._t == -1) {
      return ExcelReferenceError._a2;
    }
    return this._c._rows$i.item(this._t)._as(this._r);
  }
  /**
   * @hidden
   */
  _v() {
    let a = ExcelUtils.cq;
    let b = 1;
    if (this.worksheet != null) {
      b = this.worksheet._c;
      a = this.worksheet._y;
    }
    let c = FormulaParser.bx(a);
    let d = null;
    let e = this.rowInputCell;
    if (WorksheetCell.l_op_Inequality(e, null)) {
      d = e._toString2(b, false, true, true);
    }
    let f = null;
    let g = this.columnInputCell;
    if (WorksheetCell.l_op_Inequality(g, null)) {
      f = g._toString2(b, false, true, true);
    }
    return stringFormat("TABLE({0}{1}{2})", d, c, f);
  }
  /**
   * @hidden
   */
  _b() {
    if (this._c == null || this._u == -1) {
      return ExcelReferenceError._a2;
    }
    return this._c._rows$i.item(this._u)._as(this._s);
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    let d = this.cellsInTable;
    if (d == null) {
      c = false;
      return {
        ret: false,
        p2: c
      };
    }
    c = d._p(a, b);
    if (c == false) {
      return {
        ret: false,
        p2: c
      };
    }
    let e = a.index == d.firstRow;
    let f = b == d._v;
    if (e) {
      if (f) {
        return {
          ret: this._k && this._q,
          p2: c
        };
      }
      return {
        ret: true,
        p2: c
      };
    }
    else if (f) {
      return {
        ret: true,
        p2: c
      };
    }
    return {
      ret: false,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _o(a) {
    if (this._c == null) {
      return false;
    }
    let b;
    let c = false;
    if (this._t >= 0) {
      b = ((() => { let d = a.d(this._t, this._r); this._t = d.p0; this._r = d.p1; return d.ret; })());
      c = b.f || c;
      if (b.g) {
        this._t = -1;
        this._r = -1;
      }
    }
    if (this._u >= 0) {
      b = ((() => { let d = a.d(this._u, this._s); this._u = d.p0; this._s = d.p1; return d.ret; })());
      c = b.f || c;
      if (b.g) {
        this._u = -1;
        this._s = -1;
      }
    }
    if (this._i._n) {
      b = ((() => { let d = a.e(this._i, false); this._i = d.p0; return d.ret; })());
      c = b.f || c;
      this._aa(this._c._cw(this._i));
    }
    return c;
  }
  /**
   * @hidden
   */
  _p(a, b) {
    if (WorksheetRegionAddress._r(b, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && this._i._w >= b.value._w && this._i._ac >= b.value._ac && this._i._x <= b.value._x && this._i._ae <= b.value._ae) {
      let c = this._c.workbook;
      let d = c._df;
      c._df = false;
      this.worksheet._dataTables$i.remove_1(this);
      c._df = d;
      return true;
    }
    if (this._i._n && a.l._h(this._i)) {
      let e = this._i;
      this._aa(null);
      this._i = e;
    }
    return false;
  }
  /**
   * @hidden
   */
  _y(a, b, c, d) {
    let e = new WorksheetRegion(a, b._ac, b._w, b._ae, b._x);
    let f = null;
    if (WorksheetCellAddress.i(c, Nullable$1.toNullable(WorksheetCellAddress.$, null))) {
      f = new WorksheetCell(a._rows$i.item(c.value.o), c.value.m);
    }
    let g = null;
    if (WorksheetCellAddress.i(d, Nullable$1.toNullable(WorksheetCellAddress.$, null))) {
      g = new WorksheetCell(a._rows$i.item(d.value.o), d.value.m);
    }
    this._x(a, e, f, g);
  }
  /**
   * @hidden
   */
  _z() {
    this._aa(null);
    this._ab(null);
    this._ac(null);
    this._c = null;
  }
  /**
   * @hidden
   */
  static _ae(a, b, c, d, e, f, g) {
    if (a == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_DataTableRemoved"));
    }
    if (b == null) {
      throw new ArgumentNullException(0, c);
    }
    if (b.worksheet == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"), c);
    }
    if (b.worksheet != a) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellsInTableFromOtherWorksheet"), c);
    }
    if (WorksheetCell.l_op_Inequality(d, null)) {
      if (d.worksheet == null) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), e);
      }
      if (d.worksheet != a) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ColumnInputCellFromOtherWorksheet"), e);
      }
    }
    if (WorksheetCell.l_op_Inequality(f, null)) {
      if (f.worksheet == null) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"), g);
      }
      if (f.worksheet != a) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_RowInputCellFromOtherWorksheet"), g);
      }
    }
    if (WorksheetCell.l_op_Equality(d, null) && WorksheetCell.l_op_Equality(f, null)) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InputCellsBothNull"));
    }
    if (WorksheetCell.l_op_Equality(d, f)) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InputCellsSame"));
    }
    WorksheetDataTable._ad(b, d);
    WorksheetDataTable._ad(b, f);
  }
  /**
   * @hidden
   */
  _w(a, b) {
    if (a._n == false || this.worksheet == null) {
      return;
    }
    let c = this.worksheet._rows$i;
    let d = a._ac;
    let e = a._w;
    for (let f = d; f <= a._ae; f++) {
      let g = c.item(f);
      for (let h = e; h <= a._x; h++) {
        g._d4(h, b);
        if (f != d && h != e) {
          let i = b ? new DataTableInteriorFormula(this) : null;
          g._d6(h, i, false);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _x(a, b, c, d) {
    this._i = WorksheetRegionAddress._b;
    this._c = a;
    this._ab(c);
    this._ac(d);
    this.cellsInTable = b;
  }
  /**
   * @hidden
   */
  _aa(a) {
    let b = this._c == null ? null : this._c.workbook;
    let c = b._df;
    b._df = true;
    try {
      if (a != null) {
        if (a.firstRow == a.lastRow || a.firstColumn == a.lastColumn) {
          throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidOperationException_CellsInTableMinSize"), "value");
        }
        let d = a._v;
        for (let e = a.firstRow + 1; e <= a.lastRow; e++) {
          let f = this._c._cr(e, d);
          if (f == null) {
            continue;
          }
          if (f.firstColumn < d || d < f.lastColumn || f.firstRow < a.firstRow || a.lastRow < f.lastRow) {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellCrossesDataTableLeftColumn"));
          }
        }
        let g = a.worksheet;
        if (g == null) {
          return;
        }
        for (let h = (a._v + 1); h <= a._w; h++) {
          let i = g._cr(a.firstRow, h);
          if (i == null) {
            continue;
          }
          if (i.firstRow < a.firstRow || a.firstRow < i.lastRow || i.firstColumn < a.firstColumn || a.lastColumn < i.lastColumn) {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellCrossesDataTableTopRow"));
          }
        }
        let j = g._cr(a.firstRow, a._v);
        if (j != null) {
          if (j.firstRow == j.lastRow) {
            if (j.firstColumn < a.firstColumn || a.lastColumn < j.lastColumn) {
              throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellCrossesDataTableTopRow"));
            }
          }
          else if (j.firstColumn == j.lastColumn) {
            if (j.firstRow < a.firstRow || a.lastRow < j.lastRow) {
              throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellCrossesDataTableLeftColumn"));
            }
          }
          else {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellCrossesDataTableTopLeftCell"));
          }
        }
        let k = this._c._cx(a.firstRow + 1, a.firstColumn + 1, a.lastRow, a.lastColumn);
        WorksheetCellBlock.az(this, a, k);
      }
      this._w(this._i, false);
      this._i = a == null ? WorksheetRegionAddress._b : a._h;
      this._w(this._i, true);
      if (b != null) {
        b._hx(this);
      }
    }
    finally {
      b._df = c;
    }
  }
  /**
   * @hidden
   */
  static _ad(a, b) {
    if (WorksheetCell.l_op_Equality(b, null)) {
      return;
    }
    let c = b.columnIndex;
    let d = b.rowIndex;
    if (a.firstColumn <= c && c <= a.lastColumn && a.firstRow <= d && d <= a.lastRow) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InputCellsInTable"));
    }
  }
  /**
   * Gets or sets the region of cells in the data table.
   * <p class="body">
   * Any interior cells (cells not in the left-most column or top row) in this region will have their values removed
   * when this is set. If any interior cells have array formulas with a region that crosses outside the data
   * table, an error will occur. However, if the array formula's region is confined to cells in the
   * interior of the data table, the array formula will have [[ArrayFormula.clearCellRange]]
   * called on it, which will remove it from all its cells. Similarly, if an existing data table's interior cells
   * contain some of the interior cells in this region as well as some external cells, an error will occur.
   * However, if all interior cells of the existing data table are contained in the interior cells of the new
   * region specified here, the existing data table will be removed from the worksheet.
   * </p>
   * <p class="body">
   * After the cells in the table have been specified, the interior cells' values cannot be modified.
   * </p>
   * <p class="note">
   * <B>Note:</B> The [[rowInputCell]] and [[columnInputCell]] cannot be with the region.
   * </p>
   * The region of cells in the data table.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[ArgumentException]] The value assigned is a region from a worksheet other than the data table's worksheet.
   * @throws [[InvalidOperationException]] The region specified contains the RowInputCell or the ColumnInputCell.
   * @throws [[InvalidOperationException]] One or more of the interior cells of the value assigned (all cells except the left-most column and top row) is an
   * interior cell of another data table or is a cell in an array formula, and the entire range of that other
   * entity extends outside the interior cells of the value assigned.
   * @throws [[ArgumentException]] The assigned value is only one row tall or one column wide. The cells in the table must be at least two rows by two columns.
   * @throws [[InvalidOperationException]] The assigned value contains merged regions which are not confined to the left-most column or top row. No merged regions
   * can exist in the interior cells of the data table and no merged regions can exist in the left-most column or top row
   * and extend outside the data table region.
   * @see [[ArrayFormula]]
   * @see [[columnInputCell]]
   * @see [[rowInputCell]]
   */
  get cellsInTable() {
    if (this._c == null || this._i._n == false) {
      return null;
    }
    return this._c._cw(this._i);
  }
  /**
   * Gets or sets the region of cells in the data table.
   * <p class="body">
   * Any interior cells (cells not in the left-most column or top row) in this region will have their values removed
   * when this is set. If any interior cells have array formulas with a region that crosses outside the data
   * table, an error will occur. However, if the array formula's region is confined to cells in the
   * interior of the data table, the array formula will have [[ArrayFormula.clearCellRange]]
   * called on it, which will remove it from all its cells. Similarly, if an existing data table's interior cells
   * contain some of the interior cells in this region as well as some external cells, an error will occur.
   * However, if all interior cells of the existing data table are contained in the interior cells of the new
   * region specified here, the existing data table will be removed from the worksheet.
   * </p>
   * <p class="body">
   * After the cells in the table have been specified, the interior cells' values cannot be modified.
   * </p>
   * <p class="note">
   * <B>Note:</B> The [[rowInputCell]] and [[columnInputCell]] cannot be with the region.
   * </p>
   * The region of cells in the data table.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[ArgumentException]] The value assigned is a region from a worksheet other than the data table's worksheet.
   * @throws [[InvalidOperationException]] The region specified contains the RowInputCell or the ColumnInputCell.
   * @throws [[InvalidOperationException]] One or more of the interior cells of the value assigned (all cells except the left-most column and top row) is an
   * interior cell of another data table or is a cell in an array formula, and the entire range of that other
   * entity extends outside the interior cells of the value assigned.
   * @throws [[ArgumentException]] The assigned value is only one row tall or one column wide. The cells in the table must be at least two rows by two columns.
   * @throws [[InvalidOperationException]] The assigned value contains merged regions which are not confined to the left-most column or top row. No merged regions
   * can exist in the interior cells of the data table and no merged regions can exist in the left-most column or top row
   * and extend outside the data table region.
   * @see [[ArrayFormula]]
   * @see [[columnInputCell]]
   * @see [[rowInputCell]]
   */
  set cellsInTable(a) {
    let b = this.cellsInTable;
    if (Base.equalsStatic(b, a) == false) {
      WorksheetDataTable._ae(this._c, a, "value", this.columnInputCell, null, this.rowInputCell, null);
      this._aa(a);
    }
  }
  /**
   * @hidden
   */
  get _j() {
    return this._i;
  }
  /**
   * Gets or sets the cell used as the column-input cell in the data table.
   * <p class="body">
   * This represents the cell reference in all formulas of the data table to replace with row header values.
   * If this and the [[rowInputCell]] are non-null, the data table is a two-variable data table.
   * Otherwise, if only one is non-null, this is a one-variable data table.
   * </p>
   * <p class="note">
   * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
   * </p>
   * The cell used as the column-input cell in the data table.
   * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
   * @throws [[InvalidOperationException]] The assigned value is null and RowInputCell is null. At least one input cell must be non-null.
   * @throws [[InvalidOperationException]] The assigned value is the same as RowInputCell. The input cells cannot be the same cell.
   * @see [[cellsInTable]]
   * @see [[rowInputCell]]
   */
  get columnInputCell() {
    if (this._c == null || this._t == -1) {
      if (this._k) {
        return WorksheetCell._d;
      }
      return null;
    }
    return this._c._rows$i.item(this._t)._cells$i.item(this._r);
  }
  /**
   * Gets or sets the cell used as the column-input cell in the data table.
   * <p class="body">
   * This represents the cell reference in all formulas of the data table to replace with row header values.
   * If this and the [[rowInputCell]] are non-null, the data table is a two-variable data table.
   * Otherwise, if only one is non-null, this is a one-variable data table.
   * </p>
   * <p class="note">
   * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
   * </p>
   * The cell used as the column-input cell in the data table.
   * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
   * @throws [[InvalidOperationException]] The assigned value is null and RowInputCell is null. At least one input cell must be non-null.
   * @throws [[InvalidOperationException]] The assigned value is the same as RowInputCell. The input cells cannot be the same cell.
   * @see [[cellsInTable]]
   * @see [[rowInputCell]]
   */
  set columnInputCell(a) {
    if (WorksheetCell.l_op_Inequality(this.columnInputCell, a)) {
      WorksheetDataTable._ae(this._c, this.cellsInTable, null, a, "value", this.rowInputCell, null);
      this._ab(a);
    }
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      this._k = false;
      this._t = -1;
      this._r = -1;
    }
    else {
      this._k = true;
      this._t = a.rowIndex;
      this._r = a._ab;
    }
  }
  /**
   * @hidden
   */
  get _l() {
    return this._k;
  }
  /**
   * @hidden
   */
  get _m() {
    return this._q;
  }
  /**
   * @hidden
   */
  get _h() {
    if (this._c == null || this._i._n == false) {
      return null;
    }
    return this._c._cx(this._i._ac + 1, this._i._w + 1, this._i._ae, this._i._x);
  }
  /**
   * Gets or sets the cell used as the row-input cell in the data table.
   * <p class="body">
   * This represents the cell reference in all formulas of the data table to replace with column header values.
   * If this and the [[columnInputCell]] are non-null, the data table is a two-variable data table.
   * Otherwise, if only one is non-null, this is a one-variable data table.
   * </p>
   * <p class="note">
   * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
   * </p>
   * The cell used as the row-input cell in the data table.
   * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
   * @throws [[InvalidOperationException]] The assigned value is null and ColumnInputCell is null. At least one input cell must be non-null.
   * @throws [[InvalidOperationException]] The assigned value is the same as ColumnInputCell. The input cells cannot be the same cell.
   * @see [[cellsInTable]]
   * @see [[columnInputCell]]
   */
  get rowInputCell() {
    if (this._c == null || this._u == -1) {
      if (this._q) {
        return WorksheetCell._d;
      }
      return null;
    }
    return this._c._rows$i.item(this._u)._cells$i.item(this._s);
  }
  /**
   * Gets or sets the cell used as the row-input cell in the data table.
   * <p class="body">
   * This represents the cell reference in all formulas of the data table to replace with column header values.
   * If this and the [[columnInputCell]] are non-null, the data table is a two-variable data table.
   * Otherwise, if only one is non-null, this is a one-variable data table.
   * </p>
   * <p class="note">
   * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
   * </p>
   * The cell used as the row-input cell in the data table.
   * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
   * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
   * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
   * @throws [[InvalidOperationException]] The assigned value is null and ColumnInputCell is null. At least one input cell must be non-null.
   * @throws [[InvalidOperationException]] The assigned value is the same as ColumnInputCell. The input cells cannot be the same cell.
   * @see [[cellsInTable]]
   * @see [[columnInputCell]]
   */
  set rowInputCell(a) {
    if (WorksheetCell.l_op_Inequality(this.rowInputCell, a)) {
      WorksheetDataTable._ae(this._c, this.cellsInTable, null, this.columnInputCell, null, a, "value");
      this._ac(a);
    }
  }
  /**
   * @hidden
   */
  _ac(a) {
    if (WorksheetCell.l_op_Equality(a, null)) {
      this._q = false;
      this._u = -1;
      this._s = -1;
    }
    else {
      this._q = true;
      this._u = a.rowIndex;
      this._s = a._ab;
    }
  }
  /**
   * Gets the worksheet on which this data table resides.
   */
  get worksheet() {
    return this._c;
  }
}
WorksheetDataTable.$t = markType(WorksheetDataTable, 'WorksheetDataTable', Base.$, [IRegionBlockingValue_$type]);
/**
 * @hidden
 */
export class UltraCalcFunctionFactory extends Base {
  constructor() {
    super();
    this._h = null;
    this._a = null;
    this._a = new Array(15);
    this._a[0] = new UltraCalcFunctionPlus();
    this._a[1] = new UltraCalcFunctionMinus();
    this._a[2] = new UltraCalcFunctionMultiply();
    this._a[3] = new UltraCalcFunctionDivide();
    this._a[4] = new UltraCalcFunctionEqual();
    this._a[5] = new UltraCalcFunctionNE();
    this._a[6] = new UltraCalcFunctionGE();
    this._a[7] = new UltraCalcFunctionGT();
    this._a[8] = new UltraCalcFunctionLE();
    this._a[9] = new UltraCalcFunctionLT();
    this._a[10] = new UltraCalcFunctionConcat();
    this._a[11] = new UltraCalcFunctionExpon();
    this._a[12] = new UltraCalcFunctionPercent();
    this._a[13] = new UltraCalcFunctionUnaryMinus();
    this._a[14] = new UltraCalcFunctionUnaryPlus();
    this._h = new Dictionary$2(String_$type, ExcelCalcFunction.$, 2, StringUtilities.e);
    this._g(new UltraCalcFunctionXLIntersect());
    this._g(new UltraCalcFunctionXLRange());
    this._g(new UltraCalcFunctionXLUnion());
    if (UltraCalcFunctionFactory._f != null) {
      UltraCalcFunctionFactory._f(this);
    }
  }
  static get _e() {
    if (UltraCalcFunctionFactory._d == null) {
      UltraCalcFunctionFactory._d = new UltraCalcFunctionFactory();
    }
    return UltraCalcFunctionFactory._d;
  }
  _item(a) {
    if (a == null) {
      return null;
    }
    let b;
    let c = this._h.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  _g(a) {
    if (a == null) {
      throw new ArgumentNullException(1);
    }
    let b = this._i(a);
    if (b.length == 0) {
      return false;
    }
    this._h.item(b, a);
    return true;
  }
  _i(a) {
    let b = a.name;
    if (b == null) {
      return stringEmpty();
    }
    return stringToLocaleLower(b, CultureInfo.invariantCulture);
  }
  _j() {
    for (let a = 0; a < this._a.length; a++) {
    }
  }
  _b(a) {
    let b = a;
    return this._a[b];
  }
  *_getEnumeratorObject() {
    for (let a of fromEnum(this._h)) {
      yield a.value;
    }
  }
  getEnumeratorObject() {
    return toEnum(() => this._getEnumeratorObject()).getEnumeratorObject();
  }
}
UltraCalcFunctionFactory.$t = markType(UltraCalcFunctionFactory, 'UltraCalcFunctionFactory', Base.$, [IEnumerable_$type]);
UltraCalcFunctionFactory._d = null;
UltraCalcFunctionFactory._f = null;
/**
 * @hidden
 */
export class UltraCalcException extends BaseError {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(2, c, d);
        }
        break;
    }
  }
}
UltraCalcException.$t = markType(UltraCalcException, 'UltraCalcException', BaseError.$);
/**
 * @hidden
 */
export class UltraCalcErrorException extends UltraCalcException {
  constructor(a) {
    super(0);
    this._c = null;
    this._c = a;
  }
  get _value() {
    return this._c;
  }
  toString() {
    return this._c.toString();
  }
}
UltraCalcErrorException.$t = markType(UltraCalcErrorException, 'UltraCalcErrorException', UltraCalcException.$);
/**
 * Provides methods and properties used to define and manage a calculation error value.
 */
export class ExcelCalcErrorValue extends Base {
  constructor(..._rest) {
    super();
    this._b = 0;
    this._i = null;
    this._g = null;
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    else if (arguments.length === 3) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let code = _rest[0];
          this._b = code;
          if (code == 2) {
            this._i = ExcelUtils.ef("Error_UCErrorCode_Div");
          }
          else if (code == 3) {
            this._i = ExcelUtils.ef("Error_UCErrorCode_NA");
          }
          else if (code == 4) {
            this._i = ExcelUtils.ef("Error_UCErrorCode_Num");
          }
          else if (code == 0) {
            this._i = ExcelUtils.ef("Error_UCErrorCode_Reference");
          }
          else if (code == 1) {
            this._i = ExcelUtils.ef("Error_UCErrorCode_Value");
          }
          else {
            this._i = ExcelUtils.ef("Error_UCErrorCode_Unknown");
          }
          this._l(code);
        }
        break;
      case 1:
        {
          let code = _rest[0];
          let message = _rest[1];
          this._b = code;
          this._i = message;
        }
        break;
      case 2:
        {
          let code = _rest[0];
          let message = _rest[1];
          let value = _rest[2];
          this._b = code;
          this._i = message;
          this._g = value;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static get _e() {
    if (ExcelCalcErrorValue._c == null) {
      ExcelCalcErrorValue._c = new ExcelCalcErrorValue(7);
    }
    return ExcelCalcErrorValue._c;
  }
  /**
   * @hidden
   */
  static get _f() {
    if (ExcelCalcErrorValue._d == null) {
      ExcelCalcErrorValue._d = new ExcelCalcErrorValue(0);
    }
    return ExcelCalcErrorValue._d;
  }
  /**
   * @hidden
   */
  _l(a) {
    if (a == 6) {
      this._i = ExcelUtils.ef("Error_UCErrorCode_Null");
    }
    else if (a == 7) {
      this._i = ExcelUtils.ef("Error_UCErrorCode_Name");
    }
  }
  /**
   * Gets the error code for this class instance
   */
  get code() {
    return this._b;
  }
  /**
   * Gets error message for this class instance. Note that when setting this property the
   * message is assumed to be localized.
   */
  get message() {
    return this._i;
  }
  /**
   * Gets the error object for this class instance
   */
  get errorValue() {
    return this._g;
  }
  /**
   * Return a string message that denotes reason for error
   * @return String containing error message
   */
  toString() {
    if (this._b == 2) {
      return ExcelUtils.ef("Value_UCErrorCode_Div");
    }
    else if (this._b == 4) {
      return ExcelUtils.ef("Value_UCErrorCode_Num");
    }
    else if (this._b == 3) {
      return ExcelUtils.ef("Value_UCErrorCode_NA");
    }
    else if (this._b == 1) {
      return ExcelUtils.ef("Value_UCErrorCode_Value");
    }
    else if (this._b == 0) {
      return ExcelUtils.ef("Value_UCErrorCode_Reference");
    }
    else if (this._b == 6) {
      return ExcelUtils.ef("Value_UCErrorCode_Null");
    }
    else if (this._b == 7) {
      return ExcelUtils.ef("Value_UCErrorCode_Name");
    }
    else {
      return ExcelUtils.ef("Value_UCErrorCode_Unknown");
    }
  }
  /**
   * @hidden
   */
  _m() {
    if (typeCast(UltraCalcException.$, this._g) !== null) {
      throw this._g;
    }
    else {
      throw new UltraCalcErrorException(this);
    }
  }
}
ExcelCalcErrorValue.$t = markType(ExcelCalcErrorValue, 'ExcelCalcErrorValue');
/**
 * @hidden
 */
ExcelCalcErrorValue._c = null;
/**
 * @hidden
 */
ExcelCalcErrorValue._d = null;
/**
 * @hidden
 */
export class ExcelCalcValue_ArrayProxyGroup extends Base {
  constructor(a) {
    super();
    this.a = null;
    this.a = a;
  }
  get b() {
    return this.a;
  }
  get d() {
    return this.a.length;
  }
  item(a, b) {
    if (arguments.length === 2) {
      this.a[a] = b;
      return b;
    }
    else {
      return this.a[a];
    }
  }
}
ExcelCalcValue_ArrayProxyGroup.$t = markType(ExcelCalcValue_ArrayProxyGroup, 'ExcelCalcValue_ArrayProxyGroup');
/**
 * @hidden
 */
export class CalculationContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.a = null;
    this.d = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.c = d;
          this.a = c;
          this.d = false;
        }
        break;
    }
  }
  static b(a) {
    if (a.a == null) {
      return {
        ret: null,
        p0: a
      };
    }
    return {
      ret: a.a._k,
      p0: a
    };
  }
}
CalculationContext.$t = markStruct(CalculationContext, 'CalculationContext');
/**
 * Provides methods that manage a composite data type representing a value.
 * <p class="body">
 * An instance of this class may contain one of several base data types including doubles, singles, integers, booleans, strings, and error values.
 * <p></p>
 * The class implements the IConvertible interface providing methods to perform conversions between the basic data types.
 * <p></p>
 * Additionally the class provides methods to perform basic arithmetic operations and comparisons between [[ExcelCalcValue]] objects.
 * </p>
 */
export class ExcelCalcValue extends Base {
  constructor(..._rest) {
    super();
    /**
     * @hidden
     */
    this._n = new CalculationContext();
    this._x = false;
    this._bl = null;
    let a;
    if (arguments.length === 0) {
      a = 1;
    }
    else if (arguments.length === 1) {
      a = 0;
    }
    switch (a) {
      case 0:
        {
          let value = _rest[0];
          this._bt(value);
        }
        break;
      case 1:
        {
          let b = [null];
          {
            let value = b[0];
            this._bt(value);
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _bu() {
    let a = typeCast(Array_$type, this._bl);
    if (a == null) {
      return;
    }
    if (a.length != 0 && typeCast(ArrayProxy.$, a[0]) !== null) {
      let b = this._bl;
      this._bl = new ExcelCalcValue_ArrayProxyGroup(b);
      return;
    }
    if (a.length == 0 || (typeCast(Array_$type, a[0]) !== null && typeCast(ExcelCalcValue.$, a[0][0]) !== null)) {
      let c = a;
      this._bl = new CLRArrayProxy(1, c);
      return;
    }
    if (a.length == 0 || (typeCast(Array_$type, a[0]) !== null && typeCast(Array_$type, a[0][0]) !== null && typeCast(ExcelCalcValue.$, a[0][0][0]) !== null)) {
      let d = a;
      let e = new Array(d.length);
      for (let f = 0; f < d.length; f++) {
        e[f] = new CLRArrayProxy(1, d[f]);
      }
      this._bl = e;
      return;
    }
  }
  /**
   * @hidden
   */
  _k(a, b) {
    return {
      ret: ((() => { let c = this._l(a, true, b); b = c.p2; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  _l(a, b, c) {
    c = null;
    let d = this._m();
    let e = typeCast(RefBase.$, ExcelCalcEngine.b(d));
    if (e != null) {
      let f = ((() => { let g = e._m(this._n, b, c); this._n = g.p0; c = g.p2; return g.ret; })());
      if (f != e) {
        if (f == null) {
          return {
            ret: null,
            p2: c
          };
        }
        e = f;
        this._y = true;
      }
      e._e = this._n;
      e._e.d = a;
      if (this._y) {
        e = e._o();
      }
      return {
        ret: e,
        p2: c
      };
    }
    return {
      ret: d,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _br(a) {
    for (let c = 0; c < a.length; c++) {
      let b = a[c];
      b._f = this;
    }
  }
  /**
   * @hidden
   */
  _bk(a, b, c, d) {
    let e = b.getLength(0);
    let f = b.getLength(1);
    if (e == 0 || f == 0) {
      return new ExcelCalcErrorValue(1);
    }
    let g;
    let h = typeCast(CellCalcReference.$, ((() => { let i = CalculationContext.b(this._n); this._n = i.p0; return i.ret; })()));
    if (h != null && h._a4) {
      g = CalcUtilities.d(b, h);
      if (g == null) {
        return new ExcelCalcErrorValue(3);
      }
    }
    else if ((1 < e || 1 < f) && a.isReference) {
      g = null;
      let i = false;
      if ((e == 1 || f == 1) && h != null) {
        let j = CalcUtilities.l(a.toReference());
        if (j.count == 1) {
          let k = j.item(0);
          if (e == 1) {
            let l = h._w.index;
            if (k.firstRow <= l && l <= k.lastRow) {
              g = b.item(0, l - k.firstRow);
              i = true;
            }
          }
          if (f == 1) {
            let m = h._ao;
            if (k.firstColumn <= m && m <= k.lastColumn) {
              g = b.item(m - k.firstColumn, 0);
              i = true;
            }
          }
        }
      }
      if (i == false) {
        return new ExcelCalcErrorValue(1);
      }
    }
    else {
      g = b.item(0, 0);
    }
    g._n = this._n;
    return g._bj(d, c);
  }
  /**
   * Returns whether this class instance contains an array value.
   * @return True if this instance class contains an array, else false.
   * @see [[toArrayProxy]]
   */
  get isArray() {
    return typeCast(ArrayProxy.$, this._getResolvedValue3(false)) !== null;
  }
  /**
   * Returns whether this class instance contains a group of array values.
   * @return True if this instance class contains an array group, else false.
   * @see [[toArrayProxyGroup]]
   */
  get isArrayGroup() {
    return typeCast(ExcelCalcValue_ArrayProxyGroup.$, this._getResolvedValue3(false)) !== null;
  }
  /**
   * @hidden
   */
  get _s() {
    return typeCast(ArrayProxy.$, this._bh(this, false, false, false)) !== null;
  }
  /**
   * @hidden
   */
  get _y() {
    return this._x;
  }
  /**
   * @hidden
   */
  set _y(a) {
    this._x = a;
  }
  /**
   * Convert this class instance's value to an [[ArrayProxy]] data type.
   * @return An array equivalent to the value of this instance.
   * @see [[ArrayProxy]]
   */
  toArrayProxy() {
    return this._d(true);
  }
  /**
   * @hidden
   */
  _d(a) {
    let b = this._bj(a, false);
    let c = typeCast(ArrayProxy.$, b);
    if (c == null) {
      let d = typeCast(ExcelCalcValue_ArrayProxyGroup.$, b);
      if (d != null) {
        if (d.d != 1) {
          return new CLRArrayProxy(0, new ExcelCalcValue(new ExcelCalcErrorValue(1)));
        }
        c = d.item(0);
      }
      else {
        c = new CLRArrayProxy(0, this);
      }
    }
    c._f = this;
    return c;
  }
  /**
   * @hidden
   */
  _e() {
    let a = typeCast(ArrayProxy.$, this._bh(this, false, false, false));
    return a;
  }
  /**
   * Convert this class instance's value to an array group data type.
   * @return An array group equivalent to the value of this instance.
   * @see [[ArrayProxy]]
   */
  toArrayProxyGroup() {
    return this._b(true);
  }
  /**
   * @hidden
   */
  _b(a) {
    let b = this._bj(a, false);
    let c = typeCast(ExcelCalcValue_ArrayProxyGroup.$, b);
    let d;
    if (c == null) {
      let e = typeCast(ArrayProxy.$, b);
      if (e != null) {
        d = [e];
      }
      else {
        d = [new CLRArrayProxy(0, this)];
      }
    }
    else {
      d = c.b;
    }
    this._br(d);
    return d;
  }
  /**
   * @hidden
   */
  get _o() {
    let a = this._n.a;
    if (a == null) {
      return null;
    }
    return a._r;
  }
  /**
   * @hidden
   */
  toUInt64(provider) {
    return truncate(this._toDecimal(provider));
  }
  /**
   * @hidden
   */
  toSByte(provider) {
    return truncate(this._toDecimal(provider));
  }
  /**
   * @hidden
   */
  toUInt16(provider) {
    return truncate(this._toDecimal(provider));
  }
  /**
   * @hidden
   */
  toUInt32(provider) {
    return truncate(this._toDecimal(provider));
  }
  /**
   * @hidden
   */
  _bt(a) {
    if (typeCast(BaseError.$, a) !== null) {
      this._bs(a);
    }
    else {
      this._bl = a;
      this._bu();
    }
  }
  toInt() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._toInt.apply(this, arguments);
      case 1: return this._toInt1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toInt() {
    return this._toInt1(this._a0);
  }
  /**
   * @hidden
   */
  _toInt1(a) {
    return truncate(this._toDecimal(a));
  }
  /**
   * @hidden
   */
  _bs(a) {
    if (typeCast(UltraCalcErrorException.$, a) !== null) {
      this._bl = a._value;
    }
    else if (typeCast(DivideByZeroException.$, a) !== null) {
      this._bl = new ExcelCalcErrorValue(2, a.message, a);
    }
    else if (typeCast(ArithmeticException.$, a) !== null) {
      this._bl = new ExcelCalcErrorValue(4, a.message, a);
    }
    else if (typeCast(InvalidCastException.$, a) !== null) {
      this._bl = new ExcelCalcErrorValue(4, a.message, a);
    }
    else if (typeCast(FormatException.$, a) !== null) {
      this._bl = new ExcelCalcErrorValue(1, a.message, a);
    }
    else {
      this._bl = new ExcelCalcErrorValue(1, a.message, a);
    }
    return;
  }
  /**
   * Convert this instance's value to a [[IExcelCalcReference]].
   * <p class="body">
   * The instance value's underlying data type must be reference to return a reference, else an error reference is returned.
   * <p></p>
   * If there is no meaningful conversion to a reference, this method will throw an <b>InvalidCastException</b>
   * </p>
   * @return If this instance contains a object that implements the [[IExcelCalcReference]] interface, this method returns the object instance, else an error reference is returned.
   */
  toReference() {
    let a;
    let b = ((() => { let c = this._k(true, a); a = c.p1; return c.ret; })());
    if (b != null) {
      return b;
    }
    return ExcelCalcValue._h();
  }
  /**
   * @hidden
   */
  _j(a) {
    let b;
    return ((() => { let c = this._k(a, b); b = c.p1; return c.ret; })());
  }
  /**
   * @hidden
   */
  _m() {
    if (typeCast(IExcelCalcReference_$type, this._bl) !== null) {
      return this._bl;
    }
    if (typeCast(ExcelCalcErrorValue.$, this._bl) !== null) {
      this._bl._m();
    }
    return ExcelCalcValue._h();
  }
  /**
   * @hidden
   */
  static _h() {
    return ExcelReferenceError._a2;
  }
  /**
   * Convert this instance's value to an [[ExcelCalcErrorValue]]
   * <p class="body">
   * This method returns an [[ExcelCalcErrorValue]] whose error code is set this instance's error code.
   * <p></p>
   * If there this instance does not contain an error, a [[ExcelCalcErrorValue]] containing a default value is returned
   * </p>
   * @return A [[ExcelCalcErrorValue]] containing the equivalent error code to the value of this instance
   */
  toErrorValue() {
    let a = this._getResolvedValue();
    return typeCast(ExcelCalcErrorValue.$, a);
  }
  /**
   * Returns a string representation of this instance's value.
   * @return String representation of instance's value
   */
  toString() {
    return this.toString1(this._a0);
  }
  /**
   * Returns whether this class instance contains a [[IExcelCalcReference]] value
   * @return True if this instance class contains a reference, else false
   */
  get isReference() {
    if ((typeCast(IExcelCalcReference_$type, this._bl) !== null) == false) {
      return false;
    }
    let a;
    return ((() => { let b = this._k(false, a); a = b.p1; return b.ret; })()) != null;
  }
  /**
   * Returns whether this class instance contains an error value
   * @return True if this class instance contains an error, else false
   */
  get isError() {
    return ExcelCalcValue._aa(this._getResolvedValue3(false));
  }
  /**
   * @hidden
   */
  static _aa(a) {
    return typeCast(ExcelCalcErrorValue.$, a) !== null;
  }
  /**
   * Returns whether this class instance contains a null value
   * @return True if this instance class contains a null value, else false
   */
  get isNull() {
    let a = this._getResolvedValue3(false);
    return ExcelCalcValue._ac(a);
  }
  /**
   * @hidden
   */
  static _ac(a) {
    if (ExcelUtils.a9(a)) {
      return true;
    }
    if (true) {
      return false;
    }
    let b = typeCast(String_$type, a);
    return b != null && b.length == 0;
  }
  /**
   * Returns whether this class instance contains a DBNull value
   * @return True if this instance class contains a null value, else false
   */
  get isDBNull() {
    return false;
  }
  /**
   * Returns whether this class instance contains a string value
   * @return True if this instance class contains a string, else false
   */
  get isString() {
    let a = this._getResolvedValue3(false);
    return ExcelCalcValue._ag(a);
  }
  /**
   * @hidden
   */
  static _ag(a) {
    if (typeof a === 'string') {
      return true;
    }
    if (typeCast(StringElement.$, a) !== null) {
      return true;
    }
    if (typeCast(HyperlinkResult.$, a) !== null) {
      return true;
    }
    return false;
  }
  /**
   * Returns whether this class instance contains a boolean value
   * @return True if this instance class contains a boolean, else false
   */
  get isBoolean() {
    return ExcelCalcValue._u(this._getResolvedValue3(false));
  }
  /**
   * @hidden
   */
  static _u(a) {
    return typeCast(Boolean_$type, a) !== null;
  }
  /**
   * Returns whether this class instance contains a DateTime value
   * @return True if this instance class contains a DateTime, else false
   */
  get isDateTime() {
    let a = this._getResolvedValue3(false);
    return typeCast(Date_$type, a) !== null;
  }
  /**
   * Return the underlying value
   */
  get value() {
    return this._bl;
  }
  /**
   * Indicates if the value of the specified [[ExcelCalcValue]] is equivalent to the [[value]]
   * @param x First [[ExcelCalcValue]] to compare
   * @param y Second [[ExcelCalcValue]] to compare
   * @return True if the values are the same; otherwise false is returned.
   */
  static areValuesEqual(x, y) {
    if (null == x) {
      return null == y;
    }
    if (null == y) {
      return false;
    }
    let a = x._getResolvedValue();
    let b = y._getResolvedValue();
    if (true) {
      if (x.isString && y.isString) {
        let c = a.toString();
        let d = b.toString();
        if (StringUtilities.c(c, d, x._a0, 1) == 0) {
          return true;
        }
      }
    }
    if (typeCast(IComparable_$type, a) !== null && typeCast(IComparable_$type, b) !== null && getInstanceType(a) == getInstanceType(b)) {
      return CompareUtil.compareToObject(a, b) == 0;
    }
    if (true) {
      if (a == null) {
        if (b == null || (typeof b === 'string' && b == stringEmpty()) || (typeCast(Boolean_$type, b) !== null && b == false)) {
          return true;
        }
      }
      else if (b == null) {
        if ((typeof a === 'string' && a == stringEmpty()) || (typeCast(Boolean_$type, a) !== null && a == false)) {
          return true;
        }
      }
      if (x.isBoolean != y.isBoolean) {
        return false;
      }
      if (x.isString != y.isString) {
        return false;
      }
    }
    let e, f;
    if (((() => { let g = x._toDouble1(e); e = g.p0; return g.ret; })()) && ((() => { let g = y._toDouble1(f); f = g.p0; return g.ret; })())) {
      return e == f;
    }
    return stringEquals1(x.toString(), y.toString(), 4);
  }
  /**
   * @hidden
   */
  compareToObject(value) {
    return this.compareTo(value);
  }
  /**
   * Compares current instance with the passed in [[ExcelCalcValue]] instance. Returns
   * -1, 1 or 0 depending on whether the current instance is less than, greater than
   * or equal to the passed in instance respectively.
   * @param value The object that this instance should be compared against.
   * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
   * or equal to the passed in instance respectively.
   */
  compareTo(value) {
    return ExcelCalcValue._compareTo1(this, value);
  }
  /**
   * Compares x and y [[ExcelCalcValue]] instances and returns -1 if x is less than y,
   * 1 if x is greater than y and 0 if x and y are equal.
   * @param x The first value to compare.
   * @param y The value to compare with the first value.
   * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
   * or equal to the passed in instance respectively.
   */
  static compareTo(x, y) {
    return ExcelCalcValue._compareTo1.apply(null, arguments);
  }
  /**
   * @hidden
   */
  static _compareTo1(a, b) {
    if (Base.referenceEquals(a, b)) {
      return 0;
    }
    else if (Base.referenceEquals(a, null)) {
      return -1;
    }
    else if (Base.referenceEquals(b, null)) {
      return 1;
    }
    return ExcelCalcValue._a4(a, a._getResolvedValue(), b, b._getResolvedValue());
  }
  /**
   * @hidden
   */
  static _a4(a, b, c, d) {
    let e = a._a0;
    if (true) {
      let f = ExcelCalcValue._u(b);
      let g = ExcelCalcValue._u(d);
      if (f && g == false) {
        return 1;
      }
      else if (g && f == false) {
        return -1;
      }
      let h = ExcelCalcValue._ag(b);
      let i = ExcelCalcValue._ag(d);
      if (h && i == false) {
        return 1;
      }
      else if (i && h == false) {
        return -1;
      }
      if (h && i) {
        let j = a._bp(b, e);
        let k = c._bp(d, e);
        return stringCompare(j, k);
      }
    }
    let l, m;
    let n;
    if (((() => { let o = a._ao(b, l, e, n); l = o.p1; n = o.p3; return o.ret; })()) && ((() => { let o = c._ao(d, m, e, n); m = o.p1; n = o.p3; return o.ret; })())) {
      l = MathUtilities.i(l);
      m = MathUtilities.i(m);
      return Base.compareSimple(l, m);
    }
    if (null != b && null != d && getInstanceType(b) == getInstanceType(d)) {
      let o = typeCast(IComparable_$type, b);
      if (null != o) {
        return CompareUtil.compareToObject(o, d);
      }
    }
    let p = a._bp(b, e);
    let q = c._bp(d, e);
    return stringCompare(p, q);
  }
  /**
   * Indicates if the specified [[ExcelCalcValue]] has the save [[value]] as this instance.
   * @param value [[ExcelCalcValue]] to compare against.
   * @return True if the [[value]] of both instances are equal; otherwise false.
   */
  isSameValue(value) {
    return ExcelCalcValue.areValuesEqual(this, value);
  }
  /**
   * @hidden
   */
  _ah(a) {
    let b = this._bj(true, false);
    if (typeCast(Boolean_$type, b) !== null) {
      return b;
    }
    if (ExcelCalcValue._aa(b) || ExcelCalcValue._ac(b)) {
      return false;
    }
    if (ExcelCalcValue._ag(b)) {
      let c = this._bp(b, a);
      let d;
      if (((() => { let e = tryParseBool(c, d); d = e.p1; return e.ret; })())) {
        return d;
      }
    }
    let e;
    let f;
    if (((() => { let g = this._ao(b, f, a, e); f = g.p1; e = g.p3; return g.ret; })())) {
      return f != 0;
    }
    return false;
  }
  getResolvedValue() {
    let n;
    if (arguments.length === 0) {
      n = 0;
    }
    else if (arguments.length === 1) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getResolvedValue.apply(this, arguments);
      case 1: return this._getResolvedValue3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getResolvedValue() {
    return this._bj(true, false);
  }
  toDouble() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toDouble.apply(this, arguments);
      case 1: return this._toDouble3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toDouble3() {
    return this._toDouble(this._a0);
  }
  /**
   * @hidden
   */
  _toDouble(a) {
    let b;
    let c;
    if (((() => { let d = this._toDouble2(b, a, c); b = d.p0; c = d.p2; return d.ret; })())) {
      return b;
    }
    throw c || new InvalidCastException(null, null);
  }
  /**
   * @hidden
   */
  _toDouble1(a) {
    let b;
    return {
      ret: ((() => { let c = this._toDouble2(a, this._a0, b); a = c.p0; b = c.p2; return c.ret; })()),
      p0: a
    };
  }
  /**
   * @hidden
   */
  _toDouble2(a, b, c) {
    let d = this._getResolvedValue();
    return {
      ret: ((() => { let e = this._ao(d, a, b, c); a = e.p1; c = e.p3; return e.ret; })()),
      p0: a,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _ao(a, b, c, d) {
    d = null;
    if (typeof a === 'number') {
      b = a;
      return {
        ret: true,
        p1: b,
        p3: d
      };
    }
    if (ExcelCalcValue._ac(a)) {
      b = 0;
      return {
        ret: true,
        p1: b,
        p3: d
      };
    }
    if (typeof a === 'string') {
      if (((() => { let e = MathUtilities.c(a, c, b); b = e.p2; return e.ret; })())) {
        return {
          ret: true,
          p1: b,
          p3: d
        };
      }
      let e;
      let f = ((() => { let g = dateTryParse(a, e); e = g.p1; return g.ret; })());
      if (f) {
        let g = ExcelCalcValue._dateTimeToExcelDate(this._o, e);
        if (g.hasValue) {
          let h = c == null ? MathUtilities.l.dateTimeFormat : c.getFormat(DateTimeFormat.$);
          if (c != null && stringContains(a, ExcelUtils.ec(h))) {
            b = g.value;
            return {
              ret: true,
              p1: b,
              p3: d
            };
          }
        }
      }
      d = new FormatException(0);
      return {
        ret: false,
        p1: b,
        p3: d
      };
    }
    if (true && typeCast(Date_$type, a) !== null) {
      let i = ExcelCalcValue._dateTimeToExcelDate(this._o, a);
      if (i.hasValue == false) {
        d = new ArgumentOutOfRangeException(0);
        b = 0;
        return {
          ret: false,
          p1: b,
          p3: d
        };
      }
      b = i.value;
      return {
        ret: true,
        p1: b,
        p3: d
      };
    }
    try {
      if (!true && typeCast(Date_$type, a) !== null) {
        b = 0;
        return {
          ret: false,
          p1: b,
          p3: d
        };
      }
      let j = typeCast(IConvertible_$type, a);
      if (j != null) {
        b = ConvertUtil.toDouble(j, c);
        return {
          ret: true,
          p1: b,
          p3: d
        };
      }
      else {
        b = 0;
        return {
          ret: false,
          p1: b,
          p3: d
        };
      }
    }
    catch (k) {
      d = k;
      b = 0;
      return {
        ret: false,
        p1: b,
        p3: d
      };
    }
  }
  toDateTime() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toDateTime.apply(this, arguments);
      case 1: return this._toDateTime1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toDateTime1() {
    return this._toDateTime(this._a0);
  }
  /**
   * @hidden
   */
  _toDateTime(a) {
    let b;
    if (((() => { let c = this._aj(a, b, false); b = c.p1; return c.ret; })()) == false) {
      throw new InvalidCastException(null, null);
    }
    return b;
  }
  /**
   * @hidden
   */
  _aj(a, b, c = true, d = false) {
    let e = this._bj(true, true);
    if (typeCast(Date_$type, e) !== null) {
      b = e;
      return {
        ret: true,
        p1: b
      };
    }
    if (true) {
      let f;
      let g;
      if (((() => { let h = this._toDouble2(f, a, g); f = h.p0; g = h.p2; return h.ret; })())) {
        let h = ExcelCalcValue._be(this._o, f, true, d && f >= 0 && f < 1);
        if (h.hasValue == false) {
          b = dateMinValue();
          return {
            ret: false,
            p1: b
          };
        }
        b = h.value;
        return {
          ret: true,
          p1: b
        };
      }
    }
    if (typeof e === 'number') {
      try {
        b = dateFromTicks((typeGetValue(e)));
        return {
          ret: true,
          p1: b
        };
      }
      catch (i) {
        b = dateMinValue();
        return {
          ret: false,
          p1: b
        };
      }
    }
    if (c && typeof e === 'string') {
      let j = ((() => { let k = dateTryParse(e, b); b = k.p1; return k.ret; })());
      return {
        ret: j,
        p1: b
      };
    }
    if (typeCast(IConvertible_$type, e) !== null) {
      b = ConvertUtil.toDateTime(e, a);
      return {
        ret: true,
        p1: b
      };
    }
    b = dateMinValue();
    return {
      ret: false,
      p1: b
    };
  }
  toSingle() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toSingle.apply(this, arguments);
      case 1: return this._toSingle1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toSingle1() {
    return this._toSingle(this._a0);
  }
  /**
   * @hidden
   */
  _toSingle(a) {
    return this._toDouble(a);
  }
  toBoolean() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toBoolean.apply(this, arguments);
      case 1: return this._toBoolean1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toBoolean1() {
    return this._toBoolean(this._a0);
  }
  /**
   * @hidden
   */
  _toBoolean(a) {
    let b = this._bj(true, true);
    if (typeCast(Boolean_$type, b) !== null) {
      return b;
    }
    if (ExcelCalcValue._ac(b)) {
      return false;
    }
    let c = typeCast(String_$type, b);
    if (c != null) {
      let d;
      if (((() => { let e = tryParseBool(c, d); d = e.p1; return e.ret; })())) {
        return d;
      }
      if (true) {
        throw new FormatException(0);
      }
    }
    return this._toDouble(a) != 0;
  }
  toInt32() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toInt32.apply(this, arguments);
      case 1: return this._toInt321.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toInt321() {
    return this._toInt32(this._a0);
  }
  /**
   * @hidden
   */
  _toInt32(a) {
    return truncate(this._toDecimal(a));
  }
  toInt16() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toInt16.apply(this, arguments);
      case 1: return this._toInt161.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toInt161() {
    return this._toInt16(this._a0);
  }
  /**
   * @hidden
   */
  _toInt16(a) {
    return truncate(this._toDecimal(a));
  }
  /**
   * Convert this class instance's value to a string instance data type
   * <p class="body">
   * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
   * </p>
   * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
   * @return A string instance equivalent to the value of this instance
   */
  toString1(provider) {
    let a = this._getResolvedValue();
    return this._bp(a, provider);
  }
  /**
   * @hidden
   */
  _bp(a, b) {
    if (true) {
      if (typeCast(Boolean_$type, a) !== null) {
        return boolToString(a, b).toUpperCase();
      }
      if (typeCast(Date_$type, a) !== null) {
        let c;
        let d;
        if (((() => { let e = this._ao(a, c, b, d); c = e.p1; d = e.p3; return e.ret; })())) {
          return numberToString(c, b);
        }
        else {
        }
      }
    }
    if (typeof a === 'number') {
      return numberToString2(a, "G", b);
    }
    if (typeCast(IConvertible_$type, a) !== null) {
      return ConvertUtil.toString1(a, b);
    }
    else if (typeCast(ExcelCalcErrorValue.$, a) !== null) {
      return a.toString();
    }
    else if (typeCast(UltraCalcErrorException.$, a) !== null) {
      return a.toString();
    }
    else if (null == a) {
      return "";
    }
    else {
      return a.toString();
    }
  }
  toByte() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toByte.apply(this, arguments);
      case 1: return this._toByte1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toByte1() {
    return this._toByte(this._a0);
  }
  /**
   * @hidden
   */
  _toByte(a) {
    return truncate(this._toDecimal(a));
  }
  toChar() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toChar.apply(this, arguments);
      case 1: return this._toChar1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toChar1() {
    return this._toChar(this._a0);
  }
  /**
   * @hidden
   */
  _toChar(a) {
    let b = this._bj(true, true);
    let c = typeCast(IConvertible_$type, b);
    if (c != null) {
      return ConvertUtil.toChar(c, a);
    }
    else {
      throw new InvalidCastException(null, null);
    }
  }
  toInt64() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toInt64.apply(this, arguments);
      case 1: return this._toInt641.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toInt641() {
    return this._toInt64(this._a0);
  }
  /**
   * @hidden
   */
  _toInt64(a) {
    if (!true) {
      let b = this._bj(true, true);
      if (typeCast(Date_$type, b) !== null) {
        return b.getTime();
      }
    }
    return truncate(this._toDecimal(a));
  }
  toDecimal() {
    let n;
    if (arguments.length === 0) {
      n = 1;
    }
    else if (arguments.length === 1) {
      n = 0;
    }
    switch (n) {
      case 0: return this._toDecimal.apply(this, arguments);
      case 1: return this._toDecimal2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _toDecimal2() {
    return this._toDecimal(this._a0);
  }
  /**
   * @hidden
   */
  _toDecimal1(a) {
    let b;
    return {
      ret: ((() => { let c = this._al(a, this._a0, b); a = c.p0; b = c.p2; return c.ret; })()),
      p0: a
    };
  }
  /**
   * @hidden
   */
  _toDecimal(a) {
    let b;
    let c;
    if (((() => { let d = this._al(b, a, c); b = d.p0; c = d.p2; return d.ret; })())) {
      return b;
    }
    if (c == null) {
      throw new InvalidCastException(null, null);
    }
    throw c;
  }
  /**
   * @hidden
   */
  _al(a, b, c) {
    c = null;
    let d = this._bj(true, true);
    if (ExcelCalcValue._ac(d)) {
      a = 0;
      return {
        ret: true,
        p0: a,
        p2: c
      };
    }
    if (true && typeCast(Date_$type, d) !== null) {
      let e = ExcelCalcValue._dateTimeToExcelDate(this._o, d);
      if (e.hasValue == false) {
        c = new ArgumentOutOfRangeException(0);
        a = 0;
        return {
          ret: false,
          p0: a,
          p2: c
        };
      }
      a = e.value;
      return {
        ret: true,
        p0: a,
        p2: c
      };
    }
    if (typeCast(IConvertible_$type, d) !== null) {
      try {
        a = ConvertUtil.toDecimal(d, b);
        return {
          ret: true,
          p0: a,
          p2: c
        };
      }
      catch (f) {
        if (true) {
          let g = typeCast(String_$type, d);
          if (g != null) {
            let h;
            if (((() => { let i = MathUtilities.b(g, b, h); h = i.p2; return i.ret; })())) {
              a = h;
              return {
                ret: true,
                p0: a,
                p2: c
              };
            }
          }
        }
        c = f;
        a = 0;
        return {
          ret: false,
          p0: a,
          p2: c
        };
      }
    }
    else {
      a = 0;
      return {
        ret: false,
        p0: a,
        p2: c
      };
    }
  }
  static dateTimeToExcelDate() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return unwrapNullable(ExcelCalcValue._dateTimeToExcelDate.apply(null, arguments));
      case 1: return unwrapNullable(ExcelCalcValue._dateTimeToExcelDate1.apply(null, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _dateTimeToExcelDate(a, b) {
    return ExcelCalcValue._dateTimeToExcelDate1(a, b, true);
  }
  /**
   * @hidden
   */
  static _dateTimeToExcelDate1(a, b, c) {
    return ExcelCalcValue._bb(b, c, a != null && a.dateSystem == 1);
  }
  /**
   * @hidden
   */
  static _bb(a, b, c) {
    if (a.getTime() == 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    let d;
    try {
      d = toOADate(a);
    }
    catch (e) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    let f = b;
    let g = false;
    if (c) {
      d -= 1462;
      f = false;
      g = true;
    }
    if (f && a < dateFromValues(1900, 3, 1, 0, 0, 0, 0)) {
      d -= 1;
    }
    if (g == false && d == 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (d < 0) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    return Nullable$1.toNullable(Number_$type, d);
  }
  static excelDateToDateTime() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return unwrapNullable(ExcelCalcValue._excelDateToDateTime.apply(null, arguments));
      case 1: return unwrapNullable(ExcelCalcValue._excelDateToDateTime1.apply(null, arguments));
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _excelDateToDateTime(a, b) {
    return ExcelCalcValue._excelDateToDateTime1(a, b, true);
  }
  /**
   * @hidden
   */
  static _excelDateToDateTime1(a, b, c) {
    return ExcelCalcValue._be(a, b, c, false);
  }
  /**
   * @hidden
   */
  static _be(a, b, c, d) {
    let e = c;
    if (a != null && a.dateSystem == 1) {
      b += 1462;
      e = false;
    }
    if (b >= 2958466 || b <= -657435) {
      return Nullable$1.toNullable(Date_$type, null);
    }
    let f;
    try {
      f = ExcelUtils.ce(b);
    }
    catch (g) {
      return Nullable$1.toNullable(Date_$type, null);
    }
    if (e && f < dateFromValues(1900, 3, 1, 0, 0, 0, 0) && b >= 0) {
      f = dateAddDays(f, 1);
    }
    if (d == false && f < dateFromValues(1900, 1, 1, 0, 0, 0, 0)) {
      return Nullable$1.toNullable(Date_$type, null);
    }
    return Nullable$1.toNullable(Date_$type, f);
  }
  /**
   * @hidden
   */
  static _bq(a, b = false) {
    if (b == false && a >= 0) {
      a = a % 1;
    }
    try {
      return timeSpanFromDays(a);
    }
    catch (c) {
      return (0);
    }
  }
  /**
   * @hidden
   */
  static _ay(a, b = false) {
    let c = timeSpanTotalDays(a);
    if (b == false && c >= 1) {
      c = c % 1;
    }
    return c;
  }
  /**
   * @hidden
   */
  _getResolvedValue3(a) {
    return this._bj(a, false);
  }
  /**
   * @hidden
   */
  _bj(a, b) {
    return this._bg(this, a, b);
  }
  /**
   * @hidden
   */
  _bg(a, b, c) {
    return this._bh(a, b, true, c);
  }
  /**
   * @hidden
   */
  _bh(a, b, c, d) {
    if (this._bl != null && !(typeof this._bl === 'number') && !(typeof this._bl === 'string') && typeCast(IExcelCalcReference_$type, this._bl) !== null) {
      let e;
      let f = ((() => { let g = this._l(b, c, e); e = g.p2; return g.ret; })());
      if (f == null) {
        return e;
      }
      let g = f.value;
      if (g == null) {
        return null;
      }
      return g._bh(a, b, c, d);
    }
    let h = this._bl;
    if (c && this._n.c == 64) {
      let i = typeCast(ArrayProxy.$, this._bl);
      if (i != null) {
        h = this._bk(a, i, d, b);
      }
      else {
        let j = typeCast(ExcelCalcValue_ArrayProxyGroup.$, this._bl);
        if (j != null) {
          if (j.d != 1) {
            h = new ExcelCalcErrorValue(1);
          }
          else {
            h = this._bk(a, j.item(0), d, b);
          }
        }
      }
    }
    if (typeof this._bl === 'number' && isInfinity(this._bl)) {
      h = new ExcelCalcErrorValue(4);
    }
    if (d) {
      let k = typeCast(ExcelCalcErrorValue.$, h);
      if (k != null) {
        k._m();
      }
    }
    return h;
  }
  /**
   * @hidden
   */
  get _a0() {
    if (true) {
      let a = this._n.a;
      if (a != null) {
        return a._w;
      }
      return ExcelUtils.cq;
    }
    return CultureInfo.invariantCulture;
  }
}
ExcelCalcValue.$t = markType(ExcelCalcValue, 'ExcelCalcValue', Base.$, [IConvertible_$type, IComparable_$type]);
/**
 * @hidden
 */
ExcelCalcValue._ax = 1462;
/**
 * @hidden
 */
ExcelCalcValue._aw = -657435;
/**
 * @hidden
 */
ExcelCalcValue._av = 2958466;
/**
 * @hidden
 */
ExcelCalcValue._g = new ExcelCalcValue();
/**
 * @hidden
 */
ExcelCalcValue._aq = true;
/**
 * @hidden
 */
ExcelCalcValue._ap = true;
/**
 * Represents a two-dimensional array of [[ExcelCalcValue]] instances used in calculations.
 */
export class ArrayProxy extends Base {
  constructor() {
    super(...arguments);
    this._e = null;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  *_getEnumerator() {
    let a = this.getLength(0);
    let b = this.getLength(1);
    for (let c = 0; c < a; c++) {
      for (let d = 0; d < b; d++) {
        yield this.item(c, d);
      }
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  *__i(a, b) {
    for (let c of fromEnum(this._j(a, b))) {
      this._l(c.value);
      yield c;
    }
  }
  _i(a, b) {
    return toEnum(() => this.__i(a, b));
  }
  /**
   * @hidden
   */
  _m(a, b) {
    let c = this.getLength(0);
    let d = this.getLength(1);
    for (let e = 0; e < d; e++) {
      for (let f = 0; f < c; f++) {
        b(this.item(f, e), new ArrayValueContext(1, f, e));
      }
    }
  }
  /**
   * @hidden
   */
  _n() {
    throw new IndexOutOfRangeException(1, ExcelUtils.ef("LE_IndexOutOfRangeException_ArrayBounds"));
  }
  /**
   * @hidden
   */
  _l(a) {
    if (this._e == null) {
      return;
    }
    a._n = this._e._n;
    if (this._h) {
      a._y = this._e._y;
    }
  }
  /**
   * Gets the [[ExcelCalcValue]] at the specified index.
   * @param x The index for the first dimension of the array. This is the relative column index for arrays representing cell regions on a worksheet.
   * @param y The index for the second dimension of the array. This is the relative row index for arrays representing cell regions on a worksheet.
   * @return An [[ExcelCalcValue]] representing the specified value in the array.
   */
  item(a, b) {
    return this._b(new ArrayValueContext(1, a, b));
  }
  /**
   * @hidden
   */
  _b(a) {
    let b = this._c(a);
    this._l(b);
    return b;
  }
  /**
   * @hidden
   */
  get__h() {
    return false;
  }
  /**
   * @hidden
   */
  get _h() {
    return this.get__h();
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e;
  }
  /**
   * @hidden
   */
  set _f(a) {
    this._e = a;
  }
}
ArrayProxy.$t = markType(ArrayProxy, 'ArrayProxy', Base.$, [IEnumerable$1_$type.specialize(ExcelCalcValue.$)]);
/**
 * @hidden
 */
export class CLRArrayProxy extends ArrayProxy {
  constructor(a, ..._rest) {
    super();
    this._o = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          this._o = ((() => {
            let $ret = new Array();
            $ret.push([c]);
            return $ret;
          })());
        }
        break;
      case 1:
        {
          let c = _rest[0];
          this._o = c;
        }
        break;
    }
  }
  get__g() {
    return false;
  }
  get _g() {
    return this.get__g();
  }
  *__j(a, b) {
    switch (a) {
      case 0:
        {
          let c = this.getLength(1);
          for (let d = 0; d < c; d++) {
            yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, d, this._o[b][d]);
          }
        }
        break;
      case 1:
        {
          let e = this.getLength(0);
          for (let f = 0; f < e; f++) {
            yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, f, this._o[f][b]);
          }
        }
        break;
      default:
        this._n();
        break;
    }
  }
  _j(a, b) {
    return toEnum(() => this.__j(a, b));
  }
  getLength(a) {
    return arrayGetLength(this._o, a);
  }
  _c(a) {
    return this._o[a.b][a.c];
  }
  _a() {
    return this._o;
  }
}
CLRArrayProxy.$t = markType(CLRArrayProxy, 'CLRArrayProxy', ArrayProxy.$);
/**
 * Base class for formula functions.
 */
export class ExcelCalcFunction extends Base {
  constructor() {
    super();
    this._h = null;
    this._ae();
  }
  /**
   * @hidden
   */
  _ae() {
    if (this._r == false) {
      let a = this._z();
      let b = stringToLocaleUpper(a, CultureInfo.invariantCulture);
      switch (b) {
        case "ERRORTYPE":
          this._h = Function._en;
          break;
        default:
          this._h = Function._gv(a);
          break;
      }
    }
  }
  /**
   * @hidden
   */
  get _o() {
    let a = this._i();
    if (a == null) {
      return false;
    }
    return a._qt;
  }
  /**
   * @hidden
   */
  _z() {
    return this.name;
  }
  /**
   * Evaluates the function against the arguments on the number stack.
   * @param numberStack Formula number stack containing function arguments.
   * @param argumentCount Denotes the number of function arguments pushed onto the number stack.
   */
  performEvaluation(numberStack, argumentCount) {
    this._ah(numberStack, argumentCount);
    try {
      this._aj(numberStack, argumentCount);
    }
    finally {
      this._ag(numberStack);
    }
  }
  /**
   * @hidden
   */
  _aj(a, b) {
    let c = a.count();
    let d;
    try {
      d = this.evaluate(a, b);
    }
    catch (e) {
      d = new ExcelCalcValue(e);
    }
    finally {
      a.reset(c - b);
    }
    if (d == null) {
      d = new ExcelCalcValue(new ExcelCalcErrorValue(3, ExcelUtils.eg("Error_NullFunctionResult", getInstanceType(this).typeName)));
    }
    let f = this._af(d);
    d = f.p0;
    a.push(d);
  }
  /**
   * @hidden
   */
  static _t(a, b, c, d, e) {
    let f = a.count();
    let g = null;
    try {
      let h;
      for (let i = 0; i < b; i++) {
        let j = a.pop();
        if (j.isReference && j.toReference().isEnumerable) {
          let k = j.toReference().references;
          for (let l of fromEn(k)) {
            let m = l.value;
            if (d && m.isNull) {
              continue;
            }
            if (e && m.isError) {
              g = m.toErrorValue();
              return false;
            }
            if (!((() => { let n = m._toDouble1(h); h = n.p0; return n.ret; })())) {
              g = new ExcelCalcErrorValue(4);
              return false;
            }
            c.add(h);
          }
        }
        else {
          if (j.isReference) {
            j = j.toReference().value;
          }
          if (d && j.isNull) {
            continue;
          }
          if (e && j.isError) {
            g = j.toErrorValue();
            return false;
          }
          if (j.isArray || j.isArrayGroup) {
            let n = j.toArrayProxyGroup();
            for (let o = 0; o < n.length; o++) {
              for (let p of fromEnum(n[o])) {
                if (d && p.isNull) {
                  continue;
                }
                if (e && p.isError) {
                  g = j.toErrorValue();
                  return false;
                }
                if (!((() => { let q = p._toDouble1(h); h = q.p0; return q.ret; })())) {
                  g = new ExcelCalcErrorValue(4);
                  return false;
                }
                c.add(h);
              }
            }
            continue;
          }
          if (!((() => { let q = j._toDouble1(h); h = q.p0; return q.ret; })())) {
            g = new ExcelCalcErrorValue(4);
            return false;
          }
          c.add(h);
        }
      }
      return true;
    }
    finally {
      a.reset(f - b);
      if (g != null) {
        a.push(new ExcelCalcValue(g));
      }
    }
  }
  getArguments() {
    let n;
    if (arguments.length === 3) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._getArguments.apply(this, arguments);
      case 1: return this._getArguments1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _getArguments(a, b, c) {
    return this._getArguments1(a, b, c, false);
  }
  /**
   * @hidden
   */
  _getArguments1(a, b, c, d) {
    if (ExcelCalcFunction._w == null) {
      ExcelCalcFunction._w = new List$1(ExcelCalcValue.$, 2, b);
    }
    try {
      for (let e = 0; e < b; e++) {
        ExcelCalcFunction._ac(ExcelCalcFunction._w, a.pop(), c, d);
      }
      return ExcelCalcFunction._w.toArray();
    }
    finally {
      ExcelCalcFunction._w.clear();
    }
  }
  /**
   * @hidden
   */
  _ad(a, b, c, d) {
    let e = CalcFunctionUtilities.p(c);
    try {
      for (let f = 0; f < c; f++) {
        e.add(b.pop());
      }
      e.w();
      for (let g = 0; g < c; g++) {
        ExcelCalcFunction._ac(a, e._inner[g], d, false);
      }
    }
    finally {
      CalcFunctionUtilities.ad(e);
    }
  }
  /**
   * @hidden
   */
  static _ac(a, b, c, d, e = false) {
    let f = b.isReference;
    if (f && (c || (!b.isArray && !b.isArrayGroup) || (e && !b.toReference().isEnumerable))) {
      let g = b.toReference();
      if (g.isEnumerable) {
        for (let h of fromEn(g.references)) {
          if (d && ExcelCalcFunction._p(h)) {
            continue;
          }
          ExcelCalcFunction._ac(a, h.value, c, d, e);
        }
      }
      else {
        if (d && ExcelCalcFunction._p(g)) {
          return;
        }
        if (e) {
          if (!c || !g.value.isNull) {
            a.add(b);
          }
          return;
        }
        ExcelCalcFunction._ac(a, g.value, c, d);
      }
    }
    else if (b.isArray) {
      ExcelCalcFunction._ab(a, b.toArrayProxy(), c, d, e);
    }
    else if (b.isArrayGroup) {
      let i = b.toArrayProxyGroup();
      for (let k = 0; k < i.length; k++) {
        let j = i[k];
        ExcelCalcFunction._ab(a, j, c, d, e);
      }
    }
    else {
      if (!c || !b.isNull) {
        a.add(b);
      }
    }
  }
  /**
   * @hidden
   */
  static _ab(a, b, c, d, e = false) {
    let f = b.getLength(0);
    let g = b.getLength(1);
    for (let h = 0; h < g; h++) {
      for (let i = 0; i < f; i++) {
        ExcelCalcFunction._ac(a, b.item(i, h), c, d, e);
      }
    }
  }
  /**
   * @hidden
   */
  static _p(a) {
    let b = typeCast(CellCalcReference.$, ExcelCalcEngine.b(a));
    return b != null && b._a6;
  }
  /**
   * @hidden
   */
  static _q(a, b, c) {
    let d = typeCast(CellCalcReference.$, ExcelCalcEngine.b(a));
    if (d != null) {
      if (b && d._a5) {
        return true;
      }
      if (c && d._a7) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  static _u(a) {
    let b = ExcelCalcEngine.b(a);
    if (b != null) {
      let c = typeCast(Formula.$, b.formula);
      if (c != null) {
        let d = c._e;
        if (d != null) {
          for (let e = 0; e < d.length; e++) {
            let f = typeCast(FunctionOperator.$, d[e]);
            if (f != null && f.$function != null && stringEquals1(f.$function._alx, "subtotal", 3)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  /**
   * Determines whether the parameter at the specified index will accept an enumerable reference.
   * @param parameterIndex In 0-based index of the parameter.
   * @return True if the parameter at the specified index can accept enumerable references; False otherwise or if the parameter is out of range for this function.
   */
  canParameterBeEnumerable(parameterIndex) {
    return false;
  }
  /**
   * @hidden
   */
  static _c(a, b) {
    let c;
    let d;
    if (((() => { let e = a._toDouble1(c); c = e.p0; return e.ret; })()) == false || ((() => { let e = b._toDouble1(d); d = e.p0; return e.ret; })()) == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(c + d);
  }
  /**
   * @hidden
   */
  static _d(a, b) {
    let c;
    let d;
    if (((() => { let e = a._toDouble1(c); c = e.p0; return e.ret; })()) == false || ((() => { let e = b._toDouble1(d); d = e.p0; return e.ret; })()) == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    if (d == 0) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(2));
    }
    return new ExcelCalcValue(c / d);
  }
  /**
   * @hidden
   */
  static _f(a, b) {
    let c;
    let d;
    if (((() => { let e = a._toDouble1(c); c = e.p0; return e.ret; })()) == false || ((() => { let e = b._toDouble1(d); d = e.p0; return e.ret; })()) == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(c * d);
  }
  /**
   * @hidden
   */
  static _g(a, b) {
    let c;
    let d;
    if (((() => { let e = a._toDouble1(c); c = e.p0; return e.ret; })()) == false || ((() => { let e = b._toDouble1(d); d = e.p0; return e.ret; })()) == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(c - d);
  }
  /**
   * @hidden
   */
  _af(a) {
    if (this._k == 64) {
      let b = a.toErrorValue();
      if (b != null) {
        a = new ExcelCalcValue(b);
      }
    }
    if (a.isReference) {
      a._y = true;
    }
    return {
      p0: a
    };
  }
  /**
   * @hidden
   */
  _ag(a) {
    a._ab();
  }
  /**
   * @hidden
   */
  _ah(a, b) {
    a._ac(this, b);
  }
  /**
   * @hidden
   */
  get__k() {
    let a = this._i();
    if (a == null) {
      return 32;
    }
    return a._qj;
  }
  /**
   * @hidden
   */
  get _k() {
    return this.get__k();
  }
  /**
   * Determines whether the function accepts an intermediate result array created by evaluating a nested function
   * on a per-element basis of an array or region parameter when a single value is expected.
   * <p class="body">
   * An intermediate result array will be generated when multiple values are specified where a single value is expected.
   * For example, the following formula will generate the value 15: =SUM(10/{1,2}). This is because "10/{1,2}" will
   * result in an intermediate result array of {10/1,10/2}, or {10,5}. Then each element is summed up to result in the
   * value 15. However, the SUM function does not allow intermediate result arrays for region references. So a function
   * such as =SUM(10/D6:E7) will result in a #VALUE! error. Unlike the SUM function, the LOOKUP function allows intermediate
   * result arrays from region references. So a formula like LOOKUP(10,D6:E7*2) will return a correct result if the value 10
   * can be found in the following intermediate result array when using the normal LOOKUP function logic: {D6*2,E6*2; D7*2,E7*2}.
   * Therefore, SUM would return True from this method only when 'isCreatedFromRegionReference' is False
   * and LOOKUP would return True from this method always (for a 'parameterIndex' value of 1 in this example).
   * </p>
   * <p class="note">
   * <b>Note:</b> if this function is being called in an array formula, the restrictions are relaxed in the following way:
   * if the function supports intermediate result arrays created from constant array, it will also support intermediate
   * result arrays created from region references, so the 'isCreatedFromRegionReference' value will always
   * be passed in as False.
   * </p>
   * @param parameterIndex The 0-based index of parameter in which the intermediate array will be passed.
   * @param isCreatedFromRegionReference True if the value which will generate the intermediate result array is a region reference; False if it is a constant array.
   * @return True to allow intermediate result arrays for the specified parameter; False otherwise.
   */
  doesParameterAllowIntermediateResultArray(parameterIndex, isCreatedFromRegionReference) {
    return false;
  }
  /**
   * @hidden
   */
  _i() {
    return this._h;
  }
  /**
   * @hidden
   */
  _j(a) {
    let b = this._i();
    if (b == null) {
      return 32;
    }
    return b._qh(a);
  }
  /**
   * @hidden
   */
  static _l(a) {
    let b = typeCast(RefBase.$, a._k);
    return b == null ? null : b._t;
  }
  /**
   * @hidden
   */
  get__r() {
    return false;
  }
  /**
   * @hidden
   */
  get _r() {
    return this.get__r();
  }
  /**
   * @hidden
   */
  get__s() {
    return false;
  }
  /**
   * @hidden
   */
  get _s() {
    return this.get__s();
  }
  /**
   * @hidden
   */
  _v(a) {
    return true;
  }
}
ExcelCalcFunction.$t = markType(ExcelCalcFunction, 'ExcelCalcFunction');
/**
 * @hidden
 */
ExcelCalcFunction._w = null;
/**
 * @hidden
 */
export class BuiltInFunctionBase extends ExcelCalcFunction {
  constructor() {
    super();
  }
}
BuiltInFunctionBase.$t = markType(BuiltInFunctionBase, 'BuiltInFunctionBase', ExcelCalcFunction.$);
/**
 * @hidden
 */
export class UltraCalcBinaryOperatorBase extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    return this._ak(d, c);
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcBinaryOperatorBase.$t = markType(UltraCalcBinaryOperatorBase, 'UltraCalcBinaryOperatorBase', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionPlus extends UltraCalcBinaryOperatorBase {
  _ak(a, b) {
    return ExcelCalcFunction._c(a, b);
  }
  get_name() {
    return "+";
  }
  get name() {
    return this.get_name();
  }
}
UltraCalcFunctionPlus.$t = markType(UltraCalcFunctionPlus, 'UltraCalcFunctionPlus', UltraCalcBinaryOperatorBase.$);
/**
 * @hidden
 */
export class Function extends Base {
  constructor(a, b, c, d, e, f, g, h, i, j, ...k) {
    super();
    this._alw = null;
    this._ut = 0;
    this._q0 = 0;
    this._w0 = 0;
    this._qq = false;
    this._qs = false;
    this._aav = 0;
    this._aat = 0;
    this._a = null;
    this._qi = 0;
    this._c = null;
    this._ql = false;
    this._qv = false;
    this._aru = null;
    this._aly = null;
    this._al0 = null;
    this._qo = false;
    this._alw = a;
    this._qo = f;
    if (b < 0) {
      this._ut = 255;
      this._ql = true;
      if (b == -3) {
        this._qv = true;
      }
      this._aru = "<AddInFunctions>";
    }
    else {
      this._ut = b;
    }
    this._q0 = c;
    this._w0 = d;
    this._qs = e;
    this._aav = g;
    this._aat = h;
    this._a = i;
    this._qi = j;
    this._c = k;
    this._aly = stringToLocaleLower(this._alw, CultureInfo.invariantCulture);
    this._al0 = stringToLocaleUpper(this._alw, CultureInfo.invariantCulture);
  }
  compareTo(a) {
    let b = this._ut - a._ut;
    if (b != 0) {
      return b;
    }
    b = stringCompare1(this._alw, a._alw, StringUtilities.g);
    if (b != 0) {
      return b;
    }
    return stringCompare1(this._aru, a._aru, StringUtilities.g);
  }
  _qh(a) {
    if (a < this._c.length) {
      return this._c[a];
    }
    if (this._aat > 1 && this._c.length == this._aav) {
      return this._c[this._c.length - this._aat + ((a - this._aav) % this._aat)];
    }
    return this._c[this._c.length - 1];
  }
  _qx(a) {
    let b = ExcelUtils.au(a) ? 30 : 255;
    if (this._w0 == -1) {
      let c = b - this._aaw;
      while ((c % this._aau) != 0) {
        c--;
      }
      return c;
    }
    return Math.min(b, this._w0);
  }
  get _vv() {
    return this._ut;
  }
  get _qk() {
    return this._ut == 255;
  }
  get _qm() {
    return this._ql;
  }
  get _qn() {
    return this._ut == 255 || this._q0 != this._w0;
  }
  get _qp() {
    return this._ut == 1 || this._ut == 100;
  }
  get _qr() {
    return this._qq;
  }
  get _qt() {
    return this._qs;
  }
  get _b() {
    return this._a;
  }
  get _qu() {
    switch (this._ut) {
      case 1:
      case 100:
      case 64:
      case 28:
      case 101:
      case 102: return true;
      default: return false;
    }
  }
  get _q1() {
    return this._q0;
  }
  get _alx() {
    return this._alw;
  }
  get _qw() {
    return this._qv;
  }
  get _qj() {
    return this._qi;
  }
  get _aau() {
    return this._aat;
  }
  get _aaw() {
    return this._aav;
  }
  get _arv() {
    return this._aru;
  }
  static _ar8(a, b) {
    let c;
    if (((() => { let d = b.tryGetValue(a._alx.length, c); c = d.p1; return d.ret; })()) == false) {
      c = new List$1(Function.$, 2, 1);
      b.addItem(a._alx.length, c);
    }
    c.add(a);
  }
  static _q3() {
    let a = new Dictionary$2(Number_$type, List$1.$.specialize(Function.$), 0);
    Function._ar8(Function._b8, a);
    Function._ar8(Function._hf, a);
    Function._ar8(Function._iq, a);
    Function._ar8(Function._il, a);
    Function._ar8(Function._n6, a);
    Function._ar8(Function._ah, a);
    Function._ar8(Function._jt, a);
    Function._ar8(Function._jl, a);
    Function._ar8(Function._m0, a);
    Function._ar8(Function._bs, a);
    Function._ar8(Function._kb, a);
    Function._ar8(Function._kv, a);
    Function._ar8(Function._nw, a);
    Function._ar8(Function._dy, a);
    Function._ar8(Function._fd, a);
    Function._ar8(Function._nl, a);
    Function._ar8(Function._b4, a);
    Function._ar8(Function._on, a);
    Function._ar8(Function._ad, a);
    Function._ar8(Function._ln, a);
    Function._ar8(Function._nt, a);
    Function._ar8(Function._et, a);
    Function._ar8(Function._ja, a);
    Function._ar8(Function._jc, a);
    Function._ar8(Function._d, a);
    Function._ar8(Function._id, a);
    Function._ar8(Function._nk, a);
    Function._ar8(Function._mv, a);
    Function._ar8(Function._ji, a);
    Function._ar8(Function._h8, a);
    Function._ar8(Function._ml, a);
    Function._ar8(Function._jr, a);
    Function._ar8(Function._i6, a);
    Function._ar8(Function._pm, a);
    Function._ar8(Function._pd, a);
    Function._ar8(Function._e3, a);
    Function._ar8(Function._v, a);
    Function._ar8(Function._k9, a);
    Function._ar8(Function._kr, a);
    Function._ar8(Function._j1, a);
    Function._ar8(Function._db, a);
    Function._ar8(Function._d4, a);
    Function._ar8(Function._c5, a);
    Function._ar8(Function._dw, a);
    Function._ar8(Function._dv, a);
    Function._ar8(Function._d2, a);
    Function._ar8(Function._pn, a);
    Function._ar8(Function._d6, a);
    Function._ar8(Function._ou, a);
    Function._ar8(Function._i8, a);
    Function._ar8(Function._pa, a);
    Function._ar8(Function._jd, a);
    Function._ar8(Function._g2, a);
    Function._ar8(Function._l1, a);
    Function._ar8(Function._fy, a);
    Function._ar8(Function._ku, a);
    Function._ar8(Function._lo, a);
    Function._ar8(Function._mc, a);
    Function._ar8(Function._jy, a);
    Function._ar8(Function._ii, a);
    Function._ar8(Function._l7, a);
    Function._ar8(Function._jk, a);
    Function._ar8(Function._c1, a);
    Function._ar8(Function._o5, a);
    Function._ar8(Function._c6, a);
    Function._ar8(Function._j5, a);
    Function._ar8(Function._qa, a);
    Function._ar8(Function._py, a);
    Function._ar8(Function._ha, a);
    Function._ar8(Function._jw, a);
    Function._ar8(Function._nc, a);
    Function._ar8(Function._kt, a);
    Function._ar8(Function._y, a);
    Function._ar8(Function._m1, a);
    Function._ar8(Function._bt, a);
    Function._ar8(Function._k6, a);
    Function._ar8(Function._m8, a);
    Function._ar8(Function._o9, a);
    Function._ar8(Function._pg, a);
    Function._ar8(Function._ae, a);
    Function._ar8(Function._ab, a);
    Function._ar8(Function._h, a);
    Function._ar8(Function._bp, a);
    Function._ar8(Function._g9, a);
    Function._ar8(Function._pv, a);
    Function._ar8(Function._ix, a);
    Function._ar8(Function._jb, a);
    Function._ar8(Function._bf, a);
    Function._ar8(Function._jj, a);
    Function._ar8(Function._pk, a);
    Function._ar8(Function._l0, a);
    Function._ar8(Function._i4, a);
    Function._ar8(Function._ms, a);
    Function._ar8(Function._eq, a);
    Function._ar8(Function._pb, a);
    Function._ar8(Function._mj, a);
    Function._ar8(Function._n4, a);
    Function._ar8(Function._br, a);
    Function._ar8(Function._e8, a);
    Function._ar8(Function._be, a);
    Function._ar8(Function._ik, a);
    Function._ar8(Function._iy, a);
    Function._ar8(Function._is, a);
    Function._ar8(Function._ij, a);
    Function._ar8(Function._og, a);
    Function._ar8(Function._ka, a);
    Function._ar8(Function._c4, a);
    Function._ar8(Function._o6, a);
    Function._ar8(Function._np, a);
    Function._ar8(Function._of, a);
    Function._ar8(Function._dd, a);
    Function._ar8(Function._h9, a);
    Function._ar8(Function._bq, a);
    Function._ar8(Function._jo, a);
    Function._ar8(Function._jx, a);
    Function._ar8(Function._jz, a);
    Function._ar8(Function._ih, a);
    Function._ar8(Function._lt, a);
    Function._ar8(Function._b9, a);
    Function._ar8(Function._lz, a);
    Function._ar8(Function._e1, a);
    Function._ar8(Function._gs, a);
    Function._ar8(Function._d1, a);
    Function._ar8(Function._ir, a);
    Function._ar8(Function._n0, a);
    Function._ar8(Function._pr, a);
    Function._ar8(Function._d3, a);
    Function._ar8(Function._d7, a);
    Function._ar8(Function._pe, a);
    Function._ar8(Function._ip, a);
    Function._ar8(Function._dc, a);
    Function._ar8(Function._pl, a);
    Function._ar8(Function._e9, a);
    Function._ar8(Function._m9, a);
    Function._ar8(Function._mk, a);
    Function._ar8(Function._i5, a);
    Function._ar8(Function._mt, a);
    Function._ar8(Function._js, a);
    Function._ar8(Function._i7, a);
    Function._ar8(Function._mz, a);
    Function._ar8(Function._my, a);
    Function._ar8(Function._aa, a);
    Function._ar8(Function._da, a);
    Function._ar8(Function._l9, a);
    Function._ar8(Function._r, a);
    Function._ar8(Function._c8, a);
    Function._ar8(Function._o8, a);
    Function._ar8(Function._pt, a);
    Function._ar8(Function._jq, a);
    Function._ar8(Function._n9, a);
    Function._ar8(Function._nm, a);
    Function._ar8(Function._b5, a);
    Function._ar8(Function._oo, a);
    Function._ar8(Function._ac, a);
    Function._ar8(Function._i, a);
    Function._ar8(Function._af, a);
    Function._ar8(Function._dr, a);
    Function._ar8(Function._ia, a);
    Function._ar8(Function._c9, a);
    Function._ar8(Function._fv, a);
    Function._ar8(Function._en, a);
    Function._ar8(Function._ag, a);
    Function._ar8(Function._at, a);
    Function._ar8(Function._f7, a);
    Function._ar8(Function._au, a);
    Function._ar8(Function._a1, a);
    Function._ar8(Function._bh, a);
    Function._ar8(Function._bi, a);
    Function._ar8(Function._bu, a);
    Function._ar8(Function._bz, a);
    Function._ar8(Function._cn, a);
    Function._ar8(Function._ep, a);
    Function._ar8(Function._ev, a);
    Function._ar8(Function._e5, a);
    Function._ar8(Function._fa, a);
    Function._ar8(Function._fb, a);
    Function._ar8(Function._fc, a);
    Function._ar8(Function._fe, a);
    Function._ar8(Function._f5, a);
    Function._ar8(Function._f6, a);
    Function._ar8(Function._bb, a);
    Function._ar8(Function._he, a);
    Function._ar8(Function._jh, a);
    Function._ar8(Function._je, a);
    Function._ar8(Function._ke, a);
    Function._ar8(Function._kn, a);
    Function._ar8(Function._kp, a);
    Function._ar8(Function._ko, a);
    Function._ar8(Function._j0, a);
    Function._ar8(Function._nv, a);
    Function._ar8(Function._k1, a);
    Function._ar8(Function._lj, a);
    Function._ar8(Function._lp, a);
    Function._ar8(Function._os, a);
    Function._ar8(Function._p0, a);
    Function._ar8(Function._od, a);
    Function._ar8(Function._ob, a);
    Function._ar8(Function._oc, a);
    Function._ar8(Function._bo, a);
    Function._ar8(Function._b3, a);
    Function._ar8(Function._cj, a);
    Function._ar8(Function._fk, a);
    Function._ar8(Function._fx, a);
    Function._ar8(Function._ie, a);
    Function._ar8(Function._lc, a);
    Function._ar8(Function._m3, a);
    Function._ar8(Function._n3, a);
    Function._ar8(Function._nq, a);
    Function._ar8(Function._pf, a);
    Function._ar8(Function._ly, a);
    Function._ar8(Function._dq, a);
    Function._ar8(Function._gb, a);
    Function._ar8(Function._g4, a);
    Function._ar8(Function._oa, a);
    Function._ar8(Function._i0, a);
    Function._ar8(Function._nn, a);
    Function._ar8(Function._qg, a);
    Function._ar8(Function._i1, a);
    Function._ar8(Function._nr, a);
    Function._ar8(Function._l2, a);
    Function._ar8(Function._ld, a);
    Function._ar8(Function._lg, a);
    Function._ar8(Function._j2, a);
    Function._ar8(Function._pc, a);
    Function._ar8(Function._o7, a);
    Function._ar8(Function._by, a);
    Function._ar8(Function._ls, a);
    Function._ar8(Function._l6, a);
    Function._ar8(Function._di, a);
    Function._ar8(Function._n5, a);
    Function._ar8(Function._n7, a);
    Function._ar8(Function._cb, a);
    Function._ar8(Function._ca, a);
    Function._ar8(Function._iw, a);
    Function._ar8(Function._c2, a);
    Function._ar8(Function._c3, a);
    Function._ar8(Function._kw, a);
    Function._ar8(Function._mu, a);
    Function._ar8(Function._hb, a);
    Function._ar8(Function._lm, a);
    Function._ar8(Function._ai, a);
    Function._ar8(Function._jm, a);
    Function._ar8(Function._ju, a);
    Function._ar8(Function._n1, a);
    Function._ar8(Function._ps, a);
    Function._ar8(Function._nz, a);
    Function._ar8(Function._pq, a);
    Function._ar8(Function._f, a);
    Function._ar8(Function._g, a);
    Function._ar8(Function._t, a);
    Function._ar8(Function._u, a);
    Function._ar8(Function._aj, a);
    Function._ar8(Function._ak, a);
    Function._ar8(Function._al, a);
    Function._ar8(Function._an, a);
    Function._ar8(Function._ao, a);
    Function._ar8(Function._ap, a);
    Function._ar8(Function._aq, a);
    Function._ar8(Function._av, a);
    Function._ar8(Function._aw, a);
    Function._ar8(Function._ax, a);
    Function._ar8(Function._bw, a);
    Function._ar8(Function._b2, a);
    Function._ar8(Function._cd, a);
    Function._ar8(Function._ce, a);
    Function._ar8(Function._cf, a);
    Function._ar8(Function._cg, a);
    Function._ar8(Function._ch, a);
    Function._ar8(Function._ci, a);
    Function._ar8(Function._cq, a);
    Function._ar8(Function._cr, a);
    Function._ar8(Function._cs, a);
    Function._ar8(Function._ct, a);
    Function._ar8(Function._cu, a);
    Function._ar8(Function._cv, a);
    Function._ar8(Function._cw, a);
    Function._ar8(Function._cx, a);
    Function._ar8(Function._cy, a);
    Function._ar8(Function._de, a);
    Function._ar8(Function._df, a);
    Function._ar8(Function._dg, a);
    Function._ar8(Function._dn, a);
    Function._ar8(Function._du, a);
    Function._ar8(Function._dz, a);
    Function._ar8(Function._d0, a);
    Function._ar8(Function._d5, a);
    Function._ar8(Function._ea, a);
    Function._ar8(Function._eb, a);
    Function._ar8(Function._eh, a);
    Function._ar8(Function._ei, a);
    Function._ar8(Function._ek, a);
    Function._ar8(Function._e2, a);
    Function._ar8(Function._fz, a);
    Function._ar8(Function._ga, a);
    Function._ar8(Function._gc, a);
    Function._ar8(Function._gy, a);
    Function._ar8(Function._g6, a);
    Function._ar8(Function._g7, a);
    Function._ar8(Function._g8, a);
    Function._ar8(Function._hd, a);
    Function._ar8(Function._hg, a);
    Function._ar8(Function._hj, a);
    Function._ar8(Function._hk, a);
    Function._ar8(Function._hl, a);
    Function._ar8(Function._hm, a);
    Function._ar8(Function._hn, a);
    Function._ar8(Function._hs, a);
    Function._ar8(Function._ht, a);
    Function._ar8(Function._hu, a);
    Function._ar8(Function._hv, a);
    Function._ar8(Function._hw, a);
    Function._ar8(Function._hx, a);
    Function._ar8(Function._hy, a);
    Function._ar8(Function._hz, a);
    Function._ar8(Function._h2, a);
    Function._ar8(Function._h4, a);
    Function._ar8(Function._h5, a);
    Function._ar8(Function._h6, a);
    Function._ar8(Function._ig, a);
    Function._ar8(Function._im, a);
    Function._ar8(Function._iu, a);
    Function._ar8(Function._i3, a);
    Function._ar8(Function._jp, a);
    Function._ar8(Function._j7, a);
    Function._ar8(Function._j8, a);
    Function._ar8(Function._kf, a);
    Function._ar8(Function._ki, a);
    Function._ar8(Function._kq, a);
    Function._ar8(Function._ky, a);
    Function._ar8(Function._kz, a);
    Function._ar8(Function._k0, a);
    Function._ar8(Function._k2, a);
    Function._ar8(Function._k3, a);
    Function._ar8(Function._k4, a);
    Function._ar8(Function._k5, a);
    Function._ar8(Function._lv, a);
    Function._ar8(Function._lw, a);
    Function._ar8(Function._lx, a);
    Function._ar8(Function._l5, a);
    Function._ar8(Function._l8, a);
    Function._ar8(Function._md, a);
    Function._ar8(Function._m4, a);
    Function._ar8(Function._ne, a);
    Function._ar8(Function._nu, a);
    Function._ar8(Function._n8, a);
    Function._ar8(Function._op, a);
    Function._ar8(Function._oq, a);
    Function._ar8(Function._or, a);
    Function._ar8(Function._pz, a);
    Function._ar8(Function._p5, a);
    Function._ar8(Function._p7, a);
    Function._ar8(Function._p8, a);
    Function._ar8(Function._qb, a);
    Function._ar8(Function._qc, a);
    Function._ar8(Function._qd, a);
    Function._ar8(Function._qe, a);
    Function._ar8(Function._j, a);
    Function._ar8(Function._k, a);
    Function._ar8(Function._s, a);
    Function._ar8(Function._x, a);
    Function._ar8(Function._am, a);
    Function._ar8(Function._ar, a);
    Function._ar8(Function._as, a);
    Function._ar8(Function._ay, a);
    Function._ar8(Function._az, a);
    Function._ar8(Function._a0, a);
    Function._ar8(Function._a2, a);
    Function._ar8(Function._a3, a);
    Function._ar8(Function._a4, a);
    Function._ar8(Function._a5, a);
    Function._ar8(Function._a6, a);
    Function._ar8(Function._bc, a);
    Function._ar8(Function._bd, a);
    Function._ar8(Function._bj, a);
    Function._ar8(Function._bk, a);
    Function._ar8(Function._bl, a);
    Function._ar8(Function._bm, a);
    Function._ar8(Function._bn, a);
    Function._ar8(Function._bv, a);
    Function._ar8(Function._b0, a);
    Function._ar8(Function._b1, a);
    Function._ar8(Function._b6, a);
    Function._ar8(Function._b7, a);
    Function._ar8(Function._ck, a);
    Function._ar8(Function._cl, a);
    Function._ar8(Function._co, a);
    Function._ar8(Function._cp, a);
    Function._ar8(Function._c7, a);
    Function._ar8(Function._dh, a);
    Function._ar8(Function._ej, a);
    Function._ar8(Function._el, a);
    Function._ar8(Function._eu, a);
    Function._ar8(Function._ew, a);
    Function._ar8(Function._ex, a);
    Function._ar8(Function._ey, a);
    Function._ar8(Function._ez, a);
    Function._ar8(Function._e0, a);
    Function._ar8(Function._e7, a);
    Function._ar8(Function._ff, a);
    Function._ar8(Function._fg, a);
    Function._ar8(Function._fr, a);
    Function._ar8(Function._f2, a);
    Function._ar8(Function._f3, a);
    Function._ar8(Function._f4, a);
    Function._ar8(Function._f8, a);
    Function._ar8(Function._f9, a);
    Function._ar8(Function._hc, a);
    Function._ar8(Function._hh, a);
    Function._ar8(Function._ho, a);
    Function._ar8(Function._hp, a);
    Function._ar8(Function._hq, a);
    Function._ar8(Function._hr, a);
    Function._ar8(Function._h0, a);
    Function._ar8(Function._h1, a);
    Function._ar8(Function._h3, a);
    Function._ar8(Function._h7, a);
    Function._ar8(Function._io, a);
    Function._ar8(Function._iv, a);
    Function._ar8(Function._jf, a);
    Function._ar8(Function._jg, a);
    Function._ar8(Function._j3, a);
    Function._ar8(Function._j4, a);
    Function._ar8(Function._j9, a);
    Function._ar8(Function._kd, a);
    Function._ar8(Function._kj, a);
    Function._ar8(Function._kk, a);
    Function._ar8(Function._kl, a);
    Function._ar8(Function._km, a);
    Function._ar8(Function._kx, a);
    Function._ar8(Function._lb, a);
    Function._ar8(Function._le, a);
    Function._ar8(Function._lf, a);
    Function._ar8(Function._lh, a);
    Function._ar8(Function._li, a);
    Function._ar8(Function._lk, a);
    Function._ar8(Function._ll, a);
    Function._ar8(Function._lq, a);
    Function._ar8(Function._l3, a);
    Function._ar8(Function._l4, a);
    Function._ar8(Function._ma, a);
    Function._ar8(Function._mb, a);
    Function._ar8(Function._m2, a);
    Function._ar8(Function._na, a);
    Function._ar8(Function._nb, a);
    Function._ar8(Function._nh, a);
    Function._ar8(Function._ni, a);
    Function._ar8(Function._no, a);
    Function._ar8(Function._nx, a);
    Function._ar8(Function._ny, a);
    Function._ar8(Function._oh, a);
    Function._ar8(Function._oi, a);
    Function._ar8(Function._oj, a);
    Function._ar8(Function._ok, a);
    Function._ar8(Function._ol, a);
    Function._ar8(Function._om, a);
    Function._ar8(Function._ph, a);
    Function._ar8(Function._pi, a);
    Function._ar8(Function._po, a);
    Function._ar8(Function._pp, a);
    Function._ar8(Function._px, a);
    Function._ar8(Function._p1, a);
    Function._ar8(Function._p9, a);
    Function._ar8(Function._qf, a);
    Function._ar8(Function._d9, a);
    Function._ar8(Function._it, a);
    Function._ar8(Function._kg, a);
    Function._ar8(Function._p6, a);
    Function._ar8(Function._fl, a);
    Function._ar8(Function._fm, a);
    Function._ar8(Function._fn, a);
    Function._ar8(Function._fp, a);
    Function._ar8(Function._fo, a);
    Function._ar8(Function._cc, a);
    Function._ar8(Function._bx, a);
    Function._ar8(Function._hi, a);
    Function._ar8(Function._jn, a);
    Function._ar8(Function._jv, a);
    Function._ar8(Function._oe, a);
    Function._ar8(Function._ow, a);
    Function._ar8(Function._iz, a);
    Function._ar8(Function._mw, a);
    Function._ar8(Function._mx, a);
    Function._ar8(Function._oy, a);
    Function._ar8(Function._oz, a);
    Function._ar8(Function._o0, a);
    Function._ar8(Function._o1, a);
    Function._ar8(Function._o2, a);
    Function._ar8(Function._o3, a);
    Function._ar8(Function._o4, a);
    Function._ar8(Function._e, a);
    Function._ar8(Function._l, a);
    Function._ar8(Function._a8, a);
    Function._ar8(Function._a9, a);
    Function._ar8(Function._eo, a);
    Function._ar8(Function._gh, a);
    Function._ar8(Function._ic, a);
    Function._ar8(Function._i2, a);
    Function._ar8(Function._m7, a);
    Function._ar8(Function._nd, a);
    Function._ar8(Function._ox, a);
    Function._ar8(Function._pu, a);
    Function._ar8(Function._m, a);
    Function._ar8(Function._n, a);
    Function._ar8(Function._o, a);
    Function._ar8(Function._p, a);
    Function._ar8(Function._w, a);
    Function._ar8(Function._z, a);
    Function._ar8(Function._a7, a);
    Function._ar8(Function._ba, a);
    Function._ar8(Function._bg, a);
    Function._ar8(Function._cm, a);
    Function._ar8(Function._cz, a);
    Function._ar8(Function._c0, a);
    Function._ar8(Function._dj, a);
    Function._ar8(Function._dk, a);
    Function._ar8(Function._dl, a);
    Function._ar8(Function._dm, a);
    Function._ar8(Function._dp, a);
    Function._ar8(Function._ds, a);
    Function._ar8(Function._dt, a);
    Function._ar8(Function._dx, a);
    Function._ar8(Function._d8, a);
    Function._ar8(Function._ec, a);
    Function._ar8(Function._ed, a);
    Function._ar8(Function._ee, a);
    Function._ar8(Function._ef, a);
    Function._ar8(Function._eg, a);
    Function._ar8(Function._em, a);
    Function._ar8(Function._er, a);
    Function._ar8(Function._es, a);
    Function._ar8(Function._e4, a);
    Function._ar8(Function._e6, a);
    Function._ar8(Function._fh, a);
    Function._ar8(Function._fi, a);
    Function._ar8(Function._fj, a);
    Function._ar8(Function._fq, a);
    Function._ar8(Function._fs, a);
    Function._ar8(Function._ft, a);
    Function._ar8(Function._fu, a);
    Function._ar8(Function._fw, a);
    Function._ar8(Function._f0, a);
    Function._ar8(Function._f1, a);
    Function._ar8(Function._gd, a);
    Function._ar8(Function._ge, a);
    Function._ar8(Function._gf, a);
    Function._ar8(Function._gg, a);
    Function._ar8(Function._gi, a);
    Function._ar8(Function._gj, a);
    Function._ar8(Function._gk, a);
    Function._ar8(Function._gl, a);
    Function._ar8(Function._gm, a);
    Function._ar8(Function._gn, a);
    Function._ar8(Function._go, a);
    Function._ar8(Function._gp, a);
    Function._ar8(Function._gq, a);
    Function._ar8(Function._gr, a);
    Function._ar8(Function._gs, a);
    Function._ar8(Function._g0, a);
    Function._ar8(Function._g1, a);
    Function._ar8(Function._g3, a);
    Function._ar8(Function._g5, a);
    Function._ar8(Function._ib, a);
    Function._ar8(Function._i9, a);
    Function._ar8(Function._j6, a);
    Function._ar8(Function._kc, a);
    Function._ar8(Function._kh, a);
    Function._ar8(Function._ks, a);
    Function._ar8(Function._k7, a);
    Function._ar8(Function._k8, a);
    Function._ar8(Function._la, a);
    Function._ar8(Function._lr, a);
    Function._ar8(Function._lu, a);
    Function._ar8(Function._me, a);
    Function._ar8(Function._mf, a);
    Function._ar8(Function._mg, a);
    Function._ar8(Function._mh, a);
    Function._ar8(Function._mi, a);
    Function._ar8(Function._mm, a);
    Function._ar8(Function._mn, a);
    Function._ar8(Function._mo, a);
    Function._ar8(Function._mp, a);
    Function._ar8(Function._mq, a);
    Function._ar8(Function._mr, a);
    Function._ar8(Function._m5, a);
    Function._ar8(Function._m6, a);
    Function._ar8(Function._nf, a);
    Function._ar8(Function._ng, a);
    Function._ar8(Function._nj, a);
    Function._ar8(Function._ns, a);
    Function._ar8(Function._n2, a);
    Function._ar8(Function._ot, a);
    Function._ar8(Function._ov, a);
    Function._ar8(Function._pj, a);
    Function._ar8(Function._pw, a);
    Function._ar8(Function._p2, a);
    Function._ar8(Function._p3, a);
    Function._ar8(Function._p4, a);
    let b = new Dictionary$2(Number_$type, Array_$type, 0);
    for (let c of fromEnum(a)) {
      b.addItem(c.key, c.value.toArray());
    }
    return b;
  }
  static _gt(a, b) {
    let c = Function._gw(b, 255, 0, -1, false, 0, 1, null, 32, 32);
    c._qq = true;
    c._aru = a;
    return c;
  }
  static _gu(a) {
    if (a == 255) {
      return Function._q;
    }
    if (Function._q4 == null || Function._q2 == null) {
      Function._gv("COUNT");
    }
    let b = null;
    if (a >= 0 && a <= Function._q4.count) {
      b = Function._q4._inner[a];
    }
    return b;
  }
  static _gv(a) {
    return Function._gx(a, 0, a.length);
  }
  static _gx(a, b, c) {
    if (Function._q2 == null) {
      Function._q2 = Function._q3();
    }
    let d;
    if (((() => { let e = Function._q2.tryGetValue(c, d); d = e.p1; return e.ret; })())) {
      for (let e = 0; e < d.length; e++) {
        let f = d[e];
        let g = true;
        for (let h = 0, i = b; h < c; h++ , i++) {
          let j = a.charAt(i);
          if (j != f._aly.charAt(h) && j != f._al0.charAt(h)) {
            g = false;
            break;
          }
        }
        if (g) {
          return f;
        }
      }
    }
    let k = a.substr(b, c);
    if (stringStartsWith(k, "_xll.")) {
      return Function._gz(k.substr(5));
    }
    if (stringStartsWith(k, "_xlfn.")) {
      return Function._gx(a, b + 6, c - 6);
    }
    return Function._gz(k);
  }
  static _gw(a, b, c, d, e, f, g, h, i, ...j) {
    let k = false;
    if (b > 10000) {
      b -= 10000;
      k = true;
    }
    let l = ((b != 255 || a == "<AddIn>") && b >= 0);
    if (l) {
      if (Function._q4 != null && b < Function._q4.count && Function._q4._inner[b] != null) {
        return Function._q4._inner[b];
      }
    }
    let m = new Function(a, b, c, d, e, k, f, g, h, i, ...j);
    if (l) {
      if (Function._q4 == null) {
        Function._q4 = new List$1(Function.$, 2, 400);
        for (let n = 0; n < 400; n++) {
          Function._q4.add(null);
        }
      }
      let o = m._vv;
      for (let p = Function._q4.count; p <= o; p++) {
        Function._q4.add(null);
      }
      Function._q4._inner[o] = m;
    }
    return m;
  }
  static _gz(a) {
    let b = Function._gw(a, 255, 0, -1, false, 0, 1, null, 32, 32);
    b._qq = true;
    b._aru = "<AddInFunctions>";
    return b;
  }
  static get _b8() {
    return Function._gw("COUNT", 0, 0, -1, false, 0, 1, null, 64, 32);
  }
  static get _hf() {
    return Function._gw("IF", 1, 2, 3, false, 0, 1, null, 32, 64, 32, 32);
  }
  static get _iq() {
    return Function._gw("ISNA", 2, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _il() {
    return Function._gw("ISERROR", 3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _n6() {
    return Function._gw("SUM", 4, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _ah() {
    return Function._gw("AVERAGE", 5, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _jt() {
    return Function._gw("MIN", 6, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _jl() {
    return Function._gw("MAX", 7, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _m0() {
    return Function._gw("ROW", 8, 0, 1, false, 0, 1, [0], 64, 64);
  }
  static get _bs() {
    return Function._gw("COLUMN", 9, 0, 1, false, 0, 1, [0], 64, 64);
  }
  static get _kb() {
    return Function._gw("NA", 10, 0, 0, false, 0, 1, null, 64);
  }
  static get _kv() {
    return Function._gw("NPV", 11, 2, -1, false, 0, 1, null, 64, 64, 32);
  }
  static get _nw() {
    return Function._gw("STDEV", 12, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _dy() {
    return Function._gw("DOLLAR", 13, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _fd() {
    return Function._gw("FIXED", 14, 1, 3, false, 0, 1, null, 64, 64, 64);
  }
  static get _nl() {
    return Function._gw("SIN", 15, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _b4() {
    return Function._gw("COS", 16, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _on() {
    return Function._gw("TAN", 17, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ad() {
    return Function._gw("ATAN", 18, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ln() {
    return Function._gw("PI", 19, 0, 0, false, 0, 1, null, 64);
  }
  static get _nt() {
    return Function._gw("SQRT", 20, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _et() {
    return Function._gw("EXP", 21, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ja() {
    return Function._gw("LN", 22, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _jc() {
    return Function._gw("LOG10", 23, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _d() {
    return Function._gw("ABS", 24, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _id() {
    return Function._gw("INT", 25, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _nk() {
    return Function._gw("SIGN", 26, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mv() {
    return Function._gw("ROUND", 27, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ji() {
    return Function._gw("LOOKUP", 28, 2, 3, false, 0, 1, null, 64, 64, 32);
  }
  static get _h8() {
    return Function._gw("INDEX", 29, 2, 4, false, 0, 1, null, 32, 32, 64);
  }
  static get _ml() {
    return Function._gw("REPT", 30, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _jr() {
    return Function._gw("MID", 31, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _i6() {
    return Function._gw("LEN", 32, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _pm() {
    return Function._gw("VALUE", 33, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _pd() {
    return Function._gw("TRUE", 34, 0, 0, false, 0, 1, null, 64);
  }
  static get _e3() {
    return Function._gw("FALSE", 35, 0, 0, false, 0, 1, null, 64);
  }
  static get _v() {
    return Function._gw("AND", 36, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _k9() {
    return Function._gw("OR", 37, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _kr() {
    return Function._gw("NOT", 38, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _j1() {
    return Function._gw("MOD", 39, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _db() {
    return Function._gw("DCOUNT", 40, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _d4() {
    return Function._gw("DSUM", 41, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _c5() {
    return Function._gw("DAVERAGE", 42, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _dw() {
    return Function._gw("DMIN", 43, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _dv() {
    return Function._gw("DMAX", 44, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _d2() {
    return Function._gw("DSTDEV", 45, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _pn() {
    return Function._gw("VAR", 46, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _d6() {
    return Function._gw("DVAR", 47, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _ou() {
    return Function._gw("TEXT", 48, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _i8() {
    return Function._gw("LINEST", 49, 1, 4, false, 0, 1, null, 96, 32, 32, 64, 64);
  }
  static get _pa() {
    return Function._gw("TREND", 50, 1, 4, false, 0, 1, null, 96, 32, 32, 32, 64);
  }
  static get _jd() {
    return Function._gw("LOGEST", 51, 1, 4, false, 0, 1, null, 96, 32, 32, 64, 64);
  }
  static get _g2() {
    return Function._gw("GROWTH", 52, 1, 4, false, 0, 1, null, 96, 32, 32, 32, 64);
  }
  static get _l1() {
    return Function._gw("PV", 56, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _fy() {
    return Function._gw("FV", 57, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ku() {
    return Function._gw("NPER", 58, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _lo() {
    return Function._gw("PMT", 59, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _mc() {
    return Function._gw("RATE", 60, 3, 6, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _jy() {
    return Function._gw("MIRR", 61, 3, 3, false, 0, 1, null, 64, 32, 64, 64);
  }
  static get _ii() {
    return Function._gw("IRR", 62, 1, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _l7() {
    return Function._gw("RAND", 63, 0, 0, true, 0, 1, null, 64);
  }
  static get _jk() {
    return Function._gw("MATCH", 64, 2, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _c1() {
    return Function._gw("DATE", 65, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _o5() {
    return Function._gw("TIME", 66, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _c6() {
    return Function._gw("DAY", 67, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _j5() {
    return Function._gw("MONTH", 68, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _qa() {
    return Function._gw("YEAR", 69, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _py() {
    return Function._gw("WEEKDAY", 70, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _ha() {
    return Function._gw("HOUR", 71, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _jw() {
    return Function._gw("MINUTE", 72, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _nc() {
    return Function._gw("SECOND", 73, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _kt() {
    return Function._gw("NOW", 74, 0, 0, true, 0, 1, null, 64);
  }
  static get _y() {
    return Function._gw("AREAS", 75, 1, 1, false, 0, 1, [0], 64, 32);
  }
  static get _m1() {
    return Function._gw("ROWS", 76, 1, 1, false, 0, 1, null, 64, 32);
  }
  static get _bt() {
    return Function._gw("COLUMNS", 77, 1, 1, false, 0, 1, null, 64, 32);
  }
  static get _k6() {
    return Function._gw("OFFSET", 78, 3, 5, true, 0, 1, [0], 32, 32, 64, 64, 64, 64);
  }
  static get _m8() {
    return Function._gw("SEARCH", 82, 2, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _o9() {
    return Function._gw("TRANSPOSE", 83, 1, 1, false, 0, 1, null, 96, 96);
  }
  static get _pg() {
    return Function._gw("TYPE", 86, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ae() {
    return Function._gw("ATAN2", 97, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ab() {
    return Function._gw("ASIN", 98, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h() {
    return Function._gw("ACOS", 99, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _bp() {
    return Function._gw("CHOOSE", 100, 2, -1, false, 0, 1, null, 32, 64, 32);
  }
  static get _g9() {
    return Function._gw("HLOOKUP", 101, 3, 4, false, 0, 1, null, 64, 64, 32, 64);
  }
  static get _pv() {
    return Function._gw("VLOOKUP", 102, 3, 4, false, 0, 1, null, 64, 64, 32, 64);
  }
  static get _ix() {
    return Function._gw("ISREF", 105, 1, 1, false, 0, 1, null, 64, 32);
  }
  static get _jb() {
    return Function._gw("LOG", 109, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bf() {
    return Function._gw("CHAR", 111, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _jj() {
    return Function._gw("LOWER", 112, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _pk() {
    return Function._gw("UPPER", 113, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _l0() {
    return Function._gw("PROPER", 114, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _i4() {
    return Function._gw("LEFT", 115, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ms() {
    return Function._gw("RIGHT", 116, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _eq() {
    return Function._gw("EXACT", 117, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _pb() {
    return Function._gw("TRIM", 118, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mj() {
    return Function._gw("REPLACE", 119, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _n4() {
    return Function._gw("SUBSTITUTE", 120, 3, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _br() {
    return Function._gw("CODE", 121, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _e8() {
    return Function._gw("FIND", 124, 2, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _be() {
    return Function._gw("CELL", 125, 1, 2, true, 0, 1, [1], 64, 64, 32);
  }
  static get _ik() {
    return Function._gw("ISERR", 126, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _iy() {
    return Function._gw("ISTEXT", 127, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _is() {
    return Function._gw("ISNUMBER", 128, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ij() {
    return Function._gw("ISBLANK", 129, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _og() {
    return Function._gw("T", 130, 1, 1, false, 0, 1, null, 64, 32);
  }
  static get _ka() {
    return Function._gw("N", 131, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _c4() {
    return Function._gw("DATEVALUE", 140, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o6() {
    return Function._gw("TIMEVALUE", 141, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _np() {
    return Function._gw("SLN", 142, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _of() {
    return Function._gw("SYD", 143, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _dd() {
    return Function._gw("DDB", 144, 4, 5, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _h9() {
    return Function._gw("INDIRECT", 148, 1, 2, true, 0, 1, null, 32, 64, 64);
  }
  static get _bq() {
    return Function._gw("CLEAN", 162, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _jo() {
    return Function._gw("MDETERM", 163, 1, 1, false, 0, 1, null, 64, 96);
  }
  static get _jx() {
    return Function._gw("MINVERSE", 164, 1, 1, false, 0, 1, null, 96, 96);
  }
  static get _jz() {
    return Function._gw("MMULT", 165, 2, 2, false, 0, 1, null, 96, 96, 96);
  }
  static get _ih() {
    return Function._gw("IPMT", 167, 4, 6, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _lt() {
    return Function._gw("PPMT", 168, 4, 6, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _b9() {
    return Function._gw("COUNTA", 169, 0, -1, false, 0, 1, null, 64, 32);
  }
  static get _lz() {
    return Function._gw("PRODUCT", 183, 0, -1, false, 0, 1, null, 64, 32);
  }
  static get _e1() {
    return Function._gw("FACT", 184, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _gs() {
    return Function._gw("GET.WORKSPACE", 186 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _d1() {
    return Function._gw("DPRODUCT", 189, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _ir() {
    return Function._gw("ISNONTEXT", 190, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _n0() {
    return Function._gw("STDEVP", 193, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _pr() {
    return Function._gw("VARP", 194, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _d3() {
    return Function._gw("DSTDEVP", 195, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _d7() {
    return Function._gw("DVARP", 196, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _pe() {
    return Function._gw("TRUNC", 197, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _ip() {
    return Function._gw("ISLOGICAL", 198, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dc() {
    return Function._gw("DCOUNTA", 199, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _pl() {
    return Function._gw("USDOLLAR", 204, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _e9() {
    return Function._gw("FINDB", 205, 2, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _m9() {
    return Function._gw("SEARCHB", 206, 2, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _mk() {
    return Function._gw("REPLACEB", 207, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _i5() {
    return Function._gw("LEFTB", 208, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _mt() {
    return Function._gw("RIGHTB", 209, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _js() {
    return Function._gw("MIDB", 210, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _i7() {
    return Function._gw("LENB", 211, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mz() {
    return Function._gw("ROUNDUP", 212, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _my() {
    return Function._gw("ROUNDDOWN", 213, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _aa() {
    return Function._gw("ASC", 214, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _da() {
    return Function._gw("DBCS", 215, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _l9() {
    return Function._gw("RANK", 216, 2, 3, false, 0, 1, [1], 64, 64, 32, 64);
  }
  static get _r() {
    return Function._gw("ADDRESS", 219, 2, 5, false, 0, 1, null, 64, 64, 64);
  }
  static get _c8() {
    return Function._gw("DAYS360", 220, 2, 3, false, 0, 1, null, 64, 64, 64);
  }
  static get _o8() {
    return Function._gw("TODAY", 221, 0, 0, true, 0, 1, null, 64);
  }
  static get _pt() {
    return Function._gw("VDB", 222, 5, 7, false, 0, 1, null, 64, 64, 64, 64, 64, 64);
  }
  static get _jq() {
    return Function._gw("MEDIAN", 227, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _n9() {
    return Function._gw("SUMPRODUCT", 228, 1, -1, false, 0, 1, null, 64, 96);
  }
  static get _nm() {
    return Function._gw("SINH", 229, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _b5() {
    return Function._gw("COSH", 230, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _oo() {
    return Function._gw("TANH", 231, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ac() {
    return Function._gw("ASINH", 232, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _i() {
    return Function._gw("ACOSH", 233, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _af() {
    return Function._gw("ATANH", 234, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dr() {
    return Function._gw("DGET", 235, 3, 3, false, 0, 1, [0], 64, 32, 32, 32);
  }
  static get _ia() {
    return Function._gw("INFO", 244, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _c9() {
    return Function._gw("DB", 247, 4, 5, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _fv() {
    return Function._gw("FREQUENCY", 252, 2, 2, false, 0, 1, null, 96, 32, 32);
  }
  static get _en() {
    return Function._gw("ERROR.TYPE", 261, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ag() {
    return Function._gw("AVEDEV", 269, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _at() {
    return Function._gw("BETADIST", 270, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _f7() {
    return Function._gw("GAMMALN", 271, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _au() {
    return Function._gw("BETAINV", 272, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _a1() {
    return Function._gw("BINOMDIST", 273, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _bh() {
    return Function._gw("CHIDIST", 274, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bi() {
    return Function._gw("CHIINV", 275, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bu() {
    return Function._gw("COMBIN", 276, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bz() {
    return Function._gw("CONFIDENCE", 277, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _cn() {
    return Function._gw("CRITBINOM", 278, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ep() {
    return Function._gw("EVEN", 279, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ev() {
    return Function._gw("EXPONDIST", 280, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _e5() {
    return Function._gw("FDIST", 281, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _fa() {
    return Function._gw("FINV", 282, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _fb() {
    return Function._gw("FISHER", 283, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _fc() {
    return Function._gw("FISHERINV", 284, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _fe() {
    return Function._gw("FLOOR", 285, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _f5() {
    return Function._gw("GAMMADIST", 286, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _f6() {
    return Function._gw("GAMMAINV", 287, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _bb() {
    return Function._gw("CEILING", 288, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _he() {
    return Function._gw("HYPGEOMVERT", 289, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _jh() {
    return Function._gw("LOGNORMDIST", 290, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _je() {
    return Function._gw("LOGINV", 291, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ke() {
    return Function._gw("NEGBINOMDIST", 292, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _kn() {
    return Function._gw("NORMDIST", 293, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _kp() {
    return Function._gw("NORMSDIST", 294, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ko() {
    return Function._gw("NORMINV", 295, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _j0() {
    return Function._gw("MNORMSINV", 296, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _nv() {
    return Function._gw("STANDARDIZE", 297, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _k1() {
    return Function._gw("ODD", 298, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _lj() {
    return Function._gw("PERMUT", 299, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _lp() {
    return Function._gw("POISSON", 300, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _os() {
    return Function._gw("TDIST", 301, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _p0() {
    return Function._gw("WEIBULL", 302, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _od() {
    return Function._gw("SUMXMY2", 303, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _ob() {
    return Function._gw("SUMX2MY2", 304, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _oc() {
    return Function._gw("SUMX2PY2", 305, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _bo() {
    return Function._gw("CHITEST", 306, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _b3() {
    return Function._gw("CORREL", 307, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _cj() {
    return Function._gw("COVAR", 308, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _fk() {
    return Function._gw("FORECAST", 309, 3, 3, false, 0, 1, null, 64, 64, 96, 96);
  }
  static get _fx() {
    return Function._gw("FTEST", 310, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _ie() {
    return Function._gw("INTERCEPT", 311, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _lc() {
    return Function._gw("PEARSON", 312, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _m3() {
    return Function._gw("RSQ", 313, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _n3() {
    return Function._gw("STEYX", 314, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _nq() {
    return Function._gw("SLOPE", 315, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _pf() {
    return Function._gw("TTEST", 316, 4, 4, false, 0, 1, null, 64, 96, 96, 64, 64);
  }
  static get _ly() {
    return Function._gw("PROB", 317, 3, 4, false, 0, 1, null, 64, 96, 96, 64, 64);
  }
  static get _dq() {
    return Function._gw("DEVSQ", 318, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _gb() {
    return Function._gw("GEOMEAN", 319, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _g4() {
    return Function._gw("HARMEAN", 320, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _oa() {
    return Function._gw("SUMSQ", 321, 0, -1, false, 0, 1, null, 64, 32);
  }
  static get _i0() {
    return Function._gw("KURT", 322, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _nn() {
    return Function._gw("SKEW", 323, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _qg() {
    return Function._gw("ZTEST", 324, 2, 3, false, 0, 1, null, 64, 32, 64);
  }
  static get _i1() {
    return Function._gw("LARGE", 325, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _nr() {
    return Function._gw("SMALL", 326, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _l2() {
    return Function._gw("QUARTILE", 327, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _ld() {
    return Function._gw("PERCENTILE", 328, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _lg() {
    return Function._gw("PERCENTRANK", 329, 2, 3, false, 0, 1, null, 64, 32, 64);
  }
  static get _j2() {
    return Function._gw("MODE", 330, 1, -1, false, 0, 1, null, 64, 96);
  }
  static get _pc() {
    return Function._gw("TRIMMEAN", 331, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _o7() {
    return Function._gw("TINV", 332, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _by() {
    return Function._gw("CONCATENATE", 336, 0, -1, false, 0, 1, null, 64, 64);
  }
  static get _ls() {
    return Function._gw("POWER", 337, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _l6() {
    return Function._gw("RADIANS", 342, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _di() {
    return Function._gw("DEGREES", 343, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _n5() {
    return Function._gw("SUBTOTAL", 344, 2, -1, false, 0, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254], 64, 64, 32);
  }
  static get _n7() {
    return Function._gw("SUMIF", 345, 2, 3, false, 0, 1, [0, 2], 64, 32, 64, 32);
  }
  static get _cb() {
    return Function._gw("COUNTIF", 346, 2, 2, false, 0, 1, [0], 64, 32, 64);
  }
  static get _ca() {
    return Function._gw("COUNTBLANK", 347, 1, 1, false, 0, 1, [0], 64, 32);
  }
  static get _iw() {
    return Function._gw("ISPMT", 350, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _c2() {
    return Function._gw("DATEDIF", 351, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _c3() {
    return Function._gw("DATESTRING", 352, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _kw() {
    return Function._gw("NUMBERSTRING", 353, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _mu() {
    return Function._gw("ROMAN", 354, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _gy() {
    return Function._gw("GETPIVOTDATA", 358, 2, -1, false, 2, 2, null, 32, 32, 32);
  }
  static get _hb() {
    return Function._gw("HYPERLINK", 359, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _lm() {
    return Function._gw("PHONETIC", 360, 1, -1, false, 0, 1, [0], 64, 32);
  }
  static get _ai() {
    return Function._gw("AVERAGEA", 361, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _jm() {
    return Function._gw("MAXA", 362, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _ju() {
    return Function._gw("MINA", 363, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _n1() {
    return Function._gw("STDEVPA", 364, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _ps() {
    return Function._gw("VARPA", 365, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _nz() {
    return Function._gw("STDEVA", 366, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _pq() {
    return Function._gw("VARA", 367, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _q() {
    return Function._gw("<AddIn>", 255, 0, -1, false, 0, 1, null, 32, 32);
  }
  static get _f() {
    return Function._gw("ACCRINT", -1, 6, 8, false, 0, 1, null, 32, 32);
  }
  static get _g() {
    return Function._gw("ACCRINTM", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _t() {
    return Function._gw("AMORDEGRC", -1, 6, 7, false, 0, 1, null, 32, 32);
  }
  static get _u() {
    return Function._gw("AMORLINC", -1, 6, 7, false, 0, 1, null, 32, 32);
  }
  static get _aj() {
    return Function._gw("AVERAGEIF", -1, 2, 3, false, 0, 1, [0, 2], 64, 32, 64, 32);
  }
  static get _ak() {
    return Function._gw("AVERAGEIFS", -1, 3, -1, false, 3, 2, [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251], 32, 32, 32, 64);
  }
  static get _al() {
    return Function._gw("BAHTTEXT", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _an() {
    return Function._gw("BESSELI", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _ao() {
    return Function._gw("BESSELJ", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _ap() {
    return Function._gw("BESSELK", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _aq() {
    return Function._gw("BESSELY", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _av() {
    return Function._gw("BIN2DEC", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _aw() {
    return Function._gw("BIN2HEX", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _ax() {
    return Function._gw("BIN2OCT", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _bw() {
    return Function._gw("COMPLEX", -1, 2, 3, false, 0, 1, null, 32, 32);
  }
  static get _b2() {
    return Function._gw("CONVERT", -1, 3, 3, false, 0, 1, null, 64, 64);
  }
  static get _cd() {
    return Function._gw("COUPDAYBS", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _ce() {
    return Function._gw("COUPDAYS", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _cf() {
    return Function._gw("COUPDAYSNC", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _cg() {
    return Function._gw("COUPNCD", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _ch() {
    return Function._gw("COUPNUM", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _ci() {
    return Function._gw("COUPPCD", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _cq() {
    return Function._gw("CUBEKPIMEMBER", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _cr() {
    return Function._gw("CUBEMEMBER", -1, 2, 3, false, 0, 1, null, 32, 32);
  }
  static get _cs() {
    return Function._gw("CUBEMEMBERPROPERTY", -1, 3, 3, false, 0, 1, null, 32, 32);
  }
  static get _ct() {
    return Function._gw("CUBERANKEDMEMBER", -1, 3, 4, false, 0, 1, null, 32, 32);
  }
  static get _cu() {
    return Function._gw("CUBESET", -1, 2, 5, false, 0, 1, null, 32, 32);
  }
  static get _cv() {
    return Function._gw("CUBESETCOUNT", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _cw() {
    return Function._gw("CUBEVALUE", -1, 1, -1, false, 0, 1, null, 32, 32);
  }
  static get _cx() {
    return Function._gw("CUMIPMT", -1, 6, 6, false, 0, 1, null, 32, 32);
  }
  static get _cy() {
    return Function._gw("CUMPRINC", -1, 6, 6, false, 0, 1, null, 32, 32);
  }
  static get _de() {
    return Function._gw("DEC2BIN", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _df() {
    return Function._gw("DEC2HEX", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _dg() {
    return Function._gw("DEC2OCT", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _dn() {
    return Function._gw("DELTA", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _du() {
    return Function._gw("DISC", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _dz() {
    return Function._gw("DOLLARDE", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _d0() {
    return Function._gw("DOLLARFR", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _d5() {
    return Function._gw("DURATION", -1, 5, 6, false, 0, 1, null, 32, 32);
  }
  static get _ea() {
    return Function._gw("EDATE", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _eb() {
    return Function._gw("EFFECT", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _eh() {
    return Function._gw("EOMONTH", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _ei() {
    return Function._gw("ERF", -1, 1, 2, false, 0, 1, null, 32, 32);
  }
  static get _ek() {
    return Function._gw("ERFC", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _e2() {
    return Function._gw("FACTDOUBLE", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _fz() {
    return Function._gw("FVSCHEDULE", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _ga() {
    return Function._gw("GCD", -1, 1, -1, false, 0, 1, null, 32, 32);
  }
  static get _gc() {
    return Function._gw("GESTEP", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _g6() {
    return Function._gw("HEX2BIN", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _g7() {
    return Function._gw("HEX2DEC", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _g8() {
    return Function._gw("HEX2OCT", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _hd() {
    return Function._gw("HYPGEOMDIST", -1, 4, 4, false, 0, 1, null, 32, 32);
  }
  static get _hg() {
    return Function._gw("IFERROR", -1, 2, 2, false, 0, 1, null, 32, 64, 32);
  }
  static get _hj() {
    return Function._gw("IMABS", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hk() {
    return Function._gw("IMAGINARY", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hl() {
    return Function._gw("IMARGUMENT", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hm() {
    return Function._gw("IMCONJUGATE", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hn() {
    return Function._gw("IMCOS", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hs() {
    return Function._gw("IMDIV", -1, 2, 2, false, 0, 1, null, 64, 64);
  }
  static get _ht() {
    return Function._gw("IMEXP", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hu() {
    return Function._gw("IMLN", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hv() {
    return Function._gw("IMLOG10", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hw() {
    return Function._gw("IMLOG2", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hx() {
    return Function._gw("IMPOWER", -1, 2, 2, false, 0, 1, null, 64, 64);
  }
  static get _hy() {
    return Function._gw("IMPRODUCT", -1, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _hz() {
    return Function._gw("IMREAL", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h2() {
    return Function._gw("IMSIN", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h4() {
    return Function._gw("IMSQRT", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h5() {
    return Function._gw("IMSUB", -1, 2, 2, false, 0, 1, null, 64, 64);
  }
  static get _h6() {
    return Function._gw("IMSUM", -1, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _ig() {
    return Function._gw("INTRATE", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _im() {
    return Function._gw("ISEVEN", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _iu() {
    return Function._gw("ISODD", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _i3() {
    return Function._gw("LCM", -1, 1, -1, false, 0, 1, null, 32, 32);
  }
  static get _jp() {
    return Function._gw("MDURATION", -1, 5, 6, false, 0, 1, null, 32, 32);
  }
  static get _j7() {
    return Function._gw("MROUND", -1, 2, 2, false, 0, 1, null, 32, 64);
  }
  static get _j8() {
    return Function._gw("MULTINOMIAL", -1, 1, -1, false, 0, 1, null, 32, 32);
  }
  static get _kf() {
    return Function._gw("NETWORKDAYS", -1, 2, 3, false, 0, 1, null, 32, 32);
  }
  static get _ki() {
    return Function._gw("NOMINAL", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _kq() {
    return Function._gw("NORMSINV", -1, 1, 1, false, 0, 1, null, 32, 32);
  }
  static get _ky() {
    return Function._gw("OCT2BIN", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _kz() {
    return Function._gw("OCT2DEC", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _k0() {
    return Function._gw("OCT2HEX", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _k2() {
    return Function._gw("ODDFPRICE", -1, 8, 9, false, 0, 1, null, 32, 32);
  }
  static get _k3() {
    return Function._gw("ODDFYIELD", -1, 8, 9, false, 0, 1, null, 32, 32);
  }
  static get _k4() {
    return Function._gw("ODDLPRICE", -1, 7, 8, false, 0, 1, null, 32, 32);
  }
  static get _k5() {
    return Function._gw("ODDLYIELD", -1, 7, 8, false, 0, 1, null, 32, 32);
  }
  static get _lv() {
    return Function._gw("PRICE", -1, 6, 7, false, 0, 1, null, 32, 32);
  }
  static get _lw() {
    return Function._gw("PRICEDISC", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _lx() {
    return Function._gw("PRICEMAT", -1, 5, 6, false, 0, 1, null, 32, 32);
  }
  static get _l5() {
    return Function._gw("QUOTIENT", -1, 2, 2, false, 0, 1, null, 32, 32);
  }
  static get _l8() {
    return Function._gw("RANDBETWEEN", -1, 2, 2, true, 0, 1, null, 32, 32);
  }
  static get _md() {
    return Function._gw("RECEIVED", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _m4() {
    return Function._gw("RTD", -1, 3, -1, false, 0, 1, null, 32, 32);
  }
  static get _ne() {
    return Function._gw("SERIESSUM", -1, 4, 4, false, 0, 1, null, 32, 64, 64, 64, 32);
  }
  static get _nu() {
    return Function._gw("SQRTPI", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _n8() {
    return Function._gw("SUMIFS", -1, 3, -1, false, 3, 2, [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251], 32, 32, 32, 64);
  }
  static get _op() {
    return Function._gw("TBILLEQ", -1, 3, 3, false, 0, 1, null, 32, 32);
  }
  static get _oq() {
    return Function._gw("TBILLPRICE", -1, 3, 3, false, 0, 1, null, 32, 32);
  }
  static get _or() {
    return Function._gw("TBILLYIELD", -1, 3, 3, false, 0, 1, null, 32, 32);
  }
  static get _pz() {
    return Function._gw("WEEKNUM", -1, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _p5() {
    return Function._gw("WORKDAY", -1, 2, 3, false, 0, 1, null, 64, 64);
  }
  static get _p7() {
    return Function._gw("XIRR", -1, 2, 3, false, 0, 1, null, 32, 32);
  }
  static get _p8() {
    return Function._gw("XNPV", -1, 3, 3, false, 0, 1, null, 32, 32);
  }
  static get _qb() {
    return Function._gw("YEARFRAC", -1, 2, 3, false, 0, 1, null, 32, 32);
  }
  static get _qc() {
    return Function._gw("YIELD", -1, 6, 7, false, 0, 1, null, 32, 32);
  }
  static get _qd() {
    return Function._gw("YIELDDISC", -1, 4, 5, false, 0, 1, null, 32, 32);
  }
  static get _qe() {
    return Function._gw("YIELDMAT", -1, 5, 6, false, 0, 1, null, 32, 32);
  }
  static get _j() {
    return Function._gw("ACOT", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _k() {
    return Function._gw("ACOTH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _x() {
    return Function._gw("ARABIC", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _s() {
    return Function._gw("AGGREGATE", -3, 3, -1, false, 0, 1, [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254], 64, 64, 64, 64, 64, 32);
  }
  static get _am() {
    return Function._gw("BASE", -3, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _ar() {
    return Function._gw("BETA.DIST", -3, 4, 6, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _as() {
    return Function._gw("BETA.INV", -3, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ay() {
    return Function._gw("BINOM.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _az() {
    return Function._gw("BINOM.DIST.RANGE", -3, 3, 4, false, 0, 1, null, 64, 32);
  }
  static get _a0() {
    return Function._gw("BINOM.INV", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _a2() {
    return Function._gw("BITAND", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _a3() {
    return Function._gw("BITLSHIFT", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _a4() {
    return Function._gw("BITOR", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _a5() {
    return Function._gw("BITRSHIFT", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _a6() {
    return Function._gw("BITXOR", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bc() {
    return Function._gw("CEILING.MATH", -3, 1, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _bd() {
    return Function._gw("CEILING.PRECISE", -3, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bj() {
    return Function._gw("CHISQ.DIST", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _bk() {
    return Function._gw("CHISQ.DIST.RT", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bl() {
    return Function._gw("CHISQ.INV", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bm() {
    return Function._gw("CHISQ.INV.RT", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bn() {
    return Function._gw("CHISQ.TEST", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _bv() {
    return Function._gw("COMBINA", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _b0() {
    return Function._gw("CONFIDENCE.NORM", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _b1() {
    return Function._gw("CONFIDENCE.T", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _b6() {
    return Function._gw("COT", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _b7() {
    return Function._gw("COTH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ck() {
    return Function._gw("COVARIANCE.P", -3, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _cl() {
    return Function._gw("COVARIANCE.S", -3, 2, 2, false, 0, 1, null, 64, 96, 96);
  }
  static get _co() {
    return Function._gw("CSC", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _cp() {
    return Function._gw("CSCH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _c7() {
    return Function._gw("DAYS", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _dh() {
    return Function._gw("DECIMAL", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ej() {
    return Function._gw("ERF.PRECISE", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _el() {
    return Function._gw("ERFC.PRECISE", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _eu() {
    return Function._gw("EXPON.DIST", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ew() {
    return Function._gw("F.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _ex() {
    return Function._gw("F.DIST.RT", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ey() {
    return Function._gw("F.INV", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _ez() {
    return Function._gw("F.INV.RT", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _e0() {
    return Function._gw("F.TEST", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _e7() {
    return Function._gw("FILTERXML", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ff() {
    return Function._gw("FLOOR.MATH", -3, 1, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _fg() {
    return Function._gw("FLOOR.PRECISE", -3, 1, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _fr() {
    return Function._gw("FORMULATEXT", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _f2() {
    return Function._gw("GAMMA", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _f3() {
    return Function._gw("GAMMA.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _f4() {
    return Function._gw("GAMMA.INV", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _f8() {
    return Function._gw("GAMMALN.PRECISE", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _f9() {
    return Function._gw("GAUSS", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hc() {
    return Function._gw("HYPGEOM.DIST", -3, 5, 5, false, 0, 1, null, 32, 32);
  }
  static get _hh() {
    return Function._gw("IFNA", -3, 2, 2, false, 0, 1, null, 32, 64, 32);
  }
  static get _ho() {
    return Function._gw("IMCOSH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hp() {
    return Function._gw("IMCOT", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hq() {
    return Function._gw("IMCSC", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _hr() {
    return Function._gw("IMCSCH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h0() {
    return Function._gw("IMSEC", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h1() {
    return Function._gw("IMSECH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h3() {
    return Function._gw("IMSINH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _h7() {
    return Function._gw("IMTAN", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _io() {
    return Function._gw("ISFORMULA", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _iv() {
    return Function._gw("ISOWEEKNUM", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _jf() {
    return Function._gw("LOGNORM.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _jg() {
    return Function._gw("LOGNORM.INV", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _j3() {
    return Function._gw("MODE.MULT", -3, 1, -1, false, 0, 1, null, 96, 96);
  }
  static get _j4() {
    return Function._gw("MODE.SNGL", -3, 1, -1, false, 0, 1, null, 64, 96);
  }
  static get _j9() {
    return Function._gw("MUNIT", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _kd() {
    return Function._gw("NEGBINOM.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _kj() {
    return Function._gw("NORM.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _kk() {
    return Function._gw("NORM.INV", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _kl() {
    return Function._gw("NORM.S.DIST", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _km() {
    return Function._gw("NORM.S.INV", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _kx() {
    return Function._gw("NUMBERVALUE", -3, 1, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _lb() {
    return Function._gw("PDURATION", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _le() {
    return Function._gw("PERCENTILE.EXC", -3, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _lf() {
    return Function._gw("PERCENTILE.INC", -3, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _lh() {
    return Function._gw("PERCENTRANK.EXC", -3, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _li() {
    return Function._gw("PERCENTRANK.INC", -3, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _lk() {
    return Function._gw("PERMUTATIONA", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ll() {
    return Function._gw("PHI", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _lq() {
    return Function._gw("POISSON.DIST", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _l3() {
    return Function._gw("QUARTILE.EXC", -3, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _l4() {
    return Function._gw("QUARTILE.INC", -3, 2, 2, false, 0, 1, null, 64, 32, 64);
  }
  static get _ma() {
    return Function._gw("RANK.AVG", -3, 2, 3, false, 0, 1, [1], 64, 64, 32, 64);
  }
  static get _mb() {
    return Function._gw("RANK.EQ", -3, 2, 3, false, 0, 1, [1], 64, 64, 32, 64);
  }
  static get _m2() {
    return Function._gw("RRI", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _na() {
    return Function._gw("SEC", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _nb() {
    return Function._gw("SECH", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _nh() {
    return Function._gw("SHEET", -3, 0, 1, true, 0, 1, null, 64, 64);
  }
  static get _ni() {
    return Function._gw("SHEETS", -3, 0, 1, true, 0, 1, null, 64, 32);
  }
  static get _no() {
    return Function._gw("SKEW.P", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _nx() {
    return Function._gw("STDEV.P", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _ny() {
    return Function._gw("STDEV.S", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _oh() {
    return Function._gw("T.DIST", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _oi() {
    return Function._gw("T.DIST.2T", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _oj() {
    return Function._gw("T.DIST.RT", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ok() {
    return Function._gw("T.INV", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _ol() {
    return Function._gw("T.INV.2T", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _om() {
    return Function._gw("T.TEST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _ph() {
    return Function._gw("UNICHAR", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _pi() {
    return Function._gw("UNICODE", -3, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _po() {
    return Function._gw("VAR.P", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _pp() {
    return Function._gw("VAR.S", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _px() {
    return Function._gw("WEBSERVICE", -3, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _p1() {
    return Function._gw("WEIBULL.DIST", -3, 4, 4, false, 0, 1, null, 64, 64, 64, 64, 64);
  }
  static get _p9() {
    return Function._gw("XOR", -3, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _qf() {
    return Function._gw("Z.TEST", -3, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _d9() {
    return Function._gw("ECMA.CEILING", -3, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _it() {
    return Function._gw("ISO.CEILING", -3, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _kg() {
    return Function._gw("NETWORKDAYS.INTL", -3, 2, 4, false, 0, 1, null, 64, 32, 64);
  }
  static get _p6() {
    return Function._gw("WORKDAY.INTL", -3, 2, 4, false, 0, 1, null, 64, 32, 64);
  }
  static get _fl() {
    return Function._gw("FORECAST.ETS", -3, 3, 6, false, 0, 1, null, 64, 32);
  }
  static get _fm() {
    return Function._gw("FORECAST.ETS.CONFINT", -3, 3, 7, false, 0, 1, null, 64, 32);
  }
  static get _fn() {
    return Function._gw("FORECAST.ETS.SEASONALITY", -3, 2, 4, false, 0, 1, null, 64, 32);
  }
  static get _fp() {
    return Function._gw("FORECAST.LINEAR", -3, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _fo() {
    return Function._gw("FORECAST.ETS.STAT", -3, 3, 6, false, 0, 1, null, 64, 32);
  }
  static get _cc() {
    return Function._gw("COUNTIFS", -1, 2, -1, false, 2, 2, [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254], 32, 32, 64);
  }
  static get _bx() {
    return Function._gw("CONCAT", -2, 1, -1, false, 0, 1, null, 64, 32);
  }
  static get _hi() {
    return Function._gw("IFS", -2, 2, -1, false, 0, 2, null, 32, 32);
  }
  static get _jn() {
    return Function._gw("MAXIFS", -2, 3, -1, false, 1, 2, [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251], 32, 32, 32, 64);
  }
  static get _jv() {
    return Function._gw("MINIFS", -2, 3, -1, false, 1, 2, [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251], 32, 32, 32, 64);
  }
  static get _oe() {
    return Function._gw("SWITCH", -2, 3, -1, false, 2, 1, null, 32, 32);
  }
  static get _ow() {
    return Function._gw("TEXTJOIN", -2, 3, -1, false, 2, 1, null, 64, 32);
  }
  static get _iz() {
    return Function._gw("ISTHAIDIGIT", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mw() {
    return Function._gw("ROUNDBAHTDOWN", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mx() {
    return Function._gw("ROUNDBAHTUP", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _oy() {
    return Function._gw("THAIDAYOFWEEK", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _oz() {
    return Function._gw("THAIDIGIT", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o0() {
    return Function._gw("THAIMONTHOFYEAR", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o1() {
    return Function._gw("THAINUMSOUND", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o2() {
    return Function._gw("THAINUMSTRING", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o3() {
    return Function._gw("THAISTRINGLENGTH", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _o4() {
    return Function._gw("THAIYEAR", -1, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _e() {
    return Function._gw("ABSREF", 79 + 10000, 2, 2, false, 0, 1, null, 64, 64, 32);
  }
  static get _l() {
    return Function._gw("ACTIVE.CELL", 94 + 10000, 0, 0, false, 0, 1, null, 32);
  }
  static get _a8() {
    return Function._gw("CALL", 150 + 10000, 1, 1, false, 0, 1, null, 64, 32);
  }
  static get _a9() {
    return Function._gw("CALLER", 89 + 10000, 0, 0, false, 0, 1, null, 32);
  }
  static get _eo() {
    return Function._gw("EVALUATE", 257 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _gh() {
    return Function._gw("GET.DOCUMENT", 188 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _ic() {
    return Function._gw("INPUT", 104 + 10000, 1, 7, false, 0, 1, null, 64, 64);
  }
  static get _i2() {
    return Function._gw("LAST.ERROR", 238 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _m7() {
    return Function._gw("SCENARIO.GET", 348 + 10000, 1, 2, true, 0, 1, null, 32, 64, 64);
  }
  static get _nd() {
    return Function._gw("SELECTION", 95 + 10000, 0, 0, false, 0, 1, null, 32);
  }
  static get _ox() {
    return Function._gw("TEXTREF", 147 + 10000, 1, 2, true, 0, 1, null, 32, 64, 64);
  }
  static get _pu() {
    return Function._gw("VIEW.GET", 357 + 10000, 1, 2, true, 0, 1, null, 32, 64, 64);
  }
  static get _m() {
    return Function._gw("ADD.BAR", 151 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _n() {
    return Function._gw("ADD.COMMAND", 153 + 10000, 3, 5, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _o() {
    return Function._gw("ADD.MENU", 152 + 10000, 2, 4, false, 0, 1, null, 64, 32, 64);
  }
  static get _p() {
    return Function._gw("ADD.TOOLBAR", 253 + 10000, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _w() {
    return Function._gw("APP.TITLE", 262 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _z() {
    return Function._gw("ARGUMENT", 81 + 10000, 1, 3, false, 0, 1, null, 32, 64, 64, 32);
  }
  static get _a7() {
    return Function._gw("BREAK", 173 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _ba() {
    return Function._gw("CANCEL.KEY", 170 + 10000, 1, 2, false, 0, 1, null, 64, 64, 32);
  }
  static get _bg() {
    return Function._gw("CHECK.COMMAND", 155 + 10000, 4, 5, false, 0, 1, null, 64, 32);
  }
  static get _cm() {
    return Function._gw("CREATE.OBJECT", 236 + 10000, 4, 12, false, 0, 1, null, 64, 64);
  }
  static get _cz() {
    return Function._gw("CUSTOM.REPEAT", 240 + 10000, 0, 3, false, 0, 1, null, 64, 64);
  }
  static get _c0() {
    return Function._gw("CUSTOM.UNDO", 239 + 10000, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _dj() {
    return Function._gw("DELETE.BAR", 200 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dk() {
    return Function._gw("DELETE.COMMAND", 159 + 10000, 3, 4, false, 0, 1, null, 64, 32);
  }
  static get _dl() {
    return Function._gw("DELETE.MENU", 158 + 10000, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _dm() {
    return Function._gw("DELETE.TOOLBAR", 254 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dp() {
    return Function._gw("DEREF", 90 + 10000, 1, 1, false, 0, 1, [0], 64, 32);
  }
  static get _ds() {
    return Function._gw("DIALOG.BOX", 161 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dt() {
    return Function._gw("DIRECTORY", 123 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _dx() {
    return Function._gw("DOCUMENTS", 93 + 10000, 0, 2, false, 0, 1, null, 96, 64);
  }
  static get _d8() {
    return Function._gw("ECHO", 87 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ec() {
    return Function._gw("ELSE", 223 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _ed() {
    return Function._gw("ELSE.IF", 224 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ee() {
    return Function._gw("ENABLE.COMMAND", 154 + 10000, 4, 5, false, 0, 1, null, 64, 32);
  }
  static get _ef() {
    return Function._gw("ENABLE.TOOL", 265 + 10000, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _eg() {
    return Function._gw("END.IF", 225 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _em() {
    return Function._gw("ERROR", 84 + 10000, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _er() {
    return Function._gw("EXEC", 110 + 10000, 1, 4, false, 0, 1, null, 64, 32, 32, 32, 64);
  }
  static get _es() {
    return Function._gw("EXECUTE", 178 + 10000, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _e4() {
    return Function._gw("FCLOSE", 133 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _e6() {
    return Function._gw("FILES", 166 + 10000, 0, 1, false, 0, 1, null, 96, 64);
  }
  static get _fh() {
    return Function._gw("FOPEN", 132 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _fi() {
    return Function._gw("FOR", 171 + 10000, 3, 4, false, 0, 1, null, 64, 32);
  }
  static get _fj() {
    return Function._gw("FOR.CELL", 226 + 10000, 2, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _fq() {
    return Function._gw("FORMULA.CONVERT", 241 + 10000, 2, 5, false, 0, 1, null, 64, 64, 64);
  }
  static get _fs() {
    return Function._gw("FPOS", 139 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _ft() {
    return Function._gw("FREAD", 136 + 10000, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _fu() {
    return Function._gw("FREADLN", 135 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _fw() {
    return Function._gw("FSIZE", 134 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _f0() {
    return Function._gw("FWRITE", 138 + 10000, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _f1() {
    return Function._gw("FWRITELN", 137 + 10000, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _gd() {
    return Function._gw("GET.BAR", 182 + 10000, 0, 3, false, 0, 1, null, 64, 64);
  }
  static get _ge() {
    return Function._gw("GET.CELL", 185 + 10000, 1, 2, false, 0, 1, null, 64, 64);
  }
  static get _gf() {
    return Function._gw("GET.CHART.ITEM", 160 + 10000, 2, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _gg() {
    return Function._gw("GET.DEF", 145 + 10000, 2, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _gi() {
    return Function._gw("GET.FORMULA", 106 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _gj() {
    return Function._gw("GET.LINK.INFO", 242 + 10000, 2, 4, false, 0, 1, null, 64, 32, 64);
  }
  static get _gk() {
    return Function._gw("GET.MOVIE", 335 + 10000, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _gl() {
    return Function._gw("GET.NAME", 107 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _gm() {
    return Function._gw("GET.NOTE", 191 + 10000, 0, 3, false, 0, 1, null, 64, 32, 64);
  }
  static get _gn() {
    return Function._gw("GET.OBJECT", 246 + 10000, 1, 5, false, 0, 1, null, 64, 64);
  }
  static get _go() {
    return Function._gw("GET.TOOL", 259 + 10000, 2, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _gp() {
    return Function._gw("GET.TOOLBAR", 258 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _gq() {
    return Function._gw("GET.WINDOW", 187 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _gr() {
    return Function._gw("GET.WORKBOOK", 268 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _g0() {
    return Function._gw("GOTO", 53 + 10000, 1, 1, false, 0, 1, [0], 64, 32);
  }
  static get _g1() {
    return Function._gw("GROUP", 245 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _g3() {
    return Function._gw("HALT", 54 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _g5() {
    return Function._gw("HELP", 181 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ib() {
    return Function._gw("INITIATE", 175 + 10000, 2, 2, false, 0, 1, null, 64, 64, 64);
  }
  static get _i9() {
    return Function._gw("LINKS", 103 + 10000, 0, 2, false, 0, 1, null, 96, 64);
  }
  static get _j6() {
    return Function._gw("MOVIE.COMMAND", 334 + 10000, 3, 4, false, 0, 1, null, 64, 32);
  }
  static get _kc() {
    return Function._gw("NAMES", 122 + 10000, 0, 3, false, 0, 1, null, 96, 64);
  }
  static get _kh() {
    return Function._gw("NEXT", 174 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _ks() {
    return Function._gw("NOTE", 192 + 10000, 0, 4, false, 0, 1, null, 64, 64, 32, 64);
  }
  static get _k7() {
    return Function._gw("OPEN.DIALOG", 355 + 10000, 0, 4, false, 0, 1, null, 64, 64);
  }
  static get _k8() {
    return Function._gw("OPTIONS.LISTS.GET", 349 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _la() {
    return Function._gw("PAUSE", 248 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _lr() {
    return Function._gw("POKE", 177 + 10000, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _lu() {
    return Function._gw("PRESS.TOOL", 266 + 10000, 3, 3, false, 0, 1, null, 64, 64, 64, 64);
  }
  static get _me() {
    return Function._gw("REFTEXT", 146 + 10000, 2, 2, false, 0, 1, [0], 64, 32, 64);
  }
  static get _mf() {
    return Function._gw("REGISTER", 149 + 10000, 1, 31, false, 0, 1, null, 64, 64);
  }
  static get _mg() {
    return Function._gw("REGISTER.ID", 267 + 10000, 2, 3, false, 0, 1, null, 64, 32);
  }
  static get _mh() {
    return Function._gw("RELREF", 80 + 10000, 2, 2, false, 0, 1, null, 32, 32, 32);
  }
  static get _mi() {
    return Function._gw("RENAME.COMMAND", 156 + 10000, 4, 5, false, 0, 1, null, 64, 32, 64);
  }
  static get _mm() {
    return Function._gw("REQUEST", 176 + 10000, 2, 2, false, 0, 1, null, 96, 64, 64);
  }
  static get _mn() {
    return Function._gw("RESET.TOOLBAR", 256 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mo() {
    return Function._gw("RESTART", 180 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mp() {
    return Function._gw("RESULT", 96 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mq() {
    return Function._gw("RESUME", 251 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _mr() {
    return Function._gw("RETURN", 55 + 10000, 0, 1, false, 0, 1, null, 64, 64);
  }
  static get _m5() {
    return Function._gw("SAVE.DIALOG", 356 + 10000, 0, 5, false, 0, 1, null, 64, 64);
  }
  static get _m6() {
    return Function._gw("SAVE.TOOLBAR", 264 + 10000, 0, 2, false, 0, 1, null, 64, 64);
  }
  static get _nf() {
    return Function._gw("SET.NAME", 88 + 10000, 1, 2, true, 0, 1, null, 64, 64, 64);
  }
  static get _ng() {
    return Function._gw("SET.VALUE", 108 + 10000, 2, 2, false, 0, 1, [0], 64, 32, 64);
  }
  static get _nj() {
    return Function._gw("SHOW.BAR", 157 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ns() {
    return Function._gw("SPELLING.CHECK", 260 + 10000, 1, 3, false, 0, 1, null, 64, 64, 32, 32);
  }
  static get _n2() {
    return Function._gw("STEP", 85 + 10000, 0, 0, false, 0, 1, null, 64);
  }
  static get _ot() {
    return Function._gw("TERMINATE", 179 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _ov() {
    return Function._gw("TEXT.BOX", 243 + 10000, 1, 4, false, 0, 1, null, 64, 64);
  }
  static get _pj() {
    return Function._gw("UNREGISTER", 201 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _pw() {
    return Function._gw("VOLATILE", 237 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _p2() {
    return Function._gw("WHILE", 172 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _p3() {
    return Function._gw("WINDOW.TITLE", 263 + 10000, 1, 1, false, 0, 1, null, 64, 64);
  }
  static get _p4() {
    return Function._gw("WINDOWS", 91 + 10000, 0, 2, false, 0, 1, null, 96, 64);
  }
}
Function.$t = markType(Function, 'Function', Base.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
Function._q2 = null;
Function._q4 = null;
/**
 * @hidden
 */
export class UltraCalcFunctionMinus extends UltraCalcBinaryOperatorBase {
  _ak(a, b) {
    return ExcelCalcFunction._g(a, b);
  }
  get_name() {
    return "-";
  }
  get name() {
    return this.get_name();
  }
}
UltraCalcFunctionMinus.$t = markType(UltraCalcFunctionMinus, 'UltraCalcFunctionMinus', UltraCalcBinaryOperatorBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionMultiply extends UltraCalcBinaryOperatorBase {
  _ak(a, b) {
    return ExcelCalcFunction._f(a, b);
  }
  get_name() {
    return "*";
  }
  get name() {
    return this.get_name();
  }
}
UltraCalcFunctionMultiply.$t = markType(UltraCalcFunctionMultiply, 'UltraCalcFunctionMultiply', UltraCalcBinaryOperatorBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionDivide extends UltraCalcBinaryOperatorBase {
  _ak(a, b) {
    return ExcelCalcFunction._d(a, b);
  }
  get_name() {
    return "/";
  }
  get name() {
    return this.get_name();
  }
}
UltraCalcFunctionDivide.$t = markType(UltraCalcFunctionDivide, 'UltraCalcFunctionDivide', UltraCalcBinaryOperatorBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionEqual extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let e = ExcelCalcValue.areValuesEqual(d, c);
    return new ExcelCalcValue(e);
  }
  get_name() {
    return "=";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionEqual.$t = markType(UltraCalcFunctionEqual, 'UltraCalcFunctionEqual', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionNE extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let e = ExcelCalcValue.areValuesEqual(d, c);
    return new ExcelCalcValue(!e);
  }
  get_name() {
    return "<>";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionNE.$t = markType(UltraCalcFunctionNE, 'UltraCalcFunctionNE', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionGE extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    return new ExcelCalcValue(ExcelCalcValue._compareTo1(d, c) >= 0);
  }
  get_name() {
    return ">=";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionGE.$t = markType(UltraCalcFunctionGE, 'UltraCalcFunctionGE', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionGT extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    return new ExcelCalcValue(ExcelCalcValue._compareTo1(d, c) > 0);
  }
  get_name() {
    return ">";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__k() {
    return 64;
  }
  get__r() {
    return true;
  }
}
UltraCalcFunctionGT.$t = markType(UltraCalcFunctionGT, 'UltraCalcFunctionGT', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionLE extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    return new ExcelCalcValue(ExcelCalcValue._compareTo1(d, c) <= 0);
  }
  get_name() {
    return "<=";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionLE.$t = markType(UltraCalcFunctionLE, 'UltraCalcFunctionLE', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionLT extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    return new ExcelCalcValue(ExcelCalcValue._compareTo1(d, c) < 0);
  }
  get_name() {
    return "<";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionLT.$t = markType(UltraCalcFunctionLT, 'UltraCalcFunctionLT', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionConcat extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let e = c.toString();
    let f = d.toString();
    return new ExcelCalcValue(f + e);
  }
  get_name() {
    return "&";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionConcat.$t = markType(UltraCalcFunctionConcat, 'UltraCalcFunctionConcat', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionExpon extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let e, f;
    if (!((() => { let g = c._toDouble1(f); f = g.p0; return g.ret; })()) || !((() => { let g = d._toDouble1(e); e = g.p0; return g.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(Math.pow(e, f));
  }
  get_name() {
    return "^";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionExpon.$t = markType(UltraCalcFunctionExpon, 'UltraCalcFunctionExpon', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionPercent extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let d;
    if (!((() => { let e = c._toDouble1(d); d = e.p0; return e.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(d / 100);
  }
  get_name() {
    return "%";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 1;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 1;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionPercent.$t = markType(UltraCalcFunctionPercent, 'UltraCalcFunctionPercent', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionUnaryMinus extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    if (c.isError) {
      return new ExcelCalcValue(c.toErrorValue());
    }
    let d;
    if (!((() => { let e = c._toDouble1(d); d = e.p0; return e.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(d * -1);
  }
  get_name() {
    return "-()";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 1;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 1;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionUnaryMinus.$t = markType(UltraCalcFunctionUnaryMinus, 'UltraCalcFunctionUnaryMinus', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionUnaryPlus extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = null;
    if (true) {
      let d = a.pop();
      if (d.isReference) {
        d = new ExcelCalcValue(d._getResolvedValue());
      }
      return d;
    }
    let e = a.pop();
    if (e.isError) {
      return new ExcelCalcValue(e.toErrorValue());
    }
    let f;
    if (!((() => { let g = e._toDouble1(f); f = g.p0; return g.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(4));
    }
    return new ExcelCalcValue(f);
  }
  get_name() {
    return "+()";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 1;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 1;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  doesParameterAllowIntermediateResultArray(a, b) {
    return true;
  }
  _j(a) {
    if (a == 0) {
      return 64;
    }
    return super._j(a);
  }
  get__r() {
    return true;
  }
  get__k() {
    return 64;
  }
}
UltraCalcFunctionUnaryPlus.$t = markType(UltraCalcFunctionUnaryPlus, 'UltraCalcFunctionUnaryPlus', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionXLIntersect extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    if (c.isError) {
      return c;
    }
    let d = a.pop();
    if (d.isError) {
      return d;
    }
    if (c.isReference == false || d.isReference == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let e = RegionGroupCalcReference._a7(c.toReference());
    let f = RegionGroupCalcReference._a7(d.toReference());
    if (e == null || f == null || e._u == null || e._u != f._u) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let g = RegionGroupCalcReference._a3(e, f);
    if (g == null) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(6));
    }
    return new ExcelCalcValue(g);
  }
  get_name() {
    return "xlintersect";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 32;
    }
    return super._j(a);
  }
  get__k() {
    return 32;
  }
  _v(a) {
    return false;
  }
}
UltraCalcFunctionXLIntersect.$t = markType(UltraCalcFunctionXLIntersect, 'UltraCalcFunctionXLIntersect', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionXLRange extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    if (c.isError) {
      return c;
    }
    let d = a.pop();
    if (d.isError) {
      return d;
    }
    if (c.isReference == false || d.isReference == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let e = RegionGroupCalcReference._a7(c.toReference());
    let f = RegionGroupCalcReference._a7(d.toReference());
    if (e == null || f == null || e._u == null || e._u != f._u) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(RegionGroupCalcReference._a4(e, f));
  }
  get_name() {
    return "xlrange";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 32;
    }
    return super._j(a);
  }
  get__k() {
    return 32;
  }
  _v(a) {
    return false;
  }
}
UltraCalcFunctionXLRange.$t = markType(UltraCalcFunctionXLRange, 'UltraCalcFunctionXLRange', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class UltraCalcFunctionXLUnion extends BuiltInFunctionBase {
  evaluate(a, b) {
    let c = a.pop();
    if (c.isError) {
      return c;
    }
    let d = a.pop();
    if (d.isError) {
      return d;
    }
    if (c.isReference == false || d.isReference == false) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let e = RegionGroupCalcReference._a7(c.toReference());
    let f = RegionGroupCalcReference._a7(d.toReference());
    if (e == null || f == null || e._u == null || e._u != f._u) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return new ExcelCalcValue(RegionGroupCalcReference._a6(e, f));
  }
  get_name() {
    return "xlunion";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return 2;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return 2;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  _j(a) {
    if (a == 0 || a == 1) {
      return 32;
    }
    return super._j(a);
  }
  get__k() {
    return 32;
  }
  _v(a) {
    return false;
  }
}
UltraCalcFunctionXLUnion.$t = markType(UltraCalcFunctionXLUnion, 'UltraCalcFunctionXLUnion', BuiltInFunctionBase.$);
/**
 * @hidden
 */
export class WorksheetCellFormatCollection extends GenericCachedCollectionEx$1 {
  constructor(a, b) {
    super(WorksheetCellFormatData.$, a, b, b._fv);
  }
  _q(a) {
    let b;
    let c = ((() => { let d = this._b.f(a, b); b = d.p1; return d.ret; })());
  }
  get workbook() {
    return this._d;
  }
}
WorksheetCellFormatCollection.$t = markType(WorksheetCellFormatCollection, 'WorksheetCellFormatCollection', GenericCachedCollectionEx$1.$.specialize(WorksheetCellFormatData.$));
/**
 * @hidden
 */
export class ValueFormatter_ValueFormatterContext extends Base {
  constructor() {
    super(...arguments);
    this.i = 0;
    this.l = null;
    this.a = null;
    this.b = 0;
    this.f = false;
    this.g = false;
    this.c = 0;
    this.o = new StringBuilder(0);
    this.p = new StringBuilder(0);
    this.k = Nullable$1.toNullable(Boolean_$type, null);
    this.n = null;
    this.h = 0;
    this.m = null;
    this.e = false;
    this.d = false;
  }
  s() {
    if (typeCast(Boolean_$type, this.l) !== null && this.a != null) {
      let a = this.a.e(this.n);
      if (this.i < a) {
        this.f = true;
        this.k = Nullable$1.toNullable(Boolean_$type, false);
        return;
      }
    }
  }
  ab() {
    if (typeCast(Boolean_$type, this.l) !== null && this.l == false) {
      this.i--;
    }
    this.f = false;
    this.b = 3;
  }
  z() {
    this.f = true;
    this.b = 2;
  }
  v() {
    this.f = false;
  }
  x(a) {
    this.g = false;
    this.b = a.g;
    this.c = a.j;
  }
  ac(a) {
    if (this.b == 2 && this.a != null && this.a.c == false) {
      a = stringReplace(a, ' ', '0');
    }
    return {
      p0: a
    };
  }
  ae() {
    this.i = 0;
    this.l = null;
    this.a = null;
    this.b = 0;
    this.f = false;
    this.g = false;
    this.c = 0;
  }
  ah(a, b, c) {
    if (this.a != null) {
      let d = this.a.e(this.p.toString());
      if (d <= this.i) {
        let e = a.cm(this, c, b, d);
        d = e.p3;
      }
      else if (typeCast(Boolean_$type, this.l) !== null || c >= 0) {
        this.f = true;
        this.t();
      }
    }
  }
  q(a, b = null) {
    this.o.l(a);
    if (b != null) {
      a = b;
    }
    else {
      let c = this.ac(a);
      a = c.p0;
    }
    this.p.l(a);
  }
  t() {
    this.o.v();
    this.p.v();
  }
  aa() {
    this.ab();
  }
  r() {
    this.s();
  }
  y() {
    this.z();
  }
  u() {
    this.v();
  }
  ag(a, b, c) {
    this.ah(a, b, c);
  }
  w(a) {
    this.x(a);
  }
  ad() {
    this.o.v();
    this.p.v();
    this.k = Nullable$1.toNullable(Boolean_$type, null);
    this.n = null;
    this.h = NaN;
    this.ae();
  }
  af(a) {
    this.t();
    this.o.l(a);
    let b = this.ac(a);
    a = b.p0;
    this.p.l(a);
  }
  get j() {
    return this.o.c;
  }
}
ValueFormatter_ValueFormatterContext.$t = markType(ValueFormatter_ValueFormatterContext, 'ValueFormatter_ValueFormatterContext');
/**
 * @hidden
 */
export class ValueFormatter extends Base {
  constructor(a, ..._rest) {
    super();
    this.i = null;
    this.a = null;
    this.y = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = [d, e, c._editingCulture$i];
          {
            let h = f[0];
            let i = f[1];
            let j = f[2];
            this.y = j;
            this.a = this.b(h, i);
          }
          this.i = c;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.y = e;
          this.a = this.b(c, d);
        }
        break;
    }
  }
  h(a, b, c, d, e, f, g, h = false) {
    let i = null;
    if (f != null) {
      i = new ValueFormatter_GetTextWidthHelper(e, f);
    }
    let j = new GetCellTextResult(0);
    j.e = a;
    let k;
    let l = null;
    if (typeCast(ErrorValue.$, c) !== null) {
      j.f = null;
      j.a = 3;
      l = b;
      if (i == null) {
        j.g = l;
        return j;
      }
      let m = i.e(l);
      if (m <= d) {
        j.g = l;
        return j;
      }
      k = true;
    }
    else {
      let n = ValueFormatter.g();
      n.h = a;
      n.n = b;
      n.l = c;
      n.a = i;
      n.i = d;
      n.e = g;
      n.d = h;
      let o = this.ai(n);
      n = o.p0;
      l = n.o.toString();
      k = n.f;
      j.a = n.b;
      j.b = n.c;
      j.f = n.m;
      let p = n.k;
      if (h && nullableEquals(p, true)) {
        l = n.p.toString();
      }
      ValueFormatter.d.f(n);
      if (nullableEquals(p, true)) {
        j.g = l;
        return j;
      }
    }
    j.a = 3;
    if (k && i != null) {
      j.g = ValueFormatter.af(i, d);
      return j;
    }
    j.g = b;
    return j;
  }
  static af(a, b) {
    let c = '#';
    let d = a.d(c.toString());
    let e = truncate((b / d));
    return stringCreateFromChar(c, e);
  }
  ag() {
    let a = "G";
    if (this.o) {
      let b = this.a[0];
      let c = this.a[1];
      if (b.g == 1) {
        if (b.s && !b.r) {
          let d = b.br([19, 18]);
          if (b.bf == null && d >= 0) {
            let e = b.br([25, 24]);
            if (e >= 0) {
              let f = b.br([28, 27]);
              let g = b.br([16, 12, 13, 14, 15]);
              if (g < 0 || (g > d && g > e)) {
                if (f >= 0) {
                  if (b.q) {
                    a = "D6";
                  }
                  else {
                    a = "D8";
                  }
                }
                else {
                  if (b.q) {
                    a = "D7";
                  }
                  else {
                    a = "D9";
                  }
                }
              }
            }
          }
        }
        else {
          let h = [35, 49, 34, 48, 33, 32];
          let i = b.br(h);
          let j = b.br([40, 39, 38, 37, 36]);
          let k = b.br([31, 30, 42, 41]);
          if (j >= 0) {
            if (b.bf != null) {
              if (i < 0 || k < 0 || j < 0 || i > j || i > k) {
                if (k > j) {
                  if (i >= 0 && i < k) {
                    a = "D2";
                  }
                  else {
                    a = "D1";
                  }
                }
                else if (k < 0) {
                  if (i < 0 || i > j) {
                    a = "D2";
                  }
                }
              }
            }
            else if (i >= 0) {
              if (j < 0 || k < 0 || k > j || k > i) {
                if (i < j) {
                  if (k < 0 || b.br(h, j) > 0) {
                    a = "D2";
                  }
                  else {
                    a = "D1";
                  }
                }
                else {
                  if (k < 0) {
                    a = "D5";
                  }
                  else if (i > k) {
                    a = "D3";
                  }
                  else {
                    a = "D4";
                  }
                }
              }
            }
            else {
              if (k > j) {
                a = "D3";
              }
            }
          }
        }
      }
      else if (b.g == 2 && !b.aa) {
        if (b.t) {
          a = "C";
        }
        else if (b.ag) {
          a = "S";
        }
        else if (b.bx > 0) {
          a = "P";
        }
        else if (b.az) {
          a = ",";
        }
        else {
          a = "F";
        }
        a += b.bo;
      }
      if (c != null && !stringIsNullOrEmpty(c.ci())) {
        a += "-";
      }
      if (b.ad) {
        a += "()";
      }
    }
    return a;
  }
  aa(a) {
    if (this.o) {
      let b = this.a[0];
      if (b.aq(a)) {
        return 0;
      }
      let c = this.a[1];
      if (c != null) {
        if (c.aq(a)) {
          return 1;
        }
        let d = this.a[2];
        if (d != null) {
          return 2;
        }
        else if (!c.v) {
          return 1;
        }
      }
      else if (!b.v) {
        return 0;
      }
    }
    return -1;
  }
  c(a) {
    if (a < 0 || a >= this.a.length) {
      return null;
    }
    let b = this.a[a];
    if (b == null) {
      return null;
    }
    return new ValueFormatter_ValueFormatterSectionInfo(b);
  }
  f(a) {
    if (this.o == false) {
      return 0;
    }
    if (this.a.length <= a) {
      return 0;
    }
    let b = this.a[a];
    if (b == null) {
      return 0;
    }
    return b.g;
  }
  e(a) {
    if (this.o == false) {
      return 0;
    }
    let b = this.a[0];
    if (b.aq(a) == false) {
      let c = this.a[1];
      if (c != null) {
        b = c;
        if (b.aq(a) == false) {
          let d = this.a[2];
          if (d != null) {
            b = d;
          }
          else {
            if (b.v) {
              return 0;
            }
          }
        }
      }
      else if (b.v) {
        return 3;
      }
    }
    return b.g;
  }
  j() {
    if (this.o) {
      for (let a = this.a.length - 1; a >= 0; a--) {
        let b = this.a[a];
        if (b != null && b.aj) {
          return true;
        }
      }
    }
    return false;
  }
  k(a) {
    return this.f(a) == 1;
  }
  l(a) {
    if (this.o && 0 <= a && a < this.a.length) {
      let b = this.a[a];
      if (b != null && b.am) {
        return true;
      }
    }
    return false;
  }
  m(a) {
    let b = this.f(a);
    return b != 3 && b != 0;
  }
  n(a) {
    return this.f(a) == 3;
  }
  ah(a, b) {
    if (a.g) {
      a.h = MathUtilities.f(b);
      let c = this.ai(a);
      a = c.p0;
    }
    return {
      p0: a
    };
  }
  static g() {
    if (ValueFormatter.d == null) {
      ValueFormatter.d = new ObjectPool$1(ValueFormatter_ValueFormatterContext.$, () => new ValueFormatter_ValueFormatterContext());
    }
    let a = ValueFormatter.d.b();
    a.ad();
    return a;
  }
  static z(a, b, ...c) {
    let d = 1;
    while (b + d < a.length) {
      let e = a.charAt(b + d);
      if (arrayIndexOf1(String_$type, c, e) >= 0) {
        d++;
      }
      else {
        break;
      }
    }
    b += d - 1;
    return {
      ret: d,
      p1: b
    };
  }
  b(a, b) {
    let c = b.numberFormat.numberDecimalSeparator.charAt(0);
    let d = b.numberFormat.numberGroupSeparator.charAt(0);
    let e = new Array(4);
    let f = 0;
    let g = new ValueFormatter_FormatSection(this, f, b);
    e[f] = g;
    let h = false;
    let i = false;
    let j = false;
    let k = true;
    for (let l = 0; l < a.length && k; l++) {
      let m = a.charAt(l);
      try {
        if (h) {
          g.ck(m, 2);
          h = false;
          continue;
        }
        else if (i || j) {
          g.ck(m, j ? 1 : 0);
          i = false;
          j = false;
          continue;
        }
        switch (m) {
          case ';':
            if (++f == 4) {
              return null;
            }
            e[f] = g = new ValueFormatter_FormatSection(this, f, b);
            break;
          case '_':
            h = true;
            break;
          case '*':
            j = true;
            break;
          case '\\':
            i = true;
            break;
          case 'g':
          case 'G':
            if (startsWith1(a.substr(l), "general", StringUtilities.g)) {
              l += 6;
              g.co(1);
            }
            else {
              let n = ((() => { let o = ValueFormatter.z(a, l, 'g'); l = o.p1; return o.ret; })());
              switch (n) {
                case 1:
                  g.co(45);
                  break;
                case 2:
                  g.co(46);
                  break;
                default:
                case 3:
                  g.co(47);
                  break;
              }
            }
            break;
          case '@':
            g.co(2);
            break;
          case '[':
            if (((() => { let o = ValueFormatter.q(g, a, b, c, l); l = o.p4; return o.ret; })()) == false) {
              return null;
            }
            break;
          case '/':
            switch (g.g) {
              case 0:
              case 3: return null;
              case 1:
                g.ck(m);
                break;
              case 2:
                g.co(9);
                if (((() => { let o = ValueFormatter.p(g, a, c, d, l); l = o.p4; return o.ret; })()) == false) {
                  return null;
                }
                break;
              default: break;
            }
            break;
          case '\"':
            {
              let o = l + 1;
              let p = false;
              for (l = o; l < a.length; l++) {
                if (a.charAt(l) == '\"') {
                  p = true;
                  break;
                }
              }
              if (p == false) {
                return null;
              }
              g.cl(a.substr(o, l - o));
            }
            break;
          case '0':
            g.co(5);
            break;
          case '#':
            g.co(4);
            break;
          case '?':
            g.co(6);
            break;
          case '%':
            g.co(8);
            break;
          case 'b':
            {
              let q = ((() => { let r = ValueFormatter.z(a, l, 'b'); l = r.p1; return r.ret; })());
              if (q <= 2) {
                g.co(30);
              }
              else {
                g.co(31);
              }
            }
            break;
          case 'e':
            let r = ((() => { let s = ValueFormatter.z(a, l, 'e'); l = s.p1; return s.ret; })());
            if (r == 1) {
              g.co(43);
            }
            else {
              g.co(44);
            }
            break;
          case 'y':
          case 'Y':
            {
              let s = ((() => { let t = ValueFormatter.z(a, l, 'y', 'Y'); l = t.p1; return t.ret; })());
              if (s <= 2) {
                g.co(41);
              }
              else {
                g.co(42);
              }
            }
            break;
          case 'm':
          case 'M':
            {
              let t = ((() => { let u = ValueFormatter.z(a, l, 'm', 'M'); l = u.p1; return u.ret; })());
              let u = g.h();
              if (t <= 2 && u != null && ValueFormatter_WellKnownPart.h(u.d)) {
                switch (t) {
                  case 1:
                    g.co(24);
                    break;
                  case 2:
                    g.co(25);
                    break;
                }
              }
              else {
                switch (t) {
                  case 1:
                    g.co(36);
                    break;
                  case 2:
                    g.co(37);
                    break;
                  case 3:
                    g.co(38);
                    break;
                  default:
                  case 4:
                    g.co(39);
                    break;
                  case 5:
                    g.co(40);
                    break;
                }
              }
            }
            break;
          case 'd':
          case 'D':
            {
              let v = ((() => { let w = ValueFormatter.z(a, l, 'd', 'D'); l = w.p1; return w.ret; })());
              switch (v) {
                case 1:
                  g.co(32);
                  break;
                case 2:
                  g.co(33);
                  break;
                case 3:
                  g.co(34);
                  break;
                default:
                case 4:
                  g.co(35);
                  break;
              }
            }
            break;
          case 'h':
          case 'H':
            {
              let w = ((() => { let x = ValueFormatter.z(a, l, 'h', 'H'); l = x.p1; return x.ret; })());
              switch (w) {
                case 1:
                  g.co(18);
                  break;
                default:
                case 2:
                  g.co(19);
                  break;
              }
            }
            break;
          case 's':
          case 'S':
            {
              let x = ((() => { let y = ValueFormatter.z(a, l, 's', 'S'); l = y.p1; return y.ret; })());
              let y = g.h();
              if (y != null) {
                y.o();
              }
              switch (x) {
                case 1:
                  g.co(27);
                  break;
                default:
                case 2:
                  g.co(28);
                  break;
              }
            }
            break;
          case 'a':
          case 'A':
            {
              if (a.length - l >= 3) {
                let z = a.substr(l, 3);
                if (stringEquals1(z, "a/p", StringUtilities.g)) {
                  l += 2;
                  let aa = z.charAt(0) == 'a';
                  let ab = z.charAt(2) == 'p';
                  let ac;
                  if (aa) {
                    ac = ab ? 12 : 13;
                  }
                  else {
                    ac = ab ? 14 : 15;
                  }
                  g.co(ac);
                  break;
                }
              }
              if (a.length - l >= 5) {
                let ad = a.substr(l, 5);
                if (stringEquals1(ad, "am/pm", StringUtilities.g)) {
                  l += 4;
                  g.co(16);
                  break;
                }
              }
              let ae = ((() => { let af = ValueFormatter.z(a, l, 'a', 'A'); l = af.p1; return af.ret; })());
              if (ae == 3) {
                g.co(48);
              }
              else if (ae == 4) {
                g.co(49);
              }
              else if (ae > 1) {
                g.cl(a.substr(l - (ae - 1), ae));
              }
              else {
                g.ck(m);
              }
            }
            break;
          case '':
            {
              if (a.length - l >= 5) {
                let af = a.substr(l, 5);
                if (stringEquals1(af, "/", StringUtilities.g)) {
                  l += 4;
                  g.co(17);
                  break;
                }
              }
              g.ck(m);
            }
            break;
          case 'E':
            if (++l < a.length) {
              let ag = a.charAt(l);
              switch (ag) {
                case '-':
                  g.co(10);
                  break;
                case '+':
                  g.co(11);
                  break;
                default: return null;
              }
            }
            else {
              return null;
            }
            break;
          case 'B':
          case 'N':
          case 'n': return null;
          default:
            if (m == c) {
              if (((() => { let ah = this.s(a, g, l); l = ah.p2; return ah.ret; })()) == false) {
                return null;
              }
              break;
            }
            if (m == d) {
              if (((() => { let ah = this.t(a, g, d, l); l = ah.p3; return ah.ret; })()) == false) {
                return null;
              }
              break;
            }
            g.ck(m);
            break;
        }
      }
      finally {
        k = g.ap;
      }
    }
    if (k == false) {
      return null;
    }
    if (h || i || j) {
      return null;
    }
    if (e[1] != null) {
      if (e[0].aj) {
        return null;
      }
      if (e[1].aj) {
        if (e[2] != null) {
          return null;
        }
        if (e[0].v == false) {
          e[0].at(0, 0, false);
        }
      }
      else if (e[2] == null) {
        if (e[0].v == false) {
          e[0].at(6, 0, false);
        }
      }
      if (e[2] != null && e[2].aj) {
        if (e[3] != null) {
          return null;
        }
        if (e[1].v == false) {
          e[1].at(0, 0, false);
        }
      }
      let ah = e[3];
      if (ah != null && ah.g != 3 && ah.g != 0) {
        return null;
      }
    }
    return e;
  }
  static p(a, b, c, d, e) {
    let f = stringEmpty();
    let g = false;
    let h = false;
    let i = false;
    let j = false;
    let k = false;
    let l = false;
    let m = false;
    let n = false;
    for (e++; e < b.length; e++) {
      let o = b.charAt(e);
      if (l) {
        if (h) {
          i = true;
        }
        j = true;
        a.ck(o, 2);
        l = false;
        continue;
      }
      else if (m || n) {
        if (h) {
          i = true;
        }
        j = true;
        a.ck(o, n ? 1 : 0);
        m = false;
        n = false;
        continue;
      }
      else if (k && o != '\"') {
        a.ck(o);
        continue;
      }
      if (o == ';') {
        e--;
        break;
      }
      switch (o) {
        case '\"':
          k = !k;
          if (h) {
            i = true;
          }
          break;
        case '_':
          l = true;
          break;
        case '*':
          n = true;
          break;
        case '\\':
          m = true;
          break;
        case '#':
          if (i) {
            a.cl((0).toString());
          }
          else {
            a.co(4);
            h = true;
            f += o;
          }
          break;
        case '?':
          if (i) {
            a.ck(' ');
          }
          else {
            a.co(6);
            h = true;
            f += o;
          }
          break;
        case '0':
          if (i) {
            a.ck(o);
          }
          else {
            a.co(5);
            h = true;
            f += o;
          }
          break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          if (i) {
            a.ck(o);
          }
          else {
            a.co(5);
            h = true;
            f += o;
            g = true;
          }
          break;
        case '@':
        case '/':
        case 'b':
        case 'B':
        case 'd':
        case 'D':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'n':
        case 'N':
        case 's':
        case 'S':
        case 'y':
        case 'Y': return {
          ret: false,
          p4: e
        };
        default:
          if (o == c) {
            if (j == false || i == false) {
              return {
                ret: false,
                p4: e
              };
            }
          }
          else if (o == d) {
            let p = a.e;
            let q = typeCast(ValueFormatter_WellKnownPart.$, p);
            if (q != null && ValueFormatter_WellKnownPart.g(q.d)) {
              return {
                ret: false,
                p4: e
              };
            }
            let r = typeCast(ValueFormatter_LiteralFormatPart.$, p);
            if (r != null && r.g == c.toString()) {
              return {
                ret: false,
                p4: e
              };
            }
          }
          if (h) {
            i = true;
          }
          j = true;
          a.ck(o);
          break;
      }
    }
    if (k) {
      return {
        ret: false,
        p4: e
      };
    }
    if (l || m || n) {
      return {
        ret: false,
        p4: e
      };
    }
    if (f.length == 0) {
      return {
        ret: false,
        p4: e
      };
    }
    let s;
    if (((() => { let t = tryParseInt32_1(f, s); s = t.p1; return t.ret; })()) == false && g) {
      return {
        ret: false,
        p4: e
      };
    }
    if (s == 0) {
      a.b2 = Nullable$1.toNullable(Number_$type, f.length);
    }
    else {
      a.b4 = Nullable$1.toNullable(Number_$type, s);
    }
    return {
      ret: true,
      p4: e
    };
  }
  static q(a, b, c, d, e) {
    e++;
    let f = e;
    let g = b.substr(f);
    let h = b.charAt(f);
    switch (h) {
      case 'h':
      case 'H':
        {
          let i = ((() => { let j = ValueFormatter.z(b, e, 'h', 'H'); e = j.p1; return j.ret; })());
          let j = ((() => { let k = ValueFormatter.z(b, e, ' '); e = k.p1; return k.ret; })());
          if (b.length <= ++e || b.charAt(e) != ']') {
            return {
              ret: false,
              p4: e
            };
          }
          a.cp(20, i);
          return {
            ret: true,
            p4: e
          };
        }
      case 's':
      case 'S':
        {
          let k = ((() => { let l = ValueFormatter.z(b, e, 's', 'S'); e = l.p1; return l.ret; })());
          let l = ((() => { let m = ValueFormatter.z(b, e, ' '); e = m.p1; return m.ret; })());
          if (b.length <= ++e || b.charAt(e) != ']') {
            return {
              ret: false,
              p4: e
            };
          }
          a.cp(29, k);
          return {
            ret: true,
            p4: e
          };
        }
      case 'm':
      case 'M':
        {
          let m = ((() => { let n = ValueFormatter.z(b, e, 'm', 'M'); e = n.p1; return n.ret; })());
          let n = ((() => { let o = ValueFormatter.z(b, e, ' '); e = o.p1; return o.ret; })());
          if (b.length <= ++e) {
            return {
              ret: false,
              p4: e
            };
          }
          let o = b.charAt(e);
          switch (b.charAt(e)) {
            case ']':
              a.cp(26, m);
              return {
                ret: true,
                p4: e
              };
            case 'a':
            case 'A': return {
              ret: ((() => { let p = ValueFormatter.u(a, b, f, g, e, "magenta"); e = p.p4; return p.ret; })()),
              p4: e
            };
          }
          return {
            ret: false,
            p4: e
          };
        }
      case 'c':
      case 'C':
        if (startsWith1(g, "color", StringUtilities.g)) {
          e = f + 5;
          let p;
          if (((() => { let q = ValueFormatter.r(b, true, c, d, e, p); e = q.p4; p = q.p5; return q.ret; })()) == false) {
            return {
              ret: false,
              p4: e
            };
          }
          if (p < 1 || 56 < p) {
            return {
              ret: false,
              p4: e
            };
          }
          if (a.ar(p.toString()) == false) {
            return {
              ret: false,
              p4: e
            };
          }
          return {
            ret: true,
            p4: e
          };
        }
        return {
          ret: ((() => { let q = ValueFormatter.u(a, b, f, g, e, "cyan"); e = q.p4; return q.ret; })()),
          p4: e
        };
      case '$':
        {
          let q = false;
          for (e++; e < b.length; e++) {
            let r = b.charAt(e);
            if (r == '-') {
              q = true;
              break;
            }
            if (r == ']') {
              return {
                ret: true,
                p4: e
              };
            }
            a.ck(r);
          }
          if (q == false) {
            return {
              ret: false,
              p4: e
            };
          }
          let s = stringEmpty();
          for (e++; e < b.length; e++) {
            let t = b.charAt(e);
            if (t == ' ') {
              if (s.length == 0) {
                let u = ValueFormatter.z(b, e, ' ');
                e = u.p1;
                continue;
              }
              break;
            }
            if ('0'.charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= '9'.charCodeAt(0) || 'a'.charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= 'f'.charCodeAt(0) || 'A'.charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= 'F'.charCodeAt(0)) {
              s += t;
            }
            else {
              break;
            }
          }
          if (e < b.length && b.charAt(e) == ']') {
            let v;
            if (((() => { let w = tryParseInt32_2(s, 515, a.bd, v); v = w.p3; return w.ret; })()) == false) {
              return {
                ret: true,
                p4: e
              };
            }
            if (a.av(v) == false) {
              return {
                ret: false,
                p4: e
              };
            }
            if (a.al) {
              for (e++; e < b.length; e++) {
                if (b.charAt(e) == ';') {
                  e--;
                  break;
                }
              }
            }
            return {
              ret: true,
              p4: e
            };
          }
          for (; e < b.length; e++) {
            if (b.charAt(e) == ']') {
              return {
                ret: true,
                p4: e
              };
            }
          }
          return {
            ret: false,
            p4: e
          };
        }
      case '=':
      case '<':
      case '>':
        {
          if (g.length < 2) {
            return {
              ret: false,
              p4: e
            };
          }
          let w;
          let x = g.substr(0, 2);
          switch (x) {
            case "<>":
              e += 2;
              w = 2;
              break;
            case "<=":
              e += 2;
              w = 4;
              break;
            case ">=":
              e += 2;
              w = 6;
              break;
            default:
              {
                switch (h) {
                  case '=':
                    w = 1;
                    break;
                  case '<':
                    w = 3;
                    break;
                  case '>':
                    w = 5;
                    break;
                  default: return {
                    ret: false,
                    p4: e
                  };
                }
                e++;
              }
              break;
          }
          let y;
          let z = ValueFormatter.r(b, false, c, d, e, y);
          e = z.p4;
          y = z.p5;
          if (a.as(w, y) == false) {
            return {
              ret: false,
              p4: e
            };
          }
          for (; e < b.length; e++) {
            if (b.charAt(e) == ']') {
              return {
                ret: true,
                p4: e
              };
            }
          }
          return {
            ret: false,
            p4: e
          };
        }
      default:
        if (startsWith1(g, "DBNum", StringUtilities.g) && g.length >= 7) {
          let aa = g.charAt(5);
          if ('1'.charCodeAt(0) <= aa.charCodeAt(0) && aa.charCodeAt(0) <= '4'.charCodeAt(0)) {
            for (e = e + 6; e < b.length; e++) {
              if (b.charAt(e) == ']') {
                a.au(aa.charCodeAt(0) - '0'.charCodeAt(0));
                return {
                  ret: true,
                  p4: e
                };
              }
            }
          }
        }
        return {
          ret: ((() => { let ab = ValueFormatter.u(a, b, f, g, e, "blue", "black", "green", "red", "white", "yellow"); e = ab.p4; return ab.ret; })()),
          p4: e
        };
    }
  }
  static r(a, b, c, d, e, f) {
    f = 0;
    if (b) {
      if (e == a.length) {
        return {
          ret: false,
          p4: e,
          p5: f
        };
      }
      if (a.charAt(e) == ' ') {
        let g = ValueFormatter.z(a, e, ' ');
        e = g.p1;
        e++;
      }
    }
    let h = stringEmpty();
    for (; e < a.length; e++) {
      let i = a.charAt(e);
      if (i == ']') {
        break;
      }
      if (i == '-' || i == '+') {
        if (b) {
          return {
            ret: false,
            p4: e,
            p5: f
          };
        }
        if (h.length != 0) {
          return {
            ret: false,
            p4: e,
            p5: f
          };
        }
        h += i;
        continue;
      }
      if ('0'.charCodeAt(0) <= i.charCodeAt(0) && i.charCodeAt(0) <= '9'.charCodeAt(0)) {
        h += i;
        continue;
      }
      if (i == d) {
        h += i;
        continue;
      }
      break;
    }
    if (h.length == 0) {
      return {
        ret: false,
        p4: e,
        p5: f
      };
    }
    if (((() => { let j = MathUtilities.c(h, c, f); f = j.p2; return j.ret; })()) == false) {
      return {
        ret: false,
        p4: e,
        p5: f
      };
    }
    for (; e < a.length; e++) {
      if (a.charAt(e) == ']') {
        return {
          ret: true,
          p4: e,
          p5: f
        };
      }
    }
    return {
      ret: false,
      p4: e,
      p5: f
    };
  }
  s(a, b, c) {
    if (b.g == 3) {
      return {
        ret: false,
        p2: c
      };
    }
    if (b.g == 0) {
      b.cw(2);
    }
    else if (b.g == 1) {
      if (c < a.length - 1 && a.charAt(c + 1) == '0') {
        c++;
        let d = ((() => { let e = ValueFormatter.z(a, c, '0'); c = e.p1; return e.ret; })());
        switch (d) {
          case 1:
            b.co(21);
            return {
              ret: true,
              p2: c
            };
          case 2:
            b.co(22);
            return {
              ret: true,
              p2: c
            };
          case 3:
            b.co(23);
            return {
              ret: true,
              p2: c
            };
          default: return {
            ret: false,
            p2: c
          };
        }
      }
      else {
        b.ck(a.charAt(c));
      }
      return {
        ret: true,
        p2: c
      };
    }
    b.co(3);
    return {
      ret: true,
      p2: c
    };
  }
  t(a, b, c, d) {
    let e = ((() => { let f = ValueFormatter.z(a, d, c); d = f.p1; return f.ret; })());
    let f = typeCast(ValueFormatter_WellKnownPart.$, b.e);
    if (f != null && ValueFormatter_WellKnownPart.g(f.d)) {
      let g = String.fromCharCode(0);
      if (d < a.length - 1) {
        g = a.charAt(d + 1);
      }
      switch (g) {
        case '0':
        case '#':
        case '?':
          if (b.ag) {
            return {
              ret: false,
              p3: d
            };
          }
          if (b.y == false) {
            b.cx();
          }
          break;
        default:
          if (b.ag == false) {
            b.cp(7, e);
          }
          break;
      }
    }
    else {
      b.ck(a.charAt(d));
    }
    return {
      ret: true,
      p3: d
    };
  }
  static w(a, b = 0) {
    return MathUtilities.g(a, b);
  }
  static u(a, b, c, d, e, ...f) {
    for (let h = 0; h < f.length; h++) {
      let g = f[h];
      if (startsWith1(d, g, StringUtilities.g) == false) {
        continue;
      }
      if (a.ar(g) == false) {
        return {
          ret: false,
          p4: e
        };
      }
      for (e = c + g.length; e < b.length; e++) {
        if (b.charAt(e) == ']') {
          return {
            ret: true,
            p4: e
          };
        }
      }
    }
    return {
      ret: false,
      p4: e
    };
  }
  v(a, b, c) {
    let d = ValueFormatter.g();
    d.h = a;
    d.n = b;
    let e = this.ai(d);
    d = e.p0;
    c = d.o.toString();
    let f = d.k;
    ValueFormatter.d.f(d);
    return {
      ret: f.value,
      p2: c
    };
  }
  ai(a) {
    a.aa();
    if (this.o == false) {
      a.k = Nullable$1.toNullable(Boolean_$type, false);
      return {
        p0: a
      };
    }
    if (isNaN_(a.h)) {
      for (let b = this.a.length - 1; b >= 0; b--) {
        let c = this.a[b];
        if (c == null) {
          continue;
        }
        if (c.g == 1 || c.g == 2) {
          a.r();
          if (nullableNotEquals(a.k, null)) {
            return {
              p0: a
            };
          }
          a.af(a.n);
          a.k = Nullable$1.toNullable(Boolean_$type, true);
          return {
            p0: a
          };
        }
        let d = c.cr(a);
        a = d.p0;
        a.k = Nullable$1.toNullable(Boolean_$type, a.j != 0);
        a.m = c.ci();
        return {
          p0: a
        };
      }
      a.k = Nullable$1.toNullable(Boolean_$type, false);
      return {
        p0: a
      };
    }
    a.y();
    let e = MathUtilities.i(a.h);
    let f = this.a[0];
    if (f.aq(e) == false) {
      let g = this.a[1];
      if (g != null) {
        f = g;
        if (f.aq(e) == false) {
          let h = this.a[2];
          if (h != null) {
            f = h;
          }
          else {
            if (f.v) {
              a.k = Nullable$1.toNullable(Boolean_$type, false);
              return {
                p0: a
              };
            }
          }
        }
      }
      else if (f.v) {
        a.af(numberToString(e, this.i != null ? this.i._e6 : ExcelUtils.cq));
        a.k = Nullable$1.toNullable(Boolean_$type, true);
        return {
          p0: a
        };
      }
    }
    let i;
    let j = f.cs(a, i);
    a = j.p0;
    i = j.p1;
    a.m = f.ci();
    if (a.j == 0) {
      let k = this.ah(a, e);
      a = k.p0;
    }
    if (a.j > 0 && a.d) {
      if (f.am) {
        a.p.z('.', '0');
      }
    }
    if (a.j != 0 || nullableNotEquals(a.k, true)) {
      a.k = Nullable$1.toNullable(Boolean_$type, a.j != 0);
    }
    if (a.j == 0 && a.h == 0) {
      if (f.g == 2 && (this.a.length < 2 || f != this.a[2])) {
        a.k = Nullable$1.toNullable(Boolean_$type, true);
      }
      else if (this.a.length >= 2 && f == this.a[2] && f.e == null) {
        a.k = Nullable$1.toNullable(Boolean_$type, true);
      }
    }
    return {
      p0: a
    };
  }
  get o() {
    return this.a != null;
  }
}
ValueFormatter.$t = markType(ValueFormatter, 'ValueFormatter');
ValueFormatter.d = null;
ValueFormatter.x = new CultureInfo("en-US");
/**
 * @hidden
 */
export class ValueFormatter_FormatSection extends Base {
  constructor(a, b, c) {
    super();
    this.bh = -1;
    this.bi = -1;
    this.bj = -1;
    this.bk = -1;
    this.bl = -1;
    this.a7 = null;
    this.a8 = null;
    this.b7 = null;
    this.a4 = 0;
    this.d = 0;
    this.bc = null;
    this.ak = false;
    this.bn = 0;
    this.a0 = false;
    this.be = null;
    this.k = false;
    this.l = false;
    this.b = null;
    this.b3 = Nullable$1.toNullable(Number_$type, null);
    this.b1 = Nullable$1.toNullable(Number_$type, null);
    this.b5 = Nullable$1.toNullable(Number_$type, null);
    this.m = false;
    this.n = true;
    this.bs = 0;
    this.p = false;
    this.u = false;
    this.x = false;
    this.z = false;
    this.ab = false;
    this.ah = false;
    this.w = false;
    this.b6 = Nullable$1.toNullable(Boolean_$type, null);
    this.af = false;
    this.ai = false;
    this.ao = true;
    this.a2 = new List$1(ValueFormatter_Part.$, 0);
    this.bw = 0;
    this.bz = 0;
    this.f = 0;
    this.aw = false;
    this.ay = false;
    this.i = 0;
    this.bc = c;
    this.b = a;
    this.bz = b;
    switch (this.bz) {
      case 0:
        this.d = 5;
        this.a4 = 0;
        break;
      case 1:
        this.d = 3;
        this.a4 = 0;
        break;
    }
    if (this.b.y != null) {
      this.av(CalendarUtilities.a(this.b.y), true);
    }
  }
  cm(a, b, c, d) {
    if (c.charCodeAt(0) == 0 || b < 0) {
      return {
        p3: d
      };
    }
    let e = a.i - d;
    let f = a.a.d(c.toString());
    let g = truncate((e / f));
    if (g > 0) {
      let h = stringCreateFromChar(c, g);
      a.o.x(b, h);
      a.p.x(b, h);
    }
    return {
      p3: d
    };
  }
  cq(a, b, c, d) {
    if (a.a == null) {
      return {
        p1: b,
        p3: d
      };
    }
    let e = a.a.e(a.p.toString());
    let f = a.i;
    for (let g = 0; g < a.o.c; g++) {
      let h = a.o.item(g);
      if (h == '.') {
        if (this.bx != 0) {
          continue;
        }
        if (!this.am && this.f == 2 && !this.af) {
          continue;
        }
        if (b.e < 0) {
          b.e = Math.max(0, a.a.e("0") - a.a.e("."));
        }
        f -= b.e;
      }
      else if (this.ag && h == 'E' && g < a.o.c - 1) {
        if ((a.o.item(g + 1).toString() == this.bc.numberFormat.negativeSign || a.o.item(g + 1).toString() == this.bc.numberFormat.positiveSign)) {
          f -= Math.max(0, a.a.e("0") - a.a.e(a.o.item(g + 1).toString()));
        }
      }
      else {
        if (ValueFormatter_FormatSection.an(h)) {
          f--;
        }
      }
    }
    if (e <= f) {
      let i = this.cm(a, b.g, b.d, e);
      e = i.p3;
      return {
        p1: b,
        p3: d
      };
    }
    if (a.h == 0) {
      a.t();
      return {
        p1: b,
        p3: d
      };
    }
    if (b.a == false && b.b == false) {
      a.t();
      return {
        p1: b,
        p3: d
      };
    }
    if (b.b && this.bz != 0) {
      a.t();
      return {
        p1: b,
        p3: d
      };
    }
    if (this.a0) {
      a.t();
      return {
        p1: b,
        p3: d
      };
    }
    if (0 < c.r && b.f < c.r) {
      c.p = c.r - 1;
    }
    else {
      if (b.c) {
        a.t();
        return {
          p1: b,
          p3: d
        };
      }
      b.c = true;
      for (let j = 5; j >= 0; j--) {
        a.t();
        let k = new ValueFormatter_FormatSection(this.b, this.bz, this.bc);
        if (b.b) {
          k.cn(j);
        }
        else {
          for (let l of fromEnum(this.a2)) {
            let m = typeCast(ValueFormatter_WellKnownPart.$, l);
            if (m != null) {
              if (m.d == 1) {
                k.cn(j);
              }
              else {
                k.co(m.d);
              }
            }
            else {
              let n = typeCast(ValueFormatter_LiteralFormatPart.$, l);
              if (n != null) {
                k.cl(n.g, n.d);
              }
              else {
              }
            }
          }
        }
        let o;
        let p = k.cs(a, o);
        a = p.p0;
        o = p.p1;
        if (a.j != 0 && o == j) {
          return {
            p1: b,
            p3: d
          };
        }
      }
      if (b.f == 0) {
        a.t();
        return {
          p1: b,
          p3: d
        };
      }
      if (b.b || this.a2.count > 1) {
        a.g = true;
        a.t();
        return {
          p1: b,
          p3: d
        };
      }
      c.p = 0;
    }
    d = true;
    return {
      p1: b,
      p3: d
    };
  }
  static an(a) {
    return CharUnicodeInfo.b(a);
  }
  ck(a, b = 0) {
    this.cl(a.toString(), b);
  }
  cl(a, b = 0) {
    this.a2.add(new ValueFormatter_LiteralFormatPart(a, b));
  }
  cn(a) {
    this.co(5);
    if (a != 0) {
      this.co(3);
      this.co(5);
      for (let b = 1; b < a; b++) {
        this.co(4);
      }
    }
    this.co(11);
    this.co(5);
    this.co(5);
  }
  co(a) {
    this.cp(a, 1);
  }
  cp(a, b) {
    if (ValueFormatter_WellKnownPart.g(a)) {
      this.bi = -1;
      this.bj = -1;
      this.bk = -1;
      this.bh = -1;
      this.bl = -1;
    }
    if (ValueFormatter_WellKnownPart.e(a)) {
      this.i |= 1;
      this.w = true;
      this.cw(1);
    }
    else if (ValueFormatter_WellKnownPart.i(a)) {
      this.i |= 2;
      this.ah = true;
      this.cw(1);
    }
    switch (a) {
      case 16:
      case 12:
      case 13:
      case 14:
      case 15:
      case 17:
        this.p = true;
        break;
      case 3:
        this.x = true;
        break;
      case 4:
      case 5:
      case 6:
        {
          this.cw(2);
          let c = typeCast(ValueFormatter_WellKnownPart.$, this.e);
          if (c == null || (ValueFormatter_WellKnownPart.g(c.d) == false && c.d != 3)) {
            this.cv();
          }
        }
        break;
      case 9:
        {
          if (this.z || this.af) {
            this.ao = false;
            return;
          }
          this.z = true;
          let d = false;
          this.m = true;
          for (let e = this.a2.count - 1; e >= 0; e--) {
            let f = this.a2._inner[e];
            let g = typeCast(ValueFormatter_WellKnownPart.$, f);
            if (g == null) {
              d = true;
              continue;
            }
            if (this.b5.hasValue) {
              if (g.d == 3) {
                this.ao = false;
                return;
              }
              if (ValueFormatter_WellKnownPart.g(g.d)) {
                if (d) {
                  this.n = false;
                }
                else {
                  this.b5 = Nullable$1.toNullable(Number_$type, e);
                }
              }
            }
            else {
              if (g.d == 3 || ValueFormatter_WellKnownPart.g(g.d)) {
                this.b5 = Nullable$1.toNullable(Number_$type, e);
              }
            }
            if (d == false && g.d == 5) {
              this.m = false;
            }
          }
        }
        break;
      case 1:
        this.cw(3);
        break;
      case 7:
        {
          for (let h = this.a2.count - 1; h >= 0; h--) {
            let i = this.a2._inner[h];
            let j = typeCast(ValueFormatter_WellKnownPart.$, i);
            if (j == null) {
              this.cv();
              break;
            }
            if (j.d == 7) {
              break;
            }
          }
          this.bs += b;
        }
        break;
      case 21:
      case 22:
      case 23:
        this.ab = true;
        break;
      case 8:
        this.cw(2);
        this.bw++;
        break;
      case 10:
      case 11:
        this.cw(2);
        if (this.af || this.z) {
          this.ao = false;
          return;
        }
        this.af = true;
        this.cv();
        break;
      case 2:
        this.ai = true;
        this.cw(3);
        break;
      case 41:
      case 42:
        for (let k = this.a2.count - 1; k >= 0; k--) {
          let l = this.a2._inner[k];
          let m = typeCast(ValueFormatter_WellKnownPart.$, l);
          if (m == null) {
            continue;
          }
          switch (m.d) {
            case 45:
            case 46:
            case 47:
              a = 44;
              break;
            default: continue;
          }
          break;
        }
        break;
      case 31:
        if (this.be != null) {
          a = 42;
        }
        break;
      case 30:
        if (this.be != null) {
          a = 41;
        }
        break;
    }
    this.a2.add(new ValueFormatter_WellKnownPart(a, b));
  }
  b8(a) {
    let b = null;
    if (this.a0) {
      b = DBNumHelper.c(CalendarUtilities.a(this.be), this.bn);
    }
    else if (this.aw) {
      b = this.bg.numberFormat.nativeDigits;
    }
    if (b == null) {
      return a;
    }
    let c = new StringBuilder(0);
    for (let d = 0; d < a.length; d++) {
      let e = a.charAt(d);
      if ('0'.charCodeAt(0) <= e.charCodeAt(0) && e.charCodeAt(0) <= '9'.charCodeAt(0)) {
        c.l(b[e.charCodeAt(0) - '0'.charCodeAt(0)]);
      }
      else {
        c.h(e);
      }
    }
    return c.toString();
  }
  bb(a) {
    switch (a) {
      case 0: return this.bg.calendar;
      case 1:
      case 2:
      case 9:
      case 10:
      case 11:
      case 12: return new GregorianCalendar(1, a);
      case 3: return new JapaneseCalendar();
      case 4: return new TaiwanCalendar();
      case 5: return new KoreanCalendar();
      case 6: return new HijriCalendar();
      case 7: return new ThaiBuddhistCalendar();
      case 8: return new HebrewCalendar();
      case 23: return new UmAlQuraCalendar();
      default: return null;
    }
  }
  b9(a, b, c) {
    let d;
    if (a.getFullYear() == 1899 && this.ba.getYear(a) == 1899) {
      d = 0;
    }
    else if (b.l < ValueFormatter_FormatSection.a5 && b.l >= ValueFormatter_FormatSection.a6 && a < ValueFormatter_FormatSection.a3) {
      d = this.ba.getDayOfMonth(dateAddDays(a, -1)) + 1;
    }
    else {
      d = this.ba.getDayOfMonth(a);
    }
    return this.cf(d, c);
  }
  ca(a, b, c, d = false) {
    if (a < ValueFormatter_FormatSection.a3) {
      a = ExcelCalcValue._be(this.c.i, b.l, false, true).value;
    }
    let e = d && this.ak ? ValueFormatter.x : this.bg;
    return dateToStringFormat(a, c, e);
  }
  cb(a, b, c) {
    let d;
    if (a.getFullYear() == 1899 && this.ba.getYear(a) == 1899) {
      d = 1;
    }
    else if (b.l < ValueFormatter_FormatSection.a5 && b.l >= ValueFormatter_FormatSection.a6 && a < ValueFormatter_FormatSection.a3) {
      d = this.ba.getMonth(dateAddDays(a, -1));
    }
    else {
      d = this.ba.getMonth(a);
    }
    return this.cf(d, c);
  }
  cc(a, b, c, d = true) {
    let e = d && this.ak ? ValueFormatter.x : this.bg;
    if (a.getFullYear() == 1899 && this.ba.getYear(a) == 1899) {
      return dateToStringFormat(dateFromValues(1900, 1, 1, 0, 0, 0, 0), c, e);
    }
    else if (b.l < ValueFormatter_FormatSection.a5 && b.l >= ValueFormatter_FormatSection.a6 && a < ValueFormatter_FormatSection.a3) {
      a = dateAddDays(a, -1);
    }
    return dateToStringFormat(a, c, e);
  }
  cd(a, b = true, c = true) {
    if (c && this.a0) {
      let d = truncate(MathUtilities.j(Math.abs(a)));
      let e = DBNumHelper.v(CalendarUtilities.a(this.be), this.bn, d);
      if (e != null) {
        let f = a - MathUtilities.j(a);
        if (f != 0) {
          let g = MathUtilities.r(a, this.bd);
          let h = g.indexOf(this.bd.numberFormat.numberDecimalSeparator);
          if (h >= 0) {
            e += this.b8(g.substr(h));
          }
        }
        if (a < 0) {
          e = "-" + e;
        }
        return e;
      }
    }
    let i = b ? numberToString(a, this.bc) : MathUtilities.r(a, this.bc);
    if (this.aj) {
      return i;
    }
    return this.b8(i);
  }
  ce(a) {
    return this.cf(a, 1);
  }
  cf(a, b, c = true) {
    if (this.a0 && c) {
      return DBNumHelper.v(CalendarUtilities.a(this.be), this.bn, intSToU(Math.abs(a)), b);
    }
    let d = this.bg.numberFormat;
    let e = ValueFormatter_FormatSection.a;
    if (this.a0) {
      e = DBNumHelper.c(CalendarUtilities.a(this.be), this.bn);
    }
    else if (this.aj == false) {
      e = d.nativeDigits;
    }
    let f = new StringBuilder(1, b);
    while (true) {
      let g;
      if (a == 0) {
        if (f.c >= b) {
          break;
        }
        g = 0;
      }
      else {
        g = a % 10;
        a = intDivide(a, 10);
      }
      f.x(0, e[g]);
    }
    return f.toString();
  }
  cg(a, b) {
    return this.ch(this.ba, a, b);
  }
  ch(a, b, c) {
    let d = a.getYear(b);
    if (b.getFullYear() == 1899 && d == 1899) {
      d = 1900;
    }
    if (c == 2) {
      d %= 100;
    }
    return this.cf(d, c, false);
  }
  cr(a) {
    a.u();
    let b = -1;
    let c = String.fromCharCode(0);
    if (this.aj == false && this.bz != 3) {
      a.af(a.n);
    }
    else {
      for (let d of fromEnum(this.a2)) {
        let e = typeCast(ValueFormatter_WellKnownPart.$, d);
        if (e != null && e.d == 1) {
          a.af(a.n);
          break;
        }
        let f = d.b(this, a.n);
        let g = typeCast(ValueFormatter_LiteralFormatPart.$, d);
        if (g != null && g.d == 1) {
          b = a.j;
          c = g.g.charAt(0);
        }
        if (f == null) {
          a.k = Nullable$1.toNullable(Boolean_$type, false);
          return {
            p0: a
          };
        }
        if (g != null && g.d == 2) {
          a.q(f, g.g);
        }
        else {
          a.q(f);
        }
      }
    }
    a.ag(this, c, b);
    return {
      p0: a
    };
  }
  cs(a, b) {
    b = 0;
    a.w(this);
    if (this.g == 2 && this.ag == false && this.aa == false && this.y == false && this.bx == 0) {
      a.h = MathUtilities.f(a.h);
    }
    if (a.h < 0) {
      let c = false;
      switch (this.bz) {
        case 0:
          c = (this.u == false || this.a4 != 0);
          break;
        case 1:
          if (this.b.a[2] == null) {
            if (this.aj) {
              c = true;
            }
            else if (this.v == false) {
              let d = this.b.a[0];
              if (d.v && d.a4 != 0) {
                c = true;
              }
            }
          }
          break;
        case 2:
          c = true;
          break;
        default: break;
      }
      if (c) {
        a.q(this.bc.numberFormat.negativeSign);
      }
    }
    let e = new ValueFormatter_FormatValueState(this, a.h, a.e);
    let f = a.o.toString();
    let g = a.p.toString();
    let h = new ValueFormatter_FormatSection_FormulaValueInfo();
    h.f = Math.max(0, -MathUtilities.m(Math.abs(a.h)));
    h.e = -1;
    h.a = false;
    h.b = false;
    h.c = false;
    let i = 0;
    while (true) {
      h.g = -1;
      h.d = String.fromCharCode(0);
      if (this.g == 3 && this.aj) {
        h.b = true;
        a.q(this.cj(e));
        i++;
      }
      else {
        if (this.k) {
          if (e.ab.hasValue == false) {
            a.t();
            return {
              p0: a,
              p1: b
            };
          }
          a.q(toLongDateString(e.ab.value));
          i++;
        }
        else if (this.l) {
          if (e.ab.hasValue == false) {
            a.t();
            return {
              p0: a,
              p1: b
            };
          }
          a.q(toLongTimeString(e.ab.value));
          i++;
        }
        else {
          for (let j of fromEnum(this.a2)) {
            let k = j.a(this, e);
            let l = null;
            let m = typeCast(ValueFormatter_LiteralFormatPart.$, j);
            if (m != null && m.d == 1) {
              h.g = a.j;
              h.d = m.g.charAt(0);
            }
            else {
              l = typeCast(ValueFormatter_WellKnownPart.$, j);
              if (l != null && l.d == 1) {
                h.a = true;
              }
            }
            if (k == null) {
              a.t();
              return {
                p0: a,
                p1: b
              };
            }
            if (m != null && m.d == 2) {
              a.q(k, m.g);
            }
            else if (l != null && l.d == 6 && k == " ") {
              a.q(k, "0");
            }
            else {
              a.q(k);
            }
            i++;
          }
        }
      }
      if (a.j == 0 && i > 0) {
        a.k = Nullable$1.toNullable(Boolean_$type, true);
        return {
          p0: a,
          p1: b
        };
      }
      b = e.t;
      let n = false;
      let o = this.cq(a, h, e, n);
      h = o.p1;
      n = o.p3;
      if (n == false) {
        return {
          p0: a,
          p1: b
        };
      }
      a.o.v();
      a.o.l(f);
      a.p.v();
      a.p.l(g);
    }
    return {
      p0: a,
      p1: b
    };
  }
  get o() {
    return this.n;
  }
  ci() {
    return this.b7;
  }
  h() {
    for (let a = this.a2.count - 1; a >= 0; a--) {
      let b = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[a]);
      if (b != null && ValueFormatter_WellKnownPart.f(b.d)) {
        return b;
      }
    }
    return null;
  }
  cj(a) {
    let b = a.h;
    if (b == 0) {
      return this.cd(b);
    }
    let c = 9;
    let d = 20;
    let e = false;
    if (a.p == -1 && !this.a0) {
      let f = a.f ? 1E-05 : 0.0001;
      if (b < f) {
        let g = a.f ? d : c;
        let h = ValueFormatter.w(b, g);
        if (h == 0) {
          e = true;
        }
        else {
          let i = this.cd(h, false);
          let j = a.f ? 21 : 11;
          if (i.length <= j) {
            a.r = g;
            return i;
          }
          else {
            e = true;
          }
        }
      }
      else {
        let k = a.f ? 1E+21 : 99999999999.5;
        if (k <= b) {
          e = true;
        }
      }
    }
    if (e) {
      let l = MathUtilities.m(Math.abs(b));
      let m = l < 0 ? 1 / Math.pow(10, -l) : Math.pow(10, l);
      let n = b / m;
      if (n < 1 && a.f) {
        n *= 10;
        l--;
      }
      let o = this.cf(Math.abs(l), 2);
      let p = a.f ? 16 : 7;
      let q = Math.max(0, p - o.length);
      let r = this.cd(round10N(n, q));
      let s = l < 0 ? this.bd.numberFormat.negativeSign : this.bd.numberFormat.positiveSign;
      return r + "E" + s + o;
    }
    else {
      let t;
      if (b < 1) {
        t = a.f ? d : c;
      }
      else {
        let u = MathUtilities.m(Math.abs(b)) + 1;
        let v = a.f ? 15 : 10;
        t = Math.max(0, v - u);
      }
      if (a.p != -1) {
        t = Math.min(a.p, t);
      }
      a.r = t;
      return this.cd(ValueFormatter.w(b, t), false);
    }
  }
  get aa() {
    return this.z;
  }
  get ac() {
    return this.ab;
  }
  ae(a) {
    return this.br(a) >= 0;
  }
  br(a, b = 0) {
    for (let c = b; c < this.a2.count; c++) {
      let d = this.a2._inner[c];
      let e = typeCast(ValueFormatter_WellKnownPart.$, d);
      if (e != null) {
        for (let f = 0; f < a.length; f++) {
          if (e.d == a[f]) {
            return c;
          }
        }
      }
    }
    return -1;
  }
  get aj() {
    return this.ai;
  }
  ct(a, b, c) {
    let d = this.cu(a, b, c, this.bc.numberFormat.numberGroupSeparator);
    a = d.p0;
    return {
      p0: a
    };
  }
  cu(a, b, c, d) {
    if (this.ay == false) {
      return {
        p0: a
      };
    }
    let e = this.bc.numberFormat.numberGroupSizes;
    let f = a.length;
    let g = (this.bv - b) + (f - 1) - 1;
    let h = 0;
    for (let i = 0; i < e.length; i++) {
      let j = e[i];
      h += j;
      if (g < h) {
        break;
      }
      if (g - (f - 1) <= h) {
        a = stringInsert(a, (g - h) + 1, d);
      }
      if (i == e.length - 1) {
        if (j == 0) {
          break;
        }
        i--;
      }
    }
    return {
      p0: a
    };
  }
  aq(a) {
    switch (this.d) {
      case 0: return true;
      case 1: return a == this.a4;
      case 2: return a != this.a4;
      case 3: return a < this.a4;
      case 4: return a <= this.a4;
      case 5: return a > this.a4;
      case 6: return a >= this.a4;
      default: return true;
    }
  }
  cv() {
    this.bs = 0;
  }
  ar(a) {
    if (this.b7 != null) {
      return false;
    }
    this.b7 = a;
    return true;
  }
  as(a, b) {
    return this.at(a, b, true);
  }
  at(a, b, c) {
    if (this.u) {
      return false;
    }
    if (this.bz >= 2) {
      return false;
    }
    this.u = c;
    this.d = a;
    this.a4 = b;
    return true;
  }
  au(a) {
    if (this.bn != 0) {
      return false;
    }
    this.bn = a;
    this.cy();
    return true;
  }
  av(a, b = false) {
    if (this.be != null) {
      if (b || !this.ak) {
        return false;
      }
    }
    this.ak = b;
    if (a == 63488) {
      this.a2.clear();
      this.k = true;
      this.cw(1);
      return true;
    }
    else if (a == 62464) {
      this.a2.clear();
      this.l = true;
      this.cw(1);
      return true;
    }
    try {
      let c = ExcelUtils.c5(a, 24, 31);
      let d = ExcelUtils.c5(a, 16, 23);
      a = ExcelUtils.c5(a, 0, 15);
      if (a == 0) {
        switch (c) {
          case 1:
          case 13:
            a = 1054;
            break;
        }
      }
      this.be = CultureInfo.getCultureInfo(a);
      let e = this.be.numberFormat.nativeDigits;
      for (let f = 0; f < 10; f++) {
        if (f.toString() != e[f]) {
          this.aw = true;
          break;
        }
      }
      this.cy();
      if (this.be.twoLetterISOLanguageName == "ja") {
        this.a8 = this.bb(3);
      }
      this.a7 = this.bb(d) || this.a7;
    }
    catch (g) {
    }
    return true;
  }
  cw(a) {
    if (this.f == a) {
      return;
    }
    if (this.f != 0) {
      this.ao = false;
      return;
    }
    this.f = a;
    return;
  }
  ax(a) {
    return this.m && a.x == 0;
  }
  cx() {
    this.ay = true;
  }
  cy() {
    this.a0 = DBNumHelper.k(this.bn) && this.bn != 4 && DBNumHelper.l(CalendarUtilities.a(this.be));
  }
  get ba() {
    return this.a7 || this.bb(0);
  }
  get a9() {
    return this.a8 || this.ba;
  }
  get bd() {
    return this.bc;
  }
  get bf() {
    return this.be;
  }
  get bg() {
    return this.be || this.bc;
  }
  get j() {
    return this.i;
  }
  get c() {
    return this.b;
  }
  get bo() {
    if (this.x == false) {
      return 0;
    }
    if (this.bh < 0) {
      this.bh = 0;
      let a = false;
      for (let b = 0; b < this.a2.count; b++) {
        let c = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[b]);
        if (c == null) {
          continue;
        }
        if (c.d == 10 || c.d == 11) {
          break;
        }
        if (c.d == 3) {
          a = true;
        }
        else if (a && ValueFormatter_WellKnownPart.g(c.d)) {
          this.bh++;
        }
      }
    }
    return this.bh;
  }
  get b4() {
    return this.b3;
  }
  set b4(a) {
    this.b3 = a;
  }
  get b2() {
    return this.b1;
  }
  set b2(a) {
    this.b1 = a;
  }
  get bp() {
    if (this.z == false) {
      return 0;
    }
    if (this.bi < 0) {
      this.bi = 0;
      let a = false;
      for (let b = 0; b < this.a2.count; b++) {
        let c = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[b]);
        if (c == null) {
          continue;
        }
        if (c.d == 9) {
          a = true;
        }
        else if (a && ValueFormatter_WellKnownPart.g(c.d)) {
          this.bi++;
        }
      }
    }
    return this.bi;
  }
  get bq() {
    if (this.z == false || this.b5.hasValue == false) {
      return 0;
    }
    if (this.bj < 0) {
      this.bj = 0;
      for (let a = this.b5.value; a < this.a2.count; a++) {
        let b = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[a]);
        if (b == null) {
          continue;
        }
        if (b.d == 9) {
          break;
        }
        if (ValueFormatter_WellKnownPart.g(b.d)) {
          this.bj++;
        }
      }
    }
    return this.bj;
  }
  get bt() {
    return this.bs;
  }
  get q() {
    return this.p;
  }
  get r() {
    return this.w;
  }
  get s() {
    return this.ah;
  }
  get v() {
    return this.u;
  }
  get t() {
    let a = this.bc.numberFormat.currencySymbol;
    for (let b of fromEnum(this.a2)) {
      let c = typeCast(ValueFormatter_LiteralFormatPart.$, b);
      if (c != null) {
        if (stringContains(c.g, a)) {
          return true;
        }
      }
    }
    return false;
  }
  get y() {
    return this.x;
  }
  get ad() {
    let a = false;
    let b = false;
    for (let c = 0; c < this.a2.count; c++) {
      let d = typeCast(ValueFormatter_LiteralFormatPart.$, this.a2._inner[c]);
      if (d != null && d.d != 2) {
        if (d.g == "(") {
          a = true;
        }
        else if (d.g == ")") {
          b = true;
        }
      }
    }
    return a && b;
  }
  get az() {
    return this.ay;
  }
  get ag() {
    return this.af;
  }
  get al() {
    return this.k || this.l;
  }
  get am() {
    if (nullableEquals(this.b6, null)) {
      if (this.a2.count == 1) {
        let a = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[0]);
        this.b6 = Nullable$1.toNullable(Boolean_$type, a != null && a.d == 1);
      }
      else {
        this.b6 = Nullable$1.toNullable(Boolean_$type, false);
      }
    }
    return this.b6.value;
  }
  get ap() {
    return this.ao;
  }
  get e() {
    if (this.a2.count == 0) {
      return null;
    }
    return this.a2._inner[this.a2.count - 1];
  }
  get bv() {
    if (this.z && this.n) {
      return 0;
    }
    if (this.bk < 0) {
      this.bk = 0;
      for (let a = 0; a < this.a2.count; a++) {
        if (this.b5.hasValue && a == this.b5.value) {
          break;
        }
        let b = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[a]);
        if (b == null) {
          continue;
        }
        if (b.d == 3 || b.d == 10 || b.d == 11) {
          break;
        }
        if (ValueFormatter_WellKnownPart.g(b.d)) {
          this.bk++;
        }
      }
    }
    return this.bk;
  }
  get bx() {
    return this.bw;
  }
  get by() {
    if (this.af == false) {
      return 0;
    }
    if (this.bl < 0) {
      this.bl = 0;
      let a = false;
      for (let b = 0; b < this.a2.count; b++) {
        let c = typeCast(ValueFormatter_WellKnownPart.$, this.a2._inner[b]);
        if (c == null) {
          continue;
        }
        if (c.d == 10 || c.d == 11) {
          a = true;
          continue;
        }
        if (a == false) {
          continue;
        }
        if (c.d == 3) {
          break;
        }
        if (ValueFormatter_WellKnownPart.g(c.d)) {
          this.bl++;
        }
      }
    }
    return this.bl;
  }
  get g() {
    return this.f;
  }
  get a1() {
    return this.a0;
  }
}
ValueFormatter_FormatSection.$t = markType(ValueFormatter_FormatSection, 'ValueFormatter_FormatSection');
ValueFormatter_FormatSection.a3 = dateFromValues(1900, 3, 2, 0, 0, 0, 0);
ValueFormatter_FormatSection.a6 = 60;
ValueFormatter_FormatSection.a5 = 61;
ValueFormatter_FormatSection.a = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
/**
 * @hidden
 */
export class ValueFormatter_Part extends Base {
}
ValueFormatter_Part.$t = markType(ValueFormatter_Part, 'ValueFormatter_Part');
/**
 * @hidden
 */
export class ValueFormatter_WellKnownPart extends ValueFormatter_Part {
  constructor(a, b) {
    super();
    this.j = 0;
    this.c = 0;
    this.c = a;
    this.j = b;
  }
  b(a, b) {
    switch (this.c) {
      case 1:
      case 2: return b;
      case 0: return " ";
      default: return stringEmpty();
    }
  }
  a(a, b) {
    let c = dateMinValue();
    if (ValueFormatter_WellKnownPart.f(this.c) && this.c != 20 && this.c != 26 && this.c != 29) {
      if (b.l < 0) {
        return null;
      }
      if (b.ab.hasValue == false) {
        return null;
      }
      c = b.ab.value;
    }
    let t1 = this.c;
    L0: while (true) {
      switch (t1) {
        case 0: return " ";
        case 8: return a.bd.numberFormat.percentSymbol;
        case 3:
          {
            let d = stringEmpty();
            if (b.c == 0) {
              if (1 <= b.h && a.bv == 0) {
                d += b.aj;
              }
            }
            else if (b.c == 2) {
              if (a.bq == 0) {
                d += b.ah;
              }
            }
            d += a.bd.numberFormat.numberDecimalSeparator;
            b.am();
            return d;
          }
        case 4:
        case 5:
        case 6:
          {
            if (this.c == 6 && b.e == false && b.c == 3) {
              b.e = true;
              b.as();
            }
            let e = this.l(a, b);
            b.n++;
            return e;
          }
        case 7: return stringEmpty();
        case 9:
          b.ao();
          if (a.ax(b)) {
            return " ";
          }
          return "/";
        case 10:
        case 11:
          {
            b.aq();
            let f = "E";
            if (b.z < 0 || this.c == 11) {
              f += b.z < 0 ? a.bd.numberFormat.negativeSign : a.bd.numberFormat.positiveSign;
            }
            return f;
          }
        case 43:
          if (CalendarUtilities.b(a.a9) == 1) {
            t1 = 42;
            continue L0;
          }
          return a.cf(a.a9.getYear(c), 1);
        case 44:
          if (CalendarUtilities.b(a.a9) == 1) {
            t1 = 42;
            continue L0;
          }
          return a.cf(a.a9.getYear(c), 2);
        case 45:
        case 46:
        case 47:
          {
            let g = a.a9;
            if (CalendarUtilities.b(g) == 1) {
              return stringEmpty();
            }
            let h = g.getEra(c);
            let i = typeCast(JapaneseCalendar.$, g);
            if (i != null) {
              let j = i._getEraInfo(h);
              if (j == null) {
                return stringEmpty();
              }
              switch (this.c) {
                case 45: return j.i;
                case 46: return j.h;
                case 47: return j.j;
              }
            }
            return stringEmpty();
          }
        case 41: return a.cg(c, 2);
        case 42: return a.cg(c, 4);
        case 30: return a.ch(a.bb(7), c, 2);
        case 31: return a.ch(a.bb(7), c, 4);
        case 36: return a.cb(c, b, 1);
        case 37: return a.cb(c, b, 2);
        case 38: return a.cc(c, b, "MMM");
        case 39: return a.cc(c, b, "MMMM");
        case 40: return a.cc(c, b, "MMMM").charAt(0).toString();
        case 32: return a.b9(c, b, 1);
        case 33: return a.b9(c, b, 2);
        case 48: return a.ca(c, b, "ddd");
        case 34: return a.ca(c, b, "ddd", true);
        case 49: return a.ca(c, b, "dddd");
        case 35: return a.ca(c, b, "dddd", true);
        case 18:
        case 19:
          {
            let k = this.c == 18 ? 1 : 2;
            let l = timeSpanHours(dateGetTimeOfDay(c));
            if (a.q) {
              if (l == 0) {
                l = 12;
              }
              else if (12 < l) {
                l -= 12;
              }
            }
            return a.cf(l, k);
          }
        case 20:
        case 26:
        case 29:
          {
            let m = false;
            let n;
            let t2 = this.c;
            L1: while (true) {
              switch (t2) {
                case 20:
                  n = 24;
                  break;
                case 26:
                  n = 1440;
                  break;
                case 29:
                  n = 86400;
                  m = (a.ac == false);
                  break;
                default:
                  t2 = 20;
                  continue L1;
              }
              break;
            }
            let o = b.h * n;
            if (m) {
              o += 0.5;
            }
            o = Math.floor(o);
            if (a.a1) {
              return a.cd(o, false);
            }
            return a.b8(numberToString2(o, stringCreateFromChar('0', this.j)));
          }
        case 24: return a.ce(timeSpanMinutes(dateGetTimeOfDay(c)));
        case 25: return a.cf(timeSpanMinutes(dateGetTimeOfDay(c)), 2);
        case 27:
        case 28:
          {
            let p = timeSpanSeconds(dateGetTimeOfDay(c));
            if (a.ac == false && 500 <= timeSpanMilliseconds(dateGetTimeOfDay(c))) {
              p++;
            }
            if (this.c == 27) {
              return a.ce(p);
            }
            else {
              return a.cf(p, 2);
            }
          }
        case 21:
        case 22:
        case 23:
          {
            let q;
            switch (this.c) {
              case 21:
                q = 2;
                break;
              case 22:
                q = 1;
                break;
              case 23:
                q = 0;
                break;
              default: return stringEmpty();
            }
            let r = truncate(ValueFormatter.w(timeSpanMilliseconds(dateGetTimeOfDay(c)) / Math.pow(10, q)));
            return a.bd.numberFormat.numberDecimalSeparator + a.ce(r);
          }
        case 12:
        case 13:
        case 14:
        case 15:
          {
            let s = timeSpanHours(dateGetTimeOfDay(c)) < 12;
            let t = dateToStringFormat(c, "%t", a.bg);
            let u;
            let t2 = this.c;
            L1: while (true) {
              switch (t2) {
                case 12:
                  u = true;
                  break;
                case 13:
                  u = s;
                  break;
                case 14:
                  u = (s == false);
                  break;
                case 15:
                  u = false;
                  break;
                default:
                  t2 = 15;
                  continue L1;
              }
              break;
            }
            if (u) {
              t = t.toLowerCase();
            }
            return t;
          }
        case 16: return dateToStringFormat(c, "tt", a.bg);
        case 17:
          if (timeSpanHours(dateGetTimeOfDay(c)) < 12) {
            return "";
          }
          return "";
        case 1:
        case 2:
          {
            return a.cj(b);
          }
        default: return stringEmpty();
      }
      break;
    }
  }
  o() {
    switch (this.c) {
      case 36:
        this.c = 24;
        break;
      case 40:
      case 37:
      case 39:
      case 38:
        this.c = 25;
        break;
    }
  }
  l(a, b) {
    let c = this.m(a, b);
    if (c != null) {
      return c;
    }
    switch (this.c) {
      case 4: return stringEmpty();
      case 5:
        c = a.cf(0, 1);
        if (b.c == 0) {
          let d = a.ct(c, b.n, b.aj);
          c = d.p0;
        }
        return c;
      case 6:
        c = " ";
        if (b.c == 0) {
          let e = a.cu(c, b.n, b.aj, " ");
          c = e.p0;
        }
        return c;
      default: return stringEmpty();
    }
  }
  m(a, b) {
    switch (b.c) {
      case 0:
      case 4: return this.n(a, b, Nullable$1.toNullable(Number_$type, b.j), b.aj, a.bv, false);
      case 1:
      case 5:
        let c = this.n(a, b, Nullable$1.toNullable(Number_$type, null), b.ad, a.bo, true);
        if (c != null) {
          b.an();
        }
        return c;
      case 6: return this.n(a, b, Nullable$1.toNullable(Number_$type, b.z), b.al, a.by, false);
      case 7: return null;
      case 3:
        if (a.ax(b)) {
          if (b.n == 0) {
            return " ";
          }
          return this.n(a, b, Nullable$1.toNullable(Number_$type, 0), stringCreateFromChar(' ', b.af.length), a.bp, b.e);
        }
        return this.n(a, b, Nullable$1.toNullable(Number_$type, b.v), b.af, a.bp, b.e);
      case 2:
        if (a.ax(b)) {
          return this.n(a, b, Nullable$1.toNullable(Number_$type, 0), stringCreateFromChar(' ', b.ah.length), a.bq, false);
        }
        return this.n(a, b, Nullable$1.toNullable(Number_$type, b.x), b.ah, a.bq, false);
      default: return stringEmpty();
    }
  }
  n(a, b, c, d, e, f) {
    if (d == null) {
      return null;
    }
    if (f) {
      if (b.n < d.length) {
        return d.charAt(b.n).toString();
      }
      return null;
    }
    if (c.hasValue && c.value == 0 && (a.aa == false || b.c != 0 || a.ax(b) == false)) {
      switch (this.c) {
        case 4: return stringEmpty();
        case 6: return " ";
      }
    }
    let g = null;
    let h = d.length - e;
    if (h >= 0) {
      if (b.n == 0) {
        g = d.substr(0, h + 1);
      }
      else {
        g = d.charAt(h + b.n).toString();
      }
    }
    else {
      let i = b.n + h;
      if (i >= 0) {
        g = d.charAt(i).toString();
      }
    }
    if (g != null) {
      if (b.c == 0 || b.c == 4) {
        let j = a.ct(g, b.n, d);
        g = j.p0;
      }
    }
    return g;
  }
  static e(a) {
    switch (a) {
      case 31:
      case 30:
      case 33:
      case 35:
      case 32:
      case 34:
      case 40:
      case 37:
      case 39:
      case 36:
      case 38:
      case 42:
      case 41:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 49:
      case 48: return true;
    }
    return false;
  }
  static f(a) {
    return ValueFormatter_WellKnownPart.e(a) || ValueFormatter_WellKnownPart.i(a);
  }
  static g(a) {
    switch (a) {
      case 4:
      case 5:
      case 6: return true;
    }
    return false;
  }
  static h(a) {
    switch (a) {
      case 18:
      case 19:
      case 20: return true;
    }
    return false;
  }
  static i(a) {
    switch (a) {
      case 16:
      case 12:
      case 13:
      case 14:
      case 15:
      case 17:
      case 19:
      case 18:
      case 20:
      case 21:
      case 22:
      case 23:
      case 25:
      case 24:
      case 26:
      case 28:
      case 27:
      case 29: return true;
    }
    return false;
  }
  get d() {
    return this.c;
  }
}
ValueFormatter_WellKnownPart.$t = markType(ValueFormatter_WellKnownPart, 'ValueFormatter_WellKnownPart', ValueFormatter_Part.$);
/**
 * @hidden
 */
export class CalendarUtilities extends Base {
  static b(a) {
    return a.eras.length;
  }
  static a(a) {
    if (a == null) {
      return 0;
    }
    let b = a.name.toLowerCase();
    switch (b) {
      case "af": return 54;
      case "af-za": return 1078;
      case "am": return 94;
      case "am-et": return 1118;
      case "ar": return 1;
      case "ar-ae": return 14337;
      case "ar-bh": return 15361;
      case "ar-dz": return 5121;
      case "ar-eg": return 3073;
      case "ar-iq": return 2049;
      case "ar-jo": return 11265;
      case "ar-kw": return 13313;
      case "ar-lb": return 12289;
      case "ar-ly": return 4097;
      case "ar-ma": return 6145;
      case "ar-om": return 8193;
      case "ar-qa": return 16385;
      case "ar-sa": return 1025;
      case "ar-sy": return 10241;
      case "ar-tn": return 7169;
      case "ar-ye": return 9217;
      case "arn": return 122;
      case "arn-cl": return 1146;
      case "as": return 77;
      case "as-in": return 1101;
      case "az": return 44;
      case "az-cyrl": return 29740;
      case "az-cyrl-az": return 2092;
      case "az-latn": return 30764;
      case "az-latn-az": return 1068;
      case "ba": return 109;
      case "ba-ru": return 1133;
      case "be": return 35;
      case "be-by": return 1059;
      case "bg": return 2;
      case "bg-bg": return 1026;
      case "bin": return 102;
      case "bin-ng": return 1126;
      case "bn": return 69;
      case "bn-bd": return 2117;
      case "bn-in": return 1093;
      case "bo": return 81;
      case "bo-cn": return 1105;
      case "br": return 126;
      case "br-fr": return 1150;
      case "bs": return 30746;
      case "bs-cyrl": return 25626;
      case "bs-cyrl-ba": return 8218;
      case "bs-latn": return 26650;
      case "bs-latn-ba": return 5146;
      case "ca": return 3;
      case "ca-es": return 1027;
      case "ca-es-valencia": return 2051;
      case "chr": return 92;
      case "chr-cher": return 31836;
      case "chr-cher-us": return 1116;
      case "co": return 131;
      case "co-fr": return 1155;
      case "cs": return 5;
      case "cs-cz": return 1029;
      case "cy": return 82;
      case "cy-gb": return 1106;
      case "da": return 6;
      case "da-dk": return 1030;
      case "de": return 7;
      case "de-at": return 3079;
      case "de-ch": return 2055;
      case "de-de": return 1031;
      case "de-li": return 5127;
      case "de-lu": return 4103;
      case "dsb": return 31790;
      case "dsb-de": return 2094;
      case "dv": return 101;
      case "dv-mv": return 1125;
      case "dz-bt": return 3153;
      case "el": return 8;
      case "el-gr": return 1032;
      case "en": return 9;
      case "en-029": return 9225;
      case "en-au": return 3081;
      case "en-bz": return 10249;
      case "en-ca": return 4105;
      case "en-gb": return 2057;
      case "en-hk": return 15369;
      case "en-id": return 14345;
      case "en-ie": return 6153;
      case "en-in": return 16393;
      case "en-jm": return 8201;
      case "en-my": return 17417;
      case "en-nz": return 5129;
      case "en-ph": return 13321;
      case "en-sg": return 18441;
      case "en-tt": return 11273;
      case "en-us": return 1033;
      case "en-za": return 7177;
      case "en-zw": return 12297;
      case "es": return 10;
      case "es-419": return 22538;
      case "es-ar": return 11274;
      case "es-bo": return 16394;
      case "es-cl": return 13322;
      case "es-co": return 9226;
      case "es-cr": return 5130;
      case "es-cu": return 23562;
      case "es-do": return 7178;
      case "es-ec": return 12298;
      case "es-es": return 3082;
      case "es-gt": return 4106;
      case "es-hn": return 18442;
      case "es-mx": return 2058;
      case "es-ni": return 19466;
      case "es-pa": return 6154;
      case "es-pe": return 10250;
      case "es-pr": return 20490;
      case "es-py": return 15370;
      case "es-sv": return 17418;
      case "es-us": return 21514;
      case "es-uy": return 14346;
      case "es-ve": return 8202;
      case "et": return 37;
      case "et-ee": return 1061;
      case "eu": return 45;
      case "eu-es": return 1069;
      case "fa": return 41;
      case "fa-ir": return 1065;
      case "ff": return 103;
      case "ff-latn": return 31847;
      case "ff-latn-sn": return 2151;
      case "ff-ng": return 1127;
      case "fi": return 11;
      case "fi-fi": return 1035;
      case "fil": return 100;
      case "fil-ph": return 1124;
      case "fo": return 56;
      case "fo-fo": return 1080;
      case "fr": return 12;
      case "fr-029": return 7180;
      case "fr-be": return 2060;
      case "fr-ca": return 3084;
      case "fr-cd": return 9228;
      case "fr-ch": return 4108;
      case "fr-ci": return 12300;
      case "fr-cm": return 11276;
      case "fr-fr": return 1036;
      case "fr-ht": return 15372;
      case "fr-lu": return 5132;
      case "fr-ma": return 14348;
      case "fr-mc": return 6156;
      case "fr-ml": return 13324;
      case "fr-re": return 8204;
      case "fr-sn": return 10252;
      case "fy": return 98;
      case "fy-nl": return 1122;
      case "ga": return 60;
      case "ga-ie": return 2108;
      case "gd": return 145;
      case "gd-gb": return 1169;
      case "gl": return 86;
      case "gl-es": return 1110;
      case "gn": return 116;
      case "gn-py": return 1140;
      case "gsw": return 132;
      case "gsw-fr": return 1156;
      case "gu": return 71;
      case "gu-in": return 1095;
      case "ha": return 104;
      case "ha-latn": return 31848;
      case "ha-latn-ng": return 1128;
      case "haw": return 117;
      case "haw-us": return 1141;
      case "he": return 13;
      case "he-il": return 1037;
      case "hi": return 57;
      case "hi-in": return 1081;
      case "hr": return 26;
      case "hr-ba": return 4122;
      case "hr-hr": return 1050;
      case "hsb": return 46;
      case "hsb-de": return 1070;
      case "hu": return 14;
      case "hu-hu": return 1038;
      case "hy": return 43;
      case "hy-am": return 1067;
      case "ibb": return 105;
      case "ibb-ng": return 1129;
      case "id": return 33;
      case "id-id": return 1057;
      case "ig": return 112;
      case "ig-ng": return 1136;
      case "ii": return 120;
      case "ii-cn": return 1144;
      case "is": return 15;
      case "is-is": return 1039;
      case "it": return 16;
      case "it-ch": return 2064;
      case "it-it": return 1040;
      case "iu": return 93;
      case "iu-cans": return 30813;
      case "iu-cans-ca": return 1117;
      case "iu-latn": return 31837;
      case "iu-latn-ca": return 2141;
      case "ja": return 17;
      case "ja-jp": return 1041;
      case "ka": return 55;
      case "ka-ge": return 1079;
      case "kk": return 63;
      case "kk-kz": return 1087;
      case "kl": return 111;
      case "kl-gl": return 1135;
      case "km": return 83;
      case "km-kh": return 1107;
      case "kn": return 75;
      case "kn-in": return 1099;
      case "ko": return 18;
      case "ko-kr": return 1042;
      case "kok": return 87;
      case "kok-in": return 1111;
      case "kr": return 113;
      case "kr-ng": return 1137;
      case "ks": return 96;
      case "ks-arab": return 1120;
      case "ks-deva-in": return 2144;
      case "ku": return 146;
      case "ku-arab": return 31890;
      case "ku-arab-iq": return 1170;
      case "ky": return 64;
      case "ky-kg": return 1088;
      case "la": return 118;
      case "la-001": return 1142;
      case "lb": return 110;
      case "lb-lu": return 1134;
      case "lo": return 84;
      case "lo-la": return 1108;
      case "lt": return 39;
      case "lt-lt": return 1063;
      case "lv": return 38;
      case "lv-lv": return 1062;
      case "mi": return 129;
      case "mi-nz": return 1153;
      case "mk": return 47;
      case "mk-mk": return 1071;
      case "ml": return 76;
      case "ml-in": return 1100;
      case "mn": return 80;
      case "mn-cyrl": return 30800;
      case "mn-mn": return 1104;
      case "mn-mong": return 31824;
      case "mn-mong-cn": return 2128;
      case "mn-mong-mn": return 3152;
      case "mni": return 88;
      case "mni-in": return 1112;
      case "moh": return 124;
      case "moh-ca": return 1148;
      case "mr": return 78;
      case "mr-in": return 1102;
      case "ms": return 62;
      case "ms-bn": return 2110;
      case "ms-my": return 1086;
      case "mt": return 58;
      case "mt-mt": return 1082;
      case "my": return 85;
      case "my-mm": return 1109;
      case "nb": return 31764;
      case "nb-no": return 1044;
      case "ne": return 97;
      case "ne-in": return 2145;
      case "ne-np": return 1121;
      case "nl": return 19;
      case "nl-be": return 2067;
      case "nl-nl": return 1043;
      case "nn": return 30740;
      case "nn-no": return 2068;
      case "no": return 20;
      case "nso": return 108;
      case "nso-za": return 1132;
      case "oc": return 130;
      case "oc-fr": return 1154;
      case "om": return 114;
      case "om-et": return 1138;
      case "or": return 72;
      case "or-in": return 1096;
      case "pa": return 70;
      case "pa-arab": return 31814;
      case "pa-arab-pk": return 2118;
      case "pa-in": return 1094;
      case "pap": return 121;
      case "pap-029": return 1145;
      case "pl": return 21;
      case "pl-pl": return 1045;
      case "prs": return 140;
      case "prs-af": return 1164;
      case "ps": return 99;
      case "ps-af": return 1123;
      case "pt": return 22;
      case "pt-br": return 1046;
      case "pt-pt": return 2070;
      case "quc": return 134;
      case "quc-latn": return 31878;
      case "quc-latn-gt": return 1158;
      case "quz": return 107;
      case "quz-bo": return 1131;
      case "quz-ec": return 2155;
      case "quz-pe": return 3179;
      case "rm": return 23;
      case "rm-ch": return 1047;
      case "ro": return 24;
      case "ro-md": return 2072;
      case "ro-ro": return 1048;
      case "ru": return 25;
      case "ru-md": return 2073;
      case "ru-ru": return 1049;
      case "rw": return 135;
      case "rw-rw": return 1159;
      case "sa": return 79;
      case "sa-in": return 1103;
      case "sah": return 133;
      case "sah-ru": return 1157;
      case "sd": return 89;
      case "sd-arab": return 31833;
      case "sd-arab-pk": return 2137;
      case "sd-deva-in": return 1113;
      case "se": return 59;
      case "se-fi": return 3131;
      case "se-no": return 1083;
      case "se-se": return 2107;
      case "si": return 91;
      case "si-lk": return 1115;
      case "sk": return 27;
      case "sk-sk": return 1051;
      case "sl": return 36;
      case "sl-si": return 1060;
      case "sma": return 30779;
      case "sma-no": return 6203;
      case "sma-se": return 7227;
      case "smj": return 31803;
      case "smj-no": return 4155;
      case "smj-se": return 5179;
      case "smn": return 28731;
      case "smn-fi": return 9275;
      case "sms": return 29755;
      case "sms-fi": return 8251;
      case "so": return 119;
      case "so-so": return 1143;
      case "sq": return 28;
      case "sq-al": return 1052;
      case "sr": return 31770;
      case "sr-cyrl": return 27674;
      case "sr-cyrl-ba": return 7194;
      case "sr-cyrl-me": return 12314;
      case "sr-cyrl-rs": return 10266;
      case "sr-latn": return 28698;
      case "sr-latn-ba": return 6170;
      case "sr-latn-me": return 11290;
      case "sr-latn-rs": return 9242;
      case "st": return 48;
      case "st-za": return 1072;
      case "sv": return 29;
      case "sv-fi": return 2077;
      case "sv-se": return 1053;
      case "sw": return 65;
      case "sw-ke": return 1089;
      case "syr": return 90;
      case "syr-sy": return 1114;
      case "ta": return 73;
      case "ta-in": return 1097;
      case "ta-lk": return 2121;
      case "te": return 74;
      case "te-in": return 1098;
      case "tg": return 40;
      case "tg-cyrl": return 31784;
      case "tg-cyrl-tj": return 1064;
      case "th": return 30;
      case "th-th": return 1054;
      case "ti": return 115;
      case "ti-er": return 2163;
      case "ti-et": return 1139;
      case "tk": return 66;
      case "tk-tm": return 1090;
      case "tn": return 50;
      case "tn-bw": return 2098;
      case "tn-za": return 1074;
      case "tr": return 31;
      case "tr-tr": return 1055;
      case "ts": return 49;
      case "ts-za": return 1073;
      case "tt": return 68;
      case "tt-ru": return 1092;
      case "tzm": return 95;
      case "tzm-arab-ma": return 1119;
      case "tzm-latn": return 31839;
      case "tzm-latn-dz": return 2143;
      case "tzm-tfng": return 30815;
      case "tzm-tfng-ma": return 4191;
      case "ug": return 128;
      case "ug-cn": return 1152;
      case "uk": return 34;
      case "uk-ua": return 1058;
      case "ur": return 32;
      case "ur-in": return 2080;
      case "ur-pk": return 1056;
      case "uz": return 67;
      case "uz-cyrl": return 30787;
      case "uz-cyrl-uz": return 2115;
      case "uz-latn": return 31811;
      case "uz-latn-uz": return 1091;
      case "ve": return 51;
      case "ve-za": return 1075;
      case "vi": return 42;
      case "vi-vn": return 1066;
      case "wo": return 136;
      case "wo-sn": return 1160;
      case "xh": return 52;
      case "xh-za": return 1076;
      case "yi": return 61;
      case "yi-001": return 1085;
      case "yo": return 106;
      case "yo-ng": return 1130;
      case "zh": return 30724;
      case "zh-cn": return 2052;
      case "zh-hans": return 4;
      case "zh-hant": return 31748;
      case "zh-hk": return 3076;
      case "zh-mo": return 5124;
      case "zh-sg": return 4100;
      case "zh-tw": return 1028;
      case "zu": return 53;
      case "zu-za": return 1077;
      case "zh-chs": return 4;
      case "zh-cht": return 31748;
    }
    return 0;
  }
}
CalendarUtilities.$t = markType(CalendarUtilities, 'CalendarUtilities');
/**
 * @hidden
 */
export class DBNumHelper extends Base {
  static k(a) {
    return 1 <= a && a <= 4;
  }
  static l(a) {
    return DBNumHelper.c(a, 1) != null;
  }
  static c(a, b) {
    if (b == 3) {
      return DBNumHelper.j;
    }
    if (b == 1 || b == 2) {
      switch (a) {
        case 30724:
        case 2052:
        case 4:
        case 4100: return b == 1 ? DBNumHelper.a : DBNumHelper.b;
        case 31748:
        case 3076:
        case 1028:
        case 5124: return b == 1 ? DBNumHelper.h : DBNumHelper.i;
        case 18:
        case 1042: return b == 1 ? DBNumHelper.f : DBNumHelper.g;
        case 17:
        case 1041: return b == 1 ? DBNumHelper.d : DBNumHelper.e;
      }
    }
    return null;
  }
  static o(a, b) {
    if (1 <= b && b <= 3) {
      switch (a) {
        case 30724:
        case 2052:
        case 4:
        case 4100: return b == 2 ? "" : "";
        case 31748:
        case 3076:
        case 5124:
        case 1028: return b == 2 ? "" : "";
        case 18:
        case 1042: return b == 2 ? "" : "";
        case 17:
        case 1041: return b == 2 ? "" : "";
      }
    }
    return null;
  }
  static v(a, b, c, d = 0) {
    let e = DBNumHelper.c(a, b);
    let f = DBNumHelper.o(a, b);
    if (f == null || e == null) {
      return null;
    }
    let g = e == DBNumHelper.j || e == DBNumHelper.d;
    let h = b == 2;
    let i = new StringBuilder(0);
    let j = 1;
    let k = 0;
    if (c == 0) {
      return "" + e[0];
    }
    let l = false;
    while (c != 0) {
      let m = (c % 10);
      if (j >= 17 || (j == 13 && c >= 10000)) {
        l = true;
      }
      if (l) {
        if (k != 6) {
          k = 6;
          i.w(0, f.charAt(6));
        }
        i.x(0, e[m]);
      }
      else if (m > 0) {
        if (j >= 5) {
          let n = intDivide((j - 5), 4) + 4;
          if (n != k) {
            i.w(0, f.charAt(n));
            k = n;
          }
          let o = (j - 5) % 4;
          if (o > 0 || (!h && m == 1)) {
            i.w(0, f.charAt(o));
          }
        }
        else if (j == 2) {
          i.w(0, f.charAt(1));
        }
        else if (j == 3) {
          i.w(0, f.charAt(2));
        }
        else if (j == 4) {
          i.w(0, f.charAt(3));
        }
        if (j == 1 || !g || m > 1) {
          i.x(0, e[m]);
        }
      }
      j++;
      c = intDivide((c - m), 10);
    }
    while (j <= d) {
      i.x(0, e[0]);
      j++;
    }
    return i.toString();
  }
}
DBNumHelper.$t = markType(DBNumHelper, 'DBNumHelper');
DBNumHelper.f = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.a = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.h = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.d = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.g = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.b = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.i = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.e = ["", "", "", "", "", "", "", "", "", ""];
DBNumHelper.j = ["", "", "", "", "", "", "", "", "", ""];
/**
 * @hidden
 */
export class ValueFormatter_LiteralFormatPart extends ValueFormatter_Part {
  constructor(a, b) {
    super();
    this.e = null;
    this.c = 0;
    this.e = a;
    this.c = b;
  }
  b(a, b) {
    return this.f();
  }
  a(a, b) {
    b.ap();
    return this.f();
  }
  f() {
    if (this.c == 1) {
      return stringEmpty();
    }
    if (this.c == 2) {
      return " ";
    }
    return this.e;
  }
  get g() {
    return this.e;
  }
  get d() {
    return this.c;
  }
}
ValueFormatter_LiteralFormatPart.$t = markType(ValueFormatter_LiteralFormatPart, 'ValueFormatter_LiteralFormatPart', ValueFormatter_Part.$);
/**
 * Extend the class ArgumentOutOfRangeException to add a constructor
 */
export class ArgumentOutOfRangeExceptionExtension extends ArgumentOutOfRangeException {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      if (typeof arguments[1] === 'string') {
        a = 0;
      }
      else if (typeCast(BaseError.$, arguments[1]) !== null) {
        a = 2;
      }
      else if (arguments[1] == null) {
        a = 0;
      }
    }
    else if (arguments.length === 3) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let paramName = _rest[0];
          let message = _rest[1];
          super(2, paramName, message);
          paramName = (paramName !== void 0 ? paramName : null);
          message = (message !== void 0 ? message : null);
        }
        break;
      case 1:
        {
          let paramName = _rest[0];
          let value = _rest[1];
          let message = _rest[2];
          super(2, paramName, message);
        }
        break;
      case 2:
        {
          let message = _rest[0];
          let innerException = _rest[1];
          super(4, message, innerException);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
}
ArgumentOutOfRangeExceptionExtension.$t = markType(ArgumentOutOfRangeExceptionExtension, 'ArgumentOutOfRangeExceptionExtension', ArgumentOutOfRangeException.$);
/**
 * A collection of worksheets in a workbook.
 * @see [[Worksheet]]
 * @see */
export class WorksheetCollection extends Base {
  constructor(a) {
    super();
    this._j = null;
    this._f = true;
    this._a = null;
    this._a = a;
    this._j = new List$1(Worksheet.$, 0);
  }
  add() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(Worksheet.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddWorksheet"));
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._k.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._k.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  insert(index, item) {
    throw new NotSupportedException(0);
  }
  item() {
    if (arguments.length === 2) {
      return this._item$e.apply(this, arguments);
    }
    else {
      let n;
      if (arguments.length === 1) {
        if (typeof arguments[0] === 'number') {
          n = 0;
        }
        else if (typeof arguments[0] === 'string') {
          n = 1;
        }
        else if (arguments[0] == null) {
          n = 1;
        }
      }
      switch (n) {
        case 0: return this._item.apply(this, arguments);
        case 1: return this._item1.apply(this, arguments);
        default: throw new Error('Invalid arguments');
      }
    }
  }
  /**
   * @hidden
   */
  _item$e(a, b) {
    if (arguments.length === 2) {
      throw new NotSupportedException(0);
      return b;
    }
    else {
      return this._item(a);
    }
  }
  /**
   * @hidden
   */
  _add1(a) {
    return this._add2(a, this._a._g2());
  }
  /**
   * @hidden
   */
  _add2(a, b) {
    return this._a._sheets$i._add2(a, b, 0);
  }
  /**
   * Clears all worksheets from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with a worksheet for a scope, they will be removed from the [[Workbook]].
   * </p>
   */
  clear() {
    this._a._sheets$i._t();
  }
  /**
   * Determines whether a worksheet is in the collection.
   * @param worksheet The worksheet to locate in the collection.
   * @return True if the worksheet is found; False otherwise.
   */
  contains(worksheet) {
    return this._a._sheets$i.contains(worksheet);
  }
  /**
   * @hidden
   */
  _n() {
    this._f = true;
  }
  /**
   * Determines whether a worksheet with the specified name exists in the collection.
   * @param name The name of the worksheet to search for. The name is compared case-insensitively.
   * @return True if a worksheet with the specified name is found; False otherwise.
   */
  exists(name) {
    for (let a of fromEnum(this._k)) {
      if (StringUtilities.c(a.name, name, this._a._e6, 1) == 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the index of the specified worksheet in the collection.
   * @param worksheet The worksheet of which to get the index.
   * @return The index of the specified worksheet in the collection.
   * @see [[Worksheet.index]]
   */
  indexOf(worksheet) {
    return this._k.indexOf(worksheet);
  }
  /**
   * @hidden
   */
  _o(a, b) {
    let c = this._k._inner[a];
    let d = c.sheetIndex;
    let e = this._k._inner[b].sheetIndex;
    this._a._sheets$i._v(d, e);
  }
  /**
   * Removes the specified worksheet from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
   * </p>
   * @param worksheet The worksheet to remove from the collection.
   * @return True if the worksheet was successfully removed from the collection;
   * False if the worksheet did not exist in the collection.
   */
  remove_1(worksheet) {
    return this._a._sheets$i.remove_1(worksheet);
  }
  /**
   * Removes the worksheet at the specified index from the collection.
   * <p class="body">
   * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
   * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
   * </p>
   * @param index The index of the worksheet to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  removeAt(index) {
    this._a._sheets$i.removeAt(this._k._inner[index].sheetIndex);
  }
  /**
   * Gets the number of worksheets in the collection.
   * The number of worksheets in the collection.
   */
  get count() {
    return this._k.count;
  }
  /**
   * @hidden
   */
  _item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._k._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    let b = this._a._sheets$i._item1(a);
    if (b.type != 0) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LER_Exception_KeyNotFound"));
    }
    return b;
  }
  /**
   * @hidden
   */
  get _k() {
    if (this._f) {
      this._f = false;
      this._j.clear();
      let a = this._a._sheets$i;
      for (let b = 0; b < a.count; b++) {
        let c = a._item(b);
        if (c.type == 0) {
          this._j.add(c);
        }
      }
    }
    return this._j;
  }
}
WorksheetCollection.$t = markType(WorksheetCollection, 'WorksheetCollection', Base.$, [IList$1_$type.specialize(Worksheet.$)]);
/**
 * @hidden
 */
export class WorksheetRowCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.e = 0;
    this.d = 0;
    this.b = null;
    this.a = null;
    this.c = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.b = c;
          this.e = d;
          this.d = e;
          this.a = f;
          this.c = new Dictionary$2(WorksheetCellAddress.$, SingleTargetFormula.$, 0);
        }
        break;
    }
  }
  get workbook() {
    return this.b._e.workbook;
  }
  get sheet() {
    return this.b._e;
  }
  get source() {
    return this.b._e;
  }
}
WorksheetRowCollection_CollectionChangeContext.$t = markStruct(WorksheetRowCollection_CollectionChangeContext, 'WorksheetRowCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of rows in a worksheet.
 * <p class="body">
 * Rows in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the rows which were already accessed.
 * </p>
 * @see [[WorksheetRow]]
 * @see [[Worksheet.rows]]
 */
export class WorksheetRowCollection extends RowColumnCollectionBase$1 {
  constructor(a) {
    super(WorksheetRow.$, a, Workbook.getMaxRowCount(a._o));
    this._al = null;
    this._al = this._c;
  }
  static staticInit() {
    WorksheetRowCollection._ag = WorksheetRowCollection._ah();
  }
  /**
   * @hidden
   */
  _a() {
    this._al = new WorksheetRowCollection_RowsLoadOnDemandTree(this);
    return this._al;
  }
  /**
   * @hidden
   */
  _createValue(a) {
    return new WorksheetRow(this._e, a);
  }
  /**
   * @hidden
   */
  _getItemIndex(a) {
    return a.index;
  }
  /**
   * @hidden
   */
  _initializeItemIndex(a, b, c) {
    a._dn(b, c);
  }
  /**
   * @hidden
   */
  _isItemStillValid(a) {
    return !a._m;
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get_maxCount() {
    return Workbook.getMaxRowCount(this._e._o);
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get maxCount() {
    return this.get_maxCount();
  }
  /**
   * @hidden
   */
  _ab() {
    super._ab();
    for (let a of fromEnum(this)) {
      a._x();
    }
  }
  /**
   * @hidden
   */
  _ae(a) {
    throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxRows", this._e.workbook.maxRowCount));
  }
  /**
   * @hidden
   */
  _af(a, b) {
    for (let c of fromEnum(this)) {
      c._ac(a, b);
    }
  }
  /**
   * @hidden
   */
  static _ai($tValue, a, b, c, d, e, f, g = true, h = true) {
    return new ChangeInfo$2(WorksheetRowCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, g, f, h, null, null);
  }
  /**
   * @hidden
   */
  static _ah() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, WorksheetRowCollection._ai(Number_$type, "Add", 97, (b) => b.e, (b, c) => WorksheetRowCollection._a1(b, c), null, 64));
    ChangeInfo.f(a, 1, WorksheetRowCollection._ai(Number_$type, "Remove", 98, (b) => b.e, (b, c) => WorksheetRowCollection._a2(b, c), null, 512));
    return a;
  }
  /**
   * @hidden
   */
  _aq(a, b, c, d, e = false) {
    let f = this._al._a6(a, b, c, d, e);
    c = f.p2;
    d = f.p3;
    return {
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _aj(a) {
    let b;
    if (((() => { let c = this._c._p(a, b); b = c.p1; return c.ret; })())) {
      return b;
    }
    return null;
  }
  /**
   * @hidden
   */
  _ar(a, b, c, d, e = false) {
    {
      let f = Workbook._fc(this._e.workbook);
      try {
        let g = this._al._a7(a, b, c, d, e);
        a = g.p0;
        b = g.p1;
        c = g.p2;
        d = g.p3;
      }
      finally {
        if (f != null) {
          f.dispose();
        }
      }
    }
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _ap(a, b, c) {
    let d = c ? this._n(a + 1, this.maxCount - 1, true) : this._n(0, a - 1, false);
    for (let e of fromEnum(d)) {
      let f = e._a2(b);
      if (f != null && f.j(b)) {
        return Nullable$1.toNullable(Number_$type, e.index);
      }
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  _as(a) {
    for (let b of fromEnum(this)) {
      b.hidden = a.contains(b);
    }
  }
  /**
   * Inserts one or more rows into the collection
   * <para class="note"><b>Note:</b> An equal number of rows will be removed (i.e. bumped) off the end of the collection.</para>
   * @param index the insertion point
   * @param count The number of rows to insert
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
   */
  insert(index, count = 1) {
    this._a3();
    let a = this.maxCount;
    if (index < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (count < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (index + count > a) {
      throw new InvalidOperationException(1, "Max rows exceeded");
    }
    this._au(index, count);
  }
  /**
   * @hidden
   */
  _au(a, b, c = Nullable$1.toNullable(WorksheetRowCollection_CollectionChangeContext.$, null)) {
    let d = this.maxCount;
    let e = null;
    if (a > 0) {
      e = this._g(a - 1, false);
    }
    let f = new List$1(WorksheetRow.$, 1, this._m(d - b, d - 1));
    if (0 < a) {
      let g = this._aj(a - 1);
      if (g != null) {
        g._di(false);
      }
    }
    let h = this._aj(a);
    if (h != null) {
      h._di(false);
    }
    let i = WorksheetRowCollection._ag[0];
    let j = new WorksheetRowCollection_CollectionChangeContext(1, this, a, b, f.toArray());
    let k = new WorksheetRowCollection_InsertRemoveOperationWrapper(i, j, true, nullableNotEquals(c, null), null);
    let l = this._e._b8(new CellShiftOperation(2, this._e, 3, null, a, d - (b + 1), 0, (Workbook.getMaxColumnCount(this._e._o) - 1), b, true), 2, k);
    this._e._h0();
    this._ac(l.a);
    i.e(WorksheetRowCollection_CollectionChangeContext.$, Number_$type, j, -1, a);
    if (e != null) {
      let m = a + b;
      for (let n = a; n < m; n++) {
        let o = this.item(n);
        o._dm(e);
        o._di(false);
      }
    }
    for (let p of fromEnum(f)) {
      p._du(j.c);
    }
    if (nullableNotEquals(c, null)) {
      this._aw(c.value.a, c.value.c);
    }
    this._al._ba();
    this._al._au(false);
    k.h();
    if (k.g != null) {
      i.d(this._e.workbook, k.g);
    }
    for (let q of fromEnum(this._m(a + b, this.maxCount - 1))) {
      q._dg();
    }
    let r = this._e.workbook;
    if (r != null) {
      r._hm((s, t) => t._b6(r), true);
    }
    this._e._ig();
    this._e._h7();
  }
  /**
   * @hidden
   */
  _av() {
    this._al._ba();
  }
  /**
   * @hidden
   */
  _aw(a, b) {
    let c = this._k;
    for (let e = 0; e < a.length; e++) {
      let d = a[e];
      d._dr(this._e, c);
      let f = this._i(d, d.index);
    }
    for (let h = 0; h < a.length; h++) {
      let g = a[h];
      g._dt(this._e, b);
    }
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetRow.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return WorksheetItemCollection$1.prototype._remove$i.apply(this, arguments);
      case 1: return this._remove1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove1(a, b = 1) {
    this._a3();
    let c = this.maxCount;
    if (a < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (b < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (a + b > c) {
      throw new InvalidOperationException(1, "Max rows exceeded");
    }
    let d = null;
    let e = 0;
    let f = null;
    let g = new WorksheetRegionAddress(1, a, a + b - 1, 0, (this._e._columns$i.maxCount - 1));
    for (let h of fromEnum(this._e._tables$i)) {
      if (h._by._j(g)) {
        e++;
        if (!g._h(h._by)) {
          if (f != null) {
            this._ac(3);
          }
          else {
            f = h;
          }
        }
      }
    }
    if (f != null) {
      if (e > 1) {
        this._ac(3);
      }
      if (f.isHeaderRowVisible && g._i(f.headerRowRegion.firstRow, f._by._w)) {
        this._ac(3);
      }
      if (g._h(f.dataAreaRegion._h)) {
        d = this._aj(a);
        if (b == 1) {
          d._de();
          return;
        }
        a += 1;
        b -= 1;
      }
    }
    this._ay(a, b, Nullable$1.toNullable(WorksheetRowCollection_CollectionChangeContext.$, null), d);
  }
  /**
   * @hidden
   */
  _ay(a, b, c = Nullable$1.toNullable(WorksheetRowCollection_CollectionChangeContext.$, null), d = null) {
    let e = new List$1(WorksheetRow.$, 1, this._m(a, a + b - 1));
    if (e.count != 0) {
      if (0 < a && e._inner[e.count - 1].index == a + b - 1 && (e._inner[e.count - 1]._b1)) {
        this._h(a - 1);
      }
      if (a + b < this.maxCount && e._inner[0].index == a && (e._inner[0]._b4)) {
        this._h(a + b);
      }
    }
    if (0 < a) {
      let f = this._aj(a - 1);
      if (f != null) {
        f._di(false);
      }
    }
    if (a + b < this.maxCount) {
      let g = this._aj(a + b);
      if (g != null) {
        g._di(false);
      }
    }
    let h = WorksheetRowCollection._ag[1];
    let i = new WorksheetRowCollection_CollectionChangeContext(1, this, a, b, e.toArray());
    let j = new WorksheetRowCollection_InsertRemoveOperationWrapper(h, i, false, nullableNotEquals(c, null), d);
    let k = this._e._b8(new CellShiftOperation(2, this._e, 3, null, a + b, this.maxCount - 1, 0, (Workbook.getMaxColumnCount(this._e._o) - 1), -b, true), 0, j);
    this._e._h0();
    this._ac(k.a);
    for (let l of fromEnum(e)) {
      l._du(i.c);
    }
    if (nullableNotEquals(c, null)) {
      this._aw(c.value.a, c.value.c);
    }
    h.e(WorksheetRowCollection_CollectionChangeContext.$, Number_$type, i, -1, a);
    this._al._ba();
    this._al._au(false);
    this._e._h5();
    j.h();
    if (j.g != null) {
      h.d(this._e.workbook, j.g);
    }
    for (let m of fromEnum(this._m(a + b, this.maxCount - 1))) {
      m._dg();
    }
    let n = this._e.workbook;
    if (n != null) {
      n._hm((o, p) => p._b6(n), true);
    }
    this._e._ig();
  }
  /**
   * @hidden
   */
  _az(a) {
    this._al._ba();
    this._al._au(a);
  }
  /**
   * @hidden
   */
  _a0(a, b) {
    this._al._ba();
    this._al._av(a, b);
  }
  /**
   * @hidden
   */
  static _a1(a, b) {
    a.b._y();
    a.b._ay(a.e, a.d, Nullable$1.toNullable(WorksheetRowCollection_CollectionChangeContext.$, a));
  }
  /**
   * @hidden
   */
  static _a2(a, b) {
    a.b._y();
    a.b._au(a.e, a.d, Nullable$1.toNullable(WorksheetRowCollection_CollectionChangeContext.$, a));
  }
  /**
   * @hidden
   */
  _a3() {
    if (this._e.workbook == null) {
      throw new InvalidOperationException(1, "The worksheet has been deleted");
    }
  }
  /**
   * Gets the row at the specified index.
   * <p class="note">
   * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
   * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
   * the maximum row count, and pass in each index to the collection's indexer.
   * </p>
   * The row at the specified index.
   * @param index The zero-based index of the row to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
   * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelRowCount]]
   * or [[Workbook.maxExcel2007RowCount]], depending on the [[Workbook.currentFormat]].
   */
  item(a) {
    return this._h(a);
  }
}
WorksheetRowCollection.$t = markType(WorksheetRowCollection, 'WorksheetRowCollection', RowColumnCollectionBase$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
WorksheetRowCollection._am = 0;
/**
 * @hidden
 */
WorksheetRowCollection._ao = 1;
/**
 * @hidden
 */
WorksheetRowCollection._an = 2;
/**
 * @hidden
 */
WorksheetRowCollection._ag = null;
/**
 * @hidden
 */
export class WorksheetElementResizeContext extends Base {
  constructor() {
    super(...arguments);
    this.h = false;
    this.a = null;
    this.x = 0;
  }
  static b(a) {
    let b;
    if (WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac == null) {
      b = new WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange();
    }
    else {
      b = WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac;
      WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac = null;
    }
    b.ag(a);
    b.ab();
    return b;
  }
  static j(a, b, c) {
    if (b < -1) {
      b = -1;
    }
    if (c < b) {
      b = c;
    }
    let d = new List$1(WorksheetElementResizeState.$, 2, a.count);
    for (let e of fromEnum(a)) {
      d.add(new WorksheetElementResizeState(e.a, e.b, b, false, b >= 0));
    }
    return d;
  }
  static c(a, b, c, d, e = null) {
    e = e || WorksheetElementResizeContext.k(a, b, c, d);
    let f = new WorksheetElementResizeContext_MultiElementVisibilityChange(a, false, b, c, e);
    f.ab();
    return f;
  }
  static d(a, b, c, d) {
    let e = new WorksheetElementResizeContext_MultiElementResizeChange(a, b, c, d);
    e.ab();
    return e;
  }
  static e(a, b, c, d, e, f = null) {
    f = f || WorksheetElementResizeContext.n(a, b, c, d, e);
    let g = new WorksheetElementResizeContext_MultiElementVisibilityChange(a, true, b, c, f);
    g.ab();
    return g;
  }
  static k(a, b, c, d) {
    let e = new List$1(IndexRange.$, 0);
    for (let f of fromEnum(a._ff)) {
      if (f.r < b) {
        continue;
      }
      if (c < f.q) {
        break;
      }
      if (f.i != d) {
        e.add(new IndexRange(1, Math.max(f.q, b), Math.min(f.r, c)));
      }
    }
    return e;
  }
  static n(a, b, c, d, e) {
    let f = new List$1(IndexRange.$, 0);
    if (e || (nullableNotEquals(d, null) && nullableNotEquals(d, a._dv))) {
      let g = b;
      for (let h of fromEnum(a._rows$i._m(b, c))) {
        if (nullableEquals(d, null) || nullableEquals(h.hidden, d)) {
          if (h.index != g) {
            f.add(new IndexRange(1, g, h.index - 1));
          }
          g = h.index + 1;
        }
      }
      if (g != c + 1) {
        f.add(new IndexRange(1, g, c));
      }
    }
    else {
      let i = Nullable$1.toNullable(Number_$type, null);
      let j = 0;
      for (let k of fromEnum(a._rows$i._m(b, c))) {
        if (nullableNotEquals(d, null) && nullableNotEquals(k.hidden, d)) {
          if (nullableEquals(i, null)) {
            i = Nullable$1.toNullable(Number_$type, k.index);
          }
          else {
            if (nullableNotEquals(i, k.index + 1)) {
              f.add(new IndexRange(1, i.value, j));
              i = Nullable$1.toNullable(Number_$type, k.index);
            }
          }
          j = k.index;
        }
      }
      if (nullableNotEquals(i, null)) {
        f.add(new IndexRange(1, i.value, j));
      }
    }
    return f;
  }
  static l(a, b, c) {
    let d = new List$1(WorksheetElementResizeState.$, 0);
    let e = b;
    let f = a._dv;
    let g = a.defaultRowHeight;
    for (let h of fromEnum(a._ff)) {
      let i = h.q;
      let j = h.r;
      if (j < b) {
        continue;
      }
      let k = d.count == 0 ? null : d._inner[d.count - 1];
      if (k == null || k.c != h.v || k.a != h.j || k.b != h.i) {
        let l = k == null ? b : k.e + 1;
        let m = Math.min(c, j);
        k = new WorksheetElementResizeState(l, m, h.v, h.i, h.j);
        d.add(k);
      }
      else {
        k.e = Math.min(c, j);
      }
      if (k.e == c) {
        break;
      }
    }
    return d;
  }
  static m(a, b, c, d = null) {
    let e = new List$1(WorksheetElementResizeState.$, 0);
    let f = b;
    let g = a._dv;
    let h = a.defaultRowHeight;
    for (let i of fromEnum(a._rows$i._m(b, c))) {
      let j = i.index;
      let k = e.count == 0 ? null : e._inner[e.count - 1];
      if (f < j) {
        if (k != null && k.e == f - 1 && k.c == h && k.b == g) {
          k.e = j - 1;
        }
        else {
          k = new WorksheetElementResizeState(f, j - 1, h, g, false);
          e.add(k);
        }
      }
      f = j + 1;
      if (d != null && !d(i)) {
        continue;
      }
      if (k != null && k.e == j - 1 && k.b == i.hidden && k.c == i._ct()) {
        k.e++;
      }
      else {
        k = new WorksheetElementResizeState(j, j, i._ct(), i.hidden, false);
        e.add(k);
      }
    }
    if (f < a._rows$i.maxCount - 1) {
      let l = e.count == 0 ? null : e._inner[e.count - 1];
      if (l != null && l.e == f - 1 && l.c == h && l.b == g) {
        l.e = a._rows$i.maxCount - 1;
      }
      else {
        l = new WorksheetElementResizeState(f, a._rows$i.maxCount - 1, h, g, false);
        e.add(l);
      }
    }
    return e;
  }
  static o(a, b, c) {
    c = false;
    let d = new List$1(WorksheetElementResizeState.$, 0);
    for (let e = 0; e < b.count; e++) {
      let f = b._inner[e];
      let g = f.d;
      let h = a._f9(g);
      let i = a._ff._inner[h];
      let j = d.count;
      while (true) {
        let k = i.v;
        let l = i.i;
        let m = i.j;
        if (i.r < f.e) {
          h++;
          i = a._ff._inner[h];
          if (i.v != k || i.i != l || i.j != m) {
            d.add(new WorksheetElementResizeState(g, i.q - 1, k, l, m));
            g = i.q;
          }
        }
        else {
          d.add(new WorksheetElementResizeState(g, f.e, k, l, m));
          break;
        }
      }
      if (!c) {
        for (let n = j; n < d.count; n++) {
          if (f.b != d._inner[n].b) {
            c = true;
            break;
          }
        }
      }
    }
    return {
      ret: d,
      p2: c
    };
  }
  static p(a, b, c) {
    c = false;
    let d = new List$1(WorksheetElementResizeState.$, 0);
    let e = -1;
    let f = a._dv;
    let g = false;
    for (let h = 0; h < b.count; h++) {
      let i = b._inner[h];
      let j = i.d;
      let k = a._rows$i._aj(j);
      let l = k != null;
      let m = l ? k._cm : e;
      let n = l ? k._l : f;
      let o = l ? k._bz : g;
      let p = j + 1;
      let q = d.count;
      for (let r of fromEnum(a._rows$i._m(i.d + 1, i.e))) {
        if (r.index > p) {
          if (e != m || f != n || g != o) {
            d.add(new WorksheetElementResizeState(j, p - 1, m, n, o));
            j = p;
            m = e;
            n = f;
            o = g;
          }
        }
        if (r._cm != m || r._l != n || r._bz != o) {
          d.add(new WorksheetElementResizeState(j, r.index - 1, m, n, o));
          j = r.index;
          m = r._cm;
          n = r._l;
          o = r._bz;
        }
        p = r.index + 1;
      }
      if (p <= i.e && (e != m || f != n || g != o)) {
        d.add(new WorksheetElementResizeState(j, p - 1, m, n, o));
        j = p;
        m = e;
        n = f;
        o = g;
      }
      d.add(new WorksheetElementResizeState(j, i.e, m, n, o));
      if (!c) {
        for (let s = q; s < d.count; s++) {
          if (i.b != d._inner[s].b) {
            c = true;
            break;
          }
        }
      }
    }
    return {
      ret: d,
      p2: c
    };
  }
  z(a, b) {
    this.a = a;
    this.h = b;
  }
  y() {
    this.aa();
    this.a = null;
  }
  q(a) {
    if (a == 0) {
      return 0;
    }
    if (this.h) {
      return a;
    }
    else {
      return truncate(MathUtilities.f(this.a._fl(a, 5, false)));
    }
  }
  f(a) {
    if (this.h) {
      return this.a._eg(a);
    }
    else {
      return this.a._ec(a);
    }
  }
  s(a, b = false) {
    if (this.h) {
      return this.a._gh(a, b);
    }
    else {
      return this.a._gb(a, b);
    }
  }
  t(a, b, c = false) {
    if (this.h) {
      let d;
      let e;
      let f = this.a._rows$i._aq(a, b + 1, d, e, c);
      d = f.p2;
      e = f.p3;
      return (e - d);
    }
    else {
      let g;
      let h;
      let i = this.a._columns$i._aq(a, b + 1, g, h, c);
      g = i.p2;
      h = i.p3;
      return (h - g);
    }
  }
  aa() {
    let a = this.h ? this.a._bp.l(this.r, this.a._rows$i.maxCount - 1) : this.a._bp.i(this.r, this.a._columns$i.maxCount - 1);
    let b = a._d;
    if (b != null) {
      for (let c = 0; c < b.count; c++) {
        b._inner[c]._cu(this);
      }
    }
    a.dispose();
    for (let d of fromEnum(this.a._eu.values)) {
      if (this.h) {
        if (d._ad.o < this.r) {
          continue;
        }
      }
      else {
        if (d._ad.m < this.r) {
          continue;
        }
      }
      d._cu(this);
    }
  }
  ab() {
    let a = this.h ? this.a._bp.l(this.r, this.a._rows$i.maxCount - 1) : this.a._bp.i(this.r, this.a._columns$i.maxCount - 1);
    let b = a._d;
    let c = 0;
    if (b != null) {
      c += b.count;
      for (let d = 0; d < b.count; d++) {
        b._inner[d]._cv();
      }
    }
    a.dispose();
    for (let e of fromEnum(this.a._eu.values)) {
      if (this.h) {
        if (e._ad.o < this.r) {
          continue;
        }
      }
      else {
        if (e._ad.m < this.r) {
          continue;
        }
      }
      c++;
      e._cv();
    }
    this.x = c;
  }
}
WorksheetElementResizeContext.$t = markType(WorksheetElementResizeContext, 'WorksheetElementResizeContext');
/**
 * @hidden
 */
export class WorksheetShapeCollection_ChartShiftInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
}
WorksheetShapeCollection_ChartShiftInfo.$t = markStruct(WorksheetShapeCollection_ChartShiftInfo, 'WorksheetShapeCollection_ChartShiftInfo');
/**
 * @hidden
 */
export class WorksheetShapeCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._e.sheet != null ? this.b._e.sheet.workbook : null;
  }
  get sheet() {
    return this.b._g;
  }
  get source() {
    return this.b._e;
  }
}
WorksheetShapeCollection_CollectionChangeContext.$t = markStruct(WorksheetShapeCollection_CollectionChangeContext, 'WorksheetShapeCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export let IMultiChartContext_$type = new Type(null, 'IMultiChartContext');
/**
 * @hidden
 */
export class WorksheetShapeCollection_ChartShiftContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
  c() {
    WorksheetShapeCollection._s.clear();
    WorksheetShapeCollection._t.clear();
    for (let a = 0; a < this.a.length; a++) {
      let b = this.a[a];
      let c = b.b;
      for (let d = 0; d < b.a.length; d++) {
        let e = b.a[d];
        let f = e.c;
        let g = f.undoChartShift(e.d);
        if (g != null) {
          WorksheetShapeCollection._t.add(Tuple.a(IChartObject_$type, Base.$, f, g));
        }
      }
      WorksheetShapeCollection._s.add(new WorksheetShapeCollection_ChartShiftInfo(1, b.b, WorksheetShapeCollection._t.toArray()));
      WorksheetShapeCollection._t.clear();
    }
    let h = this.sheet;
    let i = h.workbook;
    let j = i._df;
    i._df = false;
    let k = WorksheetShapeCollection._a[4];
    let l = new WorksheetShapeCollection_ChartShiftContext(1, this.b, WorksheetShapeCollection._s.toArray());
    k.x(l, null, null);
    i._df = j;
    WorksheetShapeCollection._s.clear();
  }
  get workbook() {
    return this.b._e.sheet != null ? this.b._e.sheet.workbook : null;
  }
  get sheet() {
    return this.b._g;
  }
  get source() {
    return this.b._e;
  }
  *_charts() {
    let c = this.a;
    for (let b = 0; b < c.length; b++) {
      let a = c[b];
      yield a.b;
    }
  }
  charts() {
    return toEnum(() => this._charts());
  }
}
WorksheetShapeCollection_ChartShiftContext.$t = markStruct(WorksheetShapeCollection_ChartShiftContext, 'WorksheetShapeCollection_ChartShiftContext', ValueType.$, [IChangeInfoContext_$type, IMultiChartContext_$type]);
/**
 * A collection of [[WorksheetShape]] instances in a [[Worksheet]]
 * or [[WorksheetShapeGroup]].
 * @see@see */
export class WorksheetShapeCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._e = null;
    this._u = null;
    this._e = a;
    this._u = new List$1(WorksheetShape.$, 0);
  }
  static staticInit() {
    WorksheetShapeCollection._a = WorksheetShapeCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._u.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._u.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 3;
    }
    else if (arguments.length === 2) {
      n = 2;
    }
    else if (arguments.length === 3) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    switch (n) {
      case 0:
        arguments[2] = rectFromLiteral(arguments[2]);
        return this._add.apply(this, arguments);
      case 1:
        arguments[2] = pointFromLiteral(arguments[2]);
        arguments[4] = pointFromLiteral(arguments[4]);
        return this._add1.apply(this, arguments);
      case 2:
        arguments[1] = rectFromLiteral(arguments[1]);
        return this._add2.apply(this, arguments);
      case 3: return this._add3.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add2(a, b) {
    if (this._g == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_NoWorksheetContextToSetShapeBounds"));
    }
    return this._add(a, this._g, b);
  }
  /**
   * @hidden
   */
  _add(a, b, c) {
    if (b == null) {
      throw new ArgumentNullException(0, "sheet");
    }
    let d = WorksheetShape.createPredefinedShape(a);
    if (d == null) {
      return null;
    }
    d._setBoundsInTwips(b, c);
    this._add3(d);
    return d;
  }
  /**
   * @hidden
   */
  _add1(a, b, c, d, e) {
    let f = WorksheetShape.createPredefinedShape(a);
    if (f == null) {
      return null;
    }
    if (WorksheetCell.l_op_Equality(b, null) || WorksheetCell.l_op_Equality(d, null)) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_AnchorShapeBeforeAddingToCollection"));
    }
    if (b.worksheet != this._g) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TopLeftAnchorFromOtherWorksheet"));
    }
    if (d.worksheet != this._g) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_BottomRightAnchorFromOtherWorksheet"));
    }
    f._c5(b.worksheet, b._e, c, d._e, e);
    this._add3(f);
    return f;
  }
  /**
   * @hidden
   */
  _add3(a) {
    this._add4(a, true);
  }
  /**
   * @hidden
   */
  _add4(a, b, c = null) {
    if (a == null) {
      throw new ArgumentNullException(2, "shape", ExcelUtils.ef("LE_ArgumentNullException_Shape"));
    }
    if (b && a._aq == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ShapeCannotBeAdded"), "shape");
    }
    this._ai(this._u.count, a, c);
  }
  /**
   * @hidden
   */
  _ai(a, b, c = null) {
    this._aj();
    let d = typeCast(IChartObject_$type, b);
    if (d != null && this._p) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddChartInChart"));
    }
    let e = WorksheetShapeCollection._a[d != null ? 1 : 0];
    let f = null;
    if (this._e.sheet != null) {
      f = e.b(this._e.sheet.workbook, this._e.sheet, e.c);
    }
    let g = new WorksheetShapeCollection_CollectionChangeContext(1, this, b, a);
    b._ct(this);
    this._u.insert(a, b);
    this._e.onShapeAdded(b);
    if (c != null) {
      c(typeCast(WorksheetChart.$, b));
    }
    e.e(WorksheetShapeCollection_CollectionChangeContext.$, WorksheetShape.$, g, null, b);
    if (f != null) {
      e.d(this._e.sheet.workbook, f);
    }
    this._ak();
  }
  addChart() {
    let n;
    if (arguments.length === 2) {
      n = 2;
    }
    else if (arguments.length === 3) {
      if (typeCast(Sheet.$, arguments[1]) !== null) {
        n = 0;
      }
      else if (isRect(arguments[1])) {
        n = 2;
      }
      else if (arguments[1] == null) {
        n = 0;
      }
    }
    else if (arguments.length === 4) {
      n = 0;
    }
    else if (arguments.length === 5) {
      n = 1;
    }
    else if (arguments.length === 6) {
      n = 1;
    }
    switch (n) {
      case 0:
        arguments[2] = rectFromLiteral(arguments[2]);
        arguments[3] = (arguments[3] !== void 0 ? arguments[3] : null);
        return this._addChart.apply(this, arguments);
      case 1:
        arguments[2] = pointFromLiteral(arguments[2]);
        arguments[4] = pointFromLiteral(arguments[4]);
        arguments[5] = (arguments[5] !== void 0 ? arguments[5] : null);
        return this._addChart1.apply(this, arguments);
      case 2:
        arguments[1] = rectFromLiteral(arguments[1]);
        arguments[2] = (arguments[2] !== void 0 ? arguments[2] : null);
        return this._addChart2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _addChart2(a, b, c = null) {
    return this._addChart(a, this._g, b, c);
  }
  /**
   * @hidden
   */
  _addChart(a, b, c, d = null) {
    if (b == null) {
      throw new ArgumentNullException(0, "sheet");
    }
    WorksheetChart._jv(b, a);
    b.workbook._i9();
    let e = new WorksheetChart(0);
    e._i8();
    e.chartType = a;
    e._setBoundsInTwips(b, c);
    this._add4(e, true, d);
    e._je();
    e._ja();
    return e;
  }
  /**
   * @hidden
   */
  _addChart1(a, b, c, d, e, f = null) {
    this._g.workbook._i9();
    WorksheetChart._jv(this._g, a);
    if (WorksheetCell.l_op_Equality(b, null) || WorksheetCell.l_op_Equality(d, null)) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_AnchorShapeBeforeAddingToCollection"));
    }
    if (b.worksheet != this._g) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_TopLeftAnchorFromOtherWorksheet"));
    }
    if (d.worksheet != this._g) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_BottomRightAnchorFromOtherWorksheet"));
    }
    let g = new WorksheetChart(0);
    g._i8();
    g.chartType = a;
    g._c5(b.worksheet, b._e, c, d._e, e);
    this._add4(g, true, f);
    g._je();
    g._ja();
    return g;
  }
  /**
   * Clears all shapes from the collection.
   */
  clear() {
    this._aj();
    let a = this._u.count > 1 ? this._ac(21) : null;
    for (let b = this._u.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._am(a);
    this._ak();
  }
  /**
   * Determines whether a shape is in the collection.
   * @param shape The shape to locate in the collection.
   * @return True if the shape is found; False otherwise.
   */
  contains(shape) {
    return this._u.contains(shape);
  }
  /**
   * Removes the specified shape from the collection.
   * @param shape The shape to remove from the collection.
   * @return True if the shape was successfully removed from the collection;
   * False if the shape did not exist in the collection.
   */
  remove_1(shape) {
    let a = this._u.indexOf(shape);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the shape at the specified index from the collection.
   * @param index The index of the shape to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._aj();
    let a = this._u._inner[index];
    let b = typeCast(IChartObject_$type, a);
    let c = WorksheetShapeCollection._a[b != null ? 3 : 2];
    let d = new WorksheetShapeCollection_CollectionChangeContext(1, this, a, index);
    let e = null;
    if (this._e.sheet != null) {
      e = c.b(this._e.sheet.workbook, this._e.sheet, c.c);
    }
    this._u.removeAt(index);
    a._cz();
    this._e.onShapeRemoved(a);
    c.e(WorksheetShapeCollection_CollectionChangeContext.$, WorksheetShape.$, d, a, null);
    if (e != null) {
      c.d(this._e.sheet.workbook, e);
    }
    this._ak();
  }
  /**
   * @hidden
   */
  _ag() {
    for (let a = this._u.count - 1; a >= 0; a--) {
      let b = this._u._inner[a];
      let c = typeCast(WorksheetShapeGroupBase.$, b);
      if (c != null) {
        c._shapes$i._ag();
        continue;
      }
      if (b._b9 != null) {
        this._u.removeAt(a);
      }
    }
  }
  /**
   * @hidden
   */
  _al(a, b) {
    let c = typeCast(Sheet.$, this._g);
    switch (c.workbook.currentFormat) {
      case 0:
      case 1: return;
    }
    if (WorksheetShapeCollection._t == null) {
      WorksheetShapeCollection._t = new List$1(Tuple$2.$.specialize(IChartObject_$type, Base.$), 0);
    }
    else {
      WorksheetShapeCollection._t.clear();
    }
    if (WorksheetShapeCollection._s == null) {
      WorksheetShapeCollection._s = new List$1(WorksheetShapeCollection_ChartShiftInfo.$, 0);
    }
    else {
      WorksheetShapeCollection._s.clear();
    }
    this._ah((d) => {
      let e = typeCast(WorksheetChart.$, d);
      if (e == null) {
        return;
      }
      try {
        WorksheetChart._jv(e.sheet, e.chartType);
      }
      catch (f) {
        DocCoreUtils.ao(f.message);
        return;
      }
      e.onShiftRegion((g, h) => WorksheetShapeCollection._t.add(Tuple.a(IChartObject_$type, Base.$, g, h)), a, b);
      if (WorksheetShapeCollection._t.count > 0) {
        e.onPropertyChanged();
        WorksheetShapeCollection._s.add(new WorksheetShapeCollection_ChartShiftInfo(1, e, WorksheetShapeCollection._t.toArray()));
        WorksheetShapeCollection._t.clear();
      }
    });
    WorksheetShapeCollection._t.clear();
    if (WorksheetShapeCollection._s.count == 0) {
      return;
    }
    let d = c.workbook;
    let e = d._df;
    d._df = false;
    let f = WorksheetShapeCollection._a[4];
    let g = new WorksheetShapeCollection_ChartShiftContext(1, this, WorksheetShapeCollection._s.toArray());
    f.x(g, null, null);
    d._df = e;
    WorksheetShapeCollection._s.clear();
  }
  /**
   * @hidden
   */
  _ao() {
    for (let a = this.count - 1; a >= 0; a--) {
      let b = this.item(a);
      if (b._aq == false) {
        this.removeAt(a);
        continue;
      }
      let c = typeCast(WorksheetShapeGroupBase.$, b);
      if (c != null) {
        c._shapes$i._ao();
      }
    }
  }
  /**
   * @hidden
   */
  _ah(a) {
    for (let b of fromEnum(this)) {
      a(b);
      if (typeCast(WorksheetShapeGroupBase.$, b) !== null) {
        b._shapes$i._ah(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetShapeCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetShapeCollection_ChartShiftContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(5);
    ChangeInfo.f(a, 0, WorksheetShapeCollection._c(WorksheetShape.$, "Add", 63, (b) => b.a, (b, c) => WorksheetShapeCollection._ap(b, c)));
    ChangeInfo.f(a, 1, WorksheetShapeCollection._c(WorksheetShape.$, "Add", 6, (b) => b.a, (b, c) => WorksheetShapeCollection._ap(b, c)));
    ChangeInfo.f(a, 2, WorksheetShapeCollection._c(WorksheetShape.$, "Remove", 64, (b) => b.a, (b, c) => WorksheetShapeCollection._aq(b, c)));
    ChangeInfo.f(a, 3, WorksheetShapeCollection._c(WorksheetShape.$, "Remove", 8, (b) => b.a, (b, c) => WorksheetShapeCollection._aq(b, c)));
    ChangeInfo.f(a, 4, WorksheetShapeCollection._d(Base.$, "ChartShift", 7, (b) => null, (b, c) => b.c()));
    return a;
  }
  /**
   * @hidden
   */
  _aj() {
    let a = typeCast(IChartObject_$type, this._e);
    if (a != null) {
      let b = a.workbook;
      if (b != null && !b._c4) {
        b._i9();
      }
    }
  }
  /**
   * @hidden
   */
  _ak() {
    let a = typeCast(IChartObject_$type, this._e);
    if (a != null) {
      a.onPropertyChanged();
    }
  }
  /**
   * @hidden
   */
  _ac(a) {
    let b = this._e.sheet.workbook;
    return b != null && b._cx ? b._go(this._e.sheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _am(a) {
    if (a != null) {
      let b = this._e.sheet.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _ap(a, b) {
    let c = a.b._u.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _aq(a, b) {
    a.b._ai(a.c, a.a);
  }
  /**
   * Gets the number of shapes in the collection.
   * The number of shapes in the collection.
   */
  get count() {
    return this._u.count;
  }
  /**
   * Gets the shape at the specified index in the collection.
   * The shape at the specified index.
   * @param index The zero-based index of the shape to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._u._inner[a];
  }
  /**
   * @hidden
   */
  get _p() {
    let a = typeCast(IChartObject_$type, this._e);
    if (a != null) {
      return true;
    }
    let b = typeCast(WorksheetShapeGroupBase.$, this._e);
    return b != null ? b._a7 : false;
  }
  /**
   * @hidden
   */
  get _q() {
    return this._e.areChildrenTopMost;
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e;
  }
  /**
   * @hidden
   */
  get _g() {
    return this._e.sheet;
  }
}
WorksheetShapeCollection.$t = markType(WorksheetShapeCollection, 'WorksheetShapeCollection', Base.$, [ICollection$1_$type.specialize(WorksheetShape.$)]);
/**
 * @hidden
 */
WorksheetShapeCollection._w = 0;
/**
 * @hidden
 */
WorksheetShapeCollection._v = 1;
/**
 * @hidden
 */
WorksheetShapeCollection._ab = 2;
/**
 * @hidden
 */
WorksheetShapeCollection._aa = 3;
/**
 * @hidden
 */
WorksheetShapeCollection._x = 4;
/**
 * @hidden
 */
WorksheetShapeCollection._z = 5;
/**
 * @hidden
 */
WorksheetShapeCollection._a = null;
/**
 * @hidden
 */
WorksheetShapeCollection._t = null;
/**
 * @hidden
 */
WorksheetShapeCollection._s = null;
/**
 * @hidden
 */
export class WorksheetCellAddress extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.l = 0;
    this.n = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.n = c;
          this.l = d;
        }
        break;
    }
  }
  equals(a) {
    if ((typeCast(WorksheetCellAddress.$, a) !== null) == false) {
      return false;
    }
    let b = a;
    if (this.n != b.n) {
      return false;
    }
    return this.l == b.l;
  }
  getHashCode() {
    return this.n ^ (this.l << 16);
  }
  toString() {
    return this.p(false, false, 2, 1);
  }
  a() {
    return new WorksheetCellAddress(1, this.n, this.l);
  }
  p(a, b, c, d) {
    if (this.e == false) {
      return "#REF!";
    }
    return CellAddress.u(this.n, this.l, c, a, b, this.n, this.l, false, d);
  }
  c(a) {
    if (a == this.l) {
      return this;
    }
    return new WorksheetCellAddress(1, this.n, a);
  }
  d(a) {
    if (a == this.n) {
      return this;
    }
    return new WorksheetCellAddress(1, a, this.l);
  }
  get m() {
    return this.l;
  }
  get e() {
    return this.n >= 0 && this.l >= 0;
  }
  get o() {
    return this.n;
  }
  static f(a, b) {
    return a.l == b.l && a.n == b.n;
  }
  static g(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return WorksheetCellAddress.f(a.value, b.value);
  }
  static h(a, b) {
    return !(WorksheetCellAddress.f(a, b));
  }
  static i(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return WorksheetCellAddress.h(a.value, b.value);
  }
}
WorksheetCellAddress.$t = markStruct(WorksheetCellAddress, 'WorksheetCellAddress');
WorksheetCellAddress.b = new WorksheetCellAddress(1, -1, -1);
/**
 * Represents a comment for a cell.
 * <p class="body">
 * Comments cannot be added to a worksheet's or a shape group's shapes collection. Instead, they must be set directly on the cell
 * with the cell's [[WorksheetCell.comment]] property.
 * </p>
 * <p class="body">
 * It is not required that the anchors of this shape be initialized before setting it as the comment of a cell. If the
 * [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]] anchors are both null when
 * the comment is applied to a cell, default anchor cells will be used based on the cell.
 * </p>
 */
export class WorksheetCellComment extends WorksheetShape {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
          this._d9 = null;
          this._d1 = null;
          this._d0 = null;
          this._eb = 0;
          this._d3 = new WorksheetCellAddress();
          this._dy = null;
          this._ed();
        }
        break;
      case 1:
        {
          let shapeWithText = _rest[0];
          super(2, shapeWithText);
          this._d9 = null;
          this._d1 = null;
          this._d0 = null;
          this._eb = 0;
          this._d3 = new WorksheetCellAddress();
          this._dy = null;
          this._ed();
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _ed() {
    this.fill = ShapeFill._fromColor$i(SystemColorsInternal.ax);
    if (this._bb == false) {
      this.positioningMode = 3;
    }
    this.visible = false;
    this._cc = 530;
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitWorksheetCellComment$i(this, b);
  }
  /**
   * @hidden
   */
  get__aq() {
    return false;
  }
  /**
   * @hidden
   */
  get__as() {
    return false;
  }
  /**
   * @hidden
   */
  get__a8() {
    return true;
  }
  /**
   * @hidden
   */
  _cz() {
    super._cz();
    if (this._dy != null) {
      this._dy._ac(null);
    }
  }
  /**
   * @hidden
   */
  _c0(a) {
    super._c0(a);
    if (this._dy != null) {
      this._dy._ac(a);
    }
  }
  /**
   * @hidden
   */
  _c3() {
    if (this._h == null) {
      this._h = new Obj(1, this);
    }
  }
  /**
   * @hidden
   */
  _c4(a, b, c) {
    super._c4(a, b, c);
    this._d1 = a;
    if (WorksheetCell.l_op_Inequality(this._d1, null)) {
      this._d0 = this._d1.worksheet;
    }
  }
  /**
   * @hidden
   */
  _r(a, b, c) {
    if (WorksheetCell.l_op_Equality(this._d1, null)) {
      return {
        ret: ((() => { let d = super._r(a, b, c); c = d.p2; return d.ret; })()),
        p2: c
      };
    }
    let d = b ? this._d1._m : new WorksheetRegionAddress(2, this._d3, this._d3);
    let e = d;
    let f = ((() => { let g = a.e(e, false); e = g.p0; return g.ret; })());
    if (f.f) {
      if (e._ac != e._ae || e._w != e._x) {
        return {
          ret: ShiftAddressResult.d,
          p2: c
        };
      }
      let g = e._ac - d._ac;
      let h = e._w - d._w;
      let i = c._ac + g;
      if (i < 0) {
        i = 0;
        g = i = c._ac;
      }
      if (g != 0) {
        c = c._d(i)._f(c._ae + g);
      }
      let j = c._w + h;
      if (j < 0) {
        j = 0;
        h = j = c._w;
      }
      if (h != 0) {
        c = c._c(j)._e((c._x + h));
      }
      if (c._ae >= this.worksheet._rows$i.maxCount) {
        c = c._f(this.worksheet._rows$i.maxCount - 1);
      }
      if (c._x >= this.worksheet._columns$i.maxCount) {
        c = c._e((this.worksheet._columns$i.maxCount - 1));
      }
    }
    return {
      ret: f,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _dc() {
    super._dc();
    this._d3 = WorksheetCell.l_op_Inequality(this._d1, null) ? this._d1._e : WorksheetCellAddress.b;
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 202);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, null);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
  /**
   * @hidden
   */
  _dh(a) {
  }
  /**
   * Gets the worksheet on which the shape resides.
   * The worksheet on which the shape resides.
   */
  get_sheet() {
    return this._d0;
  }
  /**
   * @hidden
   */
  get allowDefaultValues() {
    return true;
  }
  /**
   * @hidden
   */
  getDefaultFont() {
    return null;
  }
  /**
   * @hidden
   */
  getFontDefaultsResolver() {
    return null;
  }
  /**
   * @hidden
   */
  onUnformattedStringChanged(sender) {
    if (this._dy != null) {
      let a = this._dy.unformattedString;
      if (stringIsNullOrEmpty(a) == false && a.length > 32767) {
        throw new ArgumentException(1, stringFormat(ExcelUtils.ef("LE_ArgumentException_TextLengthGreaterThanMax"), 32767));
      }
    }
    this._ee();
  }
  /**
   * @hidden
   */
  onFormattingChanged() {
  }
  /**
   * @hidden
   */
  resolveDefaults(font) {
    if (WorkbookColorInfo.l_op_Equality(font.colorInfo, null)) {
      font.colorInfo = new WorkbookColorInfo(SystemColorsInternal.az);
    }
    UltimateFontDefaultsResolver.a.resolveDefaults(font);
  }
  /**
   * @hidden
   */
  _ee() {
    if (this._dy == null) {
      return;
    }
    let a = this._dy._m;
    if (stringIsNullOrEmpty(a._y)) {
      return;
    }
    let b = typeCast(FormattedStringElement.$, a);
    if (b != null && b._u) {
      return;
    }
    if (this.worksheet == null) {
      return;
    }
    this._dy._x();
    if (b == null) {
      b = this._dy._e();
    }
    b._ah.add(new FormattedStringRun(b, 0));
    this._dy._w();
  }
  /**
   * @hidden
   */
  static _dx($tValue, a, b, c, d = null, e = true, f = false, g = 8192) {
    return new ChangeInfo$2(WorksheetCellComment.$, $tValue, a, 3, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _dw() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, WorksheetCellComment._dx(String_$type, "Author", (b) => b.author, (b, c) => b.author = c));
    ChangeInfo.f(a, 1, WorksheetCellComment._dx(FormattedString.$, "Text", (b) => b.text, (b, c) => b.text = c, null, true, true));
    return a;
  }
  /**
   * Gets or sets the author of the comment.
   * <p class="body">
   * This information is not displayed in the Microsoft Excel UI and is for informational purposes only.
   * </p>
   * The author of the comment.
   */
  get author() {
    return this._d9;
  }
  /**
   * Gets or sets the author of the comment.
   * <p class="body">
   * This information is not displayed in the Microsoft Excel UI and is for informational purposes only.
   * </p>
   * The author of the comment.
   */
  set author(a) {
    if (a == null) {
      a = stringEmpty();
    }
    let b = WorksheetCellComment._dv[0].g(WorksheetCellComment.$, String_$type, this, this._d9, a);
    this._d9 = b.p1;
  }
  /**
   * Gets the cell to which the comment is applied.
   * The cell to which the comment is applied.
   * @see [[WorksheetCell.comment]]
   */
  get cell() {
    return this._d1;
  }
  /**
   * Gets the cell to which the comment is applied.
   * The cell to which the comment is applied.
   * @see [[WorksheetCell.comment]]
   */
  set cell(a) {
    if (WorksheetCell.l_op_Equality(this._d1, a)) {
      return;
    }
    this._d1 = a;
    if (WorksheetCell.l_op_Inequality(this._d1, null)) {
      this._d0 = this._d1.worksheet;
    }
    this._ee();
  }
  /**
   * @hidden
   */
  get _d4() {
    return this._d3;
  }
  /**
   * @hidden
   */
  get _ec() {
    return this._eb;
  }
  /**
   * @hidden
   */
  set _ec(a) {
    this._eb = a;
  }
  /**
   * Gets or sets the formatted text of the comment.
   * <p class="body">
   * Getting the value of this property will always return a non-null value. If null is set on the property, it will subsequently
   * return an empty formatted string.
   * </p>
   * The formatted text of the comment.
   */
  get text() {
    if (this._dy == null) {
      this._dy = new FormattedString(stringEmpty());
      this._dy._owner = this;
    }
    return this._dy;
  }
  /**
   * Gets or sets the formatted text of the comment.
   * <p class="body">
   * Getting the value of this property will always return a non-null value. If null is set on the property, it will subsequently
   * return an empty formatted string.
   * </p>
   * The formatted text of the comment.
   */
  set text(a) {
    if (this._dy == a) {
      return;
    }
    if (a != null) {
      a._verifyNewOwner1(this);
    }
    let b = this._dy;
    let c = WorksheetCellComment._dv[1];
    let d = this.worksheet;
    let e = d != null ? d.workbook : null;
    let f = null;
    if (e != null && e._cx) {
      f = c.b(e, d, c.c);
    }
    if (this._dy != null) {
      this._dy._owner = null;
    }
    this._dy = a;
    if (this._dy != null) {
      this._dy._owner = this;
    }
    this.onUnformattedStringChanged(this._dy);
    if (e != null && e._cx) {
      c.e(WorksheetCellComment.$, FormattedString.$, this, b, this._dy);
      if (f != null) {
        c.d(e, f);
      }
    }
  }
}
WorksheetCellComment.$t = markType(WorksheetCellComment, 'WorksheetCellComment', WorksheetShape.$, [IFormattedStringOwner_$type, IWorkbookFontDefaultsResolver_$type]);
/**
 * @hidden
 */
WorksheetCellComment._d6 = 32767;
/**
 * @hidden
 */
WorksheetCellComment._d5 = 0;
/**
 * @hidden
 */
WorksheetCellComment._d8 = 1;
/**
 * @hidden
 */
WorksheetCellComment._d7 = 2;
/**
 * @hidden
 */
WorksheetCellComment._dv = WorksheetCellComment._dw();
/**
 * @hidden
 */
export class WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange extends WorksheetElementResizeContext {
  constructor() {
    super();
    this.ae = 0;
    this.ad = false;
    this.af = 0;
  }
  y() {
    if (this.ad != this.f(this.ae) || this.af != this.s(this.ae, true)) {
      super.y();
    }
    if (WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac == null) {
      WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac = this;
    }
    this.a = null;
  }
  ag(a) {
    this.z(a.worksheet, typeCast(WorksheetRow.$, a) !== null);
    this.ae = a.index;
    this.ad = a.hidden;
    this.af = this.s(this.ae, true);
  }
  g(a) {
    if (this.ae == a) {
      return this.ad;
    }
    return this.f(a);
  }
  u(a, b = false) {
    if (this.ae == a) {
      if (b == false && this.ad) {
        return 0;
      }
      return this.af;
    }
    return this.s(a, b);
  }
  v(a, b) {
    if (a == this.ae && b == this.ae) {
      return this.u(this.ae, false);
    }
    let c = this.t(a, b);
    let d = (this.s(this.ae) - this.u(this.ae, false));
    return c - d;
  }
  get_i() {
    return ((() => {
      let $ret = new List$1(IndexRange.$, 0);
      $ret.add(new IndexRange(1, this.ae, this.ae));
      return $ret;
    })());
  }
  get i() {
    return this.get_i();
  }
  get_r() {
    return this.ae;
  }
  get r() {
    return this.get_r();
  }
  get_w() {
    return this.ae;
  }
  get w() {
    return this.get_w();
  }
}
WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.$t = markType(WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange, 'WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange', WorksheetElementResizeContext.$);
WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange.ac = null;
/**
 * @hidden
 */
export class WorksheetColumnBlock extends Base {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.o = 0;
    this.e = false;
    this.p = 0;
    this.l = 0;
    this.s = -1;
    this.f = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.o = c;
          this.p = d;
          this.a = e;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = [c, d, e.a];
          {
            let h = f[0];
            let i = f[1];
            let j = f[2];
            this.o = h;
            this.p = i;
            this.a = j;
          }
          this.e = e.e;
          this.l = e.l;
          this.s = e.s;
          this.a.k();
          this.f = e.f;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(WorksheetColumnBlock.$, a);
    if (b == null) {
      return false;
    }
    return this.e == b.e && this.l == b.l && this.s == b.s && this.f == b.f && this.a.equals(b.a);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.e) ^ (this.l) ^ (this.s) ^ Base.getHashCodeStatic(this.f) ^ this.a.getHashCode();
  }
  toString() {
    let a = new StringBuilder(0);
    a.r("FirstColumn: {0}, LastColumn: {1}", this.o, this.p);
    if (this.s >= 0) {
      a.q(", Width: {0}", this.s);
    }
    if (this.e) {
      a.l(", Hidden");
    }
    return a.toString();
  }
  c(a) {
    return this.d(a, this.q, this.r);
  }
  d(a, b, c) {
    let d = new WorksheetColumnBlock(0, b, c, this.b._bv(a));
    d.e = this.e;
    d.l = this.l;
    d.s = this.s;
    d.f = this.f;
    return d;
  }
  g(a) {
    return a >= this.o && a <= this.p;
  }
  n(a, b, c = false) {
    if (c == false && this.i) {
      return 0;
    }
    return a._fl(this.v < 0 ? a.defaultColumnWidth : this.v, b);
  }
  x(a, b) {
    if (this.k) {
      return;
    }
    let c = Workbook.getMaxColumnCount(b) - 1;
    if (c < this.q) {
      a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxColumnIndex"), Math.max(this.q, c + 1), c));
    }
  }
  get b() {
    return this.a;
  }
  set b(a) {
    this.a = a;
  }
  get t() {
    return this.p + 1 - this.o;
  }
  get q() {
    return this.o;
  }
  set q(a) {
    this.o = a;
  }
  get i() {
    return this.e;
  }
  set i(a) {
    this.e = a;
  }
  get j() {
    return this.f;
  }
  set j(a) {
    this.f = a;
  }
  get k() {
    return this.e == false && this.l == 0 && this.s == -1 && this.a._cd;
  }
  get r() {
    return this.p;
  }
  set r(a) {
    this.p = a;
  }
  get m() {
    return this.l;
  }
  set m(a) {
    this.l = a;
  }
  get v() {
    return this.s;
  }
  set v(a) {
    this.s = a;
  }
}
WorksheetColumnBlock.$t = markType(WorksheetColumnBlock, 'WorksheetColumnBlock');
/**
 * @hidden
 */
export class WorksheetCellFormatBlock extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = 0;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
}
WorksheetCellFormatBlock.$t = markStruct(WorksheetCellFormatBlock, 'WorksheetCellFormatBlock');
/**
 * @hidden
 */
export class Worksheet_FontNameHeightPair extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.b = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
  equals(a) {
    if ((typeCast(Worksheet_FontNameHeightPair.$, a) !== null) == false) {
      return false;
    }
    let b = a;
    return this.b == b.b && this.a == b.a;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.b) ^ (this.a);
  }
}
Worksheet_FontNameHeightPair.$t = markStruct(Worksheet_FontNameHeightPair, 'Worksheet_FontNameHeightPair');
/**
 * @hidden
 */
export class CellSizeMeasurementContext extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.d = null;
    this.c = null;
    this.a = null;
    this.d = new Dictionary$2(WorksheetCellFormatData.$, Size.$, 0);
    this.a = new LfuCache$2(WorksheetCellFormatData.$, LfuCache$2.$.specialize(String_$type, Number_$type), 20, null);
    this.c = a;
    this.b = b;
  }
  e(a, b, c, d) {
    let e = a._b8;
    let f = CellSizeMeasurementContext.j(b);
    if (e) {
      return this.h(a, b, c, Math.max(d, 1), f);
    }
    else {
      let g = this.a.item(a);
      let h = g != null ? g.item(b) : 0;
      if (h == 0) {
        h = this.b._g(a, b, Nullable$1.toNullable(Size.$, null), true, f > 0).width;
        if (g == null) {
          g = new LfuCache$2(String_$type, Number_$type, 500, null);
          this.a.h(a, g);
        }
        g.h(b, h);
      }
      if (f > 0) {
        h += f * 8;
      }
      return h;
    }
  }
  k(a) {
    let b;
    b = this.b._d(a);
    return truncate(Workbook._ep(this.c, b, true));
  }
  l(a, b, c) {
    let d = this.f(a, b, c);
    return truncate(Math.ceil(Workbook._ep(this.c, d, true)));
  }
  static j(a) {
    let b = 0;
    let c = -1;
    while ((c = a.indexOf('\r', c + 1)) > 0) {
      b++;
    }
    c = -1;
    while ((c = a.indexOf('\n', c + 1)) > 0) {
      if (c == 0 || a.charAt(c - 1) != '\r') {
        b++;
      }
    }
    return b;
  }
  f(a, b, c) {
    try {
      return this.g(a, b, c);
    }
    catch (d) {
      return 20;
    }
  }
  m(a) {
    let b = new Size();
    if (((() => { let c = this.d.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      b = this.b._g(a, "0", Nullable$1.toNullable(Size.$, null), true, false);
      this.d.addItem(a, b);
    }
    return b;
  }
  g(a, b, c) {
    let d;
    d = this.b._d(a);
    let e = this.m(a);
    let f = this.b._g(a, b, Nullable$1.toNullable(Size.$, new Size(1, c, 0x7FFFFFFF)), true, false);
    let g = CellSizeMeasurementContext.i(f.height, e.height, d);
    if (g < f.height) {
      g = f.height;
    }
    return g;
  }
  h(a, b, c, d, e) {
    let f = Workbook._er(this.c, c, true, false);
    let g = d;
    let h = new Size(1, g, truncate(MathUtilities.f(f)));
    let i = this.m(a).height;
    let j = f / i;
    let k = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
    let l = k.height / i;
    if (k.height > f) {
      if (e == 0) {
        h.width = 0x7FFFFFFF;
        k = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
        if (j > 1) {
          g = truncate(Math.ceil(k.width / j));
          do {
            h.width = g;
            k = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
            g += 2;
          } while (k.height > f);
        }
      }
      else {
        let m = e + 1;
        if (m > j) {
        }
        else {
          h.width = 0x7FFFFFFF;
          k = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
          if (m == j) {
          }
          else {
            let n = g;
            let o = truncate(MathUtilities.f(k.width));
            l = k.height / i;
            while (n <= o) {
              g = n + (intDivide((o - n), 2));
              h.width = g;
              k = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
              l = k.height / i;
              if (l < j) {
                o = g - 1;
              }
              else if (l > j) {
                n = g + 1;
              }
              else {
                break;
              }
            }
            for (let p = truncate(MathUtilities.f(k.width)) - 1; p > n; p -= 2) {
              h.width = p;
              let q = this.b._g(a, b, Nullable$1.toNullable(Size.$, h), true, false);
              l = q.height / i;
              if (l != j) {
                break;
              }
              k = q;
            }
          }
        }
      }
    }
    return k.width;
  }
  static i(a, b, c) {
    return Math.round(a / b) * c;
  }
}
CellSizeMeasurementContext.$t = markType(CellSizeMeasurementContext, 'CellSizeMeasurementContext');
/**
 * @hidden
 */
export class CellDataContext extends Base {
  constructor(a, b, c, d, e, f) {
    super();
    this.c = null;
    this.i = null;
    this.k = false;
    this.q = 0;
    this.m = false;
    this.g = 0;
    this.e = new WorksheetCellBlock_CellValue();
    this.q = a;
    this.c = b;
    this.i = c;
    this.m = d;
    this.g = e;
    this.e = f;
  }
  get d() {
    return this.c;
  }
  get j() {
    return this.i;
  }
  set j(a) {
    if (a == null) {
      this.k = true;
    }
    else {
    }
    this.i = a;
  }
  get l() {
    return this.k;
  }
  get r() {
    return this.q;
  }
  get n() {
    return this.m;
  }
  get o() {
    return this.g != 0;
  }
  get h() {
    return this.g;
  }
  get f() {
    return this.e;
  }
  get p() {
    return this.g == 7 && this.e.a == 10;
  }
  s(a) {
    let b = this.g;
    if (b == 0 || this.c == null) {
      return null;
    }
    if (this.c.l(b, this.e)) {
      return this.c.y(a, this.q);
    }
    let c = this.c.ab(a, this.q, null, b, this.e);
    let d = typeCast(StringElement.$, c);
    if (d != null) {
      return d._y;
    }
    let e = typeCast(FormattedStringValueReference.$, c);
    if (e != null) {
      return e.e;
    }
    return c;
  }
  t(a) {
    let b = this.g;
    if (b == 0 || this.c == null) {
      return null;
    }
    return this.c.ab(a, this.q, null, b, this.e);
  }
  u() {
    this.c = null;
    this.i = null;
    CellDataContext.a = this;
  }
  static b(a, b, c, d, e, f) {
    let g = CellDataContext.a;
    if (g != null) {
      CellDataContext.a = null;
      g.q = a;
      g.c = b;
      g.i = c;
      g.m = d;
      g.e = f;
      g.g = e;
    }
    else {
      g = new CellDataContext(a, b, c, d, e, f);
    }
    return g;
  }
}
CellDataContext.$t = markType(CellDataContext, 'CellDataContext');
CellDataContext.a = null;
/**
 * @hidden
 */
export class WorksheetCellBlock extends Base {
  constructor(a) {
    super();
    this.v = 0;
    this.v = a;
  }
  static o(a, b) {
    switch (a) {
      case 0: return false;
      case 5:
      case 6: return true;
      case 7:
        {
          switch (b.a) {
            case 14:
            case 12:
            case 17:
            case 16: return true;
          }
          break;
        }
    }
    return false;
  }
  static q(a) {
    return a == null || StringUtilities.e.compare(a, "General") == 0;
  }
  static u(a) {
    if (typeCast(Date_$type, a) !== null) {
      return true;
    }
    return false;
  }
  static ax(a) {
    if (a == null || typeCast(ValueType.$, a) !== null) {
      return;
    }
    if (typeCast(Formula.$, a) !== null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSetFormulaDirectly"));
    }
    if (typeCast(WorksheetDataTable.$, a) !== null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSetDataTableDirectly"));
    }
    if ((typeCast(ErrorValue.$, a)) == ErrorValue.circularity) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantSetCircularityErrorDirectly"));
    }
  }
  static az(a, b, c) {
    let d = c.worksheet;
    if (d == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_RegionShiftedOffWorksheet"));
    }
    if ((typeCast(ArrayFormula.$, a) !== null) && c._u) {
    }
    else {
      for (let e of fromEnum(b)) {
        if (e.associatedTable != null) {
          a.throwExceptionWhenTableInRegion();
        }
      }
    }
    let f = new HashSet$1(IRegionBlockingValue_$type, 0);
    let g = new HashSet$1(IRegionBlockingValue_$type, 0);
    for (let h = c.firstRow; h <= c.lastRow; h++) {
      let i = d._rows$i.item(h);
      for (let j = c._v; j <= c._w; j++) {
        if (d._cr(h, j) != null) {
          a.throwExceptionWhenMergedCellsInRegion();
        }
        let k = typeCast(IRegionBlockingSingleCellComponent_$type, i._c6(j));
        if (k != null && k.owningValue != a && f.add_1(k.owningValue)) {
          let l = k.owningValue.blockedRegion;
          if (l != null) {
            if (c._o(l)) {
              g.add_1(k.owningValue);
            }
            else {
              k.owningValue.throwBlockingException();
            }
          }
        }
      }
    }
    for (let m of fromEnum(g)) {
      m.removeFromRegion();
    }
  }
  static a0(a) {
    if (a == null || typeof a === 'number' || ExcelUtils.bg(getInstanceType(a))) {
      return;
    }
    let b = 0;
    let c = typeCast(String_$type, a);
    if (c != null) {
      b = c.length;
    }
    else {
      let d = typeCast(FormattedString.$, a);
      if (d != null) {
        b = d._t;
      }
      else {
        let e = typeCast(StringElement.$, a);
        if (e != null) {
          b = e._w;
        }
        else {
          let f = typeCast(StringBuilder.$, a);
          if (f != null) {
            b = f.c;
          }
        }
      }
    }
    let g = 32767;
    if (g < b) {
      throw new ArgumentException(1, stringFormat(ExcelUtils.ef("LE_ArgumentException_CellValueStringLength"), g));
    }
  }
  aj(a, b) {
    let c;
    let d = this.as(a, b, false, c);
    c = d.p3;
    let e = this.ao(a, b, null, c);
    c = e.p3;
  }
  i(a, b) {
    if (this.j(b)) {
      return true;
    }
    let c = a._a8(b);
    if (c != null) {
      let d = a.worksheet.workbook;
      if (d == null || c._ca(d._ca._p) == false) {
        return true;
      }
    }
    return false;
  }
  j(a) {
    return this.f(a) != 0;
  }
  k(a, b, c) {
    let d = this.am(a, b, c);
    b = d.p1;
    c = d.p2;
    return {
      ret: b != 0,
      p1: b,
      p2: c
    };
  }
  m(a) {
    let b;
    let c = new WorksheetCellBlock_CellValue();
    return ((() => { let d = this.n(a, b, c); b = d.p1; c = d.p2; return d.ret; })());
  }
  n(a, b, c) {
    let d = this.am(a, b, c);
    b = d.p1;
    c = d.p2;
    return {
      ret: this.l(b, c),
      p1: b,
      p2: c
    };
  }
  l(a, b) {
    return a == 7 && b.a == 10;
  }
  y(a, b, c = true) {
    let d = a._at(b);
    if (d != null) {
      d._bf();
    }
    if (d != null) {
      if (d._formula != null) {
        let e = d._formula._cd;
        if (e != null) {
          return CalcUtilities.m(e.value, c);
        }
      }
    }
    return null;
  }
  b(a, b, c) {
    let d;
    if (nullableEquals(c.g, false) && this.m(c.e)) {
      let e = a._ar(c.e);
      if (e != null) {
        return new GetCellTextResult(1, e._toString1(a.worksheet._c));
      }
    }
    d = this.z(a, c.e);
    return WorksheetCellBlock.a(a.worksheet, a, b, c, d);
  }
  static a(a, b, c, d, e) {
    if (e == null) {
      return new GetCellTextResult(1, "");
    }
    let f = WorksheetCellBlock.ah(e);
    if (ExcelUtils.bw(d.a, 1) && WorksheetCellBlock.s(e)) {
      return new GetCellTextResult(1, f);
    }
    let g = a.workbook;
    let h = NaN;
    let i;
    if (((() => { let j = ExcelUtils.b0(g, e, i); i = j.p2; return j.ret; })())) {
      h = i;
    }
    let j;
    let k = null;
    let l = false;
    if (a.displayOptions.showFormulasInCells) {
      l = true;
      d.b = 1;
      if (g != null) {
        j = g._b2.a(0);
      }
      else {
        j = new ValueFormatter(0, g, "General", a._y);
      }
    }
    else {
      k = a._b4(b, d.e);
      let m = a._be(c, d.e, true);
      let n = m != null && m._h != null ? m._h.formatString : null;
      if (n != null) {
        j = new ValueFormatter(0, g, n, a._y);
      }
      else if (g != null) {
        j = g._b2.a(k._cs);
      }
      else {
        j = new ValueFormatter(0, g, k._dg, a._y);
      }
    }
    if (j.o == false) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_InvalidFormatString_GetTextCall"));
    }
    let o = -1;
    if (d.b == 1) {
      k = null;
    }
    else {
      let p = b != null ? b._bl(d.e) : null;
      let q = 0;
      if (p != null) {
        for (let r = p._v; r <= p._w; r++) {
          q += a._fp(r);
        }
        k = p._cellFormatInternal.d;
      }
      else {
        if (k == null) {
          k = a._b4(b, d.e);
        }
        q = a._fp(d.e);
        if (k._a4 == 6) {
          let s = (d.e + 1);
          while (s < a._columns$i.maxCount) {
            if (a._b4(b, s)._a4 != 6 || (b != null && b._c6(s) != null)) {
              break;
            }
            q += a._fp(s);
            s++;
          }
        }
      }
      q -= d.f;
      o = Math.max(0, truncate(q) - a._ge());
    }
    let t = false;
    let u;
    if (k == null) {
      u = null;
    }
    else {
      if (d.d != null) {
        u = d.d();
        t = true;
      }
      else {
        u = g != null ? g._bq : null;
        if (u == null) {
          t = true;
          u = Workbook._br(g);
        }
      }
    }
    try {
      return j.h(h, f, e, o, u, k, l, d.c);
    }
    finally {
      if (u != null && t) {
        u.dispose();
      }
    }
  }
  z(a, b) {
    let c;
    let d = new WorksheetCellBlock_CellValue();
    if (((() => { let e = this.n(b, c, d); c = e.p1; d = e.p2; return e.ret; })())) {
      return this.y(a, b);
    }
    let e = this.ab(a, b, null, c, d);
    let f = typeCast(StringElement.$, e);
    if (f != null) {
      return f._y;
    }
    let g = typeCast(FormattedStringValueReference.$, e);
    if (g != null) {
      return g.e;
    }
    return e;
  }
  c(a, b) {
    let c;
    let d = new WorksheetCellBlock_CellValue();
    let e = this.am(b, c, d);
    c = e.p1;
    d = e.p2;
    if (c != 6) {
      return null;
    }
    return this.d(a, b, d);
  }
  ai(a, b, c, d) {
    if (c != 7) {
      return null;
    }
    if (d.a != 12) {
      return null;
    }
    return typeCast(StringBuilder.$, this.ag(a, b));
  }
  ac(a, b, c, d) {
    let e = this.am(b, c, d);
    c = e.p1;
    d = e.p2;
    return {
      ret: this.ab(a, b, null, c, d),
      p2: c,
      p3: d
    };
  }
  aa(a, b, c = null) {
    let d;
    let e = new WorksheetCellBlock_CellValue();
    let f = this.am(b, d, e);
    d = f.p1;
    e = f.p2;
    return this.ab(a, b, c, d, e);
  }
  ab(a, b, c, d, e) {
    let f = c != null;
    let g = this.ad(a, b, f, d, e);
    if (f) {
      let h = typeCast(FormattedStringValueReference.$, g);
      if (h != null) {
        return this.ae(a, b, h);
      }
      let i = typeCast(StringBuilder.$, g);
      if (i != null) {
        return StringElementIndex.b(c._as.item(i));
      }
      if (typeCast(Date_$type, g) !== null) {
        let j = ExcelCalcValue._dateTimeToExcelDate(c._b, g);
        if (j.hasValue) {
          return unwrapNullable(j);
        }
        return 0;
      }
    }
    return g;
  }
  ad(a, b, c, d, e) {
    switch (d) {
      case 0: return null;
      case 1: return e.i;
      case 2: return e.i;
      case 3: return e.b;
      case 4:
        {
          return dateFromTicks(e.i);
        }
      case 5:
        if (c) {
          return this.af(a, b, e);
        }
        return this.d(a, b, e);
      case 6:
        {
          if (c) {
            return this.af(a, b, e);
          }
          let f = this.d(a, b, e);
          if (f != null) {
            let g = new FormattedString(a.worksheet.workbook, f, true, false);
            g._setOwningCell(a, b);
            return g;
          }
          return null;
        }
      case 7:
        {
          switch (e.a) {
            case 0: return e.g;
            case 1: return e.g;
            case 2: return e.g;
            case 3: return e.g;
            case 4: return e.g;
            case 5: return e.g;
            case 6: return e.f;
            case 7: return e.g != 0;
            case 9: return ErrorValue._j(e.g);
            case 10:
              let h = a._as(b)._formula;
              return h;
            case 11:
            case 12: return this.ag(a, b);
            case 14:
            case 15:
            case 16:
            case 17: return this.ag(a, b);
            default: return null;
          }
        }
      default: return null;
    }
  }
  static ah(a) {
    if (a == null) {
      return stringEmpty();
    }
    if (typeCast(Boolean_$type, a) !== null) {
      return a.toString().toUpperCase();
    }
    return a.toString();
  }
  g(a, b, c, d) {
    d = null;
    if (c == false) {
      return {
        ret: 0,
        p3: d
      };
    }
    for (let e of fromEnum(a.worksheet._tables$i)) {
      if (e._ce(a, b) == false) {
        continue;
      }
      let f = e.headerRowRegion;
      if (f != null && f._p(a, b)) {
        d = e;
        return {
          ret: 1,
          p3: d
        };
      }
      let g = e.totalsRowRegion;
      if (g != null && g._p(a, b)) {
        d = e;
        return {
          ret: 2,
          p3: d
        };
      }
    }
    return {
      ret: 0,
      p3: d
    };
  }
  p(a, b) {
    let c;
    let d = new WorksheetCellBlock_CellValue();
    let e = this.am(b, c, d);
    c = e.p1;
    d = e.p2;
    return WorksheetCellBlock.o(c, d);
  }
  static s(a) {
    if (a == null) {
      return false;
    }
    return typeof a === 'string' || typeCast(FormattedString.$, a) !== null || typeCast(StringElement.$, a) !== null || typeCast(FormattedStringValueReference.$, a) !== null || typeCast(String_$type, a) !== null || typeCast(Guid.$, a) !== null || typeCast(StringBuilder.$, a) !== null || ExcelUtils.a3(getInstanceType(a));
  }
  as(a, b, c, d, e = true) {
    if (c == false) {
      d = null;
    }
    else if (((() => { let f = this.h(d); d = f.p0; return f.ret; })())) {
      a._dw(b, d);
      let f;
      let g = d.as(a, b, c, f);
      f = g.p3;
      return {
        p3: d
      };
    }
    let h = this.r(b);
    if (h == c) {
      return {
        p3: d
      };
    }
    this.at(b, c);
    if (e) {
      let i;
      let j = ((() => { let k = this.g(a, b, c, i); i = k.p3; return k.ret; })());
      if (j == 0) {
        return {
          p3: d
        };
      }
      if (j == 2 && this.m(b)) {
        return {
          p3: d
        };
      }
      let k = this.z(a, b);
      if (typeof k === 'string') {
        return {
          p3: d
        };
      }
      if (j == 2 && k == null) {
        return {
          p3: d
        };
      }
      let l = this.ao(a, b, k, d, false, true);
      d = l.p3;
    }
    return {
      p3: d
    };
  }
  ao(a, b, c, d, e = true, f = false) {
    d = null;
    let g;
    let h = new WorksheetCellBlock_CellValue();
    let i = this.am(b, g, h);
    g = i.p1;
    h = i.p2;
    let j = this.ad(a, b, false, g, h);
    if (f == false) {
      if (Base.equalsStatic(c, j)) {
        return {
          p3: d
        };
      }
      if (typeof c === 'string') {
        let k = typeCast(StringElement.$, j);
        if (k != null && k._u == false && k._y == c) {
          return {
            p3: d
          };
        }
      }
    }
    let l = a._bl(b);
    if (l != null && (l.firstRow != a.index || l.firstColumn != b)) {
      return {
        p3: d
      };
    }
    let m;
    let n = ((() => { let o = this.g(a, b, this.r(b), m); m = o.p3; return o.ret; })());
    if (n != 0) {
      c = this.x(a, b, c, n);
    }
    let o = false;
    let p = a.worksheet.workbook;
    if (p != null) {
      o = p._c4;
    }
    if (!o) {
      this.ay(a, b, j, c, e);
    }
    let q = p != null && p._c9 && !p._c4;
    let r = null;
    let s = a.worksheet;
    if (q && g == 7 && h.a == 10 && j._as) {
      if (s != null) {
        r = WorksheetCellLocation.c.b(p, s, WorksheetCellLocation.c.c);
      }
    }
    let t = this.ap(a, b, c, j, g, h, d);
    d = t.p6;
    if (o == false) {
      if (c != null && a.worksheet._cb(b).b._cd == false) {
        a._bc(b);
      }
      if (WorksheetCellBlock.u(c)) {
        let u;
        if (((() => { let v = WorksheetCellBlock.t(a, b, u); u = v.p2; return v.ret; })())) {
          if (u == null) {
            u = a._bc(b);
          }
          let v = a.worksheet._y.dateTimeFormat;
          if (typeCast(Date_$type, c) !== null) {
            let w = c;
            if (timeSpanTotalHours(dateGetTimeOfDay(w)) != 0) {
              u.formatString = WorkbookFormatCollection.ae(a.worksheet._y);
            }
            else {
              u.formatString = WorkbookFormatCollection.af(a.worksheet._y);
            }
          }
        }
      }
      if ((typeof c === 'string' || typeCast(FormattedString.$, c) !== null || typeCast(StringElement.$, c) !== null) && a.worksheet._eh == false) {
        let x = c.toString();
        if (x.indexOf('\n') >= 0) {
          let y = a._bc(b);
          if (nullableEquals(y._wrapText$i, null)) {
            y._wrapText$i = Nullable$1.toNullable(Boolean_$type, true);
          }
        }
      }
      if (ExcelUtils.a9(c) && a.worksheet._eh == false) {
        let z = a.worksheet._hyperlinks$i;
        for (let aa = z.count - 1; aa >= 0; aa--) {
          if (z.item(aa).sourceRegion._p(a, b)) {
            z._s(aa, false);
          }
        }
      }
    }
    if (m != null && n == 1) {
      m._dz();
    }
    if (s != null) {
      s.workbook._il(a, b);
      if (q) {
        let ab = new WorksheetCellLocation(1, a, b);
        WorksheetCellLocation.c.x(ab, j, c);
        if (r != null) {
          WorksheetCellLocation.c.d(p, r);
        }
      }
    }
    return {
      p3: d
    };
  }
  ap(a, b, c, d, e, f, g, h = false) {
    if (c == null) {
      g = null;
    }
    else if (((() => { let i = this.h(g); g = i.p0; return i.ret; })())) {
      a._dw(b, g);
      let i;
      let j = g.ap(a, b, c, d, e, f, i, h);
      i = j.p6;
      return {
        p6: g
      };
    }
    if (d != null) {
      this.ak(a, b, e, f);
      let k = typeCast(IWorksheetCellOwnedValue_$type, d);
      if (k != null) {
        if (k.isOwnedByAllCellsAppliedTo) {
          k.setOwningCell(null, -1);
        }
      }
      else {
        let l = typeCast(StringElement.$, d);
        if (l == null) {
          let m = typeCast(FormattedStringValueReference.$, d);
          if (m != null) {
            l = m.c;
          }
        }
        if (l != null) {
          GenericCacheElement.m(StringElement.$, l, a._au);
        }
      }
      if (h == false) {
        let n = typeCast(Formula.$, d);
        if (n != null && n._ai) {
          a.worksheet._ii(a, b);
        }
      }
    }
    this.aw(a, b, c, e, f);
    let o = typeCast(IWorksheetCellOwnedValue_$type, c);
    if (o != null && o.isOwnedByAllCellsAppliedTo) {
      o.setOwningCell(a, b);
    }
    a._ed(b, c, true, h);
    return {
      p6: g
    };
  }
  av(a, b) {
    let c = new WorksheetCellBlock_CellValue();
    c.j(b);
    this.an(a, c, false);
  }
  aw(a, b, c, d, e) {
    let f = 0;
    let g = new WorksheetCellBlock_CellValue();
    if (c != null) {
      if (typeof c === 'number') {
        f = 3;
        g.b = c;
      }
      else {
        let h = a.worksheet.workbook;
        let i;
        let j = typeCast(String_$type, c);
        if (j != null) {
          j = ExcelUtils.eb(j);
          i = StringElement._r(j);
        }
        else {
          i = typeCast(StringElement.$, c);
        }
        if (i != null) {
          f = 5;
          if (h == null) {
            if (i.f > 0) {
              i = i.g(null);
            }
            this.au(a, b, i);
          }
          else {
            let k = i;
            i = GenericCacheElement.a(StringElement.$, i, h._bj);
            g.j(i);
            if (k != i && k != c) {
              k._ab();
            }
          }
        }
        else {
          let l = typeCast(FormattedString.$, c);
          if (l != null) {
            f = 6;
            if (h == null) {
              this.au(a, b, l._m);
            }
            else {
              l._z(h._bj);
              g.j(l._m);
            }
          }
          else {
            let m = typeCast(SingleTargetFormula.$, c);
            if (m != null) {
              f = 7;
              g.a = 10;
            }
            else if (typeof c === 'number') {
              f = 7;
              g.a = 4;
              g.g = intSToU(typeGetValue(c));
            }
            else if (typeCast(Boolean_$type, c) !== null) {
              f = 7;
              g.a = 7;
              g.g = c ? 1 : 0;
            }
            else {
              let n = typeCast(ErrorValue.$, c);
              if (n != null) {
                f = 7;
                g.a = 9;
                g.g = n._y;
              }
              else if (typeCast(Date_$type, c) !== null) {
                let o = c;
                let p = ExcelCalcValue._dateTimeToExcelDate(h, o);
                if (p.hasValue) {
                  f = 4;
                  g.i = o.getTime();
                }
                else {
                  f = 7;
                  g.a = 15;
                  this.au(a, b, new FormattedStringValueReference(c, h));
                }
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 6;
                g.f = c;
              }
              else if (typeof c === 'number') {
                f = 1;
                g.i = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 0;
                g.g = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 1;
                g.g = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 2;
                g.g = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 3;
                g.g = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 5;
                g.g = typeGetValue(c);
              }
              else if (typeof c === 'number') {
                f = 2;
                g.i = typeGetValue(c);
              }
              else if (typeCast(String_$type, c) !== null) {
                f = 7;
                g.a = 14;
                this.au(a, b, new FormattedStringValueReference(c, h));
              }
              else if (typeof c === 'number') {
                f = 7;
                g.a = 11;
                this.au(a, b, c);
              }
              else if (typeCast(Guid.$, c) !== null) {
                f = 7;
                g.a = 17;
                this.au(a, b, new FormattedStringValueReference(c, h));
              }
              else if (ExcelUtils.a3(getInstanceType(c))) {
                f = 7;
                g.a = 16;
                this.au(a, b, new FormattedStringValueReference(c, h));
              }
              else {
                let q = typeCast(StringBuilder.$, c);
                if (q != null) {
                  f = 7;
                  g.a = 12;
                  this.au(a, b, c);
                }
                else {
                }
              }
            }
          }
        }
      }
    }
    this.ar(b, f, g);
    if (d == 0 || f == 0) {
      a._dh();
    }
    if (a._b0 && (WorksheetCellBlock.o(d, e) || WorksheetCellBlock.o(f, g))) {
      let r = a.worksheet._b4(a, b);
      if (r._b8) {
        a._dx();
      }
    }
  }
  ay(a, b, c, d, e) {
    if (d != null) {
      let f = true;
      if (getInstanceType(d) == null) {
        f = false;
      }
      if (!f) {
        throw new NotSupportedException(1, ExcelUtils.eg("LE_NotSupportedException_CellType", d));
      }
    }
    WorksheetCellBlock.a0(d);
    if (e) {
      let g = typeCast(IRegionBlockingSingleCellComponent_$type, c);
      if (g != null) {
        let h = g.owningValue.blockedRegion;
        if (h.firstRow == h.lastRow && h.firstColumn == h.lastColumn) {
          g.owningValue.removeFromRegion();
        }
        else {
          g.owningValue.throwBlockingException();
        }
      }
    }
    if (d != null && WorksheetCell.isCellTypeSupported(getInstanceType(d)) == false) {
      throw new NotSupportedException(1, ExcelUtils.eg("LE_NotSupportedException_CellType", getInstanceType(d)));
    }
    let i = typeCast(IWorksheetCellOwnedValue_$type, d);
    if (i != null) {
      i.verifyNewOwner(a, b);
    }
  }
  ak(a, b, c, d) {
    if (c != 7) {
      return;
    }
    switch (d.a) {
      case 11:
      case 12:
      case 14:
      case 15:
      case 16:
      case 17:
        a.worksheet._ew.removeItem(ValueTuple.a(WorksheetRow.$, Number_$type, a, b));
        break;
      default: break;
    }
  }
  x(a, b, c, d) {
    if (d == 0) {
      return c;
    }
    if (typeCast(Formula.$, c) !== null || typeCast(WorksheetDataTable.$, c) !== null) {
      if (d == 2) {
        return c;
      }
      if (d == 1) {
        c = 0;
      }
      else {
        c = null;
      }
    }
    let e = new GetCellTextParameters(b);
    e.b = 1;
    switch (d) {
      case 2:
        if (typeCast(FormattedString.$, c) !== null && a.worksheet != null) {
          let f = a.worksheet._b4(a, b).formatString;
          if (f == null || StringUtilities.e.equalsC(f, "General")) {
            return c;
          }
        }
        e.a = 0;
        return WorksheetCellBlock.a(a.worksheet, a, a.index, e, c).g;
      case 1:
        if (c == null) {
          return null;
        }
        if (typeCast(FormattedString.$, c) !== null) {
          return c;
        }
        e.a = 1;
        return WorksheetCellBlock.a(a.worksheet, a, a.index, e, c).g;
      default: return c;
    }
  }
  d(a, b, c) {
    let d = a.worksheet.workbook;
    if (d == null) {
      return typeCast(StringElement.$, this.ag(a, b));
    }
    return d._bj._o(c.c, c.h);
  }
  af(a, b, c) {
    let d = a.worksheet.workbook;
    if (d == null) {
    }
    return StringElementIndex.b(d._bj._r(c.c, c.h));
  }
  ae(a, b, c) {
    let d = a.worksheet.workbook;
    if (d == null) {
    }
    let e = HashHelpers.d(c.c);
    return StringElementIndex.b(d._bj._r(e, c.c._aa));
  }
  ag(a, b) {
    if (a.worksheet._d3 == false) {
      return null;
    }
    let c;
    if (((() => { let d = a.worksheet._ew.tryGetValue(ValueTuple.a(WorksheetRow.$, Number_$type, a, b), c); c = d.p1; return d.ret; })())) {
      return c;
    }
    return null;
  }
  au(a, b, c) {
    a.worksheet._ew.item(ValueTuple.a(WorksheetRow.$, Number_$type, a, b), c);
  }
  static t(a, b, c) {
    if (WorksheetCellBlock.q(a._a7(b)._dg)) {
      c = a._bc(b);
      return {
        ret: true,
        p2: c
      };
    }
    c = null;
    return {
      ret: false,
      p2: c
    };
  }
  get w() {
    return this.v;
  }
}
WorksheetCellBlock.$t = markType(WorksheetCellBlock, 'WorksheetCellBlock');
/**
 * Represents a merged region of cells, or cells which share a value and format and appear as one cell when
 * viewed in Microsoft Excel.
 * <p class="body">
 * Merged cell regions cannot overlap (a cell can only belong to one merged cell region). In addition,
 * [[ArrayFormula]] and [[WorksheetDataTable]] instances cannot be applied to merged cell
 * regions.
 * </p>
 */
export class WorksheetMergedCellsRegion extends WorksheetRegion {
  constructor(a, b, c, d, e) {
    super(a, b, c, d, e, false);
    this._au = null;
    this._ay = true;
  }
  /**
   * @hidden
   */
  get cellFormatInternal() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  get hasCellFormat() {
    return this._hasCellFormat;
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return null;
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
    if (this.worksheet == null) {
      return;
    }
    if ((options & 4) != 0) {
      return;
    }
    let a = 2;
    if (this == WorksheetMergedCellsRegion._aw || (options & 64) != 0) {
      a |= 64;
    }
    let b = this.worksheet.workbook;
    if (b != null && b._c4) {
      return;
    }
    let c = ExcelUtils.a(values, true);
    let d = (values & ~208404486) == 0;
    let e = d && (values & ~201326598) == 0;
    let f = d && (values & ~201326598) == values;
    let g = (values & ~208404486) == values;
    let h = this._cellFormatInternal;
    let i = this.firstRow;
    let j = this.lastRow;
    let k = this._v;
    let l = this._w;
    for (let m = i; m <= j; m++) {
      if (e && m == i + 1) {
        m = j;
      }
      let n = this.worksheet._rows$i.item(m);
      for (let o = k; o <= l; o++) {
        if (d && o == k + 1) {
          if (f || (m > i && m < j)) {
            o = l;
          }
        }
        let p;
        if (g) {
          p = n._bd(o);
          if (p == null) {
            continue;
          }
        }
        else {
          p = n._bc(o);
        }
        let q = p.a();
        for (let r = 0; r < c.length; r++) {
          let s = c[r];
          switch (s) {
            case 2:
            case 4:
              if (m == j) {
                p._bl(s, h._aj(s), false, a);
              }
              break;
            case 67108864:
            case 134217728:
              if (m == i) {
                p._bl(s, h._aj(s), false, a);
              }
              break;
            case 262144:
            case 524288:
              if (o == k) {
                p._bl(s, h._aj(s), false, a);
              }
              break;
            case 2097152:
            case 4194304:
              if (o == l) {
                p._bl(s, h._aj(s), false, a);
              }
              break;
            case 32640:
              p._a1(h._u, false, a);
              break;
            default:
              p._bl(s, h._aj(s), false, a);
              break;
          }
        }
        p.g(q);
      }
    }
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
  }
  /**
   * @hidden
   */
  _aj(a, b, c, d = 0) {
    let e = this._k;
    if (e == null) {
      return {
        p1: b,
        p2: c
      };
    }
    if (b == null) {
      b = e;
      c = this._v;
    }
    a._bq(b, c, e, this._v, d);
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _d(a, b) {
    let c = this._h;
    let d = super._d(a, b);
    if (d.f && d.g == false) {
      this._a6(c);
    }
    return d;
  }
  /**
   * @hidden
   */
  _al(a) {
    let b = this._h;
    super._al(a);
    this._a6(b);
  }
  /**
   * @hidden
   */
  static _a3(a, b, c, d) {
    let e = 0;
    let f = WorksheetMergedCellsRegion._a4(a, e, b, c, e, d);
    c = f.p3;
    e = f.p4;
    d = f.p5;
    return {
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  static _a4(a, b, c, d, e, f) {
    if (WorkbookColorInfo.l_op_Equality(d, null)) {
      d = a;
      e = b;
      f = c;
    }
    else if (WorkbookColorInfo.l_op_Inequality(d, a) || e != b || f != c) {
      d = WorkbookColorInfo.automatic;
      e = 1;
      f = 0;
    }
    return {
      p3: d,
      p4: e,
      p5: f
    };
  }
  /**
   * @hidden
   */
  _a1(a, b) {
    return WorksheetMergedCellsRegion._a0(this.worksheet, this._h, a, b);
  }
  /**
   * @hidden
   */
  static _a0(a, b, c, d) {
    let e = new Dictionary$2(CellFormatValue_$type, Base.$, 0);
    if (a == null) {
      return e;
    }
    let f = a._o;
    let g = a._rows$i.item(b._ac);
    let h = a._rows$i.item(b._ae);
    let i = b._w;
    let j = b._x;
    if (nullableEquals(c, null) || nullableEquals(c, 67108864) || nullableEquals(c, 134217728)) {
      let k = (d && b._ac > 0) ? a._rows$i._aj(b._ac - 1) : null;
      if (nullableEquals(c, null) || nullableEquals(c, 67108864)) {
        WorksheetMergedCellsRegion._ba(a, b, e, g, k, g, i, 67108864);
      }
      if (nullableEquals(c, null) || nullableEquals(c, 134217728)) {
        WorksheetMergedCellsRegion._ba(a, b, e, g, k, g, i, 134217728);
      }
    }
    if (nullableEquals(c, null) || nullableEquals(c, 2) || nullableEquals(c, 4)) {
      let l = (d && (b._ae + 1) < Workbook.getMaxRowCount(f)) ? a._rows$i._aj(b._ae + 1) : null;
      if (nullableEquals(c, null) || nullableEquals(c, 2)) {
        WorksheetMergedCellsRegion._ba(a, b, e, h, l, h, i, 2);
      }
      if (nullableEquals(c, null) || nullableEquals(c, 4)) {
        WorksheetMergedCellsRegion._ba(a, b, e, h, l, h, i, 4);
      }
    }
    if (nullableEquals(c, null) || nullableEquals(c, 262144) || nullableEquals(c, 524288) || nullableEquals(c, 2097152) || nullableEquals(c, 4194304)) {
      let m = ((d && b._w > 0) ? b._w - 1 : -1);
      let n = ((d && (b._x + 1) < Workbook.getMaxColumnCount(f)) ? b._x + 1 : -1);
      if (nullableEquals(c, null) || nullableEquals(c, 262144)) {
        WorksheetMergedCellsRegion._bb(a, b, e, b._w, m, g, i, 262144);
      }
      if (nullableEquals(c, null) || nullableEquals(c, 524288)) {
        WorksheetMergedCellsRegion._bb(a, b, e, b._w, m, g, i, 524288);
      }
      if (nullableEquals(c, null) || nullableEquals(c, 2097152)) {
        WorksheetMergedCellsRegion._bb(a, b, e, b._x, n, g, j, 2097152);
      }
      if (nullableEquals(c, null) || nullableEquals(c, 4194304)) {
        WorksheetMergedCellsRegion._bb(a, b, e, b._x, n, g, j, 4194304);
      }
    }
    return e;
  }
  /**
   * Gets the resolved cell formatting for this merged cell region.
   * <p class="body">
   * If any cell format properties are the default values on the merged cell region, the values from the owning row's cell format will be used.
   * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
   * will be used.
   * </p>
   * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
   * @see [[cellFormat]]
   * @see [[RowColumnBase.cellFormat]]
   */
  getResolvedCellFormat() {
    return new WorksheetMergedCellFormatDataResolved(this);
  }
  /**
   * @hidden
   */
  _a5(a) {
    let b = this.firstRow;
    let c = this.firstColumn;
    let d = this.lastRow;
    let e = this.lastColumn;
    let f = null;
    let g = -1;
    let h = null;
    let i = 0;
    let j = -1;
    let k = null;
    let l = -1;
    let m = null;
    let n = -1;
    let o = null;
    let p = -1;
    let q = this._k;
    let r = q._bc(this._v).d._bu();
    let s = null;
    let t = this.worksheet;
    if (!a) {
      let u = new WorksheetCellFormatDataResolved(null);
      for (let v = b; v <= d; v++) {
        let w = t._rows$i.item(v);
        for (let x = c; x <= e; x++) {
          let y = w._bc(x);
          u._m(y);
          if (s == null) {
            s = w._c6(x);
            if (s != null) {
              r = y.d._bu();
            }
          }
          if (v == b) {
            let z = WorksheetMergedCellsRegion._a3(u.topBorderColorInfo, u.topBorderStyle, o, p);
            o = z.p2;
            p = z.p3;
          }
          if (v == d) {
            let aa = WorksheetMergedCellsRegion._a3(u.bottomBorderColorInfo, u.bottomBorderStyle, f, g);
            f = aa.p2;
            g = aa.p3;
          }
          if (x == c) {
            let ab = WorksheetMergedCellsRegion._a3(u.leftBorderColorInfo, u.leftBorderStyle, k, l);
            k = ab.p2;
            l = ab.p3;
          }
          if (x == e) {
            let ac = WorksheetMergedCellsRegion._a3(u.rightBorderColorInfo, u.rightBorderStyle, m, n);
            m = ac.p2;
            n = ac.p3;
          }
          let ad = WorksheetMergedCellsRegion._a4(u.diagonalBorderColorInfo, u.diagonalBorders, u.diagonalBorderStyle, h, i, j);
          h = ad.p3;
          i = ad.p4;
          j = ad.p5;
        }
      }
    }
    let ae = t.workbook;
    let af = ae == null || ae._c4 == false;
    let ag = t._eh;
    try {
      t._eh = true;
      for (let ah = b; ah <= d; ah++) {
        let ai = t._rows$i.item(ah);
        for (let aj = c; aj <= e; aj++) {
          ai._d9(aj, this);
          if (af == false) {
            continue;
          }
          if (!a) {
            let ak = ai._bc(aj);
            ak.style = r.style;
            ak.formatOptions = 0;
          }
        }
      }
      let al = t._hyperlinks$i;
      for (let am = al.count - 1; am >= 0; am--) {
        let an = al.item(am).sourceRegion;
        if (this._o(an)) {
          if (an.firstRow != this.firstRow || an._v != this._v) {
            al.removeAt(am);
          }
        }
      }
    }
    finally {
      t._eh = ag;
    }
    if (a) {
      this._ay = true;
      if (this._au != null) {
        this._au.h(this.worksheet.workbook._ca);
      }
      return;
    }
    let ao = this._cellFormatInternal;
    ao.setFormatting(r);
    let ap = true;
    if (ExcelUtils.bx(ao.formatOptions, 8)) {
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bf, f) || ao.d._al != g || WorkbookColorInfo.l_op_Inequality(ao.d._bg, h) || ao.d._aw != i || ao.d._am != j || WorkbookColorInfo.l_op_Inequality(ao.d._bk, k) || ao.d._an != l || WorkbookColorInfo.l_op_Inequality(ao.d._bl, m) || ao.d._ao != n || WorkbookColorInfo.l_op_Inequality(ao.d._bm, o) || ao.d._ap != p) {
        ao.formatOptions &= ~8;
      }
      else {
        ap = false;
      }
    }
    if (ap) {
      if (ao.d._al != g) {
        ao.bottomBorderStyle = g;
      }
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bf, f)) {
        ao.bottomBorderColorInfo = f;
      }
      if (ao.d._am != j) {
        ao.diagonalBorderStyle = j;
      }
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bg, h)) {
        ao.diagonalBorderColorInfo = h;
      }
      if (ao.d._aw != i) {
        ao.diagonalBorders = i;
      }
      if (ao.d._an != l) {
        ao.leftBorderStyle = l;
      }
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bk, k)) {
        ao.leftBorderColorInfo = k;
      }
      if (ao.d._ao != n) {
        ao.rightBorderStyle = n;
      }
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bl, m)) {
        ao.rightBorderColorInfo = m;
      }
      if (ao.d._ap != p) {
        ao.topBorderStyle = p;
      }
      if (WorkbookColorInfo.l_op_Inequality(ao.d._bm, o)) {
        ao.topBorderColorInfo = o;
      }
    }
    q._d6(this._v, s);
  }
  /**
   * @hidden
   */
  _a6(a) {
    if (this.worksheet != null) {
      for (let b = a._ac; b <= a._ae; b++) {
        let c = this.worksheet._rows$i.item(b);
        for (let d = a._w; d <= a._x; d++) {
          c._dz(d, null);
        }
      }
      let e = this._h;
      for (let f = e._ac; f <= e._ae; f++) {
        let g = this.worksheet._rows$i.item(f);
        for (let h = e._w; h <= e._x; h++) {
          g._dz(h, this);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _a7(a, b, c) {
    switch (c) {
      case 2:
      case 4:
        if (a.index != this.lastRow) {
          return;
        }
        break;
      case 262144:
      case 524288:
        if (b != this.firstColumn) {
          return;
        }
        break;
      case 2097152:
      case 4194304:
        if (b != this.lastColumn) {
          return;
        }
        break;
      case 67108864:
      case 134217728:
        if (a.index != this.firstRow) {
          return;
        }
        break;
    }
    let d = this._a1(Nullable$1.toNullable(CellFormatValue_$type, c), false);
    this._cellFormatInternal._bl(c, d.item(c), true, 4);
  }
  /**
   * @hidden
   */
  _a8() {
    if (this.worksheet == null) {
      return;
    }
    for (let a = this.firstRow; a <= this.lastRow; a++) {
      let b = this.worksheet._rows$i.item(a);
      for (let c = this._v; c <= this._w; c++) {
        b._d9(c, null);
      }
    }
    this._ay = false;
    if (this._au != null) {
      this._au.i();
    }
  }
  /**
   * @hidden
   */
  _a9() {
    if (this.worksheet == null) {
      return;
    }
    for (let a of fromEnum(this.worksheet._rows$i._m(this.firstRow, this.lastRow))) {
      a._dx();
    }
  }
  /**
   * @hidden
   */
  static _ba(a, b, c, d, e, f, g, h) {
    let i = ExcelUtils.dz(a, f, g, e, b._w, h);
    let j = ExcelUtils.d0(d, e, h);
    let k = i;
    if (WorksheetCellFormatData._cf(h, k)) {
      k = j;
    }
    if (WorksheetCellFormatData._cf(h, k) == false) {
      for (let l = (b._w + 1); l <= b._x; l++) {
        let m = ExcelUtils.dz(a, d, l, e, l, h);
        if (WorksheetCellFormatData._cf(h, m)) {
          m = j;
        }
        if (Base.equalsStatic(m, k) == false) {
          k = WorksheetCellFormatData._c8(h);
          break;
        }
      }
    }
    c.addItem(h, k);
  }
  /**
   * @hidden
   */
  static _bb(a, b, c, d, e, f, g, h) {
    if (a == null) {
      return;
    }
    let i = a._columns$i.maxCount;
    let j = null;
    if (0 <= d && d < i) {
      j = a._cb(d);
    }
    let k = null;
    if (0 <= e && e < i) {
      k = a._cb(e);
    }
    let l = a._rows$i.item(b._ac);
    let m = ExcelUtils.dz(a, f, g, l, e, h);
    let n;
    if (j != null) {
      n = j.b._dd(h);
    }
    else if (k != null) {
      n = k.b._dd(ExcelUtils.o(h));
    }
    else {
      n = WorksheetCellFormatData._c8(h);
    }
    let o = m;
    if (WorksheetCellFormatData._cf(h, o)) {
      o = n;
    }
    if (WorksheetCellFormatData._cf(h, o) == false) {
      for (let p = b._ac + 1; p <= b._ae; p++) {
        let q = a._rows$i.item(p);
        let r = ExcelUtils.dz(a, q, d, q, e, h);
        if (WorksheetCellFormatData._cf(h, r)) {
          r = n;
        }
        if (Base.equalsStatic(r, o) == false) {
          o = WorksheetCellFormatData._c8(h);
          break;
        }
      }
    }
    c.addItem(h, o);
  }
  /**
   * Gets the cell formatting for the merged cell region.
   * The cell formatting for the merged cell region.
   */
  get cellFormat() {
    return this._cellFormatInternal;
  }
  /**
   * @hidden
   */
  get _hasCellFormat() {
    return this._au != null;
  }
  /**
   * @hidden
   */
  get _cellFormatInternal() {
    if (this._au == null) {
      let a = null;
      if (this.worksheet != null) {
        a = this.worksheet.workbook;
      }
      let b = this._ay ? a._ca : null;
      this._au = new WorksheetMergedRegionOwnedCellFormatProxy(b, this);
    }
    return this._au;
  }
  /**
   * Gets or sets the comment for the merged cells region.
   * <p class="body">
   * The comment of the merged region can also be accessed from the top-left cell of the merged region of cells.
   * </p>
   * The comment for the merged cells region.
   */
  get comment() {
    if (this._ay == false) {
      return null;
    }
    if (this._k == null) {
      return null;
    }
    return this._k._a6(this._v);
  }
  /**
   * Gets or sets the comment for the merged cells region.
   * <p class="body">
   * The comment of the merged region can also be accessed from the top-left cell of the merged region of cells.
   * </p>
   * The comment for the merged cells region.
   */
  set comment(a) {
    if (this._ay == false) {
      return;
    }
    if (this._k == null) {
      return;
    }
    this._k._d2(this._v, a);
  }
  /**
   * Gets the formula which has been applied to the merged region.
   * The formula which has been applied to the merged region or null if no formula has been applied.
   */
  get formula() {
    if (this._k == null) {
      return null;
    }
    return typeCast(Formula.$, this._k._c6(this._v));
  }
  /**
   * @hidden
   */
  get _az() {
    return this._ay;
  }
  /**
   * Gets or sets the value of the merged cell region.
   * <p class="body">The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * The value of the merged cell region.
   * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
   * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
   * should be called on the Formula, passing in the cell.
   * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
   * should be set to a region containing the cell.
   * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
   * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
   * @see [[WorksheetCell.value]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   */
  get value() {
    if (this._ay == false) {
      return null;
    }
    if (this._k == null) {
      return null;
    }
    return this._k._c5(this._v);
  }
  /**
   * Gets or sets the value of the merged cell region.
   * <p class="body">The types supported for the value are:
   * <BR/>
   * <ul>
   * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
   * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
   * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
   * </ul>
   * </p>
   * The value of the merged cell region.
   * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
   * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
   * should be called on the Formula, passing in the cell.
   * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
   * should be set to a region containing the cell.
   * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
   * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
   * @see [[WorksheetCell.value]]
   * @see [[WorksheetCell.isCellTypeSupported]]
   */
  set value(a) {
    if (this._ay == false) {
      return;
    }
    if (this._k == null) {
      return;
    }
    this._k.setCellValue(this._v, a);
  }
}
WorksheetMergedCellsRegion.$t = markType(WorksheetMergedCellsRegion, 'WorksheetMergedCellsRegion', WorksheetRegion.$, [ICellFormatOwner_$type, IWorksheetCellFormatProxyOwner_$type]);
/**
 * @hidden
 */
WorksheetMergedCellsRegion._aw = null;
/**
 * Class which exposes the display options which can only be controlled through the worksheet.
 * @see [[Worksheet.displayOptions]]
 * @see [[CustomViewDisplayOptions]]
 */
export class WorksheetDisplayOptions extends DisplayOptions {
  constructor(a, b) {
    super(a);
    this._b5 = 100;
    this._b8 = 60;
    this._cb = 100;
    this._by = false;
    this._b0 = true;
    this._bx = null;
    this._b2 = null;
    if (b == false) {
      let c = null;
      this._b2 = () => c;
      this._bx = (d) => c = d;
    }
    else {
      this._b2 = () => this._ad.tabColorInfo;
      this._bx = (d) => this._ad.tabColorInfo = d;
    }
  }
  /**
   * @hidden
   */
  _e() {
    return new WorksheetDisplayOptions(this._ad, false);
  }
  /**
   * @hidden
   */
  _n(a) {
    super._n(a);
    let b = typeCast(WorksheetDisplayOptions.$, a);
    if (b != null) {
      this._b5 = b._b5;
      this._b8 = b._b8;
      this._cb = b._cb;
      this._by = b._by;
      this._b0 = b._b0;
      this.tabColorInfo = b.tabColorInfo;
      return;
    }
    let c = typeCast(CustomViewDisplayOptions.$, a);
    if (c != null) {
      switch (c.view) {
        case 0:
          this._b5 = c.magnificationInCurrentView;
          break;
        case 2:
          this._b8 = c.magnificationInCurrentView;
          break;
        case 1:
          this._cb = c.magnificationInCurrentView;
          break;
        default: break;
      }
      return;
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return true;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
  /**
   * Resets the display options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
   * </p>
   */
  resetCore() {
    super.resetCore();
    this._b5 = 100;
    this._b8 = 60;
    this._cb = 100;
    this._by = false;
    this._b0 = true;
  }
  /**
   * @hidden
   */
  _bq(a) {
    if (this.panesAreFrozen == false && this._ad != null && this._ad.workbook != null && this._ad.workbook._c4 == false) {
      let b = this._b4(this.view);
      let c = this._b4(a);
      this.unfrozenPaneSettings._ao(b, c);
    }
    super._bq(a);
  }
  /**
   * @hidden
   */
  static _bv($tValue, a, b, c, d, e = null, f = false, g = 0) {
    return new ChangeInfo$2(WorksheetDisplayOptions.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _bu() {
    let a = new Array(5);
    ChangeInfo.f(a, 0, WorksheetDisplayOptions._bv(Number_$type, "MagnificationInNormalView", 99, (b) => b.magnificationInNormalView, (b, c) => b.magnificationInNormalView = c, (b, c) => ((() => { let d = b._ch(0, b._b5, c); b._b5 = d.p1; })()), true));
    ChangeInfo.f(a, 1, WorksheetDisplayOptions._bv(Number_$type, "MagnificationInPageBreakView", 99, (b) => b.magnificationInPageBreakView, (b, c) => b.magnificationInPageBreakView = c, (b, c) => ((() => { let d = b._ch(2, b._b8, c); b._b8 = d.p1; })()), true));
    ChangeInfo.f(a, 2, WorksheetDisplayOptions._bv(Number_$type, "MagnificationInPageLayoutView", 99, (b) => b.magnificationInPageLayoutView, (b, c) => b.magnificationInPageLayoutView = c, (b, c) => ((() => { let d = b._ch(1, b._cb, c); b._cb = d.p1; })()), true));
    ChangeInfo.f(a, 3, WorksheetDisplayOptions._bv(Boolean_$type, "OrderColumnsRightToLeft", 35, (b) => b.orderColumnsRightToLeft, (b, c) => b.orderColumnsRightToLeft = c, null, true));
    ChangeInfo.f(a, 4, WorksheetDisplayOptions._bv(Boolean_$type, "ShowWhitespaceInPageLayoutView", 35, (b) => b.showWhitespaceInPageLayoutView, (b, c) => b.showWhitespaceInPageLayoutView = c, null, true));
    return a;
  }
  /**
   * @hidden
   */
  _b4(a) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 0: return this.magnificationInNormalView;
        case 2: return this.magnificationInPageBreakView;
        case 1: return this.magnificationInPageLayoutView;
        default:
          t1 = 0;
          continue L0;
      }
      break;
    }
  }
  /**
   * @hidden
   */
  _ch(a, b, c) {
    if (this.view == a && this.panesAreFrozen == false && this._ad != null && this._ad.workbook != null && this._ad.workbook._c4 == false) {
      this.unfrozenPaneSettings._ao(b, c);
    }
    b = c;
    return {
      p1: b
    };
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in normal view.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in normal view.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInPageBreakView]]
   * @see [[magnificationInPageLayoutView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  get magnificationInNormalView() {
    return this._b5;
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in normal view.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in normal view.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInPageBreakView]]
   * @see [[magnificationInPageLayoutView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  set magnificationInNormalView(a) {
    if (this._b5 != a) {
      if (a < 10 || 400 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MagnificationLevel"));
      }
      WorksheetDisplayOptions._bt[0].h(WorksheetDisplayOptions.$, Number_$type, this, a);
    }
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in the page break preview.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in the page break preview.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInNormalView]]
   * @see [[magnificationInPageLayoutView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  get magnificationInPageBreakView() {
    return this._b8;
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in the page break preview.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in the page break preview.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInNormalView]]
   * @see [[magnificationInPageLayoutView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  set magnificationInPageBreakView(a) {
    if (this._b8 != a) {
      if (a < 10 || 400 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MagnificationLevel"));
      }
      WorksheetDisplayOptions._bt[1].h(WorksheetDisplayOptions.$, Number_$type, this, a);
    }
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in page layout view.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in page layout view.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInNormalView]]
   * @see [[magnificationInPageBreakView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  get magnificationInPageLayoutView() {
    return this._cb;
  }
  /**
   * Gets or sets the magnification level of the worksheet when it is displayed in page layout view.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the worksheet when it is displayed in page layout view.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
   * @see [[magnificationInNormalView]]
   * @see [[magnificationInPageBreakView]]
   * @see [[DisplayOptions.view]]
   * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
   */
  set magnificationInPageLayoutView(a) {
    if (this._cb != a) {
      if (a < 10 || 400 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MagnificationLevel"));
      }
      WorksheetDisplayOptions._bt[2].h(WorksheetDisplayOptions.$, Number_$type, this, a);
    }
  }
  /**
   * Gets or sets the value indicating whether the columns are ordered right to left.
   * <p class="body">
   * If the columns are ordered right to left, other aspects of the worksheet display differently. The vertical scrollbar
   * will display on the left side of the worksheet and the worksheet tab bar, usually displayed on the left side of the
   * worksheet, will display on the right side.
   * </p>
   * The value indicating whether the columns are ordered right to left.
   */
  get orderColumnsRightToLeft() {
    return this._by;
  }
  /**
   * Gets or sets the value indicating whether the columns are ordered right to left.
   * <p class="body">
   * If the columns are ordered right to left, other aspects of the worksheet display differently. The vertical scrollbar
   * will display on the left side of the worksheet and the worksheet tab bar, usually displayed on the left side of the
   * worksheet, will display on the right side.
   * </p>
   * The value indicating whether the columns are ordered right to left.
   */
  set orderColumnsRightToLeft(a) {
    let b = WorksheetDisplayOptions._bt[3].g(WorksheetDisplayOptions.$, Boolean_$type, this, this._by, a);
    this._by = b.p1;
  }
  /**
   * Gets or sets the value which indicates whether to show whitespace between worksheet pages in page layout view.
   * <p class="note">
   * <B>Note:</B> For this value to affect the display of the worksheet, the [[DisplayOptions.view]] must
   * be set to PageLayout. However, if a different view is used, this is still saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will default to Normal view.
   * </p>
   * The value which indicates whether to show white page between worksheet pages in page layout view.
   * @see [[DisplayOptions.view]]
   */
  get showWhitespaceInPageLayoutView() {
    return this._b0;
  }
  /**
   * Gets or sets the value which indicates whether to show whitespace between worksheet pages in page layout view.
   * <p class="note">
   * <B>Note:</B> For this value to affect the display of the worksheet, the [[DisplayOptions.view]] must
   * be set to PageLayout. However, if a different view is used, this is still saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
   * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will default to Normal view.
   * </p>
   * The value which indicates whether to show white page between worksheet pages in page layout view.
   * @see [[DisplayOptions.view]]
   */
  set showWhitespaceInPageLayoutView(a) {
    let b = WorksheetDisplayOptions._bt[4].g(WorksheetDisplayOptions.$, Boolean_$type, this, this._b0, a);
    this._b0 = b.p1;
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
   * <p class="body">
   * If the tab bar is not visible, this color will not be seen.
   * </p>
   * The WorkbookColorInfo to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
   * @see [[WindowOptions.tabBarVisible]]
   */
  get tabColorInfo() {
    return this._b2();
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
   * <p class="body">
   * If the tab bar is not visible, this color will not be seen.
   * </p>
   * The WorkbookColorInfo to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
   * @see [[WindowOptions.tabBarVisible]]
   */
  set tabColorInfo(a) {
    this._bx(a);
  }
  /**
   * @hidden
   */
  get _b3() {
    return this._b4(this.view);
  }
  /**
   * @hidden
   */
  set _b3(a) {
    let t1 = this.view;
    L0: while (true) {
      switch (t1) {
        case 0:
          this.magnificationInNormalView = a;
          break;
        case 2:
          this.magnificationInPageBreakView = a;
          break;
        case 1:
          this.magnificationInPageLayoutView = a;
          break;
        default:
          t1 = 0;
          continue L0;
      }
      break;
    }
  }
}
WorksheetDisplayOptions.$t = markType(WorksheetDisplayOptions, 'WorksheetDisplayOptions', DisplayOptions.$);
/**
 * @hidden
 */
WorksheetDisplayOptions._b7 = 0;
/**
 * @hidden
 */
WorksheetDisplayOptions._ca = 1;
/**
 * @hidden
 */
WorksheetDisplayOptions._cd = 2;
/**
 * @hidden
 */
WorksheetDisplayOptions._cf = 3;
/**
 * @hidden
 */
WorksheetDisplayOptions._cg = 4;
/**
 * @hidden
 */
WorksheetDisplayOptions._ce = 5;
/**
 * @hidden
 */
WorksheetDisplayOptions._bt = WorksheetDisplayOptions._bu();
/**
 * @hidden
 */
export class GetCellTextParameters extends Base {
  constructor(a) {
    super();
    this.e = 0;
    this.a = 0;
    this.b = 0;
    this.g = Nullable$1.toNullable(Boolean_$type, null);
    this.d = null;
    this.c = false;
    this.f = 0;
    this.e = a;
  }
}
GetCellTextParameters.$t = markType(GetCellTextParameters, 'GetCellTextParameters');
/**
 * @hidden
 */
export class WorksheetCellBlock_CellValue extends ValueType {
  constructor() {
    super();
    this.d = null;
    this.e = null;
  }
  get b() {
    return (this.d);
  }
  set b(a) {
    this.d = a;
  }
  get i() {
    return (this.d);
  }
  set i(a) {
    this.d = a;
  }
  get a() {
    return (this.d);
  }
  set a(a) {
    this.d = a;
  }
  get g() {
    return (this.e);
  }
  set g(a) {
    this.e = a;
  }
  get f() {
    return (this.e);
  }
  set f(a) {
    this.e = a;
  }
  get c() {
    return (this.d);
  }
  set c(a) {
    this.d = a;
  }
  get h() {
    return (this.e);
  }
  set h(a) {
    this.e = a;
  }
  j(a) {
    this.c = HashHelpers.d(a);
    this.h = a._aa;
  }
}
WorksheetCellBlock_CellValue.$t = markStruct(WorksheetCellBlock_CellValue, 'WorksheetCellBlock_CellValue');
/**
 * @hidden
 */
export class GetCellTextResult extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.g = null;
    this.e = 0;
    this.a = 0;
    this.f = null;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.g = c;
          this.e = NaN;
          this.a = 3;
          this.f = null;
          this.b = 0;
        }
        break;
    }
  }
  get c() {
    return this.a == 1;
  }
  get d() {
    return this.a == 2;
  }
}
GetCellTextResult.$t = markStruct(GetCellTextResult, 'GetCellTextResult');
/**
 * @hidden
 */
export class WorkbookSerializationManager extends Base {
  constructor(a, b) {
    super();
    this._c = null;
    this._k = null;
    this._d = null;
    this._a = null;
    this._e = null;
    this._f = null;
    this._c = new List$1(WorksheetCellFormatData.$, 0);
    this._k = b;
    this._d = new List$1(WorkbookFontData.$, 0);
    this._e = new List$1(WorkbookReferenceBase.$, 0);
    this._f = new List$1(WorksheetReference.$, 0);
    this._a = a;
    a._gw = b;
  }
  dispose() {
    this.disposeCore(true);
  }
  disposeCore(a) {
  }
  get _g() {
    return this._c;
  }
  get _l() {
    return this._k;
  }
  get _h() {
    return this._d;
  }
  get _b() {
    return this._a;
  }
  get _i() {
    return this._e;
  }
  get _j() {
    return this._f;
  }
}
WorkbookSerializationManager.$t = markType(WorkbookSerializationManager, 'WorkbookSerializationManager', Base.$, [IDisposable_$type]);
/**
 * @hidden
 */
export let IColorFilterVisitor$2_$type = new Type(null, 'IColorFilterVisitor$2');
/**
 * @hidden
 */
export class WorkbookSaveManager extends WorkbookSerializationManager {
  constructor(a, b, c) {
    super(a, b);
    this._au = null;
    this._ai = null;
    this._aj = null;
    this._a8 = 0;
    this._ak = null;
    this._al = null;
    this._an = null;
    this._ao = null;
    this._a0 = null;
    this._ap = null;
    this._a9 = 0;
    this._ab = false;
    this._ac = false;
    this._am = null;
    this._ay = null;
    this._x = null;
    this._t = null;
    this._aq = null;
    this._au = new HashSet$1(WorksheetColumnBlock.$, 0);
    this._ai = new Dictionary$2(WorksheetTableColumn.$, Number_$type, 0);
    this._aj = new Dictionary$2(WorkbookFontData.$, Number_$type, 0);
    this._ak = new Dictionary$2(WorksheetShape.$, WorksheetShape.$, 0);
    this._al = new Dictionary$2(WorksheetRow.$, WorksheetRowSerializationCache.$, 0);
    this._an = new Dictionary$2(StringBuilder.$, Number_$type, 0);
    this._ao = new Dictionary$2(WorkbookStyle.$, Number_$type, 0);
    this._a0 = new List$1(StringElement.$, 0);
    this._ap = new Dictionary$2(WorksheetTableStyle.$, SortedList$2.$.specialize(WorksheetTableStyleArea_$type, Number_$type), 0);
    this._am = new Dictionary$2(Sheet.$, SheetSerializationCache.$, 0);
    this._x = WorkbookSaveOptions._h(c);
    this._ay = this._x.c(a);
    this._t = new WorkbookSaveManager_ColorSortConditionVisitorProxy$1(WorksheetTableColumn.$, this, true, true, this._ai);
    this._aq = new Dictionary$2(Formula.$, String_$type, 0);
  }
  _visitFillFilter$i(a, b) {
    let c = this._b._cd(2);
    c._ce = true;
    c.fill = a.fill._c(this._b);
    return c;
  }
  _visitFontColorFilter$i(a, b) {
    let c = this._b._cd(2);
    c._ce = true;
    let d = a.fontColorInfo._aj(this._b);
    c.fill = new CellFillPattern(new WorkbookColorInfo(d), new WorkbookColorInfo(ColorsInternal.e), 1, null, true);
    return c;
  }
  _ba(a) {
    let b = intSToU(this._g.count);
    this._g.add(a);
    return b;
  }
  _bd(a, b) {
    let c = a.d._ak(b);
    let d;
    if (((() => { let e = this._aj.tryGetValue(c, d); d = e.p1; return e.ret; })()) == false) {
      d = this._h.count;
      this._h.add(c);
      this._aj.addItem(c, d);
    }
    a._r = Nullable$1.toNullable(Number_$type, d);
  }
  _y(a) {
    return a._accept$2$i(Boolean_$type, WorksheetCellFormatData.$, this, null);
  }
  _ad(a) {
    return this._au.contains(a);
  }
  _bf($t, a, b, c, d) {
    let e;
    let f = this._bg($t, a, b, c, d, e);
    c = f.p2;
    d = f.p3;
    e = f.p4;
    return {
      p2: c,
      p3: d
    };
  }
  _bg($t, a, b, c, d, e, ...f) {
    c = null;
    d = null;
    e = null;
    let g = a._f(b);
    if (g == null) {
      return {
        p2: c,
        p3: d,
        p4: e
      };
    }
    let h = g.d;
    c = h.style;
    if (f.length != 0) {
      h = h._bu();
      e = this._b._cd(2);
      for (let i = 0; i < f.length; i++) {
        let j = f[i];
        ExcelUtils.e9(h, e, j);
        h._ds(j);
      }
      if (e._cd) {
        e = null;
      }
      if (h._cc() == false) {
        h.formatOptions &= ~8;
      }
    }
    if (h._cd == false) {
      d = h;
    }
    return {
      p2: c,
      p3: d,
      p4: e
    };
  }
  _a2(a) {
    let b;
    if (((() => { let c = this._ai.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return Nullable$1.toNullable(Number_$type, b);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  _av(a) {
    return this._x.a(a);
  }
  _z(a) {
    let b;
    let c = this._ak.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  _aw(a, b = false) {
    return this._x.b(a, b);
  }
  _w(a) {
    return this._s(a);
  }
  _s(a) {
    return this._am.item(a);
  }
  _u(a) {
    let b;
    let c = this._al.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  _a3(a, b, c = false) {
    let d = b.r;
    let e = a._bl(d);
    if (e != null && (a.index != e.firstRow || d != e._v)) {
      return null;
    }
    let f = b.d;
    if (f == null) {
      return null;
    }
    if (c && f.l(b.h, b.f)) {
      return WorkbookSaveManager._a4(f.y(a, d));
    }
    return WorkbookSaveManager._a4(f.ab(a, d, this, b.h, b.f));
  }
  static _a4(a) {
    let b = typeCast(ErrorValue.$, a);
    if (b == ErrorValue.circularity) {
      return 0;
    }
    return a;
  }
  *__ax() {
    for (let a of fromEnum(this._b._bj)) {
      yield a;
    }
    for (let b of fromEnum(this._a0)) {
      yield b;
    }
  }
  _ax() {
    return toEnum(() => this.__ax());
  }
  _aa(a) {
    let b;
    if (((() => { let c = this._ap.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      b = new SortedList$2(WorksheetTableStyleArea_$type, Number_$type, 0);
      this._ap.item(a, b);
    }
    return b;
  }
  _ae(a) {
    return a._d9 && Enumerable.c(WorksheetMergedCellsRegion.$, this._x.a(a));
  }
  _o() {
    let a = this._b;
    for (let b of fromEnum(a._worksheets$i)) {
      for (let c of fromEnum(this._aw(b))) {
        c._cb();
      }
    }
    a._bj._n(false);
    a._ca._n(true);
    return Async.h(() => {
      if (a.calculationMode == 0 && a.recalculateBeforeSave) {
        a._recalculate();
      }
      this._bk();
      this._bx();
      ExcelUtils.fm(WorksheetTableStyle.$, a._customTableStyles$i, runOn(this, this._b2));
      ExcelUtils.fm(Sheet.$, this._az, runOn(this, this._bw));
      if (this._ab) {
        for (let d of fromEnum(this._az)) {
          if (d.type == 0) {
            a._bb.g(d.name, null);
          }
        }
      }
      this._bt();
      this._br();
      return this._p();
    }, () => {
      a._bj._m();
      a._ca._m();
    });
  }
  static _b5(a, b, c, d) {
    d = a.displayText;
    if (d == null) {
      if (WorksheetCell.l_op_Inequality(a.sourceCell, null)) {
        d = a.sourceCell._getText1(1);
      }
      else {
        d = a.sourceRegion._k._da(a.sourceRegion._v, 1);
      }
    }
    let e = a.targetAddress;
    if (typeof a.target === 'string' && a._t == false) {
      let f = e.indexOf('#');
      if (0 <= f) {
        b = e.substr(0, f);
        c = e.substr(f + 1);
        let g = a.worksheet != null ? a.worksheet.workbook : null;
        if (g != null) {
          let h;
          if (!stringIsNullOrEmpty(c) && !((() => { let i = Formula._a3("=" + c, 1, g.currentFormat, g._e6, h); h = i.p4; return i.ret; })())) {
            b = e;
            c = null;
          }
        }
      }
      else {
        b = e;
        c = null;
      }
    }
    else {
      b = null;
      c = e;
    }
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  _bo(a) {
  }
  _b4(a) {
    let b = typeCast(WorksheetShapeGroup.$, a);
    if (b == null) {
      return {
        p0: a
      };
    }
    let c = 0;
    let d = null;
    for (let e = 0; e < b._shapes$i.count; e++) {
      let f = b._shapes$i.item(e);
      let g = this._b4(f);
      f = g.p0;
      if (f == null) {
        continue;
      }
      c++;
      if (d == null) {
        d = f;
      }
      if (c > 1) {
        break;
      }
    }
    if (c == 0) {
      a = null;
      return {
        p0: a
      };
    }
    else if (c == 1) {
      a = d;
      return {
        p0: a
      };
    }
    return {
      p0: a
    };
  }
  _bl(a) {
  }
  _bm(a) {
  }
  _be(a, b) {
    a._c3();
    if (a._h.e == null) {
      return {
        p1: b
      };
    }
    let c = typeCast(UnknownShape.$, a);
    if (c != null && c._ek) {
      return {
        p1: b
      };
    }
    a._h.e.t = b;
    if (a._bi != null) {
      for (let d = 0; d < a._bi.count; d++) {
        let e = a._bi._inner[d];
        if (e._b == 267) {
          e._i = b;
          break;
        }
      }
    }
    let f = this._b._hk(b);
    b = f.p0;
    return {
      p1: b
    };
  }
  static _ar(a, b) {
    b = -1;
    let c = new Dictionary$2(Formula.$, String_$type, 0);
    for (let d of fromEnum(a._en)) {
      let e = d.name;
      if (stringIsNullOrEmpty(e)) {
        continue;
      }
      let f = null;
      if (((() => { let g = c.tryGetValue(d._j, f); f = g.p1; return g.ret; })())) {
      }
      else {
        c.addItem(d._j, e);
      }
      let g = (e.length >= "_xlchart.v1.".length) ? e.indexOf("_xlchart.v1.") : -1;
      if (g == 0) {
        let h;
        let i = e.substr("_xlchart.v1.".length);
        if (((() => { let j = tryParseInt32_1(i, h); h = j.p1; return j.ret; })())) {
          b = Math.max(b, h);
        }
      }
    }
    return {
      ret: c,
      p1: b
    };
  }
  _bj(a, b) {
    let c = this._b;
    for (let d of fromEnum(a._paragraphs$i)) {
      for (let e of fromEnum(d._getFormattingRuns(c))) {
        this._bd(e.f(c), b);
      }
    }
  }
  _bn(a) {
    if (a == null) {
      return;
    }
    for (let b of fromEnum(a)) {
      let c = typeCast(WorksheetShapeGroupBase.$, b);
      if (c != null) {
        this._bn(c._shapes$i);
        continue;
      }
      let d = typeCast(IWorksheetImage_$type, b);
      if (d != null) {
        this._bo(d);
      }
    }
  }
  _bp() {
    let a = this._b;
    a._bb.ac();
    for (let b of fromEnum(this._az)) {
      this._bs(b._p);
    }
    this._bh();
    if (this._b._cv) {
      for (let c of fromEnum(a._namedReferences$i)) {
        this._b._bb.aj(c);
      }
    }
    if (a._cu) {
      for (let d of fromEnum(a._en)) {
        this._b._bb.aj(d);
      }
    }
    if (a._cq) {
      ExcelUtils.fm(CustomView.$, a._customViews$i, runOn(this, this._bq));
    }
  }
  _bq(a) {
    if (a.saveHiddenRowsAndColumns == false && a.savePrintOptions == false) {
      return;
    }
    for (let b of fromEnum(this._az)) {
      if (b.type != 0) {
        continue;
      }
      let c = b;
      if (a.saveHiddenRowsAndColumns) {
        let d = a.getHiddenColumns(c, false);
        if (d != null) {
          let e = d._b();
          if (e != null) {
            this._b._bb.aj(e);
          }
        }
        let f = a.getHiddenRows(c, false);
        if (f != null) {
          let g = f._b();
          if (g != null) {
            this._b._bb.aj(g);
          }
        }
      }
      if (a.savePrintOptions) {
        let h = a.getPrintOptions(c, false);
        if (h != null) {
          if (h.columnsToRepeatAtLeft != null || h.rowsToRepeatAtTop != null) {
            let i = stringFormat2(CultureInfo.invariantCulture, "Z_{0}_.wvu.PrintTitles", stringToLocaleUpper(stringReplace(a._t.toString2("D"), "-", "_"), CultureInfo.invariantCulture));
            let j = null;
            let k;
            let l = h._dt(this._b, i, false, j, k);
            j = l.p3;
            k = l.p4;
            j._p = true;
            this._b._bb.aj(j);
          }
          if (h._cq) {
            let m = stringFormat2(CultureInfo.invariantCulture, "Z_{0}_.wvu.PrintArea", stringToLocaleUpper(stringReplace(a._t.toString2("D"), "-", "_"), CultureInfo.invariantCulture));
            let n = null;
            let o;
            let p = h._dr(this._b, m, false, n, o);
            n = p.p3;
            o = p.p4;
            n._p = true;
            this._b._bb.aj(n);
          }
        }
      }
    }
  }
  _br() {
    let a = this._b._bb;
    this._i.add(a);
    this._bp();
    this._b._hn((b, c) => {
      let d = b == null || b.type == 0 ? new FormulaContext(3, this._b, b, c._ab, c._bb, c) : new FormulaContext(4, b, c._aa.o, c._aa.m, c._z, c, null, 1);
      let e = WorkbookSaveManager_InitSerializationCacheFormulaHelper.a1(d, this);
      e.h();
    }, Enumerable.a(NamedReferenceBase.$, a.u), this._az, true);
  }
  _bs(a) {
    for (let b of fromEnum(a)) {
      let c = typeCast(WorksheetShapeGroupBase.$, b);
      if (c != null) {
        this._bs(c._shapes$i);
      }
      if (b._h == null || b._h.l == null) {
        continue;
      }
      let d = b._h.l.a();
      if (d == null) {
        continue;
      }
      for (let e = 0; e < d._e.length; e++) {
        let f = typeCast(NameXToken.$, d._e[e]);
        if (f == null) {
          continue;
        }
        let g = typeCast(NamedReference.$, f.u);
        if (g != null) {
          this._b._bb.aj(g);
        }
      }
    }
  }
  _bh() {
    let a = new HashSet$1(Formula.$, 0);
    let b = new List$1(Formula.$, 0);
    let c = -1;
    let d = ((() => { let e = WorkbookSaveManager._ar(this._b, c); c = e.p1; return e.ret; })());
    c += 1;
    for (let e of fromEnum(this._az)) {
      if (e._p == null) {
        continue;
      }
      e._p._ah((f) => {
        let g = typeCast(WorksheetChart.$, f);
        if (g == null || WorksheetChart._f9(g.chartType) == false) {
          return;
        }
        for (let h of fromEnum(g._seriesCollection$i)) {
          let i = h._b1 ? h.xValues : null;
          let j = h._b0 ? h.values : null;
          let k = h.name;
          if (i != null && i._f != null && a.add_1(i._f)) {
            b.add(i._f);
          }
          if (j != null && j._f != null && a.add_1(j._f)) {
            b.add(j._f);
          }
          if (k != null && k._d != null && a.add_1(k._d)) {
            b.add(k._d);
          }
        }
      });
    }
    let f = this._b._namedReferences$i;
    let g = this._b;
    for (let h of fromEnum(b)) {
      let i = null;
      if (((() => { let j = d.tryGetValue(h, i); i = j.p1; return j.ret; })())) {
        this._aq.item(h, i);
        continue;
      }
      let j = new NamedReferenceFormula(2, h);
      let k = stringFormat("{0}{1}", "_xlchart.v1.", c);
      let l = typeCast(NamedReference.$, g._a2(k, null));
      if (l != null) {
        g._en.remove(l);
      }
      this._aq.item(h, k);
      let m = new NamedReference(1, f, g, true);
      m.name = k;
      m._j = j;
      g._en.add(m);
      c += 1;
    }
  }
  _bt() {
    let a = 1024;
    let b = 65535;
    let c = this._b._hk(b);
    b = c.p0;
    for (let d of fromEnum(this._az)) {
      a = intSToU(ExcelUtils.dj(a, 1024));
      let e = this._bu(d, a, b);
      a = e.p1;
      b = e.p2;
    }
    this._a8 = a;
  }
  _bu(a, b, c) {
    let d = this._s(a);
    d.c = 1;
    d.d = b++;
    let e = this._bv(d, a._p, this._ag == false, b, c);
    b = e.p3;
    c = e.p4;
    if (a.type == 0) {
      let f = this._bv(d, d.j, true, b, c);
      b = f.p3;
      c = f.p4;
    }
    d.b = b - 1;
    return {
      p1: b,
      p2: c
    };
  }
  _bv(a, b, c, d, e) {
    for (let f of fromEnum(b)) {
      let g = f;
      let h = this._b4(g);
      g = h.p0;
      if (g == null) {
        continue;
      }
      this._ak.item(f, g);
      this._ac = true;
      if (typeCast(WorksheetChart.$, g) !== null) {
        this._ab = true;
      }
      a.c++;
      if (c) {
        g._cn = d++;
        let i = this._be(g, e);
        e = i.p1;
      }
      let j = typeCast(WorksheetShapeGroupBase.$, g);
      if (j != null) {
        let k = this._bv(a, j._shapes$i, c, d, e);
        d = k.p3;
        e = k.p4;
      }
    }
    return {
      p3: d,
      p4: e
    };
  }
  _bx() {
    let a = Tuple.a(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type, this, null);
    for (let b of fromEnum(this._b._bj)) {
      b._t(Tuple$2.$.specialize(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type), Boolean_$type, WorkbookSaveManager_InitSerializationCacheHelper.d, a);
      this._a9 += intSToU(b.f);
    }
  }
  _bw(a) {
    if (a.type == 0) {
      this._by(a);
    }
    else if (a.type == 1) {
      this._bi(a);
    }
    else {
    }
  }
  _bi(a) {
    this._bn(a._p);
    let b = new SheetSerializationCache();
    this._am.item(a, b);
    for (let c of fromEnum(a._p)) {
      c._am(WorkbookSaveManager.$, Boolean_$type, WorkbookSaveManager_InitSerializationCacheHelper.d, this);
    }
  }
  _by(a) {
    a._g9();
    this._bn(a._shapes$i);
    let b = Nullable$1.toNullable(Number_$type, null);
    let c = Nullable$1.toNullable(Number_$type, null);
    let d = Nullable$1.toNullable(Number_$type, null);
    let e = Nullable$1.toNullable(Number_$type, null);
    let f = 0;
    let g = 0;
    let h = null;
    for (let i of fromEnum(a._ff)) {
      if (this._af(a, i, h)) {
        f = Math.max(i.m, f);
        if (nullableEquals(b, null)) {
          b = Nullable$1.toNullable(Number_$type, i.q);
        }
        c = Nullable$1.toNullable(Number_$type, (i.r + 1));
      }
      h = i;
    }
    let j = 0;
    let k = 0;
    let l = this._x.e(a);
    let m = this._x.d(a);
    if (a._dv) {
      j = l - m;
    }
    else {
      k = l - m;
    }
    let n = -1;
    let o = 0;
    let p = null;
    for (let q of fromEnum(this._aw(a))) {
      let r = this._v(q, p, a._dv);
      if (r.b) {
        if (n < 0) {
          n = q.index;
        }
        if (q.index - n > 31) {
          o++;
          n = q.index;
        }
      }
      else {
        if (q.hidden) {
          j++;
        }
        else {
          k++;
        }
      }
      p = q;
    }
    if (n >= 0) {
      o++;
    }
    let s = this._x == DefaultWorkbookSaveFilter.f ? k < j : a._dv;
    let t = s != a._dv;
    let u = getEnumerator(this._aw(a, t));
    {
      let v = u;
      try {
        while (u.moveNext()) {
          let w = u.current;
          let x;
          let y = this._al.tryGetValue(w, x);
          x = y.p1;
          if (w.hidden != s && (x == null || x.b == false)) {
            x = new WorksheetRowSerializationCache(true, false, 0, 0);
            this._al.item(w, x);
          }
          if (x != null && x.b) {
            g = Math.max(w._n, g);
            if (nullableEquals(d, null)) {
              d = Nullable$1.toNullable(Number_$type, intSToU(w.index));
            }
            e = Nullable$1.toNullable(Number_$type, intSToU(w.index) + 1);
            if (nullableEquals(b, null) || nullableLessThan(x.c, b)) {
              b = Nullable$1.toNullable(Number_$type, x.c);
            }
            if (nullableEquals(c, null) || nullableLessThan(c, x.d)) {
              c = Nullable$1.toNullable(Number_$type, x.d);
            }
          }
        }
      }
      finally {
        if (v != null) {
          v.dispose();
        }
      }
    }
    a._dv = s;
    let z = new WorksheetSerializationCache(b.getValueOrDefault(), c.getValueOrDefault(), d.getValueOrDefault(), e.getValueOrDefault(), f, g, o);
    this._am.item(a, z);
    if (a._d2) {
      this._ac = true;
      z.j.o(a._eu.values);
      for (let aa of fromEnum(z.j)) {
        aa._am(WorkbookSaveManager.$, Boolean_$type, WorkbookSaveManager_InitSerializationCacheHelper.d, this);
      }
    }
    for (let ab of fromEnum(a._shapes$i)) {
      ab._am(WorkbookSaveManager.$, Boolean_$type, WorkbookSaveManager_InitSerializationCacheHelper.d, this);
    }
    ExcelUtils.fm(WorksheetTable.$, a._tables$i, runOn(this, this._b0));
    if (a.filterSettings.region != null) {
      let ac = new WorkbookSaveManager_ColorSortConditionVisitorProxy$1(Number_$type, this, false, true, z.g);
      for (let ad of fromEnum(a.filterSettings.sortSettings._sortConditions$i)) {
        let ae = typeCast(IColorSortCondition_$type, ad.value);
        if (ae != null) {
          ae._accept$2$i(Number_$type, Boolean_$type, ac, ad.key.index);
        }
      }
    }
    if (a.sortSettings.region != null) {
      let af = new WorkbookSaveManager_ColorSortConditionVisitorProxy$1(Number_$type, this, false, true, z.h);
      for (let ag of fromEnum(a.sortSettings._sortConditions$i)) {
        let ah = typeCast(IColorSortCondition_$type, ag.value);
        if (ah != null) {
          ah._accept$2$i(Number_$type, Boolean_$type, af, ag.key.index);
        }
      }
    }
    this._bl(a);
    this._bm(a);
  }
  _bz(a, b) {
    let c = a.worksheet;
    let d = this._b;
    if (b.o && b.d != null) {
      let e = b.d.ai(a, b.r, b.h, b.f);
      if (e != null) {
        if (this._an.containsKey(e) == false) {
          let f = new StringElement(e.toString());
          let g = d._bj._a(f);
          let h = 0;
          if (g != null) {
            h = d._bj._q(g);
          }
          else {
            h = this._a1;
            f._t(Tuple$2.$.specialize(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type), Boolean_$type, WorkbookSaveManager_InitSerializationCacheHelper.d, Tuple.a(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type, this, b.j));
            this._a0.add(f);
          }
          this._an.item(e, h);
        }
        this._a9++;
      }
    }
  }
  _af(a, b, c) {
    let d = 0;
    let e = false;
    if (a.displayOptions._ao) {
      if (c != null) {
        d = c.m;
        e = c.i;
      }
    }
    else {
      let f = (b.r + 1);
      if (f < a._columns$i.maxCount) {
        let g = a._cb(f);
        if (g != null) {
          d = g.m;
          e = g.i;
        }
      }
    }
    let h = e && b.m < d;
    if (h) {
      this._au.add_1(b);
    }
    return h || b.m != 0 || b.v >= 0 || b.b._cd == false;
  }
  _v(a, b, c) {
    let d = false;
    let e = Nullable$1.toNullable(Number_$type, null);
    let f = Nullable$1.toNullable(Number_$type, null);
    let g = 0;
    let h = c;
    if (a.worksheet.displayOptions._an) {
      if (b != null && b.index + 1 == a.index) {
        g = b.outlineLevel;
        h = b.hidden;
      }
    }
    else {
      let i = a.worksheet._rows$i._aj(a.index + 1);
      if (i != null) {
        g = i.outlineLevel;
        h = i.hidden;
      }
    }
    let j = h && a.outlineLevel < g;
    let k = a._hasCellFormat ? a._cellFormatInternal.d : this._b._ca._p;
    for (let l of fromEnum(a._ch(void 0, void 0, true))) {
      this._bz(a, l);
      d = true;
      if (nullableEquals(e, null)) {
        e = Nullable$1.toNullable(Number_$type, l.r);
      }
      f = Nullable$1.toNullable(Number_$type, (l.r + 1));
    }
    if (d == false) {
      d = j || a._j || a._b1 || a._b4;
    }
    let m = new WorksheetRowSerializationCache(d, j, e.getValueOrDefault(), f.getValueOrDefault());
    if (d) {
      this._al.item(a, m);
    }
    return m;
  }
  _b0(a) {
    ExcelUtils.fm(WorksheetTableColumn.$, a._columns$i, runOn(this, this._b1));
  }
  _b1(a) {
    let b = typeCast(IColorSortCondition_$type, a.sortCondition);
    if (b != null) {
      b._accept$2$i(WorksheetTableColumn.$, Boolean_$type, this._t, a);
    }
  }
  _b2(a) {
    let b = this._aa(a);
    for (let c of fromEnum(a._areaFormats$i._i())) {
      b._m(c._bt, this._ba(c.d));
    }
    this._b3(a, a.columnStripeWidth != 1, 7);
    this._b3(a, a.alternateColumnStripeWidth != 1, 8);
    this._b3(a, a.rowStripeHeight != 1, 5);
    this._b3(a, a.alternateRowStripeHeight != 1, 6);
  }
  _b3(a, b, c) {
    let d = this._aa(a);
    if (b && d._b(c) == false) {
      let e = this._b._cd(2);
      d._m(c, this._ba(e));
    }
  }
  get _bb() {
    return this._a8;
  }
  get _as() {
    return this._an;
  }
  get _at() {
    return this._ao;
  }
  get _a1() {
    return this._b._bj._count + this._a0.count;
  }
  get _bc() {
    return this._a9;
  }
  get _az() {
    return this._ay;
  }
  get _ah() {
    return this._ac;
  }
  get__r() {
    throw new NotImplementedException(0);
  }
  set__r(a) {
    throw new NotImplementedException(0);
  }
  get _r() {
    return this.get__r();
  }
  set _r(a) {
    this.set__r(a);
  }
  get__q() {
    throw new NotImplementedException(0);
  }
  set__q(a) {
    throw new NotImplementedException(0);
  }
  get _q() {
    return this.get__q();
  }
  set _q(a) {
    this.set__q(a);
  }
}
WorkbookSaveManager.$t = markType(WorkbookSaveManager, 'WorkbookSaveManager', WorkbookSerializationManager.$, [IColorFilterVisitor$2_$type.specialize(Boolean_$type, WorksheetCellFormatData.$)]);
/**
 * @hidden
 */
export class StringElementIndex extends Base {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  static b(a) {
    let b;
    if (StringElementIndex.a != null) {
      b = StringElementIndex.a;
      b.c = a;
      StringElementIndex.a = null;
    }
    else {
      b = new StringElementIndex(a);
    }
    return b;
  }
  d() {
    StringElementIndex.a = this;
  }
}
StringElementIndex.$t = markType(StringElementIndex, 'StringElementIndex');
StringElementIndex.a = null;
/**
 * A collection of cells in a row.
 * <p class="body">
 * Cells in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the cells which were already accessed.
 * </p>
 * @see [[WorksheetCell]]
 * @see [[WorksheetRow.cells]]
 */
export class WorksheetCellCollection extends RowColumnCollectionBase$1 {
  constructor(a) {
    super(WorksheetCell.$, a.worksheet, Workbook.getMaxColumnCount(a.worksheet._o));
    this._ai = -1;
    this._ah = null;
    this._ah = a;
  }
  /**
   * @hidden
   */
  get__count() {
    if (this._ai < 1) {
      this._ai = 0;
      for (let a of fromEnum(this._ah._ch(void 0, void 0, true))) {
        this._ai++;
      }
    }
    return this._ai;
  }
  /**
   * @hidden
   */
  _a() {
    return null;
  }
  /**
   * @hidden
   */
  _createValue(a) {
    if (32767 < a) {
      return null;
    }
    return new WorksheetCell(this._ah, a);
  }
  /**
   * @hidden
   */
  *__p() {
    for (let a of fromEnum(this._ah._ch(void 0, void 0, true))) {
      yield this.item(a.r);
    }
  }
  _p() {
    return toEnum(() => this.__p()).getEnumerator();
  }
  /**
   * @hidden
   */
  *__n(a, b, c) {
    if (c) {
      return undefined;
    }
    for (let d of fromEnum(this._ah._ch(a, b, true))) {
      yield this.item(d.r);
    }
  }
  _n(a, b, c) {
    return toEnum(() => this.__n(a, b, c));
  }
  /**
   * @hidden
   */
  _getItemIndex(a) {
    return a.columnIndex;
  }
  /**
   * @hidden
   */
  _initializeItemIndex(a, b, c) {
  }
  /**
   * @hidden
   */
  _isItemStillValid(a) {
    return true;
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get_maxCount() {
    return Workbook.getMaxColumnCount(this._e._o);
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get maxCount() {
    return this.get_maxCount();
  }
  /**
   * @hidden
   */
  _ab() {
    super._ab();
  }
  /**
   * @hidden
   */
  _ae(a) {
    throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxColumns", this._e.workbook._ff));
  }
  /**
   * @hidden
   */
  _af(a, b) {
  }
  /**
   * @hidden
   */
  _aj() {
    this._ai = -1;
  }
  /**
   * Gets the cell at the specified column index in the owning row.
   * <p class="note">
   * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
   * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
   * the maximum column count, and pass in each index to the collection's indexer.
   * </p>
   * The cell at the specified column index in the owning row.
   * @param index The zero-based column index of the cell to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
   * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
   * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
   * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
   */
  item(a) {
    this._ah._ad();
    return this._h(a);
  }
  /**
   * @hidden
   */
  _h(a) {
    if (a < 0) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_IndexNegative"));
    }
    if (a >= this.maxCount) {
      this._ae(a);
    }
    return new WorksheetCell(this._ah, a);
  }
}
WorksheetCellCollection.$t = markType(WorksheetCellCollection, 'WorksheetCellCollection', RowColumnCollectionBase$1.$.specialize(WorksheetCell.$));
/**
 * @hidden
 */
export class DependencyGraph_StronglyConnectedComponentSorter extends Base {
  constructor() {
    super();
  }
  compare(a, b) {
    let c = typeCast(CellCalcReference.$, a);
    let d = typeCast(CellCalcReference.$, b);
    if (c == null || d == null) {
      return 0;
    }
    let e = c._u.index - d._u.index;
    if (e != 0) {
      return e;
    }
    e = c._w.index - d._w.index;
    if (e != 0) {
      return e;
    }
    e = c._ao - d._ao;
    if (e != 0) {
      return e;
    }
    return 0;
  }
}
DependencyGraph_StronglyConnectedComponentSorter.$t = markType(DependencyGraph_StronglyConnectedComponentSorter, 'DependencyGraph_StronglyConnectedComponentSorter', Base.$, [IComparer$1_$type.specialize(RefBase.$)]);
DependencyGraph_StronglyConnectedComponentSorter._a = new DependencyGraph_StronglyConnectedComponentSorter();
/**
 * @hidden
 */
export class NamedCalcReferenceBase extends RefBase {
  get__ao() {
    return -1;
  }
  get _ao() {
    return this.get__ao();
  }
  get__aj() {
    return true;
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
}
NamedCalcReferenceBase.$t = markType(NamedCalcReferenceBase, 'NamedCalcReferenceBase', RefBase.$);
/**
 * @hidden
 */
export class NamedCalcReference extends NamedCalcReferenceBase {
  constructor(a) {
    super();
    this._a4 = null;
    this._a2 = null;
    this._a2 = a;
  }
  get__formula() {
    return this._a4;
  }
  get__x() {
    return true;
  }
  containsReference(a) {
    let b = typeCast(NamedCalcReference.$, ExcelCalcEngine.b(a));
    if (b == null) {
      return false;
    }
    return b._a2 == this._a2;
  }
  get_context() {
    return this._a2;
  }
  get_elementName() {
    return this._a2.toString();
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(NamedCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a2 == b._a2;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a2);
  }
  isSubsetReference(a) {
    let b = typeCast(NamedCalcReference.$, ExcelCalcEngine.b(a));
    if (b == null) {
      return false;
    }
    return b._a2 == this._a2;
  }
  get__f() {
    return this._a4 || super.get__f();
  }
  _az(a) {
    this._a4 = a;
  }
  get__c() {
    return new ExcelCalcValue(this._formula);
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a2._k;
  }
  get _a3() {
    return this._a2;
  }
}
NamedCalcReference.$t = markType(NamedCalcReference, 'NamedCalcReference', NamedCalcReferenceBase.$);
/**
 * @hidden
 */
export class ExcelReferenceError extends RefBase {
  constructor() {
    super();
  }
  _au(a) {
  }
  get__ao() {
    return -1;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    return false;
  }
  get_elementName() {
    return "#REF!";
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    return typeCast(ExcelReferenceError.$, a) !== null;
  }
  getHashCode() {
    return 1;
  }
  isSubsetReference(a) {
    return false;
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
  get__c() {
    return new ExcelCalcValue(ExcelCalcErrorValue._f);
  }
  get _c() {
    return this.get__c();
  }
}
ExcelReferenceError.$t = markType(ExcelReferenceError, 'ExcelReferenceError', RefBase.$);
ExcelReferenceError._a2 = new ExcelReferenceError();
/**
 * @hidden
 */
export class WorksheetDataTableCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.d = 0;
    this.c = new WorksheetRegionAddress();
    this.e = Nullable$1.toNullable(WorksheetCellAddress.$, null);
    this.f = Nullable$1.toNullable(WorksheetCellAddress.$, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.d = e;
          this.c = this.a._j;
          let f = this.a.columnInputCell;
          if (WorksheetCell.l_op_Inequality(f, null)) {
            this.e = Nullable$1.toNullable(WorksheetCellAddress.$, f._e);
          }
          else {
            this.e = Nullable$1.toNullable(WorksheetCellAddress.$, null);
          }
          let g = this.a.rowInputCell;
          if (WorksheetCell.l_op_Inequality(g, null)) {
            this.f = Nullable$1.toNullable(WorksheetCellAddress.$, g._e);
          }
          else {
            this.f = Nullable$1.toNullable(WorksheetCellAddress.$, null);
          }
        }
        break;
    }
  }
  get workbook() {
    return this.b._d == null ? null : this.b._d.workbook;
  }
  get sheet() {
    return this.b._d;
  }
  get source() {
    return this.b._d;
  }
}
WorksheetDataTableCollection_CollectionChangeContext.$t = markStruct(WorksheetDataTableCollection_CollectionChangeContext, 'WorksheetDataTableCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[WorksheetDataTable]] instances on a worksheet.
 */
export class WorksheetDataTableCollection extends Base {
  constructor(a) {
    super();
    this._h = null;
    /**
     * @hidden
     */
    this._d = null;
    this._d = a;
    this._h = new List$1(WorksheetDataTable.$, 0);
  }
  static staticInit() {
    WorksheetDataTableCollection._a = WorksheetDataTableCollection._b();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddDataTable"));
  }
  /**
   * @hidden
   */
  contains(item) {
    return this._h.contains(item);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._h.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._h.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _add1(a, b, c) {
    WorksheetDataTable._ae(this._d, a, "cellsInTable", b, "columnInputCell", c, "rowInputCell");
    let d = null;
    this._o(-1, () => {
      d = new WorksheetDataTable(this._d, a, b, c);
      return d;
    });
    return d;
  }
  /**
   * Clears all data tables from the collection.
   * <p class="body">
   * Once a data table is removed from the collection, it can no longer be used.
   * </p>
   */
  clear() {
    if (this._h.count == 0) {
      return;
    }
    let a = this._m(11);
    for (let b = this._h.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._p(a);
  }
  /**
   * Removes the specified data table from the collection.
   * <p class="body">
   * Once a data table is removed from the collection, it can no longer be used.
   * </p>
   * @param dataTable The data table to remove from the collection.
   * @return True if the dataTable was successfully removed; False if the dataTable was not in the collection.
   */
  remove_1(dataTable) {
    let a = this._h.indexOf(dataTable);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the data table at the specified index from the collection.
   * <p class="body">
   * Once a data table is removed from the collection, it can no longer be used.
   * </p>
   * @param index The zero-based index of the data table to remove from the collection.
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    let a = this._h._inner[index];
    let b = WorksheetDataTableCollection._a[1];
    let c = null;
    let d = Nullable$1.toNullable(WorksheetDataTableCollection_CollectionChangeContext.$, null);
    let e = this._d.workbook;
    if (e != null && e._cx) {
      c = b.b(this._d.workbook, this._d, b.c);
      d = Nullable$1.toNullable(WorksheetDataTableCollection_CollectionChangeContext.$, new WorksheetDataTableCollection_CollectionChangeContext(1, this, a, index));
    }
    this._h.removeAt(index);
    a._z();
    if (nullableNotEquals(d, null)) {
      b.e(WorksheetDataTableCollection_CollectionChangeContext.$, WorksheetDataTable.$, d.value, a, null);
      if (c != null) {
        b.d(this._d.workbook, c);
      }
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetDataTableCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, WorksheetDataTableCollection._c(WorksheetDataTable.$, "Add", 29, (b) => b.a, (b, c) => WorksheetDataTableCollection._r(b, c)));
    ChangeInfo.f(a, 1, WorksheetDataTableCollection._c(WorksheetDataTable.$, "Remove", 30, (b) => b.a, (b, c) => WorksheetDataTableCollection._s(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _o(a, b, c = Nullable$1.toNullable(WorksheetDataTableCollection_CollectionChangeContext.$, null)) {
    let d = WorksheetDataTableCollection._a[0];
    let e = null;
    let f = this._d.workbook;
    if (f != null && f._cx) {
      e = d.b(this._d.workbook, this._d, d.c);
    }
    let g = b();
    if (a < 0) {
      a = this._h.count;
    }
    this._h.insert(a, g);
    if (nullableNotEquals(c, null)) {
      g._y(this._d, c.value.c, c.value.e, c.value.f);
    }
    if (f != null && f._cx) {
      let h = new WorksheetDataTableCollection_CollectionChangeContext(1, this, g, a);
      d.e(WorksheetDataTableCollection_CollectionChangeContext.$, WorksheetDataTable.$, h, null, g);
      if (e != null) {
        d.d(this._d.workbook, e);
      }
    }
  }
  /**
   * @hidden
   */
  _m(a) {
    let b = this._d.workbook;
    return b != null && b._cx ? b._go(this._d, a, null) : null;
  }
  /**
   * @hidden
   */
  _p(a) {
    if (a != null) {
      let b = this._d.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    a.b.remove_1(a.a);
  }
  /**
   * @hidden
   */
  static _s(a, b) {
    a.b._o(a.d, () => a.a, Nullable$1.toNullable(WorksheetDataTableCollection_CollectionChangeContext.$, a));
  }
  /**
   * Gets the number of data tables in the collection.
   * The number of data tables in the collection.
   */
  get count() {
    return this._h.count;
  }
  /**
   * Gets the data table at the specified index in the collection.
   * The data table at the specified index.
   * @param index The zero-based index of the data table to get.
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._h._inner[a];
  }
}
WorksheetDataTableCollection.$t = markType(WorksheetDataTableCollection, 'WorksheetDataTableCollection', Base.$, [ICollection$1_$type.specialize(WorksheetDataTable.$)]);
/**
 * @hidden
 */
WorksheetDataTableCollection._i = 0;
/**
 * @hidden
 */
WorksheetDataTableCollection._l = 1;
/**
 * @hidden
 */
WorksheetDataTableCollection._k = 2;
/**
 * @hidden
 */
WorksheetDataTableCollection._a = null;
/**
 * @hidden
 */
export class WorksheetColumnCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
        }
        break;
    }
  }
  get workbook() {
    return this.a.e._e.workbook;
  }
  get sheet() {
    return this.a.e._e;
  }
  get source() {
    return this.a.e._e;
  }
}
WorksheetColumnCollection_CollectionChangeContext.$t = markStruct(WorksheetColumnCollection_CollectionChangeContext, 'WorksheetColumnCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of columns in a worksheet.
 * <p class="body">
 * Columns in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * Therefore, if this collection is enumerated, it only enumerates the columns which were already accessed.
 * </p>
 * @see [[WorksheetColumn]]
 * @see [[Worksheet.columns]]
 */
export class WorksheetColumnCollection extends RowColumnCollectionBase$1 {
  constructor(a) {
    super(WorksheetColumn.$, a, Workbook.getMaxColumnCount(a._o));
    this._ak = null;
  }
  static staticInit() {
    WorksheetColumnCollection._ag = WorksheetColumnCollection._ah();
  }
  /**
   * @hidden
   */
  _createValue(a) {
    let b = new WorksheetColumn(this._e, a);
    return b;
  }
  /**
   * @hidden
   */
  _p() {
    return getEnumerator(this._n(0, this.maxCount - 1, true));
  }
  /**
   * @hidden
   */
  _getItemIndex(a) {
    return a.index;
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    return this._e._ex(a, b, c);
  }
  /**
   * @hidden
   */
  _initializeItemIndex(a, b, c) {
    a._a2(b, c);
  }
  /**
   * @hidden
   */
  _isItemStillValid(a) {
    return !a._m;
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get_maxCount() {
    return Workbook.getMaxColumnCount(this._e._o);
  }
  /**
   * Gets the maximum number of items allowed in this collection.
   */
  get maxCount() {
    return this.get_maxCount();
  }
  /**
   * @hidden
   */
  _ab() {
    super._ab();
    for (let a of fromEnum(this)) {
      a._x();
    }
  }
  /**
   * @hidden
   */
  _ae(a) {
    throw new InvalidOperationException(1, ExcelUtils.eg("LE_InvalidOperationException_MaxColumns", this._e.workbook._ff));
  }
  /**
   * @hidden
   */
  _af(a, b) {
    for (let c of fromEnum(this._e._ff)) {
      c.x(a, b);
    }
  }
  /**
   * @hidden
   */
  static _ai($tValue, a, b, c, d, e, f, g = true, h = true) {
    return new ChangeInfo$2(WorksheetColumnCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, g, f, h, null, null);
  }
  /**
   * @hidden
   */
  static _ah() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, WorksheetColumnCollection._ai(Number_$type, "Add", 97, (b) => b.a.h, (b, c) => WorksheetColumnCollection._ay(b, c), null, 64));
    ChangeInfo.f(a, 1, WorksheetColumnCollection._ai(Number_$type, "Remove", 98, (b) => b.a.h, (b, c) => WorksheetColumnCollection._a0(b, c), null, 512));
    return a;
  }
  /**
   * @hidden
   */
  _al(a, b, c, d = Nullable$1.toNullable(WorksheetColumnCollection_CollectionChangeContext.$, null)) {
    let e = this.maxCount;
    let f = c ? e - b : a;
    let g = new List$1(WorksheetColumn.$, 1, this._o(f, f + b - 1));
    let h = this._e._a0(f, b);
    let i = new WorksheetColumnCollection_CollectionChangeContextData(this, nullableNotEquals(d, null) && false == d.value.a.f, a, b, g.toArray(), h);
    let j = new WorksheetColumnCollection_CollectionChangeContext(1, i);
    let k = WorksheetColumnCollection._ag[c ? 0 : 1];
    return new WorksheetColumnCollection_InsertRemoveOperationWrapper(k, j, a, c, nullableNotEquals(d, null), nullableNotEquals(d, null) ? d.value.a.b : null, nullableNotEquals(d, null) ? d.value.a.a : null);
  }
  /**
   * @hidden
   */
  _aq(a, b, c, d, e = false) {
    c = 0;
    d = 0;
    let f = this._e.defaultColumnWidth;
    for (let g of fromEnum(this._e._ff)) {
      let h = 0;
      if (e || g.i == false) {
        if (g.v < 0) {
          h = f;
        }
        else {
          h = g.v;
        }
      }
      let i = Math.max(0, Math.min(g.r, a - 1) - g.q + 1);
      let j = Math.max(0, Math.min(g.r, b - 1) - g.q + 1);
      if (i == 0 && j == 0) {
        break;
      }
      c += i * h;
      d += j * h;
    }
    return {
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _ar(a, b, c, d, e = false) {
    c = 0;
    d = 0;
    let f = false;
    let g = this._e.defaultColumnWidth;
    for (let h of fromEnum(this._e._ff)) {
      let i = 0;
      if (e || h.i == false) {
        if (h.v < 0) {
          i = g;
        }
        else {
          i = h.v;
        }
      }
      let j = (h.r - h.q) + 1;
      let k = i * j;
      if (f == false) {
        if (a < k) {
          let l = (intDivide(a, i));
          c += l;
          a -= (l * i);
          f = true;
        }
        else {
          a -= k;
          c += j;
        }
      }
      if (b < k) {
        let m = (intDivide(b, i));
        d += m;
        b -= (m * i);
        return {
          p0: a,
          p1: b,
          p2: c,
          p3: d
        };
      }
      else {
        b -= k;
        d += j;
      }
    }
    if (d >= this.maxCount) {
      d = this.maxCount - 1;
    }
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  /**
   * @hidden
   */
  _as(a) {
    let b = new HashSet$1(WorksheetColumn.$, 0);
    for (let c of fromEnum(this._e._ff)) {
      if (c.i == false) {
        continue;
      }
      for (let d = c.q; d <= c.r; d++) {
        b.add_1(this.item(d));
      }
    }
    for (let e of fromEnum(a)) {
      b.remove(e);
      e.hidden = true;
    }
    for (let f of fromEnum(b)) {
      f.hidden = false;
    }
  }
  /**
   * Inserts one or more columns into the collection
   * <para class="note"><b>Note:</b> An equal number of columns will be removed (i.e. bumped) off the end of the collection.</para>
   * @param index the insertion point
   * @param count The number of columns to insert
   * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
   * @throws [[IndexOutOfRangeException]] If index is negative.
   * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
   */
  insert(index, count = 1) {
    this._a1();
    let a = this.maxCount;
    if (index < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (count < 1) {
      throw new ArgumentOutOfRangeException(1, "count");
    }
    if (index + count > a) {
      throw new InvalidOperationException(1, "Max columns exceeded");
    }
    let b = this._al(index, count, true);
    this._am(index, count, true, b);
  }
  /**
   * @hidden
   */
  _am(a, b, c, d, e = Nullable$1.toNullable(WorksheetColumnCollection_CollectionChangeContext.$, null)) {
    let f = WorksheetColumnCollection._ag[c ? 0 : 1];
    let g = c ? a : (a + b);
    let h = c ? (this.maxCount - (1 + b)) : (this.maxCount - 1);
    let i = c ? b : -b;
    let j = new CellShiftOperation(2, this._e, 0, null, 0, Workbook.getMaxRowCount(this._e._o) - 1, g, h, i, false);
    let k = this._e._b8(j, 2, d);
    this._ac(k.a);
    if (k.b != null && k.b.count > 0) {
      d.d.a.i(k.b.toArray());
    }
    let n = d.d.a.b;
    for (let m = 0; m < n.length; m++) {
      let l = n[m];
      l._a4();
    }
    if (nullableEquals(e, null)) {
      d.k();
      d.d.workbook._hm((o, p) => p._b6(d.d.workbook), true);
    }
    this._e._ig();
    this._e._h7();
    return d;
  }
  /**
   * @hidden
   */
  _au(a, b) {
    let c = this._k;
    for (let e = 0; e < a.length; e++) {
      let d = a[e];
      d._a3(this._e, c);
      let f = this._i(d, d.index);
    }
    this._e._ia(b);
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(WorksheetColumn.$, arguments[0]) !== null) {
        n = 0;
      }
      else if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return WorksheetItemCollection$1.prototype._remove$i.apply(this, arguments);
      case 1: return this._remove1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove1(a, b = 1) {
    this._a1();
    let c = this.maxCount;
    if (a < 0) {
      throw new IndexOutOfRangeException(1, "index");
    }
    if (b < 1) {
      throw new IndexOutOfRangeException(1, "count");
    }
    if (a + b > c) {
      throw new InvalidOperationException(1, "Max columns exceeded");
    }
    let d = this._al(a, b, false);
    this._am(a, b, false, d);
  }
  /**
   * @hidden
   */
  _aw(a) {
    if (a.d != null) {
      let d = a.d;
      for (let c = 0; c < d.length; c++) {
        let b = d[c];
        for (let e of fromEnum(b._columns$i)) {
          e._bs();
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ax(a) {
    if (a.d != null) {
      let d = a.d;
      for (let c = 0; c < d.length; c++) {
        let b = d[c];
        for (let e of fromEnum(b._columns$i)) {
          e._b4();
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _ay(a, b) {
    a.a.e._y();
    a.a.e._az(a, false);
  }
  /**
   * @hidden
   */
  _az(a, b) {
    let c = WorksheetColumnCollection._ag[b ? 0 : 1];
    if (this._ak == null) {
      this._ak = this._al(a.a.h, a.a.g, b, Nullable$1.toNullable(WorksheetColumnCollection_CollectionChangeContext.$, a));
      this._ak.i();
      if (!a.a.f) {
        this._am(a.a.h, a.a.g, b, this._ak, Nullable$1.toNullable(WorksheetColumnCollection_CollectionChangeContext.$, a));
      }
      else {
        a.a.e._ax(a.a);
      }
    }
    else {
      if (a.a.f) {
        this._am(a.a.h, a.a.g, b, this._ak, Nullable$1.toNullable(WorksheetColumnCollection_CollectionChangeContext.$, a));
      }
      this._ak.k();
      a.a.e._aw(a.a);
      a.workbook._hm((d, e) => e._b6(a.workbook), true);
      this._e._ig();
      this._e._h7();
      this._ak = null;
    }
  }
  /**
   * @hidden
   */
  static _a0(a, b) {
    a.a.e._y();
    a.a.e._az(a, true);
  }
  /**
   * @hidden
   */
  _a1() {
    if (this._e.workbook == null) {
      throw new InvalidOperationException(1, "The worrksheet has been deleted");
    }
  }
  /**
   * Gets the column at the specified index.
   * <p class="note">
   * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
   * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
   * the maximum column count, and pass in each index to the collection's indexer.
   * </p>
   * The column at the specified index.
   * @param index The zero-based index of the column to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
   * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
   * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
   */
  item(a) {
    return this._h(a);
  }
}
WorksheetColumnCollection.$t = markType(WorksheetColumnCollection, 'WorksheetColumnCollection', RowColumnCollectionBase$1.$.specialize(WorksheetColumn.$));
/**
 * @hidden
 */
WorksheetColumnCollection._an = 0;
/**
 * @hidden
 */
WorksheetColumnCollection._ap = 1;
/**
 * @hidden
 */
WorksheetColumnCollection._ao = 2;
/**
 * @hidden
 */
WorksheetColumnCollection._ag = null;
/**
 * @hidden
 */
export class WorksheetRegion_HorizontalSorter extends Base {
  constructor() {
    super();
  }
  compare(a, b) {
    return WorksheetRegion_HorizontalAddressSorter._a.compare(a._h, b._h);
  }
}
WorksheetRegion_HorizontalSorter.$t = markType(WorksheetRegion_HorizontalSorter, 'WorksheetRegion_HorizontalSorter', Base.$, [IComparer$1_$type.specialize(WorksheetRegion.$)]);
WorksheetRegion_HorizontalSorter._a = new WorksheetRegion_HorizontalSorter();
/**
 * @hidden
 */
export class DependencyGraph_EvaluationEnumerator extends Base {
  constructor(a) {
    super();
    this._b = null;
    this._a = null;
    this._d = false;
    this._c = null;
    this._a = a;
    this._c = this._a.b._c;
  }
  dispose() {
    this._c = null;
    this._a.c = null;
  }
  get current() {
    return this._b;
  }
  get currentObject() {
    return this.current;
  }
  moveNext() {
    if (this._d) {
      this._b = null;
      return false;
    }
    if (this._c == null) {
      this._c = this._a.b._c;
    }
    if (this._c == null) {
      this._d = true;
      this._b = null;
      return false;
    }
    let a = this._c;
    while (a != null && a._af == false) {
      a = a._j;
    }
    this._b = a;
    if (this._b != null) {
      this._c = this._b._j;
      return true;
    }
    this._d = true;
    this._c = null;
    return false;
  }
  reset() {
    this._d = false;
    this._c = null;
  }
  _e(a) {
    while (this._c != null && a.contains(this._c)) {
      this._c = this._c._k;
    }
  }
}
DependencyGraph_EvaluationEnumerator.$t = markType(DependencyGraph_EvaluationEnumerator, 'DependencyGraph_EvaluationEnumerator', Base.$, [IEnumerator$1_$type.specialize(RefBase.$)]);
/**
 * @hidden
 */
export class ObjectPool$2 extends Base {
  constructor($t, $tArg, a, b) {
    super();
    this.$t = null;
    this.$tArg = null;
    this.a = new Array(1024);
    this.d = null;
    this.c = null;
    this.e = 0;
    this.$t = $t;
    this.$tArg = $tArg;
    this.$type = this.$type.specialize(this.$t, this.$tArg);
    this.d = a;
    this.c = b;
  }
  b(a) {
    if (this.e == 0) {
      return this.d(a);
    }
    let b = this.a[--this.e];
    this.c(b, a);
    return b;
  }
  g(a) {
    if (this.e == 1024) {
      return;
    }
    this.a[this.e++] = a;
  }
}
ObjectPool$2.$t = markType(ObjectPool$2, 'ObjectPool$2');
/**
 * Stack of [[ExcelCalcValue]] instances used to evaluate formulas.
 * <p class="body">
 * The number stack is used for evaluating formulas.  When formulas are compiled, the formula tokens are
 * placed in a collection in post-fix, or Reverse Polish Notation (RPN) format.  RPN format arranges the formula token list so each
 * sub-expressions's terms are placed before their operator, and sub-expressions are ordered to enforce correct operator precedence.
 * This format allows the formula evaluate method to loop through the formula token collection front to back pushing an operator's terms onto
 * the number stack until an operator is reached.  Each time an operator is reached, it's subexpression is computed and resulting value pushed
 * onto the number stack.  Once the end of the end of the formula collection is reached, the formulas calculated value is at the top of the
 * number stack.
 * </p>
 */
export class ExcelCalcNumberStack extends Base {
  constructor(..._rest) {
    super();
    this._o = null;
    this._a = null;
    this._y = 0;
    this._z = 0;
    this._m = 0;
    this._j = null;
    this._t = false;
    this._q = null;
    this._v = null;
    let a;
    if (arguments.length === 0) {
      a = 1;
    }
    else if (arguments.length === 2) {
      a = 0;
    }
    switch (a) {
      case 0:
        {
          let formulaOwner = _rest[0];
          let formula = _rest[1];
          {
            this._v = new List$1(ExcelCalcValue.$, 0);
            if (ExcelCalcNumberStack._l == null) {
              ExcelCalcNumberStack._l = new ObjectPool$2(ExcelCalcValue.$, Base.$, (b) => new ExcelCalcValue(b), (b, c) => b._bt(c));
            }
          }
          this._o = formula;
          this._j = formulaOwner;
          this._m = CalcUtilities.h(this._j);
        }
        break;
      case 1:
        {
          this._v = new List$1(ExcelCalcValue.$, 0);
          if (ExcelCalcNumberStack._l == null) {
            ExcelCalcNumberStack._l = new ObjectPool$2(ExcelCalcValue.$, Base.$, (b) => new ExcelCalcValue(b), (b, c) => b._bt(c));
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _e(a) {
    let b = this._b(a, this._v.count);
    if (Base.referenceEquals(b, a) == false) {
      this._v._inner[this._v.count - 1] = b;
      a = b;
    }
    return a;
  }
  /**
   * @hidden
   */
  _f(a) {
    return this._b(a, this._v.count + 1);
  }
  /**
   * @hidden
   */
  _g(a) {
    let b = typeCast(SingleTargetFormula.$, a._getResolvedValue3(false));
    if (b != null) {
      let c = this._r;
      let d = this._j;
      if (a._y && b._af()) {
        let e = this.owningCell;
        if (WorksheetCell.l_op_Inequality(e, null)) {
          d = new TempCellCalcReference(true, e.worksheet, new WorksheetCellAddress(1, 0, 0));
        }
      }
      a = b._cf(c, d, this._u);
      if (a.isReference) {
        a._y = true;
      }
    }
    a._n = new CalculationContext(1, this, 32);
    if (this._u && a.isReference) {
      a._y = true;
    }
    return a;
  }
  /**
   * @hidden
   */
  _b(a, b) {
    if (this._a == null) {
      a._n.c = this._n;
    }
    else {
      let c = this._y - 1 - (this._z - b);
      if (c >= 0) {
        let d = this._a._v(c);
        a._n.c = this._a._j(c);
        if (this._k != null && this._k.formula != null && d && a.isReference && a._y) {
          if ((typeCast(ArrayInteriorFormula.$, this._k.formula) !== null) == false || this._a._j(c) != 64) {
            this._k.formula.addDynamicReferenceI(a.toReference());
            a._y = false;
          }
        }
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  get _p() {
    return this._o;
  }
  /**
   * @hidden
   */
  get _n() {
    return this._m;
  }
  /**
   * @hidden
   */
  get _k() {
    return this._j;
  }
  /**
   * @hidden
   */
  _d(a) {
    let b = this._z - this._y + a;
    if (b < 0) {
      return new ExcelCalcValue(null);
    }
    return this._v._inner[b];
  }
  /**
   * @hidden
   */
  get _u() {
    return this._t;
  }
  /**
   * @hidden
   */
  set _u(a) {
    this._t = a;
  }
  /**
   * Gets the [[WorksheetCell]] instance whose formula is currently being solved.
   */
  get owningCell() {
    let a = typeCast(CellCalcReference.$, this._k);
    if (a == null) {
      return null;
    }
    return a._w._cells$i.item(a._ao);
  }
  /**
   * @hidden
   */
  _ab() {
    this._a = null;
    this._y = 0;
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    this._z = this._v.count;
    this._a = a;
    this._y = b;
  }
  /**
   * @hidden
   */
  get _r() {
    if (this._q == null) {
      let a = typeCast(RefBase.$, ExcelCalcEngine.b(this._k));
      if (a == null) {
        return null;
      }
      this._q = a._t;
    }
    return this._q;
  }
  /**
   * @hidden
   */
  static _c(a) {
    return ExcelCalcNumberStack._l.b(a);
  }
  /**
   * @hidden
   */
  static _ad(a) {
    a._y = false;
    a._n = new CalculationContext();
    ExcelCalcNumberStack._l.g(a);
  }
  /**
   * Push a value onto number stack.
   * @param value Value to push onto the number stack
   */
  push(value) {
    if (value == null) {
      throw new ArgumentNullException(1);
    }
    value = this._g(value);
    this._v.add(value);
  }
  /**
   * Pop value off top of the number stack.
   * @return [[ExcelCalcValue]] that was at the top of the number stack.
   */
  pop() {
    let a = this._v._inner[this._v.count - 1];
    this._v.removeAt(this._v.count - 1);
    a = this._f(a);
    return a;
  }
  /**
   * Return value off top of the number stack.
   * @return [[ExcelCalcValue]] that is at the top of the number stack.
   */
  peek() {
    let a = this._v._inner[this._v.count - 1];
    a = this._e(a);
    return a;
  }
  /**
   * Remove all values from number stack.
   */
  clear() {
    this._v.clear();
  }
  /**
   * Clear elements off top of number stack until it contains given number of elements
   * @param elements Denotes the desired stack level
   */
  reset(elements) {
    this._v.v(elements, this._v.count - elements);
  }
  /**
   * Return the number of values on number stack
   * @return Number of stack values
   */
  count() {
    return this._v.count;
  }
  /**
   * @hidden
   */
  get _w() {
    if (true) {
      if (this._r != null) {
        return this._r._e6;
      }
      return ExcelUtils.cq;
    }
    return CultureInfo.invariantCulture;
  }
}
ExcelCalcNumberStack.$t = markType(ExcelCalcNumberStack, 'ExcelCalcNumberStack');
/**
 * @hidden
 */
ExcelCalcNumberStack._l = null;
/**
 * @hidden
 */
export class FormulaContext extends Base {
  constructor(a, ..._rest) {
    super();
    this.a = 1;
    this.n = null;
    this.g = 2;
    this.c = null;
    this.k = WorksheetCellAddress.b;
    this.e = null;
    this.i = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          this.e = c;
          if (this.e != null) {
            this.g = this.e.currentFormat;
            this.n = this.e._e6;
          }
          else {
            this.n = ExcelUtils.cq;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c || d._y];
          {
            let g = e[0];
            this.e = g;
            if (this.e != null) {
              this.g = this.e.currentFormat;
              this.n = this.e._e6;
            }
            else {
              this.n = ExcelUtils.cq;
            }
          }
          this.c = d;
          let f = this.c._t;
          this.i = f != null && f.type == 0 ? f : null;
          this.k = this.c._aa;
          if (this.e == null) {
            this.g = d._z;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = [null, c];
          {
            let h = f[0];
            let i = f[1];
            let j = [h || i._y];
            {
              let l = j[0];
              this.e = l;
              if (this.e != null) {
                this.g = this.e.currentFormat;
                this.n = this.e._e6;
              }
              else {
                this.n = ExcelUtils.cq;
              }
            }
            this.c = i;
            let k = this.c._t;
            this.i = k != null && k.type == 0 ? k : null;
            this.k = this.c._aa;
            if (this.e == null) {
              this.g = i._z;
            }
          }
          this.n = e || ExcelUtils.cq;
          this.a = d;
        }
        break;
      case 3:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = [c];
          {
            let j = h[0];
            this.e = j;
            if (this.e != null) {
              this.g = this.e.currentFormat;
              this.n = this.e._e6;
            }
            else {
              this.n = ExcelUtils.cq;
            }
          }
          this.c = g;
          this.i = d;
          if (e != null) {
            this.k = new WorksheetCellAddress(1, e.index, f);
          }
        }
        break;
      case 4:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          let j = [c == null ? null : c.workbook];
          {
            let l = j[0];
            this.e = l;
            if (this.e != null) {
              this.g = this.e.currentFormat;
              this.n = this.e._e6;
            }
            else {
              this.n = ExcelUtils.cq;
            }
          }
          this.a = i;
          this.g = f;
          this.c = g;
          this.i = c != null && c.type == 0 ? c : null;
          if (0 <= d && 0 <= e) {
            this.k = new WorksheetCellAddress(1, d, e);
          }
        }
        break;
      case 5:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = _rest[6];
          let j = _rest[7];
          this.a = i;
          this.n = h || ExcelUtils.cq;
          this.g = j;
          this.c = g;
          this.e = c;
          this.i = d;
          if (e != null) {
            this.k = new WorksheetCellAddress(1, e.index, f);
          }
        }
        break;
    }
  }
  get b() {
    return this.a;
  }
  get o() {
    return this.n;
  }
  get h() {
    return this.g;
  }
  get d() {
    return this.c;
  }
  get l() {
    return this.k;
  }
  get m() {
    if (this.i == null || false == this.k.e) {
      return null;
    }
    return this.i._rows$i.item(this.k.o);
  }
  get f() {
    return this.e;
  }
  get j() {
    return this.i;
  }
}
FormulaContext.$t = markType(FormulaContext, 'FormulaContext');
/**
 * @hidden
 */
export class FormulaEvaluator extends FormulaTokenVisitor {
  constructor() {
    super();
    this.a2 = null;
    this.a0 = null;
    this.a3 = null;
    this.a7 = false;
    this.bd = new Stack$1(Boolean_$type);
    this.az = null;
    this.a6 = null;
    this.a6 = new FormulaEvaluator_ShouldSplitParameterHelper();
  }
  g() {
    this.a2 = null;
    this.a0 = null;
    this.a3 = null;
    this.a7 = false;
    this.bd.g();
    this.az = null;
    super.g();
  }
  p(a) {
    let b = this.a1(a);
    if (b == null) {
      return;
    }
    let c = -1;
    let d;
    if (((() => { let e = b._toDouble1(d); d = e.p0; return e.ret; })())) {
      c = truncate(Math.floor(d));
    }
    if (c < 1 || a.skipTokenIndexes.count < c) {
      this.a0.push(new ExcelCalcValue(new ExcelCalcErrorValue(1)));
      this.bh(a.t);
      return;
    }
    if (1 < c) {
      this.d = a.skipTokenIndexes._inner[c - 2];
    }
  }
  q(a) {
    let b = this.a1(a);
    if (b == null) {
      return;
    }
    try {
      if (b._toBoolean1()) {
        return;
      }
    }
    catch (c) {
      this.a0.push(new ExcelCalcValue(c));
      this.bh(a.v);
      return;
    }
    this.d = a.skipTokenIndexes._inner[0];
    if (a.r == false) {
      this.a0.push(new ExcelCalcValue(false));
    }
  }
  r(a) {
    if (this.bd.d() && a.t != 0) {
      this.bh(a.t);
    }
  }
  v(a) {
    this.be(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a3), a, 2);
  }
  x(a) {
    super.x(a);
    if (typeCast(NamedCalcReferenceBase.$, this.a2) !== null && a.p) {
      this.a0.peek()._y = true;
    }
  }
  aa(a) {
    this.bj(a);
  }
  ab(a) {
    this.bj(a);
  }
  ac(a) {
    this.bj(a);
  }
  aj(a) {
    if (a.u._g == 1) {
      return;
    }
    super.aj(a);
  }
  am(a) {
    this.a0.push(new ExcelCalcValue(a.n(this.b)));
  }
  ay(a) {
    this.be(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a3), a, 1);
  }
  a8(a) {
    let b = this.az[a.selectorFunctionTokenIndex];
    if (b == null || a.skipTokenIndexes.count == 0) {
      return false;
    }
    let c = b.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a3);
    if (c == null) {
      return false;
    }
    return this.bc(c, a.selectorFunctionTokenIndex, 0, this.a0.peek()) == false;
  }
  be(a, b, c) {
    if (a == null) {
      this.bf(c);
      return;
    }
    try {
      this.a0._ac(a, c);
      if (this.a9(a, this.d, c) == false) {
        a._aj(this.a0, c);
      }
    }
    finally {
      this.a0._ab();
    }
  }
  bf(a) {
    for (let b = 0; b < a; b++) {
      this.a0.pop();
    }
    this.a0.push(new ExcelCalcValue(new ExcelCalcErrorValue(7)));
  }
  static a5(a, b, c) {
    if (FormulaEvaluator.a4 == null) {
      FormulaEvaluator.a4 = new FormulaEvaluator();
    }
    let d = FormulaEvaluator.a4;
    if (d.b != null) {
      d = new FormulaEvaluator();
    }
    d.b = a;
    d.a2 = b;
    d.a3 = a.f._w.d;
    d.a0 = c;
    d.a7 = c._u;
    d.az = a.d._e;
    d.b.d._cb();
    return d;
  }
  a9(a, b, c) {
    let d = new Array(c);
    let e = false;
    for (let f = 0; f < c; f++) {
      if (this.bb(a, b, f, d)) {
        e = true;
        d[f] = true;
      }
      else {
        d[f] = false;
      }
    }
    if (e == false) {
      return false;
    }
    let g = new Array(c);
    for (let h = c - 1; h >= 0; h--) {
      g[h] = this.a0.pop();
    }
    let i = 1;
    let j = 1;
    for (let k = 0; k < c; k++) {
      if (d[k] == false) {
        continue;
      }
      let l = g[k]._e();
      if (l == null) {
        continue;
      }
      let m = l.getLength(0);
      let n = l.getLength(1);
      if (m != 1) {
        if (i != 1 && i != m) {
          this.a0.push(new ExcelCalcValue(new ExcelCalcErrorValue(1)));
          return true;
        }
        i = m;
      }
      if (n != 1) {
        if (j != 1 && j != n) {
          this.a0.push(new ExcelCalcValue(new ExcelCalcErrorValue(1)));
          return true;
        }
        j = n;
      }
    }
    let o = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = i);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(j);
      }
      return $ret;
    })());
    for (let p = 0; p < i; p++) {
      for (let q = 0; q < j; q++) {
        for (let r = 0; r < c; r++) {
          let s = g[r];
          if (d[r]) {
            let t = s._e();
            let u = t.getLength(0);
            let v = t.getLength(1);
            let w = u == 1 ? 0 : p;
            let x = v == 1 ? 0 : q;
            s = t.item(w, x);
          }
          this.a0.push(s);
        }
        a._aj(this.a0, c);
        o[p][q] = this.a0.pop();
      }
    }
    this.a0.push(new ExcelCalcValue(o));
    return true;
  }
  bh(a) {
    this.d = (a - 1);
  }
  bb(a, b, c, d) {
    if (d != null && a._s && c > 0 && d[0]) {
      return this.a0._d(c)._s;
    }
    return this.bc(a, b, c, this.a0._d(c));
  }
  bc(a, b, c, d) {
    if (a._j(c) != 64) {
      return false;
    }
    if (d._s == false) {
      return false;
    }
    let e;
    if (typeCast(ArrayInteriorFormula.$, this.a0._k.formula) !== null) {
      e = false;
    }
    else {
      e = d.isReference;
    }
    let f = this.b.f;
    if (f == null) {
      return false;
    }
    return this.a6.bj(this.b, b, c, e);
  }
  a1(a) {
    let b = this.a8(a);
    this.bg(b);
    if (b == false) {
      return null;
    }
    let c = this.a0.pop();
    if (c.isError) {
      this.a0.push(new ExcelCalcValue(c.toErrorValue()));
      this.bh(a.selectorFunctionTokenIndex);
      return null;
    }
    return c;
  }
  ba() {
    let a = this.bd.e();
    this.bi();
    return a;
  }
  bg(a) {
    this.bd.h(a);
    this.bi();
  }
  bi() {
    this.a0._u = this.a7 || this.bd.f != 0;
  }
  bj(a) {
    let b = a.formulaToken;
    let c = b.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.a3);
    if (c != null && c._s && this.bd.f > 0 && this.ba()) {
      return;
    }
    this.be(c, b, a.argumentCount);
  }
}
FormulaEvaluator.$t = markType(FormulaEvaluator, 'FormulaEvaluator', FormulaTokenVisitor.$);
FormulaEvaluator.a4 = null;
/**
 * @hidden
 */
export class TempCellCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a3 = null;
    this._a9 = 0;
    this._a2 = null;
    this._a4 = null;
    this._a5 = new WorksheetCellAddress();
    this._a8 = false;
    this._a2 = b;
    this._a4 = b.type == 0 ? b : null;
    this._a5 = c;
    this._a9 = TempCellCalcReference._ba++;
    this._a8 = a;
  }
  get__x() {
    return true;
  }
  get__ao() {
    return this._a5.m;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    return false;
  }
  get_context() {
    return this;
  }
  get_elementName() {
    return stringEmpty();
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(TempCellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return Base.referenceEquals(this, b);
  }
  get__formula() {
    return this._a3;
  }
  getHashCode() {
    return this._a9;
  }
  _am() {
    return null;
  }
  _ae(a, b) {
    return false;
  }
  isSubsetReference(a) {
    return false;
  }
  get__f() {
    return EmptyReferencesCollection._a;
  }
  get__w() {
    return this._a5.o < 0 ? null : this._a4._rows$i.item(this._a5.o);
  }
  get _w() {
    return this.get__w();
  }
  _az(a) {
    this._a3 = a;
  }
  get__ak() {
    return false;
  }
  _a1(a) {
    if (this._a3 == null) {
      return;
    }
    let b = a._getResolvedValue();
    if (ExcelUtils.a9(b)) {
      b = 0;
    }
    else if (typeCast(HyperlinkResult.$, b) !== null && (typeCast(HyperlinkResult.$, a.value) !== null) == false) {
      b = b.toString();
    }
    this._a3._cd = new ExcelCalcValue(b);
  }
  get__c() {
    return this._formula._cd;
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a2.workbook;
  }
  get__u() {
    return this._a4;
  }
  get _a6() {
    return this._a3 != null && this._a3._ak;
  }
  get _a7() {
    return false;
  }
  get__as() {
    return this._a5.o;
  }
  get__r() {
    return this._a2;
  }
}
TempCellCalcReference.$t = markType(TempCellCalcReference, 'TempCellCalcReference', RefBase.$);
TempCellCalcReference._ba = 0;
/**
 * @hidden
 */
export class CalcUtilities extends Base {
  static i(a, b) {
    if (a == null) {
      return false;
    }
    let c = typeCast(CellCalcReference.$, b.context);
    if (c != null) {
      let d = c._w;
      let e = c._ao;
      return a._p(d, e);
    }
    let f = typeCast(WorksheetRegion.$, b.context);
    if (f != null) {
      return a._s(f);
    }
    let g = typeCast(List$1.$.specialize(WorksheetRegion.$), b.context);
    if (g != null) {
      for (let h of fromEnum(g)) {
        if (a._s(h)) {
          return true;
        }
      }
      return false;
    }
    return false;
  }
  static c(a) {
    if (a == null || typeof a === 'number' || typeof a === 'string') {
      return new ExcelCalcValue(a);
    }
    let b = typeCast(ErrorValue.$, a);
    if (b != null) {
      if (b == ErrorValue.circularity) {
        return new ExcelCalcValue(0);
      }
      return new ExcelCalcValue(b._a());
    }
    if (typeCast(FormattedString.$, a) !== null || typeCast(StringBuilder.$, a) !== null || typeCast(String_$type, a) !== null || typeCast(StringElement.$, a) !== null || typeCast(FormattedStringValueReference.$, a) !== null) {
      a = a.toString();
    }
    return new ExcelCalcValue(a);
  }
  static b(a) {
    let t1 = a;
    L0: while (true) {
      switch (t1) {
        case 42: return 3;
        case 7: return 2;
        case 0: return 6;
        case 23: return 0;
        case 36: return 4;
        case 29: return 7;
        case 15: return 1;
        default:
          t1 = 36;
          continue L0;
      }
      break;
    }
  }
  static h(a) {
    if (a == null) {
      return 64;
    }
    a = ExcelCalcEngine.b(a);
    if (typeCast(CellCalcReference.$, a) !== null) {
      return 64;
    }
    if (typeCast(NamedCalcReferenceBase.$, a) !== null) {
      return 32;
    }
    let b = typeCast(DataValidationCalcReference.$, a);
    if (b != null) {
      return b._bc ? 64 : 32;
    }
    let c = typeCast(TempCellCalcReference.$, a);
    if (c != null) {
      return c._a8 ? 64 : 32;
    }
    return 64;
  }
  static e(a, b, c, d, e) {
    return CalcUtilities.f(a, b, c, d, e, 1);
  }
  static f(a, b, c, d, e, f) {
    if (e != null) {
      let g;
      let h = ((() => { let i = e._ar(trimEnd(a), f, d, b, c, g); g = i.p5; return i.ret; })());
      if (h != null) {
        return h;
      }
    }
    return ExcelReferenceError._a2;
  }
  static a(a) {
    if (a == null) {
      return ((() => {
        let $firstRank;
        let $ret = new Array($firstRank = 0);
        let $currRet = $ret;
        for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
          $currRet[$rankInit] = new Array(0);
        }
        return $ret;
      })());
    }
    if (a.worksheet == null) {
      return ((() => {
        let $ret = new Array();
        $ret.push([new ExcelCalcValue(ErrorValue.invalidCellReference._a())]);
        return $ret;
      })());
    }
    let b = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = a._ad);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(a._aa);
      }
      return $ret;
    })());
    for (let c = a.firstRow, d = 0; c <= a.lastRow; c++ , d++) {
      let e = a.worksheet._rows$i.item(c);
      for (let f = a._v, g = 0; f <= a._w; f++ , g++) {
        b[g][d] = CalcUtilities.c(e._as(f));
      }
    }
    return b;
  }
  static l(a) {
    let b = typeCast(RefBase.$, ExcelCalcEngine.b(a));
    if (b == null) {
      return null;
    }
    return b._am() || boxArray$1(WorksheetRegion._a);
  }
  static g(a, b, c) {
    if (b.worksheet == null) {
      c = new ExcelCalcErrorValue(0);
      return {
        ret: null,
        p2: c
      };
    }
    c = null;
    let d;
    let e;
    if (((() => { let f = CalcUtilities.k(a, b._ad, b._aa, d, e); d = f.p3; e = f.p4; return f.ret; })()) == false) {
      c = new ExcelCalcErrorValue(3);
      return {
        ret: null,
        p2: c
      };
    }
    let f = e + b.firstRow;
    let g = (d + b._v);
    return {
      ret: b.worksheet._rows$i.item(f)._as(g),
      p2: c
    };
  }
  static m(a, b) {
    if (ExcelUtils.a9(a)) {
      return 0;
    }
    if (typeCast(ErrorValue.$, a) !== null) {
      return a;
    }
    if (typeof a === 'string' || typeCast(Boolean_$type, a) !== null || typeCast(Date_$type, a) !== null) {
      return a;
    }
    let c = typeCast(ExcelCalcErrorValue.$, a);
    if (c == null) {
      let d = typeCast(HyperlinkResult.$, a);
      if (d != null) {
        if (b) {
          return d.a;
        }
        return d;
      }
      try {
        let e = Convert.toDouble3(a);
        if (isNaN_(e)) {
          return ErrorValue.divisionByZero;
        }
        return e;
      }
      catch (f) {
        return a;
      }
    }
    let t1 = c.code;
    L0: while (true) {
      switch (t1) {
        case 0: return ErrorValue.invalidCellReference;
        case 1: return ErrorValue.wrongOperandType;
        case 2: return ErrorValue.divisionByZero;
        case 3: return ErrorValue.argumentOrFunctionNotAvailable;
        case 4: return ErrorValue.valueRangeOverflow;
        case 6: return ErrorValue.emptyCellRangeIntersection;
        case 7: return ErrorValue.wrongFunctionName;
        case 5: return ErrorValue.circularity;
        default:
          t1 = 0;
          continue L0;
      }
      break;
    }
  }
  static j(a, b) {
    if (a == null) {
      return false;
    }
    let c = typeCast(CellCalcReference.$, b.context);
    if (c != null) {
      let d = c._w;
      let e = c._ao;
      return a._p(d, e);
    }
    let f = typeCast(WorksheetRegion.$, b.context);
    if (f != null) {
      return a._o(f);
    }
    let g = typeCast(List$1.$.specialize(WorksheetRegion.$), b.context);
    if (g != null) {
      for (let h of fromEnum(g)) {
        if (a._o(h)) {
          return true;
        }
      }
      return false;
    }
    return false;
  }
  static d(a, b) {
    let c;
    let d;
    if (((() => { let e = CalcUtilities.k(b, a.getLength(0), a.getLength(1), c, d); c = e.p3; d = e.p4; return e.ret; })()) == false) {
      return null;
    }
    return a.item(c, d);
  }
  static k(a, b, c, d, e) {
    let f = a._ba(d, e);
    d = f.p0;
    e = f.p1;
    if (b <= d) {
      if (b == 1) {
        d = 0;
      }
      else {
        return {
          ret: false,
          p3: d,
          p4: e
        };
      }
    }
    if (c <= e) {
      if (c == 1) {
        e = 0;
      }
      else {
        return {
          ret: false,
          p3: d,
          p4: e
        };
      }
    }
    return {
      ret: true,
      p3: d,
      p4: e
    };
  }
}
CalcUtilities.$t = markType(CalcUtilities, 'CalcUtilities');
/**
 * @hidden
 */
export class DataValidationCalcReference extends CellCalcReferenceBase {
  constructor(a, b, c) {
    super(a, b);
    this._bc = false;
    this._bc = c;
    this._af = true;
  }
  containsReference(a) {
    return false;
  }
  _z(a) {
    let b = typeCast(DataValidationCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a3 == b._a3 && this._a8 == b._a8;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a3) ^ (this._a8 << 16);
  }
  isSubsetReference(a) {
    return false;
  }
  get__f() {
    return EmptyReferencesCollection._a;
  }
  get__ak() {
    return false;
  }
  get__c() {
    return this._formula._cd;
  }
}
DataValidationCalcReference.$t = markType(DataValidationCalcReference, 'DataValidationCalcReference', CellCalcReferenceBase.$);
/**
 * @hidden
 */
export class FormulaTokenEvaluator$1 extends FormulaTokenVisitor$1 {
  constructor($tStackItem) {
    super(Boolean_$type);
    this.$tStackItem = null;
    this.bf = null;
    this.$tStackItem = $tStackItem;
    this.$type = this.$type.specialize(this.$tStackItem);
    this.bf = new Stack$1(this.$tStackItem);
  }
  a1() {
    this.bf.g();
    super.a1();
  }
  r(a) {
    return this.ba(a);
  }
  t(a) {
    return this.bc(a);
  }
  w(a) {
    return this.bb(a);
  }
  x(a) {
    return this.bb(a);
  }
  y(a) {
    return this.bb(a);
  }
  ai(a) {
    return this.bc(a);
  }
  aj(a) {
    return this.bd(a);
  }
  al(a) {
    return this.bc(a);
  }
  am(a) {
    return this.bc(a);
  }
  aq(a) {
    return this.bc(a);
  }
  au(a) {
    return this.be(a);
  }
  a4(a, b) {
    return Type.getDefaultValue(this.$tStackItem);
  }
  a2() {
    return this.a3(true);
  }
  a3(a) {
    try {
      this.bf.g();
      let b;
      if (((() => { let c = this.ay(b); b = c.p0; return c.ret; })()) == false) {
        return new EvaluationResult$1(this.$tStackItem, 2, b);
      }
      if (this.bf.f != 1) {
        return new EvaluationResult$1(this.$tStackItem, 2, Nullable$1.toNullable(Number_$type, null));
      }
      return new EvaluationResult$1(this.$tStackItem, 1, this.bf.e());
    }
    finally {
      if (a) {
        this.a1();
      }
    }
  }
  ba(a) {
    if (this.bf.f < 2) {
      this.a0();
      return false;
    }
    let b = this.bf.e();
    let c = this.bf.e();
    let d = this.a5(a, c, b);
    this.bf.h(d);
    return true;
  }
  bb(a) {
    let b = new Array(a.argumentCount);
    for (let c = b.length - 1; c >= 0; c--) {
      b[c] = this.bf.e();
    }
    let d;
    let e = a.$function;
    if (e == null) {
      this.a0();
      return false;
    }
    if (e._qk) {
      d = this.bf.e();
    }
    else {
      d = this.a4(a, e._alx);
    }
    let f = this.a6(a, d, b);
    this.bf.h(f);
    return true;
  }
  bc(a) {
    let b = this.a7(a);
    this.bf.h(b);
    return true;
  }
  bd(a) {
    if (this.bf.f < 1) {
      this.a0();
      return false;
    }
    let b = this.a8(a, this.bf.e());
    this.bf.h(b);
    return true;
  }
  be(a) {
    if (this.bf.f < 1) {
      this.a0();
      return false;
    }
    let b = this.a9(a, this.bf.e());
    this.bf.h(b);
    return true;
  }
  get bg() {
    return this.bf;
  }
}
FormulaTokenEvaluator$1.$t = markType(FormulaTokenEvaluator$1, 'FormulaTokenEvaluator$1', FormulaTokenVisitor$1.$.specialize(Boolean_$type));
/**
 * @hidden
 */
export class FormulaEvaluator_ShouldSplitParameterHelper extends FormulaTokenEvaluator$1 {
  constructor() {
    super(Number_$type);
    this.bl = 0;
    this.bk = 0;
    this.bi = false;
    this.bh = null;
    this.bn = Nullable$1.toNullable(Boolean_$type, null);
    this.bm = 0;
  }
  a1() {
    this.bh = null;
    super.a1();
  }
  bj(a, b, c, d) {
    this.c = a;
    this.bn = Nullable$1.toNullable(Boolean_$type, null);
    this.bi = d;
    this.bl = c;
    this.bk = b;
    this.bm = -1;
    this.bh = a.f._w.d;
    this.ax();
    return !nullableIsNull(this.bn) ? this.bn.value : false;
  }
  a5(a, b, c) {
    if (this.az == this.bk) {
      this.bk = -1;
      this.bo(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, this.bl);
      this.bm = this.az;
    }
    else {
      if (b == this.bm) {
        this.bo(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, 0);
        this.bm = this.az;
      }
      else if (c == this.bm) {
        this.bo(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, 1);
        this.bm = this.az;
      }
    }
    return this.az;
  }
  a6(a, b, c) {
    if (this.az == this.bk) {
      this.bk = -1;
      this.bo(a.formulaToken.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, this.bl);
      this.bm = this.az;
    }
    else {
      for (let d = 0; d < c.length; d++) {
        if (c[d] == this.bm) {
          this.bo(a.formulaToken.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, d);
          this.bm = this.az;
          break;
        }
      }
    }
    return this.az;
  }
  a7(a) {
    return this.az;
  }
  a8(a, b) {
    if (b == this.bm) {
      this.bm = this.az;
    }
    return this.az;
  }
  a9(a, b) {
    if (this.az == this.bk) {
      this.bk = -1;
      this.bo(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, 0);
      this.bm = this.az;
    }
    else {
      if (b == this.bm) {
        this.bo(a.e(UltraCalcFunctionFactory.$, ExcelCalcFunction.$, GetCalcFunctionVisitor.a3, this.bh), this.az, 0);
        this.bm = this.az;
      }
    }
    return this.az;
  }
  bo(a, b, c) {
    if (a == null || nullableNotEquals(this.bn, null)) {
      return;
    }
    if (a.doesParameterAllowIntermediateResultArray(c, this.bi) == false) {
      this.bn = Nullable$1.toNullable(Boolean_$type, false);
    }
    else if (a._j(c) != 64) {
      this.bn = Nullable$1.toNullable(Boolean_$type, true);
    }
  }
}
FormulaEvaluator_ShouldSplitParameterHelper.$t = markType(FormulaEvaluator_ShouldSplitParameterHelper, 'FormulaEvaluator_ShouldSplitParameterHelper', FormulaTokenEvaluator$1.$.specialize(Number_$type));
/**
 * @hidden
 */
export class TokenReferenceResolver extends FormulaTokenEvaluator$1 {
  constructor() {
    super(FormulaToken.$);
    this.bl = new Stack$1(FormulaToken.$);
    this.bh = null;
    this.bm = new Stack$1(TokenReferenceResolver_SkipTokenInfo.$);
  }
  a5(a, b, c) {
    return a;
  }
  a6(a, b, c) {
    let d = typeCast(FunctionVOperator.$, a);
    if (d != null && d.$function._qp && this.bl.f > 0) {
      if (d.$function._vv == 1) {
        let e = typeCast(AttrIfToken.$, this.bl.e());
        if (e == null) {
          this.a0();
          return a.formulaToken;
        }
        e.skipTokenIndexes.clear();
        e.v = this.az;
        for (let f = 1; f < c.length; f++) {
          let g = this.bm.e();
          e.skipTokenIndexes.insert(0, g.b);
          g.a.t = this.az;
        }
      }
      else if (d.$function._vv == 100) {
        let h = typeCast(AttrChooseToken.$, this.bl.e());
        if (h == null) {
          return a.formulaToken;
        }
        h.skipTokenIndexes.clear();
        h.t = this.az;
        for (let i = 1; i < c.length; i++) {
          let j = this.bm.e();
          h.skipTokenIndexes.insert(0, j.b);
          j.a.t = this.az;
        }
      }
    }
    return a.formulaToken;
  }
  a7(a) {
    return a;
  }
  a8(a, b) {
    return a;
  }
  a9(a, b) {
    return a;
  }
  get_a() {
    return this.bh;
  }
  a1() {
    this.bl.g();
    this.bh = null;
    this.bm.g();
    super.a1();
  }
  l(a) {
    this.bl.h(a);
    return true;
  }
  m(a) {
    this.bl.h(a);
    return true;
  }
  n(a) {
    this.bm.h(new TokenReferenceResolver_SkipTokenInfo(1, a, this.az));
    return true;
  }
  static bj(a) {
    return TokenReferenceResolver.bk(a, a.d._e);
  }
  static bk(a, b) {
    if (TokenReferenceResolver.bi == null) {
      TokenReferenceResolver.bi = new TokenReferenceResolver();
    }
    TokenReferenceResolver.bi.bh = b;
    TokenReferenceResolver.bi.c = a;
    return TokenReferenceResolver.bi;
  }
}
TokenReferenceResolver.$t = markType(TokenReferenceResolver, 'TokenReferenceResolver', FormulaTokenEvaluator$1.$.specialize(FormulaToken.$));
TokenReferenceResolver.bi = null;
/**
 * @hidden
 */
export class EvaluationResult$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.a = null;
    this.c = false;
    this.e = Nullable$1.toNullable(Number_$type, null);
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.c = true;
          this.a = c;
          this.e = Nullable$1.toNullable(Number_$type, null);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          this.c = false;
          this.a = Type.getDefaultValue(this.$t);
          this.e = c;
        }
        break;
    }
  }
  get d() {
    return this.c;
  }
  get b() {
    return this.a;
  }
  get f() {
    return this.e;
  }
}
EvaluationResult$1.$t = markStruct(EvaluationResult$1, 'EvaluationResult$1');
/**
 * @hidden
 */
export class SpecialFormulaToken extends FormulaToken {
  constructor(a) {
    super(a);
  }
  get_n() {
    return false;
  }
  get n() {
    return this.get_n();
  }
}
SpecialFormulaToken.$t = markType(SpecialFormulaToken, 'SpecialFormulaToken', FormulaToken.$);
/**
 * @hidden
 */
export class TokenReferenceResolver_SkipTokenInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
}
TokenReferenceResolver_SkipTokenInfo.$t = markStruct(TokenReferenceResolver_SkipTokenInfo, 'TokenReferenceResolver_SkipTokenInfo');
/**
 * @hidden
 */
export class RefBase_DynamicReference extends RefBase {
  constructor(a) {
    super();
    this._a2 = null;
    this._a2 = a;
    this._e = this._a2._e;
  }
  get__formula() {
    return this._a2._formula;
  }
  get__x() {
    return this._a2._x;
  }
  get__ao() {
    return this._a2._ao;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    return this._a2.containsReference(a);
  }
  get_context() {
    return this._a2.context;
  }
  get_elementName() {
    return this._a2.elementName;
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    return this._a2._z(a);
  }
  getHashCode() {
    return this._a2.getHashCode();
  }
  _v() {
    return this._a2._v();
  }
  _am() {
    return this._a2._am();
  }
  get_isEnumerable() {
    return this._a2.isEnumerable;
  }
  get__aj() {
    return this._a2._aj;
  }
  isSubsetReference(a) {
    return this._a2.isSubsetReference(a);
  }
  get__references() {
    return this._a2._references;
  }
  get__l() {
    return this._a2;
  }
  _m(a, b, c) {
    return {
      ret: ((() => { let d = this._a2._m(a, b, c); a = d.p0; c = d.p2; return d.ret; })()),
      p0: a,
      p2: c
    };
  }
  _n(a, b) {
    return {
      ret: ((() => { let c = this._a2._n(a, b); b = c.p1; return c.ret; })()),
      p1: b
    };
  }
  get__w() {
    return this._a2._w;
  }
  get _w() {
    return this.get__w();
  }
  get__as() {
    return this._a2._as;
  }
  _az(a) {
    this._a2._az(a);
  }
  _o() {
    return this;
  }
  get_value() {
    return this._a2._b(true);
  }
  set_value(a) {
  }
  get__c() {
    return this._a2._c;
  }
  get _c() {
    return this.get__c();
  }
  get__q() {
    return this._a2._q;
  }
  get__t() {
    return this._a2._t;
  }
}
RefBase_DynamicReference.$t = markType(RefBase_DynamicReference, 'RefBase_DynamicReference', RefBase.$);
/**
 * @hidden
 */
export class NamedCalcReferenceUnconnected extends NamedCalcReferenceBase {
  constructor(a) {
    super();
    this._a2 = null;
    this._a2 = a;
  }
  containsReference(a) {
    return this.equals(a);
  }
  get_context() {
    return this._a2;
  }
  get_elementName() {
    return this._a2.toString();
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(NamedCalcReferenceUnconnected.$, a);
    if (b == null) {
      return false;
    }
    return this._a2.equals(b._a2);
  }
  getHashCode() {
    return this._a2.getHashCode();
  }
  isSubsetReference(a) {
    return this.equals(a);
  }
  get__c() {
    return new ExcelCalcValue(ExcelCalcErrorValue._e);
  }
  get _c() {
    return this.get__c();
  }
}
NamedCalcReferenceUnconnected.$t = markType(NamedCalcReferenceUnconnected, 'NamedCalcReferenceUnconnected', NamedCalcReferenceBase.$);
/**
 * @hidden
 */
export class EmptyReferencesCollection extends Base {
  constructor() {
    super();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  *_getEnumerator() {
    return undefined;
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
}
EmptyReferencesCollection.$t = markType(EmptyReferencesCollection, 'EmptyReferencesCollection', Base.$, [IExcelCalcReferenceCollectionEx_$type]);
EmptyReferencesCollection._a = new EmptyReferencesCollection();
/**
 * @hidden
 */
export class DependencyGraph_FinishTimeSorter extends Base {
  constructor() {
    super();
  }
  compare(a, b) {
    if (a._aq < b._aq) {
      return -1;
    }
    if (a._aq > b._aq) {
      return 1;
    }
    return 0;
  }
}
DependencyGraph_FinishTimeSorter.$t = markType(DependencyGraph_FinishTimeSorter, 'DependencyGraph_FinishTimeSorter', Base.$, [IComparer$1_$type.specialize(RefBase.$)]);
DependencyGraph_FinishTimeSorter._a = new DependencyGraph_FinishTimeSorter();
/**
 * @hidden
 */
export class ArrayValueContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.b = 0;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = null;
          this.b = c;
          this.c = d;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
}
ArrayValueContext.$t = markStruct(ArrayValueContext, 'ArrayValueContext');
/**
 * @hidden
 */
export class ConditionalFormatCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.b = null;
    this.c = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.c = d;
          this.d = e;
          let f = d.regions.count;
          this.a = new Array(f);
          for (let g = 0; g < f; g++) {
            this.a[g] = d.regions.item(g)._h;
          }
        }
        break;
    }
  }
  get workbook() {
    return this.b._x;
  }
  get sheet() {
    return this.b._y;
  }
  get source() {
    return this.b._y;
  }
}
ConditionalFormatCollection_CollectionChangeContext.$t = markStruct(ConditionalFormatCollection_CollectionChangeContext, 'ConditionalFormatCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class ConditionalFormatCollection_PriorityChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.a = c;
          this.b = d;
          this.d = e;
          this.c = f;
        }
        break;
    }
  }
  get workbook() {
    return this.a._x;
  }
  get sheet() {
    return this.a._y;
  }
  get source() {
    return this.a._y;
  }
}
ConditionalFormatCollection_PriorityChangeContext.$t = markStruct(ConditionalFormatCollection_PriorityChangeContext, 'ConditionalFormatCollection_PriorityChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class ConditionalFormatCollection_ShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.e = null;
    this.c = null;
    this.d = null;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          this.e = c;
          this.c = d != null ? d.toArray() : null;
          this.d = f != null ? f.toArray() : null;
          this.b = e != null ? e.toArray() : null;
          this.a = g != null ? g.toArray() : null;
        }
        break;
    }
  }
  f() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    ConditionalFormatCollection._ag.clear();
    ConditionalFormatCollection._af.clear();
    ConditionalFormatCollection._ah.clear();
    let b = this.workbook._df;
    this.workbook._df = false;
    let c = this.b != null ? new List$1(ConditionBase.$, 2, this.b.length) : null;
    let d = this.a != null ? ConditionalFormatCollection._af : null;
    let e = this.c != null ? ConditionalFormatCollection._ag : null;
    let f = this.d != null ? ConditionalFormatCollection._ah : null;
    if (this.a != null) {
      for (let g = this.a.length - 1; g >= 0; g--) {
        let h = this.a[g];
        let i = this.e.indexOf(h);
        if (i >= 0) {
          let j = new Array(h.regions.count);
          for (let k = 0; k < j.length; k++) {
            j[k] = h.regions.item(k)._h;
          }
          d.insert(0, Tuple.b(ConditionBase.$, Number_$type, Array_$type, h, i, j));
          this.e._aj.removeAt(i);
          h._bj();
        }
      }
    }
    if (this.b != null) {
      for (let l = 0; l < this.b.length; l++) {
        let m = this.b[l];
        let n = m.c;
        this.e._aj.insert(m.d, n);
        c.add(n);
        n._bs(m.e);
      }
    }
    if (this.c != null) {
      let q = this.c;
      for (let p = 0; p < q.length; p++) {
        let o = q[p];
        let r = o.c;
        let s = new Array(r.regions.count);
        for (let t = 0; t < s.length; t++) {
          s[t] = r.regions.item(t)._h;
        }
        r._bk(this.sheet, o.d);
        e.add(Tuple.a(ConditionBase.$, Array_$type, r, s));
      }
    }
    if (this.d != null) {
      let w = this.d;
      for (let v = 0; v < w.length; v++) {
        let u = w[v];
        let x = u.c.undoFormulaShift(u.d, u.e);
        if (x != null) {
          f.add(Tuple.b(ISupportFormulaShifts_$type, Base.$, String_$type, u.c, u.d, x));
        }
      }
    }
    let y = ConditionalFormatCollection._a[3];
    let z = new ConditionalFormatCollection_ShiftChangeContext(1, this.e, e, d, f, c);
    y.x(z, null, null);
    this.workbook._df = b;
    ConditionalFormatCollection._ag.clear();
    ConditionalFormatCollection._af.clear();
    ConditionalFormatCollection._ah.clear();
  }
  get workbook() {
    return this.e._x;
  }
  get sheet() {
    return this.e._y;
  }
  get source() {
    return this.e._y;
  }
}
ConditionalFormatCollection_ShiftChangeContext.$t = markStruct(ConditionalFormatCollection_ShiftChangeContext, 'ConditionalFormatCollection_ShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Collection class for objects which derive from [[ConditionBase]].
 * <p class="body">
 * To enable a conditional format on a <see cref="WorksheetRegion">region</see>
 * of worksheet <see cref="WorksheetCell">cells</see>, add a [[ConditionBase]]-derived
 * instance to this collection.
 * </p>
 * <p class="body">
 * This collection exposes an Add method for each type of conditional format available.
 * </p>
 * <p class="body">
 * For example, to add a conditional format which is based on a value and a logical
 * operator, use the [[addOperatorCondition]]
 * method.
 * </p>
 * <p class="body">
 * The conditional formatting classes which derive from [[ConditionalFormatBase]]
 * expose a <see cref="ConditionalFormatBase.CellFormat">CellFormat</see> property, which
 * in turn exposes properties which control the visual attributes of cells which meet the
 * criteria defined by the condition. This format is applied to cells with a value which
 * passes the condition.
 * </p>
 * @see [[ConditionBase]]
 * @see [[addAverageCondition]]
 * @see [[addBlanksCondition]]
 * @see [[addColorScaleCondition]]
 * @see [[addDataBarCondition]]
 * @see [[addDateTimeCondition]]
 * @see [[addDuplicateCondition]]
 * @see [[addErrorsCondition]]
 * @see [[addFormulaCondition]]
 * @see [[addIconSetCondition]]
 * @see [[addNoBlanksCondition]]
 * @see [[addNoErrorsCondition]]
 * @see [[addOperatorCondition]]
 * @see [[addRankCondition]]
 * @see [[addTextCondition]]
 * @see [[addUniqueCondition]]
 */
export class ConditionalFormatCollection extends Base {
  constructor(a) {
    super();
    this._aa = false;
    /**
     * @hidden
     */
    this._y = null;
    /**
     * @hidden
     */
    this._aj = null;
    this._y = a;
    this._aj = new List$1(ConditionBase.$, 0);
  }
  static staticInit() {
    ConditionalFormatCollection._a = ConditionalFormatCollection._b();
  }
  /**
   * Returns the total number of items in the collection.
   */
  get count() {
    return this._aj.count;
  }
  /**
   * Indexer
   * @param index The zer-based index of an item
   * @return The item at the specified index
   * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
   */
  item(a) {
    return this._aj._inner[a];
  }
  /**
   * @hidden
   */
  get _x() {
    return this._y != null ? this._y.workbook : null;
  }
  /**
   * @hidden
   */
  get _z() {
    return this._y;
  }
  /**
   * @hidden
   */
  _as(a, b = false) {
    this._at(this._aj.count, a, b);
  }
  /**
   * @hidden
   */
  _at(a, b, c = true, d = null) {
    let e = ConditionalFormatCollection._a[0];
    let f = new ConditionalFormatCollection_CollectionChangeContext(1, this, b, a);
    let g = e.b(this._y.workbook, this._y, e.c);
    this._aj.insert(a, b);
    if (d != null) {
      b._bs(d);
    }
    e.e(ConditionalFormatCollection_CollectionChangeContext.$, ConditionBase.$, f, null, b);
    if (g != null) {
      e.d(this._y.workbook, g);
    }
    if (c) {
      b._ba();
    }
  }
  /**
   * Adds a new [[OperatorConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param conditionOperator A [[FormatConditionOperator]] value which defines the initial value of the [[OperatorConditionalFormat.operator]] property. This parameter is optional and defaults to <i>Equal</i>.
   * @return The resulting [[OperatorConditionalFormat]] instance.
   * @see [[OperatorConditionalFormat]]
   */
  addOperatorCondition(regionAddress, conditionOperator = 2) {
    let a = this._c(regionAddress);
    let b = new OperatorConditionalFormat(1, boxArray$1(a), conditionOperator);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[FormulaConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param formula The formula which is used to determine whether a cell value meets the condition criteria.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @return The resulting [[FormulaConditionalFormat]] instance.
   * @see [[FormulaConditionalFormat]]
   * @see [[FormulaConditionalFormat.formula]]
   * @see [[FormulaConditionalFormat.setFormula]]
   */
  addFormulaCondition(regionAddress, formula, cellReferenceMode) {
    if (arguments[2] !== void 0) {
      arguments[2] = wrapNullable(CellReferenceMode_$type, arguments[2]);
    }
    return this._addFormulaCondition$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _addFormulaCondition$i(a, b, c = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    let d = this._d(a, c);
    let e = new FormulaConditionalFormat(1, boxArray$1(d), b, c);
    this._ax(0, e);
    return e;
  }
  /**
   * Adds a new [[RankConditionalFormat]] instance to this collection.
   * <p class="body">
   * A <i>RankConditionalFormat</i> can be used, for example, to format the "top ten" values in a given cell range.
   * </p>
   * <p class="body">
   * To change the number of top or bottom values, use the [[RankConditionalFormat.rank]] property.
   * </p>
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param topBottom A [[FormatConditionTopBottom]] value which determines whether the top or bottom of the ranking is evaluated. This parameter is optional and defaults to <i>Top</i>.
   * @param rank The numeric, percentage, or percentile ranking. This parameter is optional and defaults to <i>10</i>.
   * @return The resulting [[RankConditionalFormat]] instance.
   * @see [[RankConditionalFormat]]
   */
  addRankCondition(regionAddress, topBottom = 1, rank = 10) {
    let a = this._c(regionAddress);
    let b = new RankConditionalFormat(1, boxArray$1(a), topBottom, 10);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[AverageConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param aboveBelow A [[FormatConditionAboveBelow]] value which defines the initial value of the [[AverageConditionalFormat.aboveBelow]] property. This parameter is optional and defaults to <i>AboveAverage</i>.
   * @return The resulting [[AverageConditionalFormat]].
   * @see [[AverageConditionalFormat]]
   */
  addAverageCondition(regionAddress, aboveBelow = 0) {
    let a = this._c(regionAddress);
    let b = new AverageConditionalFormat(1, boxArray$1(a), aboveBelow);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[UniqueConditionalFormat]] instance to this collection,
   * configured as a unique value condition.
   * <p class="body">
   * Use this method to add a condition which evaluates to true only for cell values which
   * are unique across the associated range.
   * </p>
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[UniqueConditionalFormat]] instance.
   * @see [[UniqueConditionalFormat]]
   * @see [[addDuplicateCondition]]
   */
  addUniqueCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new UniqueConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[DuplicateConditionalFormat]] instance to this collection,
   * configured as a duplicate value condition.
   * <p class="body">
   * Use this method to add a condition which evaluates to true only for cell values which
   * are non-unique across the associated range.
   * </p>
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[DuplicateConditionalFormat]] instance.
   * @see [[DuplicateConditionalFormat]]
   * @see [[addUniqueCondition]]
   */
  addDuplicateCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new DuplicateConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[DateTimeConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param dateOperator A [[FormatConditionTimePeriod]] which defines the time period against which cell date values are evaluated. This parameter is optional and defaults to <i>Today</i>.
   * @return The resulting [[DateTimeConditionalFormat]] instance.
   * @see [[DateTimeConditionalFormat]]
   */
  addDateTimeCondition(regionAddress, dateOperator = 0) {
    let a = this._c(regionAddress);
    let b = new DateTimeConditionalFormat(1, boxArray$1(a), dateOperator);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[TextOperatorConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param text A string which determines the string against which cell text values are evaluated. This parameter is optional and defaults to <i>null</i>.
   * @param textOperator A [[FormatConditionTextOperator]] value which determines the manner in which cell values are compared to the 'text' value. This parameter is optional and defaults to <i>BeginsWith</i>.
   * @return The resulting [[TextOperatorConditionalFormat]] instance.
   * @see [[TextOperatorConditionalFormat]]
   */
  addTextCondition(regionAddress, text = null, textOperator = 0) {
    let a = this._c(regionAddress);
    let b = new TextOperatorConditionalFormat(1, boxArray$1(a), text, textOperator);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[BlanksConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[BlanksConditionalFormat]] instance.
   * @see [[BlanksConditionalFormat]]
   * @see [[addNoBlanksCondition]]
   */
  addBlanksCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new BlanksConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[NoBlanksConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[NoBlanksConditionalFormat]] instance.
   * @see [[NoBlanksConditionalFormat]]
   * @see [[addBlanksCondition]]
   */
  addNoBlanksCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new NoBlanksConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[ErrorsConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[ErrorsConditionalFormat]] instance.
   * @see [[ErrorsConditionalFormat]]
   * @see [[addNoErrorsCondition]]
   */
  addErrorsCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new ErrorsConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[NoErrorsConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[NoErrorsConditionalFormat]] instance.
   * @see [[ErrorsConditionalFormat]]
   * @see [[addErrorsCondition]]
   */
  addNoErrorsCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new NoErrorsConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[ColorScaleConditionalFormat]] instance to this collection.
   * <p class="body">
   * Note that when <i>TwoColor</i> is specified as the value of the 'colorScaleType'
   * parameter, the [[ColorScaleConditionalFormat.midpointThreshold]] property is not applicable;
   * attempting to set properties on the object returned from that property causes an exception to be thrown.
   * </p>
   * <p class="body">
   * The [[ColorScaleConditionalFormat.minimumThreshold]] and [[ColorScaleConditionalFormat.maximumThreshold]]
   * properties can be used to customize the coloring and threshold boundaries for the minimum and maximum points of the associated
   * range.
   * </p>
   * <p class="body">
   * For a 3-color scale, the [[ColorScaleConditionalFormat.midpointThreshold]] can also
   * be used to customize the midpoint threshold boundary.
   * </p>
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param colorScaleType A [[ColorScaleType]] value which determines whether to add a 2-color or 3-color scale.
   * @return The resulting [[ColorScaleConditionalFormat]] instance.
   * @see [[ColorScaleConditionalFormat]]
   * @see [[ColorScaleCriterion]]
   */
  addColorScaleCondition(regionAddress, colorScaleType) {
    let a = this._c(regionAddress);
    let b = new ColorScaleConditionalFormat(1, boxArray$1(a), colorScaleType);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[IconSetConditionalFormat]] instance to this collection.
   * <p class="body">
   * Each constant in the [[FormatConditionIconSet]] enumeration contains either
   * 3, 4, or 5 in its name. This number identifies the number of thresholds supported by
   * the condition.
   * </p>
   * <p class="body">
   * A three-threshold condition supports thresholds of 33%, 67%, and 100%.
   * </p>
   * <p class="body">
   * A four-threshold condition supports thresholds of 25%, 50%, 75%, and 100%.
   * </p>
   * <p class="body">
   * A five-threshold condition supports thresholds of 20%, 40%, 60%, 80%, and 100%.
   * </p>
   * <p class="body">
   * A [[ColorScaleCriterion]] object for each threshold, is returned
   * from the [[IconSetConditionalFormat.iconCriteria]]
   * collection.
   * </p>
   * <p class="body">
   * These objects provide the ability to customize the values for the corresponding
   * threshold. For example, the icon that is displayed for a given index can be
   * overridden using the [[IconCriterion.icon]] property.
   * </p>
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @param iconSet A [[FormatConditionIconSet]] value which identifies the icon set to use. This parameter is optional and defaults to <i>IconSet3TrafficLights1</i>.
   * @return The resulting [[IconSetConditionalFormat]] instance.
   * @see [[IconSetConditionalFormat]]
   * @see [[IconSetConditionalFormat.iconCriteria]]
   * @see [[IconCriterion]]
   */
  addIconSetCondition(regionAddress, iconSet = 4) {
    let a = this._c(regionAddress);
    let b = new IconSetConditionalFormat(1, boxArray$1(a), iconSet);
    this._ax(0, b);
    return b;
  }
  /**
   * Adds a new [[DataBarConditionalFormat]] instance to this collection.
   * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
   * @return The resulting [[DataBarConditionalFormat]] instance.
   */
  addDataBarCondition(regionAddress) {
    let a = this._c(regionAddress);
    let b = new DataBarConditionalFormat(1, boxArray$1(a));
    this._ax(0, b);
    return b;
  }
  /**
   * Removes all items from the collection.
   */
  clear() {
    let a = this._aj.count > 1 ? this._ar(28) : null;
    for (let b = this._aj.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._a3(a);
  }
  /**
   * Returns true if the collection contains the condition
   * @param condition The condition
   */
  contains(condition) {
    return this._aj.contains(condition);
  }
  /**
   * @hidden
   */
  static _e($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ConditionalFormatCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _f($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ConditionalFormatCollection_PriorityChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _g($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(ConditionalFormatCollection_ShiftChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, ConditionalFormatCollection._e(ConditionBase.$, "Add", 28, (b) => b.c, (b, c) => ConditionalFormatCollection._a8(b, c)));
    ChangeInfo.f(a, 1, ConditionalFormatCollection._e(ConditionBase.$, "Remove", 28, (b) => b.c, (b, c) => ConditionalFormatCollection._ba(b, c)));
    ChangeInfo.f(a, 2, ConditionalFormatCollection._f(ConditionBase.$, "Priority", 28, (b) => b.b, (b, c) => ConditionalFormatCollection._a9(b, c)));
    ChangeInfo.f(a, 3, ConditionalFormatCollection._g(Base.$, "Shift", 28, (b) => null, (b, c) => b.f()));
    return a;
  }
  /**
   * @hidden
   */
  _ar(a) {
    let b = this._y.workbook;
    return b != null && b._cx ? b._go(this._y, a, null) : null;
  }
  /**
   * @hidden
   */
  _a3(a) {
    if (a != null) {
      let b = this._y.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return this._aj.getEnumerator();
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return this._aj.getEnumerator();
  }
  /**
   * @hidden
   */
  _av(a, b, c) {
    let d = this._aj;
    let e = d.count;
    for (let f = 0; f < e; f++) {
      let g = d._inner[f];
      if (g != null && g._ad(b, c)) {
        a.add(g);
      }
    }
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    let c = this.count;
    for (let d = 0; d < c; d++) {
      let e = typeCast(ConditionalFormatBase.$, this.item(d));
      if (e != null && !stringIsNullOrEmpty(e.cellFormat.formatString)) {
        for (let f = 0; f < e.regions.count; f++) {
          let g = e.regions.item(f);
          if (g._q(a, b)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Gets the index of the item in the collection
   * @param condition
   * @return The index or -1 if the item is not in the collection
   */
  indexOf(condition) {
    return this._aj.indexOf(condition);
  }
  /**
   * @hidden
   */
  _ax(a, b) {
    this._at(a, b);
  }
  /**
   * @hidden
   */
  _ay(a) {
    let b = this.count;
    for (let c = 0; c < b; c++) {
      this._aj._inner[c]._a9(a);
    }
  }
  /**
   * @hidden
   */
  _az(a, b) {
    let c = this._x;
    if (c._c4) {
      return;
    }
    let d = this._aj.count;
    let e = a.index;
    let f = b;
    for (let g = 0; g < d; g++) {
      let h = this._aj._inner[g];
      switch (h._j) {
        case 0: break;
        case 2:
          h._ba();
          break;
        case 1:
          {
            let i = true;
            for (let j = 0; j < h.regions.count; j++) {
              let k = h.regions.item(j);
              if (k._q(e, f)) {
                if (i == true) {
                  i = false;
                  h._bb();
                }
                c._hv(k);
              }
            }
          }
          break;
      }
    }
  }
  /**
   * @hidden
   */
  _a0(a) {
    switch (a) {
      case 0:
      case 1: return;
    }
    let b = this._y._o;
    switch (b) {
      default: return;
      case 0:
      case 1: break;
    }
    for (let c = 0; c < this._aj.count; c++) {
      let d = this._aj._inner[c];
      d._bc();
      if (d.regions.count == 0) {
        this._aj.removeAt(c);
        c--;
      }
    }
  }
  /**
   * @hidden
   */
  _ad(a, b, c, d) {
    if (this._y._tables$i._k(b, c)) {
      return false;
    }
    this._av(a, b, c);
    if (a.count > 1 || (b == 0 && c == 0)) {
      return false;
    }
    let e = Math.max(0, b - 3);
    let f = Math.max(0, c - 3);
    let g = b == e;
    let h = g ? b : b - 1;
    let i = g ? (c - 1) : c;
    while (i >= f && h >= e) {
      this._av(a, h, i);
      if (a.count > 0) {
        for (let j = 0; j < a.count; j++) {
          let k = a._inner[j];
          let l = d ? k._al : k._am;
          if (l) {
            l = !this._y._tables$i._k(h, i);
          }
          if (l) {
            l = k._y(b, c, !g);
          }
          if (!l) {
            a.removeAt(j);
            j--;
          }
        }
        if (a.count > 0) {
          return true;
        }
      }
      g = h <= e;
      if (g) {
        i--;
      }
      else {
        h--;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _a1(a) {
    if (this._y._t) {
      return;
    }
    let b = a._h;
    let c = new WorksheetCellAddress(1, b._ac, b._w);
    let d = new WorksheetRegionAddress(2, c, c);
    let e = new WorksheetReferenceCollection(a);
    e._remove2(d);
    for (let f = 0; f < this._aj.count; f++) {
      let g = this._aj._inner[f];
      g._bh(c, e);
      if (g.regions.count == 0) {
        this.removeAt(f);
        f--;
      }
    }
  }
  /**
   * @hidden
   */
  _a2(a, b) {
    if (b != null && b.isUndoOperation) {
      return;
    }
    if (ConditionalFormatCollection._ag == null) {
      ConditionalFormatCollection._ag = new List$1(Tuple$2.$.specialize(ConditionBase.$, Array_$type), 0);
    }
    else {
      ConditionalFormatCollection._ag.clear();
    }
    if (ConditionalFormatCollection._ah == null) {
      ConditionalFormatCollection._ah = new List$1(Tuple$3.$.specialize(ISupportFormulaShifts_$type, Base.$, String_$type), 0);
    }
    else {
      ConditionalFormatCollection._ah.clear();
    }
    if (ConditionalFormatCollection._af == null) {
      ConditionalFormatCollection._af = new List$1(Tuple$3.$.specialize(ConditionBase.$, Number_$type, Array_$type), 0);
    }
    else {
      ConditionalFormatCollection._af.clear();
    }
    if (ConditionalFormatCollection._ai == null) {
      ConditionalFormatCollection._ai = new List$1(WorksheetRegionAddress.$, 0);
    }
    else {
      ConditionalFormatCollection._ai.clear();
    }
    let c = a.h;
    for (let d = 0; d < this._aj.count; d++) {
      let e = this._aj._inner[d];
      ConditionalFormatCollection._ai.clear();
      let f = e.regions;
      for (let g = 0; g < f.count; g++) {
        let h = f.item(g);
        let i = h._h;
        ConditionalFormatCollection._ai.add(i);
      }
      let j = e._aj(this._aa, a, b, ConditionalFormatCollection._ai);
      if (e.regions.count > 0) {
        e.shiftFormulas((k, l, m) => ConditionalFormatCollection._ah.add(Tuple.b(ISupportFormulaShifts_$type, Base.$, String_$type, k, l, m)), a, b);
      }
      if (j) {
        if (e.regions.count == 0) {
          e._bj();
          ConditionalFormatCollection._af.add(Tuple.b(ConditionBase.$, Number_$type, Array_$type, e, d + ConditionalFormatCollection._af.count, ConditionalFormatCollection._ai.toArray()));
          this._aj.removeAt(d);
          d--;
        }
        else {
          ConditionalFormatCollection._ag.add(Tuple.a(ConditionBase.$, Array_$type, e, ConditionalFormatCollection._ai.toArray()));
        }
      }
    }
    ConditionalFormatCollection._ai.clear();
    if (ConditionalFormatCollection._ag.count > 0 || ConditionalFormatCollection._af.count > 0 || ConditionalFormatCollection._ah.count > 0) {
      let k = this._y.workbook._df;
      this._y.workbook._df = false;
      let l = ConditionalFormatCollection._a[3];
      let m = new ConditionalFormatCollection_ShiftChangeContext(1, this, ConditionalFormatCollection._ag, ConditionalFormatCollection._af, ConditionalFormatCollection._ah, null);
      l.x(m, null, null);
      this._y.workbook._df = k;
    }
    for (let n of fromEnum(ConditionalFormatCollection._ag)) {
      n.c._ba();
    }
    ConditionalFormatCollection._ah.clear();
    ConditionalFormatCollection._ag.clear();
    ConditionalFormatCollection._af.clear();
  }
  /**
   * Removes an item from the collection
   * @param condition
   * @return true is the item was removed or false if the item wasn't in the collection
   */
  remove(condition) {
    let a = this._aj.indexOf(condition);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes an item from the collection at a specifoed index
   * @param index The zero based index in the collection
   */
  removeAt(index) {
    let a = this._aj._inner[index];
    let b = ConditionalFormatCollection._a[1];
    let c = new ConditionalFormatCollection_CollectionChangeContext(1, this, a, index);
    let d = b.b(this._y.workbook, this._y, b.c);
    a._bj();
    this._aj.removeAt(index);
    b.e(ConditionalFormatCollection_CollectionChangeContext.$, ConditionBase.$, c, a, null);
    if (d != null) {
      b.d(this._y.workbook, d);
    }
    a._ba();
  }
  /**
   * @hidden
   */
  _a5(a, b) {
    let c = this._aj.indexOf(b);
    if (c < 0) {
      return;
    }
    let d = a - 1;
    d = Math.max(0, Math.min(d, this._aj.count - 1));
    let e = ConditionalFormatCollection._a[2];
    let f = new ConditionalFormatCollection_PriorityChangeContext(1, this, b, c, d);
    let g = e.b(this._y.workbook, this._y, e.c);
    this._aj.removeAt(c);
    this._aj.insert(d, b);
    e.e(ConditionalFormatCollection_PriorityChangeContext.$, ConditionBase.$, f, b, null);
    if (g != null) {
      e.d(this._y.workbook, g);
    }
    b._ba();
  }
  /**
   * @hidden
   */
  _a6(a = false) {
    this._aa = a;
  }
  /**
   * @hidden
   */
  _a7() {
    this._aa = false;
  }
  /**
   * @hidden
   */
  static _a8(a, b) {
    let c = a.b.indexOf(a.c);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _ba(a, b) {
    let c = a.c;
    a.b._at(a.d, c, true, a.a);
  }
  /**
   * @hidden
   */
  static _a9(a, b) {
    let c = a.b;
    a.a._a5(a.d + 1, a.b);
  }
  /**
   * @hidden
   */
  _c(a) {
    return this._y._getRegions1(a, this._y._c);
  }
  /**
   * @hidden
   */
  _d(a, b) {
    return this._y._getRegions1(a, nullableNotEquals(b, null) ? b.value : this._y._c);
  }
  /**
   * @hidden
   */
  _aw(a) {
    this.clear();
    if (a == null || a.count < 1) {
      return;
    }
    for (let b = 0, c = a.count; b < c; b++) {
      let d = a.item(b);
      this._as(d);
      for (let e of fromEnum(d.regions)) {
      }
    }
  }
}
ConditionalFormatCollection.$t = markType(ConditionalFormatCollection, 'ConditionalFormatCollection', Base.$, [IEnumerable$1_$type.specialize(ConditionBase.$)]);
/**
 * @hidden
 */
ConditionalFormatCollection._ak = 0;
/**
 * @hidden
 */
ConditionalFormatCollection._ap = 1;
/**
 * @hidden
 */
ConditionalFormatCollection._ao = 2;
/**
 * @hidden
 */
ConditionalFormatCollection._aq = 3;
/**
 * @hidden
 */
ConditionalFormatCollection._an = 4;
/**
 * @hidden
 */
ConditionalFormatCollection._a = null;
/**
 * @hidden
 */
ConditionalFormatCollection._ag = null;
/**
 * @hidden
 */
ConditionalFormatCollection._ah = null;
/**
 * @hidden
 */
ConditionalFormatCollection._af = null;
/**
 * @hidden
 */
ConditionalFormatCollection._ai = null;
/**
 * @hidden
 */
export class HyperlinkResult extends Base {
  constructor(a, b) {
    super();
    this.a = null;
    this.b = null;
    this.a = b;
    this.b = a;
  }
  toString() {
    return this.a;
  }
}
HyperlinkResult.$t = markType(HyperlinkResult, 'HyperlinkResult');
/**
 * @hidden
 */
export class FormulaStringGenerator extends FormulaTokenEvaluator$1 {
  constructor() {
    super(String_$type);
    this.bq = null;
    this.bm = false;
    this.bh = null;
    this.bo = '\0';
    this.bp = null;
    this.bp = new List$1(AttrSpaceToken.$, 0);
  }
  a4(a, b) {
    return b;
  }
  a2() {
    this.bp.clear();
    if (this.bh != null) {
      arrayClear1(this.bh, 0, this.bh.length);
    }
    let a = super.a2();
    if (a.d == false) {
      return a;
    }
    if (this.bn) {
      return new EvaluationResult$1(String_$type, 1, "=" + a.b);
    }
    return a;
  }
  a5(a, b, c) {
    let d = this.bt(0, 1);
    let e = stringFormat1("{0}{1}{2}{3}", b, d, this.bs(a), c);
    this.bv(a, e);
    return e;
  }
  a6(a, b, c) {
    let d = this.bt(4, 5);
    let e = this.bt(0, 1);
    let f = new StringBuilder(2, stringFormat("{0}{1}(", e, b));
    for (let g = 0; g < c.length; g++) {
      f.l(c[g]);
      if (g != c.length - 1) {
        f.h(this.bo);
      }
    }
    f.l(stringFormat("{0})", d));
    let h = f.toString();
    this.bv(a.formulaToken, h);
    return h;
  }
  a7(a) {
    let b = this.bt(0, 1);
    let c = b + this.bs(a);
    this.bv(a, c);
    return c;
  }
  a8(a, b) {
    let c = this.bt(2, 3);
    let d = this.bt(4, 5);
    let e = stringFormat("{0}({1}{2})", c, b, d);
    this.bv(a, e);
    return e;
  }
  a9(a, b) {
    let c = this.bt(0, 1);
    let d = a.n ? "{0}{1}{2}" : "{2}{0}{1}";
    let e = stringFormat(d, c, this.bs(a), b);
    this.bv(a, e);
    return e;
  }
  a1() {
    this.bq = null;
    this.bm = false;
    this.bh = null;
    this.bo = '\0';
    this.bp.clear();
    super.a1();
  }
  o(a) {
    if (this.bm == false) {
      this.bp.add(a);
    }
    return true;
  }
  v(a) {
    let b = this.bs(a);
    this.bv(a, b);
    this.bf.h(b);
    return true;
  }
  at(a) {
    let b = this.bs(a);
    this.bv(a, b);
    this.bf.h(b);
    return true;
  }
  bs(a) {
    return a.l(this.c, GetFormulaStringInfo.a);
  }
  bt(...a) {
    let b = stringEmpty();
    for (let c = this.bp.count - 1; c >= 0; c--) {
      let d = this.bp._inner[c];
      for (let e = 0; e < a.length; e++) {
        let f = a[e];
        if (d.t == f) {
          this.bp.removeAt(c);
          b = this.bs(d) + b;
          break;
        }
      }
    }
    return b;
  }
  static bj(a) {
    return FormulaStringGenerator.bl(a, false);
  }
  static bk(a, b) {
    let c = FormulaStringGenerator.bj(a);
    c.bh = b;
    return c;
  }
  static bl(a, b) {
    if (FormulaStringGenerator.bi == null) {
      FormulaStringGenerator.bi = new FormulaStringGenerator();
    }
    FormulaStringGenerator.bu(FormulaStringGenerator.bi, a, b);
    return FormulaStringGenerator.bi;
  }
  static bu(a, b, c) {
    a.bm = c;
    a.bq = b.o.numberFormat.numberDecimalSeparator;
    a.bo = FormulaParser.by(a.bq);
    a.c = b;
  }
  bv(a, b) {
    if (this.bh != null) {
      this.bh[this.az] = b;
    }
  }
  get_bn() {
    return true;
  }
  get bn() {
    return this.get_bn();
  }
}
FormulaStringGenerator.$t = markType(FormulaStringGenerator, 'FormulaStringGenerator', FormulaTokenEvaluator$1.$.specialize(String_$type));
FormulaStringGenerator.bi = null;
/**
 * @hidden
 */
export class AttrTokenBase extends SpecialFormulaToken {
  constructor() {
    super(255);
  }
  get_f() {
    return 25;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return getInstanceType(this).typeName;
  }
  static o(a, b, c) {
    let d = ((() => { let e = a.readByteFromBuffer(b, c); b = e.p0; c = e.p1; return e.ret; })());
    switch (d) {
      case 1: return {
        ret: new AttrVolatileToken(),
        p1: b,
        p2: c
      };
      case 2: return {
        ret: new AttrIfToken(),
        p1: b,
        p2: c
      };
      case 4: return {
        ret: new AttrChooseToken(),
        p1: b,
        p2: c
      };
      case 8: return {
        ret: new AttrSkipToken(),
        p1: b,
        p2: c
      };
      case 16: return {
        ret: new AttrSumToken(),
        p1: b,
        p2: c
      };
      case 32: break;
      case 64: return {
        ret: new AttrSpaceToken(0),
        p1: b,
        p2: c
      };
      case 65: return {
        ret: new AttrSpaceVolitileToken(0),
        p1: b,
        p2: c
      };
      default: break;
    }
    return {
      ret: null,
      p1: b,
      p2: c
    };
  }
  get_q() {
    return false;
  }
  get q() {
    return this.get_q();
  }
}
AttrTokenBase.$t = markType(AttrTokenBase, 'AttrTokenBase', SpecialFormulaToken.$);
/**
 * @hidden
 */
export class WhitespaceId extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = 0;
    this.a = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = d;
          this.a = c;
        }
        break;
    }
  }
  equals(a) {
    let b = Nullable$1.toNullable(WhitespaceId.$, typeCast(WhitespaceId.$, a));
    if (nullableEquals(b, null)) {
      return false;
    }
    return b.getValueOrDefault().b == this.b && b.getValueOrDefault().a == this.a;
  }
  getHashCode() {
    return this.b << 8 | this.a;
  }
}
WhitespaceId.$t = markStruct(WhitespaceId, 'WhitespaceId');
/**
 * @hidden
 */
export class AttrSpaceToken extends AttrTokenBase {
  constructor(a, ..._rest) {
    super();
    this.u = 0;
    this.s = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.u = c;
          this.s = d;
        }
        break;
    }
  }
  static r(a, b) {
    if (AttrSpaceToken.w == null) {
      AttrSpaceToken.w = new Dictionary$2(WhitespaceId.$, AttrSpaceToken.$, 0);
    }
    let c = new WhitespaceId(1, b, a);
    let d;
    if (((() => { let e = AttrSpaceToken.w.tryGetValue(c, d); d = e.p1; return e.ret; })()) == false) {
      d = new AttrSpaceToken(1, a, b);
      AttrSpaceToken.w.item(c, d);
    }
    return d;
  }
  m(a) {
    a.s(this);
  }
  d($tResult, a) {
    return a.o(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.o(this, b);
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.u == d.u && this.s == d.s;
  }
  l(a, b) {
    switch (this.s) {
      case 0:
      case 2:
      case 4:
      case 6: return stringCreateFromChar(' ', this.u);
      default: return stringCreateFromChar('\n', this.u);
    }
  }
  get_p() {
    return 64;
  }
  get p() {
    return this.get_p();
  }
  get v() {
    return this.u;
  }
  set v(a) {
    this.u = a;
  }
  get t() {
    return this.s;
  }
  set t(a) {
    this.s = a;
  }
}
AttrSpaceToken.$t = markType(AttrSpaceToken, 'AttrSpaceToken', AttrTokenBase.$);
AttrSpaceToken.w = null;
/**
 * @hidden
 */
export class FormulaParser extends Base {
  constructor() {
    super();
    this.cu = null;
    this.cw = null;
    this.b8 = null;
    this.b9 = null;
    this.bz = '\0';
    this.i = 0;
    this.b4 = '\0';
    this.r = new FormulaParser_TextSpan();
    this.cp = 0;
    this.af = false;
    this.g = null;
    this.cg = 0;
    this.p = null;
    this.b7 = null;
    this.dx = null;
    this.cd = null;
    this.cb = null;
    this.cc = null;
    this.ca = null;
    this.dy = null;
    this.x = null;
    this.b6 = null;
    this.j = null;
    this.ce = 0;
    this.cf = 0;
    this.dg = null;
    this.dk = null;
    this.di = null;
    this.dm = null;
    this.dp = null;
    this.dr = null;
    this.dt = null;
    this.dv = null;
    this.b8 = new List$1(FormulaParser_FormulaTokenInfo.$, 0);
    this.b9 = new List$1(FormulaParser_FormulaTokenInfo.$, 0);
    this.dx = new StringBuilder(0);
    this.p = new FormulaParser_StructuredTableReferenceParser(this);
    this.dy = new StringBuilder(0);
    this.cd = new Stack$1(FormulaParser_SelectorFunctionOptimizationInfo.$);
    this.cb = new Stack$1(Number_$type);
    this.cc = new Stack$1(FormulaParser_FormulaTokenInfo.$);
    this.ca = new List$1(AttrSpaceToken.$, 0);
    this.b6 = new Dictionary$2(String_$type, WorkbookReferenceBase.$, 0);
  }
  static b(a, b) {
    let c = null;
    switch (stringToLocaleUpper(a, b)) {
      case "#NULL!":
        c = ErrorValue.emptyCellRangeIntersection;
        break;
      case "#DIV/0!":
        c = ErrorValue.divisionByZero;
        break;
      case "#VALUE!":
        c = ErrorValue.wrongOperandType;
        break;
      case "#REF!":
        c = ErrorValue.invalidCellReference;
        break;
      case "#NAME?":
        c = ErrorValue.wrongFunctionName;
        break;
      case "#NUM!":
        c = ErrorValue.valueRangeOverflow;
        break;
      case "#N/A":
        c = ErrorValue.argumentOrFunctionNotAvailable;
        break;
      default: return null;
    }
    return c;
  }
  static d(a, b, c, d, e, f, g) {
    if (FormulaParser.m == null) {
      FormulaParser.m = new FormulaParser();
    }
    let h = FormulaParser.k(b, c, e, d);
    FormulaParser.m.ec(a, c, h);
    FormulaParser.m.b7 = f;
    FormulaParser.m.cf = 0;
    FormulaParser.m.ce = 0;
    let i = FormulaParser.m.c();
    g = FormulaParser.m.h;
    return {
      ret: i,
      p6: g
    };
  }
  static e(a, b, c, d, e, f, g, h, i) {
    if (FormulaParser.m == null) {
      FormulaParser.m = new FormulaParser();
    }
    let j = FormulaParser.k(b, c, e, d);
    FormulaParser.m.ec(a, c, j);
    FormulaParser.m.b7 = f;
    FormulaParser.m.cf = g;
    FormulaParser.m.ce = h;
    let k = FormulaParser.m.c();
    i = FormulaParser.m.h;
    return {
      ret: k,
      p8: i
    };
  }
  static f(a, b, c, d, e) {
    if (FormulaParser.m == null) {
      FormulaParser.m = new FormulaParser();
    }
    FormulaParser.m.ec(a, b, c);
    FormulaParser.m.b7 = d;
    FormulaParser.m.cf = 0;
    FormulaParser.m.ce = 0;
    let f = FormulaParser.m.c();
    e = FormulaParser.m.h;
    return {
      ret: f,
      p4: e
    };
  }
  ec(a, b, c) {
    this.g = null;
    this.af = false;
    this.r = FormulaParser_TextSpan.a;
    this.cp = 0;
    this.cg = 0;
    this.b8.clear();
    this.b9.clear();
    this.cd.g();
    this.cb.g();
    this.cc.g();
    this.b6.clear();
    this.j = c;
    if (c.f != null) {
      this.x = this.j.f._bb;
      c.d._al = true;
    }
    else {
      this.x = new WorkbookReferenceUnconnected(null, false);
    }
    this.cw = a;
    this.i = b;
    this.cu = this.j.o.numberFormat.numberDecimalSeparator;
    this.b4 = FormulaParser.by(this.cu);
    this.bz = FormulaParser.bw(this.cu);
  }
  c() {
    if (this.cw.length > this.ch) {
      this.h = new FormulaParseException(0, this.cw, stringFormat(ExcelUtils.ef("LE_FormulaParseException_TooLong"), this.ch), this.cw);
      return null;
    }
    this.cp = 0;
    if (this.bq('=') == false) {
      this.h = new FormulaParseException(0, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoEqualsSign"), this.cw);
      return null;
    }
    this.ee();
    if (this.av(true) == false) {
      if (this.h == null) {
        this.h = new FormulaParseException(0, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoExpressions"), this.cw.substr(1));
      }
      return null;
    }
    if (this.cp != this.cw.length) {
      this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_ExtraExpressions"), this.cw.substr(this.cp));
      return null;
    }
    if (this.af) {
      this.j.d._ax = true;
      this.b9.add(new FormulaParser_FormulaTokenInfo(1, new AttrVolatileToken(), 0, null));
    }
    let a = this.q();
    if (!a.b) {
      this.h = new FormulaParseException(a.d, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidArguments"), this.cw.substr(a.d, a.c));
      return null;
    }
    let b = new Array(this.b9.count);
    for (let c = 0; c < this.b9.count; c++) {
      b[c] = this.b9._inner[c].b;
    }
    this.j.d._e = b;
    let d = new Array(this.b9.count);
    let e = null;
    let f = -1;
    let g = TokenClassResolver.bj(this.j, this.i);
    let h = g.a2();
    if (nullableNotEquals(h.f, null)) {
      e = d[h.f.value];
      f = this.b9._inner[h.f.value].c;
    }
    if (h.d == false) {
      this.h = new FormulaParseException(f, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidArguments"), e);
      return null;
    }
    if (this.i == 3 || this.i == 4) {
      for (let i = 0; i < this.b9.count; i++) {
        let j = this.b9._inner[i];
        let k = typeCast(CellReferenceToken.$, j.b);
        if (k != null && k.q == false) {
          e = d[i];
          f = j.c;
          this.h = new FormulaParseException(f, this.cw, ExcelUtils.ef("LE_FormulaParseException_NamedReferenceRefsNeedSheetName"), e);
          return null;
        }
      }
    }
    else if (this.i == 7) {
      let l = FormulaParser_ParseFormulaValidator.a4(this);
      if (l >= 0) {
        e = d[l];
        f = this.b9._inner[l].c;
        this.h = new FormulaParseException(f, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidConditionalFormatFormula"), e);
        return null;
      }
    }
    this.j.d._ac = true;
    return this.j.d;
  }
  av(a) {
    let b = this.cp;
    if (this.a5() == false) {
      let c = this.o();
      let d;
      if (((() => { let e = this.ah(a, d); d = e.p1; return e.ret; })())) {
        if (d == false) {
          this.a5();
          let e = this.cp;
          this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_MissingArgumentBeforeBinary"), this.cw.substr(b, e - b));
        }
      }
      this.eg(c);
      return false;
    }
    while (true) {
      let f = this.o();
      let g = this.cp;
      let h;
      if (((() => { let i = this.ah(a, h); h = i.p1; return i.ret; })()) == false) {
        this.eg(f);
        return true;
      }
      let i = this.cp;
      if (this.a5() == false) {
        if (this.h != null) {
          return false;
        }
        if (h == false) {
          this.h = new FormulaParseException(g, this.cw, ExcelUtils.ef("LE_FormulaParseException_MissingArgumentAfterBinary"), this.cw.substr(b, this.cp - b));
          return false;
        }
        this.eg(f);
        return true;
      }
      b = i;
    }
  }
  a5() {
    if (this.be() == false) {
      return false;
    }
    while (true) {
      if (this.h != null) {
        return false;
      }
      let a = this.o();
      if (this.bh() == false) {
        this.eg(a);
        return true;
      }
    }
  }
  be() {
    if (this.aw()) {
      return true;
    }
    if (this.ai()) {
      return true;
    }
    if (this.a6()) {
      return true;
    }
    if (this.at()) {
      return true;
    }
    if (this.a2()) {
      return true;
    }
    let a = this.cp;
    if (this.bi()) {
      if (this.be()) {
        return true;
      }
      if (this.h == null) {
        this.h = new FormulaParseException(a, this.cw, ExcelUtils.ef("LE_FormulaParseException_MissingArgumentAfterUnary"), this.cw.substr(a, this.cp - a));
      }
      return false;
    }
    if (this.bg()) {
      return true;
    }
    let b = this.cp;
    if (this.a4()) {
      if (this.av(true)) {
        if (this.aj()) {
          return true;
        }
        this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_UnmatchedOpenParen"), this.cw.substr(b, this.cp - b));
      }
      if (this.h == null) {
        this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_MissingArgumentAfterParen"), this.cw.substr(b, this.cp - b));
      }
      return false;
    }
    if (this.ag()) {
      return true;
    }
    return false;
  }
  ag() {
    if (this.h != null) {
      return false;
    }
    let a = this.b8.count;
    let b = this.r;
    let c = this.cp;
    if (this.bq('{') == false) {
      return false;
    }
    this.ee();
    if (this.ay(c) == false) {
      return false;
    }
    if (this.bq('}') == false) {
      let d = this.cw.indexOf('}', this.cp);
      if (d >= 0) {
        this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_ArrayContainsConstants"), this.cw.substr(c, d - c + 1));
      }
      else {
        this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_UnmatchedOpenBracket"), this.cw.substr(c, this.cp - c));
      }
      return false;
    }
    let e = 0;
    for (let f = a; f < this.b8.count; f++) {
      if (typeCast(MatrixRowSeparatorToken.$, this.b8._inner[f].b) !== null) {
        break;
      }
      if ((typeCast(UnionOperator.$, this.b8._inner[f].b) !== null) == false) {
        e++;
      }
    }
    if (e == 0) {
      this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_ArrayHasEmptyFirstRow"), this.cw.substr(c, this.cp - c));
      return false;
    }
    let g = this.b8.count - a;
    g -= (intDivide(g, 2));
    let h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_ArrayHasMisalignedRows"), this.cw.substr(c, this.cp - c));
    let i = intDivide(g, e);
    let j = new Array(e);
    for (let k = 0; k < e; k++) {
      j[k] = new Array(i);
    }
    let l = a;
    for (let m = 0; m < i; m++) {
      for (let n = 0; n < e; n++) {
        let o = this.b8._inner[l];
        let p = o.b;
        let q = typeCast(NumberToken.$, p);
        let r = typeCast(IntToken.$, p);
        let s = typeCast(StrToken.$, p);
        let t = typeCast(BoolToken.$, p);
        let u = typeCast(ErrToken.$, p);
        if (q != null) {
          j[n][m] = new NumberConstant(1, q.p);
        }
        else if (r != null) {
          j[n][m] = new NumberConstant(1, r.p);
        }
        else if (s != null) {
          j[n][m] = new StringConstant(1, s.p);
        }
        else if (t != null) {
          j[n][m] = new BooleanConstant(1, t.r);
        }
        else if (u != null) {
          j[n][m] = new ErrorConstant(1, u.p);
        }
        else {
          this.h = h;
          return false;
        }
        l++;
        if (n == e - 1 && m == i - 1) {
          break;
        }
        o = this.b8._inner[l];
        p = o.b;
        l++;
        if (n < e - 1) {
          if ((typeCast(UnionOperator.$, p) !== null) == false) {
            this.h = h;
            return false;
          }
        }
        else {
          if ((typeCast(MatrixRowSeparatorToken.$, p) !== null) == false) {
            this.h = h;
            return false;
          }
        }
      }
    }
    if (l != this.b8.count) {
      this.h = h;
      return false;
    }
    this.b8.v(a, this.b8.count - a);
    this.d5(new ArrayToken(1, j), c, this.cp - c, b, 0);
    return true;
  }
  ah(a, b) {
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p1: b
      };
    }
    if (this.cp >= this.cw.length) {
      return {
        ret: false,
        p1: b
      };
    }
    let c = null;
    let d = 1;
    let e = this.cw.charAt(this.cp);
    switch (e) {
      case '+':
        c = AddOperator.z;
        break;
      case '-':
        c = SubOperator.z;
        break;
      case '*':
        c = MulOperator.z;
        break;
      case '/':
        c = DivOperator.z;
        break;
      case '^':
        c = PowerOperator.z;
        break;
      case '=':
        c = EQOperator.z;
        break;
      case '<':
        {
          if (this.cp < this.cw.length - 1) {
            switch (this.cw.charAt(this.cp + 1)) {
              case '>':
                d = 2;
                c = NEOperator.z;
                break;
              case '=':
                d = 2;
                c = LEOperator.z;
                break;
            }
          }
          if (c == null) {
            c = LTOperator.z;
          }
        }
        break;
      case '>':
        {
          if (this.cp < this.cw.length - 1 && this.cw.charAt(this.cp + 1) == '=') {
            d = 2;
            c = GEOperator.z;
          }
          else {
            c = GTOperator.z;
          }
        }
        break;
      case "&":
        c = ConcatOperator.z;
        break;
      case ":":
        c = RangeOperator.z;
        break;
      case ",":
      case ";":
        {
          if (a && e == this.b4) {
            c = UnionOperator.z;
            break;
          }
          return {
            ret: false,
            p1: b
          };
        }
    }
    if (c == null) {
      if (this.r.c == 0) {
        return {
          ret: false,
          p1: b
        };
      }
      let f;
      for (f = this.r.c - 1; f >= 0; f--) {
        if (this.cw.charAt(f + this.r.d) == ' ') {
          break;
        }
      }
      if (f == -1) {
        return {
          ret: false,
          p1: b
        };
      }
      b = true;
      let g = IsectOperator.z;
      this.cp -= this.r.c;
      this.cp += f;
      this.r = new FormulaParser_TextSpan(1, this.r.d, f);
      this.d4(g, 1, 0);
      return {
        ret: true,
        p1: b
      };
    }
    this.d4(c, d, 0);
    return {
      ret: true,
      p1: b
    };
  }
  ai() {
    if (this.h != null) {
      return false;
    }
    if (this.cp >= this.cw.length) {
      return false;
    }
    let a = this.cw.charAt(this.cp);
    switch (a) {
      case 't':
      case 'T':
        {
          if (this.cw.length - this.cp < 4) {
            return false;
          }
          a = this.cw.charAt(this.cp + 1);
          if (a != 'r' && a != 'R') {
            return false;
          }
          a = this.cw.charAt(this.cp + 2);
          if (a != 'u' && a != 'U') {
            return false;
          }
          a = this.cw.charAt(this.cp + 3);
          if (a != 'e' && a != 'E') {
            return false;
          }
          this.d4(BoolToken.p, 4, 0);
          return true;
        }
      case 'f':
      case 'F':
        {
          if (this.cw.length - this.cp < 5) {
            return false;
          }
          a = this.cw.charAt(this.cp + 1);
          if (a != 'a' && a != 'A') {
            return false;
          }
          a = this.cw.charAt(this.cp + 2);
          if (a != 'l' && a != 'L') {
            return false;
          }
          a = this.cw.charAt(this.cp + 3);
          if (a != 's' && a != 'S') {
            return false;
          }
          a = this.cw.charAt(this.cp + 4);
          if (a != 'e' && a != 'E') {
            return false;
          }
          this.d4(BoolToken.o, 5, 0);
          return true;
        }
      default: return false;
    }
  }
  cq() {
    if (this.h != null) {
      return Nullable$1.toNullable(CellAddress.$, null);
    }
    let a;
    let b;
    let c;
    let d;
    let e = this.o();
    if (this.j.b == 1) {
      if (((() => { let f = this.al(a, b); a = f.p0; b = f.p1; return f.ret; })()) == false) {
        this.eg(e);
        return Nullable$1.toNullable(CellAddress.$, null);
      }
      if (((() => { let f = this.a8(c, d); c = f.p0; d = f.p1; return f.ret; })()) == false) {
        this.eg(e);
        return Nullable$1.toNullable(CellAddress.$, null);
      }
    }
    else {
      if (((() => { let f = this.bb(c, d); c = f.p0; d = f.p1; return f.ret; })()) == false) {
        this.eg(e);
        return Nullable$1.toNullable(CellAddress.$, null);
      }
      if (((() => { let f = this.ao(a, b); a = f.p0; b = f.p1; return f.ret; })()) == false) {
        this.eg(e);
        return Nullable$1.toNullable(CellAddress.$, null);
      }
    }
    return Nullable$1.toNullable(CellAddress.$, new CellAddress(1, c, d, a, b));
  }
  cr(a) {
    let b = this.o();
    this.ee();
    if (this.bq(":") == false) {
      if (this.r.c != 0) {
        this.eg(b);
      }
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    this.ee();
    let c = this.cq();
    if (CellAddress.j(c, Nullable$1.toNullable(CellAddress.$, null))) {
      this.eg(b);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    return Nullable$1.toNullable(CellAddressRange.$, new CellAddressRange(1, a, c.getValueOrDefault()));
  }
  aj() {
    if (this.h != null) {
      return false;
    }
    if (this.bp(')') == false) {
      return false;
    }
    this.d4(new ParenToken(), 1, 4);
    return true;
  }
  ak(a, b) {
    if (this.j.b == 1) {
      return {
        ret: ((() => { let c = this.al(a, b); a = c.p0; b = c.p1; return c.ret; })()),
        p0: a,
        p1: b
      };
    }
    else {
      return {
        ret: ((() => { let c = this.ao(a, b); a = c.p0; b = c.p1; return c.ret; })()),
        p0: a,
        p1: b
      };
    }
  }
  al(a, b) {
    a = 0;
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c;
    if (((() => { let d = FormulaParser.am(this.cw, this.cp, this.j.h, this.j.o, a, b, c); a = d.p4; b = d.p5; c = d.p6; return d.ret; })()) == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    if (b && this.bn) {
      a -= this.ce;
    }
    this.cp += c;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  static am(a, b, c, d, e, f, g) {
    g = 0;
    if (b == a.length) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g
      };
    }
    let h = a.charAt(b);
    if (h == '$') {
      f = false;
      h = a.charAt(++b);
    }
    else {
      f = true;
    }
    let i = 3;
    e = 0;
    let j = 0;
    while (j <= i && (('A'.charCodeAt(0) <= h.charCodeAt(0) && h.charCodeAt(0) <= 'Z'.charCodeAt(0)) || ('a'.charCodeAt(0) <= h.charCodeAt(0) && h.charCodeAt(0) <= 'z'.charCodeAt(0)))) {
      e *= 26;
      if (h.charCodeAt(0) < 'a'.charCodeAt(0)) {
        e += (h.charCodeAt(0) - 'A'.charCodeAt(0) + 1);
      }
      else {
        e += (h.charCodeAt(0) - 'a'.charCodeAt(0) + 1);
      }
      j++;
      if (++b < a.length) {
        h = a.charAt(b);
      }
      else {
        break;
      }
    }
    if (j > i) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g
      };
    }
    if (--e < 0) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g
      };
    }
    if (b < a.length && (h == '_' || isLetter(h))) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g
      };
    }
    if (e > Workbook.getMaxColumnCount(c) - 1) {
      return {
        ret: false,
        p4: e,
        p5: f,
        p6: g
      };
    }
    g = j;
    if (f == false) {
      g++;
    }
    return {
      ret: true,
      p4: e,
      p5: f,
      p6: g
    };
  }
  static an(a, b, c, d) {
    if (((() => { let e = tryParseInt16_1(a, d); d = e.p1; return e.ret; })()) == false) {
      return {
        ret: false,
        p3: d
      };
    }
    if (b == false) {
      d--;
      if (d < 0) {
        return {
          ret: false,
          p3: d
        };
      }
    }
    if (Math.abs(d) > Workbook.getMaxColumnCount(c) - 1) {
      return {
        ret: false,
        p3: d
      };
    }
    return {
      ret: true,
      p3: d
    };
  }
  ao(a, b) {
    a = 0;
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c;
    if (((() => { let d = this.aq(this.cw, this.cp, this.j.h, a, b, c); a = d.p3; b = d.p4; c = d.p5; return d.ret; })()) == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    this.cp += c;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  static ap(a, b, c, d, e, f) {
    return {
      ret: ((() => { let g = FormulaParser.n.aq(a, b, c, d, e, f); d = g.p3; e = g.p4; f = g.p5; return g.ret; })()),
      p3: d,
      p4: e,
      p5: f
    };
  }
  aq(a, b, c, d, e, f) {
    f = 0;
    let g = this.dh.j(a, b);
    if (g.i == false) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    let h = g.g;
    if (h.length == 1) {
      e = true;
      d = 0;
    }
    else {
      e = h.charAt(1) == '[';
      let i = e ? h.substr(2, h.length - 3) : h.substr(1);
      if (((() => { let j = FormulaParser.an(i, e, c, d); d = j.p3; return j.ret; })()) == false) {
        e = true;
        d = 0;
        f = 1;
        return {
          ret: true,
          p3: d,
          p4: e,
          p5: f
        };
      }
    }
    f = g.d;
    return {
      ret: true,
      p3: d,
      p4: e,
      p5: f
    };
  }
  cs() {
    if (this.h != null) {
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    let a = this.o();
    let b;
    let c;
    if (((() => { let d = this.ak(b, c); b = d.p0; c = d.p1; return d.ret; })()) == false) {
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    if (this.bq(":") == false) {
      this.eg(a);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    let d;
    let e;
    if (((() => { let f = this.ak(d, e); d = f.p0; e = f.p1; return f.ret; })()) == false) {
      this.eg(a);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    let f = new CellAddress();
    let g = new CellAddress();
    let h = Workbook.getMaxRowCount(this.j.h) - 1;
    if (b <= d) {
      f = new CellAddress(1, 0, false, b, c);
      g = new CellAddress(1, h, false, d, e);
    }
    else {
      f = new CellAddress(1, 0, false, d, e);
      g = new CellAddress(1, h, false, b, c);
    }
    return Nullable$1.toNullable(CellAddressRange.$, new CellAddressRange(1, f, g));
  }
  ed() {
    if (this.h != null) {
      return;
    }
    if (this.av(false)) {
      return;
    }
    this.d4(MissArgToken.o, 0, 0);
  }
  at() {
    return this.au(false);
  }
  au(a) {
    if (this.h != null) {
      return false;
    }
    if (this.bp('#') == false) {
      return false;
    }
    let b = this.dl.j(this.cw, this.cp);
    if (b.i == false) {
      this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidErrorValue"), this.cw.substr(this.cp));
      return false;
    }
    let c = FormulaParser.b(b.g, this.j.o);
    if (c == null) {
      return false;
    }
    if (a && c != ErrorValue.invalidCellReference) {
      return false;
    }
    this.d4(new ErrToken(1, c), b.d, 0);
    return true;
  }
  c3(a, b) {
    a = false;
    b = null;
    let c = this.cp;
    let d = this.c6();
    if (this.bq('[') == false) {
      this.cp = c;
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    let e = this.c5();
    if (e == null) {
      let f = this.cw.indexOf(']', this.cp);
      if (f >= 0) {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidFileNameInBrackets"), this.cw.substr(c, f - c + 1));
      }
      else {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoFileNameAfterBracket"), this.cw.substr(c));
      }
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    if (this.bq(']') == false) {
      let g = this.cw.indexOf(']', this.cp);
      if (g >= 0) {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidFileNameInBrackets"), this.cw.substr(c, g - c + 1));
      }
      else {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_UnmatchedOpenSquareBracket"), this.cw.substr(c, this.cp - c));
      }
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    let h = d == null ? e : stringConcat(d, e);
    if (this.b7 != null) {
      let i;
      if (((() => { let j = tryParseInt32_1(h, i); i = j.p1; return j.ret; })()) && i < this.b7.count) {
        let j = this.b7._inner[i];
        b = j;
        h = j.x;
        a = typeCast(OleLinkWorkbookReference.$, j) !== null || typeCast(DdeLinkWorkbookReference.$, j) !== null;
      }
    }
    if (stringIsNullOrEmpty(h)) {
      h = null;
    }
    return {
      ret: h,
      p0: a,
      p1: b
    };
  }
  c4(a, b) {
    a = false;
    b = false;
    if (this.h != null) {
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    if (this.bp('[') == false) {
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    let c = this.dn.j(this.cw, this.cp);
    if (c.i == false) {
      return {
        ret: null,
        p0: a,
        p1: b
      };
    }
    let d = c.g.substr(1, c.d - 2);
    if (this.b7 != null) {
      let e;
      if (((() => { let f = tryParseInt32_1(d, e); e = f.p1; return f.ret; })())) {
        if (e < this.b7.count) {
          a = true;
          let f = this.b7._inner[e];
          d = f.x;
          b = typeCast(OleLinkWorkbookReference.$, f) !== null || typeCast(DdeLinkWorkbookReference.$, f) !== null;
        }
      }
    }
    this.cp += c.d;
    return {
      ret: d,
      p0: a,
      p1: b
    };
  }
  c5() {
    if (this.h != null) {
      return null;
    }
    let a = this.dq.j(this.cw, this.cp);
    if (a.i == false) {
      return null;
    }
    let b = a.g;
    b = stringReplace(b, "''", "'");
    this.cp += a.d;
    return b;
  }
  c6() {
    if (this.h != null) {
      return null;
    }
    let a = this.c7();
    if (a != null) {
      return a;
    }
    return this.db();
  }
  aw() {
    if (this.h != null) {
      return false;
    }
    let a = this.cp;
    let b = this.r;
    let c = this.s();
    if (c.c != 0) {
      let d = Function._gx(this.cw, c.d, c.c);
      if (this.ax(d, a, b)) {
        return true;
      }
    }
    return false;
  }
  ax(a, b, c) {
    if (a != null && a._qo && this.b7 == null) {
      if (this.i != 3 && this.i != 4) {
        this.h = new FormulaParseException(b, this.cw, ExcelUtils.eg("LE_FormulaParseException_MacroFunctionNotAllowed", a._alx), this.cw.substr(b, this.cp - b));
        return false;
      }
    }
    let d = this.cp;
    let e = this.b8.count;
    this.cg++;
    let f = this.co();
    let g = this.cg > this.ck;
    this.cg--;
    if (this.h != null) {
      return false;
    }
    if (this.aj() == false) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_FunctionMissingClosingParen"), this.cw.substr(b, this.cp - b));
      return false;
    }
    if (g) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_FunctionNestingTooDeep"), this.cw.substr(b, this.cp - b));
      return false;
    }
    if (f < a._q1 || a._qx(this.j.h) < f || ((f - a._aaw) % a._aau) != 0) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_IncorrectNumberOfArguments"), this.cw.substr(b, this.cp - b));
      return false;
    }
    if (this.af == false && a._qt) {
      this.af = true;
    }
    let h;
    if (a._qn) {
      h = new FunctionVOperator(1, a, a._qx(this.j.h));
      h.argumentCount = f;
    }
    else {
      h = new FunctionOperator(1, a);
    }
    let i = this.cp;
    let j = this.r;
    this.o();
    this.eb(e, h, b, d - b + 1, c, 0);
    this.cp = i;
    this.r = j;
    return true;
  }
  s() {
    if (this.cp == this.cw.length) {
      return FormulaParser_TextSpan.a;
    }
    let a = this.cp;
    let b = this.cw.charAt(a++);
    if (b == '_') {
      if (this.cw.length - this.cp < 5) {
        return FormulaParser_TextSpan.a;
      }
      b = this.cw.charAt(a++);
      if (b != 'x') {
        return FormulaParser_TextSpan.a;
      }
      b = this.cw.charAt(a++);
      if (b != 'l') {
        return FormulaParser_TextSpan.a;
      }
      b = this.cw.charAt(a++);
      if (b != 'l') {
        if (b != 'f') {
          return FormulaParser_TextSpan.a;
        }
        b = this.cw.charAt(a++);
        if (b != 'n') {
          return FormulaParser_TextSpan.a;
        }
      }
      b = this.cw.charAt(a++);
      if (b != '.') {
        return FormulaParser_TextSpan.a;
      }
      if (ExcelUtils.au(this.j.h)) {
        return FormulaParser_TextSpan.a;
      }
      b = this.cw.charAt(a++);
    }
    if (isLetter(b) == false) {
      return FormulaParser_TextSpan.a;
    }
    while (a < this.cw.length) {
      b = this.cw.charAt(a++);
      switch (b) {
        case '(':
          {
            let c = this.cp;
            this.cp = a;
            this.ee();
            return new FormulaParser_TextSpan(1, c, a - c - 1);
          }
        case '.':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': continue;
        default:
          if (isLetter(b)) {
            continue;
          }
          break;
      }
      break;
    }
    return FormulaParser_TextSpan.a;
  }
  c7() {
    if (this.h != null) {
      return null;
    }
    let a = this.ds.j(this.cw, this.cp);
    if (a.i == false) {
      return null;
    }
    if (a.d < 2) {
      return null;
    }
    let b = a.g;
    b = stringReplace(b, "''", "'");
    this.cp += a.d;
    return b;
  }
  ay(a) {
    if (this.a0(a) == false) {
      return false;
    }
    while (true) {
      let b = this.o();
      if (this.a1() == false) {
        this.eg(b);
        return true;
      }
      if (this.a0(a) == false) {
        return false;
      }
    }
  }
  az() {
    if (this.a2()) {
      return true;
    }
    if (this.bg()) {
      return true;
    }
    if (this.at()) {
      return true;
    }
    if (this.ai()) {
      return true;
    }
    return false;
  }
  a0(a) {
    if (this.az() == false) {
      return true;
    }
    while (true) {
      let b = this.o();
      let c = this.cp;
      if (this.bf(this.bz) == false) {
        this.eg(b);
        return true;
      }
      if (this.az() == false) {
        this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoElementAfterArraySerapator"), this.cw.substr(a, this.cp - a));
        return false;
      }
    }
  }
  a1() {
    if (this.h != null) {
      return false;
    }
    if (this.bp(';') == false) {
      return false;
    }
    this.d2(new MatrixRowSeparatorToken(), 1);
    return true;
  }
  c8(a) {
    if (this.h != null) {
      return null;
    }
    let b = this.cp;
    let c = ((() => { let d = FormulaParser.c9(this.cw, a, this.cp); this.cp = d.p2; return d.ret; })());
    if (c == null || this.ad(c, this.j.h, this.j.o) == false) {
      this.cp = b;
      return null;
    }
    if (stringStartsWith(c, "_xlnm.") && ExcelUtils.av(this.j.h)) {
      c = c.substr("_xlnm.".length);
    }
    return c;
  }
  static c9(a, b, c) {
    let d = c;
    if (d >= a.length) {
      return {
        ret: null,
        p2: c
      };
    }
    let e = null;
    let f = a.charAt(d);
    switch (f) {
      case '[':
        {
          while (++d < a.length) {
            f = a.charAt(d);
            if (FormulaParser.ac(f, false) == false) {
              break;
            }
          }
          if (f != ']') {
            return {
              ret: null,
              p2: c
            };
          }
          if (++d >= a.length) {
            return {
              ret: null,
              p2: c
            };
          }
          f = a.charAt(d);
          break;
        }
      case '\'':
        {
          if (b) {
            if (d >= a.length - 1) {
              return {
                ret: null,
                p2: c
              };
            }
            while (++d < a.length) {
              f = a.charAt(d);
              if (f == '\'') {
                break;
              }
            }
            if (f != '\'') {
              return {
                ret: null,
                p2: c
              };
            }
            e = a.substr(c + 1, d - (c + 1));
            c = d + 1;
            return {
              ret: e,
              p2: c
            };
          }
          break;
        }
    }
    if (FormulaParser.ac(f, true) == false) {
      return {
        ret: null,
        p2: c
      };
    }
    while (++d < a.length) {
      f = a.charAt(d);
      if (FormulaParser.ac(f, false) == false) {
        break;
      }
    }
    e = a.substr(c, d - c);
    c = d;
    return {
      ret: e,
      p2: c
    };
  }
  static ac(a, b) {
    switch (a) {
      case '\\':
      case '_':
      case '':
      case '':
      case '':
      case '':
      case '': return true;
      case '.':
      case '?': return b == false;
      case '':
      case '':
      case '': return false;
      default:
        {
          if (isLetter(a)) {
            return true;
          }
          if (isDigit(a)) {
            return b == false;
          }
          let c = CharUnicodeInfo.e(a);
          switch (c) {
            case 9:
            case 10:
            case 28: return b == false;
            case 18: return true;
            case 24: return a.charCodeAt(0) > 255;
            case 26: return a.charCodeAt(0) > 255;
            case 25: return b == false && a != '+' && a != '<' && a != '=' && a != '>' && a != '|' && a != '~';
            case 20: return a != '(' && a != '[' && a != '{';
            case 21: return a != ')' && a != ']' && a != '}';
          }
          return false;
        }
    }
  }
  ee() {
    let a;
    for (a = this.cp; a < this.cw.length; a++) {
      let b = this.cw.charAt(a);
      if (b != ' ' && b != '\t' && b != '\r' && b != '\n') {
        break;
      }
    }
    if (a == this.cp) {
      this.r = FormulaParser_TextSpan.a;
      return;
    }
    this.r = new FormulaParser_TextSpan(1, this.cp, a - this.cp);
    this.cp = a;
  }
  a2() {
    if (this.h != null) {
      return false;
    }
    let a = this.da();
    let b;
    if (a == null || ((() => { let c = MathUtilities.c(a, this.j.o, b); b = c.p2; return c.ret; })()) == false) {
      return false;
    }
    this.d4(this.v(b), a.length, 0);
    return true;
  }
  ar(a, b) {
    if (b != this.cu.charAt(0)) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c = this.cu.length;
    if (c != 1) {
      for (let d = 1; d < c; d++) {
        if (this.cw.charAt(d + a) != this.cu.charAt(d)) {
          return {
            ret: false,
            p0: a,
            p1: b
          };
        }
      }
    }
    a += c;
    if (a < this.cw.length) {
      b = this.cw.charAt(a);
    }
    else {
      b = '\0';
    }
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  da() {
    let a = this.cp;
    let b = this.cw.length;
    if (a >= b) {
      return null;
    }
    let c = this.cw.charAt(a);
    if (c == '-' || c == '+') {
      if (++a == b) {
        return null;
      }
      c = this.cw.charAt(a);
    }
    let d = ((() => { let e = this.as(a, c); a = e.p0; c = e.p1; return e.ret; })());
    if (((() => { let e = this.ar(a, c); a = e.p0; c = e.p1; return e.ret; })())) {
      if (((() => { let e = this.as(a, c); a = e.p0; c = e.p1; return e.ret; })()) == false) {
        return null;
      }
      d = true;
    }
    if (d == false) {
      return null;
    }
    if (c == 'e' || c == 'E') {
      if (++a == b) {
        return null;
      }
      c = this.cw.charAt(a);
      if (c == '-' || c == '+') {
        if (++a == b) {
          return null;
        }
        c = this.cw.charAt(a);
      }
      if (((() => { let e = this.as(a, c); a = e.p0; c = e.p1; return e.ret; })()) == false) {
        return null;
      }
    }
    return this.cw.substr(this.cp, a - this.cp);
  }
  as(a, b) {
    if (FormulaParser.z(b) == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    while (true) {
      if (++a == this.cw.length) {
        b = '\0';
        break;
      }
      b = this.cw.charAt(a);
      if (FormulaParser.z(b) == false) {
        break;
      }
    }
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  static z(a) {
    return '0'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0);
  }
  static ef(a, b, c, d = '|') {
    let e = a.indexOf(d);
    if (e < 0) {
      b = "";
      c = a;
    }
    else {
      b = a.substr(0, e);
      c = a.substr(e + 1);
    }
    if (2 <= b.length && b.charAt(0) == '\'' && b.charAt(b.length - 1) == '\'') {
      b = stringReplace(b.substr(1, b.length - 2), "''", "'");
    }
    if (2 <= c.length && c.charAt(0) == '\'' && c.charAt(c.length - 1) == '\'') {
      c = stringReplace(c.substr(1, c.length - 2), "''", "'");
    }
    return {
      p1: b,
      p2: c
    };
  }
  a3(a, b) {
    let c = null;
    let d = this.t();
    if (d.b == false) {
      c = this.cw.substr(d.d, d.c);
    }
    else if (this.bq('\'')) {
      let e = this.c6();
      let f = this.c5();
      c = e + f;
      if (this.bq('\'') == false) {
        c = null;
      }
    }
    if (c == null) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoOleObjectName"), this.cw.substr(b, this.cp - b));
      return {
        ret: false,
        p0: a
      };
    }
    a.a = true;
    a.b = this.cw.substr(b, this.cp - b);
    a.c = null;
    if (this.bq("!") == false) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoExclamationAfterOleObjectName"), this.cw.substr(b, this.cp - b));
      return {
        ret: false,
        p0: a
      };
    }
    return {
      ret: true,
      p0: a
    };
  }
  a4() {
    if (this.h != null) {
      return false;
    }
    if (this.bp('(') == false) {
      return false;
    }
    this.d4(OpenParenOperator.y, 1, 2);
    return true;
  }
  co() {
    let a = this.o();
    this.ed();
    let b = 1;
    while (true) {
      let c = this.o();
      if (this.bf(this.b4) == false) {
        this.eg(c);
        break;
      }
      this.ed();
      b++;
    }
    if (b == 1 && typeCast(MissArgToken.$, this.b8._inner[this.b8.count - 1].b) !== null) {
      this.eg(a);
      return 0;
    }
    return b;
  }
  a6() {
    if (this.h != null) {
      return false;
    }
    let a = this.cp;
    let b = this.r;
    let c = new FormulaParser_WorksheetReferenceInfo();
    let d = ((() => { let e = this.bk(c); c = e.p0; return e.ret; })());
    if (this.h != null) {
      return false;
    }
    let e;
    let f = new CellAddressRange();
    if (d == false || c.c != null) {
      let g = this.cq();
      if (CellAddress.l(g, Nullable$1.toNullable(CellAddress.$, null))) {
        e = this.cr(g.getValueOrDefault());
      }
      else {
        e = this.cs();
        if (CellAddressRange.n(e, Nullable$1.toNullable(CellAddressRange.$, null))) {
          e = this.ct();
        }
      }
      if (CellAddressRange.p(e, Nullable$1.toNullable(CellAddressRange.$, null))) {
        f = e.getValueOrDefault();
        let h = this.bn && f.l;
        let i;
        if (d) {
          let j = ((() => { let k = this.y(c); c = k.p0; return k.ret; })());
          if (h) {
            i = new Area3DNToken(0, j, f);
          }
          else {
            i = new Area3DToken(1, j, f);
          }
        }
        else {
          if (h) {
            i = new AreaNToken(1, f);
          }
          else {
            i = new AreaToken(1, f);
          }
        }
        this.d5(i, a, this.cp - a, b, 0);
        return true;
      }
      if (CellAddress.l(g, Nullable$1.toNullable(CellAddress.$, null))) {
        let k = g.getValueOrDefault();
        let l = this.bn && k.h;
        let m;
        if (d) {
          let n = ((() => { let o = this.y(c); c = o.p0; return o.ret; })());
          if (l) {
            m = new Ref3DNToken(0, n, k);
          }
          else {
            m = new Ref3DToken(1, n, k);
          }
        }
        else {
          if (l) {
            m = new RefNToken(1, k);
          }
          else {
            m = new RefToken(1, k);
          }
        }
        if (this.br(false)) {
          this.cp = a;
        }
        else {
          this.d5(m, a, this.cp - a, b, 0);
          return true;
        }
      }
    }
    let o = this.c8(d);
    if (o != null) {
      if (c.b != null && this.bq('(')) {
        if (this.ax(Function._gt(c.b, o), a, b)) {
          return true;
        }
      }
      let p = c.b == null ? c.c : c.b;
      if (this.p.c(p, o, b)) {
        return true;
      }
      let q;
      if (d) {
        q = new NameXToken(1, c.b, c.c, o, this.j, c.a ? 2 : 0, false);
      }
      else {
        q = new NameToken(1, o, this.j, c.a ? 2 : 0, false);
      }
      this.d5(q, a, this.cp - a, b, 0);
      return true;
    }
    if (this.p.c(null, null, b)) {
      return true;
    }
    if (this.j.b == 0 && (d == false || c.c != null)) {
      let r;
      let s;
      if (((() => { let t = this.bb(r, s); r = t.p0; s = t.p1; return t.ret; })())) {
        let t = new CellAddress(1, r, s, 0, false);
        let u = new CellAddress(1, r, s, (Workbook._fe(this.j.h) - 1), false);
        f = new CellAddressRange(1, t, u);
        let v;
        if (d) {
          let w = ((() => { let x = this.y(c); c = x.p0; return x.ret; })());
          if (f.l) {
            v = new Area3DNToken(0, w, f);
          }
          else {
            v = new Area3DToken(1, w, f);
          }
        }
        else {
          if (f.l) {
            v = new AreaNToken(1, f);
          }
          else {
            v = new AreaToken(1, f);
          }
        }
        this.d5(v, a, this.cp - a, b, 0);
        return true;
      }
      let x;
      let y;
      if (((() => { let z = this.ao(x, y); x = z.p0; y = z.p1; return z.ret; })())) {
        let z = new CellAddress(1, 0, false, x, y);
        let aa = new CellAddress(1, Workbook.getMaxRowCount(this.j.h) - 1, false, x, y);
        f = new CellAddressRange(1, z, aa);
        let ab;
        if (d) {
          let ac = ((() => { let ad = this.y(c); c = ad.p0; return ad.ret; })());
          if (f.l) {
            ab = new Area3DNToken(0, ac, f);
          }
          else {
            ab = new Area3DToken(1, ac, f);
          }
        }
        else {
          if (f.l) {
            ab = new AreaNToken(1, f);
          }
          else {
            ab = new AreaToken(1, f);
          }
        }
        this.d5(ab, a, this.cp - a, b, 0);
        return true;
      }
    }
    if (d) {
      if (this.au(true)) {
        this.b8.removeAt(this.b8.count - 1);
        let ad = ((() => { let ae = this.y(c); c = ae.p0; return ae.ret; })());
        let ae = new RefErr3dToken(1, ad);
        this.d5(ae, a, this.cp - a, b, 0);
        return true;
      }
      this.h = new FormulaParseException(a, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoValidTermAfterWorksheetName"), this.cw.substr(a, this.cp - a));
      return false;
    }
    let af;
    let ag;
    if (((() => { let ah = this.bj(af, ag); af = ah.p0; ag = ah.p1; return ah.ret; })())) {
      let ah = this.c8(true);
      if (ah == null) {
        let ai = this.cq();
        if (CellAddress.l(ai, Nullable$1.toNullable(CellAddress.$, null))) {
          this.h = new FormulaParseException(a, this.cw, ExcelUtils.ef("LE_FormulaParseException_CellReferenceAfterWorkbookName"), this.cw.substr(a, this.cp - a));
        }
        else {
          this.h = new FormulaParseException(a, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoValidTermAfterWorkbookName"), this.cw.substr(a, this.cp - a));
        }
        return false;
      }
      this.d6(new NameXToken(1, af, null, ah, this.j, ag ? 2 : 0, false), a, this.cp - a, 0);
      return true;
    }
    return false;
  }
  a7(a, b) {
    if (this.j.b == 1) {
      return {
        ret: ((() => { let c = this.a8(a, b); a = c.p0; b = c.p1; return c.ret; })()),
        p0: a,
        p1: b
      };
    }
    else {
      return {
        ret: ((() => { let c = this.bb(a, b); a = c.p0; b = c.p1; return c.ret; })()),
        p0: a,
        p1: b
      };
    }
  }
  a8(a, b) {
    a = 0;
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c;
    if (((() => { let d = FormulaParser.a9(this.cw, this.cp, this.j.h, a, b, c); a = d.p3; b = d.p4; c = d.p5; return d.ret; })()) == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    if (b && this.bn) {
      a -= this.cf;
    }
    this.cp += c;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  static a9(a, b, c, d, e, f) {
    f = 0;
    if (b == a.length) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    let g = a.charAt(b);
    if (g == '$') {
      e = false;
      g = a.charAt(++b);
    }
    else {
      e = true;
    }
    let h = 7;
    d = 0;
    let i = 0;
    while ('0'.charCodeAt(0) <= g.charCodeAt(0) && g.charCodeAt(0) <= '9'.charCodeAt(0) && i <= h) {
      d *= 10;
      d += (g.charCodeAt(0) - '0'.charCodeAt(0));
      i++;
      if (++b < a.length) {
        g = a.charAt(b);
      }
      else {
        break;
      }
    }
    if (i > h) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    if (--d < 0) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    if (b < a.length && (g == '_' || isLetter(g))) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    if (d > Workbook.getMaxRowCount(c) - 1) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    f = i;
    if (e == false) {
      f++;
    }
    return {
      ret: true,
      p3: d,
      p4: e,
      p5: f
    };
  }
  static ba(a, b, c, d) {
    if (((() => { let e = tryParseInt32_1(a, d); d = e.p1; return e.ret; })()) == false) {
      return {
        ret: false,
        p3: d
      };
    }
    if (b == false) {
      d--;
      if (d < 0) {
        return {
          ret: false,
          p3: d
        };
      }
    }
    if (Math.abs(d) > Workbook.getMaxRowCount(c) - 1) {
      return {
        ret: false,
        p3: d
      };
    }
    return {
      ret: true,
      p3: d
    };
  }
  bb(a, b) {
    a = 0;
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c;
    if (((() => { let d = this.bd(this.cw, this.cp, this.j.h, a, b, c); a = d.p3; b = d.p4; c = d.p5; return d.ret; })()) == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    this.cp += c;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  static bc(a, b, c, d, e, f) {
    return {
      ret: ((() => { let g = FormulaParser.n.bd(a, b, c, d, e, f); d = g.p3; e = g.p4; f = g.p5; return g.ret; })()),
      p3: d,
      p4: e,
      p5: f
    };
  }
  bd(a, b, c, d, e, f) {
    f = 0;
    let g = this.du.j(a, b);
    if (g.i == false) {
      return {
        ret: false,
        p3: d,
        p4: e,
        p5: f
      };
    }
    let h = g.g;
    if (h.length == 1) {
      e = true;
      d = 0;
    }
    else {
      e = h.charAt(1) == '[';
      let i = e ? h.substr(2, h.length - 3) : h.substr(1);
      if (((() => { let j = FormulaParser.ba(i, e, c, d); d = j.p3; return j.ret; })()) == false) {
        e = true;
        d = 0;
        f = 1;
        return {
          ret: true,
          p3: d,
          p4: e,
          p5: f
        };
      }
    }
    f = g.d;
    return {
      ret: true,
      p3: d,
      p4: e,
      p5: f
    };
  }
  ct() {
    let a = this.o();
    let b;
    let c;
    if (((() => { let d = this.a7(b, c); b = d.p0; c = d.p1; return d.ret; })()) == false) {
      this.eg(a);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    if (this.h != null) {
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    if (this.bq(":") == false) {
      this.eg(a);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    let d;
    let e;
    if (((() => { let f = this.a7(d, e); d = f.p0; e = f.p1; return f.ret; })()) == false) {
      this.eg(a);
      return Nullable$1.toNullable(CellAddressRange.$, null);
    }
    let f = new CellAddress();
    let g = new CellAddress();
    let h = (Workbook._fe(this.j.h) - 1);
    if (b <= d) {
      f = new CellAddress(1, b, c, 0, false);
      g = new CellAddress(1, d, e, h, false);
    }
    else {
      f = new CellAddress(1, d, e, 0, false);
      g = new CellAddress(1, b, c, h, false);
    }
    return Nullable$1.toNullable(CellAddressRange.$, new CellAddressRange(1, f, g));
  }
  bf(a) {
    if (this.h != null) {
      return false;
    }
    if (this.bp(a) == false) {
      return false;
    }
    this.d2(UnionOperator.z, 1);
    return true;
  }
  bg() {
    if (this.h != null) {
      return false;
    }
    if (this.bp('\"') == false) {
      return false;
    }
    this.dx.c = 0;
    let a = 0;
    let b;
    for (b = this.cp + 1; b < this.cw.length; b++) {
      let c = this.cw.charAt(b);
      if (c != '\"') {
        a++;
        this.dx.h(c);
        continue;
      }
      if (b < this.cw.length - 1 && this.cw.charAt(b + 1) == '\"') {
        a += 2;
        b++;
        this.dx.h(c);
        continue;
      }
      break;
    }
    if (b >= this.cw.length) {
      return false;
    }
    let d = this.dx.c == 0 ? stringEmpty() : this.dx.toString();
    if (a > 255) {
      this.h = new FormulaParseException(this.cp, this.cw, stringFormat(ExcelUtils.ef("LE_FormulaParseException_StringConstantLengthTooLong"), 255), d);
      return false;
    }
    this.d4(new StrToken(1, d), a + 2, 0);
    return true;
  }
  bh() {
    if (this.h != null) {
      return false;
    }
    if (this.bp('%') == false) {
      return false;
    }
    this.d4(PercentOperator.y, 1, 0);
    return true;
  }
  bi() {
    if (this.h != null) {
      return false;
    }
    if (this.bp('-')) {
      this.d4(UminusOperator.y, 1, 0);
    }
    else if (this.bp('+')) {
      this.d4(UplusOperator.y, 1, 0);
    }
    else {
      return false;
    }
    return true;
  }
  db() {
    if (this.h != null) {
      return null;
    }
    let a = this.dw.j(this.cw, this.cp);
    if (a.i == false) {
      return null;
    }
    let b = a.g;
    b = stringReplace(b, "''", "'");
    this.cp += a.d;
    return b;
  }
  bj(a, b) {
    a = null;
    b = false;
    if (this.h != null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c = this.cp;
    if (this.bq('\'') == false) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let d = this.c6();
    let e = this.c5();
    if (e == null) {
      let f = null;
      if (this.b7 != null) {
        e = ((() => { let g = this.c3(b, f); b = g.p0; f = g.p1; return g.ret; })());
      }
      if (e == null && (f == null || typeCast(CurrentWorkbookReference.$, f) !== null == false || !stringIsNullOrEmpty(d))) {
        this.cp = c;
        return {
          ret: false,
          p0: a,
          p1: b
        };
      }
    }
    a = e == null ? null : stringConcat(d, e);
    if (this.bq('\'') == false) {
      let g = this.dj.j(this.cw, this.cp);
      if (g.i) {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidWorkbookName"), this.cw.substr(c, g.b - c + 1));
      }
      else {
        this.h = new FormulaParseException(this.cp, this.cw, ExcelUtils.ef("LE_FormulaParseException_WorkbookNameMissingEndQuote"), this.cw.substr(c, this.cp - c));
      }
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    if (this.bq("!") == false) {
      this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoExclamationAfterWorkbookName"), this.cw.substr(c, this.cp - c));
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  dc() {
    if (this.h != null) {
      return null;
    }
    this.dy.c = 0;
    let a = this.cp;
    for (; a < this.cw.length; a++) {
      let b = true;
      let c = this.cw.charAt(a);
      switch (c) {
        case '*':
        case '[':
        case ']':
        case ':':
        case '/':
        case '\\':
        case '?':
          b = false;
          break;
        case '\'':
          if (a < this.cw.length - 1 && this.cw.charAt(a + 1) == '\'') {
            a++;
            this.dy.h(c);
          }
          else {
            b = false;
          }
          break;
        default:
          this.dy.h(c);
          break;
      }
      if (b == false) {
        break;
      }
    }
    if (a == this.cp) {
      return null;
    }
    this.cp = a;
    return this.dy.toString();
  }
  t() {
    if (this.h != null) {
      return FormulaParser_TextSpan.a;
    }
    return ((() => { let a = FormulaParser.u(this.cw, this.cp, false); this.cp = a.p1; return a.ret; })());
  }
  static u(a, b, c) {
    if (b >= a.length) {
      return {
        ret: FormulaParser_TextSpan.a,
        p1: b
      };
    }
    let d = a.charAt(b);
    if (FormulaParser.ae(d, true, c) == false) {
      return {
        ret: FormulaParser_TextSpan.a,
        p1: b
      };
    }
    let e = b;
    while (++e < a.length) {
      d = a.charAt(e);
      if (FormulaParser.ae(d, false, c) == false) {
        break;
      }
    }
    let f = new FormulaParser_TextSpan(1, b, e - b);
    b = e;
    return {
      ret: f,
      p1: b
    };
  }
  static ae(a, b, c) {
    if (c && a.charCodeAt(0) >= 65280 && a.charCodeAt(0) <= 65374) {
      a = String.fromCharCode((a.charCodeAt(0) - 65280 + 32));
    }
    switch (a) {
      case '_': return true;
      case '':
      case '':
      case '':
      case '': return true;
      case '':
      case '':
      case '':
        if (!c) {
          return true;
        }
        break;
      case '.':
      case '?': return b == false;
    }
    if (isLetter(a)) {
      return true;
    }
    if (b == false && isNumber(a)) {
      return true;
    }
    let d = CharUnicodeInfo.e(a);
    switch (d) {
      case 28:
      case 10:
      case 9:
      case 5:
      case 18: return true;
      case 25: return a != '+' && a != '<' && a != '=' && a != '>' && a != '|' && a != '~';
      case 20:
        {
          switch (a) {
            case '(':
            case '[':
            case '{':
            case '':
            case '': return false;
            default: return true;
          }
        }
      case 21: return a != ')' && a != ']' && a != '}';
    }
    if (12448 <= a.charCodeAt(0) && a.charCodeAt(0) <= 12543) {
      return true;
    }
    if (!c && a.charCodeAt(0) >= 65280 && a.charCodeAt(0) <= 65374) {
      return true;
    }
    if (!c && d == 24) {
      switch (a) {
        case '':
        case '':
        case '':
        case '':
        case '': return true;
      }
    }
    return false;
  }
  bk(a) {
    if (((() => { let b = this.bm(a); a = b.p0; return b.ret; })())) {
      return {
        ret: true,
        p0: a
      };
    }
    return {
      ret: ((() => { let b = this.bl(a); a = b.p0; return b.ret; })()),
      p0: a
    };
  }
  bl(a) {
    if (this.h != null) {
      return {
        ret: false,
        p0: a
      };
    }
    let b = this.cp;
    if (this.bq('\'') == false) {
      return {
        ret: false,
        p0: a
      };
    }
    let c;
    a.b = ((() => { let d = this.c3(a.a, c); a.a = d.p0; c = d.p1; return d.ret; })());
    a.c = this.dc();
    if (a.c != null && this.bq(":")) {
      let d = this.cp;
      a.d = this.dc();
      if (a.d == null && this.bq('\'')) {
        if (this.h == null) {
          this.h = new FormulaParseException(d, this.cw, ExcelUtils.ef("LE_FormulaParseException_WorksheetRangeMissingEndingName"), this.cw.substr(b, this.cp - b + 1));
        }
        this.cp = b;
        return {
          ret: false,
          p0: a
        };
      }
    }
    if (a.c == null || this.bq('\'') == false) {
      if (this.b7 == null && a.b != null) {
        let e = this.dj.j(this.cw, this.cp);
        if (e.i) {
          this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidWorksheetName"), this.cw.substr(b, e.b - b + 1));
        }
        else {
          this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidWorksheetName"), this.cw.substr(b, this.cp - b));
        }
      }
      this.cp = b;
      return {
        ret: false,
        p0: a
      };
    }
    if (a.b == null && a.c != null && a.d == null && this.bq("|")) {
      return {
        ret: ((() => { let f = this.a3(a, b); a = f.p0; return f.ret; })()),
        p0: a
      };
    }
    if (this.bq("!") == false) {
      this.h = new FormulaParseException(b, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoExclamationAfterWorksheetName"), this.cw.substr(b, this.cp - b));
      return {
        ret: false,
        p0: a
      };
    }
    return {
      ret: true,
      p0: a
    };
  }
  bm(a) {
    if (this.h != null) {
      return {
        ret: false,
        p0: a
      };
    }
    let b = this.o();
    let c = b.d;
    let d;
    a.b = ((() => { let e = this.c4(d, a.a); d = e.p0; a.a = e.p1; return e.ret; })());
    let e = this.t();
    if (e.b && d == false) {
      if (a.b != null) {
        if (ExcelUtils.au(this.j.h) == false) {
          a.b = null;
          this.eg(b);
          return {
            ret: false,
            p0: a
          };
        }
        this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoWorksheetAfterWorkbookName"), this.cw.substr(c, this.cp - c));
      }
      this.eg(b);
      return {
        ret: false,
        p0: a
      };
    }
    let f = FormulaParser_TextSpan.a;
    let g = false;
    if (this.bq(":")) {
      g = true;
      if (a.b == null) {
        let h;
        let i;
        if (this.j.b == 1) {
          if (((() => { let j = ExcelUtils.bn(this.cw, e.d, e.c, this.j.h, this.j.o, h, i); h = j.p5; i = j.p6; return j.ret; })()) && this.bq("!") == false) {
            this.eg(b);
            return {
              ret: false,
              p0: a
            };
          }
        }
        else {
          let j;
          let k;
          if (((() => { let l = ExcelUtils.bp(this.cw, e.d, e.c, this.j.h, h, j, i, k); h = l.p4; j = l.p5; i = l.p6; k = l.p7; return l.ret; })()) && this.bq("!") == false) {
            this.eg(b);
            return {
              ret: false,
              p0: a
            };
          }
        }
      }
      let l = this.cp;
      f = this.t();
      if (f.b) {
        if (g && l < this.cw.length) {
          let m = this.cw.charAt(l);
          if (isLetter(m) || m == ' ') {
            this.eg(b);
            return {
              ret: false,
              p0: a
            };
          }
          else if (a.b == null) {
            let n = ((() => { let o = this.c4(d, a.a); d = o.p0; a.a = o.p1; return o.ret; })());
            if (n != null || d) {
              this.eg(b);
              return {
                ret: false,
                p0: a
              };
            }
            else if (this.bq('\'')) {
              let o = this.dc();
              if (o != null && this.bq('\'') && this.bq("!")) {
                this.eg(b);
                return {
                  ret: false,
                  p0: a
                };
              }
            }
          }
        }
        this.h = new FormulaParseException(l, this.cw, ExcelUtils.ef("LE_FormulaParseException_WorksheetRangeMissingEndingName"), this.cw.substr(c, this.cp - c));
        return {
          ret: false,
          p0: a
        };
      }
    }
    if (a.b == null && e.b == false && f.b && this.bq("|")) {
      return {
        ret: ((() => { let p = this.a3(a, c); a = p.p0; return p.ret; })()),
        p0: a
      };
    }
    if (this.bq("!") == false) {
      this.cp = c;
      if (this.bp('[') && this.c8(false) != null) {
        this.cp = c;
        return {
          ret: false,
          p0: a
        };
      }
      if (a.b != null) {
        this.h = new FormulaParseException(c, this.cw, ExcelUtils.ef("LE_FormulaParseException_NoExclamationAfterWorksheetName"), this.cw.substr(c, this.cp - c));
      }
      this.eg(b);
      return {
        ret: false,
        p0: a
      };
    }
    if (e.b == false) {
      a.c = this.cw.substr(e.d, e.c);
    }
    if (f.b == false) {
      a.d = this.cw.substr(f.d, f.c);
    }
    return {
      ret: true,
      p0: a
    };
  }
  static bu(a, b) {
    b = false;
    if (stringEquals1(a, "FALSE", StringUtilities.g)) {
      return {
        ret: true,
        p1: b
      };
    }
    if (stringEquals1(a, "TRUE", StringUtilities.g)) {
      b = true;
      return {
        ret: true,
        p1: b
      };
    }
    return {
      ret: false,
      p1: b
    };
  }
  dz(a) {
    this.d7(a);
    let b = typeCast(FunctionVOperator.$, a.b);
    if (b == null) {
      return;
    }
    if (b.$function._qp == false) {
      return;
    }
    let c = this.cd.e();
    let d = (this.b9.count - 1);
    c.a.selectorFunctionTokenIndex = d;
    for (let e of fromEnum(c.b)) {
      e.t = d;
    }
  }
  d0(a, b) {
    let c = b.b;
    while (a.f > 0) {
      let d = a.d().b;
      if (c.n) {
        if (c.o > d.o) {
          this.dz(a.e());
        }
        else {
          break;
        }
      }
      else {
        if (c.o >= d.o) {
          this.dz(a.e());
        }
        else {
          break;
        }
      }
    }
    a.h(b);
  }
  d1() {
    let a = new AttrSkipToken();
    let b = this.cd.d();
    b.b.add(a);
    b.a.skipTokenIndexes.add(this.b9.count);
    this.d7(new FormulaParser_FormulaTokenInfo(1, a, -1, null));
  }
  d2(a, b) {
    this.d3(a, this.cp, b);
  }
  d3(a, b, c) {
    this.ea(this.b8.count, a, b, c, null);
  }
  ea(a, b, c, d, e) {
    this.cp = c + d;
    this.b8.insert(a, new FormulaParser_FormulaTokenInfo(1, b, c, e));
    this.ee();
  }
  d4(a, b, c) {
    this.d6(a, this.cp, b, c);
  }
  d6(a, b, c, d) {
    this.d5(a, b, c, this.r, d);
  }
  d5(a, b, c, d, e) {
    this.eb(this.b8.count, a, b, c, d, e);
  }
  eb(a, b, c, d, e, f) {
    let g = this.a(e, f);
    this.ea(a, b, c, d, g);
  }
  d7(a) {
    this.d9(a.a);
    this.b9.add(a);
  }
  d8(a, b, c) {
    c = FormulaParser.w(c, b);
    while (a > 0) {
      let d = Math.min(a, 255);
      this.ca.add(AttrSpaceToken.r(d, c));
      a -= d;
    }
  }
  d9(a) {
    if (a == null) {
      return;
    }
    for (let b = 0; b < a.length; b++) {
      let c = a[b];
      if (this.b9.count == 1 && typeCast(AttrVolatileToken.$, this.b9._inner[0].b) !== null) {
        this.b9._inner[0] = new FormulaParser_FormulaTokenInfo(1, new AttrSpaceVolitileToken(1, c), 0, null);
      }
      else {
        this.b9.add(new FormulaParser_FormulaTokenInfo(1, c, 0, null));
      }
    }
  }
  q() {
    let a = false;
    let b = false;
    for (let c = 0, d = this.b8.count; c < d; c++) {
      let e = this.b8._inner[c];
      let f = e.b;
      b = a;
      a = false;
      let g = typeCast(FunctionOperator.$, f);
      if (g != null) {
        if (g.$function._vv == 359) {
          this.j.d._ai = true;
        }
        else if (g.$function._qu) {
          this.j.d._at = true;
        }
        a = true;
        this.cb.h(0);
        this.cc.h(e);
        if (g.$function._qk) {
          let h;
          {
            h = new NameXToken(1, g.$function._arv, null, g.$function._alx, this.j, 1, false);
          }
          this.d7(new FormulaParser_FormulaTokenInfo(1, h, e.c, null));
        }
        continue;
      }
      if (typeCast(OpenParenOperator.$, f) !== null) {
        this.cc.h(e);
        continue;
      }
      let i = typeCast(UnionOperator.$, f);
      if (i != null) {
        let j = false;
        for (let k of fromEnum(this.cc)) {
          let l = k.b;
          if (typeCast(OpenParenOperator.$, l) !== null) {
            break;
          }
          else if (typeCast(FunctionOperator.$, l) !== null) {
            j = true;
            while ((typeCast(FunctionOperator.$, this.cc.d().b) !== null) == false) {
              this.dz(this.cc.e());
            }
            let m = this.cc.d();
            let n = m.b;
            if (n.$function._qp) {
              if (this.cb.d() == 0) {
                let o = n.$function._vv == 1 ? new AttrIfToken() : new AttrChooseToken();
                this.cd.h(new FormulaParser_SelectorFunctionOptimizationInfo(1, o));
                this.d7(new FormulaParser_FormulaTokenInfo(1, o, -1, null));
              }
              else {
                this.d1();
              }
            }
            let p = this.cb.e();
            p++;
            this.cb.h(p);
            break;
          }
        }
        if (j) {
          continue;
        }
      }
      if (typeCast(ParenToken.$, f) !== null) {
        while ((typeCast(FunctionOperator.$, this.cc.d().b) !== null) == false && (typeCast(OpenParenOperator.$, this.cc.d().b) !== null) == false) {
          this.dz(this.cc.e());
        }
        let q = this.cc.e();
        let r = q.b;
        let s = typeCast(FunctionOperator.$, r);
        if (s != null) {
          if (e.a != null) {
            q.d(e.a);
          }
          if (s.$function._qp) {
            this.d9(q.a);
            this.d1();
            q.a = null;
          }
          let t = this.cb.e();
          if (b == false) {
            t++;
          }
          else {
          }
          if (t == 1 && s.$function._vv == 4) {
            let u = new AttrSumToken();
            this.d7(new FormulaParser_FormulaTokenInfo(1, u, q.c, q.a));
          }
          else {
            this.dz(q);
            let v = typeCast(FunctionVOperator.$, s);
            if (v != null) {
              v.argumentCount = t;
            }
          }
        }
        else {
          e.c = q.c;
          if (q.a != null) {
            e.d(q.a);
          }
          this.d7(e);
        }
        continue;
      }
      let w = typeCast(OperatorToken.$, f);
      if (w != null) {
        if (w.f == 15 && e.a == null && c + 3 < d && this.b9.count > 0) {
          let x = this.b9._inner[this.b9.count - 1];
          if (x.b.f == 30 && typeCast(IntToken.$, this.b8._inner[c + 1].b) !== null && typeCast(DivOperator.$, this.b8._inner[c + 2].b) !== null && typeCast(IntToken.$, this.b8._inner[c + 3].b) !== null) {
            if (this.b8._inner[c + 2].a != null) {
              return new FormulaParser_TextSpan(1, this.b8._inner[c + 1].c, (this.b8._inner[c + 3].c - this.b8._inner[c + 1].c));
            }
            let y = x.b.p;
            let z = this.b8._inner[c + 1].b.p;
            let aa = this.b8._inner[c + 3].b.p;
            if (this.b8._inner[c + 3].a != null || aa <= 0) {
              let ab = (c + 4) < this.b8.count ? this.b8._inner[c + 4].c - this.b8._inner[c + 2].c : this.cw.length - this.b8._inner[c + 2].c;
              return new FormulaParser_TextSpan(1, this.b8._inner[c + 2].c, ab);
            }
            let ac = y + (z / aa);
            let ad = new NumberToken(1, ac);
            this.b9._inner[this.b9.count - 1] = new FormulaParser_FormulaTokenInfo(1, ad, x.c, x.a);
            c += 3;
            continue;
          }
        }
        this.d0(this.cc, e);
        continue;
      }
      this.d7(e);
    }
    while (this.cc.f > 0) {
      this.dz(this.cc.e());
    }
    return FormulaParser_TextSpan.a;
  }
  static k(a, b, c, d) {
    let e = Formula._h(a, b);
    e._z = d;
    return new FormulaContext(5, null, null, null, -1, e, c, a, d);
  }
  static l(a, b, c, d, e, f, g) {
    let h = Formula._h(f, g);
    let i = 2;
    if (a != null) {
      i = a.currentFormat;
    }
    h._z = i;
    return new FormulaContext(5, a, b, c, d, h, e, f, i);
  }
  v(a) {
    if (a % 1 == 0 && 0 <= a && a <= 65535) {
      return new IntToken(1, truncate(a));
    }
    return new NumberToken(1, a);
  }
  a(a, b) {
    if (a.c == 0) {
      return null;
    }
    this.ca.clear();
    for (let c = 0, d = a.d; c < a.c; c++ , d++) {
      let e = 1;
      let f = this.cw.charAt(d);
      switch (f) {
        case ' ':
        case '\t':
        case '\n':
          {
            for (c++ , d++; c < a.c && this.cw.charAt(d) == f; c++ , d++) {
              e++;
            }
            switch (f) {
              case ' ':
                this.d8(e, true, b);
                break;
              case '\t':
                this.d8(e * 4, true, b);
                break;
              case '\n':
                this.d8(e, false, b);
                break;
              default: break;
            }
            continue;
          }
        case '\r':
          {
            d++;
            let g;
            if (++c == a.c) {
              g = '\0';
            }
            else {
              g = this.cw.charAt(d);
            }
            switch (g) {
              case '\r':
                {
                  e++;
                  for (c++ , d++; c < a.c && this.cw.charAt(d) == f; c++ , d++) {
                    e++;
                  }
                }
                break;
              case '\n':
                {
                  for (c++ , d++; c < a.c && this.cw.charAt(d) == '\r' && this.cw.charAt(d + 1) == '\n'; c++ , d++) {
                    e++;
                  }
                }
                break;
              default: break;
            }
            this.d8(e, false, b);
            continue;
          }
      }
      break;
    }
    return this.ca.toArray();
  }
  static w(a, b) {
    switch (a) {
      case 0:
      case 1: if (b) {
        return 0;
      }
      else {
        return 1;
      }
      case 2:
      case 3: if (b) {
        return 2;
      }
      else {
        return 3;
      }
      case 4:
      case 5: if (b) {
        return 4;
      }
      else {
        return 5;
      }
      case 6: return 6;
      default: return 0;
    }
  }
  static cx(a) {
    switch (a) {
      case 0: return "#All";
      case 1: return "#Data";
      case 2: return "#Headers";
      case 3: return "#Totals";
      case 4: return "#This Row";
      default: return "#Data";
    }
  }
  static bw(a) {
    if (a == ",") {
      return '\\';
    }
    return ",";
  }
  static bx(a) {
    return FormulaParser.by(a.numberFormat.numberDecimalSeparator);
  }
  static by(a) {
    if (a == ",") {
      return ";";
    }
    return ",";
  }
  y(a) {
    let b;
    if (a.b == null) {
      b = this.x;
    }
    else {
      if (((() => { let c = this.b6.tryGetValue(a.b, b); b = c.p1; return c.ret; })()) == false) {
        let c;
        if (this.j.f != null && this.j.f._dz != null && ((() => { let d = this.j.f._dz.tryGetValue(a.b, c); c = d.p1; return d.ret; })())) {
          b = c;
        }
        else {
          b = new WorkbookReferenceUnconnected(a.b, a.a);
        }
        this.b6.addItem(a.b, b);
      }
    }
    return {
      ret: b.g(a.c, a.d),
      p0: a
    };
  }
  static aa(a) {
    switch (a) {
      case '\'':
      case '[':
      case ']':
      case '#':
      case '@': return true;
      default: return false;
    }
  }
  static ab(a, b, c) {
    let d = 0;
    let e = ((() => { let f = FormulaParser.c9(a, false, d); d = f.p2; return f.ret; })());
    return e == a && FormulaParser.n.ad(a, b, c);
  }
  ad(a, b, c) {
    let d = false;
    let e = 0;
    let f;
    let g = false;
    let h = 0;
    let i;
    if (((() => { let j = FormulaParser.am(a, 0, b, c, e, d, f); e = j.p4; d = j.p5; f = j.p6; return j.ret; })())) {
      if (((() => { let j = FormulaParser.a9(a, f, b, h, g, i); h = j.p3; g = j.p4; i = j.p5; return j.ret; })())) {
        if (f + i == a.length) {
          return false;
        }
      }
    }
    if (((() => { let j = this.bd(a, 0, b, h, g, i); h = j.p3; g = j.p4; i = j.p5; return j.ret; })())) {
      return false;
    }
    if (((() => { let j = this.aq(a, 0, b, e, d, f); e = j.p3; d = j.p4; f = j.p5; return j.ret; })())) {
      if (f == a.length) {
        return false;
      }
      if (a.charAt(f) != '.') {
        return false;
      }
      if (f > 1 && f + 1 < a.length) {
        if (((() => { let j = this.bd(a, f + 1, b, h, g, i); h = j.p3; g = j.p4; i = j.p5; return j.ret; })()) && i > 1 && (i + f + 1) == a.length) {
          return false;
        }
      }
    }
    return true;
  }
  eg(a) {
    this.cp = a.d;
    this.r = a.b;
    this.b8.v(a.f, this.b8.count - a.f);
  }
  o() {
    return new FormulaParser_PositionInfo(1, this.cp, this.b8.count, this.r);
  }
  static bo(a) {
    let b = 0;
    let c = ((() => { let d = FormulaParser.u(a, b, true); b = d.p1; return d.ret; })());
    if (c.c != a.length) {
      return true;
    }
    let d = stringToLocaleUpper(a, CultureInfo.invariantCulture);
    if ("RC" == d) {
      return true;
    }
    let e = 2;
    let f = 0;
    let g = false;
    let h;
    if (((() => { let i = FormulaParser.bc(d, 0, e, f, g, h); f = i.p3; g = i.p4; h = i.p5; return i.ret; })()) && !g && f >= 0 && f < Workbook.getMaxRowCount(e)) {
      return true;
    }
    let i = 0;
    let j = 0;
    if (d.length > 1 && d.charAt(0) == 'R') {
      j = 1;
    }
    if (((() => { let k = FormulaParser.ap(d, j, e, i, g, h); i = k.p3; g = k.p4; h = k.p5; return k.ret; })()) && !g && i >= 0 && i < Workbook.getMaxRowCount(e)) {
      return true;
    }
    if (((() => { let k = ExcelUtils.bm(a, e, CultureInfo.currentCulture, i, f); i = k.p3; f = k.p4; return k.ret; })())) {
      return true;
    }
    return false;
  }
  bp(a) {
    if (this.cp >= this.cw.length) {
      return false;
    }
    return this.cw.charAt(this.cp) == a;
  }
  bq(a) {
    if (this.cp >= this.cw.length) {
      return false;
    }
    if (this.cw.charAt(this.cp) != a) {
      return false;
    }
    this.cp++;
    return true;
  }
  br(a) {
    if (this.cp >= this.cw.length) {
      return false;
    }
    return FormulaParser.ac(this.cw.charAt(this.cp), a);
  }
  bs(a) {
    return this.bt(a, true);
  }
  bt(a, b) {
    if ((this.cp + a.length) > this.cw.length) {
      return false;
    }
    for (let c = 0; c < a.length; c++) {
      let d = this.cw.charAt(this.cp + c);
      let e = a.charAt(c);
      if (b) {
        d = d.toLowerCase();
        e = e.toLowerCase();
      }
      if (d != e) {
        return false;
      }
    }
    this.cp += a.length;
    return true;
  }
  static get n() {
    if (FormulaParser.m == null) {
      FormulaParser.m = new FormulaParser();
    }
    return FormulaParser.m;
  }
  get ch() {
    if (ExcelUtils.au(this.j.h)) {
      return 1024;
    }
    return 8192;
  }
  get ck() {
    if (ExcelUtils.au(this.j.h)) {
      return 8;
    }
    return 64;
  }
  get h() {
    return this.g;
  }
  set h(a) {
    this.g = a;
  }
  get bn() {
    if (this.j.b == 0) {
      return true;
    }
    switch (this.i) {
      case 2:
      case 3:
      case 4:
      case 7: return true;
    }
    return false;
  }
  get dh() {
    if (this.dg == null) {
      this.dg = new Regex(1, "\\GC(?![\\p{L}_])((\\[[-+]?[0-9]{1,6}])|([0-9]{1,6}(?![0-9])))?", 8);
    }
    return this.dg;
  }
  get dl() {
    if (this.dk == null) {
      this.dk = new Regex(1, "\\G(#NULL!|#DIV/0!|#VALUE!|#REF!|#NAME\\?|#NUM!|#N/A)", 8 | 1);
    }
    return this.dk;
  }
  get dj() {
    if (this.di == null) {
      this.di = new Regex(1, "(?<=(?<!')('')*)'(?!')", 8);
    }
    return this.di;
  }
  get dn() {
    if (this.dm == null) {
      this.dm = new Regex(1, "\\G\\[[_a-zA-Z0-9][_a-zA-Z0-9.]*\\]", 8);
    }
    return this.dm;
  }
  get dq() {
    if (this.dp == null) {
      this.dp = new Regex(1, "\\G([^\\\\/:*?\"<>|[\\]']|(''))+", 8);
    }
    return this.dp;
  }
  get ds() {
    if (this.dr == null) {
      this.dr = new Regex(1, "\\G(([a-zA-Z]:(\\\\|/))|\\\\\\\\)?(([^\\\\/:*?\"<>|[\\]']|(''))*(\\\\|/))*", 8);
    }
    return this.dr;
  }
  get du() {
    if (this.dt == null) {
      this.dt = new Regex(1, "\\G((R(?![\\p{L}_])((\\[[-+]?[0-9]{1,7}])|([0-9]{1,7}(?![0-9])))?)|(R(?=C(?![\\p{L}_]))))", 8);
    }
    return this.dt;
  }
  get dw() {
    if (this.dv == null) {
      this.dv = new Regex(1, "\\G(ht|f)tp(s?)\\:(\\\\|/){2}([0-9a-zA-Z]([-.\\w\\s]*[0-9a-zA-Z])*(\\\\|/)?)*(:(0-9)*)*(/?)([a-zA-Z0-9\\-\\.\\?\\,'/\\\\\\+&%\\$#_]*)?(\\\\|/)", 8);
    }
    return this.dv;
  }
}
FormulaParser.$t = markType(FormulaParser, 'FormulaParser');
FormulaParser.m = null;
/**
 * Represents the aggregated conditioal format for a specific cell. It is returned via the <see cref="Worksheet.GetCellConditionalFormat(int, int)">Worksheet.GetCellConditionalFormat</see> and the <see cref="WorksheetRow.GetCellConditionalFormat">WorksheetRow.GetCellConditionalFormat</see> methods.
 */
export class CellConditionalFormat extends Base {
  constructor(a, ..._rest) {
    super();
    this._g = null;
    this._b = null;
    this._d = null;
    this._i = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          this._i = false;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this._i = true;
          this._g = c;
          this._b = d;
          this._d = e;
        }
        break;
    }
  }
  /**
   * Returns a cell format that represents the aggregated format for all conditional formats that apply to the cell (read-only).
   */
  get cellFormat() {
    return this._g;
  }
  /**
   * @hidden
   */
  get _h() {
    return this._g;
  }
  /**
   * Returns a data bar info if applicable, otherwise null (read-only).
   */
  get dataBarInfo() {
    return this._b;
  }
  /**
   * Returns an icon info if applicable, otherwise null (read-only).
   */
  get iconInfo() {
    return this._d;
  }
  /**
   * Returns whether this cell has conditional formatting applied (read-only)
   */
  get hasConditionFormatting() {
    return this._i;
  }
}
CellConditionalFormat.$t = markType(CellConditionalFormat, 'CellConditionalFormat');
/**
 * @hidden
 */
CellConditionalFormat._a = new CellConditionalFormat(0);
/**
 * Exposes the information necessary for drawing a data bar for a specific cell.
 * @see [[CellConditionalFormat]]
 */
export class CellDataBarInfo extends Base {
  constructor(a, b, c, d, e, f, g, h, i, j) {
    super();
    this._o = 0;
    this._p = 0;
    this._q = 0;
    this._k = false;
    this._l = false;
    this._a = 0;
    this._c = 0;
    this._e = null;
    this._g = null;
    this._f = null;
    this._o = a;
    this._p = b;
    this._q = c;
    this._k = d;
    this._l = e;
    this._a = f;
    this._c = g;
    this._e = h;
    this._g = i;
    this._f = j;
  }
  /**
   * The color to use to draw the axis line or null if no axis line is to be drawn (read-only).
   * @see [[axisPosition]]
   */
  get axisColor() {
    return this._e;
  }
  /**
   * Specifies the position, as a percentage of the cell width, where the axis ahould be rendered (read-only)
   * a percentage from 0 to 100
   * <para class="note"><b>Note:</b> if [[axisColor]] returns null then this property can be ignored.</para>
   * @see [[axisColor]]
   */
  get axisPosition() {
    return this._o;
  }
  /**
   * The color to use to draw the border around the data bar or null if no border is to be drawn (read-only).
   */
  get barBorder() {
    return this._f;
  }
  /**
   * The color to use to draw the data bar (read-only).
   * @see [[barFillType]]
   * @see [[barPositionFrom]]
   * @see [[barPositionTo]]
   */
  get barColor() {
    return this._g;
  }
  /**
   * Specifies whether the data bar should be filled with a sold color or a gradient (read-only).
   * @see [[barColor]]
   */
  get barFillType() {
    return this._c;
  }
  /**
   * Species the position, as a percentage of the cell width, where the data bar should begin (read-only).
   * @see [[barPositionTo]]
   * @see [[direction]]
   */
  get barPositionFrom() {
    return this._p;
  }
  /**
   * Species the position, as a percentage of the cell width, where the data bar should end (read-only).
   * @see [[barPositionFrom]]
   * @see [[direction]]
   */
  get barPositionTo() {
    return this._q;
  }
  /**
   * Specifies the direction of the bata bar (read-only).
   * @see [[barPositionFrom]]
   * @see [[barPositionTo]]
   */
  get direction() {
    return this._a;
  }
  /**
   * Returns true if the cell value is negative (read-only).
   */
  get isNegative() {
    return this._k;
  }
  /**
   * Returns whether the cell value is to be shown along with the data bar (read-only).
   */
  get showValue() {
    return this._l;
  }
}
CellDataBarInfo.$t = markType(CellDataBarInfo, 'CellDataBarInfo');
/**
 * Exposes the information necessary for drawing an icon for a specific cell.
 * @see [[CellConditionalFormat]]
 */
export class CellIconInfo extends Base {
  constructor(a, b, c, d) {
    super();
    this._e = false;
    this._g = 0;
    this._a = 0;
    this._c = 0;
    this._c = a;
    this._a = b;
    this._g = c;
    this._e = d;
  }
  /**
   * The icon to be drawn (read-only).
   */
  get icon() {
    return this._a;
  }
  /**
   * The index of the icon in the icon set (read-only).
   */
  get iconIndex() {
    return this._g;
  }
  /**
   * The icon set (read-only).
   */
  get iconSet() {
    return this._c;
  }
  /**
   * Returns whether the cell value is to be shown along with the data bar (read-only).
   */
  get showValue() {
    return this._e;
  }
}
CellIconInfo.$t = markType(CellIconInfo, 'CellIconInfo');
/**
 * @hidden
 */
export class ConditionMatchResult extends Base {
  constructor(a, ..._rest) {
    super();
    this.i = false;
    this.g = null;
    this.a = null;
    this.c = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = [true];
          {
            let f = d[0];
            this.i = f;
          }
          this.g = c;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [true];
          {
            let f = d[0];
            this.i = f;
          }
          this.a = c;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = [true];
          {
            let f = d[0];
            this.i = f;
          }
          this.c = c;
        }
        break;
      case 3:
        {
          let c = _rest[0];
          this.i = c;
        }
        break;
    }
  }
  get h() {
    return this.g;
  }
  get b() {
    return this.a;
  }
  get d() {
    return this.c;
  }
}
ConditionMatchResult.$t = markType(ConditionMatchResult, 'ConditionMatchResult');
ConditionMatchResult.e = new ConditionMatchResult(3, true);
ConditionMatchResult.f = new ConditionMatchResult(3, false);
/**
 * Abstract base class for classes which control
 * the visual attributes of a [[WorksheetCell]],
 * based on whether the cell's value meets a logical condition.
 */
export class ConditionalFormatBase extends ConditionBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super();
          this._bt = null;
          this._bv = null;
          this._by = NaN;
        }
        break;
      case 1:
        {
          let regions = _rest[0];
          let conditionType = _rest[1];
          super(regions, conditionType);
          this._bt = null;
          this._bv = null;
          this._by = NaN;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _bb() {
    this._a5();
  }
  /**
   * @hidden
   */
  _bf() {
    super._bf();
    this._a5();
  }
  /**
   * Returns an [[IWorksheetCellFormat]] interface implementation
   * which represents the format for cells which meet the criteria associated
   * with this condition.
   * <p class="body">
   * The IWorksheetCellFormat implementation defines the visual attributes which
   * are applied to cells whose value meets the associated condition.
   * </p>
   */
  get cellFormat() {
    if (this._bt == null) {
      let a = this.workbook;
      if (a != null) {
        this._bt = new ConditionalFormatOwnedFormatProxy(a._cc, this);
      }
    }
    return this._bt;
  }
  /**
   * @hidden
   */
  get _bz() {
    return this._by;
  }
  /**
   * @hidden
   */
  set _bz(a) {
    this._by = a;
  }
  /**
   * @hidden
   */
  get _bw() {
    if (this._bv == null && this.workbook != null) {
      this._bv = this.workbook._cd(2);
    }
    return this._bv;
  }
  /**
   * @hidden
   */
  set _bw(a) {
    this._bv = a;
  }
  /**
   * @hidden
   */
  get _bx() {
    return this._bv != null;
  }
  /**
   * @hidden
   */
  _a5() {
    this._by = NaN;
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(ConditionalFormatBase.$, a);
    if (c._bv != null) {
      this._bv = c._bv._bv(this.workbook, b);
    }
  }
  /**
   * @hidden
   */
  getAdjacentFormatForBorderResolution(sender, borderValue) {
    return null;
  }
  /**
   * @hidden
   */
  onCellFormatValueChanged(sender, values, options) {
  }
  /**
   * @hidden
   */
  onCellFormatValueChanging(sender, values) {
  }
  /**
   * @hidden
   */
  verifyFormatOptions(sender, formatOptions) {
  }
}
ConditionalFormatBase.$t = markType(ConditionalFormatBase, 'ConditionalFormatBase', ConditionBase.$, [IWorksheetCellFormatProxyOwner_$type]);
/**
 * @hidden
 */
export class WorksheetMergedRegionOwnedCellFormatProxy extends WorksheetCellFormatProxy {
  constructor(a, b) {
    super(1, a, b);
  }
  get__l() {
    return WorksheetMergedRegionOwnedCellFormatProxy._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 4;
  }
  get _q() {
    return this.get__q();
  }
  get__v() {
    let a = typeCast(WorksheetMergedCellsRegion.$, this._s);
    if (a != null) {
      return a.worksheet;
    }
    return null;
  }
  get _v() {
    return this.get__v();
  }
}
WorksheetMergedRegionOwnedCellFormatProxy.$t = markType(WorksheetMergedRegionOwnedCellFormatProxy, 'WorksheetMergedRegionOwnedCellFormatProxy', WorksheetCellFormatProxy.$);
WorksheetMergedRegionOwnedCellFormatProxy._br = WorksheetCellFormatProxy._m(4, 4);
/**
 * @hidden
 */
export class ValueFormatter_GetTextWidthHelper extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.a = null;
    this.b = b;
    this.a = a;
  }
  e(a) {
    return truncate(this.a._g(this.b, a, Nullable$1.toNullable(Size.$, null), true, false).width);
  }
  d(a) {
    return this.a._g(this.b, a, Nullable$1.toNullable(Size.$, null), true, false).width;
  }
  get c() {
    return this.a._b;
  }
}
ValueFormatter_GetTextWidthHelper.$t = markType(ValueFormatter_GetTextWidthHelper, 'ValueFormatter_GetTextWidthHelper');
/**
 * @hidden
 */
export class ValueFormatter_FormatValueState extends Base {
  constructor(a, b, c) {
    super();
    this.g = 0;
    this.m = 0;
    this.b = 0;
    this.aa = Nullable$1.toNullable(Date_$type, null);
    this.o = -1;
    this.q = -1;
    this.s = 0;
    this.ac = null;
    this.u = 0;
    this.d = false;
    this.ae = null;
    this.w = 0;
    this.ag = null;
    this.i = 0;
    this.ai = null;
    this.k = 0;
    this.y = 0;
    this.ak = null;
    this.a = null;
    this.f = false;
    this.a = a;
    this.k = b;
    this.g = Math.abs(this.k);
    this.f = c;
    if (a.aa) {
      let d;
      if (a.o) {
        this.at(2);
        d = this.g;
      }
      else {
        this.i = MathUtilities.j(this.g);
        this.ai = a.cd(this.i, false);
        d = this.g - this.i;
      }
      if (a.b4.hasValue) {
        this.u = a.b4.value;
        this.w = truncate(ValueFormatter.w(d * this.u));
      }
      else if (a.b2.hasValue) {
        let e;
        let f;
        let g = ValueFormatter_FormatValueState.ar(d, a.b2.value, e, f);
        e = g.p2;
        f = g.p3;
        this.u = f;
        this.w = e;
      }
      else {
        return;
      }
      if (this.u == this.w && a.o == false) {
        this.i += 1;
        this.ai = a.cd(this.i, false);
        this.w = 0;
      }
      this.ae = a.ce(this.u);
      this.ag = a.ce(this.w);
    }
    else if (a.ag) {
      if (this.g == 0) {
        this.y = 0;
      }
      else {
        this.y = MathUtilities.m(this.g);
        let h = this.y % a.bv;
        if (this.y % a.bv != 0) {
          if (this.y < 0) {
            this.y -= a.bv + h;
          }
          else {
            this.y -= h;
          }
        }
      }
      this.ak = a.ce(Math.abs(this.y));
      let i = this.g / Math.pow(10, this.y);
      i = ValueFormatter.w(i, Math.min(a.bo, 15));
      this.i = truncate(MathUtilities.j(i));
      this.ai = a.cd(this.i, false);
      let j = a.cd(i, false);
      let k = j.indexOf(this.a.bd.numberFormat.numberDecimalSeparator);
      if (k < 0) {
        this.ac = stringEmpty();
      }
      else {
        this.ac = j.substr(k + 1);
      }
      this.at(4);
    }
    else {
      let l = this.g;
      if (a.bt != 0) {
        l /= Math.pow(1000, a.bt);
      }
      if (a.bx != 0) {
        l *= Math.pow(100, a.bx);
      }
      if (l != 0 && a.g != 1) {
        l = ValueFormatter.w(l, Math.min(a.bo, 15));
      }
      this.i = MathUtilities.j(l);
      this.ai = a.cd(this.i, false, a.am);
      let m = a.cd(l, false, false);
      let n = m.indexOf(this.a.bd.numberFormat.numberDecimalSeparator);
      if (n < 0) {
        this.ac = stringEmpty();
      }
      else {
        this.ac = m.substr(n + 1);
      }
    }
    if (stringIsNullOrEmpty(this.ac) == false) {
      this.ac = a.b8(this.ac);
    }
  }
  am() {
    switch (this.b) {
      case 0:
        this.at(1);
        break;
      case 4:
        this.at(5);
        break;
      case 6:
        this.at(7);
        break;
      case 1:
      case 2:
      case 5:
      case 7: break;
      default: break;
    }
  }
  ao() {
    this.at(3);
  }
  an() {
    this.s++;
  }
  ap() {
    if (this.a.aa && this.a.o == false && this.b == 0 && this.m > 0) {
      this.at(2);
    }
  }
  aq() {
    this.at(6);
  }
  static ar(a, b, c, d) {
    d = 1;
    c = truncate(a);
    let e = a;
    let f = truncate(Math.pow(10, b)) - 1;
    let g = 0;
    let h = c / d;
    let i = Math.abs(a - h);
    let j = d;
    let k = c;
    while (a - h != 0 && e != Math.floor(e)) {
      e = 1 / (e - Math.floor(e));
      let l = d * truncate(Math.floor(e)) + g;
      if (l > f) {
        break;
      }
      g = d;
      d = l;
      c = truncate(ValueFormatter.w(a * d));
      h = c / d;
      let m = Math.abs(a - h);
      if (m < i) {
        i = m;
        j = d;
        k = c;
      }
    }
    d = j;
    c = k;
    return {
      p2: c,
      p3: d
    };
  }
  as() {
    this.m = 0;
  }
  at(a) {
    this.b = a;
    this.as();
  }
  get h() {
    return this.g;
  }
  get n() {
    return this.m;
  }
  set n(a) {
    this.m = a;
  }
  get c() {
    return this.b;
  }
  get ab() {
    if (this.aa.hasValue == false) {
      this.aa = ExcelCalcValue._be(this.a.c.i, this.k, true, true);
    }
    return this.aa;
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
  get r() {
    return this.q;
  }
  set r(a) {
    this.q = a;
  }
  get t() {
    return this.s;
  }
  get ad() {
    return this.ac;
  }
  get v() {
    return this.u;
  }
  get e() {
    return this.d;
  }
  set e(a) {
    this.d = a;
  }
  get af() {
    return this.ae;
  }
  get x() {
    return this.w;
  }
  get ah() {
    return this.ag;
  }
  get l() {
    return this.k;
  }
  get j() {
    return this.i;
  }
  get aj() {
    return this.ai;
  }
  get z() {
    return this.y;
  }
  get al() {
    return this.ak;
  }
}
ValueFormatter_FormatValueState.$t = markType(ValueFormatter_FormatValueState, 'ValueFormatter_FormatValueState');
/**
 * @hidden
 */
export class ValueFormatter_FormatSection_FormulaValueInfo extends ValueType {
  constructor() {
    super();
    this.e = 0;
    this.a = false;
    this.b = false;
    this.f = 0;
    this.g = 0;
    this.d = '\0';
    this.c = false;
  }
}
ValueFormatter_FormatSection_FormulaValueInfo.$t = markStruct(ValueFormatter_FormatSection_FormulaValueInfo, 'ValueFormatter_FormatSection_FormulaValueInfo');
/**
 * @hidden
 */
export class WorksheetRowCollection_RowsLoadOnDemandTree extends RowColumnLoadOnDemandTree$1 {
  constructor(a) {
    super(WorksheetRow.$, a);
    this._ay = 0;
  }
  _f(a, b) {
    return new WorksheetRowCollection_RowBinaryTreeNode(a, b, this);
  }
  _k(a, b, c) {
    return new WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint(this, a, b, c);
  }
  _l(a, b) {
    return new WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd(a, b);
  }
  _m(a, b) {
    return new WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove(a, b);
  }
  get _a1() {
    return this._ay;
  }
  _a3(a, b, c) {
    if (c == 0) {
      return {
        p0: a,
        p1: b
      };
    }
    let d = (intDivide(b, c));
    d = Math.min(d, this._al - a - 1);
    a += d;
    b -= (d * c);
    return {
      p0: a,
      p1: b
    };
  }
  _a2(a, b, c, d) {
    let e = 0;
    let f = this._ac;
    let g = f != null ? f.count : 0;
    for (let h = 0; h < g; h++) {
      let i = typeCast(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint.$, f._inner[h]);
      if (i.n > a) {
        break;
      }
      let j = 0;
      if (false == i.e || i.l < a) {
        j = i.aa(b, c, d);
      }
      else {
        let k = a - i.n;
        for (let l = 0; l < k; l++) {
          j += i.z(l, b, c, d);
        }
      }
      if (i.e) {
        e += j;
      }
      else {
        e -= j;
      }
    }
    return e;
  }
  _a6(a, b, c, d, e) {
    let f = this._at.defaultRowHeight;
    let g = f;
    if (e == false && this._at._dv) {
      g = 0;
    }
    let h = this._a4(a, b, c, d, f, g, e);
    c = h.p2;
    d = h.p3;
    return {
      p2: c,
      p3: d
    };
  }
  _a4(a, b, c, d, e, f, g) {
    c = 0;
    d = 0;
    if (a == 0 && b == 0) {
      return {
        p2: c,
        p3: d
      };
    }
    let h = Math.max(this._ah(a), 0);
    let i = b == a ? h : Math.max(this._ah(b), 0);
    let j = this._a5(h, i, c, d, e, f, g);
    c = j.p2;
    d = j.p3;
    c += this._a2(a, e, f, g);
    if (a == b) {
      d = c;
    }
    else {
      d += this._a2(b, e, f, g);
    }
    return {
      p2: c,
      p3: d
    };
  }
  _a5(a, b, c, d, e, f, g) {
    let h = f * 32;
    let i = a - a % 32;
    let j = b - b % 32;
    let k = f;
    let l = i;
    let m = false;
    let n = 0;
    let o;
    for (let p of fromEnum(this._y())) {
      let q = p;
      if (m == false) {
        o = intDivide((Math.min(i, q.l) - n), 32);
        c += o * h;
      }
      o = intDivide((Math.min(j, q.l) - n), 32);
      d += o * h;
      if (l < q.l) {
        if (m == false) {
          c += k * (a - l);
          m = true;
          l = j;
        }
        if (l < q.l) {
          d += k * (b - l);
          return {
            p2: c,
            p3: d
          };
        }
      }
      if (q.l == l) {
        if (m == false) {
          c += WorksheetRowCollection_RowsLoadOnDemandTree._az(a, q, e, f, g);
          m = true;
          l = b - b % 32;
        }
        if (q.l == l) {
          d += WorksheetRowCollection_RowsLoadOnDemandTree._az(b, q, e, f, g);
          return {
            p2: c,
            p3: d
          };
        }
        else if (q.l < l) {
          d += q.q(e, f, g);
        }
      }
      else if (q.l < l) {
        let r = q.q(e, f, g);
        c += m ? 0 : r;
        d += r;
      }
      n = q.l + 32;
    }
    if (m == false) {
      c += (a - n) * k;
    }
    d += (b - n) * k;
    return {
      p2: c,
      p3: d
    };
  }
  static _az(a, b, c, d, e) {
    let f = a - b.l;
    if (f == 0) {
      return 0;
    }
    if (f == 32) {
      return b.q(c, d, e);
    }
    return b.o(f, c, d, e);
  }
  _a8(a, b, c, d, e, f, g, h) {
    c = 0;
    d = 0;
    let i = a;
    let j = b;
    let k = null;
    let l = null;
    let m = 0;
    let n = 0;
    let o = 0;
    let p = 0;
    let q = this._ac;
    let r = q != null ? q.count : 0;
    for (let s = 0; s < r; s++) {
      let t = typeCast(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint.$, q._inner[s]);
      let u = t.ae(f, g, h);
      if (u > a && u > b) {
        break;
      }
      let v = t.aa(f, g, h);
      if (k == null && u <= a) {
        if (t.e) {
          if (u + v > a) {
            k = t;
            m = (a - u);
          }
          else {
            i = Math.max(i - v, 0);
            o += t.k;
          }
        }
        else {
          i += v;
          o -= t.k;
        }
      }
      if (l == null && u <= b) {
        if (t.e) {
          if (u + v > b) {
            l = t;
            n = (b - u);
          }
          else {
            j = Math.max(j - v, 0);
            p += t.k;
          }
        }
        else {
          j += v;
          p -= t.k;
        }
      }
    }
    let w = true;
    if (k != null) {
      if (l != null) {
        w = false;
      }
      else {
        i = j;
      }
    }
    else {
      if (l != null) {
        j = i;
      }
    }
    if (w) {
      let x = this._a9(i, j, c, d, e, f, g, h);
      i = x.p0;
      j = x.p1;
      c = x.p2;
      d = x.p3;
      a = i;
      b = j;
    }
    if (k != null) {
      c = k.n + ((() => { let y = k.y(m, f, g, h); m = y.p0; return y.ret; })());
      a = m;
    }
    else {
      c += o;
    }
    if (l != null) {
      d = l.n + ((() => { let y = l.y(n, f, g, h); n = y.p0; return y.ret; })());
      b = n;
    }
    else {
      d += p;
    }
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  _a9(a, b, c, d, e, f, g, h) {
    let i = g * 32;
    let j = false;
    let k = 0;
    for (let l of fromEnum(this._y())) {
      let m = l;
      let n = intDivide((m.l - k), 32);
      let o = n * i;
      if (((() => { let p = this._aw(null, o, n, a, b, c, d, j, f, g, h); a = p.p3; b = p.p4; c = p.p5; d = p.p6; j = p.p7; return p.ret; })())) {
        return {
          p0: a,
          p1: b,
          p2: c,
          p3: d
        };
      }
      let p = m.q(f, g, h);
      if (((() => { let q = this._aw(m, p, 1, a, b, c, d, j, f, g, h); a = q.p3; b = q.p4; c = q.p5; d = q.p6; j = q.p7; return q.ret; })())) {
        return {
          p0: a,
          p1: b,
          p2: c,
          p3: d
        };
      }
      k = m.l + 32;
    }
    if (g == 0) {
      if (j == false) {
        c = e;
      }
      d = e;
      return {
        p0: a,
        p1: b,
        p2: c,
        p3: d
      };
    }
    if (j == false) {
      let q = this._a3(c, a, g);
      c = q.p0;
      a = q.p1;
    }
    let r = this._a3(d, b, g);
    d = r.p0;
    b = r.p1;
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  _a7(a, b, c, d, e) {
    let f = this._at.defaultRowHeight;
    let g = f;
    if (e == false && this._at._dv) {
      g = 0;
    }
    let h = a;
    let i = b;
    let j = this._a8(a, b, c, d, Workbook.getMaxRowCount(this._at._o) - 1, f, g, e);
    a = j.p0;
    b = j.p1;
    c = j.p2;
    d = j.p3;
    if (c < 0 || c >= this._al || d < 0 || d >= this._al) {
      this._an();
      a = h;
      b = i;
      let k = this._a8(a, b, c, d, Workbook.getMaxRowCount(this._at._o) - 1, f, g, e);
      a = k.p0;
      b = k.p1;
      c = k.p2;
      d = k.p3;
    }
    return {
      p0: a,
      p1: b,
      p2: c,
      p3: d
    };
  }
  static _a0(a, b, c, d, e) {
    let f = a.b;
    for (let g = 0; g < 32; g++) {
      let h = f[g];
      let i;
      if (h == null || h._m) {
        i = d;
      }
      else {
        if (e == false && h.hidden) {
          continue;
        }
        i = a.p(h, g);
      }
      if (i < 0) {
        b -= c;
      }
      else if (b < i) {
        return {
          ret: g,
          p1: b
        };
      }
      else {
        b -= i;
      }
    }
    return {
      ret: 32 - 1,
      p1: b
    };
  }
  _ba() {
    this._ay++;
  }
  _aw(a, b, c, d, e, f, g, h, i, j, k) {
    if (h == false && ((() => { let l = this._ax(a, b, c, d, f, i, j, k); d = l.p3; f = l.p4; return l.ret; })())) {
      h = true;
    }
    if (((() => { let l = this._ax(a, b, c, e, g, i, j, k); e = l.p3; g = l.p4; return l.ret; })())) {
      return {
        ret: true,
        p3: d,
        p4: e,
        p5: f,
        p6: g,
        p7: h
      };
    }
    return {
      ret: false,
      p3: d,
      p4: e,
      p5: f,
      p6: g,
      p7: h
    };
  }
  _ax(a, b, c, d, e, f, g, h) {
    if (d < b) {
      if (a == null) {
        let i = this._a3(e, d, g);
        e = i.p0;
        d = i.p1;
      }
      else {
        e += ((() => { let j = WorksheetRowCollection_RowsLoadOnDemandTree._a0(a, d, f, g, h); d = j.p1; return j.ret; })());
      }
      return {
        ret: true,
        p3: d,
        p4: e
      };
    }
    else {
      let j = c * 32;
      if (e + j == this._al) {
        let k = d - (b - 1);
        d = b - 1;
        if (a == null) {
          let l = this._a3(e, d, g);
          e = l.p0;
          d = l.p1;
        }
        else {
          e += ((() => { let m = WorksheetRowCollection_RowsLoadOnDemandTree._a0(a, d, f, g, h); d = m.p1; return m.ret; })());
        }
        d += k;
      }
      else {
        d -= b;
        e += j;
      }
    }
    return {
      ret: false,
      p3: d,
      p4: e
    };
  }
}
WorksheetRowCollection_RowsLoadOnDemandTree.$t = markType(WorksheetRowCollection_RowsLoadOnDemandTree, 'WorksheetRowCollection_RowsLoadOnDemandTree', RowColumnLoadOnDemandTree$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
export class WorksheetRowCollection_RowBinaryTreeNode extends RowColumnBinaryTreeNode$1 {
  constructor(a, b, c) {
    super(WorksheetRow.$, a, b, c);
  }
  p(a, b) {
    return a._ct(true);
  }
}
WorksheetRowCollection_RowBinaryTreeNode.$t = markType(WorksheetRowCollection_RowBinaryTreeNode, 'WorksheetRowCollection_RowBinaryTreeNode', RowColumnBinaryTreeNode$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
export class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint extends LoadOnDemandTree_ChangeAdjustmentPoint$1 {
  constructor(a, b, c, d) {
    super(WorksheetRow.$, a, b, c, d);
    this.ac = -1;
    this.ad = -1;
    this.w = -1;
    this.x = -1;
    this.v = 0;
  }
  t() {
    this.v--;
  }
  ae(a, b, c) {
    this.ag();
    let d = c ? this.ad : this.ac;
    if (d < 0) {
      d = this.af(a, b, c);
      if (c) {
        this.ad = d;
      }
      else {
        this.ac = d;
      }
    }
    return d;
  }
  y(a, b, c, d) {
    for (let e = 0; e < this.k; e++) {
      let f = this.z(e, b, c, d);
      if (f > a) {
        return {
          ret: e,
          p0: a
        };
      }
      a -= f;
    }
    return {
      ret: this.k - 1,
      p0: a
    };
  }
  z(a, b, c, d) {
    return this.c.d(a + this.o, b, c, d);
  }
  aa(a, b, c) {
    this.ag();
    let d = c ? this.x : this.w;
    if (d < 0) {
      d = this.ab(a, b, c);
      if (c) {
        this.x = d;
      }
      else {
        this.w = d;
      }
    }
    return d;
  }
  af(a, b, c) {
    let d = this.n;
    if (d == 0) {
      return 0;
    }
    let e = d;
    let f = d;
    if (!this.e) {
      e--;
    }
    let g;
    let h;
    let i = this.a._a4(e, f, g, h, a, b, c);
    g = i.p2;
    h = i.p3;
    return h;
  }
  ab(a, b, c) {
    if (!this.e) {
      return b * this.k;
    }
    let d = this.c;
    if (this.k == d.c) {
      return d.e(a, b, c);
    }
    let e = 0;
    for (let f = 0; f < this.k; f++) {
      e += this.z(f, a, b, c);
    }
    return e;
  }
  ag() {
    if (this.v != this.a._a1) {
      this.v = this.a._a1;
      this.ac = -1;
      this.ad = -1;
      this.w = -1;
      this.x = -1;
      let a = typeCast(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd.$, this.c);
      if (a != null) {
        a.n();
      }
    }
  }
}
WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint.$t = markType(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint, 'WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint', LoadOnDemandTree_ChangeAdjustmentPoint$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
export class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd extends LoadOnDemandTree_ChangeHistoryItemAdd$1 {
  constructor(a, b) {
    super(WorksheetRow.$, a, b);
    this.k = -1;
    this.l = -1;
  }
  d(a, b, c, d) {
    if (!this.j) {
      return c;
    }
    let e = typeCast(WorksheetRow.$, this.i[a]);
    if (e == null || e._m) {
      return c;
    }
    if (false == d && e._l) {
      return 0;
    }
    let f = e._ct(d);
    if (f < 0) {
      return b;
    }
    return f;
  }
  e(a, b, c) {
    if (c) {
      if (this.l < 0) {
        this.l = this.m(this.b, a, b, true);
      }
      return this.l;
    }
    if (this.k < 0) {
      this.k = this.m(this.b, a, b, false);
    }
    return this.k;
  }
  m(a, b, c, d) {
    if (!this.j) {
      return c * a;
    }
    let e = 0;
    for (let f = 0; f < a; f++) {
      let g = typeCast(WorksheetRow.$, this.i[f]);
      if (g == null) {
        e += c;
        continue;
      }
      if (d == false && g.hidden) {
        continue;
      }
      let h = this.d(f, b, c, d);
      if (h < 0) {
        e += b;
      }
      else {
        e += h;
      }
    }
    return e;
  }
  n() {
    this.k = -1;
    this.l = -1;
  }
}
WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd.$t = markType(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd, 'WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd', LoadOnDemandTree_ChangeHistoryItemAdd$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
export class WorksheetPaneSelection extends Base {
  constructor() {
    super();
    this.e = null;
    this.b = new WorksheetCellAddress();
    this.f = 0;
    this.a = 0;
    this.e = new List$1(WorksheetRegionAddress.$, 0);
  }
  get d() {
    return this.e;
  }
  static c(a = 3) {
    let b = new WorksheetPaneSelection();
    b.b = new WorksheetCellAddress(1, 0, 0);
    b.a = a;
    b.d.add(new WorksheetRegionAddress(1, 0, 0, 0, 0));
    return b;
  }
  g(a) {
    this.a = a.a;
    this.b = a.b;
    this.f = a.f;
    this.d.clear();
    this.e.o(a.d);
  }
}
WorksheetPaneSelection.$t = markType(WorksheetPaneSelection, 'WorksheetPaneSelection');
/**
 * Represents the window options which are saved with the workbook.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a workbook, but
 * not with a custom view.
 * </p>
 * @see [[Workbook.windowOptions]]
 * @see [[CustomViewWindowOptions]]
 */
export class WorkbookWindowOptions extends WindowOptions {
  constructor(a) {
    super(a);
    this._at = new Rect(0, 1000, 1000, 15000, 10000);
    this._am = 0;
    this._aj = false;
    this._ar = 0;
  }
  /**
   * @hidden
   */
  get__o() {
    return this._workbook._sheets$i.count == 0;
  }
  /**
   * @hidden
   */
  get _o() {
    return this.get__o();
  }
  /**
   * @hidden
   */
  _d(a) {
    return a._e;
  }
  /**
   * Resets the window options to their default settings.
   * <p class="body">
   * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
   * </p>
   */
  reset() {
    this._at = new Rect(0, 1000, 1000, 15000, 10000);
    this._am = 0;
    this._aj = false;
    this._ar = 0;
    super.reset();
  }
  /**
   * @hidden
   */
  _ad() {
    for (let a of fromEnum(this._workbook._sheets$i)) {
      a._w = a == this.selectedSheet;
    }
  }
  /**
   * @hidden
   */
  static _ai($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(WorkbookWindowOptions.$, $tValue, a, 86, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _ah() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, WorkbookWindowOptions._ai(Rect.$, "BoundsInTwips", (b) => b._boundsInTwips$i, (b, c) => b._boundsInTwips$i = c));
    ChangeInfo.f(a, 1, WorkbookWindowOptions._ai(Number_$type, "FirstVisibleTabIndex", (b) => b.firstVisibleTabIndex, (b, c) => b.firstVisibleTabIndex = c));
    ChangeInfo.f(a, 2, WorkbookWindowOptions._ai(Boolean_$type, "Minimized", (b) => b.minimized, (b, c) => b.minimized = c));
    return a;
  }
  /**
   * Gets or sets the bounds of the workbook's MDI child window in twips (1/20th of a point).
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The bounds of the workbook's MDI child window in twips (1/20th of a point).
   * @throws [[ArgumentException]] The width or height of the value assigned are less than zero.
   */
  get boundsInTwips() {
    return rectToLiteral(this._boundsInTwips$i);
  }
  /**
   * Gets or sets the bounds of the workbook's MDI child window in twips (1/20th of a point).
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The bounds of the workbook's MDI child window in twips (1/20th of a point).
   * @throws [[ArgumentException]] The width or height of the value assigned are less than zero.
   */
  set boundsInTwips(a) {
    arguments[0] = rectFromLiteral(arguments[0]);
    this._boundsInTwips$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _boundsInTwips$i() {
    return this._at;
  }
  /**
   * @hidden
   */
  set _boundsInTwips$i(a) {
    if (Rect.l_op_Inequality(this._at, a)) {
      if (a.width < 0 || a.height < 0) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_WidthHeightWindowBounds"), "value");
      }
      let b = WorkbookWindowOptions._ag[0].g(WorkbookWindowOptions.$, Rect.$, this, this._at, a);
      this._at = b.p1;
    }
  }
  /**
   * Gets or sets the index of the first visible tab in the worksheet tab bar.
   * <p class="body">
   * If the worksheet tab bar is not visible, this value will not be used, but it is still saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The index of the first visible tab in the worksheet tab bar.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than zero.
   * @see [[WindowOptions.tabBarVisible]]
   * @see [[WindowOptions.tabBarWidth]]
   */
  get firstVisibleTabIndex() {
    return this._am;
  }
  /**
   * Gets or sets the index of the first visible tab in the worksheet tab bar.
   * <p class="body">
   * If the worksheet tab bar is not visible, this value will not be used, but it is still saved with the workbook.
   * </p>
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The index of the first visible tab in the worksheet tab bar.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than zero.
   * @see [[WindowOptions.tabBarVisible]]
   * @see [[WindowOptions.tabBarWidth]]
   */
  set firstVisibleTabIndex(a) {
    if (this._am != a) {
      if (a < 0) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_FirstVisibleTabIndex"));
      }
      let b = WorkbookWindowOptions._ag[1].g(WorkbookWindowOptions.$, Number_$type, this, this._am, a);
      this._am = b.p1;
    }
  }
  /**
   * Gets or sets the value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
   * @see [[CustomViewWindowOptions.maximized]]
   */
  get minimized() {
    return this._aj;
  }
  /**
   * Gets or sets the value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
   * <p class="note">
   * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
   * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
   * a newly created CustomView will not be initialized with the setting from this property.
   * </p>
   * The value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
   * @see [[CustomViewWindowOptions.maximized]]
   */
  set minimized(a) {
    if (a != this._aj) {
      let b = WorkbookWindowOptions._ag[2].g(WorkbookWindowOptions.$, Boolean_$type, this, this._aj, a);
      this._aj = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _as() {
    return this._ar;
  }
  /**
   * @hidden
   */
  set _as(a) {
    this._ar = a;
  }
}
WorkbookWindowOptions.$t = markType(WorkbookWindowOptions, 'WorkbookWindowOptions', WindowOptions.$);
/**
 * @hidden
 */
WorkbookWindowOptions._al = 0;
/**
 * @hidden
 */
WorkbookWindowOptions._ao = 1;
/**
 * @hidden
 */
WorkbookWindowOptions._ap = 2;
/**
 * @hidden
 */
WorkbookWindowOptions._aq = 3;
/**
 * @hidden
 */
WorkbookWindowOptions._ag = WorkbookWindowOptions._ah();
/**
 * @hidden
 */
export class WorksheetSelection extends Base {
  constructor() {
    super();
    this.c = null;
    this.c = new List$1(WorksheetPaneSelection.$, 0);
  }
  get b() {
    return this.c;
  }
  a(a) {
    let b = this.d(a);
    return b < 0 ? null : this.c._inner[b];
  }
  d(a) {
    for (let b = 0; b < this.b.count; b++) {
      if (this.c._inner[b].a == a) {
        return b;
      }
    }
    return -1;
  }
  e(a) {
    for (let b of fromEnum(a.b)) {
      let c = this.d(b.a);
      let d;
      if (c >= 0) {
        d = this.b.item(c);
      }
      else {
        d = new WorksheetPaneSelection();
        this.b.add(d);
      }
      d.g(b);
    }
  }
}
WorksheetSelection.$t = markType(WorksheetSelection, 'WorksheetSelection');
/**
 * A collection of workbook styles, or complex formats which can be easily applied to cells in Microsoft Excel.
 * @see [[WorkbookStyle]]
 */
export class WorkbookStyleCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._q = null;
    this._b = null;
    this._y = null;
    this._r = null;
    this._s = null;
    this._c = null;
    this._v = null;
    this._a = new Array(8);
    this._b = new Array(8);
    this._y = new List$1(WorkbookStyle.$, 0);
    this._r = new Dictionary$2(String_$type, WorkbookStyle.$, 2, ExcelUtils.em(a._e6, true));
    this._s = new Dictionary$2(BuiltInStyleType_$type, WorkbookStyle.$, 0);
    this._c = a;
    let b = WorkbookStyleCollection._x;
    for (let c = 0; c < b.count; c++) {
      this._add(b._inner[c]._ad(this._c));
    }
    this._aa();
  }
  static staticInit() {
    WorkbookStyleCollection._n = DefaultStyleHelper.b;
  }
  /**
   * @hidden
   */
  add(item) {
    throw new InvalidOperationException(1, "Styles cannot be added directly to the collection.");
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._y.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._y.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  addUserDefinedStyle() {
    let n;
    if (arguments.length === 1) {
      n = 1;
    }
    else if (arguments.length === 2) {
      n = 0;
    }
    switch (n) {
      case 0: return this._addUserDefinedStyle.apply(this, arguments);
      case 1: return this._addUserDefinedStyle1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _addUserDefinedStyle1(a) {
    return this._addUserDefinedStyle(this._c._cd(1), a);
  }
  /**
   * @hidden
   */
  _addUserDefinedStyle(a, b) {
    this._ah(b, "name");
    let c;
    let d = new BuiltInStyleInfo();
    if (((() => { let e = WorkbookStyleCollection._t.tryGetValue(b, d); d = e.p1; return e.ret; })())) {
      c = new WorkbookBuiltInStyle(this._c, a, d.a, d.b);
    }
    else {
      c = new WorkbookUserDefinedStyle(this._c, a, b);
    }
    this._add(c);
    return c;
  }
  /**
   * Clears all styles, other than the Normal style, from the collection.
   * @see [[normalStyle]]
   */
  clear() {
    this._ag(0);
  }
  /**
   * Determines whether a style is in the collection.
   * @param style The style to locate in the collection.
   * @return True if the style is found; False otherwise.
   */
  contains(style) {
    let a;
    if (((() => { let b = this._r.tryGetValue(style.name, a); a = b.p1; return b.ret; })())) {
      return style == a;
    }
    return false;
  }
  /**
   * Removes the specified style from the collection.
   * @param style The style to remove from the collection.
   * @throws [[InvalidOperationException]] 'style' is the Normal style.
   * @return True if the style was successfully removed; False if the style was not
   * in the collection.
   * @see [[normalStyle]]
   */
  remove(style) {
    if (style == null) {
      return false;
    }
    let a = this._y.indexOf(style);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the style at the specified index from the collection.
   * @param index The zero-based index of the style in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   * @throws [[InvalidOperationException]] The style to remove at 'index' is the Normal style.
   * @see [[normalStyle]]
   */
  removeAt(index) {
    this._ae(index, 0);
  }
  /**
   * @hidden
   */
  _ae(a, b) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    let c = this._y._inner[a];
    let d = typeCast(WorkbookBuiltInStyle.$, c);
    if (d != null) {
      if (d._n) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotRemoveNormalStyle"));
      }
    }
    c._z();
    this._y.removeAt(a);
    this._r.removeItem(c.name);
    if (c.isBuiltIn || c._m == false) {
      this._r.removeItem(c.name);
    }
    else if (this._v != null) {
      this._v.remove(c);
    }
    if (d != null) {
      d._m = true;
      switch (d._ac) {
        case 2:
          this._a[d._ak] = null;
          break;
        case 1:
          this._b[d._ak] = null;
          break;
        default:
          this._s.removeItem(d._ac);
          if (b == 0) {
            if (this._q == null) {
              this._q = new Dictionary$2(BuiltInStyleType_$type, WorkbookBuiltInStyle.$, 0);
            }
            this._q.addItem(d._ac, d);
          }
          break;
      }
    }
    this._c._h8(c);
  }
  /**
   * Resets the collection to its original state by clearing all styles and adding in preset built in styles.
   */
  reset() {
    this._ag(2);
    if (this._q != null) {
      let a = this._q.values;
      this._q = null;
      for (let b of fromEnum(a)) {
        b.reset();
        this._add(b);
      }
    }
    if (this._v != null) {
      let c = this._v;
      this._v = null;
      for (let d of fromEnum(c)) {
        d.reset();
        this._add(d);
      }
    }
    let e = WorkbookStyleCollection._x;
    for (let f = 0; f < e.count; f++) {
      let g = e._inner[f];
      if (this._o(g._ac)) {
        continue;
      }
      this._add(g._ad(this._c));
    }
  }
  /**
   * @hidden
   */
  _ag(a) {
    for (let b = this._y.count - 1; b >= 0; b--) {
      let c = this._y._inner[b];
      if (c.isBuiltIn) {
        if (a == 2 || c._n) {
          c.reset();
          continue;
        }
      }
      this._ae(b, a);
    }
  }
  /**
   * @hidden
   */
  _add(a) {
    if (a.isBuiltIn || a._m == false) {
      let b = this._item1(a.name);
      if (b != null) {
        if (b.isBuiltIn) {
          b._m = false;
          b._i.setFormatting(a._i);
          b._i._dt(a._i.formatOptions);
          return b;
        }
        this.remove(b);
      }
    }
    this._y.add(a);
    a._v();
    if (a.isBuiltIn || a._m == false) {
      this._r.item(a.name, a);
    }
    else {
      if (this._v == null) {
        this._v = new List$1(WorkbookUserDefinedStyle.$, 0);
      }
      this._v.add(a);
    }
    let c = typeCast(WorkbookBuiltInStyle.$, a);
    if (c != null) {
      switch (c._ac) {
        case 2:
          this._a[c._ak] = c;
          break;
        case 1:
          this._b[c._ak] = c;
          break;
        default:
          this._s.item(c._ac, c);
          break;
      }
      if (this._q != null) {
        this._q.removeItem(c._ac);
      }
    }
    return a;
  }
  /**
   * @hidden
   */
  _e(a) {
    let b = this._item1(a.name);
    if (b != null) {
      b._i.setFormatting(a._i);
      b._i.formatOptions = a._i.formatOptions;
      b._m = true;
      this.remove(b);
      return b;
    }
    if (a._ai) {
      return a;
    }
    if (this._q == null) {
      this._q = new Dictionary$2(BuiltInStyleType_$type, WorkbookBuiltInStyle.$, 0);
    }
    let c;
    if (((() => { let d = this._q.tryGetValue(a._ac, c); c = d.p1; return d.ret; })())) {
      c._i.setFormatting(a._i);
      c._i.formatOptions = a._i.formatOptions;
      return c;
    }
    this._q.addItem(a._ac, a);
    return a;
  }
  /**
   * @hidden
   */
  _f(a, b) {
    let c = new WorkbookUserDefinedStyle(this._c, a, b);
    c._m = true;
    return this._add(c);
  }
  /**
   * @hidden
   */
  _o(a) {
    for (let b of fromEnum(this._y)) {
      let c = typeCast(WorkbookBuiltInStyle.$, b);
      if (c != null && c._ac == a) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _i(a) {
    let b;
    let c = this._s.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * @hidden
   */
  _j(a, b) {
    switch (a) {
      case 2: return this._a[b];
      case 1: return this._b[b];
      default: return this._i(a);
    }
  }
  /**
   * @hidden
   */
  *__u() {
    if (this._q != null) {
      for (let a of fromEnum(this._q.values)) {
        yield a;
      }
    }
  }
  _u() {
    return toEnum(() => this.__u());
  }
  /**
   * @hidden
   */
  _ac(a, b) {
    this._r.removeItem(b);
    this._r.addItem(a.name, a);
  }
  /**
   * @hidden
   */
  _ah(a, b) {
    if (stringIsNullOrEmpty(a)) {
      throw new ArgumentNullException(2, b, ExcelUtils.ef("LE_ArgumentNullException_StyleName"));
    }
    if (255 < a.length) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_StyleNameTooLong"), b);
    }
    if (this._r.containsKey(a)) {
      throw new ArgumentException(2, ExcelUtils.eg("LE_ArgumentException_StyleNameAlreadyExists", a), b);
    }
  }
  /**
   * @hidden
   */
  _aa() {
    if (this._o(0) == false) {
      this._add(new WorkbookBuiltInStyle(this._c, new WorksheetCellFormatData(this._c, 1), 0, 0));
    }
  }
  /**
   * @hidden
   */
  static _ab() {
    WorkbookStyleCollection._w = new List$1(WorkbookBuiltInStyle.$, 0);
    WorkbookStyleCollection._n(WorkbookStyleCollection._w);
    WorkbookStyleCollection._w.y();
    WorkbookStyleCollection._p = null;
  }
  /**
   * Gets the number of styles in the collection.
   * The number of styles in the collection.
   */
  get count() {
    return this._y.count;
  }
  item() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 0;
      }
      else if (typeof arguments[0] === 'string') {
        n = 1;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._item.apply(this, arguments);
      case 1: return this._item1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _item(a) {
    return this._y._inner[a];
  }
  /**
   * @hidden
   */
  _item1(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "name");
    }
    let b;
    let c = this._r.tryGetValue(a, b);
    b = c.p1;
    return b;
  }
  /**
   * Gets the default style for the workbook.
   * <p class="body">
   * The normal style is the parent style for all cell and differential formats in the workbook, unless another parent style is specified.
   * </p>
   * @see [[IWorksheetCellFormat.style]]
   */
  get normalStyle() {
    return this._i(0);
  }
  /**
   * @hidden
   */
  static get _x() {
    if (WorkbookStyleCollection._w == null) {
      if (WorkbookStyleCollection._w == null) {
        WorkbookStyleCollection._ab();
      }
    }
    return WorkbookStyleCollection._w;
  }
  /**
   * @hidden
   */
  static get _t() {
    if (WorkbookStyleCollection._p == null) {
      if (WorkbookStyleCollection._p == null) {
        let a = new Dictionary$2(String_$type, BuiltInStyleInfo.$, 2, StringComparer.c);
        let b = WorkbookStyleCollection._x;
        for (let c = 0; c < b.count; c++) {
          let d = b._inner[c];
          a.item(d.name, new BuiltInStyleInfo(1, d._ac, d._ak));
        }
        WorkbookStyleCollection._p = a;
      }
    }
    return WorkbookStyleCollection._p;
  }
}
WorkbookStyleCollection.$t = markType(WorkbookStyleCollection, 'WorkbookStyleCollection', Base.$, [ICollection$1_$type.specialize(WorkbookStyle.$)]);
/**
 * @hidden
 */
WorkbookStyleCollection._z = {};
/**
 * @hidden
 */
WorkbookStyleCollection._w = null;
/**
 * @hidden
 */
WorkbookStyleCollection._p = null;
/**
 * @hidden
 */
WorkbookStyleCollection._n = null;
/**
 * @hidden
 */
export class WorkbookStyleCollection_RefEqualityComparer$1 extends Base {
  constructor($t) {
    super();
    this.$t = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
  }
  equalsC(a, b) {
    return Base.referenceEquals(a, b);
  }
  getHashCodeC(a) {
    return Base.getHashCodeStatic(a);
  }
}
WorkbookStyleCollection_RefEqualityComparer$1.$t = markType(WorkbookStyleCollection_RefEqualityComparer$1, 'WorkbookStyleCollection_RefEqualityComparer$1', Base.$, [IEqualityComparer$1_$type.specialize(0)]);
/**
 * @hidden
 */
export class Worksheet_SetColumnWidthInfo extends Base {
  constructor(a, b, c) {
    super();
    this.c = 0;
    this.a = 0;
    this.b = false;
    this.c = a;
    this.a = b;
    this.b = c;
  }
}
Worksheet_SetColumnWidthInfo.$t = markType(Worksheet_SetColumnWidthInfo, 'Worksheet_SetColumnWidthInfo');
/**
 * @hidden
 */
export class Worksheet_ShiftRegionHelper extends Base {
  constructor(a) {
    super();
    this.a = new CellShiftOperation();
    this.a = a;
  }
  b(a, b) {
    let c = a._d(this.a, true);
    b = c.f;
    return {
      p1: b
    };
  }
}
Worksheet_ShiftRegionHelper.$t = markType(Worksheet_ShiftRegionHelper, 'Worksheet_ShiftRegionHelper');
/**
 * @hidden
 */
export class Worksheet_InsertRemoveOperationWrapper extends Base {
  constructor(a, b, c, d) {
    super();
    this.a = null;
    this.b = new Worksheet_CellInsertDeleteChangeContext();
    this.e = null;
    this.c = false;
    this.d = false;
    this.c = c;
    this.d = d;
    this.a = a;
    this.b = b;
    this.e = null;
  }
  get f() {
    return this.e;
  }
  get count() {
    return 0;
  }
  get index() {
    return -1;
  }
  get shiftsColumns() {
    return false;
  }
  get shiftsRows() {
    return false;
  }
  get isRemoveOperation() {
    return !this.c;
  }
  get isUndoOperation() {
    return this.d;
  }
  get performsShift() {
    return false;
  }
  get worksheet() {
    return this.b.sheet;
  }
  onBeforeShift(a) {
    this.e = this.a.b(this.b.workbook, this.b.sheet, null);
  }
  performShift(a) {
    return false;
  }
}
Worksheet_InsertRemoveOperationWrapper.$t = markType(Worksheet_InsertRemoveOperationWrapper, 'Worksheet_InsertRemoveOperationWrapper', Base.$, [ICellShiftOperationOverride_$type]);
/**
 * @hidden
 */
export class WorksheetCellShiftResult extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.b = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
}
WorksheetCellShiftResult.$t = markStruct(WorksheetCellShiftResult, 'WorksheetCellShiftResult');
/**
 * @hidden
 */
export class WorksheetDummyCellFormatProxy extends WorksheetCellFormatProxy {
  constructor(a) {
    super(0, a, null, null);
  }
  get__l() {
    return null;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 4;
  }
  get _q() {
    return this.get__q();
  }
  get__v() {
    return null;
  }
  get _v() {
    return this.get__v();
  }
}
WorksheetDummyCellFormatProxy.$t = markType(WorksheetDummyCellFormatProxy, 'WorksheetDummyCellFormatProxy', WorksheetCellFormatProxy.$);
/**
 * @hidden
 */
export class MutableItemRange extends Base {
  constructor(a, b) {
    super();
    this.a = 0;
    this.b = 0;
    this.a = a;
    this.b = b;
  }
}
MutableItemRange.$t = markType(MutableItemRange, 'MutableItemRange');
/**
 * @hidden
 */
export class WorksheetCellBlock_DataTypesCompressed extends ValueType {
  constructor() {
    super();
    this.b = 0;
    this.c = 0;
    this.d = 0;
  }
  a(a) {
    switch (a) {
      case 0: return ((this.b & 224) >> 5);
      case 1: return ((this.b & 28) >> 2);
      case 2: return (((this.b & 3) << 1) | ((this.c & 128) >> 7));
      case 3: return ((this.c & 112) >> 4);
      case 4: return ((this.c & 14) >> 1);
      case 5: return (((this.c & 1) << 2) | ((this.d & 192) >> 6));
      case 6: return ((this.d & 56) >> 3);
      case 7: return (this.d & 7);
      default: return 0;
    }
  }
  e(a, b) {
    let c = b;
    switch (a) {
      case 0:
        this.b = ((c << 5) | (this.b & 31));
        break;
      case 1:
        this.b = ((c << 2) | (this.b & 227));
        break;
      case 2:
        this.b = ((c >>> 1) | (this.b & 252));
        this.c = (((c << 7) & 128) | (this.c & 127));
        break;
      case 3:
        this.c = ((c << 4) | (this.c & 143));
        break;
      case 4:
        this.c = ((c << 1) | (this.c & 241));
        break;
      case 5:
        this.c = ((c >>> 2) | (this.c & 254));
        this.d = (((c << 6) & 192) | (this.d & 63));
        break;
      case 6:
        this.d = ((c << 3) | (this.d & 199));
        break;
      case 7:
        this.d = (c | (this.d & 248));
        break;
      default: break;
    }
  }
}
WorksheetCellBlock_DataTypesCompressed.$t = markStruct(WorksheetCellBlock_DataTypesCompressed, 'WorksheetCellBlock_DataTypesCompressed');
/**
 * @hidden
 */
export class WorksheetCellBlockFull extends WorksheetCellBlock {
  constructor(a) {
    super(a);
    this.bx = new WorksheetCellBlock_DataTypesCompressed();
    this.by = new WorksheetCellBlock_DataTypesCompressed();
    this.bz = new WorksheetCellBlock_DataTypesCompressed();
    this.b0 = new WorksheetCellBlock_DataTypesCompressed();
    this.b1 = 0;
    this.a1 = new WorksheetCellBlock_CellValue();
    this.a2 = new WorksheetCellBlock_CellValue();
    this.a3 = new WorksheetCellBlock_CellValue();
    this.a4 = new WorksheetCellBlock_CellValue();
    this.a5 = new WorksheetCellBlock_CellValue();
    this.a6 = new WorksheetCellBlock_CellValue();
    this.a7 = new WorksheetCellBlock_CellValue();
    this.a8 = new WorksheetCellBlock_CellValue();
    this.a9 = new WorksheetCellBlock_CellValue();
    this.ba = new WorksheetCellBlock_CellValue();
    this.bb = new WorksheetCellBlock_CellValue();
    this.bc = new WorksheetCellBlock_CellValue();
    this.bd = new WorksheetCellBlock_CellValue();
    this.be = new WorksheetCellBlock_CellValue();
    this.bf = new WorksheetCellBlock_CellValue();
    this.bg = new WorksheetCellBlock_CellValue();
    this.bh = new WorksheetCellBlock_CellValue();
    this.bi = new WorksheetCellBlock_CellValue();
    this.bj = new WorksheetCellBlock_CellValue();
    this.bk = new WorksheetCellBlock_CellValue();
    this.bl = new WorksheetCellBlock_CellValue();
    this.bm = new WorksheetCellBlock_CellValue();
    this.bn = new WorksheetCellBlock_CellValue();
    this.bo = new WorksheetCellBlock_CellValue();
    this.bp = new WorksheetCellBlock_CellValue();
    this.bq = new WorksheetCellBlock_CellValue();
    this.br = new WorksheetCellBlock_CellValue();
    this.bs = new WorksheetCellBlock_CellValue();
    this.bt = new WorksheetCellBlock_CellValue();
    this.bu = new WorksheetCellBlock_CellValue();
    this.bv = new WorksheetCellBlock_CellValue();
    this.bw = new WorksheetCellBlock_CellValue();
  }
  h(a) {
    a = null;
    return {
      ret: false,
      p0: a
    };
  }
  al(a, b, c, d) {
    c = this.e(a);
    b = this.f(a);
    d = this.r(a);
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  e(a) {
    switch (a & 31) {
      case 0: return this.a1;
      case 1: return this.a2;
      case 2: return this.a3;
      case 3: return this.a4;
      case 4: return this.a5;
      case 5: return this.a6;
      case 6: return this.a7;
      case 7: return this.a8;
      case 8: return this.a9;
      case 9: return this.ba;
      case 10: return this.bb;
      case 11: return this.bc;
      case 12: return this.bd;
      case 13: return this.be;
      case 14: return this.bf;
      case 15: return this.bg;
      case 16: return this.bh;
      case 17: return this.bi;
      case 18: return this.bj;
      case 19: return this.bk;
      case 20: return this.bl;
      case 21: return this.bm;
      case 22: return this.bn;
      case 23: return this.bo;
      case 24: return this.bp;
      case 25: return this.bq;
      case 26: return this.br;
      case 27: return this.bs;
      case 28: return this.bt;
      case 29: return this.bu;
      case 30: return this.bv;
      case 31: return this.bw;
      default: return new WorksheetCellBlock_CellValue();
    }
  }
  f(a) {
    switch (a & 24) {
      case 0: return this.bx.a(a & 7);
      case 8: return this.by.a(a & 7);
      case 16: return this.bz.a(a & 7);
      case 24: return this.b0.a(a & 7);
      default: return 0;
    }
  }
  am(a, b, c) {
    c = this.e(a);
    b = this.f(a);
    return {
      p1: b,
      p2: c
    };
  }
  r(a) {
    let b = a & 31;
    return ExcelUtils.bu(this.b1, b);
  }
  an(a, b, c) {
    switch (a & 31) {
      case 0:
        this.a1 = b;
        return;
      case 1:
        this.a2 = b;
        return;
      case 2:
        this.a3 = b;
        return;
      case 3:
        this.a4 = b;
        return;
      case 4:
        this.a5 = b;
        return;
      case 5:
        this.a6 = b;
        return;
      case 6:
        this.a7 = b;
        return;
      case 7:
        this.a8 = b;
        return;
      case 8:
        this.a9 = b;
        return;
      case 9:
        this.ba = b;
        return;
      case 10:
        this.bb = b;
        return;
      case 11:
        this.bc = b;
        return;
      case 12:
        this.bd = b;
        return;
      case 13:
        this.be = b;
        return;
      case 14:
        this.bf = b;
        return;
      case 15:
        this.bg = b;
        return;
      case 16:
        this.bh = b;
        return;
      case 17:
        this.bi = b;
        return;
      case 18:
        this.bj = b;
        return;
      case 19:
        this.bk = b;
        return;
      case 20:
        this.bl = b;
        return;
      case 21:
        this.bm = b;
        return;
      case 22:
        this.bn = b;
        return;
      case 23:
        this.bo = b;
        return;
      case 24:
        this.bp = b;
        return;
      case 25:
        this.bq = b;
        return;
      case 26:
        this.br = b;
        return;
      case 27:
        this.bs = b;
        return;
      case 28:
        this.bt = b;
        return;
      case 29:
        this.bu = b;
        return;
      case 30:
        this.bv = b;
        return;
      case 31:
        this.bw = b;
        return;
      default: return;
    }
  }
  aq(a, b) {
    switch (a & 24) {
      case 0:
        this.bx.e(a & 7, b);
        break;
      case 8:
        this.by.e(a & 7, b);
        break;
      case 16:
        this.bz.e(a & 7, b);
        break;
      case 24:
        this.b0.e(a & 7, b);
        break;
      default: return;
    }
  }
  ar(a, b, c) {
    this.an(a, c, b == 0);
    this.aq(a, b);
  }
  at(a, b) {
    let c = a & 31;
    let d = ExcelUtils.f9(this.b1, b, c);
    this.b1 = d.p0;
  }
}
WorksheetCellBlockFull.$t = markType(WorksheetCellBlockFull, 'WorksheetCellBlockFull', WorksheetCellBlock.$);
/**
 * @hidden
 */
export class WorksheetCellBlockHalf extends WorksheetCellBlock {
  constructor(a) {
    super(a);
    this.bq = 0;
    this.br = 0;
    this.bs = 0;
    this.bt = 0;
    this.bu = 0;
    this.bv = 0;
    this.bj = new WorksheetCellBlock_DataTypesCompressed();
    this.bk = new WorksheetCellBlock_DataTypesCompressed();
    this.bw = 0;
    this.by = 0;
    this.bx = 0;
    this.a2 = new WorksheetCellBlock_CellValue();
    this.a3 = new WorksheetCellBlock_CellValue();
    this.a4 = new WorksheetCellBlock_CellValue();
    this.a5 = new WorksheetCellBlock_CellValue();
    this.a6 = new WorksheetCellBlock_CellValue();
    this.a7 = new WorksheetCellBlock_CellValue();
    this.a8 = new WorksheetCellBlock_CellValue();
    this.a9 = new WorksheetCellBlock_CellValue();
    this.ba = new WorksheetCellBlock_CellValue();
    this.bb = new WorksheetCellBlock_CellValue();
    this.bc = new WorksheetCellBlock_CellValue();
    this.bd = new WorksheetCellBlock_CellValue();
    this.be = new WorksheetCellBlock_CellValue();
    this.bf = new WorksheetCellBlock_CellValue();
    this.bg = new WorksheetCellBlock_CellValue();
    this.bh = new WorksheetCellBlock_CellValue();
  }
  h(a) {
    if (this.bx != 65535) {
      a = null;
      return {
        ret: false,
        p0: a
      };
    }
    a = new WorksheetCellBlockFull(this.w);
    for (let b = 0; b < 16; b++) {
      let c = this.bm(b);
      let d = this.a1(b);
      let e = this.bi(b);
      let f = this.bl(b);
      a.ar(c, e, d);
      a.at(c, f);
    }
    return {
      ret: true,
      p0: a
    };
  }
  al(a, b, c, d) {
    let e = this.bp(a, false);
    if (e == -1) {
      c = new WorksheetCellBlock_CellValue();
      b = 0;
      d = false;
      return {
        p1: b,
        p2: c,
        p3: d
      };
    }
    c = this.a1(e);
    b = this.bi(e);
    d = ExcelUtils.bt(this.bw, e);
    return {
      p1: b,
      p2: c,
      p3: d
    };
  }
  e(a) {
    let b = this.bp(a, false);
    if (b == -1) {
      return new WorksheetCellBlock_CellValue();
    }
    return this.a1(b);
  }
  a1(a) {
    switch (a) {
      case 0: return this.a2;
      case 1: return this.a3;
      case 2: return this.a4;
      case 3: return this.a5;
      case 4: return this.a6;
      case 5: return this.a7;
      case 6: return this.a8;
      case 7: return this.a9;
      case 8: return this.ba;
      case 9: return this.bb;
      case 10: return this.bc;
      case 11: return this.bd;
      case 12: return this.be;
      case 13: return this.bf;
      case 14: return this.bg;
      case 15: return this.bh;
      default: return new WorksheetCellBlock_CellValue();
    }
  }
  f(a) {
    let b = this.bp(a, false);
    if (b == -1) {
      return 0;
    }
    return this.bi(b);
  }
  bi(a) {
    switch (a & 8) {
      case 0: return this.bj.a(a & 7);
      case 8: return this.bk.a(a & 7);
      default: return 0;
    }
  }
  am(a, b, c) {
    let d = this.bp(a, false);
    if (d == -1) {
      c = new WorksheetCellBlock_CellValue();
      b = 0;
      return {
        p1: b,
        p2: c
      };
    }
    c = this.a1(d);
    b = this.bi(d);
    return {
      p1: b,
      p2: c
    };
  }
  r(a) {
    let b = this.bp(a, false);
    if (b == -1) {
      return false;
    }
    return this.bl(b);
  }
  bl(a) {
    return ExcelUtils.bt(this.bw, a);
  }
  an(a, b, c) {
    let d = this.bp(a, c == false);
    if (d < 0) {
      return;
    }
    this.b1(d, b);
  }
  b1(a, b) {
    switch (a) {
      case 0:
        this.a2 = b;
        return;
      case 1:
        this.a3 = b;
        return;
      case 2:
        this.a4 = b;
        return;
      case 3:
        this.a5 = b;
        return;
      case 4:
        this.a6 = b;
        return;
      case 5:
        this.a7 = b;
        return;
      case 6:
        this.a8 = b;
        return;
      case 7:
        this.a9 = b;
        return;
      case 8:
        this.ba = b;
        return;
      case 9:
        this.bb = b;
        return;
      case 10:
        this.bc = b;
        return;
      case 11:
        this.bd = b;
        return;
      case 12:
        this.be = b;
        return;
      case 13:
        this.bf = b;
        return;
      case 14:
        this.bg = b;
        return;
      case 15:
        this.bh = b;
        return;
      default: return;
    }
  }
  aq(a, b) {
    let c = this.bp(a, b != 0);
    if (c < 0) {
      return;
    }
    this.b3(a, c, b);
  }
  b3(a, b, c) {
    switch (b & 8) {
      case 0:
        this.bj.e(b & 7, c);
        break;
      case 8:
        this.bk.e(b & 7, c);
        break;
      default: return;
    }
    if (c == 0 && this.bl(b) == false) {
      this.b0(a, b);
    }
  }
  ar(a, b, c) {
    let d = this.bp(a, b != 0);
    if (d < 0) {
      return;
    }
    this.b1(d, c);
    this.b3(a, d, b);
  }
  at(a, b) {
    let c = this.bp(a, b);
    if (c < 0) {
      return;
    }
    let d = ExcelUtils.f7(this.bw, b, c);
    this.bw = d.p0;
    if (b == false && this.f(a) == 0) {
      this.b0(a, c);
    }
  }
  bz(a) {
    let b = intDivide(a, 3);
    let c = (a % 3) * 5;
    let d = c + 5 - 1;
    switch (b) {
      case 0:
        let e = ExcelUtils.e5(this.bq, c, d);
        this.bq = e.p0;
        break;
      case 1:
        let f = ExcelUtils.e5(this.br, c, d);
        this.br = f.p0;
        break;
      case 2:
        let g = ExcelUtils.e5(this.bs, c, d);
        this.bs = g.p0;
        break;
      case 3:
        let h = ExcelUtils.e5(this.bt, c, d);
        this.bt = h.p0;
        break;
      case 4:
        let i = ExcelUtils.e5(this.bu, c, d);
        this.bu = i.p0;
        break;
      case 5:
        let j = ExcelUtils.e5(this.bv, c, d);
        this.bv = j.p0;
        break;
      default: return;
    }
  }
  b0(a, b) {
    let c = a & 31;
    let d = ExcelUtils.f7(this.bx, false, b);
    this.bx = d.p0;
    let e = ExcelUtils.f9(this.by, false, c);
    this.by = e.p0;
    this.bz(b);
  }
  bm(a) {
    let b = intDivide(a, 3);
    let c = (a % 3) * 5;
    let d = c + 5 - 1;
    switch (b) {
      case 0: return ExcelUtils.c6(this.bq, c, d);
      case 1: return ExcelUtils.c6(this.br, c, d);
      case 2: return ExcelUtils.c6(this.bs, c, d);
      case 3: return ExcelUtils.c6(this.bt, c, d);
      case 4: return ExcelUtils.c6(this.bu, c, d);
      case 5: return ExcelUtils.c6(this.bv, c, d);
      default: return 0;
    }
  }
  bp(a, b) {
    let c = (a & 31);
    let d = -1;
    if (this.by == 0) {
      d = 0;
    }
    else {
      let e = ExcelUtils.bu(this.by, c);
      if (e || b) {
        for (let f = 0; f < 16; f++) {
          let g = ExcelUtils.bt(this.bx, f);
          if (e) {
            if (g && this.bm(f) == c) {
              return f;
            }
          }
          else if (g == false) {
            if (d < 0) {
              d = f;
            }
            continue;
          }
        }
      }
    }
    if (b) {
      if (d < 0) {
      }
      else {
        let h = ExcelUtils.f7(this.bx, true, d);
        this.bx = h.p0;
        this.b2(d, c);
        return d;
      }
    }
    return -1;
  }
  b2(a, b) {
    let c = intDivide(a, 3);
    let d = (a % 3) * 5;
    let e = d + 5 - 1;
    switch (c) {
      case 0:
        let f = ExcelUtils.e1(this.bq, b, d, e);
        this.bq = f.p0;
        break;
      case 1:
        let g = ExcelUtils.e1(this.br, b, d, e);
        this.br = g.p0;
        break;
      case 2:
        let h = ExcelUtils.e1(this.bs, b, d, e);
        this.bs = h.p0;
        break;
      case 3:
        let i = ExcelUtils.e1(this.bt, b, d, e);
        this.bt = i.p0;
        break;
      case 4:
        let j = ExcelUtils.e1(this.bu, b, d, e);
        this.bu = j.p0;
        break;
      case 5:
        let k = ExcelUtils.e1(this.bv, b, d, e);
        this.bv = k.p0;
        break;
      default: return;
    }
    let l = ExcelUtils.f9(this.by, true, b);
    this.by = l.p0;
  }
}
WorksheetCellBlockHalf.$t = markType(WorksheetCellBlockHalf, 'WorksheetCellBlockHalf', WorksheetCellBlock.$);
/**
 * @hidden
 */
export class WorksheetCellLocation extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.e = null;
    this.f = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.e = c;
          this.f = d;
        }
        break;
    }
  }
  static h(a) {
    return a.e._getCellValue1(a.f);
  }
  static d(a) {
    return a.e.getCellComment(a.f);
  }
  static j(a, b) {
    WorksheetCellLocation.k(a, b, false);
  }
  static k(a, b, c) {
    let d = typeCast(Formula.$, b);
    let e = a.e.worksheet._eh;
    try {
      a.e.worksheet._eh = true;
      if (d != null) {
        try {
          if (c) {
            a.e.worksheet._dr = true;
          }
          d._bp(a.e, a.f, c ? 1 : 0);
        }
        finally {
          if (c) {
            a.e.worksheet._dr = false;
          }
        }
      }
      else {
        a.e.setCellValue(a.f, b);
      }
    }
    finally {
      a.e.worksheet._eh = e;
    }
  }
  static i(a, b) {
    a.e.setCellComment(a.f, b);
  }
  static b($tValue, a, b, c, d = false, e = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetCellLocation.$, $tValue, a, 5, b, c, null, true, e, d, (f) => WorksheetCellLocation.g(f), null);
  }
  static g(a) {
    return a.f;
  }
  get workbook() {
    let a = this.e.worksheet;
    return a != null ? a.workbook : null;
  }
  get sheet() {
    return this.e.worksheet;
  }
  get source() {
    return this.e;
  }
}
WorksheetCellLocation.$t = markStruct(WorksheetCellLocation, 'WorksheetCellLocation', ValueType.$, [IChangeInfoContext_$type]);
WorksheetCellLocation.a = WorksheetCellLocation.b(WorksheetCellComment.$, "Comment", (a) => WorksheetCellLocation.d(a), (a, b) => WorksheetCellLocation.i(a, b));
WorksheetCellLocation.c = WorksheetCellLocation.b(Base.$, "Value", (a) => WorksheetCellLocation.h(a), (a, b) => WorksheetCellLocation.k(a, b, true), true);
/**
 * @hidden
 */
export class WorksheetCellFormatDataResolved extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._b = null;
    this._b = a;
  }
  equals(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(WorksheetCellFormatDataResolved.$, a);
    if (b == null) {
      return false;
    }
    return this._b.equals(b._b);
  }
  getHashCode() {
    return this._b.getHashCode();
  }
  _f(a, b) {
    b = null;
    if (this._b._s == null) {
      return {
        ret: false,
        p1: b
      };
    }
    let c = this._b._s.getAdjacentFormatForBorderResolution(this._b, a);
    if (c == null || ExcelUtils.bx(c.formatOptions, 8) == false) {
      return {
        ret: false,
        p1: b
      };
    }
    b = c._da(ExcelUtils.o(a), null);
    return {
      ret: true,
      p1: b
    };
  }
  _m(a) {
    this._b = a;
    if (this._a != null) {
      this._a._d(a);
    }
  }
  setFormatting(a) {
    this._n();
  }
  _n() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_ResolvedFormatCannotBeModified"));
  }
  get alignment() {
    return this._b.d._a4;
  }
  set alignment(a) {
    this._n();
  }
  get bottomBorderColorInfo() {
    return this._b.d._da(2, runOn(this, this._f));
  }
  set bottomBorderColorInfo(a) {
    this._n();
  }
  get bottomBorderStyle() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._b.d._da(4, runOn(this, this._f)));
  }
  set bottomBorderStyle(a) {
    this._n();
  }
  get _g() {
    return this._b.d._cl;
  }
  get _h() {
    return this._b.d._cm;
  }
  get _i() {
    return this._b.d._cn;
  }
  get _k() {
    return this._b.d._cp;
  }
  get _j() {
    return this._b.d._co;
  }
  get _c() {
    return this._b.d._b7;
  }
  get _d() {
    return this._b.d._b8;
  }
  get diagonalBorderColorInfo() {
    return this._b.d._bg;
  }
  set diagonalBorderColorInfo(a) {
    this._n();
  }
  get diagonalBorders() {
    return this._b.d._aw;
  }
  set diagonalBorders(a) {
    this._n();
  }
  get diagonalBorderStyle() {
    return this._b.d._am;
  }
  set diagonalBorderStyle(a) {
    this._n();
  }
  get fill() {
    return this._b.d._ar;
  }
  set fill(a) {
    this._n();
  }
  get font() {
    if (this._a == null) {
      this._a = new WorkbookFontDataResolved(this._b);
    }
    return this._a;
  }
  get formatOptions() {
    return this._b.d._bz;
  }
  set formatOptions(a) {
    this._n();
  }
  get formatString() {
    return this._b.d._dg;
  }
  set formatString(a) {
    this._n();
  }
  get indent() {
    return this._b.d._ct;
  }
  set indent(a) {
    this._n();
  }
  get leftBorderColorInfo() {
    return this._b.d._da(262144, runOn(this, this._f));
  }
  set leftBorderColorInfo(a) {
    this._n();
  }
  get leftBorderStyle() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._b.d._da(524288, runOn(this, this._f)));
  }
  set leftBorderStyle(a) {
    this._n();
  }
  get locked() {
    return unwrapNullable(this._locked$i);
  }
  set locked(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._locked$i = arguments[0];
  }
  get _locked$i() {
    return this._b.d._c5;
  }
  set _locked$i(a) {
    this._n();
  }
  get rightBorderColorInfo() {
    return this._b.d._da(2097152, runOn(this, this._f));
  }
  set rightBorderColorInfo(a) {
    this._n();
  }
  get rightBorderStyle() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._b.d._da(4194304, runOn(this, this._f)));
  }
  set rightBorderStyle(a) {
    this._n();
  }
  get rotation() {
    return this._b.d._cw;
  }
  set rotation(a) {
    this._n();
  }
  get shrinkToFit() {
    return unwrapNullable(this._shrinkToFit$i);
  }
  set shrinkToFit(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._shrinkToFit$i = arguments[0];
  }
  get _shrinkToFit$i() {
    return this._b.d._c6;
  }
  set _shrinkToFit$i(a) {
    this._n();
  }
  get style() {
    return this._b.d._bs;
  }
  set style(a) {
    this._n();
  }
  get topBorderColorInfo() {
    return this._b.d._da(67108864, runOn(this, this._f));
  }
  set topBorderColorInfo(a) {
    this._n();
  }
  get topBorderStyle() {
    return EnumUtil.getEnumValue(CellBorderLineStyle_$type, this._b.d._da(134217728, runOn(this, this._f)));
  }
  set topBorderStyle(a) {
    this._n();
  }
  get verticalAlignment() {
    return this._b.d._a9;
  }
  set verticalAlignment(a) {
    this._n();
  }
  get wrapText() {
    return unwrapNullable(this._wrapText$i);
  }
  set wrapText(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._wrapText$i = arguments[0];
  }
  get _wrapText$i() {
    return this._b.d._c7;
  }
  set _wrapText$i(a) {
    this._n();
  }
}
WorksheetCellFormatDataResolved.$t = markType(WorksheetCellFormatDataResolved, 'WorksheetCellFormatDataResolved', Base.$, [IWorksheetCellFormat_$type]);
/**
 * @hidden
 */
export class WorksheetMergedCellFormatDataResolved extends WorksheetCellFormatDataResolved {
  constructor(a) {
    super(a._cellFormatInternal);
    this._o = null;
    this._o = a;
  }
  _f(a, b) {
    let c = this._o._a1(Nullable$1.toNullable(CellFormatValue_$type, a), true);
    let d = c.tryGetValue(a, b);
    b = d.p1;
    return {
      ret: Base.equalsStatic(b, WorksheetCellFormatData._c8(a)) == false,
      p1: b
    };
  }
}
WorksheetMergedCellFormatDataResolved.$t = markType(WorksheetMergedCellFormatDataResolved, 'WorksheetMergedCellFormatDataResolved', WorksheetCellFormatDataResolved.$);
/**
 * @hidden
 */
export class WorksheetCellOwnedFormatProxy extends WorksheetCellFormatProxy {
  constructor(a, b, c, d, e) {
    super(0, a, b, c);
    this._bs = null;
    this._bw = 0;
    this._bu = 0;
    this._bu = d;
    this._bs = e;
    this._bw = c.worksheet._fv;
  }
  g(a) {
    super.g(a);
    this._bx();
  }
  b(a) {
    this._by();
    if (a == false) {
      return super.b(a);
    }
    let b = super.b(a);
    this._bx();
    return b;
  }
  get__l() {
    return WorksheetCellOwnedFormatProxy._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 4;
  }
  get _q() {
    return this.get__q();
  }
  _ai() {
    this._by();
    let a = this._s;
    return Nullable$1.toNullable(WorksheetCellAddress.$, new WorksheetCellAddress(1, a.index, this._bu));
  }
  _at(a) {
    if (WorksheetCellAddress.i(a, Nullable$1.toNullable(WorksheetCellAddress.$, null))) {
      let b = this._s;
      if (b != null) {
        let c = b.worksheet;
        if (c != null) {
          this._bw = c._fv;
          this._bc(c._rows$i.item(a.value.o));
          this._bu = a.value.m;
        }
      }
    }
  }
  get__v() {
    let a = typeCast(WorksheetRow.$, this._s);
    return a != null ? a.worksheet : null;
  }
  get _v() {
    return this.get__v();
  }
  get_d() {
    this._by();
    this.c = this._bs[this._bu % 32];
    return this.c;
  }
  _bx() {
    this._bs[this._bu % 32] = this.c;
  }
  _by() {
    if (this._bs != null) {
      let a = this._s;
      let b = this._bu;
      let c = this._s;
      let d = c.worksheet;
      if (d == null || ((() => { let e = d._eo(c, this._bu, this._bw); c = e.p0; this._bu = e.p1; this._bw = e.p2; return e.ret; })()) == false) {
        this._bc(null);
        this._bu = -1;
        this._bs = null;
        this.c = null;
      }
      else if (c != a || this._bu != b) {
        this._bc(c);
        this._bs = c._aj(this._bu);
        this.c = c._bb(this._bs, this._bu).d;
      }
    }
    if (this._bs == null) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_CellShiftedOffWorksheet"));
    }
  }
  get _bv() {
    return this._bu;
  }
  get _bt() {
    return this.c;
  }
  set _bt(a) {
    this.c = a;
  }
}
WorksheetCellOwnedFormatProxy.$t = markType(WorksheetCellOwnedFormatProxy, 'WorksheetCellOwnedFormatProxy', WorksheetCellFormatProxy.$);
WorksheetCellOwnedFormatProxy._br = WorksheetCellFormatProxy._m(4, 4);
/**
 * @hidden
 */
export class Excel2007ChartData extends Base {
  constructor() {
    super(...arguments);
    this.a = null;
    this.c = null;
    this.d = null;
    this.e = null;
    this.b = null;
  }
}
Excel2007ChartData.$t = markType(Excel2007ChartData, 'Excel2007ChartData');
/**
 * @hidden
 */
export class FontXInfo extends Base {
  constructor(a, b) {
    super();
    this.c = false;
    this.a = null;
    this.d = 0;
    if (a == 0) {
      this.c = true;
    }
    else if (a < b._h.count) {
      this.a = b._h._inner[a];
    }
    else {
      this.d = a - b._h.count;
    }
  }
  e(a) {
    if (this.c) {
      return 0;
    }
    if (this.a != null) {
      let b = a._h.indexOf(this.a);
      return b;
    }
    return (this.d + a._h.count);
  }
  get b() {
    return this.a;
  }
}
FontXInfo.$t = markType(FontXInfo, 'FontXInfo');
/**
 * @hidden
 */
export class WorksheetColumnOwnedFormatProxy extends WorksheetCellFormatProxy {
  constructor(a, b) {
    super(0, b.worksheet._cb(b._aq).b, a, b);
  }
  g(a) {
    super.g(a);
    this._bs().b = this.c;
    let b = this._s._aj();
    this.c = b.b;
    this._s.worksheet._hh();
  }
  b(a) {
    let b = this._s._ak();
    this.c = b.b;
    let c = super.b(a);
    b.b = this.c;
    return c;
  }
  get__l() {
    return WorksheetColumnOwnedFormatProxy._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 27;
  }
  get _q() {
    return this.get__q();
  }
  get_d() {
    this.c = this._bs().b;
    return this.c;
  }
  get__v() {
    let a = typeCast(WorksheetColumn.$, this._s);
    return a != null ? a.worksheet : null;
  }
  get _v() {
    return this.get__v();
  }
  _bs() {
    let a = this._s;
    return a.worksheet._cb(a._aq);
  }
}
WorksheetColumnOwnedFormatProxy.$t = markType(WorksheetColumnOwnedFormatProxy, 'WorksheetColumnOwnedFormatProxy', WorksheetCellFormatProxy.$);
WorksheetColumnOwnedFormatProxy._br = WorksheetCellFormatProxy._m(27, 8);
/**
 * @hidden
 */
export class WorksheetColumnCollection_InsertRemoveOperationWrapper extends Base {
  constructor(a, b, c, d, e, f, g) {
    super();
    this.c = null;
    this.d = new WorksheetColumnCollection_CollectionChangeContext();
    this.a = null;
    this.h = null;
    this.g = 0;
    this.b = null;
    this.e = false;
    this.f = false;
    this.c = a;
    this.d = b;
    this.h = null;
    this.a = g;
    this.g = c;
    this.e = d;
    this.f = e;
    this.b = f;
  }
  i() {
    let a = this.d.sheet;
    this.h = this.c.b(this.d.workbook, a, null);
    this.worksheet._hz(false);
    a.sortSettings._bl(true);
    a.filterSettings._bn();
    a._conditionalFormats$i._a6();
    this.c.e(WorksheetColumnCollection_CollectionChangeContext.$, Number_$type, this.d, -1, this.g);
  }
  j() {
    let a = this.d.sheet;
    a.sortSettings._bm();
    a.filterSettings._bo();
    a._conditionalFormats$i._a7();
  }
  k() {
    this.c.e(WorksheetColumnCollection_CollectionChangeContext.$, Number_$type, this.d, -1, this.g);
    this.worksheet._h0();
    this.j();
    if (this.h != null) {
      this.c.d(this.d.workbook, this.h);
    }
  }
  get count() {
    return this.d.a.g;
  }
  get index() {
    return this.g;
  }
  get shiftsColumns() {
    return true;
  }
  get shiftsRows() {
    return false;
  }
  get isRemoveOperation() {
    return !this.e;
  }
  get isUndoOperation() {
    return this.f;
  }
  get performsShift() {
    return true;
  }
  get worksheet() {
    return this.d.sheet;
  }
  onBeforeShift(a) {
    if (!this.f) {
      this.i();
    }
  }
  performShift(a) {
    let b = this.d.workbook;
    let c = b._df;
    b._df = false;
    let d = this.d.a.e;
    if (this.e) {
      d._aa(this.index, this.count);
      this.worksheet._hx(this.index, this.count);
    }
    else {
      d._ad(this.index, this.count);
      this.worksheet._hy(this.index, this.count);
    }
    if (this.b != null) {
      this.d.a.e._au(this.b, this.a);
    }
    b._df = c;
    return false;
  }
}
WorksheetColumnCollection_InsertRemoveOperationWrapper.$t = markType(WorksheetColumnCollection_InsertRemoveOperationWrapper, 'WorksheetColumnCollection_InsertRemoveOperationWrapper', Base.$, [ICellShiftOperationOverride_$type]);
/**
 * @hidden
 */
export class WorksheetColumnCollection_CollectionChangeContextData extends Base {
  constructor(a, b, c, d, e, f) {
    super();
    this.f = false;
    this.h = 0;
    this.g = 0;
    this.e = null;
    this.b = null;
    this.a = null;
    this.c = null;
    this.e = a;
    this.f = b;
    this.h = c;
    this.g = d;
    this.b = e;
    this.a = f;
    this.c = null;
  }
  i(a) {
    this.c = a;
  }
  get d() {
    return this.c;
  }
}
WorksheetColumnCollection_CollectionChangeContextData.$t = markType(WorksheetColumnCollection_CollectionChangeContextData, 'WorksheetColumnCollection_CollectionChangeContextData');
/**
 * @hidden
 */
export class WorksheetElementResizeContext_MultiElementResizeChange extends WorksheetElementResizeContext {
  constructor(a, b, c, d) {
    super();
    this.ac = null;
    this.ad = 0;
    this.z(a, c);
    this.ac = b;
    this.ad = d;
  }
  g(a) {
    for (let b = 0; b < this.ac.count; b++) {
      let c = this.ac._inner[b];
      if (c.d <= a && a <= c.e) {
        return this.ac._inner[b].b;
      }
    }
    return this.f(a);
  }
  u(a, b = false) {
    for (let c = 0; c < this.ac.count; c++) {
      let d = this.ac._inner[c];
      if (d.d <= a && a <= d.e) {
        if (!b && !this.ac._inner[c].b) {
          return 0;
        }
        else {
          let e = this.ac._inner[c].c;
          return e < 0 ? this.ad : e;
        }
      }
    }
    return this.s(a, b);
  }
  v(a, b) {
    let c = this.t(a, b);
    for (let d = 0; d < this.ac.count; d++) {
      let e = this.ac._inner[d];
      if (e.e < a) {
        continue;
      }
      if (e.d > b) {
        break;
      }
      let f = a < e.d ? e.d : a;
      let g = b > e.e ? e.e : b;
      let h = this.t(f, g);
      let i;
      if (this.ac._inner[d].b) {
        i = 0;
      }
      else {
        if (this.ac._inner[d].c < 0) {
          i = this.ad;
        }
        else {
          i = this.ac._inner[d].c;
        }
        i *= (g - f + 1);
      }
      c -= (h - i);
    }
    return c;
  }
  get_i() {
    let a = new List$1(IndexRange.$, 0);
    for (let b of fromEnum(this.ac)) {
      a.add(new IndexRange(1, b.d, b.e));
    }
    return a;
  }
  get i() {
    return this.get_i();
  }
  get_r() {
    return this.ac._inner[0].d;
  }
  get r() {
    return this.get_r();
  }
  get_w() {
    return this.ac._inner[this.ac.count - 1].e;
  }
  get w() {
    return this.get_w();
  }
}
WorksheetElementResizeContext_MultiElementResizeChange.$t = markType(WorksheetElementResizeContext_MultiElementResizeChange, 'WorksheetElementResizeContext_MultiElementResizeChange', WorksheetElementResizeContext.$);
/**
 * @hidden
 */
export class WorksheetElementResizeContext_MultiElementVisibilityChange extends WorksheetElementResizeContext {
  constructor(a, b, c, d, e) {
    super();
    this.ac = null;
    this.ad = 0;
    this.ae = 0;
    this.z(a, b);
    this.ac = e;
    this.ad = c;
    this.ae = d;
  }
  g(a) {
    let b = this.f(a);
    for (let c = 0; c < this.ac.count; c++) {
      let d = this.ac._inner[c];
      if (d.a <= a && a <= d.b) {
        return (b == false);
      }
    }
    return b;
  }
  u(a, b = false) {
    if (b == false && this.g(a)) {
      return 0;
    }
    return this.s(a, true);
  }
  v(a, b) {
    let c = this.t(a, b);
    for (let d = 0; d < this.ac.count; d++) {
      let e = this.ac._inner[d];
      if (e.b < a) {
        continue;
      }
      if (b < e.a) {
        break;
      }
      let f = this.t(Math.max(e.a, a), Math.min(e.b, b), true);
      if (this.f(e.a)) {
        c += f;
      }
      else {
        c -= f;
      }
    }
    return c;
  }
  get_i() {
    return this.ac;
  }
  get i() {
    return this.get_i();
  }
  get_r() {
    return this.ad;
  }
  get r() {
    return this.get_r();
  }
  get_w() {
    return this.ae;
  }
  get w() {
    return this.get_w();
  }
}
WorksheetElementResizeContext_MultiElementVisibilityChange.$t = markType(WorksheetElementResizeContext_MultiElementVisibilityChange, 'WorksheetElementResizeContext_MultiElementVisibilityChange', WorksheetElementResizeContext.$);
/**
 * @hidden
 */
export class IndexRange extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
}
IndexRange.$t = markStruct(IndexRange, 'IndexRange');
/**
 * @hidden
 */
export class WorksheetElementResizeState extends Base {
  constructor(a, b, c, d, e) {
    super();
    this.d = 0;
    this.e = 0;
    this.c = 0;
    this.b = false;
    this.a = false;
    this.d = a;
    this.e = b;
    this.c = c;
    this.b = d;
    this.a = e;
  }
}
WorksheetElementResizeState.$t = markType(WorksheetElementResizeState, 'WorksheetElementResizeState');
/**
 * Represents a hyperlink for a cell or region.
 * @see [[Worksheet.hyperlinks]]
 * @see [[WorksheetCell.getHyperlink]]
 * @see [[WorksheetRow.getCellHyperlink]]
 */
export class WorksheetHyperlink extends Base {
  constructor(..._rest) {
    super();
    this._aj = null;
    this._r = false;
    this._q = false;
    this._p = false;
    this._ak = null;
    this._h = null;
    this._k = null;
    this._n = new WorksheetRegionAddress();
    this._ah = null;
    this._al = null;
    this._f = null;
    /**
     * @hidden
     */
    this._t = false;
    /**
     * @hidden
     */
    this._v = false;
    let a;
    if (arguments.length === 2) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (typeof arguments[0] === 'string') {
        a = 0;
      }
      else if (arguments[0] == null) {
        a = 0;
      }
    }
    else if (arguments.length === 3) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (typeof arguments[0] === 'string') {
        a = 0;
      }
      else if (arguments[0] == null) {
        a = 0;
      }
    }
    else if (arguments.length === 4) {
      if (typeCast(WorksheetCell.$, arguments[0]) !== null) {
        if (typeof arguments[1] === 'string') {
          if (typeCast(Boolean_$type, arguments[3]) !== null) {
            a = 3;
          }
          else if (typeof arguments[3] === 'string') {
            a = 1;
          }
          else if (arguments[3] == null) {
            a = 1;
          }
        }
        else if (typeCast(Base.$, arguments[1]) !== null) {
          a = 1;
        }
        else if (arguments[1] == null) {
          if (typeCast(Boolean_$type, arguments[3]) !== null) {
            a = 3;
          }
          else if (typeof arguments[3] === 'string') {
            a = 1;
          }
          else if (arguments[3] == null) {
            a = 1;
          }
        }
      }
      else if (typeCast(WorksheetRegion.$, arguments[0]) !== null) {
        a = 2;
      }
      else if (typeof arguments[0] === 'string') {
        a = 0;
      }
      else if (arguments[0] == null) {
        if (typeof arguments[1] === 'string') {
          if (typeCast(Boolean_$type, arguments[3]) !== null) {
            a = 3;
          }
          else if (typeof arguments[3] === 'string') {
            a = 0;
          }
          else if (arguments[3] == null) {
            a = 0;
          }
        }
        else if (typeCast(Base.$, arguments[1]) !== null) {
          a = 0;
        }
        else if (arguments[1] == null) {
          if (typeCast(Boolean_$type, arguments[3]) !== null) {
            a = 3;
          }
          else if (typeof arguments[3] === 'string') {
            a = 0;
          }
          else if (arguments[3] == null) {
            a = 0;
          }
        }
      }
    }
    switch (a) {
      case 0:
        {
          let sourceAddress = _rest[0];
          let target = _rest[1];
          let displayText = _rest[2];
          let toolTip = _rest[3];
          displayText = (displayText !== void 0 ? displayText : null);
          toolTip = (toolTip !== void 0 ? toolTip : null);
          DocCoreUtils.au(sourceAddress, "sourceAddress");
          this._a8(target, "target");
          this._a6(displayText, "displayText");
          this._a9(toolTip, "toolTip");
          this._aj = displayText;
          this._ah = target;
          this._al = toolTip;
          this._a0(sourceAddress);
        }
        break;
      case 1:
        {
          let sourceCell = _rest[0];
          let target = _rest[1];
          let displayText = _rest[2];
          let toolTip = _rest[3];
          displayText = (displayText !== void 0 ? displayText : null);
          toolTip = (toolTip !== void 0 ? toolTip : null);
          DocCoreUtils.au(sourceCell, "sourceCell");
          this._aj = displayText;
          this._ah = target;
          this._al = toolTip;
          this._a1(sourceCell);
          this._a8(target, "target");
        }
        break;
      case 2:
        {
          let sourceRegion = _rest[0];
          let target = _rest[1];
          let displayText = _rest[2];
          let toolTip = _rest[3];
          displayText = (displayText !== void 0 ? displayText : null);
          toolTip = (toolTip !== void 0 ? toolTip : null);
          DocCoreUtils.au(sourceRegion, "sourceRegion");
          this._aj = displayText;
          this._ah = target;
          this._al = toolTip;
          this._a2(sourceRegion);
          this._a8(target, "target");
        }
        break;
      case 3:
        {
          let sourceCell = _rest[0];
          let target = _rest[1];
          let displayText = _rest[2];
          let isSealed = _rest[3];
          this._aj = displayText;
          this._p = isSealed;
          this._ah = target;
          this._a1(sourceCell);
          if (isSealed && WorksheetCell.l_op_Inequality(sourceCell, null)) {
            this._f = sourceCell.worksheet;
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get workbook() {
    return this.worksheet != null ? this.worksheet.workbook : null;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
  /**
   * Gets the string representation of the hyperlink.
   * @return The string representation of the hyperlink.
   */
  toString() {
    if (this.displayText != null) {
      return stringFormat("Hyperlink: {0} [{1}]", this.displayText, this.targetAddress);
    }
    return stringFormat("Hyperlink: {0}", this.targetAddress);
  }
  /**
   * @hidden
   */
  _au(a = true, b = true) {
    if (this._f == null) {
      return;
    }
    if (this._f._t) {
      return;
    }
    if (a) {
      let c = this._k != null ? this._k._h : this._n;
      if (!c._n) {
        return;
      }
      let d = this._f._rows$i.item(c._ac);
      let e = c._w;
      let f = d._c6(e);
      if (ExcelUtils.a9(f) || (this.displayText != null && WorksheetCellBlock.s(f))) {
        d.setCellValue(e, this.displayText != null ? this.displayText : this.targetAddress);
      }
    }
    if (b) {
      WorksheetHyperlink._at(this.sourceRegion);
    }
  }
  /**
   * @hidden
   */
  static _at(a) {
    let b = a.worksheet;
    if (b.workbook == null) {
      return;
    }
    let c = b.workbook._styles$i;
    let d = c._i(8);
    if (d == null) {
      d = c._add(Enumerable.ae(WorkbookBuiltInStyle.$, WorkbookStyleCollection._x, (e) => e._ac == 8)._ad(b.workbook));
    }
    for (let e = a.firstRow; e <= a.lastRow; e++) {
      let f = b._rows$i.item(e);
      for (let g = a._v; g <= a._w; g++) {
        f._bc(g).style = d;
      }
    }
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = false, h = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetHyperlink.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(7);
    ChangeInfo.f(a, 0, WorksheetHyperlink._d(String_$type, "DisplayText", 47, (b) => b.displayText, (b, c) => b.displayText = c, (b, c) => b._ay(c), true, true));
    ChangeInfo.f(a, 1, WorksheetHyperlink._d(String_$type, "SourceAddress", 47, (b) => b.sourceAddress, (b, c) => b.sourceAddress = c, (b, c) => b._a0(c), true, true));
    ChangeInfo.f(a, 2, WorksheetHyperlink._d(WorksheetCell.$, "SourceCell", 47, (b) => b.sourceCell, (b, c) => b.sourceCell = c, (b, c) => b._a1(c), true, true));
    ChangeInfo.f(a, 3, WorksheetHyperlink._d(WorksheetRegion.$, "SourceRegion", 47, (b) => b.sourceRegion, (b, c) => b.sourceRegion = c, (b, c) => b._a2(c), true, true));
    ChangeInfo.f(a, 4, WorksheetHyperlink._d(Base.$, "Target", 47, (b) => b.target, (b, c) => b.target = c, null, true, false));
    ChangeInfo.f(a, 5, WorksheetHyperlink._d(String_$type, "ToolTip", 47, (b) => b.toolTip, (b, c) => b.toolTip = c, null, true, false));
    ChangeInfo.f(a, 6, WorksheetHyperlink._d(WorksheetHyperlink.$, "OnVisited", 47, (b) => b, (b, c) => {
    }, void 0, false));
    return a;
  }
  /**
   * @hidden
   */
  _s() {
    if (this._v) {
      return true;
    }
    if (this.isSealed) {
      if (WorksheetCell.l_op_Inequality(this._h, null)) {
        let a = this._h.worksheet;
        if (a != null && a._fi.contains(this._h)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _an(a) {
    if (this._c == 1) {
      return a._toString2(1, false, true, true);
    }
    else {
      return a._toString2(0, false, false, false);
    }
  }
  /**
   * @hidden
   */
  _ao(a) {
    if (this._c == 1) {
      return a._toString2(1, false, true, true);
    }
    else {
      return a._toString2(0, false, false, false);
    }
  }
  /**
   * @hidden
   */
  _av() {
    let a = false;
    if (this.isSealed) {
      if (WorksheetCell.l_op_Inequality(this._h, null)) {
        let b = this._h.worksheet;
        if (b != null && !b._fi.contains(this._h)) {
          b._fi.add(this._h);
          a = true;
        }
      }
    }
    else if (this._v == false) {
      this._v = true;
      a = true;
    }
    if (a) {
      WorksheetHyperlink._a[6].x(this, this, this);
    }
  }
  /**
   * @hidden
   */
  _a3(a, b = true, c = true) {
    if (b && a == null && this._f != null) {
      this._aw();
    }
    if (this._r) {
      if (a == null) {
        this._h = null;
        this._k = null;
      }
      else {
        this._k = a._getRegion(this._ak);
        this._a5();
      }
    }
    this._f = a;
    this._au(c, b);
  }
  /**
   * @hidden
   */
  _aw() {
    let a = this._k != null ? this._k.worksheet : this._f;
    let b = this._k != null ? this._k._h : this._n;
    if (a == null || a.workbook == null || !b._n) {
      return;
    }
    let c = a.workbook._styles$i.normalStyle;
    for (let d = b._ac; d <= b._ae; d++) {
      let e = a._rows$i.item(d);
      for (let f = b._w; f <= b._x; f++) {
        e._bc(f).style = c;
      }
    }
  }
  /**
   * @hidden
   */
  _ax(a, b) {
    this._q = false;
    if (a == null) {
      return;
    }
    if (!b._n) {
      return;
    }
    this._n = b;
    this._k = b._n ? a._cw(this._n) : null;
    this._h = this._k != null && this._k._u ? a._rows$i.item(this._n._ac)._cells$i.item(this._n._w) : null;
    if (this._r && this._k != null && !stringIsNullOrEmpty(this._ak)) {
      this._ak = this._n._ah(false, false, a.workbook.currentFormat, 1);
    }
  }
  /**
   * @hidden
   */
  _az(a) {
    this._n = a;
    this._q = true;
  }
  /**
   * @hidden
   */
  _a4() {
    if (this._f == null) {
      return;
    }
    if (this._q) {
      this._ax(this._f, this._n);
    }
    this._n = WorksheetRegionAddress._b;
    if (this._k != null) {
      this._n = this._k._h;
    }
    else if (WorksheetCell.l_op_Inequality(this._h, null)) {
      this._n = new WorksheetRegionAddress(2, this._h._e, this._h._e);
    }
    else if (this._f != null && !stringIsNullOrEmpty(this._ak)) {
      try {
        let a = this._f._getRegion(this._ak);
        if (a != null) {
          this._n = a._h;
        }
      }
      catch (b) {
      }
    }
    this._k = null;
    this._h = null;
  }
  /**
   * @hidden
   */
  _a5() {
    let a = this.sourceRegion;
    if (a._u) {
      if (WorksheetCell.l_op_Equality(this._h, null) || this._h.worksheet == null) {
        this._h = a._k._cells$i.item(a.firstColumn);
      }
      else {
      }
    }
    else {
      this._h = null;
    }
  }
  /**
   * @hidden
   */
  _a6(a, b) {
    if (a != null && a.length > 2084) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DisplayTextTooLongS"), b);
    }
  }
  /**
   * @hidden
   */
  _a7() {
    if (this._p) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_HyperlinkSealed"));
    }
  }
  /**
   * @hidden
   */
  _a8(a, b) {
    if (a == null) {
      return;
    }
    let c = typeCast(WorksheetCell.$, a);
    let d = typeCast(WorksheetRegion.$, a);
    let e = typeCast(NamedReference.$, a);
    let f = typeCast(String_$type, a);
    if (f != null) {
      if (f.length > 2076) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_TargetTooLong"), b);
      }
    }
    else if (WorksheetCell.l_op_Equality(c, null) && d == null && e == null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidTarget"), b);
    }
    let g = this._f;
    if (g == null) {
      if (WorksheetCell.l_op_Inequality(this._h, null)) {
        g = this._h.worksheet;
      }
      else if (this._k != null) {
        g = this._k.worksheet;
      }
    }
    if (g != null) {
      let h = false;
      if (e != null) {
        h = e._k != g.workbook;
      }
      else if (WorksheetCell.l_op_Inequality(c, null)) {
        h = c.worksheet != null && c.worksheet.workbook != g.workbook;
      }
      else if (d != null) {
        h = d.worksheet != null && d.worksheet.workbook != g.workbook;
      }
      if (h) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_HyperlinkTargetFromOtherWorkbook"), b);
      }
    }
  }
  /**
   * @hidden
   */
  _a9(a, b) {
    if (a != null && a.length > 256) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_ToolTipTooLong"), b);
    }
  }
  /**
   * Gets or sets the text to display in the cell when the hyperlink is added to a worksheet, or null to use the target text.
   * <p class="note">
   * <b>Note: the display text will only get applied if the target cell has no value or a string value.</b>
   * </p>
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 2084 characters.
   */
  get displayText() {
    return this._aj;
  }
  /**
   * Gets or sets the text to display in the cell when the hyperlink is added to a worksheet, or null to use the target text.
   * <p class="note">
   * <b>Note: the display text will only get applied if the target cell has no value or a string value.</b>
   * </p>
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 2084 characters.
   */
  set displayText(a) {
    this._a7();
    if (this.displayText == a) {
      return;
    }
    this._a6(a, "value");
    WorksheetHyperlink._a[0].h(WorksheetHyperlink.$, String_$type, this, a);
  }
  /**
   * @hidden
   */
  _ay(a) {
    this._aj = a;
    this._au(void 0, false);
  }
  /**
   * Gets the value indicating whether the hyperlink is sealed and cannot be modified.
   */
  get isSealed() {
    return this._p;
  }
  /**
   * Gets or sets the address of the cell or region on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned cannot be parsed as a cell or region address in the owning workbook's current
   * cell reference mode.
   * @see [[sourceCell]]
   * @see [[sourceRegion]]
   */
  get sourceAddress() {
    if (this._f != null) {
      this._a5();
      if (WorksheetCell.l_op_Inequality(this._h, null)) {
        this._ak = this._an(this._h);
      }
      else if (this._k != null) {
        this._ak = this._ao(this._k);
      }
    }
    return this._ak;
  }
  /**
   * Gets or sets the address of the cell or region on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned cannot be parsed as a cell or region address in the owning workbook's current
   * cell reference mode.
   * @see [[sourceCell]]
   * @see [[sourceRegion]]
   */
  set sourceAddress(a) {
    this._a7();
    if (this._r && this.sourceAddress == a) {
      return;
    }
    WorksheetHyperlink._a[1].h(WorksheetHyperlink.$, String_$type, this, a);
  }
  /**
   * @hidden
   */
  _a0(a) {
    if (this.sourceAddress == a) {
      this._r = true;
      this._h = null;
      this._k = null;
      return;
    }
    if (this._f == null) {
      this._ak = a;
      this._h = null;
      this._k = null;
    }
    else {
      this._aw();
      let b = this._f._getRegion(a);
      this._ak = a;
      this._k = b;
      if (this._k._u) {
        this._h = this._k._k._cells$i.item(this._k.firstColumn);
      }
      else {
        this._h = null;
      }
    }
    this._r = true;
    this._au();
  }
  /**
   * Gets or sets the cell on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
   * @see [[sourceAddress]]
   * @see [[sourceRegion]]
   */
  get sourceCell() {
    if (this._f != null) {
      this._a5();
    }
    return this._h;
  }
  /**
   * Gets or sets the cell on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
   * @see [[sourceAddress]]
   * @see [[sourceRegion]]
   */
  set sourceCell(a) {
    this._a7();
    if (this._r == false && WorksheetCell.l_op_Equality(this._h, a)) {
      return;
    }
    DocCoreUtils.au(a, "value");
    if (this._f != null && a.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_SourceFromOtherWorksheetThanHyperlink"), "value");
    }
    WorksheetHyperlink._a[2].h(WorksheetHyperlink.$, WorksheetCell.$, this, a);
  }
  /**
   * @hidden
   */
  _a1(a) {
    if (WorksheetCell.l_op_Equality(this._h, a)) {
      this._r = false;
      return;
    }
    if (this._f != null) {
      this._aw();
    }
    this._h = a;
    this._ak = this._an(this._h);
    this._k = this._h._l();
    this._r = false;
    this._au();
  }
  /**
   * Gets or sets the region on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
   * @see [[sourceCell]]
   * @see [[sourceRegion]]
   */
  get sourceRegion() {
    if (this._k == null && this._f != null && this._n._n && this._f._hyperlinks$i.contains(this)) {
      return this._f._cw(this._n);
    }
    return this._k;
  }
  /**
   * Gets or sets the region on which the hyperlink resides.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
   * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
   * @see [[sourceCell]]
   * @see [[sourceRegion]]
   */
  set sourceRegion(a) {
    this._a7();
    if (this._r == false && this._k == a) {
      return;
    }
    DocCoreUtils.au(a, "value");
    if (this._f != null && a.worksheet != this._f) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_SourceFromOtherWorksheetThanHyperlink"), "value");
    }
    WorksheetHyperlink._a[3].h(WorksheetHyperlink.$, WorksheetRegion.$, this, a);
  }
  /**
   * @hidden
   */
  _a2(a) {
    if (this._k == a) {
      this._r = false;
      return;
    }
    if (this._f != null) {
      this._aw();
    }
    this._k = a;
    this._ak = this._ao(this._k);
    this._a5();
    this._r = false;
    this._au();
  }
  /**
   * Gets or sets the target of the hyperlink, which can be a string, [[WorksheetCell]], [[WorksheetRegion]], or
   * [[NamedReference]] instance. For bookmarks in an external document, separate the sub-address with a #,
   * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
   * "mailto:joe@company.com?subject=Email%20Subject".
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is not a string, WorksheetCell, WorksheetRegion, or NamedReference instance.
   * @throws [[ArgumentException]] Occurs when the specified value is a string longer than 256 characters.
   * @throws [[ArgumentException]] Occurs when the value assigned is a cell or region which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  get target() {
    if (this._t && this._f != null && this._f.workbook != null) {
      let a = WorkbookLoadManager._v(this._f.workbook, null, typeCast(String_$type, this._ah));
      if (a != this._ah) {
        this.target = a;
      }
    }
    return this._ah;
  }
  /**
   * Gets or sets the target of the hyperlink, which can be a string, [[WorksheetCell]], [[WorksheetRegion]], or
   * [[NamedReference]] instance. For bookmarks in an external document, separate the sub-address with a #,
   * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
   * "mailto:joe@company.com?subject=Email%20Subject".
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is not a string, WorksheetCell, WorksheetRegion, or NamedReference instance.
   * @throws [[ArgumentException]] Occurs when the specified value is a string longer than 256 characters.
   * @throws [[ArgumentException]] Occurs when the value assigned is a cell or region which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  set target(a) {
    this._a7();
    if (this._ah == a) {
      return;
    }
    this._a8(a, "value");
    this._t = false;
    let b = WorksheetHyperlink._a[4].g(WorksheetHyperlink.$, Base.$, this, this._ah, a);
    this._ah = b.p1;
  }
  /**
   * Gets or sets the target address of the hyperlink. For bookmarks in an external document, separate the sub-address with a #,
   * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
   * "mailto:joe@company.com?subject=Email%20Subject".
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
   * @see [[target]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  get targetAddress() {
    let a = typeCast(String_$type, this.target);
    if (a != null) {
      return a;
    }
    let b = typeCast(WorksheetCell.$, this.target);
    if (WorksheetCell.l_op_Inequality(b, null)) {
      return b._toString2(1, true, true, true);
    }
    let c = typeCast(WorksheetRegion.$, this.target);
    if (c != null) {
      return c._toString2(1, true, true, true);
    }
    let d = typeCast(NamedReference.$, this.target);
    if (d != null) {
      return d.toString();
    }
    return null;
  }
  /**
   * Gets or sets the target address of the hyperlink. For bookmarks in an external document, separate the sub-address with a #,
   * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
   * "mailto:joe@company.com?subject=Email%20Subject".
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
   * @see [[target]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  set targetAddress(a) {
    this.target = a;
  }
  /**
   * Gets or sets the target cell of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a cell which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  get targetCell() {
    return typeCast(WorksheetCell.$, this.target);
  }
  /**
   * Gets or sets the target cell of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a cell which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetRegion]]
   * @see [[targetNamedReference]]
   */
  set targetCell(a) {
    this.target = a;
  }
  /**
   * Gets or sets the target named reference of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a named reference which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   */
  get targetNamedReference() {
    return typeCast(NamedReference.$, this.target);
  }
  /**
   * Gets or sets the target named reference of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a named reference which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetRegion]]
   */
  set targetNamedReference(a) {
    this.target = a;
  }
  /**
   * Gets or sets the target region of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a region which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetNamedReference]]
   */
  get targetRegion() {
    return typeCast(WorksheetRegion.$, this.target);
  }
  /**
   * Gets or sets the target region of the hyperlink.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the value assigned is a region which is not from the same workbook as the owning workbook of the hyperlink.
   * @see [[target]]
   * @see [[targetAddress]]
   * @see [[targetCell]]
   * @see [[targetNamedReference]]
   */
  set targetRegion(a) {
    this.target = a;
  }
  /**
   * Gets or sets the text to use in a tool tip when hovering over the source cell or region, or null to use the default tool tip.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
   */
  get toolTip() {
    return this._al;
  }
  /**
   * Gets or sets the text to use in a tool tip when hovering over the source cell or region, or null to use the default tool tip.
   * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
   * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
   */
  set toolTip(a) {
    this._a7();
    this._a9(a, "value");
    let b = WorksheetHyperlink._a[5].g(WorksheetHyperlink.$, String_$type, this, this._al, a);
    this._al = b.p1;
  }
  /**
   * Gets the worksheet to which the hyperlink belongs.
   */
  get worksheet() {
    return this._f;
  }
  /**
   * @hidden
   */
  get _o() {
    return this._n;
  }
  /**
   * @hidden
   */
  get _c() {
    if (this._f != null) {
      return this._f._c;
    }
    return 1;
  }
}
WorksheetHyperlink.$t = markType(WorksheetHyperlink, 'WorksheetHyperlink', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
WorksheetHyperlink._w = 0;
/**
 * @hidden
 */
WorksheetHyperlink._ac = 1;
/**
 * @hidden
 */
WorksheetHyperlink._ad = 2;
/**
 * @hidden
 */
WorksheetHyperlink._ae = 3;
/**
 * @hidden
 */
WorksheetHyperlink._af = 4;
/**
 * @hidden
 */
WorksheetHyperlink._ag = 5;
/**
 * @hidden
 */
WorksheetHyperlink._ab = 6;
/**
 * @hidden
 */
WorksheetHyperlink._aa = 7;
/**
 * @hidden
 */
WorksheetHyperlink._x = 2084;
/**
 * @hidden
 */
WorksheetHyperlink._y = 2076;
/**
 * @hidden
 */
WorksheetHyperlink._z = 256;
/**
 * @hidden
 */
WorksheetHyperlink._a = WorksheetHyperlink._b();
/**
 * @hidden
 */
export class WorksheetHyperlinkCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._e.workbook;
  }
  get sheet() {
    return this.b._e;
  }
  get source() {
    return this.b._e;
  }
}
WorksheetHyperlinkCollection_CollectionChangeContext.$t = markStruct(WorksheetHyperlinkCollection_CollectionChangeContext, 'WorksheetHyperlinkCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetHyperlinkCollection_ShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.b = null;
    this.c = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.d = c;
          this.b = d != null ? d.toArray() : null;
          this.c = e != null ? e.toArray() : null;
          this.a = f != null ? f.toArray() : null;
        }
        break;
    }
  }
  e() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    let b = this.workbook._df;
    this.workbook._df = false;
    let c = this.b != null ? new List$1(WorksheetHyperlink.$, 2, this.b.length) : null;
    let d = this.a != null ? new List$1(Tuple$3.$.specialize(WorksheetHyperlink.$, Number_$type, WorksheetRegionAddress.$), 2, this.a.length) : null;
    let e = this.c != null ? new List$1(Tuple$2.$.specialize(WorksheetHyperlink.$, WorksheetRegionAddress.$), 2, this.c.length) : null;
    if (this.a != null) {
      let h = this.a;
      for (let g = 0; g < h.length; g++) {
        let f = h[g];
        let i = this.d._g.indexOf(f);
        if (i >= 0) {
          this.d._g.removeAt(i);
          f._a4();
          f._a3(null);
          d.add(Tuple.b(WorksheetHyperlink.$, Number_$type, WorksheetRegionAddress.$, f, i, f._o));
        }
      }
    }
    if (this.b != null) {
      let l = this.b;
      for (let k = 0; k < l.length; k++) {
        let j = l[k];
        let m = j.c;
        this.d._g.insert(j.d, m);
        m._ax(this.sheet, j.e);
        m._a3(this.d._e, void 0, false);
        c.add(m);
      }
    }
    if (this.c != null) {
      let p = this.c;
      for (let o = 0; o < p.length; o++) {
        let n = p[o];
        let q = n.c;
        let r = q._o;
        q._ax(this.sheet, n.d);
        e.add(Tuple.a(WorksheetHyperlink.$, WorksheetRegionAddress.$, q, r));
      }
    }
    let s = WorksheetHyperlinkCollection._a[2];
    let t = new WorksheetHyperlinkCollection_ShiftChangeContext(1, this.d, d, e, c);
    s.x(t, null, null);
    this.workbook._df = b;
  }
  get workbook() {
    return this.d._e.workbook;
  }
  get sheet() {
    return this.d._e;
  }
  get source() {
    return this.d._e;
  }
}
WorksheetHyperlinkCollection_ShiftChangeContext.$t = markStruct(WorksheetHyperlinkCollection_ShiftChangeContext, 'WorksheetHyperlinkCollection_ShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[WorksheetHyperlink]] instances in a [[Worksheet]].
 * @see [[Worksheet.hyperlinks]]
 */
export class WorksheetHyperlinkCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._g = null;
    /**
     * @hidden
     */
    this._e = null;
    this._g = new List$1(WorksheetHyperlink.$, 0);
    this._e = a;
  }
  static staticInit() {
    WorksheetHyperlinkCollection._a = WorksheetHyperlinkCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._g.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  /**
   * Adds the specified hyperlink to the collection.
   * @param hyperlink The hyperlink to add to the collection.
   * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
   * of the collection.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
   * reference mode of the owning workbook.
   */
  add(hyperlink) {
    this.insert(this.count, hyperlink);
  }
  /**
   * Clears all hyperlinks from the collection.
   */
  clear() {
    let a = this._g.count != 0 ? this._l(16) : null;
    for (let b = this._g.count - 1; b >= 0; b--) {
      this._s(b);
    }
    this._p(a);
  }
  /**
   * Determines whether a hyperlink is in the collection.
   * @param hyperlink The hyperlink to locate in the collection.
   * @return True if the hyperlink is found; False otherwise.
   */
  contains(hyperlink) {
    return this._g.contains(hyperlink);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * Gets an enumerator which can iterator all hyperlinks in the collection.
   */
  getEnumerator() {
    return this._g.getEnumerator();
  }
  /**
   * Inserts the specified hyperlink in the collection.
   * @param index The 0-based index in the collection where the hyperlink should be inserted.
   * @param hyperlink The hyperlink to insert in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than [[count]].
   * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
   * of the collection.
   * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
   * reference mode of the owning workbook.
   */
  insert(index, hyperlink) {
    this._n(index, hyperlink, false);
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    if (a < 0 || this.count < a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    if (b == null) {
      throw new ArgumentNullException(0, "hyperlink");
    }
    if (b.worksheet != null) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_HyperlinkAlreadyOwned"), "hyperlink");
    }
    let d = b.sourceCell;
    if (WorksheetCell.l_op_Inequality(d, null) && d.worksheet != this._e) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_HyperlinkAlreadyOwned"), "hyperlink");
    }
    let e = b.sourceRegion;
    if (e != null && e.worksheet != this._e) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_HyperlinkAlreadyOwned"), "hyperlink");
    }
    if (c) {
      b._ax(this._e, b._o);
    }
    let f = WorksheetHyperlinkCollection._a[0];
    let g = f.b(this._e.workbook, this._e, f.c);
    let h = new WorksheetHyperlinkCollection_CollectionChangeContext(1, this, b, a);
    this._g.add(b);
    b._a3(this._e, void 0, !c);
    f.e(WorksheetHyperlinkCollection_CollectionChangeContext.$, WorksheetHyperlink.$, h, null, b);
    if (g != null) {
      f.d(this._e.workbook, g);
    }
  }
  /**
   * Removes the specified hyperlink from the collection.
   * @param hyperlink The hyperlink to remove from the collection.
   * @return True if the hyperlink was successfully removed from the collection;
   * False if the hyperlink did not exist in the collection.
   */
  remove(hyperlink) {
    let a = this._g.indexOf(hyperlink);
    if (a < 0) {
      return false;
    }
    this._s(a);
    return true;
  }
  /**
   * Removes the hyperlink at the specified index from the collection.
   * @param index The index of the hyperlink to remove from the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    this._s(index);
  }
  /**
   * @hidden
   */
  _o() {
    for (let a of fromEnum(this)) {
      a._ax(this._e, a._o);
    }
  }
  /**
   * @hidden
   */
  _q(a, b) {
    let c = null;
    let d = null;
    for (let e = 0; e < this._g.count; e++) {
      let f = this._g._inner[e];
      f._a4();
      if (b != null && b.isUndoOperation) {
        continue;
      }
      let g = f._o;
      let h = ((() => { let i = a.e(g, false); g = i.p0; return i.ret; })());
      if (!h.f) {
        continue;
      }
      if (h.g) {
        if (c == null) {
          c = new List$1(Tuple$3.$.specialize(WorksheetHyperlink.$, Number_$type, WorksheetRegionAddress.$), 0);
        }
        c.add(Tuple.b(WorksheetHyperlink.$, Number_$type, WorksheetRegionAddress.$, f, e + c.count, f._o));
        this._g.removeAt(e);
        f._a3(null);
        e--;
        continue;
      }
      if (d == null) {
        d = new List$1(Tuple$2.$.specialize(WorksheetHyperlink.$, WorksheetRegionAddress.$), 0);
      }
      d.add(Tuple.a(WorksheetHyperlink.$, WorksheetRegionAddress.$, f, f._o));
      f._az(g);
    }
    if (b != null && b.isUndoOperation) {
      return;
    }
    let i = this._e.workbook._df;
    this._e.workbook._df = false;
    let j = WorksheetHyperlinkCollection._a[2];
    let k = new WorksheetHyperlinkCollection_ShiftChangeContext(1, this, c, d, null);
    j.x(k, null, null);
    this._e.workbook._df = i;
  }
  /**
   * @hidden
   */
  _s(a, b = true) {
    let c = this._g._inner[a];
    let d = WorksheetHyperlinkCollection._a[1];
    let e = new WorksheetHyperlinkCollection_CollectionChangeContext(1, this, c, a);
    let f = d.b(this._e.workbook, this._e, d.c);
    this._g.removeAt(a);
    c._a4();
    c._a3(null, b);
    d.e(WorksheetHyperlinkCollection_CollectionChangeContext.$, WorksheetHyperlink.$, e, c, null);
    if (f != null) {
      d.d(this._e.workbook, f);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetHyperlinkCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192 | 16384) {
    return new ChangeInfo$2(WorksheetHyperlinkCollection_ShiftChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, WorksheetHyperlinkCollection._c(WorksheetHyperlink.$, "Add", 48, (b) => b.a, (b, c) => WorksheetHyperlinkCollection._t(b, c)));
    ChangeInfo.f(a, 1, WorksheetHyperlinkCollection._c(WorksheetHyperlink.$, "Remove", 49, (b) => b.a, (b, c) => WorksheetHyperlinkCollection._u(b, c)));
    ChangeInfo.f(a, 2, WorksheetHyperlinkCollection._d(Base.$, "Shift", 49, (b) => null, (b, c) => b.e()));
    return a;
  }
  /**
   * @hidden
   */
  _l(a) {
    let b = this._e.workbook;
    return b != null && b._cx ? b._go(this._e, a, null) : null;
  }
  /**
   * @hidden
   */
  _p(a) {
    if (a != null) {
      let b = this._e.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _t(a, b) {
    let c = a.b._g.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _u(a, b) {
    a.b._n(a.c, a.a, true);
  }
  /**
   * Gets the number of hyperlinks on the [[Worksheet]].
   */
  get count() {
    return this._g.count;
  }
  /**
   * Gets the hyperlink at the specified index in the collection.
   * The hyperlink at the specified index.
   * @param index The zero-based index of the hyperlink to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
   */
  item(a) {
    if (a < 0 || this.count <= a) {
      throw ExcelUtils.x("index", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    return this._g._inner[a];
  }
}
WorksheetHyperlinkCollection.$t = markType(WorksheetHyperlinkCollection, 'WorksheetHyperlinkCollection', Base.$, [ICollection$1_$type.specialize(WorksheetHyperlink.$)]);
/**
 * @hidden
 */
WorksheetHyperlinkCollection._h = 0;
/**
 * @hidden
 */
WorksheetHyperlinkCollection._j = 1;
/**
 * @hidden
 */
WorksheetHyperlinkCollection._k = 2;
/**
 * @hidden
 */
WorksheetHyperlinkCollection._i = 3;
/**
 * @hidden
 */
WorksheetHyperlinkCollection._a = null;
/**
 * Represents any image on the worksheet except the background image.
 * @see [[Worksheet.imageBackground]]
 */
export class WorksheetImage extends WorksheetShape {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      if (typeCast(Boolean_$type, arguments[0]) !== null) {
        a = 1;
      }
      else if (typeof arguments[0] === 'string') {
        a = 2;
      }
      else if (arguments[0] == null) {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          super(0);
          this._dv = null;
          this._dx = null;
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
          this._dv = null;
          this._dx = null;
        }
        break;
      case 2:
        {
          let image = _rest[0];
          super(0);
          this._dv = null;
          this._dx = null;
          if (image == null) {
            throw new ArgumentNullException(1);
          }
          let b = image.indexOf(',');
          if (!stringStartsWith(image, "data:") || b < 0) {
            throw new ArgumentException(1, "The image doesn't appear to a valid data url");
          }
          let c = image.substr(0, b);
          if (!stringEndsWith(c, ";base64")) {
            throw new ArgumentException(1, "The data url for the image should be a base64 value");
          }
          let d = b - 12;
          if (d <= 0) {
            throw new ArgumentException(1, "The mediatype of the data url for the image should specify an image media type");
          }
          let e = 5;
          let f = c.indexOf(';', e);
          if (f >= 0) {
            d = f - e;
          }
          let g = c.substr(e, d);
          let h = ImageFormat.d(g);
          let i = Convert.fromBase64String(image.substr(b + 1));
          this._dv = new ExcelImage(1, h, new MemoryStream(2, i));
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get image() {
    return this._image;
  }
  /**
   * @hidden
   */
  set image(a) {
    this._image = a;
  }
  /**
   * @hidden
   */
  get preferredFormat() {
    return this._dx;
  }
  /**
   * @hidden
   */
  set preferredFormat(a) {
    this._dx = a;
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitWorksheetImage$i(this, b);
  }
  /**
   * @hidden
   */
  get__a4() {
    return false;
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 75);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, null);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
  /**
   * @hidden
   */
  get _image() {
    return this._dv;
  }
  /**
   * @hidden
   */
  set _image(a) {
    this._dv = a;
  }
}
WorksheetImage.$t = markType(WorksheetImage, 'WorksheetImage', WorksheetShape.$, [IWorksheetImage_$type]);
/**
 * @hidden
 */
export class WorksheetItemPosition extends ValueType {
  constructor(a, ..._rest) {
    super();
    this._g = 0;
    this._h = 0;
    this._k = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this._h = c;
          this._g = e;
          this._k = d;
        }
        break;
    }
  }
  equals1(a) {
    if (typeCast(WorksheetItemPosition.$, a) !== null) {
      return this.equals(a);
    }
    return false;
  }
  getHashCode() {
    return this._h + (this._g) ^ (this._k);
  }
  toString() {
    return stringFormat("Index {0}: Offset {1}, Extent {2}", this._j, this._m, this._i);
  }
  get _l() {
    return this._k + this._g;
  }
  get _i() {
    return this._g;
  }
  get _j() {
    return this._h;
  }
  get _m() {
    return this._k;
  }
  equals(a) {
    return a._h == this._h && a._k == this._k && a._g == this._g;
  }
  static _a(a, b) {
    return a.equals(b);
  }
  static _b(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return WorksheetItemPosition._a(a.value, b.value);
  }
  static _c(a, b) {
    return !(WorksheetItemPosition._a(a, b));
  }
  static _d(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return WorksheetItemPosition._c(a.value, b.value);
  }
}
WorksheetItemPosition.$t = markStruct(WorksheetItemPosition, 'WorksheetItemPosition', ValueType.$, [IEquatable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export class WorksheetMergedCellsRegionCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._e.workbook;
  }
  get sheet() {
    return this.b._e;
  }
  get source() {
    return this.b._e;
  }
}
WorksheetMergedCellsRegionCollection_CollectionChangeContext.$t = markStruct(WorksheetMergedCellsRegionCollection_CollectionChangeContext, 'WorksheetMergedCellsRegionCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetMergedCellsRegionCollection_ShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.c = null;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          if (e != null && e.count > 1) {
            e.aa((g, h) => Base.compareSimple(g.d, h.d));
          }
          this.d = c;
          this.c = d != null ? d.toArray() : null;
          this.b = e != null ? e.toArray() : null;
          this.a = f != null ? f.toArray() : null;
        }
        break;
    }
  }
  e() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    let b = this.workbook._df;
    this.workbook._df = false;
    let c = this.b != null ? new List$1(WorksheetMergedCellsRegion.$, 2, this.b.length) : null;
    let d = this.a != null ? new List$1(Tuple$3.$.specialize(WorksheetMergedCellsRegion.$, Number_$type, WorksheetRegionAddress.$), 0) : null;
    let e = this.c != null ? new List$1(Tuple$2.$.specialize(WorksheetMergedCellsRegion.$, WorksheetRegionAddress.$), 0) : null;
    if (this.a != null) {
      for (let f = this.a.length - 1; f >= 0; f--) {
        let g = this.a[f];
        let h = this.d._j.indexOf(g);
        if (h >= 0) {
          let i = g._h;
          d.insert(0, Tuple.b(WorksheetMergedCellsRegion.$, Number_$type, WorksheetRegionAddress.$, g, h, i));
          this.d._j.removeAt(h);
          g._a9();
          g._a8();
        }
      }
    }
    if (this.b != null) {
      for (let j = 0; j < this.b.length; j++) {
        let k = this.b[j];
        let l = k.c;
        c.add(l);
        this.d._r(k.d, l, true, false);
      }
    }
    if (this.c != null) {
      let o = this.c;
      for (let n = 0; n < o.length; n++) {
        let m = o[n];
        let p = m.c;
        let q = p._h;
        p._al(m.d);
        p._a9();
        this.sheet._conditionalFormats$i._a1(p);
        e.add(Tuple.a(WorksheetMergedCellsRegion.$, WorksheetRegionAddress.$, p, q));
      }
    }
    let r = WorksheetMergedCellsRegionCollection._a[2];
    let s = new WorksheetMergedCellsRegionCollection_ShiftChangeContext(1, this.d, e, d, c);
    r.x(s, null, null);
    this.workbook._df = b;
  }
  get workbook() {
    return this.d._e.workbook;
  }
  get sheet() {
    return this.d._e;
  }
  get source() {
    return this.d._e;
  }
}
WorksheetMergedCellsRegionCollection_ShiftChangeContext.$t = markStruct(WorksheetMergedCellsRegionCollection_ShiftChangeContext, 'WorksheetMergedCellsRegionCollection_ShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[WorksheetMergedCellsRegion]] instances in a [[Worksheet]].
 * @see [[WorksheetMergedCellsRegion]]
 * @see [[Worksheet.mergedCellsRegions]]
 */
export class WorksheetMergedCellsRegionCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._j = null;
    /**
     * @hidden
     */
    this._e = null;
    this._e = a;
    this._j = new List$1(WorksheetMergedCellsRegion.$, 0);
  }
  static staticInit() {
    WorksheetMergedCellsRegionCollection._a = WorksheetMergedCellsRegionCollection._b();
  }
  add() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._add$e.apply(this, arguments);
      case 1: return this._add1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _add$e(a) {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantAddMergedRegion"));
  }
  /**
   * @hidden
   */
  contains(item) {
    return this._j.contains(item);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._j.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  /**
   * @hidden
   */
  remove(item) {
    return this.remove_1(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._j.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * @hidden
   */
  _add1(a, b, c, d) {
    this._y(a, b, c, d);
    let e = a > 0 ? this._e._rows$i._aj(a - 1) : null;
    let f = c < this._e._rows$i.maxCount - 1 ? this._e._rows$i._aj(c + 1) : null;
    let g = e != null && e._b3;
    let h = f != null && f._b6;
    let i = new WorksheetMergedCellsRegion(this._e, a, b, c, d);
    let j = WorksheetMergedCellsRegion._aw;
    WorksheetMergedCellsRegion._aw = i;
    try {
      this._r(this._j.count, i, false);
    }
    finally {
      WorksheetMergedCellsRegion._aw = j;
    }
    i._a9();
    if (!g && e != null && e._b3) {
      e._dx();
    }
    if (!h && f != null && f._b6) {
      f._dx();
    }
    return i;
  }
  /**
   * Clears all merged cell regions from the collection.
   * <p class="body">
   * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
   * All other cells in the region will have a null value. In addition, all cells in the merged region will
   * have the region's cell format when it is removed.
   * </p>
   */
  clear() {
    let a = this._j.count > 1 ? this._p(18) : null;
    for (let b = this._j.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._t(a);
  }
  /**
   * @hidden
   */
  _r(a, b, c, d = true) {
    let e = WorksheetMergedCellsRegionCollection._a[0];
    let f = d ? e.b(this._e.workbook, this._e, e.c) : null;
    let g = new WorksheetMergedCellsRegionCollection_CollectionChangeContext(1, this, b, a);
    b._a5(c);
    this._j.insert(a, b);
    this._e._conditionalFormats$i._a1(b);
    if (d) {
      e.e(WorksheetMergedCellsRegionCollection_CollectionChangeContext.$, WorksheetMergedCellsRegion.$, g, null, b);
      if (f != null) {
        e.d(this._e.workbook, f);
      }
    }
  }
  /**
   * Checks if any part of specified region is already a part of a merged cell region.
   * @param firstRow The index of the first row of the merged cell region.
   * @param firstColumn The index of the first column of the merged cell region.
   * @param lastRow The index of the last row of the merged cell region.
   * @param lastColumn The index of the last row column of the merged cell region.
   * @return True if any part of specified region is a part of merged cell region; False otherwise.
   */
  isOverlappingWithMergedRegion(firstRow, firstColumn, lastRow, lastColumn) {
    if (this._e._mergedCellsRegions$i.count == 0) {
      return false;
    }
    WorksheetRegion._ap(firstRow, lastRow);
    WorksheetRegion._am(firstColumn, lastColumn);
    ExcelUtils.gp(this._e, firstRow, "firstRow");
    ExcelUtils.gp(this._e, lastRow, "lastRow");
    ExcelUtils.gi(this._e, firstColumn, "firstColumn");
    ExcelUtils.gi(this._e, lastColumn, "lastColumn");
    for (let a = firstRow; a <= lastRow; a++) {
      for (let b = firstColumn; b <= lastColumn; b++) {
        if (this._e._cr(a, b) != null) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Removes the specified merged cell region from the collection.
   * <p class="body">
   * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
   * All other cells in the region will have a null value. In addition, all cells in the merged region will
   * have the region's cell format when it is removed.
   * </p>
   * @param region The merged cell region to remove from the collection.
   * @return True if the merged cell region was successfully removed; False if the merged cell region was not
   * in the collection.
   */
  remove_1(region) {
    if (region == null) {
      return false;
    }
    let a = this._j.indexOf(region);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the merged cell region at the specified index from the collection.
   * <p class="body">
   * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
   * All other cells in the region will have a null value. In addition, all cells in the merged region will
   * have the region's cell format when it is removed.
   * </p>
   * @param index The zero-based index of the merged cell region in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_CollectionIndex"));
    }
    let a = this._j._inner[index];
    let b = WorksheetMergedCellsRegionCollection._a[1];
    let c = new WorksheetMergedCellsRegionCollection_CollectionChangeContext(1, this, a, index);
    let d = b.b(this._e.workbook, this._e, b.c);
    this._j.removeAt(index);
    a._a9();
    a._a8();
    b.e(WorksheetMergedCellsRegionCollection_CollectionChangeContext.$, WorksheetMergedCellsRegion.$, c, a, null);
    if (d != null) {
      b.d(this._e.workbook, d);
    }
  }
  /**
   * @hidden
   */
  _s(a, b, c) {
    if (b != null && b.isUndoOperation) {
      return;
    }
    if (c.count == 0) {
      return;
    }
    let d = new List$1(Tuple$2.$.specialize(WorksheetMergedCellsRegion.$, WorksheetRegionAddress.$), 0);
    let e = new List$1(Tuple$3.$.specialize(WorksheetMergedCellsRegion.$, Number_$type, WorksheetRegionAddress.$), 0);
    let f = a.h;
    let g = a.x;
    let h = new List$1(WorksheetMergedCellsRegion.$, 0);
    for (let i = 0; i < c.count; i++) {
      let j = c._inner[i];
      let k = j._h;
      let l = (WorksheetRegionAddress._r(g, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && j.firstColumn >= g.value._w && j.firstRow >= g.value._ac && j.lastColumn <= g.value._x && j.lastRow <= g.value._ae);
      if (l) {
        e.add(Tuple.b(WorksheetMergedCellsRegion.$, Number_$type, WorksheetRegionAddress.$, j, this._j.indexOf(j), k));
      }
      else {
        h.add(j);
      }
    }
    let m = this._e.workbook._df;
    if (e.count > 0) {
      this._e.workbook._df = true;
    }
    for (let n of fromEnum(e)) {
      this.remove_1(n.c);
    }
    for (let o = 0; o < h.count; o++) {
      let p = h._inner[o];
      let q = p._h;
      let r = p._d(a, false);
      if (r.f) {
        d.add(Tuple.a(WorksheetMergedCellsRegion.$, WorksheetRegionAddress.$, p, q));
      }
    }
    if (d.count > 0 || e.count > 0) {
      this._e.workbook._df = false;
      let s = WorksheetMergedCellsRegionCollection._a[2];
      let t = new WorksheetMergedCellsRegionCollection_ShiftChangeContext(1, this, d, e, null);
      s.x(t, null, null);
      this._e.workbook._df = m;
    }
  }
  /**
   * @hidden
   */
  _x(a, b) {
    for (let c of fromEnum(this)) {
      c._an(a, b);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetMergedCellsRegionCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(WorksheetMergedCellsRegionCollection_ShiftChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, WorksheetMergedCellsRegionCollection._c(WorksheetMergedCellsRegion.$, "Add", 50, (b) => b.a, (b, c) => WorksheetMergedCellsRegionCollection._v(b, c)));
    ChangeInfo.f(a, 1, WorksheetMergedCellsRegionCollection._c(WorksheetMergedCellsRegion.$, "Remove", 51, (b) => b.a, (b, c) => WorksheetMergedCellsRegionCollection._w(b, c)));
    ChangeInfo.f(a, 2, WorksheetMergedCellsRegionCollection._d(Base.$, "Shift", 50, (b) => null, (b, c) => b.e()));
    return a;
  }
  /**
   * @hidden
   */
  _p(a) {
    let b = this._e.workbook;
    return b != null && b._cx ? b._go(this._e, a, null) : null;
  }
  /**
   * @hidden
   */
  _t(a) {
    if (a != null) {
      let b = this._e.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _v(a, b) {
    let c = a.b._j.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _w(a, b) {
    a.b._r(a.c, a.a, true);
  }
  /**
   * @hidden
   */
  _y(a, b, c, d) {
    if (this._e._d5) {
      for (let e of fromEnum(this._e._dataTables$i)) {
        let f = e.cellsInTable;
        if (f._t(a, b, c, d)) {
          let g = false;
          if (a == f.firstRow && c == f.firstRow) {
            if (b < f.firstColumn || f.lastColumn < d) {
              g = true;
            }
          }
          else if (b == f.firstColumn && d == f.firstColumn) {
            if (a < f.firstRow || f.lastRow < c) {
              g = true;
            }
          }
          else {
            g = true;
          }
          if (g) {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantOverlapDataTableInterior"));
          }
        }
      }
    }
    for (let h = a; h <= c; h++) {
      let i = this._e._rows$i.item(h);
      for (let j = b; j <= d; j++) {
        if (i.getCellAssociatedTable(j) != null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_MergedCellsAppliedInTable"));
        }
        if (i._bl(j) != null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LER_Exception_MergedRegionsOverlap"));
        }
        if (typeCast(ArrayFormula.$, i._c6(j)) !== null) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CantOverlapArrayFormula"));
        }
      }
    }
  }
  /**
   * Gets the number of merged cell regions in the collection.
   * The number of merged cell regions in the collection.
   */
  get count() {
    return this._j.count;
  }
  /**
   * Gets the merged cell region at the specified index.
   * The merged cell region at the specified index.
   * @param index The zero-based index of the merged cell region to get.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
   * equal to [[count]].
   */
  item(a) {
    return this._j._inner[a];
  }
}
WorksheetMergedCellsRegionCollection.$t = markType(WorksheetMergedCellsRegionCollection, 'WorksheetMergedCellsRegionCollection', Base.$, [ICollection$1_$type.specialize(WorksheetMergedCellsRegion.$)]);
/**
 * @hidden
 */
WorksheetMergedCellsRegionCollection._k = 0;
/**
 * @hidden
 */
WorksheetMergedCellsRegionCollection._n = 1;
/**
 * @hidden
 */
WorksheetMergedCellsRegionCollection._o = 2;
/**
 * @hidden
 */
WorksheetMergedCellsRegionCollection._m = 3;
/**
 * @hidden
 */
WorksheetMergedCellsRegionCollection._a = null;
/**
 * @hidden
 */
export class WorksheetRegion_HorizontalAddressSorter extends Base {
  constructor() {
    super();
  }
  static _b(a, b) {
    return a._w - b._w;
  }
  static _c(a, b) {
    return a._x - b._x;
  }
  compare(a, b) {
    let c = WorksheetRegion_HorizontalAddressSorter._b(a, b);
    if (c != 0) {
      return c;
    }
    c = WorksheetRegion_VerticalAddressSorter._b(a, b);
    if (c != 0) {
      return c;
    }
    c = WorksheetRegion_HorizontalAddressSorter._c(a, b);
    if (c != 0) {
      return c;
    }
    return WorksheetRegion_VerticalAddressSorter._c(a, b);
  }
}
WorksheetRegion_HorizontalAddressSorter.$t = markType(WorksheetRegion_HorizontalAddressSorter, 'WorksheetRegion_HorizontalAddressSorter', Base.$, [IComparer$1_$type.specialize(WorksheetRegionAddress.$)]);
WorksheetRegion_HorizontalAddressSorter._a = new WorksheetRegion_HorizontalAddressSorter();
/**
 * @hidden
 */
export class WorksheetRegion_HorizontalWeakSorter extends Base {
  constructor() {
    super();
  }
  compare(a, b) {
    let c = ExcelUtils.dy(a);
    let d = ExcelUtils.dy(b);
    if (c == null && d == null) {
      return 0;
    }
    if (c == null) {
      return -1;
    }
    if (d == null) {
      return 1;
    }
    return WorksheetRegion_HorizontalSorter._a.compare(c, d);
  }
}
WorksheetRegion_HorizontalWeakSorter.$t = markType(WorksheetRegion_HorizontalWeakSorter, 'WorksheetRegion_HorizontalWeakSorter', Base.$, [IComparer$1_$type.specialize(WeakReference.$)]);
WorksheetRegion_HorizontalWeakSorter._a = new WorksheetRegion_HorizontalWeakSorter();
/**
 * @hidden
 */
export class WorksheetRegion_VerticalSorter extends Base {
  constructor() {
    super();
  }
  compare(a, b) {
    return WorksheetRegion_VerticalAddressSorter._a.compare(a._h, b._h);
  }
}
WorksheetRegion_VerticalSorter.$t = markType(WorksheetRegion_VerticalSorter, 'WorksheetRegion_VerticalSorter', Base.$, [IComparer$1_$type.specialize(WorksheetRegion.$)]);
WorksheetRegion_VerticalSorter._a = new WorksheetRegion_VerticalSorter();
/**
 * @hidden
 */
export class WorksheetRegion_VerticalAddressSorter extends Base {
  constructor() {
    super();
  }
  static _b(a, b) {
    return a._ac - b._ac;
  }
  static _c(a, b) {
    return a._ae - b._ae;
  }
  compare(a, b) {
    let c = WorksheetRegion_VerticalAddressSorter._b(a, b);
    if (c != 0) {
      return c;
    }
    return WorksheetRegion_HorizontalAddressSorter._b(a, b);
  }
}
WorksheetRegion_VerticalAddressSorter.$t = markType(WorksheetRegion_VerticalAddressSorter, 'WorksheetRegion_VerticalAddressSorter', Base.$, [IComparer$1_$type.specialize(WorksheetRegionAddress.$)]);
WorksheetRegion_VerticalAddressSorter._a = new WorksheetRegion_VerticalAddressSorter();
/**
 * @hidden
 */
export class RegionShiftComparer$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this._a = false;
    this._b = false;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._b = !a.o;
    this._a = a.w < 1;
  }
  compare(a, b) {
    let c = this._b ? a.firstColumn : a.firstRow;
    let d = this._b ? b.firstColumn : b.firstRow;
    let e = Base.compareSimple(c, d);
    return this._a ? e : -e;
  }
}
RegionShiftComparer$1.$t = markType(RegionShiftComparer$1, 'RegionShiftComparer$1', Base.$, [IComparer$1_$type.specialize(0)]);
/**
 * @hidden
 */
export class MutableWorksheetRegionAddress extends Base {
  constructor() {
    super();
    this.d = 0;
    this.h = 0;
    this.e = 0;
    this.i = 0;
    this.n();
  }
  get f() {
    return this.d;
  }
  get j() {
    return this.h;
  }
  get b() {
    return this.d < 0;
  }
  get c() {
    return this.d == this.e && this.h == this.i;
  }
  get g() {
    return this.e;
  }
  get k() {
    return this.i;
  }
  n() {
    this.d = this.e = -1;
    this.h = this.e = -1;
  }
  a() {
    if (this.b) {
      return WorksheetRegionAddress._b;
    }
    else {
      return new WorksheetRegionAddress(1, this.h, this.i, this.d, this.e);
    }
  }
  toString() {
    return this.m(1, true);
  }
  m(a, b) {
    let c = (((d, e, f, g, h) => CellAddress.u(d, e, void 0, g, h, void 0, void 0, void 0, f))(this.h, this.d, a, b, b));
    if (this.c) {
      return c;
    }
    return stringFormat("{0}{1}{2}", c, ":", (((i, j, k, l, m) => CellAddress.u(i, j, void 0, l, m, void 0, void 0, void 0, k))(this.i, this.e, a, b, b)));
  }
  q(n, o) {
    if (this.b) {
      this.h = this.i = n;
      this.d = this.e = o;
    }
    else {
      if (n < this.h) {
        this.h = n;
      }
      else if (n > this.i) {
        this.i = n;
      }
      if (o < this.d) {
        this.d = o;
      }
      else if (o > this.e) {
        this.e = o;
      }
    }
  }
  o(n) {
    this.q(n.o, n.m);
  }
  p(n) {
    if (this.b) {
      this.d = n._w;
      this.h = n._ac;
      this.e = n._x;
      this.i = n._ae;
    }
    else {
      this.d = Math.min(this.d, n._w);
      this.h = Math.min(this.h, n._ac);
      this.e = Math.max(this.e, n._x);
      this.i = Math.max(this.i, n._ae);
    }
  }
}
MutableWorksheetRegionAddress.$t = markType(MutableWorksheetRegionAddress, 'MutableWorksheetRegionAddress');
/**
 * @hidden
 */
export class CellFormatContext extends Base {
  constructor(a, b, c) {
    super();
    this.a = null;
    this.b = null;
    this.d = 0;
    this.d = a;
    this.b = b;
    this.a = c;
  }
  c(a) {
    if (this.b == null || this.a == null) {
      return a._bc(this.d);
    }
    return a._be(this.d, this.b, this.a, true);
  }
  get e() {
    return this.d;
  }
}
CellFormatContext.$t = markType(CellFormatContext, 'CellFormatContext');
/**
 * @hidden
 */
export class WorksheetRowOwnedCellFormatProxy extends WorksheetCellFormatProxy {
  constructor(a, b) {
    super(1, a, b);
  }
  get__l() {
    return WorksheetRowOwnedCellFormatProxy._br;
  }
  get _l() {
    return this.get__l();
  }
  get__q() {
    return 61;
  }
  get _q() {
    return this.get__q();
  }
  get__v() {
    let a = typeCast(WorksheetRow.$, this._s);
    if (a != null) {
      return a.worksheet;
    }
    return null;
  }
  get _v() {
    return this.get__v();
  }
}
WorksheetRowOwnedCellFormatProxy.$t = markType(WorksheetRowOwnedCellFormatProxy, 'WorksheetRowOwnedCellFormatProxy', WorksheetCellFormatProxy.$);
WorksheetRowOwnedCellFormatProxy._br = WorksheetCellFormatProxy._m(61, 8 | 4);
/**
 * @hidden
 */
export class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove extends LoadOnDemandTree_ChangeHistoryItemRemove$1 {
  constructor(a, b) {
    super(WorksheetRow.$, a, b);
  }
  d(a, b, c, d) {
    return c;
  }
  e(a, b, c) {
    return b * this.c;
  }
}
WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove.$t = markType(WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove, 'WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove', LoadOnDemandTree_ChangeHistoryItemRemove$1.$.specialize(WorksheetRow.$));
/**
 * @hidden
 */
export class WorksheetRowCollection_InsertRemoveOperationWrapper extends Base {
  constructor(a, b, c, d, e) {
    super();
    this.a = null;
    this.c = new WorksheetRowCollection_CollectionChangeContext();
    this.f = null;
    this.d = false;
    this.e = false;
    this.b = null;
    this.a = a;
    this.c = b;
    this.f = null;
    this.d = c;
    this.e = d;
    this.b = e;
  }
  get g() {
    return this.f;
  }
  h() {
    let a = this.c.sheet;
    a.sortSettings._bm();
    a.filterSettings._bo();
    a._conditionalFormats$i._a7();
  }
  get count() {
    return this.c.d;
  }
  get index() {
    return this.c.e;
  }
  get shiftsColumns() {
    return false;
  }
  get shiftsRows() {
    return true;
  }
  get isRemoveOperation() {
    return !this.d;
  }
  get isUndoOperation() {
    return this.e;
  }
  get performsShift() {
    return true;
  }
  get worksheet() {
    return this.c.sheet;
  }
  onBeforeShift(a) {
    let b = this.c.sheet;
    this.f = this.a.b(this.c.workbook, b, null);
    b.sortSettings._bl(false);
    b.filterSettings._bn();
    b._conditionalFormats$i._a6();
    b._hz(false);
  }
  performShift(a) {
    let b = this.c.workbook;
    let c = b._df;
    b._df = false;
    if (this.b != null) {
      this.b._de();
    }
    let d = this.c.b;
    if (this.d) {
      d._aa(this.index, this.count);
    }
    else {
      d._ad(this.index, this.count);
    }
    b._df = c;
    return true;
  }
}
WorksheetRowCollection_InsertRemoveOperationWrapper.$t = markType(WorksheetRowCollection_InsertRemoveOperationWrapper, 'WorksheetRowCollection_InsertRemoveOperationWrapper', Base.$, [ICellShiftOperationOverride_$type]);
/**
 * @hidden
 */
export let IWorksheetShapeVisitor$2_$type = new Type(null, 'IWorksheetShapeVisitor$2');
/**
 * @hidden
 */
export class WorksheetShapeVisitor$2 extends Base {
  constructor($tArg, $tResult) {
    super();
    this.$tArg = null;
    this.$tResult = null;
    this.$tArg = $tArg;
    this.$tResult = $tResult;
    this.$type = this.$type.specialize(this.$tArg, this.$tResult);
  }
  visitDiamondShape(value, argument) {
    return this._visitDiamondShape$i.apply(this, arguments);
  }
  _visitDiamondShape$i(a, b) {
    return this.c(a, b);
  }
  visitEllipseShape(value, argument) {
    return this._visitEllipseShape$i.apply(this, arguments);
  }
  _visitEllipseShape$i(a, b) {
    return this.c(a, b);
  }
  visitHeartShape(value, argument) {
    return this._visitHeartShape$i.apply(this, arguments);
  }
  _visitHeartShape$i(a, b) {
    return this.c(a, b);
  }
  visitIrregularSeal1Shape(value, argument) {
    return this._visitIrregularSeal1Shape$i.apply(this, arguments);
  }
  _visitIrregularSeal1Shape$i(a, b) {
    return this.c(a, b);
  }
  visitIrregularSeal2Shape(value, argument) {
    return this._visitIrregularSeal2Shape$i.apply(this, arguments);
  }
  _visitIrregularSeal2Shape$i(a, b) {
    return this.c(a, b);
  }
  visitLightningBoltShape(value, argument) {
    return this._visitLightningBoltShape$i.apply(this, arguments);
  }
  _visitLightningBoltShape$i(a, b) {
    return this.c(a, b);
  }
  visitLineShape(value, argument) {
    return this._visitLineShape$i.apply(this, arguments);
  }
  _visitLineShape$i(a, b) {
    return this.b(a, b);
  }
  visitPentagonShape(value, argument) {
    return this._visitPentagonShape$i.apply(this, arguments);
  }
  _visitPentagonShape$i(a, b) {
    return this.c(a, b);
  }
  visitRectangleShape(value, argument) {
    return this._visitRectangleShape$i.apply(this, arguments);
  }
  _visitRectangleShape$i(a, b) {
    return this.c(a, b);
  }
  visitRightTriangleShape(value, argument) {
    return this._visitRightTriangleShape$i.apply(this, arguments);
  }
  _visitRightTriangleShape$i(a, b) {
    return this.c(a, b);
  }
  visitStraightConnector1Shape(value, argument) {
    return this._visitStraightConnector1Shape$i.apply(this, arguments);
  }
  _visitStraightConnector1Shape$i(a, b) {
    return this.b(a, b);
  }
  visitUnknownShape(value, argument) {
    return this._visitUnknownShape$i.apply(this, arguments);
  }
  _visitUnknownShape$i(a, b) {
    return this.c(a, b);
  }
  visitWorksheetCellComment(value, argument) {
    return this._visitWorksheetCellComment$i.apply(this, arguments);
  }
  _visitWorksheetCellComment$i(a, b) {
    return this.b(a, b);
  }
  visitWorksheetChart(value, argument) {
    return this._visitWorksheetChart$i.apply(this, arguments);
  }
  _visitWorksheetChart$i(a, b) {
    return this.b(a, b);
  }
  visitWorksheetImage(value, argument) {
    return this._visitWorksheetImage$i.apply(this, arguments);
  }
  _visitWorksheetImage$i(a, b) {
    return this.b(a, b);
  }
  visitWorksheetShapeGroup(value, argument) {
    return this._visitWorksheetShapeGroup$i.apply(this, arguments);
  }
  _visitWorksheetShapeGroup$i(a, b) {
    return this.b(a, b);
  }
  a(a, b) {
    return Type.getDefaultValue(this.$tResult);
  }
  b(a, b) {
    return this.a(a, b);
  }
  c(a, b) {
    return this.b(a, b);
  }
}
WorksheetShapeVisitor$2.$t = markType(WorksheetShapeVisitor$2, 'WorksheetShapeVisitor$2', Base.$, [IWorksheetShapeVisitor$2_$type.specialize(0, 1)]);
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export class WorksheetShapeGroup extends WorksheetShapeGroupBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let loading = _rest[0];
          super(1, loading);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
}
WorksheetShapeGroup.$t = markType(WorksheetShapeGroup, 'WorksheetShapeGroup', WorksheetShapeGroupBase.$);
/**
 * @hidden
 */
export class WorksheetShapeCollection_AxisShiftInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.c = d;
          this.b = e;
        }
        break;
    }
  }
}
WorksheetShapeCollection_AxisShiftInfo.$t = markStruct(WorksheetShapeCollection_AxisShiftInfo, 'WorksheetShapeCollection_AxisShiftInfo');
/**
 * @hidden
 */
export class WorksheetShapeCollection_SeriesShiftInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = null;
    this.d = null;
    this.e = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          this.a = c;
          this.c = d;
          this.b = e;
          this.d = f;
          this.e = g;
        }
        break;
    }
  }
}
WorksheetShapeCollection_SeriesShiftInfo.$t = markStruct(WorksheetShapeCollection_SeriesShiftInfo, 'WorksheetShapeCollection_SeriesShiftInfo');
/**
 * Represents a sparkline cell
 */
export class Sparkline extends Base {
  constructor() {
    super();
    this._e = null;
    this._h = new WorksheetCellAddress();
    this._d = null;
    this._l = new WorksheetRegionAddress();
    this._n = null;
  }
  /**
   * The region containing the data for the sparkline (read-only)
   * The data region if it is located on a worksheet within the same workbook, otherwise null.
   */
  get dataRegion() {
    if (this._d != null && this._l._n) {
      return this._d._cw(this._l);
    }
    return null;
  }
  /**
   * A striing that describes the region containing the data for the sparkline (read-only)
   * Should always be non-null.
   */
  get dataRegionName() {
    return this._n;
  }
  /**
   * The cell location of the sparkline (read-only)
   */
  get location() {
    if (this._e != null && this._h.e) {
      return this._e._cx(this._h.o, this._h.m, this._h.o, this._h.m);
    }
    return null;
  }
  /**
   * @hidden
   */
  get _m() {
    return this._l;
  }
  /**
   * @hidden
   */
  get _f() {
    return this._d;
  }
  /**
   * @hidden
   */
  get _i() {
    return this._h;
  }
  /**
   * @hidden
   */
  get _g() {
    return this._e;
  }
  /**
   * @hidden
   */
  _a() {
    let a = new Sparkline();
    a._l = this._l;
    a._n = this._n;
    a._d = this._d;
    a._h = this._h;
    a._e = this._e;
    return a;
  }
  /**
   * @hidden
   */
  _p(a, b, c) {
    this._e = a != null ? a.worksheet : null;
    this._h = a != null ? new WorksheetCellAddress(1, a._h._ac, a._h._w) : WorksheetCellAddress.b;
    this._d = b != null ? b.worksheet : null;
    this._l = b != null ? b._h : WorksheetRegionAddress._b;
    this._n = c;
  }
  /**
   * @hidden
   */
  _b(a) {
    let b = this._a();
    b._l = a;
    let c = b.dataRegion;
    b._n = c != null ? c._toString2(1, true, false, false) : null;
    return b;
  }
  /**
   * @hidden
   */
  _c(a, b) {
    let c = this._a();
    c._h = new WorksheetCellAddress(1, a, b);
    return c;
  }
}
Sparkline.$t = markType(Sparkline, 'Sparkline');
/**
 * @hidden
 */
export class SparklineCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.e = 0;
    this.b = null;
    this.a = null;
    this.f = 0;
    this.d = 0;
    this.h = null;
    this.g = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this.c = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.e = e;
          this.a = d;
          this.f = d.location.firstRow;
          this.d = d.location._v;
          this.h = d.dataRegionName;
          this.g = d.dataRegion != null ? Nullable$1.toNullable(WorksheetRegionAddress.$, d.dataRegion._h) : Nullable$1.toNullable(WorksheetRegionAddress.$, null);
          this.c = d.dataRegion.worksheet;
        }
        break;
    }
  }
  get workbook() {
    return this.b._h;
  }
  get sheet() {
    return this.b._i;
  }
  get source() {
    return this.b._g;
  }
}
SparklineCollection_CollectionChangeContext.$t = markStruct(SparklineCollection_CollectionChangeContext, 'SparklineCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[Sparkline]]s exposed from a [[SparklineGroup]]
 */
export class SparklineCollection extends Base {
  constructor(a, ..._rest) {
    super();
    /**
     * @hidden
     */
    this._g = null;
    this._l = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          this._g = c;
          this._l = new List$1(Sparkline.$, 0);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this._g = c;
          this._l = new List$1(Sparkline.$, 1, d);
        }
        break;
    }
  }
  static staticInit() {
    SparklineCollection._a = SparklineCollection._b();
  }
  /**
   * Returns the total number of items in the collection.
   */
  get count() {
    return this._l.count;
  }
  /**
   * Indexer
   * @param index The zer-based index of an item
   * @return The item at the specified index
   * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
   */
  item(a, b) {
    if (arguments.length === 2) {
      this._l._inner[a] = b;
      return b;
    }
    else {
      return this._l._inner[a];
    }
  }
  /**
   * @hidden
   */
  get _h() {
    return this._g.workbook;
  }
  /**
   * @hidden
   */
  get _i() {
    return this._g.worksheet;
  }
  /**
   * Adds a new [[SparklineGroup]] with no sparklines
   * @param row The zero-based row of the sparkline cell.
   * @param column The zero-based column of the sparkline cell.
   * @param dataRegion A string describing the data region.
   * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dataRegion. If null it defaults to the workbook's mode.
   * @return The added sparkine
   */
  add(row, column, dataRegion, cellReferenceMode) {
    if (arguments[3] !== void 0) {
      arguments[3] = wrapNullable(CellReferenceMode_$type, arguments[3]);
    }
    return this._add$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _add$i(a, b, c, d = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    let e = this._i;
    DocCoreUtils.au(c, "dataRegion");
    if (nullableNotEquals(d, null)) {
      ExcelUtils.gm(CellReferenceMode_$type, d.value, "cellReferenceMode");
    }
    let f = !nullableIsNull(d) ? d.value : e.workbook.cellReferenceMode;
    let g = null;
    let h = new WorksheetRegionAddress();
    let i = Worksheet._fh;
    try {
      i.clear();
      let j = ExcelUtils.u(c, e, a, b, f, "dataRange", "LE_InvalidRegion", i);
      if (j == null || i.count != 1 || !i._inner[0].d._n) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidRegion"), "dataRegion");
      }
      if (i._inner[0].c != null) {
        g = i._inner[0].c._getRegion(i._inner[0].d._ah(false, false, 2, f));
      }
      h = i._inner[0].d;
    }
    finally {
      i.clear();
    }
    let k = h._af > 0 && h._ad > 0;
    if (k) {
      k = h._af == 1 || h._ad == 1;
    }
    if (!k) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_LocationOrDataAreaInvalid"));
    }
    let l = e._cx(a, b, a, b);
    let m = new Sparkline();
    if (!this._g._au) {
      m._p(l, g, c);
      this._l.add(m);
      return m;
    }
    this._s(this.count, m, l, g, c);
    return m;
  }
  /**
   * Clears all items from the collection
   */
  clear() {
    if (!this._g._au) {
      this._l.clear();
      return;
    }
    let a = this._l.count > 1 ? this._r(67) : null;
    for (let b = this._l.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._u(a);
  }
  /**
   * Returns true if the collection contains the item
   * @param sparkline The sparkline to check
   */
  contains(sparkline) {
    return this._l.contains(sparkline);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return getEnumerator(this._l);
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return getEnumerator(this._l);
  }
  /**
   * Gets the index of the item in the collection
   * @param sparkline
   * @return The index or -1 if the item is not in the collection
   */
  indexOf(sparkline) {
    return this._l.indexOf(sparkline);
  }
  /**
   * Removes a sparkline from the collection
   * @param sparkline The sparkline to remove.
   * @return true if successful, otherwise false
   */
  remove(sparkline) {
    let a = this.indexOf(sparkline);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes a sparkline from the collection
   * @param index The zero-based index of the sparkline to remove.
   * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
   */
  removeAt(index) {
    if (!this._g._au) {
      this._l.removeAt(index);
      return;
    }
    let a = this._l._inner[index];
    let b = SparklineCollection._a[1];
    let c = new SparklineCollection_CollectionChangeContext(1, this, a, index);
    let d = b.b(this._h, this._i, b.c);
    this._l.removeAt(index);
    b.e(SparklineCollection_CollectionChangeContext.$, Number_$type, c, index, -1);
    if (d != null) {
      b.d(this._h, d);
    }
    this._g._b1();
  }
  /**
   * @hidden
   */
  _s(a, b, c, d, e, f = true) {
    b._p(c, d, e);
    if (!this._g._au) {
      this._l.insert(a, b);
      return;
    }
    let g = SparklineCollection._a[0];
    let h = new SparklineCollection_CollectionChangeContext(1, this, b, a);
    let i = g.b(this._h, this._i, g.c);
    this._l.insert(a, b);
    this._i._sparklineGroups$i._af(b);
    g.e(SparklineCollection_CollectionChangeContext.$, Number_$type, h, -1, a);
    if (i != null) {
      g.d(this._h, i);
    }
    if (f) {
      this._g._b1();
    }
  }
  /**
   * @hidden
   */
  _c(a) {
    let b = this._l.toArray();
    this._l.clear();
    if (a != null) {
      this._l.o(a);
    }
    return b;
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(SparklineCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, SparklineCollection._d(Number_$type, "Add", 66, (b) => b.e, (b, c) => SparklineCollection._w(b, c)));
    ChangeInfo.f(a, 1, SparklineCollection._d(Number_$type, "Remove", 67, (b) => b.e, (b, c) => SparklineCollection._x(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _r(a) {
    let b = this._i.workbook;
    return b != null && b._cx ? b._go(this._i, a, null) : null;
  }
  /**
   * @hidden
   */
  _u(a) {
    if (a != null) {
      let b = this._i.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _w(a, b) {
    a.b.remove(a.a);
  }
  /**
   * @hidden
   */
  static _x(a, b) {
    let c = a.b._i._cx(a.f, a.d, a.f, a.d);
    let d = WorksheetRegionAddress._r(a.g, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? a.c._cw(a.g.value) : null;
    a.b._s(a.e, a.a, c, d, a.h, true);
  }
}
SparklineCollection.$t = markType(SparklineCollection, 'SparklineCollection', Base.$, [IEnumerable$1_$type.specialize(Sparkline.$)]);
/**
 * @hidden
 */
SparklineCollection._m = 0;
/**
 * @hidden
 */
SparklineCollection._q = 1;
/**
 * @hidden
 */
SparklineCollection._p = 2;
/**
 * @hidden
 */
SparklineCollection._a = null;
/**
 * @hidden
 */
export class SparklineGroup_RegionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.b = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
          this.c = c.dateRangeFormula != null ? c.dateRangeFormula._toString1(1) : null;
          if (this.c != null && this.c.length > 0 && this.c.charAt(0) == '=') {
            this.c = this.c.substr(1);
          }
        }
        break;
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a.worksheet;
  }
  get source() {
    return this.a;
  }
}
SparklineGroup_RegionChangeContext.$t = markStruct(SparklineGroup_RegionChangeContext, 'SparklineGroup_RegionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents a group of [[Sparkline]]s
 */
export class SparklineGroup extends Base {
  constructor(a, ..._rest) {
    super();
    this._ai = null;
    this._m = null;
    this._y = null;
    this._x = null;
    this._r = null;
    this._w = null;
    this._s = null;
    this._u = null;
    this._t = null;
    this._v = null;
    this._ah = null;
    this._am = WorksheetRegionAddress._b;
    this._e = null;
    this._a2 = 0;
    this._a3 = 0;
    this._a1 = 0;
    this._p = 0;
    this._k = 0;
    this._g = 0;
    this._h = 0;
    this._by = Nullable$1.toNullable(Guid.$, null);
    this._o = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          this._ai = c;
          this._y = new WorkbookColorInfo(Color.u(255, 55, 96, 146));
          this._r = new WorkbookColorInfo(Color.u(255, 0, 0, 0));
          this._s = this._t = this._u = this._v = this._w = this._x = new WorkbookColorInfo(Color.u(255, 208, 0, 0));
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c];
          {
            let g = e[0];
            this._ai = g;
            this._y = new WorkbookColorInfo(Color.u(255, 55, 96, 146));
            this._r = new WorkbookColorInfo(Color.u(255, 0, 0, 0));
            this._s = this._t = this._u = this._v = this._w = this._x = new WorkbookColorInfo(Color.u(255, 208, 0, 0));
          }
          this._p = d;
        }
        break;
    }
  }
  static staticInit() {
    SparklineGroup._a = SparklineGroup._b();
  }
  /**
   * Determines the color of the axis
   * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[dateAxis]]
   */
  get colorAxis() {
    return this._r;
  }
  /**
   * Determines the color of the axis
   * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[dateAxis]]
   */
  set colorAxis(a) {
    let b = this._b7(0, a, this._r);
    this._r = b.p2;
  }
  /**
   * Determines the color of the first point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[firstPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[firstPoint]]
   */
  get colorFirstPoint() {
    return this._s;
  }
  /**
   * Determines the color of the first point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[firstPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[firstPoint]]
   */
  set colorFirstPoint(a) {
    let b = this._b7(1, a, this._s);
    this._s = b.p2;
  }
  /**
   * Determines the color of the high point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[highPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[highPoint]]
   */
  get colorHighPoint() {
    return this._t;
  }
  /**
   * Determines the color of the high point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[highPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[highPoint]]
   */
  set colorHighPoint(a) {
    let b = this._b7(2, a, this._t);
    this._t = b.p2;
  }
  /**
   * Determines the color of the last point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[lastPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[lastPoint]]
   */
  get colorLastPoint() {
    return this._u;
  }
  /**
   * Determines the color of the last point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[lastPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[lastPoint]]
   */
  set colorLastPoint(a) {
    let b = this._b7(3, a, this._u);
    this._u = b.p2;
  }
  /**
   * Determines the color of the low point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[lowPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[lowPoint]]
   */
  get colorLowPoint() {
    return this._v;
  }
  /**
   * Determines the color of the low point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[lowPoint]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[lowPoint]]
   */
  set colorLowPoint(a) {
    let b = this._b7(4, a, this._v);
    this._v = b.p2;
  }
  /**
   * Determines the color of the markers
   * <para class="note"><b>Note:</b> this property is ignored unless the [[markers]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[markers]]
   */
  get colorMarkers() {
    return this._w;
  }
  /**
   * Determines the color of the markers
   * <para class="note"><b>Note:</b> this property is ignored unless the [[markers]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[markers]]
   */
  set colorMarkers(a) {
    let b = this._b7(5, a, this._w);
    this._w = b.p2;
  }
  /**
   * Determines the color of the negative point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[negativePoints]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[negativePoints]]
   */
  get colorNegativePoints() {
    return this._x;
  }
  /**
   * Determines the color of the negative point
   * <para class="note"><b>Note:</b> this property is ignored unless the [[negativePoints]] property is explicity set to true.</para>
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   * @see [[negativePoints]]
   */
  set colorNegativePoints(a) {
    let b = this._b7(6, a, this._x);
    this._x = b.p2;
  }
  /**
   * Determines the default color for the series
   * The color to use for the series.
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   */
  get colorSeries() {
    return this._y;
  }
  /**
   * Determines the default color for the series
   * The color to use for the series.
   * @throws [[ArgumentNullException]] Color can't be set to null.
   * @throws [[ArgumentException]] Color can't be set to 'Auto'.
   */
  set colorSeries(a) {
    let b = this._b7(7, a, this._y);
    this._y = b.p2;
  }
  /**
   * Determines whether to use a date axis
   * @see [[colorAxis]]
   * @see [[dateRange]]
   * @see [[setDateRange]]
   */
  get dateAxis() {
    return this._as(1);
  }
  /**
   * Determines whether to use a date axis
   * @see [[colorAxis]]
   * @see [[dateRange]]
   * @see [[setDateRange]]
   */
  set dateAxis(a) {
    this._b6(8, 1, a);
  }
  /**
   * The date range (read-only)
   * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
   * @see [[dateAxis]]
   * @see [[dateRangeFormula]]
   * @see [[setDateRange]]
   */
  get dateRange() {
    if (this._ah != null && this._am._n) {
      return this._ah._cw(this._am);
    }
    return null;
  }
  /**
   * The date range formula (read-only)
   * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
   * @see [[dateAxis]]
   * @see [[dateRangeFormula]]
   * @see [[setDateRange]]
   */
  get dateRangeFormula() {
    return this._e;
  }
  /**
   * Determines how blanks will be displayed
   */
  get displayBlanksAs() {
    return this._k;
  }
  /**
   * Determines how blanks will be displayed
   */
  set displayBlanksAs(a) {
    if (a != this._k) {
      ExcelUtils.gl(SparklineDisplayBlanksAs_$type, a);
      if (this._au) {
        let b = SparklineGroup._a[10].g(SparklineGroup.$, SparklineDisplayBlanksAs_$type, this, this._k, a);
        this._k = b.p1;
        return;
      }
      this._k = a;
      if (this._au) {
        this._b3("DisplayBlanksAs");
      }
    }
  }
  /**
   * Determines whether values from cells that are hidden will be displayed
   */
  get displayHidden() {
    return this._as(256);
  }
  /**
   * Determines whether values from cells that are hidden will be displayed
   */
  set displayHidden(a) {
    this._b6(11, 256, a);
  }
  /**
   * Determines if the x-axis will be displayed
   */
  get displayXAxis() {
    return this._as(128);
  }
  /**
   * Determines if the x-axis will be displayed
   */
  set displayXAxis(a) {
    this._b6(12, 128, a);
  }
  /**
   * Determines if the first point is displayed differently.
   * @see [[colorFirstPoint]]
   */
  get firstPoint() {
    return this._as(16);
  }
  /**
   * Determines if the first point is displayed differently.
   * @see [[colorFirstPoint]]
   */
  set firstPoint(a) {
    this._b6(13, 16, a);
  }
  /**
   * A unique identifier for this group (read-only).
   * <para class="note"><b>Note:</b> this property is optional but if one group contains a guid then all groups in the collection nust also have guids generated for them.</para>
   * @see [[SparklineGroupCollection.generateGuidsForGroups]]
   */
  get guid() {
    return unwrapNullable(this._guid$i);
  }
  /**
   * A unique identifier for this group (read-only).
   * <para class="note"><b>Note:</b> this property is optional but if one group contains a guid then all groups in the collection nust also have guids generated for them.</para>
   * @see [[SparklineGroupCollection.generateGuidsForGroups]]
   */
  set guid(a) {
    this._guid$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _guid$i() {
    return this._by;
  }
  /**
   * @hidden
   */
  set _guid$i(a) {
    this._by = a;
  }
  /**
   * Determines if the high point is displayed differently.
   * @see [[colorHighPoint]]
   */
  get highPoint() {
    return this._as(4);
  }
  /**
   * Determines if the high point is displayed differently.
   * @see [[colorHighPoint]]
   */
  set highPoint(a) {
    this._b6(14, 4, a);
  }
  /**
   * Determines if the last point is displayed differently.
   * @see [[colorLastPoint]]
   */
  get lastPoint() {
    return this._as(32);
  }
  /**
   * Determines if the last point is displayed differently.
   * @see [[colorLastPoint]]
   */
  set lastPoint(a) {
    this._b6(15, 32, a);
  }
  /**
   * Determines the weight of a line in points.
   * @throws [[ArgumentOutOfRangeException]] if the value is less than zero or greather than 1584.
   */
  get lineWeight() {
    return this._a1;
  }
  /**
   * Determines the weight of a line in points.
   * @throws [[ArgumentOutOfRangeException]] if the value is less than zero or greather than 1584.
   */
  set lineWeight(a) {
    if (a != this._a1) {
      if (a < 0 || a > 1584) {
        throw new ArgumentOutOfRangeException(2, "LineWeight", ExcelUtils.ef("LE_InvalidLineWeight"));
      }
      if (this._au) {
        let b = SparklineGroup._a[16].g(SparklineGroup.$, Number_$type, this, this._a1, a);
        this._a1 = b.p1;
        return;
      }
      this._a1 = a;
      if (this._au) {
        this._b3("LineWeight");
      }
    }
  }
  /**
   * Determines if the low point is displayed differently.
   * @see [[colorLowPoint]]
   */
  get lowPoint() {
    return this._as(8);
  }
  /**
   * Determines if the low point is displayed differently.
   * @see [[colorLowPoint]]
   */
  set lowPoint(a) {
    this._b6(17, 8, a);
  }
  /**
   * Determines if markers are displayed.
   * @see [[colorMarkers]]
   */
  get markers() {
    return this._as(2);
  }
  /**
   * Determines if markers are displayed.
   * @see [[colorMarkers]]
   */
  set markers(a) {
    this._b6(18, 2, a);
  }
  /**
   * Determines if the negative points are displayed differently.
   * @see [[colorNegativePoints]]
   */
  get negativePoints() {
    return this._as(64);
  }
  /**
   * Determines if the negative points are displayed differently.
   * @see [[colorNegativePoints]]
   */
  set negativePoints(a) {
    this._b6(19, 64, a);
  }
  /**
   * Determines if the sparkline goes from right to left.
   */
  get rightToLeft() {
    return this._as(512);
  }
  /**
   * Determines if the sparkline goes from right to left.
   */
  set rightToLeft(a) {
    this._b6(20, 512, a);
  }
  sparklines() {
    if (arguments.length !== 0) {
      let a = this._sparklines$i;
      return a.item.apply(a, arguments);
    }
    return this._sparklines$i;
  }
  /**
   * @hidden
   */
  get _sparklines$i() {
    if (this._m == null) {
      this._m = new SparklineCollection(0, this);
    }
    return this._m;
  }
  /**
   * The type of sparkline
   */
  get type() {
    return this._p;
  }
  /**
   * The type of sparkline
   */
  set type(a) {
    if (a != this._p) {
      ExcelUtils.gl(SparklineType_$type, a);
      if (this._au) {
        let b = SparklineGroup._a[21].g(SparklineGroup.$, SparklineType_$type, this, this._p, a);
        this._p = b.p1;
        return;
      }
      this._p = a;
      if (this._au) {
        this._b3("Type");
      }
    }
  }
  /**
   * A custom maximum value for the Y axis.
   * <para class="note"><b>Note:</b> if [[verticalAxisMaxType]] property is not set to 'Custom' then this property is ignored.</para>
   * @see [[verticalAxisMaxType]]
   */
  get verticalAxisMax() {
    return this._a2;
  }
  /**
   * A custom maximum value for the Y axis.
   * <para class="note"><b>Note:</b> if [[verticalAxisMaxType]] property is not set to 'Custom' then this property is ignored.</para>
   * @see [[verticalAxisMaxType]]
   */
  set verticalAxisMax(a) {
    if (a != this._a2) {
      if (this._au) {
        let b = SparklineGroup._a[22].g(SparklineGroup.$, Number_$type, this, this._a2, a);
        this._a2 = b.p1;
        return;
      }
      this._a2 = a;
      if (this._au) {
        this._b3("VerticalAxisMax");
      }
    }
  }
  /**
   * Determines how the maximum value for the Y axis is calculated.
   * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMax]] value will be used.</para>
   * @see [[verticalAxisMax]]
   */
  get verticalAxisMaxType() {
    return this._g;
  }
  /**
   * Determines how the maximum value for the Y axis is calculated.
   * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMax]] value will be used.</para>
   * @see [[verticalAxisMax]]
   */
  set verticalAxisMaxType(a) {
    if (a != this._g) {
      ExcelUtils.gl(SparklineAxisMinMax_$type, a);
      if (this._au) {
        let b = SparklineGroup._a[23].g(SparklineGroup.$, SparklineAxisMinMax_$type, this, this._g, a);
        this._g = b.p1;
        return;
      }
      this._g = a;
      if (this._au) {
        this._b3("VerticalAxisMaxType");
      }
    }
  }
  /**
   * A custom minimum value for the Y axis.
   * <para class="note"><b>Note:</b> if [[verticalAxisMinType]] property is not set to 'Custom' then this property is ignored.</para>
   * @see [[verticalAxisMinType]]
   */
  get verticalAxisMin() {
    return this._a3;
  }
  /**
   * A custom minimum value for the Y axis.
   * <para class="note"><b>Note:</b> if [[verticalAxisMinType]] property is not set to 'Custom' then this property is ignored.</para>
   * @see [[verticalAxisMinType]]
   */
  set verticalAxisMin(a) {
    if (a != this._a3) {
      if (this._au) {
        let b = SparklineGroup._a[24].g(SparklineGroup.$, Number_$type, this, this._a3, a);
        this._a3 = b.p1;
        return;
      }
      this._a3 = a;
      if (this._au) {
        this._b3("VerticalAxisMin");
      }
    }
  }
  /**
   * Determines how the minimum value for the Y axis is calculated.
   * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMin]] value will be used.</para>
   * @see [[verticalAxisMin]]
   */
  get verticalAxisMinType() {
    return this._h;
  }
  /**
   * Determines how the minimum value for the Y axis is calculated.
   * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMin]] value will be used.</para>
   * @see [[verticalAxisMin]]
   */
  set verticalAxisMinType(a) {
    if (a != this._h) {
      ExcelUtils.gl(SparklineAxisMinMax_$type, a);
      if (this._au) {
        let b = SparklineGroup._a[25].g(SparklineGroup.$, SparklineAxisMinMax_$type, this, this._h, a);
        this._h = b.p1;
        return;
      }
      this._h = a;
      if (this._au) {
        this._b3("VerticalAxisMinType");
      }
    }
  }
  /**
   * Returns a reference to the associated worksheet.
   */
  get worksheet() {
    return this._ai;
  }
  /**
   * Returns a reference to the associated workbook.
   */
  get workbook() {
    return this._ai != null ? this._ai.workbook : null;
  }
  /**
   * @hidden
   */
  get _an() {
    return this._am;
  }
  /**
   * @hidden
   */
  get _aj() {
    return this._ah;
  }
  /**
   * @hidden
   */
  get _au() {
    return this._as(1024);
  }
  /**
   * @hidden
   */
  get _av() {
    return this._as(2048);
  }
  /**
   * Assigns a new [[dateRange]].
   * <para class="note"><b>Note:</b> [[dateRange]] is ignored unless the [[dateAxis]] property is explicity set to true.</para>
   * @param dateRange The string representation of the formula.
   * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dateRange. If null it defaults to the workbook's mode.
   * @see [[dateRange]]
   */
  setDateRange(dateRange, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setDateRange$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setDateRange$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    let c = !nullableIsNull(b) ? b.value : this.workbook.cellReferenceMode;
    this._b9(a, c, this._au);
  }
  /**
   * @hidden
   */
  _b9(a, b, c) {
    let d = 0;
    let e = 0;
    if (this._sparklines$i.count > 0) {
      d = this._sparklines$i.item(0).location.firstRow;
      e = this._sparklines$i.item(0).location._v;
    }
    let f = null;
    let g = null;
    let h = null;
    if (!stringIsNullOrEmpty(a)) {
      let i = new List$1(Tuple$3.$.specialize(Worksheet.$, WorksheetRegionAddress.$, String_$type), 0);
      f = ExcelUtils.u(a, this.worksheet, d, e, b, "dateRange", "LE_InvalidRegion", i);
      if (f == null || i.count > 1) {
        throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidRegion"), "dateRange");
      }
      if (i.count == 0) {
        return;
      }
      h = i._inner[0].c;
      g = h != null ? h._cw(i._inner[0].d) : null;
    }
    if (f == this._e) {
      return;
    }
    if (!c) {
      this._ah = g != null ? g.worksheet : null;
      this._am = g != null ? g._h : WorksheetRegionAddress._b;
      this._e = f;
      this._b3("DateRange");
      return;
    }
    let j = SparklineGroup._a[9];
    let k = new SparklineGroup_RegionChangeContext(1, this, true);
    let l = j.b(this._ai.workbook, this._ai, j.c);
    this._ah = g != null ? g.worksheet : null;
    this._am = g != null ? g._h : WorksheetRegionAddress._b;
    this._e = f;
    j.e(SparklineGroup_RegionChangeContext.$, SparklineGroup.$, k, this, null);
    if (l != null) {
      j.d(this._ai.workbook, l);
    }
  }
  /**
   * @hidden
   */
  _b0(a) {
    this._ah = a != null ? a.worksheet : null;
    this._am = a != null ? a._h : WorksheetRegionAddress._b;
    if (a == null) {
      this._e = null;
    }
  }
  /**
   * @hidden
   */
  _b2() {
    this._b5(1024, true);
  }
  /**
   * @hidden
   */
  _b1() {
  }
  /**
   * @hidden
   */
  _b4(a, b) {
    this._am = b;
    if (stringIsNullOrEmpty(a)) {
      this._e = null;
    }
    else {
      this._b9(a, 1, false);
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(SparklineGroup.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(SparklineGroup_RegionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(26);
    ChangeInfo.f(a, 0, SparklineGroup._c(WorkbookColorInfo.$, "ColorAxis", 68, (b) => b.colorAxis, (b, c) => b.colorAxis = c));
    ChangeInfo.f(a, 1, SparklineGroup._c(WorkbookColorInfo.$, "ColorFirstPoint", 68, (b) => b.colorFirstPoint, (b, c) => b.colorFirstPoint = c));
    ChangeInfo.f(a, 2, SparklineGroup._c(WorkbookColorInfo.$, "ColorHighPoint", 68, (b) => b.colorHighPoint, (b, c) => b.colorHighPoint = c));
    ChangeInfo.f(a, 3, SparklineGroup._c(WorkbookColorInfo.$, "ColorLastPoint", 68, (b) => b.colorLastPoint, (b, c) => b.colorLastPoint = c));
    ChangeInfo.f(a, 4, SparklineGroup._c(WorkbookColorInfo.$, "ColorLowPoint", 68, (b) => b.colorLowPoint, (b, c) => b.colorLowPoint = c));
    ChangeInfo.f(a, 5, SparklineGroup._c(WorkbookColorInfo.$, "ColorMarkers", 68, (b) => b.colorMarkers, (b, c) => b.colorMarkers = c));
    ChangeInfo.f(a, 6, SparklineGroup._c(WorkbookColorInfo.$, "ColorNegativePoints", 68, (b) => b.colorNegativePoints, (b, c) => b.colorNegativePoints = c));
    ChangeInfo.f(a, 7, SparklineGroup._c(WorkbookColorInfo.$, "ColorSeries", 68, (b) => b.colorSeries, (b, c) => b.colorSeries = c));
    ChangeInfo.f(a, 8, SparklineGroup._c(Boolean_$type, "DateAxis", 70, (b) => b.dateAxis, (b, c) => b.dateAxis = c));
    ChangeInfo.f(a, 9, SparklineGroup._d(SparklineGroup.$, "DateRange", 69, (b) => b.a, (b, c) => SparklineGroup._ca(b, c)));
    ChangeInfo.f(a, 10, SparklineGroup._c(SparklineDisplayBlanksAs_$type, "DisplayBlanksAs", 70, (b) => b.displayBlanksAs, (b, c) => b.displayBlanksAs = c));
    ChangeInfo.f(a, 11, SparklineGroup._c(Boolean_$type, "DisplayHidden", 70, (b) => b.displayHidden, (b, c) => b.displayHidden = c));
    ChangeInfo.f(a, 12, SparklineGroup._c(Boolean_$type, "DisplayXAxis", 70, (b) => b.displayXAxis, (b, c) => b.displayXAxis = c));
    ChangeInfo.f(a, 13, SparklineGroup._c(Boolean_$type, "FirstPoint", 70, (b) => b.firstPoint, (b, c) => b.firstPoint = c));
    ChangeInfo.f(a, 14, SparklineGroup._c(Boolean_$type, "HighPoint", 70, (b) => b.highPoint, (b, c) => b.highPoint = c));
    ChangeInfo.f(a, 15, SparklineGroup._c(Boolean_$type, "LastPoint", 70, (b) => b.lastPoint, (b, c) => b.lastPoint = c));
    ChangeInfo.f(a, 16, SparklineGroup._c(Number_$type, "LineWeight", 70, (b) => b.lineWeight, (b, c) => b.lineWeight = c));
    ChangeInfo.f(a, 17, SparklineGroup._c(Boolean_$type, "LowPoint", 70, (b) => b.lowPoint, (b, c) => b.lowPoint = c));
    ChangeInfo.f(a, 18, SparklineGroup._c(Boolean_$type, "Markers", 70, (b) => b.markers, (b, c) => b.markers = c));
    ChangeInfo.f(a, 19, SparklineGroup._c(Boolean_$type, "NegativePoints", 70, (b) => b.negativePoints, (b, c) => b.negativePoints = c));
    ChangeInfo.f(a, 20, SparklineGroup._c(Boolean_$type, "RightToLeft", 70, (b) => b.rightToLeft, (b, c) => b.rightToLeft = c));
    ChangeInfo.f(a, 21, SparklineGroup._c(SparklineType_$type, "Type", 71, (b) => b.type, (b, c) => b.type = c));
    ChangeInfo.f(a, 22, SparklineGroup._c(Number_$type, "VerticalAxisMax", 70, (b) => b.verticalAxisMax, (b, c) => b.verticalAxisMax = c));
    ChangeInfo.f(a, 23, SparklineGroup._c(SparklineAxisMinMax_$type, "VerticalAxisMaxType", 70, (b) => b.verticalAxisMaxType, (b, c) => b.verticalAxisMaxType = c));
    ChangeInfo.f(a, 24, SparklineGroup._c(Number_$type, "VerticalAxisMin", 70, (b) => b.verticalAxisMin, (b, c) => b.verticalAxisMin = c));
    ChangeInfo.f(a, 25, SparklineGroup._c(SparklineAxisMinMax_$type, "VerticalAxisMinType", 70, (b) => b.verticalAxisMinType, (b, c) => b.verticalAxisMinType = c));
    return a;
  }
  /**
   * @hidden
   */
  _as(a) {
    return (this._o & a) == a;
  }
  /**
   * @hidden
   */
  _b3(a) {
  }
  /**
   * @hidden
   */
  _b5(a, b) {
    if (b) {
      this._o |= a;
    }
    else {
      this._o &= ~a;
    }
  }
  /**
   * @hidden
   */
  _b6(a, b, c) {
    let d = this._as(b);
    if (d == c) {
      return;
    }
    if (!this._au) {
      this._b5(b, c);
      return;
    }
    let e = SparklineGroup._a[a].g(SparklineGroup.$, Boolean_$type, this, d, c);
    d = e.p1;
    this._b5(b, c);
  }
  /**
   * @hidden
   */
  _b7(a, b, c) {
    if (WorkbookColorInfo.l_op_Equality(c, b)) {
      return {
        p2: c
      };
    }
    DocCoreUtils.au(b, "color");
    if (b.isAutomatic) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_AutoColorNotAllowed"));
    }
    if (!this._au) {
      c = b;
      return {
        p2: c
      };
    }
    let d = SparklineGroup._a[a].g(SparklineGroup.$, WorkbookColorInfo.$, this, c, b);
    c = d.p1;
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _ca(a, b) {
    a.a._b9(a.c, 1, a.b);
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this.worksheet;
  }
}
SparklineGroup.$t = markType(SparklineGroup, 'SparklineGroup', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
SparklineGroup._a7 = 0;
/**
 * @hidden
 */
SparklineGroup._a8 = 1;
/**
 * @hidden
 */
SparklineGroup._a9 = 2;
/**
 * @hidden
 */
SparklineGroup._ba = 3;
/**
 * @hidden
 */
SparklineGroup._bb = 4;
/**
 * @hidden
 */
SparklineGroup._bc = 5;
/**
 * @hidden
 */
SparklineGroup._bd = 6;
/**
 * @hidden
 */
SparklineGroup._be = 7;
/**
 * @hidden
 */
SparklineGroup._bf = 8;
/**
 * @hidden
 */
SparklineGroup._bg = 9;
/**
 * @hidden
 */
SparklineGroup._bh = 10;
/**
 * @hidden
 */
SparklineGroup._bi = 11;
/**
 * @hidden
 */
SparklineGroup._bj = 12;
/**
 * @hidden
 */
SparklineGroup._bk = 13;
/**
 * @hidden
 */
SparklineGroup._bl = 14;
/**
 * @hidden
 */
SparklineGroup._bm = 15;
/**
 * @hidden
 */
SparklineGroup._bn = 16;
/**
 * @hidden
 */
SparklineGroup._bo = 17;
/**
 * @hidden
 */
SparklineGroup._bp = 18;
/**
 * @hidden
 */
SparklineGroup._bq = 19;
/**
 * @hidden
 */
SparklineGroup._bs = 20;
/**
 * @hidden
 */
SparklineGroup._bt = 21;
/**
 * @hidden
 */
SparklineGroup._bu = 22;
/**
 * @hidden
 */
SparklineGroup._bv = 23;
/**
 * @hidden
 */
SparklineGroup._bw = 24;
/**
 * @hidden
 */
SparklineGroup._bx = 25;
/**
 * @hidden
 */
SparklineGroup._br = 26;
/**
 * @hidden
 */
SparklineGroup._a = null;
/**
 * @hidden
 */
export class SparklineGroupCollection_GroupModifyInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.d = null;
    this.c = new WorksheetRegionAddress();
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.b = c;
          this.d = d;
          this.c = e;
          this.a = f;
        }
        break;
    }
  }
}
SparklineGroupCollection_GroupModifyInfo.$t = markStruct(SparklineGroupCollection_GroupModifyInfo, 'SparklineGroupCollection_GroupModifyInfo');
/**
 * @hidden
 */
export class SparklineGroupCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._h;
  }
  get sheet() {
    return this.b._j;
  }
  get source() {
    return this.b._i;
  }
}
SparklineGroupCollection_CollectionChangeContext.$t = markStruct(SparklineGroupCollection_CollectionChangeContext, 'SparklineGroupCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class SparklineGroupCollection_ShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.c = null;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.d = c;
          this.c = d != null && d.count > 0 ? d.toArray() : null;
          this.b = e != null && e.count > 0 ? e.toArray() : null;
          this.a = f != null && f.count > 0 ? f.toArray() : null;
        }
        break;
    }
  }
  e() {
    let a = this.sheet;
    if (a == null) {
      return;
    }
    SparklineGroupCollection._p.clear();
    SparklineGroupCollection._o.clear();
    let b = this.workbook._df;
    this.workbook._df = false;
    let c = this.b != null ? new List$1(SparklineGroup.$, 2, this.b.length) : null;
    let d = this.a != null ? SparklineGroupCollection._o : null;
    let e = this.c != null ? SparklineGroupCollection._p : null;
    if (this.a != null) {
      for (let f = this.a.length - 1; f >= 0; f--) {
        let g = this.a[f];
        let h = this.d.indexOf(g);
        if (h >= 0) {
          d.insert(0, Tuple.a(SparklineGroup.$, Number_$type, g, h));
          this.d._r.removeAt(h);
        }
      }
    }
    if (this.b != null) {
      let k = this.b;
      for (let j = 0; j < k.length; j++) {
        let i = k[j];
        this.d._r.insert(i.d, i.c);
        c.add(i.c);
      }
    }
    if (this.c != null) {
      let n = this.c;
      for (let m = 0; m < n.length; m++) {
        let l = n[m];
        let o = l.b;
        let p = o._sparklines$i._c(l.a);
        let q = o._an;
        let r = o.dateRangeFormula != null ? o.dateRangeFormula._toString1(1) : null;
        if (r != null && r.length > 1 && r.charAt(0) == '=') {
          r = r.substr(1);
        }
        let s = l.d;
        let t = l.c;
        if (WorksheetRegionAddress._q(q, t)) {
          o._b4(s, t);
        }
        e.add(new SparklineGroupCollection_GroupModifyInfo(1, o, r, q, p));
      }
    }
    let u = SparklineGroupCollection._a[2];
    let v = new SparklineGroupCollection_ShiftChangeContext(1, this.d, e, d, c);
    u.x(v, null, null);
    this.workbook._df = b;
    SparklineGroupCollection._p.clear();
    SparklineGroupCollection._o.clear();
  }
  get workbook() {
    return this.d._h;
  }
  get sheet() {
    return this.d._j;
  }
  get source() {
    return this.d._i;
  }
}
SparklineGroupCollection_ShiftChangeContext.$t = markStruct(SparklineGroupCollection_ShiftChangeContext, 'SparklineGroupCollection_ShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[SparklineGroup]]s exposed from a [[worksheet]]
 */
export class SparklineGroupCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._i = null;
    /**
     * @hidden
     */
    this._r = null;
    this._k = false;
    this._i = a;
    this._r = new List$1(SparklineGroup.$, 0);
  }
  static staticInit() {
    SparklineGroupCollection._a = SparklineGroupCollection._b();
  }
  /**
   * Returns the total number of items in the collection.
   */
  get count() {
    return this._r.count;
  }
  /**
   * Determines if guids will be generated for groups.
   * <para class="note"><b>Note:</b> if any group has a guid then all of them must also have guids. Therefore, when this property is set to true all
   * groups in the collection, including groups that are subsequently added, will have guids generated for them. Also note that this property can not be set to false
   * if the collection contains any group with a guid.</para>
   * @throws [[ArgumentException]] Can't set GenerateGuidsForGroups to false if the collection contains groups that already have guids generated.
   * @see [[SparklineGroup.guid]]
   */
  get generateGuidsForGroups() {
    return this._k;
  }
  /**
   * Determines if guids will be generated for groups.
   * <para class="note"><b>Note:</b> if any group has a guid then all of them must also have guids. Therefore, when this property is set to true all
   * groups in the collection, including groups that are subsequently added, will have guids generated for them. Also note that this property can not be set to false
   * if the collection contains any group with a guid.</para>
   * @throws [[ArgumentException]] Can't set GenerateGuidsForGroups to false if the collection contains groups that already have guids generated.
   * @see [[SparklineGroup.guid]]
   */
  set generateGuidsForGroups(a) {
    if (a != this._k) {
      let b = this._r.count;
      if (false == a && b > 0 && Guid.l_op_Inequality_Lifted(this._r._inner[0]._guid$i, Nullable$1.toNullable(Guid.$, null))) {
        throw new ArgumentException(1, ExcelUtils.ef("LE_AllMustHavGuidsIfAnyHasThem"));
      }
      this._k = a;
      if (this._k) {
        for (let c = 0; c < b; c++) {
          let d = this._r._inner[c];
          if (Guid.l_op_Equality_Lifted(d._guid$i, Nullable$1.toNullable(Guid.$, null))) {
            d._guid$i = Nullable$1.toNullable(Guid.$, Guid.newGuid());
          }
        }
      }
    }
  }
  /**
   * Indexer
   * @param index The zer-based index of an item
   * @return The item at the specified index
   * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
   */
  item(a) {
    return this._r._inner[a];
  }
  /**
   * @hidden
   */
  get _h() {
    return this._i.workbook;
  }
  /**
   * @hidden
   */
  get _j() {
    return this._i;
  }
  /**
   * Adds a new [[SparklineGroup]]
   * @param type The type of the group.
   * @param locationRange The aggregated location for the sparklines in the group.
   * @param dataRange The aggreagated data range for all the sparklines in the group.
   * @param groupInitializer An optional callback for initializing the group before it is added to the collection.
   * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the location and data ranges. If null it defaults to the workbook's mode.
   * @return The added group
   */
  add(type, locationRange, dataRange, groupInitializer, cellReferenceMode) {
    arguments[3] = (arguments[3] !== void 0 ? arguments[3] : null);
    if (arguments[4] !== void 0) {
      arguments[4] = wrapNullable(CellReferenceMode_$type, arguments[4]);
    }
    return this._add$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _add$i(a, b, c, d = null, e = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    ExcelUtils.gm(SparklineType_$type, a, "type");
    DocCoreUtils.au(b, "locationRange");
    DocCoreUtils.au(c, "dataRange");
    if (nullableNotEquals(e, null)) {
      ExcelUtils.gm(CellReferenceMode_$type, e.value, "cellReferenceMode");
    }
    let f = this._j;
    let g = !nullableIsNull(e) ? e.value : f.workbook.cellReferenceMode;
    let h = f._getRegion1(b, g);
    if (h == null || !h._h._n) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_InvalidRegion"), "locationRange");
    }
    if (h.worksheet != this._i) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_LocationWorksheetMismatch"), "locationRange");
    }
    let i = h._ad == 1;
    let j = null;
    ExcelUtils.ga(f, c, i, false, h, g, (k) => {
      j = new SparklineGroup(1, this._i, a);
      if (d != null) {
        d(j);
      }
    }, () => {
      let k = new Sparkline();
      j._sparklines$i._s(0, k, h, null, c, false);
    }, (k, l, m, n) => {
      let o = new Sparkline();
      let p = this._i._cw(l);
      let q = k != null ? k._cw(m) : null;
      let r = q != null ? q._toString1(1, k != this._j) : k != null ? stringFormat("{0}{1}", ExcelUtils.d5(null, k.name), m._ah(false, false, 2, 1)) : n + m._ah(false, false, 2, 1);
      j._sparklines$i._s(j._sparklines$i.count, o, p, q, r, false);
    });
    this._z(this.count, j, j.dateRange);
    this._ac(j);
    return j;
  }
  /**
   * Clears all items from the collection
   */
  clear() {
    let a = this._r.count > 1 ? this._y(67) : null;
    for (let b = this._r.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._ag(a);
  }
  /**
   * Returns true if the collection contains the item
   * @param group The group to check
   */
  contains(group) {
    return this._r.contains(group);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return getEnumerator(this._r);
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return getEnumerator(this._r);
  }
  /**
   * Gets the index of the item in the collection
   * @param group
   * @return The index or -1 if the item is not in the collection
   */
  indexOf(group) {
    return this._r.indexOf(group);
  }
  /**
   * Removes a group from the collection
   * @param group The group to remove.
   * @return true if successful, otherwise false
   */
  remove(group) {
    let a = this._r.indexOf(group);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes a group from the collection
   * @param index The zero-based index of the group to remove.
   * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
   */
  removeAt(index) {
    let a = this._r._inner[index];
    let b = SparklineGroupCollection._a[1];
    let c = new SparklineGroupCollection_CollectionChangeContext(1, this, a, index);
    let d = b.b(this._h, this._j, b.c);
    this._r.removeAt(index);
    b.e(SparklineGroupCollection_CollectionChangeContext.$, SparklineGroup.$, c, a, null);
    if (d != null) {
      b.d(this._h, d);
    }
    a._b1();
  }
  /**
   * @hidden
   */
  _f(a) {
    let b = new SparklineGroup(1, this._i, a);
    this._r.add(b);
    return b;
  }
  /**
   * @hidden
   */
  _ad() {
    let a = this.count;
    let b = 0;
    for (let c = 0; c < a; c++) {
      let d = this._r._inner[c];
      d._b2();
      if (Guid.l_op_Inequality_Lifted(d._guid$i, Nullable$1.toNullable(Guid.$, null))) {
        b++;
      }
    }
    this._k = b > 0;
    if (this._k && b != a) {
      for (let e = 0; e < a; e++) {
        let f = this._r._inner[e];
        if (Guid.l_op_Equality_Lifted(f._guid$i, Nullable$1.toNullable(Guid.$, null))) {
          f._guid$i = Nullable$1.toNullable(Guid.$, Guid.newGuid());
        }
      }
    }
  }
  /**
   * @hidden
   */
  _ae(a, b) {
    if (SparklineGroupCollection._p == null) {
      SparklineGroupCollection._p = new List$1(SparklineGroupCollection_GroupModifyInfo.$, 0);
    }
    else {
      SparklineGroupCollection._p.clear();
    }
    if (SparklineGroupCollection._o == null) {
      SparklineGroupCollection._o = new List$1(Tuple$2.$.specialize(SparklineGroup.$, Number_$type), 0);
    }
    else {
      SparklineGroupCollection._o.clear();
    }
    if (SparklineGroupCollection._q == null) {
      SparklineGroupCollection._q = new List$1(Sparkline.$, 0);
    }
    else {
      SparklineGroupCollection._q.clear();
    }
    let c = a.h;
    for (let d = 0; d < this._r.count; d++) {
      let e = this._r._inner[d];
      let f = false;
      SparklineGroupCollection._q.clear();
      let g = e._sparklines$i;
      let h = new HashSet$1(Number_$type, 0);
      for (let i = 0; i < g.count; i++) {
        let j = g.item(i);
        SparklineGroupCollection._q.add(j);
        let k = false;
        if (j._g == c) {
          let l = j._i.o;
          let m = j._i.m;
          let n = ((() => { let o = a.d(l, m); l = o.p0; m = o.p1; return o.ret; })());
          if (n.f) {
            f = true;
            if (n.g) {
              k = true;
            }
            else {
              j = j._c(l, m);
              g.item(i, j);
            }
          }
        }
        if (false == k && j._f == c) {
          let o = j._m._a();
          let p = ((() => { let q = a.e(o, false); o = q.p0; return q.ret; })());
          if (p.f) {
            if (p.g) {
              o = WorksheetRegionAddress._b;
            }
            f = true;
            j = j._b(o);
            g.item(i, j);
          }
        }
        if (k) {
          h.add_1(i);
          continue;
        }
      }
      if (h.count > 0) {
        for (let q = g.count - 1; q >= 0; q--) {
          if (h.contains(q)) {
            g.removeAt(q);
          }
        }
      }
      if (e._sparklines$i.count == 0 && SparklineGroupCollection._q.count > 0) {
        SparklineGroupCollection._o.add(Tuple.a(SparklineGroup.$, Number_$type, e, d + SparklineGroupCollection._o.count));
        this._r.removeAt(d);
        d--;
        continue;
      }
      let r = e._an;
      let s = r;
      if (e._aj == c && e._an._n) {
        let t = r._a();
        let u = ((() => { let v = a.e(t, false); t = v.p0; return v.ret; })());
        if (u.f) {
          if (u.g) {
            t = WorksheetRegionAddress._b;
          }
          f = true;
          s = t;
        }
      }
      if (f) {
        let v = e.dateRangeFormula != null ? e.dateRangeFormula._toString1(1) : null;
        if (v != null && v.length > 1 && v.charAt(0) == '=') {
          v = v.substr(1);
        }
        SparklineGroupCollection._p.add(new SparklineGroupCollection_GroupModifyInfo(1, e, v, e._an, SparklineGroupCollection._q.toArray()));
        if (e._aj == c && WorksheetRegionAddress._q(s, e._an)) {
          if (e.dateRangeFormula != null) {
            e.dateRangeFormula._av(c, a, 0);
          }
          e._b0(s._n ? c._cw(s) : null);
        }
      }
    }
    SparklineGroupCollection._q.clear();
    if (SparklineGroupCollection._p.count > 0 || SparklineGroupCollection._o.count > 0) {
      let w = this._i.workbook._df;
      this._i.workbook._df = false;
      let x = SparklineGroupCollection._a[2];
      let y = new SparklineGroupCollection_ShiftChangeContext(1, this, SparklineGroupCollection._p, SparklineGroupCollection._o, null);
      x.x(y, null, null);
      this._i.workbook._df = w;
    }
    SparklineGroupCollection._p.clear();
    SparklineGroupCollection._o.clear();
  }
  /**
   * @hidden
   */
  _af(a) {
    let b = this._h;
    if (b != null && b._c4) {
      return;
    }
    for (let c = 0; c < this.count; c++) {
      let d = this._r._inner[c];
      let e = false;
      for (let f = 0; f < d._sparklines$i.count; f++) {
        let g = d._sparklines$i.item(f);
        if (g == a) {
          continue;
        }
        if (g.location.firstRow == a.location.firstRow && g.location.firstColumn == a.location.firstColumn) {
          d._sparklines$i.removeAt(f);
          f--;
          e = true;
        }
      }
      if (e && d._sparklines$i.count == 0) {
        this.removeAt(c);
        c--;
      }
    }
  }
  /**
   * @hidden
   */
  _ab(a) {
    for (let b of fromEnum(a)) {
      this._r.add(b);
    }
  }
  /**
   * @hidden
   */
  _z(a, b, c, d = true) {
    let e = SparklineGroupCollection._a[0];
    let f = new SparklineGroupCollection_CollectionChangeContext(1, this, b, a);
    let g = e.b(this._h, this._j, e.c);
    b._b0(c);
    this._r.insert(a, b);
    e.e(SparklineGroupCollection_CollectionChangeContext.$, SparklineGroup.$, f, null, b);
    if (g != null) {
      e.d(this._h, g);
    }
    if (d) {
      b._b1();
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(SparklineGroupCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _d($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(SparklineGroupCollection_ShiftChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, SparklineGroupCollection._c(SparklineGroup.$, "Add", 66, (b) => b.a, (b, c) => SparklineGroupCollection._ai(b, c)));
    ChangeInfo.f(a, 1, SparklineGroupCollection._c(SparklineGroup.$, "Remove", 67, (b) => b.a, (b, c) => SparklineGroupCollection._aj(b, c)));
    ChangeInfo.f(a, 2, SparklineGroupCollection._d(Base.$, "Shift", 67, (b) => null, (b, c) => b.e()));
    return a;
  }
  /**
   * @hidden
   */
  _ac(a) {
    if (this.generateGuidsForGroups && Guid.l_op_Equality_Lifted(a._guid$i, Nullable$1.toNullable(Guid.$, null))) {
      a._guid$i = Nullable$1.toNullable(Guid.$, Guid.newGuid());
    }
    a._b2();
  }
  /**
   * @hidden
   */
  _y(a) {
    let b = this._j.workbook;
    return b != null && b._cx ? b._go(this._j, a, null) : null;
  }
  /**
   * @hidden
   */
  _ag(a) {
    if (a != null) {
      let b = this._j.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _ai(a, b) {
    let c = a.b.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _aj(a, b) {
    let c = a.a;
    a.b._z(a.c, c, c.dateRange, true);
  }
}
SparklineGroupCollection.$t = markType(SparklineGroupCollection, 'SparklineGroupCollection', Base.$, [IEnumerable$1_$type.specialize(SparklineGroup.$)]);
/**
 * @hidden
 */
SparklineGroupCollection._s = 0;
/**
 * @hidden
 */
SparklineGroupCollection._w = 1;
/**
 * @hidden
 */
SparklineGroupCollection._x = 2;
/**
 * @hidden
 */
SparklineGroupCollection._v = 3;
/**
 * @hidden
 */
SparklineGroupCollection._p = null;
/**
 * @hidden
 */
SparklineGroupCollection._o = null;
/**
 * @hidden
 */
SparklineGroupCollection._q = null;
/**
 * @hidden
 */
SparklineGroupCollection._a = null;
/**
 * Abstract base class for the sort conditions which describe how to sort data in a region.
 * @see [[SortSettings`1.sortConditions]]
 * @see [[WorksheetTableColumn.sortCondition]]
 * @see [[OrderedSortCondition]]
 * @see [[CustomListSortCondition]]
 * @see [[FontColorSortCondition]]
 * @see [[FillSortCondition]]
 */
export class SortCondition extends Base {
  constructor(a, ..._rest) {
    super();
    this._b = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = [0];
          {
            let e = c[0];
            ExcelUtils.gl(SortDirection_$type, e);
            this._b = e;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          ExcelUtils.gl(SortDirection_$type, c);
          this._b = c;
        }
        break;
    }
  }
  /**
   * Determines whether the [[SortCondition]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(SortCondition.$, obj);
    if (a == null) {
      return false;
    }
    return this._b == a._b;
  }
  /**
   * Gets the hash code for the [[SortCondition]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return Base.getHashCodeStatic(this._b);
  }
  /**
   * Gets the value which indicates the sort direction represented by the sort condition.
   * Either SortDirection.Ascending or SortDirection.Descending.
   */
  get sortDirection() {
    return this._b;
  }
}
SortCondition.$t = markType(SortCondition, 'SortCondition');
/**
 * Represents a sort condition which will sort cells based on a custom, ordered list of values.
 * <p class="body">
 * When the sort direction is ascending, the data range is sorted with the cells in the custom list appearing first, in the order they
 * appear in the list, followed by the other cells in the same relative order they had to each other before the sort. When the sort direction
 * is descending, the cells not in the list will appear first in the data region and they will appear in the same relative order they
 * had before the sort. They will be followed by the other cells in the reverse order of the list.
 * </p>
 * <p class="body">
 * The list of values specified on this sort condition are string values. If a cell being sorted has a string value, that value is used to
 * sort the cell. Otherwise, the cell text is used. For example, if the cell's value is 0.01, but it is formatted as a percentage cell,
 * the text used to sort it with this sort condition will be "1%" and not "0.01". When using the cell text, if the format string for the
 * cell includes padding characters which are repeated across the cells, they will not be included in the cell text used for comparison.
 * </p>
 * <p class="body">
 * When matching values from a cell to values in the custom list, strings are compared case-sensitively or case-insensitively based
 * on the [[SortSettings`1.caseSensitive]] setting.
 * </p>
 * <p class="body">
 * If the cell text contains any repeated padding characters, they are ignored when comparing strings.
 * </p>
 * @see [[SortSettings`1.caseSensitive]]
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 */
export class CustomListSortCondition extends SortCondition {
  constructor(sortDirection, ...list) {
    super(1, sortDirection);
    this._j = null;
    this._m(list);
  }
  /**
   * @hidden
   */
  _m(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "list");
    }
    let b = new List$1(String_$type, 0);
    for (let c of fromEnum(a)) {
      if (c == null) {
        continue;
      }
      let d = c.trim();
      if (d.length == 0) {
        continue;
      }
      b.add(d);
    }
    if (b.count == 0) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_EmptyCustomList"), "list");
    }
    this._j = new ReadOnlyCollection$1(String_$type, 1, b);
  }
  /**
   * @hidden
   */
  _a() {
    let a = new List$1(String_$type, 0);
    a.o(this._j);
    let b = new CustomListSortCondition(this.sortDirection, ...a.toArray());
    return b;
  }
  /**
   * @hidden
   */
  _g($t, a, b, c, d, e) {
    let f = a.c;
    let g = f._rows$i._aj(b);
    let h = b == c ? g : f._rows$i._aj(c);
    let i = WorksheetRow._c2(g, d);
    let j = WorksheetRow._c2(h, e);
    if (i == null) {
      if (j == null) {
        return 0;
      }
      return 1;
    }
    else if (j == null) {
      return -1;
    }
    let k;
    if (typeCast(Boolean_$type, i) !== null) {
      if (typeCast(Boolean_$type, j) !== null) {
        k = boolCompare(i, j);
      }
      else {
        k = 1;
      }
    }
    else if (typeCast(Boolean_$type, j) !== null) {
      k = -1;
    }
    else {
      let l = new GetCellTextParameters(d);
      let m = d == e ? l : new GetCellTextParameters(e);
      l.b = 1;
      l.a = 1;
      if (d != e) {
        m.b = 1;
        m.a = 1;
      }
      let n = a.b;
      let o = g._av(l).g;
      let p = h._av(m).g;
      let q = this._k(f, o, n.caseSensitive);
      let r = this._k(f, p, n.caseSensitive);
      if (q == -1) {
        if (r == -1) {
          k = OrderedSortCondition._i($t, n, f, i, j);
        }
        else {
          k = 1;
        }
      }
      else if (r == -1) {
        k = -1;
      }
      else {
        k = Base.compareSimple(q, r);
      }
    }
    if (this.sortDirection == 1) {
      return -k;
    }
    return k;
  }
  /**
   * Determines whether the [[CustomListSortCondition]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CustomListSortCondition.$, obj);
    if (a == null || super.equals(a) == false) {
      return false;
    }
    if (this._j.count != a._j.count) {
      return false;
    }
    for (let b = 0; b < this._j.count; b++) {
      if (this._j.item(b) != a._j.item(b)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Gets the hash code for the [[CustomListSortCondition]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    let a = this._j.count;
    if (this._j.count != 0) {
      a ^= Base.getHashCodeStatic(this._j.item(0)) ^ Base.getHashCodeStatic(this._j.item(this._j.count - 1));
    }
    return a ^ super.getHashCode();
  }
  /**
   * @hidden
   */
  _f(a) {
    return a == null || a._d != 0;
  }
  /**
   * @hidden
   */
  get__d() {
    return 0;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  _l() {
    let a = new StringBuilder(1, this._j.count * 2);
    for (let b = 0; b < this._j.count; b++) {
      a.l(this._j.item(b));
      a.l(",");
    }
    a.c--;
    return a.toString();
  }
  /**
   * @hidden
   */
  _k(a, b, c) {
    let d = c ? 0 : 1;
    let e = a._y;
    for (let f = 0; f < this._j.count; f++) {
      if (StringUtilities.c(this._j.item(f), b, e, d) == 0) {
        return f;
      }
    }
    return -1;
  }
  /**
   * Gets the ordered list of values by which to sort.
   * <p class="body">
   * The list of values specified on this sort condition are string values. If a cell being sorted has a string value, that value is used to
   * sort the cell. Otherwise, the cell text is used. For example, if the cell's value is 0.01, but it is formatted as a percentage cell,
   * the text used to sort it with this sort condition will be "1%" and not "0.01". When using the cell text, if the format string for the
   * cell includes padding characters which are repeated across the cells, they will not be included in the cell text used for comparison.
   * </p>
   * <p class="body">
   * When matching values from a cell to values in the custom list, strings are compared case-sensitively or case-insensitively based
   * on the [[SortSettings`1.caseSensitive]] setting.
   * </p>
   * <p class="body">
   * If the cell text contains any repeated padding characters, they are ignored when comparing strings.
   * </p>
   * @see [[SortSettings`1.caseSensitive]]
   * @see [[WorksheetCell.getText]]
   * @see [[WorksheetRow.getCellText]]
   */
  get list() {
    return this._j;
  }
}
CustomListSortCondition.$t = markType(CustomListSortCondition, 'CustomListSortCondition', SortCondition.$);
/**
 * @hidden
 */
export let IColorSortCondition_$type = new Type(null, 'IColorSortCondition');
/**
 * Represents a sort condition which will sort cells based on their background fill.
 * <p class="body">
 * This sort condition specifies a single [[CellFill]]. Cells of this color will be moved to the beginning of the data range
 * for the ascending sort direction and moved to the end of the data range for the descending sort direction. All matching cells will
 * be kept in their same relative order to each other. In addition, all non-matching cells will be kept in their same relative order to
 * each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export class FillSortCondition extends SortCondition {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let fill = _rest[0];
          let b = [fill, 0];
          {
            let fill = b[0];
            let sortDirection = b[1];
            super(1, sortDirection);
            this._i = null;
            if (fill == null) {
              throw new ArgumentNullException(0, "fill");
            }
            this._i = fill;
          }
        }
        break;
      case 1:
        {
          let fill = _rest[0];
          let sortDirection = _rest[1];
          super(1, sortDirection);
          this._i = null;
          if (fill == null) {
            throw new ArgumentNullException(0, "fill");
          }
          this._i = fill;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _accept$2$i($tArg, $tResult, visitor, argument) {
    return visitor._visitFillSortCondition$i(this, argument);
  }
  /**
   * @hidden
   */
  _a() {
    let a = new FillSortCondition(this._i, this.sortDirection);
    return a;
  }
  /**
   * @hidden
   */
  _g($t, a, b, c, d, e) {
    let f = a.c;
    let g = f._rows$i._aj(b);
    let h = b == c ? g : f._rows$i._aj(c);
    let i = f._b4(g, d);
    let j = f._b4(h, e);
    let k = f.workbook;
    let l = ExcelUtils.an(k, i, a.a(b, d), this.fill);
    let m = ExcelUtils.an(k, j, a.a(c, e), this.fill);
    if (l == m) {
      return 0;
    }
    let n = l ? -1 : 1;
    if (this.sortDirection == 1) {
      return -n;
    }
    return n;
  }
  /**
   * Determines whether the [[FillSortCondition]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(FillSortCondition.$, obj);
    if (a == null) {
      return false;
    }
    return Base.equalsStatic(this._i, a._i) && super.equals(a);
  }
  /**
   * Gets the hash code for the [[FillSortCondition]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return Base.getHashCodeStatic(this._i) ^ super.getHashCode();
  }
  /**
   * @hidden
   */
  _f(a) {
    let b = typeCast(FillSortCondition.$, a);
    return b == null || b._i != this._i;
  }
  /**
   * @hidden
   */
  get__d() {
    return 1;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  static _k(a, b, c) {
    if (nullableEquals(b, null)) {
      return null;
    }
    if (a._g.count <= b.value) {
      return null;
    }
    let d = a._g._inner[b.value];
    if (d.fill == null) {
      return null;
    }
    return new FillSortCondition(d.fill, c);
  }
  /**
   * Gets the [[CellFill]] by which the cells should be sorted.
   * <p class="body">
   * Cells with this fill will be moved to the beginning of the data range for the ascending sort direction and moved to the end
   * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
   * In addition, all non-matching cells will be kept in their same relative order to each other.
   * </p>
   * The CellFill by which the cells should be sorted.
   * @see [[SortCondition.sortDirection]]
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.fill]]
   */
  get fill() {
    return this._i;
  }
}
FillSortCondition.$t = markType(FillSortCondition, 'FillSortCondition', SortCondition.$, [IColorSortCondition_$type]);
/**
 * Represents a sort condition which will sort cells based on their fonts colors.
 * <p class="body">
 * This sort condition specifies a single color. Cells of this color will be moved to the beginning of the data range for the ascending
 * sort direction and moved to the end of the data range for the descending sort direction. All matching cells will be kept in their same
 * relative order to each other. In addition, all non-matching cells will be kept in their same relative order to each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export class FontColorSortCondition extends SortCondition {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let fontColorInfo = _rest[0];
          let b = [fontColorInfo, 0];
          {
            let fontColorInfo = b[0];
            let sortDirection = b[1];
            super(1, sortDirection);
            this._j = null;
            if (WorkbookColorInfo.l_op_Equality(fontColorInfo, null)) {
              throw new ArgumentNullException(0, "fontColorInfo");
            }
            this._j = fontColorInfo;
          }
        }
        break;
      case 1:
        {
          let fontColorInfo = _rest[0];
          let sortDirection = _rest[1];
          super(1, sortDirection);
          this._j = null;
          if (WorkbookColorInfo.l_op_Equality(fontColorInfo, null)) {
            throw new ArgumentNullException(0, "fontColorInfo");
          }
          this._j = fontColorInfo;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _accept$2$i($tArg, $tResult, visitor, argument) {
    return visitor._visitFontColorSortCondition$i(this, argument);
  }
  /**
   * @hidden
   */
  _a() {
    let a = new FontColorSortCondition(this._j, this.sortDirection);
    return a;
  }
  /**
   * @hidden
   */
  _g($t, a, b, c, d, e) {
    let f = a.c;
    let g = f._rows$i._aj(b);
    let h = b == c ? g : f._rows$i._aj(c);
    let i = f._b4(g, d);
    let j = f._b4(h, e);
    let k = f.workbook;
    let l = ExcelUtils.ao(k, i, a.a(b, d), this.fontColorInfo);
    let m = ExcelUtils.ao(k, j, a.a(c, e), this.fontColorInfo);
    if (l == m) {
      return 0;
    }
    let n = l ? -1 : 1;
    if (this.sortDirection == 1) {
      return -n;
    }
    return n;
  }
  /**
   * Determines whether the [[FontColorSortCondition]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(FontColorSortCondition.$, obj);
    if (a == null) {
      return false;
    }
    return Base.equalsStatic(this._j, a._j) && super.equals(a);
  }
  /**
   * Gets the hash code for the [[FontColorSortCondition]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return this._j.getHashCode() ^ super.getHashCode();
  }
  /**
   * @hidden
   */
  _f(a) {
    let b = typeCast(FontColorSortCondition.$, a);
    return b == null || WorkbookColorInfo.l_op_Inequality(b._j, this._j);
  }
  /**
   * @hidden
   */
  get__d() {
    return 2;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  static _i(a, b, c) {
    if (nullableEquals(b, null)) {
      return null;
    }
    if (a._g.count <= b.value) {
      return null;
    }
    let d = a._g._inner[b.value];
    let e = d.font.colorInfo;
    if (WorkbookColorInfo.l_op_Equality(e, null)) {
      return null;
    }
    return new FontColorSortCondition(e, c);
  }
  /**
   * Gets the [[WorkbookColorInfo]] which describes the color by which the cells should be sorted.
   * <p class="body">
   * Cells of this color will be moved to the beginning of the data range for the ascending sort direction and moved to the end
   * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
   * In addition, all non-matching cells will be kept in their same relative order to each other.
   * </p>
   * The WorkbookColorInfo which describes the color by which the cells should be sorted.
   * @see [[SortCondition.sortDirection]]
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.font]]
   * @see [[IWorkbookFont.colorInfo]]
   */
  get fontColorInfo() {
    return this._j;
  }
}
FontColorSortCondition.$t = markType(FontColorSortCondition, 'FontColorSortCondition', SortCondition.$, [IColorSortCondition_$type]);
/**
 * @hidden
 */
export let IColorSortConditionVisitor$2_$type = new Type(null, 'IColorSortConditionVisitor$2');
/**
 * Represents a sort condition which will sort cells based on a specific conditioanl formmat icon.
 * <p class="body">
 * This sort condition specifies a single icon. Cells with this icon will be moved to the beginning of the data range for the ascending
 * sort direction and moved to the end of the data range for the descending sort direction. All matching cells will be kept in their same
 * relative order to each other. In addition, all non-matching cells will be kept in their same relative order to each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export class IconSortCondition extends SortCondition {
  constructor(..._rest) {
    let a;
    if (arguments.length === 2) {
      a = 1;
    }
    else if (arguments.length === 3) {
      if (typeCast(Boolean_$type, arguments[0]) !== null) {
        a = 0;
      }
      else if (typeof arguments[0] === 'number') {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          let ascending = _rest[0];
          let iconSetInternal = _rest[1];
          let iconIndex = _rest[2];
          super(1, ascending ? 0 : 1);
          this._l = Nullable$1.toNullable(Number_$type, null);
          this._j = 0;
          this._l = iconIndex;
          this._j = iconSetInternal;
        }
        break;
      case 1:
        {
          let iconSet = _rest[0];
          let iconIndex = _rest[1];
          let b = [iconSet, iconIndex, 0];
          {
            let iconSet = b[0];
            let iconIndex = b[1];
            let sortDirection = b[2];
            super(1, sortDirection);
            this._l = Nullable$1.toNullable(Number_$type, null);
            this._j = 0;
            iconIndex = wrapNullable(Number_$type, iconIndex);
            ExcelUtils.gl(FormatConditionIconSet_$type, iconSet);
            this._j = ExcelUtils.aj(iconSet);
            if (nullableEquals(iconIndex, null)) {
              this._l = Nullable$1.toNullable(Number_$type, null);
            }
            else {
              let c = IconSetConditionalFormat._b9(iconSet);
              if (iconIndex.value < 0 || iconIndex.value >= c.length) {
                throw new ArgumentOutOfRangeException(1, "iconIndex");
              }
              this._l = Nullable$1.toNullable(Number_$type, intSToU((iconIndex.value)));
            }
          }
          iconIndex = wrapNullable(Number_$type, iconIndex);
        }
        break;
      case 2:
        {
          let iconSet = _rest[0];
          let iconIndex = _rest[1];
          let sortDirection = _rest[2];
          super(1, sortDirection);
          this._l = Nullable$1.toNullable(Number_$type, null);
          this._j = 0;
          iconIndex = wrapNullable(Number_$type, iconIndex);
          ExcelUtils.gl(FormatConditionIconSet_$type, iconSet);
          this._j = ExcelUtils.aj(iconSet);
          if (nullableEquals(iconIndex, null)) {
            this._l = Nullable$1.toNullable(Number_$type, null);
          }
          else {
            let b = IconSetConditionalFormat._b9(iconSet);
            if (iconIndex.value < 0 || iconIndex.value >= b.length) {
              throw new ArgumentOutOfRangeException(1, "iconIndex");
            }
            this._l = Nullable$1.toNullable(Number_$type, intSToU((iconIndex.value)));
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _a() {
    let a = new IconSortCondition(this.sortDirection == 0, this._j, this._l);
    return a;
  }
  /**
   * @hidden
   */
  _g($t, a, b, c, d, e) {
    let f = ExcelUtils.ap(a.a(b, d), this._j, this._l);
    let g = ExcelUtils.ap(a.a(c, e), this._j, this._l);
    if (f == g) {
      return 0;
    }
    else {
      let h = f ? -1 : 1;
      if (this.sortDirection == 1) {
        h *= -1;
      }
      return h;
    }
  }
  /**
   * @hidden
   */
  _f(a) {
    let b = typeCast(IconSortCondition.$, a);
    return b == null || b._j != this._j || nullableNotEquals(b._l, this._l);
  }
  /**
   * @hidden
   */
  get__d() {
    return 3;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * The icon set (read-only).
   */
  get iconIndex() {
    return unwrapNullable(this._iconIndex$i);
  }
  /**
   * @hidden
   */
  get _iconIndex$i() {
    return nullableNotEquals(this._l, null) ? Nullable$1.toNullable(Number_$type, this._l.value) : Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * The icon's index in the associated icon set or null for 'NoCellIcon' (read-only).
   */
  get iconSet() {
    return ExcelUtils.t(this._j);
  }
  /**
   * @hidden
   */
  get _n() {
    return this._l;
  }
  /**
   * @hidden
   */
  get _k() {
    return this._j;
  }
}
IconSortCondition.$t = markType(IconSortCondition, 'IconSortCondition', SortCondition.$);
/**
 * Represents an ordered sort condition, which can sort data in either an ascending or descending manner.
 * @see [[SortSettings`1.sortConditions]]
 */
export class OrderedSortCondition extends SortCondition {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let sortDirection = _rest[0];
          super(1, sortDirection);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _a() {
    let a = new OrderedSortCondition(this.sortDirection);
    return a;
  }
  /**
   * @hidden
   */
  _g($t, a, b, c, d, e) {
    let f = a.c;
    let g = f._rows$i._aj(b);
    let h = b == c ? g : f._rows$i._aj(c);
    let i = WorksheetRow._c2(g, d);
    let j = WorksheetRow._c2(h, e);
    if (i == null) {
      if (j == null) {
        return 0;
      }
      return 1;
    }
    else if (j == null) {
      return -1;
    }
    let k = OrderedSortCondition._i($t, a.b, f, i, j);
    if (this.sortDirection == 1) {
      return -k;
    }
    return k;
  }
  /**
   * @hidden
   */
  _f(a) {
    return a == null || a._d != 0;
  }
  /**
   * @hidden
   */
  get__d() {
    return 0;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  static _i($t, a, b, c, d) {
    let e;
    let f = ((() => { let g = ExcelUtils.b0(b.workbook, c, e); e = g.p2; return g.ret; })());
    let g;
    let h = ((() => { let i = ExcelUtils.b0(b.workbook, d, g); g = i.p2; return i.ret; })());
    if (f) {
      if (h) {
        return Base.compareSimple(e, g);
      }
      return -1;
    }
    else if (h) {
      return 1;
    }
    let i = typeCast(Boolean_$type, c) !== null;
    let j = typeCast(Boolean_$type, d) !== null;
    let k = null;
    if (typeCast(ErrorValue.$, c) !== null == false && i == false) {
      k = c.toString();
    }
    let l = null;
    if (typeCast(ErrorValue.$, d) !== null == false && j == false) {
      l = d.toString();
    }
    if (k != null) {
      if (l != null) {
        return StringUtilities.c(k, l, a._q, a.caseSensitive ? 0 : 1);
      }
      return -1;
    }
    else if (l != null) {
      return 1;
    }
    if (i) {
      if (j) {
        return boolCompare(c, d);
      }
      return -1;
    }
    else if (j) {
      return 1;
    }
    return 0;
  }
}
OrderedSortCondition.$t = markType(OrderedSortCondition, 'OrderedSortCondition', SortCondition.$);
/**
 * @hidden
 */
export class SortConditionCollection_SortChangeContext$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.a = null;
    this.b = new KeyValuePair$2(this.$t, SortCondition.$);
    this.c = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.a._f._e.workbook;
  }
  get sheet() {
    return this.a._f._e.worksheet;
  }
  get source() {
    return this.a._f._e;
  }
}
SortConditionCollection_SortChangeContext$1.$t = markStruct(SortConditionCollection_SortChangeContext$1, 'SortConditionCollection_SortChangeContext$1', ValueType.$, [IChangeInfoContext_$type]);
/**
 * An ordered collection of sort conditions which are applied to a sort-able regions in a worksheet.
 * <p class="body">
 * The sort conditions in the collection are applied in order to the data.
 * </p>
 * <p class="note">
 * <B>Note:</B> The collection can hold a maximum of 64 sort condition.
 * </p>
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[SortSettings`1.sortConditions]]
 */
export class SortConditionCollection$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this._d = null;
    /**
     * @hidden
     */
    this._f = null;
    /**
     * @hidden
     */
    this._j = new List$1(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), 0);
    this._e = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._f = a;
  }
  /**
   * @hidden
   */
  containsKey(key) {
    return this._containsKey$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _containsKey$i(a) {
    return this._contains2(a);
  }
  /**
   * @hidden
   */
  get keys() {
    if (this._d == null) {
      this._d = new SortConditionCollection_KeysCollection$1(this.$t, this);
    }
    return this._d;
  }
  /**
   * @hidden
   */
  tryGetValue(key, value) {
    return this._tryGetValue$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _tryGetValue$i(a, b) {
    b = this._item(a);
    return {
      ret: b != null,
      p1: b
    };
  }
  /**
   * @hidden
   */
  get values() {
    if (this._e == null) {
      this._e = new SortConditionCollection_ValuesCollection$1(this.$t, this);
    }
    return this._e;
  }
  indexOf() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(SortCondition.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), arguments[0]) !== null) {
        n = 0;
      }
      else if (typeCast(this.$t, arguments[0]) !== null) {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    switch (n) {
      case 0: return this._indexOf$e.apply(this, arguments);
      case 1: return this._indexOf1.apply(this, arguments);
      case 2: return this._indexOf2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _indexOf$e(a) {
    let b = this._indexOf2(a.key);
    if (b < 0) {
      return b;
    }
    if (this._j._inner[b].value != a.value) {
      return -1;
    }
    return b;
  }
  insert() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._insert$e.apply(this, arguments);
      case 1: return this._insert1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _insert$e(a, b) {
    this._w(a, b);
  }
  /**
   * @hidden
   */
  add(item) {
    this._addItem$i(item.key, item.value);
  }
  contains() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(SortCondition.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), arguments[0]) !== null) {
        n = 0;
      }
      else if (typeCast(this.$t, arguments[0]) !== null) {
        n = 2;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    switch (n) {
      case 0: return this._contains$e.apply(this, arguments);
      case 1: return this._contains1.apply(this, arguments);
      case 2: return this._contains2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _contains$e(a) {
    let b = this._indexOf1(a.value);
    if (b < 0) {
      return false;
    }
    return Base.equalsStatic(this._item1(b).key, a.key);
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._j.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  remove() {
    let n;
    if (arguments.length === 1) {
      if (typeCast(SortCondition.$, arguments[0]) !== null) {
        n = 1;
      }
      else if (typeCast(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 1;
      }
    }
    switch (n) {
      case 0: return this._remove$e.apply(this, arguments);
      case 1: return this._remove2.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _remove$e(a) {
    let b = this._indexOf1(a.value);
    if (b < 0) {
      return false;
    }
    if (Base.equalsStatic(this._item1(b).key, a.key) == false) {
      return false;
    }
    this.removeAt(b);
    return true;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._j.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a sort condition to the collection.
   * @param sortableItem The sort-able item over which the sort condition will be applied.
   * @param sortCondition The sort condition to apply to the sort-able item.
   * @throws [[ArgumentNullException]] 'sortableItem' is null.
   * @throws [[ArgumentNullException]] 'sortCondition' is null.
   * @throws [[ArgumentException]] 'sortableItem' is already has a sort condition applied to it in the collection.
   * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
   */
  addItem(sortableItem, sortCondition) {
    return this._addItem$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _addItem$i(a, b) {
    this._w(this.count, new KeyValuePair$2(this.$t, SortCondition.$, 1, a, b));
  }
  /**
   * @hidden
   */
  _add2(a, b, c = true) {
    this._w(this.count, new KeyValuePair$2(this.$t, SortCondition.$, 1, a, b), true, c);
  }
  /**
   * Adds a range of sort conditions to the collection.
   * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
   * @throws [[ArgumentNullException]] 'entries' is null.
   * @throws [[ArgumentNullException]] If any sort condition is null.
   * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
   * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
   */
  addRange(entries) {
    this.insertRange(this.count, entries);
  }
  /**
   * Clears the collection.
   */
  clear() {
    if (this._j.count == 0) {
      return;
    }
    let a = this._j.count > 1 ? this._q(22) : null;
    for (let b = this._j.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._z();
    this._aa(a);
  }
  /**
   * @hidden
   */
  _contains2(a) {
    return this._indexOf2(a) >= 0;
  }
  /**
   * @hidden
   */
  _contains1(a) {
    return this._indexOf1(a) >= 0;
  }
  /**
   * @hidden
   */
  _indexOf2(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "sortableItem");
    }
    for (let b = 0; b < this._j.count; b++) {
      let c = this._j._inner[b];
      if (Base.equalsStatic(c.key, a)) {
        return b;
      }
    }
    return -1;
  }
  /**
   * @hidden
   */
  _indexOf1(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "sortCondition");
    }
    for (let b = 0; b < this._j.count; b++) {
      let c = this._j._inner[b];
      if (c.value == a) {
        return b;
      }
    }
    return -1;
  }
  /**
   * @hidden
   */
  _insert1(a, b, c) {
    this._w(a, new KeyValuePair$2(this.$t, SortCondition.$, 1, b, c));
  }
  /**
   * Inserts a range of sort conditions into the collection.
   * @param index The 0-based index where the sort condition should be inserted.
   * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
   * @throws [[ArgumentNullException]] 'entries' is null.
   * @throws [[ArgumentNullException]] If any sort condition is null.
   * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
   * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
   */
  insertRange(index, entries) {
    this._y(index, false, entries);
  }
  /**
   * @hidden
   */
  _y(a, b, c) {
    DocCoreUtils.au(c, "entries");
    let d = this._q(80);
    if (b) {
      this.clear();
    }
    let e = null;
    try {
      for (let f of fromEnum(c)) {
        this._w(a++, f, false);
      }
    }
    catch (g) {
      e = g;
    }
    this._z();
    if (e != null) {
      this._ab(d);
    }
    else {
      this._aa(d);
    }
    if (e != null) {
      throw (e);
    }
  }
  /**
   * Removes a sort-able item from the collection.
   * @param sortableItem The sort-able item to remove from the collection.
   * @throws [[ArgumentNullException]] 'sortableItem' is null.
   * @return True if the sort-able item was found and removed; False otherwise.
   */
  removeItem(sortableItem) {
    return this._removeItem$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _removeItem$i(a) {
    let b = this._j.count > 1 ? this._q(80) : null;
    let c = false;
    for (let d = 0; d < this._j.count; d++) {
      let e = this._j._inner[d];
      if (e.key == a) {
        this.removeAt(d);
        c = true;
        d--;
      }
    }
    this._aa(b);
    return c;
  }
  /**
   * @hidden
   */
  _remove2(a) {
    let b = this._indexOf1(a);
    if (b < 0) {
      return false;
    }
    this.removeAt(b);
    return true;
  }
  /**
   * Removes the sort condition at the specified index.
   * @param index The 0-based index of the sort condition to remove.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   */
  removeAt(index) {
    if (index < 0 || this._j.count <= index) {
      throw ExcelUtils.x("index", index, ExcelUtils.ef("LE_ArgumentOutOfRangeException_InvalidRemoveAtIndex_SortConditions"));
    }
    this._ac(index);
  }
  /**
   * Clears the existing sort conditions from the collection and replaces them with new entries in a single atomic operation.
   * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
   * @throws [[ArgumentNullException]] 'entries' is null.
   * @throws [[ArgumentNullException]] If any sort condition is null.
   * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
   * @throws [[InvalidOperationException]] There are more than 64 sort conditions.
   */
  replaceAll(entries) {
    this._y(0, true, entries);
  }
  /**
   * @hidden
   */
  _s(a, b) {
    this._j.add(new KeyValuePair$2(this.$t, SortCondition.$, 1, a, b));
  }
  /**
   * @hidden
   */
  _u() {
    if (this._j != null) {
      this._j.clear();
    }
  }
  /**
   * @hidden
   */
  _ad(a) {
    let b = new List$1(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), 0);
    for (let c of fromEnum(this._j)) {
      if (c.key == a) {
        b.add(c);
      }
    }
    for (let d of fromEnum(b)) {
      this._j.remove(d);
    }
  }
  /**
   * @hidden
   */
  _ag(a) {
    for (let c = 0; c < a.length; c++) {
      let b = a[c];
      this._j.insert(b.d, new KeyValuePair$2(this.$t, SortCondition.$, 1, b.c, b.e));
    }
  }
  /**
   * @hidden
   */
  static _c($t, $tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(SortConditionCollection_SortChangeContext$1.$.specialize($t), $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b($t) {
    let a = new Array(2);
    ChangeInfo.f(a, 0, SortConditionCollection$1._c($t, Nullable$1.$.specialize(KeyValuePair$2.$.specialize($t, SortCondition.$)), "Add", 80, (b) => Nullable$1.toNullable(KeyValuePair$2.$.specialize($t, SortCondition.$), b.b), (b, c) => SortConditionCollection$1._ah($t, b, c)));
    ChangeInfo.f(a, 1, SortConditionCollection$1._c($t, Nullable$1.$.specialize(KeyValuePair$2.$.specialize($t, SortCondition.$)), "Remove", 80, (b) => Nullable$1.toNullable(KeyValuePair$2.$.specialize($t, SortCondition.$), b.b), (b, c) => SortConditionCollection$1._ai($t, b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _w(a, b, c = true, d = true) {
    if (d) {
      this._aj(b.key, b.value);
    }
    let e = this.$type.getStaticFields(SortConditionCollection$1.$)._a[0];
    let f = Nullable$1.toNullable(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), b);
    let g = new SortConditionCollection_SortChangeContext$1(this.$t, 1, this, f.value, a);
    let h = e.b(g.workbook, g.sheet, e.c);
    this._j.insert(a, b);
    if (c) {
      this._z();
    }
    e.e(SortConditionCollection_SortChangeContext$1.$.specialize(this.$t), Nullable$1.$.specialize(KeyValuePair$2.$.specialize(this.$t, SortCondition.$)), g, Nullable$1.toNullable(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), null), f);
    if (h != null) {
      e.d(g.workbook, h);
    }
  }
  /**
   * @hidden
   */
  _z() {
    this._f._w();
  }
  /**
   * @hidden
   */
  _q(a) {
    let b = this._f._e.workbook;
    return b != null && b._cx ? b._go(this._f._e.worksheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _aa(a) {
    if (a != null) {
      let b = this._f._e.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  _ab(a) {
    if (a != null) {
      let b = this._f._e.workbook;
      if (b != null) {
        b._id(a);
      }
    }
  }
  /**
   * @hidden
   */
  _ac(a, b = true) {
    let c = this.$type.getStaticFields(SortConditionCollection$1.$)._a[1];
    let d = Nullable$1.toNullable(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), this._j._inner[a]);
    let e = new SortConditionCollection_SortChangeContext$1(this.$t, 1, this, d.value, a);
    let f = c.b(e.workbook, e.sheet, c.c);
    this._j.removeAt(a);
    if (b) {
      this._z();
    }
    c.e(SortConditionCollection_SortChangeContext$1.$.specialize(this.$t), Nullable$1.$.specialize(KeyValuePair$2.$.specialize(this.$t, SortCondition.$)), e, d, Nullable$1.toNullable(KeyValuePair$2.$.specialize(this.$t, SortCondition.$), null));
    if (f != null) {
      c.d(e.workbook, f);
    }
  }
  /**
   * @hidden
   */
  _af(a, b) {
    this._aj(b.key, b.value, a < this._j.count ? this._j._inner[a].value : null);
    let c = this._q(22);
    this._ac(a, false);
    this._w(a, b, false);
    this._z();
    this._aa(c);
  }
  /**
   * @hidden
   */
  static _ah($t, a, b) {
    let c = a.a._indexOf2(a.b.key);
    if (c >= 0) {
      a.a._ac(c, false);
    }
  }
  /**
   * @hidden
   */
  static _ai($t, a, b) {
    a.a._w(a.c, a.b, false, false);
  }
  /**
   * @hidden
   */
  _aj(a, b, c = null) {
    if (a == null) {
      throw new ArgumentNullException(0, "sortableItem");
    }
    this._f._ag(a);
    if (b == null) {
      throw new ArgumentNullException(0, "sortCondition");
    }
    for (let d = 0; d < this._j.count; d++) {
      let e = this._j._inner[d];
      if (Base.equalsStatic(e.key, a)) {
        if (e.value == c) {
          continue;
        }
        if (!e.value._f(b)) {
          throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentOutOfRangeException_DuplicateItemSorted"), "sortableItem");
        }
      }
    }
    if (this.count == 64) {
      throw new InvalidOperationException(1, ExcelUtils.eg("LE_ArgumentOutOfRangeException_MaxSortConditions", 64));
    }
  }
  /**
   * Gets the number of sort conditions in the collection.
   */
  get count() {
    return this._j.count;
  }
  item() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeCast(this.$t, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._item.apply(this, arguments);
      case 1: return this._item1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _item1(a, b) {
    if (arguments.length === 2) {
      if (b.key == null || b.value == null) {
        throw new ArgumentNullException(0, "value");
      }
      let c = this._indexOf2(b.key);
      if (c == a && this._j._inner[c].value == b.value) {
        return;
      }
      if (c < 0 || c == a) {
        this._af(a, b);
        return;
      }
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentOutOfRangeException_DuplicateItemSorted"), "value");
      return b;
    }
    else {
      return this._j._inner[a];
    }
  }
  /**
   * @hidden
   */
  _item(a, b) {
    if (arguments.length === 2) {
      if (a == null) {
        throw new ArgumentNullException(0, "sortableItem");
      }
      let c = this._indexOf2(a);
      if (c < 0) {
        if (b != null) {
          this._addItem$i(a, b);
        }
        return;
      }
      if (b == null) {
        this.removeAt(c);
        return;
      }
      this._af(c, new KeyValuePair$2(this.$t, SortCondition.$, 1, a, b));
      return b;
    }
    else {
      if (a == null) {
        throw new ArgumentNullException(0, "sortableItem");
      }
      let b = this._indexOf2(a);
      if (b < 0) {
        return null;
      }
      return this._j._inner[b].value;
    }
  }
}
SortConditionCollection$1.$t = markType(SortConditionCollection$1, 'SortConditionCollection$1', Base.$, [IDictionary$2_$type.specialize(0, SortCondition.$), IList$1_$type.specialize(KeyValuePair$2.$.specialize(0, SortCondition.$))], function () {
  this._a = SortConditionCollection$1._b(arguments[0]);
});
/**
 * @hidden
 */
SortConditionCollection$1._n = 64;
/**
 * @hidden
 */
SortConditionCollection$1._k = 0;
/**
 * @hidden
 */
SortConditionCollection$1._p = 1;
/**
 * @hidden
 */
SortConditionCollection$1._o = 2;
/**
 * @hidden
 */
export class SortConditionCollection_KeysCollection$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this._a = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._a = a;
  }
  _b() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotModifyKeysCollection"));
  }
  add(a) {
    this._b();
  }
  clear() {
    this._b();
  }
  contains(a) {
    return this._a._contains2(a);
  }
  copyTo(a, b) {
    for (let c = 0; c < this._a.count; c++) {
      a[b + c] = this._a._j._inner[c].key;
    }
  }
  get count() {
    return this._a.count;
  }
  get isReadOnly() {
    return true;
  }
  remove(a) {
    this._b();
    return false;
  }
  *_getEnumerator() {
    for (let a of fromEnum(this._a)) {
      yield a.key;
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
}
SortConditionCollection_KeysCollection$1.$t = markType(SortConditionCollection_KeysCollection$1, 'SortConditionCollection_KeysCollection$1', Base.$, [ICollection$1_$type.specialize(0)]);
/**
 * @hidden
 */
export class SortConditionCollection_ValuesCollection$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this._a = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._a = a;
  }
  _b() {
    throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_CannotModifyValuesCollection"));
  }
  add(a) {
    this._b();
  }
  clear() {
    this._b();
  }
  contains(a) {
    return this._a._contains1(a);
  }
  copyTo(a, b) {
    for (let c = 0; c < this._a.count; c++) {
      a[b + c] = this._a._j._inner[c].value;
    }
  }
  get count() {
    return this._a.count;
  }
  get isReadOnly() {
    return true;
  }
  remove(a) {
    this._b();
    return false;
  }
  *_getEnumerator() {
    for (let a of fromEnum(this._a)) {
      yield a.value;
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
}
SortConditionCollection_ValuesCollection$1.$t = markType(SortConditionCollection_ValuesCollection$1, 'SortConditionCollection_ValuesCollection$1', Base.$, [ICollection$1_$type.specialize(SortCondition.$)]);
/**
 * @hidden
 */
export class SortSettings_SortChangeContext$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.a = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
        }
        break;
    }
  }
  get workbook() {
    return this.a._d.workbook;
  }
  get sheet() {
    return this.a._d.worksheet;
  }
  get source() {
    return this.a._d;
  }
}
SortSettings_SortChangeContext$1.$t = markStruct(SortSettings_SortChangeContext$1, 'SortSettings_SortChangeContext$1', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class SortSettings_ShiftFormulaChangeContext$1 extends ValueType {
  constructor($t, a, ..._rest) {
    super();
    this.$t = null;
    this.a = new CellShiftOperation();
    this.b = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.a = c;
          this.b = d;
        }
        break;
    }
  }
  c() {
    let a = this.a.w;
    let b = new CellShiftOperation(1, this.sheet, 3, this.a.l._ac + a, this.a.l._ae + a, this.a.l._w, this.a.l._x, -a);
    let c = typeCast(ArrayInteriorFormula.$, this.b);
    if (c != null) {
      let d = c._cz.cellRange._d(b, false);
    }
    this.b._av(this.sheet, b, 1);
    SortSettings$1.$t.specialize(this.$t).getStaticFields()._a[1].x(new SortSettings_ShiftFormulaChangeContext$1(this.$t, 1, b, this.b), null, null);
  }
  get workbook() {
    return this.a.h.workbook;
  }
  get sheet() {
    return this.a.h;
  }
  get source() {
    return this.a.h;
  }
}
SortSettings_ShiftFormulaChangeContext$1.$t = markStruct(SortSettings_ShiftFormulaChangeContext$1, 'SortSettings_ShiftFormulaChangeContext$1', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Represents the settings which apply to sorting a region of values.
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[WorksheetTable.sortSettings]]
 */
export class SortSettings$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this._l = false;
    /**
     * @hidden
     */
    this._d = null;
    this._f = null;
    this._p = null;
    this._h = 0;
    this._k = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._d = a;
    this._k = b;
  }
  /**
   * @hidden
   */
  _w() {
    this._d.onSortSettingsModified();
  }
  /**
   * @hidden
   */
  _v(a) {
    this._l = a._l;
    this._p = a._p;
    this._h = a._h;
  }
  /**
   * @hidden
   */
  _y() {
    let a = this._d.sortRegion;
    if (a == null) {
      return;
    }
    let b = a.worksheet;
    if (b == null) {
      return;
    }
    let c = this._j == 0;
    let d = c ? a._aa : a._ad;
    if (d == 1) {
      return;
    }
    let e = b.workbook;
    if (e != null && e._c4) {
      return;
    }
    if (this._sortConditions$i.count == 0) {
      return;
    }
    let f = this._u(2);
    try {
      let g = new List$1(Number_$type, 2, d);
      let h = new List$1(SortSettings_VisibleRowIndexBlock$1.$.specialize(this.$t), 0);
      let i = a._h;
      let j = null;
      for (let k = i._ac; k <= i._ae; k++) {
        let l = b._rows$i._aj(k);
        if (l != null) {
          for (let m of fromEnum(l._ch(i._w, i._x, true))) {
            if (m.o && m.d.l(m.h, m.f)) {
              let n = typeCast(Formula.$, m.t(l));
              if (n._as) {
                l.worksheet._h3(n, false);
                n._bt(e);
              }
            }
          }
        }
        if (b._eg(k)) {
          if (j != null) {
            h.add(j);
            j = null;
          }
          continue;
        }
        if (j == null) {
          j = new SortSettings_VisibleRowIndexBlock$1(this.$t, k);
        }
        else {
          j.b++;
        }
        if (c) {
          g.add(k);
        }
      }
      if (j != null) {
        h.add(j);
      }
      let o;
      if (c) {
        o = new SortSettings_RowIndexComparer$1(this.$t, this, b, i._w);
      }
      else {
        o = new SortSettings_ColumnIndexComparer$1(this.$t, this, b, i._ac);
        for (let p = i._w; p <= i._x; p++) {
          if (!b._ec(p)) {
            g.add(p);
          }
        }
      }
      let q = new List$1(Number_$type, 1, g);
      DocCoreUtils.ar(Number_$type, g, o);
      let r = 0;
      for (let s = 0; s < h.count; s++) {
        let t = h._inner[s];
        if (c) {
          for (let u = t.c; u <= t.a; u++) {
            let v = r++;
            let w = g._inner[v];
            if (u == w) {
              continue;
            }
            let x = g.indexOf2(u, r);
            if (x < 0) {
              continue;
            }
            let y = g._inner[x];
            g._inner[v] = y;
            g._inner[x] = w;
            let z = b._rows$i.item(w);
            let aa = b._rows$i.item(y);
            SortSettings$1._af(this.$t, z, aa, i._w, i._x);
          }
        }
        else {
          let ab = i._w;
          for (let ac = 0; ac < g.count; ac++) {
            let ad = r++;
            let ae = g._inner[ad];
            let af = g.indexOf2((ac + ab), r);
            if (af < 0) {
              continue;
            }
            let ag = g._inner[af];
            g._inner[ad] = ag;
            g._inner[af] = ae;
            SortSettings$1._ae(this.$t, b, ae, ag, t.c, t.a);
          }
        }
      }
    }
    finally {
      this._x(f);
    }
  }
  /**
   * @hidden
   */
  _ag(a) {
    if (this._k != null) {
      this._k(a);
    }
  }
  /**
   * @hidden
   */
  static _c($t, $tChangeContext, $tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2($tChangeContext, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b($t) {
    let a = new Array(2);
    ChangeInfo.f(a, 0, SortSettings$1._c($t, SortSettings_SortChangeContext$1.$.specialize($t), Boolean_$type, "CaseSensitive", 80, (b) => b.a.caseSensitive, (b, c) => b.a.caseSensitive = c, (b, c) => b.a._z(c)));
    ChangeInfo.f(a, 1, SortSettings$1._c($t, SortSettings_ShiftFormulaChangeContext$1.$.specialize($t), Base.$, "ShiftFormula", 80, (b) => null, (b, c) => b.c(), void 0, void 0, false, 0));
    return a;
  }
  /**
   * @hidden
   */
  _u(a) {
    let b = this._e.workbook;
    return b != null && b._cx ? b._go(this._e.worksheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _x(a) {
    if (a != null) {
      let b = this._e.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _aa($t, a, b, c) {
    let d = a._bc(c);
    let e = b._bc(c);
    let f = d.d._bu();
    d.setFormatting(e);
    e.setFormatting(f);
  }
  /**
   * @hidden
   */
  static _ab($t, a, b, c) {
    let d = a._bc(b);
    let e = a._bc(c);
    let f = d.d._bu();
    d.setFormatting(e);
    e.setFormatting(f);
  }
  /**
   * @hidden
   */
  static _ac($t, a, b, c) {
    let d = a.worksheet;
    let e = c.r;
    let f = b._a1(e);
    if (c.o || f.j(e)) {
      let g = c.d || a._a1(e);
      let h = g.aa(a, e);
      let i = f.aa(b, e);
      let j;
      let k = g.ao(a, e, null, j);
      j = k.p3;
      let l = f.ao(b, e, null, j);
      j = l.p3;
      let m = g.ao(a, e, i, j);
      j = m.p3;
      let n = f.ao(b, e, h, j);
      j = n.p3;
      let o = typeCast(Formula.$, h);
      if (o != null) {
        let p = new CellShiftOperation(1, d, 3, a.index, a.index, e, e, b.index - a.index);
        let q = typeCast(ArrayInteriorFormula.$, o);
        if (q != null) {
          let r = q._cz.cellRange._d(p, false);
        }
        o._av(d, p, 1);
        SortSettings$1.$.specialize($t).specialize($t).getStaticFields()._a[1].x(new SortSettings_ShiftFormulaChangeContext$1($t, 1, p, o), null, null);
      }
      let s = typeCast(Formula.$, i);
      if (s != null) {
        let t = new CellShiftOperation(1, d, 3, b.index, b.index, e, e, a.index - b.index);
        let u = typeCast(ArrayInteriorFormula.$, s);
        if (u != null) {
          let v = u._cz.cellRange._d(t, false);
        }
        s._av(d, t, 1);
        SortSettings$1.$.specialize($t).specialize($t).getStaticFields()._a[1].x(new SortSettings_ShiftFormulaChangeContext$1($t, 1, t, s), null, null);
      }
    }
    SortSettings$1._aa($t, a, b, e);
  }
  /**
   * @hidden
   */
  static _ad($t, a, b, c) {
    let d = a.worksheet;
    let e = b.r;
    let f = c.r;
    if (e == f) {
      return;
    }
    let g = a._a1(f);
    if (b.o || g.j(f)) {
      let h = b.d || a._a1(e);
      let i = h.aa(a, e);
      let j = g.aa(a, f);
      let k;
      let l = h.ao(a, e, null, k);
      k = l.p3;
      let m = g.ao(a, f, null, k);
      k = m.p3;
      let n = h.ao(a, e, j, k);
      k = n.p3;
      let o = g.ao(a, f, i, k);
      k = o.p3;
      let p = typeCast(Formula.$, i);
      if (p != null) {
        let q = new CellShiftOperation(1, d, 0, a.index, a.index, e, e, f - e);
        let r = typeCast(ArrayInteriorFormula.$, p);
        if (r != null) {
          let s = r._cz.cellRange._d(q, false);
        }
        p._av(d, q, 1);
        SortSettings$1.$.specialize($t).specialize($t).getStaticFields()._a[1].x(new SortSettings_ShiftFormulaChangeContext$1($t, 1, q, p), null, null);
      }
      let t = typeCast(Formula.$, j);
      if (t != null) {
        let u = new CellShiftOperation(1, d, 0, a.index, a.index, f, f, e - f);
        let v = typeCast(ArrayInteriorFormula.$, t);
        if (v != null) {
          let w = v._cz.cellRange._d(u, false);
        }
        t._av(d, u, 1);
        SortSettings$1.$.specialize($t).specialize($t).getStaticFields()._a[1].x(new SortSettings_ShiftFormulaChangeContext$1($t, 1, u, t), null, null);
      }
    }
    SortSettings$1._ab($t, a, e, f);
  }
  /**
   * @hidden
   */
  static _ae($t, a, b, c, d, e) {
    for (let f = d; f <= e; f++) {
      let g = a._rows$i.item(f);
      let h = g._am(b, true);
      let i = g._am(c, true);
      SortSettings$1._ad($t, g, h, i);
    }
  }
  /**
   * @hidden
   */
  static _af($t, a, b, c, d) {
    let e = a.worksheet;
    let f = d - c + 1;
    let g = new BitArray(2, f);
    let h = true;
    let i = c;
    for (let j of fromEnum(a._ch(c, d))) {
      if (i != j.r) {
        h = false;
      }
      g.item(j.r - c, true);
      SortSettings$1._ac($t, a, b, j);
      i = j.r + 1;
    }
    if (i != d + 1) {
      h = false;
    }
    if (h == false) {
      for (let k of fromEnum(b._ch(c, d))) {
        let l = k.r - c;
        if (g.item(l)) {
          continue;
        }
        g.item(l, true);
        SortSettings$1._ac($t, b, a, k);
      }
      if (a._hasCellFormat || b._hasCellFormat) {
        for (let m = 0; m < f; m++) {
          if (g.item(m)) {
            continue;
          }
          SortSettings$1._aa($t, b, a, m);
        }
      }
    }
  }
  /**
   * Gets or sets the value which indicates whether strings should be compared case-sensitively when they are sorted.
   * <p class="body">
   * This is only applicable to sort conditions which sort strings.
   * </p>
   * True to sort strings case-sensitively; False to ignore case.
   */
  get caseSensitive() {
    return this._l;
  }
  /**
   * Gets or sets the value which indicates whether strings should be compared case-sensitively when they are sorted.
   * <p class="body">
   * This is only applicable to sort conditions which sort strings.
   * </p>
   * True to sort strings case-sensitively; False to ignore case.
   */
  set caseSensitive(a) {
    if (this.caseSensitive == a) {
      return;
    }
    this.$type.getStaticFields(SortSettings$1.$)._a[0].h(SortSettings_SortChangeContext$1.$.specialize(this.$t), Boolean_$type, new SortSettings_SortChangeContext$1(this.$t, 1, this), a);
  }
  /**
   * @hidden
   */
  _z(a) {
    this._l = a;
    this._w();
  }
  sortConditions() {
    if (arguments.length !== 0) {
      let a = this._sortConditions$i;
      return a.item.apply(a, arguments);
    }
    return this._sortConditions$i;
  }
  /**
   * @hidden
   */
  get _sortConditions$i() {
    if (this._f == null) {
      this._f = new SortConditionCollection$1(this.$t, this);
    }
    return this._f;
  }
  /**
   * @hidden
   */
  get _n() {
    if (this._d._culture$i.name == "zh-TW") {
      return this._i == 1;
    }
    return this._i == 2;
  }
  /**
   * @hidden
   */
  get _o() {
    return this._l || this._h != 0 || (this._f != null && this._f.count != 0);
  }
  /**
   * @hidden
   */
  get _e() {
    return this._d;
  }
  /**
   * @hidden
   */
  get _q() {
    if (this._p == null) {
      this._p = this._d._culture$i;
      let a = ExcelUtils.ge(this._p, this._i);
      this._p = a.p0;
    }
    return this._p;
  }
  /**
   * @hidden
   */
  get _i() {
    return this._h;
  }
  /**
   * @hidden
   */
  set _i(a) {
    if (this._i == a) {
      return;
    }
    this._h = a;
    this._p = null;
    this._w();
  }
  /**
   * @hidden
   */
  get__j() {
    return 0;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
}
SortSettings$1.$t = markType(SortSettings$1, 'SortSettings$1', Base.$, null, function () {
  this._a = SortSettings$1._b(arguments[0]);
});
/**
 * @hidden
 */
SortSettings$1._r = 0;
/**
 * @hidden
 */
SortSettings$1._t = 1;
/**
 * @hidden
 */
SortSettings$1._s = 2;
/**
 * @hidden
 */
export class SortSettings_ColumnIndexComparer$1 extends Base {
  constructor($t, a, b, c) {
    super();
    this.$t = null;
    this._c = 0;
    this._a = null;
    this._b = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._c = c;
    this._a = a;
    this._b = new SortSettings_SortOperation$1(this.$t, a, b);
  }
  compare(a, b) {
    for (let c = 0; c < this._a._sortConditions$i.count; c++) {
      let d = this._a._sortConditions$i._item1(c);
      let e = this._c + d.key.index;
      let f = d.value._g(this.$t, this._b, e, e, a, b);
      if (f != 0) {
        return f;
      }
    }
    return 0;
  }
}
SortSettings_ColumnIndexComparer$1.$t = markType(SortSettings_ColumnIndexComparer$1, 'SortSettings_ColumnIndexComparer$1', Base.$, [IComparer$1_$type.specialize(Number_$type)]);
/**
 * @hidden
 */
export class SortSettings_RowIndexComparer$1 extends Base {
  constructor($t, a, b, c) {
    super();
    this.$t = null;
    this._c = 0;
    this._a = null;
    this._b = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this._c = c;
    this._a = a;
    this._b = new SortSettings_SortOperation$1(this.$t, a, b);
  }
  compare(a, b) {
    for (let c = 0; c < this._a._sortConditions$i.count; c++) {
      let d = this._a._sortConditions$i._item1(c);
      let e = (this._c + d.key.index);
      let f = d.value._g(this.$t, this._b, a, b, e, e);
      if (f != 0) {
        return f;
      }
    }
    return 0;
  }
}
SortSettings_RowIndexComparer$1.$t = markType(SortSettings_RowIndexComparer$1, 'SortSettings_RowIndexComparer$1', Base.$, [IComparer$1_$type.specialize(Number_$type)]);
/**
 * @hidden
 */
export class SortSettings_VisibleRowIndexBlock$1 extends Base {
  constructor($t, a) {
    super();
    this.$t = null;
    this.b = 0;
    this.c = 0;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.c = a;
    this.b = 1;
  }
  get a() {
    return this.c + this.b - 1;
  }
}
SortSettings_VisibleRowIndexBlock$1.$t = markType(SortSettings_VisibleRowIndexBlock$1, 'SortSettings_VisibleRowIndexBlock$1');
/**
 * @hidden
 */
export class SortSettings_SortOperation$1 extends Base {
  constructor($t, a, b) {
    super();
    this.$t = null;
    this.b = null;
    this.c = null;
    this.d = null;
    this.$t = $t;
    this.$type = this.$type.specialize(this.$t);
    this.b = a;
    this.c = b;
  }
  a(a, b) {
    if (this.d == null) {
      this.d = new Dictionary$2(String_$type, CellConditionalFormat.$, 0);
    }
    let c = a + "-" + b;
    let d;
    if (!((() => { let e = this.d.tryGetValue(c, d); d = e.p1; return e.ret; })())) {
      this.d.item(c, d = this.c._getCellConditionalFormat1(a, b));
    }
    return d;
  }
}
SortSettings_SortOperation$1.$t = markType(SortSettings_SortOperation$1, 'SortSettings_SortOperation$1');
/**
 * Represents the settings which apply to sorting a region of values based on indices relative to either the Worksheet's [[Worksheet.filterSettings]] or [[Worksheet.sortSettings]] region.
 */
export class RelativeIndexSortSettings extends SortSettings$1 {
  constructor(a, b) {
    super(RelativeIndex.$, a, b);
    this._ah = false;
  }
  /**
   * @hidden
   */
  _w() {
    if (!this._ah) {
      super._w();
    }
  }
  /**
   * Initializes the region to null
   */
  initializeRegion() {
  }
  /**
   * @hidden
   */
  _aj(a, b, c) {
    let d = this._j == 0;
    let e;
    let f;
    let g;
    let h;
    let i = -1;
    let j = -1;
    let k = -1;
    if (d) {
      if (a._af == b._af) {
        return;
      }
      e = b._w;
      f = b._x;
      g = a._w;
      h = a._x;
      if (WorksheetRegionAddress._r(c.y, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        i = c.y.value._w;
      }
      if (WorksheetRegionAddress._r(c.x, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        j = c.x.value._w;
        k = c.x.value._x;
      }
    }
    else {
      if (a._ad == b._ad) {
        return;
      }
      e = b._ac;
      f = b._ae;
      g = a._ac;
      h = a._ae;
      if (WorksheetRegionAddress._r(c.y, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        i = c.y.value._ac;
      }
      if (WorksheetRegionAddress._r(c.x, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        j = c.x.value._ac;
        k = c.x.value._ae;
      }
    }
    let l = Nullable$1.toNullable(Number_$type, null);
    if (j >= 0) {
      if (j < e && k > e) {
        l = Nullable$1.toNullable(Number_$type, c.w + (e - j));
      }
    }
    if (nullableEquals(l, null) && i >= 0) {
      if (g > e) {
        l = Nullable$1.toNullable(Number_$type, c.w - (g - e));
      }
    }
    let m = nullableNotEquals(l, null) ? l.value : c.w;
    this._ah = true;
    try {
      let n = new List$1(KeyValuePair$2.$.specialize(RelativeIndex.$, SortCondition.$), 0);
      if (i >= 0) {
        for (let o of fromEnum(this._sortConditions$i)) {
          let p = o.key;
          if (p.index + g >= i) {
            n.add(o);
          }
        }
      }
      if (j >= 0) {
        let q = new List$1(RelativeIndex.$, 0);
        for (let r of fromEnum(this._sortConditions$i)) {
          let s = r.key;
          let t = s.index + e;
          if (t >= j) {
            if (t <= k) {
              if (n.count > 0) {
                n.remove(r);
              }
              q.add(s);
            }
            else {
              n.add(r);
            }
          }
        }
        if (q.count > 0) {
          for (let u of fromEnum(q)) {
            this._sortConditions$i._removeItem$i(u);
          }
        }
      }
      if (n.count > 0) {
        let v = this._e.workbook._df;
        this._e.workbook._df = true;
        for (let w of fromEnum(n)) {
          this._sortConditions$i._removeItem$i(w.key);
          this._sortConditions$i._add2(new RelativeIndex(Math.max(0, w.key.index + m)), w.value, false);
        }
        this._e.workbook._df = v;
      }
    }
    finally {
      this._ah = false;
    }
  }
  /**
   * @hidden
   */
  _ak(a) {
    if (this._sortConditions$i.count == 0) {
      return;
    }
    let b = null;
    for (let c of fromEnum(this._sortConditions$i)) {
      if (c.key.index >= a) {
        if (b == null) {
          b = new List$1(RelativeIndex.$, 0);
        }
        b.add(c.key);
      }
    }
    if (b != null) {
      for (let d of fromEnum(b)) {
        this._sortConditions$i._ad(d);
      }
    }
  }
  /**
   * @hidden
   */
  _al() {
    let a = this._e.sortRegion;
    if (a != null) {
      let b = false;
      for (let c of fromEnum(a.worksheet._tables$i)) {
        if (a._s(c.wholeTableRegion)) {
          b = true;
          break;
        }
      }
      if (b) {
        this._sortConditions$i._u();
        this.initializeRegion();
      }
    }
  }
}
RelativeIndexSortSettings.$t = markType(RelativeIndexSortSettings, 'RelativeIndexSortSettings', SortSettings$1.$.specialize(RelativeIndex.$));
/**
 * Exposes methods to identify a region in the wroksheet and to apply sort criteria to that region.
 */
export class WorksheetSortSettings extends RelativeIndexSortSettings {
  constructor(a, b) {
    super(a, b);
    this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._a8 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._ay = false;
    this._as = null;
    this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._ar = 0;
    this._aw = 0;
    this._a1 = 0;
    this._as = a;
  }
  /**
   * Initializes the region to null
   */
  initializeRegion() {
    this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
  }
  /**
   * @hidden
   */
  get__j() {
    return this.sortType;
  }
  /**
   * Returns the region that the filter settings is applied to (read-only).
   * @see [[setRegion]]
   * @see [[setRegion]]
   */
  get region() {
    if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return null;
    }
    return this._as._cw(this._a6.value);
  }
  /**
   * Determines whether columns or rows will be sorted within the region. 'Rows' is the default.
   * <para class="note"><b>Note:</b> when this property is changed all existing sort conditions will be cleared so this property should be set before sort conditions are added.</para>
   */
  get sortType() {
    return this._aw;
  }
  /**
   * Determines whether columns or rows will be sorted within the region. 'Rows' is the default.
   * <para class="note"><b>Note:</b> when this property is changed all existing sort conditions will be cleared so this property should be set before sort conditions are added.</para>
   */
  set sortType(a) {
    if (this._aw == a) {
      return;
    }
    ExcelUtils.gl(WorksheetSortType_$type, a);
    let b = this._u(22);
    if (this._sortConditions$i.count > 0) {
      this._ba();
    }
    else {
      this._w();
    }
    WorksheetSortSettings._am[2].h(WorksheetSortSettings.$, WorksheetSortType_$type, this, a);
    this._x(b);
  }
  /**
   * @hidden
   */
  _bk(a) {
    this._aw = a;
  }
  /**
   * @hidden
   */
  get _au() {
    return WorksheetRegionAddress._r(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? this._a6.value : WorksheetRegionAddress._b;
  }
  /**
   * @hidden
   */
  set _au(a) {
    if (!a._n) {
      if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return;
      }
    }
    else {
      if (WorksheetRegionAddress._r(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._o(this._a6.value, a)) {
        return;
      }
    }
    WorksheetSortSettings._am[0].h(WorksheetSortSettings.$, WorksheetRegionAddress.$, this, a);
  }
  /**
   * @hidden
   */
  _bh(a) {
    if (!a._n) {
      this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
    else {
      this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, a);
    }
    this._ay = false;
    this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
  }
  /**
   * @hidden
   */
  get _av() {
    return WorksheetRegionAddress._r(this._a7, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? this._a7.value : WorksheetRegionAddress._b;
  }
  /**
   * @hidden
   */
  set _av(a) {
    WorksheetSortSettings._am[1].h(WorksheetSortSettings.$, WorksheetRegionAddress.$, this, a);
  }
  /**
   * @hidden
   */
  _bi(a) {
    if (!a._n) {
      this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
    else {
      this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, a);
    }
  }
  /**
   * Clears the region as well as any existing sort criteria
   * @see [[setRegion]]
   * @see [[setRegion]]
   */
  clearRegion() {
    this._bj(null);
  }
  /**
   * Re-sorts all data cells in the region based on the sort conditions.
   * @see [[SortSettings`1.sortConditions]]
   */
  reapplySortConditions() {
    if (this._ay) {
      return;
    }
    if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || this._sortConditions$i.count == 0) {
      return;
    }
    this._y();
  }
  setRegion() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setRegion.apply(this, arguments);
      case 1: return this._setRegion1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setRegion(a) {
    this._setRegion1(a, this._as._c);
  }
  /**
   * @hidden
   */
  _setRegion1(a, b) {
    this._bj(this._as._getRegion2(a, b, null));
  }
  /**
   * @hidden
   */
  _bj(a) {
    let b = new WorksheetRegionAddress();
    if (a != null) {
      b = a._h;
      if (WorksheetRegionAddress._r(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._o(this._a6.value, b)) {
        return;
      }
    }
    else {
      if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return;
      }
      b = WorksheetRegionAddress._b;
    }
    if (a != null) {
      if (a.worksheet != this._as) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_RegionMustBeOnSameWorksheet"));
      }
      for (let c of fromEnum(this._as._tables$i)) {
        if (a._s(c.wholeTableRegion)) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_OverlappingTable"));
        }
      }
      for (let d of fromEnum(this._as._rows$i._m(a.firstRow, a.lastRow))) {
        for (let e = a._v; e <= a._w; e++) {
          if (d._bp(e) != null) {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_OverlappingTable"));
          }
          let f = typeCast(IRegionBlockingSingleCellComponent_$type, d._c5(e));
          if (f != null) {
            f.owningValue.throwBlockingException();
          }
        }
      }
    }
    let g = this._u(22);
    try {
      this._bn();
      this._ba();
    }
    finally {
      this._bd();
    }
    this._au = b;
    this._x(g);
  }
  /**
   * @hidden
   */
  _bb(a) {
    if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return;
    }
    switch (a) {
      case 0:
      case 1: return;
    }
    let b = this._as._o;
    switch (b) {
      default: return;
      case 0:
      case 1: break;
    }
    let c = this._as._rows$i.maxCount;
    let d = this._as._columns$i.maxCount;
    let e = this._a6.value;
    if (e._ac >= c - 1 || e._w >= d) {
      this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      this._a1 = 0;
      this._ay = false;
      this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      this._a8 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      return;
    }
    if (e._ae >= c || e._x >= d) {
      if (e._ae >= c) {
        e = e._f(c - 1);
      }
      if (e._x >= d) {
        e = e._e((d - 1));
      }
      this._a6 = Nullable$1.toNullable(WorksheetRegionAddress.$, e);
      this._a1 = 0;
      this._ak(e._af);
      this._ay = false;
      this._a7 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      this._a8 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
  }
  /**
   * @hidden
   */
  _bd() {
    this._a1--;
    if (this._a1 <= 0 && this._a0) {
      this._a0 = false;
      this.reapplySortConditions();
    }
  }
  /**
   * @hidden
   */
  _aq(a, b) {
    let c = this._as.workbook;
    let d = a.l;
    let e = this._au;
    if (!(d._k(c) || d._l(c))) {
      if (!d._h(e)) {
        return ShiftAddressResult.d;
      }
    }
    let f = e;
    let g = true;
    let h = this._ay;
    if (h) {
      if (WorksheetRegionAddress._p(this._a7, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return ShiftAddressResult.d;
      }
      if (WorksheetRegionAddress._r(this._a7, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        g = false;
        f = this._a7.value;
      }
    }
    else {
      if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return ShiftAddressResult.d;
      }
    }
    if (g) {
      let i = ((() => { let j = a.e(f, false); f = j.p0; return j.ret; })());
      if (WorksheetRegionAddress._o(e, f)) {
        return ShiftAddressResult.d;
      }
      if (this.sortType == 0) {
        if (e._w < f._w) {
          f = f._c(Math.max(e._w, a.l._w));
        }
      }
      else {
        if (e._ac < f._ac) {
          f = f._d(Math.max(e._ac, a.l._ac));
        }
      }
    }
    if (WorksheetRegionAddress._o(e, f)) {
      return ShiftAddressResult.d;
    }
    let j = f._af < 1 || f._ad < 1;
    if (j) {
      this._ba();
    }
    else {
      this._aj(f, e, a);
    }
    if (h) {
      this._a6 = j ? Nullable$1.toNullable(WorksheetRegionAddress.$, null) : Nullable$1.toNullable(WorksheetRegionAddress.$, f);
    }
    else {
      this._au = j ? WorksheetRegionAddress._b : f;
    }
    return ShiftAddressResult.c;
  }
  /**
   * @hidden
   */
  _bl(a) {
    this._ay = true;
    this._a8 = this._a6;
  }
  /**
   * @hidden
   */
  _bm() {
    if (!this._ay) {
      return;
    }
    this._ay = false;
    this._a7 = this._a8;
    this._av = this._au;
    this._a8 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
  }
  /**
   * @hidden
   */
  _bn() {
    this._a1++;
  }
  /**
   * @hidden
   */
  _ba() {
    this._sortConditions$i.clear();
  }
  /**
   * @hidden
   */
  _az(a) {
    return (this._ar & a) == a;
  }
  /**
   * @hidden
   */
  get _a0() {
    return this._az(1);
  }
  /**
   * @hidden
   */
  set _a0(a) {
    this._be(1, a);
  }
  /**
   * @hidden
   */
  _be(a, b) {
    if (b) {
      this._ar |= a;
    }
    else {
      this._ar &= ~a;
    }
  }
  /**
   * @hidden
   */
  _bo(a) {
    if (WorksheetRegionAddress._p(this._a6, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      throw new InvalidOperationException(1, "No region specified.");
    }
    if (a < 0 || a >= this._a6.value._af) {
      throw new ArgumentOutOfRangeException(1, "relativeColumnIndex");
    }
  }
  /**
   * @hidden
   */
  static _ao($tValue, a, b, c, d, e = null, f = true, g = false, h = 0) {
    return new ChangeInfo$2(WorksheetSortSettings.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _ap($tContext, $tValue, a, b, c, d, e = null, f = true, g = false, h = 8192 | 16384) {
    return new ChangeInfo$2($tContext, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _an() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, WorksheetSortSettings._ao(WorksheetRegionAddress.$, "RegionAddress", 80, (b) => b._au, (b, c) => b._au = c, (b, c) => b._bh(c), true, false));
    ChangeInfo.f(a, 1, WorksheetSortSettings._ao(WorksheetRegionAddress.$, "RegionAddress", 80, (b) => b._av, (b, c) => b._av = c, (b, c) => b._bi(c), true, false));
    ChangeInfo.f(a, 2, WorksheetSortSettings._ao(WorksheetSortType_$type, "SortType", 80, (b) => b.sortType, (b, c) => b.sortType = c, (b, c) => b._bk(c), true, false));
    return a;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._as.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._as;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
}
WorksheetSortSettings.$t = markType(WorksheetSortSettings, 'WorksheetSortSettings', RelativeIndexSortSettings.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
WorksheetSortSettings._a3 = 0;
/**
 * @hidden
 */
WorksheetSortSettings._a4 = 1;
/**
 * @hidden
 */
WorksheetSortSettings._a5 = 2;
/**
 * @hidden
 */
WorksheetSortSettings._a2 = 2 + 1;
/**
 * @hidden
 */
WorksheetSortSettings._am = WorksheetSortSettings._an();
/**
 * Represents the diamond shape.
 */
export class DiamondShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitDiamondShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 4);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 5);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
DiamondShape.$t = markType(DiamondShape, 'DiamondShape', WorksheetShapeWithText.$);
/**
 * Represents the ellipse shape.
 */
export class EllipseShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitEllipseShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 3);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 34);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
EllipseShape.$t = markType(EllipseShape, 'EllipseShape', WorksheetShapeWithText.$);
/**
 * Represents the heart shape.
 */
export class HeartShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitHeartShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 74);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 75);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
HeartShape.$t = markType(HeartShape, 'HeartShape', WorksheetShapeWithText.$);
/**
 * Represents the irregular seal 1 shape.
 */
export class IrregularSeal1Shape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitIrregularSeal1Shape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 71);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 79);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
IrregularSeal1Shape.$t = markType(IrregularSeal1Shape, 'IrregularSeal1Shape', WorksheetShapeWithText.$);
/**
 * Represents the irregular seal 2 shape.
 */
export class IrregularSeal2Shape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitIrregularSeal2Shape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 72);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 80);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
IrregularSeal2Shape.$t = markType(IrregularSeal2Shape, 'IrregularSeal2Shape', WorksheetShapeWithText.$);
/**
 * Represents the lightning bolt shape.
 */
export class LightningBoltShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitLightningBoltShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 73);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 74);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
LightningBoltShape.$t = markType(LightningBoltShape, 'LightningBoltShape', WorksheetShapeWithText.$);
/**
 * Represents the line shape.
 */
export class LineShape extends WorksheetShape {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitLineShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__a5() {
    return true;
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 20);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 0);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
LineShape.$t = markType(LineShape, 'LineShape', WorksheetShape.$);
/**
 * Represents the pentagon shape.
 */
export class PentagonShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitPentagonShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 56);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 9);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
PentagonShape.$t = markType(PentagonShape, 'PentagonShape', WorksheetShapeWithText.$);
/**
 * Represents the rectangle shape.
 */
export class RectangleShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitRectangleShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 1);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 4);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
RectangleShape.$t = markType(RectangleShape, 'RectangleShape', WorksheetShapeWithText.$);
/**
 * Represents the right triangle shape.
 */
export class RightTriangleShape extends WorksheetShapeWithText {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitRightTriangleShape$i(this, b);
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 6);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 3);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
RightTriangleShape.$t = markType(RightTriangleShape, 'RightTriangleShape', WorksheetShapeWithText.$);
/**
 * Represents the straight connector 1 shape.
 */
export class StraightConnector1Shape extends WorksheetShape {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let initializeDefaults = _rest[0];
          super(1, initializeDefaults);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _am($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
    return a._visitStraightConnector1Shape$i(this, b);
  }
  /**
   * @hidden
   */
  get__a5() {
    return true;
  }
  /**
   * @hidden
   */
  get__b0() {
    return Nullable$1.toNullable(ShapeType_$type, 32);
  }
  /**
   * @hidden
   */
  get _b0() {
    return this.get__b0();
  }
  /**
   * @hidden
   */
  get__b1() {
    return Nullable$1.toNullable(ST_ShapeType_$type, 95);
  }
  /**
   * @hidden
   */
  get _b1() {
    return this.get__b1();
  }
}
StraightConnector1Shape.$t = markType(StraightConnector1Shape, 'StraightConnector1Shape', WorksheetShape.$);
/**
 * @hidden
 */
export class AddInFunctionResolver extends FormulaTokenEvaluator$1 {
  constructor() {
    super(FormulaToken.$);
  }
  a5(a, b, c) {
    return a;
  }
  a6(a, b, c) {
    if (a.$function == Function._q) {
      let d = typeCast(NameToken.$, b);
      if (d != null && d.w != null) {
        a.$function = Function._gv(d.w);
        let e = d.u;
        if (e._g == 0) {
          d.u = this.c.f._a9.c(e.name, e.scope, true);
        }
      }
    }
    return a.formulaToken;
  }
  a7(a) {
    return a;
  }
  a8(a, b) {
    return a;
  }
  a9(a, b) {
    return a;
  }
  static bi(a) {
    if (AddInFunctionResolver.bh == null) {
      AddInFunctionResolver.bh = new AddInFunctionResolver();
    }
    AddInFunctionResolver.bh.c = a;
    return AddInFunctionResolver.bh;
  }
}
AddInFunctionResolver.$t = markType(AddInFunctionResolver, 'AddInFunctionResolver', FormulaTokenEvaluator$1.$.specialize(FormulaToken.$));
AddInFunctionResolver.bh = null;
/**
 * @hidden
 */
export class CellAddress extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.s = 0;
    this.o = false;
    this.q = 0;
    this.f = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.s = c;
          this.o = d;
          this.q = e;
          this.f = f;
        }
        break;
    }
  }
  equals(a) {
    let b = Nullable$1.toNullable(CellAddress.$, typeCast(CellAddress.$, a));
    return CellAddress.l(b, Nullable$1.toNullable(CellAddress.$, null)) && CellAddress.i(this, b.getValueOrDefault());
  }
  getHashCode() {
    let a = this.q << 16 | this.s;
    if (this.o) {
      a <<= 1;
    }
    if (this.f) {
      a <<= 2;
    }
    return a;
  }
  static u(a, b, c = 2, d = true, e = true, f = -1, g = -1, h = false, i = 1) {
    let j = CellAddress.x(a, d, c, f, h, i);
    let k = CellAddress.v(b, e, c, g, h, i);
    if (i == 1) {
      return k + j;
    }
    else {
      return j + k;
    }
  }
  static v(a, b, c, d, e, f) {
    let g = Workbook.getMaxColumnCount(c);
    return CellAddress.w(a, b, g, d, e, f);
  }
  static w(a, b, c, d, e, f) {
    a %= c;
    let g = Math.max(0, d);
    if (b) {
      if (e) {
        if (a + g < 0) {
          a += c;
        }
        else if (a + g >= c) {
          a -= c;
        }
      }
      else {
        if (a < 0) {
          a += c;
        }
      }
    }
    if (f == 1) {
      if (b && e) {
        a += g;
      }
      let h = stringEmpty();
      let i = true;
      do {
        let j = String.fromCharCode(('A'.charCodeAt(0) + (a % 26)));
        a = intDivide(a, 26);
        if (i == false) {
          if (j == 'A') {
            j = 'Z';
            a--;
          }
          else {
            ((() => { let $value = j; j = String.fromCharCode($value.charCodeAt(0) - 1); return $value; })());
          }
        }
        h = j + h;
        i = false;
      } while (a > 0);
      if (b == false) {
        return "$" + h;
      }
      return h;
    }
    else {
      if (b == false) {
        return "C" + (a + 1).toString();
      }
      if (e == false) {
        a -= g;
      }
      if (a == 0) {
        return "C";
      }
      return "C[" + a + "]";
    }
  }
  static x(a, b, c, d, e, f) {
    let g = Workbook.getMaxRowCount(c);
    return CellAddress.y(a, b, g, d, e, f);
  }
  static y(a, b, c, d, e, f) {
    a %= c;
    let g = 0;
    if (d != -1) {
      g = d;
    }
    if (b) {
      if (e) {
        if (a + g < 0) {
          a += c;
        }
        else if (a + g >= c) {
          a -= c;
        }
      }
      else {
        if (a < 0) {
          a += c;
        }
      }
    }
    if (f == 1) {
      if (b == false) {
        return "$" + (a + 1).toString();
      }
      if (e) {
        a += g;
      }
      return (a + 1).toString();
    }
    else {
      if (b == false) {
        return "R" + (a + 1).toString();
      }
      if (e == false) {
        a -= g;
      }
      if (a == 0) {
        return "R";
      }
      return "R[" + a.toString() + "]";
    }
  }
  a(a, b, c = true) {
    if ((this.f == false || b.x == 0) && (this.o == false || b.y == 0)) {
      return this;
    }
    let d = this.q;
    if (this.f) {
      d += truncate(b.x);
      if (c) {
        let e = Workbook._fe(a.h);
        if (d < 0) {
          d += e;
        }
        else if (e <= d) {
          d -= e;
        }
      }
    }
    let f = this.s;
    if (this.o) {
      f += truncate(b.y);
      if (c) {
        let g = Workbook.getMaxRowCount(a.h);
        if (f < 0) {
          f += g;
        }
        else if (g <= f) {
          f -= g;
        }
      }
    }
    return new CellAddress(1, f, this.o, d, this.f);
  }
  b(a, b, c) {
    if (c) {
      let d = this.q;
      let e = this.s;
      if (this.f) {
        let f = Workbook.getMaxColumnCount(a);
        let g = Workbook.getMaxColumnCount(b);
        if (0 <= this.q) {
          let h = f - this.q;
          if (h < g) {
            d = (g - h);
          }
        }
      }
      if (this.o) {
        let i = Workbook.getMaxRowCount(a);
        let j = Workbook.getMaxRowCount(b);
        if (0 <= this.s) {
          let k = i - this.s;
          if (k < j) {
            e = (j - k);
          }
        }
      }
      if (d != this.q || e != this.s) {
        return new CellAddress(1, e, this.o, d, this.f);
      }
    }
    return this;
  }
  c(a, b) {
    if (b == false) {
      return this;
    }
    let c = this.s;
    let d = this.q;
    if (this.o) {
      if (a.l.e) {
        c = a.l.o + this.s;
      }
      let e = Workbook.getMaxRowCount(a.h);
      c %= e;
      if (c < 0) {
        c += e;
      }
    }
    if (this.f) {
      if (a.l.e) {
        d = (a.l.m + this.q);
      }
      let f = Workbook._fe(a.h);
      d %= f;
      if (d < 0) {
        d += f;
      }
    }
    return new CellAddress(1, c, this.o, d, this.f);
  }
  e(a, b, c = true) {
    let d = this.r;
    let e = this.t;
    if (b) {
      if (this.g) {
        if (a.l.e == false) {
          return WorksheetCellAddress.b;
        }
        d += a.l.m;
        if (c) {
          let f = Workbook._fe(a.h);
          if (d < 0) {
            d += f;
          }
          else if (f <= d) {
            d -= f;
          }
        }
      }
      if (this.p) {
        if (a.l.e == false) {
          return WorksheetCellAddress.b;
        }
        e += a.l.o;
        if (c) {
          let g = Workbook.getMaxRowCount(a.h);
          if (e < 0) {
            e += g;
          }
          else if (g <= e) {
            e -= g;
          }
        }
      }
    }
    return new WorksheetCellAddress(1, e, d);
  }
  d(a) {
    let b = this.s;
    let c = this.q;
    if (this.o) {
      if (a.l.e) {
        b = this.s - a.l.o;
      }
      let d = Workbook.getMaxRowCount(a.h);
      if (b < 0) {
        b += d;
      }
    }
    if (this.f) {
      if (a.l.e) {
        c = (this.q - a.l.m);
      }
      let e = Workbook._fe(a.h);
      if (c < 0) {
        c += e;
      }
    }
    return new CellAddress(1, b, this.o, c, this.f);
  }
  z(a, b) {
    return CellAddress.u(this.s, this.q, a.h, this.o, this.f, a.l.o, a.l.m, b, a.b);
  }
  aa(a, b) {
    this.ab(a, b, false, false);
  }
  ab(a, b, c, d) {
    if (c == false) {
      let e = Workbook.getMaxColumnCount(b) - 1;
      if (e < Math.abs(this.q)) {
        a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxColumnIndex"), this.q, e));
        return;
      }
    }
    if (d == false) {
      let f = Workbook.getMaxRowCount(b) - 1;
      if (f < Math.abs(this.s)) {
        a.g(stringFormat(ExcelUtils.ef("LE_FormatLimitError_MaxRowIndex"), this.s, f));
      }
    }
  }
  get r() {
    return this.q;
  }
  get g() {
    return this.f;
  }
  get h() {
    return this.f || this.o;
  }
  get t() {
    return this.s;
  }
  get p() {
    return this.o;
  }
  static i(a, b) {
    return a.s == b.s && a.o == b.o && a.q == b.q && a.f == b.f;
  }
  static j(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return CellAddress.i(a.value, b.value);
  }
  static k(a, b) {
    return !(CellAddress.i(a, b));
  }
  static l(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return CellAddress.k(a.value, b.value);
  }
}
CellAddress.$t = markStruct(CellAddress, 'CellAddress');
/**
 * @hidden
 */
export class CellAddressRange extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = new CellAddress();
    this.a = new CellAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e;
          let f;
          let g;
          let h;
          let i;
          let j;
          let k;
          let l;
          if (c.t <= d.t) {
            e = c.t;
            f = c.p;
            g = d.t;
            h = d.p;
          }
          else {
            e = d.t;
            f = d.p;
            g = c.t;
            h = c.p;
          }
          if (c.r <= d.r) {
            i = c.r;
            j = c.g;
            k = d.r;
            l = d.g;
          }
          else {
            i = d.r;
            j = d.g;
            k = c.r;
            l = c.g;
          }
          this.c = new CellAddress(1, e, f, i, j);
          this.a = new CellAddress(1, g, h, k, l);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          this.c = new CellAddress(1, c.firstRow, false, c._v, false);
          this.a = new CellAddress(1, c.lastRow, false, c._w, false);
        }
        break;
    }
  }
  equals(a) {
    let b = Nullable$1.toNullable(CellAddressRange.$, typeCast(CellAddressRange.$, a));
    return CellAddressRange.p(b, Nullable$1.toNullable(CellAddressRange.$, null)) && CellAddressRange.m(this, b.getValueOrDefault());
  }
  getHashCode() {
    return this.c.getHashCode() ^ (this.a.getHashCode() << 1);
  }
  i(a, b) {
    let c = this.k(a, b);
    if (c._n == false || a.j == null) {
      return null;
    }
    return a.j._cw(c);
  }
  j(a, b, c, d) {
    let e = 2;
    if (a != null) {
      e = a._o;
    }
    return this.i(new FormulaContext(4, a, b, c, e, null, null, 1), d);
  }
  e(a, b, c = true) {
    let d = this.a.a(a, b, c);
    let e = this.c.a(a, b, c);
    if (CellAddress.i(d, this.a) && CellAddress.i(e, this.c)) {
      return this;
    }
    return new CellAddressRange(1, e, d);
  }
  f(a, b, c) {
    let d = Nullable$1.toNullable(Number_$type, null);
    let e = Nullable$1.toNullable(Number_$type, null);
    if (this.c.r == 0 && this.c.g == false && this.a.r == Workbook.getMaxColumnCount(a) - 1 && this.a.g == false) {
      d = Nullable$1.toNullable(Number_$type, (Workbook._fe(b) - 1));
    }
    if (this.c.t == 0 && this.c.p == false && this.a.t == Workbook.getMaxRowCount(a) - 1 && this.a.p == false) {
      e = Nullable$1.toNullable(Number_$type, Workbook.getMaxRowCount(b) - 1);
    }
    if (nullableEquals(d, null) && nullableEquals(e, null)) {
      let f = this.c.b(a, b, c);
      let g = this.a.b(a, b, c);
      if (CellAddress.k(f, this.c) || CellAddress.k(g, this.a)) {
        return new CellAddressRange(1, f, g);
      }
      return this;
    }
    return new CellAddressRange(1, this.c, new CellAddress(1, !nullableIsNull(e) ? e.value : this.a.t, this.a.p, !nullableIsNull(d) ? d.value : this.a.r, this.a.g));
  }
  g(a, b) {
    return new CellAddressRange(1, this.c.c(a, b), this.a.c(a, b));
  }
  k(a, b, c = true) {
    let d = this.d.e(a, b, c);
    let e = this.b.e(a, b, c);
    return new WorksheetRegionAddress(2, d, e);
  }
  h(a) {
    return new CellAddressRange(1, this.c.d(a), this.a.d(a));
  }
  s(a, b) {
    let c = this.c.c(a, b);
    let d = this.a.c(a, b);
    if (d.t < c.t) {
      let e = new CellAddress(1, d.t, d.p, c.r, c.g);
      d = new CellAddress(1, c.t, c.p, d.r, d.g);
      c = e;
    }
    if (d.r < d.r) {
      let f = new CellAddress(1, c.t, c.p, d.r, d.g);
      d = new CellAddress(1, d.t, d.p, c.r, c.g);
      c = f;
    }
    if (c.r == 0 && d.r == Workbook.getMaxColumnCount(a.h) - 1) {
      let g = CellAddress.x(c.t, c.p, a.h, a.l.o, false, a.b);
      let h = CellAddress.x(d.t, d.p, a.h, a.l.o, false, a.b);
      if (a.b == 0 && c.t == d.t) {
        return g;
      }
      return g + ":" + h;
    }
    if (c.t == 0 && d.t == Workbook.getMaxRowCount(a.h) - 1) {
      let i = CellAddress.v(c.r, c.g, a.h, a.l.m, false, a.b);
      let j = CellAddress.v(d.r, d.g, a.h, a.l.m, false, a.b);
      if (a.b == 0 && c.r == d.r) {
        return i;
      }
      return i + ":" + j;
    }
    return c.z(a, false) + ":" + d.z(a, false);
  }
  t(a, b) {
    this.c.aa(a, b);
    let c = false;
    let d = false;
    if (this.c.r == 0 && this.c.g == false && this.a.r == a.b.maxColumnCount - 1 && this.a.g == false) {
      c = true;
    }
    if (this.c.t == 0 && this.c.p == false && this.a.t == a.b.maxRowCount - 1 && this.a.p == false) {
      d = true;
    }
    this.a.ab(a, b, c, d);
  }
  get b() {
    return this.a;
  }
  get l() {
    return this.a.h || this.c.h;
  }
  get d() {
    return this.c;
  }
  static m(a, b) {
    return CellAddress.i(a.c, b.c) && CellAddress.i(a.a, b.a);
  }
  static n(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return CellAddressRange.m(a.value, b.value);
  }
  static o(a, b) {
    return !(CellAddressRange.m(a, b));
  }
  static p(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return CellAddressRange.o(a.value, b.value);
  }
}
CellAddressRange.$t = markStruct(CellAddressRange, 'CellAddressRange');
/**
 * @hidden
 */
export class FormulaParser_FormulaTokenInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.c = d;
          this.a = e;
        }
        break;
    }
  }
  d(a) {
    if (this.a == null) {
      this.a = a;
      return;
    }
    let b = this.a;
    this.a = new Array(b.length + a.length);
    arrayCopy2(b, this.a, b.length);
    arrayCopy1(a, 0, this.a, b.length, a.length);
  }
}
FormulaParser_FormulaTokenInfo.$t = markStruct(FormulaParser_FormulaTokenInfo, 'FormulaParser_FormulaTokenInfo');
/**
 * @hidden
 */
export class FormulaParser_SelectorFunctionOptimizationInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.b = new List$1(AttrSkipToken.$, 2, 1);
          this.a = c;
        }
        break;
    }
  }
}
FormulaParser_SelectorFunctionOptimizationInfo.$t = markStruct(FormulaParser_SelectorFunctionOptimizationInfo, 'FormulaParser_SelectorFunctionOptimizationInfo');
/**
 * @hidden
 */
export class FormulaParser_PositionInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = new FormulaParser_TextSpan();
    this.c = 0;
    this.e = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.c = c;
          this.e = d;
          this.a = e;
        }
        break;
    }
  }
  get b() {
    return this.a;
  }
  get d() {
    return this.c;
  }
  get f() {
    return this.e;
  }
}
FormulaParser_PositionInfo.$t = markStruct(FormulaParser_PositionInfo, 'FormulaParser_PositionInfo');
/**
 * @hidden
 */
export class FormulaParser_StructuredTableReferenceParser extends Base {
  constructor(a) {
    super();
    this.a = null;
    this.a = a;
  }
  c(a, b, c) {
    if (ExcelUtils.au(this.a.j.h)) {
      return false;
    }
    if (this.a.h != null) {
      return false;
    }
    let d = this.a.o();
    let e = null;
    try {
      let f;
      if (((() => { let g = this.i(f); f = g.p0; return g.ret; })())) {
        let g = this.b();
        let h;
        if (g != null && ((() => { let i = this.j(h); h = i.p0; return i.ret; })())) {
          g.h = f;
          g.g = h;
          if (g.j) {
            e = new StructuredTableReference(2, a, b, g.p, this.a.j.h);
          }
          else {
            e = new StructuredTableReference(3, a, b, g, this.a.j.h);
          }
          return true;
        }
        this.a.eg(d);
      }
      let i = this.l();
      if (i.hasValue) {
        e = new StructuredTableReference(1, a, b, i.value, this.a.j.h);
        return true;
      }
      if (this.a.bq('[')) {
        let j = this.a.cp;
        let k = this.n(true);
        if (this.a.bq(']')) {
          e = new StructuredTableReference(2, a, b, k, this.a.j.h);
          return true;
        }
        this.a.h = new FormulaParseException(d.d, this.a.cw, ExcelUtils.ef("LE_FormulaParseException_InvalidStructuredTableReference"), this.a.cw.substr(d.d, j - d.d));
      }
      return false;
    }
    finally {
      if (e != null) {
        this.a.d5(e, d.d, this.a.cp - d.d, c, 0);
      }
    }
  }
  d(a, b) {
    if (((() => { let c = this.e(a, b); b = c.p1; return c.ret; })())) {
      return {
        ret: true,
        p1: b
      };
    }
    if (this.a.bq(' ')) {
      return {
        ret: true,
        p1: b
      };
    }
    return {
      ret: false,
      p1: b
    };
  }
  e(a, b) {
    if (((() => { let c = this.k(a, b); b = c.p1; return c.ret; })())) {
      return {
        ret: true,
        p1: b
      };
    }
    if (this.a.bq('\'') && this.a.cp < this.a.cw.length - 1) {
      b = this.a.cw.charAt(this.a.cp);
      this.a.cp++;
      return {
        ret: true,
        p1: b
      };
    }
    return {
      ret: false,
      p1: b
    };
  }
  m() {
    let a = this.n(false);
    if (a != null) {
      return a;
    }
    if (this.a.bq('[')) {
      let b = this.a.o();
      a = this.n(true);
      if (a != null && this.a.bq(']')) {
        return a;
      }
      this.a.eg(b);
      return null;
    }
    return null;
  }
  f(a, b) {
    b = null;
    a = this.m();
    if (a == null) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    let c = this.a.o();
    if (this.a.bq(':')) {
      b = this.m();
      if (b != null) {
        return {
          ret: true,
          p0: a,
          p1: b
        };
      }
      this.a.eg(c);
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  b() {
    let a;
    let b;
    let c;
    let d;
    let e;
    let f = this.a.o();
    if (this.a.bq('@')) {
      while (this.a.bq(' ')) {
        ;
      }
      if (((() => { let g = this.f(d, e); d = g.p0; e = g.p1; return g.ret; })())) {
        return new StructuredTableReference_InnerReference(1, 4, false, Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null), false, d, e);
      }
      this.a.eg(f);
      return null;
    }
    if (((() => { let g = this.g(a, b, c); a = g.p0; b = g.p1; c = g.p2; return g.ret; })())) {
      f = this.a.o();
      let g;
      if (((() => { let h = this.h(g); g = h.p0; return h.ret; })()) == false) {
        return new StructuredTableReference_InnerReference(0, a.value, c, b);
      }
      if (((() => { let h = this.f(d, e); d = h.p0; e = h.p1; return h.ret; })())) {
        return new StructuredTableReference_InnerReference(1, a.value, c, b, g, d, e);
      }
      this.a.eg(f);
      return null;
    }
    if (((() => { let h = this.f(d, e); d = h.p0; e = h.p1; return h.ret; })())) {
      return new StructuredTableReference_InnerReference(2, d, e);
    }
    return null;
  }
  l() {
    if (this.a.h != null) {
      return Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    }
    let a = this.a.o();
    if (this.a.bq('[') == false) {
      return Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    }
    if (this.a.bq('@')) {
      if (this.a.bq(']')) {
        return Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 4);
      }
    }
    else if (this.a.bp('#')) {
      let b;
      if (this.a.bs("#All")) {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 0);
      }
      else if (this.a.bs("#Data")) {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 1);
      }
      else if (this.a.bs("#Headers")) {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 2);
      }
      else if (this.a.bs("#Totals")) {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 3);
      }
      else if (this.a.bs("#This Row")) {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, 4);
      }
      else {
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
      }
      if (b.hasValue && this.a.bq(']')) {
        return b;
      }
    }
    this.a.eg(a);
    return Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
  }
  g(a, b, c) {
    b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    c = false;
    a = this.l();
    if (a.hasValue == false) {
      return {
        ret: false,
        p0: a,
        p1: b,
        p2: c
      };
    }
    if (nullableEquals(a, 2) || nullableEquals(a, 1)) {
      let d = this.a.o();
      if (((() => { let e = this.h(c); c = e.p0; return e.ret; })()) == false) {
        return {
          ret: true,
          p0: a,
          p1: b,
          p2: c
        };
      }
      b = this.l();
      if (b.hasValue) {
        if (nullableEquals(a, 2) && b.value == 1) {
          return {
            ret: true,
            p0: a,
            p1: b,
            p2: c
          };
        }
        if (nullableEquals(a, 1) && b.value == 3) {
          return {
            ret: true,
            p0: a,
            p1: b,
            p2: c
          };
        }
        b = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
      }
      this.a.eg(d);
      return {
        ret: true,
        p0: a,
        p1: b,
        p2: c
      };
    }
    return {
      ret: true,
      p0: a,
      p1: b,
      p2: c
    };
  }
  n(a) {
    let b = this.a.o();
    let c;
    if (((() => { let d = this.e(a, c); c = d.p1; return d.ret; })())) {
      let d = new StringBuilder(2, c.toString());
      if (((() => { let e = this.d(a, c); c = e.p1; return e.ret; })())) {
        d.h(c);
        while (((() => { let e = this.d(a, c); c = e.p1; return e.ret; })())) {
          d.h(c);
        }
        this.a.cp--;
        if (((() => { let e = this.e(a, c); c = e.p1; return e.ret; })()) == false) {
          let e = false;
          if (this.a.cp > b.d && this.a.cw.charAt(this.a.cp - 1) == '\'') {
            this.a.cp--;
            e = ((() => { let f = this.e(a, c); c = f.p1; return f.ret; })());
          }
          if (!e) {
            this.a.eg(b);
            return null;
          }
        }
      }
      return d.toString();
    }
    this.a.eg(b);
    return null;
  }
  h(a) {
    a = false;
    let b = this.a.o();
    while (this.a.bq(' ')) {
      ;
    }
    if (this.a.bq(this.a.b4) == false) {
      this.a.eg(b);
      return {
        ret: false,
        p0: a
      };
    }
    while (this.a.bq(' ')) {
      a = true;
    }
    return {
      ret: true,
      p0: a
    };
  }
  i(a) {
    a = false;
    if (this.a.bq('[')) {
      while (this.a.bq(' ')) {
        a = true;
      }
      return {
        ret: true,
        p0: a
      };
    }
    return {
      ret: false,
      p0: a
    };
  }
  j(a) {
    a = false;
    let b = this.a.o();
    while (this.a.bq(' ')) {
      a = true;
    }
    if (this.a.bq(']')) {
      return {
        ret: true,
        p0: a
      };
    }
    this.a.eg(b);
    return {
      ret: false,
      p0: a
    };
  }
  k(a, b) {
    b = String.fromCharCode(0);
    let c = this.a.cw.charAt(this.a.cp);
    if (FormulaParser.aa(c)) {
      return {
        ret: false,
        p1: b
      };
    }
    if (a == false && c == ':') {
      return {
        ret: false,
        p1: b
      };
    }
    let d = c.charCodeAt(0);
    if (d == 9 || d == 10 || d == 13 || (32 <= d && d <= 55295) || (57344 <= d && d <= 65533) || (65536 <= d && d <= 1114111)) {
      this.a.cp++;
      b = c;
      return {
        ret: true,
        p1: b
      };
    }
    return {
      ret: false,
      p1: b
    };
  }
}
FormulaParser_StructuredTableReferenceParser.$t = markType(FormulaParser_StructuredTableReferenceParser, 'FormulaParser_StructuredTableReferenceParser');
/**
 * @hidden
 */
export class FormulaParser_TextSpan extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.d = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.d = c;
          this.c = d;
        }
        break;
    }
  }
  get b() {
    return this.c == 0;
  }
}
FormulaParser_TextSpan.$t = markStruct(FormulaParser_TextSpan, 'FormulaParser_TextSpan');
FormulaParser_TextSpan.a = new FormulaParser_TextSpan(0);
/**
 * @hidden
 */
export class FormulaParser_WorksheetReferenceInfo extends ValueType {
  constructor() {
    super();
    this.b = null;
    this.c = null;
    this.d = null;
    this.a = false;
  }
}
FormulaParser_WorksheetReferenceInfo.$t = markStruct(FormulaParser_WorksheetReferenceInfo, 'FormulaParser_WorksheetReferenceInfo');
/**
 * @hidden
 */
export class FormulaTokenVisitor$2 extends Base {
  constructor($tArgument, $tResult) {
    super();
    this.$tArgument = null;
    this.$tResult = null;
    this.b = null;
    this.az = 0;
    this.aw = false;
    this.$tArgument = $tArgument;
    this.$tResult = $tResult;
    this.$type = this.$type.specialize(this.$tArgument, this.$tResult);
  }
  d(a, b) {
    return Type.getDefaultValue(this.$tResult);
  }
  a1() {
    this.aw = true;
  }
  a2() {
    this.b = null;
    this.aw = false;
  }
  ax(a) {
    let b;
    let c = ((() => { let d = this.ay(a, b); b = d.p1; return d.ret; })());
    this.a2();
    return c;
  }
  ay(a, b) {
    b = null;
    let c = this.a;
    let d = c.length;
    for (this.az = 0; this.az < d; this.az++) {
      let e;
      let f = this.au(c[this.az], a, e);
      e = f.p2;
      if (e != null) {
        c[this.az] = e;
      }
      if (this.aw) {
        b = c[this.az];
        return {
          ret: false,
          p1: b
        };
      }
    }
    return {
      ret: true,
      p1: b
    };
  }
  e(a, b) {
    return this.i(a, b);
  }
  f(a, b) {
    return this.j(a, b);
  }
  g(a, b) {
    return this.f(a, b);
  }
  h(a, b) {
    return this.t(a, b);
  }
  i(a, b) {
    return this.j(a, b);
  }
  j(a, b) {
    return this.t(a, b);
  }
  k(a, b) {
    return this.ai(a, b);
  }
  l(a, b) {
    return this.d(a, b);
  }
  m(a, b) {
    return this.d(a, b);
  }
  n(a, b) {
    return this.d(a, b);
  }
  o(a, b) {
    return this.d(a, b);
  }
  p(a, b) {
    return this.x(a, b);
  }
  q(a, b) {
    return this.d(a, b);
  }
  r(a, b) {
    return this.d(a, b);
  }
  s(a, b) {
    return this.ai(a, b);
  }
  t(a, b) {
    return this.am(a, b);
  }
  u(a, b) {
    return this.ai(a, b);
  }
  v(a, b) {
    return this.d(a, b);
  }
  w(a, b) {
    return this.x(a, b);
  }
  x(a, b) {
    return this.d(a.formulaToken, b);
  }
  y(a, b) {
    return this.w(a, b);
  }
  z(a, b) {
    return this.ai(a, b);
  }
  aa(a, b) {
    return this.d(a, b);
  }
  ab(a, b) {
    return this.d(a, b);
  }
  ac(a, b) {
    return this.d(a, b);
  }
  ad(a, b) {
    return this.d(a, b);
  }
  ae(a, b) {
    return this.ai(a, b);
  }
  af(a, b) {
    return this.am(a, b);
  }
  ag(a, b) {
    return this.af(a, b);
  }
  ah(a, b) {
    return this.ai(a, b);
  }
  ai(a, b) {
    return this.d(a, b);
  }
  aj(a, b) {
    return this.d(a, b);
  }
  am(a, b) {
    return this.ai(a, b);
  }
  ak(a, b) {
    return this.ap(a, b);
  }
  al(a, b) {
    return this.aq(a, b);
  }
  an(a, b) {
    return this.al(a, b);
  }
  ao(a, b) {
    return this.t(a, b);
  }
  ap(a, b) {
    return this.aq(a, b);
  }
  aq(a, b) {
    return this.t(a, b);
  }
  ar(a, b) {
    return this.ai(a, b);
  }
  as(a, b) {
    return this.am(a, b);
  }
  at(a, b) {
    return this.d(a, b);
  }
  au(a, b, c) {
    c = null;
    return {
      ret: a.e(this.$tArgument, this.$tResult, this, b),
      p2: c
    };
  }
  av(a, b) {
    return this.d(a, b);
  }
  get c() {
    return this.b;
  }
  set c(a) {
    this.b = a;
  }
  get a0() {
    return this.az;
  }
  set a0(a) {
    this.az = a;
  }
  get_a() {
    return this.b.d._e;
  }
  get a() {
    return this.get_a();
  }
}
FormulaTokenVisitor$2.$t = markType(FormulaTokenVisitor$2, 'FormulaTokenVisitor$2');
/**
 * @hidden
 */
export class FormulaParser_ParseFormulaValidator extends FormulaTokenVisitor$2 {
  constructor() {
    super(FormulaParser.$, Boolean_$type);
  }
  static a4(a) {
    if (FormulaParser_ParseFormulaValidator.a3 == null) {
      FormulaParser_ParseFormulaValidator.a3 = new FormulaParser_ParseFormulaValidator();
    }
    let b = -1;
    for (let c = 0; c < a.b9.count; c++) {
      if (!a.b9._inner[c].b.e(FormulaParser.$, Boolean_$type, FormulaParser_ParseFormulaValidator.a3, a)) {
        b = c;
        break;
      }
    }
    FormulaParser_ParseFormulaValidator.a3.a2();
    return b;
  }
  d(a, b) {
    return true;
  }
  k(a, b) {
    if (b.i == 7) {
      return false;
    }
    return super.k(a, b);
  }
  r(a, b) {
    if (b.i == 7) {
      if (a.f == 15 || a.f == 16) {
        return false;
      }
    }
    return super.r(a, b);
  }
  af(a, b) {
    if (b.i == 7) {
      if (typeCast(WorksheetTable.$, a.u) !== null) {
        return false;
      }
    }
    return super.af(a, b);
  }
  as(a, b) {
    if (b.i == 7) {
      return false;
    }
    return super.as(a, b);
  }
}
FormulaParser_ParseFormulaValidator.$t = markType(FormulaParser_ParseFormulaValidator, 'FormulaParser_ParseFormulaValidator', FormulaTokenVisitor$2.$.specialize(FormulaParser.$, Boolean_$type));
FormulaParser_ParseFormulaValidator.a3 = null;
/**
 * @hidden
 */
export class TokenClassResolver_FormulaTokenNode extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = [];
          for (let b = 1; b < _rest.length; b++) {
            d[b - 1] = _rest[b];
          }
          this.d = c;
          this.a = d;
        }
        break;
    }
  }
  f(a, b, c) {
    let d = a.c.d._e[this.d];
    if (b == 32) {
      switch (a.bh) {
        case 1:
        case 3:
        case 4:
          c = true;
          break;
      }
      if (d.h == 64 && c) {
        a.bk(this.d, 96);
      }
    }
    else if (b == 64) {
      if (c) {
        a.bk(this.d, 96);
      }
      else {
        a.bk(this.d, 64);
      }
    }
    else if (b == 96) {
      a.bk(this.d, 96);
      c = true;
    }
    if (typeCast(ParenToken.$, d) !== null) {
      this.a[0].f(a, b, c);
    }
    else {
      for (let e = 0, f = this.a.length; e < f; e++) {
        this.a[e].f(a, d.e(Number_$type, TokenClass_$type, ExpectedParameterClassVisitor.a3, e), c);
      }
    }
  }
  get e() {
    return this.d;
  }
  c(a) {
    let b = a.c.d._e[this.d];
    if (typeCast(ParenToken.$, b) !== null) {
      return this.a[0].c(a);
    }
    return b.h;
  }
}
TokenClassResolver_FormulaTokenNode.$t = markStruct(TokenClassResolver_FormulaTokenNode, 'TokenClassResolver_FormulaTokenNode');
TokenClassResolver_FormulaTokenNode.b = new Array(0);
/**
 * @hidden
 */
export class TokenClassResolver extends FormulaTokenEvaluator$1 {
  constructor() {
    super(TokenClassResolver_FormulaTokenNode.$);
    this.bh = 0;
  }
  a2() {
    try {
      let a = super.a3(false);
      if (a.d) {
        switch (this.bh) {
          case 3:
          case 4:
          case 5:
            a.b.f(this, 32, false);
            break;
          default:
            a.b.f(this, 64, false);
            break;
        }
      }
      return a;
    }
    finally {
      this.a1();
    }
  }
  a5(a, b, c) {
    switch (a.f) {
      case 15:
      case 16:
      case 17:
        if (b.c(this) != 32 || c.c(this) != 32) {
          this.a0();
          return new TokenClassResolver_FormulaTokenNode();
        }
        break;
    }
    return new TokenClassResolver_FormulaTokenNode(1, this.az, b, c);
  }
  a6(a, b, c) {
    let d = a.$function;
    if (d._b != null) {
      let g = d._b;
      for (let f = 0; f < g.length; f++) {
        let e = g[f];
        if (e < c.length && c[e].c(this) != 32) {
          let h = c[e].e;
          let i = typeCast(ErrToken.$, this.c.d._e[h]);
          if (i != null && i.p == ErrorValue.invalidCellReference) {
            continue;
          }
          this.a0();
          return new TokenClassResolver_FormulaTokenNode();
        }
      }
    }
    return new TokenClassResolver_FormulaTokenNode(1, this.az, ...c);
  }
  a7(a) {
    return new TokenClassResolver_FormulaTokenNode(1, this.az, ...TokenClassResolver_FormulaTokenNode.b);
  }
  a8(a, b) {
    return new TokenClassResolver_FormulaTokenNode(1, this.az, b);
  }
  a9(a, b) {
    return new TokenClassResolver_FormulaTokenNode(1, this.az, b);
  }
  a1() {
    super.a1();
  }
  static bj(a, b) {
    if (TokenClassResolver.bi == null) {
      TokenClassResolver.bi = new TokenClassResolver();
    }
    TokenClassResolver.bi.bh = b;
    TokenClassResolver.bi.c = a;
    return TokenClassResolver.bi;
  }
  bk(a, b) {
    let c = this.c.d._e;
    let d = c[a];
    if (d.h == b) {
      return;
    }
    if (b == 96) {
      switch (d.f) {
        case 3:
          c[a] = AddOperator.aa;
          return;
        case 8:
          c[a] = ConcatOperator.aa;
          return;
        case 6:
          c[a] = DivOperator.aa;
          return;
        case 11:
          c[a] = EQOperator.aa;
          return;
        case 10:
          c[a] = LEOperator.aa;
          return;
        case 9:
          c[a] = LTOperator.aa;
          return;
        case 12:
          c[a] = GEOperator.aa;
          return;
        case 13:
          c[a] = GTOperator.aa;
          return;
        case 22:
          c[a] = MissArgToken.p;
          return;
        case 5:
          c[a] = MulOperator.aa;
          return;
        case 14:
          c[a] = NEOperator.aa;
          return;
        case 20:
          c[a] = PercentOperator.z;
          return;
        case 7:
          c[a] = PowerOperator.aa;
          return;
        case 4:
          c[a] = SubOperator.aa;
          return;
        case 19:
          c[a] = UminusOperator.z;
          return;
        case 18:
          c[a] = UplusOperator.z;
          return;
      }
    }
    d.h = b;
  }
}
TokenClassResolver.$t = markType(TokenClassResolver, 'TokenClassResolver', FormulaTokenEvaluator$1.$.specialize(TokenClassResolver_FormulaTokenNode.$));
TokenClassResolver.bi = null;
/**
 * @hidden
 */
export class XLSXFormulaStringGenerator extends FormulaStringGenerator {
  constructor() {
    super();
    this.by = null;
  }
  a4(a, b) {
    let c = typeCast(FunctionOperator.$, a);
    if (c != null && c.$function._qk) {
      if (c.$function._qm == false) {
        b = "_xll." + b;
      }
      else if (c.$function._qw) {
        b = "_xlfn." + b;
      }
    }
    return b;
  }
  a6(a, b, c) {
    let d = a.$function;
    if (d != null && d._qw) {
      b = this.a4(a, d._alx);
    }
    return super.a6(a, b, c);
  }
  bs(a) {
    let b = typeCast(NameToken.$, a);
    if (b != null) {
      let c = b.u;
      if (c != null && c._r) {
        let d = typeCast(Worksheet.$, c.scope);
        if (d != null) {
          return ExcelUtils.d5(null, d.name) + "_xlnm." + c.name;
        }
      }
    }
    return a.l(this.c, this.by);
  }
  static bx(a, b) {
    if (XLSXFormulaStringGenerator.bw == null) {
      XLSXFormulaStringGenerator.bw = new XLSXFormulaStringGenerator();
    }
    XLSXFormulaStringGenerator.bw.by = b;
    let c = new FormulaContext(2, a, 1, CultureInfo.invariantCulture);
    FormulaStringGenerator.bu(XLSXFormulaStringGenerator.bw, c, false);
    return XLSXFormulaStringGenerator.bw;
  }
  a1() {
    this.by = null;
    super.a1();
  }
  get_bn() {
    return false;
  }
}
XLSXFormulaStringGenerator.$t = markType(XLSXFormulaStringGenerator, 'XLSXFormulaStringGenerator', FormulaStringGenerator.$);
XLSXFormulaStringGenerator.bw = null;
/**
 * @hidden
 */
export class OperatorToken extends FormulaToken {
  constructor(a) {
    super(a);
  }
  get_n() {
    return false;
  }
  get n() {
    return this.get_n();
  }
}
OperatorToken.$t = markType(OperatorToken, 'OperatorToken', FormulaToken.$);
/**
 * @hidden
 */
export class BinaryOperatorToken extends OperatorToken {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.v(this);
  }
  d($tResult, a) {
    return a.r(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.r(this, b);
  }
  get_y() {
    return false;
  }
  get y() {
    return this.get_y();
  }
}
BinaryOperatorToken.$t = markType(BinaryOperatorToken, 'BinaryOperatorToken', OperatorToken.$);
/**
 * @hidden
 */
export class AddOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 6;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 3;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "+";
  }
}
AddOperator.$t = markType(AddOperator, 'AddOperator', BinaryOperatorToken.$);
AddOperator.z = new AddOperator(64);
AddOperator.aa = new AddOperator(96);
/**
 * @hidden
 */
export class OperandToken extends FormulaToken {
  constructor(a) {
    super(a);
  }
}
OperandToken.$t = markType(OperandToken, 'OperandToken', FormulaToken.$);
/**
 * @hidden
 */
export class ReferenceToken extends OperandToken {
  constructor(a) {
    super(a);
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    if (Base.equalsStatic(this.o, b.o) == false) {
      return false;
    }
    return true;
  }
  s(a) {
    let b = this.o;
    if (a != null) {
      this.o = b.g(a);
    }
  }
  get_p() {
    return false;
  }
  get p() {
    return this.get_p();
  }
  get_q() {
    return this.o != null;
  }
  get q() {
    return this.get_q();
  }
  get_r() {
    let a = this.o;
    if (a == null) {
      return false;
    }
    return a.j;
  }
  get r() {
    return this.get_r();
  }
  get_o() {
    return null;
  }
  set_o(a) {
  }
  get o() {
    return this.get_o();
  }
  set o(a) {
    this.set_o(a);
  }
}
ReferenceToken.$t = markType(ReferenceToken, 'ReferenceToken', OperandToken.$);
/**
 * @hidden
 */
export class CellReferenceToken extends ReferenceToken {
  constructor(a) {
    super(a);
  }
  u(a) {
    if (this.q == false) {
      return a.j;
    }
    if (this.o.j || this.o.k) {
      return null;
    }
    let b = typeCast(WorksheetReferenceLocal.$, this.o);
    if (b == null) {
      return null;
    }
    return b.u;
  }
  get_w() {
    return false;
  }
  get w() {
    return this.get_w();
  }
}
CellReferenceToken.$t = markType(CellReferenceToken, 'CellReferenceToken', ReferenceToken.$);
/**
 * @hidden
 */
export class AreaToken extends CellReferenceToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this.y = new CellAddressRange();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c, 32];
          {
            let f = d[0];
            let g = d[1];
            let h = [g];
            {
              let j = h[0];
              super(j);
              this.y = new CellAddressRange();
            }
            this.y = f;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [d];
          {
            let g = e[0];
            super(g);
            this.y = new CellAddressRange();
          }
          this.y = c;
        }
        break;
    }
  }
  m(a) {
    a.n(this);
  }
  d($tResult, a) {
    return a.j(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.j(this, b);
  }
  get_v() {
    return false;
  }
  get v() {
    return this.get_v();
  }
  t() {
    return new AreaErrToken(this.h);
  }
  n(a) {
    let b = this.x.i(a, this.v);
    if (b != null) {
      return b._c;
    }
    return ErrorValue.invalidCellReference._a();
  }
  get_p() {
    return this.x.l;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    if (this.x.d.g != d.x.d.g) {
      return false;
    }
    if (this.x.d.p != d.x.d.p) {
      return false;
    }
    if (this.x.b.g != d.x.b.g) {
      return false;
    }
    if (this.x.b.p != d.x.b.p) {
      return false;
    }
    let e = this.x.i(a, this.v);
    let f = d.x.i(c, d.v);
    let g = 0;
    if (this.x.d.g) {
      g = c.l.m - a.l.m;
    }
    let h = 0;
    if (this.x.d.p) {
      h = c.l.o - a.l.o;
    }
    let i = 0;
    if (this.x.b.g) {
      i = c.l.m - a.l.m;
    }
    let j = 0;
    if (this.x.b.p) {
      j = c.l.o - a.l.o;
    }
    return (e._v + g) == f._v && (e.firstRow + h) == f.firstRow && (e._w + i) == f._w && (e.lastRow + j) == f.lastRow;
  }
  l(a, b) {
    if (this.w) {
      return "#REF!";
    }
    return this.y.s(a, this.v);
  }
  get_f() {
    switch (this.h) {
      case 96: return 101;
      case 32: return 37;
      case 64: return 69;
      default: return 69;
    }
  }
  get f() {
    return this.get_f();
  }
  get x() {
    return this.y;
  }
  set x(a) {
    this.y = a;
  }
}
AreaToken.$t = markType(AreaToken, 'AreaToken', CellReferenceToken.$);
/**
 * @hidden
 */
export class AreaNToken extends AreaToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(2, c, d);
        }
        break;
    }
  }
  m(a) {
    a.m(this);
  }
  d($tResult, a) {
    return a.i(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.i(this, b);
  }
  get_v() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 109;
      case 32: return 45;
      case 64: return 77;
      default: return 77;
    }
  }
}
AreaNToken.$t = markType(AreaNToken, 'AreaNToken', AreaToken.$);
/**
 * @hidden
 */
export class Area3DNToken extends AreaNToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(1, d);
          this.z = null;
          this.z = c;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, d, e);
          this.z = null;
          this.z = c;
        }
        break;
    }
  }
  m(a) {
    a.i(this);
  }
  d($tResult, a) {
    return a.e(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.e(this, b);
  }
  get_v() {
    return true;
  }
  t() {
    return new AreaErr3DToken(1, this.z, this.x, this.h);
  }
  n(a) {
    if (!a.l.e) {
      return null;
    }
    let b = this.x.k(a, this.v);
    if (b._n == false) {
      return ExcelReferenceError._a2;
    }
    return this.z.b(b);
  }
  l(a, b) {
    let c = this.z.o(b, false);
    if (c == "#REF!") {
      return c;
    }
    return c + super.l(a, b);
  }
  get_o() {
    return this.z;
  }
  set_o(a) {
    this.z = a;
  }
}
Area3DNToken.$t = markType(Area3DNToken, 'Area3DNToken', AreaNToken.$);
/**
 * @hidden
 */
export class Area3DToken extends AreaToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
          this.z = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(1, d);
          this.z = null;
          this.z = c;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, d, e);
          this.z = null;
          this.z = c;
        }
        break;
    }
  }
  m(a) {
    a.j(this);
  }
  d($tResult, a) {
    return a.f(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.f(this, b);
  }
  get_v() {
    return false;
  }
  t() {
    return new AreaErr3DToken(1, this.z, this.x, this.h);
  }
  n(a) {
    let b = this.x.k(a, this.v);
    if (b._n == false) {
      return ExcelReferenceError._a2;
    }
    return this.z.b(b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 123;
      case 32: return 59;
      case 64: return 91;
      default: return 91;
    }
  }
  l(a, b) {
    let c = this.z.o(b, false);
    if (c == "#REF!") {
      return c;
    }
    return c + super.l(a, b);
  }
  get_o() {
    return this.z;
  }
  set_o(a) {
    this.z = a;
  }
}
Area3DToken.$t = markType(Area3DToken, 'Area3DToken', AreaToken.$);
/**
 * @hidden
 */
export class AreaErr3DToken extends Area3DToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, c, d, e);
        }
        break;
    }
  }
  m(a) {
    a.k(this);
  }
  d($tResult, a) {
    return a.g(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.g(this, b);
  }
  get_v() {
    return false;
  }
  n(a) {
    return ErrorValue.invalidCellReference._a();
  }
  get_w() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 61;
      case 32: return 61;
      case 64: return 93;
      default: return 74;
    }
  }
}
AreaErr3DToken.$t = markType(AreaErr3DToken, 'AreaErr3DToken', Area3DToken.$);
/**
 * @hidden
 */
export class AreaErrToken extends CellReferenceToken {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.l(this);
  }
  d($tResult, a) {
    return a.h(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.h(this, b);
  }
  get_v() {
    return false;
  }
  get v() {
    return this.get_v();
  }
  t() {
    return this;
  }
  n(a) {
    return ErrorValue.invalidCellReference._a();
  }
  get_w() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 107;
      case 32: return 43;
      case 64: return 75;
      default: return 74;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return "#REF!";
  }
}
AreaErrToken.$t = markType(AreaErrToken, 'AreaErrToken', CellReferenceToken.$);
/**
 * @hidden
 */
export class ArrayToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this.o = null;
          this.p = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [96];
          {
            let f = d[0];
            super(f);
            this.o = null;
            this.p = null;
          }
          this.p = c;
        }
        break;
    }
  }
  m(a) {
    a.o(this);
  }
  d($tResult, a) {
    return a.k(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.k(this, b);
  }
  n(a) {
    if (this.o == null) {
      let b = this.p.length;
      let c = this.p[0].length;
      this.o = ((() => {
        let $firstRank;
        let $ret = new Array($firstRank = b);
        let $currRet = $ret;
        for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
          $currRet[$rankInit] = new Array(c);
        }
        return $ret;
      })());
      for (let d = 0; d < c; d++) {
        for (let e = 0; e < b; e++) {
          this.o[e][d] = new ExcelCalcValue(this.p[e][d].c);
        }
      }
    }
    return this.o;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    if (this.p.length != d.p.length) {
      return false;
    }
    if (this.p[0].length != d.p[0].length) {
      return false;
    }
    let e = this.p.length;
    let f = this.p[0].length;
    for (let g = 0; g < f; g++) {
      for (let h = 0; h < e; h++) {
        if (Base.equalsStatic(this.p[h][g], d.p[h][g]) == false) {
          return false;
        }
      }
    }
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 96;
      case 32: return 32;
      case 64: return 64;
      default: return 64;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    let c = a.o.numberFormat.numberDecimalSeparator;
    let d = FormulaParser.bw(c);
    let e = new StringBuilder(2, "{");
    let f = this.p.length;
    let g = this.p[0].length;
    for (let h = 0; h < g; h++) {
      for (let i = 0; i < f; i++) {
        e.l(this.p[i][h].e(a.o));
        if (i != f - 1) {
          e.h(d);
        }
      }
      if (h != g - 1) {
        e.h(';');
      }
    }
    e.h('}');
    return e.toString();
  }
  get q() {
    return this.p;
  }
  set q(a) {
    this.p = a;
  }
}
ArrayToken.$t = markType(ArrayToken, 'ArrayToken', OperandToken.$);
/**
 * @hidden
 */
export let ISelectorFunctionOptimizationToken_$type = new Type(null, 'ISelectorFunctionOptimizationToken');
/**
 * @hidden
 */
export class AttrChooseToken extends AttrTokenBase {
  constructor() {
    super();
    this.s = 0;
    this.r = null;
  }
  get selectorFunctionTokenIndex() {
    return this.t;
  }
  set selectorFunctionTokenIndex(a) {
    this.t = a;
  }
  m(a) {
    a.p(this);
  }
  d($tResult, a) {
    return a.l(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.l(this, b);
  }
  get_p() {
    return 4;
  }
  get p() {
    return this.get_p();
  }
  get t() {
    return this.s;
  }
  set t(a) {
    this.s = a;
  }
  get skipTokenIndexes() {
    if (this.r == null) {
      this.r = new List$1(Number_$type, 0);
    }
    return this.r;
  }
}
AttrChooseToken.$t = markType(AttrChooseToken, 'AttrChooseToken', AttrTokenBase.$, [ISelectorFunctionOptimizationToken_$type]);
/**
 * @hidden
 */
export class AttrIfToken extends AttrTokenBase {
  constructor() {
    super();
    this.u = 0;
    this.t = null;
  }
  get selectorFunctionTokenIndex() {
    return this.v;
  }
  set selectorFunctionTokenIndex(a) {
    this.v = a;
  }
  m(a) {
    a.q(this);
  }
  d($tResult, a) {
    return a.m(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.m(this, b);
  }
  get_p() {
    return 2;
  }
  get p() {
    return this.get_p();
  }
  get r() {
    return this.skipTokenIndexes.count > 1;
  }
  get v() {
    return this.u;
  }
  set v(a) {
    this.u = a;
  }
  get skipTokenIndexes() {
    if (this.t == null) {
      this.t = new List$1(Number_$type, 0);
    }
    return this.t;
  }
}
AttrIfToken.$t = markType(AttrIfToken, 'AttrIfToken', AttrTokenBase.$, [ISelectorFunctionOptimizationToken_$type]);
/**
 * @hidden
 */
export class AttrSkipToken extends AttrTokenBase {
  constructor() {
    super();
    this.s = 0;
  }
  m(a) {
    a.r(this);
  }
  d($tResult, a) {
    return a.n(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.n(this, b);
  }
  get_p() {
    return 8;
  }
  get p() {
    return this.get_p();
  }
  get t() {
    return this.s;
  }
  set t(a) {
    this.s = a;
  }
}
AttrSkipToken.$t = markType(AttrSkipToken, 'AttrSkipToken', AttrTokenBase.$);
/**
 * @hidden
 */
export class AttrSpaceVolitileToken extends AttrSpaceToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(0);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c.v, c.t);
        }
        break;
    }
  }
  get_p() {
    return 65;
  }
  get_q() {
    return true;
  }
}
AttrSpaceVolitileToken.$t = markType(AttrSpaceVolitileToken, 'AttrSpaceVolitileToken', AttrSpaceToken.$);
/**
 * @hidden
 */
export let IFunctionToken_$type = new Type(null, 'IFunctionToken');
/**
 * @hidden
 */
export class AttrSumToken extends AttrTokenBase {
  constructor() {
    super();
    this.h = Function._n6._qj;
  }
  get argumentCount() {
    return 1;
  }
  get $function() {
    return Function._n6;
  }
  set $function(a) {
  }
  get formulaToken() {
    return this;
  }
  m(a) {
    a.t(this);
  }
  d($tResult, a) {
    return a.p(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.p(this, b);
  }
  l(a, b) {
    return Function._n6._alx;
  }
  get_p() {
    return 16;
  }
  get p() {
    return this.get_p();
  }
}
AttrSumToken.$t = markType(AttrSumToken, 'AttrSumToken', AttrTokenBase.$, [IFunctionToken_$type]);
/**
 * @hidden
 */
export class AttrVolatileToken extends AttrTokenBase {
  constructor() {
    super();
  }
  m(a) {
    a.u(this);
  }
  d($tResult, a) {
    return a.q(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.q(this, b);
  }
  get_p() {
    return 1;
  }
  get p() {
    return this.get_p();
  }
  get_q() {
    return true;
  }
}
AttrVolatileToken.$t = markType(AttrVolatileToken, 'AttrVolatileToken', AttrTokenBase.$);
/**
 * @hidden
 */
export class BoolToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(64);
          this.q = false;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(64);
            this.q = false;
          }
          this.q = c;
        }
        break;
    }
  }
  m(a) {
    a.w(this);
  }
  d($tResult, a) {
    return a.s(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.s(this, b);
  }
  n(a) {
    return this.q;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.q == d.q;
  }
  get_f() {
    return 29;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return stringToLocaleUpper(this.q.toString(), a.o);
  }
  get r() {
    return this.q;
  }
  set r(a) {
    this.q = a;
  }
}
BoolToken.$t = markType(BoolToken, 'BoolToken', OperandToken.$);
BoolToken.o = new BoolToken(1, false);
BoolToken.p = new BoolToken(1, true);
/**
 * @hidden
 */
export class ConcatOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 7;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 8;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "&";
  }
}
ConcatOperator.$t = markType(ConcatOperator, 'ConcatOperator', BinaryOperatorToken.$);
ConcatOperator.z = new ConcatOperator(64);
ConcatOperator.aa = new ConcatOperator(96);
/**
 * @hidden
 */
export class DivOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 5;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 6;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "/";
  }
}
DivOperator.$t = markType(DivOperator, 'DivOperator', BinaryOperatorToken.$);
DivOperator.z = new DivOperator(64);
DivOperator.aa = new DivOperator(96);
/**
 * @hidden
 */
export class EQOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 11;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "=";
  }
}
EQOperator.$t = markType(EQOperator, 'EQOperator', BinaryOperatorToken.$);
EQOperator.z = new EQOperator(64);
EQOperator.aa = new EQOperator(96);
/**
 * @hidden
 */
export class ErrToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(64);
          this.o = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(64);
            this.o = null;
          }
          this.o = c;
          if (this.o == ErrorValue.invalidCellReference) {
            this.h = 32;
          }
        }
        break;
    }
  }
  m(a) {
    a.y(this);
  }
  d($tResult, a) {
    return a.u(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.u(this, b);
  }
  n(a) {
    if (this.o == ErrorValue.circularity) {
      return 0;
    }
    return this.o._a();
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.o == d.o;
  }
  get_f() {
    return 28;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    if (this.p == ErrorValue.invalidCellReference) {
      return 32;
    }
    return super.get_h();
  }
  set_h(a) {
    super.set_h(a);
  }
  l(a, b) {
    return this.o.toString();
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
ErrToken.$t = markType(ErrToken, 'ErrToken', OperandToken.$);
/**
 * @hidden
 */
export class ExpToken extends SpecialFormulaToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(255);
          this.o = new CellAddress();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [new CellAddress(1, d, false, c, false)];
          {
            let g = e[0];
            {
              super(255);
              this.o = new CellAddress();
            }
            this.o = g;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          {
            super(255);
            this.o = new CellAddress();
          }
          this.o = c;
        }
        break;
    }
  }
  m(a) {
    a.z(this);
  }
  d($tResult, a) {
    return a.v(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.v(this, b);
  }
  get_n() {
    return true;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    if (a.j != c.j) {
      return false;
    }
    let d = b;
    return this.o.equals(d.o);
  }
  get_f() {
    return 1;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return "<Array Interior Or Shared Formula, Source: " + this.o.z(a, false) + ">";
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
ExpToken.$t = markType(ExpToken, 'ExpToken', SpecialFormulaToken.$);
/**
 * @hidden
 */
export class CloneTokenVisitor extends FormulaTokenVisitor$1 {
  constructor() {
    super(FormulaToken.$);
  }
  d(a) {
    return a;
  }
  a1() {
  }
  e(a) {
    return new Area3DNToken(1, a.o, a.x, a.h);
  }
  f(a) {
    return new Area3DToken(2, a.o, a.x, a.h);
  }
  g(a) {
    return new AreaErr3DToken(1, a.o, a.x, a.h);
  }
  i(a) {
    return new AreaNToken(2, a.x, a.h);
  }
  j(a) {
    return new AreaToken(2, a.x, a.h);
  }
  l(a) {
    let b = new AttrChooseToken();
    b.t = a.t;
    for (let c of fromEnum(a.skipTokenIndexes)) {
      b.skipTokenIndexes.add(c);
    }
    return b;
  }
  m(a) {
    let b = new AttrIfToken();
    b.v = a.v;
    for (let c of fromEnum(a.skipTokenIndexes)) {
      b.skipTokenIndexes.add(c);
    }
    return b;
  }
  n(a) {
    let b = new AttrSkipToken();
    b.t = a.t;
    return b;
  }
  v(a) {
    return new ExpToken(2, a.p);
  }
  aa(a) {
    let b = new MemAreaOperator(a.h);
    b.p = a.p;
    b.r = new Array(a.r.length);
    for (let c = 0; c < a.r.length; c++) {
      b.r[c] = a.r[c];
    }
    return b;
  }
  af(a) {
    let b = new NameToken(0, a.h, true);
    b.u = a.u;
    return b;
  }
  ag(a) {
    let b = new NameXToken(0, a.h, true);
    b.o = a.o;
    b.u = a.u;
    return b;
  }
  an(a) {
    return new RefErr3dToken(2, a.o, a.y, a.h);
  }
  ak(a) {
    return new Ref3DNToken(1, a.o, a.y, a.h);
  }
  al(a) {
    return new Ref3DToken(2, a.o, a.y, a.h);
  }
  ap(a) {
    return new RefNToken(2, a.y, a.h);
  }
  aq(a) {
    return new RefToken(2, a.y, a.h);
  }
  at(a) {
    return new TblToken(2, a.p);
  }
  as(a) {
    return new StructuredTableReference(4, a);
  }
}
CloneTokenVisitor.$t = markType(CloneTokenVisitor, 'CloneTokenVisitor', FormulaTokenVisitor$1.$.specialize(FormulaToken.$));
CloneTokenVisitor.a2 = new CloneTokenVisitor();
/**
 * @hidden
 */
export class ExpectedParameterClassVisitor extends FormulaTokenVisitor$2 {
  constructor() {
    super(Number_$type, TokenClass_$type);
  }
  d(a, b) {
    return 64;
  }
  a2() {
  }
  r(a, b) {
    if (a.y) {
      return 32;
    }
    return 64;
  }
  x(a, b) {
    return a.$function._qh(b);
  }
  av(a, b) {
    return 64;
  }
}
ExpectedParameterClassVisitor.$t = markType(ExpectedParameterClassVisitor, 'ExpectedParameterClassVisitor', FormulaTokenVisitor$2.$.specialize(Number_$type, TokenClass_$type));
ExpectedParameterClassVisitor.a3 = new ExpectedParameterClassVisitor();
/**
 * @hidden
 */
export class GetCalcFunctionVisitor extends FormulaTokenVisitor$2 {
  constructor() {
    super(UltraCalcFunctionFactory.$, ExcelCalcFunction.$);
  }
  d(a, b) {
    return null;
  }
  a2() {
  }
  r(a, b) {
    switch (a.f) {
      case 15: return b._item("xlintersect");
      case 17: return b._item("xlrange");
      case 16: return b._item("xlunion");
      case 3: return b._b(0);
      case 8: return b._b(10);
      case 6: return b._b(3);
      case 11: return b._b(4);
      case 7: return b._b(11);
      case 13: return b._b(7);
      case 12: return b._b(6);
      case 9: return b._b(9);
      case 10: return b._b(8);
      case 5: return b._b(2);
      case 14: return b._b(5);
      case 4: return b._b(1);
      default: return null;
    }
  }
  x(a, b) {
    let c = a.$function;
    let d;
    d = c._alx;
    if (c._vv == 261) {
      let e = d.indexOf('.');
      d = d.substr(0, e) + d.substr(e + 1);
    }
    return b._item(d);
  }
  aj(a, b) {
    return null;
  }
  av(a, b) {
    switch (a.f) {
      case 20: return b._b(12);
      case 19: return b._b(13);
      case 18: return b._b(14);
      default: return null;
    }
  }
}
GetCalcFunctionVisitor.$t = markType(GetCalcFunctionVisitor, 'GetCalcFunctionVisitor', FormulaTokenVisitor$2.$.specialize(UltraCalcFunctionFactory.$, ExcelCalcFunction.$));
GetCalcFunctionVisitor.a3 = new GetCalcFunctionVisitor();
/**
 * @hidden
 */
export class FunctionOperator extends OperatorToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this.z = 0;
          this.y = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c, c._q1];
          {
            let f = d[0];
            let g = d[1];
            let h = [f._qj];
            {
              let j = h[0];
              super(j);
              this.z = 0;
              this.y = null;
            }
            this.y = f;
            this.z = g;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c._qj];
          {
            let g = e[0];
            super(g);
            this.z = 0;
            this.y = null;
          }
          this.y = c;
          this.z = d;
        }
        break;
    }
  }
  get formulaToken() {
    return this;
  }
  m(a) {
    a.aa(this);
  }
  d($tResult, a) {
    return a.w(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.w(this, b);
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.y == d.y && this.z == d.z;
  }
  get_o() {
    return 0x7FFFFFFF;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    switch (this.h) {
      case 96: return 97;
      case 32: return 33;
      case 64: return 65;
      default: return 65;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return this.y._alx;
  }
  get argumentCount() {
    return this.z;
  }
  set argumentCount(a) {
    this.z = a;
  }
  get $function() {
    return this.y;
  }
  set $function(a) {
    this.y = a;
  }
}
FunctionOperator.$t = markType(FunctionOperator, 'FunctionOperator', OperatorToken.$, [IFunctionToken_$type]);
/**
 * @hidden
 */
export class FunctionVOperator extends FunctionOperator {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(2, c, d);
        }
        break;
    }
  }
  m(a) {
    a.ac(this);
  }
  d($tResult, a) {
    return a.y(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.y(this, b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 98;
      case 32: return 34;
      case 64: return 66;
      default: return 66;
    }
  }
}
FunctionVOperator.$t = markType(FunctionVOperator, 'FunctionVOperator', FunctionOperator.$);
/**
 * @hidden
 */
export class GEOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 12;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return ">=";
  }
}
GEOperator.$t = markType(GEOperator, 'GEOperator', BinaryOperatorToken.$);
GEOperator.z = new GEOperator(64);
GEOperator.aa = new GEOperator(96);
/**
 * @hidden
 */
export class GTOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 13;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return ">";
  }
}
GTOperator.$t = markType(GTOperator, 'GTOperator', BinaryOperatorToken.$);
GTOperator.z = new GTOperator(64);
GTOperator.aa = new GTOperator(96);
/**
 * @hidden
 */
export class IntToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(64);
          this.o = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(64);
            this.o = 0;
          }
          this.o = c;
        }
        break;
    }
  }
  m(a) {
    a.ad(this);
  }
  d($tResult, a) {
    return a.z(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.z(this, b);
  }
  n(a) {
    return this.o;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.o == d.o;
  }
  get_f() {
    return 30;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return this.o.toString();
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
IntToken.$t = markType(IntToken, 'IntToken', OperandToken.$);
/**
 * @hidden
 */
export class IsectOperator extends BinaryOperatorToken {
  constructor() {
    super(32);
  }
  get_y() {
    return true;
  }
  get_o() {
    return 1;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 15;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return " ";
  }
}
IsectOperator.$t = markType(IsectOperator, 'IsectOperator', BinaryOperatorToken.$);
IsectOperator.z = new IsectOperator();
/**
 * @hidden
 */
export class LEOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 10;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "<=";
  }
}
LEOperator.$t = markType(LEOperator, 'LEOperator', BinaryOperatorToken.$);
LEOperator.z = new LEOperator(64);
LEOperator.aa = new LEOperator(96);
/**
 * @hidden
 */
export class LTOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 9;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "<";
  }
}
LTOperator.$t = markType(LTOperator, 'LTOperator', BinaryOperatorToken.$);
LTOperator.z = new LTOperator(64);
LTOperator.aa = new LTOperator(96);
/**
 * @hidden
 */
export class MatrixRowSeparatorToken extends SpecialFormulaToken {
  constructor() {
    super(255);
  }
  m(a) {
    a.e(this);
  }
  d($tResult, a) {
    return a.d(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.d(this, b);
  }
  get_f() {
    return (this.f) - 1;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return ";";
  }
}
MatrixRowSeparatorToken.$t = markType(MatrixRowSeparatorToken, 'MatrixRowSeparatorToken', SpecialFormulaToken.$);
/**
 * @hidden
 */
export class MemOperatorBase extends SpecialFormulaToken {
  constructor(a) {
    super(a);
    this.o = 0;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.o == d.o;
  }
  l(a, b) {
    return getInstanceType(this).typeName;
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
MemOperatorBase.$t = markType(MemOperatorBase, 'MemOperatorBase', SpecialFormulaToken.$);
/**
 * @hidden
 */
export class MemAreaOperator extends MemOperatorBase {
  constructor(a) {
    super(a);
    this.q = null;
  }
  m(a) {
    a.ae(this);
  }
  d($tResult, a) {
    return a.aa(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.aa(this, b);
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    if (this.q.length != d.q.length) {
      return false;
    }
    for (let e = 0; e < this.q.length; e++) {
      if (this.q[e].equals(d.q[e]) == false) {
        return false;
      }
    }
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 102;
      case 32: return 38;
      case 64: return 70;
      default: return 70;
    }
  }
  get f() {
    return this.get_f();
  }
  get r() {
    return this.q;
  }
  set r(a) {
    this.q = a;
  }
}
MemAreaOperator.$t = markType(MemAreaOperator, 'MemAreaOperator', MemOperatorBase.$);
/**
 * @hidden
 */
export class MemErrOperator extends MemOperatorBase {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.af(this);
  }
  d($tResult, a) {
    return a.ab(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ab(this, b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 103;
      case 32: return 39;
      case 64: return 71;
      default: return 71;
    }
  }
  get f() {
    return this.get_f();
  }
}
MemErrOperator.$t = markType(MemErrOperator, 'MemErrOperator', MemOperatorBase.$);
/**
 * @hidden
 */
export class MemFuncOperator extends MemOperatorBase {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.ag(this);
  }
  d($tResult, a) {
    return a.ac(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ac(this, b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 105;
      case 32: return 41;
      case 64: return 73;
      default: return 73;
    }
  }
  get f() {
    return this.get_f();
  }
}
MemFuncOperator.$t = markType(MemFuncOperator, 'MemFuncOperator', MemOperatorBase.$);
/**
 * @hidden
 */
export class MemNoMemOperator extends MemOperatorBase {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.ah(this);
  }
  d($tResult, a) {
    return a.ad(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ad(this, b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 104;
      case 32: return 40;
      case 64: return 72;
      default: return 72;
    }
  }
  get f() {
    return this.get_f();
  }
}
MemNoMemOperator.$t = markType(MemNoMemOperator, 'MemNoMemOperator', MemOperatorBase.$);
/**
 * @hidden
 */
export class MissArgToken extends OperandToken {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.ai(this);
  }
  d($tResult, a) {
    return a.ae(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ae(this, b);
  }
  n(a) {
    return null;
  }
  get_f() {
    return 22;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return stringEmpty();
  }
}
MissArgToken.$t = markType(MissArgToken, 'MissArgToken', OperandToken.$);
MissArgToken.o = new MissArgToken(64);
MissArgToken.p = new MissArgToken(96);
/**
 * @hidden
 */
export class MulOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 5;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 5;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "*";
  }
}
MulOperator.$t = markType(MulOperator, 'MulOperator', BinaryOperatorToken.$);
MulOperator.z = new MulOperator(64);
MulOperator.aa = new MulOperator(96);
/**
 * @hidden
 */
export class NameToken extends ReferenceToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c);
          this.t = null;
          this.t = new NamedReferenceUnconnected(0, null, 2, 0, d);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          super(32);
          this.t = null;
          this.t = new NamedReferenceUnconnected(0, c, d.h, e, f);
          if (d.f != null) {
            Formula_ConnectReferencesVisitor.bb(d, this);
          }
        }
        break;
    }
  }
  m(a) {
    a.aj(this);
  }
  d($tResult, a) {
    return a.af(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.af(this, b);
  }
  n(a) {
    return this.u._f;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    if (a.j != c.j) {
      return false;
    }
    let d = b;
    return Base.equalsStatic(this.u, d.u);
  }
  get_f() {
    switch (this.h) {
      case 96: return 99;
      case 32: return 35;
      case 64: return 67;
      default: return 67;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return this.t._a1(b);
  }
  get w() {
    return this.t.name;
  }
  get u() {
    return this.t;
  }
  set u(a) {
    this.t = a;
  }
  get_v() {
    return null;
  }
  get v() {
    return this.get_v();
  }
}
NameToken.$t = markType(NameToken, 'NameToken', ReferenceToken.$);
/**
 * @hidden
 */
export class NameXToken extends NameToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(0, c, d);
          this.x = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = [32, h];
          {
            let k = i[0];
            let l = i[1];
            super(0, k, l);
            this.x = null;
          }
          this.u = new NamedReferenceUnconnected(0, e, f.h, g, h);
          let j = null;
          if (f.f != null) {
            if (c == null) {
              j = f.f._bb;
            }
            else if (f.f._dz != null) {
              let k;
              if (((() => { let l = f.f._dz.tryGetValue(c, k); k = l.p1; return l.ret; })())) {
                j = k;
              }
            }
          }
          if (j == null) {
            j = new WorkbookReferenceUnconnected(c, g == 2);
          }
          this.x = j.j(d);
          this.u._af = this.x.n;
          if (f.f != null) {
            Formula_ConnectReferencesVisitor.bc(f, this);
          }
        }
        break;
    }
  }
  m(a) {
    a.ak(this);
  }
  d($tResult, a) {
    return a.ag(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ag(this, b);
  }
  get_q() {
    return true;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return Base.equalsStatic(this.x, d.x);
  }
  get_r() {
    return this.x.j;
  }
  get_v() {
    return this.x.n;
  }
  get_f() {
    switch (this.h) {
      case 96: return 121;
      case 32: return 57;
      case 64: return 89;
      default: return 89;
    }
  }
  l(a, b) {
    return this.u._a1(b, true);
  }
  get_o() {
    return this.x;
  }
  set_o(a) {
    this.x = a;
  }
}
NameXToken.$t = markType(NameXToken, 'NameXToken', NameToken.$);
/**
 * @hidden
 */
export class NEOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 8;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 14;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "<>";
  }
}
NEOperator.$t = markType(NEOperator, 'NEOperator', BinaryOperatorToken.$);
NEOperator.z = new NEOperator(64);
NEOperator.aa = new NEOperator(96);
/**
 * @hidden
 */
export class NumberToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(64);
          this.o = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(64);
            this.o = 0;
          }
          this.o = c;
        }
        break;
    }
  }
  m(a) {
    a.al(this);
  }
  d($tResult, a) {
    return a.ah(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ah(this, b);
  }
  n(a) {
    return this.o;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.o == d.o;
  }
  get_f() {
    return 31;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return numberToString(this.o, a.o);
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
NumberToken.$t = markType(NumberToken, 'NumberToken', OperandToken.$);
/**
 * @hidden
 */
export class OpenParenOperator extends OperatorToken {
  constructor() {
    super(255);
  }
  m(a) {
    a.e(this);
  }
  d($tResult, a) {
    return a.d(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.d(this, b);
  }
  get_o() {
    return 0x7FFFFFFF;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return (this.f) - 1;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "(";
  }
}
OpenParenOperator.$t = markType(OpenParenOperator, 'OpenParenOperator', OperatorToken.$);
OpenParenOperator.y = new OpenParenOperator();
/**
 * @hidden
 */
export class UnaryOperatorToken extends OperatorToken {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.ay(this);
  }
  d($tResult, a) {
    return a.au(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.av(this, b);
  }
}
UnaryOperatorToken.$t = markType(UnaryOperatorToken, 'UnaryOperatorToken', OperatorToken.$);
/**
 * @hidden
 */
export class ParenToken extends FormulaToken {
  constructor() {
    super(255);
  }
  m(a) {
    a.an(this);
  }
  d($tResult, a) {
    return a.aj(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.aj(this, b);
  }
  get_f() {
    return 21;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return ")";
  }
}
ParenToken.$t = markType(ParenToken, 'ParenToken', FormulaToken.$);
/**
 * @hidden
 */
export class PercentOperator extends UnaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 3;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 20;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "%";
  }
}
PercentOperator.$t = markType(PercentOperator, 'PercentOperator', UnaryOperatorToken.$);
PercentOperator.y = new PercentOperator(64);
PercentOperator.z = new PercentOperator(96);
/**
 * @hidden
 */
export class PowerOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 4;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 7;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "^";
  }
}
PowerOperator.$t = markType(PowerOperator, 'PowerOperator', BinaryOperatorToken.$);
PowerOperator.z = new PowerOperator(64);
PowerOperator.aa = new PowerOperator(96);
/**
 * @hidden
 */
export class RangeOperator extends BinaryOperatorToken {
  constructor() {
    super(32);
  }
  get_y() {
    return true;
  }
  get_o() {
    return 0;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 17;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return ":";
  }
}
RangeOperator.$t = markType(RangeOperator, 'RangeOperator', BinaryOperatorToken.$);
RangeOperator.z = new RangeOperator();
/**
 * @hidden
 */
export class RefToken extends CellReferenceToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this.x = new CellAddress();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = [c, 32];
          {
            let f = d[0];
            let g = d[1];
            let h = [g];
            {
              let j = h[0];
              super(j);
              this.x = new CellAddress();
            }
            this.x = f;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [d];
          {
            let g = e[0];
            super(g);
            this.x = new CellAddress();
          }
          this.x = c;
        }
        break;
    }
  }
  m(a) {
    a.au(this);
  }
  d($tResult, a) {
    return a.aq(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.aq(this, b);
  }
  get_v() {
    return false;
  }
  get v() {
    return this.get_v();
  }
  t() {
    return new RefErrToken(this.h);
  }
  n(a) {
    let b = this.y.e(a, this.v);
    if (b.e == false) {
      return ExcelReferenceError._a2;
    }
    if (a.j == null) {
      return ExcelReferenceError._a2;
    }
    return a.j._rows$i.item(b.o)._as(b.m);
  }
  get_p() {
    return this.y.h;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    if (this.y.g != d.y.g) {
      return false;
    }
    if (this.y.p != d.y.p) {
      return false;
    }
    let e = this.y.e(a, this.v);
    let f = d.y.e(c, d.v);
    let g = 0;
    if (this.y.g) {
      g = c.l.m - a.l.m;
    }
    let h = 0;
    if (this.y.p && c.l.o != -1 && a.l.o != -1) {
      h = c.l.o - a.l.o;
    }
    return (e.m + g) == f.m && (e.o + h) == f.o;
  }
  get_f() {
    switch (this.h) {
      case 96: return 100;
      case 32: return 36;
      case 64: return 68;
      default: return 68;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    if (this.w) {
      return "#REF!";
    }
    return this.x.z(a, this.v);
  }
  get y() {
    return this.x;
  }
  set y(a) {
    this.x = a;
  }
}
RefToken.$t = markType(RefToken, 'RefToken', CellReferenceToken.$);
/**
 * @hidden
 */
export class RefNToken extends RefToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(2, c, d);
        }
        break;
    }
  }
  m(a) {
    a.at(this);
  }
  d($tResult, a) {
    return a.ap(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ap(this, b);
  }
  get_v() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 108;
      case 32: return 44;
      case 64: return 76;
      default: return 76;
    }
  }
}
RefNToken.$t = markType(RefNToken, 'RefNToken', RefToken.$);
/**
 * @hidden
 */
export class Ref3DNToken extends RefNToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(1, d);
          this.z = null;
          this.z = c;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, d, e);
          this.z = null;
          this.z = c;
        }
        break;
    }
  }
  m(a) {
    a.ao(this);
  }
  d($tResult, a) {
    return a.ak(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ak(this, b);
  }
  get_v() {
    return true;
  }
  t() {
    return new RefErr3dToken(2, this.z, this.y, this.h);
  }
  n(a) {
    if (!a.l.e) {
      return null;
    }
    let b = this.y.e(a, this.v);
    if (b.e == false) {
      return ExcelReferenceError._a2;
    }
    return this.z.a(b);
  }
  l(a, b) {
    let c = this.z.o(b, false);
    if (c == "#REF!") {
      return c;
    }
    return c + super.l(a, b);
  }
  get_o() {
    return this.z;
  }
  set_o(a) {
    this.z = a;
  }
}
Ref3DNToken.$t = markType(Ref3DNToken, 'Ref3DNToken', RefNToken.$);
/**
 * @hidden
 */
export class Ref3DToken extends RefToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
          this.z = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(1, d);
          this.z = null;
          this.z = c;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, d, e);
          this.z = null;
          this.z = c;
        }
        break;
    }
  }
  m(a) {
    a.ap(this);
  }
  d($tResult, a) {
    return a.al(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.al(this, b);
  }
  get_v() {
    return false;
  }
  t() {
    return new RefErr3dToken(2, this.z, this.y, this.h);
  }
  n(a) {
    let b = this.y.e(a, this.v);
    if (b.e == false) {
      return ExcelReferenceError._a2;
    }
    return this.z.a(b);
  }
  get_f() {
    switch (this.h) {
      case 96: return 122;
      case 32: return 58;
      case 64: return 90;
      default: return 90;
    }
  }
  l(a, b) {
    let c = this.z.o(b, false);
    if (c == "#REF!") {
      return c;
    }
    return c + super.l(a, b);
  }
  get_o() {
    return this.z;
  }
  set_o(a) {
    this.z = a;
  }
}
Ref3DToken.$t = markType(Ref3DToken, 'Ref3DToken', RefToken.$);
/**
 * @hidden
 */
export class RefErr3dToken extends Ref3DToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(1, c, new CellAddress(1, 0, false, 0, false));
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(2, c, d, e);
        }
        break;
    }
  }
  m(a) {
    a.ar(this);
  }
  d($tResult, a) {
    return a.an(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.an(this, b);
  }
  get_v() {
    return false;
  }
  n(a) {
    return ErrorValue.invalidCellReference._a();
  }
  get_w() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 124;
      case 32: return 60;
      case 64: return 92;
      default: return 74;
    }
  }
}
RefErr3dToken.$t = markType(RefErr3dToken, 'RefErr3dToken', Ref3DToken.$);
/**
 * @hidden
 */
export class RefErrToken extends CellReferenceToken {
  constructor(a) {
    super(a);
  }
  m(a) {
    a.as(this);
  }
  d($tResult, a) {
    return a.ao(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ao(this, b);
  }
  get_v() {
    return false;
  }
  get v() {
    return this.get_v();
  }
  t() {
    return this;
  }
  n(a) {
    return ErrorValue.invalidCellReference._a();
  }
  get_w() {
    return true;
  }
  get_f() {
    switch (this.h) {
      case 96: return 106;
      case 32: return 42;
      case 64: return 74;
      default: return 74;
    }
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return "#REF!";
  }
}
RefErrToken.$t = markType(RefErrToken, 'RefErrToken', CellReferenceToken.$);
/**
 * @hidden
 */
export class StrToken extends OperandToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(64);
          this.o = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          {
            super(64);
            this.o = null;
          }
          this.o = c;
        }
        break;
    }
  }
  m(a) {
    a.av(this);
  }
  d($tResult, a) {
    return a.ar(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.ar(this, b);
  }
  n(a) {
    return this.o;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    return this.o == d.o;
  }
  get_f() {
    return 23;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return "\"" + stringReplace(this.o, "\"", "\"\"") + "\"";
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
StrToken.$t = markType(StrToken, 'StrToken', OperandToken.$);
/**
 * @hidden
 */
export class StructuredTableReference extends ReferenceToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(32);
          this.t = null;
          this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
          this.ac = null;
          this.v = null;
          this.x = null;
          this.x = new WorkbookReferenceUnconnected(c, false);
          this.v = new NamedReferenceUnconnected(1, d, this.x, false, e, true);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = [c, d, f];
          {
            let i = g[0];
            let j = g[1];
            let k = g[2];
            super(32);
            this.t = null;
            this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
            this.ac = null;
            this.v = null;
            this.x = null;
            this.x = new WorkbookReferenceUnconnected(i, false);
            this.v = new NamedReferenceUnconnected(1, j, this.x, false, k, true);
          }
          this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, e);
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = [c, d, f];
          {
            let i = g[0];
            let j = g[1];
            let k = g[2];
            super(32);
            this.t = null;
            this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
            this.ac = null;
            this.v = null;
            this.x = null;
            this.x = new WorkbookReferenceUnconnected(i, false);
            this.v = new NamedReferenceUnconnected(1, j, this.x, false, k, true);
          }
          this.ac = e;
        }
        break;
      case 3:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = [c, d, f];
          {
            let i = g[0];
            let j = g[1];
            let k = g[2];
            super(32);
            this.t = null;
            this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
            this.ac = null;
            this.v = null;
            this.x = null;
            this.x = new WorkbookReferenceUnconnected(i, false);
            this.v = new NamedReferenceUnconnected(1, j, this.x, false, k, true);
          }
          this.t = e;
        }
        break;
      case 4:
        {
          let c = _rest[0];
          super(c.h);
          this.t = null;
          this.ab = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
          this.ac = null;
          this.v = null;
          this.x = null;
          this.x = c.x;
          this.v = c.v;
          this.ab = c.ab;
          this.ac = c.ac;
          this.t = c.t;
        }
        break;
    }
  }
  m(a) {
    a.aw(this);
  }
  d($tResult, a) {
    return a.as(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.as(this, b);
  }
  n(a) {
    let b = this.z(a);
    if (b == null) {
      return ErrorValue.invalidCellReference._a();
    }
    let c = a.m;
    if (this.t != null) {
      return this.t.a(b, c);
    }
    else if (this.ab.hasValue) {
      return new TableCalcReference(c, b, this.ab, Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null));
    }
    else if (this.ac != null) {
      let d = b._columns$i._item1(this.ac);
      if (d != null) {
        return new TableColumnCalcReference(c, d, Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null), Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null));
      }
    }
    return b._f;
  }
  get_q() {
    return this.x != null;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    let d = b;
    if (nullableNotEquals(this.ab, d.ab)) {
      return false;
    }
    if (this.ac != d.ac) {
      return false;
    }
    if (this.v == null || d.v == null) {
      if (this.v != null || d.v != null) {
        return false;
      }
    }
    else if (Base.equalsStatic(this.v, d.v) == false) {
      return false;
    }
    if (Base.equalsStatic(this.x, d.x) == false) {
      return false;
    }
    if (Base.equalsStatic(this.t, d.t) == false) {
      return false;
    }
    return true;
  }
  get_r() {
    if (this.o != null) {
      return super.get_r();
    }
    return this.x != null && this.x.n;
  }
  s(a) {
    this.x = a;
  }
  l(a, b) {
    let c = this.v != null ? this.v.name : "";
    let d;
    let e = StructuredTableReference.af(((() => { let f = this.ae(a.o, b, d); d = f.p2; return f.ret; })()), b.b);
    if (d == false && c != null && a.d != null && a.d._ab != null) {
      let f = a.d._ab.getCellAssociatedTable(a.d._bb);
      if (f != null && StringUtilities.c(f.name, c, a.o, 1) == 0) {
        c = null;
      }
    }
    let g = this.x.z(b);
    return g + (c != null ? c : "") + e;
  }
  get_f() {
    switch (this.h) {
      case 96: return 4192;
      case 32: return 4128;
      case 64: return 4160;
      default: return 4160;
    }
  }
  get f() {
    return this.get_f();
  }
  z(a) {
    if (this.x.n || this.v == null) {
      return null;
    }
    if (this.v.name == null) {
      let b = a.m;
      if (b != null) {
        return b._bp(a.l.m);
      }
      else {
        return null;
      }
    }
    if (a.f != null) {
      return a.f.getTable(this.v.name);
    }
    return null;
  }
  static ad(a) {
    if (a == null) {
      return null;
    }
    for (let b = 0; b < a.length; b++) {
      let c = a.charAt(b);
      if (FormulaParser.aa(c)) {
        let d = new StringBuilder(2, a.substr(0, b));
        d.h('\'');
        d.h(c);
        for (let e = b + 1; e < a.length; e++) {
          c = a.charAt(e);
          if (FormulaParser.aa(c)) {
            d.h('\'');
          }
          d.h(c);
        }
        return d.toString();
      }
    }
    return a;
  }
  ae(a, b, c) {
    c = true;
    if (this.t != null) {
      return {
        ret: this.t.s(a, b),
        p2: c
      };
    }
    if (this.ab.hasValue) {
      return {
        ret: FormulaParser.cx(this.ab.value),
        p2: c
      };
    }
    if (this.ac != null) {
      c = b.b;
      return {
        ret: StructuredTableReference.ad(this.ac),
        p2: c
      };
    }
    return {
      ret: stringEmpty(),
      p2: c
    };
  }
  static af(a, b) {
    if (b == false && a == stringEmpty()) {
      return stringEmpty();
    }
    return '[' + a + ']';
  }
  ai(a, b) {
    if (this.x.n == false && this.v != null && StringUtilities.c(a.name, this.v.name, a._z, 1) == 0) {
      for (let c = 0; c < b.count; c++) {
        let d = b._inner[c];
        if (this.ac != null && StringUtilities.c(d.value, this.ac, a._z, 1) == 0) {
          this.ac = d.key.name;
        }
        if (this.t != null) {
          this.t.t(a, d.value, d.key.name);
        }
      }
    }
  }
  get aa() {
    if (nullableEquals(this.ab, 4)) {
      return true;
    }
    if (this.t != null) {
      return this.t.i;
    }
    return false;
  }
  get u() {
    return this.t;
  }
  get ag() {
    return this.ac;
  }
  get ah() {
    return this.v != null ? this.v.name : null;
  }
  get w() {
    return this.v;
  }
  set w(a) {
    this.v = a;
  }
  get y() {
    return this.x;
  }
  set y(a) {
    this.x = a;
  }
}
StructuredTableReference.$t = markType(StructuredTableReference, 'StructuredTableReference', ReferenceToken.$);
/**
 * @hidden
 */
export class StructuredTableReference_InnerReference extends Base {
  constructor(a, ..._rest) {
    super();
    this.n = null;
    this.l = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    this.b = false;
    this.c = false;
    this.d = false;
    this.e = false;
    this.o = null;
    this.m = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.l = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, c);
          this.c = d;
          this.m = e;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = [c, d, e];
          {
            let k = i[0];
            let l = i[1];
            let m = i[2];
            this.l = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, k);
            this.c = l;
            this.m = m;
          }
          this.d = f;
          this.n = g;
          this.o = h;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.n = c;
          this.o = d;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(StructuredTableReference_InnerReference.$, a);
    return b != null && nullableEquals(this.l, b.l) && nullableEquals(this.m, b.m) && this.n == b.n && this.o == b.o && this.c == b.c && this.d == b.d && this.b == b.b && this.e == b.e;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.n) ^ Base.getHashCodeStatic(this.o);
  }
  toString() {
    return this.s(ExcelUtils.cq, GetFormulaStringInfo.a);
  }
  s(a, b) {
    let c = StructuredTableReference.ad(this.n);
    let d = StructuredTableReference.ad(this.o);
    if (c != null && d == null && this.l.hasValue == false && this.m.hasValue == false) {
      return c;
    }
    let e = FormulaParser.bx(a);
    let f = stringEmpty();
    if (this.h) {
      f += " ";
    }
    if (this.l.hasValue) {
      f += StructuredTableReference.af(FormulaParser.cx(this.l.value), b.b);
      if (this.m.hasValue) {
        f += e;
        if (this.c) {
          f += " ";
        }
        f += StructuredTableReference.af(FormulaParser.cx(this.m.value), b.b);
      }
    }
    if (c != null) {
      if (this.l.hasValue) {
        f += e;
        if (this.d) {
          f += " ";
        }
      }
      f += StructuredTableReference.af(c, b.b);
      if (d != null) {
        f += ":" + StructuredTableReference.af(d, b.b);
      }
    }
    if (this.g) {
      f += " ";
    }
    return f;
  }
  a(a, b) {
    if (this.o != null) {
      let c = a._columns$i._item1(this.n);
      let d = a._columns$i._item1(this.o);
      if (c != null && d != null) {
        return new TableColumnRangeCalcReference(b, c, d, this.l, this.m);
      }
    }
    else if (this.n != null) {
      let e = a._columns$i._item1(this.n);
      if (e != null) {
        return new TableColumnCalcReference(b, e, this.l, this.m);
      }
    }
    else {
      return new TableCalcReference(b, a, this.l, this.m);
    }
    return ExcelReferenceError._a2;
  }
  t(a, b, c) {
    if (this.n != null && StringUtilities.c(b, this.n, a._z, 1) == 0) {
      this.n = c;
    }
    if (this.o != null && StringUtilities.c(b, this.o, a._z, 1) == 0) {
      this.o = c;
    }
  }
  get p() {
    return this.n;
  }
  get i() {
    return nullableEquals(this.l, 4) || nullableEquals(this.m, 4);
  }
  get g() {
    return this.b;
  }
  set g(a) {
    this.b = a;
  }
  get h() {
    return this.e;
  }
  set h(a) {
    this.e = a;
  }
  get j() {
    return this.n != null && this.o == null && nullableEquals(this.l, null) && nullableEquals(this.m, null) && this.c == false && this.d == false && this.b == false && this.e == false;
  }
  get q() {
    return this.o;
  }
}
StructuredTableReference_InnerReference.$t = markType(StructuredTableReference_InnerReference, 'StructuredTableReference_InnerReference');
/**
 * @hidden
 */
export class SubOperator extends BinaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_o() {
    return 6;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 4;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "-";
  }
}
SubOperator.$t = markType(SubOperator, 'SubOperator', BinaryOperatorToken.$);
SubOperator.z = new SubOperator(64);
SubOperator.aa = new SubOperator(96);
/**
 * @hidden
 */
export class TblToken extends SpecialFormulaToken {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super(255);
          this.o = new CellAddress();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [new CellAddress(1, d, false, c, false)];
          {
            let g = e[0];
            {
              super(255);
              this.o = new CellAddress();
            }
            this.o = g;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          {
            super(255);
            this.o = new CellAddress();
          }
          this.o = c;
        }
        break;
    }
  }
  m(a) {
    a.ax(this);
  }
  d($tResult, a) {
    return a.at(this);
  }
  e($tArgument, $tResult, a, b) {
    return a.at(this, b);
  }
  get_n() {
    return true;
  }
  j(a, b, c) {
    if (super.j(a, b, c) == false) {
      return false;
    }
    if (a.j != c.j) {
      return false;
    }
    let d = b;
    return this.o.equals(d.o);
  }
  get_f() {
    return 2;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    let c = this.o.e(a, false);
    if (a.j != null && c.e) {
      let d = a.j._rows$i.item(c.o);
      let e = d._bg(c.m);
      return e._v();
    }
    return "<Data Table Interior, Source: " + this.o.z(a, false) + ">";
  }
  get p() {
    return this.o;
  }
  set p(a) {
    this.o = a;
  }
}
TblToken.$t = markType(TblToken, 'TblToken', SpecialFormulaToken.$);
/**
 * @hidden
 */
export class UminusOperator extends UnaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_n() {
    return true;
  }
  get_o() {
    return 3;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 19;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "-";
  }
}
UminusOperator.$t = markType(UminusOperator, 'UminusOperator', UnaryOperatorToken.$);
UminusOperator.y = new UminusOperator(64);
UminusOperator.z = new UminusOperator(96);
/**
 * @hidden
 */
export class UnionOperator extends BinaryOperatorToken {
  constructor() {
    super(32);
  }
  get_y() {
    return true;
  }
  get_o() {
    return 2;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 16;
  }
  get f() {
    return this.get_f();
  }
  l(a, b) {
    return FormulaParser.by(a.o.numberFormat.numberDecimalSeparator).toString();
  }
}
UnionOperator.$t = markType(UnionOperator, 'UnionOperator', BinaryOperatorToken.$);
UnionOperator.z = new UnionOperator();
/**
 * @hidden
 */
export class UplusOperator extends UnaryOperatorToken {
  constructor(a) {
    super(a);
  }
  get_n() {
    return true;
  }
  get_o() {
    return 3;
  }
  get o() {
    return this.get_o();
  }
  get_f() {
    return 18;
  }
  get f() {
    return this.get_f();
  }
  get_h() {
    return super.get_h();
  }
  set_h(a) {
  }
  l(a, b) {
    return "+";
  }
}
UplusOperator.$t = markType(UplusOperator, 'UplusOperator', UnaryOperatorToken.$);
UplusOperator.y = new UplusOperator(64);
UplusOperator.z = new UplusOperator(96);
/**
 * @hidden
 */
export class Constant extends Base {
  static a(a, b, c) {
    let d = ((() => { let e = a.readByteFromBuffer(b, c); b = e.p0; c = e.p1; return e.ret; })());
    switch (d) {
      case 0: return {
        ret: new EmptyConstant(),
        p1: b,
        p2: c
      };
      case 1: return {
        ret: new NumberConstant(0),
        p1: b,
        p2: c
      };
      case 2: return {
        ret: new StringConstant(0),
        p1: b,
        p2: c
      };
      case 4: return {
        ret: new BooleanConstant(0),
        p1: b,
        p2: c
      };
      case 16: return {
        ret: new ErrorConstant(0),
        p1: b,
        p2: c
      };
      default: return {
        ret: null,
        p1: b,
        p2: c
      };
    }
  }
  toString() {
    return this.e(ExcelUtils.cq);
  }
}
Constant.$t = markType(Constant, 'Constant');
/**
 * @hidden
 */
export class BooleanConstant extends Constant {
  constructor(a, ..._rest) {
    super();
    this.h = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.h = c;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(BooleanConstant.$, a);
    return b != null && b.h == this.h;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.h);
  }
  f(a, b, c) {
    this.h = ((() => { let d = a.readByteFromBuffer(b, c); b = d.p0; c = d.p1; return d.ret; })()) != 0;
    let d = a.readBytesFromBuffer(7, b, c);
    b = d.p1;
    c = d.p2;
    return {
      p1: b,
      p2: c
    };
  }
  g(a) {
    a.writeByte((this.h ? 1 : 0));
    a.writeByteArray(new Array(7));
  }
  e(a) {
    return this.h ? "TRUE" : "FALSE";
  }
  get_b() {
    return 4;
  }
  get b() {
    return this.get_b();
  }
  get_c() {
    return this.h;
  }
  get c() {
    return this.get_c();
  }
}
BooleanConstant.$t = markType(BooleanConstant, 'BooleanConstant', Constant.$);
/**
 * @hidden
 */
export class EmptyConstant extends Constant {
  equals(a) {
    return typeCast(EmptyConstant.$, a) !== null;
  }
  getHashCode() {
    return 0;
  }
  f(a, b, c) {
    let d = a.readBytesFromBuffer(8, b, c);
    b = d.p1;
    c = d.p2;
    return {
      p1: b,
      p2: c
    };
  }
  g(a) {
    a.writeByteArray(new Array(8));
  }
  e(a) {
    return stringEmpty();
  }
  get_b() {
    return 0;
  }
  get b() {
    return this.get_b();
  }
  get_c() {
    return null;
  }
  get c() {
    return this.get_c();
  }
}
EmptyConstant.$t = markType(EmptyConstant, 'EmptyConstant', Constant.$);
/**
 * @hidden
 */
export class ErrorConstant extends Constant {
  constructor(a, ..._rest) {
    super();
    this.h = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.h = c;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(ErrorConstant.$, a);
    return b != null && b.h == this.h;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.h);
  }
  f(a, b, c) {
    this.h = ErrorValue._j(((() => { let d = a.readByteFromBuffer(b, c); b = d.p0; c = d.p1; return d.ret; })()));
    let d = a.readBytesFromBuffer(7, b, c);
    b = d.p1;
    c = d.p2;
    return {
      p1: b,
      p2: c
    };
  }
  g(a) {
    a.writeByte(this.h._y);
    a.writeByteArray(new Array(7));
  }
  e(a) {
    return this.h.toString();
  }
  get_b() {
    return 16;
  }
  get b() {
    return this.get_b();
  }
  get_c() {
    return this.h._a();
  }
  get c() {
    return this.get_c();
  }
}
ErrorConstant.$t = markType(ErrorConstant, 'ErrorConstant', Constant.$);
/**
 * @hidden
 */
export class NumberConstant extends Constant {
  constructor(a, ..._rest) {
    super();
    this.h = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.h = c;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(NumberConstant.$, a);
    return b != null && b.h == this.h;
  }
  getHashCode() {
    return (this.h);
  }
  f(a, b, c) {
    this.h = ((() => { let d = a.readDoubleFromBuffer(b, c); b = d.p0; c = d.p1; return d.ret; })());
    return {
      p1: b,
      p2: c
    };
  }
  g(a) {
    a.writeDouble(this.h);
  }
  e(a) {
    return numberToString(this.h, a);
  }
  get_b() {
    return 1;
  }
  get b() {
    return this.get_b();
  }
  get_c() {
    return this.h;
  }
  get c() {
    return this.get_c();
  }
}
NumberConstant.$t = markType(NumberConstant, 'NumberConstant', Constant.$);
/**
 * @hidden
 */
export class StringConstant extends Constant {
  constructor(a, ..._rest) {
    super();
    this.h = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.h = c;
        }
        break;
    }
  }
  equals(a) {
    let b = typeCast(StringConstant.$, a);
    return b != null && b.h == this.h;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.h);
  }
  f(a, b, c) {
    this.h = ((() => { let d = a.readFormattedStringFromBuffer(1, b, c); b = d.p1; c = d.p2; return d.ret; })())._y;
    return {
      p1: b,
      p2: c
    };
  }
  g(a) {
    a.writeString(this.h, 1);
  }
  e(a) {
    return "\"" + stringReplace(this.h, "\"", "\"\"") + "\"";
  }
  get_b() {
    return 2;
  }
  get b() {
    return this.get_b();
  }
  get_c() {
    return this.h;
  }
  get c() {
    return this.get_c();
  }
}
StringConstant.$t = markType(StringConstant, 'StringConstant', Constant.$);
/**
 * @hidden
 */
export class ExternalCellCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a3 = new WorksheetCellAddress();
    this._a2 = null;
    this._a2 = a;
    this._a3 = new WorksheetCellAddress(1, b, c);
  }
  get__ao() {
    return this._a3.m;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a2 == c._a2 && WorksheetCellAddress.f(this._a3, c._a3);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a2 == d._q && d._a5._g(this._a3);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a2.e == e._a3.e && e._a3.l <= this._a2.l && this._a2.l <= e._a4.l && WorksheetCellAddress.f(this._a3, e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a2.e == f._a3.e && f._a3.l <= this._a2.l && this._a2.l <= f._a4.l && f._a8._g(this._a3);
    }
    return false;
  }
  get_elementName() {
    return this._a2.p + this._a3.p(false, false, this._a2.e.l.currentFormat, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(ExternalCellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a2 == b._a2 && WorksheetCellAddress.f(this._a3, b._a3);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a2) ^ this._a3.getHashCode() << 1;
  }
  isSubsetReference(a) {
    return this.containsReference(a);
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
  get__as() {
    return this._a3.o;
  }
  get__c() {
    return new ExcelCalcValue(this._a2.z(this._a3.o, this._a3.m));
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a2.e.l;
  }
  get _a4() {
    return this._a3;
  }
  get__q() {
    return this._a2;
  }
}
ExternalCellCalcReference.$t = markType(ExternalCellCalcReference, 'ExternalCellCalcReference', RefBase.$);
/**
 * @hidden
 */
export class ExternalNamedCalcReference extends NamedCalcReferenceBase {
  constructor(a) {
    super();
    this._a3 = null;
    this._a2 = null;
    this._a2 = a;
  }
  get__formula() {
    return this._a3;
  }
  get__x() {
    return true;
  }
  containsReference(a) {
    let b = typeCast(ExternalNamedCalcReference.$, ExcelCalcEngine.b(a));
    if (b == null) {
      return false;
    }
    return b._a2 == this._a2;
  }
  get_context() {
    return this._a2;
  }
  get_elementName() {
    return this._a2.toString();
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(ExternalNamedCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a2 == b._a2;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a2);
  }
  isSubsetReference(a) {
    let b = typeCast(ExternalNamedCalcReference.$, ExcelCalcEngine.b(a));
    if (b == null) {
      return false;
    }
    return b._a2 == this._a2;
  }
  _az(a) {
    this._a3 = a;
  }
  get__c() {
    return new ExcelCalcValue(this._formula);
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a2._h.l;
  }
}
ExternalNamedCalcReference.$t = markType(ExternalNamedCalcReference, 'ExternalNamedCalcReference', NamedCalcReferenceBase.$);
/**
 * @hidden
 */
export class ExternalRegionCalcReference extends RefBase {
  constructor(a, b) {
    super();
    this._a4 = new WorksheetRegionAddress();
    this._a2 = null;
    this._a3 = null;
    this._a3 = a;
    this._a4 = b;
    this._a2 = new ExcelCalcValue(new ExternalRegionCalcReference_ExternalRegionValuesArray(this));
  }
  get__ao() {
    return this._a4._w;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a3 == c._q && this._a4._g(c._a4);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a3 == d._a3 && this._a4._j(d._a4);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a3.e == e._a3.e && e._a3.l <= this._a3.l && this._a3.l <= e._a4.l && this._a4._g(e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a3.e == f._a3.e && f._a3.l <= this._a3.l && this._a3.l <= f._a4.l && this._a4._j(f._a8);
    }
    return false;
  }
  get_elementName() {
    return this._a3.p + this._a4._ah(false, false, this._t.currentFormat, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(ExternalRegionCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a3 == b._a3 && WorksheetRegionAddress._o(this._a4, b._a4);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a3) ^ this._a4.getHashCode() << 1;
  }
  isSubsetReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a3 == c._q && this._a4._g(c._a4);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a3 == d._a3 && this._a4._h(d._a4);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a3.e == e._a3.e && e._a3.l <= this._a3.l && this._a3.l <= e._a4.l && this._a4._g(e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a3.e == f._a3.e && f._a3.l <= this._a3.l && this._a3.l <= f._a4.l && this._a4._h(f._a8);
    }
    return false;
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
  get__as() {
    return this._a4._ac;
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a3.e.l;
  }
  get _a5() {
    return this._a4;
  }
  get__q() {
    return this._a3;
  }
}
ExternalRegionCalcReference.$t = markType(ExternalRegionCalcReference, 'ExternalRegionCalcReference', RefBase.$);
/**
 * @hidden
 */
export class ExternalRegionCalcReference_ExternalRegionValuesArray extends ArrayProxy {
  constructor(a) {
    super();
    this._p = null;
    this._o = null;
    this._p = a;
  }
  get__g() {
    return true;
  }
  get _g() {
    return this.get__g();
  }
  *__j(a, b) {
    let c = this._p._a5;
    let d = this._p._q;
    switch (a) {
      case 0:
        {
          let e = (c._w + b);
          for (let f = c._ac; f <= c._ae; f++) {
            let g = d.u(f);
            if (g != null) {
              let h = ExcelCalcNumberStack._c(g.h(e));
              yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, f - c._ac, h);
              ExcelCalcNumberStack._ad(h);
            }
          }
        }
        break;
      case 1:
        {
          let i = c._ac + b;
          let j = d.u(i);
          if (j != null) {
            for (let k = c._w; k <= c._x; k++) {
              let l = ExcelCalcNumberStack._c(j.h(k));
              yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, k - c._w, l);
              ExcelCalcNumberStack._ad(l);
            }
          }
        }
        break;
      default:
        this._n();
        break;
    }
  }
  _j(a, b) {
    return toEnum(() => this.__j(a, b));
  }
  getLength(a) {
    switch (a) {
      case 0: return this._p._a5._af;
      case 1: return this._p._a5._ad;
      default:
        this._n();
        return -1;
    }
  }
  _c(a) {
    if (a.b < 0 || this.getLength(0) <= a.b) {
      this._n();
    }
    if (a.c < 0 || this.getLength(1) <= a.c) {
      this._n();
    }
    let b = this._p._a5;
    let c = (b._w + a.b);
    let d = b._ac + a.c;
    return ExcelCalcNumberStack._c(this._p._q.z(d, c));
  }
  _a() {
    if (this._o == null) {
      let a = this._p._a5;
      let b = this._p._q;
      this._o = ((() => {
        let $firstRank;
        let $ret = new Array($firstRank = a._af);
        let $currRet = $ret;
        for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
          $currRet[$rankInit] = new Array(a._ad);
        }
        return $ret;
      })());
      for (let c = a._w; c <= a._x; c++) {
        for (let d = a._ac; d <= a._ae; d++) {
          let e = b.z(d, c);
          let f;
          if (e == null) {
            f = ExcelCalcValue._g;
          }
          else {
            f = new ExcelCalcValue(e);
          }
          this._o[c - a._w][d - a._ac] = f;
        }
      }
    }
    return this._o;
  }
}
ExternalRegionCalcReference_ExternalRegionValuesArray.$t = markType(ExternalRegionCalcReference_ExternalRegionValuesArray, 'ExternalRegionCalcReference_ExternalRegionValuesArray', ArrayProxy.$);
/**
 * @hidden
 */
export class MatrixUtilities extends Base {
  static f(a, b, c, d) {
    let e = MatrixUtilities.c(a, b, c, d);
    let f = MatrixUtilities.g(e, b - 1);
    return Math.pow(-1, d + c) * f;
  }
  static g(a, b) {
    if (b == 1) {
      return a[0][0];
    }
    let c = 0;
    for (let d = 0; d < b; d++) {
      let e = MatrixUtilities.f(a, b, d, 0);
      c += a[d][0] * e;
    }
    return c;
  }
  static a(a, b, c) {
    c = null;
    let d = MatrixUtilities.g(a, b);
    if (d == 0) {
      c = ErrorValue.valueRangeOverflow._a();
      return {
        ret: null,
        p2: c
      };
    }
    let e = 1 / d;
    let f = MatrixUtilities.e(Number_$type, a);
    let g = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = b);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(b);
      }
      return $ret;
    })());
    for (let h = 0; h < b; h++) {
      for (let i = 0; i < b; i++) {
        g[h][i] = e * MatrixUtilities.f(f, b, h, i);
      }
    }
    return {
      ret: g,
      p2: c
    };
  }
  static b(a, b, c) {
    c = null;
    let d = a.getLength(0);
    let e = a.getLength(1);
    let f = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = d);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(e);
      }
      return $ret;
    })());
    for (let g = 0; g < e; g++) {
      for (let h = 0; h < d; h++) {
        let i = a.item(h, g);
        if (i.isError) {
          c = i.toErrorValue();
          return {
            ret: null,
            p2: c
          };
        }
        if (i.isString || i.isBoolean) {
          switch (b) {
            case 0:
              c = new ExcelCalcErrorValue(1);
              return {
                ret: null,
                p2: c
              };
            case 1:
              f[h][g] = 0;
              break;
            case 2:
              f[h][g] = NaN;
              break;
            default: break;
          }
        }
        else {
          f[h][g] = i._toDouble3();
        }
      }
    }
    return {
      ret: f,
      p2: c
    };
  }
  static c(a, b, c, d) {
    let e = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = b - 1);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(b - 1);
      }
      return $ret;
    })());
    for (let f = 0, g = 0; f < b; f++ , g++) {
      if (f == c) {
        g--;
        continue;
      }
      for (let h = 0, i = 0; h < b; h++ , i++) {
        if (h == d) {
          i--;
          continue;
        }
        e[g][i] = a[f][h];
      }
    }
    return e;
  }
  static e($t, a) {
    let b = arrayGetLength(a, 0);
    let c = arrayGetLength(a, 1);
    let d = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = c);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(b);
      }
      return $ret;
    })());
    for (let e = 0; e < b; e++) {
      for (let f = 0; f < c; f++) {
        d[f][e] = a[e][f];
      }
    }
    return d;
  }
  static d(a) {
    let b = a.getLength(0);
    let c = a.getLength(1);
    let d = ((() => {
      let $firstRank;
      let $ret = new Array($firstRank = c);
      let $currRet = $ret;
      for (let $rankInit = 0; $rankInit < $firstRank; $rankInit++) {
        $currRet[$rankInit] = new Array(b);
      }
      return $ret;
    })());
    for (let e = 0; e < b; e++) {
      for (let f = 0; f < c; f++) {
        d[f][e] = a.item(e, f);
      }
    }
    return d;
  }
}
MatrixUtilities.$t = markType(MatrixUtilities, 'MatrixUtilities');
/**
 * @hidden
 */
export class MultiSheetCellCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a6 = new WorksheetCellAddress();
    this._a4 = null;
    this._a5 = null;
    this._a3 = null;
    this._a7 = null;
    this._a2 = null;
    this._a4 = a;
    this._a5 = b;
    this._a6 = c;
    let d = this._a4.workbook._worksheets$i;
    let e = new WorksheetRegionAddress(1, this._a6.o, this._a6.o, this._a6.m, this._a6.m);
    let f = this._a5.index - this._a4.index + 1;
    this._a7 = new List$1(WorksheetRegion.$, 2, f);
    let g = new Array(f);
    for (let h = this._a4.index, i = 0; h <= this._a5.index; h++ , i++) {
      let j = d._item(h)._cw(e);
      this._a7.add(j);
      g[i] = new RegionCalcReference_RegionArrayProxy(j);
    }
    this._a2 = new ExcelCalcValue(g);
    this._a3 = new MultiSheetCellCalcReference_MultiSheetCellReferencesCollection(this);
  }
  get__ao() {
    return this._a6.m;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = CalcUtilities.l(a);
    for (let c = 0; c < b.count; c++) {
      let d = b.item(c);
      if (d.worksheet.index < this._a4.index || this._a5.index < d.worksheet.index) {
        continue;
      }
      if (d._h._g(this._a6)) {
        return true;
      }
    }
    return false;
  }
  get_context() {
    return this._a7;
  }
  get_elementName() {
    return ExcelUtils.d6(null, this._a4.name, this._a5.name) + this._a6.p(false, false, this._a4._o, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(MultiSheetCellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a4 == b._a4 && this._a5 == b._a5 && WorksheetCellAddress.f(this._a6, b._a6);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a4) ^ Base.getHashCodeStatic(this._a5) << 1 ^ this._a6.getHashCode() << 2;
  }
  _am() {
    return this._a7;
  }
  get_isEnumerable() {
    return true;
  }
  isSubsetReference(a) {
    let b = CalcUtilities.l(a);
    for (let c = 0; c < b.count; c++) {
      let d = b.item(c);
      if (d.worksheet.index < this._a4.index || this._a5.index < d.worksheet.index) {
        return false;
      }
      if (d._h._g(this._a6) == false) {
        return false;
      }
    }
    return true;
  }
  get__references() {
    return this._a3;
  }
  get__w() {
    return this._a4._rows$i.item(this._a6.o);
  }
  get _w() {
    return this.get__w();
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
}
MultiSheetCellCalcReference.$t = markType(MultiSheetCellCalcReference, 'MultiSheetCellCalcReference', RefBase.$);
/**
 * @hidden
 */
export class MultiSheetCellCalcReference_MultiSheetCellReferencesCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  *_getEnumerator() {
    for (let a of fromEnum(this._a._a7)) {
      yield a._k._as(a._v);
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return getEnumerator(this);
  }
}
MultiSheetCellCalcReference_MultiSheetCellReferencesCollection.$t = markType(MultiSheetCellCalcReference_MultiSheetCellReferencesCollection, 'MultiSheetCellCalcReference_MultiSheetCellReferencesCollection', Base.$, [IExcelCalcReferenceCollectionEx_$type]);
/**
 * @hidden
 */
export class MultiSheetExternalCellCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a7 = new WorksheetCellAddress();
    this._a5 = null;
    this._a6 = null;
    this._a2 = null;
    this._a5 = a;
    this._a6 = b;
    this._a7 = c;
    let d = this._a5.e;
    let e = new Array(this._a6.l - this._a5.l + 1);
    for (let f = 0; f < e.length; f++) {
      let g = d.i(f + this._a5.l);
      e[f] = g.a(this._a7).value.toArrayProxy();
    }
    this._a2 = new ExcelCalcValue(e);
  }
  get__ao() {
    return this._a7.m;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a3.e == c._q.e && this._a3.l <= c._q.l && c._q.l <= this._a4.l && WorksheetCellAddress.f(this._a7, c._a4);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a3.e == d._q.e && this._a3.l <= d._q.l && d._q.l <= this._a4.l && d._a5._g(this._a7);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a5.e == e._a3.e && e._a3.l <= this._a6.l && this._a5.l <= e._a4.l && WorksheetCellAddress.f(this._a7, e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a5.e == f._a3.e && f._a3.l <= this._a6.l && this._a5.l <= f._a4.l && f._a8._g(this._a7);
    }
    return false;
  }
  get_elementName() {
    return ExcelUtils.d6(this._a5.e.x, this._a5.s, this._a6.s) + this._a7.p(false, false, this._t.currentFormat, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(MultiSheetExternalCellCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a5 == b._a5 && this._a6 == b._a6 && WorksheetCellAddress.f(this._a7, b._a7);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a5) ^ Base.getHashCodeStatic(this._a6) << 1 ^ this._a7.getHashCode() << 2;
  }
  isSubsetReference(a) {
    return this.containsReference(a);
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
  get__as() {
    return this._a7.o;
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
  get__q() {
    return this._a5;
  }
  get__t() {
    return this._a5.e.l;
  }
  get _a8() {
    return this._a7;
  }
  get _a3() {
    return this._a5;
  }
  get _a4() {
    return this._a6;
  }
}
MultiSheetExternalCellCalcReference.$t = markType(MultiSheetExternalCellCalcReference, 'MultiSheetExternalCellCalcReference', RefBase.$);
/**
 * @hidden
 */
export class MultiSheetExternalRegionCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a7 = new WorksheetRegionAddress();
    this._a5 = null;
    this._a6 = null;
    this._a2 = null;
    this._a5 = a;
    this._a6 = b;
    this._a7 = c;
    let d = this._a5.e;
    let e = new Array(this._a6.l - this._a5.l + 1);
    for (let f = 0; f < e.length; f++) {
      let g = d.i(f + this._a5.l);
      let h = g.b(this._a7);
      e[f] = h.value.toArrayProxy();
    }
    this._a2 = new ExcelCalcValue(e);
  }
  get__ao() {
    return this._a7._w;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a3.e == c._q.e && this._a3.l <= c._q.l && c._q.l <= this._a4.l && this._a7._g(c._a4);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a3.e == d._q.e && this._a3.l <= d._q.l && d._q.l <= this._a4.l && this._a7._j(d._a5);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a5.e == e._a3.e && e._a3.l <= this._a6.l && this._a5.l <= e._a4.l && this._a7._g(e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a5.e == f._a3.e && f._a3.l <= this._a6.l && this._a5.l <= f._a4.l && this._a7._j(f._a8);
    }
    return false;
  }
  get_elementName() {
    return ExcelUtils.d6(this._a5.e.x, this._a5.s, this._a6.s) + this._a7._ah(false, false, this._t.currentFormat, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(MultiSheetExternalRegionCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a5 == b._a5 && this._a6 == b._a6 && WorksheetRegionAddress._o(this._a7, b._a7);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a5) ^ Base.getHashCodeStatic(this._a6) << 1 ^ this._a7.getHashCode() << 2;
  }
  isSubsetReference(a) {
    let b = ExcelCalcEngine.b(a);
    let c = typeCast(ExternalCellCalcReference.$, b);
    if (c != null) {
      return this._a3.e == c._q.e && this._a3.l <= c._q.l && c._q.l <= this._a4.l && this._a7._g(c._a4);
    }
    let d = typeCast(ExternalRegionCalcReference.$, b);
    if (d != null) {
      return this._a3.e == d._q.e && this._a3.l <= d._q.l && d._q.l <= this._a4.l && this._a7._h(d._a5);
    }
    let e = typeCast(MultiSheetExternalCellCalcReference.$, b);
    if (e != null) {
      return this._a5.e == e._a3.e && e._a3.l <= this._a6.l && this._a5.l <= e._a4.l && this._a7._g(e._a8);
    }
    let f = typeCast(MultiSheetExternalRegionCalcReference.$, b);
    if (f != null) {
      return this._a5.e == f._a3.e && f._a3.l <= this._a6.l && this._a5.l <= f._a4.l && this._a7._h(f._a8);
    }
    return false;
  }
  get__w() {
    return null;
  }
  get _w() {
    return this.get__w();
  }
  get__as() {
    return this._a7._ac;
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
  get__t() {
    return this._a5.e.l;
  }
  get__q() {
    return this._a5;
  }
  get _a8() {
    return this._a7;
  }
  get _a3() {
    return this._a5;
  }
  get _a4() {
    return this._a6;
  }
}
MultiSheetExternalRegionCalcReference.$t = markType(MultiSheetExternalRegionCalcReference, 'MultiSheetExternalRegionCalcReference', RefBase.$);
/**
 * @hidden
 */
export class MultiSheetRegionCalcReference extends RefBase {
  constructor(a, b, c) {
    super();
    this._a4 = null;
    this._a5 = null;
    this._a3 = null;
    this._a6 = new WorksheetRegionAddress();
    this._a7 = null;
    this._a2 = null;
    this._a4 = a;
    this._a5 = b;
    this._a6 = c;
    let d = this._a4.workbook._worksheets$i;
    let e = this._a5.index - this._a4.index + 1;
    this._a7 = new List$1(WorksheetRegion.$, 2, e);
    let f = new Array(e);
    for (let g = this._a4.index, h = 0; g <= this._a5.index; g++ , h++) {
      let i = d._item(g)._cw(c);
      this._a7.add(i);
      f[h] = new RegionCalcReference_RegionArrayProxy(i);
    }
    this._a2 = new ExcelCalcValue(f);
    this._a3 = new MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection(this);
  }
  get__ao() {
    return this._a6._w;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = CalcUtilities.l(a);
    for (let c = 0; c < b.count; c++) {
      let d = b.item(c);
      if (d.worksheet.index < this._a4.index || this._a5.index < d.worksheet.index) {
        continue;
      }
      if (d._h._j(this._a6)) {
        return true;
      }
    }
    return false;
  }
  get_context() {
    return this._a7;
  }
  get_elementName() {
    return ExcelUtils.d6(null, this._a4.name, this._a5.name) + this._a6._ah(false, false, this._a4._o, 1);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(MultiSheetRegionCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a4 == b._a4 && this._a5 == b._a5 && this._a7 == b._a7;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._a4) ^ Base.getHashCodeStatic(this._a5) << 1 ^ Base.getHashCodeStatic(this._a7) << 2;
  }
  _am() {
    return this._a7;
  }
  get_isEnumerable() {
    return true;
  }
  isSubsetReference(a) {
    let b = CalcUtilities.l(a);
    for (let c = 0; c < b.count; c++) {
      let d = b.item(c);
      if (d.worksheet.index < this._a4.index || this._a5.index < d.worksheet.index) {
        return false;
      }
      if (d._h._h(this._a6) == false) {
        return false;
      }
    }
    return true;
  }
  get__references() {
    return this._a3;
  }
  get__w() {
    return this._a4._rows$i.item(this._a6._ac);
  }
  get _w() {
    return this.get__w();
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
}
MultiSheetRegionCalcReference.$t = markType(MultiSheetRegionCalcReference, 'MultiSheetRegionCalcReference', RefBase.$);
/**
 * @hidden
 */
export class MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  *_getEnumerator() {
    for (let a of fromEnum(this._a._a7)) {
      yield a._c;
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return getEnumerator(this);
  }
}
MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection.$t = markType(MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection, 'MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection', Base.$, [IExcelCalcReferenceCollectionEx_$type]);
/**
 * @hidden
 */
export class RegionArrayProxyBase extends ArrayProxy {
  constructor() {
    super();
    this._o = null;
  }
  get__g() {
    return true;
  }
  get _g() {
    return this.get__g();
  }
  get__h() {
    return true;
  }
  *__j(a, b) {
    let c = this._r;
    if (c == null) {
      return undefined;
    }
    if (c.worksheet == null) {
      yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, 0, new ExcelCalcValue(ErrorValue.invalidCellReference._a()));
      return undefined;
    }
    let d = c._v;
    let e = c.firstRow;
    let f = c._w;
    let g = c.lastRow;
    switch (a) {
      case 0:
        {
          let h = (d + b);
          for (let i of fromEnum(c.worksheet._rows$i._m(e, g))) {
            let j = RegionArrayProxyBase._q(i, h);
            if (j != null) {
              let k = this._p(j);
              yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, i.index - e, k);
              ExcelCalcNumberStack._ad(k);
            }
          }
        }
        break;
      case 1:
        {
          let l = e + b;
          let m = c.worksheet._rows$i._aj(l);
          if (m == null) {
            return undefined;
          }
          for (let n = d; n <= f; n++) {
            let o = RegionArrayProxyBase._q(m, n);
            if (o != null) {
              let p = this._p(o);
              yield new KeyValuePair$2(Number_$type, ExcelCalcValue.$, 1, n - d, p);
              ExcelCalcNumberStack._ad(p);
            }
          }
        }
        break;
      default:
        this._n();
        break;
    }
  }
  _j(a, b) {
    return toEnum(() => this.__j(a, b));
  }
  getLength(a) {
    let b = this._r;
    if (b == null) {
      return 0;
    }
    switch (a) {
      case 0: return b._ad;
      case 1: return b._aa;
      default:
        this._n();
        return -1;
    }
  }
  _c(a) {
    let b = this._r;
    if (b == null || b.worksheet == null) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(0));
    }
    if (a.b < 0) {
      this._n();
    }
    if (a.c < 0) {
      this._n();
    }
    let c = (b._v + a.b);
    let d = b.firstRow + a.c;
    if (b._w < c) {
      this._n();
    }
    if (b.lastRow < d) {
      this._n();
    }
    let e = a.a;
    if (e == null || e.index != d) {
      e = b.worksheet._rows$i.item(d);
    }
    return ExcelCalcNumberStack._c(e._as(c));
  }
  _m(a, b) {
    if (a) {
      super._m(a, b);
      return;
    }
    let c = this._r;
    let d = c.firstRow;
    let e = c.firstColumn;
    for (let f of fromEnum(c.worksheet._rows$i._m(d, c.lastRow))) {
      let g = f.index - d;
      let h = c._v;
      if (h == c.lastColumn) {
        if (f._bt(h)) {
          let i = f._as(h);
          let j = this._p(i);
          b(j, new ArrayValueContext(2, f, h - e, g));
          ExcelCalcNumberStack._ad(j);
        }
        continue;
      }
      for (let k of fromEnum(f._ch(h, c.lastColumn, true))) {
        let l = f._as(k.r);
        let m = this._p(l);
        b(m, new ArrayValueContext(2, f, k.r - e, g));
        ExcelCalcNumberStack._ad(m);
      }
    }
  }
  _a() {
    if (this._o == null) {
      this._o = CalcUtilities.a(this._r);
    }
    return this._o;
  }
  static _q(a, b) {
    return a._at(b, true);
  }
  _p(a) {
    let b = ExcelCalcNumberStack._c(a);
    this._l(b);
    return b;
  }
}
RegionArrayProxyBase.$t = markType(RegionArrayProxyBase, 'RegionArrayProxyBase', ArrayProxy.$);
/**
 * @hidden
 */
export class RegionCalcReference extends RegionCalcReferenceBase {
  constructor(a) {
    super();
    this._a8 = 0;
    this._a7 = null;
    this._a7 = new RegionCalcReference_RegionArrayProxy(a);
    this._a8 = a.getHashCode();
  }
  _a4(a, b) {
    return this._a3._h.containsColumns(a, b);
  }
  get_elementName() {
    return this._a7._r._toString1(1, true);
  }
  get elementName() {
    return this.get_elementName();
  }
  _a5(a, b) {
    return this._a3._h.intersectsWithColumns(a, b);
  }
  _z(a) {
    let b = typeCast(RegionCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._a3 == b._a3;
  }
  getHashCode() {
    return this._a8;
  }
  get__c() {
    return new ExcelCalcValue(this._a7);
  }
  get _c() {
    return this.get__c();
  }
  get__a3() {
    return this._a7._r;
  }
  get _a3() {
    return this.get__a3();
  }
}
RegionCalcReference.$t = markType(RegionCalcReference, 'RegionCalcReference', RegionCalcReferenceBase.$);
/**
 * @hidden
 */
export class RegionCalcReference_RegionArrayProxy extends RegionArrayProxyBase {
  constructor(a) {
    super();
    this._s = null;
    this._s = a;
  }
  get__r() {
    return this._s;
  }
  get _r() {
    return this.get__r();
  }
}
RegionCalcReference_RegionArrayProxy.$t = markType(RegionCalcReference_RegionArrayProxy, 'RegionCalcReference_RegionArrayProxy', RegionArrayProxyBase.$);
/**
 * @hidden
 */
export class RegionCalcReferenceBase_RegionReferencesCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  getEnumeratorObject() {
    return this.getEnumerator();
  }
  *_getEnumerator() {
    let a = this._b;
    if (a == null || a.worksheet == null) {
      yield ExcelReferenceError._a2;
      return undefined;
    }
    let b = a._v;
    let c = a._w;
    for (let d of fromEnum(a.worksheet._rows$i._m(a.firstRow, a.lastRow))) {
      for (let e = b; e <= c; e++) {
        let f = d._at(e, true);
        if (f == null) {
          continue;
        }
        f._e = this._a._e;
        yield f;
      }
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  get _b() {
    return this._a._a3;
  }
}
RegionCalcReferenceBase_RegionReferencesCollection.$t = markType(RegionCalcReferenceBase_RegionReferencesCollection, 'RegionCalcReferenceBase_RegionReferencesCollection', Base.$, [IExcelCalcReferenceCollectionEx_$type]);
/**
 * @hidden
 */
export class RegionGroupCalcReference extends RefBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super();
          this._bb = null;
          this._a8 = null;
          this._a2 = null;
          this._a9 = null;
          this._bb = c.e();
          this._bc(d);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c.worksheet._cx(c.index, d, c.index, d)];
          {
            let g = e[0];
            super();
            this._bb = null;
            this._a8 = null;
            this._a2 = null;
            this._a9 = null;
            let h = new List$1(WorksheetRegion.$, 0);
            h.add(g);
            this._bb = h.e();
            this._bc(g);
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          super();
          this._bb = null;
          this._a8 = null;
          this._a2 = null;
          this._a9 = null;
          let d = new List$1(WorksheetRegion.$, 0);
          d.add(c);
          this._bb = d.e();
          this._bc(c);
        }
        break;
    }
  }
  _bc(a) {
    let b = new Array(this._bb.count);
    for (let c = 0; c < this._bb.count; c++) {
      b[c] = new RegionCalcReference_RegionArrayProxy(this._bb.item(c));
    }
    this._a2 = new ExcelCalcValue(b);
    this._a9 = a;
  }
  get__ao() {
    if (this._bb.count == 0) {
      return -1;
    }
    return this._bb.item(0)._v;
  }
  get _ao() {
    return this.get__ao();
  }
  containsReference(a) {
    let b = CalcUtilities.l(a);
    for (let c of fromEnum(b)) {
      for (let d of fromEnum(this._bb)) {
        if (d._s(c)) {
          return true;
        }
      }
    }
    return false;
  }
  get_context() {
    return this._bb;
  }
  get_elementName() {
    let a = new StringBuilder(0);
    for (let b of fromEnum(this._bb)) {
      a.l(b._toString1(1, true));
      a.l(",");
    }
    if (a.c >= 1) {
      a.y(a.c - 1, 1);
    }
    return a.toString();
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(RegionGroupCalcReference.$, a);
    if (b == null) {
      return false;
    }
    if (this._bb.count != b._bb.count) {
      return false;
    }
    for (let c = 0; c < this._bb.count; c++) {
      if (this._bb.item(0).equals(b._bb.item(0)) == false) {
        return false;
      }
    }
    return true;
  }
  getHashCode() {
    switch (this._bb.count) {
      case 0: return 0;
      case 1: return this._bb.item(0).getHashCode();
      default: return this._bb.count ^ this._bb.item(0).getHashCode() ^ (this._bb.item(this._bb.count - 1).getHashCode() << 8);
    }
  }
  _v() {
    return this._a9;
  }
  _am() {
    return this._bb;
  }
  get_isEnumerable() {
    return true;
  }
  isSubsetReference(a) {
    let b = CalcUtilities.l(a);
    if (b.count == 0) {
      return false;
    }
    for (let c of fromEnum(b)) {
      let d = false;
      for (let e of fromEnum(this._bb)) {
        if (e._o(c)) {
          d = true;
          break;
        }
      }
      if (d == false) {
        return false;
      }
    }
    return true;
  }
  get__references() {
    if (this._a8 == null) {
      this._a8 = new RegionGroupCalcReference_GeneralReferencesCollection(this);
    }
    return this._a8;
  }
  _n(a, b) {
    if (this._bb.count != 1) {
      b = new ExcelCalcErrorValue(1);
      return {
        ret: null,
        p1: b
      };
    }
    return {
      ret: ((() => { let c = CalcUtilities.g(a, this._bb.item(0), b); b = c.p2; return c.ret; })()),
      p1: b
    };
  }
  get__w() {
    if (this._bb.count == 0) {
      return null;
    }
    let a = this._bb.item(0);
    return a._k;
  }
  get _w() {
    return this.get__w();
  }
  get__c() {
    return this._a2;
  }
  get _c() {
    return this.get__c();
  }
  static _a7(a) {
    a = ExcelCalcEngine.b(a);
    let b = typeCast(RegionGroupCalcReference.$, a);
    if (b != null) {
      return b;
    }
    let c = typeCast(CellCalcReference.$, a);
    if (c != null) {
      return new RegionGroupCalcReference(1, c._w, c._ao);
    }
    let d = typeCast(RegionCalcReferenceBase.$, a);
    if (d != null) {
      let e = d._a3;
      if (e != null) {
        return new RegionGroupCalcReference(2, e);
      }
    }
    return null;
  }
  static _a3(a, b) {
    let c = a._u;
    if (c == null || c != b._u) {
      return a;
    }
    let d = new List$1(WorksheetRegion.$, 0);
    let e = a._v();
    let f = b._v();
    let g = null;
    for (let h of fromEnum(a._bb)) {
      if (h.worksheet == null) {
        return ExcelReferenceError._a2;
      }
      for (let i of fromEnum(b._bb)) {
        if (i.worksheet == null) {
          return ExcelReferenceError._a2;
        }
        if (h.firstRow < i.firstRow && h.lastRow < i.firstRow) {
          continue;
        }
        if (i.lastRow < h.firstRow && i.lastRow < h.lastRow) {
          continue;
        }
        if (h.firstColumn < i.firstColumn && h.lastColumn < i.firstColumn) {
          continue;
        }
        if (i.lastColumn < h.firstColumn && i.lastColumn < h.lastColumn) {
          continue;
        }
        d.add(h.worksheet._cx(Math.max(h.firstRow, i.firstRow), Math.max(h.firstColumn, i.firstColumn), Math.min(h.lastRow, i.lastRow), Math.min(h.lastColumn, i.lastColumn)));
        if (g == null && h == e && i == f) {
          g = d._inner[d.count - 1];
        }
      }
    }
    d.z(WorksheetRegion_HorizontalSorter._a);
    if (g == null && d.count > 0) {
      g = d._inner[d.count - 1];
    }
    return new RegionGroupCalcReference(0, d, g)._a5();
  }
  static _a4(a, b) {
    let c = a._u;
    if (c == null || c != b._u) {
      return a;
    }
    for (let d = 0; d < a._bb.count; d++) {
      if (a._bb.item(d).worksheet == null) {
        return ExcelReferenceError._a2;
      }
    }
    for (let e = 0; e < b._bb.count; e++) {
      if (b._bb.item(e).worksheet == null) {
        return ExcelReferenceError._a2;
      }
    }
    let f = new List$1(WorksheetRegion.$, 1, a._bb);
    f.z(WorksheetRegion_VerticalSorter._a);
    let g = new List$1(WorksheetRegion.$, 1, b._bb);
    g.z(WorksheetRegion_VerticalSorter._a);
    let h = f._inner[0].firstRow;
    let i = g._inner[0].firstRow;
    let j = a._bb.item(0).firstColumn;
    let k = b._bb.item(0).firstColumn;
    let l = f._inner[f.count - 1].lastRow;
    let m = g._inner[g.count - 1].lastRow;
    let n = a._bb.item(a._bb.count - 1).lastColumn;
    let o = b._bb.item(b._bb.count - 1).lastColumn;
    let p = a._bb.item(0).worksheet._cx(Math.min(h, i), Math.min(j, k), Math.max(l, m), Math.max(n, o));
    return p._c;
  }
  static _a6(a, b) {
    let c = a._u;
    if (c == null || c != b._u) {
      return a;
    }
    let d = new List$1(WorksheetRegion.$, 0);
    d.o(a._bb);
    d.o(b._bb);
    d.z(WorksheetRegion_HorizontalSorter._a);
    return new RegionGroupCalcReference(0, d, a._v())._a5();
  }
  _a5() {
    if (this._bb.count == 0) {
      return null;
    }
    if (this._bb.count != 1) {
      return this;
    }
    return this._bb.item(0)._c;
  }
  get _ba() {
    return this._bb;
  }
}
RegionGroupCalcReference.$t = markType(RegionGroupCalcReference, 'RegionGroupCalcReference', RefBase.$);
/**
 * @hidden
 */
export class RegionGroupCalcReference_GeneralReferencesCollection extends Base {
  constructor(a) {
    super();
    this._a = null;
    this._a = a;
  }
  *_getEnumerator() {
    for (let a = 0; a < this._a._bb.count; a++) {
      if (this._a._bb.item(a).worksheet == null) {
        yield ExcelReferenceError._a2;
        return undefined;
      }
    }
    for (let b = 0; b < this._a._bb.count; b++) {
      let c = this._a._bb.item(b);
      for (let d of fromEnum(c.worksheet._rows$i._m(c.firstRow, c.lastRow))) {
        for (let e = c._v; e <= c._w; e++) {
          let f = d._at(e, true);
          if (f == null) {
            continue;
          }
          f._e = this._a._e;
          yield f;
        }
      }
    }
  }
  getEnumerator() {
    return toEnum(() => this._getEnumerator()).getEnumerator();
  }
  getEnumeratorObject() {
    return getEnumerator(this);
  }
}
RegionGroupCalcReference_GeneralReferencesCollection.$t = markType(RegionGroupCalcReference_GeneralReferencesCollection, 'RegionGroupCalcReference_GeneralReferencesCollection', Base.$, [IExcelCalcReferenceCollectionEx_$type]);
/**
 * @hidden
 */
export class TableCalcReferenceBase extends RegionCalcReferenceBase {
  constructor(a, b, c) {
    super();
    this._be = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    this._bf = Nullable$1.toNullable(StructuredTableReferenceKeywordType_$type, null);
    this._bb = null;
    this._a7 = null;
    this._be = b;
    this._bf = c;
    this._bb = a;
    this._a7 = new ExcelCalcValue(new TableCalcReferenceBase_TableReferenceArrayProxy(this));
  }
  _m(a, b, c) {
    let d = ((() => { let e = CalculationContext.b(a); a = e.p0; return e.ret; })());
    if (d != null && nullableEquals(this._be, 4)) {
      let e = typeCast(CellCalcReference.$, d);
      if (e != null && e._w != this._bb) {
        let f = this._a8(e._w);
        let g = f._m(a, b, c);
        a = g.p0;
        c = g.p2;
        return {
          ret: f,
          p0: a,
          p2: c
        };
      }
    }
    return {
      ret: ((() => { let h = super._m(a, b, c); a = h.p0; c = h.p2; return h.ret; })()),
      p0: a,
      p2: c
    };
  }
  get__t() {
    let a = this._bc;
    if (a == null) {
      return null;
    }
    return a._k;
  }
  get__c() {
    return this._a7;
  }
  get _c() {
    return this.get__c();
  }
  _a9(a, b) {
    let t1 = b;
    L0: while (true) {
      switch (t1) {
        case 0: return a.wholeTableRegion;
        case 1: return a.dataAreaRegion;
        case 2: return a.headerRowRegion;
        case 3: return a.totalsRowRegion;
        case 4:
          {
            if (this._bb == null) {
              return null;
            }
            let c = a.dataAreaRegion;
            if (c == null) {
              return null;
            }
            if (c.worksheet == null) {
              return null;
            }
            if (this._bb.index < c.firstRow || c.lastRow < this._bb.index) {
              return null;
            }
            return c.worksheet._cx(this._bb.index, c.firstColumn, this._bb.index, c.lastColumn);
          }
        default:
          t1 = 1;
          continue L0;
      }
      break;
    }
  }
  _bd(a) {
    if (nullableNotEquals(this._be, a._be) || nullableNotEquals(this._bf, a._bf)) {
      return false;
    }
    if (nullableEquals(this._be, 4)) {
      if (this._bb != a._bb) {
        return false;
      }
    }
    return true;
  }
  get _bg() {
    return this._be;
  }
  get _bh() {
    return this._bf;
  }
  get _ba() {
    let a = this._bc;
    if (a == null) {
      return null;
    }
    if (this._bg.hasValue == false) {
      return a.dataAreaRegion;
    }
    let b = this._a9(a, this._bg.value);
    if (this._bh.hasValue == false) {
      return b;
    }
    let c = this._a9(a, this._bh.value);
    return WorksheetRegion._g(b, c);
  }
}
TableCalcReferenceBase.$t = markType(TableCalcReferenceBase, 'TableCalcReferenceBase', RegionCalcReferenceBase.$);
/**
 * @hidden
 */
export class TableCalcReference extends TableCalcReferenceBase {
  constructor(a, b, c, d) {
    super(a, c, d);
    this._bi = null;
    this._bi = b;
  }
  _a8(a) {
    return new TableCalcReference(a, this._bi, this._bg, this._bh);
  }
  _a4(a, b) {
    return this._bi._cg(a, b);
  }
  get_elementName() {
    if (this._bg.hasValue == false) {
      return this._bi.name;
    }
    let a = FormulaParser.cx(this._bg.value);
    if (this._bh.hasValue == false) {
      return stringFormat("{0}[{1}]", this._bi.name, a);
    }
    let b = FormulaParser.cx(this._bh.value);
    return stringFormat("{0}[[{1}],[{2}]]", this._bi.name, a, b);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(TableCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._bi == b._bi && this._bd(b);
  }
  _a5(a, b) {
    return this._bi._cn(a, b);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._bi) ^ Base.getHashCodeStatic(this._bg) ^ Base.getHashCodeStatic(this._bh);
  }
  get__a3() {
    return this._ba;
  }
  get _a3() {
    return this.get__a3();
  }
  get__bc() {
    return this._bi;
  }
  get _bc() {
    return this.get__bc();
  }
}
TableCalcReference.$t = markType(TableCalcReference, 'TableCalcReference', TableCalcReferenceBase.$);
/**
 * @hidden
 */
export class TableCalcReferenceBase_TableReferenceArrayProxy extends RegionArrayProxyBase {
  constructor(a) {
    super();
    this._s = null;
    this._s = a;
  }
  get__r() {
    return this._s._a3;
  }
  get _r() {
    return this.get__r();
  }
}
TableCalcReferenceBase_TableReferenceArrayProxy.$t = markType(TableCalcReferenceBase_TableReferenceArrayProxy, 'TableCalcReferenceBase_TableReferenceArrayProxy', RegionArrayProxyBase.$);
/**
 * @hidden
 */
export class TableColumnCalcReference extends TableCalcReferenceBase {
  constructor(a, b, c, d) {
    super(a, c, d);
    this._bi = null;
    this._bi = b;
  }
  _a8(a) {
    return new TableColumnCalcReference(a, this._bi, this._bg, this._bh);
  }
  _a4(a, b) {
    return a >= this._bi._at && b <= this._bi._at;
  }
  get_elementName() {
    let a = this._bc;
    if (a == null) {
      return ExcelReferenceError._a2.elementName;
    }
    if (this._bg.hasValue == false) {
      return stringFormat("{0}[{1}]", a.name, this._bi.name);
    }
    let b = FormulaParser.cx(this._bg.value);
    if (this._bh.hasValue == false) {
      return stringFormat("{0}[[{1}],[{2}]]", a.name, b, this._bi.name);
    }
    let c = FormulaParser.cx(this._bh.value);
    return stringFormat1("{0}[[{1}],[{2}],[{3}]]", a.name, b, c, this._bi.name);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(TableColumnCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._bi == b._bi && this._bd(b);
  }
  _a5(a, b) {
    if (b < this._bi._at || this._bi._at < a) {
      return false;
    }
    return true;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._bi) ^ Base.getHashCodeStatic(this._bg) ^ Base.getHashCodeStatic(this._bh);
  }
  get__a3() {
    let a = this._ba;
    if (a == null) {
      return null;
    }
    return this._bi._ah(a);
  }
  get _a3() {
    return this.get__a3();
  }
  get__bc() {
    return this._bi.table;
  }
  get _bc() {
    return this.get__bc();
  }
}
TableColumnCalcReference.$t = markType(TableColumnCalcReference, 'TableColumnCalcReference', TableCalcReferenceBase.$);
/**
 * @hidden
 */
export class TableColumnRangeCalcReference extends TableCalcReferenceBase {
  constructor(a, b, c, d, e) {
    super(a, d, e);
    this._bi = null;
    this._bj = null;
    this._bi = b;
    this._bj = c;
  }
  _a8(a) {
    return new TableColumnRangeCalcReference(a, this._bi, this._bj, this._bg, this._bh);
  }
  _a4(a, b) {
    return a >= this._bi._at && b <= this._bj._at;
  }
  get_elementName() {
    let a = this._bc;
    if (a == null) {
      return ExcelReferenceError._a2.elementName;
    }
    if (this._bg.hasValue == false) {
      return stringFormat("{0}[[{1}]:[{2}]]", a.name, this._bi.name, this._bj.name);
    }
    let b = FormulaParser.cx(this._bg.value);
    if (this._bh.hasValue == false) {
      return stringFormat1("{0}[[{1}],[{2}]:[{3}]]", a.name, b, this._bi.name, this._bj.name);
    }
    let c = FormulaParser.cx(this._bh.value);
    return stringFormat1("{0}[[{1}],[{2}],[{3}]:[{4}]]", a.name, b, c, this._bi.name, this._bj.name);
  }
  get elementName() {
    return this.get_elementName();
  }
  _z(a) {
    let b = typeCast(TableColumnRangeCalcReference.$, a);
    if (b == null) {
      return false;
    }
    return this._bi == b._bi && this._bj == b._bj && this._bd(b);
  }
  getHashCode() {
    return Base.getHashCodeStatic(this._bi) ^ Base.getHashCodeStatic(this._bj) ^ Base.getHashCodeStatic(this._bg) ^ Base.getHashCodeStatic(this._bh);
  }
  _a5(a, b) {
    if (b < this._bi._at || this._bj._at < a) {
      return false;
    }
    return true;
  }
  get__a3() {
    let a = this._ba;
    if (a == null) {
      return null;
    }
    let b = this._bi._ah(a);
    let c = this._bj._ah(a);
    return WorksheetRegion._g(b, c);
  }
  get _a3() {
    return this.get__a3();
  }
  get__bc() {
    return this._bj.table;
  }
  get _bc() {
    return this.get__bc();
  }
}
TableColumnRangeCalcReference.$t = markType(TableColumnRangeCalcReference, 'TableColumnRangeCalcReference', TableCalcReferenceBase.$);
/**
 * Abstract base class for all filter types which filter data based on a dynamic condition, such as the data present in the filtered
 * data range, the date when the filter was applied, or the date when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 */
export class DynamicValuesFilter extends Filter {
  constructor(a) {
    super(a);
  }
  /**
   * @hidden
   */
  static _l(a, b, c, d, e) {
    let f = DynamicValuesFilter._o(a, e);
    if (c == 1 || c == 2) {
      return DynamicValuesFilter._k(b, c, d, Nullable$1.toNullable(Date_$type, null), f);
    }
    else {
      return DynamicValuesFilter._k(b, c, Nullable$1.toNullable(Number_$type, null), DynamicValuesFilter._o(a, d), f);
    }
  }
  /**
   * @hidden
   */
  static _k(a, b, c, d, e) {
    if (b == 0) {
      return null;
    }
    switch (b) {
      case 24:
      case 25:
      case 26:
      case 27: return new DatePeriodFilter(a, 1, (b - 24 + 1));
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39: return new DatePeriodFilter(a, 0, (b - 28 + 1));
    }
    if (b == 1 || b == 2) {
      let f = b == 1 ? 0 : 1;
      if (c.hasValue) {
        return new AverageFilter(1, a, f, c.value);
      }
      else {
        return new AverageFilter(0, a, f);
      }
    }
    if (b == 23) {
      if (nullableNotEquals(d, null) && nullableNotEquals(e, null)) {
        return new YearToDateFilter(1, a, d.value, e.value);
      }
      else {
        return new YearToDateFilter(0, a);
      }
    }
    let g;
    let h;
    switch (b) {
      case 8:
        g = 2;
        h = 0;
        break;
      case 9:
        g = 1;
        h = 0;
        break;
      case 10:
        g = 0;
        h = 0;
        break;
      case 11:
        g = 2;
        h = 1;
        break;
      case 12:
        g = 1;
        h = 1;
        break;
      case 13:
        g = 0;
        h = 1;
        break;
      case 14:
        g = 2;
        h = 2;
        break;
      case 15:
        g = 1;
        h = 2;
        break;
      case 16:
        g = 0;
        h = 2;
        break;
      case 17:
        g = 2;
        h = 3;
        break;
      case 18:
        g = 1;
        h = 3;
        break;
      case 19:
        g = 0;
        h = 3;
        break;
      case 20:
        g = 2;
        h = 4;
        break;
      case 21:
        g = 1;
        h = 4;
        break;
      case 22:
        g = 0;
        h = 4;
        break;
      default: return null;
    }
    if (nullableNotEquals(d, null) && nullableNotEquals(e, null)) {
      return new RelativeDateRangeFilter(1, a, g, h, d.value, e.value);
    }
    return new RelativeDateRangeFilter(0, a, g, h);
  }
  /**
   * @hidden
   */
  static _o(a, b) {
    if (nullableEquals(b, null)) {
      return Nullable$1.toNullable(Date_$type, null);
    }
    return ExcelCalcValue._excelDateToDateTime(a._b, b.value);
  }
  /**
   * @hidden
   */
  get _n() {
    return this._m;
  }
}
DynamicValuesFilter.$t = markType(DynamicValuesFilter, 'DynamicValuesFilter', Filter.$);
/**
 * Represents a filter which can filter data based on whether the data is below or above the average of the entire data range.
 * @see [[WorksheetTableColumn.filter]]
 */
export class AverageFilter extends DynamicValuesFilter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c);
          this._u = 0;
          this._s = 0;
          ExcelUtils.gl(AverageFilterType_$type, d);
          this._s = d;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = [c, d];
          {
            let h = f[0];
            let i = f[1];
            super(h);
            this._u = 0;
            this._s = 0;
            ExcelUtils.gl(AverageFilterType_$type, i);
            this._s = i;
          }
          this._u = e;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(AverageFilter.$, a);
    if (b == null) {
      return false;
    }
    return this._u == b._u && this._s == b._s;
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = WorksheetRow._c2(b, d);
    let f;
    if (((() => { let g = ExcelUtils.b0(a.workbook, e, f); f = g.p2; return g.ret; })())) {
      switch (this.type) {
        case 0: return this._u < f;
        case 1: return f < this._u;
        default: break;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _f(a, b, c, d) {
    let e = a.workbook;
    let f = 0;
    let g = 0;
    for (let h of fromEnum(a._rows$i._m(b, c))) {
      let i = h._c5(d);
      let j;
      if (((() => { let k = ExcelUtils.b0(e, i, j); j = k.p2; return k.ret; })())) {
        f += j;
        g++;
      }
      if (typeCast(ErrorValue.$, i) !== null) {
        this._u = 0;
        return true;
      }
    }
    if (g == 0) {
      this._u = 0;
      return true;
    }
    this._u = f / g;
    return true;
  }
  /**
   * @hidden
   */
  get__m() {
    switch (this.type) {
      case 0: return 1;
      case 1: return 2;
      default: return 0;
    }
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * Gets the average that was computed the last time the filter was applied or 0 if any errors or all non-numeric values
   * were found when applying the filter.
   */
  get average() {
    return this._u;
  }
  /**
   * Gets or sets the value indicating whether to filter in values below or above the average of the data range.
   * AboveAverage to show cells above the average of the data range; BelowAverage to show cells below the average.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[AverageFilterType]] enumeration.
   */
  get type() {
    return this._s;
  }
  /**
   * Gets or sets the value indicating whether to filter in values below or above the average of the data range.
   * AboveAverage to show cells above the average of the data range; BelowAverage to show cells below the average.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[AverageFilterType]] enumeration.
   */
  set type(a) {
    if (this.type == a) {
      return;
    }
    ExcelUtils.gl(AverageFilterType_$type, a);
    AverageFilter._p[0].h(AverageFilter.$, AverageFilterType_$type, this, a);
  }
  /**
   * @hidden
   */
  _y(a) {
    this._s = a;
    this._i();
  }
  /**
   * @hidden
   */
  static _r($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(AverageFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _q() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, AverageFilter._r(AverageFilterType_$type, "Type", (b) => b.type, (b, c) => b.type = c, (b, c) => b._y(c)));
    return a;
  }
}
AverageFilter.$t = markType(AverageFilter, 'AverageFilter', DynamicValuesFilter.$);
/**
 * @hidden
 */
AverageFilter._x = 0;
/**
 * @hidden
 */
AverageFilter._w = 1;
/**
 * @hidden
 */
AverageFilter._p = AverageFilter._q();
/**
 * A filter condition used in a [[CustomFilter]].
 * <p class="body">
 * The CustomFilterCondition contains a comparison operator and a value. The value of each cell in the data range is compared against
 * the condition value using the comparison operator.
 * </p>
 * @see [[CustomFilter.condition1]]
 * @see [[CustomFilter.condition2]]
 */
export class CustomFilterCondition extends Base {
  constructor(comparisonOperator, value) {
    super();
    this._b = 0;
    this._d = false;
    this._p = null;
    this._l = null;
    this._j = null;
    ExcelUtils.gl(ExcelComparisonOperator_$type, comparisonOperator);
    if (value == null) {
      throw new ArgumentNullException(0, "value");
    }
    if ((typeof value === 'string') == false && CustomFilterCondition._h(comparisonOperator)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidCustomFilterOperator"), "value");
    }
    this._b = comparisonOperator;
    this._j = value;
    this._l = WorksheetCellBlock.ah(value);
    this._l = this._l.trim();
    let a;
    this._p = ((() => { let b = ExcelUtils.ep(this._m(), a); a = b.p1; return b.ret; })());
    this._d = a;
  }
  /**
   * Determines whether the [[CustomFilterCondition]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(CustomFilterCondition.$, obj);
    if (a == null) {
      return false;
    }
    return this._b == a._b && Base.equalsStatic(this._j, a._j);
  }
  /**
   * Gets the hash code for the [[CustomFilterCondition]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return Base.getHashCodeStatic(this._b) ^ Base.getHashCodeStatic(this._j);
  }
  /**
   * @hidden
   */
  static _a(a, b) {
    let c = typeCast(String_$type, b);
    let d;
    let e;
    let f = c != null && stringStartsWith(c, "*");
    let g = c != null && stringEndsWith(c, "*");
    switch (a) {
      case 2:
        if (c == null || c.length == 1 || (f == false && g == false)) {
          e = b;
          d = 0;
        }
        else if (f) {
          if (g) {
            e = c.substr(1, c.length - 2);
            d = 10;
          }
          else {
            e = c.substr(1);
            d = 8;
          }
        }
        else {
          e = c.substr(0, c.length - 1);
          d = 6;
        }
        break;
      case 5:
        if (c == null || c.length == 1 || (f == false && g == false)) {
          e = b;
          d = 1;
        }
        else if (f) {
          if (g) {
            e = c.substr(1, c.length - 2);
            d = 11;
          }
          else {
            e = c.substr(1);
            d = 9;
          }
        }
        else {
          e = c.substr(0, c.length - 1);
          d = 7;
        }
        break;
      case 4:
        e = b;
        d = 2;
        break;
      case 6:
        e = b;
        d = 3;
        break;
      case 1:
        e = b;
        d = 4;
        break;
      case 3:
        e = b;
        d = 5;
        break;
      default: return null;
    }
    return new CustomFilterCondition(d, e);
  }
  /**
   * @hidden
   */
  _m() {
    let a = this._l;
    switch (this.comparisonOperator) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5: return a;
      case 6:
        if (stringEndsWith(a, "*") == false) {
          a += "*";
        }
        return a;
      case 7:
        if (stringEndsWith(a, "*") == false) {
          a += "*";
        }
        return a;
      case 8:
        if (stringStartsWith(a, "*") == false) {
          a = "*" + a;
        }
        return a;
      case 9:
        if (stringStartsWith(a, "*") == false) {
          a = "*" + a;
        }
        return a;
      case 10:
        if (stringStartsWith(a, "*") == false) {
          a = "*" + a;
        }
        if (stringEndsWith(a, "*") == false) {
          a += "*";
        }
        return a;
      case 11:
        if (stringStartsWith(a, "*") == false) {
          a = "*" + a;
        }
        if (stringEndsWith(a, "*") == false) {
          a += "*";
        }
        return a;
      default: return a;
    }
  }
  /**
   * @hidden
   */
  _q(a, b, c) {
    c = this.value;
    let d;
    if (((() => { let e = ExcelUtils.b0(a._b, c, d); d = e.p2; return e.ret; })())) {
      c = d;
    }
    let e = this._m();
    switch (this.comparisonOperator) {
      case 0:
        b = 2;
        break;
      case 1:
        b = 5;
        break;
      case 2:
        b = 4;
        break;
      case 3:
        b = 6;
        break;
      case 4:
        b = 1;
        break;
      case 5:
        b = 3;
        break;
      case 6:
      case 8:
      case 10:
        b = 2;
        c = e;
        break;
      case 7:
      case 9:
      case 11:
        b = 5;
        c = e;
        break;
      default:
        b = 2;
        c = e;
        break;
    }
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _g(a, b, c, d, e) {
    let f = WorksheetCellBlock.s(e);
    let g = Nullable$1.toNullable(Number_$type, null);
    let h;
    if (((() => { let i = ExcelUtils.b0(a.workbook, this.value, h); h = i.p2; return i.ret; })())) {
      g = Nullable$1.toNullable(Number_$type, h);
    }
    switch (this.comparisonOperator) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        {
          let i = Nullable$1.toNullable(Number_$type, null);
          if (g.hasValue) {
            if (f) {
              if (((() => { let j = MathUtilities.c(e.toString(), a._y, h); h = j.p2; return j.ret; })())) {
                i = Nullable$1.toNullable(Number_$type, h);
              }
            }
            else {
              if (((() => { let j = ExcelUtils.b0(a.workbook, e, h); h = j.p2; return j.ret; })())) {
                i = Nullable$1.toNullable(Number_$type, h);
              }
            }
          }
          if (i.hasValue == false || g.hasValue == false) {
            if (f == false || (typeof this.value === 'string') == false) {
              switch (this.comparisonOperator) {
                case 2:
                case 3:
                case 4:
                case 5: return false;
              }
            }
            let j = new GetCellTextParameters(d);
            j.b = 1;
            j.a = 0;
            let k = WorksheetCellBlock.a(a, b, c, j, e).g;
            k = k.trim();
            let l;
            if (this._d) {
              if (this.comparisonOperator == 0 || this.comparisonOperator == 1) {
                l = this._p.i(k).i ? 0 : 1;
              }
              else {
                return true;
              }
            }
            else {
              l = stringCompare1(k, this._l, StringUtilities.g);
            }
            switch (this.comparisonOperator) {
              case 0: return l == 0;
              case 1: return l != 0;
              case 2: return l > 0;
              case 3: return l >= 0;
              case 4: return l < 0;
              case 5: return l <= 0;
            }
          }
          else {
            if (f || (typeof this.value === 'string')) {
              switch (this.comparisonOperator) {
                case 2:
                case 3:
                case 4:
                case 5: return false;
              }
            }
            let m = MathUtilities.i(i.value);
            let n = MathUtilities.i(g.value);
            switch (this.comparisonOperator) {
              case 0: return m == n;
              case 1: return m != n;
              case 2: return m > n;
              case 3: return m >= n;
              case 4: return m < n;
              case 5: return m <= n;
            }
          }
          return false;
        }
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        {
          if (f == false) {
            return this.comparisonOperator == 7 || this.comparisonOperator == 11 || this.comparisonOperator == 9;
          }
          let o = new GetCellTextParameters(d);
          o.b = 1;
          o.a = 0;
          let p = WorksheetCellBlock.a(a, b, c, o, e).g;
          p = p.trim();
          let q = this._p.i(p).i;
          switch (this.comparisonOperator) {
            case 6:
            case 8:
            case 10: return q;
            case 7:
            case 9:
            case 11: return q == false;
          }
          return false;
        }
      default: return false;
    }
  }
  /**
   * @hidden
   */
  static _h(a) {
    switch (a) {
      case 6:
      case 7:
      case 10:
      case 11:
      case 8:
      case 9: return true;
    }
    return false;
  }
  /**
   * Gets the operator which describes how the cell values should be compared against [[value]].
   * @see [[value]]
   */
  get comparisonOperator() {
    return this._b;
  }
  /**
   * Gets the value against which the cell values should be compared.
   * @see [[comparisonOperator]]
   */
  get value() {
    return this._j;
  }
  /**
   * @hidden
   */
  get _f() {
    return this._d;
  }
}
CustomFilterCondition.$t = markType(CustomFilterCondition, 'CustomFilterCondition');
/**
 * @hidden
 */
CustomFilterCondition._n = "*";
/**
 * @hidden
 */
CustomFilterCondition._o = "?";
/**
 * Represents a filter which can filter data based on one or two custom conditions.
 * This filter type allows you to specify one or two filter conditions which have a comparison operator and value.
 * These two filter conditions can be combined with a logical and or a logical or operation.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[CustomFilterCondition]]
 */
export class CustomFilter extends Filter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c, d, null, 0];
          {
            let g = e[0];
            let h = e[1];
            let i = e[2];
            let j = e[3];
            super(g);
            this._p = null;
            this._q = null;
            this._n = 0;
            if (h == null) {
              throw new ArgumentNullException(0, "condition1");
            }
            ExcelUtils.gl(ConditionalOperator_$type, j);
            this._p = h;
            this._q = i;
            this._n = j;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          super(c);
          this._p = null;
          this._q = null;
          this._n = 0;
          if (d == null) {
            throw new ArgumentNullException(0, "condition1");
          }
          ExcelUtils.gl(ConditionalOperator_$type, f);
          this._p = d;
          this._q = e;
          this._n = f;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(CustomFilter.$, a);
    if (b == null) {
      return false;
    }
    return this._n == b._n && Base.equalsStatic(this._p, b._p) && Base.equalsStatic(this._q, b._q);
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = WorksheetRow._c2(b, d);
    let f = this.condition1._g(a, b, c, d, e);
    if (this.condition2 == null) {
      return f;
    }
    if (this.conditionalOperator == 0) {
      if (f == false) {
        return false;
      }
    }
    else {
      if (f) {
        return true;
      }
    }
    return this.condition2._g(a, b, c, d, e);
  }
  /**
   * @hidden
   */
  _g(a, b) {
    a = false;
    b = new List$1(String_$type, 0);
    let c = this._p._m();
    if (255 < c.length) {
      return {
        ret: false,
        p0: a,
        p1: b
      };
    }
    b.add(c);
    if (this._q != null) {
      c = this._q._m();
      if (255 < c.length) {
        return {
          ret: false,
          p0: a,
          p1: b
        };
      }
      b.add(c);
    }
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  /**
   * Gets or sets the first condition by which to filter the cells in the data range.
   * <p class="body">
   * The first filter condition is required. Setting Condition1 to null will cause an exception to be thrown.
   * </p>
   * <p class="body">
   * When both Condition1 and [[condition2]] are set, the [[conditionalOperator]] is used to determine
   * how the conditions should be logically combined.
   * </p>
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[condition2]]
   * @see [[conditionalOperator]]
   */
  get condition1() {
    return this._p;
  }
  /**
   * Gets or sets the first condition by which to filter the cells in the data range.
   * <p class="body">
   * The first filter condition is required. Setting Condition1 to null will cause an exception to be thrown.
   * </p>
   * <p class="body">
   * When both Condition1 and [[condition2]] are set, the [[conditionalOperator]] is used to determine
   * how the conditions should be logically combined.
   * </p>
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[condition2]]
   * @see [[conditionalOperator]]
   */
  set condition1(a) {
    if (this.condition1 == a) {
      return;
    }
    if (a == null) {
      throw new ArgumentNullException(0, "value");
    }
    CustomFilter._k[0].h(CustomFilter.$, CustomFilterCondition.$, this, a);
  }
  /**
   * @hidden
   */
  _x(a) {
    this._p = a;
    this._i();
  }
  /**
   * Gets or sets the second condition by which to filter the cells in the data range.
   * <p class="body">
   * The second filter condition is optional. A value of null indicates that only [[condition1]] should be used to
   * filter the data.
   * </p>
   * <p class="body">
   * When both Condition1 and Condition2 are set, the [[conditionalOperator]] is used to determine how the conditions
   * should be logically combined.
   * </p>
   * @see [[condition1]]
   * @see [[conditionalOperator]]
   */
  get condition2() {
    return this._q;
  }
  /**
   * Gets or sets the second condition by which to filter the cells in the data range.
   * <p class="body">
   * The second filter condition is optional. A value of null indicates that only [[condition1]] should be used to
   * filter the data.
   * </p>
   * <p class="body">
   * When both Condition1 and Condition2 are set, the [[conditionalOperator]] is used to determine how the conditions
   * should be logically combined.
   * </p>
   * @see [[condition1]]
   * @see [[conditionalOperator]]
   */
  set condition2(a) {
    if (this.condition2 == a) {
      return;
    }
    CustomFilter._k[1].h(CustomFilter.$, CustomFilterCondition.$, this, a);
  }
  /**
   * @hidden
   */
  _y(a) {
    this._q = a;
    this._i();
  }
  /**
   * Gets or sets the operator which defines how to logically combine [[condition1]] and [[condition2]]
   * <p class="body">
   * When both Condition1 and Condition2 are set, the ConditionalOperator is used to determine how the conditions should be logically
   * combined. If only Condition1 is set and Condition2 is null, then ConditionalOperator is ignored.
   * </p>
   * And to require both conditions to pass for the data to be filtered in. Or to allow data to be filtered in when one or both
   * conditions are met.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[conditionalOperator]] enumeration.
   * @see [[condition1]]
   * @see [[condition2]]
   */
  get conditionalOperator() {
    return this._n;
  }
  /**
   * Gets or sets the operator which defines how to logically combine [[condition1]] and [[condition2]]
   * <p class="body">
   * When both Condition1 and Condition2 are set, the ConditionalOperator is used to determine how the conditions should be logically
   * combined. If only Condition1 is set and Condition2 is null, then ConditionalOperator is ignored.
   * </p>
   * And to require both conditions to pass for the data to be filtered in. Or to allow data to be filtered in when one or both
   * conditions are met.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[conditionalOperator]] enumeration.
   * @see [[condition1]]
   * @see [[condition2]]
   */
  set conditionalOperator(a) {
    if (this.conditionalOperator == a) {
      return;
    }
    ExcelUtils.gl(ConditionalOperator_$type, a);
    CustomFilter._k[2].h(CustomFilter.$, ConditionalOperator_$type, this, a);
  }
  /**
   * @hidden
   */
  _z(a) {
    this._n = a;
    this._i();
  }
  /**
   * @hidden
   */
  static _m($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(CustomFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _l() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, CustomFilter._m(CustomFilterCondition.$, "Condition1", (b) => b.condition1, (b, c) => b.condition1 = c, (b, c) => b._x(c)));
    ChangeInfo.f(a, 1, CustomFilter._m(CustomFilterCondition.$, "Condition2", (b) => b.condition2, (b, c) => b.condition2 = c, (b, c) => b._y(c)));
    ChangeInfo.f(a, 2, CustomFilter._m(ConditionalOperator_$type, "ConditionalOperator", (b) => b.conditionalOperator, (b, c) => b.conditionalOperator = c, (b, c) => b._z(c)));
    return a;
  }
}
CustomFilter.$t = markType(CustomFilter, 'CustomFilter', Filter.$);
/**
 * @hidden
 */
CustomFilter._t = 0;
/**
 * @hidden
 */
CustomFilter._u = 1;
/**
 * @hidden
 */
CustomFilter._v = 2;
/**
 * @hidden
 */
CustomFilter._w = 3;
/**
 * @hidden
 */
CustomFilter._k = CustomFilter._l();
/**
 * Represents a filter which can filter dates in a specific period.
 * <p class="body">
 * This filter allows dates to be filtered in if they are in a specific month or quarter of any year.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 */
export class DatePeriodFilter extends DynamicValuesFilter {
  constructor(a, b, c) {
    super(a);
    this._s = 0;
    this._u = 0;
    ExcelUtils.gl(DatePeriodFilterType_$type, b);
    DatePeriodFilter._ab(b, c);
    this._s = b;
    this._u = c;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(DatePeriodFilter.$, a);
    if (b == null) {
      return false;
    }
    return this._u == b._u && this._s == b._s;
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e;
    if (((() => { let f = a._en(b, d, e); e = f.p2; return f.ret; })())) {
      switch (this.type) {
        case 0: return dateGetMonth(e) == this.value;
        case 1: return ExcelUtils.dd(e) == this.value;
        default: break;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  get__m() {
    switch (this.type) {
      case 0: return (28 + (this.value - 1));
      case 1: return (24 + (this.value - 1));
      default: return 0;
    }
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * @hidden
   */
  static _r($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(DatePeriodFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _q() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, DatePeriodFilter._r(DatePeriodFilterType_$type, "Type", (b) => b.type, (b, c) => b.type = c, (b, c) => b._z(c)));
    ChangeInfo.f(a, 1, DatePeriodFilter._r(Number_$type, "Value", (b) => b.value, (b, c) => b.value = c, (b, c) => b._aa(c)));
    return a;
  }
  /**
   * @hidden
   */
  static _ab(a, b) {
    let c = true;
    switch (a) {
      case 0:
        if (b < 1 || 12 < b) {
          c = false;
        }
        break;
      case 1:
        if (b < 1 || 4 < b) {
          c = false;
        }
        break;
      default: break;
    }
    if (c == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidDatePeriodFilterValue"), "value");
    }
  }
  /**
   * Gets or sets the type of date period to filter in.
   * Month to filter in dates in a specific month of any year; Quarter to filter in dates in a specific quarter of any year.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[DatePeriodFilterType]] enumeration.
   * @throws [[ArgumentException]] The value assigned is Quarter and the [[value]] is less than 1 or greater than 4 or
   * the value assigned is Month and the Value is less than 1 or greater than 12.
   * @see [[value]]
   */
  get type() {
    return this._s;
  }
  /**
   * Gets or sets the type of date period to filter in.
   * Month to filter in dates in a specific month of any year; Quarter to filter in dates in a specific quarter of any year.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[DatePeriodFilterType]] enumeration.
   * @throws [[ArgumentException]] The value assigned is Quarter and the [[value]] is less than 1 or greater than 4 or
   * the value assigned is Month and the Value is less than 1 or greater than 12.
   * @see [[value]]
   */
  set type(a) {
    if (this.type == a) {
      return;
    }
    ExcelUtils.gl(DatePeriodFilterType_$type, a);
    DatePeriodFilter._ab(a, this.value);
    ExcelUtils.gl(DatePeriodFilterType_$type, a);
    DatePeriodFilter._p[0].h(DatePeriodFilter.$, DatePeriodFilterType_$type, this, a);
  }
  /**
   * @hidden
   */
  _z(a) {
    this._s = a;
    this._i();
  }
  /**
   * Gets or sets the 1-based value of the month or quarter to filter in.
   * <p class="body">
   * If the [[type]] is Month, a Value of 1 indicates January, 2 indicates February, and so on. If Type is Quarter,
   * a Value of 1 indicates Quarter 1, and so on.
   * </p>
   * The 1-based value of the month or quarter to filter in.
   * @throws [[ArgumentException]] [[type]] is Quarter and the value assigned is less than 1 or greater than 4 or
   * Type is Month and the value assigned is less than 1 or greater than 12.
   * @see [[type]]
   */
  get value() {
    return this._u;
  }
  /**
   * Gets or sets the 1-based value of the month or quarter to filter in.
   * <p class="body">
   * If the [[type]] is Month, a Value of 1 indicates January, 2 indicates February, and so on. If Type is Quarter,
   * a Value of 1 indicates Quarter 1, and so on.
   * </p>
   * The 1-based value of the month or quarter to filter in.
   * @throws [[ArgumentException]] [[type]] is Quarter and the value assigned is less than 1 or greater than 4 or
   * Type is Month and the value assigned is less than 1 or greater than 12.
   * @see [[type]]
   */
  set value(a) {
    if (this.value == a) {
      return;
    }
    DatePeriodFilter._ab(this.type, a);
    DatePeriodFilter._p[1].h(DatePeriodFilter.$, Number_$type, this, a);
  }
  /**
   * @hidden
   */
  _aa(a) {
    this._u = a;
    this._i();
  }
}
DatePeriodFilter.$t = markType(DatePeriodFilter, 'DatePeriodFilter', DynamicValuesFilter.$);
/**
 * @hidden
 */
DatePeriodFilter._w = 0;
/**
 * @hidden
 */
DatePeriodFilter._y = 1;
/**
 * @hidden
 */
DatePeriodFilter._v = 2;
/**
 * @hidden
 */
DatePeriodFilter._p = DatePeriodFilter._q();
/**
 * Abstract base class for filters which filter dates based on whether they are within a specified range of dates or not.
 * @see [[RelativeDateRangeFilter]]
 * @see [[YearToDateFilter]]
 */
export class DateRangeFilter extends DynamicValuesFilter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(c);
          this._q = new Date();
          this._p = false;
          this._r = new Date();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(c);
          this._q = new Date();
          this._p = false;
          this._r = new Date();
          this._p = true;
          this._r = d;
          this._q = e;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(DateRangeFilter.$, a);
    if (b == null) {
      return false;
    }
    return +(this._q) == +(b._q) && +(this._r) == +(b._r);
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e;
    if (((() => { let f = a._en(b, d, e); e = f.p2; return f.ret; })())) {
      if (this._r <= e && e < this._q) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _f(a, b, c, d) {
    this._u();
    return true;
  }
  /**
   * @hidden
   */
  _u() {
    this._p = true;
    let a = this._v(this._r, this._q);
    this._r = a.p0;
    this._q = a.p1;
  }
  /**
   * Gets the exclusive end date of the filtered in date range.
   * @see [[start]]
   */
  get end() {
    if (this._p == false) {
      this._u();
    }
    return this._q;
  }
  /**
   * Gets the inclusive start date of the filtered in date range.
   * @see [[end]]
   */
  get start() {
    if (this._p == false) {
      this._u();
    }
    return this._r;
  }
}
DateRangeFilter.$t = markType(DateRangeFilter, 'DateRangeFilter', DynamicValuesFilter.$);
/**
 * @hidden
 */
export let IColorFilter_$type = new Type(null, 'IColorFilter');
/**
 * Represents a filter which will filter cells based on their background fills.
 * <p class="body">
 * This filter specifies a single [[CellFill]]. Cells of with this fill will be visible in the data range.
 * All other cells will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 */
export class FillFilter extends Filter {
  constructor(a, b) {
    super(a);
    this._m = null;
    if (b == null) {
      throw new ArgumentNullException(0, "fill");
    }
    this._m = b;
  }
  /**
   * @hidden
   */
  _accept$2$i($tArg, $tResult, visitor, argument) {
    return visitor._visitFillFilter$i(this, argument);
  }
  /**
   * @hidden
   */
  get isCellColorFilter() {
    return true;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(FillFilter.$, a);
    if (b == null) {
      return false;
    }
    let c = null;
    if (this._b != null) {
      c = this._b.workbook;
    }
    if (c == null) {
      return Base.equalsStatic(this._m, b._m);
    }
    else {
      return Base.equalsStatic(this._m._c(c), b._m._c(c));
    }
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = a._b4(b, d);
    return ExcelUtils.an(a.workbook, e, a._getCellConditionalFormat1(c, d), this.fill);
  }
  /**
   * @hidden
   */
  static _p(a, b) {
    if (b.fill == null) {
      return null;
    }
    let c = b.fill;
    let d = typeCast(CellFillPattern.$, c);
    if (b._b9 == false && d != null && d.patternStyle == 1) {
      c = new CellFillPattern(d.patternColorInfo, d.backgroundColorInfo, 1, null, true);
    }
    return new FillFilter(a, c);
  }
  /**
   * @hidden
   */
  static _o($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(FillFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _l() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, FillFilter._o(CellFill.$, "Fill", (b) => b.fill, (b, c) => b.fill = c, (b, c) => b._s(c)));
    return a;
  }
  /**
   * Gets or sets the [[CellFill]] by which the cells should be filtered.
   * <p class="body">
   * Cells of with this fill will be visible in the the data range. All other cells will be hidden.
   * </p>
   * The CellFill by which the cells should be filtered.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.fill]]
   */
  get fill() {
    return this._m;
  }
  /**
   * Gets or sets the [[CellFill]] by which the cells should be filtered.
   * <p class="body">
   * Cells of with this fill will be visible in the the data range. All other cells will be hidden.
   * </p>
   * The CellFill by which the cells should be filtered.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.fill]]
   */
  set fill(a) {
    if (this.fill == null) {
      return;
    }
    if (a == null) {
      throw new ArgumentNullException(0, "value");
    }
    FillFilter._k[0].h(FillFilter.$, CellFill.$, this, a);
  }
  /**
   * @hidden
   */
  _s(a) {
    this._m = a;
    this._i();
  }
}
FillFilter.$t = markType(FillFilter, 'FillFilter', Filter.$, [IColorFilter_$type]);
/**
 * @hidden
 */
FillFilter._q = 0;
/**
 * @hidden
 */
FillFilter._r = 1;
/**
 * @hidden
 */
FillFilter._k = FillFilter._l();
/**
 * Represents a fixed range of dates.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export class FixedDateGroup extends Base {
  constructor(type, value) {
    super();
    this._c = new FixedDateGroup_DateRange();
    this._h = null;
    this._d = 0;
    this._i = new Date();
    ExcelUtils.gl(FixedDateGroupType_$type, type);
    if (ExcelCalcValue._dateTimeToExcelDate(null, value).hasValue == false) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_InvalidExcelDate"), "value");
    }
    this._d = type;
    this._i = value;
    this._h = new Dictionary$2(CalendarType_$type, FixedDateGroup_DateRange.$, 0);
    let a = this._n(null, 10, this._c);
    this._c = a.p2;
  }
  /**
   * Determines whether the [[FixedDateGroup]] is equal to the specified object.
   * @param obj The object to test for equality.
   * @return True if the object is equal to this instance; False otherwise.
   */
  equals(obj) {
    if (Base.referenceEquals(this, obj)) {
      return true;
    }
    let a = typeCast(FixedDateGroup.$, obj);
    if (a == null) {
      return false;
    }
    return this._d == a._d && +(this._c.b) == +(a._c.b) && +(this._c.a) == +(a._c.a);
  }
  /**
   * Gets the hash code for the [[FixedDateGroup]].
   * @return A number which can be used to hash this instance.
   */
  getHashCode() {
    return Base.getHashCodeStatic(this._d) ^ Base.getHashCodeStatic(this._c.b) ^ (Base.getHashCodeStatic(this._c.a) << 1);
  }
  /**
   * Gets the accepted date range based on the specified calendar type.
   * @param calendarType The calendar type in which to get the accepted date range.
   * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
   * @see [[start]]
   * @see [[end]]
   * @return A [[DateRange]] where the start is the inclusive start date of the accepted date range and the end is
   * the exclusive end date.
   */
  getRange(calendarType) {
    ExcelUtils.gl(CalendarType_$type, calendarType);
    let a = new FixedDateGroup_DateRange();
    let b = this._n(null, calendarType, a);
    a = b.p2;
    let c = new DateRange();
    c.start = a.b;
    c.end = a.a;
    return c;
  }
  /**
   * @hidden
   */
  static _b(a, b, c, d, e, f, g) {
    switch (a) {
      case 5: return new FixedDateGroup(4, dateFromValues(b, c.getValueOrDefault(), d.getValueOrDefault(), e.getValueOrDefault(), f.getValueOrDefault(), g.getValueOrDefault(), 0));
      case 4: return new FixedDateGroup(2, dateFromValues(b, c.getValueOrDefault(), d.getValueOrDefault(), e.getValueOrDefault(), f.getValueOrDefault(), 0, 0));
      case 3: return new FixedDateGroup(1, dateFromValues(b, c.getValueOrDefault(), d.getValueOrDefault(), e.getValueOrDefault(), 0, 0, 0));
      case 2: return new FixedDateGroup(0, dateFromValues(b, c.getValueOrDefault(), d.getValueOrDefault(), 0, 0, 0, 0));
      case 1: return new FixedDateGroup(3, dateFromValues(b, c.getValueOrDefault(), 1, 0, 0, 0, 0));
      case 0: return new FixedDateGroup(5, dateFromValues(b, 1, 1, 0, 0, 0, 0));
      default: return null;
    }
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    if (((() => { let d = this._h.tryGetValue(b, c); c = d.p1; return d.ret; })())) {
      return {
        p2: c
      };
    }
    if (a == null) {
      a = ExcelUtils.cp(b);
    }
    let d = a.getEra(this._i);
    let e = a.getYear(this._i);
    let f;
    let g;
    let t1 = this.type;
    L0: while (true) {
      switch (t1) {
        case 4:
          f = dateFromValues(this._i.getFullYear(), dateGetMonth(this._i), this._i.getDate(), this._i.getHours(), this._i.getMinutes(), this._i.getSeconds(), 0);
          g = dateAddSeconds(f, 1);
          break;
        case 2:
          f = dateFromValues(this._i.getFullYear(), dateGetMonth(this._i), this._i.getDate(), this._i.getHours(), this._i.getMinutes(), 0, 0);
          g = dateAddMinutes(f, 1);
          break;
        case 1:
          f = dateFromValues(this._i.getFullYear(), dateGetMonth(this._i), this._i.getDate(), this._i.getHours(), 0, 0, 0);
          g = dateAddHours(f, 1);
          break;
        case 0:
          f = dateFromValues(this._i.getFullYear(), dateGetMonth(this._i), this._i.getDate(), 0, 0, 0, 0);
          g = dateAddDays(f, 1);
          break;
        case 3:
          let h = a.getMonth(this._i);
          f = a.toDateTime(e, h, 1, 0, 0, 0, 0, d);
          g = dateAddDays(f, a.getDaysInMonth(e, h, d));
          break;
        case 5:
          f = a.toDateTime(e, 1, 1, 0, 0, 0, 0, d);
          g = dateAddDays(f, a.getDaysInYear(e, d));
          break;
        default:
          t1 = 4;
          continue L0;
      }
      break;
    }
    c = new FixedDateGroup_DateRange(1, f, g);
    this._h.addItem(b, c);
    return {
      p2: c
    };
  }
  /**
   * Gets the exclusive end date of the accepted date range with a [[CalendarType]] of None.
   * @see [[start]]
   * @see [[getRange]]
   */
  get end() {
    return this._c.a;
  }
  /**
   * Gets the inclusive start date of the accepted date range with a [[CalendarType]] of None.
   * @see [[end]]
   * @see [[getRange]]
   */
  get start() {
    return this._c.b;
  }
  /**
   * Gets the type, or precision, of the group.
   * <p class="body">
   * The group type indicates the precision of the [[value]], which defines the range of accepted dates in the group.
   * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
   * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
   * </p>
   * @see [[value]]
   */
  get type() {
    return this._d;
  }
  /**
   * Gets the reference date which determines range of accepted dates.
   * <p class="body">
   * [[type]] indicates the precision of the Value, which defines the range of accepted dates in the group.
   * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
   * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
   * </p>
   * @see [[type]]
   */
  get value() {
    return this._i;
  }
  /**
   * @hidden
   */
  get _f() {
    switch (this.type) {
      case 4: return 5;
      case 2: return 4;
      case 1: return 3;
      case 0: return 2;
      case 3: return 1;
      case 5: return 0;
      default: return 0;
    }
  }
}
FixedDateGroup.$t = markType(FixedDateGroup, 'FixedDateGroup');
/**
 * @hidden
 */
export class FixedDateGroup_DateRange extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = new Date();
    this.b = new Date();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
}
FixedDateGroup_DateRange.$t = markStruct(FixedDateGroup_DateRange, 'FixedDateGroup_DateRange');
/**
 * Represents a range of dates.
 */
export class DateRange extends Base {
  constructor() {
    super(...arguments);
    this.start = new Date();
    this.end = new Date();
  }
}
DateRange.$t = markType(DateRange, 'DateRange');
/**
 * @hidden
 */
export class FixedDateGroupCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b._d._b == null ? null : this.b._d._b.workbook;
  }
  get sheet() {
    return this.b._d._b == null ? null : this.b._d._b.worksheet;
  }
  get source() {
    return this.b._d._b;
  }
}
FixedDateGroupCollection_CollectionChangeContext.$t = markStruct(FixedDateGroupCollection_CollectionChangeContext, 'FixedDateGroupCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of fixed date groups.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export class FixedDateGroupCollection extends Base {
  constructor(a) {
    super();
    /**
     * @hidden
     */
    this._d = null;
    this._e = new List$1(FixedDateGroup.$, 0);
    this._d = a;
  }
  static staticInit() {
    FixedDateGroupCollection._a = FixedDateGroupCollection._b();
  }
  /**
   * @hidden
   */
  copyTo(array, arrayIndex) {
    this._e.copyTo(array, arrayIndex);
  }
  /**
   * @hidden
   */
  get isReadOnly() {
    return false;
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._e.getEnumerator();
  }
  /**
   * @hidden
   */
  getEnumeratorObject() {
    return getEnumerator(this);
  }
  /**
   * Adds a fixed date group to the collection.
   * @param item The fixed date group to add to the collection.
   * @throws [[ArgumentNullException]] 'item' is null.
   * @throws [[ArgumentException]] 'item' is already in the collection.
   */
  add(item) {
    this._o(item);
    this._j(this._e.count, item);
  }
  /**
   * Clears the collection.
   * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
   * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
   */
  clear() {
    if (this._d._aa() == this._e.count) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    let a = this._e.count > 0 ? this._i(15) : null;
    for (let b = this._e.count - 1; b >= 0; b--) {
      this._k(b, false);
    }
    this._d._i();
    this._l(a);
  }
  /**
   * Determines whether the specified fixed date group is in the collection.
   * @param item The fixed date group to find in the collection.
   * @return True if the item is in the collection; False otherwise.
   */
  contains(item) {
    return this.indexOf(item) >= 0;
  }
  /**
   * Gets the index of the specified fixed date group in the collection.
   * @param item The fixed date group to find in the collection.
   * @return The 0-based index of the specified fixed date group in the collection or -1 if the item is not in the collection.
   */
  indexOf(item) {
    for (let a = 0; a < this._e.count; a++) {
      if (Base.equalsStatic(item, this._e._inner[a])) {
        return a;
      }
    }
    return -1;
  }
  /**
   * Inserts a fixed date group into the collection.
   * @param index The 0-based index where the value should be inserted.
   * @param item The fixed date group to insert into the collection.
   * @throws [[ArgumentNullException]] 'item' is null.
   * @throws [[ArgumentException]] 'item' is already in the collection.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
   */
  insert(index, item) {
    this._o(item);
    this._j(index, item);
  }
  /**
   * Removes the fixed date group from the collection.
   * @param item The fixed date group to remove from the collection.
   * @return True if the value was found and removed; False otherwise.
   */
  remove(item) {
    let a = this.indexOf(item);
    if (a < 0) {
      return false;
    }
    this.removeAt(a);
    return true;
  }
  /**
   * Removes the fixed date group at the specified index.
   * @param index The 0-based index of the value to remove.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
   * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
   * is not allowed for a FixedValuesFilter.
   */
  removeAt(index) {
    if (this._d._aa() == 1) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this._k(index, true);
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = true, h = 8192) {
    return new ChangeInfo$2(FixedDateGroupCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, FixedDateGroupCollection._c(FixedDateGroup.$, "Add", 39, (b) => b.a, (b, c) => FixedDateGroupCollection._m(b, c)));
    ChangeInfo.f(a, 1, FixedDateGroupCollection._c(FixedDateGroup.$, "Remove", 40, (b) => b.a, (b, c) => FixedDateGroupCollection._n(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _j(a, b) {
    let c = FixedDateGroupCollection._a[0];
    let d = null;
    if (this._d._b != null) {
      d = c.b(this._d._b.workbook, this._d._b.worksheet, c.c);
    }
    let e = new FixedDateGroupCollection_CollectionChangeContext(1, this, b, a);
    this._e.insert(a, b);
    this._d._i();
    if (this._d._b != null) {
      c.e(FixedDateGroupCollection_CollectionChangeContext.$, FixedDateGroup.$, e, null, b);
      if (d != null) {
        c.d(this._d._b.workbook, d);
      }
    }
  }
  /**
   * @hidden
   */
  _k(a, b) {
    let c = this._e._inner[a];
    let d = FixedDateGroupCollection._a[1];
    let e = null;
    if (this._d._b != null) {
      e = d.b(this._d._b.workbook, this._d._b.worksheet, d.c);
    }
    let f = new FixedDateGroupCollection_CollectionChangeContext(1, this, c, a);
    this._e.removeAt(a);
    if (b) {
      this._d._i();
    }
    if (this._d._b != null) {
      d.e(FixedDateGroupCollection_CollectionChangeContext.$, FixedDateGroup.$, f, c, null);
      if (e != null) {
        d.d(this._d._b.workbook, e);
      }
    }
  }
  /**
   * @hidden
   */
  _i(a) {
    let b = this._d._b == null ? null : this._d._b.workbook;
    return b != null && b._cx ? b._go(this._d._b.worksheet, a, null) : null;
  }
  /**
   * @hidden
   */
  _l(a) {
    if (a != null) {
      let b = this._d._b.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _m(a, b) {
    let c = a.b._e.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _n(a, b) {
    a.b._j(a.c, a.a);
  }
  /**
   * @hidden
   */
  _o(a) {
    if (a == null) {
      throw new ArgumentNullException(0, "item");
    }
    if (this.contains(a)) {
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateFixedDateGroup"), "item");
    }
  }
  /**
   * Gets the number of fixed date groups in the collection.
   */
  get count() {
    return this._e.count;
  }
  /**
   * Gets or sets the fixed date group at the specified index.
   * @param index The 0-based index of the value to get or set.
   * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @throws [[ArgumentException]] The value assigned is already in the collection.
   */
  item(a, b) {
    if (arguments.length === 2) {
      if (b == null) {
        throw new ArgumentNullException(0, "item");
      }
      let c = this.indexOf(b);
      if (c < 0 || c == a) {
        this._e._inner[a] = b;
        return;
      }
      throw new ArgumentException(2, ExcelUtils.ef("LE_ArgumentException_DuplicateFixedDateGroup"), "item");
      return b;
    }
    else {
      return this._e._inner[a];
    }
  }
}
FixedDateGroupCollection.$t = markType(FixedDateGroupCollection, 'FixedDateGroupCollection', Base.$, [IList$1_$type.specialize(FixedDateGroup.$)]);
/**
 * @hidden
 */
FixedDateGroupCollection._f = 0;
/**
 * @hidden
 */
FixedDateGroupCollection._h = 1;
/**
 * @hidden
 */
FixedDateGroupCollection._g = 2;
/**
 * @hidden
 */
FixedDateGroupCollection._a = null;
/**
 * Represents a filter which can filter cells based on specific, fixed values, which are allowed to display.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 */
export class FixedValuesFilter extends Filter {
  constructor(a) {
    super(a);
    this._x = null;
    this._p = 0;
    this._r = null;
    this._n = null;
    this._t = false;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(FixedValuesFilter.$, a);
    if (b == null) {
      return false;
    }
    if (this._t != b._t || this._p != b._p || this._displayValues$i.count != b._displayValues$i.count || this._dateGroups$i.count != b._dateGroups$i.count) {
      return false;
    }
    for (let c = 0; c < this._displayValues$i.count; c++) {
      if (this._displayValues$i.item(c) != b._displayValues$i.item(c)) {
        return false;
      }
    }
    for (let d = 0; d < this._dateGroups$i.count; d++) {
      if (Base.equalsStatic(this._dateGroups$i.item(d), b._dateGroups$i.item(d)) == false) {
        return false;
      }
    }
    return true;
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = Filter._c(b, d);
    if (stringIsNullOrEmpty(e.g)) {
      return this.includeBlanks;
    }
    if (this._n != null && this._n.contains(e.g)) {
      return true;
    }
    if (isNaN_(e.e) == false && e.a == 1 && this._r != null && this._r.count != 0) {
      let f = ExcelCalcValue._excelDateToDateTime(a.workbook, e.e);
      if (f.hasValue) {
        let g = f.value;
        for (let h = 0; h < this._r.count; h++) {
          let i = this._r.item(h);
          let j = new FixedDateGroup_DateRange();
          let k = i._n(this._y, this.calendarType, j);
          j = k.p2;
          if (j.b <= g && g < j.a) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _g(a, b) {
    let c = ((() => { let d = this._ab(true, b); b = d.p1; return d.ret; })());
    a = this._dateGroups$i.count != 0 || c > 2;
    return {
      ret: c != 0,
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _aa() {
    let a;
    return ((() => { let b = this._ab(false, a); a = b.p1; return b.ret; })());
  }
  /**
   * @hidden
   */
  _ab(a, b) {
    b = null;
    let c = 0;
    if (this.includeBlanks) {
      c++;
    }
    if (this._r != null) {
      c += this._r.count;
    }
    if (this._n != null) {
      b = new List$1(String_$type, 0);
      if (a) {
        for (let d = 0; d < this._n.count; d++) {
          let e = this._n.item(d);
          if (e.length <= 255) {
            b.add(e);
            c++;
          }
        }
      }
      else {
        c += this._n.count;
        b = this._n;
      }
    }
    return {
      ret: c,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _m($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(FixedValuesFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _l() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, FixedValuesFilter._m(CalendarType_$type, "CalendarType", (b) => b.calendarType, (b, c) => b.calendarType = c, (b, c) => b._ae(c)));
    ChangeInfo.f(a, 1, FixedValuesFilter._m(Boolean_$type, "IncludeBlanks", (b) => b.includeBlanks, (b, c) => b._v = c, (b, c) => b._af(c)));
    return a;
  }
  /**
   * Gets or sets the calendar type used to interpret values in the [[dateGroups]] collection.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[calendarType]] enumeration.
   */
  get calendarType() {
    return this._p;
  }
  /**
   * Gets or sets the calendar type used to interpret values in the [[dateGroups]] collection.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[calendarType]] enumeration.
   */
  set calendarType(a) {
    if (this.calendarType == a) {
      return;
    }
    ExcelUtils.gl(CalendarType_$type, a);
    FixedValuesFilter._k[0].h(FixedValuesFilter.$, CalendarType_$type, this, a);
  }
  /**
   * @hidden
   */
  _ae(a) {
    this._p = a;
    this._i();
  }
  dateGroups() {
    if (arguments.length !== 0) {
      let a = this._dateGroups$i;
      return a.item.apply(a, arguments);
    }
    return this._dateGroups$i;
  }
  /**
   * @hidden
   */
  get _dateGroups$i() {
    if (this._r == null) {
      this._r = new FixedDateGroupCollection(this);
    }
    return this._r;
  }
  displayValues() {
    if (arguments.length !== 0) {
      let a = this._displayValues$i;
      return a.item.apply(a, arguments);
    }
    return this._displayValues$i;
  }
  /**
   * @hidden
   */
  get _displayValues$i() {
    if (this._n == null) {
      this._n = new DisplayValueCollection(this);
    }
    return this._n;
  }
  /**
   * Gets or sets the value which indicates whether blank cells should be filtered in.
   * @throws [[InvalidOperationException]] The value is set to False and both [[dateGroups]] and [[displayValues]] contain no values.
   * This would prevent the filter from including any values, which is not allowed for a [[FixedValuesFilter]].
   */
  get includeBlanks() {
    return this._t;
  }
  /**
   * Gets or sets the value which indicates whether blank cells should be filtered in.
   * @throws [[InvalidOperationException]] The value is set to False and both [[dateGroups]] and [[displayValues]] contain no values.
   * This would prevent the filter from including any values, which is not allowed for a [[FixedValuesFilter]].
   */
  set includeBlanks(a) {
    if (this._t == a) {
      return;
    }
    if (a == false && this._aa() == 1) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this._v = a;
  }
  /**
   * @hidden
   */
  set _v(a) {
    FixedValuesFilter._k[1].h(FixedValuesFilter.$, Boolean_$type, this, a);
  }
  /**
   * @hidden
   */
  _af(a) {
    this._t = a;
    this._i();
  }
  /**
   * @hidden
   */
  get _y() {
    if (this._x == null) {
      this._x = ExcelUtils.cp(this.calendarType);
    }
    return this._x;
  }
  /**
   * @hidden
   */
  get _w() {
    return this._aa() == 0;
  }
}
FixedValuesFilter.$t = markType(FixedValuesFilter, 'FixedValuesFilter', Filter.$);
/**
 * @hidden
 */
FixedValuesFilter._z = 0;
/**
 * @hidden
 */
FixedValuesFilter._ac = 1;
/**
 * @hidden
 */
FixedValuesFilter._ad = 2;
/**
 * @hidden
 */
FixedValuesFilter._k = FixedValuesFilter._l();
/**
 * Represents a filter which will filter cells based on their font colors.
 * <p class="body">
 * This filter specifies a single color. Cells with this color font will be visible in the data range. All other cells
 * will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFontColorFilter]]
 */
export class FontColorFilter extends Filter {
  constructor(a, b) {
    super(a);
    this._o = null;
    if (WorkbookColorInfo.l_op_Equality(b, null)) {
      throw new ArgumentNullException(0, "fontColorInfo");
    }
    this._o = b;
  }
  /**
   * @hidden
   */
  _accept$2$i($tArg, $tResult, visitor, argument) {
    return visitor._visitFontColorFilter$i(this, argument);
  }
  /**
   * @hidden
   */
  get isCellColorFilter() {
    return false;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(FontColorFilter.$, a);
    if (b == null) {
      return false;
    }
    let c = null;
    if (this._b != null) {
      c = this._b.workbook;
    }
    if (c == null) {
      return WorkbookColorInfo.l_op_Equality(this._o, b._o);
    }
    return ExcelUtils.cx(this._o._aj(c)) == ExcelUtils.cx(b._o._aj(c));
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = a._b4(b, d);
    return ExcelUtils.ao(a.workbook, e, a._getCellConditionalFormat1(c, d), this.fontColorInfo);
  }
  /**
   * @hidden
   */
  static _n(a, b) {
    let c = typeCast(CellFillPattern.$, b.fill);
    if (c == null) {
      return null;
    }
    let d = c._aa(b);
    return new FontColorFilter(a, d);
  }
  /**
   * @hidden
   */
  static _m($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(FontColorFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _l() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, FontColorFilter._m(WorkbookColorInfo.$, "FontColorInfo", (b) => b.fontColorInfo, (b, c) => b.fontColorInfo = c, (b, c) => b._s(c)));
    return a;
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
   * <p class="body">
   * Cells of this font color will be visible in the the data range. All other cells will be hidden.
   * </p>
   * The WorkbookColorInfo which describes the color by which the cells should be filtered.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[Type]]
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.font]]
   * @see [[IWorkbookFont.colorInfo]]
   */
  get fontColorInfo() {
    return this._o;
  }
  /**
   * Gets or sets the [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
   * <p class="body">
   * Cells of this font color will be visible in the the data range. All other cells will be hidden.
   * </p>
   * The WorkbookColorInfo which describes the color by which the cells should be filtered.
   * @throws [[ArgumentNullException]] The value assigned is null.
   * @see [[Type]]
   * @see [[WorksheetCell.cellFormat]]
   * @see [[IWorksheetCellFormat.font]]
   * @see [[IWorkbookFont.colorInfo]]
   */
  set fontColorInfo(a) {
    if (WorkbookColorInfo.l_op_Equality(this.fontColorInfo, null)) {
      return;
    }
    if (WorkbookColorInfo.l_op_Equality(a, null)) {
      throw new ArgumentNullException(0, "value");
    }
    FontColorFilter._k[0].h(FontColorFilter.$, WorkbookColorInfo.$, this, a);
  }
  /**
   * @hidden
   */
  _s(a) {
    this._o = a;
    this._i();
  }
}
FontColorFilter.$t = markType(FontColorFilter, 'FontColorFilter', Filter.$, [IColorFilter_$type]);
/**
 * @hidden
 */
FontColorFilter._q = 0;
/**
 * @hidden
 */
FontColorFilter._r = 1;
/**
 * @hidden
 */
FontColorFilter._k = FontColorFilter._l();
/**
 * Represents a filter which can filter cells based on their conditional formatting icon.
 * <p class="body">
 * This filter allows cells to be filtered in if their conditional formatting icon matches the criteria.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[ConditionalFormatCollection.addIconSetCondition]]
 */
export class IconFilter extends Filter {
  constructor(a, b, c) {
    super(a);
    this._n = Nullable$1.toNullable(Number_$type, null);
    this._l = 0;
    this._l = b;
    this._n = c;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(IconFilter.$, a);
    if (b == null) {
      return false;
    }
    return nullableEquals(this._n, b._n) && this._l == b._l;
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = a._getCellConditionalFormat1(c, d);
    return ExcelUtils.ap(e, this._l, this._n);
  }
  /**
   * The icon set (read-only).
   */
  get iconIndex() {
    return unwrapNullable(this._iconIndex$i);
  }
  /**
   * @hidden
   */
  get _iconIndex$i() {
    return nullableNotEquals(this._n, null) ? Nullable$1.toNullable(Number_$type, this._n.value) : Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * The icon's index in the associated icon set or null for 'NoCellIcon' (read-only).
   */
  get iconSet() {
    return ExcelUtils.t(this._l);
  }
  /**
   * @hidden
   */
  get _p() {
    return this._n;
  }
  /**
   * @hidden
   */
  get _m() {
    return this._l;
  }
}
IconFilter.$t = markType(IconFilter, 'IconFilter', Filter.$);
/**
 * Represents a filter which can filter date cells based on dates relative to the when the filter was applied.
 * <p class="body">
 * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
 * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
 * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
 * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
 * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
 * dates in 1999, even if the workbook is opened in 2012.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyRelativeDateRangeFilter]]
 */
export class RelativeDateRangeFilter extends DateRangeFilter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(0, c);
          this._z = 0;
          this._ab = 0;
          this._ag(d, e);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          super(1, c, f, g);
          this._z = 0;
          this._ab = 0;
          this._ag(d, e);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _ag(a, b) {
    ExcelUtils.gl(RelativeDateRangeOffset_$type, a);
    ExcelUtils.gl(RelativeDateRangeDuration_$type, b);
    this._ab = a;
    this._z = b;
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(RelativeDateRangeFilter.$, a);
    if (b == null) {
      return false;
    }
    return this._z == b._z && this._ab == b._ab && super._d(b);
  }
  /**
   * @hidden
   */
  _v(a, b) {
    let c = dateNow();
    a = c;
    b = c;
    let d;
    switch (this.offset) {
      case 0:
        d = -1;
        break;
      case 1:
        d = 0;
        break;
      case 2:
        d = 1;
        break;
      default: return {
        p0: a,
        p1: b
      };
    }
    switch (this.duration) {
      case 0:
        a = dateAddDays(dateGetDate(c), d);
        b = dateAddDays(a, 1);
        break;
      case 1:
        a = dateAddDays(dateAddDays(dateGetDate(c), -c.getDay()), d * 7);
        b = dateAddDays(a, 7);
        break;
      case 2:
        a = dateAddMonths(dateFromValues(c.getFullYear(), dateGetMonth(c), 1, 0, 0, 0, 0), d);
        b = dateAddMonths(a, 1);
        break;
      case 3:
        let e = c.getFullYear();
        let f = ExcelUtils.dd(c) + d;
        if (f < 1) {
          e--;
          f += 4;
        }
        else if (4 < f) {
          e++;
          f -= 4;
        }
        a = dateFromValues(e, ExcelUtils.da(f), 1, 0, 0, 0, 0);
        b = dateAddMonths(a, 3);
        break;
      case 4:
        a = dateAddYears(dateFromValues(c.getFullYear(), 1, 1, 0, 0, 0, 0), d);
        b = dateAddYears(a, 1);
        break;
      default: return {
        p0: a,
        p1: b
      };
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  get__m() {
    let a;
    switch (this.duration) {
      case 0:
        a = [10, 9, 8];
        break;
      case 1:
        a = [13, 12, 11];
        break;
      case 2:
        a = [16, 15, 14];
        break;
      case 3:
        a = [19, 18, 17];
        break;
      case 4:
        a = [22, 21, 20];
        break;
      default: return 0;
    }
    return a[this.offset];
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * Gets or sets the duration of the full range of accepted dates.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeDuration]] enumeration.
   * @see [[offset]]
   */
  get duration() {
    return this._z;
  }
  /**
   * Gets or sets the duration of the full range of accepted dates.
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeDuration]] enumeration.
   * @see [[offset]]
   */
  set duration(a) {
    if (this.duration == a) {
      return;
    }
    ExcelUtils.gl(RelativeDateRangeDuration_$type, a);
    RelativeDateRangeFilter._w[0].h(RelativeDateRangeFilter.$, RelativeDateRangeDuration_$type, this, a);
  }
  /**
   * @hidden
   */
  _ah(a) {
    this._z = a;
    this._i();
  }
  /**
   * Gets or sets the offset of relative filter (previous, current, or next).
   * <p class="body">
   * Type combined with [[duration]] determines the relative date range to filter.
   * </p>
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeOffset]] enumeration.
   * @see [[duration]]
   */
  get offset() {
    return this._ab;
  }
  /**
   * Gets or sets the offset of relative filter (previous, current, or next).
   * <p class="body">
   * Type combined with [[duration]] determines the relative date range to filter.
   * </p>
   * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeOffset]] enumeration.
   * @see [[duration]]
   */
  set offset(a) {
    if (this.offset == a) {
      return;
    }
    ExcelUtils.gl(RelativeDateRangeOffset_$type, a);
    RelativeDateRangeFilter._w[1].h(RelativeDateRangeFilter.$, RelativeDateRangeOffset_$type, this, a);
  }
  /**
   * @hidden
   */
  _ai(a) {
    this._ab = a;
    this._i();
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(RelativeDateRangeFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, RelativeDateRangeFilter._y(RelativeDateRangeDuration_$type, "Duration", (b) => b.duration, (b, c) => b.duration = c, (b, c) => b._ah(c)));
    ChangeInfo.f(a, 1, RelativeDateRangeFilter._y(RelativeDateRangeOffset_$type, "Offset", (b) => b.offset, (b, c) => b.offset = c, (b, c) => b._ai(c)));
    return a;
  }
}
RelativeDateRangeFilter.$t = markType(RelativeDateRangeFilter, 'RelativeDateRangeFilter', DateRangeFilter.$);
/**
 * @hidden
 */
RelativeDateRangeFilter._ad = 0;
/**
 * @hidden
 */
RelativeDateRangeFilter._af = 1;
/**
 * @hidden
 */
RelativeDateRangeFilter._ae = 2;
/**
 * @hidden
 */
RelativeDateRangeFilter._w = RelativeDateRangeFilter._x();
/**
 * Represents a filter which can filter in cells in the upper or lower portion of the sorted values.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 */
export class TopOrBottomFilter extends DynamicValuesFilter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = [c, 0, 10];
          {
            let f = d[0];
            let g = d[1];
            let h = d[2];
            super(f);
            this._y = 0;
            this._s = 0;
            this._aa = 0;
            ExcelUtils.gl(TopOrBottomFilterType_$type, g);
            TopOrBottomFilter._ah(h);
            this._s = g;
            this._aa = h;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(c);
          this._y = 0;
          this._s = 0;
          this._aa = 0;
          ExcelUtils.gl(TopOrBottomFilterType_$type, d);
          TopOrBottomFilter._ah(e);
          this._s = d;
          this._aa = e;
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = [c, d, e];
          {
            let i = g[0];
            let j = g[1];
            let k = g[2];
            super(i);
            this._y = 0;
            this._s = 0;
            this._aa = 0;
            ExcelUtils.gl(TopOrBottomFilterType_$type, j);
            TopOrBottomFilter._ah(k);
            this._s = j;
            this._aa = k;
          }
          this._y = f;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(TopOrBottomFilter.$, a);
    if (b == null) {
      return false;
    }
    return this._y == b._y && this._s == b._s && this._aa == b._aa;
  }
  /**
   * @hidden
   */
  _e(a, b, c, d) {
    let e = WorksheetRow._c2(b, d);
    let f;
    if (((() => { let g = ExcelUtils.b0(a.workbook, e, f); f = g.p2; return g.ret; })())) {
      if (this._x) {
        return this._y <= f;
      }
      else {
        return f <= this._y;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _f(a, b, c, d) {
    let e = new List$1(Number_$type, 0);
    let f = a.workbook;
    for (let g of fromEnum(a._rows$i._m(b, c))) {
      let h = g._c5(d);
      let i = typeCast(ErrorValue.$, h);
      if (i != null && i != ErrorValue.circularity) {
        return false;
      }
      let j;
      if (((() => { let k = ExcelUtils.b0(f, h, j); j = k.p2; return k.ret; })())) {
        e.add(j);
      }
    }
    if (e.count == 0) {
      return true;
    }
    e.y();
    let k;
    if (this._w) {
      k = truncate(Math.max(1, Math.floor((e.count * Math.min(100, this.value)) / 100)));
    }
    else {
      k = Math.min(e.count, this.value);
    }
    if (k == 0) {
      return true;
    }
    if (this._x) {
      this._y = e._inner[e.count - k];
    }
    else {
      this._y = e._inner[k - 1];
    }
    return true;
  }
  /**
   * @hidden
   */
  _g(a, b) {
    a = false;
    b = null;
    return {
      ret: true,
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  get__m() {
    return 0;
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
  /**
   * @hidden
   */
  static _t(a, b) {
    if (a) {
      if (b) {
        return 2;
      }
      return 3;
    }
    if (b) {
      return 0;
    }
    return 1;
  }
  /**
   * @hidden
   */
  static _r($tValue, a, b, c, d = null, e = true, f = true, g = 2048) {
    return new ChangeInfo$2(TopOrBottomFilter.$, $tValue, a, 38, b, c, d, e, g, f, null, null);
  }
  /**
   * @hidden
   */
  static _q() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, TopOrBottomFilter._r(TopOrBottomFilterType_$type, "Type", (b) => b.type, (b, c) => b.type = c, (b, c) => b._af(c)));
    ChangeInfo.f(a, 1, TopOrBottomFilter._r(Number_$type, "Value", (b) => b.value, (b, c) => b.value = c, (b, c) => b._ag(c)));
    return a;
  }
  /**
   * @hidden
   */
  static _ah(a) {
    if (a < 1 || 500 < a) {
      throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentException_InvalidTopOrBottomFilterValue"));
    }
  }
  /**
   * Gets or sets the type of the filter.
   * TopValues or BottomValues to filter in the top or bottom N value in the list of sorted values; TopPercentage or BottomPercentage
   * to filter in the top or bottom N percentage of values in the list of sorted values.
   * @throws [[InvalidEnumArgumentException]] The value assign is not defined in the [[TopOrBottomFilterType]] enumeration.
   * @see [[value]]
   */
  get type() {
    return this._s;
  }
  /**
   * Gets or sets the type of the filter.
   * TopValues or BottomValues to filter in the top or bottom N value in the list of sorted values; TopPercentage or BottomPercentage
   * to filter in the top or bottom N percentage of values in the list of sorted values.
   * @throws [[InvalidEnumArgumentException]] The value assign is not defined in the [[TopOrBottomFilterType]] enumeration.
   * @see [[value]]
   */
  set type(a) {
    if (this.type == a) {
      return;
    }
    ExcelUtils.gl(TopOrBottomFilterType_$type, a);
    TopOrBottomFilter._p[0].h(TopOrBottomFilter.$, TopOrBottomFilterType_$type, this, a);
  }
  /**
   * @hidden
   */
  _af(a) {
    this._s = a;
    this._i();
  }
  /**
   * Gets or sets the number or percentage of value of values which should be filtered in.
   * <p class="body">
   * When [[type]] is TopValues or BottomValues, Value indicates the number of value which should be filtered in.
   * When Type is TopPercentage or BottomPercentage, Value indicates percentage to filter in. For example, a Value of 15 and
   * a Type of BottomPercentage will filter in the bottom 15 percent of values.
   * </p>
   * The number or percentage of items which should be filtered in.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 500.
   */
  get value() {
    return this._aa;
  }
  /**
   * Gets or sets the number or percentage of value of values which should be filtered in.
   * <p class="body">
   * When [[type]] is TopValues or BottomValues, Value indicates the number of value which should be filtered in.
   * When Type is TopPercentage or BottomPercentage, Value indicates percentage to filter in. For example, a Value of 15 and
   * a Type of BottomPercentage will filter in the bottom 15 percent of values.
   * </p>
   * The number or percentage of items which should be filtered in.
   * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 500.
   */
  set value(a) {
    if (this.value == a) {
      return;
    }
    TopOrBottomFilter._ah(a);
    TopOrBottomFilter._p[1].h(TopOrBottomFilter.$, Number_$type, this, a);
  }
  /**
   * @hidden
   */
  _ag(a) {
    this._aa = a;
    this._i();
  }
  /**
   * @hidden
   */
  get _v() {
    if (this._x) {
      return 6;
    }
    return 3;
  }
  /**
   * @hidden
   */
  get _w() {
    return this.type == 3 || this.type == 2;
  }
  /**
   * @hidden
   */
  get _x() {
    return this.type == 0 || this.type == 2;
  }
  /**
   * @hidden
   */
  get _z() {
    return this._y;
  }
}
TopOrBottomFilter.$t = markType(TopOrBottomFilter, 'TopOrBottomFilter', DynamicValuesFilter.$);
/**
 * @hidden
 */
TopOrBottomFilter._ac = 0;
/**
 * @hidden
 */
TopOrBottomFilter._ae = 1;
/**
 * @hidden
 */
TopOrBottomFilter._ab = 2;
/**
 * @hidden
 */
TopOrBottomFilter._p = TopOrBottomFilter._q();
/**
 * @hidden
 */
export class WorksheetColumnFilter extends Base {
  constructor(a, ..._rest) {
    super();
    this._c = null;
    this._d = new WorksheetRegionAddress();
    this._a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          this._c = c;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c];
          {
            let g = e[0];
            this._c = g;
          }
          this._h(d);
        }
        break;
    }
  }
  _g(a) {
    this._a = a;
  }
  _h(a) {
    let b = this._c.filterSettings.region._h;
    let c = (b._w + a);
    this._d = b._c(c)._e(c);
  }
  get columnIndex() {
    return this._d._w;
  }
  get filter() {
    return this._a;
  }
  get _e() {
    return this._d;
  }
  get _f() {
    let a = this._c.filterSettings.region != null ? this._c.filterSettings.region.firstColumn : 0;
    return this._d._w - a;
  }
  get workbook() {
    return this._c.workbook;
  }
  get worksheet() {
    return this._c;
  }
  onFilterModified() {
    this._c.filterSettings.reapplyFilters();
  }
  _b(a, b) {
    if (WorksheetRegionAddress._p(Nullable$1.toNullable(WorksheetRegionAddress.$, this._d), Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return ShiftAddressResult.d;
    }
    let c = this._d;
    let d = c;
    let e = a.e(d, false);
    d = e.p0;
    if (WorksheetRegionAddress._o(c, d)) {
      return ShiftAddressResult.d;
    }
    this._d = d;
    return ShiftAddressResult.c;
  }
  compareTo(a) {
    if (a == null) {
      return 1;
    }
    let b = this.columnIndex;
    return Base.compareSimple(b, a.columnIndex);
  }
  getDataAreaRowIndexes(a, b) {
    let c = this._c.filterSettings.sortAndFilterAreaRegion;
    if (c == null) {
      b = -1;
      a = -1;
    }
    else {
      a = c.firstRow;
      b = c.lastRow;
    }
    return {
      p0: a,
      p1: b
    };
  }
}
WorksheetColumnFilter.$t = markType(WorksheetColumnFilter, 'WorksheetColumnFilter', Base.$, [IFilterable_$type, IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export class WorksheetFilterSettings_AddFilterChangeInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = 0;
    this.b = new WorksheetRegionAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c.worksheet;
          this.c = c._f;
          this.b = this.a.filterSettings._ag;
        }
        break;
    }
  }
  get workbook() {
    return this.a.workbook;
  }
  get sheet() {
    return this.a;
  }
  get source() {
    return this.a.filterSettings;
  }
}
WorksheetFilterSettings_AddFilterChangeInfo.$t = markStruct(WorksheetFilterSettings_AddFilterChangeInfo, 'WorksheetFilterSettings_AddFilterChangeInfo', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class WorksheetFilterSettings_RemoveFilterChangeInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    this.d = 0;
    this.c = new WorksheetRegionAddress();
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.b = c.worksheet;
          this.a = c.filter;
          this.d = c.columnIndex;
          this.c = this.b.filterSettings._ag;
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b;
  }
  get source() {
    return this.b.filterSettings;
  }
}
WorksheetFilterSettings_RemoveFilterChangeInfo.$t = markStruct(WorksheetFilterSettings_RemoveFilterChangeInfo, 'WorksheetFilterSettings_RemoveFilterChangeInfo', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Exposes methods to identify a region in the wroksheet and to apply filters and optionally sort criteria to that region.
 */
export class WorksheetFilterSettings extends Base {
  constructor(a) {
    super();
    this._ap = null;
    this._aq = null;
    this._az = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._a0 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._ak = false;
    this._ac = null;
    this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    this._ai = null;
    this._ar = 0;
    this._x = 0;
    this._aa = null;
    this._am = false;
    this._al = false;
    this._ac = a;
  }
  static staticInit() {
    WorksheetFilterSettings._a = WorksheetFilterSettings._b();
  }
  /**
   * Returns the total region including the filter headers (read-only).
   * @see [[setRegion]]
   * @see [[setRegion]]
   * @see [[sortAndFilterAreaRegion]]
   */
  get region() {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return null;
    }
    return this._ac._cw(this._ay.value);
  }
  /**
   * Returns the region that the filters and sort settings are applied to (read-only).
   * @see [[setRegion]]
   * @see [[setRegion]]
   * @see [[region]]
   * @see [[sortSettings]]
   */
  get sortAndFilterAreaRegion() {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || this._ay.value._ad < 2) {
      return null;
    }
    return this._ac._cw(this._ay.value._d(this._ay.value._ac + 1));
  }
  /**
   * Gets the settings which determine how the data within the worksheet's filer region should be sorted.
   * <p class="note">
   * <B>Note:</B> Sort conditions are not constantly evaluated as data within the region changes. Sort conditions are applied to the region
   * only when they are are added or removed or when the [[reapplySortConditions]] method is called.
   * </p>
   * @see [[reapplySortConditions]]
   */
  get sortSettings() {
    if (this._aa == null) {
      this._aa = new RelativeIndexSortSettings(this, (a) => a._c(this.region));
    }
    return this._aa;
  }
  /**
   * @hidden
   */
  get _at() {
    return this._ai == null ? 0 : this._ai._k;
  }
  /**
   * @hidden
   */
  get _aj() {
    if (this._ai == null) {
      this._ai = new SortedList$2(WorksheetColumnFilter.$, WorksheetColumnFilter.$, 0);
    }
    return this._ai;
  }
  /**
   * @hidden
   */
  get _ag() {
    return WorksheetRegionAddress._r(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? this._ay.value : WorksheetRegionAddress._b;
  }
  /**
   * @hidden
   */
  set _ag(a) {
    if (!a._n) {
      if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return;
      }
    }
    else {
      if (WorksheetRegionAddress._r(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._o(this._ay.value, a)) {
        return;
      }
    }
    this._ak = false;
    this._az = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    WorksheetFilterSettings._a[1].h(WorksheetFilterSettings.$, WorksheetRegionAddress.$, this, a);
  }
  /**
   * @hidden
   */
  _bk(a) {
    if (!a._n) {
      this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
    else {
      this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, a);
    }
    if (this._ap == null && this._aq == null) {
      this._bt(this._al);
      return;
    }
    this._bp();
    try {
      if (this._aq != null) {
        let b = this._aq;
        this._aq = null;
        for (let c of fromEnum(b)) {
          if (WorksheetRegionAddress._o(c.c, a)) {
            WorksheetFilterSettings._bs(c, c.d);
          }
        }
        this._aq = null;
        this._ap = null;
      }
      if (this._ap != null) {
        let d = this._ap;
        this._ap = null;
        for (let e of fromEnum(d)) {
          if (WorksheetRegionAddress._o(e.b, a)) {
            WorksheetFilterSettings._br(e, e.c);
          }
          this._ap = null;
        }
      }
    }
    finally {
      this._bg();
      this._bt(this._al);
    }
  }
  /**
   * @hidden
   */
  get _ah() {
    return WorksheetRegionAddress._r(this._az, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? this._az.value : WorksheetRegionAddress._b;
  }
  /**
   * @hidden
   */
  set _ah(a) {
    WorksheetFilterSettings._a[2].h(WorksheetFilterSettings.$, WorksheetRegionAddress.$, this, a);
  }
  /**
   * @hidden
   */
  _bl(a) {
    if (!a._n) {
      this._az = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
    }
    else {
      this._az = Nullable$1.toNullable(WorksheetRegionAddress.$, a);
    }
  }
  /**
   * Applies an [[AverageFilter]] to the column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param type The value indicating whether to filter in values below or above the average of the data range.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
   * @see [[AverageFilter]]
   * @see [[getFilter]]
   * @see [[clearFilters]]
   */
  applyAverageFilter(relativeColumnIndex, type) {
    this._bw(relativeColumnIndex);
    let a = new WorksheetColumnFilter(1, this._ac, relativeColumnIndex);
    let b = new AverageFilter(0, a, type);
    this._a4(a, b);
    return b;
  }
  applyCustomFilter() {
    let n;
    if (arguments.length === 2) {
      n = 0;
    }
    else if (arguments.length === 4) {
      n = 1;
    }
    switch (n) {
      case 0: return this._applyCustomFilter.apply(this, arguments);
      case 1: return this._applyCustomFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyCustomFilter(a, b) {
    return this._applyCustomFilter1(a, b, null, 0);
  }
  /**
   * @hidden
   */
  _applyCustomFilter1(a, b, c, d) {
    this._bw(a);
    let e = new WorksheetColumnFilter(1, this._ac, a);
    let f = new CustomFilter(1, e, b, c, d);
    this._a4(e, f);
    return f;
  }
  /**
   * Applies an [[DatePeriodFilter]] to the column.
   * <p class="body">
   * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
   * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
   * </p>
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param type The type of date period to filter in.
   * @param value The 1-based value of the month or quarter to filter in.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
   * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
   * type is Month and value is less than 1 or greater than 12.
   * @see [[DatePeriodFilter]]
   * @see [[getFilter]]
   * @see [[clearFilter]]
   */
  applyDatePeriodFilter(relativeColumnIndex, type, value) {
    this._bw(relativeColumnIndex);
    let a = new WorksheetColumnFilter(1, this._ac, relativeColumnIndex);
    let b = new DatePeriodFilter(a, type, value);
    this._a4(a, b);
    return b;
  }
  /**
   * Applies a [[FillFilter]] to the column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param fill A [[CellFill]] by which the cells should be filtered.
   * @throws [[ArgumentNullException]] 'fill' is null.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @see [[FillFilter]]
   * @see [[getFilter]]
   * @see [[clearFilter]]
   */
  applyFillFilter(relativeColumnIndex, fill) {
    this._bw(relativeColumnIndex);
    let a = new WorksheetColumnFilter(1, this._ac, relativeColumnIndex);
    let b = new FillFilter(a, fill);
    this._a4(a, b);
    return b;
  }
  /**
   * @hidden
   */
  _k(a, b, ...c) {
    return this._n(a, b, c);
  }
  /**
   * @hidden
   */
  _n(a, b, c) {
    if (c == null) {
      throw new ArgumentNullException(0, "displayValues");
    }
    this._bw(a);
    let d = new WorksheetColumnFilter(1, this._ac, a);
    let e = new FixedValuesFilter(d);
    e.includeBlanks = b;
    for (let f of fromEnum(c)) {
      e._displayValues$i.add(f);
    }
    if (e._w) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this._a4(d, e);
    return e;
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    return this._m(a, b, 0, c);
  }
  /**
   * Applies a [[FixedValuesFilter]] to the column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param includeBlanks The value which indicates whether blank cells should be filtered in.
   * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
   * @param dateGroups The collection of fixed date groups which should be filtered in.
   * @throws [[ArgumentNullException]] 'dateGroups' is null.
   * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
   * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
   * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
   * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @see [[FixedValuesFilter]]
   * @see [[getFilter]]
   * @see [[clearFilter]]
   */
  applyFixedValuesFilter(relativeColumnIndex, includeBlanks, calendarType, ...dateGroups) {
    return this._applyFixedValuesFilter1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _applyFixedValuesFilter1(a, b, c, ...d) {
    return this._m(a, b, c, d);
  }
  /**
   * @hidden
   */
  _m(a, b, c, d) {
    if (d == null) {
      throw new ArgumentNullException(0, "dateGroups");
    }
    this._bw(a);
    let e = new WorksheetColumnFilter(1, this._ac, a);
    let f = new FixedValuesFilter(e);
    f.calendarType = c;
    f.includeBlanks = b;
    for (let g of fromEnum(d)) {
      f._dateGroups$i.add(g);
    }
    if (f._w) {
      throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_FixedValuesFilterMustAcceptAValue"));
    }
    this._a4(e, f);
    return f;
  }
  applyFontColorFilter() {
    let n;
    if (arguments.length === 2) {
      if (typeof arguments[1] === 'string' || typeCast(Color.$, arguments[1]) !== null) {
        n = 1;
      }
      else if (typeCast(WorkbookColorInfo.$, arguments[1]) !== null) {
        n = 0;
      }
      else if (arguments[1] == null) {
        n = 0;
      }
    }
    switch (n) {
      case 0: return this._applyFontColorFilter.apply(this, arguments);
      case 1:
        arguments[1] = Color.create(arguments[1]);
        return this._applyFontColorFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyFontColorFilter1(a, b) {
    return this._applyFontColorFilter(a, ExcelUtils.ag(b));
  }
  /**
   * @hidden
   */
  _applyFontColorFilter(a, b) {
    this._bw(a);
    let c = new WorksheetColumnFilter(1, this._ac, a);
    let d = new FontColorFilter(c, b);
    this._a4(c, d);
    return d;
  }
  /**
   * Applies a [[IconFilter]] to the column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param iconSet The icon set containing the icon.
   * @throws [[ArgumentException]] If the icon set is not valid.
   * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
   * @throws [[IndexOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
   * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
   * Filters cannot be applied when the header row or filter button is hidden.
   * @throws [[InvalidOperationException]] If column was removed from the table.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
   * @see [[IconFilter]]
   * @see [[Filter]]
   * @see [[clearFilter]]
   * @see [[ConditionalFormatCollection.addIconSetCondition]]
   */
  applyIconFilter(relativeColumnIndex, iconSet, iconIndex) {
    arguments[2] = wrapNullable(Number_$type, arguments[2]);
    return this._applyIconFilter$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _applyIconFilter$i(a, b, c) {
    ExcelUtils.gl(FormatConditionIconSet_$type, b);
    if (nullableNotEquals(c, null)) {
      let d = IconSetConditionalFormat._b9(b);
      if (c.value < 0 || c.value >= d.length) {
        throw new ArgumentOutOfRangeException(1, "iconIndex");
      }
    }
    return this._s(a, ExcelUtils.aj(b), nullableNotEquals(c, null) ? Nullable$1.toNullable(Number_$type, c.value) : Nullable$1.toNullable(Number_$type, null));
  }
  /**
   * @hidden
   */
  _s(a, b, c) {
    this._bw(a);
    let d = new WorksheetColumnFilter(1, this._ac, a);
    let e = new IconFilter(d, b, c);
    this._a4(d, e);
    return e;
  }
  /**
   * Applies a [[RelativeDateRangeFilter]] to the column.
   * <p class="body">
   * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
   * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
   * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
   * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
   * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
   * dates in 1999, even if the workbook is opened in 2012.
   * </p>
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
   * @param duration The duration of the full range of accepted dates.
   * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
   * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @see [[RelativeDateRangeFilter]]
   * @see [[getFilter]]
   * @see [[clearFilter]]
   */
  applyRelativeDateRangeFilter(relativeColumnIndex, offset, duration) {
    this._bw(relativeColumnIndex);
    let a = new WorksheetColumnFilter(1, this._ac, relativeColumnIndex);
    let b = new RelativeDateRangeFilter(0, a, offset, duration);
    this._a4(a, b);
    return b;
  }
  applyTopOrBottomFilter() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 3) {
      n = 1;
    }
    switch (n) {
      case 0: return this._applyTopOrBottomFilter.apply(this, arguments);
      case 1: return this._applyTopOrBottomFilter1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _applyTopOrBottomFilter(a) {
    return this._applyTopOrBottomFilter1(a, 0, 10);
  }
  /**
   * @hidden
   */
  _applyTopOrBottomFilter1(a, b, c) {
    this._bw(a);
    let d = new WorksheetColumnFilter(1, this._ac, a);
    let e = new TopOrBottomFilter(1, d, b, c);
    this._a4(d, e);
    return e;
  }
  /**
   * Applies a [[YearToDateFilter]] to the column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   * @see [[YearToDateFilter]]
   * @see [[Filter]]
   * @see [[clearFilter]]
   */
  applyYearToDateFilter(relativeColumnIndex) {
    this._bw(relativeColumnIndex);
    let a = new WorksheetColumnFilter(1, this._ac, relativeColumnIndex);
    let b = new YearToDateFilter(0, a);
    this._a4(a, b);
    return b;
  }
  /**
   * Clears the filter that is applied to a specific column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   */
  clearFilter(relativeColumnIndex) {
    let a = this._w(relativeColumnIndex);
    if (a == null) {
      return;
    }
    this._a5(a, false);
  }
  /**
   * Clears all previously applied filters
   */
  clearFilters() {
    if (this._ai == null || this._ai._k == 0) {
      return;
    }
    let a = this._a1(23);
    try {
      this._bp();
      let b = new List$1(WorksheetColumnFilter.$, 1, this._ai._j);
      for (let c of fromEnum(b)) {
        this._a5(c, true);
      }
    }
    finally {
      this._bg();
      this._bb(a);
    }
  }
  /**
   * Clears the region as well as any existing filters and sort criteria
   * @see [[setRegion]]
   * @see [[setRegion]]
   */
  clearRegion() {
    this._bm(null);
  }
  /**
   * Gets the filter that is applied to a specific column.
   * @param relativeColumnIndex A zero based column index relative to the [[region]]
   * @return The apllied filter or null if no filter was applied to this column.
   * @throws [[InvalidOperationException]] If the [[region]] was not set.
   * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
   */
  getFilter(relativeColumnIndex) {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return null;
    }
    let a = this._w(relativeColumnIndex);
    return a != null ? a.filter : null;
  }
  /**
   * Re-filters all data cells in the filter region based on the applied filters.
   * <p class="body">
   * Filters are not constantly evaluated as data within the region changes. Filters are applied to the region only when they are
   * added or removed or when the ReapplyFilters method is called.
   * </p>
   * <p class="body">
   * If no filters are applied this method will not do anything to the data.
   * </p>
   * <p class="note">
   * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
   * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
   * same row will also be hidden.
   * </p>
   * @see [[clearFilters]]
   */
  reapplyFilters() {
    if (this._ak) {
      return;
    }
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || this._ai == null || this._ay.value._ad < 2) {
      return;
    }
    let a = this._ac.workbook;
    if (a == null || a._c4) {
      return;
    }
    if (0 < this._ar) {
      this._ao = true;
      return;
    }
    this._be();
  }
  /**
   * @hidden
   */
  _be() {
    this._ao = false;
    if (this._ai == null) {
      return;
    }
    let a = this._a1(1);
    let b = new List$1(IFilterable_$type, 1, this._ai._j);
    this._ac._ib(this._ay.value._ac + 1, this._ay.value._ae, b);
    this._bb(a);
  }
  /**
   * Re-sorts all data cells in the region based on the sort conditions.
   * @see [[sortSettings]]
   */
  reapplySortConditions() {
    if (this._ak) {
      return;
    }
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || this._ay.value._ad < 2 || this._aa == null || this._aa._sortConditions$i.count == 0) {
      return;
    }
    this.sortSettings._y();
  }
  setRegion() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setRegion.apply(this, arguments);
      case 1: return this._setRegion1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setRegion(a) {
    this._setRegion1(a, this._ac._c);
  }
  /**
   * @hidden
   */
  _setRegion1(a, b) {
    this._bm(this._ac._getRegion2(a, b, null));
  }
  /**
   * @hidden
   */
  _bm(a) {
    if (this._ak) {
      return;
    }
    let b = new WorksheetRegionAddress();
    if (a != null) {
      b = a._h;
      if (WorksheetRegionAddress._r(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._o(this._ay.value, b)) {
        return;
      }
    }
    else {
      if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return;
      }
      b = WorksheetRegionAddress._b;
    }
    if (a != null) {
      if (a.worksheet != this._ac) {
        throw new InvalidOperationException(1, ExcelUtils.ef("LE_ArgumentException_RegionMustBeOnSameWorksheet"));
      }
      for (let c of fromEnum(this._ac._tables$i)) {
        if (a._s(c.wholeTableRegion)) {
          throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_OverlappingTable"));
        }
      }
      for (let d of fromEnum(this._ac._rows$i._m(a.firstRow, a.lastRow))) {
        for (let e = a._v; e <= a._w; e++) {
          if (d._bp(e) != null) {
            throw new InvalidOperationException(1, ExcelUtils.ef("LE_InvalidOperationException_OverlappingTable"));
          }
          let f = typeCast(IRegionBlockingSingleCellComponent_$type, d._c5(e));
          if (f != null) {
            f.owningValue.throwBlockingException();
          }
        }
      }
    }
    let g = this._a1(23);
    try {
      this._bp();
      this.clearFilters();
      this._a9();
    }
    finally {
      this._bg();
    }
    this._ag = b;
    this._bb(g);
  }
  /**
   * @hidden
   */
  _a3(a) {
    this._aj._m(a, a);
  }
  /**
   * @hidden
   */
  _ad(a) {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || this._ay.value._ad < 2) {
      return null;
    }
    let b = (this._ay.value._w + a.index);
    let c = (this._ay.value._ac + 1);
    return this._ac._cw(new WorksheetRegionAddress(1, c, this._ay.value._ae, b, b));
  }
  /**
   * @hidden
   */
  _ba(a) {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return;
    }
    switch (a) {
      case 0:
      case 1: return;
    }
    let b = this._ac._o;
    switch (b) {
      default: return;
      case 0:
      case 1: break;
    }
    let c = this._ac._rows$i.maxCount;
    let d = this._ac._columns$i.maxCount;
    let e = this._ay.value;
    if (e._ac >= c - 1 || e._w >= d) {
      this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      this._aa = null;
      this._ai = null;
      this._ap = null;
      this._aq = null;
      this._az = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      return;
    }
    if (e._ae >= c || e._x >= d) {
      if (e._ae >= c) {
        e = e._f(c - 1);
      }
      if (e._x >= d) {
        e = e._e((d - 1));
      }
      this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, e);
      if (this._aa != null) {
        this._aa._ak(e._af);
      }
      if (this._ai != null && this._ai._k > 0) {
        let f = new List$1(WorksheetColumnFilter.$, 0);
        for (let g of fromEnum(this._ai._h)) {
          if (g.columnIndex >= e._af) {
            f.add(g);
          }
        }
        for (let h of fromEnum(f)) {
          this._ai._c(h);
        }
      }
    }
  }
  /**
   * @hidden
   */
  _bc() {
    if (this._aa != null) {
      this._aa._al();
    }
    if (WorksheetRegionAddress._r(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      let a = false;
      for (let b of fromEnum(this._ac._tables$i)) {
        if (this._ay.value._j(b.wholeTableRegion._h)) {
          a = true;
          break;
        }
      }
      if (a) {
        this._ay = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
        this._ai = null;
      }
    }
  }
  /**
   * @hidden
   */
  _bg() {
    this._ar--;
    if (this._ar <= 0 && this._ao) {
      this._ao = false;
      this.reapplyFilters();
    }
  }
  /**
   * @hidden
   */
  _z(a, b) {
    let c = this._ac.workbook;
    let d = a.l;
    let e = this._ag;
    if (!(d._k(c) || d._l(c))) {
      if (!d._h(e)) {
        return ShiftAddressResult.d;
      }
    }
    let f = e;
    let g = true;
    let h = false;
    let i = this._ak;
    if (i) {
      if (WorksheetRegionAddress._p(this._az, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return ShiftAddressResult.d;
      }
      if (WorksheetRegionAddress._r(this._az, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        g = false;
        f = this._az.value;
      }
    }
    else {
      if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        return ShiftAddressResult.d;
      }
    }
    if (g) {
      let j = a.e(f, false);
      f = j.p0;
    }
    if (WorksheetRegionAddress._o(e, f)) {
      return ShiftAddressResult.d;
    }
    let k = f._af < 1 || f._ad < 1;
    let l = this._ac.workbook._df;
    if (k) {
      this.clearFilters();
      this._a9();
      this._be();
    }
    else {
      if (f._af != e._af) {
        if (this._aa != null) {
          this._aa._aj(f, e, a);
        }
        let m = new List$1(WorksheetColumnFilter.$, 0);
        if (WorksheetRegionAddress._r(a.y, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
          if (this._ai != null) {
            for (let n of fromEnum(this._ai)) {
              let o = n.key._e;
              if (o._w >= a.y.value._w) {
                m.add(n.key);
              }
            }
          }
        }
        if (WorksheetRegionAddress._r(a.x, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
          let p = new List$1(WorksheetColumnFilter.$, 0);
          if (this._ai != null) {
            for (let q of fromEnum(this._ai)) {
              let r = q.key._e;
              let s = r._w;
              if (s >= a.x.value._w) {
                if (s <= a.x.value._x) {
                  if (m.count > 0) {
                    m.remove(q.value);
                  }
                  p.add(q.value);
                }
                else {
                  m.add(q.value);
                }
              }
            }
          }
          if (p.count > 0) {
            h = true;
            for (let t of fromEnum(p)) {
              this._ai._c(t);
            }
          }
        }
        if (m.count > 0) {
          this._ac.workbook._df = true;
          for (let u of fromEnum(m)) {
            this._ai._c(u);
            u._b(a, b);
            this._ai._m(u, u);
          }
          this._ac.workbook._df = l;
        }
      }
    }
    if (i) {
      this._ay = k ? Nullable$1.toNullable(WorksheetRegionAddress.$, null) : Nullable$1.toNullable(WorksheetRegionAddress.$, f);
    }
    else {
      this._ag = k ? WorksheetRegionAddress._b : f;
    }
    if (h) {
      this._be();
    }
    this._ac.workbook._df = true;
    this._bt(false);
    this._ac.workbook._df = l;
    return ShiftAddressResult.c;
  }
  /**
   * @hidden
   */
  _bn() {
    this._ak = true;
    this._a0 = this._ay;
  }
  /**
   * @hidden
   */
  _bo() {
    if (!this._ak) {
      return;
    }
    this._ak = false;
    this._az = this._a0;
    this._ah = this._ag;
    this._a0 = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
  }
  /**
   * @hidden
   */
  _bp() {
    this._ar++;
  }
  /**
   * @hidden
   */
  _bq(a, b) {
    if (this._am) {
      return;
    }
    if (this._ac != null && this._ac.workbook != null && this._ac.workbook._c4) {
      let c = a.referencedRegion;
      if (c != null && c.worksheet != this._ac) {
        return;
      }
    }
    this._al = true;
    try {
      if (b && !this._ak) {
        this._bm(null);
      }
      this._bm(a.referencedRegion);
    }
    finally {
      this._al = false;
    }
  }
  /**
   * @hidden
   */
  _bu(a, b, c) {
    c = (b == null);
    let d = "=";
    if (WorksheetRegionAddress._r(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      let e = this.region;
      d += e._toString2(1, true, false, false);
    }
    let f = this._bv(d, a, b);
    b = f.p2;
    return {
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _a4(a, b) {
    a._g(b);
    let c = this._a1(38);
    if (this._ai == null) {
      this._ai = new SortedList$2(WorksheetColumnFilter.$, WorksheetColumnFilter.$, 0);
    }
    else {
      let d = a.columnIndex;
      let e = this._ai._k;
      for (let f = 0; f < e; f++) {
        let g = this._ai._h._inner[0];
        let h = g.columnIndex;
        if (h < d) {
          continue;
        }
        if (h == d) {
          this._a5(g, true);
        }
        break;
      }
    }
    this._a2(a, true);
    this._bb(c);
  }
  /**
   * @hidden
   */
  _a2(a, b) {
    let c = b ? null : this._a1(38);
    let d = this._ac.workbook;
    let e = WorksheetFilterSettings._a[0];
    let f = new WorksheetFilterSettings_AddFilterChangeInfo(1, a);
    this._ai._item(a, a);
    this.reapplyFilters();
    e.e(WorksheetFilterSettings_AddFilterChangeInfo.$, Number_$type, f, -1, f.c);
    if (c != null) {
      e.d(d, c);
    }
    this._bb(c);
  }
  /**
   * @hidden
   */
  _a5(a, b) {
    let c = b ? null : this._a1(23);
    let d = this._ac.workbook;
    let e = WorksheetFilterSettings._a[3];
    let f = new WorksheetFilterSettings_RemoveFilterChangeInfo(1, a);
    this._ai._c(a);
    this.reapplyFilters();
    e.e(WorksheetFilterSettings_RemoveFilterChangeInfo.$, Number_$type, f, -1, f.d);
    if (c != null) {
      e.d(d, c);
    }
  }
  /**
   * @hidden
   */
  _a9() {
    if (this._aa != null) {
      this._aa._sortConditions$i.clear();
    }
  }
  /**
   * @hidden
   */
  _w(a) {
    this._bw(a);
    if (this._ai == null || this._ai._k == 0 || WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      return null;
    }
    let b = (a + this._ay.value._w);
    let c = this._ai._k;
    for (let d = 0; d < c; d++) {
      let e = this._ai._h._inner[d];
      let f = e.columnIndex;
      if (f < b) {
        continue;
      }
      if (f == b) {
        return e;
      }
      break;
    }
    return null;
  }
  /**
   * @hidden
   */
  _an(a) {
    return (this._x & a) == a;
  }
  /**
   * @hidden
   */
  get _ao() {
    return this._an(1);
  }
  /**
   * @hidden
   */
  set _ao(a) {
    this._bh(1, a);
  }
  /**
   * @hidden
   */
  _bh(a, b) {
    if (b) {
      this._x |= a;
    }
    else {
      this._x &= ~a;
    }
  }
  /**
   * @hidden
   */
  _bv(a, b, c) {
    let d = NamedReferenceBase._av(13);
    if (c == null) {
      let e = null;
      if (this._ac.workbook != null) {
        e = this._ac.workbook._namedReferences$i;
      }
      c = new NamedReference(0, e, this._ac);
      c._bv = true;
      c._setFormula2(a, 1);
      c.name = d;
      c._p = true;
      c._bv = false;
    }
    else {
      if (b) {
        c._bv = true;
      }
      c._setFormula2(a, 1);
      if (b) {
        c._bv = false;
      }
    }
    return {
      p2: c
    };
  }
  /**
   * @hidden
   */
  _bt(a) {
    this._am = true;
    try {
      let b = this._ac.workbook;
      if (b != null) {
        let c = NamedReferenceBase._av(13);
        let d = typeCast(NamedReference.$, b._a2(c, this._ac));
        if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
          if (d != null) {
            b._en.remove(d);
          }
        }
        else {
          let e;
          let f = this._bu(false, d, e);
          d = f.p1;
          e = f.p2;
          if (e) {
            b._en.add(d);
          }
        }
      }
    }
    finally {
      this._am = false;
    }
  }
  /**
   * @hidden
   */
  _bw(a) {
    if (WorksheetRegionAddress._p(this._ay, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
      throw new InvalidOperationException(1, "No region specified.");
    }
    if (a < 0 || a >= this._ay.value._af) {
      throw new ArgumentOutOfRangeException(1, "relativeColumnIndex");
    }
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d, e = null, f = true, g = false, h = 0) {
    return new ChangeInfo$2(WorksheetFilterSettings.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _d($tContext, $tValue, a, b, c, d, e = null, f = true, g = false, h = 8192 | 16384) {
    return new ChangeInfo$2($tContext, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, WorksheetFilterSettings._d(WorksheetFilterSettings_AddFilterChangeInfo.$, Number_$type, "AddFilter", 38, (b) => b.c, (b, c) => WorksheetFilterSettings._br(b, c), null, true, true));
    ChangeInfo.f(a, 1, WorksheetFilterSettings._c(WorksheetRegionAddress.$, "RegionAddress", 38, (b) => b._ag, (b, c) => b._ag = c, (b, c) => b._bk(c), true, true));
    ChangeInfo.f(a, 2, WorksheetFilterSettings._c(WorksheetRegionAddress.$, "RegionAddress", 38, (b) => b._ah, (b, c) => b._ah = c, (b, c) => b._bl(c), true, false));
    ChangeInfo.f(a, 3, WorksheetFilterSettings._d(WorksheetFilterSettings_RemoveFilterChangeInfo.$, Number_$type, "RemoveFilter", 23, (b) => b.d, (b, c) => WorksheetFilterSettings._bs(b, c), null, true, true));
    return a;
  }
  /**
   * @hidden
   */
  _a1(a) {
    let b = this._ac.workbook;
    return b != null && b._cx ? b._go(this._ac, a, null) : null;
  }
  /**
   * @hidden
   */
  _bb(a) {
    if (a != null) {
      let b = this._ac.workbook;
      if (b != null) {
        b._ic(a);
      }
    }
  }
  /**
   * @hidden
   */
  static _br(a, b) {
    let c = a.sheet.filterSettings;
    if (WorksheetRegionAddress._o(c._ag, a.b)) {
      c.clearFilter(a.c);
    }
    else {
      if (c._ap == null) {
        c._ap = new List$1(WorksheetFilterSettings_AddFilterChangeInfo.$, 0);
      }
      c._ap.add(a);
    }
  }
  /**
   * @hidden
   */
  static _bs(a, b) {
    let c = a.sheet;
    let d = c.filterSettings;
    if (WorksheetRegionAddress._o(d._ag, a.c)) {
      let e = new WorksheetColumnFilter(1, c, a.d - d._ag._w);
      e._g(a.a);
      d._a2(e, false);
    }
    else {
      if (d._aq == null) {
        d._aq = new List$1(WorksheetFilterSettings_RemoveFilterChangeInfo.$, 0);
      }
      d._aq.add(a);
    }
  }
  /**
   * @hidden
   */
  onSortSettingsModified() {
    this.reapplySortConditions();
  }
  /**
   * @hidden
   */
  get culture() {
    return (((t) => t == null ? null : t.name)(this._culture$i));
  }
  /**
   * @hidden
   */
  get _culture$i() {
    return this._ac._y;
  }
  /**
   * @hidden
   */
  get sortRegion() {
    return this.sortAndFilterAreaRegion;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._ac.workbook;
  }
  /**
   * @hidden
   */
  get worksheet() {
    return this._ac;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._ac;
  }
}
WorksheetFilterSettings.$t = markType(WorksheetFilterSettings, 'WorksheetFilterSettings', Base.$, [ISortSettingsOwner_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
WorksheetFilterSettings._as = 0;
/**
 * @hidden
 */
WorksheetFilterSettings._av = 1;
/**
 * @hidden
 */
WorksheetFilterSettings._aw = 2;
/**
 * @hidden
 */
WorksheetFilterSettings._ax = 3;
/**
 * @hidden
 */
WorksheetFilterSettings._au = 3 + 1;
/**
 * @hidden
 */
WorksheetFilterSettings._a = null;
/**
 * Represents a filter which can filter in date cells if the dates occur between the start of the current year
 * and the time when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyYearToDateFilter]]
 */
export class YearToDateFilter extends DateRangeFilter {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          super(0, c);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(1, c, d, e);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _d(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(YearToDateFilter.$, a);
    if (b == null) {
      return false;
    }
    return super._d(b);
  }
  /**
   * @hidden
   */
  _v(a, b) {
    b = dateAddDays(dateGetDate(dateNow()), 1);
    a = dateFromValues(b.getFullYear(), 1, 1, 0, 0, 0, 0);
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  get__m() {
    return 23;
  }
  /**
   * @hidden
   */
  get _m() {
    return this.get__m();
  }
}
YearToDateFilter.$t = markType(YearToDateFilter, 'YearToDateFilter', DateRangeFilter.$);
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is above or below the average or standard deviation
 * for the associated range.
 */
export class AverageConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b3 = 0;
          this._b5 = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c, 11);
          this._b3 = 0;
          this._b5 = 0;
          this._b3 = d;
        }
        break;
    }
  }
  /**
   * Returns or sets a value which determines the manner in which cell values
   * are compared against the average or standard deviation for the associated
   * range.
   */
  get aboveBelow() {
    return this._b3;
  }
  /**
   * Returns or sets a value which determines the manner in which cell values
   * are compared against the average or standard deviation for the associated
   * range.
   */
  set aboveBelow(a) {
    if (a != this._b3) {
      let b = AverageConditionalFormat._b0[0].g(AverageConditionalFormat.$, FormatConditionAboveBelow_$type, this, this._b3, a);
      this._b3 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return 1;
  }
  /**
   * Returns or sets the numeric standard deviation for this condition.
   * Applicable only when the [[aboveBelow]] property is set
   * to 'AboveStandardDeviation' or 'BelowStandardDeviation'.
   */
  get numericStandardDeviation() {
    return this._b5;
  }
  /**
   * Returns or sets the numeric standard deviation for this condition.
   * Applicable only when the [[aboveBelow]] property is set
   * to 'AboveStandardDeviation' or 'BelowStandardDeviation'.
   */
  set numericStandardDeviation(a) {
    if (a != this._b5) {
      let b = AverageConditionalFormat._b0[1].g(AverageConditionalFormat.$, Number_$type, this, this._b5, a);
      this._b5 = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _b2($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(AverageConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, AverageConditionalFormat._b2(FormatConditionAboveBelow_$type, "AboveBelow", (b) => b.aboveBelow, (b, c) => b.aboveBelow = c));
    ChangeInfo.f(a, 1, AverageConditionalFormat._b2(Number_$type, "NumericStandardDeviation", (b) => b.numericStandardDeviation, (b, c) => b.numericStandardDeviation = c));
    return a;
  }
  /**
   * @hidden
   */
  _h() {
    return new AverageConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(AverageConditionalFormat.$, a);
    this._b3 = c._b3;
    this._b5 = c._b5;
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    let e = ConditionBase._at(this.workbook, a);
    if (isNaN_(e)) {
      return ConditionMatchResult.f;
    }
    let f = this._bz;
    if (isNaN_(f)) {
      let g = ExcelUtils.cf(this.workbook, this.regions);
      let h = 0;
      switch (this.aboveBelow) {
        case 4:
        case 5:
          {
            h = this.numericStandardDeviation;
            break;
          }
      }
      if (h != 0) {
        let i = ExcelUtils.ch(this.workbook, this.regions);
        let j;
        if (this.aboveBelow == 5) {
          j = -1;
        }
        else {
          j = 1;
        }
        g += (h * j * i);
      }
      f = g;
      this._bz = g;
    }
    if (isNegativeInfinity(f)) {
      return ConditionMatchResult.f;
    }
    let k;
    switch (this.aboveBelow) {
      default:
      case 0:
      case 4:
        k = e > f;
        break;
      case 1:
      case 5:
        k = e < f;
        break;
      case 2:
        k = e >= f;
        break;
      case 3:
        k = e <= f;
        break;
    }
    return k ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
AverageConditionalFormat.$t = markType(AverageConditionalFormat, 'AverageConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
AverageConditionalFormat._ca = "AboveBelow";
/**
 * @hidden
 */
AverageConditionalFormat._cb = "NumericStandardDeviation";
/**
 * @hidden
 */
AverageConditionalFormat._b6 = 0;
/**
 * @hidden
 */
AverageConditionalFormat._b9 = 1;
/**
 * @hidden
 */
AverageConditionalFormat._b7 = 2;
/**
 * @hidden
 */
AverageConditionalFormat._b0 = AverageConditionalFormat._b1();
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with no value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * <p class="body">
 * Since empty cells do not display content, the foreground-related properties of the
 * [[ConditionalFormatBase.cellFormat]] are not applicable.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export class BlanksConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 9);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__x() {
    return true;
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  _h() {
    return new BlanksConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (a == null) {
      return ConditionMatchResult.e;
    }
    let e = typeCast(String_$type, a);
    return e != null && stringIsNullOrWhiteSpace(e) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
BlanksConditionalFormat.$t = markType(BlanksConditionalFormat, 'BlanksConditionalFormat', ConditionalFormatBase.$);
/**
 * Base class for the [[DataBarConditionalFormat]], [[IconSetConditionalFormat]],
 * and [[ColorScaleConditionalFormat]] classes.
 */
export class ThresholdConditionBase extends ConditionBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super();
          this._bx = null;
        }
        break;
      case 1:
        {
          let regions = _rest[0];
          let conditionType = _rest[1];
          super(regions, conditionType);
          this._bx = null;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get__z() {
    return ConditionBase._aa(this._bx, this.worksheet);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(ThresholdConditionBase.$, a);
    if (c._bx != null) {
      this._bx = a._m(typeCast(SingleTargetFormula.$, c._bx._g()));
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    if (this._bx != null) {
      let b = this.regions.item(0);
      let c = new TempCellCalcReference(true, this.worksheet, new WorksheetCellAddress(1, b.firstRow, b.firstColumn));
      this._bx._cx(c, this.workbook);
      a(this.worksheet, this._bx);
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return this._bx != null ? 2 : 1;
  }
  /**
   * @hidden
   */
  _bb() {
    this._a5();
  }
  /**
   * @hidden
   */
  _bd() {
    this._m(this._by);
  }
  /**
   * @hidden
   */
  _bf() {
    super._bf();
    this._a5();
  }
  /**
   * @hidden
   */
  get__ah() {
    return this._bx != null;
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._bx != null) {
      let d = this._bp(a, 0, this._bx, b, c);
      this._bx = d.p2;
    }
    super._bq(a, b, c);
  }
  /**
   * @hidden
   */
  _a4(a, b) {
    if (typeof a === 'number') {
      let c = typeGetValue(a);
      if (0 == c) {
        return ((() => { let d = this._a3(b, this._bx); this._bx = d.p1; return d.ret; })());
      }
    }
    return null;
  }
  /**
   * Returns the <see cref="Excel.Formula">formula</see> which determines the values to which
   * this condition applies.
   * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
   * @see [[setFormula]]
   */
  get formula() {
    return this._bx;
  }
  /**
   * @hidden
   */
  get _by() {
    return this._bx;
  }
  /**
   * @hidden
   */
  set _by(a) {
    if (a != this._bx) {
      if (a != null && a._ch == null) {
        this._m(a);
      }
      let b = ThresholdConditionBase._bt[0].g(ThresholdConditionBase.$, SingleTargetFormula.$, this, this._bx, a);
      this._bx = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _bv($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(ThresholdConditionBase.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _bu() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, ThresholdConditionBase._bv(SingleTargetFormula.$, "FormulaInternal", (b) => b._by, (b, c) => b._by = c));
    return a;
  }
  /**
   * @hidden
   */
  _b1(a, b, c, d) {
    if (!isNaN_(c._u)) {
      return c._u;
    }
    let e = typeCast(SingleTargetFormula.$, c.formula);
    let f = null;
    if (e == null) {
      switch (c.valueType) {
        case 3: break;
        case 0: return c.value;
        case 1:
          {
            let g = this._b0(c.value, 4);
            let h = this._b0(c.value, 5);
            if (false == isInfinity(g) && false == isNaN_(g) && false == isInfinity(h) && false == isNaN_(h)) {
              let i = h - g;
              let j = c.value / 100;
              let k = g + (i * j);
              c._u = k;
              return k;
            }
            break;
          }
        case 2:
        case 5:
        case 4:
        case 7:
        case 6:
          {
            let l = this._b0(c.value, c.valueType);
            if (l > 0 && c.valueType == 6) {
              l = 0;
            }
            if (false == isInfinity(l) && false == isNaN_(l)) {
              c._u = l;
              return l;
            }
          }
          break;
        default: break;
      }
    }
    if (e != null) {
      let m = ((() => { let n = this._au(e, a, b, d); d = n.p3; return n.ret; })());
      if (!isNaN_(m)) {
        c._u = m;
        return m;
      }
    }
    if (f == null) {
      c._u = NaN;
    }
    else {
      let n;
      let o = ExcelUtils.b0(this.workbook, f, n);
      n = o.p2;
      c._u = n;
    }
    return c._u;
  }
  /**
   * @hidden
   */
  _b0(a, b) {
    let c = 0;
    switch (b) {
      case 2:
        c = Math.min(1, Math.max(0, a / 100));
        break;
      case 5:
      case 7:
        c = 1;
        break;
      case 4:
      case 6:
        c = 0;
        break;
      default: return Number.NEGATIVE_INFINITY;
    }
    return ExcelUtils.cg(this.workbook, c, this.regions);
  }
  /**
   * Assigns a new [[Formula]] to the [[formula]] property.
   * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
   * @param formula The string representation of the formula.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @see [[formula]]
   */
  setFormula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setFormula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    this._by = this._o(a, b);
  }
  /**
   * @hidden
   */
  _bz(a) {
    if (this._bx != null && a != null) {
      let b = this._bx._cf(this.workbook, a, false);
      return b._ah(this.workbook._e6);
    }
    return true;
  }
  /**
   * @hidden
   */
  _b6(a) {
    this._bx = a;
  }
}
ThresholdConditionBase.$t = markType(ThresholdConditionBase, 'ThresholdConditionBase', ConditionBase.$);
/**
 * @hidden
 */
ThresholdConditionBase._b4 = "Formula";
/**
 * @hidden
 */
ThresholdConditionBase._b2 = 0;
/**
 * @hidden
 */
ThresholdConditionBase._b3 = 1;
/**
 * @hidden
 */
ThresholdConditionBase._bt = ThresholdConditionBase._bu();
/**
 * Exposes properties which control the coloring of a [[WorksheetCell]]
 * based on the cell's value as relative to minimum, midpoint, and maximum threshold values.
 * <p class="body">
 * This class support either a 2-color or 3-color scale, as determined by the value of the
 * <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
 * parameter of the constructor.
 * </p>
 * <p class="body">
 * For 2-color scales, cells in the associated range are colored based on how their
 * value relates to the <see cref="MinimumThreshold">minimum</see> and <see cref="MaximumThreshold">maximum</see>
 * thresholds.
 * </p>
 * <p class="body">
 * For 3-color scales, cells in the associated range are colored based on how their
 * value relates to the minimum, <see cref="MidpointThreshold">midpoint</see>, and
 * maximum thresholds.
 * </p>
 * <p class="body">
 * This class supports a maximum of three separate and distinct color thresholds.
 * </p>
 * <p class="body">
 * Specifying only one threshold is not supported and may result in unexpected behavior.
 * </p>
 * <p class="body">
 * If this instance is created as a 2-color scale, the [[midpointThreshold]]
 * property is not applicable. Attempting to set a property on the object returned from
 * the MidpointThreshold property in this case will cause an exception to be thrown.
 * </p>
 * @see [[minimumThreshold]]
 * @see [[maximumThreshold]]
 * @see [[midpointThreshold]]
 * @see [[colorScaleType]]
 * @see [[ColorScaleCriterion]]
 */
export class ColorScaleConditionalFormat extends ThresholdConditionBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._cd = 0;
          this._b9 = null;
          this._b7 = null;
          this._b8 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c, 2);
          this._cd = 0;
          this._b9 = null;
          this._b7 = null;
          this._b8 = null;
          this._cd = d;
          this._b7 = new ColorScaleCriterion(this, 2);
          this._b9 = new ColorScaleCriterion(this, 0);
          this._b8 = new ColorScaleCriterion(this, 1);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _h() {
    return new ColorScaleConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a5() {
    this._cj();
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(ColorScaleConditionalFormat.$, a);
    this._cd = c._cd;
    if (c._b7 != null) {
      this._b7 = c._b7._ab(this, b);
    }
    if (c._b8 != null) {
      this._b8 = c._b8._ab(this, b);
    }
    if (c._b9 != null) {
      this._b9 = c._b9._ab(this, b);
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    super._a9(a);
    if (this._b9 != null) {
      this._b9._p(a);
    }
    if (this._b7 != null) {
      this._b7._p(a);
    }
    if (this._b8 != null) {
      this._b8._p(a);
    }
  }
  /**
   * @hidden
   */
  _bb() {
    super._bb();
    this._cj();
  }
  /**
   * @hidden
   */
  _bf() {
    super._bf();
    this._cj();
  }
  /**
   * @hidden
   */
  _bg() {
    super._bg();
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._b9 != null) {
      this._b9.shiftFormulas(a, b, c);
    }
    if (this._b7 != null) {
      this._b7.shiftFormulas(a, b, c);
    }
    if (this._b8 != null) {
      this._b8.shiftFormulas(a, b, c);
    }
    super._bq(a, b, c);
  }
  /**
   * Returns a [[ColorScaleType]] value which
   * identifies this instance as a 2-color or 3-color scale.
   * <p class="body">
   * A [[ColorScaleConditionalFormat]] instance which is created with
   * the 'TwoColor' value does not support the [[midpointThreshold]];
   * attempting to set a property on the object retuned from the MidpointThreshold
   * property will cause an exception to be thrown.
   * </p>
   */
  get colorScaleType() {
    return this._cd;
  }
  /**
   * Returns a [[ColorScaleCriterion]] object which defines the properties
   * of the minimum threshold for this instance.
   * <p class="body">
   * The minimum threshold defines the criteria for the lowest or minimum value
   * across the associated range.
   * </p>
   * <p class="body">
   * For a 2-color scale, the [[maximumThreshold]] defines the next "stop";
   * for a 3-color scale, the [[midpointThreshold]] property defines the next stop.
   * </p>
   * <p class="body">
   * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
   * minimum threshold, and will cause an exception to be thrown:
   * </p>
   * <p class="body">
   * <ul>
   * <li>HighestValue</li>
   * <li>AutomaticMinimum</li>
   * <li>AutomaticMaximum</li>
   * </ul>
   * </p>
   * @see [[midpointThreshold]]
   * @see [[maximumThreshold]]
   */
  get minimumThreshold() {
    return this._b9;
  }
  /**
   * Returns a [[ColorScaleCriterion]] object which defines the properties
   * of the maximum threshold for this instance.
   * <p class="body">
   * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
   * maximum threshold, and will cause an exception to be thrown:
   * </p>
   * <p class="body">
   * <ul>
   * <li>LowestValue</li>
   * <li>AutomaticMinimum</li>
   * <li>AutomaticMaximum</li>
   * </ul>
   * </p>
   * @see [[midpointThreshold]]
   * @see [[minimumThreshold]]
   */
  get maximumThreshold() {
    return this._b7;
  }
  /**
   * Returns a [[ColorScaleCriterion]] object which defines the properties
   * of the midpoint threshold for this instance.
   * <p class="body" >
   * The midpoint threshold is only supported for a [[ColorScaleConditionalFormat]]
   * instance with a value of 'ThreeColor' specified for the <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
   * parameter.
   * </p>
   * <p class="body" >
   * Attempting to set a property on the instance returned from this property will cause
   * an exception to be thrown if this instance was created as a 2-color scale.
   * </p>
   * <p class="body">
   * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
   * midpoint threshold, and will cause an exception to be thrown:
   * </p>
   * <p class="body">
   * <ul>
   * <li>LowestValue</li>
   * <li>HighestValue</li>
   * <li>AutomaticMinimum</li>
   * <li>AutomaticMaximum</li>
   * </ul>
   * </p>
   * @see [[minimumThreshold]]
   * @see [[maximumThreshold]]
   */
  get midpointThreshold() {
    return this._b8;
  }
  /**
   * @hidden
   */
  get__z() {
    if (super.get__z()) {
      return true;
    }
    if (this._b9 != null && this._b9._an) {
      return true;
    }
    if (this._cd == 1 && this._b8 != null && this._b8._an) {
      return true;
    }
    if (this._b7 != null && this._b7._an) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _cj() {
    if (this._b9 != null) {
      this._b9._m();
    }
    if (this._b8 != null) {
      this._b8._m();
    }
    if (this._b7 != null) {
      this._b7._m();
    }
  }
  /**
   * @hidden
   */
  _cf(a, b, c) {
    let d = b - a;
    if (d == 0) {
      return a;
    }
    let e = truncate((d * c));
    return (a + e);
  }
  /**
   * @hidden
   */
  _ck(a, b) {
    let c = this.workbook;
    if (c != null && !c._c4) {
      let d = null;
      switch (a._ad) {
        case 0:
          d = "MinimumThreshold";
          break;
        case 2:
          d = "MaximumThreshold";
          break;
        case 1:
          if (this._cd == 0) {
            throw new BaseError(1, "This instance supports only the minimum and maximum thresholds.");
          }
          d = "MidpointThreshold";
          break;
      }
      this._bi(stringFormat("{0}.{1}", d, b));
    }
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (!this._bz(d)) {
      return ConditionMatchResult.f;
    }
    let e = ConditionBase._as(this.workbook, a, d, null);
    if (isNaN_(e)) {
      return ConditionMatchResult.f;
    }
    let f = this._b1(b, c, this.minimumThreshold._b, d);
    let g = this._b1(b, c, this.maximumThreshold._b, d);
    if (isNaN_(f) || isNaN_(g)) {
      return ConditionMatchResult.f;
    }
    let h = null;
    if (g <= e) {
      h = this.maximumThreshold.formatColor;
    }
    else if (f >= e) {
      h = this.minimumThreshold.formatColor;
    }
    else {
      let i = null;
      let j = null;
      let k = this.colorScaleType == 1 ? this._b1(b, c, this.midpointThreshold._b, d) : NaN;
      let l = 0;
      let m = 0;
      if (!isNaN_(k)) {
        if (k == e) {
          i = j = this.midpointThreshold.formatColor;
        }
        else if (k > e) {
          l = f;
          m = k;
          i = this.minimumThreshold.formatColor;
          j = this.midpointThreshold.formatColor;
        }
        else {
          l = k;
          m = g;
          i = this.midpointThreshold.formatColor;
          j = this.maximumThreshold.formatColor;
        }
      }
      else {
        l = f;
        m = g;
        i = this.minimumThreshold.formatColor;
        j = this.maximumThreshold.formatColor;
      }
      let n = m - l;
      if (WorkbookColorInfo.l_op_Equality(i, null)) {
        h = j;
      }
      else if (WorkbookColorInfo.l_op_Equality(j, null)) {
        h = i;
      }
      else if (WorkbookColorInfo.l_op_Equality(i, j) || n == 0) {
        h = i;
      }
      else {
        let o = i._getResolvedColor1(this.workbook);
        let p = j._getResolvedColor1(this.workbook);
        let q = e - l;
        let r = Math.abs(q / n);
        let s = Color.u(this._cf(o.l, p.l, r), this._cf(o.o, p.o, r), this._cf(o.n, p.n, r), this._cf(o.m, p.m, r));
        h = new WorkbookColorInfo(s);
      }
    }
    if (WorkbookColorInfo.l_op_Equality(h, null)) {
      return ConditionMatchResult.f;
    }
    return new ConditionMatchResult(0, h);
  }
}
ColorScaleConditionalFormat.$t = markType(ColorScaleConditionalFormat, 'ColorScaleConditionalFormat', ThresholdConditionBase.$);
/**
 * @hidden
 */
ColorScaleConditionalFormat._ci = "MinimumThreshold";
/**
 * @hidden
 */
ColorScaleConditionalFormat._cg = "MaximumThreshold";
/**
 * @hidden
 */
ColorScaleConditionalFormat._ch = "MidpointThreshold";
/**
 * Base class for the [[IconCriterion]] and [[ColorScaleCriterion]] classes.
 * @see [[IconCriterion]]
 * @see [[ColorScaleCriterion]]
 */
export class CriterionBase extends Base {
  constructor() {
    super();
    this._a = null;
  }
  /**
   * Returns the numeric value for this instance.
   * <p class="body">
   * This property is read-only; to assign a value type, use the
   * [[setValue]] or
   * [[setValue]]
   * methods.
   * </p>
   * <p class="body">
   * Note that the unit of measure for this value is determined by the
   * [[valueType]] property; for example, when <i>ValueType</i>
   * is set to <i>Number</i>, the value is interpreted as a numeric value,
   * but when set to <i>Percentage</i>, it is interpreted as a percentage.
   * </p>
   * @see [[valueType]]
   * @see [[formula]]
   * @see [[setValue]]
   */
  get value() {
    this._n();
    return this._a.value;
  }
  /**
   * @hidden
   */
  get _b() {
    this._n();
    return this._a;
  }
  /**
   * Returns a [[FormatConditionValueType]] value which specifies
   * the manner in which the threshold values for this instance are determined.
   * <p class="body">
   * This property is read-only; to assign one of the following value types, use the
   * [[setValue]] method:
   * </p>
   * <p class="body">
   * <ul>
   * <li>AutomaticLowest</li>
   * <li>AutomaticHighest</li>
   * <li>LowestValue</li>
   * <li>HighestValue</li>
   * </ul>
   * </p>
   * <p class="body">
   * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
   * [[setValue]] method.
   * </p>
   * <p class="body">
   * To assign a [[formula]], use the [[setFormula]] method.
   * </p>
   * @see [[setValue]]
   */
  get valueType() {
    this._n();
    return this._a.valueType;
  }
  /**
   * Returns the <see cref="Excel.Formula">formula</see> which determines
   * whether cell values meet the criteria defined by the associated condition.
   * <p class="body">
   * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
   * </p>
   * <p class="body">
   * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
   * method.
   * </p>
   * @see [[setFormula]]
   */
  get formula() {
    this._n();
    return this._a.formula;
  }
  /**
   * @hidden
   */
  _o(a, b) {
    if (a._a != null) {
      this._a = a._a._d(this._d, runOn(this, this._q), runOn(this, this._w));
    }
  }
  /**
   * @hidden
   */
  _p(a) {
    if (this._a != null && this._a.formula != null) {
      a(this._d.worksheet, this._a.formula);
    }
  }
  /**
   * Assigns the specified formula to the [[formula]] property, and assigns
   * a value of <i>Formula</i> to the [[valueType]] property.
   * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
   * the value returned from the formula is interpreted. This parameter is optional and
   * defaults to 'Formula'.
   * @see [[formula]]
   * @see [[valueType]]
   * @see [[Formula]]
   */
  setFormula(formula, cellReferenceMode, valueType) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    arguments[2] = (arguments[2] !== void 0 ? arguments[2] : 3);
    return this._setFormula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null), c = 3) {
    this._n();
    this._a._setFormula$i(a, b, c);
  }
  setValue() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setValue.apply(this, arguments);
      case 1: return this._setValue1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setValue1(a, b) {
    this._n();
    this._b._setValue1(a, b);
  }
  /**
   * @hidden
   */
  _setValue(a) {
    this._n();
    this._b._setValue(a);
  }
  /**
   * @hidden
   */
  _v(a, b, c) {
    if (this._a != null) {
      this._a.shiftFormulas(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _j(a, b) {
    return null;
  }
  /**
   * @hidden
   */
  _n() {
    if (this._a == null) {
      this._a = new ConditionValue(this._d, runOn(this, this._q), runOn(this, this._w));
    }
  }
  /**
   * @hidden
   */
  _m() {
    if (this._a != null) {
      this._a._ac();
    }
  }
  /**
   * @hidden
   */
  _r(a) {
    this._q(this._a, a);
  }
  /**
   * @hidden
   */
  _g() {
    return this._a != null && this._a._m();
  }
  /**
   * @hidden
   */
  _f() {
    return this._a != null && this._a._m();
  }
  /**
   * @hidden
   */
  shiftFormulas(callback, shiftOperation, operationOverride) {
    this._v(callback, shiftOperation, operationOverride);
  }
  /**
   * @hidden
   */
  undoFormulaShift(context, originalFormula) {
    return this._j(context, originalFormula);
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._d.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._d.worksheet;
  }
}
CriterionBase.$t = markType(CriterionBase, 'CriterionBase', Base.$, [ISupportFormulaShifts_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
CriterionBase._k = "Value";
/**
 * @hidden
 */
CriterionBase._i = "Formula";
/**
 * @hidden
 */
CriterionBase._l = "ValueType";
/**
 * Defines the criterion for a [[ColorScaleConditionalFormat]] threshold.
 * @see [[ColorScaleConditionalFormat.minimumThreshold]]
 * @see [[ColorScaleConditionalFormat.maximumThreshold]]
 * @see [[ColorScaleConditionalFormat.midpointThreshold]]
 */
export class ColorScaleCriterion extends CriterionBase {
  constructor(a, b) {
    super();
    this._aa = null;
    this._ac = 0;
    this._aj = null;
    this._aa = a;
    this._ac = b;
    switch (this._ac) {
      case 0:
        this._b._ad(4);
        break;
      case 1:
        this._b._ae(50, 2);
        break;
      case 2:
        this._b._ad(5);
        break;
    }
  }
  /**
   * @hidden
   */
  get__d() {
    return this._aa;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the color
   * information for the threshold associated with this instance.
   * <p class="body">
   * This property returns null if not explicitly set by the caller.
   * </p>
   */
  get formatColor() {
    return this._aj;
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the color
   * information for the threshold associated with this instance.
   * <p class="body">
   * This property returns null if not explicitly set by the caller.
   * </p>
   */
  set formatColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._aj)) {
      let b = ColorScaleCriterion._x[0].g(ColorScaleCriterion.$, WorkbookColorInfo.$, this, this._aj, a);
      this._aj = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _al() {
    return WorkbookColorInfo.l_op_Inequality(this._aj, null) ? this._aj : this._am(this._ad, this._aa.colorScaleType);
  }
  /**
   * @hidden
   */
  get _ad() {
    return this._ac;
  }
  /**
   * @hidden
   */
  _ab(a, b) {
    let c = new ColorScaleCriterion(a, this._ac);
    c._o(this, b);
    return c;
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(ColorScaleCriterion.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _y() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, ColorScaleCriterion._z(WorkbookColorInfo.$, "FormatColor", (b) => b.formatColor, (b, c) => b.formatColor = c));
    return a;
  }
  /**
   * @hidden
   */
  _o(a, b) {
    super._o(a, b);
    let c = typeCast(ColorScaleCriterion.$, a);
    this._ac = c._ac;
    this._aj = b ? ExcelUtils.ah(c._aj, c._aa != null ? c._aa.workbook : null) : c._aj;
  }
  /**
   * @hidden
   */
  _q(a, b) {
    this._aa._ck(this, b);
  }
  /**
   * @hidden
   */
  _w(a, b, c) {
    let d = this._ad == 0;
    let e = this._ad == 2;
    let f = e;
    let g = d;
    let h = false;
    switch (c) {
      case 5:
        h = (f == false);
        break;
      case 4:
        h = (g == false);
        break;
      case 6:
      case 7:
        h = true;
        break;
      default: break;
    }
    if (h) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_InvalidValueType", enumGetBox(FormatConditionValueType_$type, c)));
    }
  }
  /**
   * @hidden
   */
  _ao() {
    return WorkbookColorInfo.l_op_Inequality(this._aj, null);
  }
  /**
   * @hidden
   */
  _f() {
    return super._f() || this._ao();
  }
  /**
   * @hidden
   */
  get _an() {
    return ConditionBase._aa(this.formula, this._d.worksheet);
  }
  /**
   * @hidden
   */
  _am(a, b) {
    let c = null;
    switch (b) {
      case 0:
        switch (a) {
          case 0:
            c = ColorScaleCriterion._ah;
            break;
          case 2:
            c = ColorScaleCriterion._ae;
            break;
        }
        break;
      case 1:
        switch (a) {
          case 0:
            c = ColorScaleCriterion._ai;
            break;
          case 1:
            c = ColorScaleCriterion._ag;
            break;
          case 2:
            c = ColorScaleCriterion._af;
            break;
        }
        break;
    }
    return c;
  }
  /**
   * Returns the string representation of this instance.
   */
  toString() {
    return stringFormat("{0}: {1}", enumGetBox(ColorScaleCriterionThreshold_$type, this._ad), this.value);
  }
}
ColorScaleCriterion.$t = markType(ColorScaleCriterion, 'ColorScaleCriterion', CriterionBase.$);
/**
 * @hidden
 */
ColorScaleCriterion._ar = "FormatColor";
/**
 * @hidden
 */
ColorScaleCriterion._ap = 0;
/**
 * @hidden
 */
ColorScaleCriterion._aq = 1;
/**
 * @hidden
 */
ColorScaleCriterion._x = ColorScaleCriterion._y();
/**
 * @hidden
 */
ColorScaleCriterion._ah = new WorkbookColorInfo(Color.u(255, 255, 113, 40));
/**
 * @hidden
 */
ColorScaleCriterion._ae = new WorkbookColorInfo(Color.u(255, 255, 239, 156));
/**
 * @hidden
 */
ColorScaleCriterion._ai = new WorkbookColorInfo(Color.u(255, 248, 105, 107));
/**
 * @hidden
 */
ColorScaleCriterion._ag = new WorkbookColorInfo(Color.u(255, 255, 235, 132));
/**
 * @hidden
 */
ColorScaleCriterion._af = new WorkbookColorInfo(Color.u(255, 99, 190, 123));
/**
 * @hidden
 */
export class ConditionalFormatCollection_PriorityConditionComparer extends Base {
  compare(a, b) {
    if (a == null) {
      return b == null ? 0 : -1;
    }
    else if (b == null) {
      return 1;
    }
    return Base.compareSimple(a.priority, b.priority);
  }
}
ConditionalFormatCollection_PriorityConditionComparer.$t = markType(ConditionalFormatCollection_PriorityConditionComparer, 'ConditionalFormatCollection_PriorityConditionComparer', Base.$, [IComparer$1_$type.specialize(ConditionBase.$)]);
ConditionalFormatCollection_PriorityConditionComparer._a = new ConditionalFormatCollection_PriorityConditionComparer();
/**
 * @hidden
 */
export class ConditionBase_ShiftChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b.worksheet;
  }
  get source() {
    return this.b;
  }
}
ConditionBase_ShiftChangeContext.$t = markStruct(ConditionBase_ShiftChangeContext, 'ConditionBase_ShiftChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
export class ConditionValueInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.h = 0;
    this.a = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.h = c;
          this.a = d;
        }
        break;
    }
  }
  equals(a) {
    if (typeCast(ConditionValueInfo.$, a) !== null) {
      return a.h == this.h && a.a == this.a;
    }
    return false;
  }
  getHashCode() {
    return (this.h) ^ Base.getHashCodeStatic(this.a);
  }
  toString() {
    return stringFormat("Value: {0}, ValueType: {1}", this.h, enumGetBox(FormatConditionValueType_$type, this.a));
  }
  static b(a, b) {
    return a.equals(b);
  }
  static c(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return ConditionValueInfo.b(a.value, b.value);
  }
  static d(a, b) {
    return !(ConditionValueInfo.b(a, b));
  }
  static e(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return ConditionValueInfo.d(a.value, b.value);
  }
}
ConditionValueInfo.$t = markStruct(ConditionValueInfo, 'ConditionValueInfo');
/**
 * Exposes properties which define the value and its unit of measure
 * for a conditional format threshold.
 * <p class="body">
 * When the [[valueType]] property is set to <i>Number</i>, <i>Percentage</i>,
 * or <i>Percentile</i>, only the [[value]] property is applicable.
 * </p>
 * <p class="body">
 * Similarly, the [[formula]] property is only applicable when<i>ValueType</i>
 * is set to <i>Formula</i>.
 * </p>
 * <p class="body">
 * For the following settings of <i>ValueType</i>, neither <i>Value</i> nor <i>Formula</i>
 * is applicable, and the actual threshold is derived based on the highest and/or lowest
 * values in the associated range:
 * </p>
 * <p class="body">
 * <ul>
 * <li>AutomaticMinimum</li>
 * <li>AutomaticMaximum</li>
 * <li>LowestValue</li>
 * <li>HighestValue</li>
 * </ul>
 * </p>
 * @see [[value]]
 * @see [[formula]]
 * @see [[setFormula]]
 */
export class ConditionValue extends Base {
  constructor(a, b, c) {
    super();
    this._k = null;
    this._l = null;
    this._h = null;
    this._t = NaN;
    this._e = new ConditionValueInfo(1, 0, 0);
    this._j = null;
    this._k = b;
    this._l = c;
    this._h = a;
  }
  /**
   * @hidden
   */
  get _u() {
    return this._t;
  }
  /**
   * @hidden
   */
  set _u(a) {
    this._t = a;
  }
  /**
   * Returns the <see cref="Excel.Formula">formula</see> which determines
   * whether cell values meet the criteria defined by the associated condition.
   * <p class="body">
   * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
   * </p>
   * <p class="body">
   * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
   * method.
   * </p>
   * @see [[setFormula]]
   */
  get formula() {
    return this._j;
  }
  /**
   * Returns the numeric value for this instance.
   * <p class="body">
   * This property is read-only; to assign a value type, use the
   * [[setValue]] or
   * [[setValue]]
   * methods.
   * </p>
   * <p class="body">
   * Note that the unit of measure for this value is determined by the
   * [[valueType]] property; for example, when <i>ValueType</i>
   * is set to <i>Number</i>, the value is interpreted as a numeric value,
   * but when set to <i>Percentage</i>, it is interpreted as a percentage.
   * </p>
   * @see [[valueType]]
   * @see [[formula]]
   * @see [[setValue]]
   */
  get value() {
    return this._e.h;
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e;
  }
  /**
   * @hidden
   */
  set _f(a) {
    if (ConditionValueInfo.d(a, this._e)) {
      let b = ConditionValue._a[0].g(ConditionValue.$, ConditionValueInfo.$, this, this._e, a);
      this._e = b.p1;
    }
  }
  /**
   * Returns a [[FormatConditionValueType]] value which specifies
   * the manner in which the threshold values for this instance are determined.
   * <p class="body">
   * This property is read-only; to assign one of the following value types, use the
   * [[setValue]] method:
   * </p>
   * <p class="body">
   * <ul>
   * <li>AutomaticLowest</li>
   * <li>AutomaticHighest</li>
   * <li>LowestValue</li>
   * <li>HighestValue</li>
   * </ul>
   * </p>
   * <p class="body">
   * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
   * [[setValue]] method.
   * </p>
   * <p class="body">
   * To assign a [[formula]], use the [[setFormula]] method.
   * </p>
   * @see [[setValue]]
   */
  get valueType() {
    return this._e.a;
  }
  /**
   * @hidden
   */
  _ac() {
    this._t = NaN;
  }
  /**
   * @hidden
   */
  _d(a, b, c) {
    let d = new ConditionValue(a, b, c);
    if (this._j != null) {
      d._j = typeCast(SingleTargetFormula.$, this._j._g());
    }
    d._e = this._e;
    return d;
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(ConditionValue.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, ConditionValue._c(ConditionValueInfo.$, "ValueInternal", (b) => b._f, (b, c) => b._f = c));
    return a;
  }
  /**
   * @hidden
   */
  _ad(a) {
    this._ae(NaN, a);
  }
  /**
   * @hidden
   */
  _ae(a, b) {
    this._al(a, b, true);
  }
  /**
   * @hidden
   */
  _af(a) {
    this._t = NaN;
    if (this._k != null) {
      this._k(this, a);
    }
  }
  /**
   * @hidden
   */
  _ag(a) {
    this._af(a);
  }
  /**
   * @hidden
   */
  _o() {
    return this._e.h != 0;
  }
  /**
   * @hidden
   */
  _n() {
    return this._j != null;
  }
  /**
   * @hidden
   */
  _p() {
    return true;
  }
  /**
   * @hidden
   */
  _m() {
    return this._n() || this._o() || this._p();
  }
  /**
   * Assigns the specified formula to the [[formula]] property, and assigns
   * a value of <i>Formula</i> to the [[valueType]] property.
   * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
   * the value returned from the formula is interpreted. This parameter is optional and
   * defaults to 'Formula'.
   * @see [[formula]]
   * @see [[valueType]]
   * @see [[Formula]]
   */
  setFormula(formula, cellReferenceMode, valueType) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    arguments[2] = (arguments[2] !== void 0 ? arguments[2] : 3);
    return this._setFormula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null), c = 3) {
    let d = this._h.workbook;
    this._j = ConditionBase._n(a, d, b);
    if (this._l != null) {
      this._l(this, NaN, c);
    }
    this._f = new ConditionValueInfo(1, NaN, c);
    this._af("Formula");
  }
  /**
   * @hidden
   */
  _ai(a, b = 3) {
    this._j = a;
    this._f = new ConditionValueInfo(1, NaN, b);
  }
  setValue() {
    let n;
    if (arguments.length === 1) {
      n = 0;
    }
    else if (arguments.length === 2) {
      n = 1;
    }
    switch (n) {
      case 0: return this._setValue.apply(this, arguments);
      case 1: return this._setValue1.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setValue1(a, b) {
    this._al(a, b);
  }
  /**
   * @hidden
   */
  _setValue(a) {
    this._al(NaN, a);
  }
  /**
   * @hidden
   */
  _al(a, b, c = false) {
    if (this._l != null) {
      this._l(this, a, b);
    }
    switch (b) {
      case 0:
      case 1:
      case 2:
        if (isNaN_(a) || isInfinity(a)) {
          throw new ArgumentException(1, ExcelUtils.eg("LE_SetValue_Numeric", enumGetBox(FormatConditionValueType_$type, b)));
        }
        switch (b) {
          case 1:
          case 2:
            if (ConditionBase._ae(a) == false) {
              let d = b == 1 ? "LE_PercentageValueOutOfRange" : "LE_PercentileValueOutOfRange";
              throw new ArgumentOutOfRangeException(1, ExcelUtils.eg(d, a));
            }
            break;
        }
        if (c) {
          this._e = new ConditionValueInfo(1, a, b);
        }
        else {
          this._f = new ConditionValueInfo(1, a, b);
        }
        break;
      case 6:
      case 7:
      case 4:
      case 5:
        if (!isNaN_(a)) {
          throw new ArgumentException(1, ExcelUtils.eg("LE_SetValue_NonNumeric", enumGetBox(FormatConditionValueType_$type, b)));
        }
        if (c) {
          this._e = new ConditionValueInfo(1, NaN, b);
        }
        else {
          this._f = new ConditionValueInfo(1, NaN, b);
        }
        break;
      case 3: throw new ArgumentException(1, ExcelUtils.eg("LE_SetValue_Formula", enumGetBox(FormatConditionValueType_$type, b)));
    }
  }
  /**
   * Returns the string representation of this instance.
   */
  toString() {
    switch (this._e.a) {
      case 3: return typeCast(Formula.$, this.formula) !== null ? this.formula._toString() : EnumUtil.getName(FormatConditionValueType_$type, (3));
      case 0:
      case 1:
      case 2: return stringFormat("{0} ({1})", enumGetBox(FormatConditionValueType_$type, this._e.a), this.value);
      default: return EnumUtil.getName(FormatConditionValueType_$type, this._e.a);
    }
  }
  /**
   * @hidden
   */
  static _s(a, b, c) {
    b = Nullable$1.toNullable(Number_$type, null);
    c = Nullable$1.toNullable(Number_$type, null);
    let d = 0;
    if (((() => { let e = ConditionValue._r(a, d); d = e.p1; return e.ret; })())) {
      b = Nullable$1.toNullable(Number_$type, d);
      return {
        ret: true,
        p1: b,
        p2: c
      };
    }
    let e = 0;
    if (((() => { let f = ConditionValue._q(a, e); e = f.p1; return f.ret; })())) {
      c = Nullable$1.toNullable(Number_$type, e);
      return {
        ret: true,
        p1: b,
        p2: c
      };
    }
    return {
      ret: false,
      p1: b,
      p2: c
    };
  }
  /**
   * @hidden
   */
  static _r(a, b) {
    b = 0;
    return {
      ret: ((() => { let c = tryParseInt32_1(a, b); b = c.p1; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _q(a, b) {
    b = 0;
    return {
      ret: a != null && ((() => { let c = tryParseNumber(a, b); b = c.p1; return c.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  shiftFormulas(callback, shiftOperation, operationOverride) {
    if (this._j != null) {
      let a = this._j._ch;
      if (a != null) {
        this._j._cx(null, this._h.workbook);
      }
      let b = this._j._toString2(1, this._h.workbook._e6);
      if (this._j._av(this._h.worksheet, shiftOperation, 0)) {
        callback(this, null, b);
      }
      if (a != null) {
        this._j._cx(a, this._h.workbook);
      }
    }
  }
  /**
   * @hidden
   */
  undoFormulaShift(context, originalFormula) {
    let a = this._j != null ? this._j._toString2(1, this.workbook._e6) : null;
    this._j = ConditionBase._n(originalFormula, this.workbook, Nullable$1.toNullable(CellReferenceMode_$type, 1));
    return a;
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._h.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._h.worksheet;
  }
}
ConditionValue.$t = markType(ConditionValue, 'ConditionValue', Base.$, [ISupportFormulaShifts_$type, IChangeInfoContext_$type]);
/**
 * @hidden
 */
ConditionValue._y = "Formula";
/**
 * @hidden
 */
ConditionValue._aa = "Value";
/**
 * @hidden
 */
ConditionValue._ab = "ValueType";
/**
 * @hidden
 */
ConditionValue._x = 0;
/**
 * @hidden
 */
ConditionValue._w = 1;
/**
 * @hidden
 */
ConditionValue._a = ConditionValue._b();
/**
 * Exposes properties which displays data bars in a [[WorksheetCell]]
 * based on the cell's value as relative to the associated range.
 * <p class="body">
 * </p>
 */
export class DataBarConditionalFormat extends ThresholdConditionBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._cm = null;
          this._ce = 0;
          this._cn = null;
          this._co = null;
          this._ci = 0;
          this._cg = 0;
          this._ca = null;
          this._cb = null;
          this._ck = null;
          this._c2 = 0;
          this._c3 = 0;
          this._cy = false;
          this._cx = false;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 3);
          this._cm = null;
          this._ce = 0;
          this._cn = null;
          this._co = null;
          this._ci = 0;
          this._cg = 0;
          this._ca = null;
          this._cb = null;
          this._ck = null;
          this._c2 = 0;
          this._c3 = 0;
          this._cy = false;
          this._cx = false;
          this._c3 = 0;
          this._c2 = 100;
          this._cy = true;
          this._cx = false;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _h() {
    return new DataBarConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a5() {
    this._dx();
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(DataBarConditionalFormat.$, a);
    this._cm = b ? ExcelUtils.ah(c._cm, this.workbook) : c._cm;
    this._ce = c._ce;
    this._cn = b ? ExcelUtils.ah(c._cn, this.workbook) : c._cn;
    this._co = b ? ExcelUtils.ah(c._co, this.workbook) : c._co;
    this._ci = c._ci;
    this._cg = c._cg;
    this._c2 = c._c2;
    this._c3 = c._c3;
    this._ca = c._ca;
    this._cb = c._cb;
    this._cx = c._cx;
    this._cy = c._cy;
    if (c._ck != null) {
      this._ck = c._ck._k(this, b);
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    super._a9(a);
    if (this._ca != null && this._ca.formula != null) {
      a(this.worksheet, this._ca.formula);
    }
    if (this._cb != null && this._cb.formula != null) {
      a(this.worksheet, this._cb.formula);
    }
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._ca != null) {
      this._ca.shiftFormulas(a, b, c);
    }
    if (this._cb != null) {
      this._cb.shiftFormulas(a, b, c);
    }
    super._bq(a, b, c);
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * color of the axis.
   */
  get axisColor() {
    return this._cm;
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * color of the axis.
   */
  set axisColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._cm)) {
      let b = DataBarConditionalFormat._b7[0].g(DataBarConditionalFormat.$, WorkbookColorInfo.$, this, this._cm, a);
      this._cm = b.p1;
    }
  }
  /**
   * Returns or sets a [[DataBarAxisPosition]] value which determines
   * whether an axis is displayed.
   * @see [[DataBarAxisPosition]]
   */
  get axisPosition() {
    return this._ce;
  }
  /**
   * Returns or sets a [[DataBarAxisPosition]] value which determines
   * whether an axis is displayed.
   * @see [[DataBarAxisPosition]]
   */
  set axisPosition(a) {
    if (a != this._ce) {
      let b = DataBarConditionalFormat._b7[1].g(DataBarConditionalFormat.$, DataBarAxisPosition_$type, this, this._ce, a);
      this._ce = b.p1;
    }
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * fill color of the data bar.
   */
  get barColor() {
    return this._co;
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * fill color of the data bar.
   */
  set barColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._co)) {
      let b = DataBarConditionalFormat._b7[2].g(DataBarConditionalFormat.$, WorkbookColorInfo.$, this, this._co, a);
      this._co = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _cv() {
    if (WorkbookColorInfo.l_op_Inequality(this._co, null)) {
      return this._co;
    }
    return DataBarConditionalFormat._cq;
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * border color of the data bar.
   */
  get barBorderColor() {
    return this._cn;
  }
  /**
   * Returns or sets a [[WorkbookColorInfo]] object which defines the
   * border color of the data bar.
   */
  set barBorderColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._cn)) {
      let b = DataBarConditionalFormat._b7[3].g(DataBarConditionalFormat.$, WorkbookColorInfo.$, this, this._cn, a);
      this._cn = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _ct() {
    if (WorkbookColorInfo.l_op_Inequality(this._cn, null)) {
      return this._cn;
    }
    else {
      return DataBarConditionalFormat._cw;
    }
  }
  /**
   * @hidden
   */
  static get _cw() {
    return DataBarConditionalFormat._cp;
  }
  /**
   * Returns or sets a [[DataBarFillType]] value which determines
   * whether the data bar is filled with a solid color or a gradient.
   */
  get barFillType() {
    return this._ci;
  }
  /**
   * Returns or sets a [[DataBarFillType]] value which determines
   * whether the data bar is filled with a solid color or a gradient.
   */
  set barFillType(a) {
    if (a != this._ci) {
      let b = DataBarConditionalFormat._b7[4].g(DataBarConditionalFormat.$, DataBarFillType_$type, this, this._ci, a);
      this._ci = b.p1;
    }
  }
  /**
   * Returns or sets a [[DataBarDirection]] value which determines
   * the direction in which the data bar extends.
   */
  get direction() {
    return this._cg;
  }
  /**
   * Returns or sets a [[DataBarDirection]] value which determines
   * the direction in which the data bar extends.
   */
  set direction(a) {
    if (a != this._cg) {
      let b = DataBarConditionalFormat._b7[5].g(DataBarConditionalFormat.$, DataBarDirection_$type, this, this._cg, a);
      this._cg = b.p1;
    }
  }
  /**
   * Returns or sets a value which determines the manner in which the longest
   * bar is evaluated for this condition.
   * <p class="body">
   * The following values are not supported for the [[ConditionValue.valueType]]
   * property, and will cause an exception to be thrown:
   * </p>
   * <p class="body">
   * <ul>
   * <li>LowestValue</li>
   * <li>AutomaticMinimum</li>
   * <li>None</li>
   * </ul>
   * </p>
   * @see [[minPoint]]
   * @see [[ConditionValue]]
   */
  get maxPoint() {
    if (this._ca == null) {
      this._ca = new ConditionValue(this, runOn(this, this._dy), runOn(this, this._d2));
      this._ca._ad(7);
    }
    return this._ca;
  }
  /**
   * Returns or sets a value which determines the manner in which the shortest
   * bar is evaluated for this condition.
   * <p class="body">
   * The following values are not supported for the [[ConditionValue.valueType]]
   * property, and will cause an exception to be thrown:
   * </p>
   * <p class="body">
   * <ul>
   * <li>HighestValue</li>
   * <li>AutomaticMaximum</li>
   * <li>None</li>
   * </ul>
   * </p>
   * @see [[minPoint]]
   * @see [[ConditionValue]]
   */
  get minPoint() {
    if (this._cb == null) {
      this._cb = new ConditionValue(this, runOn(this, this._dy), runOn(this, this._d2));
      this._cb._ad(6);
    }
    return this._cb;
  }
  /**
   * Returns a [[negativeBarFormat]] object which defines the visual
   * attributes of negative-value data bars.
   */
  get negativeBarFormat() {
    if (this._ck == null) {
      this._ck = new NegativeBarFormat(this, runOn(this, this._dz));
    }
    return this._ck;
  }
  /**
   * Returns or sets an integer value which determines the length of
   * the longest data bar, expressed as a percentage of the cell's width.
   */
  get fillPercentMax() {
    return this._c2;
  }
  /**
   * Returns or sets an integer value which determines the length of
   * the longest data bar, expressed as a percentage of the cell's width.
   */
  set fillPercentMax(a) {
    if (a != this._c2) {
      DataBarConditionalFormat._d1(a, "FillPercentMax");
      let b = DataBarConditionalFormat._b7[6].g(DataBarConditionalFormat.$, Number_$type, this, this._c2, a);
      this._c2 = b.p1;
    }
  }
  /**
   * Returns or sets an integer value which determines the length of
   * the shortest data bar, expressed as a percentage of the cell's width.
   */
  get fillPercentMin() {
    return this._c3;
  }
  /**
   * Returns or sets an integer value which determines the length of
   * the shortest data bar, expressed as a percentage of the cell's width.
   */
  set fillPercentMin(a) {
    if (a != this._c3) {
      DataBarConditionalFormat._d1(a, "FillPercentMin");
      let b = DataBarConditionalFormat._b7[7].g(DataBarConditionalFormat.$, Number_$type, this, this._c3, a);
      this._c3 = b.p1;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether borders
   * are displayed for both negative-value and positive-value
   * databars.
   */
  get showBorder() {
    return this._cx;
  }
  /**
   * Returns or sets a boolean value indicating whether borders
   * are displayed for both negative-value and positive-value
   * databars.
   */
  set showBorder(a) {
    if (a != this._cx) {
      let b = DataBarConditionalFormat._b7[8].g(DataBarConditionalFormat.$, Boolean_$type, this, this._cx, a);
      this._cx = b.p1;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether the cell
   * value is shown along with the data bar.
   * <p class="body">
   * By default, the cell value is displayed along with the databar;
   * use this property to prevent the cell value from appearing.
   * </p>
   */
  get showValue() {
    return this._cy;
  }
  /**
   * Returns or sets a boolean value indicating whether the cell
   * value is shown along with the data bar.
   * <p class="body">
   * By default, the cell value is displayed along with the databar;
   * use this property to prevent the cell value from appearing.
   * </p>
   */
  set showValue(a) {
    if (a != this._cy) {
      let b = DataBarConditionalFormat._b7[9].g(DataBarConditionalFormat.$, Boolean_$type, this, this._cy, a);
      this._cy = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__z() {
    if (super.get__z()) {
      return true;
    }
    let a = this._cb != null ? this._cb.formula : null;
    let b = this._ca != null ? this._ca.formula : null;
    return ConditionBase._aa(a, this.worksheet) || ConditionBase._aa(b, this.worksheet);
  }
  /**
   * @hidden
   */
  get _cz() {
    if (this._z || this.formula != null) {
      return true;
    }
    if (this._cb != null && this._cb.valueType != 4) {
      return true;
    }
    if (this._ca != null && this._ca.valueType != 5) {
      return true;
    }
    if (this._ci != 1) {
      return true;
    }
    if (WorkbookColorInfo.l_op_Inequality(this._cn, null)) {
      return true;
    }
    if (this._ce != 0) {
      return true;
    }
    let a = this._ck;
    if (a != null && a._u()) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  static _b9($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(DataBarConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b8() {
    let a = new Array(10);
    ChangeInfo.f(a, 0, DataBarConditionalFormat._b9(WorkbookColorInfo.$, "AxisColor", (b) => b.axisColor, (b, c) => b.axisColor = c));
    ChangeInfo.f(a, 1, DataBarConditionalFormat._b9(DataBarAxisPosition_$type, "AxisPosition", (b) => b.axisPosition, (b, c) => b.axisPosition = c));
    ChangeInfo.f(a, 2, DataBarConditionalFormat._b9(WorkbookColorInfo.$, "BarColor", (b) => b.barColor, (b, c) => b.barColor = c));
    ChangeInfo.f(a, 3, DataBarConditionalFormat._b9(WorkbookColorInfo.$, "BarBorderColor", (b) => b.barBorderColor, (b, c) => b.barBorderColor = c));
    ChangeInfo.f(a, 4, DataBarConditionalFormat._b9(DataBarFillType_$type, "BarFillType", (b) => b.barFillType, (b, c) => b.barFillType = c));
    ChangeInfo.f(a, 5, DataBarConditionalFormat._b9(DataBarDirection_$type, "Direction", (b) => b.direction, (b, c) => b.direction = c));
    ChangeInfo.f(a, 6, DataBarConditionalFormat._b9(Number_$type, "FillPercentMax", (b) => b.fillPercentMax, (b, c) => b.fillPercentMax = c));
    ChangeInfo.f(a, 7, DataBarConditionalFormat._b9(Number_$type, "FillPercentMin", (b) => b.fillPercentMin, (b, c) => b.fillPercentMin = c));
    ChangeInfo.f(a, 8, DataBarConditionalFormat._b9(Boolean_$type, "ShowBorder", (b) => b.showBorder, (b, c) => b.showBorder = c));
    ChangeInfo.f(a, 9, DataBarConditionalFormat._b9(Boolean_$type, "ShowValue", (b) => b.showValue, (b, c) => b.showValue = c));
    return a;
  }
  /**
   * @hidden
   */
  _dx() {
    if (this._cb != null) {
      this._cb._ac();
    }
    if (this._ca != null) {
      this._ca._ac();
    }
  }
  /**
   * @hidden
   */
  _dz(a) {
    let b = this.workbook;
    if (b != null && !b._c4) {
      let c = stringFormat("NegativeBarFormat.{0}", a);
      this._bi(c);
    }
  }
  /**
   * @hidden
   */
  _dy(a, b) {
    let c = this.workbook;
    if (c != null && !c._c4) {
      let d = null;
      if (a == this._ca) {
        d = "MaxPoint";
      }
      else if (a == this._cb) {
        d = "MinPoint";
      }
      else {
      }
      let e = stringFormat("{0}.{1}", d, b);
      this._bi(e);
    }
  }
  /**
   * @hidden
   */
  _d2(a, b, c) {
    let d = a == this._ca;
    let e = false;
    if (d) {
      switch (c) {
        case 4:
        case 6:
          e = true;
          break;
        default: break;
      }
    }
    else {
      switch (c) {
        case 5:
        case 7:
          e = true;
          break;
        default: break;
      }
    }
    if (e) {
      throw new ArgumentException(1, ExcelUtils.eg("LE_InvalidValueType", enumGetBox(FormatConditionValueType_$type, c)));
    }
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (!this._bz(d)) {
      return ConditionMatchResult.f;
    }
    let e = ConditionBase._as(this.workbook, a, d, null);
    if (isNaN_(e)) {
      return ConditionMatchResult.f;
    }
    let f = this._b1(b, c, this.minPoint, d);
    let g = this._b1(b, c, this.maxPoint, d);
    if (isNaN_(f) || isNaN_(g)) {
      return ConditionMatchResult.f;
    }
    let h = Math.max(0, Math.min(100, this.fillPercentMin));
    let i = Math.min(100, Math.max(0, this.fillPercentMax));
    if (h > i) {
      let j = h;
      h = i;
      i = j;
    }
    let k, l;
    let m = e < 0;
    let n = m ? this.negativeBarFormat._r : this._cv;
    let o = this.showBorder == false ? null : m ? this.negativeBarFormat._p : this._ct;
    if (e < f) {
      e = f;
    }
    else if (e > g) {
      e = g;
    }
    let p;
    if (f == g) {
      if (this.axisPosition == 2 || (this.axisPosition == 0 && f > 0)) {
        p = NaN;
        k = 0;
        l = (intDivide((i - h), 2) + h) / 100;
      }
      else if (f == 0) {
        p = 0.5;
        k = 0.5;
        l = 0.5 + (h / 200);
      }
      else if (this.axisPosition == 1) {
        p = 0.5;
        if (e < 0) {
          k = (100 - i) / 200;
          l = p;
        }
        else {
          k = p;
          l = 1 - (100 - i) / 200;
        }
      }
      else {
        p = i / 100;
        k = (i - h) / 200;
        l = p;
      }
    }
    else {
      switch (this.axisPosition) {
        case 0:
          {
            if (f >= 0) {
              p = NaN;
              k = 0;
              l = ((e - f) / (g - f)) * ((i - h) / 100) + (h / 200);
            }
            else {
              let q = (100 - i) / 200;
              let r = h / 200;
              let s = (-f / (g - f)) * (1 - ((q + r) * 2));
              p = s + q + r;
              if (e < 0) {
                let t = (-e) / (-f);
                k = p - (t * s + r);
                l = p;
              }
              else {
                let u = e / g;
                let v = (g / (g - f)) * (1 - ((q + r) * 2));
                k = p;
                l = p + (u * v + r);
              }
            }
            break;
          }
        case 1:
          {
            p = 0.5;
            if (e < 0) {
              let w = (-e) / (Math.max(Math.abs(f), g));
              k = p - (w * p * ((i - h) / 100) + (h / 100 * p));
              l = p;
            }
            else {
              let x = (e) / Math.max(Math.max(Math.abs(f), g), 0);
              k = p;
              l = p + (x * p * ((i - h) / 100) + (h / 100 * p));
            }
            break;
          }
        case 2:
        default:
          p = NaN;
          k = 0;
          if (f == g) {
            l = (intDivide((i - h), 2) + h) / 100;
          }
          else {
            l = ((e - f) / (g - f)) * ((i - h) / 100) + (h / 100);
          }
          break;
      }
    }
    let y = isNaN_(p) ? null : this.axisColor;
    return new ConditionMatchResult(1, new CellDataBarInfo(p, k, l, m, this.showValue, this.direction, this.barFillType, y, n, o));
  }
  /**
   * @hidden
   */
  static _d1(a, b) {
    if (ConditionBase._ae(a) == false) {
      throw new ArgumentOutOfRangeException(1, ExcelUtils.eg("LE_FillPercentInvalid", a, b));
    }
  }
  /**
   * @hidden
   */
  _d0() {
    if (this.fillPercentMax <= this.fillPercentMin) {
      throw new ArgumentOutOfRangeException(1, ExcelUtils.eg("LE_FillPercentRangeInvalid", "FillPercentMin", "FillPercentMax"));
    }
  }
}
DataBarConditionalFormat.$t = markType(DataBarConditionalFormat, 'DataBarConditionalFormat', ThresholdConditionBase.$);
/**
 * @hidden
 */
DataBarConditionalFormat._dj = "AxisColor";
/**
 * @hidden
 */
DataBarConditionalFormat._dk = "AxisPosition";
/**
 * @hidden
 */
DataBarConditionalFormat._dl = "BarBorderColor";
/**
 * @hidden
 */
DataBarConditionalFormat._dm = "BarColor";
/**
 * @hidden
 */
DataBarConditionalFormat._dn = "BarFillType";
/**
 * @hidden
 */
DataBarConditionalFormat._dp = "Direction";
/**
 * @hidden
 */
DataBarConditionalFormat._dt = "MinPoint";
/**
 * @hidden
 */
DataBarConditionalFormat._ds = "MaxPoint";
/**
 * @hidden
 */
DataBarConditionalFormat._du = "NegativeBarFormat";
/**
 * @hidden
 */
DataBarConditionalFormat._dq = "FillPercentMax";
/**
 * @hidden
 */
DataBarConditionalFormat._dr = "FillPercentMin";
/**
 * @hidden
 */
DataBarConditionalFormat._dw = "ShowValue";
/**
 * @hidden
 */
DataBarConditionalFormat._dv = "ShowBorder";
/**
 * @hidden
 */
DataBarConditionalFormat._de = 0;
/**
 * @hidden
 */
DataBarConditionalFormat._db = 100;
/**
 * @hidden
 */
DataBarConditionalFormat._c4 = 0;
/**
 * @hidden
 */
DataBarConditionalFormat._c5 = 1;
/**
 * @hidden
 */
DataBarConditionalFormat._c7 = 2;
/**
 * @hidden
 */
DataBarConditionalFormat._c6 = 3;
/**
 * @hidden
 */
DataBarConditionalFormat._c8 = 4;
/**
 * @hidden
 */
DataBarConditionalFormat._c9 = 5;
/**
 * @hidden
 */
DataBarConditionalFormat._dc = 6;
/**
 * @hidden
 */
DataBarConditionalFormat._df = 7;
/**
 * @hidden
 */
DataBarConditionalFormat._dh = 8;
/**
 * @hidden
 */
DataBarConditionalFormat._di = 9;
/**
 * @hidden
 */
DataBarConditionalFormat._dg = 10;
/**
 * @hidden
 */
DataBarConditionalFormat._b7 = DataBarConditionalFormat._b8();
/**
 * @hidden
 */
DataBarConditionalFormat._cq = new WorkbookColorInfo(ExcelUtils.gw(99, 142, 198));
/**
 * @hidden
 */
DataBarConditionalFormat._cp = new WorkbookColorInfo(ExcelUtils.gw(0, 0, 0));
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's date/time value falls within a given range of time.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with date/time
 * values which fall within a range of time as specified by the [[dateOperator]]
 * property.
 * </p>
 * <p class="body">
 * This condition provides only limited support for defining date/time ranges, i.e., the
 * current, previous, or next day, week or month. For wider ranges, or more precise conditions,
 * use the [[FormulaConditionalFormat]] class, and assign the desired date/time
 * formula to the [[FormulaConditionalFormat.formula]] property.
 * </p>
 * @see [[dateOperator]]
 * @see [[FormatConditionTimePeriod]]
 */
export class DateTimeConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b3 = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c, 10);
          this._b3 = 0;
          this._b3 = d;
        }
        break;
    }
  }
  /**
   * Returns or sets a [[FormatConditionTimePeriod]] value which
   * defines the range of time against which cell values are compared when
   * evaluating this condition.
   */
  get dateOperator() {
    return this._b3;
  }
  /**
   * Returns or sets a [[FormatConditionTimePeriod]] value which
   * defines the range of time against which cell values are compared when
   * evaluating this condition.
   */
  set dateOperator(a) {
    if (a != this._b3) {
      let b = DateTimeConditionalFormat._b0[0].g(DateTimeConditionalFormat.$, FormatConditionTimePeriod_$type, this, this._b3, a);
      this._b3 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__ai() {
    return true;
  }
  /**
   * @hidden
   */
  static _b2($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(DateTimeConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, DateTimeConditionalFormat._b2(FormatConditionTimePeriod_$type, "DateOperator", (b) => b.dateOperator, (b, c) => b.dateOperator = c));
    return a;
  }
  /**
   * @hidden
   */
  _h() {
    return new DateTimeConditionalFormat(0);
  }
  /**
   * @hidden
   */
  static _b5(a) {
    let b = a.getDay();
    if (b == 0) {
      return a;
    }
    return dateAddDays(a, -b);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(DateTimeConditionalFormat.$, a);
    this._b3 = c._b3;
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (a == null) {
      return ConditionMatchResult.f;
    }
    let e;
    if (((() => { let f = this.worksheet._en(this.worksheet._rows$i.item(b), c, e, false); e = f.p2; return f.ret; })())) {
      let f = dateGetDate(e);
      let g = dateGetDate(dateToday());
      let h = false;
      switch (this.dateOperator) {
        case 0:
          h = +f == +g;
          break;
        case 2:
          h = +f == +(dateAddDays(g, -1));
          break;
        case 1:
          h = +f == +(dateAddDays(g, 1));
          break;
        case 6:
          h = f <= g && f > dateAddDays(g, -7);
          break;
        case 7:
          h = dateGetMonth(f) == dateGetMonth(g) && f.getFullYear() == g.getFullYear();
          break;
        case 8:
          {
            let i = dateAddMonths(g, 1);
            h = dateGetMonth(f) == dateGetMonth(i) && f.getFullYear() == i.getFullYear();
            break;
          }
        case 9:
          {
            let j = dateAddMonths(g, -1);
            h = dateGetMonth(f) == dateGetMonth(j) && f.getFullYear() == j.getFullYear();
            break;
          }
        case 3:
        case 4:
        case 5:
          {
            let k = DateTimeConditionalFormat._b5(g);
            switch (this.dateOperator) {
              case 4:
                k = dateAddDays(k, 7);
                break;
              case 5:
                k = dateAddDays(k, -7);
                break;
            }
            if (f >= k) {
              let l = dateAddDays(k, 7);
              h = f < l;
            }
          }
          break;
        default: break;
      }
      return h ? ConditionMatchResult.e : ConditionMatchResult.f;
    }
    return ConditionMatchResult.f;
  }
}
DateTimeConditionalFormat.$t = markType(DateTimeConditionalFormat, 'DateTimeConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
DateTimeConditionalFormat._b8 = "DateOperator";
/**
 * @hidden
 */
DateTimeConditionalFormat._b6 = 0;
/**
 * @hidden
 */
DateTimeConditionalFormat._b7 = 1;
/**
 * @hidden
 */
DateTimeConditionalFormat._b0 = DateTimeConditionalFormat._b1();
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique or duplicated across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are non-unique across
 * the associated range.
 * </p>
 * @see [[UniqueConditionalFormat]]
 */
export class DuplicateConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b0 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 7);
          this._b0 = null;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return 1;
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  get__am() {
    return true;
  }
  /**
   * @hidden
   */
  _h() {
    return new DuplicateConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(DuplicateConditionalFormat.$, a);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (a == null) {
      return ConditionMatchResult.f;
    }
    if (this._b0 == null) {
      this._b0 = new UniqueConditionalFormat_DuplicateValueHolder(this.regions);
    }
    return this._b0.c(a) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  _bb() {
    super._bb();
    this._b0 = null;
  }
  /**
   * @hidden
   */
  _bf() {
    super._bf();
    this._b0 = null;
  }
}
DuplicateConditionalFormat.$t = markType(DuplicateConditionalFormat, 'DuplicateConditionalFormat', ConditionalFormatBase.$);
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which represents an error condition. For example, a cell
 * which displays the result of a formula whereby the formula results in
 * a divide-by-zero error meets the criteria of this condition.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoErrorsConditionalFormat]] class.
 * </p>
 * @see [[NoErrorsConditionalFormat]]
 */
export class ErrorsConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 13);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  _h() {
    return new ErrorsConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(ErrorsConditionalFormat.$, a);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    return typeCast(ErrorValue.$, a) !== null ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
ErrorsConditionalFormat.$t = markType(ErrorsConditionalFormat, 'ErrorsConditionalFormat', ConditionalFormatBase.$);
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a <see cref="Excel.Formula">formula</see>.
 * @see [[formula]]
 */
export class FormulaConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b4 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(c, 1);
          this._b4 = null;
          this._b4 = this._o(d, e);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__x() {
    return this._b4 != null;
  }
  /**
   * Returns or sets the <see cref="Excel.Formula">formula</see> which defines the criteria for this condition.
   * <p class="body">
   * This property is not settable; however, the [[setFormula]]
   * method can be used to assign the formula.
   * </p>
   * @see [[setFormula]]
   */
  get formula() {
    return this._b4;
  }
  /**
   * @hidden
   */
  get _b5() {
    return this._b4;
  }
  /**
   * @hidden
   */
  set _b5(a) {
    if (a != this._b4) {
      if (a != null && a._ch == null) {
        this._m(a);
      }
      let b = FormulaConditionalFormat._b0[0].g(FormulaConditionalFormat.$, SingleTargetFormula.$, this, this._b4, a);
      this._b4 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__z() {
    return ConditionBase._aa(this.formula, this.worksheet);
  }
  /**
   * @hidden
   */
  get__j() {
    return 2;
  }
  /**
   * @hidden
   */
  get__ah() {
    return true;
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  static _b2($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(FormulaConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(1);
    ChangeInfo.f(a, 0, FormulaConditionalFormat._b2(SingleTargetFormula.$, "FormulaInternal", (b) => b._b5, (b, c) => b._b5 = c));
    return a;
  }
  /**
   * @hidden
   */
  _h() {
    return new FormulaConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(FormulaConditionalFormat.$, a);
    if (c._b4 != null) {
      this._b4 = this._m(typeCast(SingleTargetFormula.$, c._b4._g()));
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    if (this._b4 != null) {
      let b = this.regions.item(0);
      let c = new TempCellCalcReference(true, this.worksheet, new WorksheetCellAddress(1, b.firstRow, b.firstColumn));
      this._b4._cx(c, this.workbook);
      a(this.worksheet, this._b4);
    }
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (this._b4 == null) {
      return ConditionMatchResult.f;
    }
    let e = this._b4._cf(this.workbook, d, false);
    return e._ah(this.workbook._e6) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  _bd() {
    this._m(this._b5);
  }
  /**
   * Assigns a new [[Formula]] to this instance.
   * @param formula The string representation of the formula.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   */
  setFormula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setFormula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    this._b5 = this._o(a, b);
    ;
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._b4 != null) {
      let d = this._bp(a, 0, this._b4, b, c);
      this._b4 = d.p2;
    }
    super._bq(a, b, c);
  }
  /**
   * @hidden
   */
  _a4(a, b) {
    if (typeof a === 'number' && (typeGetValue(a)) == 0) {
      return ((() => { let c = this._a3(b, this._b4); this._b4 = c.p1; return c.ret; })());
    }
    return null;
  }
  /**
   * @hidden
   */
  static _b9(a) {
    return stringFormat("={0}", a);
  }
  /**
   * @hidden
   */
  static _ca(a) {
    if (stringIsNullOrEmpty(a)) {
      return a;
    }
    return a.charAt(0) == '=' ? a.substr(1) : a;
  }
}
FormulaConditionalFormat.$t = markType(FormulaConditionalFormat, 'FormulaConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
FormulaConditionalFormat._b8 = "Formula";
/**
 * @hidden
 */
FormulaConditionalFormat._b6 = 0;
/**
 * @hidden
 */
FormulaConditionalFormat._b7 = 1;
/**
 * @hidden
 */
FormulaConditionalFormat._b0 = FormulaConditionalFormat._b1();
/**
 * @hidden
 */
export class IconCriterionInfo extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.b = 0;
    this.i = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.a = c;
          this.b = d;
          this.i = e;
        }
        break;
    }
  }
  equals(a) {
    if (typeCast(IconCriterionInfo.$, a) !== null) {
      return a.a == this.a && a.b == this.b;
    }
    return false;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.a) ^ Base.getHashCodeStatic(this.b);
  }
  toString() {
    return stringFormat("Icon: {0}, Set: {1}", enumGetBox(FormatConditionIcon_$type, this.a), enumGetBox(FormatConditionIconSet_$type, this.b));
  }
  static c(a, b) {
    return a.equals(b);
  }
  static d(a, b) {
    if (!a.hasValue) {
      return !b.hasValue;
    }
    else if (!b.hasValue) {
      return false;
    }
    return IconCriterionInfo.c(a.value, b.value);
  }
  static e(a, b) {
    return !(IconCriterionInfo.c(a, b));
  }
  static f(a, b) {
    if (!a.hasValue) {
      return b.hasValue;
    }
    else if (!b.hasValue) {
      return true;
    }
    return IconCriterionInfo.e(a.value, b.value);
  }
}
IconCriterionInfo.$t = markStruct(IconCriterionInfo, 'IconCriterionInfo');
/**
 * Defines the criterion for an [[IconSetConditionalFormat]] threshold.
 * <p class="body">
 * This class provides the ability to override the default behavior of the
 * associated <see cref="IconSetConditionalFormat">condition</see> for the
 * threshold defined by this instance.
 * </p>
 * <p class="body">
 * For example, the icon displayed for cell values which fall within this threshold
 * is determined by the value of the [[IconSetConditionalFormat.iconSet]],
 * but can be overridden using the [[icon]] property.
 * </p>
 * <p class="body">
 * Similarly, the default unit for this criterion's <see cref="ConditionValue.Value">value</see> is percentage,
 * but this can be overridden using the [[ConditionValue.valueType]]
 * property. For example, to define the unit for the value as a specific number, assign
 * a value of <i>Number</i> to the <i>ValueType</i> property.
 * </p>
 * <p class="body">
 * The value for this threshold is defined by the parent condition, based on the
 * total number of thresholds. For [[IconSetConditionalFormat.iconSet]]
 * values which yield three thresholds, for example, the effective value is dependent
 * on the threshold, so that each threshold represents approximately 33% of the associated
 * range. This can be overridden using the [[CriterionBase.value]] property; for example, setting
 * the <i>ValueType</i> property to <i>Number</i> and the <i>Value</i> property to
 * a specific number overrides the behavior as defined by the parent condition, and forces
 * the threshold boundary to the specific numeric value.
 * </p>
 * <p class="body">
 * For this reason, the [[icon]], [[ConditionValue.value]], and [[ConditionValue.valueType]]
 * properties support null values, and are in fact set to null by default; this is interpreted
 * by the parent condition as "not set", resulting in the threshold criterion being determined
 * solely by the parent condition.
 * </p>
 * @see [[icon]]
 * @see [[CriterionBase.value]]
 * @see [[ValueType]]
 * @see [[IconSetConditionalFormat.iconSet]]
 */
export class IconCriterion extends CriterionBase {
  constructor(a, ..._rest) {
    super();
    /**
     * @hidden
     */
    this._ah = 0;
    this._ad = null;
    this._al = 0;
    this._ab = new IconCriterionInfo();
    this._af = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          if (c == null) {
            throw new ArgumentNullException(0, "owner");
          }
          this._ad = c;
          this._al = d;
          this._ab = new IconCriterionInfo(1, -1, 1, -1);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = [c, d];
          {
            let i = g[0];
            let j = g[1];
            if (i == null) {
              throw new ArgumentNullException(0, "owner");
            }
            this._ad = i;
            this._al = j;
            this._ab = new IconCriterionInfo(1, -1, 1, -1);
          }
          this._au(e, f, d);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__d() {
    return this._ad._d;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * @hidden
   */
  get _ae() {
    return this._ad;
  }
  /**
   * Returns or sets a [[comparison]] value which
   * determines whether a "greater than" or "greater than or equal to"
   * comparison is made when comparing cell values to the <see cref="CriterionBase.Value">value</see>
   * of this instance.
   */
  get comparison() {
    return this._af;
  }
  /**
   * Returns or sets a [[comparison]] value which
   * determines whether a "greater than" or "greater than or equal to"
   * comparison is made when comparing cell values to the <see cref="CriterionBase.Value">value</see>
   * of this instance.
   */
  set comparison(a) {
    if (a != this._af) {
      let b = IconCriterion._x[0].g(IconCriterion.$, ThresholdComparison_$type, this, this._af, a);
      this._af = b.p1;
    }
  }
  /**
   * Returns or sets a [[FormatConditionIcon]] value which
   * identifies the icon displayed for this threshold as defined by the
   * [[IconSetConditionalFormat.iconSet]] and [[index]]
   * properties.
   * <p class="body">
   * By default, the icon displayed for this threshold is defined by the
   * parent <see cref="IconSetConditionalFormat">condition</see>, via the
   * value of the [[IconSetConditionalFormat.iconSet]] property.
   * </p>
   * <p class="body">
   * This property provides a way to override the default icon as defined by
   * the parent condition.
   * </p>
   * <p class="body">
   * This property defaults to the appropriate value given the <i>IconSet</i>
   * as defined by the parent condition and this instance's <i>Threshold</i>.
   * </p>
   * @see [[FormatConditionIcon]]
   * @see [[IconSetConditionalFormat.iconSet]]
   */
  get icon() {
    return this._ab.a;
  }
  /**
   * Returns or sets a [[FormatConditionIcon]] value which
   * identifies the icon displayed for this threshold as defined by the
   * [[IconSetConditionalFormat.iconSet]] and [[index]]
   * properties.
   * <p class="body">
   * By default, the icon displayed for this threshold is defined by the
   * parent <see cref="IconSetConditionalFormat">condition</see>, via the
   * value of the [[IconSetConditionalFormat.iconSet]] property.
   * </p>
   * <p class="body">
   * This property provides a way to override the default icon as defined by
   * the parent condition.
   * </p>
   * <p class="body">
   * This property defaults to the appropriate value given the <i>IconSet</i>
   * as defined by the parent condition and this instance's <i>Threshold</i>.
   * </p>
   * @see [[FormatConditionIcon]]
   * @see [[IconSetConditionalFormat.iconSet]]
   */
  set icon(a) {
    if (a != this._ab.a) {
      let b = this._ad._d.iconSet;
      let c = ((() => { let d = IconSetConditionalFormat._cp(a, b); b = d.p1; return d.ret; })());
      this._ac = new IconCriterionInfo(1, a, b, c);
    }
  }
  /**
   * @hidden
   */
  _av(a) {
    let b = this._ad._d.iconSet;
    let c = ((() => { let d = IconSetConditionalFormat._cp(a, b); b = d.p1; return d.ret; })());
    this._ab = new IconCriterionInfo(1, a, b, c);
  }
  /**
   * @hidden
   */
  get _ac() {
    return this._ab;
  }
  /**
   * @hidden
   */
  set _ac(a) {
    if (IconCriterionInfo.e(a, this._ab)) {
      let b = IconCriterion._x[1].g(IconCriterion.$, IconCriterionInfo.$, this, this._ab, a);
      this._ab = b.p1;
    }
  }
  /**
   * Returns a [[FormatConditionIconSet]] value which
   * identifies the icon set that includes this icon (read-only).
   * @see [[FormatConditionIconSet]]
   * @see [[IconSetConditionalFormat.iconSet]]
   */
  get iconSet() {
    return this._ab.b;
  }
  /**
   * @hidden
   */
  get _ap() {
    return this._al;
  }
  /**
   * @hidden
   */
  get _ak() {
    return this._ab.i != this._ap || this._ab.b != this._ad._d.iconSet;
  }
  /**
   * @hidden
   */
  get _aq() {
    return this._ab.i;
  }
  /**
   * @hidden
   */
  _aa(a) {
    let b = new IconCriterion(0, a, this._al);
    b._o(this, false);
    return b;
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(IconCriterion.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _y() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, IconCriterion._z(ThresholdComparison_$type, "Comparison", (b) => b.comparison, (b, c) => b.comparison = c));
    ChangeInfo.f(a, 1, IconCriterion._z(IconCriterionInfo.$, "IconInternal", (b) => b._ac, (b, c) => b._ac = c));
    return a;
  }
  /**
   * @hidden
   */
  static _an(a) {
    let b = IconSetConditionalFormat._b9(a);
    return b.length;
  }
  /**
   * @hidden
   */
  _au(a, b, c) {
    this._al = this._ap;
    let d = ((() => { let e = IconSetConditionalFormat._cp(b, a); a = e.p1; return e.ret; })());
    this._ab = new IconCriterionInfo(1, b, a, d);
  }
  /**
   * @hidden
   */
  _o(a, b) {
    super._o(a, b);
    let c = typeCast(IconCriterion.$, a);
    this._af = c._af;
    this._ab = c._ab;
  }
  /**
   * @hidden
   */
  _q(a, b) {
    this._ad._n(this, stringFormat("Value.{0}", b));
  }
  /**
   * @hidden
   */
  _w(a, b, c) {
    switch (c) {
      case 4:
      case 5:
      case 6:
      case 7: throw new ArgumentException(1, ExcelUtils.eg("LE_InvalidValueType", enumGetBox(FormatConditionValueType_$type, c)));
      default: break;
    }
    let d = this._ad.count;
    let e = this._ap;
    let f = e > 0 ? this._ad.item(e - 1) : null;
    let g = e < d - 1 ? this._ad.item(e + 1) : null;
  }
  /**
   * @hidden
   */
  _f() {
    return true;
  }
}
IconCriterion.$t = markType(IconCriterion, 'IconCriterion', CriterionBase.$);
/**
 * @hidden
 */
IconCriterion._at = "ThresholdComparison";
/**
 * @hidden
 */
IconCriterion._as = "Icon";
/**
 * @hidden
 */
IconCriterion._am = 0;
/**
 * @hidden
 */
IconCriterion._ao = 1;
/**
 * @hidden
 */
IconCriterion._ar = 2;
/**
 * @hidden
 */
IconCriterion._x = IconCriterion._y();
/**
 * @hidden
 */
export class IconSetConditionalFormat_IconSetChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.d = c.iconSet;
          this.c = d;
          this.a = new Array(c._iconCriteria$i.count);
          for (let e = 0; e < this.a.length; e++) {
            this.a[e] = c._iconCriteria$i.item(e)._aa(c._iconCriteria$i);
          }
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b.worksheet;
  }
  get source() {
    return this;
  }
}
IconSetConditionalFormat_IconSetChangeContext.$t = markStruct(IconSetConditionalFormat_IconSetChangeContext, 'IconSetConditionalFormat_IconSetChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * Exposes properties which displays icons in a [[WorksheetCell]]
 * based on the cell's value as relative to threshold values.
 * <p class="body">
 * This class provides the ability to display an icon inside a cell when that cell's
 * value meets the criteria defined by the relevant [[IconCriterion]].
 * </p>
 * <p class="body">
 * Each icon set contains between three and five individual icons. The number of icons
 * defines the number of thresholds; for example, a 3-icon set implies 3 thresholds, with
 * each threshold representing approximately 33% of the associated range. A 4-icon set
 * provides 4 thresholds, each representing 25% of the range; a 5-icon set contains 5
 * thresholds with each representing 20% of the range.
 * </p>
 * <p class="body">
 * Threshold ranges are pre-defined based on the number of icons in the associated set,
 * although this can be customized using the <see cref="CriterionBase.Value">Value</see> property
 * of the [[IconCriterion]] associated with that threshold.
 * </p>
 * <p class="body">
 * By default thresholds are expressed as percentages; use the <i>Value</i>
 * property to customize this to support a percentile rating or a specific value. How the
 * <i>Value</i> property is interpreted is dependent on the <see cref="CriterionBase.ValueType">ValueType</see> property.
 * </p>
 * <p class="body">
 * While the number of thresholds is always fixed at 3, 4, or 5, the icon which is displayed
 * for a given threshold can be customized using the [[IconCriterion.icon]] property.
 * </p>
 */
export class IconSetConditionalFormat extends ThresholdConditionBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._ci = false;
          this._cj = false;
          this._ck = false;
          this._cd = null;
          this._cf = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c, 5);
          this._ci = false;
          this._cj = false;
          this._ck = false;
          this._cd = null;
          this._cf = 0;
          this._cf = d;
          this._ck = true;
          this._cd = new IconSetCriterionCollection(this, d);
        }
        break;
    }
  }
  static staticInit() {
    IconSetConditionalFormat._b7 = IconSetConditionalFormat._b8();
  }
  /**
   * @hidden
   */
  _h() {
    return new IconSetConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a5() {
    this._cy();
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(IconSetConditionalFormat.$, a);
    this._cf = c._cf;
    this._ci = c._ci;
    this._cj = c._cj;
    this._ck = c._ck;
    if (c._cd != null) {
      this._cd = c._cd._e(this, c._cf);
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    super._a9(a);
    if (this._cd != null) {
      this._cd._m(a);
    }
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._cd != null) {
      this._cd.shiftFormulas(a, b, c);
    }
    super._bq(a, b, c);
  }
  /**
   * @hidden
   */
  get__z() {
    if (super.get__z()) {
      return true;
    }
    return this._cd != null && this._cd._g;
  }
  iconCriteria() {
    if (arguments.length !== 0) {
      let a = this._iconCriteria$i;
      return a.item.apply(a, arguments);
    }
    return this._iconCriteria$i;
  }
  /**
   * @hidden
   */
  get _iconCriteria$i() {
    return this._cd;
  }
  /**
   * Returns or sets a [[FormatConditionIconSet]] value which identifies
   * the set of icons used to express this condition.
   */
  get iconSet() {
    return this._cf;
  }
  /**
   * Returns or sets a [[FormatConditionIconSet]] value which identifies
   * the set of icons used to express this condition.
   */
  set iconSet(a) {
    if (a != this._cf) {
      if (a == -1) {
        throw new BaseError(1, ExcelUtils.ef("LE_IconSetInvalid"));
      }
      this._c0(a, true);
    }
  }
  /**
   * @hidden
   */
  _c0(a, b) {
    let c = IconSetConditionalFormat._b7[0];
    let d = new IconSetConditionalFormat_IconSetChangeContext(1, this, a);
    let e = c.b(this.workbook, this.worksheet, c.c);
    this._cf = a;
    if (b) {
      this._iconCriteria$i._l(a);
    }
    c.e(IconSetConditionalFormat_IconSetChangeContext.$, IconSetConditionalFormat.$, d, this, null);
    if (e != null) {
      c.d(this.workbook, e);
    }
    if (b) {
      this._bi("IconSet");
    }
  }
  /**
   * Returns true if the <see cref="IconCriterion.Icon">Icon</see>
   * property of one or more <see cref="IconCriterion">criterion</see>
   * returns a value which is from a different icon set as the one
   * returned from the [[iconSet]] property.
   */
  get isCustom() {
    return this._iconCriteria$i._h;
  }
  /**
   * @hidden
   */
  get _cm() {
    return this._ci;
  }
  /**
   * @hidden
   */
  set _cm(a) {
    this._ci = a;
  }
  /**
   * Returns or sets a boolean value indicating whether the order in
   * which icons appear is reversed.
   */
  get isReverseOrder() {
    return this._cj;
  }
  /**
   * Returns or sets a boolean value indicating whether the order in
   * which icons appear is reversed.
   */
  set isReverseOrder(a) {
    if (a != this._cj) {
      this._iconCriteria$i._p();
      let b = IconSetConditionalFormat._b7[1].g(IconSetConditionalFormat.$, Boolean_$type, this, this._cj, a);
      this._cj = b.p1;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether the cell
   * value is shown along with the icon.
   * <p class="body">
   * By default, the cell value is displayed along with the icon;
   * use this property to prevent the cell value from appearing.
   * </p>
   */
  get showValue() {
    return this._ck;
  }
  /**
   * Returns or sets a boolean value indicating whether the cell
   * value is shown along with the icon.
   * <p class="body">
   * By default, the cell value is displayed along with the icon;
   * use this property to prevent the cell value from appearing.
   * </p>
   */
  set showValue(a) {
    if (a != this._ck) {
      let b = IconSetConditionalFormat._b7[2].g(IconSetConditionalFormat.$, Boolean_$type, this, this._ck, a);
      this._ck = b.p1;
    }
  }
  /**
   * @hidden
   */
  _cy() {
    if (this._cd != null) {
      this._cd._k();
    }
  }
  /**
   * @hidden
   */
  static _cb($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(IconSetConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _cc($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(IconSetConditionalFormat_IconSetChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _b8() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, IconSetConditionalFormat._cc(IconSetConditionalFormat.$, "IconSSet", 28, (b) => b.b, (b, c) => IconSetConditionalFormat._c1(b, c)));
    ChangeInfo.f(a, 1, IconSetConditionalFormat._cb(Boolean_$type, "IsReverseOrder", (b) => b.isReverseOrder, (b, c) => b.isReverseOrder = c));
    ChangeInfo.f(a, 2, IconSetConditionalFormat._cb(Boolean_$type, "ShowValue", (b) => b.showValue, (b, c) => b.showValue = c));
    return a;
  }
  /**
   * @hidden
   */
  static _b9(a, b = false) {
    let c = null;
    switch (a) {
      case 1:
        c = new Array(3);
        c[0] = 3;
        c[1] = 2;
        c[2] = 1;
        break;
      case 2:
        c = new Array(3);
        c[0] = 6;
        c[1] = 5;
        c[2] = 4;
        break;
      case 3:
        c = new Array(3);
        c[0] = 9;
        c[1] = 8;
        c[2] = 7;
        break;
      case 4:
        c = new Array(3);
        c[0] = 12;
        c[1] = 11;
        c[2] = 10;
        break;
      case 5:
        c = new Array(3);
        c[0] = 16;
        c[1] = 15;
        c[2] = 14;
        break;
      case 6:
        c = new Array(3);
        c[0] = 18;
        c[1] = 17;
        c[2] = 10;
        break;
      case 7:
        c = new Array(3);
        c[0] = 21;
        c[1] = 20;
        c[2] = 19;
        break;
      case 8:
        c = new Array(3);
        c[0] = 24;
        c[1] = 23;
        c[2] = 22;
        break;
      case 9:
        c = new Array(4);
        c[0] = 3;
        c[1] = 26;
        c[2] = 25;
        c[3] = 1;
        break;
      case 10:
        c = new Array(4);
        c[0] = 6;
        c[1] = 28;
        c[2] = 27;
        c[3] = 4;
        break;
      case 11:
        c = new Array(4);
        c[0] = 32;
        c[1] = 31;
        c[2] = 30;
        c[3] = 29;
        break;
      case 12:
        c = new Array(4);
        c[0] = 38;
        c[1] = 39;
        c[2] = 40;
        c[3] = 41;
        break;
      case 13:
        c = new Array(4);
        c[0] = 13;
        c[1] = 12;
        c[2] = 11;
        c[3] = 10;
        break;
      case 14:
        c = new Array(5);
        c[0] = 3;
        c[1] = 26;
        c[2] = 2;
        c[3] = 25;
        c[4] = 1;
        break;
      case 15:
        c = new Array(5);
        c[0] = 6;
        c[1] = 28;
        c[2] = 5;
        c[3] = 27;
        c[4] = 4;
        break;
      case 16:
        c = new Array(5);
        c[0] = 37;
        c[1] = 38;
        c[2] = 39;
        c[3] = 40;
        c[4] = 41;
        break;
      case 17:
        c = new Array(5);
        c[0] = 36;
        c[1] = 35;
        c[2] = 34;
        c[3] = 33;
        c[4] = 32;
        break;
      case 18:
        c = new Array(3);
        c[0] = 44;
        c[1] = 43;
        c[2] = 42;
        break;
      case 19:
        c = new Array(3);
        c[0] = 47;
        c[1] = 46;
        c[2] = 45;
        break;
      case 20:
        c = new Array(5);
        c[0] = 52;
        c[1] = 51;
        c[2] = 50;
        c[3] = 49;
        c[4] = 48;
        break;
      case -1:
        c = new Array(1);
        c[0] = -1;
        break;
      default:
        c = new Array(0);
        break;
    }
    return b ? IconSetConditionalFormat._ca(c) : c;
  }
  /**
   * @hidden
   */
  static _ca(a) {
    let b = new Array(a.length);
    for (let c = 0; c < a.length; c++) {
      let d = a.length - c - 1;
      b[d] = a[c];
    }
    return b;
  }
  /**
   * @hidden
   */
  static _cp(a, b) {
    if (a == -1) {
      return {
        ret: -1,
        p1: b
      };
    }
    let c = IconSetConditionalFormat._b9(b);
    for (let d = 0; d < c.length; d++) {
      if (a == c[d]) {
        return {
          ret: d,
          p1: b
        };
      }
    }
    let e = b;
    switch (a) {
      case 32:
        b = 17;
        break;
      case 13:
        b = 13;
        break;
      case 33:
        b = 17;
        break;
      case 35:
        b = 17;
        break;
      case 34:
        b = 17;
        break;
      case 41:
        b = 12;
        break;
      case 48:
        b = 20;
        break;
      case 42:
        b = 18;
        break;
      case 31:
        b = 11;
        break;
      case 6:
        b = 2;
        break;
      case 28:
        b = 10;
        break;
      case 5:
        b = 2;
        break;
      case 4:
        b = 2;
        break;
      case 27:
        b = 10;
        break;
      case 22:
        b = 8;
        break;
      case 19:
        b = 7;
        break;
      case 10:
        b = 4;
        break;
      case 7:
        b = 3;
        break;
      case 14:
        b = 5;
        break;
      case 1:
        b = 1;
        break;
      case 45:
        b = 19;
        break;
      case 43:
        b = 18;
        break;
      case 38:
        b = 12;
        break;
      case 51:
        b = 20;
        break;
      case 30:
        b = 11;
        break;
      case 29:
        b = 11;
        break;
      case 12:
        b = 4;
        break;
      case 24:
        b = 8;
        break;
      case 21:
        b = 7;
        break;
      case 18:
        b = 6;
        break;
      case 3:
        b = 1;
        break;
      case 47:
        b = 19;
        break;
      case 9:
        b = 3;
        break;
      case 16:
        b = 5;
        break;
      case 44:
        b = 18;
        break;
      case 40:
        b = 12;
        break;
      case 49:
        b = 20;
        break;
      case 39:
        b = 12;
        break;
      case 50:
        b = 20;
        break;
      case 36:
        b = 17;
        break;
      case 11:
        b = 4;
        break;
      case 46:
        b = 19;
        break;
      case 26:
        b = 9;
        break;
      case 23:
        b = 8;
        break;
      case 20:
        b = 7;
        break;
      case 8:
        b = 3;
        break;
      case 2:
        b = 1;
        break;
      case 15:
        b = 5;
        break;
      case 17:
        b = 6;
        break;
      case 25:
        b = 9;
        break;
      case 37:
        b = 16;
        break;
      case 52:
        b = 20;
        break;
      default: break;
    }
    if (e == b) {
      return {
        ret: -1,
        p1: b
      };
    }
    return {
      ret: ((() => { let f = IconSetConditionalFormat._cp(a, b); b = f.p1; return f.ret; })()),
      p1: b
    };
  }
  /**
   * @hidden
   */
  _cz(a, b) {
    let c = this.workbook;
    if (c != null && !c._c4) {
      let d = stringFormat("IconCriteria[{0}].{1}", a._ap, b);
      this._bi(d);
    }
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    let e = this._iconCriteria$i.count;
    if (e == 0 || !this._bz(d)) {
      return ConditionMatchResult.f;
    }
    let f = ConditionBase._as(this.workbook, a, d, null);
    if (isNaN_(f)) {
      return ConditionMatchResult.f;
    }
    let g = new Array(e);
    let h = new Array(e);
    let i = 0;
    for (let j of fromEnum(this._iconCriteria$i)) {
      h[i] = j;
      if (i == 0) {
        g[0] = 0;
      }
      else {
        g[i] = this._b1(b, c, j._b, d);
      }
      i++;
    }
    for (let k = e - 1; k >= 0; k--) {
      let l = h[k];
      let m = g[k];
      let n;
      if (l.comparison == 0) {
        n = f >= m;
      }
      else {
        n = f > m;
      }
      if (n || k == 0) {
        return new ConditionMatchResult(2, new CellIconInfo(l.iconSet, l.icon, l._aq, this.showValue));
      }
    }
    return ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  static _c1(a, b) {
    let c = a.b;
    let d = a.a.length > 0;
    c._c0(a.d, !d);
    if (d) {
      c._iconCriteria$i._o(a.a);
      c._bi("IconSet");
    }
  }
}
IconSetConditionalFormat.$t = markType(IconSetConditionalFormat, 'IconSetConditionalFormat', ThresholdConditionBase.$);
/**
 * @hidden
 */
IconSetConditionalFormat._cv = "IconSet";
/**
 * @hidden
 */
IconSetConditionalFormat._cu = "IconCriteria";
/**
 * @hidden
 */
IconSetConditionalFormat._cw = "IsReverseOrder";
/**
 * @hidden
 */
IconSetConditionalFormat._cx = "ShowValue";
/**
 * @hidden
 */
IconSetConditionalFormat._cg = 4;
/**
 * @hidden
 */
IconSetConditionalFormat._cq = 0;
/**
 * @hidden
 */
IconSetConditionalFormat._cr = 1;
/**
 * @hidden
 */
IconSetConditionalFormat._ct = 2;
/**
 * @hidden
 */
IconSetConditionalFormat._cs = 3;
/**
 * @hidden
 */
IconSetConditionalFormat._b7 = null;
/**
 * Collection class for objects of type [[IconCriterion]].
 * <p class="body">
 * This class does not expose an Add method because [[IconCriterion]]
 * instances are created based on the iconset.
 * </p>
 * <p class="body">
 * Enumerating this class causes immediate creation of all
 * [[IconCriterion]] objects.
 * </p>
 * <p class="body">
 * The <see cref="IconSetCriterionCollection.Count">Count</see> property
 * always returns either 3, 4, or 5, depending on the value of the
 * [[IconSetConditionalFormat.iconSet]] property.
 * </p>
 * @see [[IconCriterion]]
 * @see [[IconSetConditionalFormat.iconCriteria]]
 * @see [[IconSetConditionalFormat.iconSet]]
 * @see [[IconSetConditionalFormat]]
 * @see [[FormatConditionIconSet]]
 */
export class IconSetCriterionCollection extends Base {
  constructor(a, b) {
    super();
    this._c = null;
    this._a = null;
    this._f = false;
    if (a == null) {
      throw new ArgumentNullException(0, "owner");
    }
    this._c = a;
    this._l(b);
  }
  /**
   * Returns the [[IconCriterion]] object corresponding to the
   * specified 'index'.
   * @param index A zero-based index.
   * @return The corresponding [[IconCriterion]] object
   */
  item(a) {
    return this._a[a];
  }
  /**
   * @hidden
   */
  get _d() {
    return this._c;
  }
  /**
   * Returns the number of [[IconCriterion]] objects
   * contained within this collection.
   * <p class="body">
   * This property returns a value of 3, 4, or 5, depending on the
   * value of the [[IconSetConditionalFormat.iconSet]]
   * property.
   * </p>
   * @see [[FormatConditionIconSet]]
   */
  get count() {
    return this._a != null ? this._a.length : 0;
  }
  /**
   * @hidden
   */
  get _h() {
    for (let a of fromEnum(this)) {
      if (a._ak) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _e(a, b) {
    let c = new IconSetCriterionCollection(a, b);
    if (this._a != null) {
      c._a = new Array(this._a.length);
      for (let d = 0; d < this._a.length; d++) {
        c._a[d] = this._a[d]._aa(c);
      }
    }
    return c;
  }
  /**
   * @hidden
   */
  _k() {
    if (this._a != null) {
      let c = this._a;
      for (let b = 0; b < c.length; b++) {
        let a = c[b];
        a._m();
      }
    }
  }
  /**
   * @hidden
   */
  get _g() {
    let a = this._d.worksheet;
    let d = this._a;
    for (let c = 0; c < d.length; c++) {
      let b = d[c];
      if (b == null) {
        continue;
      }
      if (ConditionBase._aa(b.formula, a)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _l(a) {
    this._f = true;
    let b = IconSetConditionalFormat._b9(a);
    let c = b.length;
    let d = this._a != null ? this._a.length : 0;
    if (c == d) {
      for (let e = 0; e < d; e++) {
        let f = this._a[e];
        if (f == null) {
          f = new IconCriterion(1, this, e, a, b[e]);
          f._b._setValue1(Math.round((e * (intDivide(100, d)))), 1);
          this._a[e] = f;
        }
        else {
          f._au(a, b[e], e);
        }
      }
    }
    else {
      this._a = new Array(c);
      for (let g = 0; g < c; g++) {
        let h = new IconCriterion(1, this, g, a, b[g]);
        h._b._ae(Math.round((g * (intDivide(100, c)))), 1);
        this._a[g] = h;
      }
    }
    this._f = false;
    this._c._ba();
  }
  /**
   * @hidden
   */
  _m(a) {
    let b = this.count;
    for (let c = 0; c < b; c++) {
      this._a[c]._p(a);
    }
  }
  /**
   * @hidden
   */
  _o(a) {
    let b = a.length;
    if (b == 0) {
      return;
    }
    this._a = new Array(b);
    for (let c = 0; c < b; c++) {
      this._a[c] = a[c]._aa(this);
    }
  }
  /**
   * @hidden
   */
  _p() {
    if (this._a == null) {
      return;
    }
    let a = this._a.length;
    if (a == 0) {
      return;
    }
    let b = new List$1(FormatConditionIcon_$type, 2, a);
    for (let c = 0; c < a; c++) {
      b.add(this._a[c].icon);
    }
    b.w();
    for (let d = 0; d < a; d++) {
      this._a[d]._av(b._inner[d]);
    }
    this._c._ba();
  }
  /**
   * @hidden
   */
  _q(a) {
    this._a = a;
  }
  /**
   * @hidden
   */
  _n(a, b) {
    if (this._f || this._c == null || this._c.worksheet == null || this._c.worksheet._t) {
      return;
    }
    this._c._cz(a, b);
  }
  /**
   * @hidden
   */
  shiftFormulas(callback, shiftOperation, operationOverride) {
    let a = this.count;
    for (let b = 0; b < a; b++) {
      this._a[b]._v(callback, shiftOperation, operationOverride);
    }
  }
  /**
   * @hidden
   */
  undoFormulaShift(context, originalFormula) {
    return null;
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return typeCast(IEnumerator$1_$type.specialize(IconCriterion.$), this);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  /**
   * @hidden
   */
  getEnumerator() {
    return this._getEnumerator$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator$e() {
    let a = this.count;
    let b = new List$1(IconCriterion.$, 2, a);
    for (let c = 0; c < a; c++) {
      b.add(this.item(c));
    }
    return new ReadOnlyCollection$1(IconCriterion.$, 1, b).getEnumerator();
  }
}
IconSetCriterionCollection.$t = markType(IconSetCriterionCollection, 'IconSetCriterionCollection', Base.$, [IEnumerable$1_$type.specialize(IconCriterion.$), ISupportFormulaShifts_$type]);
/**
 * @hidden
 */
IconSetCriterionCollection._j = 5;
/**
 * Exposes properties which control the appearance of negative-value
 * <see cref="DataBarConditionalFormat">data bars</see>.
 */
export class NegativeBarFormat extends Base {
  constructor(a, b) {
    super();
    this._d = null;
    this._t = null;
    this._e = 0;
    this._f = 0;
    this._l = null;
    this._m = null;
    this._d = a;
    this._t = b;
    this._f = 0;
    this._e = 1;
  }
  /**
   * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
   * whether the same border color as that which is used for data bars with positive cell
   * values is also used for data bars with negative cell values.
   * <p class="body">
   * By default, databars for cells with negative values use the same color
   * as those with positive values, and the [[barBorderColor]]
   * property is not used.
   * </p>
   * <p class="body">
   * Use this property to apply the color specified by the
   * [[barBorderColor]] property to the borders of databars
   * with negative cell values.
   * </p>
   * @see [[barBorderColor]]
   * @see [[DataBarConditionalFormat.barBorderColor]]
   */
  get barBorderColorType() {
    return this._e;
  }
  /**
   * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
   * whether the same border color as that which is used for data bars with positive cell
   * values is also used for data bars with negative cell values.
   * <p class="body">
   * By default, databars for cells with negative values use the same color
   * as those with positive values, and the [[barBorderColor]]
   * property is not used.
   * </p>
   * <p class="body">
   * Use this property to apply the color specified by the
   * [[barBorderColor]] property to the borders of databars
   * with negative cell values.
   * </p>
   * @see [[barBorderColor]]
   * @see [[DataBarConditionalFormat.barBorderColor]]
   */
  set barBorderColorType(a) {
    if (a != this._e) {
      let b = NegativeBarFormat._a[3].g(NegativeBarFormat.$, DataBarNegativeBarColorType_$type, this, this._e, a);
      this._e = b.p1;
    }
  }
  /**
   * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
   * whether the same color as that which is used for the positive data bars is used.
   * <p class="body">
   * By default, databars for cells with negative values have a different color
   * than those with positive values.
   * </p>
   * <p class="body">
   * Use this property to apply the same color to databars regardless of whether
   * the cell value is positive or negative.
   * </p>
   * @see [[barColor]]
   * @see [[DataBarConditionalFormat.barColor]]
   */
  get barColorType() {
    return this._f;
  }
  /**
   * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
   * whether the same color as that which is used for the positive data bars is used.
   * <p class="body">
   * By default, databars for cells with negative values have a different color
   * than those with positive values.
   * </p>
   * <p class="body">
   * Use this property to apply the same color to databars regardless of whether
   * the cell value is positive or negative.
   * </p>
   * @see [[barColor]]
   * @see [[DataBarConditionalFormat.barColor]]
   */
  set barColorType(a) {
    if (a != this._f) {
      let b = NegativeBarFormat._a[1].g(NegativeBarFormat.$, DataBarNegativeBarColorType_$type, this, this._f, a);
      this._f = b.p1;
    }
  }
  /**
   * Returns a [[WorkbookColorInfo]] which defines the border color
   * applied to data bars with a negative value.
   * <p class="body">
   * This property is only applicable when the [[barBorderColorType]]
   * property is set to <i>Color</i>.
   * </p>
   * @see [[barBorderColorType]]
   */
  get barBorderColor() {
    return this._l;
  }
  /**
   * Returns a [[WorkbookColorInfo]] which defines the border color
   * applied to data bars with a negative value.
   * <p class="body">
   * This property is only applicable when the [[barBorderColorType]]
   * property is set to <i>Color</i>.
   * </p>
   * @see [[barBorderColorType]]
   */
  set barBorderColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._l)) {
      let b = NegativeBarFormat._a[2].g(NegativeBarFormat.$, WorkbookColorInfo.$, this, this._l, a);
      this._l = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _p() {
    let a = null;
    switch (this.barBorderColorType) {
      case 1:
        a = this._d._ct;
        break;
      default:
        a = WorkbookColorInfo.l_op_Inequality(this._l, null) ? this._l : DataBarConditionalFormat._cw;
        break;
    }
    return a;
  }
  /**
   * Returns a [[WorkbookColorInfo]] which defines the fill color
   * applied to data bars with a negative value.
   * <p class="body">
   * This property is only applicable when the [[barColorType]]
   * property is set to <i>Color</i>.
   * </p>
   * @see [[barBorderColorType]]
   */
  get barColor() {
    return this._m;
  }
  /**
   * Returns a [[WorkbookColorInfo]] which defines the fill color
   * applied to data bars with a negative value.
   * <p class="body">
   * This property is only applicable when the [[barColorType]]
   * property is set to <i>Color</i>.
   * </p>
   * @see [[barBorderColorType]]
   */
  set barColor(a) {
    if (WorkbookColorInfo.l_op_Inequality(a, this._m)) {
      let b = NegativeBarFormat._a[0].g(NegativeBarFormat.$, WorkbookColorInfo.$, this, this._m, a);
      this._m = b.p1;
    }
  }
  /**
   * @hidden
   */
  get _r() {
    let a = null;
    switch (this.barColorType) {
      case 1:
        a = this._d._cv;
        break;
      default:
        a = WorkbookColorInfo.l_op_Inequality(this._m, null) ? this._m : NegativeBarFormat._s;
        break;
    }
    return a;
  }
  /**
   * @hidden
   */
  static get _s() {
    return NegativeBarFormat._n;
  }
  /**
   * @hidden
   */
  _k(a, b) {
    let c = new NegativeBarFormat(a, runOn(a, a._dz));
    c._l = b ? ExcelUtils.ah(this._l, this._d.workbook) : this._l;
    c._e = this._e;
    c._m = b ? ExcelUtils.ah(this._m, this._d.workbook) : this._m;
    c._f = this._f;
    return c;
  }
  /**
   * @hidden
   */
  static _c($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(NegativeBarFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b() {
    let a = new Array(4);
    ChangeInfo.f(a, 0, NegativeBarFormat._c(WorkbookColorInfo.$, "BarColor", (b) => b.barColor, (b, c) => b.barColor = c));
    ChangeInfo.f(a, 1, NegativeBarFormat._c(DataBarNegativeBarColorType_$type, "BarColorType", (b) => b.barColorType, (b, c) => b.barColorType = c));
    ChangeInfo.f(a, 2, NegativeBarFormat._c(WorkbookColorInfo.$, "BarBorderColor", (b) => b.barBorderColor, (b, c) => b.barBorderColor = c));
    ChangeInfo.f(a, 3, NegativeBarFormat._c(DataBarNegativeBarColorType_$type, "BarBorderColorType", (b) => b.barBorderColorType, (b, c) => b.barBorderColorType = c));
    return a;
  }
  /**
   * @hidden
   */
  _ae(a) {
    if (this._t != null) {
      this._t(a);
    }
  }
  /**
   * @hidden
   */
  _u() {
    return this._f != 0 || this._e != 1 || WorkbookColorInfo.l_op_Inequality(this._m, null) || WorkbookColorInfo.l_op_Inequality(this._l, null);
  }
  /**
   * @hidden
   */
  get source() {
    return this;
  }
  /**
   * @hidden
   */
  get workbook() {
    return this._d.workbook;
  }
  /**
   * @hidden
   */
  get sheet() {
    return this._d.worksheet;
  }
}
NegativeBarFormat.$t = markType(NegativeBarFormat, 'NegativeBarFormat', Base.$, [IChangeInfoContext_$type]);
/**
 * @hidden
 */
NegativeBarFormat._aa = "BarColor";
/**
 * @hidden
 */
NegativeBarFormat._ac = "BarBorderColor";
/**
 * @hidden
 */
NegativeBarFormat._ab = "BarColorType";
/**
 * @hidden
 */
NegativeBarFormat._ad = "BarBorderColorType";
/**
 * @hidden
 */
NegativeBarFormat._i = 0;
/**
 * @hidden
 */
NegativeBarFormat._j = 1;
/**
 * @hidden
 */
NegativeBarFormat._x = 0;
/**
 * @hidden
 */
NegativeBarFormat._y = 1;
/**
 * @hidden
 */
NegativeBarFormat._v = 2;
/**
 * @hidden
 */
NegativeBarFormat._w = 3;
/**
 * @hidden
 */
NegativeBarFormat._z = 4;
/**
 * @hidden
 */
NegativeBarFormat._a = NegativeBarFormat._b();
/**
 * @hidden
 */
NegativeBarFormat._n = new WorkbookColorInfo(ExcelUtils.gw(255, 0, 0));
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a non-empty value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export class NoBlanksConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 12);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  _h() {
    return new NoBlanksConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(NoBlanksConditionalFormat.$, a);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (a == null) {
      return ConditionMatchResult.f;
    }
    let e = typeCast(String_$type, a);
    return !(e != null && stringIsNullOrWhiteSpace(e)) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
NoBlanksConditionalFormat.$t = markType(NoBlanksConditionalFormat, 'NoBlanksConditionalFormat', ConditionalFormatBase.$);
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which does not constitute an error.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[ErrorsConditionalFormat]] class.
 * </p>
 * @see [[ErrorsConditionalFormat]]
 */
export class NoErrorsConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 14);
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  _h() {
    return new NoErrorsConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(NoErrorsConditionalFormat.$, a);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    return !(typeCast(ErrorValue.$, a) !== null) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
NoErrorsConditionalFormat.$t = markType(NoErrorsConditionalFormat, 'NoErrorsConditionalFormat', ConditionalFormatBase.$);
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a logical operator.
 * @see [[operator]]
 * @see [[operand1]]
 */
export class OperatorConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b7 = 0;
          this._cb = null;
          this._cc = null;
          this._b2 = null;
          this._b3 = null;
          this._b4 = null;
          this._b5 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c, 0);
          this._b7 = 0;
          this._cb = null;
          this._cc = null;
          this._b2 = null;
          this._b3 = null;
          this._b4 = null;
          this._b5 = null;
          this._b7 = d;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__x() {
    return true;
  }
  /**
   * @hidden
   */
  _h() {
    return new OperatorConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(OperatorConditionalFormat.$, a);
    this._b7 = c._b7;
    if (c._cb != null) {
      this._cb = this._m(typeCast(SingleTargetFormula.$, c._cb._g()));
    }
    if (c._cc != null) {
      this._cc = this._m(typeCast(SingleTargetFormula.$, c._cc._g()));
    }
  }
  /**
   * @hidden
   */
  _a9(a) {
    if (this._cb != null) {
      a(this.worksheet, this._cb);
    }
    if (this._cc != null) {
      a(this.worksheet, this._cc);
    }
  }
  /**
   * @hidden
   */
  _a5() {
    super._a5();
    this._b2 = null;
    this._b3 = null;
    this._b4 = null;
    this._b5 = null;
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (this._cb == null) {
      return ConditionMatchResult.f;
    }
    if (this._b2 == null) {
      let e;
      let f = Nullable$1.toNullable(UltraCalcOperatorFunction_$type, null);
      switch (this._b7) {
        case 0:
          e = 6;
          f = Nullable$1.toNullable(UltraCalcOperatorFunction_$type, 8);
          break;
        case 1:
          e = 9;
          f = Nullable$1.toNullable(UltraCalcOperatorFunction_$type, 7);
          break;
        case 2:
          e = 4;
          break;
        case 3:
          e = 5;
          break;
        case 4:
          e = 7;
          break;
        case 6:
          e = 6;
          break;
        case 5:
          e = 9;
          break;
        case 7:
          e = 8;
          break;
        default: return ConditionMatchResult.f;
      }
      this._b2 = this.workbook._w.d._b(e);
      this._b3 = nullableNotEquals(f, null) ? this.workbook._w.d._b(f.value) : null;
      this._b4 = null;
      this._b5 = null;
    }
    if (this._b4 == null) {
      if (this._b2 != null) {
        this._b4 = this._cb._cf(this.workbook, d, false);
      }
      if (this._b3 != null) {
        if (this._cc == null) {
          return ConditionMatchResult.f;
        }
        this._b5 = this._cc._cf(this.workbook, d, false);
      }
    }
    if (this._b4 == null || this._b4.isError) {
      return ConditionMatchResult.f;
    }
    let g = new ExcelCalcNumberStack(d, this._cb);
    let h = new ExcelCalcValue(a);
    g.push(h);
    g.push(this._b4);
    this._b2._aj(g, 2);
    let i = g.pop();
    if (i.isBoolean) {
      let j = i._toBoolean1();
      let k = !(this._cc == null || this._b5 == null);
      if (j) {
        if (false == k || this._b7 == 1) {
          return ConditionMatchResult.e;
        }
      }
      else {
        if (false == k || this._b7 == 0) {
          return ConditionMatchResult.f;
        }
      }
      if (!k) {
        return j ? ConditionMatchResult.e : ConditionMatchResult.f;
      }
      g.push(h);
      g.push(this._b5);
      this._b3._aj(g, 2);
      let l = g.pop();
      if (l.isBoolean && l._toBoolean1()) {
        return ConditionMatchResult.e;
      }
    }
    return ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  _bd() {
    this._m(this._cd);
    this._m(this._ce);
  }
  /**
   * @hidden
   */
  get__ah() {
    return this._cb != null;
  }
  /**
   * @hidden
   */
  _bq(a, b, c) {
    if (this._cb != null) {
      let d = this._bp(a, 1, this._cb, b, c);
      this._cb = d.p2;
    }
    if (this._cc != null) {
      let e = this._bp(a, 2, this._cc, b, c);
      this._cc = e.p2;
    }
    super._bq(a, b, c);
  }
  /**
   * @hidden
   */
  _a4(a, b) {
    if (typeof a === 'number') {
      let c = typeGetValue(a);
      if (1 == c) {
        return ((() => { let d = this._a3(b, this._cb); this._cb = d.p1; return d.ret; })());
      }
      if (2 == c) {
        return ((() => { let d = this._a3(b, this._cc); this._cc = d.p1; return d.ret; })());
      }
    }
    return null;
  }
  /**
   * Returns a [[FormatConditionOperator]] constant which determines the
   * manner in which the cell value is compared against the [[operand1]]
   * property.
   * <p class="body">
   * This property determines how the cell value is compared to the [[operand1]]
   * property; for example, whether it is equal, greater than, less than, etc.
   * </p>
   * <p class="body">
   * For the [[FormatConditionOperator]] values 'Between' and 'NotBetween',
   * the [[operand2]] property must also be set.
   * </p>
   * @see [[operand1]]
   * @see [[operand2]]
   */
  get operator() {
    return this._b7;
  }
  /**
   * Returns a [[FormatConditionOperator]] constant which determines the
   * manner in which the cell value is compared against the [[operand1]]
   * property.
   * <p class="body">
   * This property determines how the cell value is compared to the [[operand1]]
   * property; for example, whether it is equal, greater than, less than, etc.
   * </p>
   * <p class="body">
   * For the [[FormatConditionOperator]] values 'Between' and 'NotBetween',
   * the [[operand2]] property must also be set.
   * </p>
   * @see [[operand1]]
   * @see [[operand2]]
   */
  set operator(a) {
    if (a != this._b7) {
      let b = OperatorConditionalFormat._b0[0].g(OperatorConditionalFormat.$, FormatConditionOperator_$type, this, this._b7, a);
      this._b7 = b.p1;
    }
  }
  /**
   * Returns the <see cref="Excel.Formula">formula</see> which defines
   * the criteria for the first operand of this condition.
   * <p class="body">
   * This property is not directly settable; however, the following methods can be used to
   * assign a formula:
   * </p>
   * <p class="body">
   * <ul>
   *     <li>[[setOperand1]]</li>
   *     <li>[[setOperand1]]</li>
   *     <li>[[setOperand1]]</li>
   *     <li>[[setOperand1Formula]]</li>
   * </ul>
   * </p>
   * <p class="body">
   * When the [[operator]] property is set
   * to <i>Between</i> or <i>NotBetween</i>, this property defines the
   * lower limit of the range for "between" comparisons.
   * </p>
   * <p class="body">
   * Use the [[operand2]] property to define the
   * upper limit of the range for "between" comparisons.
   * </p>
   * @see [[setOperand1]]
   * @see [[setOperand1]]
   * @see [[setOperand1]]
   * @see [[setOperand1Formula]]
   * @see [[operand2]]
   */
  get operand1() {
    return this._cb;
  }
  /**
   * @hidden
   */
  get _cd() {
    return this._cb;
  }
  /**
   * @hidden
   */
  set _cd(a) {
    if (a != this._cb) {
      if (a != null && a._ch == null) {
        this._m(a);
      }
      let b = OperatorConditionalFormat._b0[1].g(OperatorConditionalFormat.$, SingleTargetFormula.$, this, this._cb, a);
      this._cb = b.p1;
    }
  }
  /**
   * Returns or sets a <see cref="Excel.Formula">formula</see> for the second operand
   * which defines the criteria for this condition when the [[operator]]
   * property is set to <i>Between</i> or <i>NotBetween</i>
   * <p class="body">
   * This property is only applicable when the [[operator]] property is set
   * to <i>Between</i> or <i>NotBetween</i>.
   * </p>
   * <p class="body">
   * Use this property to define the upper limit of the range for "between" comparisons, and the
   * [[operand1]] property to define the lower limit.
   * </p>
   * <p class="body">
   * This property is not directly settable; however, the following methods can be used to
   * assign a formula:
   * </p>
   * <p class="body">
   * <ul>
   *     <li>[[setOperand2]]</li>
   *     <li>[[setOperand2]]</li>
   *     <li>[[setOperand2]]</li>
   *     <li>[[setOperand2Formula]]</li>
   * </ul>
   * </p>
   * @see [[setOperand2]]
   * @see [[setOperand2]]
   * @see [[setOperand2]]
   * @see [[setOperand2Formula]]
   * @see [[operand1]]
   */
  get operand2() {
    return this._cc;
  }
  /**
   * @hidden
   */
  get _ce() {
    return this._cc;
  }
  /**
   * @hidden
   */
  set _ce(a) {
    if (a != this._cc) {
      if (a != null && a._ch == null) {
        this._m(a);
      }
      let b = OperatorConditionalFormat._b0[2].g(OperatorConditionalFormat.$, SingleTargetFormula.$, this, this._cc, a);
      this._cc = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _b6($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(OperatorConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, OperatorConditionalFormat._b6(FormatConditionOperator_$type, "Operator", (b) => b.operator, (b, c) => b.operator = c));
    ChangeInfo.f(a, 1, OperatorConditionalFormat._b6(SingleTargetFormula.$, "Operand1Internal", (b) => b._cd, (b, c) => b._cd = c));
    ChangeInfo.f(a, 2, OperatorConditionalFormat._b6(SingleTargetFormula.$, "Operand2Internal", (b) => b._ce, (b, c) => b._ce = c));
    return a;
  }
  /**
   * @hidden
   */
  static _ck(a, b) {
    let c = ExcelCalcValue._dateTimeToExcelDate(b, a);
    if (c.hasValue == false) {
      throw new ArgumentOutOfRangeException(1, "value");
    }
    let d = numberToString(c.value, OperatorConditionalFormat._cf(b));
    return FormulaConditionalFormat._b9(d);
  }
  /**
   * @hidden
   */
  static _cf(a) {
    return a != null ? a._e6 : ExcelUtils.cq;
  }
  /**
   * Assigns a [[Formula]] to the [[operand1]] property.
   * <p class="body">
   * Note that the value of the 'formula' parameter must begin with an
   * equals sign (=).
   * </p>
   * @param formula The string representation of the [[Formula]] to be assigned to the [[operand1]] property.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @see [[operand1]]
   * @see [[setOperand1]]
   * @see [[setOperand1]]
   * @see [[setOperand1]]
   * @see [[setOperand2Formula]]
   */
  setOperand1Formula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setOperand1Formula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setOperand1Formula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    this._cd = this._o(a, b);
  }
  /**
   * Assigns a [[Formula]] to the [[operand2]] property.
   * <p class="body">
   * Note that the value of the 'formula' parameter must begin with an
   * equals sign (=).
   * </p>
   * @param formula The string representation of the [[Formula]] to be assigned to the [[operand2]] property.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   * @see [[operand2]]
   * @see [[operand1]]
   * @see [[setOperand2]]
   * @see [[setOperand2]]
   * @see [[setOperand2]]
   * @see [[setOperand1Formula]]
   */
  setOperand2Formula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setOperand2Formula$i.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setOperand2Formula$i(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    this._ce = this._o(a, b);
  }
  setOperand1() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeof arguments[0] === 'string') {
        n = 2;
      }
      else if (typeCast(Date_$type, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    switch (n) {
      case 0: return this._setOperand1.apply(this, arguments);
      case 1: return this._setOperand11.apply(this, arguments);
      case 2: return this._setOperand12.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setOperand11(a) {
    let b = numberToString(a, OperatorConditionalFormat._cf(this.workbook));
    b = FormulaConditionalFormat._b9(b);
    this._setOperand1Formula$i(b);
  }
  /**
   * @hidden
   */
  _setOperand12(a) {
    let b = FormulaConditionalFormat._b9(a);
    this._setOperand1Formula$i(b);
  }
  /**
   * @hidden
   */
  _setOperand1(a) {
    let b = OperatorConditionalFormat._ck(a, this.workbook);
    this._setOperand1Formula$i(b);
  }
  setOperand2() {
    let n;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        n = 1;
      }
      else if (typeof arguments[0] === 'string') {
        n = 2;
      }
      else if (typeCast(Date_$type, arguments[0]) !== null) {
        n = 0;
      }
      else if (arguments[0] == null) {
        n = 2;
      }
    }
    switch (n) {
      case 0: return this._setOperand2.apply(this, arguments);
      case 1: return this._setOperand21.apply(this, arguments);
      case 2: return this._setOperand22.apply(this, arguments);
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _setOperand21(a) {
    let b = numberToString(a, OperatorConditionalFormat._cf(this.workbook));
    b = FormulaConditionalFormat._b9(b);
    this._setOperand2Formula$i(b);
  }
  /**
   * @hidden
   */
  _setOperand22(a) {
    let b = FormulaConditionalFormat._b9(a);
    this._setOperand2Formula$i(b);
  }
  /**
   * @hidden
   */
  _setOperand2(a) {
    let b = OperatorConditionalFormat._ck(a, this.workbook);
    this._setOperand2Formula$i(b);
  }
  /**
   * @hidden
   */
  get__z() {
    return ConditionBase._aa(this.operand1, this.worksheet) || ConditionBase._aa(this.operand2, this.worksheet);
  }
}
OperatorConditionalFormat.$t = markType(OperatorConditionalFormat, 'OperatorConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
OperatorConditionalFormat._cj = 0;
/**
 * @hidden
 */
OperatorConditionalFormat._ch = 1;
/**
 * @hidden
 */
OperatorConditionalFormat._ci = 2;
/**
 * @hidden
 */
OperatorConditionalFormat._cg = 3;
/**
 * @hidden
 */
OperatorConditionalFormat._b0 = OperatorConditionalFormat._b1();
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is within the top or bottom rank of values across the
 * associated range.
 * <p class="body">
 * A rank condition evaluates to true if a cell value is within the range defined by
 * the top or bottom <i>n</i> values across the associated range, where <i>n</i> represents
 * the [[rank]].
 * </p>
 * <p class="body">
 * A popular example of a rank condition is "top ten ", where cell values which are within
 * the range of the ten highest values across the range meet the condition. The [[rank]]
 * property, however, can be set to any arbitrary number or percentage, and is not limited to only
 * the top or bottom ten values.
 * </p>
 * <p class="body">
 * By default, this condition evaluates to true if a cell's value is at or above the specified rank;
 * to change this to the bottom of the ranking, set the [[topBottom]] property to 'Bottom'.
 * </p>
 * <p class="body">
 * The numeric criteria can be changed to a percentage using the [[isPercent]] property.
 * In this case, the <i>Rank</i> property is interepreted as a percentage.
 * </p>
 */
export class RankConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b3 = 0;
          this._b6 = false;
          this._b8 = 0;
          this._b5 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(c, 4);
          this._b3 = 0;
          this._b6 = false;
          this._b8 = 0;
          this._b5 = null;
          this._b3 = d;
          this._b8 = e;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  _h() {
    return new RankConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(RankConditionalFormat.$, a);
    this._b6 = c._b6;
    this._b8 = c._b8;
    this._b3 = c._b3;
  }
  /**
   * @hidden
   */
  _a5() {
    super._a5();
    this._b5 = null;
  }
  /**
   * @hidden
   */
  get__j() {
    return 1;
  }
  /**
   * Returns or sets a boolean value indicating whether the [[rank]] is determined
   * by a percentage value.
   * <p class="body">
   * By default, this condition evaluates cell values against the value of the [[rank]]
   * property, with the rank representing an explicit numeric value. Set this property to true
   * to identify the rank as a percentage.
   * </p>
   * <p class="body">
   * If the <i>IsPercent</i> property is set to true, this property supports only values
   * between 1 and 100, inclusively.
   * </p>
   */
  get isPercent() {
    return this._b6;
  }
  /**
   * Returns or sets a boolean value indicating whether the [[rank]] is determined
   * by a percentage value.
   * <p class="body">
   * By default, this condition evaluates cell values against the value of the [[rank]]
   * property, with the rank representing an explicit numeric value. Set this property to true
   * to identify the rank as a percentage.
   * </p>
   * <p class="body">
   * If the <i>IsPercent</i> property is set to true, this property supports only values
   * between 1 and 100, inclusively.
   * </p>
   */
  set isPercent(a) {
    if (a != this._b6) {
      let b = RankConditionalFormat._b0[0].g(RankConditionalFormat.$, Boolean_$type, this, this._b6, a);
      this._b6 = b.p1;
    }
  }
  /**
   * Returns or sets a value which specifies either the number or percentage
   * of the rank value for the associated condition.
   * <p class="body">
   * The default value of this property is 10, and the default value for the [[topBottom]]
   * property is 'Top', so that creating an instance of this class without specifying non-default
   * property values results in a "top ten" condition.
   * </p>
   * <p class="body">
   * The value of this property is interepreted as either a number or a percentage,
   * depending on the value of the [[isPercent]] property.
   * </p>
   * <p class="body">
   * If the <i>IsPercent</i> property is set to true, this property supports only values
   * between 1 and 100, inclusively.
   * </p>
   * @see [[isPercent]]
   */
  get rank() {
    return this._b8;
  }
  /**
   * Returns or sets a value which specifies either the number or percentage
   * of the rank value for the associated condition.
   * <p class="body">
   * The default value of this property is 10, and the default value for the [[topBottom]]
   * property is 'Top', so that creating an instance of this class without specifying non-default
   * property values results in a "top ten" condition.
   * </p>
   * <p class="body">
   * The value of this property is interepreted as either a number or a percentage,
   * depending on the value of the [[isPercent]] property.
   * </p>
   * <p class="body">
   * If the <i>IsPercent</i> property is set to true, this property supports only values
   * between 1 and 100, inclusively.
   * </p>
   * @see [[isPercent]]
   */
  set rank(a) {
    if (a != this._b8) {
      let b = RankConditionalFormat._b0[1].g(RankConditionalFormat.$, Number_$type, this, this._b8, a);
      this._b8 = b.p1;
    }
  }
  /**
   * @hidden
   */
  get__ah() {
    return !this.isPercent;
  }
  /**
   * Returns or sets a value indicating whether a cell value must fall within
   * the top or bottom of the ranking across the associated range.
   */
  get topBottom() {
    return this._b3;
  }
  /**
   * Returns or sets a value indicating whether a cell value must fall within
   * the top or bottom of the ranking across the associated range.
   */
  set topBottom(a) {
    if (a != this._b3) {
      let b = RankConditionalFormat._b0[2].g(RankConditionalFormat.$, FormatConditionTopBottom_$type, this, this._b3, a);
      this._b3 = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _b2($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(RankConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, RankConditionalFormat._b2(Boolean_$type, "IsPercent", (b) => b.isPercent, (b, c) => b.isPercent = c));
    ChangeInfo.f(a, 1, RankConditionalFormat._b2(Number_$type, "Rank", (b) => b.rank, (b, c) => b.rank = c));
    ChangeInfo.f(a, 2, RankConditionalFormat._b2(FormatConditionTopBottom_$type, "TopBottom", (b) => b.topBottom, (b, c) => b.topBottom = c));
    return a;
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    let e = false;
    if (this.isPercent) {
      let f = ConditionBase._at(this.workbook, a);
      if (isNaN_(f)) {
        return ConditionMatchResult.f;
      }
      let g = this._bz;
      if (isNaN_(g)) {
        let h = this.rank / 100;
        let i = this.topBottom == 0 ? h : 1 - h;
        g = ExcelUtils.cg(this.workbook, i, this.regions);
        this._bz = g;
      }
      if (isNegativeInfinity(g)) {
        return ConditionMatchResult.f;
      }
      switch (this.topBottom) {
        default:
        case 0:
          e = f <= g;
          break;
        case 1:
          e = f >= g;
          break;
      }
    }
    else {
      if (this._b5 == null) {
        this._b5 = new RankConditionalFormat_ValueCache(this);
      }
      let j;
      if (!((() => { let k = ExcelUtils.by(a, this.workbook, this.workbook._e6, false, j); j = k.p4; return k.ret; })())) {
        return ConditionMatchResult.f;
      }
      e = this._b5.a(j);
    }
    return e ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
}
RankConditionalFormat.$t = markType(RankConditionalFormat, 'RankConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
RankConditionalFormat._ch = "TopBottom";
/**
 * @hidden
 */
RankConditionalFormat._cf = "IsPercent";
/**
 * @hidden
 */
RankConditionalFormat._cg = "Rank";
/**
 * @hidden
 */
RankConditionalFormat._b9 = 10;
/**
 * @hidden
 */
RankConditionalFormat._ca = 0;
/**
 * @hidden
 */
RankConditionalFormat._cd = 1;
/**
 * @hidden
 */
RankConditionalFormat._ce = 2;
/**
 * @hidden
 */
RankConditionalFormat._cb = 3;
/**
 * @hidden
 */
RankConditionalFormat._b0 = RankConditionalFormat._b1();
/**
 * @hidden
 */
export class RankConditionalFormat_ValueCache extends Base {
  constructor(a) {
    super();
    this.b = null;
    let b = a.workbook;
    let c = b._e6;
    let d = new List$1(Number_$type, 0);
    for (let e of fromEnum(ExcelUtils.ca(a.regions))) {
      if (e == null) {
        continue;
      }
      let f;
      if (((() => { let g = ExcelUtils.by(e, b, c, false, f); f = g.p4; return g.ret; })())) {
        d.add(f);
      }
    }
    d.y();
    let g = a.topBottom == 0;
    let h = Math.max(0, g ? 0 : d.count - a.rank);
    let i = Math.min(d.count - 1, g ? a.rank - 1 : d.count - 1);
    this.b = new HashSet$1(Number_$type, 0);
    for (let j = h; j <= i; j++) {
      this.b.add_1(d._inner[j]);
    }
    this.b.v();
  }
  get c() {
    return this.b.count;
  }
  a(a) {
    return this.b.contains(a);
  }
}
RankConditionalFormat_ValueCache.$t = markType(RankConditionalFormat_ValueCache, 'RankConditionalFormat_ValueCache');
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's text value meets the criteria defined by a string and a
 * [[FormatConditionTextOperator]] value.
 */
export class TextOperatorConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b8 = null;
          this._b9 = null;
          this._b3 = 0;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          super(c, 8);
          this._b8 = null;
          this._b9 = null;
          this._b3 = 0;
          this._b8 = d;
          this._b3 = e;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  get__am() {
    return true;
  }
  /**
   * Returns or sets the string value against which cell text is compared.
   */
  get text() {
    return this._b8;
  }
  /**
   * Returns or sets the string value against which cell text is compared.
   */
  set text(a) {
    if (a != this._b8) {
      let b = TextOperatorConditionalFormat._b0[0].g(TextOperatorConditionalFormat.$, String_$type, this, this._b8, a);
      this._b8 = b.p1;
    }
  }
  /**
   * Returns or sets a [[FormatConditionTextOperator]] value which
   * determines the manner in which the cell text is compared to the value of the
   * [[text]] property.
   */
  get textOperator() {
    return this._b3;
  }
  /**
   * Returns or sets a [[FormatConditionTextOperator]] value which
   * determines the manner in which the cell text is compared to the value of the
   * [[text]] property.
   */
  set textOperator(a) {
    if (a != this._b3) {
      let b = TextOperatorConditionalFormat._b0[1].g(TextOperatorConditionalFormat.$, FormatConditionTextOperator_$type, this, this._b3, a);
      this._b3 = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _b2($tValue, a, b, c, d = null, e = true, f = 4) {
    return new ChangeInfo$2(TextOperatorConditionalFormat.$, $tValue, a, 28, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _b1() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, TextOperatorConditionalFormat._b2(String_$type, "Text", (b) => b.text, (b, c) => b.text = c));
    ChangeInfo.f(a, 1, TextOperatorConditionalFormat._b2(FormatConditionTextOperator_$type, "TextOperator", (b) => b.textOperator, (b, c) => b.textOperator = c));
    return a;
  }
  /**
   * @hidden
   */
  _h() {
    return new TextOperatorConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a5() {
    super._a5();
    this._b9 = null;
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
    let c = typeCast(TextOperatorConditionalFormat.$, a);
    this._b8 = c._b8;
    this._b3 = c._b3;
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    let e = typeCast(String_$type, a);
    let f = false;
    if (!stringIsNullOrEmpty(this._b8)) {
      if (e == null || e.length < this._b8.length) {
        f = this._b3 == 3;
      }
      else {
        let g = this.workbook._e6;
        if (this._b9 == null) {
          this._b9 = stringToLocaleLower(this._b8, g);
        }
        let h = stringToLocaleLower(e, g);
        switch (this._b3) {
          case 0:
            f = h.substr(0, this._b8.length) == this._b9;
            break;
          case 1:
            f = h.substr(e.length - this._b8.length, this._b8.length) == this._b9;
            break;
          case 2:
            f = stringContains(h, this._b9);
            break;
          default:
          case 3:
            f = !stringContains(h, this._b9);
            break;
        }
      }
    }
    return f ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  static _ce(a, b, c = "A1") {
    let d = null;
    switch (b) {
      case 0:
        d = stringFormat("LEFT({0},LEN(\"{1}\"))=\"{1}\"", c, a);
        break;
      case 2:
        d = stringFormat("NOT(ISERROR(SEARCH(\"{1}\",{0})))", c, a);
        break;
      case 3:
        d = stringFormat("ISERROR(SEARCH(\"{1}\",{0}))", c, a);
        break;
      case 1:
        d = stringFormat("RIGHT({0},LEN(\"{1}\"))=\"{1}\"", c, a);
        break;
      default: break;
    }
    return d;
  }
}
TextOperatorConditionalFormat.$t = markType(TextOperatorConditionalFormat, 'TextOperatorConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
TextOperatorConditionalFormat._ch = "Text";
/**
 * @hidden
 */
TextOperatorConditionalFormat._cg = "TextOperator";
/**
 * @hidden
 */
TextOperatorConditionalFormat._ca = "LEFT({0},LEN(\"{1}\"))=\"{1}\"";
/**
 * @hidden
 */
TextOperatorConditionalFormat._cb = "NOT(ISERROR(SEARCH(\"{1}\",{0})))";
/**
 * @hidden
 */
TextOperatorConditionalFormat._cd = "ISERROR(SEARCH(\"{1}\",{0}))";
/**
 * @hidden
 */
TextOperatorConditionalFormat._cc = "RIGHT({0},LEN(\"{1}\"))=\"{1}\"";
/**
 * @hidden
 */
TextOperatorConditionalFormat._b6 = 0;
/**
 * @hidden
 */
TextOperatorConditionalFormat._b7 = 1;
/**
 * @hidden
 */
TextOperatorConditionalFormat._b5 = 2;
/**
 * @hidden
 */
TextOperatorConditionalFormat._b0 = TextOperatorConditionalFormat._b1();
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are unique across
 * the associated range.
 * </p>
 * @see [[DuplicateConditionalFormat]]
 */
export class UniqueConditionalFormat extends ConditionalFormatBase {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          super();
          this._b0 = null;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          super(c, 6);
          this._b0 = null;
        }
        break;
    }
  }
  /**
   * @hidden
   */
  get__j() {
    return 1;
  }
  /**
   * @hidden
   */
  get__al() {
    return false;
  }
  /**
   * @hidden
   */
  get__am() {
    return true;
  }
  /**
   * @hidden
   */
  _h() {
    return new UniqueConditionalFormat(0);
  }
  /**
   * @hidden
   */
  _a7(a, b) {
    super._a7(a, b);
  }
  /**
   * @hidden
   */
  _i(a, b, c, d) {
    if (a == null) {
      return ConditionMatchResult.f;
    }
    if (this._b0 == null) {
      this._b0 = new UniqueConditionalFormat_DuplicateValueHolder(this.regions);
    }
    return !this._b0.c(a) ? ConditionMatchResult.e : ConditionMatchResult.f;
  }
  /**
   * @hidden
   */
  _bb() {
    super._bb();
    this._b0 = null;
  }
  /**
   * @hidden
   */
  _bf() {
    super._bf();
    this._b0 = null;
  }
}
UniqueConditionalFormat.$t = markType(UniqueConditionalFormat, 'UniqueConditionalFormat', ConditionalFormatBase.$);
/**
 * @hidden
 */
UniqueConditionalFormat._b1 = "Unique";
/**
 * @hidden
 */
export class UniqueConditionalFormat_DuplicateValueHolder extends Base {
  constructor(a) {
    super();
    this.e = null;
    this.d = null;
    this.b = false;
    this.a = false;
    let b = new HashSet$1(String_$type, 2, StringComparer.c);
    let c = new HashSet$1(Base.$, 0);
    let d = new HashSet$1(String_$type, 2, StringComparer.c);
    let e = new HashSet$1(Base.$, 0);
    for (let f of fromEnum(ExcelUtils.ca(a))) {
      if (f == null) {
        continue;
      }
      let g = typeCast(String_$type, f);
      if (g != null) {
        if (d.contains(g)) {
          b.add_1(g);
        }
        else {
          d.add_1(g);
        }
      }
      else {
        if (e.contains(f)) {
          c.add_1(f);
        }
        else {
          e.add_1(f);
        }
      }
    }
    for (let h of fromEnum(b)) {
      d.remove(h);
    }
    for (let i of fromEnum(c)) {
      e.remove(i);
    }
    this.b = b.count <= d.count;
    this.a = c.count <= e.count;
    if (this.b) {
      this.e = b;
    }
    else {
      this.e = d;
    }
    if (this.a) {
      this.d = c;
    }
    else {
      this.d = e;
    }
    this.e.v();
    this.d.v();
  }
  c(a) {
    let b = typeCast(String_$type, a);
    let c = b != null ? this.e.contains(b) : this.d.contains(a);
    return b != null ? this.b == c : this.a == c;
  }
}
UniqueConditionalFormat_DuplicateValueHolder.$t = markType(UniqueConditionalFormat_DuplicateValueHolder, 'UniqueConditionalFormat_DuplicateValueHolder');
/**
 * Represents a unit label on an axis in a chart.
 */
export class DisplayUnitLabel extends ChartTextAreaBase {
  constructor() {
    super(null);
  }
}
DisplayUnitLabel.$t = markType(DisplayUnitLabel, 'DisplayUnitLabel', ChartTextAreaBase.$);
/**
 * Represents the major/minor gridlines for an [[Axis]].
 * <p class="body">
 * The color of the grid lines is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the grid lines is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export class ChartGridLines extends ChartLineBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(null);
          this._al = null;
          this._gridLineType = 0;
        }
        break;
      case 1:
        {
          let owner = _rest[0];
          super(owner);
          this._al = null;
          this._gridLineType = 0;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Returns a value indicating whether this instance
   * represents a major or minor gridline.
   */
  get gridLineType() {
    return this._gridLineType;
  }
  /**
   * Returns a value indicating whether this instance
   * represents a major or minor gridline.
   */
  set gridLineType(a) {
    this._gridLineType = a;
  }
  /**
   * @hidden
   */
  _an(a, b) {
    super._l(a);
    this.gridLineType = b;
  }
  /**
   * @hidden
   */
  get _ak() {
    if (this.fill != null) {
      return this.fill;
    }
    if (this._al == null) {
      let a = this.gridLineType == 0 ? 0.15 : 0.05;
      let b = this.gridLineType == 0 ? 0.85 : 0.95;
      this._al = ChartSolidFill._w(1, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, a), Nullable$1.toNullable(Number_$type, b));
    }
    return this._al;
  }
}
ChartGridLines.$t = markType(ChartGridLines, 'ChartGridLines', ChartLineBase.$);
/**
 * Represents the tick lines for an [[Axis]].
 * <p class="body">
 * The color of the tick line is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the tick line is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 * @see [[Axis.tickLines]]
 */
export class ChartTickLines extends ChartLineBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(null);
        }
        break;
      case 1:
        {
          let owner = _rest[0];
          super(owner);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get _ak() {
    if (this.fill != null) {
      return this.fill;
    }
    let a = this.chart;
    if (a != null) {
      return a._ey;
    }
    return ChartSolidFill._w(4);
  }
}
ChartTickLines.$t = markType(ChartTickLines, 'ChartTickLines', ChartLineBase.$);
/**
 * Represents a single axis in a chart.
 * <p class="body">
 * To change the color of the ticklines, use the [[ChartLineBase.fill]] property.
 * </p>
 */
export class Axis extends ChartObject {
  constructor(a, b, c) {
    super(a);
    this._ad = Axis._ae;
    this._ah = 0;
    this._av = null;
    this._bc = 0;
    this._an = -4105;
    this._af = -4105;
    this._bu = -1;
    this._aa = null;
    this._ax = -4142;
    this._bv = 0;
    this._az = null;
    this._dn = Nullable$1.toNullable(Number_$type, null);
    this._bw = 10;
    this._ap = null;
    this._a8 = 4;
    this._bx = 1;
    this._bd = 1;
    this._by = 0;
    this._bz = 0;
    this._aq = null;
    this._a9 = 2;
    this._b0 = 0.2;
    this._be = 0;
    this._aj = 0;
    this._a1 = -4132;
    this._a4 = 4;
    this._a6 = null;
    this._cd = 1;
    this._at = null;
    this._ce = 1;
    this._al = 0;
    this._ah = c;
    this._al = b;
    if (b == 1 && c == 2) {
      this._af = 2;
      this._dw(256, false);
    }
  }
  /**
   * @hidden
   */
  _a(a) {
    return Axis._w[a];
  }
  /**
   * @hidden
   */
  _m(a) {
    if (this._av != null) {
      this._av._m(a);
    }
    if (this._az != null) {
      this._az._m(a);
    }
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._av != null && this._av._i(a, b)) {
      return true;
    }
    if (this._az != null && this._az._i(a, b)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    if (this._av != null) {
      this._av._o(a, b, c);
    }
    if (this._az != null) {
      this._az._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._av != null) {
      this._av._t(a);
    }
    if (this._az != null) {
      this._az._t(a);
    }
  }
  /**
   * True if the value axis crosses the category axis between categories.
   */
  get axisBetweenCategories() {
    return this._bl(1);
  }
  /**
   * True if the value axis crosses the category axis between categories.
   */
  set axisBetweenCategories(a) {
    this._dx(0, 1, a);
  }
  /**
   * Returns the group for the specified axis. Read-only
   */
  get axisGroup() {
    return this._ah;
  }
  /**
   * Returns or sets a [[ChartTitle]] object that represents the title of the axis.
   */
  get axisTitle() {
    return this._av;
  }
  /**
   * Returns or sets a [[ChartTitle]] object that represents the title of the axis.
   */
  set axisTitle(a) {
    let b = this._av;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Axis.$, ChartTitle.$, this, 1, this._av, a);
      this._av = c.p2;
    }
  }
  /**
   * Returns or sets the base unit for the axis.
   * <para class="note">
   * Setting this property has no visible effect if the [[categoryType]]  property for the specified axis is set to 'CategoryScale'.
   * The set value is retained, however, and takes effect when the <b>CategoryType</b> property is set to 'TimeScale'.
   * </para>
   */
  get baseUnit() {
    return this._bc;
  }
  /**
   * Returns or sets the base unit for the axis.
   * <para class="note">
   * Setting this property has no visible effect if the [[categoryType]]  property for the specified axis is set to 'CategoryScale'.
   * The set value is retained, however, and takes effect when the <b>CategoryType</b> property is set to 'TimeScale'.
   * </para>
   */
  set baseUnit(a) {
    if (a != this._bc) {
      ExcelUtils.gl(TimeUnit_$type, a);
      this._s();
      let b = this.baseUnitIsAuto ? this._j(7) : null;
      let c = this._r(Axis.$, TimeUnit_$type, this, 2, this._bc, a);
      this._bc = c.p2;
      this.baseUnitIsAuto = false;
      this._p(b);
    }
  }
  /**
   * True if Excel chooses appropriate base units for the specified category axis. The default value is True.
   */
  get baseUnitIsAuto() {
    return this._bl(2);
  }
  /**
   * True if Excel chooses appropriate base units for the specified category axis. The default value is True.
   */
  set baseUnitIsAuto(a) {
    this._dx(3, 2, a);
  }
  /**
   * Returns or sets the category axis type.
   * <p class="body">
   * This property applies only to <see cref="Charts.AxisType">category</see> axes.
   * </p>
   * <p class="body">
   * When set to <i>Automatic</i>, the axis will resolve the
   * category type to either <i>CategoryScale</i> or <i>TimeScale</i>,
   * based on the type of the selected data.
   * </p>
   */
  get categoryType() {
    return this._an;
  }
  /**
   * Returns or sets the category axis type.
   * <p class="body">
   * This property applies only to <see cref="Charts.AxisType">category</see> axes.
   * </p>
   * <p class="body">
   * When set to <i>Automatic</i>, the axis will resolve the
   * category type to either <i>CategoryScale</i> or <i>TimeScale</i>,
   * based on the type of the selected data.
   * </p>
   */
  set categoryType(a) {
    if (a != this._an) {
      let b = this._q(Axis.$, CategoryType_$type, this, 4, this._an, a);
      this._an = b.p2;
    }
  }
  /**
   * Returns or sets the point on the specified axis where the other axis crosses.
   * <p class="body">
   * This property is only applicable to a category axis.
   * </p>
   * <p class="body">
   * Set this property to <i>Custom</i> to specify a data value as a crossing point,
   * using the [[crossesAt]] property to specify that value.
   * </p>
   * @see [[crossesAt]]
   */
  get crosses() {
    return this._af;
  }
  /**
   * Returns or sets the point on the specified axis where the other axis crosses.
   * <p class="body">
   * This property is only applicable to a category axis.
   * </p>
   * <p class="body">
   * Set this property to <i>Custom</i> to specify a data value as a crossing point,
   * using the [[crossesAt]] property to specify that value.
   * </p>
   * @see [[crossesAt]]
   */
  set crosses(a) {
    if (a != this._af) {
      let b = this._q(Axis.$, AxisCrosses_$type, this, 5, this._af, a);
      this._af = b.p2;
    }
  }
  /**
   * Returns or sets the point on the [[Axis]] at which the
   * perpendicular axis intersects it.
   * <p class="body">
   * For a category axis, this value is interpreted as the value of a data point.
   * For example, on a category axis with a minimum data value of 0 and a maximum
   * of 500, setting this property to 250 causes this axis to appear near the center
   * of the plot area.
   * </p>
   * <p class="body">
   * For a value axis, this value is interpreted as the one-based number of the
   * category with which this axis should intersect.
   * </p>
   * <p class="body">
   * Setting this property causes the [[crosses]] property to change to 'Custom'.
   * </p>
   * <p class="body">
   * This property cannot be used on radar charts.
   * </p>
   * <p class="body">
   * For 3-D charts, this property indicates where the plane defined
   * by the category axes crosses the value axis.
   * </p>
   */
  get crossesAt() {
    return this._bu >= 0 ? this._bu : 0;
  }
  /**
   * Returns or sets the point on the [[Axis]] at which the
   * perpendicular axis intersects it.
   * <p class="body">
   * For a category axis, this value is interpreted as the value of a data point.
   * For example, on a category axis with a minimum data value of 0 and a maximum
   * of 500, setting this property to 250 causes this axis to appear near the center
   * of the plot area.
   * </p>
   * <p class="body">
   * For a value axis, this value is interpreted as the one-based number of the
   * category with which this axis should intersect.
   * </p>
   * <p class="body">
   * Setting this property causes the [[crosses]] property to change to 'Custom'.
   * </p>
   * <p class="body">
   * This property cannot be used on radar charts.
   * </p>
   * <p class="body">
   * For 3-D charts, this property indicates where the plane defined
   * by the category axes crosses the value axis.
   * </p>
   */
  set crossesAt(a) {
    this._dy(a);
  }
  /**
   * @hidden
   */
  _dy(a, b = true) {
    if (a != this._bu) {
      let c = this._r(Axis.$, Number_$type, this, 6, this._bu, a);
      this._bu = c.p2;
      if (b) {
        let d = this._r(Axis.$, AxisCrosses_$type, this, 5, this._af, -4114);
        this._af = d.p2;
      }
    }
  }
  /**
   * @hidden
   */
  get _dp() {
    if (this.crosses != -4114) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    if (this._bu >= 0) {
      return Nullable$1.toNullable(Number_$type, this._bu);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  /**
   * @hidden
   */
  get _ab() {
    return this._aa;
  }
  /**
   * @hidden
   */
  set _ab(a) {
    if (a != this._aa) {
      if (a != null) {
        if (a == this) {
          throw new ArgumentException(0);
        }
        ChartObject._v(a.owner, this.owner);
      }
      this._aa = a;
    }
  }
  /**
   * @hidden
   */
  get _ac() {
    if (this._ab != null) {
      return this._ab;
    }
    let a = this.chart;
    let b = a != null ? a._axisCollection$i : null;
    if (b == null) {
      return null;
    }
    let c = this.type == 3;
    let d = (this.axisGroup == 1);
    let e = (d == false);
    let f = (this.type == 1);
    let g = (f == false);
    let h = b.item(1, 1);
    let i = b.item(2, 1);
    let j = b.item(1, 2);
    let k = b.item(2, 2);
    let l = null;
    if (c) {
      l = i != null ? i : k != null ? k : h;
    }
    if (d && f) {
      l = i;
    }
    else if (e && f) {
      l = k != null ? k : i;
    }
    else if (d && g) {
      l = h != null ? h : k;
    }
    else if (e && g) {
      l = j != null ? j : h != null ? h : i;
    }
    return l;
  }
  /**
   * @hidden
   */
  get _cg() {
    let a = this.type == 3;
    let b = (this.axisGroup == 1);
    let c = (b == false);
    let d = (this.type == 1);
    let e = (d == false);
    if (a) {
      return 3;
    }
    else if (b && d) {
      return 0;
    }
    else if (b && e) {
      return 1;
    }
    else if (c && d) {
      return 3;
    }
    else if (c && e) {
      return 2;
    }
    return -1;
  }
  /**
   * @hidden
   */
  _dr(a) {
    let b = this._ac;
    if (b == null) {
      return Nullable$1.toNullable(Number_$type, null);
    }
    return Nullable$1.toNullable(Number_$type, intSToU(b._cg));
  }
  /**
   * Returns or sets the unit label for the value axis.
   */
  get displayUnit() {
    return this._ax;
  }
  /**
   * Returns or sets the unit label for the value axis.
   */
  set displayUnit(a) {
    if (a != this._ax) {
      let b = this._q(Axis.$, DisplayUnit_$type, this, 7, this._ax, a);
      this._ax = b.p2;
    }
  }
  /**
   * If the value of the DisplayUnit property 'Custom' , the DisplayUnitCustom property returns or sets the value of the displayed units. The value must be from 0 through 10E307
   */
  get displayUnitCustom() {
    return this._bv;
  }
  /**
   * If the value of the DisplayUnit property 'Custom' , the DisplayUnitCustom property returns or sets the value of the displayed units. The value must be from 0 through 10E307
   */
  set displayUnitCustom(a) {
    if (a != this._bv) {
      let b = this._r(Axis.$, Number_$type, this, 8, this._bv, a, (b) => DocCoreUtils.av(Number_$type, b, "DisplayUnitCustom", 0, 1E+308));
      this._bv = b.p2;
    }
  }
  /**
   * Returns or sets an [[displayUnitLabel]] object.
   */
  get displayUnitLabel() {
    return this._az;
  }
  /**
   * Returns or sets an [[displayUnitLabel]] object.
   */
  set displayUnitLabel(a) {
    let b = this._az;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Axis.$, DisplayUnitLabel.$, this, 9, this._az, a);
      this._az = c.p2;
    }
  }
  /**
   * Returns or sets a value indicating the width of the gaps between data points
   * or series, expressed as a percentage.
   * <p class="body">
   * This property is only applicable for <i>Box and Whisker</i>, <i>Histogram</i>,
   * <i>Pareto</i>, and <i>Waterfall</i> charts.
   * </p>
   */
  get gapWidth() {
    return unwrapNullable(this._gapWidth$i);
  }
  /**
   * Returns or sets a value indicating the width of the gaps between data points
   * or series, expressed as a percentage.
   * <p class="body">
   * This property is only applicable for <i>Box and Whisker</i>, <i>Histogram</i>,
   * <i>Pareto</i>, and <i>Waterfall</i> charts.
   * </p>
   */
  set gapWidth(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._gapWidth$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _gapWidth$i() {
    return this._dn;
  }
  /**
   * @hidden
   */
  set _gapWidth$i(a) {
    if (nullableNotEquals(a, this._dn)) {
      let b = this._r(Axis.$, Nullable$1.$.specialize(Number_$type), this, 10, this._dn, a, (b) => {
        if (b.hasValue) {
          if (b.value < 0 || b.value > 500) {
            throw new ArgumentOutOfRangeException(1, "value");
          }
        }
      });
      this._dn = b.p2;
    }
  }
  /**
   * Returns or sets the base of the logarithm when you are using log scales.
   * <para class="note">
   * Attempting to set this property to a value less than 2 causes an error. The default value is 10.
   * </para>
   */
  get logBase() {
    return this._bw;
  }
  /**
   * Returns or sets the base of the logarithm when you are using log scales.
   * <para class="note">
   * Attempting to set this property to a value less than 2 causes an error. The default value is 10.
   * </para>
   */
  set logBase(a) {
    if (a != this._bw) {
      let b = this._r(Axis.$, Number_$type, this, 11, this._bw, a, (b) => {
        if (b < 2) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._bw = b.p2;
    }
  }
  /**
   * Returns a [[ChartGridLines]] object which defines
   * the color and weight of the major ticklines.
   */
  get majorGridLines() {
    return this._ap;
  }
  /**
   * Returns a [[ChartGridLines]] object which defines
   * the color and weight of the major ticklines.
   */
  set majorGridLines(a) {
    let b = this._ap;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._an(this, 0);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Axis.$, ChartGridLines.$, this, 12, this._ap, a);
      this._ap = c.p2;
    }
  }
  /**
   * Returns or sets the type of major tick mark for the specified axis.
   */
  get majorTickMark() {
    return this._a8;
  }
  /**
   * Returns or sets the type of major tick mark for the specified axis.
   */
  set majorTickMark(a) {
    if (a != this._a8) {
      let b = this._q(Axis.$, TickMark_$type, this, 13, this._a8, a);
      this._a8 = b.p2;
    }
  }
  /**
   * True if Excel calculates the major units for the value axis.
   */
  get majorUnitIsAuto() {
    return this._bl(4);
  }
  /**
   * True if Excel calculates the major units for the value axis.
   */
  set majorUnitIsAuto(a) {
    this._dx(15, 4, a);
  }
  /**
   * Returns the major interval unit.
   * <p class="body">
   * To set the value of this property, use the [[setMajorMinorUnit]] method.
   * </p>
   * @see [[setMajorMinorUnit]]
   * @see [[minorUnit]]
   */
  get majorUnit() {
    return this._bx;
  }
  /**
   * Returns the major interval unit.
   * <p class="body">
   * To set the value of this property, use the [[setMajorMinorUnit]] method.
   * </p>
   * @see [[setMajorMinorUnit]]
   * @see [[minorUnit]]
   */
  set majorUnit(a) {
    if (a != this._bx) {
      let b = this._r(Axis.$, Number_$type, this, 14, this._bx, a);
      this._bx = b.p2;
    }
  }
  /**
   * Returns or sets the major unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
   */
  get majorUnitScale() {
    return this._bd;
  }
  /**
   * Returns or sets the major unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
   */
  set majorUnitScale(a) {
    if (a != this._bd) {
      let b = this._q(Axis.$, TimeUnit_$type, this, 16, this._bd, a);
      this._bd = b.p2;
    }
  }
  /**
   * Returns or sets the maximum value on the value axis.
   */
  get maximumScale() {
    return this._by;
  }
  /**
   * Returns or sets the maximum value on the value axis.
   */
  set maximumScale(a) {
    if (a != this._by) {
      this._s();
      let b = this.maximumScaleIsAuto ? this._j(7) : null;
      let c = this._r(Axis.$, Number_$type, this, 17, this._by, a);
      this._by = c.p2;
      this.maximumScaleIsAuto = false;
      this._p(b);
    }
  }
  /**
   * True if Excel calculates the maximum value for the value axis.
   */
  get maximumScaleIsAuto() {
    return this._bl(8);
  }
  /**
   * True if Excel calculates the maximum value for the value axis.
   */
  set maximumScaleIsAuto(a) {
    this._dx(18, 8, a);
  }
  /**
   * Returns or sets the minimum value on the value axis.
   */
  get minimumScale() {
    return this._bz;
  }
  /**
   * Returns or sets the minimum value on the value axis.
   */
  set minimumScale(a) {
    if (a != this._bz) {
      this._s();
      let b = this.minimumScaleIsAuto ? this._j(7) : null;
      let c = this._r(Axis.$, Number_$type, this, 19, this._bz, a);
      this._bz = c.p2;
      this.minimumScaleIsAuto = false;
      this._p(b);
    }
  }
  /**
   * True if Excel calculates the minimum value for the value axis.
   */
  get minimumScaleIsAuto() {
    return this._bl(16);
  }
  /**
   * True if Excel calculates the minimum value for the value axis.
   */
  set minimumScaleIsAuto(a) {
    this._dx(20, 16, a);
  }
  /**
   * Returns a [[ChartGridLines]] object which defines
   * the color and weight of the minor ticklines.
   */
  get minorGridLines() {
    return this._aq;
  }
  /**
   * Returns a [[ChartGridLines]] object which defines
   * the color and weight of the minor ticklines.
   */
  set minorGridLines(a) {
    let b = this._aq;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._an(this, 1);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Axis.$, ChartGridLines.$, this, 21, this._aq, a);
      this._aq = c.p2;
    }
  }
  /**
   * Returns or sets the type of minor tick mark for the specified axis.
   */
  get minorTickMark() {
    return this._a9;
  }
  /**
   * Returns or sets the type of minor tick mark for the specified axis.
   */
  set minorTickMark(a) {
    if (a != this._a9) {
      let b = this._q(Axis.$, TickMark_$type, this, 22, this._a9, a);
      this._a9 = b.p2;
    }
  }
  /**
   * Returns the minor interval unit.
   * <p class="body">
   * To set the value of this property, use the [[setMajorMinorUnit]] method.
   * </p>
   * @see [[setMajorMinorUnit]]
   * @see [[majorUnit]]
   */
  get minorUnit() {
    return this._b0;
  }
  /**
   * Returns the minor interval unit.
   * <p class="body">
   * To set the value of this property, use the [[setMajorMinorUnit]] method.
   * </p>
   * @see [[setMajorMinorUnit]]
   * @see [[majorUnit]]
   */
  set minorUnit(a) {
    if (a != this._b0) {
      let b = this._r(Axis.$, Number_$type, this, 23, this._b0, a);
      this._b0 = b.p2;
    }
  }
  /**
   * True if Excel calculates the minor units for the value axis.
   */
  get minorUnitIsAuto() {
    return this._bl(32);
  }
  /**
   * True if Excel calculates the minor units for the value axis.
   */
  set minorUnitIsAuto(a) {
    this._dx(24, 32, a);
  }
  /**
   * Returns or sets the minor unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
   */
  get minorUnitScale() {
    return this._be;
  }
  /**
   * Returns or sets the minor unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
   */
  set minorUnitScale(a) {
    if (a != this._be) {
      let b = this._q(Axis.$, TimeUnit_$type, this, 25, this._be, a);
      this._be = b.p2;
    }
  }
  /**
   * Returns or sets an [[AxisPosition]] value which determines
   * the placement of the axis as relative to the chart space.
   * <p class="body">
   * This property is not applicable for series axes.
   * </p>
   */
  get position() {
    return this._aj;
  }
  /**
   * Returns or sets an [[AxisPosition]] value which determines
   * the placement of the axis as relative to the chart space.
   * <p class="body">
   * This property is not applicable for series axes.
   * </p>
   */
  set position(a) {
    if (a != this._aj) {
      let b = this._q(Axis.$, AxisPosition_$type, this, 26, this._aj, a);
      this._aj = b.p2;
    }
  }
  /**
   * True if Excel plots data points from last to first.
   */
  get reversePlotOrder() {
    return this._bl(64);
  }
  /**
   * True if Excel plots data points from last to first.
   */
  set reversePlotOrder(a) {
    this._dx(27, 64, a);
  }
  /**
   * Returns or sets a value indicating whether the axis scale is linear or logarithmic.
   * <p class="body">
   * This property is only applicable for <see cref="Type">value</see> axes.
   * </p>
   * <p class="body">
   * Logarithmic scaling is not supported for axes which are associated with a series
   * that contains negative values.
   * </p>
   */
  get scaleType() {
    return this._a1;
  }
  /**
   * Returns or sets a value indicating whether the axis scale is linear or logarithmic.
   * <p class="body">
   * This property is only applicable for <see cref="Type">value</see> axes.
   * </p>
   * <p class="body">
   * Logarithmic scaling is not supported for axes which are associated with a series
   * that contains negative values.
   * </p>
   */
  set scaleType(a) {
    if (a != this._a1) {
      let b = this._q(Axis.$, ScaleType_$type, this, 28, this._a1, a);
      this._a1 = b.p2;
    }
  }
  /**
   * Describes the position of tick-mark labels on the specified axis.
   */
  get tickLabelPosition() {
    return this._a4;
  }
  /**
   * Describes the position of tick-mark labels on the specified axis.
   */
  set tickLabelPosition(a) {
    if (a != this._a4) {
      let b = this._q(Axis.$, TickLabelPosition_$type, this, 29, this._a4, a);
      this._a4 = b.p2;
    }
  }
  /**
   * Returns a TickLabels object that represents the tick-mark labels for the specified axis. Read-only.
   */
  get tickLabels() {
    if (this._a6 == null) {
      this._a6 = new TickLabels(this);
    }
    return this._a6;
  }
  /**
   * Returns or sets the number of categories or series between tick-mark labels. Applies only to category and series axes. Can be a value from 1 through 31999.
   */
  get tickLabelSpacing() {
    return this._cd;
  }
  /**
   * Returns or sets the number of categories or series between tick-mark labels. Applies only to category and series axes. Can be a value from 1 through 31999.
   */
  set tickLabelSpacing(a) {
    if (a != this._cd) {
      DocCoreUtils.av(Number_$type, a, "TickLabelSpacing", 1, 31999);
      this._s();
      let b = this.tickLabelSpacingIsAuto ? this._j(7) : null;
      let c = this._r(Axis.$, Number_$type, this, 30, this._cd, a);
      this._cd = c.p2;
      this.tickLabelSpacingIsAuto = false;
      this._p(b);
    }
  }
  /**
   * Returns or sets whether or not the tick label spacing is automatic.
   */
  get tickLabelSpacingIsAuto() {
    return this._bl(128);
  }
  /**
   * Returns or sets whether or not the tick label spacing is automatic.
   */
  set tickLabelSpacingIsAuto(a) {
    this._dx(31, 128, a);
  }
  /**
   * Determines the appearance of the tick lines.
   * @see [[majorTickMark]]
   * @see [[minorTickMark]]
   */
  get tickLines() {
    return this._at;
  }
  /**
   * Determines the appearance of the tick lines.
   * @see [[majorTickMark]]
   * @see [[minorTickMark]]
   */
  set tickLines(a) {
    if (a != this._at) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._at != null) {
        this._at._l(null);
      }
      let b = this._r(Axis.$, ChartTickLines.$, this, 32, this._at, a);
      this._at = b.p2;
    }
  }
  /**
   * Returns or sets the number of categories or series between tick marks. Applies only to category and series axes. Can be a value from 1 through 31999.
   */
  get tickMarkSpacing() {
    return this._ce;
  }
  /**
   * Returns or sets the number of categories or series between tick marks. Applies only to category and series axes. Can be a value from 1 through 31999.
   */
  set tickMarkSpacing(a) {
    if (a != this._ce) {
      let b = this._r(Axis.$, Number_$type, this, 33, this._ce, a, (b) => DocCoreUtils.av(Number_$type, b, "TickMarkSpacing", 1, 31999));
      this._ce = b.p2;
    }
  }
  /**
   * Returns the type of the axis (read-only)
   */
  get type() {
    return this._al;
  }
  /**
   * Returns or sets whether or not the axis is visible.
   */
  get visible() {
    return this._bl(256);
  }
  /**
   * Returns or sets whether or not the axis is visible.
   */
  set visible(a) {
    this._dx(34, 256, a);
  }
  /**
   * @hidden
   */
  get _ds() {
    let a = this._ac;
    let b = a == null ? "NULL" : stringFormat("[{0}, {1}]", enumGetBox(AxisType_$type, a.type), enumGetBox(AxisGroup_$type, a.axisGroup));
    return stringFormat1("[{0}, {1}] ID={2}; CrossAxis={3}", enumGetBox(AxisType_$type, this.type), enumGetBox(AxisGroup_$type, this.axisGroup), this._cg, b);
  }
  /**
   * @hidden
   */
  get _b9() {
    let a = this.maximumScale;
    if (this._a1 == -4133) {
      a = Math.max(a, 1);
    }
    return a;
  }
  /**
   * @hidden
   */
  get _cb() {
    let a = this.minimumScale;
    if (this._a1 == -4133) {
      a = Math.max(a, 1);
    }
    return a;
  }
  /**
   * Sets the values of the [[majorUnit]] and [[minorUnit]] properties.
   * <p class="body">The value of the 'majorUnit' parameter must exceed the value of the 'minorUnit' parameter or an exception is thrown.</p>
   * <p class="body">
   * Typically the value of 'majorUnit' is an exact
   * multiple of 'minorUnit'; for example, for 5 minor
   * units per major unit, set majorUnit to 1 and minorUnit to .2.
   * </p>
   * @param majorUnit The new value for the [[majorUnit]] property.
   * @param minorUnit The new value for the [[minorUnit]] property.
   * @see [[majorUnit]]
   * @see [[minorUnit]]
   */
  setMajorMinorUnit(majorUnit, minorUnit) {
    if (majorUnit <= minorUnit) {
      throw new BaseError(1, ExcelUtils.ef("LE_Axis_MajorMinorUnit"));
    }
    if (majorUnit != this._bx) {
      let a = this._r(Axis.$, Number_$type, this, 14, this._bx, majorUnit);
      this._bx = a.p2;
      this._dx(15, 4, false);
    }
    if (minorUnit != this._b0) {
      let b = this._r(Axis.$, Number_$type, this, 23, this._b0, minorUnit);
      this._b0 = b.p2;
      this._dx(24, 32, false);
    }
  }
  /**
   * @hidden
   */
  _dt(a, b) {
    if (a.hasValue) {
      let c = this._r(Axis.$, Number_$type, this, 14, this._bx, a.value);
      this._bx = c.p2;
      this._dx(15, 4, false);
    }
    else {
      this._dx(15, 4, true);
    }
    if (b.hasValue) {
      let d = this._r(Axis.$, Number_$type, this, 23, this._b0, b.value);
      this._b0 = d.p2;
      this._dx(24, 32, false);
    }
    else {
      this._dx(24, 32, true);
    }
  }
  /**
   * @hidden
   */
  _du(a, b) {
    a = Nullable$1.toNullable(Number_$type, null);
    b = Nullable$1.toNullable(Number_$type, null);
    if (this.majorUnitIsAuto == false) {
      a = Nullable$1.toNullable(Number_$type, this.majorUnit);
    }
    if (this.minorUnitIsAuto == false) {
      b = Nullable$1.toNullable(Number_$type, this.minorUnit);
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  _bt() {
    let a = new List$1(Series.$, 0);
    let b = (c) => {
      a.add(c);
      return true;
    };
    this._d0(b);
    return a;
  }
  /**
   * @hidden
   */
  _a3() {
    let a = null;
    let b = (c) => {
      a = c;
      return false;
    };
    this._d0(b);
    return a;
  }
  /**
   * @hidden
   */
  _dv(a, b) {
    this._l(a);
    this._ah = b;
  }
  /**
   * @hidden
   */
  _y() {
    let a = this.sheet;
    let b = a != null ? a.workbook : null;
    if (b == null) {
      return null;
    }
    let c = this._a6 != null ? this._a6.numberFormatLinked : true;
    let d = this._a6 != null && c == false ? this._a6.numberFormat : null;
    let e = null;
    if (stringIsNullOrEmpty(d) == false) {
      e = new ValueFormatter(0, b, d, b._e6);
    }
    if (e != null && e.o == false) {
      e = null;
    }
    if (c && e == null) {
      let f = this._a3();
      let g = f != null ? f.values : null;
      if (g != null && g._f != null) {
        let h = this._bi(g._f);
        if (h != null) {
          e = new ValueFormatter(0, b, h.formatString, b._e6);
        }
      }
    }
    if (e == null || e.o == false) {
      e = b._b2.a(0);
    }
    return e;
  }
  /**
   * @hidden
   */
  _bi(a) {
    let b = this.sheet;
    let c = null;
    if (b != null && a != null) {
      let d = (e) => {
        let f = e.count > 0 ? e.item(0) : null;
        let g = f != null && f.isReference ? typeCast(RefBase.$, f.toReference()) : null;
        let h = g != null ? g._am() : null;
        let i = h != null && h.count > 0 ? h.item(0) : null;
        let j = i != null ? i._k : null;
        if (j != null) {
          c = j._getResolvedCellFormat1(i.firstColumn);
        }
        return null;
      };
      let e = SeriesValuesBase._b(Base.$, a, b, true, d);
    }
    return c;
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(Axis.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(35);
    ChangeInfo.f(a, 0, Axis._z(Boolean_$type, "AxisBetweenCategories", 7, (b) => b.axisBetweenCategories, (b, c) => b.axisBetweenCategories = c));
    ChangeInfo.f(a, 1, Axis._z(ChartTitle.$, "AxisTitle", 7, (b) => b.axisTitle, (b, c) => b.axisTitle = c));
    ChangeInfo.f(a, 2, Axis._z(TimeUnit_$type, "BaseUnit", 7, (b) => b.baseUnit, (b, c) => b.baseUnit = c));
    ChangeInfo.f(a, 3, Axis._z(Boolean_$type, "BaseUnitIsAuto", 7, (b) => b.baseUnitIsAuto, (b, c) => b.baseUnitIsAuto = c));
    ChangeInfo.f(a, 4, Axis._z(CategoryType_$type, "CategoryType", 7, (b) => b.categoryType, (b, c) => b.categoryType = c));
    ChangeInfo.f(a, 5, Axis._z(AxisCrosses_$type, "Crosses", 7, (b) => b.crosses, (b, c) => b.crosses = c));
    ChangeInfo.f(a, 6, Axis._z(Number_$type, "CrossesAt", 7, (b) => b.crossesAt, (b, c) => b.crossesAt = c));
    ChangeInfo.f(a, 7, Axis._z(DisplayUnit_$type, "DisplayUnit", 7, (b) => b.displayUnit, (b, c) => b.displayUnit = c));
    ChangeInfo.f(a, 8, Axis._z(Number_$type, "DisplayUnitCustom", 7, (b) => b.displayUnitCustom, (b, c) => b.displayUnitCustom = c));
    ChangeInfo.f(a, 9, Axis._z(DisplayUnitLabel.$, "DisplayUnitLabel", 7, (b) => b.displayUnitLabel, (b, c) => b.displayUnitLabel = c));
    ChangeInfo.f(a, 10, Axis._z(Nullable$1.$.specialize(Number_$type), "GapWidth", 7, (b) => b._gapWidth$i, (b, c) => b._gapWidth$i = c));
    ChangeInfo.f(a, 11, Axis._z(Number_$type, "LogBase", 7, (b) => b.logBase, (b, c) => b.logBase = c));
    ChangeInfo.f(a, 12, Axis._z(ChartGridLines.$, "MajorGridLines", 7, (b) => b.majorGridLines, (b, c) => b.majorGridLines = c));
    ChangeInfo.f(a, 13, Axis._z(TickMark_$type, "MajorTickMark", 7, (b) => b.majorTickMark, (b, c) => b.majorTickMark = c));
    ChangeInfo.f(a, 14, Axis._z(Number_$type, "MajorUnit", 7, (b) => b.majorUnit, (b, c) => b.majorUnit = c));
    ChangeInfo.f(a, 15, Axis._z(Boolean_$type, "MajorUnitIsAuto", 7, (b) => b.majorUnitIsAuto, (b, c) => b.majorUnitIsAuto = c));
    ChangeInfo.f(a, 16, Axis._z(TimeUnit_$type, "MajorUnitScale", 7, (b) => b.majorUnitScale, (b, c) => b.majorUnitScale = c));
    ChangeInfo.f(a, 17, Axis._z(Number_$type, "MaximumScale", 7, (b) => b.maximumScale, (b, c) => b.maximumScale = c));
    ChangeInfo.f(a, 18, Axis._z(Boolean_$type, "MaximumScaleIsAuto", 7, (b) => b.maximumScaleIsAuto, (b, c) => b.maximumScaleIsAuto = c));
    ChangeInfo.f(a, 19, Axis._z(Number_$type, "MinimumScale", 7, (b) => b.minimumScale, (b, c) => b.minimumScale = c));
    ChangeInfo.f(a, 20, Axis._z(Boolean_$type, "MinimumScaleIsAuto", 7, (b) => b.minimumScaleIsAuto, (b, c) => b.minimumScaleIsAuto = c));
    ChangeInfo.f(a, 21, Axis._z(ChartGridLines.$, "MinorGridLines", 7, (b) => b.minorGridLines, (b, c) => b.minorGridLines = c));
    ChangeInfo.f(a, 22, Axis._z(TickMark_$type, "MinorTickMark", 7, (b) => b.minorTickMark, (b, c) => b.minorTickMark = c));
    ChangeInfo.f(a, 23, Axis._z(Number_$type, "MinorUnit", 7, (b) => b.minorUnit, (b, c) => b.minorUnit = c));
    ChangeInfo.f(a, 24, Axis._z(Boolean_$type, "MinorUnitIsAuto", 7, (b) => b.minorUnitIsAuto, (b, c) => b.minorUnitIsAuto = c));
    ChangeInfo.f(a, 25, Axis._z(TimeUnit_$type, "MinorUnitScale", 7, (b) => b.minorUnitScale, (b, c) => b.minorUnitScale = c));
    ChangeInfo.f(a, 27, Axis._z(Boolean_$type, "ReversePlotOrder", 7, (b) => b.reversePlotOrder, (b, c) => b.reversePlotOrder = c));
    ChangeInfo.f(a, 26, Axis._z(AxisPosition_$type, "Position", 7, (b) => b.position, (b, c) => b.position = c));
    ChangeInfo.f(a, 28, Axis._z(ScaleType_$type, "ScaleType", 7, (b) => b.scaleType, (b, c) => b.scaleType = c));
    ChangeInfo.f(a, 29, Axis._z(TickLabelPosition_$type, "TickLabelPosition", 7, (b) => b.tickLabelPosition, (b, c) => b.tickLabelPosition = c));
    ChangeInfo.f(a, 30, Axis._z(Number_$type, "TickLabelSpacing", 7, (b) => b.tickLabelSpacing, (b, c) => b.tickLabelSpacing = c));
    ChangeInfo.f(a, 31, Axis._z(Boolean_$type, "TickLabelSpacingIsAuto", 7, (b) => b.tickLabelSpacingIsAuto, (b, c) => b.tickLabelSpacingIsAuto = c));
    ChangeInfo.f(a, 33, Axis._z(Number_$type, "TickMarkSpacing", 7, (b) => b.tickMarkSpacing, (b, c) => b.tickMarkSpacing = c));
    ChangeInfo.f(a, 32, Axis._z(ChartTickLines.$, "TickLines", 7, (b) => b.tickLines, (b, c) => b.tickLines = c));
    ChangeInfo.f(a, 34, Axis._z(Boolean_$type, "Visible", 7, (b) => b.visible, (b, c) => b.visible = c));
    return a;
  }
  /**
   * @hidden
   */
  _bl(a) {
    return (this._ad & a) == a;
  }
  /**
   * @hidden
   */
  _dw(a, b) {
    if (b) {
      this._ad |= a;
    }
    else {
      this._ad &= ~a;
    }
  }
  /**
   * @hidden
   */
  _dx(a, b, c) {
    this._u();
    let d = this._bl(b);
    if (d == c) {
      return;
    }
    let e = Axis._w[a].g(Axis.$, Boolean_$type, this, d, c, this._h);
    d = e.p1;
    this._dw(b, c);
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  _d0(a) {
    let b = new List$1(Series.$, 0);
    let c = this.chart;
    if (c != null) {
      for (let d of fromEnum(c._seriesCollection$i)) {
        let e = true;
        if (d.axisGroup == this.axisGroup) {
          e = a(d);
        }
        if (e == false) {
          break;
        }
      }
    }
  }
}
Axis.$t = markType(Axis, 'Axis', ChartObject.$);
/**
 * @hidden
 */
Axis._cf = 0;
/**
 * @hidden
 */
Axis._ch = 1;
/**
 * @hidden
 */
Axis._ci = 2;
/**
 * @hidden
 */
Axis._cj = 3;
/**
 * @hidden
 */
Axis._ck = 4;
/**
 * @hidden
 */
Axis._cm = 5;
/**
 * @hidden
 */
Axis._cl = 6;
/**
 * @hidden
 */
Axis._co = 7;
/**
 * @hidden
 */
Axis._cn = 8;
/**
 * @hidden
 */
Axis._cp = 9;
/**
 * @hidden
 */
Axis._cq = 10;
/**
 * @hidden
 */
Axis._cr = 11;
/**
 * @hidden
 */
Axis._cs = 12;
/**
 * @hidden
 */
Axis._ct = 13;
/**
 * @hidden
 */
Axis._cu = 14;
/**
 * @hidden
 */
Axis._cv = 15;
/**
 * @hidden
 */
Axis._cw = 16;
/**
 * @hidden
 */
Axis._cx = 17;
/**
 * @hidden
 */
Axis._cy = 18;
/**
 * @hidden
 */
Axis._cz = 19;
/**
 * @hidden
 */
Axis._c0 = 20;
/**
 * @hidden
 */
Axis._c1 = 21;
/**
 * @hidden
 */
Axis._c2 = 22;
/**
 * @hidden
 */
Axis._c3 = 23;
/**
 * @hidden
 */
Axis._c4 = 24;
/**
 * @hidden
 */
Axis._c5 = 25;
/**
 * @hidden
 */
Axis._c7 = 26;
/**
 * @hidden
 */
Axis._da = 27;
/**
 * @hidden
 */
Axis._db = 28;
/**
 * @hidden
 */
Axis._df = 29;
/**
 * @hidden
 */
Axis._dh = 30;
/**
 * @hidden
 */
Axis._di = 31;
/**
 * @hidden
 */
Axis._dj = 32;
/**
 * @hidden
 */
Axis._dl = 33;
/**
 * @hidden
 */
Axis._dm = 34;
/**
 * @hidden
 */
Axis._c6 = 35;
/**
 * @hidden
 */
Axis._b2 = 1;
/**
 * @hidden
 */
Axis._b3 = 0.2;
/**
 * @hidden
 */
Axis._c8 = 0;
/**
 * @hidden
 */
Axis._c9 = 1;
/**
 * @hidden
 */
Axis._dd = 2;
/**
 * @hidden
 */
Axis._dc = 3;
/**
 * @hidden
 */
Axis._de = 3;
/**
 * @hidden
 */
Axis._b7 = 500;
/**
 * @hidden
 */
Axis._w = Axis._x();
/**
 * @hidden
 */
Axis._ae = 2 | 8 | 16 | 4 | 32 | 128 | 256;
/**
 * @hidden
 */
export class AxisCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.b = c;
          this.a = d;
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b.sheet;
  }
  get source() {
    return this.b.chart;
  }
}
AxisCollection_CollectionChangeContext.$t = markStruct(AxisCollection_CollectionChangeContext, 'AxisCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[Axis]] objects for a [[WorksheetChart]]
 */
export class AxisCollection extends ChartObject {
  constructor(a) {
    super(a);
    this._w = new Array(5);
    this._ae = new List$1(Axis.$, 0);
  }
  static staticInit() {
    AxisCollection._x = AxisCollection._y();
  }
  /**
   * @hidden
   */
  _m(a) {
    for (let b = 0; b < this._ae.count; b++) {
      this._ae._inner[b]._m(a);
    }
  }
  /**
   * @hidden
   */
  _i(a, b) {
    for (let c = 0; c < this._ae.count; c++) {
      let d = this._ae._inner[c];
      if (d._i(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    for (let d = 0; d < this._ae.count; d++) {
      this._ae._inner[d]._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    for (let b = 0; b < this._ae.count; b++) {
      this._ae._inner[b]._t(a);
    }
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    this._aq();
    return this._ae.count;
  }
  /**
   * Indexer
   * @param type The type of the axis.
   * @param group The axis group, defaults to primary.
   * @return The corresponding axis or null if not in the collection.
   */
  item(a, b = 1) {
    this._at(a, b);
    return this._w[this._ah(a, b)];
  }
  /**
   * Determines if the collecion can be modified (read-only)
   */
  get isReadOnly() {
    let a = this.workbook;
    if (a != null) {
      return !a._cn;
    }
    return false;
  }
  /**
   * Adds a new [[Axis]] into the collection with the specified type and groupo.
   * <para class="note">
   * <b>Note:</b> If there is an axis already in the collection of the type and group specified it will be replaced with the newly added one.
   * </para>
   * @param type The type of the axis.
   * @param group The axis group, defaults to primary.
   * @return The newly added [[Axis]]
   */
  add(type, group = 1) {
    this._u();
    this._at(type, group);
    let a = new Axis(this, type, group);
    this._an(a, type, group);
    return a;
  }
  /**
   * @hidden
   */
  _an(a, b, c, d = true) {
    let e = this.item(b, c);
    let f = null;
    if (e != null) {
      f = this._j(7);
      this.remove(b, c);
    }
    let g = this.workbook;
    let h = this.sheet;
    let i = new AxisCollection_CollectionChangeContext(1, this, a);
    let j = null;
    let k = null;
    if (g != null && !g._c4 && !this._h) {
      j = AxisCollection._x[0];
      k = j.b(g, h, j.c);
    }
    this._w[this._ah(b, c)] = a;
    this._ae.clear();
    if (j != null) {
      j.e(AxisCollection_CollectionChangeContext.$, Axis.$, i, null, a);
      if (k != null) {
        j.d(g, k);
      }
      if (f != null) {
        this._p(f);
      }
    }
    this.onPropertyChanged();
  }
  /**
   * Clears the collection.
   */
  clear() {
    this._u();
    let a = this.count > 1 ? this._j(7) : null;
    this._ae.clear();
    for (let b = this._w.length - 1; b >= 0; b--) {
      let c = this._w[b];
      if (c != null) {
        this._ao(c);
      }
    }
    this._p(a);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    this._aq();
    return this._ae.getEnumerator();
  }
  /**
   * Removes an axis from the collection.
   * @param type The type of the axis.
   * @param group The axis group, defaults to primary.
   * @return True if the axis was removed, otherwise false.
   */
  remove(type, group) {
    this._u();
    this._at(type, group);
    let a = this.item(type, group);
    if (a == null) {
      return false;
    }
    this._ao(a);
    return true;
  }
  /**
   * @hidden
   */
  _ao(a) {
    let b = -1;
    for (let c = 0; c < this._w.length; c++) {
      let d = this._w[c];
      if (d == a) {
        b = c;
        break;
      }
    }
    if (b < 0) {
      return;
    }
    let e = this.workbook;
    let f = this.sheet;
    let g = AxisCollection._x[1];
    let h = new AxisCollection_CollectionChangeContext(1, this, a);
    let i = e == null || e._c4 || this._h ? null : g.b(e, f, g.c);
    this._w[b] = null;
    this._ae.clear();
    if (e != null && !e._c4 && !this._h) {
      g.e(AxisCollection_CollectionChangeContext.$, Axis.$, h, null, a);
      if (i != null) {
        g.d(e, i);
      }
    }
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(AxisCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _y() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, AxisCollection._z(Axis.$, "Add", 7, (b) => b.a, (b, c) => AxisCollection._ar(b, c)));
    ChangeInfo.f(a, 1, AxisCollection._z(Axis.$, "Remove", 7, (b) => b.a, (b, c) => AxisCollection._as(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  _ah(a, b) {
    switch (a) {
      default:
      case 1: if (b == 1) {
        return 0;
      }
      else {
        return 1;
      }
      case 2: if (b == 1) {
        return 2;
      }
      else {
        return 3;
      }
      case 3: return 4;
    }
  }
  /**
   * @hidden
   */
  _aq() {
    if (this._ae.count == 0) {
      let c = this._w;
      for (let b = 0; b < c.length; b++) {
        let a = c[b];
        if (a != null) {
          this._ae.add(a);
        }
      }
    }
  }
  /**
   * @hidden
   */
  static _ar(a, b) {
    if (a.a != null) {
      a.b._ao(a.a);
    }
  }
  /**
   * @hidden
   */
  static _as(a, b) {
    let c = a.a;
    a.b._an(c, c.type, c.axisGroup, true);
  }
  /**
   * @hidden
   */
  _at(a, b) {
    ExcelUtils.gm(AxisType_$type, a, "type");
    ExcelUtils.gm(AxisGroup_$type, b, "group");
    if (a == 3 && b == 2) {
      throw new ArgumentException(0);
    }
  }
  /**
   * @hidden
   */
  _al() {
    if (this.item(1, 1) == null) {
      this.add(1, 1);
    }
    if (this.item(2, 1) == null) {
      this.add(2, 1);
    }
  }
  /**
   * @hidden
   */
  _am() {
    if (this.item(2, 2) == null) {
      this.add(2, 2);
    }
  }
  /**
   * @hidden
   */
  _ap(a, b) {
    for (let c of fromEnum(this)) {
      c.majorTickMark = a;
      c.minorTickMark = b;
    }
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    this._aq();
    return this._ae.getEnumerator();
  }
}
AxisCollection.$t = markType(AxisCollection, 'AxisCollection', ChartObject.$, [IEnumerable$1_$type.specialize(Axis.$)]);
/**
 * @hidden
 */
AxisCollection._af = 0;
/**
 * @hidden
 */
AxisCollection._aj = 1;
/**
 * @hidden
 */
AxisCollection._ai = 2;
/**
 * @hidden
 */
AxisCollection._x = null;
/**
 * Base class for chart area elements
 */
export class ChartAreaBase extends ChartObject {
  constructor(a) {
    super(a);
    this._aa = null;
    this._ac = null;
    this._ae = false;
  }
  static staticInit() {
    ChartAreaBase._w = ChartAreaBase._x();
  }
  /**
   * @hidden
   */
  _a(a) {
    return ChartAreaBase._w[a];
  }
  /**
   * Determines the appearance of the border drawn around
   * the chart element area, as well as whether a border appears.
   */
  get border() {
    return this._aa;
  }
  /**
   * Determines the appearance of the border drawn around
   * the chart element area, as well as whether a border appears.
   */
  set border(a) {
    if (a != this._aa) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._aa != null) {
        this._aa._l(null);
      }
      let b = this._r(ChartAreaBase.$, ChartBorder.$, this, 0, this._aa, a);
      this._aa = b.p2;
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the chart element area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * <p class="body">
   * To make the area transparent, assign an instance of the
   * [[ChartEmptyFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   * @see [[ChartEmptyFill]]
   */
  get fill() {
    return this._ac;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the chart element area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * <p class="body">
   * To make the area transparent, assign an instance of the
   * [[ChartEmptyFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   * @see [[ChartEmptyFill]]
   */
  set fill(a) {
    if (a != this._ac) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ac != null) {
        this._ac._l(null);
      }
      let b = this._r(ChartAreaBase.$, ChartFillBase.$, this, 1, this._ac, a);
      this._ac = b.p2;
    }
  }
  /**
   * Detrmines if the chart area is displayed with rounded corners
   */
  get roundedCorners() {
    return this._ae;
  }
  /**
   * Detrmines if the chart area is displayed with rounded corners
   */
  set roundedCorners(a) {
    if (a != this._ae) {
      let b = this._r(ChartAreaBase.$, Boolean_$type, this, 4, this._ae, a);
      this._ae = b.p2;
    }
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartAreaBase.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _z($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(PlotArea.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(8);
    ChangeInfo.f(a, 0, ChartAreaBase._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 1, ChartAreaBase._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 2, ChartAreaBase._z(Number_$type, "Height", 7, (b) => b.height, (b, c) => b.height = c));
    ChangeInfo.f(a, 3, ChartAreaBase._z(Number_$type, "Left", 7, (b) => b.left, (b, c) => b.left = c));
    ChangeInfo.f(a, 4, ChartAreaBase._y(Boolean_$type, "RoundedCorners", 7, (b) => b.roundedCorners, (b, c) => b.roundedCorners = c));
    ChangeInfo.f(a, 5, ChartAreaBase._z(ElementPosition_$type, "Position", 7, (b) => b.position, (b, c) => b.position = c));
    ChangeInfo.f(a, 6, ChartAreaBase._z(Number_$type, "Top", 7, (b) => b.top, (b, c) => b.top = c));
    ChangeInfo.f(a, 7, ChartAreaBase._z(Number_$type, "Width", 7, (b) => b.width, (b, c) => b.width = c));
    return a;
  }
}
ChartAreaBase.$t = markType(ChartAreaBase, 'ChartAreaBase', ChartObject.$);
/**
 * @hidden
 */
ChartAreaBase._ag = 0;
/**
 * @hidden
 */
ChartAreaBase._ah = 1;
/**
 * @hidden
 */
ChartAreaBase._ai = 2;
/**
 * @hidden
 */
ChartAreaBase._aj = 3;
/**
 * @hidden
 */
ChartAreaBase._am = 4;
/**
 * @hidden
 */
ChartAreaBase._al = 5;
/**
 * @hidden
 */
ChartAreaBase._an = 6;
/**
 * @hidden
 */
ChartAreaBase._ao = 7;
/**
 * @hidden
 */
ChartAreaBase._ak = 8;
/**
 * @hidden
 */
ChartAreaBase._w = null;
/**
 * Represents the area in which the chart series is plotted.
 */
export class PlotArea extends ChartAreaBase {
  constructor(a) {
    super(a);
    this._as = 0;
    this._at = 0;
    this._au = 0;
    this._av = 0;
    this._aq = -4105;
  }
  /**
   * Returns or sets the height of the area, expressed as a fraction of the
   * height of the containing chart element.
   * @see [[width]]
   * @see [[top]]
   * @see [[height]]
   */
  get height() {
    return this._as;
  }
  /**
   * Returns or sets the height of the area, expressed as a fraction of the
   * height of the containing chart element.
   * @see [[width]]
   * @see [[top]]
   * @see [[height]]
   */
  set height(a) {
    if (a != this._as) {
      let b = this._r(PlotArea.$, Number_$type, this, 2, this._as, a);
      this._as = b.p2;
    }
  }
  /**
   * Returns or sets a value which represents the left edge of the area,
   * expressed as a fraction of the width of the containing chart element.
   * <p class="body">
   * This property can be set to a value between zero and one, where one
   * represents the total width of the containing element.
   * </p>
   * <p class="body">
   * For example, to situate the area such that it's left edge coincides
   * with the center of the containing element, set this property to .5.
   * </p>
   * @see [[top]]
   * @see [[width]]
   * @see [[height]]
   */
  get left() {
    return this._at;
  }
  /**
   * Returns or sets a value which represents the left edge of the area,
   * expressed as a fraction of the width of the containing chart element.
   * <p class="body">
   * This property can be set to a value between zero and one, where one
   * represents the total width of the containing element.
   * </p>
   * <p class="body">
   * For example, to situate the area such that it's left edge coincides
   * with the center of the containing element, set this property to .5.
   * </p>
   * @see [[top]]
   * @see [[width]]
   * @see [[height]]
   */
  set left(a) {
    if (a != this._at) {
      let b = this._r(PlotArea.$, Number_$type, this, 3, this._at, a);
      this._at = b.p2;
    }
  }
  /**
   * Returns or sets a value which represents the top edge of the area,
   * expressed as a fraction of the height of the containing chart element.
   * <p class="body">
   * This property can be set to a value between zero and one, where one
   * represents the total height of the containing element.
   * </p>
   * <p class="body">
   * For example, to situate the area such that it's top edge coincides
   * with the center of the containing element, set this property to .5.
   * </p>
   * @see [[left]]
   * @see [[width]]
   * @see [[height]]
   */
  get top() {
    return this._au;
  }
  /**
   * Returns or sets a value which represents the top edge of the area,
   * expressed as a fraction of the height of the containing chart element.
   * <p class="body">
   * This property can be set to a value between zero and one, where one
   * represents the total height of the containing element.
   * </p>
   * <p class="body">
   * For example, to situate the area such that it's top edge coincides
   * with the center of the containing element, set this property to .5.
   * </p>
   * @see [[left]]
   * @see [[width]]
   * @see [[height]]
   */
  set top(a) {
    if (a != this._au) {
      let b = this._r(PlotArea.$, Number_$type, this, 6, this._au, a);
      this._au = b.p2;
    }
  }
  /**
   * Returns or sets the width of the area, expressed as a fraction of the
   * width of the containing chart element.
   * @see [[height]]
   * @see [[top]]
   * @see [[height]]
   */
  get width() {
    return this._av;
  }
  /**
   * Returns or sets the width of the area, expressed as a fraction of the
   * width of the containing chart element.
   * @see [[height]]
   * @see [[top]]
   * @see [[height]]
   */
  set width(a) {
    if (a != this._av) {
      let b = this._r(PlotArea.$, Number_$type, this, 7, this._av, a);
      this._av = b.p2;
    }
  }
  /**
   * Returns or sets the position of the plot area on the chart.
   */
  get position() {
    return this._aq;
  }
  /**
   * Returns or sets the position of the plot area on the chart.
   */
  set position(a) {
    if (a != this._aq) {
      let b = this._q(PlotArea.$, ElementPosition_$type, this, 5, this._aq, a);
      this._aq = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ap() {
    if (this.fill != null) {
      return this.fill;
    }
    let a = this.chart;
    return a != null ? a._eq : new ChartEmptyFill();
  }
}
PlotArea.$t = markType(PlotArea, 'PlotArea', ChartAreaBase.$);
/**
 * Represents the area in which the chart is displayed.
 */
export class ChartArea extends ChartAreaBase {
  constructor(a) {
    super(a);
  }
  /**
   * @hidden
   */
  get _ap() {
    let a = this.fill;
    if (a != null) {
      return a;
    }
    let b = this.chart;
    return b != null ? b._e0 : ChartSolidFill._w(0);
  }
}
ChartArea.$t = markType(ChartArea, 'ChartArea', ChartAreaBase.$);
/**
 * Exposes properties which control the appearance of a line in a [[Series]].
 */
export class ChartLine extends ChartLineBase {
  constructor() {
    super(null);
    this._an = 0;
    this._aj(2.25);
  }
  static staticInit() {
    ChartLine._ak = ChartLine._al();
  }
  /**
   * Returns or sets the style for the line, i.e., solid, dashed, dotted, etc.
   */
  get lineStyle() {
    return this._an;
  }
  /**
   * Returns or sets the style for the line, i.e., solid, dashed, dotted, etc.
   */
  set lineStyle(a) {
    if (a != this._an) {
      let b = this._q(ChartLine.$, LineStyle_$type, this, 2, this._an, a);
      this._an = b.p2;
    }
  }
  /**
   * @hidden
   */
  get__ai() {
    return Nullable$1.toNullable(LineStyle_$type, this.lineStyle);
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 2) {
      return super._a(a);
    }
    return ChartLine._ak[a - 2];
  }
  /**
   * @hidden
   */
  static _am($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartLine.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _al() {
    let a = 2;
    let b = new Array(3 - a);
    ChangeInfo.f(b, 2 - a, ChartLine._am(LineStyle_$type, "LineStyle", 7, (c) => c.lineStyle, (c, d) => c.lineStyle = d));
    return b;
  }
}
ChartLine.$t = markType(ChartLine, 'ChartLine', ChartLineBase.$);
/**
 * @hidden
 */
ChartLine._aq = 2;
/**
 * @hidden
 */
ChartLine._ar = 2 + 1;
/**
 * @hidden
 */
ChartLine._ap = 2.25;
/**
 * @hidden
 */
ChartLine._ak = null;
/**
 * Base class for the display options for a chart sheet that are used for the display as well as its custom view.
 */
export class ChartsheetDisplayOptionsBase extends DisplayOptionsBase {
  constructor(a) {
    super(a);
    this._y = 100;
    this._w = true;
  }
  /**
   * @hidden
   */
  _n(a) {
    let b = typeCast(ChartsheetDisplayOptionsBase.$, a);
    if (b != null) {
      this._w = b.sizeWithWindow;
      this._y = b.magnification;
    }
    super._n(a);
  }
  /**
   * Resets the display options to their default settings.
   */
  resetCore() {
    this._y = 100;
    this._w = true;
    super.resetCore();
  }
  /**
   * Gets or sets the magnification level of the chartsheet.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the chartsheet in the current View.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a chartsheet. The level must be between 10 and 400.
   */
  get magnification() {
    return this._y;
  }
  /**
   * Gets or sets the magnification level of the chartsheet.
   * <p class="body">
   * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
   * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
   * </p>
   * The magnification level of the chartsheet in the current View.
   * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a chartsheet. The level must be between 10 and 400.
   */
  set magnification(a) {
    if (this._y != a) {
      if (a < 10 || 400 < a) {
        throw ExcelUtils.x("value", a, ExcelUtils.ef("LE_ArgumentOutOfRangeException_MagnificationLevel"));
      }
      let b = ChartsheetDisplayOptionsBase._t[1].g(ChartsheetDisplayOptionsBase.$, Number_$type, this, this._y, a);
      this._y = b.p1;
    }
  }
  /**
   * Gets or sets whether the chart should be resized to match the size of the chart sheet window.
   */
  get sizeWithWindow() {
    return this._w;
  }
  /**
   * Gets or sets whether the chart should be resized to match the size of the chart sheet window.
   */
  set sizeWithWindow(a) {
    if (this._w != a) {
      let b = ChartsheetDisplayOptionsBase._t[0].g(ChartsheetDisplayOptionsBase.$, Boolean_$type, this, this._w, a);
      this._w = b.p1;
    }
  }
  /**
   * @hidden
   */
  static _v($tValue, a, b, c, d = null, e = false, f = 0) {
    return new ChangeInfo$2(ChartsheetDisplayOptionsBase.$, $tValue, a, 35, b, c, d, e, f, false, null, null);
  }
  /**
   * @hidden
   */
  static _u() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, ChartsheetDisplayOptionsBase._v(Boolean_$type, "SizeWithWindow", (b) => b.sizeWithWindow, (b, c) => b.sizeWithWindow = c));
    ChangeInfo.f(a, 1, ChartsheetDisplayOptionsBase._v(Number_$type, "Magnification", (b) => b.magnification, (b, c) => b.magnification = c));
    return a;
  }
}
ChartsheetDisplayOptionsBase.$t = markType(ChartsheetDisplayOptionsBase, 'ChartsheetDisplayOptionsBase', DisplayOptionsBase.$);
/**
 * @hidden
 */
ChartsheetDisplayOptionsBase._ac = 0;
/**
 * @hidden
 */
ChartsheetDisplayOptionsBase._aa = 1;
/**
 * @hidden
 */
ChartsheetDisplayOptionsBase._ab = 2;
/**
 * @hidden
 */
ChartsheetDisplayOptionsBase._t = ChartsheetDisplayOptionsBase._u();
/**
 * Class which exposes the display options which can only be controlled through the chartsheet.
 * @see [[Chartsheet.displayOptions]]
 * @see [[CustomViewChartDisplayOptions]]
 */
export class ChartsheetDisplayOptions extends ChartsheetDisplayOptionsBase {
  constructor(a) {
    super(a);
  }
  /**
   * @hidden
   */
  _e() {
    return new ChartsheetDisplayOptions(this._sheet);
  }
  /**
   * @hidden
   */
  get__j() {
    return true;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
}
ChartsheetDisplayOptions.$t = markType(ChartsheetDisplayOptions, 'ChartsheetDisplayOptions', ChartsheetDisplayOptionsBase.$);
/**
 * Class which exposes the chartsheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getSheetDisplayOptions]]
 * @see [[ChartsheetDisplayOptions]]
 */
export class CustomViewChartDisplayOptions extends ChartsheetDisplayOptionsBase {
  constructor(a, b) {
    super(a);
    /**
     * @hidden
     */
    this._ad = null;
    this._ad = b;
  }
  /**
   * @hidden
   */
  _e() {
    return new CustomViewChartDisplayOptions(this._sheet, this._ad);
  }
  /**
   * @hidden
   */
  get__j() {
    return false;
  }
  /**
   * @hidden
   */
  get _j() {
    return this.get__j();
  }
}
CustomViewChartDisplayOptions.$t = markType(CustomViewChartDisplayOptions, 'CustomViewChartDisplayOptions', ChartsheetDisplayOptionsBase.$);
/**
 * Class which exposes the various print options available for a chartsheet which can be saved with both a
 * chartsheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a chartsheet is printed.
 * </p>
 * @see [[Chartsheet.printOptions]]
 * @see [[CustomView.getSheetPrintOptions]]
 */
export class ChartsheetPrintOptions extends PrintOptionsBase {
  constructor(a, b) {
    super(a, b);
  }
}
ChartsheetPrintOptions.$t = markType(ChartsheetPrintOptions, 'ChartsheetPrintOptions', PrintOptionsBase.$);
/**
 * Provides information about the types of changes that are disabled when the associated Chartsheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Worksheet.protection]]
 * @see@see */
export class ChartsheetProtection extends SheetProtection {
  constructor(a) {
    super(a);
    this._e = 0;
  }
  /**
   * Returns a boolean indicating if objects such as shapes and controls may be created or changed when the chartsheet is protected.
   */
  get allowEditObjects() {
    return this._i(1);
  }
  /**
   * Returns a boolean indicating if objects such as shapes and controls may be created or changed when the chartsheet is protected.
   */
  set allowEditObjects(a) {
    this._k(1, a);
  }
  /**
   * Returns a boolean indicating if the chart is protected when the chartsheet is protected.
   */
  get allowEditContents() {
    return this._i(2);
  }
  /**
   * Returns a boolean indicating if the chart is protected when the chartsheet is protected.
   */
  set allowEditContents(a) {
    this._k(2, a);
  }
  /**
   * @hidden
   */
  get _f() {
    return this._e;
  }
  /**
   * @hidden
   */
  _j(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Boolean_$type, null)) {
    if (this._c.g == false) {
      this._l(1, b);
      this._l(2, c);
      this._c.k(a);
    }
  }
  /**
   * @hidden
   */
  _i(a) {
    return (this._e & a) == a;
  }
  /**
   * @hidden
   */
  _k(a, b) {
    if (b) {
      this._e |= a;
    }
    else {
      this._e &= ~a;
    }
  }
  /**
   * @hidden
   */
  _l(a, b) {
    if (b.hasValue) {
      this._k(a, b.value);
    }
  }
}
ChartsheetProtection.$t = markType(ChartsheetProtection, 'ChartsheetProtection', SheetProtection.$);
/**
 * Base class for chart elements which behave as a label.
 */
export class ChartLabelBase extends ChartTextAreaBase {
  constructor(a) {
    super(a);
    this._cc = null;
    this._b7 = false;
  }
  /**
   * Returns or sets the format to use for numbers.
   * @see [[numberFormatLinked]]
   */
  get numberFormat() {
    return this._cc;
  }
  /**
   * Returns or sets the format to use for numbers.
   * @see [[numberFormatLinked]]
   */
  set numberFormat(a) {
    if (a != this._cc) {
      let b = this._r(ChartLabelBase.$, String_$type, this, 15, this._cc, a);
      this._cc = b.p2;
    }
  }
  /**
   * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
   * @see [[numberFormat]]
   */
  get numberFormatLinked() {
    return this._b7;
  }
  /**
   * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
   * @see [[numberFormat]]
   */
  set numberFormatLinked(a) {
    if (a != this._b7) {
      let b = this._r(ChartLabelBase.$, Boolean_$type, this, 16, this._b7, a);
      this._b7 = b.p2;
    }
  }
  static staticInit() {
    ChartLabelBase._b4 = ChartLabelBase._b5();
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 15) {
      return super._a(a);
    }
    return ChartLabelBase._b4[a - 15];
  }
  /**
   * @hidden
   */
  static _b6($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ChartLabelBase.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _b5() {
    let a = 15;
    let b = new Array(17 - a);
    ChangeInfo.f(b, 15 - a, ChartLabelBase._b6(String_$type, "NumberFormat", 7, (c) => c.numberFormat, (c, d) => c.numberFormat = d));
    ChangeInfo.f(b, 16 - a, ChartLabelBase._b6(Boolean_$type, "NumberFormatLinked", 7, (c) => c.numberFormatLinked, (c, d) => c.numberFormatLinked = d));
    return b;
  }
}
ChartLabelBase.$t = markType(ChartLabelBase, 'ChartLabelBase', ChartTextAreaBase.$);
/**
 * @hidden
 */
ChartLabelBase._ca = 15 + 0;
/**
 * @hidden
 */
ChartLabelBase._cb = 15 + 1;
/**
 * @hidden
 */
ChartLabelBase._b9 = 15 + 2;
/**
 * @hidden
 */
ChartLabelBase._b4 = null;
/**
 * Represents the label of a specific [[DataPoint]].
 */
export class DataLabel extends ChartLabelBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(null);
          this._cv = 0;
          this._cm = false;
          this._ci = 0;
          this._dr = null;
          this._dc = Nullable$1.toNullable(Boolean_$type, null);
          this._dd = Nullable$1.toNullable(Boolean_$type, null);
          this._de = Nullable$1.toNullable(Boolean_$type, null);
          this._df = Nullable$1.toNullable(Boolean_$type, null);
          this._dg = Nullable$1.toNullable(Boolean_$type, null);
          this._dh = Nullable$1.toNullable(Boolean_$type, null);
          this._di = Nullable$1.toNullable(Boolean_$type, null);
          this._cw = 0;
        }
        break;
      case 1:
        {
          let owner = _rest[0];
          super(owner);
          this._cv = 0;
          this._cm = false;
          this._ci = 0;
          this._dr = null;
          this._dc = Nullable$1.toNullable(Boolean_$type, null);
          this._dd = Nullable$1.toNullable(Boolean_$type, null);
          this._de = Nullable$1.toNullable(Boolean_$type, null);
          this._df = Nullable$1.toNullable(Boolean_$type, null);
          this._dg = Nullable$1.toNullable(Boolean_$type, null);
          this._dh = Nullable$1.toNullable(Boolean_$type, null);
          this._di = Nullable$1.toNullable(Boolean_$type, null);
          this._cw = 0;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  static staticInit() {
    DataLabel._ce = DataLabel._cf();
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 17) {
      return super._a(a);
    }
    return DataLabel._ce[a - 17];
  }
  /**
   * Not supported.
   */
  get_formula() {
    return null;
  }
  /**
   * Returns or sets a value that represents the height of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  get_height() {
    return this._cv;
  }
  /**
   * Returns or sets a value that represents the height of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  set_height(a) {
    if (a != this._cv) {
      let b = this._r(DataLabel.$, Number_$type, this, 17, this._cv, a, (b) => {
        if (b < 0) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._cv = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the height of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  get height() {
    return this.get_height();
  }
  /**
   * Returns or sets a value that represents the height of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  set height(a) {
    this.set_height(a);
  }
  /**
   * Returns or sets a boolean value indicating whether this label
   * has been deleted.
   */
  get_isDeleted() {
    return this._cm;
  }
  /**
   * Returns or sets a boolean value indicating whether this label
   * has been deleted.
   */
  set_isDeleted(a) {
    if (a != this._cm) {
      let b = this._r(DataLabel.$, Boolean_$type, this, 18, this._cm, a);
      this._cm = b.p2;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether this label
   * has been deleted.
   */
  get isDeleted() {
    return this.get_isDeleted();
  }
  /**
   * Returns or sets a boolean value indicating whether this label
   * has been deleted.
   */
  set isDeleted(a) {
    this.set_isDeleted(a);
  }
  /**
   * Returns or sets a value which determines the label's position
   * as relative to the series bar/line.
   * <p class="body">
   * When this property is set to <i>Custom</i>, the position is determined
   * by the values of the <see cref="ChartTextAreaBase.Left">Left</see> and
   * <see cref="ChartTextAreaBase.Top">Top</see> properties.
   * </p>
   * <p class="body">
   * When a custom label position is assigned, connecting lines appear between
   * the label and its respective [[DataPoint]]. These lines are referred
   * to as 'leader lines'; use the [[Series.leaderLines]] property to control
   * their appearance.
   * </p>
   * <p class="body">
   * Note that leader lines can be hidden by setting the [[SeriesDataLabels.showLeaderLines]]
   * property to <i>false</i>.
   * </p>
   * @see [[ChartTextAreaBase.left]]
   * @see [[ChartTextAreaBase.top]]
   * @see [[Series.leaderLines]]
   * @see [[SeriesDataLabels.showLeaderLines]]
   */
  get labelPosition() {
    return this._ci;
  }
  /**
   * Returns or sets a value which determines the label's position
   * as relative to the series bar/line.
   * <p class="body">
   * When this property is set to <i>Custom</i>, the position is determined
   * by the values of the <see cref="ChartTextAreaBase.Left">Left</see> and
   * <see cref="ChartTextAreaBase.Top">Top</see> properties.
   * </p>
   * <p class="body">
   * When a custom label position is assigned, connecting lines appear between
   * the label and its respective [[DataPoint]]. These lines are referred
   * to as 'leader lines'; use the [[Series.leaderLines]] property to control
   * their appearance.
   * </p>
   * <p class="body">
   * Note that leader lines can be hidden by setting the [[SeriesDataLabels.showLeaderLines]]
   * property to <i>false</i>.
   * </p>
   * @see [[ChartTextAreaBase.left]]
   * @see [[ChartTextAreaBase.top]]
   * @see [[Series.leaderLines]]
   * @see [[SeriesDataLabels.showLeaderLines]]
   */
  set labelPosition(a) {
    if (a != this._ci) {
      let b = this._r(DataLabel.$, DataLabelPosition_$type, this, 19, this._ci, a);
      this._ci = b.p2;
    }
  }
  /**
   * This property is not supported. Use the [[labelPosition]] property instead.
   */
  get_position() {
    return -4105;
  }
  /**
   * This property is not supported. Use the [[labelPosition]] property instead.
   */
  set_position(a) {
  }
  /**
   * Returns or sets the separator used between multiple values in the label.
   */
  get separator() {
    return this._dr;
  }
  /**
   * Returns or sets the separator used between multiple values in the label.
   */
  set separator(a) {
    let b = this._r(DataLabel.$, String_$type, this, 20, this._dr, a);
    this._dr = b.p2;
  }
  /**
   * Returns or sets if the bubble size is shown.
   * Applies only to [[Series]] which are displayed
   * within a bubble chart.
   */
  get showBubbleSize() {
    return unwrapNullable(this._showBubbleSize$i);
  }
  /**
   * Returns or sets if the bubble size is shown.
   * Applies only to [[Series]] which are displayed
   * within a bubble chart.
   */
  set showBubbleSize(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showBubbleSize$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showBubbleSize$i() {
    return this._dc;
  }
  /**
   * @hidden
   */
  set _showBubbleSize$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 21, this._dc, a);
    this._dc = b.p2;
  }
  /**
   * @hidden
   */
  get__co() {
    if (nullableNotEquals(this._showBubbleSize$i, null)) {
      return nullableEquals(this._showBubbleSize$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showBubbleSize$i, true) : false;
  }
  /**
   * @hidden
   */
  get _co() {
    return this.get__co();
  }
  /**
   * Returns or sets a value indicating whether the category name is shown.
   * <p class="body">
   * The category name is not shown by default; to show the category name in the label, set this property to <i>true</i>.
   * </p>
   */
  get showCategoryName() {
    return unwrapNullable(this._showCategoryName$i);
  }
  /**
   * Returns or sets a value indicating whether the category name is shown.
   * <p class="body">
   * The category name is not shown by default; to show the category name in the label, set this property to <i>true</i>.
   * </p>
   */
  set showCategoryName(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showCategoryName$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showCategoryName$i() {
    return this._dd;
  }
  /**
   * @hidden
   */
  set _showCategoryName$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 22, this._dd, a);
    this._dd = b.p2;
  }
  /**
   * @hidden
   */
  get _cp() {
    if (nullableNotEquals(this._showCategoryName$i, null)) {
      return nullableEquals(this._showCategoryName$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showCategoryName$i, true) : false;
  }
  /**
   * Returns or sets if the [[Legend]] key is shown.
   * <p class="body">
   * The legend key is not shown by default; to show the legend key in the label, set this property to <i>true</i>.
   * </p>
   */
  get showLegendKey() {
    return unwrapNullable(this._showLegendKey$i);
  }
  /**
   * Returns or sets if the [[Legend]] key is shown.
   * <p class="body">
   * The legend key is not shown by default; to show the legend key in the label, set this property to <i>true</i>.
   * </p>
   */
  set showLegendKey(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showLegendKey$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showLegendKey$i() {
    return this._de;
  }
  /**
   * @hidden
   */
  set _showLegendKey$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 23, this._de, a);
    this._de = b.p2;
  }
  /**
   * @hidden
   */
  get _cq() {
    if (nullableNotEquals(this._showLegendKey$i, null)) {
      return nullableEquals(this._showLegendKey$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showLegendKey$i, true) : false;
  }
  /**
   * Returns or sets a value indicating whether the percentage of the range is shown.
   * <p class="body">
   * The percentage is not shown by default; to show the percentage in the label, set this property to <i>true</i>.
   * </p>
   */
  get showPercentage() {
    return unwrapNullable(this._showPercentage$i);
  }
  /**
   * Returns or sets a value indicating whether the percentage of the range is shown.
   * <p class="body">
   * The percentage is not shown by default; to show the percentage in the label, set this property to <i>true</i>.
   * </p>
   */
  set showPercentage(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showPercentage$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showPercentage$i() {
    return this._df;
  }
  /**
   * @hidden
   */
  set _showPercentage$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 24, this._df, a);
    this._df = b.p2;
  }
  /**
   * @hidden
   */
  get _cr() {
    if (nullableNotEquals(this._showPercentage$i, null)) {
      return nullableEquals(this._showPercentage$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showPercentage$i, true) : false;
  }
  /**
   * Returns or sets a value indicating whether the series
   * <see cref="Series.Name">name</see> is shown in the label.
   * <p class="body">
   * The series name  is not shown by default; to show the series name in the label, set this property to <i>true</i>.
   * </p>
   */
  get showSeriesName() {
    return unwrapNullable(this._showSeriesName$i);
  }
  /**
   * Returns or sets a value indicating whether the series
   * <see cref="Series.Name">name</see> is shown in the label.
   * <p class="body">
   * The series name  is not shown by default; to show the series name in the label, set this property to <i>true</i>.
   * </p>
   */
  set showSeriesName(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showSeriesName$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showSeriesName$i() {
    return this._dh;
  }
  /**
   * @hidden
   */
  set _showSeriesName$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 26, this._dh, a);
    this._dh = b.p2;
  }
  /**
   * @hidden
   */
  get _ct() {
    if (nullableNotEquals(this._showSeriesName$i, null)) {
      return nullableEquals(this._showSeriesName$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showSeriesName$i, true) : false;
  }
  /**
   * Returns or sets a boolean value indicating whether the data label range is shown.
   * <p class="body">
   * The data label range is defined by the [[SeriesDataLabels.dataLabelsRange]]
   * </p>
   * <p class="body">
   * The data label range is not shown by default; to show the range in the label, set this property to <i>true</i>.
   * </p>
   * @see [[SeriesDataLabels.dataLabelsRange]]
   */
  get showRange() {
    return unwrapNullable(this._showRange$i);
  }
  /**
   * Returns or sets a boolean value indicating whether the data label range is shown.
   * <p class="body">
   * The data label range is defined by the [[SeriesDataLabels.dataLabelsRange]]
   * </p>
   * <p class="body">
   * The data label range is not shown by default; to show the range in the label, set this property to <i>true</i>.
   * </p>
   * @see [[SeriesDataLabels.dataLabelsRange]]
   */
  set showRange(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showRange$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showRange$i() {
    return this._dg;
  }
  /**
   * @hidden
   */
  set _showRange$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 25, this._dg, a);
    this._dg = b.p2;
  }
  /**
   * @hidden
   */
  get _cs() {
    if (nullableNotEquals(this._showRange$i, null)) {
      return nullableEquals(this._showRange$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showRange$i, true) : false;
  }
  /**
   * Returns or sets a value indicating whether the value is shown.
   * <p class="body">
   * The value is shown by default; to prevent the value from displaying in the label, set this property to <i>false</i>.
   * </p>
   */
  get showValue() {
    return unwrapNullable(this._showValue$i);
  }
  /**
   * Returns or sets a value indicating whether the value is shown.
   * <p class="body">
   * The value is shown by default; to prevent the value from displaying in the label, set this property to <i>false</i>.
   * </p>
   */
  set showValue(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._showValue$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _showValue$i() {
    return this._di;
  }
  /**
   * @hidden
   */
  set _showValue$i(a) {
    let b = this._r(DataLabel.$, Nullable$1.$.specialize(Boolean_$type), this, 27, this._di, a);
    this._di = b.p2;
  }
  /**
   * @hidden
   */
  get _cu() {
    if (nullableNotEquals(this._showValue$i, null)) {
      return nullableEquals(this._showValue$i, true);
    }
    let a = this._ck;
    return a != null ? nullableEquals(a._showValue$i, true) : true;
  }
  /**
   * Returns or sets a value that represents the width of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  get_width() {
    return this._cw;
  }
  /**
   * Returns or sets a value that represents the width of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  set_width(a) {
    if (a != this._cw) {
      let b = this._r(DataLabel.$, Number_$type, this, 28, this._cw, a, (b) => {
        if (b < 0) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._cw = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the width of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  get width() {
    return this.get_width();
  }
  /**
   * Returns or sets a value that represents the width of the
   * label, expressed as a ratio, relative to the size of the
   * chart area.
   */
  set width(a) {
    this.set_width(a);
  }
  /**
   * @hidden
   */
  get__ad() {
    if (this.fill != null) {
      return this.fill;
    }
    let a = this._ck;
    if (a != null) {
      return a._ad;
    }
    return new ChartEmptyFill();
  }
  /**
   * @hidden
   */
  get _ch() {
    if (this.border != null) {
      return this.border;
    }
    let a = this._ck;
    return a != null ? a.border : null;
  }
  /**
   * @hidden
   */
  get _cl() {
    let a = this._ck;
    if (a == null) {
      return this.defaultFont;
    }
    return ExcelUtils.v([this.defaultFont, a.defaultFont], this.workbook);
  }
  /**
   * @hidden
   */
  get__ck() {
    let a = typeCast(DataPoint.$, this.owner);
    let b = a != null ? typeCast(DataPointCollection.$, a.owner) : null;
    let c = b != null ? typeCast(Series.$, b.owner) : null;
    return c != null ? c.dataLabels : null;
  }
  /**
   * @hidden
   */
  get _ck() {
    return this.get__ck();
  }
  /**
   * Not supported.
   */
  setFormula(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setFormula1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setFormula1(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    super._setFormula1(a, b);
  }
  /**
   * @hidden
   */
  _dt(a = Nullable$1.toNullable(Boolean_$type, false)) {
    this._showBubbleSize$i = a;
    this._showCategoryName$i = a;
    this._showLegendKey$i = a;
    this._showPercentage$i = a;
    this._showRange$i = a;
    this._showSeriesName$i = a;
    this._showValue$i = a;
  }
  /**
   * @hidden
   */
  static _cg($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(DataLabel.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _cf() {
    let a = 17;
    let b = new Array(29 - a);
    ChangeInfo.f(b, 18 - a, DataLabel._cg(Boolean_$type, "IsDeleted", 7, (c) => c.isDeleted, (c, d) => c.isDeleted = d));
    ChangeInfo.f(b, 17 - a, DataLabel._cg(Number_$type, "Height", 7, (c) => c.height, (c, d) => c.height = d));
    ChangeInfo.f(b, 19 - a, DataLabel._cg(DataLabelPosition_$type, "LabelPosition", 7, (c) => c.labelPosition, (c, d) => c.labelPosition = d));
    ChangeInfo.f(b, 20 - a, DataLabel._cg(String_$type, "Separator", 7, (c) => c.separator, (c, d) => c.separator = d));
    ChangeInfo.f(b, 21 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowBubbleSize", 7, (c) => c._showBubbleSize$i, (c, d) => c._showBubbleSize$i = d));
    ChangeInfo.f(b, 22 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowCategoryName", 7, (c) => c._showCategoryName$i, (c, d) => c._showCategoryName$i = d));
    ChangeInfo.f(b, 23 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowLegendKey", 7, (c) => c._showLegendKey$i, (c, d) => c._showLegendKey$i = d));
    ChangeInfo.f(b, 24 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowPercentage", 7, (c) => c._showPercentage$i, (c, d) => c._showPercentage$i = d));
    ChangeInfo.f(b, 25 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowRange", 7, (c) => c._showRange$i, (c, d) => c._showRange$i = d));
    ChangeInfo.f(b, 26 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowSeriesName", 7, (c) => c._showSeriesName$i, (c, d) => c._showSeriesName$i = d));
    ChangeInfo.f(b, 27 - a, DataLabel._cg(Nullable$1.$.specialize(Boolean_$type), "ShowValue", 7, (c) => c._showValue$i, (c, d) => c._showValue$i = d));
    ChangeInfo.f(b, 28 - a, DataLabel._cg(Number_$type, "Width", 7, (c) => c.width, (c, d) => c.width = d));
    return b;
  }
}
DataLabel.$t = markType(DataLabel, 'DataLabel', ChartLabelBase.$);
/**
 * @hidden
 */
DataLabel._cz = 17 + 0;
/**
 * @hidden
 */
DataLabel._c0 = 17 + 1;
/**
 * @hidden
 */
DataLabel._c1 = 17 + 2;
/**
 * @hidden
 */
DataLabel._c3 = 17 + 3;
/**
 * @hidden
 */
DataLabel._c4 = 17 + 4;
/**
 * @hidden
 */
DataLabel._c5 = 17 + 5;
/**
 * @hidden
 */
DataLabel._c6 = 17 + 6;
/**
 * @hidden
 */
DataLabel._c7 = 17 + 7;
/**
 * @hidden
 */
DataLabel._c8 = 17 + 8;
/**
 * @hidden
 */
DataLabel._c9 = 17 + 9;
/**
 * @hidden
 */
DataLabel._da = 17 + 10;
/**
 * @hidden
 */
DataLabel._db = 17 + 11;
/**
 * @hidden
 */
DataLabel._c2 = 17 + 12;
/**
 * @hidden
 */
DataLabel._ce = null;
/**
 * Defines the properties for all <see cref="DataLabel">data labels</see>
 * displayed for this [[Series]].
 * <p class="body">
 * This property provides a way to set properties on multiple <see cref="DataLabel">data labels</see>.
 * </p>
 * <p class="body">
 * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
 * </p>
 * <p class="body">
 * The property values of the [[DataPoint.dataLabel]] class take precedence
 * over the properties of this class.
 * </p>
 * @see [[DataLabel]]
 * @see [[DataPoint.dataLabel]]
 * @see [[Series.dataPointCollection]]
 */
export class SeriesDataLabels extends DataLabel {
  constructor(a) {
    super(a);
    this._d0 = null;
    this._dx = 2;
    this._d3 = true;
  }
  static staticInit() {
    SeriesDataLabels._du = SeriesDataLabels._dv();
  }
  /**
   * Not supported.
   */
  get_left() {
    return super.get_left();
  }
  /**
   * Not supported.
   */
  set_left(a) {
    super.set_left(a);
  }
  /**
   * Not supported.
   */
  get_top() {
    return super.get_top();
  }
  /**
   * Not supported.
   */
  set_top(a) {
    super.set_top(a);
  }
  /**
   * Not supported.
   */
  get_text() {
    return super.get_text();
  }
  /**
   * Not supported.
   */
  set_text(a) {
    super.set_text(a);
  }
  /**
   * Not supported.
   */
  get_isDeleted() {
    return super.get_isDeleted();
  }
  /**
   * Not supported.
   */
  set_isDeleted(a) {
    super.set_isDeleted(a);
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._d0 != null && this._d0._ar(a.workbook, a, b)) {
      return true;
    }
    return super._i(a, b);
  }
  /**
   * @hidden
   */
  _m(a) {
    if (this._d0 != null) {
      a(this.sheet, this._d0);
    }
    super._m(a);
  }
  /**
   * Not supported.
   */
  get_height() {
    return super.get_height();
  }
  /**
   * Not supported.
   */
  set_height(a) {
    super.set_height(a);
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    if (this._d0 != null) {
      let d = this.sheet;
      if (d != null) {
        let e = this._d0._toString2(1, d.workbook._e6);
        if (this._d0._av(d, b, 0)) {
          a(this, Tuple.a(Number_$type, String_$type, 200, e));
        }
      }
    }
    super._o(a, b, c);
  }
  /**
   * @hidden
   */
  _k(a) {
    let b = typeCast(Tuple$2.$.specialize(Number_$type, String_$type), a);
    if (b != null && b.c == 200) {
      let c = this.workbook;
      let d = c != null ? c._e6 : CultureInfo.invariantCulture;
      let e = this._d0 != null ? this._d0._toString2(1, d) : null;
      this._setFormula1(b.d, Nullable$1.toNullable(CellReferenceMode_$type, 1));
      return Tuple.a(Number_$type, String_$type, 200, e);
    }
    return super._k(a);
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._d0 != null && this._d0._t == a) {
      this._d0 = null;
    }
    super._t(a);
  }
  /**
   * Not supported.
   */
  get_width() {
    return super.get_width();
  }
  /**
   * Not supported.
   */
  set_width(a) {
    super.set_width(a);
  }
  /**
   * Returns a [[Formula]] which defines the cell range
   * from which part or all of the label text is obtained.
   * <p class="body">
   * Use the [[setDataLabelsRange]]
   * method to assign a new value.
   * </p>
   * <p class="body">
   * The cell values obtained from this property are only displayed when the
   * [[DataLabel.showRange]] property is set to true.
   * </p>
   * <p class="body">
   * The specified range must contain only one column or one row, or an exception is thrown.
   * </p>
   * @see [[setDataLabelsRange]]
   * @see [[DataLabel.showRange]]
   */
  get dataLabelsRange() {
    return this._d0;
  }
  /**
   * @hidden
   */
  get _d1() {
    return this._d0;
  }
  /**
   * @hidden
   */
  set _d1(a) {
    if (a != this._d0) {
      if (a != null && a._ch == null) {
        SeriesDataLabels._d2(this.sheet, a);
      }
      let b = this._r(SeriesDataLabels.$, SingleTargetFormula.$, this, 29, this._d0, a);
      this._d0 = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ea() {
    return this._d0 != null ? this._d0._toString() : null;
  }
  /**
   * Returns or sets a value which determines the label positioning
   * for a <i>Treemap</i> chart.
   * <p class="body">
   * This property is only applicable for <i>Treemap</i> charts.
   * </p>
   */
  get parentLabelLayout() {
    return this._dx;
  }
  /**
   * Returns or sets a value which determines the label positioning
   * for a <i>Treemap</i> chart.
   * <p class="body">
   * This property is only applicable for <i>Treemap</i> charts.
   * </p>
   */
  set parentLabelLayout(a) {
    if (a != this._dx) {
      let b = this._q(SeriesDataLabels.$, ParentLabelLayout_$type, this, 30, this._dx, a);
      this._dx = b.p2;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether <see cref="Series.LeaderLines">leader lines</see>
   * are displayed for the data labels associated with this instance.
   * <p class="body">
   * Leader lines connect <see cref="DataLabel">data labels</see> to their respective
   * <see cref="DataPoint">data points</see>.
   * </p>
   * <p class="body">
   * The [[LeaderLines]] property provides a way to customize the appearance
   * of the connecting lines. These lines are only drawn, however, for data labels whose
   * [[DataLabel.labelPosition]] property is set to <i>Custom</i>.
   * </p>
   * <p class="body">
   * Use this property to allow leader lines to be shown using the default appearance, i.e.,
   * setting this property to true without specifying a custom appearance causes them to
   * acquire the default appearance as determined by Excel.
   * </p>
   * <p class="body">
   * Leader lines can be hidden by setting this property to <i>false</i>.
   * </p>
   * @see [[Series.leaderLines]]
   * @see [[DataLabel]]
   * @see [[DataLabel.labelPosition]]
   * @see [[ChartTextAreaBase.left]]
   * @see [[ChartTextAreaBase.top]]
   * @see [[DataPoint]]
   */
  get showLeaderLines() {
    return this._d3;
  }
  /**
   * Returns or sets a boolean value indicating whether <see cref="Series.LeaderLines">leader lines</see>
   * are displayed for the data labels associated with this instance.
   * <p class="body">
   * Leader lines connect <see cref="DataLabel">data labels</see> to their respective
   * <see cref="DataPoint">data points</see>.
   * </p>
   * <p class="body">
   * The [[LeaderLines]] property provides a way to customize the appearance
   * of the connecting lines. These lines are only drawn, however, for data labels whose
   * [[DataLabel.labelPosition]] property is set to <i>Custom</i>.
   * </p>
   * <p class="body">
   * Use this property to allow leader lines to be shown using the default appearance, i.e.,
   * setting this property to true without specifying a custom appearance causes them to
   * acquire the default appearance as determined by Excel.
   * </p>
   * <p class="body">
   * Leader lines can be hidden by setting this property to <i>false</i>.
   * </p>
   * @see [[Series.leaderLines]]
   * @see [[DataLabel]]
   * @see [[DataLabel.labelPosition]]
   * @see [[ChartTextAreaBase.left]]
   * @see [[ChartTextAreaBase.top]]
   * @see [[DataPoint]]
   */
  set showLeaderLines(a) {
    if (a != this._d3) {
      let b = this._r(SeriesDataLabels.$, Boolean_$type, this, 31, this._d3, a);
      this._d3 = b.p2;
    }
  }
  /**
   * @hidden
   */
  get__ck() {
    return null;
  }
  /**
   * Assigns a [[Formula]] to the [[dataLabelsRange]]
   * @param formula The string representation of the formula used to obtain the data label text.
   * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
   */
  setDataLabelsRange(formula, cellReferenceMode) {
    if (arguments[1] !== void 0) {
      arguments[1] = wrapNullable(CellReferenceMode_$type, arguments[1]);
    }
    return this._setDataLabelsRange1.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _setDataLabelsRange1(a, b = Nullable$1.toNullable(CellReferenceMode_$type, null)) {
    if (a != null && a.length > 0 && a.charAt(0) != '=') {
      a = "=" + a;
    }
    this._a5 = ConditionBase._n(a, this.workbook, b);
  }
  /**
   * @hidden
   */
  _eb(a, b) {
    this._d0 = b;
    SeriesDataLabels._d2(a, b);
  }
  /**
   * @hidden
   */
  static _d2(a, b) {
    if (b != null) {
      let c = new TempCellCalcReference(true, a, new WorksheetCellAddress(1, 0, 0));
      b._cx(c, a.workbook);
    }
    return b;
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 29) {
      return super._a(a);
    }
    return SeriesDataLabels._du[a - 29];
  }
  /**
   * @hidden
   */
  static _dw($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(SeriesDataLabels.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _dv() {
    let a = 29;
    let b = new Array(32 - a);
    ChangeInfo.f(b, 29 - a, SeriesDataLabels._dw(SingleTargetFormula.$, "DataLabelsRangeInternal", 7, (c) => c._d1, (c, d) => c._d1 = d));
    ChangeInfo.f(b, 30 - a, SeriesDataLabels._dw(ParentLabelLayout_$type, "ParentLabelLayout", 7, (c) => c.parentLabelLayout, (c, d) => c.parentLabelLayout = d));
    ChangeInfo.f(b, 31 - a, SeriesDataLabels._dw(Boolean_$type, "ShowLeaderLines", 7, (c) => c.showLeaderLines, (c, d) => c.showLeaderLines = d));
    return b;
  }
}
SeriesDataLabels.$t = markType(SeriesDataLabels, 'SeriesDataLabels', DataLabel.$);
/**
 * @hidden
 */
SeriesDataLabels._d6 = 29 + 0;
/**
 * @hidden
 */
SeriesDataLabels._d8 = 29 + 1;
/**
 * @hidden
 */
SeriesDataLabels._d9 = 29 + 2;
/**
 * @hidden
 */
SeriesDataLabels._d7 = 29 + 3;
/**
 * @hidden
 */
SeriesDataLabels._d5 = 200;
/**
 * @hidden
 */
SeriesDataLabels._du = null;
/**
 * Represents the a specific data point in a [[series]].
 * <p class="body">
 * This class encapsulates an individual point of data in a [[series]].
 * </p>
 * <p class="body">
 * A data point manifests differently depending on the chart type; for example,
 * on a bar chart it represents the bar itself, and for a line chart, it represents
 * a point on the line. For pie and doughnut charts, a data point represents a slice
 * or wedge in the pie/doughnut.
 * </p>
 * <p class="body">
 * Many of the properties exposed by this class are also found on the
 * [[series]] class; setting the property on the series affects
 * all points on the series, whereas setting a property on this class affects
 * only one individual point in the series.
 * </p>
 * <p class="body">
 * In cases where <i>most</i> of the data points share the same property values, use
 * the property of the Series class, overriding the property values for any individual
 * points using this class.
 * </p>
 * @see [[series]]
 * @see [[Series.explosion]]
 * @see [[Series.markerStyle]]
 */
export class DataPoint extends ChartObject {
  constructor(a) {
    super(a);
    this._bd = Nullable$1.toNullable(Boolean_$type, null);
    this._be = Nullable$1.toNullable(Boolean_$type, null);
    this._bf = Nullable$1.toNullable(Boolean_$type, null);
    this._z = null;
    this._am = null;
    this._bg = Nullable$1.toNullable(Number_$type, null);
    this._af = null;
    this._bh = Nullable$1.toNullable(Boolean_$type, null);
    this._aa = null;
    this._ag = null;
    this._bi = Nullable$1.toNullable(Number_$type, null);
    this._bj = Nullable$1.toNullable(MarkerStyle_$type, null);
    this._aq = false;
  }
  static staticInit() {
    DataPoint._w = DataPoint._x();
  }
  /**
   * @hidden
   */
  _a(a) {
    return DataPoint._w[a];
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._am != null && this._am._i(a, b)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _m(a) {
    if (this._am != null) {
      this._am._m(a);
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    if (this._am != null) {
      this._am._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._am != null) {
      this._am._t(a);
    }
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the end
   * of the point or all points in the series.
   */
  get applyPicToEnd() {
    return unwrapNullable(this._applyPicToEnd$i);
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the end
   * of the point or all points in the series.
   */
  set applyPicToEnd(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._applyPicToEnd$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _applyPicToEnd$i() {
    return this._bd;
  }
  /**
   * @hidden
   */
  set _applyPicToEnd$i(a) {
    if (nullableNotEquals(a, this._bd)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Boolean_$type), this, 0, this._bd, a);
      this._bd = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ar() {
    let a = ExcelUtils.du(this._bd);
    if (a.hasValue) {
      return a.value;
    }
    let b = this._ap;
    return b != null ? b.applyPicToEnd : false;
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the front
   * of the point or all points in the series.
   */
  get applyPicToFront() {
    return unwrapNullable(this._applyPicToFront$i);
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the front
   * of the point or all points in the series.
   */
  set applyPicToFront(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._applyPicToFront$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _applyPicToFront$i() {
    return this._be;
  }
  /**
   * @hidden
   */
  set _applyPicToFront$i(a) {
    if (nullableNotEquals(a, this._be)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Boolean_$type), this, 1, this._be, a);
      this._be = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _as() {
    let a = ExcelUtils.du(this._be);
    if (a.hasValue) {
      return a.value;
    }
    let b = this._ap;
    return b != null ? b.applyPicToFront : false;
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the sides
   * of the point or all points in the series.
   */
  get applyPicToSides() {
    return unwrapNullable(this._applyPicToSides$i);
  }
  /**
   * Returns or sets a value indicating whether a picture is applied to the sides
   * of the point or all points in the series.
   */
  set applyPicToSides(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._applyPicToSides$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _applyPicToSides$i() {
    return this._bf;
  }
  /**
   * @hidden
   */
  set _applyPicToSides$i(a) {
    if (nullableNotEquals(a, this._bf)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Boolean_$type), this, 2, this._bf, a);
      this._bf = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _at() {
    let a = ExcelUtils.du(this._bf);
    if (a.hasValue) {
      return a.value;
    }
    let b = this._ap;
    return b != null ? b.applyPicToSides : false;
  }
  /**
   * Determines the appearance of the border drawn around the
   * data point's [[fill]] area.
   * <p class="body">
   * For series which support <see cref="Fill">fills</see>, this property controls the
   * color and size of the line drawn around the data point's fill region.
   * </p>
   * @see [[fill]]
   */
  get border() {
    return this._z;
  }
  /**
   * Determines the appearance of the border drawn around the
   * data point's [[fill]] area.
   * <p class="body">
   * For series which support <see cref="Fill">fills</see>, this property controls the
   * color and size of the line drawn around the data point's fill region.
   * </p>
   * @see [[fill]]
   */
  set border(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(DataPoint.$, ChartBorder.$, this, 3, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ac() {
    if (this._z != null) {
      return this._z;
    }
    let a = this._ap;
    return a != null ? a.border : null;
  }
  /**
   * Returns or sets a [[dataLabel]] instance which defines
   * the properties of the label displayed for this data point.
   * <p class="body">
   * In order to display data labels, the [[Series.showDataLabels]]
   * property must be set to true.
   * </p>
   * <p class="body">
   * Use the [[Series.dataLabels]] property to apply property
   * settings to all data labels in the series.
   * </p>
   * <p class="body">
   * Use the [[DataLabel.isDeleted]] property to hide the label
   * for a specific data point.
   * </p>
   * @see [[Series.showDataLabels]]
   * @see [[Series.dataLabels]]
   */
  get dataLabel() {
    return this._am;
  }
  /**
   * Returns or sets a [[dataLabel]] instance which defines
   * the properties of the label displayed for this data point.
   * <p class="body">
   * In order to display data labels, the [[Series.showDataLabels]]
   * property must be set to true.
   * </p>
   * <p class="body">
   * Use the [[Series.dataLabels]] property to apply property
   * settings to all data labels in the series.
   * </p>
   * <p class="body">
   * Use the [[DataLabel.isDeleted]] property to hide the label
   * for a specific data point.
   * </p>
   * @see [[Series.showDataLabels]]
   * @see [[Series.dataLabels]]
   */
  set dataLabel(a) {
    if (a != this._am) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._am != null) {
        this._am._l(null);
      }
      let b = this._r(DataPoint.$, DataLabel.$, this, 4, this._am, a);
      this._am = b.p2;
    }
  }
  /**
   * Returns or sets the explosion value for a pie-chart or doughnut-chart slice.
   * <p class="body">
   * In the context of a pie or doughnut chart, a [[DataPoint]]
   * is synonymous with an individual slice of the pie/doughnut.
   * </p>
   * <p class="body">
   * <i>Explosion</i> refers to the amount by which a slice in the pie is
   * offset from the center point of the circle.
   * </p>
   * <p class="body">
   * The valid range of values is between 0 and 400, inclusive.
   * </p>
   * <p class="body">
   * Use the [[Series.explosion]] property to set the explosion
   * for all slices in the pie.
   * </p>
   * @see [[Series.explosion]]
   * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
   */
  get explosion() {
    return unwrapNullable(this._explosion$i);
  }
  /**
   * Returns or sets the explosion value for a pie-chart or doughnut-chart slice.
   * <p class="body">
   * In the context of a pie or doughnut chart, a [[DataPoint]]
   * is synonymous with an individual slice of the pie/doughnut.
   * </p>
   * <p class="body">
   * <i>Explosion</i> refers to the amount by which a slice in the pie is
   * offset from the center point of the circle.
   * </p>
   * <p class="body">
   * The valid range of values is between 0 and 400, inclusive.
   * </p>
   * <p class="body">
   * Use the [[Series.explosion]] property to set the explosion
   * for all slices in the pie.
   * </p>
   * @see [[Series.explosion]]
   * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
   */
  set explosion(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._explosion$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _explosion$i() {
    return this._bg;
  }
  /**
   * @hidden
   */
  set _explosion$i(a) {
    if (nullableNotEquals(a, this._bg)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Number_$type), this, 5, this._bg, a, (b) => {
        if (nullableLessThan(b, 0) || nullableGreaterThan(b, 400)) {
          throw new ArgumentOutOfRangeException(2, "value", ExcelUtils.ef("LE_Series_Explosion_OutOfRange"));
        }
      });
      this._bg = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _a3() {
    if (this._bg.hasValue) {
      return this._bg.value;
    }
    let a = this._ap;
    return a != null ? a.explosion : 0;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the data point.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * In this case, the default fill color for the associated [[series]]
   * is used.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fill() {
    return this._af;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the data point.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * In this case, the default fill color for the associated [[series]]
   * is used.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fill(a) {
    if (a != this._af) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._af != null) {
        this._af._l(null);
      }
      let b = this._r(DataPoint.$, ChartFillBase.$, this, 6, this._af, a);
      this._af = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ai() {
    if (this._af != null) {
      return this._af;
    }
    let a = this._ap;
    return a != null ? a.fill : null;
  }
  /**
   * Returns or sets a value indicating whether the pattern is inverted
   * in the item when it corresponds to a negative number.
   */
  get invertIfNegative() {
    return unwrapNullable(this._invertIfNegative$i);
  }
  /**
   * Returns or sets a value indicating whether the pattern is inverted
   * in the item when it corresponds to a negative number.
   */
  set invertIfNegative(a) {
    arguments[0] = wrapNullable(Boolean_$type, arguments[0]);
    this._invertIfNegative$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _invertIfNegative$i() {
    return this._bh;
  }
  /**
   * @hidden
   */
  set _invertIfNegative$i(a) {
    if (nullableNotEquals(a, this._bh)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Boolean_$type), this, 7, this._bh, a);
      this._bh = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _au() {
    let a = ExcelUtils.du(this._bh);
    if (a.hasValue) {
      return a.value;
    }
    let b = this._ap;
    return b != null ? b.invertIfNegative : false;
  }
  /**
   * Determines the appearance of the <see cref="ChartBorder">border</see>
   * (a.k.a. outline) of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker border for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker border is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerBorder]] property to customize the border
   * for all markers in the series.
   * </p>
   * @see [[Series.markerBorder]]
   */
  get markerBorder() {
    return this._aa;
  }
  /**
   * Determines the appearance of the <see cref="ChartBorder">border</see>
   * (a.k.a. outline) of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker border for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker border is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerBorder]] property to customize the border
   * for all markers in the series.
   * </p>
   * @see [[Series.markerBorder]]
   */
  set markerBorder(a) {
    if (a != this._aa) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._aa != null) {
        this._aa._l(null);
      }
      let b = this._r(DataPoint.$, ChartBorder.$, this, 8, this._aa, a);
      this._aa = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ae() {
    if (this._aa != null) {
      return this._aa;
    }
    let a = this._ap;
    return a != null ? a.markerBorder : null;
  }
  /**
   * Defines the <see cref="ChartFillBase">fill</see> appearance of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker fill color for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker fill color is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerFill]] property to customize the fill color
   * for all markers in the series.
   * </p>
   * @see [[Series.markerFill]]
   */
  get markerFill() {
    return this._ag;
  }
  /**
   * Defines the <see cref="ChartFillBase">fill</see> appearance of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker fill color for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker fill color is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerFill]] property to customize the fill color
   * for all markers in the series.
   * </p>
   * @see [[Series.markerFill]]
   */
  set markerFill(a) {
    if (a != this._ag) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ag != null) {
        this._ag._l(null);
      }
      let b = this._r(DataPoint.$, ChartFillBase.$, this, 9, this._ag, a);
      this._ag = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _al() {
    if (this._ag != null) {
      return this._ag;
    }
    let a = this._ap;
    return a != null ? a.markerFill : null;
  }
  /**
   * Determines the size of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker size for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker size is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerSize]] property to customize the size
   * of all markers in the series.
   * </p>
   * @see [[Series.markerSize]]
   */
  get markerSize() {
    return unwrapNullable(this._markerSize$i);
  }
  /**
   * Determines the size of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker size for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker size is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerSize]] property to customize the size
   * of all markers in the series.
   * </p>
   * @see [[Series.markerSize]]
   */
  set markerSize(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._markerSize$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _markerSize$i() {
    return this._bi;
  }
  /**
   * @hidden
   */
  set _markerSize$i(a) {
    if (nullableNotEquals(a, this._bi)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(Number_$type), this, 10, this._bi, a);
      this._bi = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _a9() {
    if (this._bi.hasValue) {
      return this._bi.value;
    }
    let a = this._ap;
    return a != null ? a.markerSize : 5;
  }
  /**
   * Determines the style of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker style for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker style is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerStyle]] property to customize the style
   * of all markers in the series.
   * </p>
   * @see [[Series.markerStyle]]
   */
  get markerStyle() {
    return unwrapNullable(this._markerStyle$i);
  }
  /**
   * Determines the style of the marker for this data point.
   * <p class="body">
   * This property provides a way to customize the marker style for
   * an individual data point in the series.
   * </p>
   * <p class="body">
   * A value of null implies that the marker style is not explicitly
   * set on this data point, and should inherit the value from it's
   * associated [[series]].
   * </p>
   * <p class="body">
   * Use the [[Series.markerStyle]] property to customize the style
   * of all markers in the series.
   * </p>
   * @see [[Series.markerStyle]]
   */
  set markerStyle(a) {
    arguments[0] = wrapNullable(MarkerStyle_$type, arguments[0]);
    this._markerStyle$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _markerStyle$i() {
    return this._bj;
  }
  /**
   * @hidden
   */
  set _markerStyle$i(a) {
    if (nullableNotEquals(a, this._bj)) {
      let b = this._r(DataPoint.$, Nullable$1.$.specialize(MarkerStyle_$type), this, 11, this._bj, a);
      this._bj = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ao() {
    if (this._bj.hasValue) {
      return this._bj.value;
    }
    let a = this._ap;
    return a != null ? a.markerStyle : -4105;
  }
  /**
   * Returns or sets a boolean value indicating whether this data point represents
   * a total or subtotal in a waterfall chart.
   * <p class="body">
   * This property is only applicable for waterfall charts.
   * </p>
   * @see [[Series.showWaterfallConnectorLines]]
   */
  get setAsTotal() {
    return this._aq;
  }
  /**
   * Returns or sets a boolean value indicating whether this data point represents
   * a total or subtotal in a waterfall chart.
   * <p class="body">
   * This property is only applicable for waterfall charts.
   * </p>
   * @see [[Series.showWaterfallConnectorLines]]
   */
  set setAsTotal(a) {
    if (a != this._aq) {
      let b = this._r(DataPoint.$, Boolean_$type, this, 12, this._aq, a);
      this._aq = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ap() {
    let a = typeCast(DataPointCollection.$, this.owner);
    return a != null ? a._y : null;
  }
  /**
   * @hidden
   */
  _aw(a) {
    let b = [this._bd, this._be, this._bf, this._bh];
    for (let d = 0; d < b.length; d++) {
      let c = b[d];
      if (nullableNotEquals(c, null)) {
        return true;
      }
    }
    if (this._aa != null || this._ag != null || this._bi.hasValue || this._bj.hasValue) {
      return true;
    }
    if (this._z != null || this._af != null) {
      return true;
    }
    if (this._bg.hasValue) {
      return true;
    }
    if (a && this._am != null) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _aj(a) {
    if (this._af != null) {
      return this._af;
    }
    let b = this._ap;
    let c = this.chart;
    if (b != null && c != null) {
      let d = WorksheetChart._ge(b.chartType);
      if (d && c.varyColors == false) {
        return b._ao(a);
      }
    }
    return ExcelUtils.p(this, a);
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(DataPoint.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(13);
    ChangeInfo.f(a, 0, DataPoint._y(Nullable$1.$.specialize(Boolean_$type), "ApplyPicToEnd", 7, (b) => b._applyPicToEnd$i, (b, c) => b._applyPicToEnd$i = c));
    ChangeInfo.f(a, 1, DataPoint._y(Nullable$1.$.specialize(Boolean_$type), "ApplyPicToFront", 7, (b) => b._applyPicToFront$i, (b, c) => b._applyPicToFront$i = c));
    ChangeInfo.f(a, 2, DataPoint._y(Nullable$1.$.specialize(Boolean_$type), "ApplyPicToSides", 7, (b) => b._applyPicToSides$i, (b, c) => b._applyPicToSides$i = c));
    ChangeInfo.f(a, 3, DataPoint._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 4, DataPoint._y(DataLabel.$, "DataLabel", 7, (b) => b.dataLabel, (b, c) => b.dataLabel = c));
    ChangeInfo.f(a, 5, DataPoint._y(Nullable$1.$.specialize(Number_$type), "Explosion", 7, (b) => b._explosion$i, (b, c) => b._explosion$i = c));
    ChangeInfo.f(a, 6, DataPoint._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 7, DataPoint._y(Nullable$1.$.specialize(Boolean_$type), "InvertIfNegative", 7, (b) => b._invertIfNegative$i, (b, c) => b._invertIfNegative$i = c));
    ChangeInfo.f(a, 8, DataPoint._y(ChartBorder.$, "MarkerBorder", 7, (b) => b.markerBorder, (b, c) => b.markerBorder = c));
    ChangeInfo.f(a, 9, DataPoint._y(ChartFillBase.$, "MarkerFill", 7, (b) => b.markerFill, (b, c) => b.markerFill = c));
    ChangeInfo.f(a, 10, DataPoint._y(Nullable$1.$.specialize(Number_$type), "MarkerSize", 7, (b) => b._markerSize$i, (b, c) => b._markerSize$i = c));
    ChangeInfo.f(a, 11, DataPoint._y(Nullable$1.$.specialize(MarkerStyle_$type), "MarkerStyle", 7, (b) => b._markerStyle$i, (b, c) => b._markerStyle$i = c));
    ChangeInfo.f(a, 12, DataPoint._y(Boolean_$type, "SetAsTotal", 7, (b) => b.setAsTotal, (b, c) => b.setAsTotal = c));
    return a;
  }
}
DataPoint.$t = markType(DataPoint, 'DataPoint', ChartObject.$);
/**
 * @hidden
 */
DataPoint._ax = 0;
/**
 * @hidden
 */
DataPoint._ay = 1;
/**
 * @hidden
 */
DataPoint._az = 2;
/**
 * @hidden
 */
DataPoint._a0 = 3;
/**
 * @hidden
 */
DataPoint._a1 = 4;
/**
 * @hidden
 */
DataPoint._a2 = 5;
/**
 * @hidden
 */
DataPoint._a4 = 6;
/**
 * @hidden
 */
DataPoint._a5 = 7;
/**
 * @hidden
 */
DataPoint._a6 = 8;
/**
 * @hidden
 */
DataPoint._a7 = 9;
/**
 * @hidden
 */
DataPoint._a8 = 10;
/**
 * @hidden
 */
DataPoint._ba = 11;
/**
 * @hidden
 */
DataPoint._bc = 12;
/**
 * @hidden
 */
DataPoint._bb = 13;
/**
 * @hidden
 */
DataPoint._w = null;
/**
 * A collection of [[DataPoint]]s for a [[series]]
 */
export class DataPointCollection extends ChartObject {
  constructor(a) {
    super(a);
    this._af = new List$1(DataPoint.$, 0);
    this._ad = null;
    this._z = false;
  }
  /**
   * @hidden
   */
  _i(a, b) {
    for (let c of fromEnum(this)) {
      if (c._i(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _m(a) {
    for (let b of fromEnum(this)) {
      b._m(a);
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    for (let d of fromEnum(this)) {
      d._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _k(a) {
    let b = typeCast(List$1.$.specialize(DataPointCollection_UndoContext.$), a);
    if (b == null) {
      return null;
    }
    let c = 0;
    let d = new List$1(DataPointCollection_UndoContext.$, 0);
    for (let e = 0; e < b.count; e++) {
      let f = b._inner[e];
      let g = f.b;
      let h = c + f.c;
      let i = f.a;
      let j = i.length;
      if (g) {
        this._af.s(h, i);
        c += j;
      }
      else {
        this._af.v(h, j);
        c -= j;
      }
      d.add(new DataPointCollection_UndoContext(1, !g, h, i));
    }
    if (d.count > 0) {
      return d;
    }
    return null;
  }
  /**
   * @hidden
   */
  _t(a) {
    for (let b of fromEnum(this)) {
      b._t(a);
    }
  }
  /**
   * @hidden
   */
  get _y() {
    return typeCast(Series.$, this.owner);
  }
  /**
   * Returns the [[DataPoint]] instance at the specified
   * ordinal position within this collection.
   * @param index A zero based index
   * @return A [[DataPoint]] instance.
   */
  item(a) {
    if (this._z) {
      this._an();
    }
    if (a < 0 || a >= this._af.count) {
      throw new IndexOutOfRangeException(0);
    }
    return this._af._inner[a];
  }
  /**
   * @hidden
   */
  _ai() {
    this._af.clear();
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    if (this._z) {
      this._an();
    }
    return this._af.count;
  }
  /**
   * Determines if the collection contains thhe item
   * @param item The item to check
   * @return True if the item is in the collection, otherwise false.
   */
  contains(item) {
    if (this._z) {
      this._an();
    }
    return this._af.contains(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    if (this._z) {
      this._an();
    }
    return this._af.getEnumerator();
  }
  /**
   * Returns the index of the item in the collection
   * @param item The item to check
   * @return the zero-based index or -1 if the item isn't in the collection.
   */
  indexOf(item) {
    if (this._z) {
      this._an();
    }
    return this._af.indexOf(item);
  }
  /**
   * @hidden
   */
  _al(a, b, c) {
    while (this.count < a) {
      this._af.add(new DataPoint(this));
    }
    if (this._af.count > a) {
      this._af.v(a, this._af.count - a);
    }
    let d = 0;
    let e = new List$1(DataPoint.$, 0);
    let f = new List$1(DataPointCollection_UndoContext.$, 0);
    for (let g = 0; g < b.count; g++) {
      let h = b._inner[g];
      let i = h.c;
      let j = d + h.d;
      let k = h.e;
      let l = j;
      while (k > 0) {
        e.add(i ? this._af._inner[l] : new DataPoint(this));
        l++;
        k--;
      }
      if (i) {
        this._af.v(j, e.count);
        d -= e.count;
      }
      else {
        this._af.s(j, e);
        d += e.count;
      }
      f.add(new DataPointCollection_UndoContext(1, i, j, e.toArray()));
      e.clear();
    }
    if (f.count > 0) {
      c(this, f);
    }
  }
  /**
   * @hidden
   */
  _an() {
    let a = this._y;
    let b = this.workbook;
    if (b == null || b._c4) {
      this._z = true;
      return;
    }
    this._z = false;
    if (a == null) {
      return;
    }
    if (a.chartType == 119 && this._ac(a)) {
      return;
    }
    let c = a.values;
    if (c == null) {
      this._ai();
      return;
    }
    let d = c.getValues();
    if (d == null || d.length == 0) {
      this._ai();
      return;
    }
    if (this.count > d.length) {
      this._af.v(d.length, this.count - d.length);
    }
    else {
      while (this.count < d.length) {
        this._af.add(new DataPoint(this));
      }
    }
  }
  /**
   * @hidden
   */
  _ac(a) {
    return this._ab(a, false);
  }
  /**
   * @hidden
   */
  _w() {
    if (this._z) {
      this._an();
    }
    return this._af.toArray();
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    if (this._z) {
      this._an();
    }
    return this._af.getEnumerator();
  }
  /**
   * @hidden
   */
  _aj() {
    if (this._ad != null) {
      let a = typeCast(Series.$, this.owner);
      if (a != null && a.chartType == 119 && a.xValues != null) {
        if (this._ab(a, true)) {
          return;
        }
      }
      let b = a.values != null ? a.values.getValues() : new Array(0);
      this._af = new List$1(DataPoint.$, 2, b.length);
      for (let c = 0; c < b.length; c++) {
        let d = null;
        let e = this._ad.tryGetValue(c, d);
        d = e.p1;
        if (d == null) {
          d = new DataPoint(this);
        }
        else {
          d._l(this);
        }
        this._af.add(d);
      }
      this._ad = null;
    }
  }
  /**
   * @hidden
   */
  _ab(a, b) {
    let c = a.xValues != null ? a.xValues._u() : null;
    if (c == null || c.a != 1) {
      return false;
    }
    let d = new List$1(String_$type, 0);
    let e = (f, g) => {
      for (let h = g; h >= 0; h -= 1) {
        let i = f._inner[h];
        let j = i.a[0];
        if (stringIsNullOrEmpty(j) == false) {
          return j;
        }
      }
      return null;
    };
    for (let f = 0; f < c.c.count; f++) {
      let g = c.c._inner[f];
      let h = f > 0 ? c.c._inner[f - 1] : null;
      let i = true;
      let j = g.a.length - 1;
      for (let k = 0; k < g.a.length; k++) {
        let l = g.a[k];
        if (stringIsNullOrEmpty(l)) {
          if (k == 0) {
            l = e(c.c, f);
          }
          else {
            continue;
          }
        }
        if (h != null && k < j) {
          let m = h.a[k];
          let n = stringEquals1(l, m, 2);
          if (i && n == false) {
            i = false;
          }
          if (i == false) {
            d.add(l);
          }
        }
        else {
          d.add(l);
        }
      }
    }
    let o = b ? this._ad : this._ae();
    this._af = new List$1(DataPoint.$, 2, d.count);
    for (let p = 0; p < d.count; p++) {
      let q = null;
      if (o != null) {
        let r = o.tryGetValue(p, q);
        q = r.p1;
      }
      if (q == null) {
        q = new DataPoint(this);
      }
      else {
        q._l(this);
      }
      this._af.add(q);
    }
    if (b) {
      this._ad = null;
    }
    return true;
  }
  /**
   * @hidden
   */
  _ae() {
    let a = new Dictionary$2(Number_$type, DataPoint.$, 0);
    if (this._af == null) {
      return a;
    }
    for (let b = 0; b < this._af.count; b++) {
      a.addItem(b, this._af._inner[b]);
    }
    return a;
  }
  /**
   * @hidden
   */
  _ak(a) {
    this._ad = new Dictionary$2(Number_$type, DataPoint.$, 1, a.count);
    for (let b of fromEnum(a)) {
      b.value._l(this);
      this._ad.addItem(b.key, b.value);
    }
  }
  /**
   * @hidden
   */
  _am() {
    let a = this.sheet;
    this._aj();
  }
}
DataPointCollection.$t = markType(DataPointCollection, 'DataPointCollection', ChartObject.$, [IEnumerable$1_$type.specialize(DataPoint.$)]);
/**
 * @hidden
 */
export class DataPointCollection_UndoContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.b = false;
    this.c = 0;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.c = d;
          this.a = e;
        }
        break;
    }
  }
}
DataPointCollection_UndoContext.$t = markStruct(DataPointCollection_UndoContext, 'DataPointCollection_UndoContext');
/**
 * Exposes properties which control the appearance and behavior
 * of a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * This class is only used by <i>RegionMap</i> charts.
 * </p>
 */
export class GeographicMapSettings extends Base {
  constructor(cultureLanguage, cultureRegion, attribution, projection, area, labels, colors) {
    super();
    this._cultureLanguage = null;
    this._cultureRegion = null;
    this._attribution = null;
    this._projection$i_1 = Nullable$1.toNullable(GeographicMapProjection_$type, null);
    this._area$i_1 = Nullable$1.toNullable(GeographicMappingArea_$type, null);
    this._labels = 0;
    this._colors = null;
    if (projection !== void 0) {
      projection = wrapNullable(GeographicMapProjection_$type, projection);
    }
    if (area !== void 0) {
      area = wrapNullable(GeographicMappingArea_$type, area);
    }
    labels = (labels !== void 0 ? labels : 0);
    colors = (colors !== void 0 ? colors : null);
    this.cultureLanguage = cultureLanguage;
    this.cultureRegion = cultureRegion;
    this.attribution = attribution;
    this._projection$i = projection;
    this._area$i = area;
    this.labels = labels;
    this.colors = colors;
  }
  /**
   * @hidden
   */
  static _c() {
    return new GeographicMapSettings("en-US", "US", "Powered by Bing", Nullable$1.toNullable(GeographicMapProjection_$type, null), Nullable$1.toNullable(GeographicMappingArea_$type, null), 0, null);
  }
  /**
   * @hidden
   */
  get _m() {
    return "{E9337A44-BEBE-4D9F-B70C-5C5E7DAFC167}";
  }
  /**
   * Returns the culture language for this instance.
   */
  get cultureLanguage() {
    return this._cultureLanguage;
  }
  /**
   * Returns the culture language for this instance.
   */
  set cultureLanguage(a) {
    this._cultureLanguage = a;
  }
  /**
   * Returns the culture region for this instance.
   */
  get cultureRegion() {
    return this._cultureRegion;
  }
  /**
   * Returns the culture region for this instance.
   */
  set cultureRegion(a) {
    this._cultureRegion = a;
  }
  /**
   * Returns the attribution for this instance.
   */
  get attribution() {
    return this._attribution;
  }
  /**
   * Returns the attribution for this instance.
   */
  set attribution(a) {
    this._attribution = a;
  }
  /**
   * Returns the map projection for this instance.
   */
  get projection() {
    return unwrapNullable(this._projection$i);
  }
  /**
   * Returns the map projection for this instance.
   */
  set projection(a) {
    this._projection$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _projection$i() {
    return this._projection$i_1;
  }
  /**
   * @hidden
   */
  set _projection$i(a) {
    this._projection$i_1 = a;
  }
  /**
   * Returns the mapping area for this instance.
   */
  get area() {
    return unwrapNullable(this._area$i);
  }
  /**
   * Returns the mapping area for this instance.
   */
  set area(a) {
    this._area$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _area$i() {
    return this._area$i_1;
  }
  /**
   * @hidden
   */
  set _area$i(a) {
    this._area$i_1 = a;
  }
  /**
   * Returns a value indicating the manner in which map area labels are displayed.
   */
  get labels() {
    return this._labels;
  }
  /**
   * Returns a value indicating the manner in which map area labels are displayed.
   */
  set labels(a) {
    this._labels = a;
  }
  /**
   * Returns a [[GeographicMapColors]] instance which defines the minimum,
   * midpoint, and maximum colors used for the applicable areas of a geographic map
   * chart.
   * @see [[GeographicMapColors]]
   */
  get colors() {
    return this._colors;
  }
  /**
   * Returns a [[GeographicMapColors]] instance which defines the minimum,
   * midpoint, and maximum colors used for the applicable areas of a geographic map
   * chart.
   * @see [[GeographicMapColors]]
   */
  set colors(a) {
    this._colors = a;
  }
}
GeographicMapSettings.$t = markType(GeographicMapSettings, 'GeographicMapSettings');
/**
 * @hidden
 */
GeographicMapSettings._g = "{E9337A44-BEBE-4D9F-B70C-5C5E7DAFC167}";
/**
 * @hidden
 */
GeographicMapSettings._j = "Powered by Bing";
/**
 * @hidden
 */
GeographicMapSettings._k = "en-US";
/**
 * @hidden
 */
GeographicMapSettings._l = "US";
/**
 * Exposes properties related to series coloring for a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * Assign an instance of this class to the <see cref="GeographicMapSettings.Colors">Colors</see>
 * property of the [[GeographicMapSettings]] class to provide custom colors for map areas.
 * </p>
 */
export class GeographicMapColors extends Base {
  constructor(seriesColor, minimum, midpoint, maximum) {
    super();
    /**
     * @hidden
     */
    this._c = [218, 227, 243];
    /**
     * @hidden
     */
    this._b = [237, 125, 49];
    /**
     * @hidden
     */
    this._a = [47, 85, 151];
    this._minimum = null;
    this._midpoint = null;
    this._maximum = null;
    this._seriesColor = 0;
    this.seriesColor = seriesColor;
    this.minimum = minimum;
    this.midpoint = midpoint;
    this.maximum = maximum;
  }
  /**
   * Returns the color used for the minimum value.
   */
  get minimum() {
    return this._minimum;
  }
  /**
   * Returns the color used for the minimum value.
   */
  set minimum(a) {
    this._minimum = a;
  }
  /**
   * @hidden
   */
  get _j() {
    if (WorkbookColorInfo.l_op_Inequality(this.minimum, null)) {
      return this.minimum;
    }
    return new WorkbookColorInfo(Color.u(255, this._c[0], this._c[1], this._c[2]));
  }
  /**
   * Returns the color used for the midpoint value.
   */
  get midpoint() {
    return this._midpoint;
  }
  /**
   * Returns the color used for the midpoint value.
   */
  set midpoint(a) {
    this._midpoint = a;
  }
  /**
   * @hidden
   */
  get _h() {
    if (WorkbookColorInfo.l_op_Inequality(this.midpoint, null)) {
      return this.midpoint;
    }
    return new WorkbookColorInfo(Color.u(255, this._b[0], this._b[1], this._b[2]));
  }
  /**
   * Returns the color used for the maximum value.
   */
  get maximum() {
    return this._maximum;
  }
  /**
   * Returns the color used for the maximum value.
   */
  set maximum(a) {
    this._maximum = a;
  }
  /**
   * @hidden
   */
  get _f() {
    if (WorkbookColorInfo.l_op_Inequality(this.maximum, null)) {
      return this.maximum;
    }
    return new WorkbookColorInfo(Color.u(255, this._a[0], this._a[1], this._a[2]));
  }
  /**
   * Returns a value indicating whether a sequential (two-color)
   * or divergent (three-color) scheme is used to color regions in
   * a geographic map chart.
   */
  get seriesColor() {
    return this._seriesColor;
  }
  /**
   * Returns a value indicating whether a sequential (two-color)
   * or divergent (three-color) scheme is used to color regions in
   * a geographic map chart.
   */
  set seriesColor(a) {
    this._seriesColor = a;
  }
}
GeographicMapColors.$t = markType(GeographicMapColors, 'GeographicMapColors');
/**
 * Represents leader lines on a chart. Leader lines connect data labels to data points.
 * <para class="note">
 * <b>Note:</b> this object is not a collection and there is no object that represents a single leader line.
 * </para>
 */
export class LeaderLines extends ChartLineBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 0) {
      a = 0;
    }
    else if (arguments.length === 1) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          super(null);
          this._ak = null;
        }
        break;
      case 1:
        {
          let owner = _rest[0];
          super(owner);
          this._ak = null;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get _al() {
    if (this.fill != null) {
      return this.fill;
    }
    if (this._ak == null) {
      this._ak = ChartSolidFill._w(1, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, 0.35), Nullable$1.toNullable(Number_$type, 0.65));
    }
    return this._ak;
  }
}
LeaderLines.$t = markType(LeaderLines, 'LeaderLines', ChartLineBase.$);
/**
 * Represents a [[Trendline]] label.
 */
export class TrendlineLabel extends ChartLabelBase {
  constructor() {
    super(null);
    this._ch = false;
    this._ci = false;
  }
  /**
   * Returns or sets a boolean value indicating whether the
   * default trendline equation is displayed within the label.
   * @see [[Trendline.label]]
   */
  get displayEquation() {
    return this._ch;
  }
  /**
   * Returns or sets a boolean value indicating whether the
   * default trendline equation is displayed within the label.
   * @see [[Trendline.label]]
   */
  set displayEquation(a) {
    if (a != this._ch) {
      let b = this._r(TrendlineLabel.$, Boolean_$type, this, 17, this._ch, a);
      this._ch = b.p2;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether the
   * default R-squared function is displayed within the label.
   * @see [[Trendline.label]]
   */
  get displayRSquared() {
    return this._ci;
  }
  /**
   * Returns or sets a boolean value indicating whether the
   * default R-squared function is displayed within the label.
   * @see [[Trendline.label]]
   */
  set displayRSquared(a) {
    if (a != this._ci) {
      let b = this._r(TrendlineLabel.$, Boolean_$type, this, 18, this._ci, a);
      this._ci = b.p2;
    }
  }
  static staticInit() {
    TrendlineLabel._ce = TrendlineLabel._cf();
  }
  /**
   * @hidden
   */
  _a(a) {
    if (a < 17) {
      return super._a(a);
    }
    return TrendlineLabel._ce[a - 17];
  }
  /**
   * @hidden
   */
  static _cg($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(TrendlineLabel.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _cf() {
    let a = 17;
    let b = new Array(19 - a);
    ChangeInfo.f(b, 17 - a, TrendlineLabel._cg(Boolean_$type, "DisplayEquation", 7, (c) => c.displayEquation, (c, d) => c.displayEquation = d));
    ChangeInfo.f(b, 18 - a, TrendlineLabel._cg(Boolean_$type, "DisplayRSquared", 7, (c) => c.displayRSquared, (c, d) => c.displayRSquared = d));
    return b;
  }
}
TrendlineLabel.$t = markType(TrendlineLabel, 'TrendlineLabel', ChartLabelBase.$);
/**
 * @hidden
 */
TrendlineLabel._cl = 17;
/**
 * @hidden
 */
TrendlineLabel._cm = 17 + 1;
/**
 * @hidden
 */
TrendlineLabel._cn = 17 + 2;
/**
 * @hidden
 */
TrendlineLabel._ce = null;
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export class TrendlineLine extends ChartLine {
  constructor() {
    super();
  }
  /**
   * @hidden
   */
  _as(a) {
    if (this.fill != null) {
      return this.fill;
    }
    return ExcelUtils.p(this, a);
  }
}
TrendlineLine.$t = markType(TrendlineLine, 'TrendlineLine', ChartLine.$);
/**
 * Represents a [[Series]] trendline.
 * @see [[Series.trendlineCollection]]
 */
export class Trendline extends ChartObject {
  constructor(a) {
    super(a);
    this._aj = 0;
    this._ak = 0;
    this._a1 = Nullable$1.toNullable(Number_$type, null);
    this._ab = null;
    this._z = null;
    this._ad = null;
    this._a3 = null;
    this._af = 2;
    this._ao = 2;
    this._ah = 1;
    let b = new TrendlineLine();
    b.fill = new ChartSolidFill(new WorkbookColorInfo(1));
    b.widthInPoints = 1.5;
    this._ad = b;
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._ab != null && this._ab._i(a, b)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _m(a) {
    if (this._ab != null) {
      this._ab._m(a);
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    if (this._ab != null) {
      this._ab._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._ab != null) {
      this._ab._t(a);
    }
  }
  /**
   * Specifies the number of periods or units by which the
   * trendline extends backward.
   */
  get backward() {
    return this._aj;
  }
  /**
   * Specifies the number of periods or units by which the
   * trendline extends backward.
   */
  set backward(a) {
    if (a != this._aj) {
      let b = this._r(Trendline.$, Number_$type, this, 0, this._aj, a);
      this._aj = b.p2;
    }
  }
  /**
   * Specifies the number of periods or units by which the
   * trendline extends forward.
   */
  get forward() {
    return this._ak;
  }
  /**
   * Specifies the number of periods or units by which the
   * trendline extends forward.
   */
  set forward(a) {
    if (a != this._ak) {
      let b = this._r(Trendline.$, Number_$type, this, 1, this._ak, a);
      this._ak = b.p2;
    }
  }
  /**
   * Specifies the value axis intercept for the trendline.
   * <p class="body">
   * If this property is left unset, or assigned a value of null,
   * the intercept is automatically determined by Excel.
   * </p>
   */
  get intercept() {
    return unwrapNullable(this._intercept$i);
  }
  /**
   * Specifies the value axis intercept for the trendline.
   * <p class="body">
   * If this property is left unset, or assigned a value of null,
   * the intercept is automatically determined by Excel.
   * </p>
   */
  set intercept(a) {
    arguments[0] = wrapNullable(Number_$type, arguments[0]);
    this._intercept$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _intercept$i() {
    return this._a1;
  }
  /**
   * @hidden
   */
  set _intercept$i(a) {
    if (nullableNotEquals(a, this._a1)) {
      let b = this._r(Trendline.$, Nullable$1.$.specialize(Number_$type), this, 2, this._a1, a);
      this._a1 = b.p2;
    }
  }
  /**
   * Returns or sets a [[TrendlineLabel]] instance
   * which determines the text and appearance of the trendline label.
   * <p class="body">
   * This property is null by default, which prevents a label from appearing.
   * </p>
   * <p class="body">
   * To display a label for the trendline, assign a [[TrendlineLabel]]
   * instance to this property.
   * </p>
   * @see [[TrendlineLabel]]
   */
  get label() {
    return this._ab;
  }
  /**
   * Returns or sets a [[TrendlineLabel]] instance
   * which determines the text and appearance of the trendline label.
   * <p class="body">
   * This property is null by default, which prevents a label from appearing.
   * </p>
   * <p class="body">
   * To display a label for the trendline, assign a [[TrendlineLabel]]
   * instance to this property.
   * </p>
   * @see [[TrendlineLabel]]
   */
  set label(a) {
    let b = this._ab;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Trendline.$, TrendlineLabel.$, this, 3, this._ab, a);
      this._ab = c.p2;
    }
  }
  /**
   * Returns a [[legendEntry]] instance which determines the
   * appearance of this trendline's appearance in the [[WorksheetChart.legend]].
   * @see [[WorksheetChart.legend]]
   */
  get legendEntry() {
    if (this._z == null) {
      this._z = new LegendEntry(this);
    }
    return this._z;
  }
  /**
   * Returns a [[legendEntry]] instance which determines the
   * appearance of this trendline's appearance in the [[WorksheetChart.legend]].
   * @see [[WorksheetChart.legend]]
   */
  set legendEntry(a) {
    if (a != null) {
      a._l(this);
    }
    this._z = a;
  }
  /**
   * Returns or sets a [[TrendlineLine]] instance which controls
   * the color and width of the trendline.
   * <p class="body">
   * To prevent the trendline from appearing in the chart, set this property to null.
   * </p>
   */
  get line() {
    return this._ad;
  }
  /**
   * Returns or sets a [[TrendlineLine]] instance which controls
   * the color and width of the trendline.
   * <p class="body">
   * To prevent the trendline from appearing in the chart, set this property to null.
   * </p>
   */
  set line(a) {
    if (a != this._ad) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ad != null) {
        this._ad._l(null);
      }
      let b = this._r(Trendline.$, TrendlineLine.$, this, 4, this._ad, a);
      this._ad = b.p2;
    }
  }
  /**
   * Specifies the name of the trendline.
   */
  get name() {
    return this._a3;
  }
  /**
   * Specifies the name of the trendline.
   */
  set name(a) {
    if (a != this._a3) {
      let b = this._r(Trendline.$, String_$type, this, 5, this._a3, a);
      this._a3 = b.p2;
    }
  }
  /**
   * Specifies the order/degree of the polynomial function
   * which defines the trendline. Applicable only when the
   * [[trendlineType]] property is set to <i>Polynomial</i>.
   * <p class="body">
   * This property is only applicable when the [[trendlineType]]
   * property is set to <i>Polynomial</i>.
   * </p>
   * <p class="body">
   * Trendlines support second-degree through sixth-degree polynomials.
   * </p>
   */
  get order() {
    return this._af;
  }
  /**
   * Specifies the order/degree of the polynomial function
   * which defines the trendline. Applicable only when the
   * [[trendlineType]] property is set to <i>Polynomial</i>.
   * <p class="body">
   * This property is only applicable when the [[trendlineType]]
   * property is set to <i>Polynomial</i>.
   * </p>
   * <p class="body">
   * Trendlines support second-degree through sixth-degree polynomials.
   * </p>
   */
  set order(a) {
    if (a != this._af) {
      let b = this._r(Trendline.$, TrendlinePolynomialOrder_$type, this, 6, this._af, a);
      this._af = b.p2;
    }
  }
  /**
   * Specifies the period for a moving-average trendline.
   * Applicable only when the [[trendlineType]]
   * property is set to <i>MovingAverage</i>.
   */
  get period() {
    return this._ao;
  }
  /**
   * Specifies the period for a moving-average trendline.
   * Applicable only when the [[trendlineType]]
   * property is set to <i>MovingAverage</i>.
   */
  set period(a) {
    if (a != this._ao) {
      let b = this._r(Trendline.$, Number_$type, this, 7, this._ao, a);
      this._ao = b.p2;
    }
  }
  /**
   * Specifies the type of trendline, i.e., linear, exponential, polynomial, etc.
   */
  get trendlineType() {
    return this._ah;
  }
  /**
   * Specifies the type of trendline, i.e., linear, exponential, polynomial, etc.
   */
  set trendlineType(a) {
    if (a != this._ah) {
      let b = this._r(Trendline.$, TrendlineType_$type, this, 8, this._ah, a);
      this._ah = b.p2;
    }
  }
  /**
   * @hidden
   */
  _a(a) {
    return Trendline._w[a];
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(Trendline.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(9);
    ChangeInfo.f(a, 0, Trendline._y(Number_$type, "Backward", 7, (b) => b.backward, (b, c) => b.backward = c));
    ChangeInfo.f(a, 1, Trendline._y(Number_$type, "Forward", 7, (b) => b.forward, (b, c) => b.forward = c));
    ChangeInfo.f(a, 2, Trendline._y(Nullable$1.$.specialize(Number_$type), "Intercept", 7, (b) => b._intercept$i, (b, c) => b._intercept$i = c));
    ChangeInfo.f(a, 3, Trendline._y(TrendlineLabel.$, "Label", 7, (b) => b.label, (b, c) => b.label = c));
    ChangeInfo.f(a, 4, Trendline._y(TrendlineLine.$, "Line", 7, (b) => b.line, (b, c) => b.line = c));
    ChangeInfo.f(a, 5, Trendline._y(String_$type, "Name", 7, (b) => b.name, (b, c) => b.name = c));
    ChangeInfo.f(a, 6, Trendline._y(TrendlinePolynomialOrder_$type, "Order", 7, (b) => b.order, (b, c) => b.order = c));
    ChangeInfo.f(a, 7, Trendline._y(Number_$type, "Period", 7, (b) => b.period, (b, c) => b.period = c));
    ChangeInfo.f(a, 8, Trendline._y(TrendlineType_$type, "TrendlineType", 7, (b) => b.trendlineType, (b, c) => b.trendlineType = c));
    return a;
  }
}
Trendline.$t = markType(Trendline, 'Trendline', ChartObject.$);
/**
 * @hidden
 */
Trendline._ap = 0;
/**
 * @hidden
 */
Trendline._ar = 1;
/**
 * @hidden
 */
Trendline._as = 2;
/**
 * @hidden
 */
Trendline._at = 3;
/**
 * @hidden
 */
Trendline._au = 4;
/**
 * @hidden
 */
Trendline._av = 5;
/**
 * @hidden
 */
Trendline._ax = 6;
/**
 * @hidden
 */
Trendline._az = 7;
/**
 * @hidden
 */
Trendline._a0 = 8;
/**
 * @hidden
 */
Trendline._aw = 9;
/**
 * @hidden
 */
Trendline._aq = 2;
/**
 * @hidden
 */
Trendline._am = 1.5;
/**
 * @hidden
 */
Trendline._w = Trendline._x();
/**
 * @hidden
 */
export class TrendlineCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.c = 0;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          this.b = c;
          this.a = d;
          this.c = e;
        }
        break;
    }
  }
  get workbook() {
    return this.b.workbook;
  }
  get sheet() {
    return this.b.sheet;
  }
  get source() {
    return this.b.chart;
  }
}
TrendlineCollection_CollectionChangeContext.$t = markStruct(TrendlineCollection_CollectionChangeContext, 'TrendlineCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[Trendline]] objects belonging to the same [[Series]].
 * @see [[Series.trendlineCollection]]
 */
export class TrendlineCollection extends ChartObject {
  constructor(a) {
    super(a);
    this._af = new List$1(Trendline.$, 0);
  }
  static staticInit() {
    TrendlineCollection._w = TrendlineCollection._x();
  }
  /**
   * @hidden
   */
  _i(a, b) {
    for (let c = 0; c < this._af.count; c++) {
      let d = this._af._inner[c];
      if (d._i(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _m(a) {
    for (let b of fromEnum(this)) {
      b._m(a);
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    for (let d of fromEnum(this)) {
      d._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    for (let b of fromEnum(this)) {
      b._t(a);
    }
  }
  /**
   * Returns the [[Trendline]] instance at the specified
   * ordinal position within the collection.
   * @param index A zero based index
   */
  item(a) {
    return this._af._inner[a];
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    return this._af.count;
  }
  /**
   * Determines if the collecion can be modified (read-only)
   */
  get isReadOnly() {
    let a = this.workbook;
    if (a != null) {
      return !a._cn;
    }
    return false;
  }
  /**
   * Adds a new [[Trendline]] to the collection
   * @return The newly added [[Series]]
   */
  add() {
    return this.insert(this._af.count);
  }
  /**
   * @hidden
   */
  _al(a) {
    if (a.owner == null) {
      a._l(this);
    }
    else {
      ChartObject._v(a.owner, this);
    }
    this._af.add(a);
  }
  /**
   * Clears the collection.
   */
  clear() {
    this._u();
    let a = this._af.count > 1 ? this._j(7) : null;
    for (let b = this._af.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._p(a);
  }
  /**
   * Returns a boolean value indicating whether the specified
   * instance is contained within this collection.
   * @param item The item to check
   * @return True if the item is in the collection, otherwise false.
   */
  contains(item) {
    return this._af.contains(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return this._af.getEnumerator();
  }
  /**
   * Returns the index of the item in the collection.
   * @param item The item to check
   * @return the zero-based index or -1 if the item isn't in the collection.
   */
  indexOf(item) {
    return this._af.indexOf(item);
  }
  /**
   * Inserts a new [[Trendline]] into the collection at the specified index.
   * @param index The index at which to insert the new trendline.
   * @return The newly inserted [[Trendline]]
   */
  insert(index) {
    this._u();
    let a = new Trendline(this);
    this._an(index, a);
    return a;
  }
  /**
   * @hidden
   */
  _an(a, b, c = true) {
    this._af.insert(a, b);
    let d = this.workbook;
    if (d == null || d._c4 || this._h) {
      return;
    }
    let e = TrendlineCollection._w[0];
    let f = new TrendlineCollection_CollectionChangeContext(1, this, b, a);
    let g = this.sheet;
    let h = e.b(d, g, e.c);
    e.e(TrendlineCollection_CollectionChangeContext.$, Trendline.$, f, null, b);
    if (h != null) {
      e.d(d, h);
    }
    this.onPropertyChanged();
  }
  /**
   * Removes an item from the collection.
   * @param item The [[Trendline]] to remove
   * @return True if the trendline was removed, otherwise false.
   */
  remove(item) {
    let a = this.indexOf(item);
    if (a >= 0) {
      this.removeAt(a);
      return true;
    }
    return false;
  }
  /**
   * Removes the series at the specified index
   * @param index The zero-based index
   */
  removeAt(index) {
    this._u();
    let a = this._af._inner[index];
    let b = this.workbook;
    let c = this.sheet;
    let d = TrendlineCollection._w[1];
    let e = new TrendlineCollection_CollectionChangeContext(1, this, a, index);
    let f = b == null || b._c4 || this._h ? null : d.b(b, c, d.c);
    this._af.removeAt(index);
    if (b != null && !b._c4 && !this._h) {
      d.e(TrendlineCollection_CollectionChangeContext.$, Trendline.$, e, null, a);
      if (f != null) {
        d.d(b, f);
      }
    }
    this.onPropertyChanged();
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return this._af.getEnumerator();
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(TrendlineCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, TrendlineCollection._y(Trendline.$, "Add", 7, (b) => b.a, (b, c) => TrendlineCollection._ap(b, c)));
    ChangeInfo.f(a, 1, TrendlineCollection._y(Trendline.$, "Remove", 7, (b) => b.a, (b, c) => TrendlineCollection._aq(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  static _ap(a, b) {
    let c = a.b.indexOf(a.a);
    if (c >= 0) {
      a.b.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _aq(a, b) {
    let c = a.a;
    a.b._an(a.c, c, true);
  }
}
TrendlineCollection.$t = markType(TrendlineCollection, 'TrendlineCollection', ChartObject.$, [IEnumerable$1_$type.specialize(Trendline.$)]);
/**
 * @hidden
 */
TrendlineCollection._ag = 0;
/**
 * @hidden
 */
TrendlineCollection._ak = 1;
/**
 * @hidden
 */
TrendlineCollection._aj = 2;
/**
 * @hidden
 */
TrendlineCollection._w = null;
/**
 * Represents the error bars on a chart series.
 * <para>
 * Error bars indicate the degree of uncertainty for chart data. Only series in area, bar, column, line, and scatter groups on a 2-D chart can have error bars. Only series in scatter groups can have x and y error bars. This object isn't a collection. There's no object that represents a single error bar; you either have x error bars or y error bars turned on for all points in a series or you have them turned off.
 * </para>
 */
export class ErrorBars extends ChartObject {
  constructor() {
    super(null);
    this._ae = 0;
    this._ac = 2;
    this._ag = 3;
    this._z = null;
    this._ai = 0;
    this._aj = 0.75;
  }
  /**
   * @hidden
   */
  _a(a) {
    return ErrorBars._w[a];
  }
  /**
   * Returns or sets a value which determines the direction in which
   * the error bars extend from the data points.
   */
  get direction() {
    return this._ae;
  }
  /**
   * Returns or sets a value which determines the direction in which
   * the error bars extend from the data points.
   */
  set direction(a) {
    if (a != this._ae) {
      let b = this._q(ErrorBars.$, ErrorBarDirection_$type, this, 0, this._ae, a);
      this._ae = b.p2;
    }
  }
  /**
   * Returns or sets the end style for the error bars.
   */
  get endStyle() {
    return this._ac;
  }
  /**
   * Returns or sets the end style for the error bars.
   */
  set endStyle(a) {
    if (a != this._ac) {
      let b = this._q(ErrorBars.$, EndStyleCap_$type, this, 1, this._ac, a);
      this._ac = b.p2;
    }
  }
  /**
   * Returns or sets a value which determines the units used to
   * evaluate the error.
   */
  get errorValueType() {
    return this._ag;
  }
  /**
   * Returns or sets a value which determines the units used to
   * evaluate the error.
   */
  set errorValueType(a) {
    if (a != this._ag) {
      let b = this._q(ErrorBars.$, ErrorValueType_$type, this, 2, this._ag, a);
      this._ag = b.p2;
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill color/gradient for the line.
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fill() {
    return this._z;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill color/gradient for the line.
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fill(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(ErrorBars.$, ChartFillBase.$, this, 3, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ab() {
    if (this._z != null) {
      return this._z;
    }
    let a = this.chart;
    return a != null ? a._ez : ChartSolidFill._w(1);
  }
  /**
   * Determines the width of the line, expressed in points.
   * <p class="body">
   * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
   * </p>
   */
  get widthInPoints() {
    return this._aj;
  }
  /**
   * Determines the width of the line, expressed in points.
   * <p class="body">
   * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
   * </p>
   */
  set widthInPoints(a) {
    if (a != this._aj) {
      let b = this._r(ErrorBars.$, Number_$type, this, 5, this._aj, a);
      this._aj = b.p2;
    }
  }
  /**
   * Returns or sets a value which defines the error range.
   * <p class="body">
   * The unit for this property is determined by the [[errorValueType]] property.
   * </p>
   * @see [[errorValueType]]
   */
  get value() {
    return this._ai;
  }
  /**
   * Returns or sets a value which defines the error range.
   * <p class="body">
   * The unit for this property is determined by the [[errorValueType]] property.
   * </p>
   * @see [[errorValueType]]
   */
  set value(a) {
    if (a != this._ai) {
      let b = this._r(ErrorBars.$, Number_$type, this, 4, this._ai, a);
      this._ai = b.p2;
    }
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(ErrorBars.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(6);
    ChangeInfo.f(a, 0, ErrorBars._y(ErrorBarDirection_$type, "Direction", 7, (b) => b.direction, (b, c) => b.direction = c));
    ChangeInfo.f(a, 1, ErrorBars._y(EndStyleCap_$type, "EndStyle", 7, (b) => b.endStyle, (b, c) => b.endStyle = c));
    ChangeInfo.f(a, 2, ErrorBars._y(ErrorValueType_$type, "ErrorValueType", 7, (b) => b.errorValueType, (b, c) => b.errorValueType = c));
    ChangeInfo.f(a, 3, ErrorBars._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 4, ErrorBars._y(Number_$type, "Value", 7, (b) => b.value, (b, c) => b.value = c));
    ChangeInfo.f(a, 5, ErrorBars._y(Number_$type, "WidthInPoints", 7, (b) => b.widthInPoints, (b, c) => b.widthInPoints = c));
    return a;
  }
}
ErrorBars.$t = markType(ErrorBars, 'ErrorBars', ChartObject.$);
/**
 * @hidden
 */
ErrorBars._am = 0;
/**
 * @hidden
 */
ErrorBars._an = 1;
/**
 * @hidden
 */
ErrorBars._ao = 2;
/**
 * @hidden
 */
ErrorBars._ap = 3;
/**
 * @hidden
 */
ErrorBars._ar = 4;
/**
 * @hidden
 */
ErrorBars._as = 5;
/**
 * @hidden
 */
ErrorBars._aq = 6;
/**
 * @hidden
 */
ErrorBars._w = ErrorBars._x();
/**
 * Represents a solid color fill for a chart element.
 */
export class ChartSolidFill extends ChartFillBase {
  constructor(color) {
    super(null);
    this._x = null;
    this._x = color;
  }
  /**
   * @hidden
   */
  static _w(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
    let e = null;
    if (c.hasValue || d.hasValue) {
      e = new WorkbookColorTransform(b, c, d, Nullable$1.toNullable(Number_$type, null));
    }
    let f = new WorkbookColorInfo(a, e);
    return new ChartSolidFill(f);
  }
  /**
   * Returns the color which is applied to the fill.
   */
  get color() {
    return this._x;
  }
}
ChartSolidFill.$t = markType(ChartSolidFill, 'ChartSolidFill', ChartFillBase.$);
/**
 * Represents a gradient fill for a chart element.
 * @see [[GradientStop]]
 * @see [[GradientType]]
 */
export class ChartGradientFill extends ChartFillBase {
  constructor(gradientType, stops, angle) {
    super(null);
    this._z = null;
    this._w = 0;
    this._aa = 0;
    angle = (angle !== void 0 ? angle : 0);
    if (stops == null) {
      throw new ArgumentNullException(0, "stops");
    }
    this._w = gradientType;
    this._aa = angle;
    this._ac(stops);
  }
  /**
   * Returns the angle defining the path along which the gradient extends;
   * applicable only for linear gradients.
   * <p class="body">
   * This property only applies to linear gradients.
   * </p>
   * <p class="body">
   * This property defines the angle the gradient path makes with the horizontal plane.
   * </p>
   * <p class="body">
   * For example, a gradient which extends from left to right can be changed to extend from
   * bottom to top by setting this property to 90 degrees.
   * </p>
   * <p class="body">
   * A value of 45 degrees yields a gradient which extends from the bottom left corner
   * of the containing element to the top right corner.
   * </p>
   */
  get angle() {
    return this._aa;
  }
  /**
   * Defines the style for the gradient.
   */
  get gradientType() {
    return this._w;
  }
  /**
   * Returns an enumerable list containing each [[GradientStop]]
   * associated with this gradient, ordered by their [[GradientStop.position]].
   * @return An array of [[GradientStop]] instances.
   */
  getStops() {
    return this._z.toArray();
  }
  /**
   * @hidden
   */
  _ac(a) {
    this._z = a == null ? null : new List$1(GradientStop.$, 1, a);
    if (this._z == null || this._z.count < 1) {
      throw new BaseError(1, DocCoreUtils.z("LE_ChartGradientFill_EmptyStops"));
    }
    DocCoreUtils.ar(GradientStop.$, this._z, new GradientStop_SortComparer());
  }
}
ChartGradientFill.$t = markType(ChartGradientFill, 'ChartGradientFill', ChartFillBase.$);
/**
 * Placeholder which indicates that no fill should be
 * rendered for the associated chart element.
 * <p class="body">
 * Some chart elements require an explicit setting to prevent the fill from appearing.
 * </p>
 * <p class="body">
 * Whether a fill is automatically rendered by Excel is dependent on the chart element.
 * </p>
 * <p class="body">
 * Use this class to ensure that no fill is rendered for the associated chart element.
 * </p>
 * @see [[ChartSolidFill]]
 * @see [[ChartGradientFill]]
 */
export class ChartEmptyFill extends ChartFillBase {
  constructor() {
    super(null);
  }
}
ChartEmptyFill.$t = markType(ChartEmptyFill, 'ChartEmptyFill', ChartFillBase.$);
/**
 * Describes the location and color of a transition
 * point in a <see cref="ChartGradientFill">gradient</see>.
 */
export class GradientStop extends Base {
  constructor(color, position) {
    super();
    this._a = null;
    this._c = 0;
    GradientStop._e(position);
    this._a = color;
    this._c = position;
  }
  /**
   * Returns the color for this gradient stop.
   */
  get color() {
    return this._a;
  }
  /**
   * Returns the position of this gradient stop, as a number between 0 and 1.
   * <p class="body">
   * The value assigned to the Position property represents a fraction
   * of the area to which the gradient is applied.
   * </p>
   * <p class="body">
   * For example, to add two stops of equal length, create one GradientStop
   * with a position of .5 and another with a position of 1.0.
   * </p>
   * <p class="body">
   * The first stop extends from the origin to the halfway point of the fill area,
   * and the second extends from the end of the first to the endpoint of the area
   * to be filled. For three uniform stops, use .33. .67, and 1.0 as the respective
   * positions; for four, use .25, .5, .75, and 1.0, etc.
   * </p>
   */
  get position() {
    return this._c;
  }
  /**
   * @hidden
   */
  static _e(a, b = null) {
    if (a < 0 || a > 1) {
      let c = ExcelUtils.ef("LE_GradientStop_InvalidPosition");
      throw new ArgumentOutOfRangeException(2, b, c);
    }
  }
}
GradientStop.$t = markType(GradientStop, 'GradientStop');
/**
 * @hidden
 */
export class GradientStop_SortComparer extends Base {
  compare(a, b) {
    if (a == null || b == null) {
      return 0;
    }
    return Base.compareSimple(a.position, b.position);
  }
}
GradientStop_SortComparer.$t = markType(GradientStop_SortComparer, 'GradientStop_SortComparer', Base.$, [IComparer$1_$type.specialize(GradientStop.$)]);
/**
 * Represents the legend in a chart. Each chart can have only one legend.
 */
export class Legend extends ChartObject {
  constructor() {
    super(null);
    this._z = null;
    this._ao = null;
    this._ab = null;
    this._ap = null;
    this._ac = null;
    this._au = 0;
    this._av = 0;
    this._ag = null;
    this._aq = false;
    this._ai = 6;
    this._aw = 0;
    this._ak = 0;
    this._ax = 0;
    this._ay = 0;
  }
  /**
   * @hidden
   */
  _a(a) {
    return Legend._w[a];
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   */
  get border() {
    return this._z;
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   */
  set border(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(Legend.$, ChartBorder.$, this, 0, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * Defines the font properties for <see cref="LegendEntries">legend entries</see>
   * which have no specific font settings. Read-only.
   * <p class="body">
   * To apply font settings to a specific legend entry, use the
   * [[LegendEntry.font]] property.
   * </p>
   * <para class="note"><b>Note:</b> this property will return null until the [[Legend]]
   * is set on the <see cref="WorksheetChart.Legend">WorksheetChart.Legend</see> property.</para>
   * @see [[LegendEntry.font]]
   */
  get defaultFont() {
    this._e(this.workbook);
    return this._ao;
  }
  /**
   * @hidden
   */
  _e(a) {
    if (this._ao != null) {
      return this._ao;
    }
    let b = this.workbook != null ? this.workbook : a;
    if (b == null) {
      return null;
    }
    this._ao = this._f(b);
    return this._ao;
  }
  /**
   * @hidden
   */
  get _an() {
    let a = this.workbook;
    if (a != null && this._ap == null) {
      this._ap = this._f(a, false);
      this._ap.height = 20 * 9;
    }
    let b = [this._ao, this._ap];
    return ExcelUtils.v(b, a);
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the font color(s) for <see cref="LegendEntry">legend entries</see>.
   * <p class="body">
   * Use this property to apply the same font color(s) to all legend entries.
   * </p>
   * <p class="body">
   * Use the [[LegendEntry.fontFill]] property to apply font color(s) for a particular legend entry.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get defaultFontFill() {
    return this._ab;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the font color(s) for <see cref="LegendEntry">legend entries</see>.
   * <p class="body">
   * Use this property to apply the same font color(s) to all legend entries.
   * </p>
   * <p class="body">
   * Use the [[LegendEntry.fontFill]] property to apply font color(s) for a particular legend entry.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set defaultFontFill(a) {
    if (a != this._ab) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ab != null) {
        this._ab._l(null);
      }
      let b = this._r(Legend.$, ChartFillBase.$, this, 1, this._ab, a);
      this._ab = b.p2;
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the legend's text area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fill() {
    return this._ac;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the legend's text area.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fill(a) {
    if (a != this._ac) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ac != null) {
        this._ac._l(null);
      }
      let b = this._r(Legend.$, ChartFillBase.$, this, 2, this._ac, a);
      this._ac = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _af() {
    if (this._ac != null) {
      return this._ac;
    }
    let a = this.chart;
    return a != null ? a._eq : new ChartEmptyFill();
  }
  /**
   * Returns or sets a value that represents the height of the legend area,
   * expressed as a fraction of the chart area's height.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total height of the chart area.
   * </p>
   * <p class="body">
   * A value of .1 (for example) represents a height that is equal to one-tenth the height
   * of the chart area.
   * </p>
   * @see [[width]]
   */
  get height() {
    return this._au;
  }
  /**
   * Returns or sets a value that represents the height of the legend area,
   * expressed as a fraction of the chart area's height.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total height of the chart area.
   * </p>
   * <p class="body">
   * A value of .1 (for example) represents a height that is equal to one-tenth the height
   * of the chart area.
   * </p>
   * @see [[width]]
   */
  set height(a) {
    if (a != this._au) {
      let b = this._r(Legend.$, Number_$type, this, 3, this._au, a, (b) => {
        if (b < 0) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._au = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the position of the left edge
   * of the legend area, expressed as a fraction of the chart area's width.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total width of the chart area.
   * </p>
   * @see [[top]]
   */
  get left() {
    return this._av;
  }
  /**
   * Returns or sets a value that represents the position of the left edge
   * of the legend area, expressed as a fraction of the chart area's width.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total width of the chart area.
   * </p>
   * @see [[top]]
   */
  set left(a) {
    if (a != this._av) {
      let b = this._r(Legend.$, Number_$type, this, 4, this._av, a);
      this._av = b.p2;
    }
  }
  legendEntries() {
    if (arguments.length !== 0) {
      let a = this._legendEntries$i;
      return a.item.apply(a, arguments);
    }
    return this._legendEntries$i;
  }
  /**
   * @hidden
   */
  get _legendEntries$i() {
    if (this._ag == null) {
      this._ag = new LegendEntries(this);
    }
    return this._ag;
  }
  /**
   * Returns or sets a boolean value indicating whether the legend
   * can intersect with the chart's plot area.
   */
  get overlay() {
    return this._aq;
  }
  /**
   * Returns or sets a boolean value indicating whether the legend
   * can intersect with the chart's plot area.
   */
  set overlay(a) {
    if (a != this._aq) {
      let b = this._r(Legend.$, Boolean_$type, this, 5, this._aq, a);
      this._aq = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the position of the legend on the chart.
   */
  get position() {
    return this._ai;
  }
  /**
   * Returns or sets a value that represents the position of the legend on the chart.
   */
  set position(a) {
    if (a != this._ai) {
      let b = this._q(Legend.$, LegendPosition_$type, this, 6, this._ai, a);
      this._ai = b.p2;
    }
  }
  /**
   * Determines the rotation of the legend's text area,
   * expressed in degrees.
   */
  get rotation() {
    return this._aw;
  }
  /**
   * Determines the rotation of the legend's text area,
   * expressed in degrees.
   */
  set rotation(a) {
    if (a != this._aw) {
      let b = this._r(Legend.$, Number_$type, this, 7, this._aw, a);
      this._aw = b.p2;
    }
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  get textDirection() {
    return this._ak;
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  set textDirection(a) {
    if (a != this._ak) {
      let b = this._q(Legend.$, TextDirection_$type, this, 8, this._ak, a);
      this._ak = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the position of the top edge
   * of the legend area, expressed as a fraction of the chart area's height.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total height of the chart area.
   * </p>
   * @see [[left]]
   */
  get top() {
    return this._ax;
  }
  /**
   * Returns or sets a value that represents the position of the top edge
   * of the legend area, expressed as a fraction of the chart area's height.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total height of the chart area.
   * </p>
   * @see [[left]]
   */
  set top(a) {
    if (a != this._ax) {
      let b = this._r(Legend.$, Number_$type, this, 9, this._ax, a);
      this._ax = b.p2;
    }
  }
  /**
   * Returns or sets a value that represents the width of the legend area,
   * expressed as a fraction of the chart area's width.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total width of the chart area.
   * </p>
   * @see [[height]]
   */
  get width() {
    return this._ay;
  }
  /**
   * Returns or sets a value that represents the width of the legend area,
   * expressed as a fraction of the chart area's width.
   * <p class="body">
   * Valid values for this property range between zero and one, with a value of one
   * representing the total width of the chart area.
   * </p>
   * @see [[height]]
   */
  set width(a) {
    if (a != this._ay) {
      let b = this._r(Legend.$, Number_$type, this, 10, this._ay, a, (b) => {
        if (b < 0) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._ay = b.p2;
    }
  }
  /**
   * @hidden
   */
  _at() {
    let a = this.chart;
    let b = null;
    let c = true;
    if (a != null && a._seriesCollection$i.count == 1) {
      let d = false;
      b = a._seriesCollection$i.item(0);
      for (let e of fromEnum(b._dataPointCollection$i)) {
        if (e.fill != null || e.border != null) {
          d = true;
          break;
        }
      }
      if (d) {
        c = false;
      }
    }
    let f = new List$1(ILegendEntry_$type, 0);
    if (c) {
      let g = this._legendEntries$i;
      for (let h = 0; h < g.count; h++) {
        let i = g.item(h);
        if (i.isDeleted) {
          continue;
        }
        let j = LegendEntryProxy.f(i);
        f.add(j);
      }
    }
    else {
      for (let k = 0; k < b._dataPointCollection$i.count; k++) {
        let l = b._dataPointCollection$i.item(k);
        let m = LegendEntryProxy.e(l, k);
        f.add(m);
      }
    }
    return f;
  }
  /**
   * @hidden
   */
  _as() {
    if (this._ab != null) {
      return true;
    }
    if (this._ao != null && this._ao._p()) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(Legend.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(11);
    ChangeInfo.f(a, 0, Legend._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 1, Legend._y(ChartFillBase.$, "DefaultFontFill", 7, (b) => b.defaultFontFill, (b, c) => b.defaultFontFill = c));
    ChangeInfo.f(a, 2, Legend._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 3, Legend._y(Number_$type, "Height", 7, (b) => b.height, (b, c) => b.height = c));
    ChangeInfo.f(a, 4, Legend._y(Number_$type, "Left", 7, (b) => b.left, (b, c) => b.left = c));
    ChangeInfo.f(a, 5, Legend._y(Boolean_$type, "Overlay", 7, (b) => b.overlay, (b, c) => b.overlay = c));
    ChangeInfo.f(a, 6, Legend._y(LegendPosition_$type, "Position", 7, (b) => b.position, (b, c) => b.position = c));
    ChangeInfo.f(a, 7, Legend._y(Number_$type, "Rotation", 7, (b) => b.rotation, (b, c) => b.rotation = c));
    ChangeInfo.f(a, 8, Legend._y(TextDirection_$type, "TextDirection", 7, (b) => b.textDirection, (b, c) => b.textDirection = c));
    ChangeInfo.f(a, 9, Legend._y(Number_$type, "Top", 7, (b) => b.top, (b, c) => b.top = c));
    ChangeInfo.f(a, 10, Legend._y(Number_$type, "Width", 7, (b) => b.width, (b, c) => b.width = c));
    return a;
  }
}
Legend.$t = markType(Legend, 'Legend', ChartObject.$);
/**
 * @hidden
 */
Legend._a4 = 0;
/**
 * @hidden
 */
Legend._a5 = 1;
/**
 * @hidden
 */
Legend._a6 = 2;
/**
 * @hidden
 */
Legend._a7 = 3;
/**
 * @hidden
 */
Legend._a8 = 4;
/**
 * @hidden
 */
Legend._ba = 5;
/**
 * @hidden
 */
Legend._bb = 6;
/**
 * @hidden
 */
Legend._bc = 7;
/**
 * @hidden
 */
Legend._bd = 8;
/**
 * @hidden
 */
Legend._be = 9;
/**
 * @hidden
 */
Legend._bf = 10;
/**
 * @hidden
 */
Legend._a9 = 11;
/**
 * @hidden
 */
Legend._w = Legend._x();
/**
 * @hidden
 */
export let ILegendEntry_$type = new Type(null, 'ILegendEntry');
/**
 * @hidden
 */
export class LegendEntryProxy extends Base {
  constructor() {
    super();
    this.a = null;
    this.g = null;
    this.c = null;
    this.d = null;
    this.b = null;
  }
  static f(a) {
    let b = -1;
    let c = ((() => { let d = a._ad(b); b = d.p0; return d.ret; })());
    if (c == null) {
      return null;
    }
    let d = new LegendEntryProxy();
    if (c.name != null) {
      d.a = c.name._a();
    }
    else {
      d.a = [(b + 1).toString()];
    }
    d.g = a._af;
    d.d = a._ab;
    d.b = c.border != null ? c.border._ap : null;
    let e = WorksheetChart._gd(c.chartType, 1);
    d.c = e ? c._aq(b) : c._ao(b);
    return d;
  }
  static e(a, b) {
    let c = a._ap;
    if (c == null) {
      return null;
    }
    let d = c.chart;
    let e = new LegendEntryProxy();
    let f = c.xValues != null ? c.xValues.getValues() : null;
    let g = b < f.length ? f[b] : null;
    let h = g != null ? g.toString() : (b + 1).toString();
    e.a = [h];
    e.g = d.legend.defaultFont;
    e.d = d.legend.defaultFontFill;
    let i = a._ac;
    e.b = i != null ? i._ap : d._eq;
    e.c = a._aj(b);
    return e;
  }
  get borderFill() {
    return this.b;
  }
  get fill() {
    return this.c;
  }
  get fontFill() {
    return this.d;
  }
  get font() {
    return this.g;
  }
  get names() {
    return this.a;
  }
}
LegendEntryProxy.$t = markType(LegendEntryProxy, 'LegendEntryProxy', Base.$, [ILegendEntry_$type]);
/**
 * Represents a legend entry in a chart legend.
 * <p class="body">
 * <b>NOTE: </b> Legend entries are not supported for the following chart types:
 * </p>
 * <p>
 * <ul>
 * <li>Box and Whisker</li>
 * <li>Histogram</li>
 * <li>Pareto</li>
 * <li>Sunburst</li>
 * <li>Treemap</li>
 * <li>Waterfall</li>
 * </ul>
 * </p>
 */
export class LegendEntry extends ChartObject {
  constructor(a) {
    super(a);
    this._ah = null;
    this._z = null;
    this._ai = false;
  }
  /**
   * Returns or sets the <see cref="IWorkbookFont">font</see>
   * for this legend entry. Read-only.
   * <p class="body">
   * This property provides a way to specify font settings
   * for a particular legend entry; to apply font settings
   * to all legend entries, use the [[Legend.defaultFont]]
   * property.
   * </p>
   * @see [[Legend.defaultFont]]
   */
  get font() {
    this._e(this.workbook);
    return this._ah;
  }
  /**
   * @hidden
   */
  _e(a) {
    if (this._ah != null) {
      return this._ah;
    }
    let b = this.workbook != null ? this.workbook : a;
    if (b == null) {
      return null;
    }
    this._ah = this._f(b);
    return this._ah;
  }
  /**
   * @hidden
   */
  get _af() {
    let a = this._ac;
    let b = a != null ? a._an : null;
    let c = [this._ah, b];
    return ExcelUtils.v(c, this.workbook);
  }
  /**
   * @hidden
   */
  get _ag() {
    return ExcelUtils.ad(this._af);
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the font color(s) for this legend entry.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  get fontFill() {
    return this._z;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the font color(s) for this legend entry.
   * <p class="body">
   * This property returns null by default, indicating that no fill is applied.
   * </p>
   * <p class="body">
   * To apply a solid color fill, assign an instance of the
   * [[ChartSolidFill]] class to this property.
   * </p>
   * <p class="body">
   * To apply a gradient fill, assign an instance of the
   * [[ChartGradientFill]] class to this property.
   * </p>
   * @see [[ChartSolidFill]]
   * @see [[ChartGradientFill]]
   */
  set fontFill(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(LegendEntry.$, ChartFillBase.$, this, 0, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ab() {
    let a = this.fontFill;
    if (a != null) {
      return a;
    }
    let b = this._ac;
    if (b != null && b.defaultFontFill != null) {
      return b.defaultFontFill;
    }
    if (a == null) {
      let c = this.chart;
      a = c != null ? c._ez : new ChartSolidFill(new WorkbookColorInfo(1));
    }
    return a;
  }
  /**
   * Returns or sets a boolean value indicating whether this entry
   * has been removed from the [[WorksheetChart.legend]]
   * <p class="body">
   * Deletion does not remove the entry from the [[Legend.legendEntries]]
   * collection, but rather marks it as deleted, so that it does not appear
   * in the legend.
   * </p>
   * @see [[WorksheetChart.legend]]
   * @see [[legend]]
   * @see [[Trendline.legendEntry]]
   */
  get isDeleted() {
    return this._ai;
  }
  /**
   * Returns or sets a boolean value indicating whether this entry
   * has been removed from the [[WorksheetChart.legend]]
   * <p class="body">
   * Deletion does not remove the entry from the [[Legend.legendEntries]]
   * collection, but rather marks it as deleted, so that it does not appear
   * in the legend.
   * </p>
   * @see [[WorksheetChart.legend]]
   * @see [[legend]]
   * @see [[Trendline.legendEntry]]
   */
  set isDeleted(a) {
    if (a != this._ai) {
      let b = this._r(LegendEntry.$, Boolean_$type, this, 1, this._ai, a);
      this._ai = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ac() {
    let a = typeCast(LegendEntries.$, this.owner);
    return a != null ? typeCast(Legend.$, a.owner) : null;
  }
  /**
   * Marks the entry as being deleted.
   */
  del() {
    this.isDeleted = true;
  }
  /**
   * @hidden
   */
  _ad(a) {
    a = -1;
    let b = typeCast(LegendEntries.$, this.owner);
    let c = this.chart;
    if (c == null || b == null) {
      return {
        ret: null,
        p0: a
      };
    }
    let d = c._seriesCollection$i;
    a = b.indexOf(this);
    if (a < 0 || a >= d.count) {
      return {
        ret: null,
        p0: a
      };
    }
    return {
      ret: d.item(a),
      p0: a
    };
  }
  /**
   * @hidden
   */
  _ak() {
    let a = typeCast(WorkbookFontProxy.$, this._ah);
    if (a == null && this._ah != null) {
      return true;
    }
    if (a != null && a._p()) {
      return true;
    }
    if (this._z != null) {
      return true;
    }
    if (this._ai) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _a(a) {
    return LegendEntry._w[a];
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(LegendEntry.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, LegendEntry._y(ChartFillBase.$, "FontFill", 7, (b) => b.fontFill, (b, c) => b.fontFill = c));
    ChangeInfo.f(a, 1, LegendEntry._y(Boolean_$type, "IsDeleted", 7, (b) => b.isDeleted, (b, c) => b.isDeleted = c));
    return a;
  }
}
LegendEntry.$t = markType(LegendEntry, 'LegendEntry', ChartObject.$);
/**
 * @hidden
 */
LegendEntry._al = 0;
/**
 * @hidden
 */
LegendEntry._am = 1;
/**
 * @hidden
 */
LegendEntry._an = 2;
/**
 * @hidden
 */
LegendEntry._w = LegendEntry._x();
/**
 * A collection of [[LegendEntry]]s for a [[WorksheetChart]]
 */
export class LegendEntries extends ChartObject {
  constructor(a) {
    super(a);
    this._aa = new List$1(LegendEntry.$, 0);
  }
  /**
   * Indexer (read-only)
   * @param index A zero based index
   * @return
   */
  item(a) {
    return this._aa._inner[a];
  }
  /**
   * @hidden
   */
  _ad() {
    this._aa.clear();
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    return this._aa.count;
  }
  /**
   * Determines if the collection contains thhe item
   * @param item The item to check
   * @return True if the item is in the collection, otherwise false.
   */
  contains(item) {
    return this._aa.contains(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return this._aa.getEnumerator();
  }
  /**
   * Returns the index of the item in the collection
   * @param item The item to check
   * @return the zero-based index or -1 if the item isn't in the collection.
   */
  indexOf(item) {
    return this._aa.indexOf(item);
  }
  /**
   * @hidden
   */
  _x(a) {
    let b = new LegendEntry(this);
    this._aa.insert(a, b);
    return b;
  }
  /**
   * @hidden
   */
  _ae(a, b) {
    b._l(this);
    this._aa.insert(a, b);
  }
  /**
   * @hidden
   */
  _af(a) {
    this._aa.removeAt(a);
  }
  /**
   * @hidden
   */
  _ag(a) {
    this._aa.clear();
    if (a != null) {
      for (let b = 0; b < a.length; b++) {
        let c = a[b];
        c._l(this);
        this._aa.add(c);
      }
    }
  }
  /**
   * @hidden
   */
  _w() {
    return this._aa.toArray();
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return this._aa.getEnumerator();
  }
}
LegendEntries.$t = markType(LegendEntries, 'LegendEntries', ChartObject.$, [IEnumerable$1_$type.specialize(LegendEntry.$)]);
/**
 * Exposes properties related to category axis binning.
 * Applicable only for Histogram and Pareto charts.
 * <p class="body">
 * This class is immutable.
 * </p>
 * @see [[Series.axisBinning]]
 */
export class CategoryAxisBinning extends Base {
  constructor(..._rest) {
    super();
    this._binWidth$i_1 = Nullable$1.toNullable(Number_$type, null);
    /**
     * @hidden
     */
    this._a = 0;
    this._numberOfBins$i_1 = Nullable$1.toNullable(Number_$type, null);
    this._overflow = false;
    this._overflowThreshold$i_1 = Nullable$1.toNullable(Number_$type, null);
    this._underflow = false;
    this._underflowThreshold$i_1 = Nullable$1.toNullable(Number_$type, null);
    let a;
    if (arguments.length === 0) {
      a = 1;
    }
    else if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 0;
    }
    else if (arguments.length === 3) {
      a = 0;
    }
    else if (arguments.length === 4) {
      a = 0;
    }
    else if (arguments.length === 5) {
      a = 0;
    }
    else if (arguments.length === 6) {
      a = 0;
    }
    else if (arguments.length === 7) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let binWidth = _rest[0];
          let numberOfBins = _rest[1];
          let overflow = _rest[2];
          let overflowThreshold = _rest[3];
          let underflow = _rest[4];
          let underflowThreshold = _rest[5];
          let b = [binWidth, numberOfBins, overflow, overflowThreshold, underflow, underflowThreshold, 1];
          {
            let binWidth = b[0];
            let numberOfBins = b[1];
            let overflow = b[2];
            let overflowThreshold = b[3];
            let underflow = b[4];
            let underflowThreshold = b[5];
            let intervalClosedSide = b[6];
            this._binWidth$i = binWidth;
            this._numberOfBins$i = numberOfBins;
            this.overflow = overflow;
            this._overflowThreshold$i = overflowThreshold;
            this.underflow = underflow;
            this._underflowThreshold$i = underflowThreshold;
            this._a = intervalClosedSide;
          }
          if (binWidth !== void 0) {
            binWidth = wrapNullable(Number_$type, binWidth);
          }
          if (numberOfBins !== void 0) {
            numberOfBins = wrapNullable(Number_$type, numberOfBins);
          }
          overflow = (overflow !== void 0 ? overflow : false);
          if (overflowThreshold !== void 0) {
            overflowThreshold = wrapNullable(Number_$type, overflowThreshold);
          }
          underflow = (underflow !== void 0 ? underflow : false);
          if (underflowThreshold !== void 0) {
            underflowThreshold = wrapNullable(Number_$type, underflowThreshold);
          }
          if (binWidth.hasValue && numberOfBins.hasValue) {
            throw new BaseError(1, ExcelUtils.ef("LE_CategoryAxisBinning_BinWidthAndNumberOfBins"));
          }
        }
        break;
      case 1: break;
      case 2:
        {
          let binWidth = _rest[0];
          let numberOfBins = _rest[1];
          let overflow = _rest[2];
          let overflowThreshold = _rest[3];
          let underflow = _rest[4];
          let underflowThreshold = _rest[5];
          let intervalClosedSide = _rest[6];
          this._binWidth$i = binWidth;
          this._numberOfBins$i = numberOfBins;
          this.overflow = overflow;
          this._overflowThreshold$i = overflowThreshold;
          this.underflow = underflow;
          this._underflowThreshold$i = underflowThreshold;
          this._a = intervalClosedSide;
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Returns the number of data points in each range, i.e., how many
   * data points exist in each bin.
   * <p class="body">
   * Use this property to control the number of data points that should appear
   * in each bin, allowing the total number of bins to be determined automatically.
   * </p>
   * <p class="body">
   * BinWidth and [[numberOfBins]] are mutually exclusive.
   * </p>
   * @see [[numberOfBins]]
   */
  get binWidth() {
    return unwrapNullable(this._binWidth$i);
  }
  /**
   * Returns the number of data points in each range, i.e., how many
   * data points exist in each bin.
   * <p class="body">
   * Use this property to control the number of data points that should appear
   * in each bin, allowing the total number of bins to be determined automatically.
   * </p>
   * <p class="body">
   * BinWidth and [[numberOfBins]] are mutually exclusive.
   * </p>
   * @see [[numberOfBins]]
   */
  set binWidth(a) {
    this._binWidth$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _binWidth$i() {
    return this._binWidth$i_1;
  }
  /**
   * @hidden
   */
  set _binWidth$i(a) {
    this._binWidth$i_1 = a;
  }
  /**
   * Returns the total number of bins.
   * <p class="body">
   * Use this property to control the number of bins that should appear,
   * allowing the number of data points per bin to be determined automatically.
   * </p>
   * <p class="body">
   * NumberOfBins and [[binWidth]] are mutually exclusive.
   * </p>
   * @see [[binWidth]]
   */
  get numberOfBins() {
    return unwrapNullable(this._numberOfBins$i);
  }
  /**
   * Returns the total number of bins.
   * <p class="body">
   * Use this property to control the number of bins that should appear,
   * allowing the number of data points per bin to be determined automatically.
   * </p>
   * <p class="body">
   * NumberOfBins and [[binWidth]] are mutually exclusive.
   * </p>
   * @see [[binWidth]]
   */
  set numberOfBins(a) {
    this._numberOfBins$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _numberOfBins$i() {
    return this._numberOfBins$i_1;
  }
  /**
   * @hidden
   */
  set _numberOfBins$i(a) {
    this._numberOfBins$i_1 = a;
  }
  /**
   * Specifies whether a bin is created for all values above a given threshold.
   * <p class="body">
   * Setting this property to true causes a bin to be created for values
   * above a given threshold.
   * </p>
   * <p class="body">
   * The threshold is determined automatically by default; use the
   * [[overflowThreshold]] property to specify a threshold
   * value.
   * </p>
   * @see [[overflowThreshold]]
   * @see [[underflow]]
   */
  get overflow() {
    return this._overflow;
  }
  /**
   * Specifies whether a bin is created for all values above a given threshold.
   * <p class="body">
   * Setting this property to true causes a bin to be created for values
   * above a given threshold.
   * </p>
   * <p class="body">
   * The threshold is determined automatically by default; use the
   * [[overflowThreshold]] property to specify a threshold
   * value.
   * </p>
   * @see [[overflowThreshold]]
   * @see [[underflow]]
   */
  set overflow(a) {
    this._overflow = a;
  }
  /**
   * Determines the threshold for the [[overflow]] bin.
   * <p class="body">
   * This property is only applicable when the [[overflow]]
   * property is set to true.
   * </p>
   * <p class="body">
   * When this property is left unset, the threshold is determined automatically.
   * </p>
   * @see [[overflow]]
   * @see [[underflowThreshold]]
   */
  get overflowThreshold() {
    return unwrapNullable(this._overflowThreshold$i);
  }
  /**
   * Determines the threshold for the [[overflow]] bin.
   * <p class="body">
   * This property is only applicable when the [[overflow]]
   * property is set to true.
   * </p>
   * <p class="body">
   * When this property is left unset, the threshold is determined automatically.
   * </p>
   * @see [[overflow]]
   * @see [[underflowThreshold]]
   */
  set overflowThreshold(a) {
    this._overflowThreshold$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _overflowThreshold$i() {
    return this._overflowThreshold$i_1;
  }
  /**
   * @hidden
   */
  set _overflowThreshold$i(a) {
    this._overflowThreshold$i_1 = a;
  }
  /**
   * Specifies whether a bin is created for all values below a given threshold.
   * <p class="body">
   * Setting this property to true causes a bin to be created for values
   * below a given threshold.
   * </p>
   * <p class="body">
   * The threshold is determined automatically by default; use the
   * [[underflowThreshold]] property to specify a threshold
   * value.
   * </p>
   * @see [[overflowThreshold]]
   * @see [[overflow]]
   */
  get underflow() {
    return this._underflow;
  }
  /**
   * Specifies whether a bin is created for all values below a given threshold.
   * <p class="body">
   * Setting this property to true causes a bin to be created for values
   * below a given threshold.
   * </p>
   * <p class="body">
   * The threshold is determined automatically by default; use the
   * [[underflowThreshold]] property to specify a threshold
   * value.
   * </p>
   * @see [[overflowThreshold]]
   * @see [[overflow]]
   */
  set underflow(a) {
    this._underflow = a;
  }
  /**
   * Determines the threshold for the [[underflow]] bin.
   * <p class="body">
   * This property is only applicable when the [[underflow]]
   * property is set to true.
   * </p>
   * <p class="body">
   * When this property is left unset, the threshold is determined automatically.
   * </p>
   * @see [[underflow]]
   * @see [[underflowThreshold]]
   */
  get underflowThreshold() {
    return unwrapNullable(this._underflowThreshold$i);
  }
  /**
   * Determines the threshold for the [[underflow]] bin.
   * <p class="body">
   * This property is only applicable when the [[underflow]]
   * property is set to true.
   * </p>
   * <p class="body">
   * When this property is left unset, the threshold is determined automatically.
   * </p>
   * @see [[underflow]]
   * @see [[underflowThreshold]]
   */
  set underflowThreshold(a) {
    this._underflowThreshold$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _underflowThreshold$i() {
    return this._underflowThreshold$i_1;
  }
  /**
   * @hidden
   */
  set _underflowThreshold$i(a) {
    this._underflowThreshold$i_1 = a;
  }
}
CategoryAxisBinning.$t = markType(CategoryAxisBinning, 'CategoryAxisBinning');
/**
 * Exposes properties related to the <i>BoxAndWhisker</i> chart type.
 * <p class="body">
 * This class is immutable.
 * </p>
 * @see [[Series.boxAndWhiskerSettings]]
 */
export class BoxAndWhiskerSettings extends Base {
  constructor(showInnerPoints, showOutlierPoints, showMeanMarkers, showMeanLine, quartileCalculation) {
    super();
    this._showInnerPoints = false;
    this._showOutlierPoints = false;
    this._showMeanMarkers = false;
    this._showMeanLine = false;
    this._quartileCalculation = 0;
    showInnerPoints = (showInnerPoints !== void 0 ? showInnerPoints : false);
    showOutlierPoints = (showOutlierPoints !== void 0 ? showOutlierPoints : true);
    showMeanMarkers = (showMeanMarkers !== void 0 ? showMeanMarkers : true);
    showMeanLine = (showMeanLine !== void 0 ? showMeanLine : false);
    quartileCalculation = (quartileCalculation !== void 0 ? quartileCalculation : 1);
    this.showInnerPoints = showInnerPoints;
    this.showOutlierPoints = showOutlierPoints;
    this.showMeanMarkers = showMeanMarkers;
    this.showMeanLine = showMeanLine;
    this.quartileCalculation = quartileCalculation;
  }
  /**
   * Determines whether inner points appear on a box and whisker chart.
   * <p class="body">
   * Inner points appear between the lower whisker line and the upper whisker line.
   * </p>
   * @see [[showOutlierPoints]]
   */
  get showInnerPoints() {
    return this._showInnerPoints;
  }
  /**
   * Determines whether inner points appear on a box and whisker chart.
   * <p class="body">
   * Inner points appear between the lower whisker line and the upper whisker line.
   * </p>
   * @see [[showOutlierPoints]]
   */
  set showInnerPoints(a) {
    this._showInnerPoints = a;
  }
  /**
   * Determines whether outlier points appear on a box and whisker chart.
   * <p class="body">
   * Outlier points appear either below the lower whisker line or above the upper whisker line.
   * </p>
   * @see [[showInnerPoints]]
   */
  get showOutlierPoints() {
    return this._showOutlierPoints;
  }
  /**
   * Determines whether outlier points appear on a box and whisker chart.
   * <p class="body">
   * Outlier points appear either below the lower whisker line or above the upper whisker line.
   * </p>
   * @see [[showInnerPoints]]
   */
  set showOutlierPoints(a) {
    this._showOutlierPoints = a;
  }
  /**
   * Determines whether mean markers appear on a box and whisker chart.
   * @see [[showMeanLine]]
   */
  get showMeanMarkers() {
    return this._showMeanMarkers;
  }
  /**
   * Determines whether mean markers appear on a box and whisker chart.
   * @see [[showMeanLine]]
   */
  set showMeanMarkers(a) {
    this._showMeanMarkers = a;
  }
  /**
   * Determines whether a mean line appears on a box and whisker chart.
   * <p class="body">
   * Mean lines connect the means of the boxes.
   * </p>
   * @see [[showMeanMarkers]]
   */
  get showMeanLine() {
    return this._showMeanLine;
  }
  /**
   * Determines whether a mean line appears on a box and whisker chart.
   * <p class="body">
   * Mean lines connect the means of the boxes.
   * </p>
   * @see [[showMeanMarkers]]
   */
  set showMeanLine(a) {
    this._showMeanLine = a;
  }
  /**
   * Determines the method for median calculation.
   */
  get quartileCalculation() {
    return this._quartileCalculation;
  }
  /**
   * Determines the method for median calculation.
   */
  set quartileCalculation(a) {
    this._quartileCalculation = a;
  }
}
BoxAndWhiskerSettings.$t = markType(BoxAndWhiskerSettings, 'BoxAndWhiskerSettings');
/**
 * @hidden
 */
BoxAndWhiskerSettings._c = false;
/**
 * @hidden
 */
BoxAndWhiskerSettings._f = true;
/**
 * @hidden
 */
BoxAndWhiskerSettings._e = true;
/**
 * @hidden
 */
BoxAndWhiskerSettings._d = false;
/**
 * @hidden
 */
BoxAndWhiskerSettings._a = 0;
/**
 * Abstract base class that defines a set of values in a [[Series]].
 */
export class SeriesValuesBase extends Base {
  constructor(..._rest) {
    super();
    /**
     * @hidden
     */
    this._a = null;
    /**
     * @hidden
     */
    this._e = null;
    /**
     * @hidden
     */
    this._f = null;
    /**
     * @hidden
     */
    this._k = null;
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 1;
    }
    else if (arguments.length === 3) {
      a = 1;
    }
    else if (arguments.length === 4) {
      a = 2;
    }
    switch (a) {
      case 0:
        {
          let values = _rest[0];
          DocCoreUtils.au(values, "values");
          this._r(values);
        }
        break;
      case 1:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let cellReferenceMode = _rest[2];
          if (cellReferenceMode !== void 0) {
            cellReferenceMode = wrapNullable(CellReferenceMode_$type, cellReferenceMode);
          }
          DocCoreUtils.au(sheet, "sheet");
          DocCoreUtils.au(formula, "sourceRange");
          this._e = sheet;
          this._p(formula, cellReferenceMode);
        }
        break;
      case 2:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let values = _rest[2];
          let dummy = _rest[3];
          DocCoreUtils.au(sheet, "sheet");
          this._e = sheet;
          this._f = formula;
          this._q();
          if (values != null && values.length > 0) {
            this._r(values);
          }
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  get__d() {
    return 0;
  }
  /**
   * @hidden
   */
  get _d() {
    return this.get__d();
  }
  /**
   * Returns an object array containing the value of
   * each data point in the associated [[Series]].
   * @return An array of values where each element in the array represents the value of a data point in the associated Series.
   */
  getValues() {
    if (this._e != null && this._f != null) {
      let a = this._d;
      let b;
      if (a == 1) {
        b = (c) => {
          let d = new Array(c.count);
          for (let e = 0; e < d.length; e++) {
            d[e] = SeriesValuesBase._l(c.item(e));
          }
          return d;
        };
      }
      else {
        b = (c) => {
          let d = new Array(c.count);
          for (let e = 0; e < d.length; e++) {
            d[e] = SeriesValuesBase._i(c.item(e));
          }
          return d;
        };
      }
      let c = SeriesValuesBase._b(Base.$, this._f, this._e, true, b);
      return c;
    }
    if (this._a != null && this._a.length > 0) {
      let d = new Array(this._a.length);
      arrayCopyTo(this._a, d, 0);
      return d;
    }
    return null;
  }
  /**
   * @hidden
   */
  _n() {
  }
  /**
   * @hidden
   */
  static _b($t, a, b, c, d) {
    let e = new TempCellCalcReference(false, b, new WorksheetCellAddress(1, 0, 0));
    let f = a._cf(b.workbook, e, false);
    if (f.isError) {
      return new Array(0);
    }
    let g = CalcFunctionUtilities.p(10);
    ExcelCalcFunction._ac(g, f, false, c, true);
    let h = d(g);
    CalcFunctionUtilities.ad(g);
    return h;
  }
  /**
   * @hidden
   */
  static _i(a) {
    if (a.isReference) {
      let b = a.toReference();
      return SeriesValuesBase._i(b.value);
    }
    else if (a.isNull) {
      return null;
    }
    else if (a.isError) {
      let c = a.toErrorValue();
      if (c.code == 3) {
        return null;
      }
      return 0;
    }
    else if (a.isString) {
      return 0;
    }
    else if (a.isBoolean) {
      return a._toBoolean1() ? 1 : 0;
    }
    else {
      let d;
      if (((() => { let e = a._toDouble1(d); d = e.p0; return e.ret; })())) {
        return d;
      }
      return null;
    }
  }
  /**
   * @hidden
   */
  static _l(a) {
    if (a.isReference) {
      let b = a.toReference();
      let c = typeCast(CellCalcReferenceBase.$, b);
      if (c != null) {
        let d = c._w;
        if (d != null) {
          return d._getCellText1(c._ao, 1);
        }
      }
    }
    if (a.isNull) {
      return "";
    }
    return a.toString();
  }
  /**
   * @hidden
   */
  _g(a, b) {
    if (this._f != null) {
      return this._f._ar(a.workbook, a, b);
    }
    return false;
  }
  /**
   * @hidden
   */
  _o(a, b, c, d, e) {
    if (this._f == null || this._e == null) {
      return;
    }
    let f = d.w < 0;
    let g = null;
    let h = 0;
    if (b == 31) {
      let i = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      let j = Nullable$1.toNullable(WorksheetRegionAddress.$, null);
      if (f && WorksheetRegionAddress._r(d.x, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && this._f._ar(this._e.workbook, d.h, d.x.value)) {
        i = d.x;
      }
      else if (WorksheetRegionAddress._r(d.y, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) && this._f._ar(this._e.workbook, d.h, d.y.value)) {
        j = d.y;
      }
      if (WorksheetRegionAddress._r(i, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) || WorksheetRegionAddress._r(j, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
        let k = this._f._c(this._e.workbook, d.h);
        if (k.length > 0) {
          g = new List$1(Tuple$3.$.specialize(Boolean_$type, Number_$type, Number_$type), 0);
        }
        let l = 0;
        for (let n = 0; n < k.length; n++) {
          let m = k[n];
          let o = m._af == 1;
          let p = o ? m._ac : m._w;
          let q = o ? m._ae : m._x;
          if (f) {
            let r = WorksheetRegionAddress._r(i, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? WorksheetRegionAddress._ag(m, i.value) : Nullable$1.toNullable(WorksheetRegionAddress.$, null);
            if (WorksheetRegionAddress._r(r, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
              g.add(SeriesValuesBase._m(true, l, m, o, r));
            }
          }
          else {
            let s = WorksheetRegionAddress._r(j, Nullable$1.toNullable(WorksheetRegionAddress.$, null)) ? WorksheetRegionAddress._ag(m, j.value) : Nullable$1.toNullable(WorksheetRegionAddress.$, null);
            if (WorksheetRegionAddress._r(s, Nullable$1.toNullable(WorksheetRegionAddress.$, null))) {
              let t = o ? j.value._ac : j.value._w;
              if (t >= p) {
                if (o) {
                  s = Nullable$1.toNullable(WorksheetRegionAddress.$, s.value._f(s.value._ac + d.w - 1));
                }
                else {
                  s = Nullable$1.toNullable(WorksheetRegionAddress.$, s.value._e((s.value._w + d.w - 1)));
                }
                g.add(SeriesValuesBase._m(false, l, m, o, s));
              }
            }
          }
          l += o ? m._ad : m._af;
        }
        h = l;
      }
    }
    let u = this._f._toString2(1, this._e.workbook._e6);
    if (this._f._av(this._e, d, 0)) {
      if (g != null && g.count >= 0) {
        a._dataPointCollection$i._al(h, g, c);
      }
      this._n();
      c(a, Tuple.a(Number_$type, String_$type, b, u));
    }
  }
  /**
   * @hidden
   */
  static _m(a, b, c, d, e) {
    let f = b + (d ? e.value._ac - c._ac : e.value._w - c._w);
    let g = d ? e.value._ad : e.value._af;
    return Tuple.b(Boolean_$type, Number_$type, Number_$type, a, f, g);
  }
  /**
   * @hidden
   */
  _j(a, b) {
    let c = this._f._toString2(1, this._e.workbook._e6);
    this._p(b, Nullable$1.toNullable(CellReferenceMode_$type, 1));
    this._n();
    return Tuple.a(Number_$type, String_$type, a, c);
  }
  /**
   * @hidden
   */
  _p(a, b) {
    if (a != null && a.length > 0 && a.charAt(0) != '=') {
      a = "=" + a;
    }
    this._f = ConditionBase._n(a, this._e.workbook, b);
    this._q();
  }
  /**
   * @hidden
   */
  _q() {
    if (this._f != null) {
      let a = new TempCellCalcReference(true, this._e, new WorksheetCellAddress(1, 0, 0));
      this._f._cx(a, this._e.workbook);
    }
  }
  /**
   * @hidden
   */
  _r(a) {
    let b = new List$1(Base.$, 0);
    for (let c of fromEn(a)) {
      b.add1(c);
    }
    let d = true;
    for (let e = 0; e < b.count; e++) {
      let f = b._inner[e];
      if (typeof f === 'string' || f == null || typeCast(IConvertible_$type, f) !== null) {
        d = false;
        continue;
      }
      d = true;
      break;
    }
    if (d) {
      throw new ArgumentException(1, ExcelUtils.ef("LE_ArgumentException_InvalidSeriesValues"));
    }
    this._a = b.toArray();
  }
}
SeriesValuesBase.$t = markType(SeriesValuesBase, 'SeriesValuesBase');
/**
 * @hidden
 */
SeriesValuesBase._h = true;
/**
 * Defines a set of values in a series
 */
export class SeriesValues extends SeriesValuesBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 2;
    }
    else if (arguments.length === 3) {
      a = 2;
    }
    else if (arguments.length === 4) {
      if (typeCast(SingleTargetFormula.$, arguments[1]) !== null) {
        a = 1;
      }
      else if (typeof arguments[1] === 'string') {
        a = 2;
      }
      else if (arguments[1] == null) {
        if (arguments[2] instanceof Array) {
          a = 1;
        }
        else if (typeof arguments[2] === 'number') {
          a = 2;
        }
        else if (arguments[2] == null) {
          if (typeCast(Boolean_$type, arguments[3]) !== null) {
            a = 1;
          }
          else if (typeof arguments[3] === 'number') {
            a = 2;
          }
        }
      }
    }
    switch (a) {
      case 0:
        {
          let values = _rest[0];
          super(values);
          this._s = null;
          this._v = false;
        }
        break;
      case 1:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let values = _rest[2];
          let dummy = _rest[3];
          super(sheet, formula, values, dummy);
          this._s = null;
          this._v = false;
        }
        break;
      case 2:
        {
          let sheet = _rest[0];
          let sourceRange = _rest[1];
          let cellReferenceMode = _rest[2];
          let colorBy = _rest[3];
          super(sheet, sourceRange, cellReferenceMode);
          this._s = null;
          this._v = false;
          if (cellReferenceMode !== void 0) {
            cellReferenceMode = wrapNullable(CellReferenceMode_$type, cellReferenceMode);
          }
          colorBy = (colorBy !== void 0 ? colorBy : 0);
          this._v = (colorBy == 1);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  static _u(a, b, c) {
    DocCoreUtils.au(a, "sheet");
    if (b == null) {
      if (c == null || c.length == 0) {
        return null;
      }
      return new SeriesValues(c);
    }
    return new SeriesValues(a, b, c, false);
  }
  /**
   * @hidden
   */
  _t(a, b) {
    a = this._f != null ? this._f._toString() : null;
    b = this._s;
    return {
      ret: this._a,
      p0: a,
      p1: b
    };
  }
}
SeriesValues.$t = markType(SeriesValues, 'SeriesValues', SeriesValuesBase.$);
/**
 * Defines the name of a series
 */
export class SeriesName extends Base {
  constructor(..._rest) {
    super();
    /**
     * @hidden
     */
    this._g = null;
    this._c = null;
    /**
     * @hidden
     */
    this._d = null;
    /**
     * @hidden
     */
    this._h = null;
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      if (typeCast(SingleTargetFormula.$, arguments[1]) !== null) {
        a = 2;
      }
      else if (typeof arguments[1] === 'string') {
        a = 1;
      }
      else if (arguments[1] == null) {
        a = 1;
      }
    }
    else if (arguments.length === 3) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let name = _rest[0];
          this._g = name;
        }
        break;
      case 1:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let cellReferenceMode = _rest[2];
          if (cellReferenceMode !== void 0) {
            cellReferenceMode = wrapNullable(CellReferenceMode_$type, cellReferenceMode);
          }
          DocCoreUtils.au(sheet, "sheet");
          DocCoreUtils.au(formula, "formula");
          this._c = sheet;
          this._k(formula, cellReferenceMode);
        }
        break;
      case 2:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          this._c = sheet;
          this._d = formula;
          let b = new TempCellCalcReference(true, this._c, new WorksheetCellAddress(1, 0, 0));
          this._d._cx(b, this._c.workbook);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * Gets the string representation of the [[SeriesName]].
   */
  toString() {
    if (this._d != null && this._c != null) {
      let a = this._a();
      let b = "";
      for (let c = 0; c < a.length; c++) {
        if (!stringIsNullOrEmpty(a[c])) {
          if (b.length > 0) {
            b += " ";
          }
          b += a[c];
        }
      }
      return b;
    }
    if (!stringIsNullOrEmpty(this._g)) {
      return this._g;
    }
    return this._h;
  }
  /**
   * @hidden
   */
  static _b(a, b, c) {
    DocCoreUtils.au(a, "sheet");
    if (b == null) {
      if (stringIsNullOrEmpty(c)) {
        return null;
      }
      return new SeriesName(c);
    }
    let d = new SeriesName(a, b);
    d._h = c;
    return d;
  }
  /**
   * @hidden
   */
  _a() {
    if (this._c != null && this._d != null) {
      let a = SeriesValuesBase._b(String_$type, this._d, this._c, false, (b) => {
        let c = new Array(b.count);
        for (let d = 0; d < c.length; d++) {
          c[d] = SeriesValuesBase._l(b.item(d));
        }
        return c;
      });
      return a;
    }
    else {
      let b = new Array(1);
      b[0] = this.toString();
      return b;
    }
  }
  /**
   * @hidden
   */
  _e(a, b) {
    if (this._d != null) {
      return this._d._ar(a.workbook, a, b);
    }
    return false;
  }
  /**
   * @hidden
   */
  _j(a, b, c, d, e) {
    if (this._d == null || this._c == null) {
      return;
    }
    let f = this._d._toString2(1, this._c.workbook._e6);
    if (this._d._av(this._c, d, 0)) {
      c(a, Tuple.a(Number_$type, String_$type, b, f));
    }
  }
  /**
   * @hidden
   */
  _f(a, b) {
    let c = this._d._toString2(1, this._c.workbook._e6);
    this._k(b, Nullable$1.toNullable(CellReferenceMode_$type, 1));
    return Tuple.a(Number_$type, String_$type, a, c);
  }
  /**
   * @hidden
   */
  _k(a, b) {
    if (a != null && a.length > 0 && a.charAt(0) != '=') {
      a = "=" + a;
    }
    this._d = ConditionBase._n(a, this._c.workbook, b);
    let c = new TempCellCalcReference(true, this._c, new WorksheetCellAddress(1, 0, 0));
    this._d._cx(c, this._c.workbook);
  }
}
SeriesName.$t = markType(SeriesName, 'SeriesName');
/**
 * Defines a set of values in a series
 */
export class XValues extends SeriesValuesBase {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      a = 3;
    }
    else if (arguments.length === 3) {
      if (typeCast(Sheet.$, arguments[0]) !== null) {
        a = 3;
      }
      else if (typeof arguments[0] === 'number') {
        a = 1;
      }
      else if (arguments[0] == null) {
        a = 3;
      }
    }
    else if (arguments.length === 4) {
      a = 4;
    }
    else if (arguments.length === 5) {
      if (typeCast(Boolean_$type, arguments[1]) !== null) {
        a = 4;
      }
      else if (typeCast(SingleTargetFormula.$, arguments[1]) !== null) {
        a = 2;
      }
      else if (arguments[1] == null) {
        a = 2;
      }
    }
    switch (a) {
      case 0:
        {
          let values = _rest[0];
          super(values);
          this._s = null;
          this._y = null;
          this._ad = Nullable$1.toNullable(Boolean_$type, null);
          this._ac = 1;
          this._ab = 0;
        }
        break;
      case 1:
        {
          let dataType = _rest[0];
          let values = _rest[1];
          let levels = _rest[2];
          super(values);
          this._s = null;
          this._y = null;
          this._ad = Nullable$1.toNullable(Boolean_$type, null);
          this._ac = 1;
          this._ab = 0;
          this._ab = dataType;
          this._s = levels;
        }
        break;
      case 2:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let dataType = _rest[2];
          let values = _rest[3];
          let levels = _rest[4];
          super(sheet, formula, values, false);
          this._s = null;
          this._y = null;
          this._ad = Nullable$1.toNullable(Boolean_$type, null);
          this._ac = 1;
          this._ab = 0;
          this._ab = dataType;
          this._s = levels;
        }
        break;
      case 3:
        {
          let sheet = _rest[0];
          let formula = _rest[1];
          let cellReferenceMode = _rest[2];
          super(sheet, formula, cellReferenceMode);
          this._s = null;
          this._y = null;
          this._ad = Nullable$1.toNullable(Boolean_$type, null);
          this._ac = 1;
          this._ab = 0;
          if (cellReferenceMode !== void 0) {
            cellReferenceMode = wrapNullable(CellReferenceMode_$type, cellReferenceMode);
          }
        }
        break;
      case 4:
        {
          let sheet = _rest[0];
          let plotByRows = _rest[1];
          let dataType = _rest[2];
          let formula = _rest[3];
          let cellReferenceMode = _rest[4];
          super(sheet, formula, cellReferenceMode);
          this._s = null;
          this._y = null;
          this._ad = Nullable$1.toNullable(Boolean_$type, null);
          this._ac = 1;
          this._ab = 0;
          this._ab = dataType;
          this._ad = Nullable$1.toNullable(Boolean_$type, plotByRows);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
  /**
   * @hidden
   */
  _n() {
    super._n();
    this._af();
  }
  /**
   * @hidden
   */
  get__d() {
    if (this._ab == 2) {
      return 0;
    }
    return 1;
  }
  /**
   * @hidden
   */
  get _z() {
    return this._y;
  }
  /**
   * Returns the actual values for this [[XValues]] instance.
   * @return An object array containing the actual data point values for the associated [[Series]].
   */
  getValues() {
    if (this._ab != 1) {
      return super.getValues();
    }
    let a = this._u();
    let b = new List$1(Base.$, 0);
    let c = new StringBuilder(0);
    let d = ' ';
    for (let e of fromEnum(a.c)) {
      c.v();
      for (let f = 0; f < e.a.length; f++) {
        if (f > 0) {
          c.h(d);
        }
        c.l(e.a[f]);
      }
      b.add1(c.toString());
    }
    return b.toArray();
  }
  /**
   * @hidden
   */
  _t() {
    return super.getValues();
  }
  /**
   * @hidden
   */
  _ag() {
    if (this._ac > 1) {
      this._ab = 1;
    }
  }
  /**
   * @hidden
   */
  static _aa(a, b, c, d, e) {
    DocCoreUtils.au(a, "sheet");
    let f = 1;
    if (d != null && d.length > 1) {
      let g = new HashSet$1(Number_$type, 0);
      for (let i = 0; i < d.length; i++) {
        let h = d[i];
        if (!g.contains(h)) {
          g.add_1(h);
        }
      }
      f = g.count;
    }
    let j;
    if (b == null) {
      if (c == null || c.length == 0) {
        return null;
      }
      j = new XValues(e, c, d);
    }
    else {
      j = new XValues(a, b, e, c, d);
    }
    j._ac = f;
    j._ab = e;
    return j;
  }
  /**
   * @hidden
   */
  _u() {
    this._ag();
    let a = super.getValues();
    switch (this._ab) {
      case 2: return XValues._v(a);
      case 1: return XValues._x(a, this._ac);
      default: return XValues._w(a);
    }
  }
  /**
   * @hidden
   */
  static _v(a) {
    let b = new List$1(XValue.$, 2, a.length);
    for (let c = 0; c < a.length; c++) {
      let d = a[c];
      let e = 0;
      try {
        e = Convert.toDouble3(d);
      }
      catch (f) {
      }
      b.add(((() => {
        let $ret = new XValue();
        $ret.d = c;
        $ret.b = e;
        $ret.f = null;
        $ret.a = null;
        return $ret;
      })()));
    }
    return new GetXValuesResult(b, 2);
  }
  /**
   * @hidden
   */
  static _w(a) {
    let b = new List$1(XValue.$, 2, a.length);
    for (let c = 0; c < a.length; c++) {
      let d = a[c];
      let e = (d == null) ? null : d.toString();
      b.add(((() => {
        let $ret = new XValue();
        $ret.d = c;
        $ret.b = NaN;
        $ret.f = e;
        $ret.a = null;
        return $ret;
      })()));
    }
    return new GetXValuesResult(b, 0);
  }
  /**
   * @hidden
   */
  static _x(a, b) {
    b = Math.max(b, 1);
    let c = new List$1(List$1.$.specialize(String_$type), 2, intDivide(a.length, b));
    let d = null;
    let e = 0;
    for (let f = 0; f < a.length; f++) {
      if (e == b) {
        e = 0;
      }
      if (e == 0) {
        d = new List$1(String_$type, 0);
        c.add(d);
      }
      let g = a[f] != null ? a[f].toString() : stringEmpty();
      d.add(g);
      e += 1;
    }
    let h = new List$1(XValue.$, 2, a.length);
    for (let i = 0; i < c.count; i++) {
      let j = c._inner[i].toArray();
      h.add(((() => {
        let $ret = new XValue();
        $ret.d = i;
        $ret.b = NaN;
        $ret.f = null;
        $ret.a = j;
        return $ret;
      })()));
    }
    return new GetXValuesResult(h, 1);
  }
  /**
   * @hidden
   */
  _ae(a) {
    this._y = a;
  }
  /**
   * @hidden
   */
  _af() {
    if (this._f != null) {
      let a = 0;
      if (nullableEquals(this._ad, null) && this._y != null) {
        let b = this._y.values;
        if (b != null) {
          let c = b.getValues();
          a = c != null ? c.length : 0;
        }
      }
      if ((nullableNotEquals(this._ad, null) || a > 0) && this._f._e != null && this._f._e.length == 1) {
        let d = typeCast(Area3DToken.$, this._f._e[0]);
        if (d != null) {
          let e = d.x;
          let f = 1 + e.b.t - e.d.t;
          let g = 1 + e.b.r - e.d.r;
          if (nullableEquals(this._ad, null)) {
            this._ad = Nullable$1.toNullable(Boolean_$type, g == a);
          }
          this._ac = this._ad.value ? f : g;
        }
        else {
          this._ac = 1;
        }
      }
    }
    this._ag();
  }
}
XValues.$t = markType(XValues, 'XValues', SeriesValuesBase.$);
/**
 * An object that represents a specific series in a chart
 */
export class Series extends ChartObject {
  constructor(a) {
    super(a);
    this._bb = Series._bc;
    this._af = null;
    this._aa = 1;
    this._dg = Nullable$1.toNullable(BarShape_$type, null);
    this._ah = null;
    this._ad = null;
    this._bj = null;
    this._av = 1;
    this._bd = null;
    this._ax = null;
    this._az = null;
    this._ca = -1;
    this._al = null;
    this._a1 = null;
    this._a3 = null;
    this._at = null;
    this._ai = null;
    this._am = null;
    this._dh = Nullable$1.toNullable(Number_$type, null);
    this._a5 = -4142;
    this._bf = null;
    this._a9 = null;
    this._a7 = 3;
    this._b8 = 1;
    this._cb = 0;
    this._bn = null;
    this._bh = 1;
    this._bk = null;
    this._bp = null;
    let b = a.chart;
    if (b != null) {
      this._av = b.chartType;
      this._bh = ExcelUtils.q(this._av);
    }
    switch (this._av) {
      case 69:
      case 70:
      case 80:
        this._ca = 10;
        break;
    }
    this._dp(64, true);
  }
  /**
   * @hidden
   */
  _a(a) {
    return Series._w[a];
  }
  /**
   * @hidden
   */
  _i(a, b) {
    if (this._bf != null && this._bf._e(a, b)) {
      return true;
    }
    if (this._bk != null && this._bk._g(a, b)) {
      return true;
    }
    if (this._bp != null && this._bp._g(a, b)) {
      return true;
    }
    if (this._bj != null && this._bj._g(a, b)) {
      return true;
    }
    if (this._bn != null && this._bn._i(a, b)) {
      return true;
    }
    if (this._bd != null && this._bd._i(a, b)) {
      return true;
    }
    if (this._ax != null && this._ax._i(a, b)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  _m(a) {
    let b = this.sheet;
    if (this._bf != null && this._bf._d != null) {
      a(b, this._bf._d);
    }
    if (this._bk != null && this._bk._f != null) {
      a(b, this._bk._f);
    }
    if (this._bp != null && this._bp._f != null) {
      a(b, this._bp._f);
    }
    if (this._bj != null && this._bj._f != null) {
      a(b, this._bj._f);
    }
    if (this._bn != null) {
      this._bn._m(a);
    }
    if (this._bd != null) {
      this._bd._m(a);
    }
    if (this._ax != null) {
      this._ax._m(a);
    }
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    let d = this.sheet;
    if (this._bf != null && this._bf._d != null) {
      this._bf._j(this, 21, a, b, c);
    }
    if (this._bk != null && this._bk._f != null) {
      this._bk._o(this, 31, a, b, c);
    }
    if (this._bp != null && this._bp._f != null) {
      this._bp._o(this, 30, a, b, c);
    }
    if (this._bj != null && this._bj._f != null) {
      this._bj._o(this, 8, a, b, c);
    }
    if (this._bn != null) {
      this._bn._o(a, b, c);
    }
    if (this._bd != null) {
      this._bd._o(a, b, c);
    }
    if (this._ax != null) {
      this._ax._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _k(a) {
    let b = typeCast(Tuple$2.$.specialize(Number_$type, String_$type), a);
    if (b != null) {
      switch (b.c) {
        case 8:
          if (this._bj != null) {
            return this._bj._j(b.c, b.d);
          }
          break;
        case 21:
          if (this._bf != null) {
            return this._bf._f(b.c, b.d);
          }
          break;
        case 31:
          if (this._bk != null) {
            return this._bk._j(b.c, b.d);
          }
          break;
        case 30:
          if (this._bp != null) {
            return this._bp._j(b.c, b.d);
          }
          break;
      }
    }
    return null;
  }
  /**
   * @hidden
   */
  _t(a) {
    if (this._bf != null && this._bf._d != null && this._bf._d._t == a) {
      this._bf = null;
    }
    if (this._bp != null && this._bp._f != null && this._bp._f._t == a) {
      this._bp = null;
    }
    if (this._bj != null && this._bj._f != null && this._bj._f._t == a) {
      this._bj = null;
    }
    if (this._bn != null) {
      this._bn._t(a);
    }
    if (this._bd != null) {
      this._bd._t(a);
    }
    if (this._ax != null) {
      this._ax._t(a);
    }
  }
  /**
   * Apply the picture to the end of the series.
   */
  get applyPicToEnd() {
    return this._bu(1);
  }
  /**
   * Apply the picture to the end of the series.
   */
  set applyPicToEnd(a) {
    this._dq(0, 1, a);
  }
  /**
   * Apply the picture to the front of the series.
   */
  get applyPicToFront() {
    return this._bu(2);
  }
  /**
   * Apply the picture to the front of the series.
   */
  set applyPicToFront(a) {
    this._dq(1, 2, a);
  }
  /**
   * Apply the picture to the sides.
   */
  get applyPicToSides() {
    return this._bu(4);
  }
  /**
   * Apply the picture to the sides.
   */
  set applyPicToSides(a) {
    this._dq(2, 4, a);
  }
  /**
   * Returns or sets a [[CategoryAxisBinning]] instance which determines
   * the binning properties for the category axis on a histogram or pareto chart.
   * <p class="body">
   * This property is only applicable for histogram and pareto charts.
   * </p>
   */
  get axisBinning() {
    return this._af;
  }
  /**
   * Returns or sets a [[CategoryAxisBinning]] instance which determines
   * the binning properties for the category axis on a histogram or pareto chart.
   * <p class="body">
   * This property is only applicable for histogram and pareto charts.
   * </p>
   */
  set axisBinning(a) {
    if (this._af != a) {
      let b = this._r(Series.$, CategoryAxisBinning.$, this, 3, this._af, a);
      this._af = b.p2;
    }
  }
  /**
   * Specifies which axis group this series applies to.
   * <p class="body">
   * This property is only applicable for combo charts.
   * </p>
   * <p class="body">
   * This property defaults to <i>Primary</i>, causing all series to
   * be plotted on the primary axis unless otherwise specified.
   * </p>
   * <p class="body">
   * To plot this series on the secondary value axis, set this property to <i>Secondary</i>.
   * </p>
   * <p class="body">
   * Setting this property to <i>Secondary</i> triggers creation of secondary
   * category and value axes.
   * </p>
   * <p class="body">
   * Not all series can be plotted on the same axis; the following table lists
   * each ChartType along with the other ChartTypes which can be plotted on the
   * same axis:
   * </p>
   * <p class="body">
   * <table border="1">
   * <tr><th>ChartType</th><th>Valid on same axis</th></tr>
   * <tr><td>ColumnClustered</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>ColumnStacked</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>ColumnStacked100</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>BarClustered</td><td>BarClustered only</td></tr>
   * <tr><td>BarStacked</td><td>BarStacked only</td></tr>
   * <tr><td>BarStacked100</td><td>BarStacked100 only</td></tr>
   * <tr><td>Line</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkers, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkersStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkersStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>Area</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>AreaStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>AreaStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>Pie</td><td>PieExploded, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>PieExploded</td><td>Pie, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>BarOfPie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>PieOfPie</td><td>Pie, PieExploded, BarOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>Doughnut</td><td>Pie, PieExploded, BarOfPie, PieOfPie, DoughnutExploded</td></tr>
   * <tr><td>DoughnutExploded</td><td>Pie, PieExploded, BarOfPie, PieOfPie, Doughnut</td></tr>
   * <tr><td>XYScatter</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterLines</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterLinesNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterSmooth</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterSmoothNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth</td></tr>
   * <tr><td>Radar</td><td>RadarFilled, RadarMarkers</td></tr>
   * <tr><td>RadarFilled</td><td>Radar, RadarMarkers</td></tr>
   * <tr><td>RadarMarkers</td><td>Radar, RadarFilled</td></tr>
   * </table>
   * </p>
   * <p class="body">
   * Attempting to set the series axis to the same value as an incompatible series
   * causes an exception to be thrown.
   * </p>
   * @see [[chartType]]
   * @see [[Axis]]
   * @see [[WorksheetChart.axisCollection]]
   * @throws [[NotSupportedException]] The target axis already contains a chart type which cannot share axes with this series
   * because of the value of the [[chartType]] property of this series.
   */
  get axisGroup() {
    return this._aa;
  }
  /**
   * Specifies which axis group this series applies to.
   * <p class="body">
   * This property is only applicable for combo charts.
   * </p>
   * <p class="body">
   * This property defaults to <i>Primary</i>, causing all series to
   * be plotted on the primary axis unless otherwise specified.
   * </p>
   * <p class="body">
   * To plot this series on the secondary value axis, set this property to <i>Secondary</i>.
   * </p>
   * <p class="body">
   * Setting this property to <i>Secondary</i> triggers creation of secondary
   * category and value axes.
   * </p>
   * <p class="body">
   * Not all series can be plotted on the same axis; the following table lists
   * each ChartType along with the other ChartTypes which can be plotted on the
   * same axis:
   * </p>
   * <p class="body">
   * <table border="1">
   * <tr><th>ChartType</th><th>Valid on same axis</th></tr>
   * <tr><td>ColumnClustered</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>ColumnStacked</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>ColumnStacked100</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>BarClustered</td><td>BarClustered only</td></tr>
   * <tr><td>BarStacked</td><td>BarStacked only</td></tr>
   * <tr><td>BarStacked100</td><td>BarStacked100 only</td></tr>
   * <tr><td>Line</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkers, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkersStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>LineMarkersStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>Area</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>AreaStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>AreaStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>Pie</td><td>PieExploded, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>PieExploded</td><td>Pie, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>BarOfPie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>PieOfPie</td><td>Pie, PieExploded, BarOfPie, Doughnut, DoughnutExploded</td></tr>
   * <tr><td>Doughnut</td><td>Pie, PieExploded, BarOfPie, PieOfPie, DoughnutExploded</td></tr>
   * <tr><td>DoughnutExploded</td><td>Pie, PieExploded, BarOfPie, PieOfPie, Doughnut</td></tr>
   * <tr><td>XYScatter</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterLines</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterLinesNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterSmooth</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmoothNoMarkers</td></tr>
   * <tr><td>XYScatterSmoothNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth</td></tr>
   * <tr><td>Radar</td><td>RadarFilled, RadarMarkers</td></tr>
   * <tr><td>RadarFilled</td><td>Radar, RadarMarkers</td></tr>
   * <tr><td>RadarMarkers</td><td>Radar, RadarFilled</td></tr>
   * </table>
   * </p>
   * <p class="body">
   * Attempting to set the series axis to the same value as an incompatible series
   * causes an exception to be thrown.
   * </p>
   * @see [[chartType]]
   * @see [[Axis]]
   * @see [[WorksheetChart.axisCollection]]
   * @throws [[NotSupportedException]] The target axis already contains a chart type which cannot share axes with this series
   * because of the value of the [[chartType]] property of this series.
   */
  set axisGroup(a) {
    if (this._aa != a) {
      ExcelUtils.gl(AxisGroup_$type, a);
      let b = this.chart;
      if (b != null && this._h == false) {
        let c = ComboChartGroupValidator.a(this, b._seriesCollection$i, a);
        if (c.a == false) {
          throw c.b;
        }
      }
      let d = b != null && a == 2 ? this._j(7) : null;
      let e = this._q(Series.$, AxisGroup_$type, this, 4, this._aa, a);
      this._aa = e.p2;
      if (this._aa == 2) {
        if (b != null) {
          b._jb();
        }
      }
      this._p(d);
    }
  }
  /**
   * Determines the shape of the bar for this series.
   * Applicable only for 3D bar charts.
   * <p class="body">
   * This property controls the shape of the bar displayed for this series only.
   * </p>
   * <p class="body">
   * To set the bar shape for all series in the chart, use the [[WorksheetChart.barShape]] property.
   * </p>
   * @see [[WorksheetChart.barShape]]
   */
  get barShape() {
    return unwrapNullable(this._barShape$i);
  }
  /**
   * Determines the shape of the bar for this series.
   * Applicable only for 3D bar charts.
   * <p class="body">
   * This property controls the shape of the bar displayed for this series only.
   * </p>
   * <p class="body">
   * To set the bar shape for all series in the chart, use the [[WorksheetChart.barShape]] property.
   * </p>
   * @see [[WorksheetChart.barShape]]
   */
  set barShape(a) {
    arguments[0] = wrapNullable(BarShape_$type, arguments[0]);
    this._barShape$i = arguments[0];
  }
  /**
   * @hidden
   */
  get _barShape$i() {
    return this._dg;
  }
  /**
   * @hidden
   */
  set _barShape$i(a) {
    if (nullableNotEquals(this._dg, a)) {
      let b = this._r(Series.$, Nullable$1.$.specialize(BarShape_$type), this, 5, this._dg, a);
      this._dg = b.p2;
    }
  }
  /**
   * Returns the resolved value of the [[barShape]] property.
   * @see [[barShape]]
   * @see [[WorksheetChart.barShape]]
   */
  get barShapeResolved() {
    return this._dg.hasValue ? this._dg.value : this.chart != null ? this.chart._ej : 0;
  }
  /**
   * Determines the appearance of the border drawn around the
   * [[fill]] area. Applicable only for chart series
   * which support fills, such as bar charts, area charts, and
   * pie charts.
   * <p class="body">
   * For series which support <see cref="Fill">fills</see>, this property controls the
   * color and size of the line drawn around the fill region.
   * </p>
   * <p class="body">
   * For line-based series, use the [[line]] property.
   * </p>
   * @see [[fill]]
   * @see [[line]]
   */
  get border() {
    return this._ah;
  }
  /**
   * Determines the appearance of the border drawn around the
   * [[fill]] area. Applicable only for chart series
   * which support fills, such as bar charts, area charts, and
   * pie charts.
   * <p class="body">
   * For series which support <see cref="Fill">fills</see>, this property controls the
   * color and size of the line drawn around the fill region.
   * </p>
   * <p class="body">
   * For line-based series, use the [[line]] property.
   * </p>
   * @see [[fill]]
   * @see [[line]]
   */
  set border(a) {
    if (a != this._ah) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ah != null) {
        this._ah._l(null);
      }
      let b = this._r(Series.$, ChartBorder.$, this, 6, this._ah, a);
      this._ah = b.p2;
    }
  }
  /**
   * Returns or sets a [[boxAndWhiskerSettings]] instance which determines
   * the properties for a box and whisker chart.
   * <p class="body">
   * This property is only applicable for box and whisker charts.
   * </p>
   */
  get boxAndWhiskerSettings() {
    return this._ad;
  }
  /**
   * Returns or sets a [[boxAndWhiskerSettings]] instance which determines
   * the properties for a box and whisker chart.
   * <p class="body">
   * This property is only applicable for box and whisker charts.
   * </p>
   */
  set boxAndWhiskerSettings(a) {
    if (this._ad != a) {
      let b = this._r(Series.$, BoxAndWhiskerSettings.$, this, 7, this._ad, a);
      this._ad = b.p2;
    }
  }
  /**
   * Returns or sets a [[values]] instance that determines the bubble sizes in a bubble chart.
   */
  get bubbleSizes() {
    return this._bj;
  }
  /**
   * Returns or sets a [[values]] instance that determines the bubble sizes in a bubble chart.
   */
  set bubbleSizes(a) {
    let b = this._r(Series.$, SeriesValues.$, this, 8, this._bj, a);
    this._bj = b.p2;
  }
  /**
   * Specifies the type of chart for this series. Applicable only
   * for combo charts.
   * <p class="body">
   * This property is only applicable for combo charts. Setting this
   * property for any other type of chart causes an exception to be thrown.
   * </p>
   * <p class="body">
   * Not all ChartType values are supported for series which are plotted within
   * a combo chart. For a list of the supported values, see documentation for
   * the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
   * method.
   * </p>
   * <p class="body">
   * If the value assigned to this property necessitates plotting this series
   * on a different axis than the one referenced by the [[axisGroup]]
   * property, and the other axis can accommodate this series, the AxisGroup
   * property is changed accordingly.
   * </p>
   * <p class="body">
   * If the other axis cannot accommodate this series, and other series which are
   * of the same series type exist on the same axis, an attempt is made to change
   * the ChartType of those other series. For example, if a different series exists
   * with a ChartType of <i>BarClustered</i>, and a value of <i>BarStacked</i> is
   * assigned to this series, the ChartType of   the other series is changed to
   * <i>BarStacked</i> in order to accommodate the setting of the property on this
   * series.
   * </p>
   * <p class="body">
   * If no adjustment can be made that would allow the ChartType to be changed to the
   * specified value, an exception is thrown.
   * </p>
   * <p class="body">
   * Note that in all cases, the value of the [[type]] property is
   * automatically changed to a value which is appropriate for the assigned ChartType.
   * </p>
   * @see [[type]]
   * @see [[axisGroup]]
   * @throws [[NotSupportedException]] The [[axisGroup]] on which this series currently resides cannot share an axis
   * with a series of this <i>ChartType</i>, and no adjustment could be made to avoid this.
   */
  get chartType() {
    return this._av;
  }
  /**
   * Specifies the type of chart for this series. Applicable only
   * for combo charts.
   * <p class="body">
   * This property is only applicable for combo charts. Setting this
   * property for any other type of chart causes an exception to be thrown.
   * </p>
   * <p class="body">
   * Not all ChartType values are supported for series which are plotted within
   * a combo chart. For a list of the supported values, see documentation for
   * the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
   * method.
   * </p>
   * <p class="body">
   * If the value assigned to this property necessitates plotting this series
   * on a different axis than the one referenced by the [[axisGroup]]
   * property, and the other axis can accommodate this series, the AxisGroup
   * property is changed accordingly.
   * </p>
   * <p class="body">
   * If the other axis cannot accommodate this series, and other series which are
   * of the same series type exist on the same axis, an attempt is made to change
   * the ChartType of those other series. For example, if a different series exists
   * with a ChartType of <i>BarClustered</i>, and a value of <i>BarStacked</i> is
   * assigned to this series, the ChartType of   the other series is changed to
   * <i>BarStacked</i> in order to accommodate the setting of the property on this
   * series.
   * </p>
   * <p class="body">
   * If no adjustment can be made that would allow the ChartType to be changed to the
   * specified value, an exception is thrown.
   * </p>
   * <p class="body">
   * Note that in all cases, the value of the [[type]] property is
   * automatically changed to a value which is appropriate for the assigned ChartType.
   * </p>
   * @see [[type]]
   * @see [[axisGroup]]
   * @throws [[NotSupportedException]] The [[axisGroup]] on which this series currently resides cannot share an axis
   * with a series of this <i>ChartType</i>, and no adjustment could be made to avoid this.
   */
  set chartType(a) {
    this._dr(a, true);
  }
  /**
   * @hidden
   */
  _dr(a, b) {
    if (this._av != a) {
      let c = this.chart;
      let d = null;
      if (b && c != null && c._gc == false) {
        if (this._b6(a, c.chartType) == false) {
          let e = (c.chartType == 113);
          if (a != c.chartType && e == false) {
            throw new BaseError(1, ExcelUtils.eg("LE_Series_ChartType_NonCombo", enumGetBox(ChartType_$type, c.chartType), enumGetBox(ChartType_$type, a)));
          }
          if (e && WorksheetChart._go(a) == false) {
            throw new BaseError(1, ExcelUtils.eg("LE_Series_ChartType_InvalidForComboChart", enumGetBox(ChartType_$type, a)));
          }
          if (e) {
            d = ComboChartGroupValidator.c(this, c._seriesCollection$i, a, this.axisGroup);
            if (d.c != null) {
              throw d.c;
            }
          }
        }
      }
      let f = this._q(Series.$, ChartType_$type, this, 9, this._av, a);
      this._av = f.p2;
      this.type = ExcelUtils.q(a);
      if (d != null) {
        if (d.b != null) {
          for (let g of fromEnum(d.b)) {
            g._dr(a, false);
          }
        }
        else if (d.d.hasValue) {
          this.axisGroup = d.d.value;
        }
      }
    }
  }
  /**
   * @hidden
   */
  _b6(a, b) {
    let c = true;
    let d = false;
    switch (b) {
      case 117:
        d = true;
        c = (a == 51);
        break;
      case 116:
        d = true;
        c = (a == 51 || a == 116);
        break;
      case 114:
        d = true;
        c = (a == 114);
        break;
      case 118:
        d = true;
        c = (a == 118);
        break;
      case 119:
        d = true;
        c = (a == 119);
        break;
      case 120:
        d = true;
        c = (a == 120);
        break;
      case 115:
        d = true;
        c = (a == 115);
        break;
      case 121:
        d = true;
        c = (a == 121);
        break;
    }
    if (c == false) {
      throw new BaseError(1, ExcelUtils.eg("LE_Series_ChartType_ChartEx", enumGetBox(ChartType_$type, a), enumGetBox(ChartType_$type, b)));
    }
    return d;
  }
  /**
   * Returns a [[SeriesDataLabels]] instance which applies to all [[DataLabel]]
   * instances which do not have a specific setting for a given property.
   * <p class="body">
   * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
   * </p>
   */
  get dataLabels() {
    if (this._bd == null) {
      this._bd = new SeriesDataLabels(this);
      this._dm(this._bd);
    }
    return this._bd;
  }
  /**
   * @hidden
   */
  _dm(a) {
    if (nullableEquals(a._showBubbleSize$i, null)) {
      a._showBubbleSize$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showCategoryName$i, null)) {
      a._showCategoryName$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showLegendKey$i, null)) {
      a._showLegendKey$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showPercentage$i, null)) {
      a._showPercentage$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showRange$i, null)) {
      a._showRange$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showSeriesName$i, null)) {
      a._showSeriesName$i = Nullable$1.toNullable(Boolean_$type, false);
    }
    if (nullableEquals(a._showValue$i, null)) {
      a._showValue$i = Nullable$1.toNullable(Boolean_$type, true);
    }
  }
  dataPointCollection() {
    if (arguments.length !== 0) {
      let a = this._dataPointCollection$i;
      return a.item.apply(a, arguments);
    }
    return this._dataPointCollection$i;
  }
  /**
   * @hidden
   */
  get _dataPointCollection$i() {
    if (this._ax == null) {
      this._ax = new DataPointCollection(this);
    }
    return this._ax;
  }
  /**
   * Returns or sets an [[ErrorBars]] object.
   */
  get errorBars() {
    return this._az;
  }
  /**
   * Returns or sets an [[ErrorBars]] object.
   */
  set errorBars(a) {
    let b = this._az;
    if (a != b) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Series.$, ErrorBars.$, this, 10, this._az, a);
      this._az = c.p2;
    }
  }
  /**
   * Returns or sets a value which determines the amount by which individual slices
   * are offset from the center of the pie or doughnut, expressed as a percentage
   * of the radius.
   * <p class="body">
   * The valid range of values is between 0 and 400, inclusive.
   * </p>
   * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
   */
  get explosion() {
    return this._ca < 0 ? 0 : this._ca;
  }
  /**
   * Returns or sets a value which determines the amount by which individual slices
   * are offset from the center of the pie or doughnut, expressed as a percentage
   * of the radius.
   * <p class="body">
   * The valid range of values is between 0 and 400, inclusive.
   * </p>
   * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
   */
  set explosion(a) {
    if (this._ca != a) {
      let b = this._r(Series.$, Number_$type, this, 11, this._ca, a, (b) => {
        if (b < -1 || b > 400) {
          throw new ArgumentOutOfRangeException(2, "value", ExcelUtils.ef("LE_Series_Explosion_OutOfRange"));
        }
      });
      this._ca = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _dj() {
    if (this._ca >= 0) {
      return Nullable$1.toNullable(Number_$type, this._ca);
    }
    switch (this.chartType) {
      case 69:
      case 70:
      case 80: return Nullable$1.toNullable(Number_$type, 10);
      default: return Nullable$1.toNullable(Number_$type, null);
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill for this series. Not applicable for
   * line charts.
   * <p class="body">
   * This property is not applicable to charts which depict the data
   * series as a line. For these chart types, use the [[line]]
   * property, which controls the color and width of the line.
   * </p>
   * @see [[border]]
   */
  get fill() {
    return this._al;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill for this series. Not applicable for
   * line charts.
   * <p class="body">
   * This property is not applicable to charts which depict the data
   * series as a line. For these chart types, use the [[line]]
   * property, which controls the color and width of the line.
   * </p>
   * @see [[border]]
   */
  set fill(a) {
    if (a != this._al) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._al != null) {
        this._al._l(null);
      }
      let b = this._r(Series.$, ChartFillBase.$, this, 12, this._al, a);
      this._al = b.p2;
    }
  }
  /**
   * Returns or sets a [[geographicMapSettings]] instance
   * which defines the appearance and behavior for a geographic map chart.
   * <p class="body">
   * This property is only applicable when the <see cref="WorksheetChart.ChartType">ChartType</see>
   * property is set to <i>RegionMap</i>.
   * </p>
   */
  get geographicMapSettings() {
    return this._a1;
  }
  /**
   * Returns or sets a [[geographicMapSettings]] instance
   * which defines the appearance and behavior for a geographic map chart.
   * <p class="body">
   * This property is only applicable when the <see cref="WorksheetChart.ChartType">ChartType</see>
   * property is set to <i>RegionMap</i>.
   * </p>
   */
  set geographicMapSettings(a) {
    if (a != this._a1) {
      let b = this._r(Series.$, GeographicMapSettings.$, this, 13, this._a1, a);
      this._a1 = b.p2;
    }
  }
  /**
   * Determines if negative values will be inverted.
   */
  get invertIfNegative() {
    return this._bu(8);
  }
  /**
   * Determines if negative values will be inverted.
   */
  set invertIfNegative(a) {
    this._dq(14, 8, a);
  }
  /**
   * Returns or sets the  instance.
   * <p class="body">
   * A leader line connects a [[DataLabel]] to it's associated series.
   * </p>
   * @see [[leaderLines]]
   * @see [[DataLabel]]
   * @see [[dataPointCollection]]
   */
  get leaderLines() {
    return this._a3;
  }
  /**
   * Returns or sets the  instance.
   * <p class="body">
   * A leader line connects a [[DataLabel]] to it's associated series.
   * </p>
   * @see [[leaderLines]]
   * @see [[DataLabel]]
   * @see [[dataPointCollection]]
   */
  set leaderLines(a) {
    let b = this._a3;
    if (a != b) {
      if (a != null) {
        if (a.owner != null && a.owner != this) {
          throw new ArgumentException(0);
        }
        a._l(this);
      }
      if (b != null) {
        b._l(null);
      }
      let c = this._r(Series.$, LeaderLines.$, this, 15, this._a3, a);
      this._a3 = c.p2;
    }
  }
  /**
   * Determines the <see cref="ChartLineBase.Fill">fill</see> and
   * <see cref="ChartLineBase.WidthInPoints">width</see> of a series line.
   * <p class="body">
   * This property is not applicable for series which support <see cref="Fill">fills</see>,
   * such as bar, area, or pie charts.
   * </p>
   * <p class="body">
   * For chart series which supports fills, use the [[fill]] property
   * to control the fill color, and the [[border]] property for the
   * line drawn around that fill area.
   * </p>
   * @see [[fill]]
   * @see [[border]]
   * @see [[markerFill]]
   * @see [[markerBorder]]
   */
  get line() {
    return this._at;
  }
  /**
   * Determines the <see cref="ChartLineBase.Fill">fill</see> and
   * <see cref="ChartLineBase.WidthInPoints">width</see> of a series line.
   * <p class="body">
   * This property is not applicable for series which support <see cref="Fill">fills</see>,
   * such as bar, area, or pie charts.
   * </p>
   * <p class="body">
   * For chart series which supports fills, use the [[fill]] property
   * to control the fill color, and the [[border]] property for the
   * line drawn around that fill area.
   * </p>
   * @see [[fill]]
   * @see [[border]]
   * @see [[markerFill]]
   * @see [[markerBorder]]
   */
  set line(a) {
    if (a != this._at) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._at != null) {
        this._at._l(null);
      }
      let b = this._r(Series.$, ChartLine.$, this, 16, this._at, a);
      this._at = b.p2;
    }
  }
  /**
   * Determines the appearance of the <see cref="ChartBorder">border</see>
   * (a.k.a. outline) for the marker.
   */
  get markerBorder() {
    return this._ai;
  }
  /**
   * Determines the appearance of the <see cref="ChartBorder">border</see>
   * (a.k.a. outline) for the marker.
   */
  set markerBorder(a) {
    if (a != this._ai) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ai != null) {
        this._ai._l(null);
      }
      let b = this._r(Series.$, ChartBorder.$, this, 17, this._ai, a);
      this._ai = b.p2;
    }
  }
  /**
   * Defines the <see cref="ChartFillBase">fill</see> appearance for the marker.
   */
  get markerFill() {
    return this._am;
  }
  /**
   * Defines the <see cref="ChartFillBase">fill</see> appearance for the marker.
   */
  set markerFill(a) {
    if (a != this._am) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._am != null) {
        this._am._l(null);
      }
      let b = this._r(Series.$, ChartFillBase.$, this, 18, this._am, a);
      this._am = b.p2;
    }
  }
  /**
   * Determines the size of the markers.
   */
  get markerSize() {
    return this._dh.hasValue ? this._dh.value : 5;
  }
  /**
   * Determines the size of the markers.
   */
  set markerSize(a) {
    if (nullableEquals(this._dh, null) || a != this._dh.value) {
      let b = this.markerSize;
      let c = this._r(Series.$, Number_$type, this, 19, b, a);
      b = c.p2;
      this._dh = Nullable$1.toNullable(Number_$type, b);
    }
  }
  /**
   * @hidden
   */
  get _dk() {
    return this._dh;
  }
  /**
   * Determines the style of the markers
   */
  get markerStyle() {
    return this._a5;
  }
  /**
   * Determines the style of the markers
   */
  set markerStyle(a) {
    if (a != this._a5) {
      let b = this._q(Series.$, MarkerStyle_$type, this, 20, this._a5, a);
      this._a5 = b.p2;
    }
  }
  /**
   * The name of the series
   */
  get name() {
    return this._bf;
  }
  /**
   * The name of the series
   */
  set name(a) {
    if (a != this._bf) {
      let b = this._r(Series.$, SeriesName.$, this, 21, this._bf, a);
      this._bf = b.p2;
    }
  }
  /**
   * Returns or sets a reference to the owning [[Series]].
   * Applicable only for a line series in a <i>Pareto</i> chart.
   * <p class="body">
   * This property is only applicable for Series contained within a
   * <i>Pareto</i> chart.
   * </p>
   * <p class="body">
   * If the [[chartType]] property of this series, as well as that of
   * the associated <see cref="WorksheetChart">chart</see>, are not both set to
   * 'Pareto', an exception is thrown.
   * </p>
   * <p class="body">
   * If the value assigned to this property has a [[chartType]] of any value
   * other than 'ClusteredColumn', an exception is thrown.
   * </p>
   */
  get owningSeries() {
    return this._a9;
  }
  /**
   * Returns or sets a reference to the owning [[Series]].
   * Applicable only for a line series in a <i>Pareto</i> chart.
   * <p class="body">
   * This property is only applicable for Series contained within a
   * <i>Pareto</i> chart.
   * </p>
   * <p class="body">
   * If the [[chartType]] property of this series, as well as that of
   * the associated <see cref="WorksheetChart">chart</see>, are not both set to
   * 'Pareto', an exception is thrown.
   * </p>
   * <p class="body">
   * If the value assigned to this property has a [[chartType]] of any value
   * other than 'ClusteredColumn', an exception is thrown.
   * </p>
   */
  set owningSeries(a) {
    if (a != this._a9) {
      let b = null;
      if (a == this) {
        b = ExcelUtils.ef("LE_Series_OwningSeries_Same");
      }
      else {
        let c = this.chart;
        if (c != null && c._gc == false) {
          if (c.chartType != 116 || this.chartType != 116) {
            b = ExcelUtils.ef("LE_Series_OwningSeries_NotParetoLine");
          }
          else if (a.chartType != 51) {
            b = ExcelUtils.ef("LE_Series_OwningSeries_NotClusteredColumn");
          }
        }
      }
      if (stringIsNullOrEmpty(b) == false) {
        throw new BaseError(1, b);
      }
      let d = this._r(Series.$, Series.$, this, 22, this._a9, a);
      this._a9 = d.p2;
    }
  }
  /**
   * Determines whether pictures are scaled, stacked, or stretched.
   */
  get pictureType() {
    return this._a7;
  }
  /**
   * Determines whether pictures are scaled, stacked, or stretched.
   */
  set pictureType(a) {
    if (a != this._a7) {
      let b = this._q(Series.$, PictureType_$type, this, 23, this._a7, a);
      this._a7 = b.p2;
    }
  }
  /**
   * Returns or sets a value which defines the unit of measure
   * when [[pictureType]] is set to <i>Stack</i>.
   */
  get pictureUnit() {
    return this._b8;
  }
  /**
   * Returns or sets a value which defines the unit of measure
   * when [[pictureType]] is set to <i>Stack</i>.
   */
  set pictureUnit(a) {
    if (a != this._b8) {
      let b = this._r(Series.$, Number_$type, this, 24, this._b8, a);
      this._b8 = b.p2;
    }
  }
  /**
   * The plotting order for the data series.
   * <para class="note">
   * <b>Note:</b> this is the order in which the series names will appear in the legend. When there is only one series then this is omitted. This must be a whole number between 1 and the number of series on the chart. If you enter zero then 1 is used. If you enter a number greater than the number of series then the total number of series is used.
   * </para>
   */
  get plotOrder() {
    return this._cb;
  }
  /**
   * The plotting order for the data series.
   * <para class="note">
   * <b>Note:</b> this is the order in which the series names will appear in the legend. When there is only one series then this is omitted. This must be a whole number between 1 and the number of series on the chart. If you enter zero then 1 is used. If you enter a number greater than the number of series then the total number of series is used.
   * </para>
   */
  set plotOrder(a) {
    if (a != this._cb) {
      let b = this._r(Series.$, Number_$type, this, 25, this._cb, a, (b) => {
        if (b < 0) {
          throw new ArgumentOutOfRangeException(0);
        }
      });
      this._cb = b.p2;
    }
  }
  /**
   * Returns or sets a boolean value indicating whether to display
   * [[dataLabels]].
   */
  get showDataLabels() {
    return this._bu(32);
  }
  /**
   * Returns or sets a boolean value indicating whether to display
   * [[dataLabels]].
   */
  set showDataLabels(a) {
    this._dq(26, 32, a);
  }
  /**
   * Returns or sets a boolean value indicating whether to display
   * connecting lines between the data points in a waterfall chart.
   * <p class="body">
   * This property is only applicable for waterfall charts.
   * </p>
   * <p class="body">
   * Use the [[border]] property to control the visual
   * appearance of the connector lines.
   * </p>
   */
  get showWaterfallConnectorLines() {
    return this._bu(64);
  }
  /**
   * Returns or sets a boolean value indicating whether to display
   * connecting lines between the data points in a waterfall chart.
   * <p class="body">
   * This property is only applicable for waterfall charts.
   * </p>
   * <p class="body">
   * Use the [[border]] property to control the visual
   * appearance of the connector lines.
   * </p>
   */
  set showWaterfallConnectorLines(a) {
    this._dq(27, 64, a);
  }
  /**
   * Determines whether a smoothing effect should be applied.
   */
  get smooth() {
    return this._bu(16);
  }
  /**
   * Determines whether a smoothing effect should be applied.
   */
  set smooth(a) {
    this._dq(28, 16, a);
  }
  /**
   * @hidden
   */
  get _b5() {
    switch (this.chartType) {
      case 72:
      case 73: return true;
    }
    return this.smooth;
  }
  trendlineCollection() {
    if (arguments.length !== 0) {
      let a = this._trendlineCollection$i;
      return a.item.apply(a, arguments);
    }
    return this._trendlineCollection$i;
  }
  /**
   * @hidden
   */
  get _trendlineCollection$i() {
    if (this._bn == null) {
      this._bn = new TrendlineCollection(this);
    }
    return this._bn;
  }
  /**
   * @hidden
   */
  get _bw() {
    return this._bn != null && this._bn.count > 0;
  }
  /**
   * Returns or sets a [[SeriesType]] value which determines
   * the type of this series. Applicable only for combo charts.
   * <p class="body">
   * This property is only applicable for combo charts. Setting this
   * property for any other type of chart causes an exception to be thrown.
   * </p>
   * <p class="body">
   * Combo charts do not support <i>Bubble</i> or <i>Surface</i>; setting this property
   * to either of those values causes an exception to be thrown.
   * </p>
   * <p class="body">
   * The [[chartType]] property must be set to a value that is compatible
   * with assigned series type. If the current value of the ChartType property is
   * not compatible with the value assigned to this property, a reasonable default
   * value, which is compatible, is assigned to the ChartType property.
   * </p>
   * @see [[chartType]]
   */
  get type() {
    return this._bh;
  }
  /**
   * Returns or sets a [[SeriesType]] value which determines
   * the type of this series. Applicable only for combo charts.
   * <p class="body">
   * This property is only applicable for combo charts. Setting this
   * property for any other type of chart causes an exception to be thrown.
   * </p>
   * <p class="body">
   * Combo charts do not support <i>Bubble</i> or <i>Surface</i>; setting this property
   * to either of those values causes an exception to be thrown.
   * </p>
   * <p class="body">
   * The [[chartType]] property must be set to a value that is compatible
   * with assigned series type. If the current value of the ChartType property is
   * not compatible with the value assigned to this property, a reasonable default
   * value, which is compatible, is assigned to the ChartType property.
   * </p>
   * @see [[chartType]]
   */
  set type(a) {
    if (a != this._bh) {
      let b = Nullable$1.toNullable(ChartType_$type, null);
      let c = this.chart;
      if (c != null && c._gc == false) {
        let d = c.chartType == 113;
        if (d) {
          if (Series._bz(a) == false) {
            throw new BaseError(1, ExcelUtils.eg("LE_Series_InvalidSeriesTypeForComboChart", enumGetBox(SeriesType_$type, a)));
          }
          else {
            let e;
            if (((() => { let f = Series._by(a, this.chartType, e); e = f.p2; return f.ret; })()) == false) {
              b = Nullable$1.toNullable(ChartType_$type, e);
            }
          }
        }
        else {
          if (this._b7(a, c.chartType) == false) {
            let f = ExcelUtils.q(c.chartType);
            if (a != f) {
              throw new BaseError(1, ExcelUtils.eg("LE_Series_SeriesType_NonCombo", enumGetBox(ChartType_$type, c.chartType)));
            }
          }
        }
      }
      let g = this._q(Series.$, SeriesType_$type, this, 29, this._bh, a);
      this._bh = g.p2;
      if (b.hasValue) {
        this._dr(b.value, false);
      }
    }
  }
  /**
   * @hidden
   */
  _b7(a, b) {
    let c = true;
    let d = false;
    switch (b) {
      case 114:
      case 120:
      case 119:
      case 117:
      case 115:
      case 121:
        d = true;
        c = (a == 1);
        break;
      case 116:
        d = true;
        c = (a == 1 || a == 2);
        break;
      case 118:
        d = true;
        c = (a == 3);
        break;
    }
    if (c == false) {
      throw new BaseError(1, ExcelUtils.eg("LE_Series_SeriesType_ChartEx", enumGetBox(SeriesType_$type, a), enumGetBox(ChartType_$type, b)));
    }
    return d;
  }
  /**
   * Returns or sets a [[xValues]] instance that contains a collection of all the x values in the series.
   * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
   * </para>
   */
  get xValues() {
    let a = this.owningSeries;
    if (this._bp == null && a != null) {
      return a.xValues;
    }
    return this._bp;
  }
  /**
   * Returns or sets a [[xValues]] instance that contains a collection of all the x values in the series.
   * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
   * </para>
   */
  set xValues(a) {
    if (this._bp != a) {
      if (a != null) {
        a._ae(this);
      }
      let b = this._r(Series.$, XValues.$, this, 30, this._bp, a);
      this._bp = b.p2;
      if (this._bp != null) {
        this._bp._af();
      }
    }
  }
  /**
   * @hidden
   */
  get _b1() {
    return this._bp != null;
  }
  /**
   * Returns or sets a [[values]] instance that contains a collection of all the values in the series.
   * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
   * </para>
   */
  get values() {
    let a = this.owningSeries;
    if (this._bk == null && a != null) {
      return a.values;
    }
    return this._bk;
  }
  /**
   * Returns or sets a [[values]] instance that contains a collection of all the values in the series.
   * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
   * </para>
   */
  set values(a) {
    if (this._bk != a) {
      let b = this._r(Series.$, SeriesValues.$, this, 31, this._bk, a);
      this._bk = b.p2;
      if (this._bk != null && this._bp != null) {
        this._bp._af();
      }
      this._ds();
    }
  }
  /**
   * @hidden
   */
  get _b0() {
    return this._bk != null;
  }
  /**
   * @hidden
   */
  get _z() {
    let a = this.chart;
    return a == null ? null : a._axisCollection$i.item(2, this.axisGroup);
  }
  /**
   * @hidden
   */
  _dl(a, b) {
    a = b = null;
    let c = this.xValues != null ? this.xValues.getValues() : null;
    let d = this.values != null ? this.values.getValues() : null;
    let e = d != null ? d.length : 0;
    if (e == 0) {
      b = new Array(0);
      a = new Array(0);
      return {
        p0: a,
        p1: b
      };
    }
    else if (c != null && c.length == e) {
      a = d;
      b = c;
      return {
        p0: a,
        p1: b
      };
    }
    else if (c == null) {
      b = new Array(e);
      a = d;
      return {
        p0: a,
        p1: b
      };
    }
    a = d;
    if (c.length != e) {
      let f = new Array(e);
      for (let g = 0; g < e; g++) {
        let h = g < c.length ? c[g] : null;
        f[g] = h;
      }
      b = f;
    }
    return {
      p0: a,
      p1: b
    };
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(Series.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(32);
    ChangeInfo.f(a, 0, Series._y(Boolean_$type, "ApplyPicToEnd", 7, (b) => b.applyPicToEnd, (b, c) => b.applyPicToEnd = c));
    ChangeInfo.f(a, 1, Series._y(Boolean_$type, "ApplyPicToFront", 7, (b) => b.applyPicToFront, (b, c) => b.applyPicToFront = c));
    ChangeInfo.f(a, 2, Series._y(Boolean_$type, "ApplyPicToSides", 7, (b) => b.applyPicToSides, (b, c) => b.applyPicToSides = c));
    ChangeInfo.f(a, 3, Series._y(CategoryAxisBinning.$, "AxisBinning", 7, (b) => b.axisBinning, (b, c) => b.axisBinning = c));
    ChangeInfo.f(a, 4, Series._y(AxisGroup_$type, "AxisGroup", 7, (b) => b.axisGroup, (b, c) => b.axisGroup = c));
    ChangeInfo.f(a, 5, Series._y(Nullable$1.$.specialize(BarShape_$type), "BarShape", 7, (b) => b._barShape$i, (b, c) => b._barShape$i = c));
    ChangeInfo.f(a, 6, Series._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 7, Series._y(BoxAndWhiskerSettings.$, "BoxAndWhiskerSettings", 7, (b) => b.boxAndWhiskerSettings, (b, c) => b.boxAndWhiskerSettings = c));
    ChangeInfo.f(a, 8, Series._y(SeriesValues.$, "BubbleSizes", 7, (b) => b.bubbleSizes, (b, c) => b.bubbleSizes = c));
    ChangeInfo.f(a, 9, Series._y(ChartType_$type, "ChartType", 7, (b) => b.chartType, (b, c) => ((() => { let d = b._q(Series.$, ChartType_$type, b, 9, b._av, c); b._av = d.p2; })())));
    ChangeInfo.f(a, 10, Series._y(ErrorBars.$, "ErrorBars", 7, (b) => b.errorBars, (b, c) => b.errorBars = c));
    ChangeInfo.f(a, 11, Series._y(Number_$type, "Explosion", 7, (b) => b.explosion, (b, c) => b.explosion = c));
    ChangeInfo.f(a, 12, Series._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 13, Series._y(GeographicMapSettings.$, "GeographicMapSettings", 7, (b) => b.geographicMapSettings, (b, c) => b.geographicMapSettings = c));
    ChangeInfo.f(a, 14, Series._y(Boolean_$type, "InvertIfNegative", 7, (b) => b.invertIfNegative, (b, c) => b.invertIfNegative = c));
    ChangeInfo.f(a, 15, Series._y(LeaderLines.$, "LeaderLines", 7, (b) => b.leaderLines, (b, c) => b.leaderLines = c));
    ChangeInfo.f(a, 16, Series._y(ChartLine.$, "Line", 7, (b) => b.line, (b, c) => b.line = c));
    ChangeInfo.f(a, 17, Series._y(ChartBorder.$, "MarkerBorder", 7, (b) => b.markerBorder, (b, c) => b.markerBorder = c));
    ChangeInfo.f(a, 18, Series._y(ChartFillBase.$, "MarkerFill", 7, (b) => b.markerFill, (b, c) => b.markerFill = c));
    ChangeInfo.f(a, 19, Series._y(Number_$type, "MarkerSize", 7, (b) => b.markerSize, (b, c) => b.markerSize = c));
    ChangeInfo.f(a, 20, Series._y(MarkerStyle_$type, "MarkerStyle", 7, (b) => b.markerStyle, (b, c) => b.markerStyle = c));
    ChangeInfo.f(a, 21, Series._y(SeriesName.$, "Name", 7, (b) => b.name, (b, c) => b.name = c));
    ChangeInfo.f(a, 22, Series._y(Series.$, "OwningSeries", 7, (b) => b.owningSeries, (b, c) => b.owningSeries = c));
    ChangeInfo.f(a, 23, Series._y(PictureType_$type, "PictureType", 7, (b) => b.pictureType, (b, c) => b.pictureType = c));
    ChangeInfo.f(a, 24, Series._y(Number_$type, "PictureUnit", 7, (b) => b.pictureUnit, (b, c) => b.pictureUnit = c));
    ChangeInfo.f(a, 25, Series._y(Number_$type, "PlotOrder", 7, (b) => b.plotOrder, (b, c) => b.plotOrder = c));
    ChangeInfo.f(a, 26, Series._y(Boolean_$type, "ShowDataLabels", 7, (b) => b.showDataLabels, (b, c) => b.showDataLabels = c));
    ChangeInfo.f(a, 27, Series._y(Boolean_$type, "ShowDataLabels", 7, (b) => b.showWaterfallConnectorLines, (b, c) => b.showWaterfallConnectorLines = c));
    ChangeInfo.f(a, 28, Series._y(Boolean_$type, "Smooth", 7, (b) => b.smooth, (b, c) => b.smooth = c));
    ChangeInfo.f(a, 29, Series._y(SeriesType_$type, "Type", 7, (b) => b.type, (b, c) => b.type = c));
    ChangeInfo.f(a, 30, Series._y(XValues.$, "XValues", 7, (b) => b.xValues, (b, c) => b.xValues = c));
    ChangeInfo.f(a, 31, Series._y(SeriesValues.$, "Values", 7, (b) => b.values, (b, c) => b.values = c));
    return a;
  }
  /**
   * @hidden
   */
  _bu(a) {
    return (this._bb & a) == a;
  }
  /**
   * @hidden
   */
  _dp(a, b) {
    if (b) {
      this._bb |= a;
    }
    else {
      this._bb &= ~a;
    }
  }
  /**
   * @hidden
   */
  _dq(a, b, c) {
    this._u();
    let d = this._bu(b);
    if (d == c) {
      return;
    }
    let e = Series._w[a].g(Series.$, Boolean_$type, this, d, c, this._h);
    d = e.p1;
    this._dp(b, c);
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  _ao(a) {
    return Series._ap(this, this.fill, a);
  }
  /**
   * @hidden
   */
  static _ap(a, b, c) {
    return b != null ? b : ExcelUtils.p(a, c);
  }
  /**
   * @hidden
   */
  _aq(a) {
    let b = this._at != null ? this._at.fill : null;
    return Series._ap(this, b, a);
  }
  /**
   * @hidden
   */
  _ar(a) {
    if (this._am != null) {
      return this._am;
    }
    let b = WorksheetChart._gd(this.chartType, 1);
    let c = this._at != null ? this._at.fill : null;
    let d = b ? c : this._al;
    if (d != null) {
      return d;
    }
    return Series._ap(this, null, a);
  }
  /**
   * @hidden
   */
  _bv(a) {
    let b = this.values;
    let c = b != null ? b.getValues() : null;
    if (c == null || c.length == 0) {
      return false;
    }
    for (let e = 0; e < c.length; e++) {
      let d = c[e];
      let f;
      if (((() => { let g = ExcelUtils.b0(a, d, f); f = g.p2; return g.ret; })())) {
        if (f < 0) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  static _bz(a) {
    switch (a) {
      case 7:
      case 5: return false;
      default: return true;
    }
  }
  /**
   * @hidden
   */
  static _by(a, b, c) {
    c = 0;
    if (Series._bz(a) == false) {
      return {
        ret: false,
        p2: c
      };
    }
    let d = WorksheetChart._g0(Nullable$1.toNullable(SeriesType_$type, a));
    if (d.contains(b)) {
      c = b;
      return {
        ret: true,
        p2: c
      };
    }
    else {
      for (let e of fromEnum(d)) {
        c = e;
        break;
      }
    }
    return {
      ret: false,
      p2: c
    };
  }
  /**
   * @hidden
   */
  _dn() {
    if (this._ax != null) {
      this._ax._am();
    }
  }
  /**
   * @hidden
   */
  _ds() {
    this._dataPointCollection$i._an();
  }
}
Series.$t = markType(Series, 'Series', ChartObject.$);
/**
 * @hidden
 */
Series._cc = 0;
/**
 * @hidden
 */
Series._cd = 1;
/**
 * @hidden
 */
Series._ce = 2;
/**
 * @hidden
 */
Series._cf = 3;
/**
 * @hidden
 */
Series._cg = 4;
/**
 * @hidden
 */
Series._ch = 5;
/**
 * @hidden
 */
Series._ci = 6;
/**
 * @hidden
 */
Series._cj = 7;
/**
 * @hidden
 */
Series._ck = 8;
/**
 * @hidden
 */
Series._cl = 9;
/**
 * @hidden
 */
Series._cp = 10;
/**
 * @hidden
 */
Series._cr = 11;
/**
 * @hidden
 */
Series._cs = 12;
/**
 * @hidden
 */
Series._ct = 13;
/**
 * @hidden
 */
Series._cu = 14;
/**
 * @hidden
 */
Series._cv = 15;
/**
 * @hidden
 */
Series._cw = 16;
/**
 * @hidden
 */
Series._cx = 17;
/**
 * @hidden
 */
Series._cy = 18;
/**
 * @hidden
 */
Series._c0 = 19;
/**
 * @hidden
 */
Series._c1 = 20;
/**
 * @hidden
 */
Series._c3 = 21;
/**
 * @hidden
 */
Series._c5 = 22;
/**
 * @hidden
 */
Series._c6 = 23;
/**
 * @hidden
 */
Series._c7 = 24;
/**
 * @hidden
 */
Series._c9 = 25;
/**
 * @hidden
 */
Series._da = 26;
/**
 * @hidden
 */
Series._db = 27;
/**
 * @hidden
 */
Series._dc = 28;
/**
 * @hidden
 */
Series._dd = 29;
/**
 * @hidden
 */
Series._df = 30;
/**
 * @hidden
 */
Series._de = 31;
/**
 * @hidden
 */
Series._c4 = 32;
/**
 * @hidden
 */
Series._cm = 5;
/**
 * @hidden
 */
Series._co = 10;
/**
 * @hidden
 */
Series._cn = 1;
/**
 * @hidden
 */
Series._c2 = 400;
/**
 * @hidden
 */
Series._w = Series._x();
/**
 * @hidden
 */
Series._bc = 0;
/**
 * @hidden
 */
export class GetXValuesResult extends Base {
  constructor(a, b) {
    super();
    this.a = 0;
    this.c = null;
    this.a = b;
    this.c = a;
  }
  b(a, b) {
    let c = new List$1(Number_$type, 2, this.c.count);
    a = 1.7976931348623157E+308;
    b = -1.7976931348623157E+308;
    for (let d = 0; d < this.c.count; d++) {
      let e = this.c._inner[d];
      let f = e.c;
      a = Math.min(a, f);
      b = Math.max(b, f);
      c.add(f);
    }
    return {
      ret: c,
      p0: a,
      p1: b
    };
  }
}
GetXValuesResult.$t = markType(GetXValuesResult, 'GetXValuesResult');
/**
 * @hidden
 */
export class XValue extends Base {
  constructor() {
    super(...arguments);
    this.d = 0;
    this.b = 0;
    this.f = null;
    this.a = null;
  }
  get c() {
    return isNaN_(this.b) == false ? this.b : this.d;
  }
  toString() {
    if (isNaN_(this.b) == false) {
      return stringFormat("Number: {0}", this.b);
    }
    else if (stringIsNullOrEmpty(this.f) == false) {
      return stringFormat("String: {0}", this.f);
    }
    else {
      let a = this.e();
      return stringFormat("StringArray: {0}", a);
    }
  }
  e(a = ", ") {
    if (this.a == null) {
      return stringEmpty();
    }
    let b = new StringBuilder(0);
    for (let c = 0; c < this.a.length; c++) {
      if (c > 0) {
        b.l(a);
      }
      b.l(this.a[c]);
    }
    return b.toString();
  }
}
XValue.$t = markType(XValue, 'XValue');
/**
 * @hidden
 */
export class SeriesCollection_CollectionChangeContext extends ValueType {
  constructor(a, ..._rest) {
    super();
    this.d = 0;
    this.c = null;
    this.b = null;
    this.a = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this.c = c;
          this.b = d;
          this.a = e;
          this.d = f;
        }
        break;
    }
  }
  get workbook() {
    return this.c.workbook;
  }
  get sheet() {
    return this.c.sheet;
  }
  get source() {
    return this.c.chart;
  }
}
SeriesCollection_CollectionChangeContext.$t = markStruct(SeriesCollection_CollectionChangeContext, 'SeriesCollection_CollectionChangeContext', ValueType.$, [IChangeInfoContext_$type]);
/**
 * A collection of [[Series]] for a [[WorksheetChart]]
 */
export class SeriesCollection extends ChartObject {
  constructor(a) {
    super(a);
    this._aj = new List$1(Series.$, 0);
    this._ai = null;
  }
  static staticInit() {
    SeriesCollection._w = SeriesCollection._x();
  }
  /**
   * @hidden
   */
  _m(a) {
    for (let b = 0; b < this._aj.count; b++) {
      this._aj._inner[b]._m(a);
    }
  }
  /**
   * @hidden
   */
  _i(a, b) {
    for (let c = 0; c < this._aj.count; c++) {
      let d = this._aj._inner[c];
      if (d._i(a, b)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _o(a, b, c) {
    for (let d = 0; d < this._aj.count; d++) {
      this._aj._inner[d]._o(a, b, c);
    }
  }
  /**
   * @hidden
   */
  _t(a) {
    for (let b = 0; b < this._aj.count; b++) {
      let c = this._aj._inner[b];
      c._t(a);
      let d = c.values != null ? c.values._f : null;
      if (d != null && d._t == a) {
        this._aj.removeAt(b);
        b--;
      }
    }
  }
  /**
   * Indexer
   * @param index A zero based index
   * @return
   */
  item(a) {
    return this._aj._inner[a];
  }
  /**
   * Returns the number of items in the collection (read-only)
   */
  get count() {
    return this._aj.count;
  }
  /**
   * Determines if the collecion can be modified (read-only)
   */
  get isReadOnly() {
    let a = this.workbook;
    if (a != null) {
      return !a._cn;
    }
    return false;
  }
  /**
   * Adds a new series to the collection
   * @return The newly added [[Series]]
   */
  add() {
    return this.insert(this._aj.count);
  }
  /**
   * Clears the collection.
   */
  clear() {
    this._u();
    let a = this._aj.count > 1 ? this._j(7) : null;
    for (let b = this._aj.count - 1; b >= 0; b--) {
      this.removeAt(b);
    }
    this._p(a);
  }
  /**
   * Determines if the collection contains thhe item
   * @param item The item to check
   * @return True if the item is in the collection, otherwise false.
   */
  contains(item) {
    return this._aj.contains(item);
  }
  [Symbol.iterator]() {
    return new EnumeratorWrapper(this.getEnumerator());
  }
  getEnumerator() {
    return this._getEnumerator.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumerator() {
    return this._aj.getEnumerator();
  }
  /**
   * Returns the index of the item in the collection
   * @param item The item to check
   * @return the zero-based index or -1 if the item isn't in the collection.
   */
  indexOf(item) {
    return this._aj.indexOf(item);
  }
  /**
   * Inserts a new [[Series]] into the collection at the specified index.
   * @param index The index to insert the new series
   * @return The newly inserted [[Series]]
   */
  insert(index) {
    this._u();
    let a = new Series(this);
    this._at(index, a);
    return a;
  }
  /**
   * @hidden
   */
  _at(a, b, c = true, d = null) {
    this._aj.insert(a, b);
    let e = this.chart.legend;
    if (d == null) {
      if (e != null) {
        d = e._legendEntries$i._x(a);
      }
    }
    else {
      if (e != null) {
        e._legendEntries$i._ae(a, d);
      }
    }
    let f = this.workbook;
    if (f == null || f._c4 || this._h) {
      return;
    }
    let g = SeriesCollection._w[0];
    let h = new SeriesCollection_CollectionChangeContext(1, this, b, d, a);
    let i = this.sheet;
    let j = g.b(f, i, g.c);
    g.e(SeriesCollection_CollectionChangeContext.$, Series.$, h, null, b);
    if (j != null) {
      g.d(f, j);
    }
    this.onPropertyChanged();
  }
  /**
   * Removes an item from the collection.
   * @param item The series to remove
   * @return True if the series was removed, otherwise false.
   */
  remove(item) {
    let a = this.indexOf(item);
    if (a >= 0) {
      this.removeAt(a);
      return true;
    }
    return false;
  }
  /**
   * Removes the series at the specified index
   * @param index The zero-based index
   */
  removeAt(index) {
    this._u();
    let a = this._aj._inner[index];
    let b = null;
    let c = this.chart.legend;
    if (c != null) {
      b = c._legendEntries$i.item(index);
    }
    let d = this.workbook;
    let e = this.sheet;
    let f = SeriesCollection._w[1];
    let g = new SeriesCollection_CollectionChangeContext(1, this, a, b, index);
    let h = d == null || d._c4 || this._h ? null : f.b(d, e, f.c);
    this._aj.removeAt(index);
    if (c != null) {
      c._legendEntries$i._af(index);
    }
    if (d != null && !d._c4 && !this._h) {
      f.e(SeriesCollection_CollectionChangeContext.$, Series.$, g, null, a);
      if (h != null) {
        f.d(d, h);
      }
    }
    this.onPropertyChanged();
  }
  /**
   * @hidden
   */
  _a0() {
    let a = this.chart.legend;
    if (a == null) {
      return;
    }
    let b = a._legendEntries$i;
    let c = this.count;
    for (let d = 0; d < c; d++) {
      if (d >= b.count) {
        b._x(d);
      }
    }
    while (b.count > c) {
      b._af(b.count - 1);
    }
  }
  /**
   * @hidden
   */
  _a1(a) {
    if (a == this.count) {
      return;
    }
    for (let b = this.count - 1; b >= a; b -= 1) {
      this.removeAt(b);
    }
  }
  getEnumeratorObject() {
    return this._getEnumeratorObject$e.apply(this, arguments);
  }
  /**
   * @hidden
   */
  _getEnumeratorObject$e() {
    return this._aj.getEnumerator();
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = true, h = 4) {
    return new ChangeInfo$2(SeriesCollection_CollectionChangeContext.$, $tValue, a, b, c, d, e, f, h, g, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, SeriesCollection._y(Series.$, "Add", 7, (b) => b.b, (b, c) => SeriesCollection._a2(b, c)));
    ChangeInfo.f(a, 1, SeriesCollection._y(Series.$, "Remove", 7, (b) => b.b, (b, c) => SeriesCollection._a3(b, c)));
    return a;
  }
  /**
   * @hidden
   */
  static _a2(a, b) {
    let c = a.c.indexOf(a.b);
    if (c >= 0) {
      a.c.removeAt(c);
    }
  }
  /**
   * @hidden
   */
  static _a3(a, b) {
    let c = a.b;
    a.c._at(a.d, c, true, a.a);
  }
  /**
   * @hidden
   */
  _az(a, b = false) {
    for (let c of fromEnum(this)) {
      let d = c.explosion > 0;
      if (b == false && a == d) {
        continue;
      }
      c.explosion = a ? 10 : 0;
    }
  }
  /**
   * @hidden
   */
  _ay(a) {
    for (let b of fromEnum(this)) {
      b.markerStyle = a;
    }
  }
  /**
   * @hidden
   */
  _aw(a, b) {
    for (let c of fromEnum(this)) {
      if (c.chartType == a) {
        c.chartType = b;
      }
    }
  }
  /**
   * @hidden
   */
  _ax(a) {
    for (let b of fromEnum(this)) {
      b.line = ((() => {
        let $ret = new ChartLine();
        $ret.fill = a;
        return $ret;
      })());
    }
  }
  /**
   * @hidden
   */
  _av() {
    let a = new List$1(SeriesCollection_PlotOrderSortItem.$, 0);
    for (let b = 0; b < this.count; b++) {
      let c = this.item(b);
      a.add(((() => {
        let $ret = new SeriesCollection_PlotOrderSortItem();
        $ret.a = c;
        $ret.b = b;
        $ret.c = c.plotOrder;
        return $ret;
      })()));
    }
    a.z(new SeriesCollection_PlotOrderSortComparer());
    this._ai = new Dictionary$2(Series.$, Number_$type, 0);
    for (let d = 0; d < a.count; d++) {
      let e = a._inner[d];
      this._ai.addItem(e.a, intSToU(d));
    }
  }
  /**
   * @hidden
   */
  _aq(a) {
    if (this._ai == null) {
      this._av();
    }
    let b = 0;
    if (((() => { let c = this._ai.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return Nullable$1.toNullable(Number_$type, b);
    }
    else {
      return Nullable$1.toNullable(Number_$type, null);
    }
  }
  /**
   * @hidden
   */
  _ad(a) {
    for (let b of fromEnum(this)) {
      if (b.type == a) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  get _ae() {
    for (let a of fromEnum(this)) {
      if (a.axisGroup == 1) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  get _ah() {
    for (let a of fromEnum(this)) {
      if (a.axisGroup == 2) {
        return true;
      }
    }
    return false;
  }
  /**
   * @hidden
   */
  _ak(a, b, c = null) {
    let d = new List$1(Series.$, 0);
    for (let e of fromEnum(this)) {
      if (e == c) {
        continue;
      }
      if (a.hasValue && a.value != e.type) {
        continue;
      }
      if (b.hasValue && b.value != e.axisGroup) {
        continue;
      }
      d.add(e);
    }
    return d;
  }
  /**
   * @hidden
   */
  _as(a, b) {
    a = false;
    b = false;
    for (let c of fromEnum(this)) {
      if (WorksheetChart._f3(c.chartType) == false) {
        continue;
      }
      if (c.axisGroup == 1) {
        a = true;
      }
      if (c.axisGroup == 2) {
        b = true;
      }
    }
    return {
      p0: a,
      p1: b
    };
  }
}
SeriesCollection.$t = markType(SeriesCollection, 'SeriesCollection', ChartObject.$, [IEnumerable$1_$type.specialize(Series.$)]);
/**
 * @hidden
 */
SeriesCollection._al = 0;
/**
 * @hidden
 */
SeriesCollection._ap = 1;
/**
 * @hidden
 */
SeriesCollection._ao = 2;
/**
 * @hidden
 */
SeriesCollection._w = null;
/**
 * @hidden
 */
export class SeriesCollection_PlotOrderSortItem extends Base {
  constructor() {
    super(...arguments);
    this.a = null;
    this.b = 0;
    this.c = 0;
  }
}
SeriesCollection_PlotOrderSortItem.$t = markType(SeriesCollection_PlotOrderSortItem, 'SeriesCollection_PlotOrderSortItem');
/**
 * @hidden
 */
export class SeriesCollection_PlotOrderSortComparer extends Base {
  compare(a, b) {
    if (a == null || b == null || a == b) {
      return 0;
    }
    let c = a.c > 0 ? a.c : a.b;
    let d = b.c > 0 ? b.c : b.b;
    return c < d ? -1 : c > d ? 1 : 0;
  }
}
SeriesCollection_PlotOrderSortComparer.$t = markType(SeriesCollection_PlotOrderSortComparer, 'SeriesCollection_PlotOrderSortComparer', Base.$, [IComparer$1_$type.specialize(SeriesCollection_PlotOrderSortItem.$)]);
/**
 * Represents the tick-mark labels associated with tick marks on a chart [[Axis]].
 */
export class TickLabels extends ChartObject {
  constructor(a) {
    super(a);
    this._ai = -4108;
    this._z = null;
    this._al = null;
    this._ap = null;
    this._aq = true;
    this._bd = null;
    this._ar = true;
    this._a0 = 0;
    this._ac = -5002;
    this._ax = 0;
    this._af = 0;
  }
  /**
   * @hidden
   */
  _a(a) {
    return TickLabels._w[a];
  }
  /**
   * Specifies the alignment of the tick labels
   */
  get alignment() {
    return this._ai;
  }
  /**
   * Specifies the alignment of the tick labels
   */
  set alignment(a) {
    if (a != this._ai) {
      let b = this._q(TickLabels.$, TickLabelAlignment_$type, this, 0, this._ai, a);
      this._ai = b.p2;
    }
  }
  /**
   * Specifies which font to use. Read-only.
   * <para class="note"><b>Note:</b> this property will return null until the [[TickLabels]]
   * is set on the <see cref="Axis.TickLabels">Axis.TickLabels</see> property.</para>
   */
  get font() {
    this._e(this.workbook);
    return this._al;
  }
  /**
   * @hidden
   */
  _e(a) {
    if (this._al != null) {
      return typeCast(WorkbookFontProxy.$, this._al);
    }
    let b = this.workbook != null ? this.workbook : a;
    if (b == null) {
      return null;
    }
    this._al = this._f(b);
    return typeCast(WorkbookFontProxy.$, this._al);
  }
  /**
   * @hidden
   */
  get _ao() {
    return ExcelUtils.ad(this._al);
  }
  /**
   * @hidden
   */
  get _an() {
    let a = this.workbook;
    if (this._ap == null) {
      this._ap = this._f(a, false);
      this._ap.height = 20 * 9;
    }
    let b = [this._al, this._ap];
    return ExcelUtils.v(b, a);
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill applied to the background of tick labels.
   * <p class="body">
   * This property is not applicable for <i>BoxAndWhisker</i>, <i>Histogram</i>,
   * <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, or <i>Waterfall</i> charts.
   * </p>
   */
  get fill() {
    return this._z;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill applied to the background of tick labels.
   * <p class="body">
   * This property is not applicable for <i>BoxAndWhisker</i>, <i>Histogram</i>,
   * <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, or <i>Waterfall</i> charts.
   * </p>
   */
  set fill(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(TickLabels.$, ChartFillBase.$, this, 1, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ab() {
    if (this._z != null) {
      return this._z;
    }
    let a = this.chart;
    return a != null ? a._eq : new ChartEmptyFill();
  }
  /**
   * Specifies whether an axis is multilevel or not.
   */
  get multiLevel() {
    return this._aq;
  }
  /**
   * Specifies whether an axis is multilevel or not.
   */
  set multiLevel(a) {
    if (a != this._aq) {
      let b = this._r(TickLabels.$, Boolean_$type, this, 2, this._aq, a);
      this._aq = b.p2;
    }
  }
  /**
   * Returns or sets the format to use for numbers.
   * <p class="body">
   * Note that in some cases it may be necessary to set [[numberFormatLinked]]
   * to false in order to see the format applied. If the tick labels are not displaying the
   * format you specified, try setting NumberFormatLinked to false.
   * </p>
   * @see [[numberFormatLinked]]
   */
  get numberFormat() {
    return this._bd;
  }
  /**
   * Returns or sets the format to use for numbers.
   * <p class="body">
   * Note that in some cases it may be necessary to set [[numberFormatLinked]]
   * to false in order to see the format applied. If the tick labels are not displaying the
   * format you specified, try setting NumberFormatLinked to false.
   * </p>
   * @see [[numberFormatLinked]]
   */
  set numberFormat(a) {
    if (a != this._bd) {
      let b = this._r(TickLabels.$, String_$type, this, 3, this._bd, a);
      this._bd = b.p2;
    }
  }
  /**
   * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
   * <p class="body">
   * Note that in some cases it may be necessary to set this property
   * to false in order to see the [[numberFormat]] applied.
   * If the tick labels are not displaying the format you specified,
   * try setting this property to false.
   * </p>
   * @see [[numberFormat]]
   */
  get numberFormatLinked() {
    return this._ar;
  }
  /**
   * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
   * <p class="body">
   * Note that in some cases it may be necessary to set this property
   * to false in order to see the [[numberFormat]] applied.
   * If the tick labels are not displaying the format you specified,
   * try setting this property to false.
   * </p>
   * @see [[numberFormat]]
   */
  set numberFormatLinked(a) {
    if (a != this._ar) {
      let b = this._r(TickLabels.$, Boolean_$type, this, 4, this._ar, a);
      this._ar = b.p2;
    }
  }
  /**
   * Returns or sets a Long value that represents the distance between the levels of labels, and the distance between the first level and the axis line.
   */
  get offset() {
    return this._a0;
  }
  /**
   * Returns or sets a Long value that represents the distance between the levels of labels, and the distance between the first level and the axis line.
   */
  set offset(a) {
    if (a != this._a0) {
      let b = this._r(TickLabels.$, Number_$type, this, 5, this._a0, a);
      this._a0 = b.p2;
    }
  }
  /**
   * Determines the reading order
   */
  get readingOrder() {
    return this._ac;
  }
  /**
   * Determines the reading order
   */
  set readingOrder(a) {
    this._ac = a;
  }
  /**
   * Determines the rotation of the text area, expressed in degrees.
   * <p class="body">
   * The Rotation property is only applicable when [[textDirection]]
   * is set to <i>Horizontal</i>.
   * </p>
   * @see [[textDirection]]
   */
  get rotation() {
    return this._ax;
  }
  /**
   * Determines the rotation of the text area, expressed in degrees.
   * <p class="body">
   * The Rotation property is only applicable when [[textDirection]]
   * is set to <i>Horizontal</i>.
   * </p>
   * @see [[textDirection]]
   */
  set rotation(a) {
    if (a != this._ax) {
      let b = this._r(TickLabels.$, Number_$type, this, 7, this._ax, a);
      this._ax = b.p2;
    }
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  get textDirection() {
    return this._af;
  }
  /**
   * Determines the orientation and direction in which text flows.
   * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
   * @see [[rotation]]
   */
  set textDirection(a) {
    if (a != this._af) {
      let b = this._q(TickLabels.$, TextDirection_$type, this, 8, this._af, a);
      this._af = b.p2;
    }
  }
  /**
   * @hidden
   */
  _aw() {
    if (this._ai != -4108) {
      return true;
    }
    let a = typeCast(WorkbookFontProxy.$, this._al);
    if (a != null && a._p()) {
      return true;
    }
    if (this._ac != -5002) {
      return true;
    }
    if (this._ax != 0) {
      return true;
    }
    if (this._af != 0) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(TickLabels.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(9);
    ChangeInfo.f(a, 0, TickLabels._y(TickLabelAlignment_$type, "Alignment", 7, (b) => b.alignment, (b, c) => b.alignment = c));
    ChangeInfo.f(a, 1, TickLabels._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 2, TickLabels._y(Boolean_$type, "MultiLevel", 7, (b) => b.multiLevel, (b, c) => b.multiLevel = c));
    ChangeInfo.f(a, 3, TickLabels._y(String_$type, "NumberFormat", 7, (b) => b.numberFormat, (b, c) => b.numberFormat = c));
    ChangeInfo.f(a, 4, TickLabels._y(Boolean_$type, "NumberFormatLinked", 7, (b) => b.numberFormatLinked, (b, c) => b.numberFormatLinked = c));
    ChangeInfo.f(a, 5, TickLabels._y(Number_$type, "Offset", 7, (b) => b.offset, (b, c) => b.offset = c));
    ChangeInfo.f(a, 6, TickLabels._y(ReadingOrder_$type, "ReadingOrder", 7, (b) => b.readingOrder, (b, c) => b.readingOrder = c));
    ChangeInfo.f(a, 7, TickLabels._y(Number_$type, "Rotation", 7, (b) => b.rotation, (b, c) => b.rotation = c));
    ChangeInfo.f(a, 8, TickLabels._y(TextDirection_$type, "TextDirection", 7, (b) => b.textDirection, (b, c) => b.textDirection = c));
    return a;
  }
}
TickLabels.$t = markType(TickLabels, 'TickLabels', ChartObject.$);
/**
 * @hidden
 */
TickLabels._a1 = 0;
/**
 * @hidden
 */
TickLabels._a3 = 1;
/**
 * @hidden
 */
TickLabels._a4 = 2;
/**
 * @hidden
 */
TickLabels._a6 = 3;
/**
 * @hidden
 */
TickLabels._a7 = 4;
/**
 * @hidden
 */
TickLabels._a9 = 5;
/**
 * @hidden
 */
TickLabels._ba = 6;
/**
 * @hidden
 */
TickLabels._bb = 7;
/**
 * @hidden
 */
TickLabels._bc = 8;
/**
 * @hidden
 */
TickLabels._a5 = 9;
/**
 * @hidden
 */
TickLabels._ak = -4108;
/**
 * @hidden
 */
TickLabels._as = true;
/**
 * @hidden
 */
TickLabels._at = true;
/**
 * @hidden
 */
TickLabels._a2 = 0;
/**
 * @hidden
 */
TickLabels._ad = -5002;
/**
 * @hidden
 */
TickLabels._ay = 0;
/**
 * @hidden
 */
TickLabels._ag = 0;
/**
 * @hidden
 */
TickLabels._w = TickLabels._x();
/**
 * Represents the bar which depicts gain or loss on a stock chart.
 */
export class UpDownBar extends ChartObject {
  constructor(a, b) {
    super(a);
    this._ae = 0;
    this._z = null;
    this._ab = null;
    this._ae = b;
    let c = null;
    switch (this._ae) {
      case 0:
        c = new WorkbookColorInfo(Color.u(255, 255, 255, 255));
        break;
      case 1:
        c = new WorkbookColorInfo(Color.u(255, 0, 0, 0));
        break;
    }
    this._ab = new ChartSolidFill(c);
  }
  /**
   * Returns a value which identifies this instance as as up or down bar.
   */
  get barType() {
    return this._ae;
  }
  /**
   * Determines the appearance of the border drawn around
   * the bar, as well as whether a border appears.
   * @see [[fill]]
   */
  get border() {
    return this._z;
  }
  /**
   * Determines the appearance of the border drawn around
   * the bar, as well as whether a border appears.
   * @see [[fill]]
   */
  set border(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(UpDownBar.$, ChartBorder.$, this, 0, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the bar.
   * @see [[border]]
   */
  get fill() {
    return this._ab;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill properties for the bar.
   * @see [[border]]
   */
  set fill(a) {
    if (a != this._ab) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ab != null) {
        this._ab._l(null);
      }
      let b = this._r(UpDownBar.$, ChartFillBase.$, this, 1, this._ab, a);
      this._ab = b.p2;
    }
  }
  /**
   * @hidden
   */
  get _ad() {
    if (this._ab != null) {
      return this._ab;
    }
    let a = this.chart;
    if (a != null) {
      return this.barType == 0 ? a._e0 : a._ez;
    }
    let b = this.barType == 0 ? 0 : 1;
    return new ChartSolidFill(new WorkbookColorInfo(b));
  }
  /**
   * @hidden
   */
  _a(a) {
    return UpDownBar._w[a];
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(UpDownBar.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(2);
    ChangeInfo.f(a, 0, UpDownBar._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 1, UpDownBar._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    return a;
  }
}
UpDownBar.$t = markType(UpDownBar, 'UpDownBar', ChartObject.$);
/**
 * @hidden
 */
UpDownBar._ag = 0;
/**
 * @hidden
 */
UpDownBar._ai = 1;
/**
 * @hidden
 */
UpDownBar._aj = 2;
/**
 * @hidden
 */
UpDownBar._ah = 2;
/**
 * @hidden
 */
UpDownBar._w = UpDownBar._x();
/**
 * Represents the walls and floor of a 3-D chart.
 * This object isn't a collection. There's no object
 * that represents a single wall; you must return all
 * the walls as a unit.
 */
export class Wall extends ChartObject {
  constructor(a, b) {
    super(a);
    this._z = null;
    this._ab = null;
    this._ae = 0;
    this._type = 0;
    this.type = b;
  }
  /**
   * @hidden
   */
  _a(a) {
    return Wall._w[a];
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   * @see [[fill]]
   */
  get border() {
    return this._z;
  }
  /**
   * Determines the appearance of the border drawn around
   * the text area, as well as whether a border appears.
   * @see [[fill]]
   */
  set border(a) {
    if (a != this._z) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._z != null) {
        this._z._l(null);
      }
      let b = this._r(Wall.$, ChartBorder.$, this, 0, this._z, a);
      this._z = b.p2;
    }
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill for this series.
   * @see [[border]]
   */
  get fill() {
    return this._ab;
  }
  /**
   * Returns or sets a [[ChartFillBase]] derived object
   * which defines the fill for this series.
   * @see [[border]]
   */
  set fill(a) {
    if (a != this._ab) {
      if (a != null) {
        ChartObject._v(a.owner, this.owner);
        a._l(this);
      }
      if (this._ab != null) {
        this._ab._l(null);
      }
      let b = this._r(Wall.$, ChartFillBase.$, this, 1, this._ab, a);
      this._ab = b.p2;
    }
  }
  /**
   * The thickness of the wall
   */
  get thickness() {
    return this._ae;
  }
  /**
   * The thickness of the wall
   */
  set thickness(a) {
    if (a != this._ae) {
      let b = this._r(Wall.$, Number_$type, this, 2, this._ae, a);
      this._ae = b.p2;
    }
  }
  /**
   * Returns the type of the wall, i.e., back, side, floor, or all.
   */
  get type() {
    return this._type;
  }
  /**
   * Returns the type of the wall, i.e., back, side, floor, or all.
   */
  set type(a) {
    this._type = a;
  }
  /**
   * @hidden
   */
  static _y($tValue, a, b, c, d, e = null, f = true, g = 4) {
    return new ChangeInfo$2(Wall.$, $tValue, a, b, c, d, e, f, g, false, null, null);
  }
  /**
   * @hidden
   */
  static _x() {
    let a = new Array(3);
    ChangeInfo.f(a, 0, Wall._y(ChartBorder.$, "Border", 7, (b) => b.border, (b, c) => b.border = c));
    ChangeInfo.f(a, 1, Wall._y(ChartFillBase.$, "Fill", 7, (b) => b.fill, (b, c) => b.fill = c));
    ChangeInfo.f(a, 2, Wall._y(Number_$type, "Thickness", 7, (b) => b.thickness, (b, c) => b.thickness = c));
    return a;
  }
}
Wall.$t = markType(Wall, 'Wall', ChartObject.$);
/**
 * @hidden
 */
Wall._af = 0;
/**
 * @hidden
 */
Wall._ag = 1;
/**
 * @hidden
 */
Wall._aj = 2;
/**
 * @hidden
 */
Wall._ah = 3;
/**
 * @hidden
 */
Wall._w = Wall._x();
/**
 * Extend the class ArgumentException to add a constructor
 */
export class ArgumentExceptionExtension extends ArgumentException {
  constructor(..._rest) {
    let a;
    if (arguments.length === 1) {
      a = 0;
    }
    else if (arguments.length === 2) {
      if (typeof arguments[1] === 'string') {
        a = 1;
      }
      else if (typeCast(BaseError.$, arguments[1]) !== null) {
        a = 0;
      }
      else if (arguments[1] == null) {
        a = 0;
      }
    }
    else if (arguments.length === 3) {
      a = 1;
    }
    switch (a) {
      case 0:
        {
          let message = _rest[0];
          let innerException = _rest[1];
          super(3, message, innerException);
          message = (message !== void 0 ? message : null);
          innerException = (innerException !== void 0 ? innerException : null);
        }
        break;
      case 1:
        {
          let message = _rest[0];
          let paramName = _rest[1];
          let innerException = _rest[2];
          super(3, message, innerException);
          innerException = (innerException !== void 0 ? innerException : null);
        }
        break;
      default: throw new Error('Invalid arguments');
    }
  }
}
ArgumentExceptionExtension.$t = markType(ArgumentExceptionExtension, 'ArgumentExceptionExtension', ArgumentException.$);
/**
 * @hidden
 */
export class ExcelImage extends Base {
  constructor(a, ..._rest) {
    super();
    this.a = null;
    this.c = null;
    this.g = 0;
    this.f = 0;
    this.e = false;
    this.h = Nullable$1.toNullable(Guid.$, null);
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          let g = _rest[4];
          let h = _rest[5];
          let i = [c, d];
          {
            let k = i[0];
            let l = i[1];
            this.c = k;
            this.a = DocCoreUtils.c(l);
          }
          this.g = e;
          this.f = f;
          this.e = g;
          this.h = Nullable$1.toNullable(Guid.$, h);
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.c = c;
          this.a = DocCoreUtils.c(d);
        }
        break;
    }
  }
  get b() {
    return this.a;
  }
  get d() {
    return this.c;
  }
  i(a, b) {
    a.write(this.a, 0, this.a.length);
  }
}
ExcelImage.$t = markType(ExcelImage, 'ExcelImage');
/**
 * @hidden
 */
export class DdeItem extends Base {
  constructor(a, b, c, d) {
    super();
    this.a = false;
    this.b = false;
    this.d = null;
    this.c = false;
    this.d = a;
    this.b = b;
    this.a = c;
    this.c = d;
  }
}
DdeItem.$t = markType(DdeItem, 'DdeItem');
/**
 * @hidden
 */
export class DdeLinkNamedReference extends NamedReferenceBase {
  constructor(a, b) {
    super(b, false);
    this._bf = null;
    this._bf = a;
  }
  get__f() {
    return ExcelReferenceError._a2;
  }
  get _f() {
    return this.get__f();
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
  get__z() {
    return this._bf.l._e6;
  }
  get _z() {
    return this.get__z();
  }
  toString() {
    return this._a1(GetFormulaStringInfo.a, false);
  }
  _a1(a, b = false) {
    let c = this._bf.l;
    let d = this._aw();
    return this._bf.z(a, b) + d;
  }
  get__g() {
    return 2;
  }
  get__k() {
    return null;
  }
  get _k() {
    return this.get__k();
  }
  get__h() {
    return this._bf;
  }
}
DdeLinkNamedReference.$t = markType(DdeLinkNamedReference, 'DdeLinkNamedReference', NamedReferenceBase.$);
/**
 * @hidden
 */
export class WorkbookReferenceBase extends Base {
  constructor(a) {
    super();
    this.p = null;
    this.q = null;
    this.v = null;
    this.s = null;
    this.k = null;
    this.r = null;
    this.k = a;
  }
  ac() {
    this.q = null;
    this.s = null;
    this.v = null;
  }
  d(a) {
    return this;
  }
  e() {
    return new WorkbookReferenceUnconnected(this.x, false);
  }
  f(a, b) {
    let c = Tuple.a(WorksheetReferenceSingle.$, WorksheetReferenceSingle.$, a, b);
    if (this.p == null) {
      this.p = new Dictionary$2(Tuple$2.$.specialize(WorksheetReferenceSingle.$, WorksheetReferenceSingle.$), WorksheetReferenceMulti.$, 0);
    }
    let d;
    if (((() => { let e = this.p.tryGetValue(c, d); d = e.p1; return e.ret; })()) == false) {
      d = new WorksheetReferenceMulti(a, b);
      this.p.item(c, d);
    }
    return d;
  }
  c(a, b, c) {
    let d = this.o(a);
    let e;
    if (((() => { let f = d.tryGetValue(b, e); e = f.p1; return f.ret; })()) == false) {
      if (c) {
        e = this.b(a, b, false);
        if (e._m && e._j == null) {
          let f = new SingleTargetFormula(0, 1, this.a);
          e._bb(f, false);
        }
        d.addItem(b, e);
        this.t.add(e);
      }
    }
    return e;
  }
  z(a, b = false) {
    return this.ab(-2, -2, a, b);
  }
  g(a, b) {
    let c = this.j(a);
    if (b == null) {
      return c;
    }
    let d = this.j(b);
    return this.f(c, d);
  }
  i(a) {
    if (this.r == null) {
      this.r = new Dictionary$2(Number_$type, WorksheetReferenceSingle.$, 0);
    }
    let b;
    if (((() => { let c = this.r.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      b = this.h(a);
      this.r.addItem(a, b);
    }
    return b;
  }
  ad() {
    if (this.r == null) {
      return;
    }
    let a = new List$1(WorksheetReferenceSingle.$, 1, this.r.values);
    this.r.clear();
    for (let b = 0; b < a.count; b++) {
      let c = a._inner[b];
      this.r.item(c.l, c);
    }
  }
  ae(a) {
    let b;
    if (this.r == null || ((() => { let c = this.r.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
      return;
    }
    this.r.removeItem(a);
    if (this.p != null) {
      let c = new List$1(Tuple$2.$.specialize(WorksheetReferenceSingle.$, WorksheetReferenceSingle.$), 0);
      for (let d of fromEnum(this.p.keys)) {
        if (d.c == b || d.d == b) {
          c.add(d);
        }
      }
      for (let e = 0; e < c.count; e++) {
        this.p.removeItem(c._inner[e]);
      }
    }
    this.ad();
  }
  y(a, b) {
    if (a.c != null) {
      let c;
      if (((() => { let d = a.c.tryGetValue(this, c); c = d.p1; return d.ret; })())) {
        b = true;
        return {
          ret: stringFormat("[{0}]", c),
          p1: b
        };
      }
    }
    b = false;
    return {
      ret: this.x,
      p1: b
    };
  }
  o(a) {
    if (this.q == null) {
      let b = ExcelUtils.cq;
      if (this.l != null) {
        b = this.l._e6;
      }
      this.q = new Dictionary$2(String_$type, Dictionary$2.$.specialize(Base.$, NamedReferenceBase.$), 2, ExcelUtils.em(b, true));
    }
    let c;
    if (((() => { let d = this.q.tryGetValue(a, c); c = d.p1; return d.ret; })()) == false) {
      c = new Dictionary$2(Base.$, NamedReferenceBase.$, 0);
      this.q.addItem(a, c);
    }
    return c;
  }
  get_x() {
    return null;
  }
  get x() {
    return this.get_x();
  }
  get_m() {
    return true;
  }
  get m() {
    return this.get_m();
  }
  get t() {
    if (this.s == null) {
      this.s = new List$1(NamedReferenceBase.$, 0);
    }
    return this.s;
  }
  get u() {
    if (this.v == null) {
      this.v = this.t.e();
    }
    return this.v;
  }
  get l() {
    return this.k;
  }
  get_w() {
    return this;
  }
  get w() {
    return this.get_w();
  }
}
WorkbookReferenceBase.$t = markType(WorkbookReferenceBase, 'WorkbookReferenceBase');
/**
 * @hidden
 */
export class DdeLinkWorkbookReference extends WorkbookReferenceBase {
  constructor(a, b, c) {
    super(c);
    this.af = null;
    this.ah = null;
    this.ai = null;
    this.af = new List$1(DdeItem.$, 0);
    this.ah = a;
    this.ai = b;
  }
  b(a, b, c) {
    let d = new DdeLinkNamedReference(this, b);
    d._bd(a, c);
    return d;
  }
  h(a) {
    return new WorksheetReferenceToWorkbook(this);
  }
  e() {
    return new WorkbookReferenceUnconnected(this.x, true);
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    return a.toString();
  }
  j(a) {
    return this.i(-2);
  }
  ab(a, b, c, d) {
    let e;
    let f = ((() => { let g = this.y(c, e); e = g.p1; return g.ret; })());
    return f + "!";
  }
  get_x() {
    return DdeLinkWorkbookReference.aj(this.ah, this.ai);
  }
  static aj(a, b) {
    if (FormulaParser.bo(a)) {
      a = stringFormat("'{0}'", stringReplace(a, "'", "''"));
    }
    if (FormulaParser.bo(b)) {
      b = stringFormat("'{0}'", stringReplace(b, "'", "''"));
    }
    return stringFormat("{0}|{1}", a, b);
  }
  get_n() {
    return true;
  }
  get n() {
    return this.get_n();
  }
  get ag() {
    return this.af;
  }
  get_a() {
    return 4;
  }
  get a() {
    return this.get_a();
  }
  get ak() {
    return this.ah;
  }
  get al() {
    return this.ai;
  }
}
DdeLinkWorkbookReference.$t = markType(DdeLinkWorkbookReference, 'DdeLinkWorkbookReference', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class AddInFunctionNamedReference extends NamedReferenceBase {
  constructor(a, b) {
    super(b, false);
    this._bf = null;
    this._bf = a;
  }
  get__f() {
    return null;
  }
  get _f() {
    return this.get__f();
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
  get__z() {
    return this._bf.l._e6;
  }
  get _z() {
    return this.get__z();
  }
  get__l() {
    return this._bf.l.currentFormat;
  }
  toString() {
    return this.name;
  }
  get__g() {
    return 1;
  }
  get__k() {
    return null;
  }
  get _k() {
    return this.get__k();
  }
  get__h() {
    return this._bf;
  }
}
AddInFunctionNamedReference.$t = markType(AddInFunctionNamedReference, 'AddInFunctionNamedReference', NamedReferenceBase.$);
/**
 * @hidden
 */
export class AddInFunctionsWorkbookReference extends WorkbookReferenceBase {
  constructor(a) {
    super(a);
  }
  b(a, b, c) {
    let d = new AddInFunctionNamedReference(this, b);
    d._bd(a, c);
    return d;
  }
  h(a) {
    return new WorksheetReferenceToWorkbook(this);
  }
  get_x() {
    return "<AddInFunctions>";
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    return a.toString();
  }
  j(a) {
    return this.i(-2);
  }
  ab(a, b, c, d) {
    return null;
  }
  get_n() {
    return false;
  }
  get n() {
    return this.get_n();
  }
  get_a() {
    return 0;
  }
  get a() {
    return this.get_a();
  }
}
AddInFunctionsWorkbookReference.$t = markType(AddInFunctionsWorkbookReference, 'AddInFunctionsWorkbookReference', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class CurrentWorkbookReference extends WorkbookReferenceBase {
  constructor(a) {
    super(a);
    this.ai = null;
    this.af = null;
  }
  b(a, b, c = true) {
    let d = null;
    if (b == this.l) {
      d = this.l._a3(a);
    }
    else {
      let e = typeCast(Worksheet.$, b);
      if (e != null) {
        d = this.l._namedReferences$i._find1(a, e);
      }
      else {
      }
    }
    if (d != null) {
      return d;
    }
    return new NamedReferenceUnconnected(1, a, b, false, this.l.currentFormat, c);
  }
  h(a) {
    if (a == -1) {
      return new WorksheetReferenceError(this);
    }
    if (a == -2) {
      return new WorksheetReferenceToWorkbook(this);
    }
    let b = this.l._worksheets$i;
    if (b.count <= a) {
      return new WorksheetReferenceError(this);
    }
    return new WorksheetReferenceLocal(this, b._item(a));
  }
  get_x() {
    return this.l._gw;
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    let b = this.l._worksheets$i;
    if (b.count <= a) {
      return this.ah(a);
    }
    return b._item(a).name;
  }
  j(a) {
    let b;
    if (this.ai != a || this.af == null || this.af.u.workbook == null || this.af.s != a) {
      this.ai = a;
      b = this.ag(a);
      this.af = typeCast(WorksheetReferenceLocal.$, b);
    }
    else {
      b = this.af;
    }
    return b;
  }
  ag(a) {
    if (a == null) {
      return this.i(-2);
    }
    let b = this.l._e6;
    if (StringUtilities.c(a, "#REF!", b, 1) == 0) {
      return this.i(-1);
    }
    let c = this.l._worksheets$i;
    for (let d = 0; d < c.count; d++) {
      let e = c._item(d);
      if (StringUtilities.c(e.name, a, b, 1) == 0) {
        return this.i(d);
      }
    }
    return this.i(-1);
  }
  ab(a, b, c, d) {
    let e = null;
    let f = false;
    if (d) {
      e = ((() => { let g = this.y(c, f); f = g.p1; return g.ret; })());
    }
    if (a == b) {
      return ExcelUtils.d4(e, f, this.aa(a), null);
    }
    return ExcelUtils.d6(e, this.aa(a), this.aa(b));
  }
  get_n() {
    return false;
  }
  get n() {
    return this.get_n();
  }
  get_a() {
    return 3;
  }
  get a() {
    return this.get_a();
  }
  get_w() {
    return this.l;
  }
  aj(a) {
    let b = this.o(a.name);
    b.item(a.scope, a);
    this.t.add(a);
  }
  ah(a) {
    return "?" + a;
  }
  ak(a) {
  }
}
CurrentWorkbookReference.$t = markType(CurrentWorkbookReference, 'CurrentWorkbookReference', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class ExternalNamedReference extends NamedReferenceBase {
  constructor(a, b) {
    super(b, false);
    this._bf = null;
    this._bg = null;
    this._bg = a;
  }
  get__f() {
    if (this._bf == null) {
      this._bf = new ExternalNamedCalcReference(this);
      this._bg.l._ha(this._bf);
    }
    return this._bf;
  }
  get _f() {
    return this.get__f();
  }
  get__z() {
    return this._bg.l._e6;
  }
  get _z() {
    return this.get__z();
  }
  get__l() {
    return this._bg.l.currentFormat;
  }
  _a6(a) {
    if (this._j == null || this._j._e.length == 0) {
      return;
    }
    this._f._a0(this._j, false);
  }
  toString() {
    return this._a1(GetFormulaStringInfo.a, false);
  }
  _a1(a, b = false) {
    if (typeCast(WorkbookReferenceBase.$, this.scope) !== null) {
      return this._bg.z(a, b) + this.name;
    }
    let c = typeCast(WorksheetReference.$, this.scope);
    if (c != null) {
      return c.o(a, b) + this.name;
    }
    return this.name;
  }
  get__k() {
    return null;
  }
  get _k() {
    return this.get__k();
  }
  get__h() {
    return this._bg;
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
}
ExternalNamedReference.$t = markType(ExternalNamedReference, 'ExternalNamedReference', NamedReferenceBase.$);
/**
 * @hidden
 */
export class ExternalWorkbookReference extends WorkbookReferenceBase {
  constructor(a, b) {
    super(b);
    this.ah = null;
    this.af = null;
    this.ah = a;
    this.af = new List$1(String_$type, 0);
  }
  b(a, b, c) {
    let d = new ExternalNamedReference(this, b);
    d._bd(a, c);
    return d;
  }
  h(a) {
    if (a == -1) {
      return new WorksheetReferenceError(this);
    }
    if (a == -2) {
      return new WorksheetReferenceToWorkbook(this);
    }
    return new WorksheetReferenceExternal(this, a);
  }
  get_x() {
    return this.ah;
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    return this.af._inner[a];
  }
  j(a) {
    if (a == null) {
      return this.i(-2);
    }
    let b = this.l._e6;
    if (StringUtilities.c(a, "#REF!", b, 1) == 0) {
      return this.i(-1);
    }
    for (let c = 0; c < this.af.count; c++) {
      let d = this.af._inner[c];
      if (StringUtilities.c(d, a, b, 1) == 0) {
        return this.i(c);
      }
    }
    this.af.add(a);
    return this.i(this.af.count - 1);
  }
  ab(a, b, c, d) {
    let e;
    let f = ((() => { let g = this.y(c, e); e = g.p1; return g.ret; })());
    if (a == b) {
      return ExcelUtils.d4(f, e, this.aa(a), null);
    }
    return ExcelUtils.d4(f, e, this.aa(a), this.aa(b));
  }
  get_n() {
    return true;
  }
  get n() {
    return this.get_n();
  }
  get_a() {
    return 4;
  }
  get a() {
    return this.get_a();
  }
  toString() {
    return this.ah;
  }
  get ag() {
    return this.af;
  }
}
ExternalWorkbookReference.$t = markType(ExternalWorkbookReference, 'ExternalWorkbookReference', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class GetFormulaStringInfo extends Base {
  constructor(a, b) {
    super();
    this.c = null;
    this.b = false;
    this.c = a;
    this.b = b;
  }
}
GetFormulaStringInfo.$t = markType(GetFormulaStringInfo, 'GetFormulaStringInfo');
GetFormulaStringInfo.a = new GetFormulaStringInfo(null, false);
/**
 * @hidden
 */
export class ImageHolder extends Base {
  constructor(a, b) {
    super();
    this.a = null;
    this.c = null;
    this.a = a;
    this.c = b;
  }
  get b() {
    return this.a;
  }
  get d() {
    return this.c;
  }
}
ImageHolder.$t = markType(ImageHolder, 'ImageHolder');
/**
 * @hidden
 */
export class MultipleCellValueInfo extends Base {
  constructor(a, b, c, d, e) {
    super();
    this.e = null;
    this.a = null;
    this.g = null;
    this.h = null;
    this.i = null;
    this.e = a;
    this.a = b;
    this.g = c;
    this.h = d;
    this.i = e;
  }
  d(a) {
    return this.g._inner[a];
  }
  static c(a, b, c) {
    return a._a8(b) || c;
  }
  static f(a, b, c, d, e) {
    c = null;
    d = null;
    e = null;
    let f = a._r.b;
    let g;
    if (((() => { let h = b(a, f, a._q, g); g = h.p3; return h.ret; })()) == false) {
      return {
        ret: false,
        p2: c,
        p3: d,
        p4: e
      };
    }
    let h = f.worksheet.workbook;
    let i;
    if (f._hasCellFormat) {
      i = f._cellFormatInternal.d;
    }
    else {
      i = h._ca._p;
    }
    c = new List$1(WorksheetCellFormatData.$, 0);
    d = new List$1(Number_$type, 0);
    e = new List$1(Base.$, 0);
    let j = a._q.r;
    c.add(MultipleCellValueInfo.c(f, j, i));
    d.add(j);
    e.add1(g);
    let k = h._ff;
    for (let l = (j + 1); l < k; l++) {
      let m = f._am(l);
      if (m == null) {
        break;
      }
      if (((() => { let n = b(a, f, m, g); g = n.p3; return n.ret; })()) == false) {
        break;
      }
      c.add(MultipleCellValueInfo.c(f, l, i));
      d.add(l);
      e.add1(g);
    }
    return {
      ret: d.count >= 2,
      p2: c,
      p3: d,
      p4: e
    };
  }
  n(a) {
    return this.i._inner[a];
  }
  get j() {
    return this.h._inner[0];
  }
  get k() {
    return this.h._inner[this.h.count - 1];
  }
  get l() {
    return this.h.count;
  }
  get b() {
    return this.a;
  }
  get m() {
    return this.e.index;
  }
}
MultipleCellValueInfo.$t = markType(MultipleCellValueInfo, 'MultipleCellValueInfo');
/**
 * @hidden
 */
export class MultipleCellBlankInfo extends MultipleCellValueInfo {
  constructor(a, b, c, d, e) {
    super(a, b, c, d, e);
  }
  static o(a) {
    let b;
    let c;
    let d;
    if (((() => { let e = MultipleCellValueInfo.f(a, MultipleCellBlankInfo.p, b, c, d); b = e.p2; c = e.p3; d = e.p4; return e.ret; })()) == false) {
      return null;
    }
    let e = a._r;
    return new MultipleCellBlankInfo(e.b, e.a, b, c, d);
  }
  static q(a, b, c, d) {
    d = a._a3(b, c);
    return {
      ret: ExcelUtils.a9(d),
      p3: d
    };
  }
}
MultipleCellBlankInfo.$t = markType(MultipleCellBlankInfo, 'MultipleCellBlankInfo', MultipleCellValueInfo.$);
MultipleCellBlankInfo.p = MultipleCellBlankInfo.q;
/**
 * @hidden
 */
export class MultipleCellRKInfo extends MultipleCellValueInfo {
  constructor(a, b, c, d, e) {
    super(a, b, c, d, e);
  }
  static o(a) {
    let b;
    let c;
    let d;
    if (((() => { let e = MultipleCellValueInfo.f(a, MultipleCellRKInfo.p, b, c, d); b = e.p2; c = e.p3; d = e.p4; return e.ret; })()) == false) {
      return null;
    }
    let e = a._r;
    return new MultipleCellRKInfo(e.b, e.a, b, c, d);
  }
  static q(a, b, c, d) {
    d = null;
    let e = a._a3(b, c);
    if (ExcelUtils.ba(e) == false) {
      return {
        ret: false,
        p3: d
      };
    }
    let f = Convert.toDouble4(e, CultureInfo.invariantCulture);
    let g;
    if (((() => { let h = ExcelUtils.bz(f, g); g = h.p1; return h.ret; })()) == false) {
      return {
        ret: false,
        p3: d
      };
    }
    d = g;
    return {
      ret: true,
      p3: d
    };
  }
}
MultipleCellRKInfo.$t = markType(MultipleCellRKInfo, 'MultipleCellRKInfo', MultipleCellValueInfo.$);
MultipleCellRKInfo.p = MultipleCellRKInfo.q;
/**
 * @hidden
 */
export class OleItem extends Base {
  constructor(a, b, c, d) {
    super();
    this.a = false;
    this.b = false;
    this.d = null;
    this.c = false;
    this.d = a;
    this.b = b;
    this.a = c;
    this.c = d;
  }
}
OleItem.$t = markType(OleItem, 'OleItem');
/**
 * @hidden
 */
export class OleLinkNamedReference extends NamedReferenceBase {
  constructor(a, b) {
    super(b, false);
    this._bf = null;
    this._bf = a;
  }
  get__f() {
    return ExcelReferenceError._a2;
  }
  get _f() {
    return this.get__f();
  }
  get__n() {
    return false;
  }
  get _n() {
    return this.get__n();
  }
  get__z() {
    return this._bf.l._e6;
  }
  get _z() {
    return this.get__z();
  }
  toString() {
    return this._a1(GetFormulaStringInfo.a, false);
  }
  _a1(a, b = false) {
    let c = this._bf.l;
    let d = this._aw();
    return this._bf.z(a, b) + d;
  }
  get__g() {
    return 2;
  }
  get__k() {
    return null;
  }
  get _k() {
    return this.get__k();
  }
  get__h() {
    return this._bf;
  }
}
OleLinkNamedReference.$t = markType(OleLinkNamedReference, 'OleLinkNamedReference', NamedReferenceBase.$);
/**
 * @hidden
 */
export class OleLinkWorkbookReference extends WorkbookReferenceBase {
  constructor(a, b, c) {
    super(c);
    this.af = null;
    this.aj = null;
    this.ah = null;
    this.af = new List$1(OleItem.$, 0);
    this.ah = a;
    this.aj = b;
  }
  b(a, b, c) {
    let d = new OleLinkNamedReference(this, b);
    d._bd(a, c);
    return d;
  }
  h(a) {
    return new WorksheetReferenceToWorkbook(this);
  }
  e() {
    return new WorkbookReferenceUnconnected(this.x, true);
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    return a.toString();
  }
  j(a) {
    return this.i(-2);
  }
  ab(a, b, c, d) {
    let e;
    let f = ((() => { let g = this.y(c, e); e = g.p1; return g.ret; })());
    return f + "!";
  }
  get_x() {
    let a = this.ah;
    if (FormulaParser.bo(a)) {
      a = stringFormat("'{0}'", stringReplace(a, "'", "''"));
    }
    let b = this.aj.originalString;
    if (FormulaParser.bo(b)) {
      b = stringFormat("'{0}'", stringReplace(b, "'", "''"));
    }
    return stringFormat("{0}|{1}", a, b);
  }
  get_n() {
    return true;
  }
  get n() {
    return this.get_n();
  }
  get ag() {
    return this.af;
  }
  get_a() {
    return 4;
  }
  get a() {
    return this.get_a();
  }
  get ak() {
    return this.aj;
  }
  get ai() {
    return this.ah;
  }
}
OleLinkWorkbookReference.$t = markType(OleLinkWorkbookReference, 'OleLinkWorkbookReference', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class PivotCacheInfo extends Base {
  constructor(a, b) {
    super();
    this.b = 0;
    this.a = null;
    this.b = b;
    this.a = a;
  }
}
PivotCacheInfo.$t = markType(PivotCacheInfo, 'PivotCacheInfo');
/**
 * @hidden
 */
export class PivotTableInfo extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.a = null;
    this.b = a;
    this.a = b;
  }
}
PivotTableInfo.$t = markType(PivotTableInfo, 'PivotTableInfo');
/**
 * @hidden
 */
export class WorkbookLoadManager extends WorkbookSerializationManager {
  constructor(a, b) {
    super(a, b);
    this._t = null;
    this._t = new List$1(StringElement.$, 0);
  }
  _y(a, b) {
    if (a._x && (!b || !a._v)) {
      return;
    }
    if (b) {
      if (this._s(a) == false) {
        this._b._en.add(a);
        if (a._r) {
          a._b3();
        }
      }
    }
    else {
      this._b._namedReferences$i._x(a);
    }
  }
  static _v(a, b, c) {
    if (c == null) {
      return b;
    }
    if (b != null) {
      return b + "#" + c;
    }
    let d = c.lastIndexOf('!');
    if (d < 0) {
      if (FormulaParser.ab(c, a.currentFormat, Workbook._fa)) {
        return a._namedReferences$i._find(c) || c;
      }
      return c;
    }
    let e = c.substr(0, d).trim();
    let f = c.substr(d + 1).trim();
    if (e.length >= 2 && e.charAt(0) == '\'' && e.charAt(e.length - 1) == '\'') {
      e = e.substr(1, e.length - 2);
    }
    if (f.length >= 2 && f.charAt(0) == '\'' && f.charAt(f.length - 1) == '\'') {
      f = f.substr(1, f.length - 1);
    }
    if (a._worksheets$i.exists(e) == false) {
      return c;
    }
    let g = a._worksheets$i._item1(e);
    if (FormulaParser.ab(f, a.currentFormat, Workbook._fa)) {
      return a._namedReferences$i._find1(f, g) || c;
    }
    if (stringContains(f, ":")) {
      return g._getRegion(f);
    }
    return g._getCell1(f, 1);
  }
  _ae(a, b, c, d) {
    if (a == null) {
      a = new CT_Transform2D();
      a.b = ((() => {
        let $ret = new CT_PositiveSize2D();
        $ret.a = ST_PositiveCoordinate.a(0);
        $ret.b = ST_PositiveCoordinate.a(0);
        return $ret;
      })());
      a.a = ((() => {
        let $ret = new CT_Point2D();
        $ret.a = ST_Coordinate.b(0);
        $ret.b = ST_Coordinate.b(0);
        return $ret;
      })());
    }
    let e = d.width / c.m.a.j();
    let f = d.height / c.m.b.j();
    let g = (a.a.a.k() - c.l.a.k()) * e;
    let h = (a.a.b.k() - c.l.b.k()) * f;
    let i = truncate(MathUtilities.f(d.x + g));
    let j = truncate(MathUtilities.f(d.y + h));
    let k = truncate(MathUtilities.f(e * a.b.a.j()));
    let l = truncate(MathUtilities.f(f * a.b.b.j()));
    b %= 360;
    if (b < 0) {
      b += 360;
    }
    if (i == -2147483648) {
      i = 0;
    }
    if (j == -2147483648) {
      j = 0;
    }
    if (ExcelUtils.au(this._b.currentFormat) || (b < 45) || (b > 135 && b < 225) || (b > 315)) {
      if (k == -2147483648) {
        k = 0;
      }
      if (l == -2147483648) {
        l = 0;
      }
      return new Rect(0, i, j, k, l);
    }
    else {
      let m = truncate(MathUtilities.f(f * a.b.a.j()));
      let n = truncate(MathUtilities.f(e * a.b.b.j()));
      let o = intDivide((k - m), 2);
      let p = intDivide((l - n), 2);
      if (m == -2147483648) {
        m = 0;
      }
      if (n == -2147483648) {
        n = 0;
      }
      return new Rect(0, i + o, j + p, m, n);
    }
  }
  _q(a) {
    let b = this._j;
    if (a < 0 || b.count <= a) {
      return null;
    }
    return b._inner[a];
  }
  _o() {
    return WorkItemExtensions.a(this._p(), () => {
      for (let a = this._b._worksheets$i.count - 1; a >= 0; a--) {
        if (this._b._worksheets$i._item(a)._br != 0) {
          this._b._worksheets$i.removeAt(a);
        }
        else if (this._b._worksheets$i._item(a).isProtected) {
          this._b._worksheets$i._item(a).protection._af();
        }
      }
      if (ExcelUtils.au(this._b.currentFormat) == false) {
      }
    });
  }
  _z() {
    let a = this._b;
    let b = a.windowOptions;
    b.selectedSheet = a._sheets$i._item(b._as);
    if (a._cq) {
      for (let c of fromEnum(a._customViews$i)) {
        let d = c.windowOptions._ao;
        if (d < 0) {
          continue;
        }
        let e = a._bl(d);
        if (e != null) {
          c.windowOptions.selectedSheet = e;
        }
      }
    }
    a._ca._p = this._r();
    a._av._p = this._h._inner[0];
  }
  _ac($t, a, b, c, d, e) {
    this._ad($t, a, b, c, d, e, null);
  }
  _ad($t, a, b, c, d, e, f, ...g) {
    if (d != null || e != null || f != null) {
      if (e == null) {
        e = this._b._cd(2);
      }
      if (d == null) {
        d = this._b._styles$i.normalStyle;
      }
      e._du(d);
      if (f != null && g.length != 0) {
        if (ExcelUtils.bx(f.formatOptions, 8)) {
          for (let h = 0; h < g.length; h++) {
            ExcelUtils.e9(f, e, g[h]);
          }
        }
      }
      let i = a._d(this._b, b);
      for (let j = 1; j != 1073741824; j = (j << 1)) {
        if (c(b, j) == false) {
          continue;
        }
        ExcelUtils.fa(e, i, j);
      }
    }
  }
  static _aa(a, b, c) {
    let d = b.getHiddenColumns(a, true);
    if (d == null) {
      return;
    }
    let e = ExcelUtils.cd(c);
    for (let f = 0; f < e.count; f++) {
      let g = e._inner[f];
      d._l(g.d.r, g.b.r);
    }
  }
  static _ab(a, b, c) {
    let d = b.getHiddenRows(a, true);
    if (d == null) {
      return;
    }
    let e = ExcelUtils.cd(c);
    for (let f = 0; f < e.count; f++) {
      let g = e._inner[f];
      d._l(g.d.t, g.b.t);
    }
  }
  _s(a) {
    let b = typeCast(Worksheet.$, a.scope);
    if (b == null) {
      return false;
    }
    let c = WorkbookLoadManager._x.i(a.name);
    if (c.i == false) {
      return false;
    }
    let d = stringReplace(c.g.substr(2, 36), "_", "");
    let e = new Guid(3, d);
    let f = this._b._customViews$i._item(e);
    if (f == null) {
      return false;
    }
    let g = c.d;
    let h = a.name.length - g;
    let i = stringToLocaleLower(a.name.substr(g, h), CultureInfo.invariantCulture);
    switch (i) {
      case "cols":
        WorkbookLoadManager._aa(b, f, a._j);
        break;
      case "rows":
        WorkbookLoadManager._ab(b, f, a._j);
        break;
      case "printarea":
        let j = f.getPrintOptions(b, true);
        NamedReferenceBase._a4(a, j);
        break;
      case "printtitles":
        NamedReferenceBase._a5(a, f.getPrintOptions(b, true));
        break;
      default: break;
    }
    return true;
  }
  static get _x() {
    if (WorkbookLoadManager._w == null) {
      WorkbookLoadManager._w = new Regex(1, "\\GZ_[0-9A-Z]{8}_([0-9A-Z]{4}_){3}[0-9A-Z]{12}_\\.wvu\\.", 1 | 8);
    }
    return WorkbookLoadManager._w;
  }
  get _u() {
    return this._t;
  }
}
WorkbookLoadManager.$t = markType(WorkbookLoadManager, 'WorkbookLoadManager', WorkbookSerializationManager.$);
WorkbookLoadManager._w = null;
/**
 * @hidden
 */
export class WorkbookReferenceUnconnected extends WorkbookReferenceBase {
  constructor(a, b) {
    super(null);
    this.af = false;
    this.ag = null;
    this.af = b;
    this.ag = a;
  }
  d(a) {
    if (a.f == null) {
      return this;
    }
    if (this.af) {
      return a.f._be(this.ag);
    }
    else {
      return a.f._bf(this.ag);
    }
  }
  b(a, b, c) {
    return null;
  }
  h(a) {
    if (a == -1) {
      return new WorksheetReferenceError(this);
    }
    if (a == -2) {
      return new WorksheetReferenceToWorkbook(this);
    }
    return null;
  }
  e() {
    return this;
  }
  get_x() {
    return this.ag;
  }
  aa(a) {
    if (a == -1) {
      return "#REF!";
    }
    if (a == -2) {
      return null;
    }
    return a.toString();
  }
  j(a) {
    if (a == null) {
      return this.i(-2);
    }
    if (StringUtilities.c(a, "#REF!", ExcelUtils.cq, 1) == 0) {
      return this.i(-1);
    }
    return new WorksheetReferenceSingleUnconnected(1, this, a);
  }
  ab(a, b, c, d) {
    if (a == b) {
      return ExcelUtils.d5(this.x, this.aa(a));
    }
    return ExcelUtils.d6(this.x, this.aa(a), this.aa(b));
  }
  get_m() {
    return false;
  }
  get_n() {
    return this.ag != null;
  }
  get n() {
    return this.get_n();
  }
  get_a() {
    if (this.n) {
      return 4;
    }
    return 3;
  }
  get a() {
    return this.get_a();
  }
}
WorkbookReferenceUnconnected.$t = markType(WorkbookReferenceUnconnected, 'WorkbookReferenceUnconnected', WorkbookReferenceBase.$);
/**
 * @hidden
 */
export class WorkbookSaveManager_InitSerializationCacheFormulaHelper extends FormulaTokenVisitor {
  constructor() {
    super();
    this.az = null;
  }
  g() {
    this.az = null;
    super.g();
  }
  aj(a) {
    let b = a.u;
    let c = this.a2(b);
    b = c.p0;
    a.u = b;
    this.aq(a);
  }
  aq(a) {
    this.a4(a.o);
  }
  aw(a) {
    this.a3(a.y);
    this.aq(a);
  }
  static a1(a, b) {
    if (WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0 == null) {
      WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0 = new WorkbookSaveManager_InitSerializationCacheFormulaHelper();
    }
    WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0.az = b;
    WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0.b = a;
    return WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0;
  }
  a2(a) {
    this.a3(a._h);
    let b = a._h || this.az._b._bb;
    let c = a.scope != null ? a.scope : b.w;
    a = b.c(a.name, c, true);
    return {
      p0: a
    };
  }
  a3(a) {
    if (a == null) {
      return;
    }
    if (this.az._i.contains(a) == false) {
      this.az._i.add(a);
    }
  }
  a4(a) {
    if (a == null) {
      return;
    }
    this.a3(a.e);
    if (this.az._j.contains(a) == false) {
      this.az._j.add(a);
    }
  }
}
WorkbookSaveManager_InitSerializationCacheFormulaHelper.$t = markType(WorkbookSaveManager_InitSerializationCacheFormulaHelper, 'WorkbookSaveManager_InitSerializationCacheFormulaHelper', FormulaTokenVisitor.$);
WorkbookSaveManager_InitSerializationCacheFormulaHelper.a0 = null;
/**
 * @hidden
 */
export class WorkbookSaveManager_InitSerializationCacheHelper extends WorksheetShapeVisitor$2 {
  constructor() {
    super(WorkbookSaveManager.$, Boolean_$type);
  }
  _visitFormattedStringElement$i(a, b) {
    if (a._u == false) {
      return true;
    }
    let c = b.c;
    let d = b.d;
    for (let e of fromEnum(a._ah)) {
      if (e.h) {
        c._bd(e.f(c._b), d);
      }
    }
    return true;
  }
  _visitStringElement$i(a, b) {
    return true;
  }
  visitWorksheetCellComment(value, saveManager) {
    return this._visitWorksheetCellComment$i.apply(this, arguments);
  }
  _visitWorksheetCellComment$i(a, b) {
    if (a.text != null) {
      a.text._m._t(Tuple$2.$.specialize(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type), Boolean_$type, this, Tuple.a(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type, b, a));
    }
    return true;
  }
  visitWorksheetChart(value, saveManager) {
    return this._visitWorksheetChart$i.apply(this, arguments);
  }
  _visitWorksheetChart$i(a, b) {
    if (a._g4 != null) {
      for (let c of fromEnum(a._g4)) {
        if (c.b != null && b._h.contains(c.b) == false) {
          b._h.add(c.b);
        }
      }
    }
    return true;
  }
  visitWorksheetShapeGroup(value, saveManager) {
    return this._visitWorksheetShapeGroup$i.apply(this, arguments);
  }
  _visitWorksheetShapeGroup$i(a, b) {
    for (let c of fromEnum(a._shapes$i)) {
      c._am(WorkbookSaveManager.$, Boolean_$type, this, b);
    }
    return true;
  }
  c(a, b) {
    if (a.text != null) {
      b._bj(a.text, a);
    }
    return true;
  }
}
WorkbookSaveManager_InitSerializationCacheHelper.$t = markType(WorkbookSaveManager_InitSerializationCacheHelper, 'WorkbookSaveManager_InitSerializationCacheHelper', WorksheetShapeVisitor$2.$.specialize(WorkbookSaveManager.$, Boolean_$type), [IStringElementVisitor$2_$type.specialize(Tuple$2.$.specialize(WorkbookSaveManager.$, IWorkbookFontDefaultsResolver_$type), Boolean_$type)]);
WorkbookSaveManager_InitSerializationCacheHelper.d = new WorkbookSaveManager_InitSerializationCacheHelper();
/**
 * @hidden
 */
export class WorkbookSaveManager_ColorSortConditionVisitorProxy$1 extends Base {
  constructor($tArg, a, b, c, d) {
    super();
    this.$tArg = null;
    this.a = null;
    this.c = false;
    this.d = false;
    this.e = null;
    this.$tArg = $tArg;
    this.$type = this.$type.specialize(this.$tArg);
    this.a = a;
    this.c = b;
    this.d = c;
    this.e = d;
  }
  b(a, b) {
    let c = this.a._b._cd(2);
    c._ce = a;
    this.e.item(b, this.a._ba(c));
    return c;
  }
  visitFillSortCondition(value, arg) {
    return this._visitFillSortCondition$i.apply(this, arguments);
  }
  _visitFillSortCondition$i(a, b) {
    this.b(this.c, b).fill = a.fill;
    return true;
  }
  visitFontColorSortCondition(value, arg) {
    return this._visitFontColorSortCondition$i.apply(this, arguments);
  }
  _visitFontColorSortCondition$i(a, b) {
    this.b(this.d, b).font.colorInfo = a.fontColorInfo;
    return true;
  }
}
WorkbookSaveManager_ColorSortConditionVisitorProxy$1.$t = markType(WorkbookSaveManager_ColorSortConditionVisitorProxy$1, 'WorkbookSaveManager_ColorSortConditionVisitorProxy$1', Base.$, [IColorSortConditionVisitor$2_$type.specialize(0, Boolean_$type)]);
/**
 * @hidden
 */
export class CellContext extends Base {
  constructor(a, b) {
    super();
    this.b = null;
    this.a = null;
    this.c = null;
    this.b = a;
    this.a = b;
  }
}
CellContext.$t = markType(CellContext, 'CellContext');
/**
 * @hidden
 */
export class WorksheetReference extends Base {
  constructor(a) {
    super();
    this.d = null;
    this.d = a;
  }
  f(a) {
    if (this.i) {
      return this;
    }
    if (this.e == null) {
      if (a.f == null) {
        return this;
      }
      return this.g(a.f._bb);
    }
    return this.g(this.e.d(a));
  }
  g(a) {
    return this;
  }
  get_i() {
    return true;
  }
  get i() {
    return this.get_i();
  }
  get_m() {
    return this.l;
  }
  get m() {
    return this.get_m();
  }
  get_n() {
    return this;
  }
  get n() {
    return this.get_n();
  }
  get p() {
    return this.o(GetFormulaStringInfo.a, false);
  }
  get e() {
    return this.d;
  }
}
WorksheetReference.$t = markType(WorksheetReference, 'WorksheetReference');
/**
 * @hidden
 */
export class WorksheetReferenceSingle extends WorksheetReference {
  constructor(a) {
    super(a);
  }
  h() {
    let a = null;
    let b = this.e;
    if (b != null) {
      a = b.x;
    }
    return new WorksheetReferenceSingleUnconnected(0, a, this.s);
  }
  o(a, b) {
    return this.e.ab(this.l, this.m, a, b);
  }
  get_k() {
    return false;
  }
  get k() {
    return this.get_k();
  }
}
WorksheetReferenceSingle.$t = markType(WorksheetReferenceSingle, 'WorksheetReferenceSingle', WorksheetReference.$);
/**
 * @hidden
 */
export class WorksheetReferenceError extends WorksheetReferenceSingle {
  constructor(a) {
    super(a);
  }
  g(a) {
    return a.i(this.l);
  }
  get_l() {
    return -1;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    return ExcelReferenceError._a2;
  }
  b(a) {
    return ExcelReferenceError._a2;
  }
  q(a, b) {
    return ExcelReferenceError._a2;
  }
  r(a, b) {
    return ExcelReferenceError._a2;
  }
  c(a) {
    return null;
  }
  get_i() {
    return this.e.m;
  }
  get_j() {
    return this.e.n;
  }
  get j() {
    return this.get_j();
  }
  get_s() {
    return "#REF!";
  }
  get s() {
    return this.get_s();
  }
}
WorksheetReferenceError.$t = markType(WorksheetReferenceError, 'WorksheetReferenceError', WorksheetReferenceSingle.$);
/**
 * @hidden
 */
export class WorksheetReferenceExternal extends WorksheetReferenceSingle {
  constructor(a, b) {
    super(a);
    this.w = null;
    this.v = null;
    this.y = 0;
    this.y = b;
  }
  get_l() {
    return this.y;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    return this.t(a.o).a(a.m);
  }
  b(a) {
    if (this.v == null) {
      this.v = new SortedList$2(WorksheetRegionAddress.$, ExternalRegionCalcReference.$, 0);
    }
    let b = this.v._l(a);
    let c;
    if (b < 0) {
      c = new ExternalRegionCalcReference(this, a);
      this.v._item(a, c);
    }
    else {
      c = this.v._j._inner[b];
    }
    return c;
  }
  q(a, b) {
    let c = typeCast(WorksheetReferenceExternal.$, a);
    if (c == null) {
      return null;
    }
    return new MultiSheetExternalCellCalcReference(this, c, b);
  }
  r(a, b) {
    let c = typeCast(WorksheetReferenceExternal.$, a);
    if (c == null) {
      return null;
    }
    return new MultiSheetExternalRegionCalcReference(this, c, b);
  }
  c(a) {
    return this.e.c(a, this, true);
  }
  get_j() {
    return true;
  }
  get j() {
    return this.get_j();
  }
  get_s() {
    return this.e.aa(this.y);
  }
  get s() {
    return this.get_s();
  }
  z(a, b) {
    if (this.w != null) {
      let c = this.w._l(a);
      if (0 <= c) {
        return this.w._j._inner[c].h(b);
      }
    }
    return null;
  }
  t(a) {
    if (this.w == null) {
      this.w = new SortedList$2(Number_$type, WorksheetReferenceExternalRowValues.$, 1, UtilitiesInt32Comparer._c);
    }
    let b = this.w._l(a);
    let c;
    if (b < 0) {
      c = new WorksheetReferenceExternalRowValues(this, a);
      this.w._item(a, c);
    }
    else {
      c = this.w._j._inner[b];
    }
    return c;
  }
  aa(a, b, c) {
    this.t(a).i(b, c);
  }
  u(a) {
    if (this.w != null) {
      let b = this.w._l(a);
      if (0 <= b) {
        return this.w._j._inner[b];
      }
    }
    return null;
  }
  get x() {
    if (this.w == null) {
      return Enumerable.k(WorksheetReferenceExternalRowValues.$);
    }
    return this.w._j;
  }
}
WorksheetReferenceExternal.$t = markType(WorksheetReferenceExternal, 'WorksheetReferenceExternal', WorksheetReferenceSingle.$);
/**
 * @hidden
 */
export class WorksheetReferenceExternalRowValues extends Base {
  constructor(a, b) {
    super();
    this.d = null;
    this.c = null;
    this.b = null;
    this.f = 0;
    this.b = a;
    this.f = b;
  }
  h(a) {
    if (this.d != null) {
      let b = this.d._l(a);
      if (0 <= b) {
        return this.d._j._inner[b];
      }
    }
    return null;
  }
  a(a) {
    if (this.c == null) {
      this.c = new SortedList$2(Number_$type, ExternalCellCalcReference.$, 1, Utilities_Int16Comparer._c);
    }
    let b = this.c._l(a);
    let c;
    if (b < 0) {
      c = new ExternalCellCalcReference(this.b, this.f, a);
      this.c._item(a, c);
    }
    else {
      c = this.c._j._inner[b];
    }
    return c;
  }
  i(a, b) {
    if (this.d == null) {
      this.d = new SortedList$2(Number_$type, Base.$, 1, Utilities_Int16Comparer._c);
    }
    this.d._item(a, b);
  }
  get e() {
    if (this.d == null) {
      return Enumerable.k(KeyValuePair$2.$.specialize(Number_$type, Base.$));
    }
    return this.d;
  }
  get g() {
    return this.f;
  }
}
WorksheetReferenceExternalRowValues.$t = markType(WorksheetReferenceExternalRowValues, 'WorksheetReferenceExternalRowValues');
/**
 * @hidden
 */
export class WorksheetReferenceLocal extends WorksheetReferenceSingle {
  constructor(a, b) {
    super(a);
    this.t = null;
    this.t = b;
  }
  get_l() {
    if (this.t == null) {
      return -1;
    }
    return this.t.index;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    if (this.t == null || this.t.workbook == null) {
      return ExcelReferenceError._a2;
    }
    return this.t._rows$i.item(a.o)._as(a.m);
  }
  b(a) {
    if (this.t == null || this.t.workbook == null) {
      return ExcelReferenceError._a2;
    }
    let b = this.t._cw(a);
    return b._c;
  }
  q(a, b) {
    let c = typeCast(WorksheetReferenceLocal.$, a);
    if (c == null) {
      return null;
    }
    return new MultiSheetCellCalcReference(this.t, c.t, b);
  }
  r(a, b) {
    let c = typeCast(WorksheetReferenceLocal.$, a);
    if (c == null) {
      return null;
    }
    return new MultiSheetRegionCalcReference(this.t, c.t, b);
  }
  c(a) {
    if (this.t == null || this.t.workbook == null) {
      return null;
    }
    return this.t.workbook._namedReferences$i._find1(a, this.t);
  }
  get_j() {
    return false;
  }
  get j() {
    return this.get_j();
  }
  get_s() {
    if (this.t == null) {
      return "#REF!";
    }
    return this.t.name;
  }
  get s() {
    return this.get_s();
  }
  get_n() {
    return this.t;
  }
  get u() {
    return this.t;
  }
}
WorksheetReferenceLocal.$t = markType(WorksheetReferenceLocal, 'WorksheetReferenceLocal', WorksheetReferenceSingle.$);
/**
 * @hidden
 */
export class WorksheetReferenceSingleUnconnected extends WorksheetReferenceSingle {
  constructor(a, ..._rest) {
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [new WorkbookReferenceUnconnected(c, false), d];
          {
            let g = e[0];
            let h = e[1];
            super(g);
            this.t = null;
            this.t = h;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          super(c);
          this.t = null;
          this.t = d;
        }
        break;
    }
  }
  g(a) {
    return a.j(this.t);
  }
  h() {
    return this;
  }
  equals(a) {
    if (Base.referenceEquals(this, a)) {
      return true;
    }
    let b = typeCast(WorksheetReferenceSingleUnconnected.$, a);
    if (b == null) {
      return false;
    }
    return Base.equalsStatic(this.e, b.e) && this.t == b.t;
  }
  get_l() {
    return 0;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    return ExcelReferenceError._a2;
  }
  b(a) {
    return ExcelReferenceError._a2;
  }
  getHashCode() {
    return Base.getHashCodeStatic(this.t);
  }
  q(a, b) {
    return ExcelReferenceError._a2;
  }
  r(a, b) {
    return ExcelReferenceError._a2;
  }
  c(a) {
    return null;
  }
  o(a, b) {
    return ExcelUtils.d6(this.e.x, this.t, null);
  }
  get_i() {
    return false;
  }
  get_j() {
    return this.e.n;
  }
  get j() {
    return this.get_j();
  }
  get_s() {
    return this.t;
  }
  get s() {
    return this.get_s();
  }
}
WorksheetReferenceSingleUnconnected.$t = markType(WorksheetReferenceSingleUnconnected, 'WorksheetReferenceSingleUnconnected', WorksheetReferenceSingle.$);
/**
 * @hidden
 */
export class WorksheetReferenceToWorkbook extends WorksheetReferenceSingle {
  constructor(a) {
    super(a);
  }
  g(a) {
    return a.i(this.l);
  }
  get_l() {
    return -2;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    return ExcelReferenceError._a2;
  }
  b(a) {
    return ExcelReferenceError._a2;
  }
  q(a, b) {
    return ExcelReferenceError._a2;
  }
  r(a, b) {
    return ExcelReferenceError._a2;
  }
  c(a) {
    return this.e.c(a, this.e.w, true);
  }
  get_i() {
    return this.e.m;
  }
  get_j() {
    return this.e.n;
  }
  get j() {
    return this.get_j();
  }
  get_s() {
    return null;
  }
  get s() {
    return this.get_s();
  }
  get_n() {
    return this.e.w;
  }
}
WorksheetReferenceToWorkbook.$t = markType(WorksheetReferenceToWorkbook, 'WorksheetReferenceToWorkbook', WorksheetReferenceSingle.$);
/**
 * @hidden
 */
export class WorksheetReferenceMulti extends WorksheetReference {
  constructor(a, b) {
    super(a.e);
    this.q = null;
    this.s = null;
    this.q = a;
    this.s = b;
  }
  g(a) {
    return a.g(this.q.s, this.s.s);
  }
  h() {
    if (this.i == false) {
      return this;
    }
    let a = null;
    let b = this.e;
    if (b != null) {
      a = b.x;
    }
    return new WorkbookReferenceUnconnected(a, false).g(this.q.s, this.s.s);
  }
  get_l() {
    return this.q.l;
  }
  get l() {
    return this.get_l();
  }
  a(a) {
    let b = this.l;
    let c = this.m;
    if (b == -1 || b == c) {
      return this.q.a(a);
    }
    return this.q.q(this.s, a);
  }
  b(a) {
    let b = this.l;
    let c = this.m;
    if (b == -1 || b == c) {
      return this.q.b(a);
    }
    return this.q.r(this.s, a);
  }
  c(a) {
    return null;
  }
  o(a, b) {
    if (this.i) {
      return this.e.ab(this.l, this.m, a, b);
    }
    return ExcelUtils.d6(this.e.x, this.q.s, this.s.s);
  }
  get_i() {
    return this.q.i;
  }
  get_j() {
    return this.q.j;
  }
  get j() {
    return this.get_j();
  }
  get_k() {
    return true;
  }
  get k() {
    return this.get_k();
  }
  get_m() {
    return this.s.l;
  }
  get_n() {
    return this.q.n;
  }
  get r() {
    return this.q;
  }
  get t() {
    return this.s;
  }
}
WorksheetReferenceMulti.$t = markType(WorksheetReferenceMulti, 'WorksheetReferenceMulti', WorksheetReference.$);
/**
 * @hidden
 */
export class WorksheetRowSerializationCache extends Base {
  constructor(a, b, c, d) {
    super();
    this.a = false;
    this.b = false;
    this.c = 0;
    this.d = 0;
    this.a = b;
    this.b = a;
    this.c = c;
    this.d = d;
  }
}
WorksheetRowSerializationCache.$t = markType(WorksheetRowSerializationCache, 'WorksheetRowSerializationCache');
/**
 * @hidden
 */
export class SheetSerializationCache extends Base {
  constructor() {
    super(...arguments);
    this.a = null;
    this.b = 0;
    this.c = 0;
    this.d = 0;
  }
}
SheetSerializationCache.$t = markType(SheetSerializationCache, 'SheetSerializationCache');
/**
 * @hidden
 */
export class WorksheetSerializationCache extends SheetSerializationCache {
  constructor(a, b, c, d, e, f, g) {
    super();
    this.n = 0;
    this.o = 0;
    this.p = 0;
    this.q = 0;
    this.e = 0;
    this.f = 0;
    this.k = 0;
    this.i = null;
    this.g = null;
    this.h = null;
    this.n = a;
    this.o = b;
    this.p = c;
    this.q = d;
    this.e = e;
    this.f = f;
    this.k = g;
    this.i = new List$1(WorksheetCellComment.$, 0);
    this.g = new Dictionary$2(Number_$type, Number_$type, 0);
    this.h = new Dictionary$2(Number_$type, Number_$type, 0);
  }
  get j() {
    return this.i;
  }
  l(a) {
    let b;
    if (((() => { let c = this.g.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return Nullable$1.toNullable(Number_$type, b);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
  m(a) {
    let b;
    if (((() => { let c = this.h.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
      return Nullable$1.toNullable(Number_$type, b);
    }
    return Nullable$1.toNullable(Number_$type, null);
  }
}
WorksheetSerializationCache.$t = markType(WorksheetSerializationCache, 'WorksheetSerializationCache', SheetSerializationCache.$);
/**
 * @hidden
 */
export let IBiffRecordStream_$type = new Type(null, 'IBiffRecordStream');
/**
 * @hidden
 */
export class ConditionalFormattingUtils extends Base {
  static g(a) {
    let b = a.formula;
    if (b == null) {
      return null;
    }
    let c = b._aa;
    if (b == null) {
      return null;
    }
    let d = new FormulaContext(4, a.worksheet, c.o, c.m, 2, b, null, 1);
    let e = FormulaStringGenerator.bj(d);
    let f = e.a2();
    return FormulaConditionalFormat._ca(f.b);
  }
  static d(a) {
    let b = "A1";
    if (stringIsNullOrEmpty(b)) {
      return null;
    }
    let c = null;
    let d = null;
    switch (a.conditionType) {
      case 9:
        c = stringFormat("LEN(TRIM({0}))=0", b);
        break;
      case 12:
        c = stringFormat("LEN(TRIM({0}))>0", b);
        break;
      case 13:
        c = stringFormat("ISERROR({0})", b);
        break;
      case 14:
        c = stringFormat("NOT(ISERROR({0}))", b);
        break;
      case 7:
      case 6:
        d = ConditionBase._a1(a.worksheet, a.regions, 1, false, false);
        let e = a.conditionType == 7 ? ">" : "=";
        c = stringFormat("AND(COUNTIF({0}, {1}){2}1,NOT(ISBLANK({1})))", d, b, e);
        break;
      case 11:
        c = stringFormat("AVERAGE({0})", b);
        break;
      default:
        c = null;
        break;
    }
    return c;
  }
  static f(a) {
    let b = "A1";
    if (stringIsNullOrEmpty(b)) {
      return null;
    }
    let c = null;
    let d = a.text != null ? a.text : stringEmpty();
    let e = a.textOperator;
    switch (e) {
      case 2:
        c = stringFormat("NOT(ISERROR(SEARCH(\"{0}\",{1})))", d, b);
        break;
      case 3:
        c = stringFormat("ISERROR(SEARCH(\"{0}\",{1}))", d, b);
        break;
      case 0:
        c = stringFormat("LEFT({1},LEN(\"{0}\"))=\"{0}\"", d, b);
        break;
      case 1:
        c = stringFormat("RIGHT({1},LEN(\"{0}\"))=\"{0}\"", d, b);
        break;
      default:
        c = null;
        break;
    }
    return c;
  }
  static e(a) {
    let b = "A1";
    if (stringIsNullOrEmpty(b)) {
      return null;
    }
    let c = null;
    switch (a.dateOperator) {
      case 2:
        c = stringFormat("FLOOR({0},1)=TODAY()-1", b);
        break;
      case 0:
        c = stringFormat("FLOOR({0},1)=TODAY()", b);
        break;
      case 1:
        c = stringFormat("FLOOR({0},1)=TODAY()+1", b);
        break;
      case 9:
        c = stringFormat("AND(MONTH({0})=MONTH(EDATE(TODAY(),0-1)),YEAR({0})=YEAR(EDATE(TODAY(),0-1)))", b);
        break;
      case 8:
        c = stringFormat("AND(MONTH({0})=MONTH(EDATE(TODAY(),0+1)),YEAR({0})=YEAR(EDATE(TODAY(),0+1)))", b);
        break;
      case 6:
        c = stringFormat("AND(TODAY()-FLOOR({0},1)<=6,FLOOR({0},1)<=TODAY())", b);
        break;
      case 5:
        c = stringFormat("AND(TODAY()-ROUNDDOWN({0},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN({0},0)<(WEEKDAY(TODAY())+7))", b);
        break;
      case 4:
        c = stringFormat("AND(ROUNDDOWN({0},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN({0},0)-TODAY()<(15-WEEKDAY(TODAY())))", b);
        break;
      case 3:
        c = stringFormat("AND(TODAY()-ROUNDDOWN({0},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN({0},0)-TODAY()<=7-WEEKDAY(TODAY()))", b);
        break;
      default:
        c = null;
        break;
    }
    return c;
  }
  static a(a) {
    return ConditionalFormattingUtils.c(a.regions);
  }
  static c(a) {
    return a.count > 0 ? ConditionalFormattingUtils.b(a.item(0)) : null;
  }
  static b(a) {
    return CellAddress.u(a.firstRow, a.firstColumn);
  }
}
ConditionalFormattingUtils.$t = markType(ConditionalFormattingUtils, 'ConditionalFormattingUtils');
/**
 * @hidden
 */
export class FullColorExtInfo extends Base {
  constructor() {
    super(...arguments);
    this.a = 0;
    this.b = 0;
    this.c = 0;
  }
}
FullColorExtInfo.$t = markType(FullColorExtInfo, 'FullColorExtInfo');
/**
 * @hidden
 */
export class GradStopInfo extends Base {
  constructor() {
    super(...arguments);
    this.a = 0;
    this.d = 0;
    this.b = 0;
    this.c = 0;
  }
}
GradStopInfo.$t = markType(GradStopInfo, 'GradStopInfo');
/**
 * @hidden
 */
export class XFExtGradientInfo extends Base {
  constructor() {
    super(...arguments);
    this.g = 0;
    this.b = 0;
    this.d = 0;
    this.e = 0;
    this.f = 0;
    this.c = 0;
    this.a = null;
  }
}
XFExtGradientInfo.$t = markType(XFExtGradientInfo, 'XFExtGradientInfo');
/**
 * @hidden
 */
export class XFPropColorInfo extends Base {
  constructor() {
    super(...arguments);
    this.b = 0;
    this.a = 0;
    this.c = 0;
    this.d = 0;
  }
}
XFPropColorInfo.$t = markType(XFPropColorInfo, 'XFPropColorInfo');
/**
 * @hidden
 */
export class ExtProp extends Base {
}
ExtProp.$t = markType(ExtProp, 'ExtProp');
/**
 * @hidden
 */
export class ExtPropColorBase extends ExtProp {
  constructor(a) {
    super();
    this.d = 0;
    this.d = a;
  }
  b(a, b) {
    let c = this.e(a._b);
    switch (this.a) {
      case 5:
      case 4:
        {
          let d = typeCast(CellFillPattern.$, b.fill);
          if (d != null) {
            let e = d._y(b);
            let f = d._aa(b);
            if (this.a == 5) {
              e = c;
            }
            else {
              f = c;
            }
            b.fill = new CellFillPattern(e, f, d.patternStyle, b, true);
          }
        }
        break;
      case 8:
        b.bottomBorderColorInfo = c;
        break;
      case 13:
        b.font.colorInfo = c;
        break;
      case 11:
        b.diagonalBorderColorInfo = c;
        break;
      case 9:
        b.leftBorderColorInfo = c;
        break;
      case 10:
        b.rightBorderColorInfo = c;
        break;
      case 7:
        b.topBorderColorInfo = c;
        break;
      default: break;
    }
  }
  get_a() {
    return this.d;
  }
  get a() {
    return this.get_a();
  }
  c(a) {
    let b;
    switch (this.a) {
      case 5:
      case 4:
        b = 1;
        break;
      case 8:
      case 11:
      case 9:
      case 10:
      case 7:
        b = 0;
        break;
      case 13:
        b = 2;
        break;
      default:
        b = 1;
        break;
    }
    a.writeFullColorExt(this.e(a.saveManager._b), b);
  }
}
ExtPropColorBase.$t = markType(ExtPropColorBase, 'ExtPropColorBase', ExtProp.$);
/**
 * @hidden
 */
export class ExtPropColor extends ExtPropColorBase {
  constructor(a, b) {
    super(b);
    this.f = null;
    this.f = a;
  }
  e(a) {
    return this.f;
  }
}
ExtPropColor.$t = markType(ExtPropColor, 'ExtPropColor', ExtPropColorBase.$);
/**
 * @hidden
 */
export class ExtPropColorLoaded extends ExtPropColorBase {
  constructor(a, b) {
    super(b);
    this.f = null;
    this.f = a;
  }
  e(a) {
    return ExcelUtils.ae(a, this.f);
  }
}
ExtPropColorLoaded.$t = markType(ExtPropColorLoaded, 'ExtPropColorLoaded', ExtPropColorBase.$);
/**
 * @hidden
 */
export class ExtPropFontScheme extends ExtProp {
  constructor(a) {
    super();
    this.d = 0;
    this.d = a;
  }
  b(a, b) {
    b._a6 = this.d;
  }
  get_a() {
    return 14;
  }
  get a() {
    return this.get_a();
  }
  c(a) {
    a.writeByte(this.d);
  }
}
ExtPropFontScheme.$t = markType(ExtPropFontScheme, 'ExtPropFontScheme', ExtProp.$);
/**
 * @hidden
 */
export class ExtPropGradientFillBase extends ExtProp {
  b(a, b) {
    b.fill = this.d(a._b);
  }
  c(a) {
    a.writeXFExtGradient(this.d(a.saveManager._b));
  }
}
ExtPropGradientFillBase.$t = markType(ExtPropGradientFillBase, 'ExtPropGradientFillBase', ExtProp.$);
/**
 * @hidden
 */
export class ExtPropGradientFill extends ExtPropGradientFillBase {
  constructor(a) {
    super();
    this.e = null;
    this.e = a;
  }
  b(a, b) {
    b.fill = this.e;
  }
  d(a) {
    return this.e;
  }
  get_a() {
    return 6;
  }
  get a() {
    return this.get_a();
  }
  c(a) {
    a.writeXFExtGradient(this.e);
  }
}
ExtPropGradientFill.$t = markType(ExtPropGradientFill, 'ExtPropGradientFill', ExtPropGradientFillBase.$);
/**
 * @hidden
 */
export class ExtPropGradientFillLoaded extends ExtPropGradientFillBase {
  constructor(a) {
    super();
    this.e = null;
    this.e = a;
  }
  d(a) {
    return ExcelUtils.k(a, this.e);
  }
  get_a() {
    return 6;
  }
  get a() {
    return this.get_a();
  }
}
ExtPropGradientFillLoaded.$t = markType(ExtPropGradientFillLoaded, 'ExtPropGradientFillLoaded', ExtPropGradientFillBase.$);
/**
 * @hidden
 */
export class ExtPropTextIndentationLevel extends ExtProp {
  constructor(a) {
    super();
    this.d = 0;
    this.d = a;
  }
  b(a, b) {
    b.indent = this.d;
  }
  get_a() {
    return 15;
  }
  get a() {
    return this.get_a();
  }
  c(a) {
    a.writeDouble(this.d);
  }
}
ExtPropTextIndentationLevel.$t = markType(ExtPropTextIndentationLevel, 'ExtPropTextIndentationLevel', ExtProp.$);
/**
 * @hidden
 */
export class XFProp extends Base {
}
XFProp.$t = markType(XFProp, 'XFProp');
/**
 * @hidden
 */
export class XFPropBool extends XFProp {
  constructor(a, ..._rest) {
    super();
    this.d = false;
    this.c = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.c = c;
          this.d = d;
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c, nullableEquals(d, true)];
          {
            let g = e[0];
            let h = e[1];
            this.c = g;
            this.d = h;
          }
        }
        break;
      case 2:
        {
          let c = _rest[0];
          let d = _rest[1];
          this.c = c;
          this.d = d == 0 ? false : true;
        }
        break;
    }
  }
  b(a, b) {
    let c = ExcelUtils.dv(this.d);
    switch (this.c) {
      case 23: break;
      case 14:
        if (this.d) {
          b.diagonalBorders |= 3;
        }
        else {
          b.diagonalBorders &= ~3;
        }
        break;
      case 13:
        if (this.d) {
          b.diagonalBorders |= 5;
        }
        else {
          b.diagonalBorders &= ~5;
        }
        break;
      case 32: break;
      case 33: break;
      case 28:
        b.font._italic$i = c;
        break;
      case 30: break;
      case 31: break;
      case 29:
        b.font._strikeout$i = c;
        break;
      case 44: break;
      case 43:
        b._locked$i = c;
        break;
      case 22:
        b._shrinkToFit$i = c;
        break;
      case 20:
        b._wrapText$i = c;
        break;
      default: break;
    }
  }
  get_a() {
    return this.c;
  }
  get a() {
    return this.get_a();
  }
  get e() {
    return this.d;
  }
  get f() {
    return (this.d ? 1 : 0);
  }
}
XFPropBool.$t = markType(XFPropBool, 'XFPropBool', XFProp.$);
/**
 * @hidden
 */
export class XFPropBorderBase extends XFProp {
  constructor(a, b) {
    super();
    this.c = 0;
    this.e = 0;
    this.c = b;
    this.e = a;
  }
  b(a, b) {
    let c = this.f(a);
    switch (this.a) {
      case 7:
        b.bottomBorderColorInfo = c;
        b.bottomBorderStyle = this.c;
        break;
      case 10:
        b.diagonalBorderColorInfo = c;
        b.diagonalBorderStyle = this.c;
        break;
      case 12: break;
      case 8:
        b.leftBorderColorInfo = c;
        b.leftBorderStyle = this.c;
        break;
      case 9:
        b.rightBorderColorInfo = c;
        b.rightBorderStyle = this.c;
        break;
      case 6:
        b.topBorderColorInfo = c;
        b.topBorderStyle = this.c;
        break;
      case 11: break;
      default: break;
    }
  }
  get_a() {
    return this.e;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropBorderBase.$t = markType(XFPropBorderBase, 'XFPropBorderBase', XFProp.$);
/**
 * @hidden
 */
export class XFPropBorder extends XFPropBorderBase {
  constructor(a, b, c) {
    super(a, c);
    this.g = null;
    this.g = b;
  }
  f(a) {
    return this.g;
  }
}
XFPropBorder.$t = markType(XFPropBorder, 'XFPropBorder', XFPropBorderBase.$);
/**
 * @hidden
 */
export class XFPropBorderLoaded extends XFPropBorderBase {
  constructor(a, b, c) {
    super(a, c);
    this.g = null;
    this.g = b;
  }
  f(a) {
    return ExcelUtils.af(a, this.g);
  }
}
XFPropBorderLoaded.$t = markType(XFPropBorderLoaded, 'XFPropBorderLoaded', XFPropBorderBase.$);
/**
 * @hidden
 */
export class XFPropByte extends XFProp {
  constructor(a, b) {
    super();
    this.c = 0;
    this.d = 0;
    this.c = a;
    this.d = b;
  }
  b(a, b) {
  }
  get_a() {
    return this.c;
  }
  get a() {
    return this.get_a();
  }
  get e() {
    return this.d;
  }
}
XFPropByte.$t = markType(XFPropByte, 'XFPropByte', XFProp.$);
/**
 * @hidden
 */
export class XFPropColorBase extends XFProp {
  b(a, b) {
    switch (this.a) {
      case 2:
      case 1: break;
      case 5:
        b.font.colorInfo = this.c(a);
        break;
      default: break;
    }
  }
}
XFPropColorBase.$t = markType(XFPropColorBase, 'XFPropColorBase', XFProp.$);
/**
 * @hidden
 */
export class XFPropColor extends XFPropColorBase {
  constructor(a, b) {
    super();
    this.e = null;
    this.d = 0;
    this.d = a;
    this.e = b;
  }
  c(a) {
    return this.e;
  }
  get_a() {
    return this.d;
  }
  get a() {
    return this.get_a();
  }
  get f() {
    return this.e;
  }
}
XFPropColor.$t = markType(XFPropColor, 'XFPropColor', XFPropColorBase.$);
/**
 * @hidden
 */
export class XFPropColorLoaded extends XFPropColorBase {
  constructor(a, b) {
    super();
    this.d = null;
    this.e = 0;
    this.e = a;
    this.d = b;
  }
  c(a) {
    return ExcelUtils.af(a, this.d);
  }
  get_a() {
    return this.e;
  }
  get a() {
    return this.get_a();
  }
}
XFPropColorLoaded.$t = markType(XFPropColorLoaded, 'XFPropColorLoaded', XFPropColorBase.$);
/**
 * @hidden
 */
export class XFPropFillPattern extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
  }
  get_a() {
    return 0;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFillPattern.$t = markType(XFPropFillPattern, 'XFPropFillPattern', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontBold extends XFProp {
  constructor(a, ..._rest) {
    super();
    this.c = false;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let t1 = c;
          L0: while (true) {
            switch (t1) {
              case 400:
                this.c = false;
                break;
              case 700:
                this.c = true;
                break;
              default:
                if (c < 400) {
                  t1 = 400;
                  continue L0;
                }
                t1 = 700;
                continue L0;
            }
            break;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          this.c = nullableEquals(c, true);
        }
        break;
    }
  }
  b(a, b) {
    b.font._bold$i = ExcelUtils.dv(this.c);
  }
  get_a() {
    return 25;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
  get e() {
    return this.c ? 700 : 400;
  }
}
XFPropFontBold.$t = markType(XFPropFontBold, 'XFPropFontBold', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontHeight extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.font.height = this.c;
  }
  get_a() {
    return 36;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFontHeight.$t = markType(XFPropFontHeight, 'XFPropFontHeight', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontName extends XFProp {
  constructor(a) {
    super();
    this.c = null;
    this.c = a;
  }
  b(a, b) {
    b.font.name = this.c;
  }
  get_a() {
    return 24;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFontName.$t = markType(XFPropFontName, 'XFPropFontName', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontSubscriptSuperscript extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.font.superscriptSubscriptStyle = this.c;
  }
  get_a() {
    return 27;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFontSubscriptSuperscript.$t = markType(XFPropFontSubscriptSuperscript, 'XFPropFontSubscriptSuperscript', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontScheme extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b._a6 = this.c;
  }
  get_a() {
    return 37;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFontScheme.$t = markType(XFPropFontScheme, 'XFPropFontScheme', XFProp.$);
/**
 * @hidden
 */
export class XFPropFontUnderline extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.font.underlineStyle = this.c;
  }
  get_a() {
    return 26;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropFontUnderline.$t = markType(XFPropFontUnderline, 'XFPropFontUnderline', XFProp.$);
/**
 * @hidden
 */
export class XFPropGradientFill extends XFProp {
  constructor(a, b, c, d, e, f) {
    super();
    this.c = false;
    this.e = 0;
    this.g = 0;
    this.h = 0;
    this.i = 0;
    this.f = 0;
    this.c = a;
    this.e = b;
    this.g = c;
    this.h = d;
    this.i = e;
    this.f = f;
  }
  b(a, b) {
  }
  get_a() {
    return 3;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
  get j() {
    return this.e;
  }
  get l() {
    return this.g;
  }
  get m() {
    return this.h;
  }
  get n() {
    return this.i;
  }
  get k() {
    return this.f;
  }
}
XFPropGradientFill.$t = markType(XFPropGradientFill, 'XFPropGradientFill', XFProp.$);
/**
 * @hidden
 */
export class XFPropGradientStopBase extends XFProp {
  constructor(a) {
    super();
    this.d = 0;
    this.d = a;
  }
  b(a, b) {
  }
  get_a() {
    return 4;
  }
  get a() {
    return this.get_a();
  }
  get e() {
    return this.d;
  }
}
XFPropGradientStopBase.$t = markType(XFPropGradientStopBase, 'XFPropGradientStopBase', XFProp.$);
/**
 * @hidden
 */
export class XFPropGradientStop extends XFPropGradientStopBase {
  constructor(a, b) {
    super(b);
    this.f = null;
    this.f = a;
  }
  c(a) {
    return this.f;
  }
}
XFPropGradientStop.$t = markType(XFPropGradientStop, 'XFPropGradientStop', XFPropGradientStopBase.$);
/**
 * @hidden
 */
export class XFPropGradientStopLoaded extends XFPropGradientStopBase {
  constructor(a, b) {
    super(b);
    this.f = null;
    this.f = a;
  }
  c(a) {
    return ExcelUtils.af(a, this.f);
  }
}
XFPropGradientStopLoaded.$t = markType(XFPropGradientStopLoaded, 'XFPropGradientStopLoaded', XFPropGradientStopBase.$);
/**
 * @hidden
 */
export class XFPropHorizontalAlignment extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.alignment = this.c;
  }
  get_a() {
    return 15;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropHorizontalAlignment.$t = markType(XFPropHorizontalAlignment, 'XFPropHorizontalAlignment', XFProp.$);
/**
 * @hidden
 */
export class XFPropNumberFormat extends XFProp {
  constructor(a, b) {
    super();
    this.e = 0;
    this.c = null;
    this.e = a;
    this.c = b;
  }
  b(a, b) {
    b.formatString = this.c;
  }
  get_a() {
    return 38;
  }
  get a() {
    return this.get_a();
  }
  get f() {
    return this.e;
  }
  get d() {
    return this.c;
  }
}
XFPropNumberFormat.$t = markType(XFPropNumberFormat, 'XFPropNumberFormat', XFProp.$);
/**
 * @hidden
 */
export class XFPropNumberFormatId extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b._cr = this.c;
  }
  get_a() {
    return 41;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropNumberFormatId.$t = markType(XFPropNumberFormatId, 'XFPropNumberFormatId', XFProp.$);
/**
 * @hidden
 */
export class XFPropTextIndentationLevel extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.indent = this.c;
  }
  get_a() {
    return 18;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropTextIndentationLevel.$t = markType(XFPropTextIndentationLevel, 'XFPropTextIndentationLevel', XFProp.$);
/**
 * @hidden
 */
export class XFPropTextIndentationLevelRelative extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.indent += this.c;
  }
  get_a() {
    return 42;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropTextIndentationLevelRelative.$t = markType(XFPropTextIndentationLevelRelative, 'XFPropTextIndentationLevelRelative', XFProp.$);
/**
 * @hidden
 */
export class XFPropTextRotation extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.rotation = this.c;
  }
  get_a() {
    return 17;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropTextRotation.$t = markType(XFPropTextRotation, 'XFPropTextRotation', XFProp.$);
/**
 * @hidden
 */
export class XFPropVerticalAlignment extends XFProp {
  constructor(a) {
    super();
    this.c = 0;
    this.c = a;
  }
  b(a, b) {
    b.verticalAlignment = this.c;
  }
  get_a() {
    return 16;
  }
  get a() {
    return this.get_a();
  }
  get d() {
    return this.c;
  }
}
XFPropVerticalAlignment.$t = markType(XFPropVerticalAlignment, 'XFPropVerticalAlignment', XFProp.$);
/**
 * @hidden
 */
export class FtCbls extends Base {
  constructor() {
    super();
    this.b = 0;
    this.c = 0;
    this.d = 0;
  }
}
FtCbls.$t = markType(FtCbls, 'FtCbls');
/**
 * @hidden
 */
export class FtCblsData extends Base {
  constructor() {
    super();
    this.c = 0;
    this.b = 0;
    this.a = false;
  }
}
FtCblsData.$t = markType(FtCblsData, 'FtCblsData');
/**
 * @hidden
 */
export class FtCf extends Base {
  constructor() {
    super();
    this.a = 65535;
  }
  get b() {
    return this.a;
  }
}
FtCf.$t = markType(FtCf, 'FtCf');
/**
 * @hidden
 */
export class FtCmo extends Base {
  constructor(a, ..._rest) {
    super();
    this.a = 0;
    this.s = 0;
    this.u = 0;
    this.w = 0;
    this.x = 0;
    this.y = 0;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          this.a = c;
          if (c == 25) {
            this.u = 16401;
          }
          else {
            this.u = 24593;
          }
        }
        break;
    }
  }
  get c() {
    return (this.u & 4) == 4;
  }
  get d() {
    return (this.u & 128) == 128;
  }
  get e() {
    return (this.u & 1) == 1;
  }
  get f() {
    return (this.u & 8) == 8;
  }
  get g() {
    return (this.u & 4) == 4;
  }
  get h() {
    return (this.u & 512) == 512;
  }
  get i() {
    return (this.u & 4096) == 4096;
  }
  get j() {
    return (this.u & 256) == 256;
  }
  get t() {
    return this.s;
  }
  set t(a) {
    this.s = a;
  }
  get b() {
    return this.a;
  }
}
FtCmo.$t = markType(FtCmo, 'FtCmo');
/**
 * @hidden
 */
export class FtEdoData extends Base {
  constructor() {
    super();
    this.d = 0;
    this.a = false;
    this.b = false;
    this.c = 0;
  }
}
FtEdoData.$t = markType(FtEdoData, 'FtEdoData');
/**
 * @hidden
 */
export class FtGboData extends Base {
  constructor() {
    super();
    this.b = 0;
    this.a = false;
  }
}
FtGboData.$t = markType(FtGboData, 'FtGboData');
/**
 * @hidden
 */
export class FtGmo extends Base {
  constructor() {
    super();
    this.b = 0;
  }
}
FtGmo.$t = markType(FtGmo, 'FtGmo');
/**
 * @hidden
 */
export class FtLbsData extends Base {
  constructor() {
    super();
    this.f = 0;
    this.d = null;
    this.g = 0;
    this.j = 0;
    this.h = 0;
    this.i = 0;
    this.c = null;
    this.b = null;
    this.a = null;
  }
  get e() {
    return this.d;
  }
}
FtLbsData.$t = markType(FtLbsData, 'FtLbsData');
/**
 * @hidden
 */
export class FtMacro extends Base {
  constructor() {
    super();
    this.b = null;
  }
  a() {
    if (this.b == null) {
      return null;
    }
    return this.b.a();
  }
  get c() {
    return this.b;
  }
}
FtMacro.$t = markType(FtMacro, 'FtMacro');
/**
 * @hidden
 */
export class FtNts extends Base {
  constructor() {
    super();
    this.a = new Guid();
    this.b = 0;
    this.d = 0;
  }
}
FtNts.$t = markType(FtNts, 'FtNts');
/**
 * @hidden
 */
export class FtPictFmla extends Base {
  constructor() {
    super();
    this.b = null;
    this.g = 0;
    this.f = 0;
    this.d = null;
  }
  a() {
    if (this.b == null) {
      return null;
    }
    return this.b.a();
  }
  get c() {
    return this.b;
  }
  get e() {
    return this.d;
  }
}
FtPictFmla.$t = markType(FtPictFmla, 'FtPictFmla');
/**
 * @hidden
 */
export class FtPioGrbit extends Base {
  constructor(a) {
    super();
    this.j = 1;
    if (!a) {
      this.j = (this.j & ~1);
    }
  }
  get a() {
    return (this.j & 512) == 512;
  }
  get b() {
    return (this.j & 1) == 1;
  }
  get c() {
    return (this.j & 128) == 128;
  }
  get d() {
    return (this.j & 16) == 16;
  }
  get e() {
    return (this.j & 2) == 2;
  }
  get f() {
    return (this.j & 256) == 256;
  }
  get g() {
    return (this.j & 8) == 8;
  }
  get i() {
    return (this.j & 32) == 32;
  }
  get h() {
    return (this.j & 4) == 4;
  }
}
FtPioGrbit.$t = markType(FtPioGrbit, 'FtPioGrbit');
/**
 * @hidden
 */
export class FtRbo extends Base {
  constructor() {
    super();
    this.c = 0;
    this.b = 0;
  }
}
FtRbo.$t = markType(FtRbo, 'FtRbo');
/**
 * @hidden
 */
export class FtRboData extends Base {
  constructor() {
    super();
    this.d = 0;
    this.a = null;
    this.c = false;
  }
  get e() {
    return this.d;
  }
  get b() {
    return this.a;
  }
  set b(a) {
    this.a = a;
  }
}
FtRboData.$t = markType(FtRboData, 'FtRboData');
/**
 * @hidden
 */
export class FtSbs extends Base {
  constructor() {
    super();
    this.j = 0;
    this.h = 0;
    this.g = 0;
    this.f = 0;
    this.a = 0;
    this.b = 0;
    this.d = 0;
    this.c = 0;
    this.e = 0;
  }
}
FtSbs.$t = markType(FtSbs, 'FtSbs');
/**
 * @hidden
 */
export class LbsDropData extends Base {
  constructor() {
    super();
    this.a = 0;
    this.c = 0;
    this.d = 0;
    this.b = null;
  }
}
LbsDropData.$t = markType(LbsDropData, 'LbsDropData');
/**
 * @hidden
 */
export class Obj extends Base {
  constructor(a, ..._rest) {
    super();
    this.d = null;
    this.h = null;
    this.c = null;
    this.p = null;
    this.a = null;
    this.r = null;
    this.u = null;
    this.m = null;
    this.k = null;
    this.n = null;
    this.v = null;
    this.b = null;
    this.s = null;
    this.f = null;
    this.i = null;
    this.g = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0: break;
      case 1:
        {
          let c = _rest[0];
          if (typeCast(WorksheetCellComment.$, c) !== null) {
            this.d = new FtCmo(1, 25);
            this.m = new FtNts();
          }
          else if (typeCast(WorksheetImage.$, c) !== null) {
            this.d = new FtCmo(1, 8);
            this.c = new FtCf();
            this.p = new FtPioGrbit(true);
          }
          else if (typeCast(WorksheetShapeGroup.$, c) !== null) {
            this.d = new FtCmo(1, 0);
            this.h = new FtGmo();
          }
          else if (typeCast(WorksheetChart.$, c) !== null) {
            this.d = new FtCmo(1, 5);
          }
          else if (typeCast(RectangleShape.$, c) !== null) {
            this.d = new FtCmo(1, 2);
          }
          else if (typeCast(LineShape.$, c) !== null) {
            this.d = new FtCmo(1, 1);
          }
          else if (typeCast(EllipseShape.$, c) !== null) {
            this.d = new FtCmo(1, 3);
          }
          else if (c._b0.hasValue && EnumUtil.isDefined(PredefinedShapeType_$type, enumGetBox(PredefinedShapeType_$type, (c._b0.value)))) {
            this.d = new FtCmo(1, 30);
          }
          else {
            this.d = new FtCmo(1, 9);
          }
        }
        break;
    }
  }
  get e() {
    return this.d;
  }
  get w() {
    return this.v;
  }
  get j() {
    return this.i;
  }
  get l() {
    return this.k;
  }
  get q() {
    return this.p;
  }
  get o() {
    return this.n;
  }
  get t() {
    return this.s;
  }
}
Obj.$t = markType(Obj, 'Obj');
/**
 * @hidden
 */
export class ObjectParsedFormula extends Base {
  constructor() {
    super();
    this.c = 0;
    this.b = null;
  }
  a() {
    if (this.b == null) {
      return null;
    }
    return this.b.b;
  }
}
ObjectParsedFormula.$t = markType(ObjectParsedFormula, 'ObjectParsedFormula');
/**
 * @hidden
 */
export class ObjFmla extends Base {
  constructor() {
    super();
    this.b = null;
    this.d = null;
  }
  a() {
    if (this.b == null) {
      return null;
    }
    return this.b.a();
  }
  f(a, b) {
    let c = this.a();
    if (c != null) {
      b(a, c);
    }
  }
  get e() {
    return this.d;
  }
  get c() {
    return this.b;
  }
}
ObjFmla.$t = markType(ObjFmla, 'ObjFmla');
/**
 * @hidden
 */
export class ObjLinkFmla extends Base {
  constructor() {
    super();
    this.a = null;
  }
  get b() {
    return this.a;
  }
}
ObjLinkFmla.$t = markType(ObjLinkFmla, 'ObjLinkFmla');
/**
 * @hidden
 */
export class PictFmlaEmbedInfo extends Base {
  constructor() {
    super();
    this.a = null;
  }
  get b() {
    return this.a;
  }
}
PictFmlaEmbedInfo.$t = markType(PictFmlaEmbedInfo, 'PictFmlaEmbedInfo');
/**
 * @hidden
 */
export class PictFmlaKey extends Base {
  constructor() {
    super();
    this.a = null;
    this.b = null;
    this.d = null;
  }
  get c() {
    return this.b;
  }
  get e() {
    return this.d;
  }
}
PictFmlaKey.$t = markType(PictFmlaKey, 'PictFmlaKey');
/**
 * @hidden
 */
export class Rgce extends Base {
  constructor() {
    super();
    this.a = null;
  }
  get b() {
    return this.a;
  }
}
Rgce.$t = markType(Rgce, 'Rgce');
/**
 * @hidden
 */
export let IEscherRecord_$type = new Type(null, 'IEscherRecord');
/**
 * @hidden
 */
export let ICalloutRule_$type = new Type(null, 'ICalloutRule', null, [IEscherRecord_$type]);
/**
 * @hidden
 */
export class PropertyTableBase_PropertyValue extends Base {
  constructor(a, ..._rest) {
    super();
    this._a = 0;
    this._e = false;
    this._c = false;
    this._h = null;
    a = (a == void 0) ? 0 : a;
    switch (a) {
      case 0:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = [c, d, false, false];
          {
            let g = e[0];
            let h = e[1];
            let i = e[2];
            let j = e[3];
            this._a = g;
            this._h = h;
            this._e = i;
            this._c = j;
          }
        }
        break;
      case 1:
        {
          let c = _rest[0];
          let d = _rest[1];
          let e = _rest[2];
          let f = _rest[3];
          this._a = c;
          this._h = d;
          this._e = e;
          this._c = f;
        }
        break;
    }
  }
  get _d() {
    return this._c;
  }
  get _f() {
    return this._e;
  }
  get _g() {
    if (this._e == false) {
      return false;
    }
    switch (this._a) {
      case 1728:
      case 1729:
      case 1284:
      case 407:
      case 341:
      case 337:
      case 338:
      case 345:
      case 342:
      case 343:
      case 326:
      case 325:
      case 899:
      case 1551:
      case 1615:
      case 1349:
      case 1487:
      case 1423:
      case 463: return true;
    }
    return false;
  }
  get _b() {
    return this._a;
  }
  get _i() {
    return this._h;
  }
  set _i(a) {
    this._h = a;
  }
  compareTo(a) {
    return this._a - a._a;
  }
}
PropertyTableBase_PropertyValue.$t = markType(PropertyTableBase_PropertyValue, 'PropertyTableBase_PropertyValue', Base.$, [IComparable$1_$type.specialize(-1)]).initSelfReferences();
/**
 * @hidden
 */
export let IValueFormatterSectionInfo_$type = new Type(null, 'IValueFormatterSectionInfo');
/**
 * @hidden
 */
export class ValueFormatter_ValueFormatterSectionInfo extends Base {
  constructor(a) {
    super();
    this.a = null;
    this.a = typeCast(ValueFormatter_FormatSection.$, a);
  }
  get color() {
    return this.a != null ? this.a.ci() : null;
  }
  get fractionDigitCount() {
    return this.a != null ? this.a.bo : 0;
  }
  get hasAnyDateParts() {
    return this.a != null && this.a.r;
  }
  get hasAnyTimeParts() {
    return this.a != null && this.a.s;
  }
  get hasParentheses() {
    return this.a != null && this.a.ad;
  }
  get hasVerbatimString() {
    return this.a != null && this.a.aj;
  }
  get isDateSection() {
    return this.b == 1;
  }
  get isNumberSection() {
    return this.b == 2;
  }
  get percentCount() {
    return this.a == null ? 0 : this.a.bx;
  }
  get b() {
    return this.a == null ? 0 : this.a.g;
  }
  get showsGroupSeparators() {
    return this.a != null && this.a.az;
  }
}
ValueFormatter_ValueFormatterSectionInfo.$t = markType(ValueFormatter_ValueFormatterSectionInfo, 'ValueFormatter_ValueFormatterSectionInfo', Base.$, [IValueFormatterSectionInfo_$type]);
/**
 * @hidden
 */
export class CalcArgumentHelper extends Base {
  static a(a, b, c, d) {
    let e = a.getLength(0);
    let f = a.getLength(1);
    for (let g = 0; g < e; g++) {
      for (let h = 0; h < f; h++) {
        let i = a.item(g, h);
        let j = CalcArgumentHelper.c(i, b, c, d);
        if (j != null) {
          return j;
        }
      }
    }
    return null;
  }
  static c(a, b, c, d) {
    if (a.isReference && (0 != (c & 1) || (!a.isArray && !a.isArrayGroup))) {
      let e = a.toReference();
      if (e.isEnumerable) {
        for (let f of fromEn(e.references)) {
          if (0 != (c & 4098) && ExcelCalcFunction._q(f, 0 != (c & 4096), 0 != (c & 2))) {
            continue;
          }
          if (0 != (c & 2048) && ExcelCalcFunction._u(f)) {
            continue;
          }
          let g = CalcArgumentHelper.c(f.value, 2, c, d);
          if (g != null) {
            return g;
          }
        }
        return null;
      }
      else {
        if (0 != (c & 4098) && ExcelCalcFunction._q(e, 0 != (c & 4096), 0 != (c & 2))) {
          return null;
        }
        if (0 != (c & 2048) && ExcelCalcFunction._u(e)) {
          return null;
        }
        return CalcArgumentHelper.c(e.value, 2, c, d);
      }
    }
    else if (a.isArrayGroup) {
      let h = a.toArrayProxyGroup();
      let i = a.isReference ? 2 : 1;
      for (let j = 0; j < h.length; j++) {
        let k = CalcArgumentHelper.a(h[j], i, c, d);
        if (k != null) {
          return k;
        }
      }
      return null;
    }
    else if (a.isArray) {
      return CalcArgumentHelper.a(a.toArrayProxy(), a.isReference ? 2 : 1, c, d);
    }
    else {
      return CalcArgumentHelper.b(a, b, c, d);
    }
  }
  static b(a, b, c, d) {
    if (a.isString) {
      if (b == 1 && 0 != (c & 1024)) {
        return null;
      }
      if (b == 2 && 0 != (c & 4)) {
        return null;
      }
      if (b != 0 && 0 != (c & 32)) {
        d(0);
      }
      else {
        let e;
        if (((() => { let f = a._toDouble1(e); e = f.p0; return f.ret; })())) {
          d(e);
        }
        else {
          if (0 == (c & 256)) {
            if (0 != (c & 512)) {
              d(0);
            }
            else {
              return new ExcelCalcValue(new ExcelCalcErrorValue(1));
            }
          }
        }
      }
    }
    else if (a.isNull) {
      if (0 == (c & 1) || b != 2) {
        if (0 != (c & 128)) {
          d(0);
        }
      }
    }
    else if (a.isBoolean) {
      if (0 != (c & 8) && b != 0) {
        return null;
      }
      if (0 != (c & 64) && b == 1) {
        return null;
      }
      d(a._toBoolean1() ? 1 : 0);
    }
    else if (a.isError) {
      if (0 == (c & 256)) {
        if (0 != (c & 512)) {
          d(0);
        }
        else {
          return new ExcelCalcValue(a.toErrorValue());
        }
      }
    }
    else {
      d(a._toDouble3());
    }
    return null;
  }
  static e(a, b, c) {
    let d = a.count;
    for (let e = 0; e < d; e++) {
      let f = CalcArgumentHelper.c(a.item(e), 0, b, c);
      if (f != null) {
        return f;
      }
    }
    return null;
  }
  static d(a, b, c, d) {
    let e = CalcFunctionUtilities.p(b);
    try {
      for (let f = 0; f < b; f++) {
        e.add(a.pop());
      }
      for (let g = 1; g <= b; g++) {
        let h = e._inner[b - g];
        let i = CalcArgumentHelper.c(h, 0, c, d);
        if (i != null) {
          return i;
        }
      }
      return null;
    }
    finally {
      CalcFunctionUtilities.ad(e);
    }
  }
}
CalcArgumentHelper.$t = markType(CalcArgumentHelper, 'CalcArgumentHelper');
/**
 * @hidden
 */
export class CalcFunctionUtilities extends Base {
  static h(a, b, c) {
    let d = a.pop();
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (!b && d.isBoolean) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let e;
    if (!((() => { let f = d._toDouble1(e); e = f.p0; return f.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return c(e);
  }
  static j(a, b, c) {
    let d = a.pop();
    let e = a.pop();
    if (e.isError) {
      return new ExcelCalcValue(e.toErrorValue());
    }
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (!b && (e.isBoolean || d.isBoolean)) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let f, g;
    if (!((() => { let h = e._toDouble1(f); f = h.p0; return h.ret; })()) || !((() => { let h = d._toDouble1(g); g = h.p0; return h.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return c(f, g);
  }
  static i(a, b, c) {
    let d = a.pop();
    let e = a.pop();
    let f = a.pop();
    if (f.isError) {
      return new ExcelCalcValue(f.toErrorValue());
    }
    if (e.isError) {
      return new ExcelCalcValue(e.toErrorValue());
    }
    if (d.isError) {
      return new ExcelCalcValue(d.toErrorValue());
    }
    if (!b && (f.isBoolean || e.isBoolean || d.isBoolean)) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    let g, h, i;
    if (!((() => { let j = f._toDouble1(g); g = j.p0; return j.ret; })()) || !((() => { let j = e._toDouble1(h); h = j.p0; return j.ret; })()) || !((() => { let j = d._toDouble1(i); i = j.p0; return j.ret; })())) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1));
    }
    return c(g, h, i);
  }
  static p(a) {
    if (CalcFunctionUtilities.n == null) {
      CalcFunctionUtilities.n = new List$1(List$1.$.specialize(ExcelCalcValue.$), 2, 10);
    }
    let b;
    if (CalcFunctionUtilities.n.count > 0) {
      let c = CalcFunctionUtilities.n.count - 1;
      b = CalcFunctionUtilities.n._inner[c];
      CalcFunctionUtilities.n.removeAt(c);
    }
    else {
      b = new List$1(ExcelCalcValue.$, 2, a);
    }
    return b;
  }
  static ad(a) {
    if (CalcFunctionUtilities.n == null) {
      CalcFunctionUtilities.n = new List$1(List$1.$.specialize(ExcelCalcValue.$), 2, 10);
    }
    if (CalcFunctionUtilities.n.count < 10) {
      a.clear();
      CalcFunctionUtilities.n.add(a);
    }
  }
  static o(a) {
    if (CalcFunctionUtilities.m == null) {
      CalcFunctionUtilities.m = new List$1(List$1.$.specialize(Number_$type), 2, 10);
    }
    let b;
    if (CalcFunctionUtilities.m.count > 0) {
      let c = CalcFunctionUtilities.m.count - 1;
      b = CalcFunctionUtilities.m._inner[c];
      CalcFunctionUtilities.m.removeAt(c);
    }
    else {
      b = new List$1(Number_$type, 2, a);
    }
    return b;
  }
  static ac(a) {
    if (CalcFunctionUtilities.m == null) {
      CalcFunctionUtilities.m = new List$1(List$1.$.specialize(Number_$type), 2, 10);
    }
    if (CalcFunctionUtilities.m.count < 10) {
      a.clear();
      CalcFunctionUtilities.m.add(a);
    }
  }
  static e(a, b, c) {
    let d = CalcFunctionUtilities.o(a.count);
    let e = CalcArgumentHelper.e(a, b, runOn(d, d.add));
    if (e == null) {
      e = c(d);
    }
    CalcFunctionUtilities.ac(d);
    return e;
  }
  static d(a, b, c, d) {
    let e;
    let f = CalcFunctionUtilities.o(b);
    try {
      e = CalcFunctionUtilities.f(a, b, c, runOn(f, f.add));
      if (e == null) {
        e = d(f);
      }
    }
    finally {
      CalcFunctionUtilities.ac(f);
    }
    return e;
  }
  static f(a, b, c, d) {
    if (a != null && a._r != null && a._r.dateSystem == 1) {
      c |= 16;
    }
    return CalcArgumentHelper.d(a, b, c, d);
  }
  static g(a, b, c) {
    return CalcArgumentHelper.e(a, b, c);
  }
  static l(a, b) {
    let c = 0;
    let d = CalcArgumentHelper.e(a, b, (e) => c++);
    if (d == null) {
      d = new ExcelCalcValue(c);
    }
    return d;
  }
  static k(a, b, c) {
    if (a != null && a._r != null && a._r.dateSystem == 1) {
      c |= 16;
    }
    let d = 0;
    let e = CalcArgumentHelper.d(a, b, c, (f) => d++);
    if (e == null) {
      e = new ExcelCalcValue(d);
    }
    return e;
  }
  static c(a, b, c, d) {
    return CalcFunctionUtilities.a(b ? 673 : 1485, a, c, d);
  }
  static b(a, b, c, d) {
    return CalcFunctionUtilities.a(b ? 1249 : 1229, a, c, d);
  }
  static a(a, b, c, d) {
    if (c) {
      a |= 4096;
    }
    if (d) {
      a |= 2;
    }
    if (b != null && b._r != null && b._r.dateSystem == 1) {
      a |= 16;
    }
    return a;
  }
  static q(a) {
    let b = 0;
    for (let c = 0; c < a.count; c++) {
      b += a._inner[c];
    }
    return b / a.count;
  }
  static r(a) {
    let b = CalcFunctionUtilities.z(a);
    let c = CalcFunctionUtilities.t(a.count, b);
    return CalcFunctionUtilities.s(a, c);
  }
  static s(a, b) {
    let c = 0;
    for (let d = 0; d < a.count; d++) {
      let e = a._inner[d] - b;
      c += e * e;
    }
    return c;
  }
  static t(a, b) {
    return b / a;
  }
  static u(a, b, c) {
    return Math.exp(-0.5 * (a - b) * (a - b) / (c * c)) / (CalcFunctionUtilities.w * c);
  }
  static v(a) {
    if (a.count == 0) {
      return 0;
    }
    let b = 1;
    for (let c = 0; c < a.count; c++) {
      b *= a._inner[c];
    }
    return b;
  }
  static x(a) {
    return Math.exp(-0.5 * a * a) / CalcFunctionUtilities.w;
  }
  static y(a, b, c) {
    let d = b;
    if (c) {
      d -= 1;
    }
    return Math.sqrt(a / d);
  }
  static z(a) {
    let b = 0;
    for (let c = 0; c < a.count; c++) {
      b += a._inner[c];
    }
    return b;
  }
  static ab(a, b) {
    let c = CalcFunctionUtilities.r(a);
    let d = a.count;
    if (b) {
      d -= 1;
    }
    return c / d;
  }
}
CalcFunctionUtilities.$t = markType(CalcFunctionUtilities, 'CalcFunctionUtilities');
CalcFunctionUtilities.w = Math.sqrt(6.2831853071795862);
CalcFunctionUtilities.n = null;
CalcFunctionUtilities.m = null;
/**
 * @hidden
 */
export class CalcDateUtilities extends Base {
  static c(a, b, c) {
    switch (c) {
      default:
      case 0:
      case 2:
      case 4: return 360;
      case 3: return 365;
      case 1:
        {
          let d = a.getDate();
          let e = dateGetMonth(a);
          let f = a.getFullYear();
          let g = b.getDate();
          let h = dateGetMonth(b);
          let i = b.getFullYear();
          if (f == i) {
            return CalcDateUtilities.b(f) ? 366 : 365;
          }
          else if (((i - 1) == f) && ((e > h) || ((e == h) && d >= g))) {
            if (CalcDateUtilities.b(f)) {
              return (e < 2 || (e == 2 && d <= 29)) ? 366 : 365;
            }
            else if (CalcDateUtilities.b(i)) {
              return (h > 2 || (h == 2 && g == 29)) ? 366 : 365;
            }
            else {
              return 365;
            }
          }
          else {
            let j = 0;
            for (let k = f; k <= i; k++) {
              j += CalcDateUtilities.b(k) ? 366 : 365;
            }
            return j / (i - f + 1);
          }
        }
    }
  }
  static e(a, b, c, d, e, f) {
    return ((b - a) * 360) + ((d - c) * 30) + (f - e);
  }
  static f(a, b, c) {
    a = dateGetDate(a);
    b = dateGetDate(b);
    switch (c) {
      case 0: return CalcDateUtilities.h(a, b);
      case 4: return CalcDateUtilities.g(a, b);
      default: return truncate(MathUtilities.f(timeSpanTotalDays((+(dateGetDate(b)) - +(dateGetDate(a))))));
    }
  }
  static g(a, b) {
    let c = a.getDate();
    let d = dateGetMonth(a);
    let e = a.getFullYear();
    let f = b.getDate();
    let g = dateGetMonth(b);
    let h = b.getFullYear();
    if (c == 31) {
      c = 30;
    }
    if (f == 31) {
      f = 30;
    }
    return CalcDateUtilities.e(e, h, d, g, c, f);
  }
  static h(a, b) {
    let c = a.getDate();
    let d = dateGetMonth(a);
    let e = a.getFullYear();
    let f = b.getDate();
    let g = dateGetMonth(b);
    let h = b.getFullYear();
    if ((g == 2 && CalcDateUtilities.a(f, g, h)) && (d == 2 && CalcDateUtilities.a(c, d, e))) {
      f = 30;
    }
    if (f == 31 && c >= 30) {
      f = 30;
    }
    if (c == 31) {
      c = 30;
    }
    if (d == 2 && CalcDateUtilities.a(c, d, e)) {
      c = 30;
    }
    return CalcDateUtilities.e(e, h, d, g, c, f);
  }
  static a(a, b, c) {
    switch (b) {
      case 2: return CalcDateUtilities.b(c) ? a == 29 : a == 28;
      case 4:
      case 6:
      case 9:
      case 11: return a == 30;
      default: return a == 31;
    }
  }
  static b(a) {
    return (a % 4) == 0 && ((a % 100) != 0 || (a % 400) == 0);
  }
  static d(a, b, c) {
    if (a > b) {
      let d = b;
      b = a;
      a = d;
    }
    return CalcDateUtilities.f(a, b, c) / CalcDateUtilities.c(a, b, c);
  }
}
CalcDateUtilities.$t = markType(CalcDateUtilities, 'CalcDateUtilities');
/**
 * @hidden
 */
export class CustomExcelCalcFunction extends ExcelCalcFunction {
  constructor(a, b, c, d) {
    super();
    this._an = null;
    this._am = 0;
    this._al = 0;
    this._ak = null;
    this._an = a;
    this._am = b;
    this._al = c;
    this._ak = d;
    this._ae();
  }
  get_name() {
    return this._an != null ? this._an : "";
  }
  get name() {
    return this.get_name();
  }
  get_minArgs() {
    return this._am;
  }
  get minArgs() {
    return this.get_minArgs();
  }
  get_maxArgs() {
    return this._al;
  }
  get maxArgs() {
    return this.get_maxArgs();
  }
  evaluate(a, b) {
    try {
      return this._ak(a, b);
    }
    catch (c) {
      return new ExcelCalcValue(new ExcelCalcErrorValue(1, c.toString()));
    }
  }
}
CustomExcelCalcFunction.$t = markType(CustomExcelCalcFunction, 'CustomExcelCalcFunction', ExcelCalcFunction.$);
/**
 * @hidden
 */
export class CalcManagerUtilities extends Base {
  static c(a, b, c) {
    return SilverlightFixes.e(SilverlightFixes.a(a), b, c);
  }
  static b(a, b, c) {
    return SilverlightFixes.e(a, b, c);
  }
  static e(a, b, c, d, e) {
    return SilverlightFixes.q(SilverlightFixes.a(a), b, c, d, e);
  }
  static d(a, b, c, d, e) {
    return SilverlightFixes.q(a, b, c, d, e);
  }
  static f(a) {
  }
  static g(a, b) {
  }
  static a(a) {
    return EnumUtil.getValues(a);
  }
}
CalcManagerUtilities.$t = markType(CalcManagerUtilities, 'CalcManagerUtilities');
callStaticConstructors();
//# sourceMappingURL=excel.core.js.map
