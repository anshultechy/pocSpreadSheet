/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ValueType, markEnum, Type, Base, Nullable$1, Stream, Boolean_$type, typeCast, Point_$type, EnumUtil, markType, BaseError, Number_$type, fromEnum, String_$type, markStruct, callStaticConstructors, Date_$type, getBoxIfEnum, NotSupportedException, runOn, enumGetBox, getInstanceType, Array_$type, fromEn, typeGetValue } from "../../igniteui-angular-core/ES2015/type";
import { CT_GroupTransform2D, ST_Angle, CT_Transform2D, CT_Point2D, ST_CoordinateUnqualified, ST_Coordinate, CT_PositiveSize2D, ST_PositiveCoordinate, ImageData, ImageFormat, RoundTripControlData, WorkItem, WorkItemExtensions, Async, BinaryData, ST_CellType_$type, DocCoreUtils, ST_IconSetType_$type, ProtectionValidationInfo, WorkItemScheduler, OleDataSpaces, ST_FilterOperator_$type, ST_ShapeType_$type, IPackageRelationship_$type, UriUtilities } from "./documents.core";
import { WorksheetShapeGroup, WorksheetShape, ExcelUtils, ImageHolder, ExcelImage, SystemColorsInternal, ColorsInternal, WorkbookColorInfo, Workbook, WorksheetCellAddress, Worksheet, FillPatternStyle_$type, MathUtilities, WorkbookColorTransform, WorkbookFontData, WorkbookSaveManager, WorkbookLoadManager, WorkbookThemeColorType_$type, NamedReference, Excel2007ChartData, WorksheetCellFormatData, WorkbookStyle, WorkbookBuiltInStyle, WorkbookStyleCollection, WorkbookFormatCollection, CellFill, CellFillPattern, CellFillGradient, ExternalWorkbookReference, SingleTargetFormula, Formula, WorkbookReferenceBase, ReferenceToken, FormattedStringElement, FormattedStringRun, StringElement, WorkbookFontProxy, FormulaParser, KnownBoxes, FormattedString, Sheet, IWorkbookFont_$type, IWorkbookFontDefaultsResolver_$type, CellFillLinearGradient, CellFillRectangularGradient, CellFillGradientStop, Filter, CustomFilterCondition, CustomFilter, WorksheetTable, SortCondition, WorksheetTableColumn, WorksheetRegionAddress, WorksheetRegion, FillFilter, FontColorFilter, FixedValuesFilter, FixedDateGroup, DynamicValuesFilter, IconFilter, FillSortCondition, FontColorSortCondition, IconSortCondition, OrderedSortCondition, CustomListSortCondition, WorksheetTableStyle, TopOrBottomFilter, ArrayFormula, DateRangeFilter, AverageFilter, ExcelCalcValue, WorksheetTableArea_$type, WorksheetTableColumnArea_$type, IColorFilter_$type, ConditionBase, FormatConditionOperator_$type, FormatConditionTextOperator_$type, IconSetConditionalFormat, IconCriterion, DataValidationRule, WorksheetCell, ILegacyShapeData_$type, WorksheetCellComment, CellAddress, OperatorConditionalFormat, FormulaConditionalFormat, RankConditionalFormat, AverageConditionalFormat, UniqueConditionalFormat, DuplicateConditionalFormat, BlanksConditionalFormat, NoBlanksConditionalFormat, ErrorsConditionalFormat, NoErrorsConditionalFormat, TextOperatorConditionalFormat, DateTimeConditionalFormat, ColorScaleConditionalFormat, DataBarConditionalFormat, ConditionalFormatBase, CellReferenceMode_$type, ConditionValue, ConditionValueInfo, SparklineGroup, Sparkline, WorksheetRow, PrintOptions, HorizontalPageBreakCollection, VerticalPageBreakCollection, HorizontalPageBreak, VerticalPageBreak, UnknownShape, CustomViewCollection, CustomView, DisplayOptions, ListDataValidationRule, AnyValueDataValidationRule, CustomDataValidationRule, TwoConstraintDataValidationRule, OneConstraintDataValidationRule, WorksheetReferenceCollection, FormulaContext, WorksheetColumnFilter, PrintOptionsBase, WorksheetHyperlink, WorksheetCellBlock, WorksheetProtectedRange, WorksheetPaneSelection, RelativeIndex, WorksheetDataTable, CalcUtilities, WorksheetShapeGroupBase, StringElementIndex, ErrorValue, WorksheetColumnBlock, PivotTableInfo, WorksheetMergedCellsRegion, WorksheetChart, OleLinkWorkbookReference, PaperSize_$type, BuiltInStyleInfo, WorksheetTableStyleArea_$type, StandardTableStyleCollection, WorkbookLoadOptions, WorkbookOptionsBase, FormulaTokenVisitor, WorkbookFormat_$type, GetFormulaStringInfo, XLSXFormulaStringGenerator, DisplayUnit_$type, IWorksheetImage_$type, CategoryType_$type, SeriesValues, ErrorBars, ChartGradientFill, GradientStop, ChartSolidFill, ChartEmptyFill, ChartGridLines, ChartTickLines, SeriesValuesBase, XValues, SeriesName, Legend, ChartBorder, LegendEntry, Axis, ChartLineBase, ChartLine, Series, ChartTitle, DisplayUnitLabel, BorderLineStyle_$type, TextHorizontalOverflow_$type, TextVerticalOverflow_$type, VerticalTitleAlignment_$type, ChartDeserializationCache, CategoryAxisBinning, BoxAndWhiskerSettings, ChartSeriesLines, LeaderLines, ChartHighLowLines, ChartDropLines, UpDownBars, SeriesDataLabels, DataPoint, Trendline, TrendlineLabel, DataLabel, AxisGroup_$type, ChartType_$type, MarkerStyle_$type, GeographicMapSettings, GeographicMapColors, ComboChartGroup, TrendlineLine, DataLabelPosition_$type, GeographicMapProjection_$type, GeographicMappingArea_$type, AxisCrosses_$type, BarShape_$type, ConditionalFormattingUtils, Chartsheet, DocumentProperties, ShapeFill, ShapeOutline, WorksheetImage, WorksheetShapeWithText, FormattedTextParagraph, FormattedTextRun, FormattedText, RectangleShape, ShapeFillSolid, ShapeOutlineSolid, HorizontalTextAlignment_$type, ShapeFillImage, PredefinedShapeType_$type, ShapeFillNoFill, IShapeFillVisitor$2_$type, IShapeOutlineVisitor$2_$type, UltimateFontDefaultsResolver, DdeLinkWorkbookReference, WorksheetReferenceExternalRowValues, DdeItem, WorksheetReferenceExternal, OleItem, PivotCacheInfo, CurrentWorkbookReference, WorksheetShapeVisitor$2 } from "./excel.core";
import { MemoryStream } from "../../igniteui-angular-core/ES2015/MemoryStream";
import { CT_Marker, ST_HorizontalAlignment_$type, ST_PatternType_$type, ST_SystemColorVal_$type, ST_VerticalAlignment_$type, ST_PresetColorVal_$type, ColorTransform_Alpha, CT_Angle, CT_PositiveFixedAngle, ColorTransform_LumMod, ST_PositiveFixedAngle, ColorTransform_LumOff, ST_Percentage, CT_Percentage, ST_FixedPercentage, CT_FixedPercentage, ST_PositivePercentage, CT_PositivePercentage, ColorTransform_Shade, CT_PositiveFixedPercentage, ST_PositiveFixedPercentage, IEG_ColorTransformVisitor$2_$type, CT_SchemeColor, CT_SRgbColor, ST_HexColorRGB, CT_SysColor, CT_BlipFillProperties, CT_GroupFillProperties, CT_NoFillProperties, CT_SolidFillProperties, IEG_ColorChoiceVisitor$2_$type, IEG_FillPropertiesVisitor$2_$type, ST_UnsignedIntHex, ExcelDocumentManager, Office2007ExtensibilityPartManager, Office2010ExtensibilityPartManager, ImagePartManagerBase, PngPartManager, JpegPartManager, GifPartManager, TiffPartManager, EmfPartManager, WmfPartManager, BmpPartManager, PartManagerBase, CT_AbsoluteAnchor, CT_TwoCellAnchor, SpreadsheetMLMain, EG_Anchor, DrawingMLSpreadsheetDrawing, CT_AnchorClientData, CT_OneCellAnchor, ST_OnOff, TablePartManager, SpreadsheetML2009Main, ST_CfType_$type, ST_ConditionalFormattingOperator_$type, ST_TimePeriod_$type, ST_DataBarDirection_$type, ST_DataBarAxisPosition_$type, IEG_AnchorVisitor$2_$type, ST_CF_$type, ST_InsetMode_$type, CommentsPartManager, ST_Guid, Excel2006Main, XmlNamespaceDefinitionBase, AttributeValue, WorksheetPartManager, PackageUtilities, ST_UnsignedShortHex, AlternateContentChoice, VmlNamespace, ST_ConformanceClass_$type, ActiveXPartManager, ExcelStylesPartManager, PackageFactory, WorkbookPartManagerBase, Package, ISupportSetProperty_$type, DrawingMLChart, CT_ComplementTransform, CT_GrayscaleTransform, CT_InverseTransform, CT_StretchInfoProperties, CT_RelativeRect, CT_LineJoinBevel, CT_DashStopList, CT_LineEndProperties, CT_LinePropertiesBase, CT_LineJoinMiterProperties, CT_PresetLineDashProperties, CT_LineJoinRound, CT_DashStop, ST_TileFlipMode_$type, ST_RectAlignment_$type, ST_TextVertOverflowType_$type, ST_TextHorzOverflowType_$type, ST_TextVerticalType_$type, ST_TextWrappingType_$type, ST_TextAnchoringType_$type, ST_ObjectType_$type, ST_DataValidationType_$type, ST_DataValidationErrorStyle_$type, ST_DataValidationImeMode_$type, ST_DataValidationOperator_$type, ST_CfvoType_$type, CT_Slicer, ST_FontScheme_$type, ST_UnderlineValues_$type, ST_VerticalAlignRun_$type, ST_GradientType_$type, ST_BorderStyle_$type, CT_TextFont, DrawingMLMain, CT_NonVisualDrawingProps, CT_NonVisualDrawingShapeProps, CT_ShapeStyle, CT_NonVisualConnectorProperties, CT_NonVisualPictureProperties, CT_NonVisualGraphicFrameProperties, CT_GraphicalObject, CT_NonVisualGroupDrawingShapeProps, CT_GroupShapeProperties, ISaveToXLSX_$type, ST_PresetPatternVal_$type, CT_GeomGuide, ST_BlackWhiteMode_$type, CT_CustomGeometry2D, CT_PresetGeometry2D, CT_FontReference, CT_TileInfoProperties, CT_BlipFillPropertiesBase, CT_TextCharacterPropertiesBase, CT_Hyperlink, ST_TextFontSize, ST_TextPoint, ST_TextUnderlineType_$type, ST_TextStrikeType_$type, ST_TextCapsType_$type, CT_Blip, ST_BlipCompression_$type, ST_LineWidth, ST_PenAlignment_$type, ST_LineCap_$type, ST_CompoundLine_$type, ST_SchemeColorVal_$type, CT_TextParagraphProperties, ST_Coordinate32, ST_TextIndent, ST_TextIndentLevelType, ST_TextMargin, ST_TextAlignType_$type, ST_TextFontAlignType_$type, CT_StyleMatrixReference, CT_EmbeddedWAVAudioFile, CT_GeomRect, ST_AdjCoordinate, CT_ConnectionSite, ST_AdjAngle, CT_AdjPoint2D, CT_Path2D, CT_PolarAdjustHandle, ST_GeomGuideName, CT_XYAdjustHandle, CT_Path2DArcTo, ST_LineEndLength_$type, ST_LineEndType_$type, ST_LineEndWidth_$type, ST_PresetLineDashVal_$type, OfficeDocumentRelationships, ST_PathFillMode_$type, CT_GeomGuideList, CT_AdjustHandleList, CT_ConnectionSiteList, CT_Path2DList, CT_RelId, ST_Orientation_$type, DrawingMLChart2012, DrawingMLChart2014, DrawingMLChartEx2015_9_8, DrawingMLChartEx2015_10_21, DrawingMLChartEx2016_5_10, CT_ShapeNonVisual, CT_Shape, CT_GroupShape, CT_Connector, CT_Picture, ST_FontCollectionIndex_$type, ST_Coordinate32Unqualified, ST_TextPointUnqualified, CT_ShapeProperties, CT_Path2DClose, CT_Path2DMoveTo, CT_Path2DLineTo, CT_Path2DQuadBezierTo, CT_Path2DCubicBezierTo, CT_TextListStyle, ST_StrokeJoinStyle_$type, ST_ConnectType_$type, ST_Ext_$type, ChartExPartManager, ChartsheetPartManager, ActiveXBinaryPartManager, RoundTripDataPartManager, CalcChainPartManager, ChartColorStylePartManager, ChartPartManager, ChartStylePartManager, ChartUserShapePartManager, ConnectionsPartManager, CorePropertiesPartManager, CoreProperties, DcElements, DcTerms, CtrlPropPartManager, CustomXmlItemPartManager, CustomXmlItemPropsPartManager, DrawingPartManager, DrawingPartManagerHelpers, CT_ConnectorNonVisual, ST_DrawingElementId, CT_LineProperties, CT_GraphicalObjectFrame, CT_GraphicalObjectData, Drawing2010Slicer, CT_GraphicalObjectFrameNonVisual, Drawing2010Main, CT_GroupShapeNonVisual, CT_PictureNonVisual, CT_PictureLocking, CT_TextBody, CT_TextParagraph, CT_RegularTextRun, CT_TextBodyProperties, CT_TextCharacterProperties, AlternateGraphicalObjectContent, MarkupCompatibility2006, IEG_FillProperties_$type, IGraphicalObjectContent_$type, IGraphicalObjectContentVisitor$2_$type, IEG_TextRunVisitor$2_$type, IEG_LineFillPropertiesVisitor$2_$type, IEG_GeometryVisitor$2_$type, ExtendedPropertiesPartManager, OfficeDocumentDocPropsVTypes, CT_Vector, OfficeDocumentExtendedProperties, ExternalLinkPartManager, PivotCacheDefinitionPartManager, PivotCacheRecordsPartManager, PivotTablePartManager, PrinterSettingsPartManager, SharedStringsPartManager, SlicerCachePartManager, SlicerPartManager, ThemeManagerPartManager, IGOfficeExtensions, ThemePartManager, VbaProjectPartManager, VmlDrawingPartManager, ExcelNamespace, OfficeNamespace, EmptyNamespace, ST_ShadowType_$type, ST_HrAlign_$type, ST_ConnectorType_$type, ST_BWMode_$type, ST_StrokeLineStyle_$type } from "./documents.openxml";
import { Color } from "../../igniteui-angular-core/ES2015/Color";
import { Tuple$2 } from "../../igniteui-angular-core/ES2015/Tuple$2";
import { Tuple } from "../../igniteui-angular-core/ES2015/Tuple";
import { wrapNullable, nullableEquals, nullableNotEquals, unwrapNullable, nullableLessThan, nullableIsNull, nullableDivide } from "../../igniteui-angular-core/ES2015/nullable";
import { stringStartsWith, stringIsNullOrEmpty, stringEmpty, stringReplace, stringConcat, stringContains, stringIsNullOrWhiteSpace, stringJoin1, stringRemove } from "../../igniteui-angular-core/ES2015/string";
import { Convert } from "../../igniteui-angular-core/ES2015/Convert";
import { truncate, isNaN_, intDivide, tryParseNumber } from "../../igniteui-angular-core/ES2015/number";
import { List$1 } from "../../igniteui-angular-core/ES2015/List$1";
import { intSToU, u32BitwiseAnd, tryParseInt32_1, tryParseNumber1, parseNumber, intToString1, u32BitwiseOr, numberToString, parseInt32_1, parseUInt32_1, intToString, tryParseUInt32_2, parseUInt8_1, parseInt64_1, parseUInt16_1, parseInt8_1 } from "../../igniteui-angular-core/ES2015/numberExtended";
import { StringComparer } from "../../igniteui-angular-core/ES2015/StringComparer";
import { Dictionary$2 } from "../../igniteui-angular-core/ES2015/Dictionary$2";
import { HashSet$1 } from "../../igniteui-angular-core/ES2015/HashSet$1";
import { Uri } from "../../igniteui-angular-core/ES2015/Uri";
import { Guid } from "../../igniteui-angular-core/ES2015/Guid";
import { InvalidOperationException } from "../../igniteui-angular-core/ES2015/InvalidOperationException";
import { stringFormat, stringCompare3, stringInsert, stringSplit, stringEquals1 } from "../../igniteui-angular-core/ES2015/stringExtended";
import { NotImplementedException } from "../../igniteui-angular-core/ES2015/NotImplementedException";
import { CultureInfo } from "../../igniteui-angular-core/ES2015/culture";
import { dateParse } from "../../igniteui-angular-core/ES2015/dateExtended";
import { KeyValuePair$2 } from "../../igniteui-angular-core/ES2015/KeyValuePair$2";
import { dateGetMonth, dateNow } from "../../igniteui-angular-core/ES2015/date";
import { StringBuilder } from "../../igniteui-angular-core/ES2015/StringBuilder";
import { IComparer$1_$type } from "../../igniteui-angular-core/ES2015/IComparer$1";
import { Regex } from "../../igniteui-angular-core/ES2015/Regex";
import { Enumerable } from "../../igniteui-angular-core/ES2015/Enumerable";
import { IOPath } from "../../igniteui-angular-core/ES2015/IOPath";
import { Environment } from "../../igniteui-angular-core/ES2015/Environment";
import { StreamReader } from "../../igniteui-angular-core/ES2015/StreamReader";
import { Encoding } from "../../igniteui-angular-core/ES2015/Encoding";
import * as Pako from "pako";
/**
 * @hidden
 */
export let CompressionMode_$type = markEnum('CompressionMode', 'Decompress,0|Compress,1');
/**
 * @hidden
 */
export let SparklinesDeserializer_ContextFlags_$type = markEnum('SparklinesDeserializer_ContextFlags', 'None,0|Sparklines,1');
/**
 * For internal use only.
 */
export var OpenPackagingNonConformanceReason;
(function (OpenPackagingNonConformanceReason) {
    /**
     * The IPackage.GetPart method threw an exception.
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["CouldNotGetPackagePart"] = -1] = "CouldNotGetPackagePart";
    /**
     * The IPackagePart conforms fully to the ECMA TC45 Open Packaging Conventions.
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["Conformant"] = 0] = "Conformant";
    /**
     * The package implementer shall require a part name. [M1.1]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameMissing"] = 1] = "NameMissing";
    /**
     * The package implementer shall require a content type and
     * the format designer shall specify the content type. [M1.2], [M1.13]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeMissing"] = 2] = "ContentTypeMissing";
    /**
     * A part name shall not have empty segments. [M1.3]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentEmpty"] = 3] = "SegmentEmpty";
    /**
     * A part name shall start with a forward slash (“/”) character. [M1.4]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameDoesNotStartWithForwardSlash"] = 4] = "NameDoesNotStartWithForwardSlash";
    /**
     * A part name shall not have a forward slash as the last character. [M1.5]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameEndsWithForwardSlash"] = 5] = "NameEndsWithForwardSlash";
    /**
     * A segment shall not hold any characters other than pchar characters. [M1.6]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasNonPCharCharacters"] = 6] = "SegmentHasNonPCharCharacters";
    /**
     * A segment shall not contain percent-encoded forward slash (“/”),
     * or backward slash (“\”) characters. [M1.7]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasPercentEncodedSlashCharacters"] = 7] = "SegmentHasPercentEncodedSlashCharacters";
    /**
     * A segment shall not contain percent-encoded unreserved characters. [M1.8]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasPercentEncodedUnreservedCharacters"] = 8] = "SegmentHasPercentEncodedUnreservedCharacters";
    /**
     * A segment shall not end with a dot (“.”) character. [M1.9]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentEndsWithDotCharacter"] = 9] = "SegmentEndsWithDotCharacter";
    /**
     * A segment shall include at least one non-dot character. [M1.10]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentMissingNonDotCharacter"] = 10] = "SegmentMissingNonDotCharacter";
    /**
     * A package implementer shall neither create nor recognize
     * a part with a part name derived from another part name by
     * appending segments to it. [M1.11]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameDerivesFromExistingPartName"] = 11] = "NameDerivesFromExistingPartName";
    /**
     * Part name equivalence is determined by comparing part names as
     * case-insensitive ASCII strings. Packages shall not contain equivalent
     * part names and package implementers shall neither create nor recognize
     * packages with equivalent part names. [M1.12]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["DuplicateName"] = 12] = "DuplicateName";
    /**
     * IPackage implementers shall only create and only recognize parts with a content type;
     * format designers shall specify a content type for each part included in the format.
     * Content types for package parts shall fit the definition and syntax for media types
     * as specified in RFC 2616, §3.7. [M1.13]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasInvalidSyntax"] = 13] = "ContentTypeHasInvalidSyntax";
    /**
     * Content types shall not use linear white space either between the type and subtype or
     * between an attribute and its value. Content types also shall not have leading or
     * trailing white spaces. IPackage implementers shall create only such content types
     * and shall require such content types when retrieving a part from a package;
     * format designers shall specify only such content types for inclusion in the format. [M1.14]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasInvalidWhitespace"] = 14] = "ContentTypeHasInvalidWhitespace";
    /**
     * The package implementer shall require a content type that does not include comments
     * and the format designer shall specify such a content type. [M1.15]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasComments"] = 15] = "ContentTypeHasComments";
    /**
     * IPackage implementers and format designers shall not create content types
     * with parameters for the package specific parts defined in this Open Packaging
     * specification and shall treat the presence of parameters in these content types
     * as an error. [M1.22]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasParameters"] = 16] = "ContentTypeHasParameters";
    /**
     * If the package implementer specifies a growth hint, it is set when a
     * part is created and the package implementer shall not change the growth
     * hint after the part has been created. [M1.16]
     * <p class="body">The PackageConformanceManager does not verify this convention.</p>
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["GrowthHintChanged"] = 17] = "GrowthHintChanged";
    /**
     * XML content shall be encoded using either UTF-8 or UTF-16.
     * If any part includes an encoding declaration, as defined in
     * §4.3.3 of the XML 1.0 specification, that declaration shall
     * not name any encoding other than UTF-8 or UTF-16. IPackage
     * implementers shall enforce this requirement upon creation
     * and retrieval of the XML content. [M1.17]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlEncodingUnsupported"] = 18] = "XmlEncodingUnsupported";
    /**
     * XML content shall be valid against the corresponding XSD schema defined
     * in this Open Packaging specification. In particular, the XML content shall
     * not contain elements or attributes drawn from namespaces that are not explicitly
     * defined in the corresponding XSD unless the XSD allows elements or attributes drawn
     * from any namespace to be present in particular locations in the XML markup. IPackage
     * implementers  shall enforce this requirement upon creation and retrieval of the
     * XML content. [M1.20]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlContentInvalidForSchema"] = 19] = "XmlContentInvalidForSchema";
    /**
     * XML content shall not contain elements or attributes drawn from “xml” or “xsi”
     * namespaces unless they are explicitly defined in the XSD schema or by other means
     * described in this Open Packaging specification. IPackage implementers shall enforce
     * this requirement upon creation and retrieval of the XML content. [M1.21]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlContentDrawsOnUndefinedNamespace"] = 20] = "XmlContentDrawsOnUndefinedNamespace";
    /**
     * The Relationships part shall not have relationships to any other part. IPackage
     * implementers shall enforce this requirement upon the attempt to create such a
     * relationship and shall treat any such relationship as invalid. [M1.25]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetsOtherRelationship"] = 21] = "RelationshipTargetsOtherRelationship";
    /**
     * The package implementer shall require that every Relationship element
     * has an Id attribute, the value of which is unique within the Relationships
     * part, and that the Id type is xsd:ID, the value of which conforms to the naming
     * restrictions for xsd:IDas described in the W3C Recommendation “XML Schema Part 2:
     * Datatypes.” [M1.26]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipIdInvalid"] = 22] = "RelationshipIdInvalid";
    /**
     * The package implementer shall require the Type attribute to be a URI
     * that defines the role of the relationship and the format designer shall
     * specify such a Type. [M1.27]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTypeInvalid"] = 23] = "RelationshipTypeInvalid";
    /**
     * The package implementer shall require the Target attribute to be a URI
     * reference pointing to a target resource. The URI reference shall be a URI
     * or a relative reference. [M1.28]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetInvalid"] = 24] = "RelationshipTargetInvalid";
    /**
     * When set to Internal, the Target attribute shall be a relative reference and
     * that reference is interpreted relative to the “parent” part. For package
     * relationships, the package implementer shallresolve relative references in
     * the Target attribute against the pack URI that identifies the entire package
     * resource. [M1.29]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetNotRelativeReference"] = 25] = "RelationshipTargetNotRelativeReference";
    /**
     * The package implementer shall name relationship parts according to the special
     * relationships part naming convention and require that parts with names that
     * conform to this naming convention have the content type for a Relationships
     * part. [M1.30]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipNameInvalid"] = 26] = "RelationshipNameInvalid";
})(OpenPackagingNonConformanceReason || (OpenPackagingNonConformanceReason = {}));
/**
 * @hidden
 */
export let OpenPackagingNonConformanceReason_$type = markEnum('OpenPackagingNonConformanceReason', 'CouldNotGetPackagePart,-1|Conformant,0|NameMissing,1|ContentTypeMissing,2|SegmentEmpty,3|NameDoesNotStartWithForwardSlash,4|NameEndsWithForwardSlash,5|SegmentHasNonPCharCharacters,6|SegmentHasPercentEncodedSlashCharacters,7|SegmentHasPercentEncodedUnreservedCharacters,8|SegmentEndsWithDotCharacter,9|SegmentMissingNonDotCharacter,10|NameDerivesFromExistingPartName,11|DuplicateName,12|ContentTypeHasInvalidSyntax,13|ContentTypeHasInvalidWhitespace,14|ContentTypeHasComments,15|ContentTypeHasParameters,16|GrowthHintChanged,17|XmlEncodingUnsupported,18|XmlContentInvalidForSchema,19|XmlContentDrawsOnUndefinedNamespace,20|RelationshipTargetsOtherRelationship,21|RelationshipIdInvalid,22|RelationshipTypeInvalid,23|RelationshipTargetInvalid,24|RelationshipTargetNotRelativeReference,25|RelationshipNameInvalid,26');
/**
 * @hidden
 */
export let X14Serialization_$type = markEnum('X14Serialization', 'None,0|X14Only,1|Both,2');
/**
 * @hidden
 */
export let ST_ColorStyleMethodEnum_$type = markEnum('ST_ColorStyleMethodEnum', 'cycle,0|withinLinear,1|acrossLinear,2|withinLinearReversed,3|acrossLinearReversed,4');
/**
 * @hidden
 */
export let ST_StyleReferenceModifierEnum_$type = markEnum('ST_StyleReferenceModifierEnum', 'ignoreCSTransforms,0');
/**
 * @hidden
 */
export let ST_StyleColorEnum_$type = markEnum('ST_StyleColorEnum', 'auto,0');
/**
 * @hidden
 */
export let ST_StyleEntryModifierEnum_$type = markEnum('ST_StyleEntryModifierEnum', 'allowNoFillOverride,0|allowNoLineOverride,1');
/**
 * @hidden
 */
export let ST_PageOrientation_$type = markEnum('ST_PageOrientation', '_default,0|portrait,1|landscape,2');
/**
 * @hidden
 */
export let ST_SidePos_$type = markEnum('ST_SidePos', 'l,0|t,1|r,2|b,3');
/**
 * @hidden
 */
export let ST_PosAlign_$type = markEnum('ST_PosAlign', 'min,0|ctr,1|max,2');
/**
 * @hidden
 */
export let ST_TickMarksType_$type = markEnum('ST_TickMarksType', '_in,0|_out,1|cross,2|none,3');
/**
 * @hidden
 */
export let ST_FormulaDirection_$type = markEnum('ST_FormulaDirection', 'col,0|row,1');
/**
 * @hidden
 */
export let ST_AxisUnit_$type = markEnum('ST_AxisUnit', 'hundreds,0|thousands,1|tenThousands,2|hundredThousands,3|millions,4|tenMillions,5|hundredMillions,6|billions,7|trillions,8|percentage,9');
/**
 * @hidden
 */
export let ST_QuartileMethod_$type = markEnum('ST_QuartileMethod', 'inclusive,0|exclusive,1');
/**
 * @hidden
 */
export let ST_EntityType_$type = markEnum('ST_EntityType', 'Address,0|AdminDistrict,1|AdminDistrict2,2|AdminDistrict3,3|Continent,4|CountryRegion,5|Locality,6|Ocean,7|Planet,8|PostalCode,9|Region,10|Unsupported,11');
/**
 * @hidden
 */
export let ST_GeoProjectionType_$type = markEnum('ST_GeoProjectionType', 'mercator,0|miller,1|robinson,2|albers,3');
/**
 * @hidden
 */
export let ST_GeoMappingLevel_$type = markEnum('ST_GeoMappingLevel', 'dataOnly,0|postalCode,1|county,2|state,3|countryRegion,4|countryRegionList,5|world,6');
/**
 * @hidden
 */
export let ST_IntervalClosedSide_$type = markEnum('ST_IntervalClosedSide', 'l,0|r,1');
/**
 * @hidden
 */
export let ST_RegionLabelLayout_$type = markEnum('ST_RegionLabelLayout', 'none,0|bestFitOnly,1|showAll,2');
/**
 * @hidden
 */
export let ST_ParentLabelLayout_$type = markEnum('ST_ParentLabelLayout', 'none,0|banner,1|overlapping,2');
/**
 * @hidden
 */
export let ST_DataLabelPos_$type = markEnum('ST_DataLabelPos', 'bestFit,0|b,1|ctr,2|inBase,3|inEnd,4|l,5|outEnd,6|r,7|t,8');
/**
 * @hidden
 */
export let ST_SeriesLayout_$type = markEnum('ST_SeriesLayout', 'boxWhisker,0|clusteredColumn,1|funnel,2|paretoLine,3|regionMap,4|sunburst,5|treemap,6|waterfall,7');
/**
 * @hidden
 */
export let ST_StringDimensionType_$type = markEnum('ST_StringDimensionType', 'cat,0|colorStr,1');
/**
 * @hidden
 */
export let ST_NumericDimensionType_$type = markEnum('ST_NumericDimensionType', 'val,0|x,1|y,2|size,3|colorVal,4');
/**
 * @hidden
 */
export let ST_PageSetupOrientation_$type = markEnum('ST_PageSetupOrientation', 'default:$default,0|portrait,1|landscape,2');
/**
 * @hidden
 */
export let ST_LegendPos_$type = markEnum('ST_LegendPos', 'b,0|tr,1|l,2|r,3|t,4');
/**
 * @hidden
 */
export let ST_LayoutTarget_$type = markEnum('ST_LayoutTarget', 'inner,0|outer,1');
/**
 * @hidden
 */
export let ST_LayoutMode_$type = markEnum('ST_LayoutMode', 'edge,0|factor,1');
/**
 * @hidden
 */
export let ST_AxPos_$type = markEnum('ST_AxPos', 'b,0|l,1|r,2|t,3');
/**
 * @hidden
 */
export let ST_TickMark_$type = markEnum('ST_TickMark', 'cross,0|in:$in,1|none,2|out,3');
/**
 * @hidden
 */
export let ST_TickLblPos_$type = markEnum('ST_TickLblPos', 'high,0|low,1|nextTo,2|none,3');
/**
 * @hidden
 */
export let ST_Crosses_$type = markEnum('ST_Crosses', 'autoZero,0|max,1|min,2');
/**
 * @hidden
 */
export let ST_TimeUnit_$type = markEnum('ST_TimeUnit', 'days,0|months,1|years,2');
/**
 * @hidden
 */
export let ST_LblAlgn_$type = markEnum('ST_LblAlgn', 'ctr,0|l,1|r,2');
/**
 * @hidden
 */
export let ST_BuiltInUnit_$type = markEnum('ST_BuiltInUnit', 'hundreds,0|thousands,1|tenThousands,2|hundredThousands,3|millions,4|tenMillions,5|hundredMillions,6|billions,7|trillions,8');
/**
 * @hidden
 */
export let ST_CrossBetween_$type = markEnum('ST_CrossBetween', 'between,0|midCat,1');
/**
 * @hidden
 */
export let ST_SizeRepresents_$type = markEnum('ST_SizeRepresents', 'area,0|w,1');
/**
 * @hidden
 */
export let ST_PictureFormat_$type = markEnum('ST_PictureFormat', 'stretch,0|stack,1|stackScale,2');
/**
 * @hidden
 */
export let ST_DLblPos_$type = markEnum('ST_DLblPos', 'bestFit,0|b,1|ctr,2|inBase,3|inEnd,4|l,5|outEnd,6|r,7|t,8');
/**
 * @hidden
 */
export let ST_TrendlineType_$type = markEnum('ST_TrendlineType', 'exp,0|linear,1|log,2|movingAvg,3|poly,4|power,5');
/**
 * @hidden
 */
export let ST_ErrDir_$type = markEnum('ST_ErrDir', 'x,0|y,1');
/**
 * @hidden
 */
export let ST_ErrBarType_$type = markEnum('ST_ErrBarType', 'both,0|minus,1|plus,2');
/**
 * @hidden
 */
export let ST_ErrValType_$type = markEnum('ST_ErrValType', 'cust,0|fixedVal,1|percentage,2|stdDev,3|stdErr,4');
/**
 * @hidden
 */
export let ST_SplitType_$type = markEnum('ST_SplitType', 'auto,0|cust,1|percent,2|pos,3|val,4');
/**
 * @hidden
 */
export let ST_OfPieType_$type = markEnum('ST_OfPieType', 'pie,0|bar,1');
/**
 * @hidden
 */
export let ST_BarDir_$type = markEnum('ST_BarDir', 'bar,0|col,1');
/**
 * @hidden
 */
export let ST_BarGrouping_$type = markEnum('ST_BarGrouping', 'percentStacked,0|clustered,1|standard,2|stacked,3');
/**
 * @hidden
 */
export let ST_Shape_$type = markEnum('ST_Shape', 'cone,0|coneToMax,1|box,2|cylinder,3|pyramid,4|pyramidToMax,5');
/**
 * @hidden
 */
export let ST_ScatterStyle_$type = markEnum('ST_ScatterStyle', 'none,0|line,1|lineMarker,2|marker,3|smooth,4|smoothMarker,5');
/**
 * @hidden
 */
export let ST_RadarStyle_$type = markEnum('ST_RadarStyle', 'standard,0|marker,1|filled,2');
/**
 * @hidden
 */
export let ST_Grouping_$type = markEnum('ST_Grouping', 'percentStacked,0|standard,1|stacked,2');
/**
 * @hidden
 */
export let ItemsChoiceType_$type = markEnum('ItemsChoiceType', 'close,0|moveTo,1|lnTo,2|arcTo,3|quadBezTo,4|cubicBezTo,5');
/**
 * @hidden
 */
export let ST_TextTabAlignType_$type = markEnum('ST_TextTabAlignType', 'l,0|ctr,1|r,2|dec,3');
/**
 * @hidden
 */
export let ST_TextAutonumberScheme_$type = markEnum('ST_TextAutonumberScheme', 'alphaLcParenBoth,0|alphaUcParenBoth,1|alphaLcParenR,2|alphaUcParenR,3|alphaLcPeriod,4|alphaUcPeriod,5|arabicParenBoth,6|arabicParenR,7|arabicPeriod,8|arabicPlain,9|romanLcParenBoth,10|romanUcParenBoth,11|romanLcParenR,12|romanUcParenR,13|romanLcPeriod,14|romanUcPeriod,15|circleNumDbPlain,16|circleNumWdBlackPlain,17|circleNumWdWhitePlain,18|arabicDbPeriod,19|arabicDbPlain,20|ea1ChsPeriod,21|ea1ChsPlain,22|ea1ChtPeriod,23|ea1ChtPlain,24|ea1JpnChsDbPeriod,25|ea1JpnKorPlain,26|ea1JpnKorPeriod,27|arabic1Minus,28|arabic2Minus,29|hebrew2Minus,30|thaiAlphaPeriod,31|thaiAlphaParenR,32|thaiAlphaParenBoth,33|thaiNumPeriod,34|thaiNumParenR,35|thaiNumParenBoth,36|hindiAlphaPeriod,37|hindiNumPeriod,38|hindiNumParenR,39|hindiAlpha1Period,40');
/**
 * @hidden
 */
export let ST_OnOffStyleType_$type = markEnum('ST_OnOffStyleType', 'on,0|off,1|def,2');
/**
 * @hidden
 */
export let ST_TextShapeType_$type = markEnum('ST_TextShapeType', 'textNoShape,0|textPlain,1|textStop,2|textTriangle,3|textTriangleInverted,4|textChevron,5|textChevronInverted,6|textRingInside,7|textRingOutside,8|textArchUp,9|textArchDown,10|textCircle,11|textButton,12|textArchUpPour,13|textArchDownPour,14|textCirclePour,15|textButtonPour,16|textCurveUp,17|textCurveDown,18|textCanUp,19|textCanDown,20|textWave1,21|textWave2,22|textDoubleWave1,23|textWave4,24|textInflate,25|textDeflate,26|textInflateBottom,27|textDeflateBottom,28|textInflateTop,29|textDeflateTop,30|textDeflateInflate,31|textDeflateInflateDeflate,32|textFadeRight,33|textFadeLeft,34|textFadeUp,35|textFadeDown,36|textSlantUp,37|textSlantDown,38|textCascadeUp,39|textCascadeDown,40');
/**
 * @hidden
 */
export let ST_PresetShadowVal_$type = markEnum('ST_PresetShadowVal', 'shdw1,0|shdw2,1|shdw3,2|shdw4,3|shdw5,4|shdw6,5|shdw7,6|shdw8,7|shdw9,8|shdw10,9|shdw11,10|shdw12,11|shdw13,12|shdw14,13|shdw15,14|shdw16,15|shdw17,16|shdw18,17|shdw19,18|shdw20,19');
/**
 * @hidden
 */
export let ST_PathShadeType_$type = markEnum('ST_PathShadeType', 'shape,0|circle,1|rect,2');
/**
 * @hidden
 */
export let ST_BlendMode_$type = markEnum('ST_BlendMode', 'over,0|mult,1|screen,2|darken,3|lighten,4');
/**
 * @hidden
 */
export let ST_EffectContainerType_$type = markEnum('ST_EffectContainerType', 'sib,0|tree,1');
/**
 * @hidden
 */
export let ST_BevelPresetType_$type = markEnum('ST_BevelPresetType', 'relaxedInset,0|circle,1|slope,2|cross,3|angle,4|softRound,5|convex,6|coolSlant,7|divot,8|riblet,9|hardEdge,10|artDeco,11');
/**
 * @hidden
 */
export let ST_PresetMaterialType_$type = markEnum('ST_PresetMaterialType', 'legacyMatte,0|legacyPlastic,1|legacyMetal,2|legacyWireframe,3|matte,4|plastic,5|metal,6|warmMatte,7|translucentPowder,8|powder,9|dkEdge,10|softEdge,11|clear,12|flat,13|softmetal,14');
/**
 * @hidden
 */
export let ST_LightRigDirection_$type = markEnum('ST_LightRigDirection', 'tl,0|t,1|tr,2|l,3|r,4|bl,5|b,6|br,7');
/**
 * @hidden
 */
export let ST_LightRigType_$type = markEnum('ST_LightRigType', 'legacyFlat1,0|legacyFlat2,1|legacyFlat3,2|legacyFlat4,3|legacyNormal1,4|legacyNormal2,5|legacyNormal3,6|legacyNormal4,7|legacyHarsh1,8|legacyHarsh2,9|legacyHarsh3,10|legacyHarsh4,11|threePt,12|balanced,13|soft,14|harsh,15|flood,16|contrasting,17|morning,18|sunrise,19|sunset,20|chilly,21|freezing,22|flat,23|twoPt,24|glow,25|brightRoom,26');
/**
 * @hidden
 */
export let ST_PresetCameraType_$type = markEnum('ST_PresetCameraType', 'legacyObliqueTopLeft,0|legacyObliqueTop,1|legacyObliqueTopRight,2|legacyObliqueLeft,3|legacyObliqueFront,4|legacyObliqueRight,5|legacyObliqueBottomLeft,6|legacyObliqueBottom,7|legacyObliqueBottomRight,8|legacyPerspectiveTopLeft,9|legacyPerspectiveTop,10|legacyPerspectiveTopRight,11|legacyPerspectiveLeft,12|legacyPerspectiveFront,13|legacyPerspectiveRight,14|legacyPerspectiveBottomLeft,15|legacyPerspectiveBottom,16|legacyPerspectiveBottomRight,17|orthographicFront,18|isometricTopUp,19|isometricTopDown,20|isometricBottomUp,21|isometricBottomDown,22|isometricLeftUp,23|isometricLeftDown,24|isometricRightUp,25|isometricRightDown,26|isometricOffAxis1Left,27|isometricOffAxis1Right,28|isometricOffAxis1Top,29|isometricOffAxis2Left,30|isometricOffAxis2Right,31|isometricOffAxis2Top,32|isometricOffAxis3Left,33|isometricOffAxis3Right,34|isometricOffAxis3Bottom,35|isometricOffAxis4Left,36|isometricOffAxis4Right,37|isometricOffAxis4Bottom,38|obliqueTopLeft,39|obliqueTop,40|obliqueTopRight,41|obliqueLeft,42|obliqueRight,43|obliqueBottomLeft,44|obliqueBottom,45|obliqueBottomRight,46|perspectiveFront,47|perspectiveLeft,48|perspectiveRight,49|perspectiveAbove,50|perspectiveBelow,51|perspectiveAboveLeftFacing,52|perspectiveAboveRightFacing,53|perspectiveContrastingLeftFacing,54|perspectiveContrastingRightFacing,55|perspectiveHeroicLeftFacing,56|perspectiveHeroicRightFacing,57|perspectiveHeroicExtremeLeftFacing,58|perspectiveHeroicExtremeRightFacing,59|perspectiveRelaxed,60|perspectiveRelaxedModerately,61');
/**
 * @hidden
 */
export let ST_AnimationBuildType_IGEXT_$type = markEnum('ST_AnimationBuildType_IGEXT', 'allAtOnce,0|one,1|lvlOne,2|lvlAtOnce,3');
/**
 * @hidden
 */
export let ST_ChartBuildStep_$type = markEnum('ST_ChartBuildStep', 'category,0|ptInCategory,1|series,2|ptInSeries,3|allPts,4|gridLegend,5');
/**
 * @hidden
 */
export let ST_DgmBuildStep_$type = markEnum('ST_DgmBuildStep', 'sp,0|bg,1');
/**
 * @hidden
 */
export let ST_AnimationBuildType_$type = markEnum('ST_AnimationBuildType', 'allAtOnce,0');
/**
 * @hidden
 */
export let ST_AnimationDgmOnlyBuildType_$type = markEnum('ST_AnimationDgmOnlyBuildType', 'one,0|lvlOne,1|lvlAtOnce,2');
/**
 * @hidden
 */
export let ST_AnimationChartOnlyBuildType_$type = markEnum('ST_AnimationChartOnlyBuildType', 'series,0|category,1|seriesEl,2|categoryEl,3');
/**
 * @hidden
 */
export let ST_ColorSchemeIndex_$type = markEnum('ST_ColorSchemeIndex', 'dk1,0|lt1,1|dk2,2|lt2,3|accent1,4|accent2,5|accent3,6|accent4,7|accent5,8|accent6,9|hlink,10|folHlink,11');
/**
 * @hidden
 */
export let ST_PivotAreaType_$type = markEnum('ST_PivotAreaType', 'none,0|normal,1|data,2|all,3|origin,4|button,5|topRight,6');
/**
 * @hidden
 */
export let ST_Axis_$type = markEnum('ST_Axis', 'axisRow,0|axisCol,1|axisPage,2|axisValues,3');
/**
 * @hidden
 */
export let ST_DdeValueType_$type = markEnum('ST_DdeValueType', 'nil,0|b,1|n,2|e,3|str,4');
/**
 * @hidden
 */
export let ST_Type_$type = markEnum('ST_Type', 'none,0|all,1|row,2|column,3');
/**
 * @hidden
 */
export let ST_Scope_$type = markEnum('ST_Scope', 'selection,0|data,1|field,2');
/**
 * @hidden
 */
export let ST_TabularSlicerCacheSortOrder_$type = markEnum('ST_TabularSlicerCacheSortOrder', 'ascending,0|descending,1');
/**
 * @hidden
 */
export let ST_SlicerCacheCrossFilter_$type = markEnum('ST_SlicerCacheCrossFilter', 'none,0|showItemsWithDataAtTop,1|showItemsWithNoData,2');
/**
 * @hidden
 */
export let ST_Checked_$type = markEnum('ST_Checked', 'Unchecked,0|Checked,1|Mixed,2');
/**
 * @hidden
 */
export let ST_DropStyle_$type = markEnum('ST_DropStyle', 'combo,0|comboedit,1|simple,2');
/**
 * @hidden
 */
export let ST_SelType_$type = markEnum('ST_SelType', 'single,0|multi,1|extended,2');
/**
 * @hidden
 */
export let ST_TextHAlign_$type = markEnum('ST_TextHAlign', 'left,0|center,1|right,2|justify,3|distributed,4');
/**
 * @hidden
 */
export let ST_TextVAlign_$type = markEnum('ST_TextVAlign', 'top,0|center,1|bottom,2|justify,3|distributed,4');
/**
 * @hidden
 */
export let ST_EditValidation_$type = markEnum('ST_EditValidation', 'text,0|integer,1|number,2|reference,3|formula,4');
/**
 * @hidden
 */
export let ST_SlicerStyleType_$type = markEnum('ST_SlicerStyleType', 'unselectedItemWithData,0|selectedItemWithData,1|unselectedItemWithNoData,2|selectedItemWithNoData,3|hoveredUnselectedItemWithData,4|hoveredSelectedItemWithData,5|hoveredUnselectedItemWithNoData,6|hoveredSelectedItemWithNoData,7');
/**
 * @hidden
 */
export let ST_PivotEditValueType_$type = markEnum('ST_PivotEditValueType', 'number,0|dateTime,1|string:string1,2|boolean:boolean1,3|error,4');
/**
 * @hidden
 */
export let ST_AllocationMethod_$type = markEnum('ST_AllocationMethod', 'equalAllocation,0|equalIncrement,1|weightedAllocation,2|weightedIncrement,3');
/**
 * @hidden
 */
export let ST_PivotShowAs_$type = markEnum('ST_PivotShowAs', 'percentOfParent,0|percentOfParentRow,1|percentOfParentCol,2|percentOfRunningTotal,3|rankAscending,4|rankDescending,5');
/**
 * @hidden
 */
export let ST_SparklineType_$type = markEnum('ST_SparklineType', 'line,0|column,1|stacked,2');
/**
 * @hidden
 */
export let ST_SparklineAxisMinMax_$type = markEnum('ST_SparklineAxisMinMax', 'individual,0|group,1|custom,2');
/**
 * @hidden
 */
export let ST_OlapSlicerCacheSortOrder_$type = markEnum('ST_OlapSlicerCacheSortOrder', 'natural,0|ascending,1|descending,2');
/**
 * @hidden
 */
export let ElementNamespaceContext_$type = markEnum('ElementNamespaceContext', 'None,0|DML,1|SML,2|Chart,3');
/**
 * @hidden
 */
export let ST_MarkerStyle_$type = markEnum('ST_MarkerStyle', 'none,0|circle,1|dash,2|diamond,3|dot,4|plus,5|picture,6|square,7|star,8|triangle,9|x,10');
/**
 * @hidden
 */
export let ST_DispBlanksAs_$type = markEnum('ST_DispBlanksAs', 'span,0|gap,1|zero,2');
/**
 * @hidden
 */
export let XlsxUtilities_ColorTransformsApplicator_ColorChannelHSL_$type = markEnum('XlsxUtilities_ColorTransformsApplicator_ColorChannelHSL', 'H,0|S,1|L,2');
/**
 * @hidden
 */
export let XlsxUtilities_ColorTransformsApplicator_ColorChannelRGB_$type = markEnum('XlsxUtilities_ColorTransformsApplicator_ColorChannelRGB', 'A,0|R,1|G,2|B,3');
/**
 * @hidden
 */
export class XlsxUtilities extends Base {
    static af(a) {
        let b = a._getBoundsInTwips();
        return ((() => {
            let $ret = new CT_GroupTransform2D();
            $ret.j = Nullable$1.toNullable(ST_Angle.$, ST_Angle.a(a._b6));
            $ret.i = Nullable$1.toNullable(Boolean_$type, a.flippedHorizontally);
            $ret.k = Nullable$1.toNullable(Boolean_$type, a.flippedVertically);
            $ret.a = ((() => {
                let $ret = new CT_Point2D();
                $ret.a = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.x)));
                $ret.b = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.y)));
                return $ret;
            })());
            $ret.b = ((() => {
                let $ret = new CT_PositiveSize2D();
                $ret.a = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.width));
                $ret.b = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.height));
                return $ret;
            })());
            $ret.l = ((() => {
                let $ret = new CT_Point2D();
                $ret.a = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.x)));
                $ret.b = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.y)));
                return $ret;
            })());
            $ret.m = ((() => {
                let $ret = new CT_PositiveSize2D();
                $ret.a = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.width));
                $ret.b = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.height));
                return $ret;
            })());
            return $ret;
        })());
    }
    static ag(a) {
        let b = a._getBoundsInTwips();
        return ((() => {
            let $ret = new CT_Transform2D();
            $ret.j = Nullable$1.toNullable(ST_Angle.$, ST_Angle.a(a._b6));
            $ret.i = Nullable$1.toNullable(Boolean_$type, a.flippedHorizontally);
            $ret.k = Nullable$1.toNullable(Boolean_$type, a.flippedVertically);
            $ret.a = ((() => {
                let $ret = new CT_Point2D();
                $ret.a = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.x)));
                $ret.b = new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.y)));
                return $ret;
            })());
            $ret.b = ((() => {
                let $ret = new CT_PositiveSize2D();
                $ret.a = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.width));
                $ret.b = new ST_PositiveCoordinate(1, ExcelUtils.dm(b.height));
                return $ret;
            })());
            return $ret;
        })());
    }
    static u(a) {
        let b = typeCast(ImageHolder.$, a.e);
        if (b == null) {
            {
                let c = new MemoryStream(2, a.b);
                try {
                    b = XlsxUtilities.v(c, a.d);
                }
                finally {
                    if (c != null) {
                        c.dispose();
                    }
                }
            }
            a.e = b;
        }
        return b;
    }
    static v(a, b) {
        let c = new ExcelImage(1, b, a);
        return new ImageHolder(c, b);
    }
    static a(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 1;
        }
    }
    static f(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 10: return 10;
            case 11: return 11;
            case 12: return 12;
            case 13: return 13;
            default: return 10;
        }
    }
    static b(a) {
        switch (a) {
            case 9: return 9;
            case 11: return 11;
            case 3: return 3;
            case 4: return 4;
            case 6: return 6;
            case 7: return 7;
            case 2: return 2;
            case 10: return 10;
            case 12: return 12;
            case 8: return 8;
            case 0: return 0;
            case 13: return 13;
            case 5: return 5;
            case 1: return 1;
            default: return 0;
        }
    }
    static c(a) {
        switch (a) {
            case 0: return 1;
            case 1: return 0;
            default: return 1;
        }
    }
    static d(a) {
        switch (a) {
            case 2: return 2;
            case 0: return 0;
            case 1: return 1;
            default: return 2;
        }
    }
    static s(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 2;
            case 6: return 4;
            case 7: return 6;
            case 4: return 5;
            case 5: return 7;
            case 1: return 1;
            case 3: return 3;
            default: return 2;
        }
    }
    static t(a) {
        switch (a) {
            case 0: return 0;
            case 4: return 4;
            case 2: return 2;
            case 7: return 7;
            case 3: return 3;
            case 6: return 6;
            case 5: return 5;
            case 1: return 1;
            default: return 0;
        }
    }
    static a7(a) {
        return wrapNullable(Boolean_$type, (a));
    }
    static a6(a) {
        let b = Nullable$1.toNullable(Boolean_$type, a);
        return wrapNullable(Boolean_$type, (b));
    }
    static a8(a) {
        if (nullableEquals(a, null)) {
            return Nullable$1.toNullable(FillPatternStyle_$type, null);
        }
        return Nullable$1.toNullable(FillPatternStyle_$type, XlsxUtilities.e(a.value));
    }
    static e(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 10: return 10;
            case 11: return 11;
            case 12: return 12;
            case 13: return 13;
            case 14: return 14;
            case 15: return 15;
            case 16: return 16;
            case 17: return 17;
            case 18: return 18;
            default: return 0;
        }
    }
    static g(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static i(a) {
        switch (a) {
            case 4: return 0;
            case 0: return 1;
            case 1: return 2;
            case 2: return 33;
            case 3: return 34;
            default: return 0;
        }
    }
    static h(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 1;
            case 3: return 2;
            default: return 1;
        }
    }
    static k(a) {
        if (nullableEquals(a, null)) {
            return -1;
        }
        return XlsxUtilities.j(a.value);
    }
    static j(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            default: return 0;
        }
    }
    static l(a) {
        switch (a) {
            case 1: return 0;
            case 3: return 2;
            case 4: return 3;
            case 0: return 4;
            case 2: return 5;
            case 5: return 6;
            case 6: return 1;
            default: return 4;
        }
    }
    static p(a) {
        switch (a) {
            case 3: return 3;
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 3;
        }
    }
    static m(a) {
        switch (a) {
            case 2: return 2;
            case 0: return 0;
            case 1: return 1;
            default: return 0;
        }
    }
    static n(a) {
        switch (a) {
            case 0: return 2;
            case 2: return 0;
            case 1: return 1;
            default: return 2;
        }
    }
    static o(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            default: return 1;
        }
    }
    static q(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            case 3: return 3;
            default: return 0;
        }
    }
    static r(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static w(a) {
        switch (a) {
            case 2: return 3;
            case 0: return 0;
            case 1: return 2;
            default: return 3;
        }
    }
    static am(a) {
        switch (a) {
            case 9: return 9;
            case 11: return 11;
            case 3: return 3;
            case 4: return 4;
            case 6: return 6;
            case 7: return 7;
            case 2: return 2;
            case 10: return 10;
            case 12: return 12;
            case 8: return 8;
            case -1:
            case 0: return 0;
            case 13: return 13;
            case 5: return 5;
            case 1: return 1;
            default: return 0;
        }
    }
    static aq(a) {
        switch (a) {
            case 2: return 2;
            case 0: return 0;
            case 1: return 1;
            default: return 2;
        }
    }
    static ar(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 2;
            case 4: return 6;
            case 6: return 7;
            case 5: return 4;
            case 7: return 5;
            case 1: return 1;
            case 3: return 3;
            default: return 2;
        }
    }
    static as(a) {
        switch (a) {
            case 0: return 0;
            case 4: return 4;
            case 2: return 2;
            case 7: return 7;
            case 3: return 3;
            case 6: return 6;
            case 5: return 5;
            case 1: return 1;
            default: return 0;
        }
    }
    static an(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 1;
        }
    }
    static ao(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 10: return 10;
            case 11: return 11;
            case 12: return 12;
            case 13: return 13;
            default: return 10;
        }
    }
    static ap(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static at(a) {
        switch (a) {
            case 3: return 2;
            case 0: return 0;
            case 2: return 1;
            default: return 2;
        }
    }
    static a9(a) {
        switch (a) {
            case -1: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, null);
            case 0: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 0);
            case 1: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 1);
            case 2: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 2);
            case 3: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 3);
            case 4: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 4);
            case 5: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 5);
            case 6: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 6);
            case 7: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 7);
            default: return Nullable$1.toNullable(ST_HorizontalAlignment_$type, 0);
        }
    }
    static au(a) {
        switch (a) {
            case 2: return 2;
            case 0: return 0;
            case 1: return 1;
            default: return 0;
        }
    }
    static av(a) {
        switch (a) {
            case 2: return 0;
            case 0: return 2;
            case 1: return 1;
            default: return 0;
        }
    }
    static aw(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            default: return 1;
        }
    }
    static ax(a) {
        switch (a) {
            case 3: return 3;
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 3;
        }
    }
    static ba(a) {
        if (nullableEquals(a, null)) {
            return Nullable$1.toNullable(ST_PatternType_$type, null);
        }
        return Nullable$1.toNullable(ST_PatternType_$type, XlsxUtilities.ay(a.value));
    }
    static ay(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 10: return 10;
            case 11: return 11;
            case 12: return 12;
            case 13: return 13;
            case 14: return 14;
            case 15: return 15;
            case 16: return 16;
            case 17: return 17;
            case 18: return 18;
            default: return 0;
        }
    }
    static az(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            case 3: return 3;
            default: return 0;
        }
    }
    static a0(a) {
        switch (a) {
            case 1: return 0;
            case 0: return 1;
            default: return 0;
        }
    }
    static ah(a) {
        switch (a) {
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 1: return 13;
            case 3: return 15;
            case 11: return 11;
            case 10: return 10;
            case 0: return 14;
            case 2: return 16;
            default: return 4;
        }
    }
    static a1(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 0;
        }
    }
    static a2(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 1;
            case 1: return 2;
            default: return 0;
        }
    }
    static a3(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static bb(a) {
        if (ExcelUtils.am(a) == false) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, null);
        }
        if (a.equals(SystemColorsInternal.d)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 0);
        }
        if (a.equals(SystemColorsInternal.f)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 1);
        }
        if (a.equals(SystemColorsInternal.j)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 3);
        }
        if (a.equals(SystemColorsInternal.ab)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 10);
        }
        if (a.equals(SystemColorsInternal.l)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 4);
        }
        if (a.equals(SystemColorsInternal.n)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 8);
        }
        if (a.equals(SystemColorsInternal.z)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 9);
        }
        if (a.equals(SystemColorsInternal.h)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 2);
        }
        if (a.equals(SystemColorsInternal.t)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 5);
        }
        if (a.equals(SystemColorsInternal.af)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 11);
        }
        if (a.equals(SystemColorsInternal.ah)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 12);
        }
        if (a.equals(SystemColorsInternal.aj)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 13);
        }
        if (a.equals(SystemColorsInternal.al)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 14);
        }
        if (a.equals(SystemColorsInternal.an)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 15);
        }
        if (a.equals(SystemColorsInternal.ap)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 16);
        }
        if (a.equals(SystemColorsInternal.ar)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 17);
        }
        if (a.equals(SystemColorsInternal.av)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 19);
        }
        if (a.equals(SystemColorsInternal.ax)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 21);
        }
        if (a.equals(SystemColorsInternal.v)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 7);
        }
        if (a.equals(SystemColorsInternal.a3)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 22);
        }
        if (a.equals(SystemColorsInternal.a1)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 23);
        }
        if (a.equals(SystemColorsInternal.a5)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 24);
        }
        if (a.equals(SystemColorsInternal.a7)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 25);
        }
        if (a.equals(SystemColorsInternal.a9)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 26);
        }
        if (a.equals(SystemColorsInternal.bb)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 27);
        }
        if (a.equals(SystemColorsInternal.bd)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 28);
        }
        if (a.equals(SystemColorsInternal.bf)) {
            return Nullable$1.toNullable(ST_SystemColorVal_$type, 29);
        }
        return Nullable$1.toNullable(ST_SystemColorVal_$type, null);
    }
    static a4(a) {
        return a;
    }
    static ai(a) {
        switch (a) {
            case 0: return 1;
            case 2: return 3;
            case 3: return 4;
            case 4: return 0;
            case 5: return 2;
            case 1: return 6;
            case 6: return 5;
            default: return 0;
        }
    }
    static aj(a) {
        switch (a) {
            case 0: return 2;
            case 1: return 1;
            case 2: return 0;
            default: return 2;
        }
    }
    static ak(a) {
        switch (a) {
            case -1:
            case 0: return 0;
            case 1:
            case 33: return 2;
            case 2:
            case 34: return 3;
            default: return 0;
        }
    }
    static a5(a) {
        switch (a) {
            case -1:
            case 0: return 4;
            case 1: return 0;
            case 2: return 1;
            case 33: return 2;
            case 34: return 3;
            default: return 4;
        }
    }
    static bc(a) {
        switch (a) {
            case -1: return Nullable$1.toNullable(ST_VerticalAlignment_$type, null);
            case 0: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 0);
            case 1: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 1);
            case 2: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 2);
            case 3: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 3);
            case 4: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 4);
            default: return Nullable$1.toNullable(ST_VerticalAlignment_$type, 2);
        }
    }
    static al(a) {
        switch (a) {
            case -1:
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static bf(a) {
        switch (a) {
            case 0: return SystemColorsInternal.d;
            case 1: return SystemColorsInternal.f;
            case 3: return SystemColorsInternal.j;
            case 10: return SystemColorsInternal.ab;
            case 4: return SystemColorsInternal.l;
            case 8: return SystemColorsInternal.n;
            case 9: return SystemColorsInternal.z;
            case 2: return SystemColorsInternal.h;
            case 5: return SystemColorsInternal.t;
            case 11: return SystemColorsInternal.af;
            case 12: return SystemColorsInternal.ah;
            case 13: return SystemColorsInternal.aj;
            case 14: return SystemColorsInternal.al;
            case 15: return SystemColorsInternal.an;
            case 16: return SystemColorsInternal.ap;
            case 17: return SystemColorsInternal.ar;
            case 19: return SystemColorsInternal.av;
            case 21: return SystemColorsInternal.ax;
            case 7: return SystemColorsInternal.v;
            case 22: return SystemColorsInternal.a3;
            case 23: return SystemColorsInternal.a1;
            case 24: return SystemColorsInternal.a5;
            case 25: return SystemColorsInternal.a7;
            case 26: return SystemColorsInternal.a9;
            case 27: return SystemColorsInternal.bb;
            case 28: return SystemColorsInternal.bd;
            case 29: return SystemColorsInternal.bf;
            default: break;
        }
        return ColorsInternal.c;
    }
    static y(a) {
        if (nullableEquals(a, null)) {
            return -1;
        }
        return XlsxUtilities.x(a.value);
    }
    static x(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            default: return 2;
        }
    }
    static z(a) {
        switch (a) {
            case 2: return 0;
            case 1: return 1;
            case 4: return 0;
            case 3: return 0;
            case 0: return 2;
            default: return 0;
        }
    }
    static aa(a, b) {
        return a._accept$2$i(Workbook.$, WorkbookColorInfo.$, XlsxUtilities_WorkbookColorInfoCreator.a, b);
    }
    static ab(a, b) {
        return a._accept$2$i(Workbook.$, WorkbookColorInfo.$, XlsxUtilities_WorkbookColorInfoCreator.a, b);
    }
    static ac(a) {
        switch (a) {
            case 4: return 4;
            case 5: return 5;
            case 6: return 6;
            case 7: return 7;
            case 8: return 8;
            case 9: return 9;
            case 13: return 1;
            case 15: return 3;
            case 1: return 1;
            case 3: return 3;
            case 11: return 11;
            case 10: return 10;
            case 14: return 0;
            case 16: return 2;
            case 0: return 0;
            case 2: return 2;
            default: return 4;
        }
    }
    static bd(a, b) {
        let c = new WorksheetCellAddress(1, a.d, a.c);
        let d = b._gd(a.c, true);
        let e = b._gh(a.d, true);
        let f = a.a.k();
        let g = a.b.k();
        let h = { $type: Point_$type, x: d == 0 ? 0 : ((f * 100) / d), y: e == 0 ? 0 : ((g * 100) / e) };
        return Tuple.a(WorksheetCellAddress.$, Point_$type, c, h);
    }
    static ad(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 2;
            case 2: return 1;
            default: return 0;
        }
    }
    static ae(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 0;
            default: return 0;
        }
    }
    static be(a) {
        let b = EnumUtil.getName(ST_PresetColorVal_$type, a);
        if (stringStartsWith(b, "dk")) {
            b = "dark" + b.substr(2);
        }
        else if (stringStartsWith(b, "lt")) {
            b = "light" + b.substr(2);
        }
        else if (stringStartsWith(b, "med")) {
            b = "medium" + b.substr(3);
        }
        let c = new Color();
        c = new Color();
        c.colorString = b;
        return c;
    }
}
XlsxUtilities.$t = markType(XlsxUtilities, 'XlsxUtilities');
/**
 * @hidden
 */
export class XlsxUtilities_ColorTransformsApplicator extends Base {
    constructor() {
        super();
    }
    _visitColorTransform_Alpha$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 0, () => (ST_PositiveFixedPercentage.m(a.a) / 100) * 255);
    }
    _visitColorTransform_AlphaMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 0, () => Convert.toInt32((ST_PositivePercentage.m(a.a) / 100) * b.l));
    }
    _visitColorTransform_AlphaOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 0, () => b.l + Convert.toInt32((ST_FixedPercentage.m(a.a) / 100) * 255));
    }
    _visitColorTransform_Blue$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 3, () => (ST_Percentage.l(a.a) / 100) * 255);
    }
    _visitColorTransform_BlueMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 3, () => Convert.toInt32((ST_Percentage.l(a.a) / 100) * b.m));
    }
    _visitColorTransform_BlueOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 3, () => b.m + Convert.toInt32((ST_Percentage.l(a.a) / 100) * 255));
    }
    _visitColorTransform_Comp$i(a, b) {
        return Color.u(b.l, (255 - b.o), (255 - b.n), (255 - b.m));
    }
    _visitColorTransform_Gray$i(a, b) {
        let c = truncate(((b.o * 0.3) + (b.n * 0.59) + (b.m * 0.11)));
        return Color.u(255, c, c, c);
    }
    _visitColorTransform_Green$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 2, () => (ST_Percentage.l(a.a) / 100) * 255);
    }
    _visitColorTransform_GreenMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 2, () => Convert.toInt32((ST_Percentage.l(a.a) / 100) * b.n));
    }
    _visitColorTransform_GreenOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 2, () => b.n + Convert.toInt32((ST_Percentage.l(a.a) / 100) * 255));
    }
    _visitColorTransform_Hue$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 0, (c) => 240 * (a.a.q() / 360));
    }
    _visitColorTransform_HueMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 0, (c) => c * (ST_PositivePercentage.m(a.a) / 100));
    }
    _visitColorTransform_HueOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 0, (c) => c + 240 * (a.a.n() / 360));
    }
    _visitColorTransform_Inv$i(a, b) {
        return Color.u(b.l, (255 - b.o), (255 - b.n), (255 - b.m));
    }
    _visitColorTransform_Lum$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 2, (c) => 240 * (ST_Percentage.l(a.a) / 100));
    }
    _visitColorTransform_LumMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 2, (c) => c * (ST_Percentage.l(a.a) / 100));
    }
    _visitColorTransform_LumOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 2, (c) => c + (240 * (ST_Percentage.l(a.a) / 100)));
    }
    _visitColorTransform_Red$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 1, () => (ST_Percentage.l(a.a) / 100) * 255);
    }
    _visitColorTransform_RedMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 1, () => Convert.toInt32((ST_Percentage.l(a.a) / 100) * b.o));
    }
    _visitColorTransform_RedOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.c(b, 1, () => b.o + Convert.toInt32((ST_Percentage.l(a.a) / 100) * 255));
    }
    _visitColorTransform_Sat$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 1, (c) => 240 * (ST_Percentage.l(a.a) / 100));
    }
    _visitColorTransform_SatMod$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 1, (c) => c * (ST_Percentage.l(a.a) / 100));
    }
    _visitColorTransform_SatOff$i(a, b) {
        return XlsxUtilities_ColorTransformsApplicator.b(b, 1, (c) => c + (240 * (ST_Percentage.l(a.a) / 100)));
    }
    _visitColorTransform_Shade$i(a, b) {
        try {
            b = ExcelUtils.gt(b, ST_PositiveFixedPercentage.m(a.a) / 100);
        }
        catch (c) {
        }
        return b;
    }
    _visitColorTransform_Tint$i(a, b) {
        try {
            b = ExcelUtils.gu(b, 1 - (ST_PositiveFixedPercentage.m(a.a) / 100));
        }
        catch (c) {
        }
        return b;
    }
    static c(a, b, c) {
        try {
            let d = truncate(Math.max(0, Math.min(MathUtilities.f(c()), 255)));
            switch (b) {
                default:
                case 0: return Color.u(d, a.o, a.n, a.m);
                case 1: return Color.u(a.l, d, a.n, a.m);
                case 2: return Color.u(a.l, a.o, d, a.m);
                case 3: return Color.u(a.l, a.o, a.n, d);
            }
        }
        catch (e) {
            return a;
        }
    }
    static b(a, b, c) {
        try {
            let d, e, f;
            let g = ExcelUtils.e8(a, d, f, e);
            d = g.p1;
            f = g.p2;
            e = g.p3;
            let h;
            switch (b) {
                default:
                case 0:
                    h = d;
                    break;
                case 1:
                    h = e;
                    break;
                case 2:
                    h = f;
                    break;
            }
            let i = truncate(Math.max(0, Math.min(MathUtilities.f(c(h)), 240)));
            switch (b) {
                default:
                case 0: return ExcelUtils.gy(i, f, e);
                case 2: return ExcelUtils.gy(d, i, e);
                case 1: return ExcelUtils.gy(d, f, i);
            }
        }
        catch (j) {
            return a;
        }
    }
}
XlsxUtilities_ColorTransformsApplicator.$t = markType(XlsxUtilities_ColorTransformsApplicator, 'XlsxUtilities_ColorTransformsApplicator', Base.$, [IEG_ColorTransformVisitor$2_$type.specialize(Color.$, Color.$)]);
XlsxUtilities_ColorTransformsApplicator.a = new XlsxUtilities_ColorTransformsApplicator();
/**
 * @hidden
 */
export class XlsxUtilities_WorkbookColorInfoCreator extends Base {
    constructor() {
        super();
    }
    _visitCT_SchemeColor$i(a, b) {
        let c = new WorkbookColorInfo(XlsxUtilities.ac(a.c));
        let d = XlsxUtilities_WorkbookColorInfoCreator.b(a, b, c);
        c = d.p2;
        return c;
    }
    _visitCT_SRgbColor$i(a, b) {
        let c = new WorkbookColorInfo(ST_HexColorRGB.s(a.c));
        let d = XlsxUtilities_WorkbookColorInfoCreator.b(a, b, c);
        c = d.p2;
        return c;
    }
    _visitCT_SysColor$i(a, b) {
        if (a.d == 27 && a.b.count == 0) {
            return WorkbookColorInfo.automatic;
        }
        let c = new WorkbookColorInfo(XlsxUtilities.bf(a.d));
        let d = XlsxUtilities_WorkbookColorInfoCreator.b(a, b, c);
        c = d.p2;
        return c;
    }
    _visitCT_PresetColor$i(a, b) {
        let c = XlsxUtilities.be(a.c);
        let d = new WorkbookColorInfo(c);
        let e = XlsxUtilities_WorkbookColorInfoCreator.b(a, b, d);
        d = e.p2;
        return d;
    }
    _visitCT_BlipFillProperties$i(a, b) {
        return null;
    }
    _visitCT_GroupFillProperties$i(a, b) {
        return null;
    }
    _visitCT_NoFillProperties$i(a, b) {
        return null;
    }
    _visitCT_SolidFillProperties$i(a, b) {
        return XlsxUtilities.aa(a.a, b);
    }
    static b(a, b, c) {
        if (a.b.count == 0) {
            return {
                p2: c
            };
        }
        if (nullableNotEquals(c._themeColorType$i, null) && nullableEquals(c._tint$i, null)) {
            if (a.b.count == 1) {
                let d = typeCast(ColorTransform_LumMod.$, a.b._inner[0]);
                if (d != null) {
                    c = c._h(new WorkbookColorTransform(Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, ST_Percentage.l(d.a) / 100), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null)));
                    return {
                        p2: c
                    };
                }
            }
            else if (a.b.count == 2) {
                let e = typeCast(ColorTransform_LumMod.$, a.b._inner[0]);
                let f = typeCast(ColorTransform_LumOff.$, a.b._inner[1]);
                if (e == null && f == null) {
                    e = typeCast(ColorTransform_LumMod.$, a.b._inner[1]);
                    f = typeCast(ColorTransform_LumOff.$, a.b._inner[0]);
                }
                if (e != null && f != null) {
                    c = c._h(new WorkbookColorTransform(Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, ST_Percentage.l(e.a) / 100), Nullable$1.toNullable(Number_$type, ST_Percentage.l(f.a) / 100), Nullable$1.toNullable(Number_$type, null)));
                    return {
                        p2: c
                    };
                }
            }
        }
        let g = c._getResolvedColor1(b);
        for (let h of fromEnum(a.b)) {
            g = h._accept$2$i(Color.$, Color.$, XlsxUtilities_ColorTransformsApplicator.a, g);
        }
        c = new WorkbookColorInfo(g);
        return {
            p2: c
        };
    }
}
XlsxUtilities_WorkbookColorInfoCreator.$t = markType(XlsxUtilities_WorkbookColorInfoCreator, 'XlsxUtilities_WorkbookColorInfoCreator', Base.$, [IEG_ColorChoiceVisitor$2_$type.specialize(Workbook.$, WorkbookColorInfo.$), IEG_FillPropertiesVisitor$2_$type.specialize(Workbook.$, WorkbookColorInfo.$)]);
XlsxUtilities_WorkbookColorInfoCreator.a = new XlsxUtilities_WorkbookColorInfoCreator();
/**
 * @hidden
 */
export class ColorInfo extends Base {
    constructor() {
        super(...arguments);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
        this.k = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        this.l = Nullable$1.toNullable(Number_$type, null);
        this.g = 0;
        this.d = null;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(ColorInfo.$, a);
        return b != null && nullableEquals(this.i, b.i) && nullableEquals(this.j, b.j) && Base.equalsStatic(this.k, unwrapNullable(b.k)) && nullableEquals(this.l, b.l) && this.g == b.g;
    }
    getHashCode() {
        return Base.getHashCodeStatic(this.i) ^ Base.getHashCodeStatic(this.j) ^ Base.getHashCodeStatic(this.k) ^ Base.getHashCodeStatic(this.l) ^ (this.g);
    }
    get f() {
        return this.equals(ColorInfo.b);
    }
    static a(a, b, c) {
        let d = new ColorInfo();
        if (WorkbookColorInfo.l_op_Inequality(b, null)) {
            if (b.isAutomatic) {
                d.i = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (b._color$i.hasValue) {
                let e = b._color$i.value;
                if (ExcelUtils.am(e)) {
                    d.j = Nullable$1.toNullable(Number_$type, intSToU(a._b._palette$i._l(b, c)));
                }
                else {
                    d.k = Nullable$1.toNullable(ST_UnsignedIntHex.$, ST_UnsignedIntHex.b(intSToU(ExcelUtils.cx(e))));
                }
            }
            if (b._themeColorType$i.hasValue) {
                d.l = Nullable$1.toNullable(Number_$type, b._themeColorType$i.value);
            }
            if (b._tint$i.hasValue) {
                d.g = b._tint$i.value;
            }
        }
        return d;
    }
    c(a) {
        if (this.f) {
            return null;
        }
        if (nullableEquals(this.i, true)) {
            return WorkbookColorInfo.automatic;
        }
        let b = Nullable$1.toNullable(Number_$type, null);
        if (this.g != 0) {
            b = Nullable$1.toNullable(Number_$type, this.g);
        }
        if (a == null) {
            return WorkbookColorInfo.automatic;
        }
        if (nullableNotEquals(this.l, null) && nullableLessThan(this.l, a._b._h.length)) {
            return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, this.l.value), b, true, false);
        }
        if (nullableNotEquals(this.j, null)) {
            return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, a._b._palette$i._ae(this.j.value)), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), b, true, false);
        }
        if (nullableNotEquals(this.k, null)) {
            if ((u32BitwiseAnd(ST_UnsignedIntHex.h(this.k.value), 4278190080)) == 4278190080) {
                return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, ExcelUtils.gx(ST_UnsignedIntHex.h(this.k.value))), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), b, true, true);
            }
            return null;
        }
        return null;
    }
    m(a, b) {
        this.i = a.i;
        if (a.d != null) {
            this.d = a.d._aj(b);
        }
        this.j = a.j;
        this.k = a.k;
        this.l = ST_UnsignedIntHex.f(a.k);
        this.g = a.g;
    }
}
ColorInfo.$t = markType(ColorInfo, 'ColorInfo');
ColorInfo.b = new ColorInfo();
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007_FontCollection extends Base {
    constructor() {
        super();
        this.b = null;
        this.c = null;
        this.d = null;
        this.b = new Dictionary$2(String_$type, String_$type, 2, StringComparer.c);
        this.c = new Dictionary$2(Number_$type, String_$type, 0);
    }
    f(a, b) {
        this.b.item(a, b);
        this.c.addItem(this.c.count, a);
    }
    e() {
        let a = null;
        if (ExcelUtils.ay) {
            let b = this.b.tryGetValue("jpan", a);
            a = b.p1;
        }
        if (a != null) {
            return a;
        }
        return this.d;
    }
    a(a, b, c) {
        b = null;
        c = null;
        if (((() => { let d = this.c.tryGetValue(a, b); b = d.p1; return d.ret; })())) {
            c = this.b.item(b);
        }
        return {
            ret: stringIsNullOrEmpty(c) == false,
            p1: b,
            p2: c
        };
    }
}
WorkbookLoadManagerExcel2007_FontCollection.$t = markType(WorkbookLoadManagerExcel2007_FontCollection, 'WorkbookLoadManagerExcel2007_FontCollection');
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007_NamedReferenceInfo extends ValueType {
    constructor() {
        super();
        this.b = false;
        this.a = null;
    }
}
WorkbookLoadManagerExcel2007_NamedReferenceInfo.$t = markStruct(WorkbookLoadManagerExcel2007_NamedReferenceInfo, 'WorkbookLoadManagerExcel2007_NamedReferenceInfo');
/**
 * @hidden
 */
export class ExcelWorkbookDocumentManager extends ExcelDocumentManager {
    constructor(a, b, c, d, e, f, g) {
        super(d, e, f, g);
        this._bx = null;
        this._bu = null;
        this._bx = a;
        this._bu = new ThemePartInfo();
        this._bu.a = b;
        this._bu.b = c;
    }
    get _bv() {
        return this._bu != null ? this._bu.a : null;
    }
    get _bw() {
        return this._bu != null ? this._bu.b : null;
    }
    get _by() {
        return this._bx;
    }
}
ExcelWorkbookDocumentManager.$t = markType(ExcelWorkbookDocumentManager, 'ExcelWorkbookDocumentManager', ExcelDocumentManager.$);
/**
 * @hidden
 */
export class ObjectModelExcelDocumentManager extends ExcelWorkbookDocumentManager {
    constructor(a, ..._rest) {
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    super(c._b, c._al, c._am, d, e, true, f);
                    this._b6 = null;
                    this._b8 = null;
                    this._b3 = null;
                    this._ca = null;
                    this._b6 = c;
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    super(c._b, null, null, d, e, false, f);
                    this._b6 = null;
                    this._b8 = null;
                    this._b3 = null;
                    this._ca = null;
                    this._b8 = c;
                }
                break;
        }
    }
    _bh() {
        super._bh();
        this._bl(Office2007ExtensibilityPartManager.a4, false);
        this._bl(Office2010ExtensibilityPartManager.a4, false);
        this._bl(ObjectModelActiveXBinaryPartManager.x);
        this._bl(ObjectModelActiveXPartManager.x);
        this._bl(ObjectModelCalcChainPartManager.a6);
        this._bl(ObjectModelChartPartManager.ba);
        this._bl(ObjectModelChartExPartManager.a9);
        this._bl(ObjectModelChartColorStylePartManager.a8);
        this._bl(ObjectModelChartsheetPartManager.ba);
        this._bl(ObjectModelChartStylePartManager.a8);
        this._bl(ObjectModelChartUserShapePartManager.v);
        this._bl(ObjectModelCommentsPartManager.a8);
        this._bl(ObjectModelConnectionsPartManager.a8);
        this._bl(ObjectModelCorePropertiesPartManager.a8);
        this._bl(ObjectModelCtrlPropPartManager.x);
        this._bl(ObjectModelCustomXmlItemPartManager.x);
        this._bl(ObjectModelCustomXmlItemPropsPartManager.x);
        this._bl(ObjectModelDrawingPartManager.bf);
        this._bl(ObjectModelExtendedPropertiesPartManager.a8);
        this._bl(ObjectModelExternalLinkPartManager.a8);
        this._bl(ObjectModelMacroEnabledTemplatePartManager.b7);
        this._bl(ObjectModelMacroEnabledWorkbookPartManager.b7);
        this._bl(ObjectModelPivotCacheDefinitionPartManager.a8);
        this._bl(ObjectModelPivotCacheRecordsPartManager.a8);
        this._bl(ObjectModelPivotTablePartManager.a9);
        this._bl(ObjectModelPrinterSettingsPartManager.a7);
        this._bl(ObjectModelSharedStringsPartManager.a8);
        this._bl(ObjectModelSlicerCachePartManager.a7);
        this._bl(ObjectModelSlicerPartManager.a7);
        this._bl(ObjectModelStylesPartManager.a8);
        this._bl(ObjectModelTablePartManager.a9);
        this._bl(ObjectModelTemplatePartManager.b7);
        this._bl(ObjectModelThemePartManager.bb);
        this._bl(ObjectModelVmlDrawingPartManager.ba);
        this._bl(ObjectModelWorkbookPartManager.b7);
        this._bl(ObjectModelWorksheetPartManager.bi);
        if (this._z != 1) {
            this._bl(ObjectModelVbaProjectPartManager.x);
        }
        this._h = this._by._n;
        this._i = this._by._o;
    }
    _o() {
        let a = this._by;
        if (a.currentFormat == 2 && this._z == 1) {
            a._iz(6);
        }
        return super._o();
    }
    _s() {
        return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.i(Tuple$2.$.specialize(Uri.$, String_$type), this._j(ObjectModelExtendedPropertiesPartManager.a8), () => this._j(ObjectModelCorePropertiesPartManager.a8)), () => this._b2()), () => this._b1());
    }
    _b0(a, b, c = null) {
        let d;
        let e = new Guid();
        try {
            if (b == null) {
                b = a.d;
            }
            e = b.n;
        }
        catch (f) {
            throw new InvalidOperationException(2, ExcelUtils.ef("LE_InvalidOperationException_ImageDisposed"), f);
        }
        let g = false;
        let h = g || Guid.l_op_Equality(e, ImageFormat.g.n);
        if (h) {
            d = PngPartManager.y;
            b = ImageFormat.g;
            e = b.n;
        }
        else if (Guid.l_op_Equality(e, ImageFormat.f.n)) {
            d = JpegPartManager.y;
        }
        else if (Guid.l_op_Equality(e, ImageFormat.e.n)) {
            d = GifPartManager.y;
        }
        else if (Guid.l_op_Equality(e, ImageFormat.h.n)) {
            d = TiffPartManager.y;
        }
        else if (Guid.l_op_Equality(e, ImageFormat.c.n)) {
            d = EmfPartManager.y;
        }
        else if (Guid.l_op_Equality(e, ImageFormat.i.n)) {
            d = WmfPartManager.y;
        }
        else if (g) {
            d = BmpPartManager.y;
        }
        else {
            d = PngPartManager.y;
        }
        let i;
        {
            let j = new MemoryStream(0);
            try {
                ExcelUtils.f4(a, b, j);
                i = new ImageData(0, d.r(d.s), j.toArray());
            }
            finally {
                if (j != null) {
                    j.dispose();
                }
            }
        }
        return this._j(d, i, c);
    }
    _bz(a, b = null) {
        let c;
        let d = a.d.n;
        if (Guid.l_op_Equality(d, ImageFormat.p)) {
            c = PngPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.j)) {
            c = BmpPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.k)) {
            c = BmpPartManager.z;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.o)) {
            c = JpegPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.m)) {
            c = GifPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.q)) {
            c = TiffPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.l)) {
            c = EmfPartManager.y;
        }
        else if (Guid.l_op_Equality(d, ImageFormat.r)) {
            c = WmfPartManager.y;
        }
        else {
            c = PngPartManager.y;
        }
        return this._j(c, a, b);
    }
    _cd() {
        return ImagePartManagerBase.v(this._z);
    }
    _b4() {
        return DeserializedChartInfo.a(this._by._ad);
    }
    _b1() {
        let a = this._b5();
        return Async.g(a != null, () => this._j(a));
    }
    _b5() {
        switch (this._by.currentFormat) {
            case 2:
            case 6: return ObjectModelWorkbookPartManager.b7;
            case 3: return ObjectModelMacroEnabledWorkbookPartManager.b7;
            case 4: return ObjectModelMacroEnabledTemplatePartManager.b7;
            case 5: return ObjectModelTemplatePartManager.b7;
            default: return null;
        }
    }
    _b2() {
        let a = this._by._eh;
        if (a == null) {
            return null;
        }
        let b = this._by._ef;
        if (b == null) {
            return null;
        }
        let c = Math.min(a.count, b.count);
        return Async.c(0, c, 1, (d) => this._j(ObjectModelCustomXmlItemPartManager.x, Tuple.a(BinaryData.$, BinaryData.$, b._inner[d], a._inner[d])));
    }
    get _b7() {
        return this._b6;
    }
    get _b9() {
        return this._b8;
    }
}
ObjectModelExcelDocumentManager.$t = markType(ObjectModelExcelDocumentManager, 'ObjectModelExcelDocumentManager', ExcelWorkbookDocumentManager.$);
/**
 * @hidden
 */
export class ThemePartInfo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
    }
}
ThemePartInfo.$t = markType(ThemePartInfo, 'ThemePartInfo');
/**
 * @hidden
 */
export class WorkbookSerializationDataExcel2007 extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = null;
        this.c = null;
        this.d = null;
        this.e = null;
        this.a = null;
        this.f = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.b = new List$1(BorderInfo.$, 0);
                    this.c = new List$1(StyleInfo.$, 0);
                    this.d = new List$1(FormatInfo.$, 0);
                    this.e = new List$1(FormatInfo.$, 0);
                    this.a = c;
                    this.f = new List$1(FillInfo.$, 0);
                }
                break;
        }
    }
}
WorkbookSerializationDataExcel2007.$t = markStruct(WorkbookSerializationDataExcel2007, 'WorkbookSerializationDataExcel2007');
/**
 * @hidden
 */
export class BorderInfo extends Base {
    constructor() {
        super(...arguments);
        this.h = new BorderStyleInfo();
        this.j = new BorderStyleInfo();
        this.l = new BorderStyleInfo();
        this.b = new BorderStyleInfo();
        this.d = new BorderStyleInfo();
        this.f = new BorderStyleInfo();
        this.n = new BorderStyleInfo();
        this.p = false;
        this.r = false;
        this.u = false;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(BorderInfo.$, a);
        if (b == null) {
            return false;
        }
        return this.p == b.p && this.r == b.r && this.u == b.u && Base.equalsStatic(this.b, b.b) && Base.equalsStatic(this.d, b.d) && Base.equalsStatic(this.f, b.f) && Base.equalsStatic(this.h, b.h) && Base.equalsStatic(this.j, b.j) && Base.equalsStatic(this.l, b.l) && Base.equalsStatic(this.n, b.n);
    }
    getHashCode() {
        let a = Base.getHashCodeStatic(this.p) ^ Base.getHashCodeStatic(this.r) ^ Base.getHashCodeStatic(this.u);
        if (this.b != null) {
            a ^= this.b.getHashCode();
        }
        if (this.d != null) {
            a ^= this.d.getHashCode();
        }
        if (this.f != null) {
            a ^= this.f.getHashCode();
        }
        if (this.h != null) {
            a ^= this.h.getHashCode();
        }
        if (this.j != null) {
            a ^= this.j.getHashCode();
        }
        if (this.l != null) {
            a ^= this.l.getHashCode();
        }
        if (this.n != null) {
            a ^= this.n.getHashCode();
        }
        return a;
    }
    get i() {
        return this.h;
    }
    get k() {
        return this.j;
    }
    get m() {
        return this.l;
    }
    get c() {
        return this.b;
    }
    get e() {
        return this.d;
    }
    get g() {
        return this.f;
    }
    get o() {
        return this.n;
    }
    get q() {
        return this.p;
    }
    set q(a) {
        this.p = a;
    }
    get s() {
        return this.r;
    }
    set s(a) {
        this.r = a;
    }
    get v() {
        return this.u;
    }
    set v(a) {
        this.u = a;
    }
    x(a, b) {
        if (this.c != null && this.c.f == false) {
            a.bottomBorderColorInfo = this.c.d.c(b);
            a.bottomBorderStyle = this.c.a;
        }
        if (this.m != null && this.m.f == false) {
            a.topBorderColorInfo = this.m.d.c(b);
            a.topBorderStyle = this.m.a;
        }
        if (this.i != null && this.i.f == false) {
            a.leftBorderColorInfo = this.i.d.c(b);
            a.leftBorderStyle = this.i.a;
        }
        if (this.k != null && this.k.f == false) {
            a.rightBorderColorInfo = this.k.d.c(b);
            a.rightBorderStyle = this.k.a;
        }
        if (this.e != null && this.e.f == false) {
            a.diagonalBorderColorInfo = this.e.d.c(b);
            a.diagonalBorderStyle = this.e.a;
        }
        let c = 1;
        if (this.q) {
            c |= 3;
        }
        if (this.s) {
            c |= 5;
        }
        a.diagonalBorders = c;
    }
    static a(a, b) {
        let c = new BorderInfo();
        BorderInfo.y(a, c.c, b._al, b.bottomBorderColorInfo, b._bf);
        BorderInfo.y(a, c.m, b._ap, b.topBorderColorInfo, b._bm);
        BorderInfo.y(a, c.i, b._an, b.leftBorderColorInfo, b._bk);
        BorderInfo.y(a, c.k, b._ao, b.rightBorderColorInfo, b._bl);
        BorderInfo.y(a, c.e, b._am, b.diagonalBorderColorInfo, b._bg);
        let d = b._aw;
        if (ExcelUtils.a0(d)) {
            c.q = true;
        }
        if (ExcelUtils.a1(d)) {
            c.s = true;
        }
        return c;
    }
    static y(a, b, c, d, e) {
        let f = (c == 0) ? d : e;
        b.a = c;
        b.d = ColorInfo.a(a, f, 0);
    }
}
BorderInfo.$t = markType(BorderInfo, 'BorderInfo');
/**
 * @hidden
 */
export class StyleInfo extends Base {
    constructor(a, ..._rest) {
        super();
        this.g = Nullable$1.toNullable(Number_$type, null);
        this.a = false;
        this.c = false;
        this.i = Nullable$1.toNullable(Number_$type, 0);
        this.k = stringEmpty();
        this.f = -1;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.l = d.name;
                    this.e = c._a7(d);
                    let e = typeCast(WorkbookBuiltInStyle.$, d);
                    if (e != null) {
                        if (e._ak == 255) {
                            this.j = Nullable$1.toNullable(Number_$type, null);
                        }
                        else {
                            this.j = Nullable$1.toNullable(Number_$type, Convert.toUInt32(e._ak));
                        }
                        this.h = Nullable$1.toNullable(Number_$type, e._ac);
                        this.b = e._ah;
                    }
                    this.d = d._m;
                }
                break;
        }
    }
    get h() {
        return this.g;
    }
    set h(a) {
        this.g = a;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get j() {
        return this.i;
    }
    set j(a) {
        this.i = a;
    }
    get l() {
        return this.k;
    }
    set l(a) {
        this.k = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
}
StyleInfo.$t = markType(StyleInfo, 'StyleInfo');
/**
 * @hidden
 */
export class FormatInfo extends Base {
    constructor() {
        super(...arguments);
        this.h = 0;
        this.n = Nullable$1.toNullable(Number_$type, null);
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(Number_$type, null);
        this.u = Nullable$1.toNullable(Number_$type, null);
        this.j = false;
        this.l = false;
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.c = null;
        this.a = null;
        this.f = null;
    }
    get i() {
        return this.h;
    }
    set i(a) {
        this.h = a;
    }
    get o() {
        return this.n;
    }
    set o(a) {
        this.n = a;
    }
    get r() {
        return this.q;
    }
    set r(a) {
        this.q = a;
    }
    get t() {
        return this.s;
    }
    set t(a) {
        this.s = a;
    }
    get v() {
        return this.u;
    }
    set v(a) {
        this.u = a;
    }
    get k() {
        return this.j;
    }
    set k(a) {
        this.j = a;
    }
    get m() {
        return this.l;
    }
    set m(a) {
        this.l = a;
    }
    get p() {
        return this.w;
    }
    set p(a) {
        this.w = a;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    get g() {
        return this.f;
    }
    set g(a) {
        this.f = a;
    }
    e(a, b, c) {
        let d = a._b;
        let e = d._cd(b ? 1 : 0);
        let f = this.i;
        let g = ExcelUtils.bx(f, 2);
        let h = ExcelUtils.bx(f, 8);
        let i = ExcelUtils.bx(f, 16);
        let j = ExcelUtils.bx(f, 4);
        let k = ExcelUtils.bx(f, 1);
        let l = ExcelUtils.bx(f, 32);
        if (e._b1 != 1) {
            let m = 0;
            if (this.p.hasValue && this.p.value < a._bd.count) {
                m = this.p.value;
            }
            let n = a._bd._inner[m];
            let o;
            if (((() => { let p = a._a7.tryGetValue(m, o); o = p.p1; return p.ret; })()) == false) {
                let p;
                let q = 1;
                do {
                    p = stringFormat("Style {0}", q++);
                } while (d._styles$i._item1(p) != null);
                o = d._styles$i._addUserDefinedStyle(n.g, p);
                a._a7.addItem(m, o);
            }
            e.style = o;
            if (g == false && (Base.equalsStatic(this.b, n.b) == false)) {
                g = true;
                f |= 2;
            }
            if (h == false && nullableNotEquals(this.o, null) && nullableNotEquals(this.o, n.o)) {
                h = true;
                f |= 8;
            }
            if (i == false && nullableNotEquals(this.r, null) && nullableNotEquals(this.r, n.r)) {
                i = true;
                f |= 16;
            }
            if (j == false && nullableNotEquals(this.t, null) && nullableNotEquals(this.t, n.t)) {
                j = true;
                f |= 4;
            }
            if (k == false && nullableNotEquals(this.u, null) && nullableNotEquals(this.u, n.u)) {
                k = true;
                f |= 1;
            }
            if (l == false && (Base.equalsStatic(this.d, n.d) == false)) {
                l = true;
                f |= 32;
            }
        }
        e.formatOptions = f;
        if ((j || c) && nullableNotEquals(this.t, null) && this.t.value < a._h.count) {
            let r = a._h._inner[this.t.value]._ak(e);
            e.font.setFontFormatting(r);
        }
        if ((k || c) && nullableNotEquals(this.v, null)) {
            e.formatString = d._b2.item(this.v.value);
        }
        if ((l || c) && this.d != null) {
            this.d.k(e);
        }
        if (g || c) {
            if (this.b != null) {
                this.b.ai(e);
            }
            else {
                AlignmentInfo.f.ai(e, false);
            }
        }
        if ((h || c) && nullableNotEquals(this.o, null) && this.o.value < a._bb.count) {
            let s = a._bb._inner[this.o.value];
            s.x(e, a);
        }
        if ((i || c) && nullableNotEquals(this.r, null) && this.r.value < a._bf.count) {
            let t = a._bf._inner[this.r.value];
            t.h(e, a);
        }
        e._dt(f);
        return e;
    }
}
FormatInfo.$t = markType(FormatInfo, 'FormatInfo');
/**
 * @hidden
 */
export class FillInfo extends Base {
    constructor() {
        super(...arguments);
        this.e = null;
        this.c = null;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(FillInfo.$, a);
        if (b == null) {
            return false;
        }
        return Base.equalsStatic(this.e, b.e) && Base.equalsStatic(this.c, b.c);
    }
    getHashCode() {
        let a = 0;
        if (this.e != null) {
            a ^= this.e.getHashCode();
        }
        if (this.c != null) {
            a ^= this.c.getHashCode();
        }
        return a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    h(a, b) {
        if (this.d != null) {
            a.fill = this.d.a(b, a);
        }
        else if (this.b != null) {
            a.fill = this.b.a(b);
        }
        else {
        }
    }
    static a(a, b) {
        let c = new FillInfo();
        let d = b._ar;
        let e = typeCast(CellFillPattern.$, d);
        if (e != null) {
            c.d = PatternFillInfo.f(a, b, e);
        }
        else {
            let f = typeCast(CellFillGradient.$, d);
            if (f != null) {
                c.b = GradientFillInfo.b(a, f);
            }
            else {
            }
        }
        return c;
    }
}
FillInfo.$t = markType(FillInfo, 'FillInfo');
/**
 * @hidden
 */
export class GZipStream extends Stream {
    constructor(a, b) {
        super();
        this._o = null;
        this._entryStream = null;
        this._o = a;
        if (b == 0) {
            let c = new Array(a.length);
            a.read(c, 0, c.length);
            this._entryStream = new MemoryStream(2, (Pako.inflate(c)));
        }
        else {
            throw new NotImplementedException(0);
        }
    }
    get _baseStream() {
        return this._o;
    }
    get_canRead() {
        return true;
    }
    get canRead() {
        return this.get_canRead();
    }
    get_canSeek() {
        return true;
    }
    get canSeek() {
        return this.get_canSeek();
    }
    get_canWrite() {
        return false;
    }
    get canWrite() {
        return this.get_canWrite();
    }
    get_length() {
        return this._entryStream.length;
    }
    get length() {
        return this.get_length();
    }
    get_position() {
        return this._entryStream.position;
    }
    set_position(a) {
        this._entryStream.position = a;
    }
    get position() {
        return this.get_position();
    }
    set position(a) {
        this.set_position(a);
    }
    disposeCore(a) {
        this._entryStream.dispose();
    }
    flush() {
        this._entryStream.flush();
    }
    read(a, b, c) {
        return this._entryStream.read(a, b, c);
    }
    seek(a, b) {
        return this._entryStream.seek(a, b);
    }
    setLength(a) {
        this._entryStream.setLength(a);
    }
    write(a, b, c) {
        this._entryStream.write(a, b, c);
    }
}
GZipStream.$t = markType(GZipStream, 'GZipStream', Stream.$);
/**
 * @hidden
 */
export class DxfInfo extends Base {
    constructor(a, ..._rest) {
        super();
        this.b = null;
        this.c = null;
        this.e = null;
        this.a = null;
        this.d = null;
        this.g = null;
        this.f = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    if (ExcelUtils.bx(d.formatOptions, 2)) {
                        this.b = AlignmentInfo.e(d, true);
                    }
                    if (ExcelUtils.bx(d.formatOptions, 8)) {
                        this.c = BorderInfo.a(c, d);
                    }
                    if (ExcelUtils.bx(d.formatOptions, 16)) {
                        this.e = FillInfo.a(c, d);
                    }
                    if (ExcelUtils.bx(d.formatOptions, 1)) {
                        this.g = SerializationNumberFormatInfo.a(d);
                    }
                    if (ExcelUtils.bx(d.formatOptions, 32)) {
                        this.f = ProtectionInfo.b(d, true);
                    }
                    if (ExcelUtils.bx(d.formatOptions, 4)) {
                        this.a = d._bp.d._ak(d);
                    }
                }
                break;
        }
    }
    h(a) {
        let b = a._b._cd(2);
        if (this.b != null) {
            this.b.ai(b);
        }
        if (this.c != null) {
            this.c.x(b, a);
        }
        if (this.e != null) {
            this.e.h(b, a);
        }
        if (this.a != null) {
            b.font.setFontFormatting(this.a);
        }
        if (this.d != null) {
            b.font.colorInfo = this.d.c(a);
        }
        if (this.g != null) {
            this.g.d(b);
        }
        if (this.f != null) {
            this.f.k(b);
        }
        return b;
    }
}
DxfInfo.$t = markType(DxfInfo, 'DxfInfo');
/**
 * @hidden
 */
export class AlignmentInfo extends Base {
    constructor(a, ..._rest) {
        super();
        this.b = 0;
        this.aa = Nullable$1.toNullable(Number_$type, null);
        this.p = false;
        this.ac = Nullable$1.toNullable(Number_$type, null);
        this.ae = Nullable$1.toNullable(Number_$type, null);
        this.r = false;
        this.ag = Nullable$1.toNullable(Number_$type, null);
        this.h = 2;
        this.t = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = _rest[4];
                    let h = _rest[5];
                    let i = _rest[6];
                    let j = _rest[7];
                    let k = _rest[8];
                    this.b = c;
                    this.aa = d;
                    this.p = e;
                    this.ac = f;
                    this.ae = g;
                    this.r = (nullableEquals(i, true));
                    this.ag = h;
                    this.h = j;
                    this.t = (nullableEquals(k, true));
                }
                break;
        }
    }
    static staticInit() {
        AlignmentInfo.f = new AlignmentInfo(0);
    }
    equals(a) {
        return AlignmentInfo.n(this, typeCast(AlignmentInfo.$, a));
    }
    getHashCode() {
        let a = 0;
        a ^= this.b;
        a ^= this.aa.value << 1;
        a ^= Convert.toInt321(this.p) << 2;
        a ^= this.ac.value << 3;
        a ^= this.ae.value << 4;
        a ^= Convert.toInt321(this.r) << 5;
        a ^= this.ag.value << 6;
        a ^= this.h << 7;
        a ^= Convert.toInt321(this.t) << 8;
        return a;
    }
    get c() {
        return this.b;
    }
    set c(a) {
        this.b = a;
    }
    get ab() {
        return this.aa;
    }
    set ab(a) {
        this.aa = a;
    }
    get q() {
        return this.p;
    }
    set q(a) {
        this.p = a;
    }
    get ad() {
        return this.ac;
    }
    set ad(a) {
        this.ac = a;
    }
    get af() {
        return this.ae;
    }
    set af(a) {
        this.ae = a;
    }
    get s() {
        return this.r;
    }
    set s(a) {
        this.r = a;
    }
    get ah() {
        return this.ag;
    }
    set ah(a) {
        this.ag = a;
    }
    get i() {
        return this.h;
    }
    set i(a) {
        this.h = a;
    }
    get u() {
        return this.t;
    }
    set u(a) {
        this.t = a;
    }
    get o() {
        return (this.b == 0 && nullableEquals(this.aa, null) && this.p == false && nullableEquals(this.ac, null) && nullableEquals(this.ae, null) && this.r == false && nullableEquals(this.ag, null) && this.h == 2 && this.t == false);
    }
    ai(a, b = true) {
        a._b6 = this.q;
        if (b || a._a4 != this.c) {
            a.alignment = this.c;
        }
        let c = this.ah.getValueOrDefault1(0);
        if (b || a._cw != c) {
            a.rotation = c;
        }
        let d = XlsxUtilities.a6(this.u);
        if (b || nullableNotEquals(a._c7, d)) {
            a._wrapText$i = d;
        }
        if (b || a._a9 != this.i) {
            a.verticalAlignment = this.i;
        }
        let e = this.ab.getValueOrDefault1(0);
        if (b || a._ct != e) {
            a.indent = e;
        }
        let f = XlsxUtilities.a6(this.s);
        if (b || nullableNotEquals(a._c6, f)) {
            a._shrinkToFit$i = f;
        }
    }
    static d(a) {
        return AlignmentInfo.e(a, false);
    }
    static e(a, b) {
        let c = a._b6;
        let d = a._a4;
        let e = Nullable$1.toNullable(Number_$type, intSToU(a._ct));
        let f = Nullable$1.toNullable(Number_$type, intSToU(a._cw));
        let g = a._c6;
        let h = a._a9;
        let i = a._c7;
        if (b == false && c == false && d == 0 && nullableEquals(e, 0) && nullableEquals(f, 0) && nullableEquals(g, false) && nullableEquals(i, false) && h == 2) {
            return null;
        }
        return new AlignmentInfo(1, d, e, c, Nullable$1.toNullable(Number_$type, 0), Nullable$1.toNullable(Number_$type, 0), f, g, h, i);
    }
    static n(a, b) {
        if (Base.referenceEquals(a, null) && Base.referenceEquals(b, null)) {
            return true;
        }
        if (Base.referenceEquals(a, null) || Base.referenceEquals(b, null)) {
            return false;
        }
        return (a.b == b.b && nullableEquals(a.aa, b.aa) && a.p == b.p && nullableEquals(a.ac, b.ac) && nullableEquals(a.ae, b.ae) && a.r == b.r && nullableEquals(a.ag, b.ag) && a.h == b.h && a.t == b.t);
    }
}
AlignmentInfo.$t = markType(AlignmentInfo, 'AlignmentInfo');
AlignmentInfo.f = null;
/**
 * @hidden
 */
export class PatternFillInfo extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.d = null;
        this.i = Nullable$1.toNullable(FillPatternStyle_$type, null);
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(PatternFillInfo.$, a);
        if (b == null) {
            return false;
        }
        return nullableEquals(this.i, b.i) && Base.equalsStatic(this.c, b.c) && Base.equalsStatic(this.d, b.d);
    }
    getHashCode() {
        let a = Base.getHashCodeStatic(this.i);
        if (this.c != null) {
            a ^= this.c.getHashCode();
        }
        if (this.d != null) {
            a ^= this.d.getHashCode();
        }
        return a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get e() {
        return this.d;
    }
    set e(a) {
        this.d = a;
    }
    get j() {
        return this.i;
    }
    set j(a) {
        this.i = a;
    }
    static f(a, b, c) {
        let d = new PatternFillInfo();
        d.j = Nullable$1.toNullable(FillPatternStyle_$type, c.patternStyle);
        if (c.patternStyle == 0) {
            return d;
        }
        let e = c._aa(b);
        if (WorkbookColorInfo.l_op_Inequality(e, WorkbookColorInfo.automatic)) {
            d.e = ColorInfo.a(a, e, 1);
        }
        let f = c._y(b);
        if (WorkbookColorInfo.l_op_Inequality(f, new WorkbookColorInfo(SystemColorsInternal.bb))) {
            d.b = ColorInfo.a(a, f, 1);
        }
        return d;
    }
    a(a, b) {
        let c = 0;
        let d = new WorkbookColorInfo(SystemColorsInternal.bb);
        if (this.b != null) {
            c = 1;
            d = this.b.c(a);
        }
        let e = WorkbookColorInfo.automatic;
        if (this.e != null) {
            c = 1;
            e = this.e.c(a);
        }
        if (this.j.hasValue) {
            c = this.j.value;
        }
        return new CellFillPattern(d, e, c, b, true);
    }
}
PatternFillInfo.$t = markType(PatternFillInfo, 'PatternFillInfo');
/**
 * @hidden
 */
export class ObjectModelCommonPartHelpers extends Base {
    static e(a, b) {
        if (a != null) {
            a = stringReplace(a, "\r\n", b);
            a = stringReplace(a, "\n", b);
        }
        return a;
    }
    static b(a) {
        return a.d;
    }
    static f(a) {
        a.s.k(new CT_AbsoluteAnchor());
    }
    static g(a) {
        let b = a.s.a(WorksheetShape.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.tl(a, c, d);
        c = e.p1;
        d = e.p2;
        let f;
        if (c) {
            if (d) {
                f = 0;
            }
            else {
                f = 1;
            }
        }
        else {
            f = 2;
        }
        let g = ((() => {
            let $ret = new CT_TwoCellAnchor();
            $ret.e = f;
            return $ret;
        })());
        a.s.k(g);
    }
    static h(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.tp(a, c);
        c = d.p1;
        b._bold$i = XlsxUtilities.a6(c);
    }
    static i(a) {
        let b = a.s.a(EG_Anchor.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = DrawingMLSpreadsheetDrawing.en(a, c, d);
        c = e.p1;
        d = e.p2;
        b.a = ((() => {
            let $ret = new CT_AnchorClientData();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
    }
    static j(a) {
        let b = a.s.a(CT_Marker.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLSpreadsheetDrawing.eo(a, c);
        c = d.p1;
        b.c = c;
    }
    static k(a) {
        let b = a.s.a(CT_Marker.$);
        if (b == null) {
            return;
        }
        let c = new ST_Coordinate();
        let d = DrawingMLSpreadsheetDrawing.ep(a, c);
        c = d.p1;
        b.a = c;
    }
    static l(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b != null ? b.s.a(ConditionalFormatInfo.$) : null;
        if (c != null) {
            ObjectModelWorksheetPartManager.cr(a);
            return;
        }
        let d = a.s.a(ColorInfo.$);
        if (d == null) {
            return;
        }
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.ue(a, e, f, g, h, i);
        e = j.p1;
        f = j.p2;
        g = j.p3;
        h = j.p4;
        i = j.p5;
        d.i = e;
        d.j = f;
        d.k = g;
        d.l = h;
        d.g = i;
    }
    static c(a, b) {
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = b(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        if (nullableEquals(c, true)) {
            return WorkbookColorInfo.automatic;
        }
        let i = g == 0 ? Nullable$1.toNullable(Number_$type, null) : Nullable$1.toNullable(Number_$type, g);
        if (nullableNotEquals(e, null)) {
            return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, ExcelUtils.gx(ST_UnsignedIntHex.h(e.value))), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), i, true, false);
        }
        if (nullableNotEquals(f, null)) {
            return new WorkbookColorInfo(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, f.value), i, true, false);
        }
        if (nullableNotEquals(d, null)) {
            return new WorkbookColorInfo(ObjectModelCommonPartHelpers.b(a)._by, d.value);
        }
        return WorkbookColorInfo.automatic;
    }
    static a(a, b) {
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = b(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        return ((() => {
            let $ret = new ColorInfo();
            $ret.i = c;
            $ret.j = d;
            $ret.k = e;
            $ret.l = f;
            $ret.g = g;
            return $ret;
        })());
    }
    static m(a) {
        let b = ObjectModelCommonPartHelpers.b(a);
        let c = b._by;
        let d = a.s.a(ExternalWorkbookReference.$);
        if (d != null) {
            ObjectModelCommonPartHelpers.n(a, b, c, d);
            return;
        }
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u = SpreadsheetMLMain.vc(a, f, e, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
        f = u.p1;
        e = u.p2;
        g = u.p3;
        h = u.p4;
        i = u.p5;
        j = u.p6;
        k = u.p7;
        l = u.p8;
        m = u.p9;
        n = u.p10;
        o = u.p11;
        p = u.p12;
        q = u.p13;
        r = u.p14;
        s = u.p15;
        t = u.p16;
        let v = false;
        if (stringStartsWith(e, "_xlnm.")) {
            e = e.substr("_xlnm.".length);
            v = true;
        }
        let w;
        if (nullableNotEquals(l, null) && l.value < c._worksheets$i.count) {
            w = c._worksheets$i._item(l.value);
        }
        else {
            w = c;
        }
        let x = new NamedReference(1, c._namedReferences$i, w, m);
        x.name = e;
        x._v = n;
        x.comment = g;
        let y = WorkbookLoadManagerExcel2007._bs(f);
        f = y.p0;
        let z = Formula._k(f, c.cellReferenceMode, 3, c.currentFormat, CultureInfo.invariantCulture, b._b7._bi);
        x._bb(z, false);
        let aa = new WorkbookLoadManagerExcel2007_NamedReferenceInfo();
        aa.b = m;
        aa.a = x;
        b._b7._bh.add(aa);
    }
    static n(a, b, c, d) {
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.vb(a, e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        let i = b._b7._i;
        let j = i._inner[i.count - 1];
        let k = j;
        if (nullableNotEquals(g, null)) {
            k = j.i(g.value);
        }
        let l = j.c(e, k, true);
        if (f == null) {
            return;
        }
        if (stringStartsWith(f, "=") == false) {
            f = "=" + f;
        }
        let m;
        let n;
        if (false == ((() => { let o = Formula._a0(f, 1, 4, c.currentFormat, CultureInfo.invariantCulture, b._b7._bi, m, n); m = o.p6; n = o.p7; return o.ret; })())) {
            m = Formula._k("=#REF!", 1, 4, c.currentFormat, CultureInfo.invariantCulture, b._b7._bi);
        }
        for (let o = 0; o < m._e.length; o++) {
            let p = typeCast(ReferenceToken.$, m._e[o]);
            if (p == null || p.q == false) {
                continue;
            }
            p.s(d);
        }
        l._j = m;
    }
    static o(a) {
    }
    static p(a) {
        let b = new ST_PositiveCoordinate();
        let c = new ST_PositiveCoordinate();
        let d = DrawingMLSpreadsheetDrawing.er(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ((() => {
            let $ret = new CT_PositiveSize2D();
            $ret.a = b;
            $ret.b = c;
            return $ret;
        })());
        let f = a.s.a(CT_OneCellAnchor.$);
        if (f != null) {
            f.c = e;
            return;
        }
        let g = a.s.a(CT_AbsoluteAnchor.$);
        if (g != null) {
            g.d = e;
            return;
        }
    }
    static q(a) {
        let b;
        let c = SpreadsheetMLMain.vw(a, b);
        b = c.p1;
    }
    static r(a) {
        let b = new CT_Marker();
        a.s.k(b);
        let c = a.s.a(CT_TwoCellAnchor.$);
        if (c != null) {
            c.c = b;
            return;
        }
        let d = a.s.a(CT_OneCellAnchor.$);
        if (d != null) {
            d.d = b;
            return;
        }
    }
    static s(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.wl(a, c);
        c = d.p1;
        b._italic$i = XlsxUtilities.a6(c);
    }
    static t(a, b) {
        let c = a.s.a(IWorkbookFont_$type);
        if (c == null) {
            return;
        }
        let d;
        let e = b(a, d);
        d = e.p1;
        c.name = d;
    }
    static u(a) {
        a.s.k(new CT_OneCellAnchor());
    }
    static v(a) {
        let b = a.s.a(CT_AbsoluteAnchor.$);
        if (b == null) {
            return;
        }
        let c = new ST_Coordinate();
        let d = new ST_Coordinate();
        let e = DrawingMLSpreadsheetDrawing.eu(a, c, d);
        c = e.p1;
        d = e.p2;
        b.c = ((() => {
            let $ret = new CT_Point2D();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
    }
    static w(a) {
    }
    static x(a) {
        let b = a.s.a(CT_Marker.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLSpreadsheetDrawing.ev(a, c);
        c = d.p1;
        b.d = c;
    }
    static y(a) {
        let b = a.s.a(CT_Marker.$);
        if (b == null) {
            return;
        }
        let c = new ST_Coordinate();
        let d = DrawingMLSpreadsheetDrawing.ew(a, c);
        c = d.p1;
        b.b = c;
    }
    static z(a) {
        let b = a.s.a(FormattedStringElement.$);
        if (b == null) {
            return;
        }
        let c = 0;
        let d = b._y;
        if (d != null) {
            c = b._y.length;
        }
        let e = new FormattedStringRun(b, c);
        b._ah.add(e);
        a.s.k(e.f(ObjectModelCommonPartHelpers.b(a)._by));
        let f = new ColorInfo();
        a.s.k(f);
    }
    static aa(a) {
        let b = a.s.a(ColorInfo.$);
        let c = a.s.a(WorkbookFontProxy.$);
        if (b == null || c == null) {
            return;
        }
        let d = ObjectModelCommonPartHelpers.b(a);
        if (b.f == false) {
            c.colorInfo = b.c(d._b7);
        }
        c.setFontFormatting(c.d._ak(a.s.a(IWorkbookFontDefaultsResolver_$type)));
    }
    static ac(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.yb(a, c);
        c = d.p1;
        b._strikeout$i = XlsxUtilities.a6(c);
    }
    static ad(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.yd(a, c);
        c = d.p1;
        b.height = Convert.toInt32(c * 20);
    }
    static ae(a) {
        let b = a.s.a(StringElement.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.yo(a, c);
        c = d.p1;
        b._y = c == null ? b._y : stringConcat(b._y, c);
    }
    static af(a) {
        let b = a.s.a(CT_TwoCellAnchor.$);
        if (b == null) {
            return;
        }
        let c = new CT_Marker();
        b.d = c;
        a.s.k(c);
    }
    static ag(a) {
        let b;
        let c = DrawingMLSpreadsheetDrawing.ez(a, b);
        b = c.p1;
        a.s.k(((() => {
            let $ret = new CT_TwoCellAnchor();
            $ret.e = b;
            return $ret;
        })()));
    }
    static ah(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.yt(a, c);
        c = d.p1;
        b.underlineStyle = XlsxUtilities.i(c);
    }
    static d(a, b) {
        let c;
        let d = SpreadsheetMLMain.yu(a, c);
        c = d.p1;
        let e = ObjectModelCommonPartHelpers.b(a);
        let f = a.s.a(ST_CellType_$type);
        let t1 = f;
        L0: while (true) {
            switch (t1) {
                case 0: return ST_OnOff.e(c);
                case 1: return dateParse(c);
                case 3: return FormulaParser.b(c, CultureInfo.invariantCulture);
                case 2:
                    if (c == null) {
                        return null;
                    }
                    switch (c) {
                        case "0": return KnownBoxes.x;
                        case "1": return KnownBoxes.w;
                        default: return ObjectModelCommonPartHelpers_DoubleValueCache.f(c);
                    }
                case 6:
                case 5: return c != null ? c : stringEmpty();
                case 4:
                    if (c == null) {
                        return null;
                    }
                    let g;
                    if (((() => { let h = tryParseInt32_1(c, g); g = h.p1; return h.ret; })()) == false) {
                        return null;
                    }
                    let h = e._b7;
                    if (g >= h._u.count) {
                        return null;
                    }
                    let i = h._u._inner[g];
                    let j = typeCast(FormattedStringElement.$, i);
                    if (j != null && j._u) {
                        return new FormattedString(e._by, j);
                    }
                    return i;
                default:
                    t1 = 6;
                    continue L0;
            }
            break;
        }
    }
    static ai(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.yv(a, c);
        c = d.p1;
        b.superscriptSubscriptStyle = XlsxUtilities.g(c);
    }
    static ab(a) {
        let b = a.s.a(IWorkbookFont_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.xo(a, c);
        c = d.p1;
        let e = ObjectModelCommonPartHelpers.b(a)._b7;
        let f = null;
        switch (c) {
            case 1:
                f = e._al;
                break;
            case 2:
                f = e._am;
                break;
            case 0: break;
            default: break;
        }
        if (f != null) {
            let g = f.e();
            if (g != null) {
                b.name = g;
            }
        }
    }
    static aj(a) {
        a.ay(SpreadsheetMLMain.gg, ObjectModelCommonPartHelpers.m);
        a.ay(SpreadsheetMLMain.gh, ObjectModelCommonPartHelpers.o);
    }
    static ak(a, b, c) {
        a.ay(SpreadsheetMLMain.dc, ObjectModelCommonPartHelpers.h);
        a.ay(SpreadsheetMLMain.et, ObjectModelCommonPartHelpers.l);
        a.ay(SpreadsheetMLMain.hr, ObjectModelCommonPartHelpers.q);
        a.ay(SpreadsheetMLMain.jo, ObjectModelCommonPartHelpers.s);
        a.ay(b, (d) => ObjectModelCommonPartHelpers.t(d, c));
        a.ay(SpreadsheetMLMain.qe, ObjectModelCommonPartHelpers.ac);
        a.ay(SpreadsheetMLMain.qm, ObjectModelCommonPartHelpers.ad);
        a.ay(SpreadsheetMLMain.rt, ObjectModelCommonPartHelpers.ah);
        a.ay(SpreadsheetMLMain.r7, ObjectModelCommonPartHelpers.ai);
        a.ay(SpreadsheetMLMain.oe, ObjectModelCommonPartHelpers.ab);
    }
    static al(a) {
        a.ay(SpreadsheetMLMain.m7, ObjectModelCommonPartHelpers.w);
        a.ay(SpreadsheetMLMain.n6, ObjectModelCommonPartHelpers.z);
        a.ax(SpreadsheetMLMain.n6, ObjectModelCommonPartHelpers.aa);
        a.ay(SpreadsheetMLMain.qn, ObjectModelCommonPartHelpers.ae);
        ObjectModelCommonPartHelpers.ak(a, SpreadsheetMLMain.nv, SpreadsheetMLMain.xh);
    }
    static am(a) {
        a.ay(SpreadsheetMLMain.co, ObjectModelCommonPartHelpers.g);
        a.ay(DrawingMLSpreadsheetDrawing.ds, ObjectModelCommonPartHelpers.f);
        a.ay(DrawingMLSpreadsheetDrawing.dt, ObjectModelCommonPartHelpers.i);
        a.ay(DrawingMLSpreadsheetDrawing.dw, ObjectModelCommonPartHelpers.j);
        a.ay(DrawingMLSpreadsheetDrawing.dx, ObjectModelCommonPartHelpers.k);
        a.ay(DrawingMLSpreadsheetDrawing.d0, ObjectModelCommonPartHelpers.p);
        a.ay(DrawingMLSpreadsheetDrawing.d3, ObjectModelCommonPartHelpers.r);
        a.ay(DrawingMLSpreadsheetDrawing.ea, ObjectModelCommonPartHelpers.u);
        a.ay(DrawingMLSpreadsheetDrawing.ec, ObjectModelCommonPartHelpers.v);
        a.ay(DrawingMLSpreadsheetDrawing.ed, ObjectModelCommonPartHelpers.x);
        a.ay(DrawingMLSpreadsheetDrawing.ee, ObjectModelCommonPartHelpers.y);
        a.ay(DrawingMLSpreadsheetDrawing.ei, ObjectModelCommonPartHelpers.af);
        a.ay(DrawingMLSpreadsheetDrawing.ej, ObjectModelCommonPartHelpers.ag);
    }
    static ao(a, b, c, d) {
        let e = ObjectModelCommonPartHelpers.b(a)._by;
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = 0;
        if (b.isAutomatic) {
            f = Nullable$1.toNullable(Boolean_$type, true);
        }
        else if (b._color$i.hasValue) {
            let k = b._color$i.value;
            if (ExcelUtils.am(k)) {
                g = Nullable$1.toNullable(Number_$type, intSToU(b._y(e, c)));
            }
            else {
                h = Nullable$1.toNullable(ST_UnsignedIntHex.$, new ST_UnsignedIntHex(1, intSToU(ExcelUtils.cx(k))));
            }
        }
        else if (b._themeColorType$i.hasValue) {
            i = Nullable$1.toNullable(Number_$type, b._themeColorType$i.value);
        }
        else {
        }
        if (b._tint$i.hasValue) {
            j = b._tint$i.value;
        }
        d(a, f, g, h, i, j);
        a.ad.k();
    }
    static an(a, b, c) {
        if (b == null || b.f) {
            return;
        }
        c(a, b.i, b.j, b.k, b.l, b.g);
        a.ad.k();
    }
    static ap(a, b) {
        let c = b.name;
        let d = typeCast(NamedReference.$, b);
        if (d != null) {
            if (d._r) {
                c = "_xlnm." + c;
            }
            let e = Nullable$1.toNullable(Number_$type, null);
            let f = typeCast(Worksheet.$, d.scope);
            if (f != null) {
                e = Nullable$1.toNullable(Number_$type, intSToU(ObjectModelCommonPartHelpers.b(a)._b9._az.indexOf(f)));
            }
            let g = null;
            if (d._j != null) {
                g = ObjectModelCommonPartHelpers.b(a)._b9._ct(d._j);
            }
            SpreadsheetMLMain.aax(a, g, c, d.comment, void 0, void 0, void 0, void 0, e, d._p, d._v);
            a.ad.k();
        }
        else {
            SpreadsheetMLMain.aaw(a, b.name);
            a.ad.k();
        }
    }
    static aq(a, b) {
        if (b.u.count == 0) {
            return;
        }
        SpreadsheetMLMain.aay(a);
        for (let c of fromEnum(b.u)) {
            if (c._j == null || c._j._e.length == 0) {
                continue;
            }
            ObjectModelCommonPartHelpers.ap(a, c);
        }
        a.ad.k();
    }
    static as(a, b) {
        ObjectModelCommonPartHelpers.ar(a, b);
    }
    static ar(a, b) {
        ObjectModelCommonPartHelpers.at(a, b, SpreadsheetMLMain.abu, SpreadsheetMLMain.acf);
    }
    static at(a, b, c, d) {
        if (b == null) {
            return;
        }
        c(a);
        let e = 2;
        if (stringIsNullOrEmpty(b.name) == false) {
            d(a, b.name);
            a.ad.k();
            e = ExcelUtils.s(b.name);
        }
        if (e != 0) {
            SpreadsheetMLMain.abh(a, e);
            a.ad.k();
        }
        if (nullableEquals(b._bold$i, true)) {
            SpreadsheetMLMain.za(a);
            a.ad.k();
        }
        if (nullableEquals(b._italic$i, true)) {
            SpreadsheetMLMain.ab7(a);
            a.ad.k();
        }
        if (nullableEquals(b._strikeout$i, true)) {
            SpreadsheetMLMain.ady(a);
            a.ad.k();
        }
        if (WorkbookColorInfo.l_op_Inequality(b.colorInfo, null)) {
            ObjectModelCommonPartHelpers.ao(a, b.colorInfo, 2, SpreadsheetMLMain.zy);
        }
        SpreadsheetMLMain.ad0(a, b.height / 20);
        a.ad.k();
        if (b.underlineStyle != 0 && b.underlineStyle != -1) {
            SpreadsheetMLMain.aeg(a, XlsxUtilities.a5(b.underlineStyle));
            a.ad.k();
        }
        if (b.superscriptSubscriptStyle != 0 && b.superscriptSubscriptStyle != -1) {
            SpreadsheetMLMain.aej(a, XlsxUtilities.al(b.superscriptSubscriptStyle));
            a.ad.k();
        }
        let f;
        if (b.name == "Calibri") {
            f = 2;
        }
        else if (b.name == "Cambria") {
            f = 1;
        }
        else {
            f = 0;
        }
        if (f != 0) {
            SpreadsheetMLMain.ada(a, f);
            a.ad.k();
        }
        a.ad.k();
    }
    static au(a, b, c, d) {
        d(a);
        let e = c._y;
        let f = typeCast(FormattedStringElement.$, c);
        if (f != null && f._u) {
            let g = f._ah;
            let h = g._inner[0].i;
            if (0 < h) {
                SpreadsheetMLMain.aeb(a, e.substr(0, h));
                a.ad.k();
            }
            for (let i = 0; i < g.count; i++) {
                ObjectModelCommonPartHelpers.av(a, b, g._inner[i]);
            }
        }
        else {
            SpreadsheetMLMain.aeb(a, e);
            a.ad.k();
        }
        a.ad.k();
    }
    static av(a, b, c) {
        SpreadsheetMLMain.ac2(a);
        let d = c.f(b._b);
        if (c.i != 0 || d._r.getValueOrDefault() != 0) {
            if (nullableLessThan(d._r, b._h.count)) {
                let e = b._h._inner[d._r.value];
                ObjectModelCommonPartHelpers.aw(a, e);
            }
            else {
            }
        }
        SpreadsheetMLMain.aeb(a, c.l);
        a.ad.k();
        a.ad.k();
    }
    static aw(a, b) {
        ObjectModelCommonPartHelpers.at(a, b, SpreadsheetMLMain.ac9, SpreadsheetMLMain.ac3);
    }
}
ObjectModelCommonPartHelpers.$t = markType(ObjectModelCommonPartHelpers, 'ObjectModelCommonPartHelpers');
/**
 * @hidden
 */
export class BorderStyleInfo extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.b = -1;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(BorderStyleInfo.$, a);
        if (b == null) {
            return false;
        }
        return this.b == b.b && Base.equalsStatic(this.c, b.c);
    }
    getHashCode() {
        let a = Base.getHashCodeStatic(this.b);
        if (this.c != null) {
            a ^= this.c.getHashCode();
        }
        return a;
    }
    get f() {
        if (this.c != null && this.c.f == false) {
            return false;
        }
        if (this.b != -1) {
            return false;
        }
        return true;
    }
    get d() {
        if (this.c == null) {
            this.c = new ColorInfo();
        }
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
}
BorderStyleInfo.$t = markType(BorderStyleInfo, 'BorderStyleInfo');
/**
 * @hidden
 */
export class GradientFillInfo extends Base {
    constructor() {
        super(...arguments);
        this.g = new List$1(StopInfo.$, 0);
        this.i = 0;
        this.v = 0;
        this.t = 0;
        this.r = 0;
        this.p = 0;
        this.d = 0;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(GradientFillInfo.$, a);
        if (b == null) {
            return false;
        }
        if (this.i != b.i || this.p != b.p || this.d != b.d || this.r != b.r || this.t != b.t || this.v != b.v || this.g.count != b.g.count) {
            return false;
        }
        for (let c = 0; c < this.g.count; c++) {
            if (Base.equalsStatic(this.g._inner[c], b.g._inner[c]) == false) {
                return false;
            }
        }
        return true;
    }
    getHashCode() {
        let a = (this.i) ^ (this.v) ^ (this.t) ^ (this.r) ^ (this.p) ^ Base.getHashCodeStatic(this.d) ^ this.g.count;
        if (this.g.count != 0) {
            a ^= this.g._inner[0].getHashCode();
            a ^= this.g._inner[this.g.count - 1].getHashCode();
        }
        return a;
    }
    get h() {
        return this.g;
    }
    get j() {
        return this.i;
    }
    set j(a) {
        this.i = a;
    }
    get w() {
        return this.v;
    }
    set w(a) {
        this.v = a;
    }
    get s() {
        return this.r;
    }
    set s(a) {
        this.r = a;
    }
    get u() {
        return this.t;
    }
    set u(a) {
        this.t = a;
    }
    get q() {
        return this.p;
    }
    set q(a) {
        this.p = a;
    }
    get e() {
        return this.d;
    }
    set e(a) {
        this.d = a;
    }
    static b(a, b) {
        let c = new GradientFillInfo();
        for (let d = 0; d < b.stops.count; d++) {
            c.h.add(StopInfo.d(a, b.stops.item(d)));
        }
        let e = typeCast(CellFillLinearGradient.$, b);
        let f = typeCast(CellFillRectangularGradient.$, b);
        if (e != null) {
            c.e = 0;
            c.q = e.angle;
        }
        else if (f != null) {
            c.e = 1;
            c.j = f.bottom;
            c.s = f.left;
            c.u = f.right;
            c.w = f.top;
        }
        else {
        }
        return c;
    }
    a(a) {
        let b = new Array(this.h.count);
        for (let c = 0; c < b.length; c++) {
            b[c] = this.h._inner[c].a(a);
        }
        switch (this.e) {
            case 0: return CellFill._createLinearGradientFill(this.q, ...b);
            case 1: return CellFill._createRectangularGradientFill1(this.s, this.w, this.u, this.j, ...b);
            default: return null;
        }
    }
}
GradientFillInfo.$t = markType(GradientFillInfo, 'GradientFillInfo');
/**
 * @hidden
 */
export class StopInfo extends Base {
    constructor() {
        super(...arguments);
        this.f = 0;
        this.b = null;
    }
    get g() {
        return this.f;
    }
    set g(a) {
        this.f = a;
    }
    get c() {
        return this.b;
    }
    set c(a) {
        this.b = a;
    }
    equals(a) {
        if (Base.referenceEquals(this, a)) {
            return true;
        }
        let b = typeCast(StopInfo.$, a);
        if (b == null) {
            return false;
        }
        return Base.equalsStatic(this.f, b.f) && Base.equalsStatic(this.b, b.b);
    }
    getHashCode() {
        let a = (this.f);
        if (this.b != null) {
            a ^= this.b.getHashCode();
        }
        return a;
    }
    static d(a, b) {
        let c = new StopInfo();
        c.c = ColorInfo.a(a, b.colorInfo, 1);
        c.g = b.offset;
        return c;
    }
    a(a) {
        let b = new WorkbookColorInfo(ColorsInternal.a);
        if (this.c != null) {
            b = this.c.c(a);
        }
        return new CellFillGradientStop(b, this.g);
    }
}
StopInfo.$t = markType(StopInfo, 'StopInfo');
/**
 * @hidden
 */
export class SerializationNumberFormatInfo extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.c = 0;
    }
    d(a) {
        if (stringIsNullOrEmpty(this.b) == false) {
            a.formatString = this.b;
        }
        else if (this.c >= 0) {
            a.formatString = a.v._b2.item(this.c);
        }
    }
    static a(a) {
        let b = a._cs;
        return ((() => {
            let $ret = new SerializationNumberFormatInfo();
            $ret.b = a.v._b2.ad(b);
            $ret.c = intSToU(b);
            return $ret;
        })());
    }
}
SerializationNumberFormatInfo.$t = markType(SerializationNumberFormatInfo, 'SerializationNumberFormatInfo');
/**
 * @hidden
 */
export class ProtectionInfo extends Base {
    constructor() {
        super(...arguments);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
    }
    equals(a) {
        return ProtectionInfo.d(this, typeCast(ProtectionInfo.$, a));
    }
    getHashCode() {
        let a = 0;
        a ^= Convert.toInt321(unwrapNullable(this.g));
        a ^= Convert.toInt321(unwrapNullable(this.i)) << 1;
        return a;
    }
    get h() {
        return this.g;
    }
    set h(a) {
        this.g = a;
    }
    get j() {
        return this.i;
    }
    set j(a) {
        this.i = a;
    }
    get e() {
        return nullableEquals(this.g, null) && nullableEquals(this.i, null);
    }
    k(a) {
        a._locked$i = XlsxUtilities.a7(this.j);
    }
    static a(a) {
        return ProtectionInfo.b(a, false);
    }
    static b(a, b) {
        let c = a._c5;
        if (b == false && nullableEquals(c, true)) {
            return null;
        }
        let d = new ProtectionInfo();
        d.j = Nullable$1.toNullable(Boolean_$type, (nullableEquals(c, true)));
        return d;
    }
    static d(a, b) {
        if (Base.referenceEquals(a, null) && Base.referenceEquals(b, null)) {
            return true;
        }
        if (Base.referenceEquals(a, null) || Base.referenceEquals(b, null)) {
            return false;
        }
        return (nullableEquals(a.g, b.g) && nullableEquals(a.i, b.i));
    }
}
ProtectionInfo.$t = markType(ProtectionInfo, 'ProtectionInfo');
/**
 * @hidden
 */
export class ObjectModelStylesPartManager_TableStylesCollectionInfo extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
}
ObjectModelStylesPartManager_TableStylesCollectionInfo.$t = markType(ObjectModelStylesPartManager_TableStylesCollectionInfo, 'ObjectModelStylesPartManager_TableStylesCollectionInfo');
/**
 * @hidden
 */
export class ObjectModelTablePartManager_FilterColumnElementContext extends Base {
    constructor(a) {
        super();
        this.c = 0;
        this.a = null;
        this.c = a;
    }
    get d() {
        return this.c;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
}
ObjectModelTablePartManager_FilterColumnElementContext.$t = markType(ObjectModelTablePartManager_FilterColumnElementContext, 'ObjectModelTablePartManager_FilterColumnElementContext');
/**
 * @hidden
 */
export class ObjectModelTablePartManager_CustomFilterContext extends Base {
    constructor(a) {
        super();
        this.a = 0;
        this.c = null;
        this.d = null;
        this.a = a;
    }
    e(a) {
        if (this.c == null) {
            this.c = a;
            return;
        }
        if (this.d == null) {
            this.d = a;
            return;
        }
    }
    b() {
        if (this.c == null && this.d == null) {
            return null;
        }
        return new CustomFilter(1, null, this.c, this.d, this.a);
    }
}
ObjectModelTablePartManager_CustomFilterContext.$t = markType(ObjectModelTablePartManager_CustomFilterContext, 'ObjectModelTablePartManager_CustomFilterContext');
/**
 * @hidden
 */
export class ObjectModelTablePartManager_TableContext extends Base {
    constructor(a) {
        super();
        this.b = null;
        this.c = null;
        this.a = null;
        this.a = a;
    }
    d(a, b) {
        if (b == null) {
            return;
        }
        if (this.b == null) {
            this.b = new Dictionary$2(Number_$type, Filter.$, 0);
        }
        this.b.item(a, b);
    }
    e(a, b) {
        if (this.c == null) {
            this.c = new List$1(KeyValuePair$2.$.specialize(Number_$type, SortCondition.$), 0);
        }
        this.c.add(new KeyValuePair$2(Number_$type, SortCondition.$, 1, a, b));
    }
    f() {
        if (this.b != null) {
            for (let a of fromEnum(this.b)) {
                let b = a.key;
                if (b < 0 || this.a._columns$i.count <= b) {
                    continue;
                }
                let c = this.a._columns$i._item(b);
                if (c == null) {
                    continue;
                }
                let d = a.value;
                d._j(c);
                c.filter = d;
            }
        }
        if (this.c != null) {
            for (let e of fromEnum(this.c)) {
                let f = e.key - this.a._by._w;
                if (f < 0 || this.a._columns$i.count <= f) {
                    continue;
                }
                let g = this.a._columns$i._item(f);
                this.a.sortSettings._sortConditions$i._addItem$i(g, e.value);
            }
        }
    }
}
ObjectModelTablePartManager_TableContext.$t = markType(ObjectModelTablePartManager_TableContext, 'ObjectModelTablePartManager_TableContext');
/**
 * @hidden
 */
export class ObjectModelTablePartManager extends TablePartManager {
    constructor() {
        super();
        this.ay(SpreadsheetMLMain.c5, ObjectModelTablePartManager.bc);
        this.ay(SpreadsheetMLMain.d1, ObjectModelTablePartManager.bd);
        this.ay(SpreadsheetMLMain.eu, ObjectModelTablePartManager.be);
        this.ay(SpreadsheetMLMain.fj, ObjectModelTablePartManager.bf);
        this.ay(SpreadsheetMLMain.fk, ObjectModelTablePartManager.bg);
        this.ax(SpreadsheetMLMain.fk, ObjectModelTablePartManager.bh);
        this.ay(SpreadsheetMLMain.f1, ObjectModelTablePartManager.bi);
        this.ay(SpreadsheetMLMain.g8, ObjectModelTablePartManager.bj);
        this.ay(SpreadsheetMLMain.hy, ObjectModelTablePartManager.bm);
        this.ay(SpreadsheetMLMain.h0, ObjectModelTablePartManager.bk);
        this.ax(SpreadsheetMLMain.h0, ObjectModelTablePartManager.bl);
        this.ay(SpreadsheetMLMain.h3, ObjectModelTablePartManager.bn);
        this.ay(SpreadsheetMLMain.jq, ObjectModelTablePartManager.bo);
        this.ay(SpreadsheetMLMain.p1, ObjectModelTablePartManager.bp);
        this.ay(SpreadsheetMLMain.p3, ObjectModelTablePartManager.bq);
        this.ay(SpreadsheetMLMain.qq, ObjectModelTablePartManager.bt);
        this.ax(SpreadsheetMLMain.qq, ObjectModelTablePartManager.bu);
        this.ay(SpreadsheetMLMain.qt, ObjectModelTablePartManager.br);
        this.ay(SpreadsheetMLMain.qu, ObjectModelTablePartManager.bs);
        this.ay(SpreadsheetMLMain.qz, ObjectModelTablePartManager.bv);
        this.ay(SpreadsheetMLMain.rg, ObjectModelTablePartManager.bw);
        this.ay(SpreadsheetMLMain.rm, ObjectModelTablePartManager.bx);
        this.ay(SpreadsheetML2009Main.br, ObjectModelTablePartManager.bo);
        this.ay(SpreadsheetML2009Main.cl, ObjectModelTablePartManager.bp);
    }
    u(a) {
        let b = typeCast(WorksheetTable.$, a);
        if (b == null) {
            return null;
        }
        let c = this.a7._b9;
        let d;
        let e;
        let f = ObjectModelTablePartManager.by(WorksheetTableArea_$type, c, b._areaFormats$i, 1, d, e);
        d = f.p3;
        e = f.p4;
        let g;
        let h;
        let i;
        let j = ObjectModelTablePartManager.bz(WorksheetTableArea_$type, c, b._areaFormats$i, 2, g, h, i, 2, 4);
        g = j.p3;
        h = j.p4;
        i = j.p5;
        let k;
        let l;
        let m;
        let n = ObjectModelTablePartManager.bz(WorksheetTableArea_$type, c, b._areaFormats$i, 0, k, l, m, 262144, 524288, 67108864, 134217728, 2097152, 4194304, 2, 4);
        k = n.p3;
        l = n.p4;
        m = n.p5;
        let o;
        let p;
        let q;
        let r = ObjectModelTablePartManager.bz(WorksheetTableArea_$type, c, b._areaFormats$i, 3, o, p, q, 67108864, 134217728);
        o = r.p3;
        p = r.p4;
        q = r.p5;
        SpreadsheetMLMain.ad4(this, b._ds, b.name, b.name, b.comment, b.wholeTableRegion._toString2(1, false, true, true), void 0, b.isHeaderRowVisible ? 1 : 0, b._cs, b._c5, b.isTotalsRowVisible ? 1 : 0, b._cm, b._c0, h, e, p, i, m, q, g, d, o);
        if (b.isFilterUIVisible) {
            this.b0(c, b);
        }
        if (b.sortSettings._o) {
            this.b8(c, b);
        }
        this.b9(c, b);
        this.ca(b);
        this.ad.k();
        return null;
    }
    static ba($t, a, b, c, d, e, f) {
        ObjectModelTablePartManager.bb($t, a, b, c, d, e, f, Nullable$1.toNullable(Number_$type, null));
    }
    static bb($t, a, b, c, d, e, f, g, ...h) {
        let i = a._by;
        let j = null;
        if (stringIsNullOrEmpty(e) == false) {
            j = i._styles$i._item1(e);
        }
        let k = null;
        if (f.hasValue) {
            k = a._b7._g._inner[f.value]._bu();
        }
        let l = null;
        if (g.hasValue) {
            l = a._b7._g._inner[g.value]._bu();
        }
        a._b7._ad($t, b, c, d, j, k, l, ...h);
    }
    static bc(a) {
        let b;
        let c = SpreadsheetMLMain.to(a, b);
        b = c.p1;
        let d = a.s.a(WorksheetTable.$);
        if (d != null && d.isHeaderRowVisible) {
            d.isFilterUIVisible = true;
        }
    }
    static bd(a) {
        let b = a.s.a(WorksheetTableColumn.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.tx(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ObjectModelTablePartManager.a8(a)._by;
        b._setColumnFormula1(ObjectModelTablePartManager.a6(f, c, d), false);
    }
    static be(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.uf(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ObjectModelTablePartManager.a8(a)._b7._g._inner[c.value];
        if (d) {
            b.b = FillFilter._p(null, f);
        }
        else {
            b.b = FontColorFilter._n(null, f);
        }
    }
    static bf(a) {
        let b = a.s.a(ObjectModelTablePartManager_CustomFilterContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.ux(a, c, d);
        c = e.p1;
        d = e.p2;
        let f;
        let g;
        if (((() => { let h = tryParseNumber1(c, 167, CultureInfo.invariantCulture, g); g = h.p3; return h.ret; })())) {
            f = g;
        }
        else {
            f = c;
        }
        let h = CustomFilterCondition._a(d, f);
        if (h != null) {
            b.e(h);
        }
    }
    static bg(a) {
        let b;
        let c = SpreadsheetMLMain.uy(a, b);
        b = c.p1;
        a.s.k(new ObjectModelTablePartManager_CustomFilterContext(b ? 0 : 1));
    }
    static bh(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        let c = a.s.a(ObjectModelTablePartManager_CustomFilterContext.$);
        if (b == null || c == null) {
            return;
        }
        b.b = c.b();
    }
    static bi(a) {
        let b = a.s.a(FixedValuesFilter.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.u7(a, c, d, e, f, g, h, i);
        c = j.p1;
        d = j.p2;
        e = j.p3;
        f = j.p4;
        g = j.p5;
        h = j.p6;
        i = j.p7;
        let k = FixedDateGroup._b(c, d, e, f, g, h, i);
        if (k != null) {
            b._dateGroups$i.add(k);
        }
    }
    static bj(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        if (b == null) {
            return;
        }
        let c = ObjectModelTablePartManager.a8(a);
        let d = c._b7;
        let e;
        let f;
        if (a.d._z == 0) {
            let g;
            let h = SpreadsheetMLMain.vk(a, e, f, g);
            e = h.p1;
            f = h.p2;
            g = h.p3;
            b.b = DynamicValuesFilter._l(d, null, e, f, g);
        }
        else {
            let i;
            let j;
            let k = SpreadsheetMLMain.vl(a, e, f, i, j);
            e = k.p1;
            f = k.p2;
            i = k.p3;
            j = k.p4;
            b.b = DynamicValuesFilter._k(null, e, f, i, j);
        }
    }
    static bm(a) {
        let b = a.s.a(FixedValuesFilter.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.v5(a, c);
        c = d.p1;
        b._displayValues$i.add(c);
    }
    static bk(a) {
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.v4(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        a.s.k(new ObjectModelTablePartManager_FilterColumnElementContext(b));
    }
    static bl(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        let c = a.s.a(ObjectModelTablePartManager_TableContext.$);
        if (b == null || c == null) {
            return;
        }
        c.d(b.d, b.b);
    }
    static bn(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.v6(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new FixedValuesFilter(null);
            $ret.calendarType = XlsxUtilities.f(d);
            $ret.includeBlanks = c;
            return $ret;
        })());
        b.b = f;
        a.s.k(f);
    }
    static bo(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.wj(a, c, d);
        c = e.p1;
        d = e.p2;
        b.b = new IconFilter(null, c, d);
    }
    static bp(a) {
        let b = a.s.a(ObjectModelTablePartManager_TableContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.x6(a, c, d, e, f, g, h, i);
        c = j.p1;
        d = j.p2;
        e = j.p3;
        f = j.p4;
        g = j.p5;
        h = j.p6;
        i = j.p7;
        if (stringIsNullOrEmpty(c)) {
            return;
        }
        let k = ObjectModelTablePartManager.a8(a);
        let l;
        let m;
        let n;
        let o;
        let p = ExcelUtils.fv(c, k._by.currentFormat, 1, CultureInfo.invariantCulture, null, -1, l, m, n, o);
        l = p.p6;
        m = p.p7;
        n = p.p8;
        o = p.p9;
        let q = d ? 1 : 0;
        let r;
        switch (e) {
            case 1:
                r = FillSortCondition._k(k._b7, g, q);
                break;
            case 2:
                r = FontColorSortCondition._i(k._b7, g, q);
                break;
            case 3:
                r = new IconSortCondition(q == 0, h, i);
                break;
            case 0:
                if (f == null) {
                    r = new OrderedSortCondition(q);
                }
                else {
                    r = new CustomListSortCondition(q, ...f.split(','));
                }
                break;
            default: return;
        }
        if (r == null) {
            return;
        }
        b.e(m, r);
    }
    static bq(a) {
        let b = a.s.a(WorksheetTable.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.x7(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        if (stringIsNullOrEmpty(c)) {
            return;
        }
        b.sortSettings.caseSensitive = e;
        b.sortSettings._i = f;
    }
    static bt(a) {
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x = SpreadsheetMLMain.yh(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w);
        b = x.p1;
        c = x.p2;
        d = x.p3;
        e = x.p4;
        f = x.p5;
        g = x.p6;
        h = x.p7;
        i = x.p8;
        j = x.p9;
        k = x.p10;
        l = x.p11;
        m = x.p12;
        n = x.p13;
        o = x.p14;
        p = x.p15;
        q = x.p16;
        r = x.p17;
        s = x.p18;
        t = x.p19;
        u = x.p20;
        v = x.p21;
        w = x.p22;
        let y = ObjectModelTablePartManager.a8(a);
        let z = y._by;
        if (stringIsNullOrEmpty(f)) {
            return;
        }
        if (g != 0) {
            return;
        }
        let aa;
        let ab;
        let ac;
        let ad;
        let ae = ExcelUtils.fv(f, z.currentFormat, 1, CultureInfo.invariantCulture, null, -1, aa, ab, ac, ad);
        aa = ae.p6;
        ab = ae.p7;
        ac = ae.p8;
        ad = ae.p9;
        let af = new WorksheetTable(c, b, aa, ac, ab, ad);
        a.an = af;
        af.comment = e;
        af.isHeaderRowVisible = (h == 1);
        af._cs = i;
        af.isTotalsRowVisible = (k == 1);
        af._cm = l;
        af.name = c;
        af._c0 = m;
        af.isFilterUIVisible = false;
        af._c5 = j;
        ObjectModelTablePartManager.ba(WorksheetTableArea_$type, y, af._areaFormats$i, 1, WorksheetTable._cd, u, o);
        ObjectModelTablePartManager.bb(WorksheetTableArea_$type, y, af._areaFormats$i, 2, WorksheetTable._cd, t, n, q, 2, 4);
        ObjectModelTablePartManager.bb(WorksheetTableArea_$type, y, af._areaFormats$i, 3, WorksheetTable._cd, v, p, s, 67108864, 134217728);
        ObjectModelTablePartManager.bb(WorksheetTableArea_$type, y, af._areaFormats$i, 0, WorksheetTable._cd, null, Nullable$1.toNullable(Number_$type, null), r, 262144, 524288, 67108864, 134217728, 2097152, 4194304, 2, 4);
        a.s.k(new ObjectModelTablePartManager_TableContext(af));
        a.s.k(af);
    }
    static bu(a) {
        let b = a.s.a(ObjectModelTablePartManager_TableContext.$);
        if (b == null) {
            return;
        }
        b.f();
    }
    static br(a) {
        let b = a.s.a(WorksheetTable.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o = SpreadsheetMLMain.yf(a, c, d, e, f, g, h, i, j, k, l, m, n);
        c = o.p1;
        d = o.p2;
        e = o.p3;
        f = o.p4;
        g = o.p5;
        h = o.p6;
        i = o.p7;
        j = o.p8;
        k = o.p9;
        l = o.p10;
        m = o.p11;
        n = o.p12;
        if (a.ab.ab < 0) {
            return;
        }
        let p = ObjectModelTablePartManager.a8(a);
        let q = b._b5(c);
        q.name = e;
        q.totalLabel = g;
        q.totalFormula = p._by._ao(q, f);
        ObjectModelTablePartManager.ba(WorksheetTableColumnArea_$type, p, q._areaFormats$i, 0, WorksheetTableColumn._ap, m, j);
        ObjectModelTablePartManager.ba(WorksheetTableColumnArea_$type, p, q._areaFormats$i, 1, WorksheetTableColumn._ap, l, i);
        ObjectModelTablePartManager.ba(WorksheetTableColumnArea_$type, p, q._areaFormats$i, 2, WorksheetTableColumn._ap, n, k);
        a.s.k(q);
    }
    static bs(a) {
        let b;
        let c = SpreadsheetMLMain.yg(a, b);
        b = c.p1;
    }
    static bv(a) {
        let b = a.s.a(WorksheetTable.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.ym(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        let i = ObjectModelTablePartManager.a8(a)._by._cj(c);
        b.style = i;
        b.displayBandedColumns = g.getValueOrDefault();
        b.displayBandedRows = f.getValueOrDefault();
        b.displayFirstColumnFormatting = d.getValueOrDefault();
        b.displayLastColumnFormatting = e.getValueOrDefault();
    }
    static bw(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.yq(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = TopOrBottomFilter._t(e, d);
        b.b = new TopOrBottomFilter(2, null, h, truncate(c), f.getValueOrDefault());
    }
    static bx(a) {
        let b = a.s.a(WorksheetTableColumn.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.ys(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ObjectModelTablePartManager.a8(a)._by;
        b.totalFormula = ObjectModelTablePartManager.a6(f, c, d);
    }
    static a6(a, b, c) {
        if (c) {
            return ArrayFormula._parse9("=" + b, 1, a.currentFormat, CultureInfo.invariantCulture);
        }
        return Formula._parse3("=" + b, 1, a.currentFormat, CultureInfo.invariantCulture);
    }
    static by($t, a, b, c, d, e) {
        let f;
        let g = ObjectModelTablePartManager.bz($t, a, b, c, d, e, f);
        d = g.p3;
        e = g.p4;
        f = g.p5;
        return {
            p3: d,
            p4: e
        };
    }
    static bz($t, a, b, c, d, e, f, ...g) {
        d = null;
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        let h;
        let i;
        let j;
        let k = a._bg($t, b, c, h, i, j, ...g);
        h = k.p2;
        i = k.p3;
        j = k.p4;
        if (h != null) {
            d = h.name;
        }
        if (i != null) {
            e = Nullable$1.toNullable(Number_$type, a._ba(i));
        }
        if (j != null) {
            f = Nullable$1.toNullable(Number_$type, a._ba(j));
        }
        return {
            p3: d,
            p4: e,
            p5: f
        };
    }
    b0(a, b) {
        SpreadsheetMLMain.y9(this, b._bq._toString2(1, false, true, true));
        for (let c of fromEnum(b._columns$i)) {
            if (c.filter == null) {
                continue;
            }
            SpreadsheetMLMain.abp(this, intSToU(c.index));
            ObjectModelTablePartManager.b5(this, this.a7, a, c.filter);
            this.ad.k();
        }
        this.ad.k();
    }
    static b5(a, b, c, d) {
        let e = typeCast(FixedValuesFilter.$, d);
        if (e != null) {
            ObjectModelTablePartManager.b6(a, e);
            return;
        }
        let f = typeCast(TopOrBottomFilter.$, d);
        if (f != null) {
            ObjectModelTablePartManager.cb(a, f);
            return;
        }
        let g = typeCast(CustomFilter.$, d);
        if (g != null) {
            ObjectModelTablePartManager.b2(a, c, g);
            return;
        }
        let h = typeCast(DynamicValuesFilter.$, d);
        if (h != null) {
            ObjectModelTablePartManager.b4(a, b, h);
            return;
        }
        let i = typeCast(IColorFilter_$type, d);
        if (i != null) {
            ObjectModelTablePartManager.b1(a, c, i);
            return;
        }
        let j = typeCast(IconFilter.$, d);
        if (j != null) {
            ObjectModelTablePartManager.b7(a, j);
            return;
        }
    }
    static b1(a, b, c) {
        let d = b._ba(b._y(c));
        SpreadsheetMLMain.zz(a, Nullable$1.toNullable(Number_$type, d), c.isCellColorFilter);
        a.ad.k();
    }
    static b2(a, b, c) {
        SpreadsheetMLMain.aaj(a, c.conditionalOperator == 0);
        ObjectModelTablePartManager.b3(a, b, c.condition1);
        if (c.condition2 != null) {
            ObjectModelTablePartManager.b3(a, b, c.condition2);
        }
        a.ad.k();
    }
    static b3(a, b, c) {
        let d;
        let e;
        let f = c._q(b, d, e);
        d = f.p1;
        e = f.p2;
        SpreadsheetMLMain.aai(a, e.toString(), d);
        a.ad.k();
    }
    static b4(a, b, c) {
        let d = b._by;
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Date_$type, null);
        let g = Nullable$1.toNullable(Date_$type, null);
        let h = typeCast(DateRangeFilter.$, c);
        let i = typeCast(AverageFilter.$, c);
        if (h != null) {
            f = Nullable$1.toNullable(Date_$type, h.start);
            g = Nullable$1.toNullable(Date_$type, h.end);
        }
        else if (i != null) {
            e = Nullable$1.toNullable(Number_$type, i.average);
        }
        if (b._z == 0) {
            SpreadsheetMLMain.aa5(a, c._m, !nullableIsNull(e) ? e : (nullableEquals(f, null) ? Nullable$1.toNullable(Number_$type, null) : ExcelCalcValue._dateTimeToExcelDate(d, f.value)), nullableEquals(g, null) ? Nullable$1.toNullable(Number_$type, null) : ExcelCalcValue._dateTimeToExcelDate(d, g.value));
        }
        else {
            SpreadsheetMLMain.aa6(a, c._m, e, f, g);
        }
        a.ad.k();
    }
    static b6(a, b) {
        SpreadsheetMLMain.abr(a, b.includeBlanks, XlsxUtilities.ao(b.calendarType));
        for (let c of fromEnum(b._displayValues$i)) {
            SpreadsheetMLMain.abq(a, c);
            a.ad.k();
        }
        for (let d of fromEnum(b._dateGroups$i)) {
            let e = d._f;
            let f = d.value.getFullYear();
            let g = Nullable$1.toNullable(Number_$type, null);
            let h = Nullable$1.toNullable(Number_$type, null);
            let i = Nullable$1.toNullable(Number_$type, null);
            let j = Nullable$1.toNullable(Number_$type, null);
            let k = Nullable$1.toNullable(Number_$type, null);
            let t1 = d.type;
            L0: while (true) {
                switch (t1) {
                    case 4:
                        k = Nullable$1.toNullable(Number_$type, d.value.getSeconds());
                        t1 = 2;
                        continue L0;
                    case 2:
                        j = Nullable$1.toNullable(Number_$type, d.value.getMinutes());
                        t1 = 1;
                        continue L0;
                    case 1:
                        i = Nullable$1.toNullable(Number_$type, d.value.getHours());
                        t1 = 0;
                        continue L0;
                    case 0:
                        h = Nullable$1.toNullable(Number_$type, d.value.getDate());
                        t1 = 3;
                        continue L0;
                    case 3:
                        g = Nullable$1.toNullable(Number_$type, dateGetMonth(d.value));
                        t1 = 5;
                        continue L0;
                    case 5: break;
                    default:
                        t1 = 4;
                        continue L0;
                }
                break;
            }
            SpreadsheetMLMain.aas(a, e, f, g, h, i, j, k);
            a.ad.k();
        }
        a.ad.k();
    }
    static b7(a, b) {
        SpreadsheetMLMain.ab4(a, b._m, b._p);
    }
    b8(a, b) {
        SpreadsheetMLMain.adu(this, b._bs._toString2(1, false, true, true), void 0, b.sortSettings.caseSensitive, b.sortSettings._n ? XlsxUtilities.a3(b.sortSettings._i) : 0);
        for (let c of fromEnum(b.sortSettings._sortConditions$i)) {
            let d = c.key;
            let e = c.value;
            let f = null;
            let g = 0;
            let h = Nullable$1.toNullable(Number_$type, null);
            let i = typeCast(CustomListSortCondition.$, e);
            if (i != null) {
                f = i._l();
            }
            let j = typeCast(IconSortCondition.$, e);
            if (j != null) {
                g = j._k;
                h = j._n;
            }
            SpreadsheetMLMain.ads(this, d._ai._toString2(1, false, true, true), e.sortDirection == 1, e._d, f, a._a2(d), g, h);
        }
        this.ad.k();
    }
    b9(a, b) {
        let c = a._b;
        SpreadsheetMLMain.ad3(this, Nullable$1.toNullable(Number_$type, intSToU(b._columns$i.count)));
        for (let d of fromEnum(b._columns$i)) {
            let e;
            let f;
            let g = ObjectModelTablePartManager.by(WorksheetTableColumnArea_$type, a, d._areaFormats$i, 0, e, f);
            e = g.p3;
            f = g.p4;
            let h = null;
            let i = Nullable$1.toNullable(Number_$type, null);
            if (d.table.isHeaderRowVisible == false) {
                let j = ObjectModelTablePartManager.by(WorksheetTableColumnArea_$type, a, d._areaFormats$i, 1, h, i);
                h = j.p3;
                i = j.p4;
            }
            let k;
            let l;
            let m = ObjectModelTablePartManager.by(WorksheetTableColumnArea_$type, a, d._areaFormats$i, 2, k, l);
            k = m.p3;
            l = m.p4;
            let n = c._ck(d);
            SpreadsheetMLMain.ad2(this, d._a9, void 0, ObjectModelCommonPartHelpers.e(d.name, "_x000a_"), n, ObjectModelCommonPartHelpers.e(d.totalLabel, "_x000a_"), Nullable$1.toNullable(Number_$type, null), i, f, l, h, e, k);
            if (d.columnFormula != null) {
                SpreadsheetMLMain.zi(this, a._ct(d.columnFormula), typeCast(ArrayFormula.$, d.columnFormula) !== null);
                this.ad.k();
            }
            if (n == 9) {
                SpreadsheetMLMain.aef(this, a._ct(d.totalFormula), typeCast(ArrayFormula.$, d.totalFormula) !== null);
                this.ad.k();
            }
            this.ad.k();
        }
        this.ad.k();
    }
    ca(a) {
        SpreadsheetMLMain.ad9(this, a.style.name, Nullable$1.toNullable(Boolean_$type, a.displayFirstColumnFormatting), Nullable$1.toNullable(Boolean_$type, a.displayLastColumnFormatting), Nullable$1.toNullable(Boolean_$type, a.displayBandedRows), Nullable$1.toNullable(Boolean_$type, a.displayBandedColumns));
        this.ad.k();
    }
    static cb(a, b) {
        SpreadsheetMLMain.aed(a, b.value, b._x, b._w, Nullable$1.toNullable(Number_$type, b._z));
        a.ad.k();
    }
    get a7() {
        return ObjectModelTablePartManager.a8(this);
    }
    static a8(a) {
        return a.d;
    }
}
ObjectModelTablePartManager.$t = markType(ObjectModelTablePartManager, 'ObjectModelTablePartManager', TablePartManager.$);
ObjectModelTablePartManager.a9 = new ObjectModelTablePartManager();
/**
 * @hidden
 */
export class ConditionalFormatInfo extends Base {
    constructor(a, b) {
        super();
        this.g = null;
        this.i = null;
        this.c = null;
        this.d = null;
        this.j = null;
        this.b = null;
        this.k = null;
        this.f = false;
        this.o();
        this.d = a;
        this.c = b;
        this.k = new List$1(CfRuleInfo.$, 0);
    }
    get h() {
        if (this.g == null) {
            this.g = new Dictionary$2(String_$type, CfRuleInfo.$, 0);
        }
        return this.g;
    }
    get a() {
        return this.d._c;
    }
    o() {
        this.j = new List$1(WorksheetRegion.$, 0);
        this.b = null;
    }
    m() {
        let a = new List$1(ConditionSortContext.$, 2, this.k.count);
        for (let b of fromEnum(this.k)) {
            let c = ConditionFactory_XLSX.d(this, b);
            a.add(((() => {
                let $ret = new ConditionSortContext();
                $ret.b = b.ad;
                $ret.a = c;
                return $ret;
            })()));
        }
        DocCoreUtils.ar(ConditionSortContext.$, a, new ConditionSortContextComparer());
        let d = ConditionSortContextComparer._a(a);
        this.d._conditionalFormats$i._aw(d);
        this.o();
    }
    get l() {
        if (this.i == null) {
            this.i = new List$1(CfRuleInfo.$, 0);
        }
        return this.i;
    }
    static e(a) {
        if (a == null) {
            return false;
        }
        return true;
    }
    static n(a, b) {
        a.j.clear();
        let c = a.d;
        for (let d of fromEnum(b)) {
            if (stringIsNullOrEmpty(d) == false) {
                let e = c._getRegion1(d, 1);
                a.j.add(e);
            }
        }
        if (a.l.count > 0) {
            for (let f of fromEnum(a.l)) {
                f.ap(a);
            }
        }
    }
}
ConditionalFormatInfo.$t = markType(ConditionalFormatInfo, 'ConditionalFormatInfo');
/**
 * @hidden
 */
export class CfRuleInfo extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.w = null;
        this.x = null;
        this.v = null;
        this.i = null;
        this.f = null;
        this.q = false;
        this.h = null;
        this.s = false;
        this.aa = null;
        this.r = false;
        this.c = null;
        this.al = Nullable$1.toNullable(ST_CfType_$type, null);
        this.ae = Nullable$1.toNullable(Number_$type, null);
        this.ag = Nullable$1.toNullable(Number_$type, null);
        this.aj = Nullable$1.toNullable(Boolean_$type, null);
        this.k = false;
        this.t = false;
        this.n = false;
        this.af = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        this.ao = null;
        this.ak = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        this.ah = Nullable$1.toNullable(Number_$type, null);
        this.ai = Nullable$1.toNullable(Number_$type, null);
        this.p = false;
        this.an = null;
        this.am = null;
    }
    ap(a) {
        this.aa = new List$1(WorksheetRegion.$, 1, a.j);
    }
    aq(a) {
        this.c = a;
        a.aa = this.aa;
    }
    get e() {
        if (this.d == null) {
            this.d = new CfRuleInfo_ResolvedValues();
        }
        return this.d;
    }
    get ad() {
        if (this.c != null && this.c.ag.hasValue) {
            return this.c.ag.value;
        }
        if (this.ag.hasValue) {
            return this.ag.value;
        }
        return 0;
    }
    get u() {
        if (this.c != null && this.c.aj.hasValue) {
            return this.c.aj.value;
        }
        if (this.aj.hasValue) {
            return this.aj.value;
        }
        return false;
    }
    get j() {
        if (this.i == null) {
            this.i = new IconSetWrapper();
        }
        return this.i;
    }
    get g() {
        if (this.f == null) {
            this.f = new DatabarWrapper();
        }
        return this.f;
    }
    get z() {
        if (this.w == null) {
            this.w = new List$1(String_$type, 2, 3);
        }
        return this.w;
    }
    get ab() {
        if (this.x == null) {
            this.x = new List$1(CfvoWrapper.$, 0);
        }
        return this.x;
    }
    get y() {
        if (this.v == null) {
            this.v = new List$1(ColorInfo.$, 0);
        }
        return this.v;
    }
    static b(a, b) {
        return CfRuleInfo.a(b, a, true, SpreadsheetML2009Main.aw);
    }
    static a(a, b, c = false, d = SpreadsheetMLMain.ef) {
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t = SpreadsheetMLMain.t4(a, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s);
        e = t.p2;
        f = t.p3;
        g = t.p4;
        h = t.p5;
        i = t.p6;
        j = t.p7;
        k = t.p8;
        l = t.p9;
        m = t.p10;
        n = t.p11;
        o = t.p12;
        p = t.p13;
        q = t.p14;
        r = t.p15;
        s = t.p16;
        let u = ((() => {
            let $ret = new CfRuleInfo();
            $ret.k = i;
            $ret.n = k;
            $ret.ae = f;
            $ret.p = q;
            $ret.af = l;
            $ret.t = j;
            $ret.ag = g;
            $ret.ah = o;
            $ret.ai = p;
            $ret.aj = h;
            $ret.ao = m;
            $ret.ak = n;
            $ret.al = e;
            $ret.an = r;
            return $ret;
        })());
        let v = u.al.hasValue ? EnumConverter.e(u.al.value) : 0;
        u.e.a = v;
        let w = Nullable$1.toNullable(FormatConditionOperator_$type, null);
        let x = Nullable$1.toNullable(FormatConditionTextOperator_$type, null);
        if (u.af.hasValue) {
            let y = EnumConverter.q(u.af.value, w, x);
            w = y.p1;
            x = y.p2;
        }
        else {
            w = Nullable$1.toNullable(FormatConditionOperator_$type, 2);
        }
        switch (v) {
            case 0:
                u.e.b = Nullable$1.toNullable(FormatConditionOperator_$type, w.value);
                break;
            case 8:
                u.e.c = Nullable$1.toNullable(FormatConditionTextOperator_$type, x.hasValue ? x.value : 2);
                break;
        }
        u.r = b.f;
        u.s = c;
        if (c == false) {
            u.ap(b);
        }
        return u;
    }
    static l(a) {
        if (a == null) {
            return false;
        }
        return true;
    }
    static m(a) {
        if (CfRuleInfo.l(a) == false) {
            return false;
        }
        if (a.y.count != a.ab.count) {
            return false;
        }
        return true;
    }
}
CfRuleInfo.$t = markType(CfRuleInfo, 'CfRuleInfo');
/**
 * @hidden
 */
export class EnumConverter extends Base {
    static e(a) {
        let b = 0;
        switch (a) {
            case 17:
                b = 11;
                break;
            case 10:
            case 11:
            case 8:
            case 9:
                b = 8;
                break;
            case 1:
                b = 0;
                break;
            case 2:
                b = 2;
                break;
            case 12:
                b = 9;
                break;
            case 13:
                b = 12;
                break;
            case 14:
                b = 13;
                break;
            case 15:
                b = 14;
                break;
            case 3:
                b = 3;
                break;
            case 7:
                b = 7;
                break;
            case 6:
                b = 6;
                break;
            case 0:
                b = 1;
                break;
            case 4:
                b = 5;
                break;
            case 16:
                b = 10;
                break;
            case 5:
                b = 4;
                break;
            default: break;
        }
        return b;
    }
    static g(a, b) {
        if (b.hasValue) {
            return b.value == 0 ? 10 : b.value == 3 ? 9 : b.value == 1 ? 11 : 8;
        }
        switch (a) {
            case 11: return 17;
            case 9: return 12;
            case 0: return 1;
            case 2: return 2;
            case 3: return 3;
            case 7: return 7;
            case 13: return 14;
            case 1: return 0;
            case 5: return 4;
            case 12: return 13;
            case 14: return 15;
            case 4: return 5;
            case 10: return 16;
            case 6: return 6;
            default: return 1;
        }
    }
    static d(a) {
        let b = 0;
        if (a.hasValue == false) {
            return b;
        }
        switch (a.value) {
            case 3:
                b = 6;
                break;
            case 5:
                b = 9;
                break;
            case 8:
                b = 5;
                break;
            case 6:
                b = 8;
                break;
            case 9:
                b = 4;
                break;
            case 4:
                b = 7;
                break;
            case 7:
                b = 3;
                break;
            case 0:
                b = 0;
                break;
            case 2:
                b = 1;
                break;
            case 1:
                b = 2;
                break;
            default: break;
        }
        return b;
    }
    static n(a) {
        switch (a) {
            case 9: return 5;
            case 6: return 3;
            case 5: return 8;
            case 8: return 6;
            case 4: return 9;
            case 7: return 4;
            case 3: return 7;
            case 0: return 0;
            case 1: return 2;
            case 2: return 1;
            default: break;
        }
        return 0;
    }
    static q(a, b, c) {
        b = Nullable$1.toNullable(FormatConditionOperator_$type, null);
        c = Nullable$1.toNullable(FormatConditionTextOperator_$type, null);
        switch (a) {
            case 10:
            case 11:
            case 8:
            case 9:
                switch (a) {
                    case 10:
                        c = Nullable$1.toNullable(FormatConditionTextOperator_$type, 0);
                        break;
                    case 11:
                        c = Nullable$1.toNullable(FormatConditionTextOperator_$type, 1);
                        break;
                    case 8:
                        c = Nullable$1.toNullable(FormatConditionTextOperator_$type, 2);
                        break;
                    case 9:
                        c = Nullable$1.toNullable(FormatConditionTextOperator_$type, 3);
                        break;
                }
                break;
            case 6:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 0);
                break;
            case 2:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 2);
                break;
            case 5:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 4);
                break;
            case 4:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 6);
                break;
            case 0:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 5);
                break;
            case 1:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 7);
                break;
            case 7:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 1);
                break;
            case 3:
                b = Nullable$1.toNullable(FormatConditionOperator_$type, 3);
                break;
            default: break;
        }
        return {
            p1: b,
            p2: c
        };
    }
    static j(a) {
        switch (a) {
            case 0: return 6;
            case 2: return 2;
            case 4: return 5;
            case 6: return 4;
            case 5: return 0;
            case 7: return 1;
            case 1: return 7;
            case 3: return 3;
            default: return 5;
        }
    }
    static k(a) {
        switch (a) {
            case 0: return 10;
            case 2: return 8;
            case 3: return 9;
            case 1: return 11;
            default: return 8;
        }
    }
    static f(a) {
        let b = 1;
        switch (a) {
            case 3:
                b = 4;
                break;
            case 2:
                b = 5;
                break;
            case 0:
                b = 0;
                break;
            case 1:
                b = 1;
                break;
            case 5:
                b = 2;
                break;
            case 4:
                b = 3;
                break;
            case 6:
                b = 6;
                break;
            case 7:
                b = 7;
                break;
            default: break;
        }
        return b;
    }
    static h(a) {
        switch (a) {
            case 7: return 7;
            case 6: return 6;
            case 3: return 4;
            case 5: return 2;
            case 4: return 3;
            case 0: return 0;
            case 1: return 1;
            case 2: return 5;
            default: return 1;
        }
    }
    static b(a) {
        return a == 2 ? -5004 : a == 1 ? -5003 : -5002;
    }
    static m(a) {
        return a == -5003 ? 1 : a == -5004 ? 2 : 0;
    }
    static a(a) {
        return a == 1 ? 1 : a == 2 ? 2 : 0;
    }
    static l(a) {
        return a == 2 ? 2 : a == 1 ? 1 : 0;
    }
    static c(a) {
        return a ? 1 : 0;
    }
    static o(a) {
        return a == 1;
    }
    static p(a, b, c, d) {
        d = ((() => { let e = IconSetConditionalFormat._cp(a, b); b = e.p1; return e.ret; })());
        c = ExcelUtils.aj(b);
        return {
            p2: c,
            p3: d
        };
    }
    static i(a) {
        switch (a) {
            case 0: return 10;
            case 2: return 8;
            case 3: return 9;
            case 1: return 11;
            default: break;
        }
        return 8;
    }
}
EnumConverter.$t = markType(EnumConverter, 'EnumConverter');
/**
 * @hidden
 */
export class CfRuleInfo_ResolvedValues extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
        this.b = Nullable$1.toNullable(FormatConditionOperator_$type, null);
        this.c = Nullable$1.toNullable(FormatConditionTextOperator_$type, null);
    }
}
CfRuleInfo_ResolvedValues.$t = markType(CfRuleInfo_ResolvedValues, 'CfRuleInfo_ResolvedValues');
/**
 * @hidden
 */
export class CfvoWrapper extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
        this.c = null;
        this.b = false;
    }
}
CfvoWrapper.$t = markType(CfvoWrapper, 'CfvoWrapper');
/**
 * @hidden
 */
export class IconSetWrapper extends Base {
    constructor() {
        super(...arguments);
        this.g = null;
        this.m = Nullable$1.toNullable(ST_IconSetType_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
    }
    get h() {
        if (this.g == null) {
            this.g = new List$1(IconCriterionWrapper.$, 0);
        }
        return this.g;
    }
    static a(a) {
        let b = a.c != null ? a.c.j : a.s ? a.j : null;
        let c = a.j;
        let d = new IconSetWrapper();
        if (b != null && b.m.hasValue) {
            d.m = Nullable$1.toNullable(ST_IconSetType_$type, b.m.value);
        }
        else if (c != null && c.m.hasValue) {
            d.m = Nullable$1.toNullable(ST_IconSetType_$type, c.m.value);
        }
        else {
            d.m = Nullable$1.toNullable(ST_IconSetType_$type, 3);
        }
        if (b != null && b.j.hasValue) {
            d.j = Nullable$1.toNullable(Boolean_$type, b.j.value);
        }
        else if (c != null && c.j.hasValue) {
            d.j = Nullable$1.toNullable(Boolean_$type, c.j.value);
        }
        else {
            d.j = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (b != null && b.k.hasValue) {
            d.k = Nullable$1.toNullable(Boolean_$type, b.k.value);
        }
        else if (c != null && c.k.hasValue) {
            d.k = Nullable$1.toNullable(Boolean_$type, c.k.value);
        }
        else {
            d.k = Nullable$1.toNullable(Boolean_$type, false);
        }
        if (b != null && b.l.hasValue) {
            d.l = Nullable$1.toNullable(Boolean_$type, b.l.value);
        }
        else if (c != null && c.l.hasValue) {
            d.l = Nullable$1.toNullable(Boolean_$type, c.l.value);
        }
        else {
            d.l = Nullable$1.toNullable(Boolean_$type, true);
        }
        d.i = Nullable$1.toNullable(Boolean_$type, b != null && b.i.hasValue ? b.i.value : false);
        return d;
    }
    n(a, b) {
        let c = a.c != null ? a.c : a.s ? a : null;
        let d = b._iconCriteria$i;
        if (c != null) {
            let e = c.j.h.count;
            let f = a.ab.count;
            if (e == 0) {
                if (c.j.i.value) {
                }
                else {
                    let g = IconCriterion._an(b.iconSet);
                    for (let h = 0; h < g; h++) {
                        let i = ((() => {
                            let $ret = new IconCriterionWrapper();
                            $ret.a = this.m.value;
                            $ret.b = h;
                            return $ret;
                        })());
                        c.j.h.add(i);
                    }
                }
            }
            for (let j = 0; j < f; j++) {
                IconCriterionExtensions.a(b._iconCriteria$i.item(j), a.j.h._inner[j], a.ab._inner[j]);
            }
        }
        else {
            IconSetCriterionCollectionExtensions.a(b._iconCriteria$i, a.ab, b.worksheet);
        }
    }
}
IconSetWrapper.$t = markType(IconSetWrapper, 'IconSetWrapper');
/**
 * @hidden
 */
export class DatabarWrapper extends Base {
    constructor() {
        super(...arguments);
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.v = Nullable$1.toNullable(Number_$type, null);
        this.z = Nullable$1.toNullable(Boolean_$type, null);
        this.t = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(ST_DataBarDirection_$type, null);
        this.y = Nullable$1.toNullable(Boolean_$type, null);
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.r = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, null);
        this.a = null;
        this.b = null;
        this.c = null;
        this.e = null;
        this.d = null;
    }
    static f(a) {
        let b = new DatabarWrapper();
        let c = a.c != null ? a.c.g : a.s ? a.g : null;
        let d = a.g;
        let e = d != null ? d.w : Nullable$1.toNullable(Number_$type, null);
        let f = d != null ? d.v : Nullable$1.toNullable(Number_$type, null);
        let g = c != null ? c.w : Nullable$1.toNullable(Number_$type, null);
        let h = c != null ? c.v : Nullable$1.toNullable(Number_$type, null);
        let i = 10;
        let j = 90;
        let k = 0;
        let l = 100;
        if (e.hasValue == false || f.hasValue == false || (e.value == i && f.value == j)) {
            if (g.hasValue && g.value == k && h.hasValue && h.value == l) {
                b.w = Nullable$1.toNullable(Number_$type, k);
                b.v = Nullable$1.toNullable(Number_$type, l);
            }
            else {
                b.w = Nullable$1.toNullable(Number_$type, e.hasValue ? e.value : i);
                b.v = Nullable$1.toNullable(Number_$type, f.hasValue ? f.value : j);
            }
        }
        else {
            b.w = Nullable$1.toNullable(Number_$type, e.hasValue ? e.value : i);
            b.v = Nullable$1.toNullable(Number_$type, f.hasValue ? f.value : j);
        }
        if (c != null && c.z.hasValue) {
            b.z = Nullable$1.toNullable(Boolean_$type, c.z.value);
        }
        else if (d != null && d.z.hasValue) {
            b.z = Nullable$1.toNullable(Boolean_$type, d.z.value);
        }
        else {
            b.z = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (c != null && c.t.hasValue) {
            b.t = Nullable$1.toNullable(Boolean_$type, c.t.value);
        }
        else if (d != null && d.t.hasValue) {
            b.t = Nullable$1.toNullable(Boolean_$type, d.t.value);
        }
        else {
            b.t = Nullable$1.toNullable(Boolean_$type, false);
        }
        if (c != null && c.u.hasValue) {
            b.u = Nullable$1.toNullable(Boolean_$type, c.u.value);
        }
        else if (d != null && d.u.hasValue) {
            b.u = Nullable$1.toNullable(Boolean_$type, d.u.value);
        }
        else {
            b.u = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (c != null && c.s.hasValue) {
            b.s = Nullable$1.toNullable(ST_DataBarDirection_$type, c.s.value);
        }
        else if (d != null && d.s.hasValue) {
            b.s = Nullable$1.toNullable(ST_DataBarDirection_$type, d.s.value);
        }
        else {
            b.s = Nullable$1.toNullable(ST_DataBarDirection_$type, 0);
        }
        if (c != null && c.y.hasValue) {
            b.y = Nullable$1.toNullable(Boolean_$type, c.y.value);
        }
        else if (d != null && d.y.hasValue) {
            b.y = Nullable$1.toNullable(Boolean_$type, d.y.value);
        }
        else {
            b.y = Nullable$1.toNullable(Boolean_$type, false);
        }
        if (c != null && c.x.hasValue) {
            b.x = Nullable$1.toNullable(Boolean_$type, c.x.value);
        }
        else if (d != null && d.x.hasValue) {
            b.x = Nullable$1.toNullable(Boolean_$type, d.x.value);
        }
        else {
            b.x = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (c != null && c.r.hasValue) {
            b.r = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, c.r.value);
        }
        else if (d != null && d.r.hasValue) {
            b.r = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, d.r.value);
        }
        else {
            b.r = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, 0);
        }
        b.a = c != null && c.a != null ? c.a : d != null ? d.a : null;
        b.b = c != null && c.b != null ? c.b : d != null ? d.b : null;
        b.c = c != null && c.c != null ? c.c : d.c;
        b.e = c != null && c.e != null ? c.e : d != null ? d.e : null;
        b.d = c != null && c.d != null ? c.d : d != null ? d.d : null;
        if (b.c == null) {
            if (a.y.count > 0) {
                b.c = a.y._inner[0];
            }
        }
        return b;
    }
}
DatabarWrapper.$t = markType(DatabarWrapper, 'DatabarWrapper');
/**
 * @hidden
 */
export class IconCriterionWrapper extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
        this.b = 0;
    }
}
IconCriterionWrapper.$t = markType(IconCriterionWrapper, 'IconCriterionWrapper');
/**
 * @hidden
 */
export class ObjectModelWorksheetPartManager_DVInfo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.c = null;
        this.b = false;
        this.d = null;
        this.e = null;
    }
}
ObjectModelWorksheetPartManager_DVInfo.$t = markType(ObjectModelWorksheetPartManager_DVInfo, 'ObjectModelWorksheetPartManager_DVInfo');
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007_ShapeAnchorApplicator extends Base {
    _visitCT_AbsoluteAnchor$i(a, b) {
        let c = b.c;
        let d = b.d;
        d.positioningMode = 3;
        if (a.c == null || a.d == null) {
            d._setBoundsInTwips(c, ExcelUtils.g9(0, 0, 1, 1));
            return false;
        }
        let e = ExcelUtils.g9(truncate(MathUtilities.f(a.c.a.k())), truncate(MathUtilities.f(a.c.b.k())), truncate(MathUtilities.f(a.d.a.j())), truncate(MathUtilities.f(a.d.b.j())));
        d._setBoundsInTwips(c, e);
        return true;
    }
    _visitCT_OneCellAnchor$i(a, b) {
        let c = b.c;
        let d = b.d;
        d.positioningMode = 2;
        if (a.d == null || a.c == null) {
            d._setBoundsInTwips(c, ExcelUtils.g9(0, 0, 1, 1));
            return false;
        }
        else if (c.type != 0) {
            d._setBoundsInTwips(c, ExcelUtils.g9(0, 0, 1, 1));
            return false;
        }
        let e = c;
        let f = XlsxUtilities.bd(a.d, e);
        let g = WorksheetShape._ds(e, f.c, f.d, f.c, f.d);
        let h = ExcelUtils.g9(truncate(MathUtilities.f(g.left)), truncate(MathUtilities.f(g.top)), truncate(MathUtilities.f(a.c.a.j())), truncate(MathUtilities.f(a.c.b.j())));
        d._setBoundsInTwips(e, h);
        return true;
    }
    _visitCT_TwoCellAnchor$i(a, b) {
        let c = b.c;
        let d = b.d;
        d.positioningMode = XlsxUtilities.w(a.e);
        if (a.c == null || a.d == null) {
            d._setBoundsInTwips(c, ExcelUtils.g9(0, 0, 1, 1));
            return false;
        }
        else if (c.type != 0) {
            d._setBoundsInTwips(c, ExcelUtils.g9(0, 0, 1, 1));
            return false;
        }
        let e = c;
        let f = XlsxUtilities.bd(a.c, e);
        let g = XlsxUtilities.bd(a.d, e);
        d._c5(e, f.c, f.d, g.c, g.d);
        return true;
    }
}
WorkbookLoadManagerExcel2007_ShapeAnchorApplicator.$t = markType(WorkbookLoadManagerExcel2007_ShapeAnchorApplicator, 'WorkbookLoadManagerExcel2007_ShapeAnchorApplicator', Base.$, [IEG_AnchorVisitor$2_$type.specialize(Tuple$2.$.specialize(Sheet.$, WorksheetShape.$), Boolean_$type)]);
WorkbookLoadManagerExcel2007_ShapeAnchorApplicator.a = new WorkbookLoadManagerExcel2007_ShapeAnchorApplicator();
/**
 * @hidden
 */
export class LegacyShapeData extends Base {
    constructor() {
        super();
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(Boolean_$type, null);
        this.p = Nullable$1.toNullable(Boolean_$type, null);
        this.q = Nullable$1.toNullable(ST_CF_$type, null);
        this.r = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.t = Nullable$1.toNullable(Number_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.v = Nullable$1.toNullable(Number_$type, null);
        this.an = null;
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.ao = null;
        this._fmlaMacro = null;
        this.ap = null;
        this.k = false;
        this.aq = null;
        this.y = Nullable$1.toNullable(Number_$type, null);
        this.z = Nullable$1.toNullable(ST_InsetMode_$type, null);
        this.c = null;
        this.ar = null;
        this.ab = Nullable$1.toNullable(Number_$type, null);
        this.ac = Nullable$1.toNullable(Number_$type, null);
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
        this.ad = Nullable$1.toNullable(Boolean_$type, null);
        this.ae = Nullable$1.toNullable(Boolean_$type, null);
        this.j = 0;
        this.af = Nullable$1.toNullable(Number_$type, null);
        this.d = null;
        this.ag = Nullable$1.toNullable(Boolean_$type, null);
        this.ah = Nullable$1.toNullable(Number_$type, null);
        this.ai = Nullable$1.toNullable(Boolean_$type, null);
        this.m = 0;
        this.as = null;
        this.at = null;
        this.aj = Nullable$1.toNullable(Boolean_$type, null);
        this.au = null;
        this.aw = null;
        this.ak = Nullable$1.toNullable(Boolean_$type, null);
        this.av = null;
        this.i = null;
        this.ax = null;
        this.ay = null;
        this.az = null;
        this.al = Nullable$1.toNullable(Number_$type, null);
        this.am = Nullable$1.toNullable(Boolean_$type, null);
        this.a = null;
        this.e = null;
        this.g = null;
        this.a = new Array(8);
    }
    get fmlaMacro() {
        return this._fmlaMacro;
    }
    set fmlaMacro(a) {
        this._fmlaMacro = a;
    }
    a0(a) {
        this.g = a;
        let b = a.worksheet;
        if (a.topLeftCornerCell.worksheet == null || a.bottomRightCornerCell.worksheet == null) {
            return;
        }
        this.a[0] = a._ah.m;
        this.a[2] = a._ah.o;
        this.a[4] = a._ad.m;
        this.a[6] = a._ad.o;
        let c = b._fp(a._ah.m, true);
        let d = ((c * a._topLeftCornerPosition$i.x) / 100);
        this.a[1] = truncate(MathUtilities.f(d));
        let e = b._fs(a._ah.o, true);
        let f = ((e * a._topLeftCornerPosition$i.y) / 100);
        this.a[3] = truncate(MathUtilities.f(f));
        let g = b._fp(a._ad.m, true);
        let h = ((g * a._bottomRightCornerPosition$i.x) / 100);
        this.a[5] = truncate(MathUtilities.f(h));
        let i = b._fs(a._ad.o, true);
        let j = ((i * a._bottomRightCornerPosition$i.y) / 100);
        this.a[7] = truncate(MathUtilities.f(j));
    }
    get b() {
        return this.a;
    }
    get f() {
        return this.e;
    }
    set f(a) {
        this.e = a;
    }
    get h() {
        return this.g;
    }
    get l() {
        if (nullableEquals(this.am, false)) {
            return false;
        }
        if (nullableEquals(this.ai, true) || nullableEquals(this.s, true)) {
            return false;
        }
        return true;
    }
}
LegacyShapeData.$t = markType(LegacyShapeData, 'LegacyShapeData', Base.$, [ILegacyShapeData_$type]);
/**
 * @hidden
 */
export class WorksheetCellCommentData extends Base {
    constructor(a, b, c, d) {
        super();
        this.g = 0;
        this.c = 0;
        this.a = null;
        this.e = 0;
        this.g = b;
        this.c = d;
        this.a = a;
        this.e = c;
    }
    get h() {
        return this.g;
    }
    get d() {
        return this.c;
    }
    get b() {
        return this.a;
    }
    get f() {
        return this.e;
    }
}
WorksheetCellCommentData.$t = markType(WorksheetCellCommentData, 'WorksheetCellCommentData');
/**
 * @hidden
 */
export class ObjectModelCommentsPartManager extends CommentsPartManager {
    constructor() {
        super();
        this.ay(SpreadsheetMLMain.cz, ObjectModelCommentsPartManager.a9);
        this.ay(SpreadsheetMLMain.c1, ObjectModelCommentsPartManager.ba);
        this.ay(SpreadsheetMLMain.e0, ObjectModelCommentsPartManager.bb);
        this.ay(SpreadsheetMLMain.e2, ObjectModelCommentsPartManager.bc);
        this.ay(SpreadsheetMLMain.e3, ObjectModelCommentsPartManager.bd);
        this.ay(SpreadsheetMLMain.q4, ObjectModelCommentsPartManager.be);
        ObjectModelCommonPartHelpers.al(this);
    }
    t() {
        let a = new List$1(WorksheetCellCommentData.$, 0);
        this.s.k(a);
        return WorkItemExtensions.g(Base.$, super.t(), () => a);
    }
    u(a) {
        let b = typeCast(Worksheet.$, a);
        if (b == null) {
            return null;
        }
        let c = this.a6._b9;
        let d = c._w(b);
        let e = new List$1(WorksheetCellCommentData.$, 0);
        let f = new List$1(String_$type, 0);
        for (let g of fromEnum(d.j)) {
            let h = f.f(g.author);
            if (h < 0) {
                h = ~h;
                f.insert(h, g.author);
            }
            if (g.cell.worksheet == null) {
                return null;
            }
            let i = new WorksheetCellCommentData(g, intSToU(h), g.cell.rowIndex, g.cell.columnIndex);
            e.add(i);
        }
        SpreadsheetMLMain.z5(this);
        SpreadsheetMLMain.y8(this);
        for (let j of fromEnum(f)) {
            SpreadsheetMLMain.y7(this, j);
            this.ad.k();
        }
        this.ad.k();
        SpreadsheetMLMain.z4(this);
        for (let k of fromEnum(e)) {
            let l = k.b.cell;
            SpreadsheetMLMain.z3(this, CellAddress.u(l.rowIndex, l.columnIndex, c._b.currentFormat), k.h);
            ObjectModelCommonPartHelpers.au(this, c, k.b.text._m, SpreadsheetMLMain.aec);
            this.ad.k();
        }
        this.ad.k();
        this.ad.k();
        return null;
    }
    static a9(a) {
        let b = a.s.a(List$1.$.specialize(String_$type));
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.tm(a, c);
        c = d.p1;
        b.add(c);
    }
    static ba(a) {
    }
    static bb(a) {
        let b = a.s.a(List$1.$.specialize(String_$type));
        let c = a.s.a(List$1.$.specialize(WorksheetCellCommentData.$));
        if (b == null || c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.ui(a, d, e, f, g);
        d = h.p1;
        e = h.p2;
        f = h.p3;
        g = h.p4;
        let i;
        let j;
        if (((() => { let k = ExcelUtils.bm(d, 2, CultureInfo.invariantCulture, i, j); i = k.p3; j = k.p4; return k.ret; })()) == false) {
        }
        let k = b._inner[e];
        let l = new WorksheetCellComment();
        l.text._e();
        l.author = k;
        let m = new WorksheetCellCommentData(l, e, j, i);
        c.add(m);
        a.s.k(l);
        a.s.k(l.text._m);
    }
    static bc(a) {
    }
    static bd(a) {
        a.s.k(new List$1(String_$type, 0));
    }
    static be(a) {
    }
    get a6() {
        return ObjectModelCommentsPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelCommentsPartManager.$t = markType(ObjectModelCommentsPartManager, 'ObjectModelCommentsPartManager', CommentsPartManager.$);
ObjectModelCommentsPartManager.a8 = new ObjectModelCommentsPartManager();
/**
 * @hidden
 */
export class LegacyDrawingHFInfo extends Base {
    constructor(a, b) {
        super();
        this.a = null;
        this.b = null;
        this.a = a;
        this.b = b;
    }
}
LegacyDrawingHFInfo.$t = markType(LegacyDrawingHFInfo, 'LegacyDrawingHFInfo');
/**
 * @hidden
 */
export class ObjectModelCommonPartHelpers_DoubleValueCache extends Base {
    constructor() {
        super(...arguments);
        this.c = new Dictionary$2(String_$type, Base.$, 0);
        this.a = new Array(512);
        this.d = 0;
    }
    static f(a) {
        let b = ObjectModelCommonPartHelpers_DoubleValueCache.b || (ObjectModelCommonPartHelpers_DoubleValueCache.b = new ObjectModelCommonPartHelpers_DoubleValueCache());
        let c;
        if (((() => { let d = b.c.tryGetValue(a, c); c = d.p1; return d.ret; })()) == false) {
            if (b.a[b.d] != null) {
                b.c.removeItem(b.a[b.d]);
            }
            b.a[b.d] = a;
            b.d = (b.d + 1) % 512;
            b.c.item(a, c = parseNumber(a, CultureInfo.invariantCulture));
        }
        return c;
    }
}
ObjectModelCommonPartHelpers_DoubleValueCache.$t = markType(ObjectModelCommonPartHelpers_DoubleValueCache, 'ObjectModelCommonPartHelpers_DoubleValueCache');
ObjectModelCommonPartHelpers_DoubleValueCache.b = null;
/**
 * @hidden
 */
export class ConditionSortContext extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.a = null;
    }
}
ConditionSortContext.$t = markType(ConditionSortContext, 'ConditionSortContext');
/**
 * @hidden
 */
export class ConditionFactory_XLSX extends Base {
    static d(a, b) {
        let c = null;
        switch (b.e.a) {
            case 11:
                c = ConditionFactory_XLSX.a(a, b);
                break;
            case 9:
                c = ConditionFactory_XLSX.b(a, b);
                break;
            case 0:
                c = ConditionFactory_XLSX.m(a, b);
                break;
            case 7:
                c = ConditionFactory_XLSX.g(a, b);
                break;
            case 13:
                c = ConditionFactory_XLSX.h(a, b);
                break;
            case 1:
                c = ConditionFactory_XLSX.i(a, b);
                break;
            case 12:
                c = ConditionFactory_XLSX.k(a, b);
                break;
            case 14:
                c = ConditionFactory_XLSX.l(a, b);
                break;
            case 4:
                c = ConditionFactory_XLSX.n(a, b);
                break;
            case 8:
                c = ConditionFactory_XLSX.o(a, b);
                break;
            case 10:
                c = ConditionFactory_XLSX.f(a, b);
                break;
            case 6:
                c = ConditionFactory_XLSX.p(a, b);
                break;
            case 2:
                c = ConditionFactory_XLSX.c(a, b);
                break;
            case 5:
                c = ConditionFactory_XLSX.j(a, b);
                break;
            case 3:
                c = ConditionFactory_XLSX.e(a, b);
                break;
            default: break;
        }
        return c;
    }
    static m(a, b) {
        let c = new OperatorConditionalFormat(1, b.aa, b.e.b.value);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        let d = a.a;
        if (b.z.count > 0) {
            let e = b.z._inner[0];
            let f = b.z.count > 1 ? b.z._inner[1] : null;
            if (stringIsNullOrEmpty(e) == false) {
                c._cd = ConditionFactory_XLSX.q(e, a, c);
            }
            if (stringIsNullOrEmpty(f) == false) {
                c._ce = ConditionFactory_XLSX.q(f, a, c);
            }
        }
        return c;
    }
    static i(a, b) {
        let c = new FormulaConditionalFormat(1, b.aa, null, Nullable$1.toNullable(CellReferenceMode_$type, null));
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        let d = a.a;
        let e = b.z.count > 0 ? b.z._inner[0] : null;
        if (stringIsNullOrEmpty(e) == false) {
            c._b5 = ConditionFactory_XLSX.q(e, a, c);
        }
        return c;
    }
    static n(a, b) {
        let c = new RankConditionalFormat(1, b.aa, 1, 10);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        if (b.ah.hasValue) {
            c.rank = b.ah.value;
        }
        c.topBottom = b.n ? 0 : 1;
        c.isPercent = b.t;
        return c;
    }
    static a(a, b) {
        let c = new AverageConditionalFormat(1, b.aa, 0);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        let d = 0;
        if (b.k) {
            if (b.p) {
                d = 2;
            }
            else if (b.ai.hasValue) {
                d = 4;
            }
            else {
                d = 0;
            }
        }
        else {
            if (b.p) {
                d = 3;
            }
            else if (b.ai.hasValue) {
                d = 5;
            }
            else {
                d = 1;
            }
        }
        c.aboveBelow = d;
        if (b.ai.hasValue) {
            c.numericStandardDeviation = b.ai.value;
        }
        return c;
    }
    static p(a, b) {
        let c = new UniqueConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static g(a, b) {
        let c = new DuplicateConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static b(a, b) {
        let c = new BlanksConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static k(a, b) {
        let c = new NoBlanksConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static h(a, b) {
        let c = new ErrorsConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static l(a, b) {
        let c = new NoErrorsConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        return c;
    }
    static o(a, b) {
        let c = new TextOperatorConditionalFormat(1, b.aa, null, 2);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        c.text = b.ao;
        c.textOperator = b.e.c.hasValue ? b.e.c.value : 2;
        return c;
    }
    static f(a, b) {
        let c = new DateTimeConditionalFormat(1, b.aa, 0);
        ConditionFactory_XLSX.t(a, b, c);
        ConditionFactory_XLSX.u(a, b, c);
        c.dateOperator = EnumConverter.d(b.ak);
        return c;
    }
    static c(a, b) {
        if (CfRuleInfo.m(b) == false) {
            return null;
        }
        let c = b.y.count == 3 ? 1 : 0;
        let d = new ColorScaleConditionalFormat(1, b.aa, c);
        ConditionFactory_XLSX.t(a, b, d);
        let e = b.z.count > 0 ? b.z._inner[0] : null;
        if (stringIsNullOrEmpty(e) == false) {
            d._by = ConditionFactory_XLSX.q(e, a, d);
        }
        let f = null;
        let g = null;
        let h = null;
        let i = a.d;
        let j = i.workbook;
        switch (c) {
            case 0:
                f = new Tuple$2(CfvoWrapper.$, ColorInfo.$, b.ab._inner[0], b.y._inner[0]);
                h = new Tuple$2(CfvoWrapper.$, ColorInfo.$, b.ab._inner[1], b.y._inner[1]);
                ConditionValueExtensions.a(d.minimumThreshold._b, f.c, i);
                d.minimumThreshold.formatColor = ColorInfoExtensions.a(f.d, a);
                ConditionValueExtensions.a(d.maximumThreshold._b, h.c, i);
                d.maximumThreshold.formatColor = ColorInfoExtensions.a(h.d, a);
                break;
            case 1:
                f = new Tuple$2(CfvoWrapper.$, ColorInfo.$, b.ab._inner[0], b.y._inner[0]);
                g = new Tuple$2(CfvoWrapper.$, ColorInfo.$, b.ab._inner[1], b.y._inner[1]);
                h = new Tuple$2(CfvoWrapper.$, ColorInfo.$, b.ab._inner[2], b.y._inner[2]);
                ConditionValueExtensions.a(d.minimumThreshold._b, f.c, i);
                d.minimumThreshold.formatColor = ColorInfoExtensions.a(f.d, a);
                ConditionValueExtensions.a(d.midpointThreshold._b, g.c, i);
                d.midpointThreshold.formatColor = ColorInfoExtensions.a(g.d, a);
                ConditionValueExtensions.a(d.maximumThreshold._b, h.c, i);
                d.maximumThreshold.formatColor = ColorInfoExtensions.a(h.d, a);
                break;
        }
        return d;
    }
    static j(a, b) {
        let c = IconSetWrapper.a(b);
        let d = ExcelUtils.t(c.m.value);
        let e = new IconSetConditionalFormat(1, b.aa, d);
        ConditionFactory_XLSX.t(a, b, e);
        let f = ConditionFactory_XLSX.s(b);
        if (stringIsNullOrEmpty(f) == false) {
            e._by = ConditionFactory_XLSX.q(f, a, e);
        }
        e._cm = c.j.value;
        e.isReverseOrder = c.k.value;
        e.showValue = c.l.value;
        c.n(b, e);
        return e;
    }
    static e(a, b) {
        let c = new DataBarConditionalFormat(1, b.aa);
        ConditionFactory_XLSX.t(a, b, c);
        let d = ConditionFactory_XLSX.s(b);
        if (stringIsNullOrEmpty(d) == false) {
            c._by = ConditionFactory_XLSX.q(d, a, c);
        }
        let e = b.c != null ? b.c : b.s ? b : null;
        let f = e != null && e.ab.count == 2 ? e.ab : b.ab;
        ConditionValueExtensions.a(c.minPoint, f._inner[0], a.d);
        ConditionValueExtensions.a(c.maxPoint, f._inner[1], a.d);
        let g = DatabarWrapper.f(b);
        if (g.c != null) {
            c.barColor = ColorInfoExtensions.a(g.c, a);
        }
        if (g.b != null) {
            c.barBorderColor = ColorInfoExtensions.a(g.b, a);
        }
        if (g.d != null) {
            c.negativeBarFormat.barBorderColor = ColorInfoExtensions.a(g.d, a);
        }
        if (g.e != null) {
            c.negativeBarFormat.barColor = ColorInfoExtensions.a(g.e, a);
        }
        if (g.a != null) {
            c.axisColor = ColorInfoExtensions.a(g.a, a);
        }
        c.barFillType = EnumConverter.c(g.u.value);
        c.negativeBarFormat.barColorType = g.y.value ? 1 : 0;
        c.negativeBarFormat.barBorderColorType = g.x.value ? 1 : 0;
        c.direction = EnumConverter.b(g.s.value);
        c.axisPosition = EnumConverter.a(g.r.value);
        c.fillPercentMin = g.w.value;
        c.fillPercentMax = g.v.value;
        c.showValue = g.z.value;
        c.showBorder = g.t.value;
        if (e == null) {
            c.axisPosition = 2;
            c.negativeBarFormat.barColorType = 1;
        }
        return c;
    }
    static t(a, b, c) {
        c._af = a.f;
        c.priority = b.ad;
        c.stopIfTrue = b.u;
    }
    static u(a, b, c) {
        c._bw = b.ae.hasValue ? a.c._g._inner[b.ae.value] : null;
    }
    static q(a, b, c) {
        let d = WorkbookLoadManagerExcel2007._bs(a);
        a = d.p0;
        let e = c.regions.item(0);
        let f = c._s();
        return ConditionBase._n(a, e.worksheet.workbook, Nullable$1.toNullable(CellReferenceMode_$type, 1), 7, f.o, f.m, b.c._bi);
    }
    static r(a) {
        return FormulaConditionalFormat._b9(a);
    }
    static s(a) {
        if (a.c != null && a.c.z.count > 0) {
            return a.c.z._inner[0];
        }
        else if (a.z.count > 0) {
            return a.z._inner[0];
        }
        return null;
    }
}
ConditionFactory_XLSX.$t = markType(ConditionFactory_XLSX, 'ConditionFactory_XLSX');
/**
 * @hidden
 */
export class ConditionValueExtensions extends Base {
    static a(a, b, c) {
        let d = c != null ? c.workbook : null;
        let e = EnumConverter.f(b.a);
        if (stringIsNullOrEmpty(b.c) == false) {
            let f = null;
            switch (e) {
                case 3:
                    f = ConditionFactory_XLSX.r(b.c);
                    a._setFormula$i(f);
                    break;
                default:
                    let g = Nullable$1.toNullable(Number_$type, null);
                    let h = Nullable$1.toNullable(Number_$type, null);
                    if (((() => { let i = ConditionValue._s(b.c, h, g); h = i.p1; g = i.p2; return i.ret; })())) {
                        if (h.hasValue) {
                            a._f = new ConditionValueInfo(1, h.value, e);
                        }
                        else if (g.hasValue) {
                            a._f = new ConditionValueInfo(1, g.value, e);
                        }
                    }
                    else {
                        f = ConditionFactory_XLSX.r(b.c);
                        let i = null;
                        if (((() => { let j = Formula._ay(f, c._c, i); i = j.p2; return j.ret; })())) {
                            a._ai(typeCast(SingleTargetFormula.$, i), e);
                        }
                        else {
                        }
                    }
                    break;
            }
        }
        else {
            a._f = new ConditionValueInfo(1, NaN, e);
        }
    }
    static b(a, b, c, d, e, f, g = Nullable$1.toNullable(Boolean_$type, null)) {
        let h = a.valueType;
        if (f == false) {
            if (h == 6) {
                h = 4;
            }
            else if (h == 7) {
                h = 5;
            }
        }
        let i = EnumConverter.h(h);
        let j = null;
        if (g.hasValue == false) {
            g = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (f) {
            SpreadsheetML2009Main.db(b, i, g.value);
            switch (a.valueType) {
                case 6:
                case 7:
                case 5:
                case 4:
                    j = null;
                    break;
                case 0:
                case 1:
                case 2:
                    if (a.formula != null && isNaN_(a.value)) {
                        j = c._ct(a.formula);
                    }
                    else {
                        j = ConditionalFormattingSerializer.u(a.value);
                    }
                    break;
                case 3:
                    j = c._ct(a.formula);
                    break;
            }
            if (stringIsNullOrEmpty(j) == false) {
                Excel2006Main.au(b, j);
                d.k();
            }
        }
        else {
            switch (a.valueType) {
                case 6:
                case 7:
                case 4:
                case 5: break;
                case 3:
                    j = c._ct(a.formula);
                    break;
                case 0:
                case 1:
                case 2:
                    if (a.formula != null && isNaN_(a.value)) {
                        j = c._ct(a.formula);
                    }
                    else {
                        j = ConditionalFormattingSerializer.u(a.value);
                    }
                    break;
            }
            SpreadsheetMLMain.zq(b, i, j, g.value);
        }
        d.k();
    }
}
ConditionValueExtensions.$t = markType(ConditionValueExtensions, 'ConditionValueExtensions');
/**
 * @hidden
 */
export class ColorInfoExtensions extends Base {
    static a(a, b) {
        return a.c(b.c);
    }
    static d(a, b, c, d, e) {
        if (WorkbookColorInfo.l_op_Equality(a, null)) {
            return;
        }
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = a._tint$i.hasValue ? a._tint$i.value : 0;
        if (a.isAutomatic) {
            f = Nullable$1.toNullable(Boolean_$type, true);
        }
        else if (a._color$i.hasValue) {
            g = Nullable$1.toNullable(ST_UnsignedIntHex.$, ST_UnsignedIntHex.d(ColorInfoExtensions.c(a._color$i.value)));
        }
        else if (a._themeColorType$i.hasValue) {
            h = Nullable$1.toNullable(Number_$type, a._themeColorType$i.value);
        }
        else {
            g = Nullable$1.toNullable(ST_UnsignedIntHex.$, ST_UnsignedIntHex.d(ColorInfoExtensions.c(a._getResolvedColor1(d.workbook))));
        }
        SpreadsheetMLMain.aad(b, e, f, Nullable$1.toNullable(Number_$type, null), g, h, i);
        c.k();
    }
    static c(a) {
        return ColorInfoExtensions.b(a.l, a.o, a.n, a.m);
    }
    static b(a, b, c, d) {
        let e = new StringBuilder(0);
        e.l(intToString1(a, "X2"));
        e.l(intToString1(b, "X2"));
        e.l(intToString1(c, "X2"));
        e.l(intToString1(d, "X2"));
        return e.toString();
    }
}
ColorInfoExtensions.$t = markType(ColorInfoExtensions, 'ColorInfoExtensions');
/**
 * @hidden
 */
export class IconCriterionExtensions extends Base {
    static a(a, b, c) {
        let d = a._d.worksheet;
        ConditionValueExtensions.a(a._b, c, d);
        a.comparison = c.b ? 0 : 1;
        let e = ExcelUtils.t(b.a);
        let f = IconSetConditionalFormat._b9(e);
        let g = b.b;
        if (g < 0 || g >= f.length) {
            g = Math.min(g, f.length - 1);
            g = Math.max(g, 0);
        }
        a.icon = f[g];
    }
}
IconCriterionExtensions.$t = markType(IconCriterionExtensions, 'IconCriterionExtensions');
/**
 * @hidden
 */
export class IconSetCriterionCollectionExtensions extends Base {
    static a(a, b, c) {
        let d = new Array(b.count);
        let e = a._d.iconSet;
        let f = IconSetConditionalFormat._b9(e);
        for (let g = 0, h = b.count; g < h; g++) {
            let i = b.item(g);
            let j = new IconCriterion(1, a, g, e, f[g]);
            j.comparison = i.b ? 0 : 1;
            ConditionValueExtensions.a(j._b, i, c);
            d[g] = j;
        }
        a._q(d);
    }
}
IconSetCriterionCollectionExtensions.$t = markType(IconSetCriterionCollectionExtensions, 'IconSetCriterionCollectionExtensions');
/**
 * @hidden
 */
export class ConditionSortContextComparer extends Base {
    compare(a, b) {
        if (a == null || b == null) {
            return 0;
        }
        return Base.compareSimple(a.b, b.b);
    }
    static _a(a) {
        let b = new List$1(ConditionBase.$, 2, a.count);
        for (let c = 0; c < a.count; c++) {
            b.add(a.item(c).a);
        }
        return b;
    }
}
ConditionSortContextComparer.$t = markType(ConditionSortContextComparer, 'ConditionSortContextComparer', Base.$, [IComparer$1_$type.specialize(ConditionSortContext.$)]);
/**
 * @hidden
 */
export class SparklinesDeserializer extends Base {
    constructor(a) {
        super();
        this.d = null;
        this.h = null;
        this.c = 0;
        this.d = a;
    }
    get e() {
        return (this.c & 1) == 1;
    }
    get i() {
        if (this.h == null) {
            this.h = new List$1(CT_SparklineGroup.$, 0);
        }
        return this.h;
    }
    static a(a, b = true) {
        let c = a.s.a(SparklinesDeserializer.$);
        if (c == null) {
            if (b) {
            }
            return null;
        }
        return c;
    }
    static b($t, a, b = true) {
        let c = a.s.a($t);
        if (getBoxIfEnum($t, c) == null) {
            if (b) {
            }
            return Type.getDefaultValue($t);
        }
        return c;
    }
    static z(a) {
        a.ay(SpreadsheetML2009Main.co, SparklinesDeserializer.v);
        a.ax(SpreadsheetML2009Main.co, SparklinesDeserializer.w);
        a.ay(SpreadsheetML2009Main.cn, SparklinesDeserializer.u);
        a.ay(SpreadsheetML2009Main.az, SparklinesDeserializer.k);
        a.ay(SpreadsheetML2009Main.a0, SparklinesDeserializer.l);
        a.ay(SpreadsheetML2009Main.a1, SparklinesDeserializer.n);
        a.ay(SpreadsheetML2009Main.a2, SparklinesDeserializer.o);
        a.ay(SpreadsheetML2009Main.a3, SparklinesDeserializer.p);
        a.ay(SpreadsheetML2009Main.a4, SparklinesDeserializer.q);
        a.ay(SpreadsheetML2009Main.a5, SparklinesDeserializer.r);
        a.ay(SpreadsheetML2009Main.a7, SparklinesDeserializer.s);
        a.ay(SpreadsheetML2009Main.cq, SparklinesDeserializer.x);
        a.ax(SpreadsheetML2009Main.cq, SparklinesDeserializer.y);
        a.ay(SpreadsheetML2009Main.cm, SparklinesDeserializer.t);
    }
    static v(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = new SparklinesDeserializer(b.bl);
        b.s.k(c);
    }
    static w(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b);
        if (c == null) {
            return;
        }
        c.j(c.d, b.bg._b7);
    }
    static u(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(ST_SparklineType_$type, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = Nullable$1.toNullable(ST_DispBlanksAs_$type, null);
        let j = Nullable$1.toNullable(Boolean_$type, null);
        let k = Nullable$1.toNullable(Boolean_$type, null);
        let l = Nullable$1.toNullable(Boolean_$type, null);
        let m = Nullable$1.toNullable(Boolean_$type, null);
        let n = Nullable$1.toNullable(Boolean_$type, null);
        let o = Nullable$1.toNullable(Boolean_$type, null);
        let p = Nullable$1.toNullable(Boolean_$type, null);
        let q = Nullable$1.toNullable(Boolean_$type, null);
        let r = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        let s = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        let t = Nullable$1.toNullable(Boolean_$type, null);
        let u = CT_SparklineGroup.bh(a, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
        d = u.p1;
        e = u.p2;
        f = u.p3;
        g = u.p4;
        h = u.p5;
        i = u.p6;
        j = u.p7;
        k = u.p8;
        l = u.p9;
        m = u.p10;
        n = u.p11;
        o = u.p12;
        p = u.p13;
        q = u.p14;
        r = u.p15;
        s = u.p16;
        t = u.p17;
        let v = ((() => {
            let $ret = new CT_SparklineGroup();
            $ret.ah = h;
            $ret.aj = i;
            $ret.al = q;
            $ret.an = p;
            $ret.ap = m;
            $ret.ar = k;
            $ret.at = n;
            $ret.av = f;
            $ret.ax = l;
            $ret.az = d;
            $ret.a1 = e;
            $ret.a3 = j;
            $ret.a5 = s;
            $ret.a7 = r;
            $ret.a9 = o;
            $ret.bb = t;
            $ret.bd = g;
            return $ret;
        })());
        c.i.add(v);
        b.s.k(v);
    }
    static m(a, b) {
        let c = typeCast(ObjectModelWorksheetPartManager.$, a);
        let d = SparklinesDeserializer.a(c);
        if (d == null) {
            return;
        }
        let e = SparklinesDeserializer.b(CT_SparklineGroup.$, c);
        if (e == null) {
            return;
        }
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = NaN;
        let k = SpreadsheetMLMain.us(a, b, f, g, h, i, j);
        f = k.p2;
        g = k.p3;
        h = k.p4;
        i = k.p5;
        j = k.p6;
        let l = ((() => {
            let $ret = new ColorInfo();
            $ret.i = f;
            $ret.j = g;
            $ret.k = h;
            $ret.l = i;
            $ret.g = j;
            return $ret;
        })());
        switch (b) {
            case SpreadsheetML2009Main.az:
                e.a = l;
                break;
            case SpreadsheetML2009Main.a0:
                e.c = l;
                break;
            case SpreadsheetML2009Main.a2:
                e.g = l;
                break;
            case SpreadsheetML2009Main.a1:
                e.e = l;
                break;
            case SpreadsheetML2009Main.a3:
                e.i = l;
                break;
            case SpreadsheetML2009Main.a4:
                e.k = l;
                break;
            case SpreadsheetML2009Main.a5:
                e.m = l;
                break;
            case SpreadsheetML2009Main.a7:
                e.o = l;
                break;
            default: break;
        }
    }
    static k(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.az);
    }
    static l(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a0);
    }
    static n(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a1);
    }
    static o(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a2);
    }
    static p(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a3);
    }
    static q(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a4);
    }
    static r(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a5);
    }
    static s(a) {
        SparklinesDeserializer.m(a, SpreadsheetML2009Main.a7);
    }
    static x(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b);
        if (c == null) {
            return;
        }
        let d = SparklinesDeserializer.b(CT_SparklineGroup.$, b);
        if (d == null) {
            return;
        }
        d.ae = new List$1(CT_Sparkline.$, 0);
        c.c |= 1;
    }
    static y(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b);
        if (c == null) {
            return;
        }
        c.c &= ~1;
    }
    static t(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b);
        if (c == null) {
            return;
        }
        let d = SparklinesDeserializer.b(CT_SparklineGroup.$, b);
        if (d == null) {
            return;
        }
        let e = new CT_Sparkline();
        b.s.k(e);
        d.ae.add(e);
    }
    static f(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b, false);
        if (c == null) {
            return false;
        }
        let d = null;
        let e = Excel2006Main.as(a, d);
        d = e.p1;
        if ((c.c & 1) == 1) {
            let f = SparklinesDeserializer.b(CT_Sparkline.$, b);
            if (f == null) {
                return false;
            }
            f.c = d;
        }
        else {
            let g = SparklinesDeserializer.b(CT_SparklineGroup.$, b);
            if (g == null) {
                return false;
            }
            g.bf = d;
        }
        return true;
    }
    static g(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = SparklinesDeserializer.a(b, false);
        if (c == null) {
            return false;
        }
        let d = SparklinesDeserializer.b(CT_Sparkline.$, b);
        if (d == null) {
            return false;
        }
        let e = null;
        let f = Excel2006Main.at(a, e);
        e = f.p1;
        let g = XmlNamespaceDefinitionBase.e(String_$type, e, (h) => h);
        d.a = ((() => {
            let $ret = new CT_Sqref();
            $ret.i = g;
            return $ret;
        })());
        return true;
    }
    j(a, b) {
        a._sparklineGroups$i.clear();
        let c = null;
        let d = new List$1(SparklineGroup.$, 2, this.i.count);
        for (let e of fromEnum(this.i)) {
            c = new SparklineGroup(0, a);
            SparklineExtensions.h(c, e, a, b);
            d.add(c);
        }
        a._sparklineGroups$i._ab(d);
    }
}
SparklinesDeserializer.$t = markType(SparklinesDeserializer, 'SparklinesDeserializer');
/**
 * @hidden
 */
export class CT_Sparkline extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static f(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_Sparkline.$t = markType(CT_Sparkline, 'CT_Sparkline');
/**
 * @hidden
 */
export class CT_Sqref extends Base {
    constructor() {
        super();
        this.f = false;
        this.h = false;
        this.c = false;
        this.d = false;
        this.j = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get a() {
        return this.d;
    }
    set a(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
}
CT_Sqref.$t = markType(CT_Sqref, 'CT_Sqref');
/**
 * @hidden
 */
export class CT_SparklineGroup extends Base {
    constructor() {
        super();
        this.p = null;
        this.n = null;
        this.b = null;
        this.l = null;
        this.d = null;
        this.h = null;
        this.f = null;
        this.j = null;
        this.bg = null;
        this.af = null;
        this.a0 = Nullable$1.toNullable(Number_$type, null);
        this.a2 = Nullable$1.toNullable(Number_$type, null);
        this.aw = Nullable$1.toNullable(Number_$type, null);
        this.be = Nullable$1.toNullable(ST_SparklineType_$type, null);
        this.ai = Nullable$1.toNullable(Boolean_$type, null);
        this.ak = Nullable$1.toNullable(ST_DispBlanksAs_$type, null);
        this.a4 = Nullable$1.toNullable(Boolean_$type, null);
        this.as = Nullable$1.toNullable(Boolean_$type, null);
        this.ay = Nullable$1.toNullable(Boolean_$type, null);
        this.aq = Nullable$1.toNullable(Boolean_$type, null);
        this.au = Nullable$1.toNullable(Boolean_$type, null);
        this.ba = Nullable$1.toNullable(Boolean_$type, null);
        this.ao = Nullable$1.toNullable(Boolean_$type, null);
        this.am = Nullable$1.toNullable(Boolean_$type, null);
        this.a8 = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        this.a6 = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        this.bc = Nullable$1.toNullable(Boolean_$type, null);
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get bf() {
        return this.bg;
    }
    set bf(a) {
        this.bg = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    get az() {
        return this.a0;
    }
    set az(a) {
        this.a0 = a;
    }
    get a1() {
        return this.a2;
    }
    set a1(a) {
        this.a2 = a;
    }
    get av() {
        return this.aw;
    }
    set av(a) {
        this.aw = a;
    }
    get bd() {
        return this.be;
    }
    set bd(a) {
        this.be = a;
    }
    get ah() {
        return this.ai;
    }
    set ah(a) {
        this.ai = a;
    }
    get aj() {
        return this.ak;
    }
    set aj(a) {
        this.ak = a;
    }
    get a3() {
        return this.a4;
    }
    set a3(a) {
        this.a4 = a;
    }
    get ar() {
        return this.as;
    }
    set ar(a) {
        this.as = a;
    }
    get ax() {
        return this.ay;
    }
    set ax(a) {
        this.ay = a;
    }
    get ap() {
        return this.aq;
    }
    set ap(a) {
        this.aq = a;
    }
    get at() {
        return this.au;
    }
    set at(a) {
        this.au = a;
    }
    get a9() {
        return this.ba;
    }
    set a9(a) {
        this.ba = a;
    }
    get an() {
        return this.ao;
    }
    set an(a) {
        this.ao = a;
    }
    get al() {
        return this.am;
    }
    set al(a) {
        this.am = a;
    }
    get a7() {
        return this.a8;
    }
    set a7(a) {
        this.a8 = a;
    }
    get a5() {
        return this.a6;
    }
    set a5(a) {
        this.a6 = a;
    }
    get bb() {
        return this.bc;
    }
    set bb(a) {
        this.bc = a;
    }
    static bh(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(ST_SparklineType_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(ST_DispBlanksAs_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = Nullable$1.toNullable(Boolean_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        p = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        q = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        for (let s of fromEnum(a.ab.u)) {
            switch (s.a.e(a.d)) {
                case "manualMax":
                    b = Nullable$1.toNullable(Number_$type, parseNumber(s.d, CultureInfo.invariantCulture));
                    break;
                case "manualMin":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(s.d, CultureInfo.invariantCulture));
                    break;
                case "lineWeight":
                    d = Nullable$1.toNullable(Number_$type, parseNumber(s.d, CultureInfo.invariantCulture));
                    break;
                case "type":
                    e = Nullable$1.toNullable(ST_SparklineType_$type, XmlNamespaceDefinitionBase.b(ST_SparklineType_$type, s.d));
                    break;
                case "dateAxis":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "displayEmptyCellsAs":
                    g = Nullable$1.toNullable(ST_DispBlanksAs_$type, XmlNamespaceDefinitionBase.b(ST_DispBlanksAs_$type, s.d));
                    break;
                case "markers":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "high":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "low":
                    j = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "first":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "last":
                    l = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "negative":
                    m = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "displayXAxis":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "displayHidden":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                case "minAxisType":
                    p = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, XmlNamespaceDefinitionBase.b(ST_SparklineAxisMinMax_$type, s.d));
                    break;
                case "maxAxisType":
                    q = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, XmlNamespaceDefinitionBase.b(ST_SparklineAxisMinMax_$type, s.d));
                    break;
                case "rightToLeft":
                    r = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(s.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r
        };
    }
    static bi(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(ST_DispBlanksAs_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Boolean_$type, null), o = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null), p = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = Nullable$1.toNullable(Boolean_$type, null), s = Nullable$1.toNullable(ST_SparklineType_$type, null)) {
        a.ad.p(b, null);
        let t = null;
        let u = null;
        if (c.hasValue) {
            u = "dateAxis";
            t = ST_OnOff.g(c.value);
            a.ad.h(u, t);
        }
        if (d.hasValue) {
            u = "displayEmptyCellsAs";
            t = XmlNamespaceDefinitionBase.f(ST_DispBlanksAs_$type, d.value);
            a.ad.h(u, t);
        }
        if (e.hasValue) {
            u = "displayHidden";
            t = ST_OnOff.g(e.value);
            a.ad.h(u, t);
        }
        if (f.hasValue) {
            u = "displayXAxis";
            t = ST_OnOff.g(f.value);
            a.ad.h(u, t);
        }
        if (g.hasValue) {
            u = "first";
            t = ST_OnOff.g(g.value);
            a.ad.h(u, t);
        }
        if (h.hasValue) {
            u = "high";
            t = ST_OnOff.g(h.value);
            a.ad.h(u, t);
        }
        if (i.hasValue) {
            u = "last";
            t = ST_OnOff.g(i.value);
            a.ad.h(u, t);
        }
        if (j.hasValue) {
            u = "lineWeight";
            t = j.value.toString();
            a.ad.h(u, t);
        }
        if (k.hasValue) {
            u = "low";
            t = ST_OnOff.g(k.value);
            a.ad.h(u, t);
        }
        if (l.hasValue) {
            u = "manualMax";
            t = l.value.toString();
            a.ad.h(u, t);
        }
        if (m.hasValue) {
            u = "manualMin";
            t = m.value.toString();
            a.ad.h(u, t);
        }
        if (n.hasValue) {
            u = "markers";
            t = ST_OnOff.g(n.value);
            a.ad.h(u, t);
        }
        if (o.hasValue) {
            u = "maxAxisType";
            t = XmlNamespaceDefinitionBase.f(ST_SparklineAxisMinMax_$type, o.value);
            a.ad.h(u, t);
        }
        if (p.hasValue) {
            u = "minAxisType";
            t = XmlNamespaceDefinitionBase.f(ST_SparklineAxisMinMax_$type, p.value);
            a.ad.h(u, t);
        }
        if (q.hasValue) {
            u = "negative";
            t = ST_OnOff.g(q.value);
            a.ad.h(u, t);
        }
        if (r.hasValue) {
            u = "rightToLeft";
            t = ST_OnOff.g(r.value);
            a.ad.h(u, t);
        }
        if (s.hasValue) {
            u = "type";
            t = XmlNamespaceDefinitionBase.f(ST_SparklineType_$type, s.value);
            a.ad.h(u, t);
        }
        ;
    }
}
CT_SparklineGroup.$t = markType(CT_SparklineGroup, 'CT_SparklineGroup');
/**
 * @hidden
 */
export class SparklineExtensions extends Base {
    static h(a, b, c, d) {
        if (b.a != null) {
            a.colorAxis = b.a.c(d);
        }
        if (b.c != null) {
            a.colorFirstPoint = b.c.c(d);
        }
        if (b.e != null) {
            a.colorHighPoint = b.e.c(d);
        }
        if (b.g != null) {
            a.colorLastPoint = b.g.c(d);
        }
        if (b.i != null) {
            a.colorLowPoint = b.i.c(d);
        }
        if (b.k != null) {
            a.colorMarkers = b.k.c(d);
        }
        if (b.m != null) {
            a.colorNegativePoints = b.m.c(d);
        }
        if (b.o != null) {
            a.colorSeries = b.o.c(d);
        }
        a.dateAxis = b.ah.hasValue ? b.ah.value : false;
        a.displayBlanksAs = b.aj.hasValue ? SparklineExtensions.e(b.aj.value) : SparklineExtensions.e(2);
        a.displayHidden = b.al.hasValue ? b.al.value : false;
        a.displayXAxis = b.an.hasValue ? b.an.value : false;
        a.firstPoint = b.ap.hasValue ? b.ap.value : false;
        a.highPoint = b.ar.hasValue ? b.ar.value : false;
        a.lastPoint = b.at.hasValue ? b.at.value : false;
        a.lineWeight = b.av.hasValue ? b.av.value : 0.75;
        a.lowPoint = b.ax.hasValue ? b.ax.value : false;
        a.markers = b.a3.hasValue ? b.a3.value : false;
        a.negativePoints = b.a9.hasValue ? b.a9.value : false;
        a.rightToLeft = b.bb.hasValue ? b.bb.value : false;
        a.type = b.bd.hasValue ? SparklineExtensions.f(b.bd.value) : SparklineExtensions.f(0);
        a.verticalAxisMaxType = b.a5.hasValue ? SparklineExtensions.d(b.a5.value) : SparklineExtensions.d(0);
        a.verticalAxisMinType = b.a7.hasValue ? SparklineExtensions.d(b.a7.value) : SparklineExtensions.d(0);
        if (b.az.hasValue) {
            a.verticalAxisMax = b.az.value;
        }
        if (b.a1.hasValue) {
            a.verticalAxisMin = b.a1.value;
        }
        if (stringIsNullOrEmpty(b.bf) == false) {
            a._setDateRange$i(b.bf);
        }
        a._sparklines$i.clear();
        for (let e of fromEnum(b.ae)) {
            let f = new Sparkline();
            SparklineExtensions.g(f, e, c, d._bi);
            a._sparklines$i._s(a._sparklines$i.count, f, f.location, f.dataRegion, f.dataRegionName, false);
        }
    }
    static g(a, b, c, d) {
        let e = null;
        let f = null;
        let g = null;
        for (let h of fromEnum(b.a.i)) {
            if (stringIsNullOrEmpty(h) == false) {
                f = h;
                g = c._getRegion1(f, c._c);
                break;
            }
        }
        e = b.c;
        let i = Worksheet._fh;
        try {
            let j = ExcelUtils.u(e, c, g.firstRow, g._v, 1, "dataRange", "LE_InvalidRegion", i, d);
            let k = null;
            if (i.count > 0 && i._inner[0].c != null) {
                k = i._inner[0].c._cw(i._inner[0].d);
            }
            else if (i.count == 1 && i._inner[0].e != null && stringContains(i._inner[0].e, "[")) {
                e = i._inner[0].e + i._inner[0].d._ah(false, false, c._o, 1);
            }
            a._p(g, k, e);
        }
        finally {
            i.clear();
        }
    }
    static e(a) {
        let b = 0;
        switch (a) {
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
            case 2:
                b = 2;
                break;
        }
        return b;
    }
    static c(a) {
        let b = 0;
        switch (a) {
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
            case 2:
                b = 2;
                break;
            default: break;
        }
        return b;
    }
    static f(a) {
        let b = 0;
        switch (a) {
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
            case 2:
                b = 2;
                break;
        }
        return b;
    }
    static b(a) {
        let b = 0;
        switch (a) {
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
            case 2:
                b = 2;
                break;
            default: break;
        }
        return b;
    }
    static d(a) {
        let b = 0;
        switch (a) {
            case 2:
                b = 2;
                break;
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
        }
        return b;
    }
    static a(a) {
        let b = 0;
        switch (a) {
            case 2:
                b = 2;
                break;
            case 1:
                b = 1;
                break;
            case 0:
                b = 0;
                break;
            default: break;
        }
        return b;
    }
}
SparklineExtensions.$t = markType(SparklineExtensions, 'SparklineExtensions');
/**
 * @hidden
 */
export class ObjectModelWorksheetPartManager extends WorksheetPartManager {
    constructor() {
        super();
        this.bs = null;
        this.bu = 0;
        this.bj = 0;
        this.bt = null;
        this.br = null;
        this.bq = null;
        this.bk = null;
        this.bv = -1;
        this.bn = false;
        this.bm = false;
        this.be = null;
        this.ay(SpreadsheetMLMain.c5, ObjectModelWorksheetPartManager.b6);
        this.ax(SpreadsheetMLMain.c5, ObjectModelWorksheetPartManager.b7);
        this.ay(SpreadsheetMLMain.dq, ObjectModelWorksheetPartManager.cd);
        this.ay(SpreadsheetMLMain.dt, ObjectModelWorksheetPartManager.ce);
        this.ay(SpreadsheetMLMain.eq, ObjectModelWorksheetPartManager.co);
        this.ay(SpreadsheetMLMain.ep, ObjectModelWorksheetPartManager.cq);
        this.ay(SpreadsheetMLMain.eu, ObjectModelTablePartManager.be);
        this.ay(SpreadsheetMLMain.ey, ObjectModelWorksheetPartManager.cv);
        this.ay(SpreadsheetMLMain.e7, ObjectModelWorksheetPartManager.cw);
        this.ax(SpreadsheetMLMain.e7, ObjectModelWorksheetPartManager.cy);
        this.ay(SpreadsheetMLMain.ef, ObjectModelWorksheetPartManager.cg);
        this.ax(SpreadsheetMLMain.ef, ObjectModelWorksheetPartManager.ci);
        this.ay(SpreadsheetMLMain.iq, ObjectModelWorksheetPartManager.dz);
        this.ay(SpreadsheetMLMain.eg, ObjectModelWorksheetPartManager.ck);
        this.ay(SpreadsheetMLMain.et, ObjectModelWorksheetPartManager.cr);
        this.ay(SpreadsheetMLMain.ex, ObjectModelWorksheetPartManager.ct);
        this.ay(SpreadsheetMLMain.js, ObjectModelWorksheetPartManager.d5);
        this.ay(SpreadsheetMLMain.fu, ObjectModelWorksheetPartManager.c8);
        this.ay(SpreadsheetMLMain.cj, ObjectModelWorksheetPartManager.b5);
        this.ay(SpreadsheetMLMain.dk, ObjectModelWorksheetPartManager.cb);
        this.ay(SpreadsheetMLMain.hv, ObjectModelWorksheetPartManager.ds);
        this.ay(SpreadsheetMLMain.mb, ObjectModelWorksheetPartManager.eu);
        this.ay(SpreadsheetMLMain.ix, ObjectModelWorksheetPartManager.d0);
        this.ay(SpreadsheetMLMain.lh, ObjectModelWorksheetPartManager.ek);
        this.ay(SpreadsheetMLMain.m0, ObjectModelWorksheetPartManager.e1);
        this.ay(SpreadsheetMLMain.id, ObjectModelWorksheetPartManager.du);
        this.ay(SpreadsheetMLMain.dg, ObjectModelWorksheetPartManager.b9);
        this.ay(SpreadsheetMLMain.hs, ObjectModelWorksheetPartManager.dq);
        this.ay(SpreadsheetMLMain.dn, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.tu, (b) => b.c));
        this.ay(SpreadsheetMLMain.gq, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.ve, (b) => b.e));
        this.ay(SpreadsheetMLMain.ha, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.vm, (b) => b.k, Nullable$1.toNullable(ST_ConformanceClass_$type, 1)));
        this.ay(SpreadsheetMLMain.jg, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.wg, (b) => b.g));
        this.ay(SpreadsheetMLMain.kc, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.wo, (b) => b.i, Nullable$1.toNullable(ST_ConformanceClass_$type, 0)));
        this.ay(SpreadsheetMLMain.n1, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.xj, (b) => b.k, Nullable$1.toNullable(ST_ConformanceClass_$type, 0)));
        this.ay(SpreadsheetMLMain.p8, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.x9, (b) => b.i, Nullable$1.toNullable(ST_ConformanceClass_$type, 1)));
        this.ay(SpreadsheetMLMain.re, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.yr, (b) => b.m));
        this.ay(SpreadsheetMLMain.r8, (a) => ObjectModelWorksheetPartManager.cc(a, SpreadsheetMLMain.yw, (b) => b.o));
        this.ay(SpreadsheetML2009Main.bv, ObjectModelWorksheetPartManager.d8);
        this.ay(SpreadsheetML2009Main.a9, ObjectModelWorksheetPartManager.c0);
        this.ay(SpreadsheetML2009Main.a8, ObjectModelWorksheetPartManager.cx);
        this.ay(SpreadsheetML2009Main.aw, ObjectModelWorksheetPartManager.ch);
        this.ax(SpreadsheetML2009Main.aw, ObjectModelWorksheetPartManager.cj);
        this.ay(SpreadsheetML2009Main.bt, ObjectModelWorksheetPartManager.d6);
        this.ay(SpreadsheetML2009Main.bc, ObjectModelWorksheetPartManager.c9);
        this.ay(SpreadsheetML2009Main.ax, ObjectModelWorksheetPartManager.cl);
        this.ax(SpreadsheetML2009Main.ax, ObjectModelWorksheetPartManager.cn);
        this.ay(SpreadsheetML2009Main.ar, ObjectModelWorksheetPartManager.b8);
        this.ay(SpreadsheetML2009Main.au, ObjectModelWorksheetPartManager.ca);
        this.ay(SpreadsheetML2009Main.bm, ObjectModelWorksheetPartManager.dr);
        this.ay(SpreadsheetML2009Main.b4, ObjectModelWorksheetPartManager.ej);
        this.ay(SpreadsheetML2009Main.b3, ObjectModelWorksheetPartManager.ei);
        this.ay(SpreadsheetML2009Main.av, ObjectModelWorksheetPartManager.cf);
        this.ay(SpreadsheetML2009Main.a6, ObjectModelWorksheetPartManager.cu);
        this.ay(SpreadsheetML2009Main.ay, ObjectModelWorksheetPartManager.cs);
        this.ax(SpreadsheetML2009Main.a8, ObjectModelWorksheetPartManager.cz);
        this.ay(SpreadsheetML2009Main.bi, ObjectModelWorksheetPartManager.di);
        this.ax(SpreadsheetML2009Main.bi, ObjectModelWorksheetPartManager.dj);
        this.ay(SpreadsheetMLMain.fc, ObjectModelWorksheetPartManager.c1);
        this.ay(SpreadsheetMLMain.fd, ObjectModelWorksheetPartManager.c2);
        this.ay(SpreadsheetMLMain.fe, ObjectModelWorksheetPartManager.c3);
        this.ay(SpreadsheetMLMain.fj, ObjectModelTablePartManager.bf);
        this.ay(SpreadsheetMLMain.fk, ObjectModelTablePartManager.bg);
        this.ax(SpreadsheetMLMain.fk, ObjectModelTablePartManager.bh);
        this.ay(SpreadsheetMLMain.fp, ObjectModelWorksheetPartManager.c6);
        this.ay(SpreadsheetMLMain.fq, ObjectModelWorksheetPartManager.c7);
        this.ay(SpreadsheetMLMain.f1, ObjectModelTablePartManager.bi);
        this.ay(SpreadsheetMLMain.fx, ObjectModelWorksheetPartManager.db);
        this.ax(SpreadsheetMLMain.fx, ObjectModelWorksheetPartManager.dd);
        this.ay(SpreadsheetMLMain.fy, ObjectModelWorksheetPartManager.de);
        this.ay(SpreadsheetMLMain.gv, ObjectModelWorksheetPartManager.df);
        this.ay(SpreadsheetMLMain.g1, ObjectModelWorksheetPartManager.dh);
        this.ay(SpreadsheetMLMain.g8, ObjectModelTablePartManager.bj);
        this.ay(SpreadsheetMLMain.hj, ObjectModelWorksheetPartManager.dk);
        this.ay(SpreadsheetMLMain.hp, ObjectModelWorksheetPartManager.dl);
        this.ay(SpreadsheetMLMain.hq, ObjectModelWorksheetPartManager.dm);
        this.ay(SpreadsheetMLMain.hy, ObjectModelTablePartManager.bm);
        this.ay(SpreadsheetMLMain.h0, ObjectModelTablePartManager.bk);
        this.ax(SpreadsheetMLMain.h0, ObjectModelWorksheetPartManager.dt);
        this.ay(SpreadsheetMLMain.h3, ObjectModelTablePartManager.bn);
        this.ay(SpreadsheetMLMain.ir, ObjectModelWorksheetPartManager.dw);
        this.ay(SpreadsheetMLMain.is, ObjectModelWorksheetPartManager.dy);
        this.ay(SpreadsheetMLMain.i4, ObjectModelWorksheetPartManager.d1);
        this.ay(SpreadsheetMLMain.jm, ObjectModelWorksheetPartManager.d3);
        this.ay(SpreadsheetMLMain.jn, ObjectModelWorksheetPartManager.d4);
        this.ay(SpreadsheetMLMain.jq, ObjectModelTablePartManager.bo);
        this.ay(SpreadsheetMLMain.b7, ObjectModelWorksheetPartManager.d9);
        this.ax(SpreadsheetMLMain.b7, ObjectModelWorksheetPartManager.ea);
        this.ay(SpreadsheetMLMain.ke, ObjectModelWorksheetPartManager.ec);
        this.ay(SpreadsheetMLMain.kf, ObjectModelWorksheetPartManager.ee);
        this.ay(SpreadsheetMLMain.k4, ObjectModelWorksheetPartManager.eg);
        this.ay(SpreadsheetMLMain.k5, ObjectModelWorksheetPartManager.eh);
        this.ay(SpreadsheetMLMain.ll, ObjectModelWorksheetPartManager.el);
        this.ay(SpreadsheetMLMain.lm, ObjectModelWorksheetPartManager.em);
        this.ay(SpreadsheetMLMain.lz, ObjectModelWorksheetPartManager.eo);
        this.ay(SpreadsheetMLMain.l1, ObjectModelWorksheetPartManager.ep);
        this.ay(SpreadsheetMLMain.l3, ObjectModelWorksheetPartManager.eq);
        this.ay(SpreadsheetMLMain.l4, ObjectModelWorksheetPartManager.es);
        this.ay(SpreadsheetMLMain.l5, ObjectModelWorksheetPartManager.et);
        this.ay(SpreadsheetMLMain.mh, ObjectModelWorksheetPartManager.ew);
        this.ay(SpreadsheetMLMain.ms, ObjectModelWorksheetPartManager.ex);
        this.ay(SpreadsheetMLMain.my, ObjectModelWorksheetPartManager.ez);
        this.ay(SpreadsheetMLMain.mz, ObjectModelWorksheetPartManager.e0);
        this.ay(SpreadsheetMLMain.n4, ObjectModelWorksheetPartManager.e4);
        this.ay(SpreadsheetMLMain.n5, ObjectModelWorksheetPartManager.e2);
        this.ay(SpreadsheetMLMain.oh, ObjectModelWorksheetPartManager.e5);
        this.ay(SpreadsheetMLMain.oo, ObjectModelWorksheetPartManager.e6);
        this.ay(SpreadsheetMLMain.op, ObjectModelWorksheetPartManager.e7);
        this.ax(SpreadsheetMLMain.op, ObjectModelWorksheetPartManager.e9);
        this.ay(SpreadsheetMLMain.or, ObjectModelWorksheetPartManager.fb);
        this.ay(SpreadsheetMLMain.ov, ObjectModelWorksheetPartManager.fd);
        this.ay(SpreadsheetMLMain.ow, ObjectModelWorksheetPartManager.ff);
        this.ay(SpreadsheetMLMain.oy, ObjectModelWorksheetPartManager.fh);
        this.ay(SpreadsheetMLMain.oz, ObjectModelWorksheetPartManager.fi);
        this.ay(SpreadsheetMLMain.p1, ObjectModelWorksheetPartManager.fm);
        this.ay(SpreadsheetMLMain.p3, ObjectModelWorksheetPartManager.fn);
        this.ay(SpreadsheetMLMain.qp, ObjectModelWorksheetPartManager.fq);
        this.ay(SpreadsheetMLMain.qv, ObjectModelWorksheetPartManager.fs);
        this.ay(SpreadsheetMLMain.qw, ObjectModelWorksheetPartManager.ft);
        this.ay(SpreadsheetMLMain.rg, ObjectModelTablePartManager.bw);
        this.ay(SpreadsheetMLMain.r3, ObjectModelWorksheetPartManager.fu);
        this.ay(SpreadsheetMLMain.su, ObjectModelWorksheetPartManager.fw);
        this.ax(SpreadsheetMLMain.su, ObjectModelWorksheetPartManager.fy);
        this.ay(SpreadsheetML2009Main.bd, ObjectModelWorksheetPartManager.db);
        this.ax(SpreadsheetML2009Main.bd, ObjectModelWorksheetPartManager.dd);
        this.ay(SpreadsheetML2009Main.be, ObjectModelWorksheetPartManager.de);
        this.ay(SpreadsheetML2009Main.bn, ObjectModelWorksheetPartManager.dv);
        this.ay(SpreadsheetML2009Main.bo, ObjectModelWorksheetPartManager.dx);
        this.ay(SpreadsheetML2009Main.br, ObjectModelTablePartManager.bo);
        this.ay(SpreadsheetML2009Main.cf, ObjectModelWorksheetPartManager.fk);
        this.ay(SpreadsheetML2009Main.cj, ObjectModelWorksheetPartManager.fl);
        this.ay(SpreadsheetML2009Main.cl, ObjectModelWorksheetPartManager.fm);
        this.ay(Excel2006Main.ar, ObjectModelWorksheetPartManager.fo);
        this.ay(Excel2006Main.ap, ObjectModelWorksheetPartManager.dn);
        SparklinesDeserializer.z(this);
        ObjectModelCommonPartHelpers.al(this);
        ObjectModelCommonPartHelpers.am(this);
    }
    z(a) {
        if (a == SpreadsheetMLMain.e7) {
            return 2;
        }
        return super.z(a);
    }
    t() {
        this.br = new Dictionary$2(Number_$type, Formula.$, 0);
        this.bq = new Dictionary$2(String_$type, Formula.$, 0);
        let a = this.bg;
        let b = a._d.uri.toString();
        this.bk = a._b7._ap(b);
        if (this.bk == null) {
            return null;
        }
        return super.t();
    }
    av(a) {
        switch (a.b.b.e(this.d)) {
            case SpreadsheetMLMain.e7: break;
            default:
                super.av(a);
                break;
        }
    }
    u(a) {
        let b = typeCast(Worksheet.$, a);
        if (b == null) {
            return null;
        }
        this.bk = b;
        this.bj = this.bk.workbook.currentFormat;
        let c = this.bg;
        let d = c._b9;
        let e = d._w(b);
        this.fz(b, e);
        let f = false;
        for (let g = 0; g < b._shapes$i.count; g++) {
            let h = d._z(b._shapes$i.item(g));
            if (h != null) {
                f = true;
                break;
            }
        }
        let i = new SheetRelationships();
        let j = b._je == null ? null : ExcelUtils.y(b._je, b._dh);
        return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(Async.g(j != null, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._b0(j, b._dh), (k) => e.a = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d)), () => Async.g(f, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelDrawingPartManager.bf, b), (k) => i.a = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => Async.g(e.j.count != 0, () => c._j(ObjectModelCommentsPartManager.a8, b))), () => Async.g(this.bt.count != 0, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelVmlDrawingPartManager.ba, this.bt), (k) => i.c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => Async.g(b._g3 != null, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelVmlDrawingPartManager.ba, b._g3), (k) => i.b = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => Async.c(0, b._tables$i.count, 1, (k) => c._j(ObjectModelTablePartManager.a9, b._tables$i._item(k)))), () => Async.d(PivotTableInfo.$, b._ey(), (k) => c._j(ObjectModelPivotTablePartManager.a9, k))), () => this.bc(d, i));
    }
    ai(a) {
        switch (a) {
            case SpreadsheetMLMain.hj:
                {
                    let b;
                    let c = SpreadsheetMLMain.vp(this, b);
                    b = c.p1;
                    switch (b) {
                        case "{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}":
                        case "{A8765BA9-456A-4dab-B4F3-ACF838C121DE}":
                        case "{78C0D931-6437-407d-A8EE-F0AAD7539E65}":
                        case "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}":
                        case "{05C60535-1F16-4fd2-B633-F4F36F0B64E0}": return true;
                        default: return false;
                    }
                }
        }
        return super.ai(a);
    }
    y(a, b) {
        switch (a.b.e(this.bg)) {
            case SpreadsheetMLMain.e7:
                {
                    let c = typeCast(List$1.$.specialize(Base.$), a.n);
                    if (c != null) {
                        let d = new StringBuilder(0);
                        for (let e of fromEnum(c)) {
                            let f = null;
                            let g = typeCast(WorksheetCell.$, e);
                            if (WorksheetCell.l_op_Inequality(g, null)) {
                                if (g.worksheet != null) {
                                    f = g._toString2(1, false, true, true);
                                }
                            }
                            else {
                                let h = e;
                                if (h.worksheet != null) {
                                    f = h._toString2(1, false, true, true);
                                }
                            }
                            if (f == null) {
                                continue;
                            }
                            if (d.c != 0) {
                                d.h(' ');
                            }
                            d.l(f);
                        }
                        if (d.c == 0) {
                            return 2;
                        }
                        for (let i = 0; i < a.j.count; i++) {
                            let j = a.j._inner[i];
                            if (j.a.f == "sqref") {
                                a.j._inner[i] = new AttributeValue(2, j.a, d.toString());
                                break;
                            }
                        }
                    }
                }
                break;
            case SpreadsheetMLMain.ef:
                {
                    let k = typeCast(WorksheetCellFormatData.$, a.n);
                    if (k != null) {
                        let l = this.bg._b9._ba(k);
                        for (let m = 0; m < a.j.count; m++) {
                            let n = a.j._inner[m];
                            if (n.a.f == "dxfId") {
                                a.j._inner[m] = new AttributeValue(2, n.a, l.toString());
                                break;
                            }
                        }
                    }
                }
                break;
            case SpreadsheetMLMain.eg:
                {
                    let o = typeCast(Tuple$2.$.specialize(SingleTargetFormula.$, String_$type), a.n);
                    if (o != null) {
                        let p = this.bg._b9;
                        let q = p._ct(o.c);
                        for (let r = 0; r < a.j.count; r++) {
                            let s = a.j._inner[r];
                            if (s.a.f == "val") {
                                a.j._inner[r] = new AttributeValue(2, s.a, q);
                                break;
                            }
                        }
                    }
                }
                break;
            case SpreadsheetMLMain.iq:
                {
                    let t = typeCast(Tuple$2.$.specialize(SingleTargetFormula.$, String_$type), a.n);
                    if (t != null) {
                        let u = this.bg._b9;
                        a.p = u._ct(t.c);
                    }
                }
                break;
            default: break;
        }
        return 0;
    }
    b4(a, b) {
        let c = b.aw;
        if (c != null) {
            let d = false;
            let e = "visibility:";
            let f = "hidden";
            let g = c.indexOf(e);
            if (g >= 0) {
                let h = g + e.length;
                if (stringCompare3(c, h, f, 0, f.length) == 0) {
                    d = true;
                }
            }
            a.visible = (d == false);
        }
        let i = (b.aj.getValueOrDefault() == false);
        let j = (b.ad.getValueOrDefault() == false);
        if (i == true) {
            a.positioningMode = 0;
        }
        else if (j == true) {
            a.positioningMode = 2;
        }
        else {
            a.positioningMode = 3;
        }
        let k = b.b[0];
        let l = b.b[1];
        let m = b.b[2];
        let n = b.b[3];
        let o = b.b[4];
        let p = b.b[5];
        let q = b.b[6];
        let r = b.b[7];
        a.topLeftCornerCell = this.bk._rows$i.item(m)._cells$i.item(k);
        a.bottomRightCornerCell = this.bk._rows$i.item(q)._cells$i.item(o);
        let s = this.bk._fp(k, true);
        let t = this.bk._fs(m, true);
        a._topLeftCornerPosition$i = ExcelUtils.g6((s == 0 ? 0 : (100 * l) / s), (t == 0 ? 0 : (100 * n) / t));
        let u = this.bk._fp(o, true);
        let v = this.bk._fs(q, true);
        a._bottomRightCornerPosition$i = ExcelUtils.g6((u == 0 ? 0 : (100 * p) / u), (v == 0 ? 0 : (100 * r) / v));
        let w = ObjectModelWorksheetPartManager.bx(b);
        if (nullableNotEquals(w, null)) {
            a._cn = w.value;
        }
        if (stringIsNullOrEmpty(b.ao) == false) {
            try {
                a._aa = this.bk._getCell(b.ao);
            }
            catch (x) {
            }
        }
    }
    static b0(a) {
        if (a == null) {
            return null;
        }
        let b = stringReplace(a, "\r\n", "_x000a_");
        b = stringReplace(b, "\n", "_x000a_");
        return b;
    }
    static b1(a) {
        if (a == null) {
            return null;
        }
        return Regex.h(a, "_x000a_", "\n", 1);
    }
    b3(a) {
        return CellAddress.v(a, true, this.bj, a, false, 1);
    }
    static bx(a) {
        let b = ObjectModelWorksheetPartManager.by(a.au);
        if (nullableNotEquals(b, null)) {
            return b;
        }
        b = ObjectModelWorksheetPartManager.by(a.at);
        if (nullableNotEquals(b, null)) {
            return b;
        }
        return Nullable$1.toNullable(Number_$type, null);
    }
    bo(a) {
        if (a == null) {
            return false;
        }
        let b = a._e;
        for (let c = 0; c < b.length; c++) {
            switch (b[c].f) {
                case 123:
                case 59:
                case 91:
                case 125:
                case 61:
                case 93:
                case 121:
                case 57:
                case 89:
                case 122:
                case 58:
                case 90:
                case 124:
                case 60:
                case 92: return true;
            }
        }
        return false;
    }
    static b6(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c;
        let d = SpreadsheetMLMain.to(a, c);
        c = d.p1;
        if (!stringIsNullOrEmpty(c)) {
            let e;
            let f;
            let g;
            let h;
            let i = b.bk;
            let j = i.workbook;
            let k = ExcelUtils.fv(c, j.currentFormat, 1, CultureInfo.invariantCulture, null, -1, e, f, g, h);
            e = k.p6;
            f = k.p7;
            g = k.p8;
            h = k.p9;
            let l = new WorksheetRegionAddress(1, e, g, f, h);
            b.bk.filterSettings._setRegion1(l._ah(false, false, i._o, 1), 1);
            b.bm = true;
        }
    }
    static b7(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        b.bm = false;
    }
    static cd(a) {
        let b = a.s.a(PrintOptions.$);
        if (b == null) {
            return;
        }
        let c = a.s.a(HorizontalPageBreakCollection.$);
        let d = a.s.a(VerticalPageBreakCollection.$);
        if (c == null && d == null) {
            return;
        }
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.tv(a, e, f, g, h, i);
        e = j.p1;
        f = j.p2;
        g = j.p3;
        h = j.p4;
        i = j.p5;
        let k = ObjectModelWorksheetPartManager.bh(a)._by;
        let l = d != null;
        let m = Nullable$1.toNullable(Number_$type, f);
        let n = Nullable$1.toNullable(Number_$type, g);
        let o = l ? new VerticalPageBreak(e, m, n) : new HorizontalPageBreak(e, m, n);
        o._g = h;
        o._d = i;
        o.printArea = b._printAreas$i._e(o._k, o._q, o._o, l);
        if (l) {
            d._add$i(o);
        }
        else {
            c._add$i(o);
        }
    }
    static ce(a) {
        let b = a.s.a(WorksheetRow.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i = SpreadsheetMLMain.ty(a, c, d, e, f, g, h);
        c = i.p1;
        d = i.p2;
        e = i.p3;
        f = i.p4;
        g = i.p5;
        h = i.p6;
        let j = a;
        let k = ObjectModelWorksheetPartManager.bh(a);
        if (c != null) {
            let l;
            if (((() => { let m = ExcelUtils.bm(c, 2, CultureInfo.invariantCulture, j.bu, l); j.bu = m.p3; l = m.p4; return m.ret; })()) == false) {
            }
        }
        else {
            j.bu = ++b._cells$i._u;
        }
        let m;
        if (d < k._b7._be.count) {
            m = k._b7._be._inner[d].g;
        }
        else {
            m = k._by._ca._p;
        }
        b._d3(j.bu, m);
        a.s.k(KnownBoxes.as(e));
    }
    static co(a) {
        let b = a.s.a(PrintOptions.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.uc(a, c, d);
        c = e.p1;
        d = e.p2;
        a.s.k(b._verticalPageBreaks$i);
    }
    static cq(a) {
        a.cp();
    }
    cp() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k = SpreadsheetMLMain.ud(this, a, b, c, d, e, f, g, h, i, j);
        a = k.p1;
        b = k.p2;
        c = k.p3;
        d = k.p4;
        e = k.p5;
        f = k.p6;
        g = k.p7;
        h = k.p8;
        i = k.p9;
        j = k.p10;
        let l = ObjectModelWorksheetPartManager.bh(this);
        let m = l._by;
        let n = this.bk.defaultColumnWidth;
        if (nullableNotEquals(c, null)) {
            n = truncate(MathUtilities.f(c.value * 256));
            if (b == 16384 && this.bk.defaultColumnWidth == 0) {
                this.bk.defaultColumnWidth = n;
            }
        }
        let o = false;
        if (g) {
            o = true;
        }
        else {
            if (n != this.bk.defaultColumnWidth) {
                o = true;
            }
        }
        if (e) {
            o = true;
        }
        if (i != 0) {
            o = true;
        }
        let p = null;
        if (d < l._b7._be.count) {
            let q = l._b7._be._inner[d].g;
            if (q._ca(m._ca._p) == false) {
                p = q;
                o = true;
            }
        }
        else {
        }
        if (o == false) {
            return;
        }
        this.bk._hw((a - 1), (b - 1), n, e, i, p, g);
    }
    static cv(a) {
    }
    static c0(a) {
    }
    static cx(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        if (b.be == null) {
            b.be = new ConditionalFormatInfo(b.bk, b.bg._b7);
        }
        b.s.k(b.be);
    }
    static cw(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c;
        let d;
        let e = SpreadsheetMLMain.um(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = b.bk;
        if (b.be == null) {
            b.be = new ConditionalFormatInfo(f, b.bg._b7);
        }
        else {
            b.be.o();
        }
        let g = b.be;
        g.f = d;
        ConditionalFormatInfo.n(g, c);
        b.s.k(b.be);
    }
    static cy(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        b.s.h();
    }
    static cz(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        for (let d of fromEnum(c.l)) {
            d.ap(c);
            d.r = c.f;
            c.k.add(d);
        }
        c.l.clear();
        c.o();
        b.s.h();
    }
    static ch(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = CfRuleInfo.b(c, a);
        c.b = d;
    }
    static cj(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = c.b;
        if (CfRuleInfo.l(d) == false) {
            return;
        }
        let e = null;
        if (stringIsNullOrEmpty(d.an) == false && ((() => { let f = c.h.tryGetValue(d.an, e); e = f.p1; return f.ret; })())) {
            e.aq(d);
            c.h.removeItem(d.an);
        }
        else {
            c.l.add(d);
        }
    }
    static cg(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = CfRuleInfo.a(a, c);
        c.k.add(d);
        c.b = d;
    }
    static ci(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        if (stringIsNullOrEmpty(c.b.am) == false) {
            c.h.addItem(c.b.am, c.b);
        }
        c.b = null;
    }
    static cl(a) {
        let b = null;
        let c = ObjectModelWorksheetPartManager.bf(a, b);
        b = c.p1;
        if (b != null) {
            b.q = true;
        }
        ObjectModelWorksheetPartManager.cm(a, true);
    }
    static cn(a) {
        let b = null;
        let c = ObjectModelWorksheetPartManager.bf(a, b);
        b = c.p1;
        if (b != null) {
            b.q = false;
        }
    }
    static ck(a) {
        ObjectModelWorksheetPartManager.cm(a, false);
    }
    static cm(a, b) {
        let c = typeCast(ObjectModelWorksheetPartManager.$, a);
        let d = c.be;
        if (ConditionalFormatInfo.e(d) == false) {
            return;
        }
        let e = d.b;
        if (CfRuleInfo.l(e) == false) {
            return;
        }
        let f;
        let g;
        let h;
        if (b) {
            let i = SpreadsheetML2009Main.cv(a, f, g, h);
            f = i.p1;
            g = i.p2;
            h = i.p3;
        }
        else {
            let j = SpreadsheetMLMain.t5(a, f, g, h);
            f = j.p1;
            g = j.p2;
            h = j.p3;
        }
        let k = ((() => {
            let $ret = new CfvoWrapper();
            $ret.a = f;
            $ret.c = g;
            $ret.b = h;
            return $ret;
        })());
        e.ab.add(k);
    }
    static ct(a) {
    }
    static cr(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = ObjectModelWorksheetPartManager.bd(a, SpreadsheetMLMain.et);
        let d = a.s.a(ColorInfo.$);
        if (d != null) {
            d.m(c, b.bk.workbook);
            return;
        }
        let e = b.be;
        if (e == null) {
            return;
        }
        let f = e.b;
        if (f == null) {
            return;
        }
        if (f.h != null) {
            let g = a.s.a(DxfInfo.$);
            g.d = c;
        }
        else {
            f.y.add(c);
        }
    }
    static bd(a, b) {
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = 0;
        let h = false;
        switch (b) {
            case SpreadsheetMLMain.et:
            case SpreadsheetML2009Main.ay:
            case SpreadsheetML2009Main.ar:
            case SpreadsheetML2009Main.au:
            case SpreadsheetML2009Main.bm:
            case SpreadsheetML2009Main.b3:
            case SpreadsheetML2009Main.b4:
                h = true;
                break;
            default: break;
        }
        if (h == false) {
            return null;
        }
        let i = SpreadsheetMLMain.us(a, b, c, d, e, f, g);
        c = i.p2;
        d = i.p3;
        e = i.p4;
        f = i.p5;
        g = i.p6;
        let j = ((() => {
            let $ret = new ColorInfo();
            $ret.i = c;
            $ret.j = d;
            $ret.k = e;
            $ret.l = f;
            $ret.g = g;
            return $ret;
        })());
        return j;
    }
    static dp(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (c == null) {
            return;
        }
        let d = c.b;
        if (d == null) {
            return;
        }
        let e;
        let f = Excel2006Main.as(a, e);
        e = f.p1;
        if (e != null) {
            let g = d.q;
            if (g == false) {
                d.z.add(e);
                return;
            }
            if (d.ab.count < 1) {
            }
            else {
                let h = d.ab._inner[d.ab.count - 1];
                h.c = e;
            }
        }
    }
    static d6(a) {
        ObjectModelWorksheetPartManager.d7(a, true);
    }
    static d5(a) {
        ObjectModelWorksheetPartManager.d7(a, false);
    }
    static d7(a, b) {
        let c = typeCast(ObjectModelWorksheetPartManager.$, a);
        let d = c.be;
        if (ConditionalFormatInfo.e(d) == false) {
            return;
        }
        let e = d.b;
        if (CfRuleInfo.l(e) == false) {
            return;
        }
        let f = 3;
        let g;
        let h;
        let i;
        let j;
        let k = SpreadsheetMLMain.wk(a, f, g, h, i, j);
        f = k.p1;
        g = k.p2;
        h = k.p3;
        i = k.p4;
        j = k.p5;
        e.j.m = Nullable$1.toNullable(ST_IconSetType_$type, f);
        e.j.j = Nullable$1.toNullable(Boolean_$type, g);
        e.j.k = Nullable$1.toNullable(Boolean_$type, h);
        e.j.l = i;
        e.j.i = Nullable$1.toNullable(Boolean_$type, b ? j : false);
    }
    static cf(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        if (d == null) {
            return;
        }
        let e;
        let f;
        let g = SpreadsheetML2009Main.cu(a, e, f);
        e = g.p1;
        f = g.p2;
        let h = ((() => {
            let $ret = new IconCriterionWrapper();
            $ret.a = e;
            $ret.b = f;
            return $ret;
        })());
        c.j.h.add(h);
    }
    static cu(a) {
    }
    static c8(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = c.b;
        if (CfRuleInfo.l(d) == false) {
            return;
        }
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.u3(a, e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        d.g.w = f;
        d.g.v = e;
        d.g.z = g;
    }
    static c9(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = c.b;
        if (CfRuleInfo.l(d) == false) {
            return;
        }
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n = SpreadsheetML2009Main.cx(a, e, f, g, h, i, j, k, l, m);
        e = n.p1;
        f = n.p2;
        g = n.p3;
        h = n.p4;
        i = n.p5;
        j = n.p6;
        k = n.p7;
        l = n.p8;
        m = n.p9;
        d.g.v = e;
        d.g.w = f;
        d.g.z = g;
        d.g.t = h;
        d.g.u = i;
        d.g.s = j;
        d.g.y = k;
        d.g.x = l;
        d.g.r = m;
    }
    static dr(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.bm);
        c.g.c = e;
    }
    static ca(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.au);
        c.g.b = e;
    }
    static b8(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.ar);
        c.g.a = e;
    }
    static ej(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.b4);
        c.g.e = e;
    }
    static ei(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.b3);
        c.g.d = e;
    }
    static cs(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = null;
        let d = ((() => { let e = ObjectModelWorksheetPartManager.bf(a, c); c = e.p1; return e.ret; })());
        let e = ObjectModelWorksheetPartManager.bd(a, SpreadsheetML2009Main.ay);
        c.y.add(e);
    }
    static d8(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (c != null) {
            let d = c.b;
            if (d != null) {
                let e;
                let f = SpreadsheetML2009Main.c2(a, e);
                e = f.p1;
                d.am = e;
            }
        }
    }
    static di(a) {
        let b = new DxfInfo(0);
        a.s.k(b);
        let c = null;
        let d = ObjectModelWorksheetPartManager.bf(a, c);
        c = d.p1;
        if (c != null) {
            c.h = b;
        }
    }
    static dj(a) {
        let b = a.s.a(DxfInfo.$);
        if (b == null) {
            return;
        }
        let c = ObjectModelWorksheetPartManager.bh(a);
        let d = intSToU(c._b7._g.count);
        c._b7._g.add(b.h(c._b7));
        let e = null;
        let f = ((() => { let g = ObjectModelWorksheetPartManager.bf(a, e); e = g.p1; return g.ret; })());
        if (ConditionalFormatInfo.e(f) == false) {
            return;
        }
        e.ae = Nullable$1.toNullable(Number_$type, d);
        e.h = null;
    }
    static b5(a) {
        ObjectModelStylesPartManager.a9(a);
    }
    static cb(a) {
        ObjectModelStylesPartManager.bb(a);
    }
    static cc(a, b, c, d = Nullable$1.toNullable(ST_ConformanceClass_$type, null)) {
        ObjectModelStylesPartManager.bd(a, b, c, d);
    }
    static ds(a) {
        ObjectModelStylesPartManager.bn(a);
    }
    static eu(a) {
        ObjectModelStylesPartManager.bw(a);
    }
    static d0(a) {
        ObjectModelStylesPartManager.br(a);
    }
    static b9(a) {
        ObjectModelStylesPartManager.ba(a);
    }
    static dq(a) {
        ObjectModelStylesPartManager.bm(a);
    }
    static ek(a) {
        ObjectModelStylesPartManager.bu(a);
    }
    static e1(a) {
        ObjectModelStylesPartManager.bx(a);
    }
    static du(a) {
        ObjectModelStylesPartManager.bp(a);
    }
    static dz(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (ConditionalFormatInfo.e(c) == false) {
            return;
        }
        let d = c.b;
        if (CfRuleInfo.l(d) == false) {
            return;
        }
        let e = null;
        let f = SpreadsheetMLMain.wd(a, e);
        e = f.p1;
        d.z.add(e);
    }
    static c1(a) {
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.un(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        let f = ObjectModelWorksheetPartManager.bh(a);
        let g = typeCast(RoundTripControlData.$, f._au(c));
        if (g != null) {
            if (g.b) {
                return;
            }
            g.b = true;
        }
        let h;
        if (((() => { let i = f._b7._a5.tryGetValue(b, h); h = i.p1; return i.ret; })()) == false) {
            h = new UnknownShape(1);
            h._cn = b;
            f._b7._a5.addItem(b, h);
        }
        h._ef = g;
        a.s.k(h);
    }
    static c2(a) {
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q = SpreadsheetMLMain.uo(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
        b = q.p1;
        c = q.p2;
        d = q.p3;
        e = q.p4;
        f = q.p5;
        g = q.p6;
        h = q.p7;
        i = q.p8;
        j = q.p9;
        k = q.p10;
        l = q.p11;
        m = q.p12;
        n = q.p13;
        o = q.p14;
        p = q.p15;
    }
    static c3(a) {
    }
    static c4(a, b, c, d, e) {
        let f = ObjectModelWorksheetPartManager.bh(a);
        let g = f._by;
        let h = WorkbookLoadManagerExcel2007._bs(c);
        c = h.p0;
        e(Formula._k(c, 1, d, g.currentFormat, CultureInfo.invariantCulture, f._b7._bi), b._toString1(b.worksheet._c, false));
    }
    static c6(a) {
        a.c5();
    }
    c5() {
        let a = new ST_Guid();
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u = SpreadsheetMLMain.uz(this, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
        a = u.p1;
        b = u.p2;
        c = u.p3;
        d = u.p4;
        e = u.p5;
        f = u.p6;
        g = u.p7;
        h = u.p8;
        i = u.p9;
        j = u.p10;
        k = u.p11;
        l = u.p12;
        m = u.p13;
        n = u.p14;
        o = u.p15;
        p = u.p16;
        q = u.p17;
        r = u.p18;
        s = u.p19;
        t = u.p20;
        let v = this.bg;
        let w = v._by;
        let x = w._customViews$i;
        let y = x._item(ST_Guid.e(a));
        if (y == null) {
            return;
        }
        let z = y.getPrintOptions(this.bk, true);
        if (z != null) {
            this.s.k(z);
        }
        let aa = y.getDisplayOptions(this.bk, true);
        if (aa == null) {
            return;
        }
        this.s.k(aa);
        aa.magnificationInCurrentView = b;
        if (c != 64) {
            aa._a2 = false;
        }
        aa._a8 = c;
        aa.showFormulasInCells = e;
        aa.showGridlines = f;
        aa.showRowAndColumnHeaders = g;
        aa.showOutlineSymbols = h;
        aa.showZeroValues = i;
        aa.visibility = XlsxUtilities.ae(p);
        aa.view = XlsxUtilities.ad(r);
        aa.showRulerInPageLayoutView = s;
        if (t != null) {
            let ab;
            let ac;
            if (((() => { let ad = ExcelUtils.bm(t, 2, CultureInfo.invariantCulture, ab, ac); ab = ad.p3; ac = ad.p4; return ad.ret; })()) == false) {
                return;
            }
            let ad = aa.unfrozenPaneSettings;
            ad.firstRowInTopPane = ac;
            ad.firstColumnInLeftPane = ab;
        }
    }
    static c7(a) {
    }
    static db(a) {
        a.da();
    }
    da() {
        let a = new ObjectModelWorksheetPartManager_DVInfo();
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        if (this.ab.k.e(this.d) == SpreadsheetML2009Main.bd) {
            let n = SpreadsheetML2009Main.cy(this, b, c, d, e, f, g, h, i, j, k, l, m);
            b = n.p1;
            c = n.p2;
            d = n.p3;
            e = n.p4;
            f = n.p5;
            g = n.p6;
            h = n.p7;
            i = n.p8;
            j = n.p9;
            k = n.p10;
            l = n.p11;
            m = n.p12;
        }
        else {
            let o = SpreadsheetMLMain.u5(this, a.e, b, c, d, e, f, g, h, i, j, k, l, m);
            a.e = o.p1;
            b = o.p2;
            c = o.p3;
            d = o.p4;
            e = o.p5;
            f = o.p6;
            g = o.p7;
            h = o.p8;
            i = o.p9;
            j = o.p10;
            k = o.p11;
            l = o.p12;
            m = o.p13;
        }
        let p;
        switch (b) {
            case 0:
                p = new AnyValueDataValidationRule();
                break;
            case 3:
                let q = new ListDataValidationRule();
                q.showDropdown = (g == false);
                p = q;
                break;
            case 7:
                p = new CustomDataValidationRule();
                break;
            case 4:
            case 2:
            case 6:
            case 5:
            case 1:
                switch (e) {
                    case 0:
                    case 1:
                        p = new TwoConstraintDataValidationRule((XlsxUtilities.s(e)), (XlsxUtilities.t(b)));
                        break;
                    case 2:
                    case 3:
                    case 6:
                    case 4:
                    case 7:
                    case 5:
                        p = new OneConstraintDataValidationRule((XlsxUtilities.s(e)), (XlsxUtilities.t(b)));
                        break;
                    default: return;
                }
                break;
            default: return;
        }
        k = ObjectModelWorksheetPartManager.b1(k);
        m = ObjectModelWorksheetPartManager.b1(m);
        p._p = f;
        p.errorStyle = XlsxUtilities.d(c);
        p.showInputMessage = h;
        p.showErrorMessageForInvalidValue = i;
        p.inputMessageTitle = l;
        p.inputMessageDescription = m;
        p.errorMessageTitle = j;
        p.errorMessageDescription = k;
        a.a = p;
        this.s.k(a);
    }
    static dd(a) {
        a.dc();
    }
    dc() {
        let a = this.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (a == null || a.e == null || a.a == null) {
            return;
        }
        let b = new WorksheetReferenceCollection(this.bk);
        b._add4(a.e, 1);
        this.bk._dataValidationRules$i._al(a.a, b);
        let c;
        if (b._t.count == 1 && a.e.indexOf(' ') < 0) {
            c = b._d;
        }
        else {
            c = this.bk._getCell1("A1", 1);
        }
        if (a.c != null) {
            ObjectModelWorksheetPartManager.c4(this, c, a.c, a.a._i, runOn(a.a, a.a._aq));
        }
        if (a.d != null) {
            ObjectModelWorksheetPartManager.c4(this, c, a.d, a.a._i, runOn(a.a, a.a._ar));
        }
    }
    static de(a) {
        let b;
        let c;
        let d;
        let e;
        if (a.ab.k.e(a.d) == SpreadsheetML2009Main.be) {
            let f = SpreadsheetML2009Main.cz(a, b, c, d, e);
            b = f.p1;
            c = f.p2;
            d = f.p3;
            e = f.p4;
        }
        else {
            let g = SpreadsheetMLMain.u6(a, b, c, d, e);
            b = g.p1;
            c = g.p2;
            d = g.p3;
            e = g.p4;
        }
    }
    static df(a) {
        let b;
        let c = SpreadsheetMLMain.vf(a, b);
        b = c.p1;
    }
    static dh(a) {
        a.dg();
    }
    dg() {
        let a;
        let b = SpreadsheetMLMain.vg(this, a);
        a = b.p1;
        let c = this.bg;
        let d = c._b7;
        let e = PackageUtilities.ak(c._g(a)).originalString;
        let f;
        if (((() => { let g = d._a6.tryGetValue(e, f); f = g.p1; return g.ret; })())) {
            for (let g of fromEnum(f)) {
                d._bp(this.bk, g);
            }
        }
        else {
        }
    }
    static dk(a) {
        let b;
        let c = SpreadsheetMLMain.vp(a, b);
        b = c.p1;
    }
    static dl(a) {
    }
    static dm(a) {
        let b = a;
        let c = a.s.a(WorksheetRow.$);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q = SpreadsheetMLMain.vx(a, d, e, f, g, h, i, j, k, l, m, n, o, p);
        d = q.p1;
        e = q.p2;
        f = q.p3;
        g = q.p4;
        h = q.p5;
        i = q.p6;
        j = q.p7;
        k = q.p8;
        l = q.p9;
        m = q.p10;
        n = q.p11;
        o = q.p12;
        p = q.p13;
        let r = c.worksheet;
        let s = ObjectModelWorksheetPartManager.bh(a);
        let t = s._by;
        let u = null;
        let v = null;
        if (k != null) {
            let w;
            let x;
            if (((() => { let y = ExcelUtils.bm(k, 2, CultureInfo.invariantCulture, w, x); w = y.p3; x = y.p4; return y.ret; })())) {
                u = r._rows$i.item(x)._cells$i.item(w);
            }
            else {
            }
        }
        if (l != null) {
            let y;
            let z;
            if (((() => { let aa = ExcelUtils.bm(l, 2, CultureInfo.invariantCulture, y, z); y = aa.p3; z = aa.p4; return aa.ret; })())) {
                v = r._rows$i.item(z)._cells$i.item(y);
            }
            else {
            }
        }
        let aa = f == null ? null : ExcelUtils.ai(f, r, CultureInfo.invariantCulture);
        let ab = WorkbookLoadManagerExcel2007._bs(p);
        p = ab.p0;
        let ac;
        switch (d) {
            case 3:
                if (p != null) {
                    let ad;
                    ac = ((() => { let ae = FormulaParser.e(p, 1, 2, t.currentFormat, CultureInfo.invariantCulture, s._b7._bi, c.index, b.bu, ad); ad = ae.p8; return ae.ret; })());
                    if (ad != null) {
                        throw ad;
                    }
                    ac = Formula._k(p, 1, 0, t.currentFormat, CultureInfo.invariantCulture, s._b7._bi);
                    ac = ac._x(c.index, b.bu, t.currentFormat);
                    if (m) {
                        ac._an = m;
                    }
                    r._h2(ac, r._getRegion1(f, 1));
                    ac._bp(c, b.bu);
                    if (nullableNotEquals(n, null)) {
                        b.br.addItem(n.value, c._ar(b.bu));
                    }
                    else {
                    }
                }
                else {
                    if (nullableNotEquals(n, null) && ((() => { let ae = b.br.tryGetValue(n.value, ac); ac = ae.p1; return ae.ret; })())) {
                        ac._bq(ac._ab, ac._bb, c, b.bu);
                    }
                    else {
                    }
                }
                break;
            case 0:
                if (p != null) {
                    let ae = 0;
                    let af = FormulaParser.l(s._by, r, c, b.bu, CultureInfo.invariantCulture, 1, ae);
                    if (s._b7._au && ((() => { let ag = b.bq.tryGetValue(p, ac); ac = ag.p1; return ag.ret; })())) {
                        ac = ac._g();
                    }
                    else {
                        ac = Formula._o(p, ae, af, s._b7._bi);
                        b.bq.item(p, ac);
                    }
                    if (m) {
                        ac._an = m;
                    }
                    ac._bp(c, b.bu);
                }
                break;
            case 1:
                if (p != null) {
                    ac = Formula._k(p, 1, 1, s._by.currentFormat, CultureInfo.invariantCulture, s._b7._bi);
                    if (m) {
                        ac._an = m;
                    }
                    if (aa != null) {
                        ac._applyTo3(aa);
                    }
                    else {
                    }
                }
                break;
            case 2:
                if (aa != null) {
                    aa = r._cx(aa.firstRow - 1, aa.firstColumn - 1, aa.lastRow, aa.lastColumn);
                    let ag = null, ah = null;
                    if (g) {
                        ag = u;
                        ah = v;
                    }
                    else if (h) {
                        ag = u;
                    }
                    else {
                        ah = u;
                    }
                    r._dataTables$i._add1(aa, ah, ag);
                }
                else {
                }
                break;
        }
    }
    static dn(a) {
        if (SparklinesDeserializer.f(a)) {
            return;
        }
        let b = a;
        let c = b != null ? b.s.a(ConditionalFormatInfo.$) : null;
        if (c != null) {
            ObjectModelWorksheetPartManager.dp(a);
            return;
        }
        let d = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (d == null) {
            return;
        }
        let e;
        let f = Excel2006Main.as(a, e);
        e = f.p1;
        if (d.b) {
            d.c = e;
        }
        else {
            d.d = e;
        }
    }
    static dt(a) {
        let b = a.s.a(ObjectModelTablePartManager_FilterColumnElementContext.$);
        let c = a.bk;
        if (b == null || c == null) {
            return;
        }
        else if (b.b == null) {
            return;
        }
        let d = new WorksheetColumnFilter(1, c, b.d);
        d._g(b.b);
        b.b._j(d);
        c.filterSettings._a3(d);
    }
    static dw(a) {
        let b = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (b == null) {
            return;
        }
        let c = SpreadsheetMLMain.wb(a, b.c);
        b.c = c.p1;
    }
    static dv(a) {
        let b = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (b == null) {
            return;
        }
        b.b = true;
    }
    static dy(a) {
        let b = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (b == null) {
            return;
        }
        let c = SpreadsheetMLMain.wc(a, b.d);
        b.d = c.p1;
    }
    static dx(a) {
        let b = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (b == null) {
            return;
        }
        b.b = false;
    }
    static d1(a) {
        let b = a.s.a(PrintOptionsBase.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.wf(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        b.alignHeadersAndFootersWithMargins = f;
        b.scaleHeadersAndFootersWithDocument = e;
    }
    static d3(a) {
        a.d2();
    }
    d2() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f = SpreadsheetMLMain.wh(this, a, b, c, d, e);
        a = f.p1;
        b = f.p2;
        c = f.p3;
        d = f.p4;
        e = f.p5;
        let g = this.bk._getRegion2(a, 1, null);
        if (e == null) {
            let h = g._k._c6(g._v);
            if (WorksheetCellBlock.s(h)) {
                e = h.toString();
            }
        }
        let i = null;
        if (b != null) {
            let j = this.d._au(b);
            let k = typeCast(Uri.$, j);
            if (k != null) {
                if (k.isAbsoluteUri && k.scheme.toLowerCase() != "file") {
                    try {
                        i = Uri.escapeUriString(k.toString());
                    }
                    catch (l) {
                        i = Uri.escapeUriString(k.originalString);
                    }
                }
                else if (k.isAbsoluteUri) {
                    i = k.localPath;
                }
                else {
                    try {
                        i = k.toString();
                    }
                    catch (m) {
                        i = k.originalString;
                    }
                }
            }
            else if (typeof j === 'string') {
                i = j;
            }
            else {
            }
        }
        let n = WorkbookLoadManager._v(this.bk.workbook, i, c);
        let o = new WorksheetHyperlink(g, n, e, d);
        o._t = c != null && typeof n === 'string' && c == n;
        this.bk._hyperlinks$i.add(o);
    }
    static d4(a) {
    }
    static d9(a) {
        a.s.k(new FormattedStringElement(0));
    }
    static ea(a) {
        let b = a.s.a(WorksheetRow.$);
        let c = a.s.a(FormattedStringElement.$);
        if (b == null || c == null) {
            return;
        }
        let d = a;
        if (c._u) {
            b.setCellValue(d.bu, c);
        }
        else {
            b.setCellValue(d.bu, c._y);
        }
    }
    static ec(a) {
        a.eb();
    }
    eb() {
        let a;
        let b = SpreadsheetMLMain.wp(this, a);
        a = b.p1;
        let c = this.bg;
        let d = c._d.getRelationship(a);
        if (d == null || d.targetMode != 0) {
            return;
        }
        let e = typeCast(List$1.$.specialize(LegacyShapeData.$), c._as(d));
        if (e == null) {
            return;
        }
        let f = PackageUtilities.ak(d).originalString;
        if (c._b7._a4.removeItem(f) == false) {
        }
        let g = null;
        for (let h of fromEnum(c._d.getRelationships())) {
            if (h.relationshipType != ObjectModelCommentsPartManager.a8.o(c._z)) {
                continue;
            }
            g = typeCast(List$1.$.specialize(WorksheetCellCommentData.$), c._as(h));
            break;
        }
        if (g == null) {
            g = new List$1(WorksheetCellCommentData.$, 0);
        }
        let i = new Dictionary$2(WorksheetCellAddress.$, WorksheetCellCommentData.$, 0);
        for (let j of fromEnum(g)) {
            i.addItem(new WorksheetCellAddress(1, j.f, j.d), j);
        }
        for (let k of fromEnum(e)) {
            if (nullableNotEquals(k.ah, null) && nullableNotEquals(k.t, null)) {
                let l = this.bk._rows$i.item(k.ah.value);
                let m = k.t.value;
                let n = new WorksheetCellAddress(1, l.index, m);
                let o;
                if (((() => { let p = i.tryGetValue(n, o); o = p.p1; return p.ret; })())) {
                    let p = o.b;
                    this.b4(p, k);
                    l._d2(m, p);
                    continue;
                }
            }
            let q = ObjectModelWorksheetPartManager.bx(k);
            if (nullableNotEquals(q, null)) {
                let r;
                let s = ((() => { let t = this.bk._da(q.value, r); r = t.p1; return t.ret; })());
                let t = typeCast(UnknownShape.$, s);
                if (t == null) {
                    if (s == null) {
                        t = new UnknownShape(1);
                        r = this.bk._shapes$i;
                    }
                    else {
                        t = new UnknownShape(2, s);
                        r.remove_1(s);
                    }
                }
                t._eg = k;
                this.b4(t, k);
                c._b7._a5.item(t._cn, t);
                r._add3(t);
            }
        }
    }
    static ee(a) {
        a.ed();
    }
    ed() {
        let a;
        let b = SpreadsheetMLMain.wq(this, a);
        a = b.p1;
        let c = this.bg;
        let d = c._d.getRelationship(a);
        if (d == null || d.targetMode != 0) {
            return;
        }
        let e = typeCast(List$1.$.specialize(LegacyShapeData.$), c._as(d));
        if (e == null) {
            return;
        }
        let f = PackageUtilities.ak(d).originalString;
        let g;
        if (((() => { let h = c._b7._a4.tryGetValue(f, g); g = h.p1; return h.ret; })())) {
            this.bk._g3 = new LegacyDrawingHFInfo(g, e);
            c._b7._a4.removeItem(f);
        }
        else {
        }
    }
    static eg(a) {
        a.ef();
    }
    ef() {
        let a;
        let b = SpreadsheetMLMain.wr(this, a);
        a = b.p1;
        let c = ExcelUtils.ai(a, this.bk, CultureInfo.invariantCulture);
        if (c != null) {
            this.bk._mergedCellsRegions$i._add1(c.firstRow, c.firstColumn, c.lastRow, c.lastColumn);
        }
        else {
        }
    }
    static eh(a) {
        let b;
        let c = SpreadsheetMLMain.ws(a, b);
        b = c.p1;
    }
    static el(a) {
        let b = a.s.a(PrintOptionsBase.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.ww(a, c);
        c = d.p1;
        b.footer = c;
    }
    static em(a) {
        let b = a.s.a(PrintOptionsBase.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.wx(a, c);
        c = d.p1;
        b.header = c;
    }
    static eo(a) {
        a.en();
    }
    en() {
        let a;
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.w2(this, a, b, c, d);
        a = e.p1;
        b = e.p2;
        c = e.p3;
        d = e.p4;
        this.bk._em = b;
        this.bk.displayOptions._showExpansionIndicatorBelowGroupedRows$i = XlsxUtilities.a6(b);
        this.bk.displayOptions._showExpansionIndicatorToRightOfGroupedColumns$i = XlsxUtilities.a6(c);
        this.bk.displayOptions.showOutlineSymbols = d;
    }
    static ep(a) {
        let b = a.s.a(PrintOptionsBase.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i = SpreadsheetMLMain.w3(a, c, d, e, f, g, h);
        c = i.p1;
        d = i.p2;
        e = i.p3;
        f = i.p4;
        g = i.p5;
        h = i.p6;
        b.leftMargin = c;
        b.rightMargin = d;
        b.topMargin = e;
        b.bottomMargin = f;
        b.headerMargin = g;
        b.footerMargin = h;
    }
    static eq(a) {
        let b = a.s.a(PrintOptionsBase.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v = SpreadsheetMLMain.w4(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        let w = c;
        if (EnumUtil.isDefined(PaperSize_$type, enumGetBox(PaperSize_$type, w)) == false) {
        }
        else {
            b.paperSize = w;
        }
        if (typeCast(PrintOptions.$, b) !== null) {
            let x = b;
            x._dq(f, false);
            x.maxPagesHorizontally = h;
            x.maxPagesVertically = i;
            x.pageOrder = XlsxUtilities.o(j);
        }
        b.startPageNumber = g;
        b.orientation = XlsxUtilities.n(k);
        b.printInBlackAndWhite = m;
        b.draftQuality = n;
        b.printNotes = XlsxUtilities.r(o);
        b.pageNumbering = p ? 1 : 0;
        b.printErrors = XlsxUtilities.q(q);
        b.resolution = Math.max(0, Math.min(r, 65535));
        b.verticalResolution = Math.max(0, Math.min(s, 65535));
        b.numberOfCopies = t;
        if (!stringIsNullOrEmpty(u)) {
            let y = typeCast(BinaryData.$, a.d._au(u));
            b._c = y;
        }
    }
    static es(a) {
        a.er();
    }
    er() {
        let a;
        let b;
        let c = SpreadsheetMLMain.w5(this, a, b);
        a = c.p1;
        b = c.p2;
        if (b) {
            this.bk.printOptions.scalingType = 1;
        }
        else {
            this.bk.printOptions.scalingType = 0;
        }
    }
    static et(a) {
        let b = a.s.a(DisplayOptions.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.w6(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        let i = -1;
        let j = -1;
        if (e != null) {
            if (((() => { let k = ExcelUtils.bm(e, 2, CultureInfo.invariantCulture, i, j); i = k.p3; j = k.p4; return k.ret; })()) == false) {
            }
        }
        b._z = XlsxUtilities.p(f);
        let t1 = g;
        L0: while (true) {
            switch (t1) {
                case 0:
                    {
                        b.panesAreFrozen = false;
                        let k = b.unfrozenPaneSettings;
                        if (i > -1 && j > -1) {
                            k.firstColumnInRightPane = i;
                            k.firstRowInBottomPane = j;
                        }
                        k.leftPaneWidth = truncate(c);
                        k.topPaneHeight = truncate(d);
                    }
                    break;
                case 2:
                    b.frozenPaneSettings._z = true;
                    t1 = 1;
                    continue L0;
                case 1:
                    {
                        b.panesAreFrozen = true;
                        let l = b.frozenPaneSettings;
                        if (i > -1 && j > -1) {
                            l.firstColumnInRightPane = i;
                            l.firstRowInBottomPane = j;
                        }
                        l.frozenColumns = truncate(c);
                        l.frozenRows = truncate(d);
                    }
                    break;
                default:
                    t1 = 1;
                    continue L0;
            }
            break;
        }
    }
    static ew(a) {
        a.ev();
    }
    ev() {
        let a;
        let b = SpreadsheetMLMain.w8(this, a);
        a = b.p1;
        let c = this.bg;
        let d = typeCast(ImageData.$, c._au(a));
        if (d != null) {
            let e = XlsxUtilities.u(d);
            this.bk._je = ExcelUtils.g4(e);
            this.bk._dh = e.d;
        }
        else {
        }
    }
    static ex(a) {
        let b = a.s.a(PrintOptions.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.xb(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        b.centerHorizontally = c;
        b.centerVertically = d;
        b.printRowAndColumnHeaders = e;
        b.printGridlines = f && g;
    }
    static ez(a) {
        a.ey();
    }
    ey() {
        let a;
        let b;
        let c;
        let d = null;
        if (SpreadsheetMLMain.b3(this)) {
            let e, f, g;
            let h;
            let i = SpreadsheetMLMain.xd(this, a, b, c, e, f, g, h);
            a = i.p1;
            b = i.p2;
            c = i.p3;
            e = i.p4;
            f = i.p5;
            g = i.p6;
            h = i.p7;
            if (f != null && g != null && nullableNotEquals(h, null)) {
                d = ProtectionValidationInfo.b(e, Convert.fromBase64String(f), Convert.fromBase64String(g), h.value);
            }
        }
        else {
            let j;
            let k = SpreadsheetMLMain.xc(this, a, b, c, j);
            a = k.p1;
            b = k.p2;
            c = k.p3;
            j = k.p4;
            if (j.hasValue) {
                d = ProtectionValidationInfo.c(j.value.e());
            }
        }
        let l = new WorksheetProtectedRange(c);
        let m = WorksheetReferenceCollection._r(this.bk, b, 1, this.bk._y);
        for (let n of fromEnum(m)) {
            l.ranges.add(n);
        }
        if (!stringIsNullOrEmpty(a)) {
            l._p(a);
        }
        l._c.b = d;
        this.bk.protection._allowedEditRanges$i.add(l);
    }
    static e0(a) {
    }
    static e4(a) {
        a.e3();
    }
    e3() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m = SpreadsheetMLMain.xl(this, a, b, c, d, e, f, g, h, i, j, k, l, true);
        a = m.p1;
        b = m.p2;
        c = m.p3;
        d = m.p4;
        e = m.p5;
        f = m.p6;
        g = m.p7;
        h = m.p8;
        i = m.p9;
        j = m.p10;
        k = m.p11;
        l = m.p12;
        let n = this.bg;
        let o = null;
        let p = this.bk._rows$i;
        if (nullableNotEquals(a, null)) {
            o = p.item((a.value - 1));
        }
        else {
            let q = false;
            while (p._aj(++p._u) != null) {
                if (q == false) {
                    q = true;
                }
            }
            o = p.item(p._u);
        }
        if (d) {
            if (c < n._b7._be.count) {
                o.cellFormat.setFormatting(n._b7._be._inner[c].g);
            }
            else {
            }
        }
        if (g && this.bv < 0) {
            this.bv = o.index;
        }
        if (nullableNotEquals(e, null)) {
            let r = truncate(MathUtilities.f(e.value * 20));
            if (g) {
                o.height = r;
            }
            else {
                o._cm = r;
            }
        }
        else if (this.bk._d4) {
            o._bz = g;
            if (this.bv >= 0) {
                o._cm = this.bk._gp;
            }
        }
        o._b1 = k;
        o._b4 = j;
        o._l = f;
        o.outlineLevel = h;
        this.s.k(o);
    }
    static e2(a) {
        let b = a.s.a(PrintOptions.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.xk(a, c, d);
        c = e.p1;
        d = e.p2;
        a.s.k(b._horizontalPageBreaks$i);
    }
    static e5(a) {
        let b = a.s.a(DisplayOptions.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.xp(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = b._af;
        let i = b._ad;
        let j = i.workbook;
        let k = new WorksheetPaneSelection();
        k.a = XlsxUtilities.p(c);
        k.f = e;
        let l = Workbook._fa;
        let m;
        let n;
        if (d != null) {
            let o = ExcelUtils.bm(d, j.currentFormat, l, n, m);
            n = o.p3;
            m = o.p4;
        }
        else {
            m = n = 0;
            d = "A1";
        }
        k.b = new WorksheetCellAddress(1, m, n);
        let p;
        let q;
        if (f != null && f.count != 0) {
            for (let r of fromEnum(f)) {
                let s = ExcelUtils.fv(r, j.currentFormat, 1, l, null, -1, m, n, p, q);
                m = s.p6;
                n = s.p7;
                p = s.p8;
                q = s.p9;
                k.d.add(new WorksheetRegionAddress(1, m, p, n, q));
            }
        }
        else {
            k.d.add(new WorksheetRegionAddress(1, m, m, n, n));
        }
        h.b.add(k);
    }
    static e6(a) {
        let b;
        let c = SpreadsheetMLMain.xr(a, b);
        b = c.p1;
    }
    static e7(a) {
        a.ab.an();
    }
    static e9(a) {
        a.e8();
    }
    e8() {
        if (this.bk._d4) {
            if (this.bv >= 0) {
                for (let a of fromEnum(this.bk._rows$i._m(0, this.bv))) {
                    if (!a._bz) {
                        a._cm = this.bk._gp;
                    }
                }
            }
        }
    }
    static fb(a) {
        a.fa();
    }
    fa() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.xw(this, a, b, c, d, e, f, g, h, i);
        a = j.p1;
        b = j.p2;
        c = j.p3;
        d = j.p4;
        e = j.p5;
        f = j.p6;
        g = j.p7;
        h = j.p8;
        i = j.p9;
        if (nullableNotEquals(c, null)) {
            this.bk._d7 = true;
            this.bk._ek = true;
            this.bk.setDefaultColumnWidth(c.value, 0);
        }
        else if (b > 0) {
            this.bk._iq(b, 2, true, false);
        }
        if (d && a > 0) {
            this.bk.defaultRowHeight = truncate((a * 20));
        }
        this.bk._ds = g;
        this.bk._dt = f;
        this.bk._dv = e;
    }
    static fd(a) {
        a.fc();
    }
    fc() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = SpreadsheetMLMain.xz(this, a, b, c, d, e, f, g, h, i);
        a = j.p1;
        b = j.p2;
        c = j.p3;
        d = j.p4;
        e = j.p5;
        f = j.p6;
        g = j.p7;
        h = j.p8;
        i = j.p9;
        this.bk._ak = g;
    }
    static ff(a) {
        a.fe();
    }
    fe() {
        let a = null;
        let b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;
        let q;
        if (SpreadsheetMLMain.b3(this)) {
            let r, s, t;
            let u;
            let v = SpreadsheetMLMain.x1(this, r, s, t, u, q, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
            r = v.p1;
            s = v.p2;
            t = v.p3;
            u = v.p4;
            q = v.p5;
            b = v.p6;
            c = v.p7;
            d = v.p8;
            e = v.p9;
            f = v.p10;
            g = v.p11;
            h = v.p12;
            i = v.p13;
            j = v.p14;
            k = v.p15;
            l = v.p16;
            m = v.p17;
            n = v.p18;
            o = v.p19;
            p = v.p20;
            if (s != null && t != null && nullableNotEquals(u, null)) {
                a = ProtectionValidationInfo.b(r, Convert.fromBase64String(s), Convert.fromBase64String(t), u.value);
            }
        }
        else {
            let w;
            let x = SpreadsheetMLMain.x0(this, w, q, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
            w = x.p1;
            q = x.p2;
            b = x.p3;
            c = x.p4;
            d = x.p5;
            e = x.p6;
            f = x.p7;
            g = x.p8;
            h = x.p9;
            i = x.p10;
            j = x.p11;
            k = x.p12;
            l = x.p13;
            m = x.p14;
            n = x.p15;
            o = x.p16;
            p = x.p17;
            if (w.hasValue) {
                a = ProtectionValidationInfo.c(w.value.e());
            }
        }
        let y = this.bk.protection;
        y.allowEditObjects = b == false;
        y.allowEditScenarios = c == false;
        y.allowFormattingCells = d == false;
        y.allowFormattingColumns = e == false;
        y.allowFormattingRows = f == false;
        y.allowInsertingColumns = g == false;
        y.allowInsertingRows = h == false;
        y.allowInsertingHyperlinks = i == false;
        y.allowDeletingColumns = j == false;
        y.allowDeletingRows = k == false;
        y.allowSorting = m == false;
        y.allowFiltering = n == false;
        y.allowUsingPivotTables = o == false;
        y._ag(l == false, p == false);
        y._c.b = a;
        y._c.j(q || b || c);
    }
    static fh(a) {
        a.fg();
    }
    fg() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t = SpreadsheetMLMain.x3(this, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s);
        a = t.p1;
        b = t.p2;
        c = t.p3;
        d = t.p4;
        e = t.p5;
        f = t.p6;
        g = t.p7;
        h = t.p8;
        i = t.p9;
        j = t.p10;
        k = t.p11;
        l = t.p12;
        m = t.p13;
        n = t.p14;
        o = t.p15;
        p = t.p16;
        q = t.p17;
        r = t.p18;
        s = t.p19;
        let u = this.bk.displayOptions;
        this.s.k(u);
        if (this.bk._r) {
            return;
        }
        this.bk._r = true;
        if (o != 64) {
            u._a2 = false;
        }
        u._a8 = o;
        u.orderColumnsRightToLeft = g;
        u.showFormulasInCells = c;
        u.showGridlines = d;
        u.showOutlineSymbols = j;
        u.showRowAndColumnHeaders = e;
        u.showRulerInPageLayoutView = i;
        u.showWhitespaceInPageLayoutView = l;
        u.showZeroValues = f;
        this.bk._w = h;
        if (n != null) {
            let v;
            let w;
            if (((() => { let x = ExcelUtils.bm(n, 2, CultureInfo.invariantCulture, v, w); v = x.p3; w = x.p4; return x.ret; })()) == false) {
            }
            u.unfrozenPaneSettings.firstColumnInLeftPane = v;
            u.unfrozenPaneSettings.firstRowInTopPane = w;
        }
        u.view = XlsxUtilities.ad(m);
        let x = q;
        let y = ExcelUtils.fj(x);
        x = y.p0;
        u.magnificationInNormalView = x;
        let z = s;
        let aa = ExcelUtils.fj(z);
        z = aa.p0;
        u.magnificationInPageLayoutView = z;
        let ab = r;
        let ac = ExcelUtils.fj(ab);
        ab = ac.p0;
        u.magnificationInPageBreakView = ab;
        u._b3 = p;
    }
    static fi(a) {
    }
    static fk(a) {
        a.fj();
    }
    fj() {
        let a;
        let b = SpreadsheetML2009Main.c7(this, a);
        a = b.p1;
        let c = typeCast(BinaryData.$, this.bg._au(a));
        if (c != null) {
            this.bk._g7(c);
        }
    }
    static fl(a) {
    }
    static fm(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.bk;
        let d = c.workbook;
        let e = b.bm ? false : c.sortSettings.sortType == 1;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m = SpreadsheetMLMain.x6(a, f, g, h, i, j, k, l);
        f = m.p1;
        g = m.p2;
        h = m.p3;
        i = m.p4;
        j = m.p5;
        k = m.p6;
        l = m.p7;
        if (stringIsNullOrEmpty(f)) {
            return;
        }
        let n = ObjectModelWorksheetPartManager.bh(a);
        let o;
        let p;
        let q;
        let r;
        let s = ExcelUtils.fv(f, n._by.currentFormat, 1, CultureInfo.invariantCulture, null, -1, o, p, q, r);
        o = s.p6;
        p = s.p7;
        q = s.p8;
        r = s.p9;
        if (e) {
        }
        else {
        }
        let t = g ? 1 : 0;
        let u;
        switch (h) {
            case 1:
                u = FillSortCondition._k(n._b7, j, t);
                break;
            case 2:
                u = FontColorSortCondition._i(n._b7, j, t);
                break;
            case 3:
                u = new IconSortCondition(t == 0, k, l);
                break;
            case 0:
                if (i == null) {
                    u = new OrderedSortCondition(t);
                }
                else {
                    u = new CustomListSortCondition(t, ...i.split(','));
                }
                break;
            default: return;
        }
        if (u == null) {
            return;
        }
        if (b.bm) {
            if (c.filterSettings.region == null) {
            }
            else {
                c.filterSettings.sortSettings._sortConditions$i._addItem$i(new RelativeIndex(p - c.filterSettings.region._v), u);
            }
        }
        else {
            if (c.sortSettings.region == null) {
            }
            else {
                c.sortSettings._sortConditions$i._addItem$i(new RelativeIndex(e ? o - c.sortSettings.region.firstRow : p - c.sortSettings.region._v), u);
            }
        }
    }
    static fn(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.x7(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        if (stringIsNullOrEmpty(c)) {
            return;
        }
        let h = b.bk;
        let i = h.workbook;
        if (b.bm) {
            h.filterSettings.sortSettings.caseSensitive = e;
            h.filterSettings.sortSettings._i = f;
        }
        else {
            h.sortSettings.sortType = d ? 1 : 0;
            h.sortSettings.caseSensitive = e;
            h.sortSettings._i = f;
            let j;
            let k;
            let l;
            let m;
            let n = ExcelUtils.fv(c, i.currentFormat, 1, CultureInfo.invariantCulture, null, -1, j, k, l, m);
            j = n.p6;
            k = n.p7;
            l = n.p8;
            m = n.p9;
            let o = new WorksheetRegionAddress(1, j, l, k, m);
            h.sortSettings._setRegion1(o._ah(false, false, i.currentFormat, 1), 1);
        }
    }
    static fo(a) {
        if (SparklinesDeserializer.g(a)) {
            return;
        }
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b != null ? b.s.a(ConditionalFormatInfo.$) : null;
        if (c != null) {
            let d = c.d;
            let e = null;
            let f = Excel2006Main.at(a, e);
            e = f.p1;
            let g = XmlNamespaceDefinitionBase.e(String_$type, e, (h) => h);
            ConditionalFormatInfo.n(c, g);
            return;
        }
        let h = a.s.a(ObjectModelWorksheetPartManager_DVInfo.$);
        if (h == null) {
            return;
        }
        let i = Excel2006Main.at(a, h.e);
        h.e = i.p1;
    }
    static fq(a) {
        a.fp();
    }
    fp() {
        this.bk.displayOptions.tabColorInfo = ObjectModelCommonPartHelpers.c(this, SpreadsheetMLMain.ye);
    }
    static fs(a) {
        a.fr();
    }
    fr() {
        let a;
        let b = SpreadsheetMLMain.yi(this, a);
        a = b.p1;
        let c = this.bg;
        let d = typeCast(WorksheetTable.$, c._au(a));
        if (d == null) {
            return;
        }
        this.bk._tables$i._t(d);
    }
    static ft(a) {
        let b;
        let c = SpreadsheetMLMain.yj(a, b);
        b = c.p1;
    }
    static fu(a) {
        let b = a.s.a(WorksheetRow.$);
        let c = a.s.a(Nullable$1.$.specialize(ST_CellType_$type));
        if (b == null || nullableEquals(c, null)) {
            return;
        }
        let d = a;
        let e = ObjectModelCommonPartHelpers.d(a, d.bu);
        let f = b._a1(d.bu);
        let g = f.aa(b, d.bu);
        if (typeCast(Formula.$, g) !== null || typeCast(WorksheetDataTable.$, g) !== null) {
            b._d0(d.bu, CalcUtilities.c(e));
        }
        else {
            let h;
            let i = f.ao(b, d.bu, e, h, false);
            h = i.p3;
            f = h || f;
        }
    }
    static fw(a) {
        a.fv();
    }
    fv() {
        this.bk._em = true;
        this.s.k(this.bk.printOptions);
    }
    static fy(a) {
        let b = typeCast(ObjectModelWorksheetPartManager.$, a);
        let c = b.be;
        if (c != null) {
            c.m();
            b.be = null;
        }
        a.fx();
    }
    fx() {
        this.bk._shapes$i._ao();
    }
    static by(a) {
        if (a == null) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        if (stringStartsWith(a, "_x0000_s") == false) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        let b = a.substr(8);
        let c;
        if (((() => { let d = tryParseInt32_1(b, c); c = d.p1; return d.ret; })()) == false) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, intSToU(c));
    }
    fz(a, b) {
        this.bs = new List$1(UnknownShape.$, 0);
        this.bt = new List$1(WorksheetShape.$, 0);
        for (let c of fromEnum(b.j)) {
            this.bt.add(c);
        }
        ObjectModelWorksheetPartManager.f0(a._shapes$i, this.bs, this.bt);
    }
    static f0(a, b, c) {
        for (let d of fromEnum(a)) {
            let e = typeCast(WorksheetShapeGroupBase.$, d);
            if (e != null) {
                ObjectModelWorksheetPartManager.f0(e._shapes$i, b, c);
                continue;
            }
            let f = typeCast(UnknownShape.$, d);
            if (f != null && f._eg != null) {
                c.add(f);
                if (f._ef != null && f._ef.d == "application/vnd.ms-office.activeX+xml") {
                    b.add(f);
                }
            }
        }
    }
    f1(a) {
        let b = this.bk.filterSettings.region;
        if (b == null || (this.bk.filterSettings.sortSettings._sortConditions$i.count == 0 && this.bk.filterSettings._at == 0)) {
            return;
        }
        SpreadsheetMLMain.y9(this, b._toString2(1, false, true, true));
        for (let c = 0; c < b._ad; c++) {
            let d = this.bk.filterSettings.getFilter(c);
            if (d == null) {
                continue;
            }
            SpreadsheetMLMain.abp(this, intSToU(c));
            ObjectModelTablePartManager.b5(this, this.bg, a, d);
            this.ad.k();
        }
        if (this.bk.filterSettings.sortSettings._sortConditions$i.count > 0) {
            this.g5(a, b, this.bk.filterSettings.sortSettings, true);
        }
        this.ad.k();
    }
    f2(a) {
        SpreadsheetMLMain.zg(this, intSToU(a._k), Nullable$1.toNullable(Number_$type, a._q), Nullable$1.toNullable(Number_$type, a._o), a._g, a._d);
        this.ad.k();
    }
    f3(a, b, c, d, e) {
        let f = e.d;
        let g = a._a3(b, e);
        let h;
        let i;
        if (f != null && f.l(e.h, e.f)) {
            h = true;
            i = a._a3(b, e, true);
            if (!this.bn && (i == null || getInstanceType(i) == ErrorValue.$)) {
                this.bn = true;
            }
        }
        else {
            h = false;
            i = g;
        }
        let j;
        let k;
        let l = WorkbookSaveManagerExcel2007._cy(i, j, k);
        j = l.p1;
        k = l.p2;
        SpreadsheetMLMain.zj(this, this.b3(e.r) + d, a._a6(e.j), j);
        if (h) {
            this.gg(a, b, e.r, g);
        }
        if (k != null) {
            let m = false;
            if (j == 5 && k.length > 0 && (/\s/i.test(k.charAt(0)) || /\s/i.test(k.charAt(k.length - 1)))) {
                m = true;
            }
            SpreadsheetMLMain.aei(this, k, m);
            this.ad.k();
            if (j == 4) {
                let n = typeCast(StringElementIndex.$, i);
                if (n != null) {
                    n.d();
                }
            }
        }
        this.ad.k();
    }
    f4(a) {
        if (a._cr == false) {
            return;
        }
        SpreadsheetMLMain.zw(this, intSToU(a._verticalPageBreaks$i.count), intSToU(a._verticalPageBreaks$i._k()));
        ExcelUtils.fm(VerticalPageBreak.$, a._verticalPageBreaks$i, runOn(this, this.f2));
        this.ad.k();
    }
    f5(a, b) {
        let c = 0;
        if (b.v >= 0) {
            c = b.v / 256;
        }
        else {
            c = this.bk.defaultColumnWidth / 256;
        }
        SpreadsheetMLMain.zx(this, intSToU((b.q + 1)), intSToU((b.r + 1)), Nullable$1.toNullable(Number_$type, c), b.b._cd ? 0 : a._a6(b.b), b.i, void 0, b.v >= 0 && (b.v != this.bk.defaultColumnWidth || b.j), void 0, b.m, a._ad(b));
        this.ad.k();
    }
    f6(a) {
        let b = this.bk._ff;
        if (b.count == 1 && b._inner[0].k) {
            return;
        }
        SpreadsheetMLMain.z2(this);
        b.q((c) => this.f5(a, c));
        this.ad.k();
    }
    f7(a) {
        if (a._cc != null) {
            let b = null;
            if (((() => { let c = a._cc.tryGetValue(this.bk, b); b = c.p1; return c.ret; })())) {
                b.x(this, a, this.ad);
            }
        }
    }
    a6(a) {
        return WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this.bg._l(a._ef.d, a._ef.e, a._ef), (b) => {
            let c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), b).d;
            SpreadsheetMLMain.z8(this, a._cn, c, a._eg.at);
            this.ad.k();
        });
    }
    a7() {
        let a = this.bg;
        if (this.bs.count == 0) {
            return null;
        }
        SpreadsheetMLMain.aaa(this);
        return WorkItemExtensions.a(Async.d(UnknownShape.$, this.bs, runOn(this, this.a6)), () => this.ad.k());
    }
    f8(a, b, c, d) {
        let e;
        if (c._t.count == 1) {
            let f = c._d;
            if (WorksheetCell.l_op_Equality(f, null) || f.worksheet == null) {
                e = a._b.cellReferenceMode == 0 ? "R1C1" : "A1";
            }
            else {
                e = f._toString1(f.worksheet._c, false);
            }
        }
        else {
            e = a._b.cellReferenceMode == 0 ? "R1C1" : "A1";
        }
        let g = b(e);
        if (g == null) {
            return;
        }
        d(this, a._ct(g));
        this.ad.k();
    }
    f9(a) {
        let b = a.getDisplayOptions(this.bk, false);
        if (b == null) {
            return;
        }
        let c = a.getHiddenRows(this.bk, false);
        let d = a.getHiddenColumns(this.bk, false);
        let e = CellAddress.u(b.unfrozenPaneSettings.firstRowInTopPane, b.unfrozenPaneSettings.firstColumnInLeftPane);
        SpreadsheetMLMain.aak(this, ST_Guid.a(a._t), intSToU(b.magnificationInCurrentView), intSToU(b._a8), void 0, b.showFormulasInCells, b.showGridlines, b.showRowAndColumnHeaders, b.showOutlineSymbols, b.showZeroValues, void 0, void 0, void 0, void 0, c != null && c.count > 0, d != null && d.count > 0, XlsxUtilities.a1(b.visibility), void 0, XlsxUtilities.a2(b.view), b.showRulerInPageLayoutView, e);
        if (b._al() || b._am()) {
            this.gs(b);
        }
        this.gy(b);
        if (a.savePrintOptions) {
            let f = a.getPrintOptions(this.bk, false);
            if (f != null) {
                this.gx(f);
                this.f4(f);
                ObjectModelWorksheetPartManager.gp(this, f);
                this.gu(f);
                ObjectModelWorksheetPartManager.gq(this, f);
                ObjectModelWorksheetPartManager.gh(this, f);
            }
        }
        this.ad.k();
    }
    ga() {
        let a = this.bg._by;
        if (a._cq == false) {
            return;
        }
        if (Enumerable.d(CustomView.$, a._customViews$i, (b) => b.getDisplayOptions(this.bk, false) != null) == false) {
            return;
        }
        SpreadsheetMLMain.aal(this);
        ExcelUtils.fm(CustomView.$, a._customViews$i, runOn(this, this.f9));
        this.ad.k();
    }
    gb(a, b, c) {
        let d = b.key;
        let e = b.value;
        let f = false;
        let g = typeCast(ListDataValidationRule.$, d);
        if (g != null) {
            f = (g.showDropdown == false);
        }
        let h = e._toString1(1);
        if (c) {
            (((i, j, k, l, m, n, o, p, q, r, s, t) => SpreadsheetML2009Main.dg(i, j, k, void 0, l, n, m, o, p, q, r, s, t))(this, XlsxUtilities.as(d._k), XlsxUtilities.aq(d.errorStyle), XlsxUtilities.ar(d._j), f, d._p, d.showInputMessage, d.showErrorMessageForInvalidValue, d.errorMessageTitle, ObjectModelWorksheetPartManager.b0(d.errorMessageDescription), d.inputMessageTitle, ObjectModelWorksheetPartManager.b0(d.inputMessageDescription)));
            if (d._l(null) != null) {
                SpreadsheetML2009Main.di(this);
                this.f8(a, runOn(d, d._l), e, Excel2006Main.au);
                this.ad.k();
            }
            if (d._m(null) != null) {
                SpreadsheetML2009Main.dj(this);
                this.f8(a, runOn(d, d._m), e, Excel2006Main.au);
                this.ad.k();
            }
            Excel2006Main.av(this, h);
            this.ad.k();
            this.ad.k();
        }
        else {
            SpreadsheetMLMain.aaq(this, h, XlsxUtilities.as(d._k), XlsxUtilities.aq(d.errorStyle), void 0, XlsxUtilities.ar(d._j), d._p, f, d.showInputMessage, d.showErrorMessageForInvalidValue, d.errorMessageTitle, ObjectModelWorksheetPartManager.b0(d.errorMessageDescription), d.inputMessageTitle, ObjectModelWorksheetPartManager.b0(d.inputMessageDescription));
            this.f8(a, runOn(d, d._l), e, SpreadsheetMLMain.abw);
            this.f8(a, runOn(d, d._m), e, SpreadsheetMLMain.abx);
            this.ad.k();
        }
    }
    gc(u, v) {
        if (v == null || v.count == 0) {
            return;
        }
        SpreadsheetMLMain.aar(this, void 0, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, intSToU(v.count)));
        v.q((w) => this.gb(u, w, false));
        this.ad.k();
    }
    gd(u, v) {
        let w = this.bk._cx(v.p, v.n, Math.max(0, v.q - 1), Math.max(0, v.o - 1));
        if (w == null) {
            return;
        }
        let x = w._u ? w._k._c7(w._v, 1, false, true, true) : w._toString2(1, false, true, true);
        SpreadsheetMLMain.aa0(this, x);
        this.ad.k();
    }
    static ge(u, v) {
        if (v == null) {
            return;
        }
        SpreadsheetMLMain.aa1(u, v);
        u.ad.k();
    }
    gf(u, v) {
        if (v == null || v.count == 0) {
            return;
        }
        SpreadsheetMLMain.aba(this, "{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}");
        this.ad.l(SpreadsheetML2009Main.an);
        SpreadsheetML2009Main.dh(this, void 0, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, intSToU(v.count)));
        this.ad.l(Excel2006Main.an);
        v.q((w) => this.gb(u, w, true));
        this.ad.k();
        this.ad.k();
    }
    a8() {
        if (this.bk._eb == false) {
            return null;
        }
        SpreadsheetMLMain.aba(this, "{A8765BA9-456A-4dab-B4F3-ACF838C121DE}");
        this.ad.l(SpreadsheetML2009Main.an);
        SpreadsheetML2009Main.dr(this);
        return WorkItemExtensions.a(Async.d(BinaryData.$, this.bk._ez(), runOn(this, this.bb)), () => {
            this.ad.k();
            this.ad.k();
        });
    }
    a9(u, v) {
        let w = null;
        let x = null;
        if (u._cc != null) {
            let y = u._cc.tryGetValue(this.bk, w);
            w = y.p1;
        }
        if (u._ch != null) {
            let z = u._ch.tryGetValue(this.bk, x);
            x = z.p1;
        }
        let aa = this.bk._eb || (w != null && w.n) || x != null;
        let ab = v != null && v.count != 0;
        if (aa == false && ab == false) {
            return null;
        }
        SpreadsheetMLMain.abg(this);
        if (w != null) {
            w.y(this, u, this.ad);
        }
        if (x != null) {
            x.b(this, u, this.ad);
        }
        this.gf(u, v);
        return WorkItemExtensions.a(this.a8(), () => this.ad.k());
    }
    gg(u, v, w, x) {
        let y = typeCast(SingleTargetFormula.$, x);
        if (y == null || y._cj == false) {
            return;
        }
        let z = null;
        let aa = null;
        let ab = 0;
        let ac = false;
        let ad = false;
        let ae = null;
        let af = null;
        let ag = Nullable$1.toNullable(Number_$type, null);
        if (y._am) {
            let ah = y._cz;
            ab = 2;
            aa = ah._h._toString2(1, false, true, true);
            let ai = ah.columnInputCell;
            let aj = ah.rowInputCell;
            let ak = WorksheetCell.l_op_Inequality(ai, null) && WorksheetCell.l_op_Inequality(aj, null);
            ac = ak;
            ad = WorksheetCell.l_op_Inequality(aj, null);
            ae = (aj || ai)._toString2(1, false, true, true);
            if (ak) {
                af = ai._toString2(1, false, true, true);
            }
        }
        else if (y._ak) {
            ab = 1;
            let al = y._cz;
            aa = al.cellRange._toString2(1, false, true, true);
            z = u._ct(al);
        }
        else {
            z = u._ct(y);
            let t1 = y._s;
            L0: while (true) {
                switch (t1) {
                    case 3:
                    case 0:
                        ab = 0;
                        break;
                    case 2:
                        ab = 3;
                        let am;
                        let an;
                        ag = Nullable$1.toNullable(Number_$type, ((() => { let ao = u._cv(v.worksheet, y, am, an); am = ao.p2; an = ao.p3; return ao.ret; })()));
                        if (an != null) {
                            aa = an._toString2(1, false, true, true);
                        }
                        if (am == false) {
                            z = null;
                        }
                        break;
                    case 4:
                        ab = 0;
                        break;
                    default:
                        t1 = 0;
                        continue L0;
                }
                break;
            }
        }
        let ao = v._as(w)._be();
        SpreadsheetMLMain.abi(this, z, ab, void 0, aa, ac, ad, void 0, void 0, ae, af, ao, ag);
        this.ad.k();
    }
    static gh(u, v) {
        let w = stringIsNullOrEmpty(v.header) == false;
        let x = stringIsNullOrEmpty(v.footer) == false;
        if (w == false && x == false && v.alignHeadersAndFootersWithMargins == true && v.scaleHeadersAndFootersWithDocument == true) {
            return;
        }
        SpreadsheetMLMain.ab0(u, void 0, void 0, v.scaleHeadersAndFootersWithDocument, v.alignHeadersAndFootersWithMargins);
        if (w) {
            SpreadsheetMLMain.acj(u, v.header);
            u.ad.k();
        }
        if (x) {
            SpreadsheetMLMain.aci(u, v.footer);
            u.ad.k();
        }
        u.ad.k();
    }
    gi(u) {
        let v;
        let w;
        let x;
        let y = WorkbookSaveManager._b5(u, v, w, x);
        v = y.p1;
        w = y.p2;
        x = y.p3;
        let z = null;
        if (v != null) {
            z = this.d._ay(v, this.bg._a4());
        }
        let aa = WorksheetCell.l_op_Inequality(u.sourceCell, null) ? u.sourceCell._toString2(1, false, true, true) : u.sourceRegion._toString2(1, false, true, true);
        let ab = u.displayText != null ? u.displayText : u.targetAddress;
        if (Base.equalsStatic(ab, u.sourceRegion._k._c6(u.sourceRegion._v))) {
            ab = null;
        }
        SpreadsheetMLMain.ab2(this, aa, z, w, u.toolTip, u.displayText);
        this.ad.k();
    }
    gj() {
        if (this.bk._d8 == false) {
            return;
        }
        SpreadsheetMLMain.ab3(this);
        ExcelUtils.fm(WorksheetHyperlink.$, this.bk._hyperlinks$i, runOn(this, this.gi));
        this.ad.k();
    }
    static gk(u, v) {
        if (v == null) {
            return;
        }
        if (u.d._z == 0) {
            SpreadsheetMLMain.acb(u, v);
            u.ad.k();
        }
        else {
            u.ad.g([new AlternateContentChoice(0, VmlNamespace.an, () => {
                    SpreadsheetMLMain.acb(u, v);
                    u.ad.k();
                })]);
        }
    }
    static gl(u, v) {
        if (v == null) {
            return;
        }
        if (u.d._z == 0) {
            SpreadsheetMLMain.acc(u, v);
            u.ad.k();
        }
        else {
            u.ad.g([new AlternateContentChoice(0, VmlNamespace.an, () => {
                    SpreadsheetMLMain.acc(u, v);
                    u.ad.k();
                })]);
        }
    }
    gm(u) {
        SpreadsheetMLMain.acd(this, u._toString2(1, false, true, true));
        this.ad.k();
    }
    gn() {
        let u = ObjectModelWorksheetPartManager.bh(this)._b9._av(this.bk);
        let v = Enumerable.aj(WorksheetMergedCellsRegion.$, u);
        if (v == 0) {
            return;
        }
        SpreadsheetMLMain.ace(this, Nullable$1.toNullable(Number_$type, intSToU(v)));
        ExcelUtils.fm(WorksheetMergedCellsRegion.$, u, runOn(this, this.gm));
        this.ad.k();
    }
    go() {
        SpreadsheetMLMain.aco(this, void 0, this.bk.displayOptions._an, this.bk.displayOptions._ao, this.bk.displayOptions.showOutlineSymbols);
        this.ad.k();
    }
    static gp(u, v) {
        SpreadsheetMLMain.acp(u, v.leftMargin, v.rightMargin, v.topMargin, v.bottomMargin, v.headerMargin, v.footerMargin);
        u.ad.k();
    }
    static gq(u, v) {
        if (v._ag() == false) {
            return;
        }
        let w = null;
        if (v._c != null) {
            let x = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), u.d._j(ObjectModelPrinterSettingsPartManager.a7, v._c));
            if (x != null) {
                w = x.d;
            }
        }
        let y = 100;
        let z = 1;
        let aa = 1;
        let ab = 0;
        if (typeCast(PrintOptions.$, v) !== null) {
            let ac = v;
            y = ac.scalingFactor;
            z = ac.maxPagesHorizontally;
            aa = ac.maxPagesVertically;
            ab = XlsxUtilities.aw(ac.pageOrder);
        }
        SpreadsheetMLMain.acq(u, v.paperSize, void 0, void 0, intSToU(y), intSToU(v.startPageNumber), intSToU(z), intSToU(aa), ab, XlsxUtilities.av(v.orientation), void 0, v.printInBlackAndWhite, v.draftQuality, XlsxUtilities.ap(v.printNotes), v.pageNumbering == 1, XlsxUtilities.az(v.printErrors), intSToU(v.resolution), intSToU(v.verticalResolution), intSToU(v.numberOfCopies), w);
        u.ad.k();
    }
    gr() {
        SpreadsheetMLMain.acr(this, void 0, this.bk.printOptions.scalingType == 1);
        this.ad.k();
    }
    gs(u) {
        let v = this.bg._by;
        u._br();
        let w = XlsxUtilities.ax(u._z);
        if (u.panesAreFrozen) {
            let x = u.frozenPaneSettings;
            let y = null;
            let z = Math.max(x.frozenColumns, x.firstColumnInRightPane);
            let aa = Math.max(x.frozenRows, x.firstRowInBottomPane);
            if (z > 0 || aa > 0) {
                y = CellAddress.u(aa, z, v.currentFormat);
            }
            let ab = x._z ? 2 : 1;
            SpreadsheetMLMain.acs(this, x.frozenColumns, x.frozenRows, y, w, ab);
        }
        else {
            let ac = u.unfrozenPaneSettings;
            let ad = null;
            if (ac.firstColumnInRightPane > 0 && ac.firstRowInBottomPane > 0) {
                ad = CellAddress.u(ac.firstRowInBottomPane, ac.firstColumnInRightPane, v.currentFormat);
            }
            SpreadsheetMLMain.acs(this, ac.leftPaneWidth, ac.topPaneHeight, ad, w, 0);
        }
        this.ad.k();
    }
    static gt(u, v, w) {
        if (w.a == null) {
            return;
        }
        SpreadsheetMLMain.acu(u, w.a);
        u.ad.k();
    }
    gu(u) {
        SpreadsheetMLMain.acx(this, u.centerHorizontally, u.centerVertically, u.printRowAndColumnHeaders, u.printGridlines);
        this.ad.k();
    }
    gv(u) {
        let v = this.d._z == 0;
        if (v && nullableEquals(u._c.h(), 0)) {
            v = false;
        }
        let w = null;
        if (u.ranges.count > 0) {
            let x = Enumerable.o(WorksheetRegion.$, WorksheetRegionAddress.$, u.ranges, (y) => y._h);
            w = WorksheetReferenceCollection._ab(1, this.bk, x);
        }
        if (v == false) {
            let y;
            let z, aa;
            let ab;
            let ac = u._c.e(y, z, aa, ab);
            y = ac.p0;
            z = ac.p1;
            aa = ac.p2;
            ab = ac.p3;
            SpreadsheetMLMain.acz(this, u._m(), w, u.title, y, z != null ? Convert.toBase64String(z) : null, aa != null ? Convert.toBase64String(aa) : null, ab);
        }
        else {
            let ad = u._c.h();
            let ae = ad.hasValue ? Nullable$1.toNullable(ST_UnsignedShortHex.$, new ST_UnsignedShortHex(1, ad.value)) : Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
            SpreadsheetMLMain.acy(this, u._m(), w, u.title, ae);
        }
        this.ad.k();
    }
    gw() {
        if (this.bk.protection._allowedEditRanges$i.count == 0) {
            return;
        }
        SpreadsheetMLMain.ac0(this);
        ExcelUtils.fm(WorksheetProtectedRange.$, this.bk.protection._allowedEditRanges$i, runOn(this, this.gv));
        this.ad.k();
    }
    bw(u, v, w) {
        let x = 0;
        let y = false;
        if (v._hasCellFormat && v._cellFormatInternal._z == false) {
            x = u._a6(v._cellFormatInternal.d);
            y = true;
        }
        let z = Nullable$1.toNullable(Number_$type, null);
        let aa = v._cs(true);
        if (aa > -1) {
            z = Nullable$1.toNullable(Number_$type, aa / 20);
        }
        else if (this.bk._d4) {
            z = Nullable$1.toNullable(Number_$type, this.bk.defaultRowHeight / 20);
        }
        SpreadsheetMLMain.ac7(this, Nullable$1.toNullable(Number_$type, intSToU((v.index + 1))), void 0, x, y, z, v.hidden, v._bz, v.outlineLevel, w.a, v._b4, v._b1);
        let ab = v._hasCellFormat ? v._cellFormatInternal.d : null;
        let ac = CellAddress.x(v.index, true, u._b.currentFormat, v.index, false, 1);
        let ad = 0;
        for (let ae of fromEnum(v._ch(void 0, void 0, true))) {
            if (ae.j == null) {
                ae.j = ab || this.bk._cb(ae.r).b;
            }
            this.f3(u, v, w, ac, ae);
            ad++;
        }
        this.ad.k();
        return ad;
    }
    gx(u) {
        if (u._cp == false) {
            return;
        }
        SpreadsheetMLMain.ac6(this, intSToU(u._horizontalPageBreaks$i.count), intSToU(u._horizontalPageBreaks$i._k()));
        ExcelUtils.fm(HorizontalPageBreak.$, u._horizontalPageBreaks$i, runOn(this, this.f2));
        this.ad.k();
    }
    gy(u) {
        if (u._ai == false) {
            return;
        }
        let v = u._af;
        let w = u._ad.workbook;
        let x = w.currentFormat;
        for (let y of fromEnum(v.b)) {
            let z = XlsxUtilities.ax(y.a);
            let aa = y.b.p(false, false, x, 1);
            let ab = intSToU(y.f);
            let ac = new List$1(String_$type, 0);
            for (let ad of fromEnum(y.d)) {
                ac.add(ad._ah(false, false, x, 1));
            }
            SpreadsheetMLMain.adb(this, z, aa, ab, ac);
            this.ad.k();
        }
    }
    gz() {
        if (Enumerable.d(KeyValuePair$2.$.specialize(WorkbookReferenceBase.$, Number_$type), this.bg._b9._ci, (u) => typeCast(OleLinkWorkbookReference.$, u.key) !== null)) {
            return;
        }
        if (!this.bn) {
            return;
        }
        SpreadsheetMLMain.add(this, true);
        this.ad.k();
    }
    ba(u) {
        SpreadsheetMLMain.ade(this);
        let v = 0;
        return WorkItemExtensions.a(Async.e(WorksheetRow.$, u._aw(this.bk), (w) => {
            let x = u._u(w);
            if (x != null) {
                v += this.bw(u, w, x);
                if (1000 < v) {
                    v = 0;
                    return false;
                }
            }
            return true;
        }), () => this.ad.k());
    }
    g0() {
        let u = this.bk._ek ? Nullable$1.toNullable(Number_$type, this.bk.getDefaultColumnWidth(0)) : Nullable$1.toNullable(Number_$type, null);
        if (nullableNotEquals(u, null) && Enumerable.b(WorksheetColumnBlock.$, this.bk._ff, (v) => v.i)) {
            u = Nullable$1.toNullable(Number_$type, 0);
        }
        SpreadsheetMLMain.adi(this, this.bk.defaultRowHeight / 20, truncate(MathUtilities.j(this.bk.getDefaultColumnWidth(2))), u, this.bk._d4, this.bk._dv, this.bk._dt, this.bk._ds);
        this.ad.k();
    }
    g1() {
        let u = null;
        if (this.bk.workbook._k != null) {
            u = this.bk._ak;
        }
        SpreadsheetMLMain.adl(this, void 0, void 0, void 0, void 0, void 0, void 0, u);
        this.g6();
        this.go();
        this.gr();
        this.ad.k();
    }
    g2() {
        let u = this.bk.protection;
        let v = this.d._z == 0;
        if (v && nullableEquals(u._c.h(), 0)) {
            v = false;
        }
        if (v && !u._c.h().hasValue) {
            v = false;
        }
        if (v == false) {
            let w;
            let x, y;
            let z;
            let aa = u._c.e(w, x, y, z);
            w = aa.p0;
            x = aa.p1;
            y = aa.p2;
            z = aa.p3;
            SpreadsheetMLMain.adn(this, w, x != null ? Convert.toBase64String(x) : null, y != null ? Convert.toBase64String(y) : null, z, this.bk.isProtected, u.allowEditObjects == false, u.allowEditScenarios == false, u.allowFormattingCells == false, u.allowFormattingColumns == false, u.allowFormattingRows == false, u.allowInsertingColumns == false, u.allowInsertingRows == false, u.allowInsertingHyperlinks == false, u.allowDeletingColumns == false, u.allowDeletingRows == false, u._ab == false, u.allowSorting == false, u.allowFiltering == false, u.allowUsingPivotTables == false, u._ac == false);
        }
        else {
            let ab = u._c.h();
            let ac = ab.hasValue ? Nullable$1.toNullable(ST_UnsignedShortHex.$, new ST_UnsignedShortHex(1, ab.value)) : Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
            SpreadsheetMLMain.adm(this, ac, this.bk.isProtected, u.allowEditObjects == false, u.allowEditScenarios == false, u.allowFormattingCells == false, u.allowFormattingColumns == false, u.allowFormattingRows == false, u.allowInsertingColumns == false, u.allowInsertingRows == false, u.allowInsertingHyperlinks == false, u.allowDeletingColumns == false, u.allowDeletingRows == false, u._ab == false, u.allowSorting == false, u.allowFiltering == false, u.allowUsingPivotTables == false, u._ac == false);
        }
        this.ad.k();
    }
    g3() {
        let u = this.bg._by;
        let v = this.bk.displayOptions;
        let w = null;
        let x = v.unfrozenPaneSettings.firstColumnInLeftPane;
        let y = v.unfrozenPaneSettings.firstRowInTopPane;
        if (x > 0 || y > 0) {
            w = CellAddress.u(y, x, u.currentFormat);
        }
        SpreadsheetMLMain.adp(this, 0, void 0, v.showFormulasInCells, v.showGridlines, v.showRowAndColumnHeaders, v.showZeroValues, v.orderColumnsRightToLeft, u.windowOptions.selectedSheet == this.bk || this.bk._w, v.showRulerInPageLayoutView, v.showOutlineSymbols, v._a8 == 64, v.showWhitespaceInPageLayoutView, XlsxUtilities.a2(v.view), w, intSToU(v._a8), intSToU(v._b3), intSToU(v.magnificationInNormalView), intSToU(v.magnificationInPageBreakView), intSToU(v.magnificationInPageLayoutView));
        let z = this.bk.displayOptions.frozenPaneSettings;
        let aa = this.bk.displayOptions.unfrozenPaneSettings;
        if ((v.panesAreFrozen && (z._h || z._i)) || (!v.panesAreFrozen && (aa._h || aa._i))) {
            this.gs(v);
        }
        this.gy(v);
        this.ad.k();
    }
    g4() {
        SpreadsheetMLMain.adq(this);
        this.g3();
        this.ad.k();
    }
    g5(u, v, w, x, y = 0) {
        if (v == null) {
            return;
        }
        (((z, aa, ab, ac, ad) => SpreadsheetMLMain.adu(z, ab, aa, ac, ad))(this, y == 1, v._toString2(1, false, true, true), w.caseSensitive, w._n ? XlsxUtilities.a3(w._i) : 0));
        let ae = u._w(v.worksheet);
        for (let af of fromEnum(w._sortConditions$i)) {
            let ag = af.key;
            let ah = af.value;
            let ai = null;
            let aj = 0;
            let ak = Nullable$1.toNullable(Number_$type, null);
            let al = typeCast(CustomListSortCondition.$, ah);
            if (al != null) {
                ai = al._l();
            }
            let am = typeCast(IconSortCondition.$, ah);
            if (am != null) {
                aj = am._k;
                ak = am._n;
            }
            let an = v._h;
            if (y == 1) {
                an = an._d((an._ac + ag.index))._f((an._ac + ag.index));
            }
            else {
                an = an._c((an._w + ag.index))._e((an._w + ag.index));
            }
            SpreadsheetMLMain.ads(this, an._ah(true, true, this.bk._o, 1), ah.sortDirection == 1, ah._d, ai, x ? ae.l(ag.index) : ae.m(ag.index), aj, ak);
        }
        this.ad.k();
    }
    bb(ae) {
        return WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this.bg._j(ObjectModelSlicerPartManager.a7, ae), (af) => {
            SpreadsheetML2009Main.dq(this, WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), af).d);
            this.ad.k();
        });
    }
    g6() {
        if (WorkbookColorInfo.l_op_Equality(this.bk.displayOptions.tabColorInfo, null)) {
            return;
        }
        ObjectModelCommonPartHelpers.ao(this, this.bk.displayOptions.tabColorInfo, 4, SpreadsheetMLMain.ad1);
    }
    g7(ae) {
        let af = this.bg._f(ae).id;
        SpreadsheetMLMain.ad5(this, af);
        this.ad.k();
    }
    g8() {
        if (this.bk._tables$i.count == 0) {
            return;
        }
        SpreadsheetMLMain.ad6(this, Nullable$1.toNullable(Number_$type, intSToU(this.bk._tables$i.count)));
        ExcelUtils.fm(WorksheetTable.$, this.bk._tables$i, runOn(this, this.g7));
        this.ad.k();
    }
    static bp(ae) {
        if (ae.workbook.calculationMode == 0 && !ae.workbook.recalculateBeforeSave) {
            return true;
        }
        if (ae._shapes$i.count > 0) {
            let af = ae._shapes$i;
            for (let ag = 0; ag < af.count; ag++) {
                if (typeCast(WorksheetChart.$, af.item(ag)) !== null) {
                    return true;
                }
            }
        }
        return false;
    }
    bc(ae, af) {
        let ag = ae._b;
        let ah = this.bk.printOptions;
        let ai = ae._w(this.bk);
        this.bn = ObjectModelWorksheetPartManager.bp(this.bk);
        let aj = null;
        let ak = null;
        for (let al of fromEnum(this.bk._dataValidationRules$i)) {
            let am = al.key;
            let an = ak;
            if (this.bo(am._l(null)) || this.bo(am._m(null))) {
                if (ak == null) {
                    ak = new List$1(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), 0);
                }
                ak.add(al);
            }
            else {
                if (aj == null) {
                    aj = new List$1(KeyValuePair$2.$.specialize(DataValidationRule.$, WorksheetReferenceCollection.$), 0);
                }
                aj.add(al);
            }
        }
        SpreadsheetMLMain.aeq(this);
        if (af.c != null || af.b != null) {
            this.ad.l(VmlNamespace.an);
        }
        this.g1();
        this.gd(ae, ai);
        this.g4();
        this.g0();
        this.f6(ae);
        return WorkItemExtensions.a(WorkItemExtensions.c(WorkItemExtensions.a(WorkItemExtensions.c(WorkItemExtensions.a(this.ba(ae), () => {
            this.gz();
            this.g2();
            this.gw();
            this.f1(ae);
            this.g5(ae, this.bk.sortSettings.region, this.bk.sortSettings, false, this.bk.sortSettings.sortType);
            this.ga();
            this.gn();
            this.f7(ae);
            this.gc(ae, aj);
            this.gj();
            this.gu(ah);
            ObjectModelWorksheetPartManager.gp(this, ah);
            ObjectModelWorksheetPartManager.gq(this, ah);
            ObjectModelWorksheetPartManager.gh(this, ah);
            this.gx(ah);
            this.f4(ah);
            ObjectModelWorksheetPartManager.ge(this, af.a);
            ObjectModelWorksheetPartManager.gk(this, af.c);
            ObjectModelWorksheetPartManager.gl(this, af.b);
            ObjectModelWorksheetPartManager.gt(this, ae, ai);
        }), () => this.a7()), () => this.g8()), () => this.a9(ae, ak)), () => this.ad.k());
    }
    static bf(ae, af) {
        af = null;
        let ag = typeCast(ObjectModelWorksheetPartManager.$, ae);
        let ah = ag.be;
        if (ConditionalFormatInfo.e(ah) == false) {
            return {
                ret: null,
                p1: af
            };
        }
        af = ah.b;
        if (CfRuleInfo.l(af) == false) {
            return {
                ret: null,
                p1: af
            };
        }
        return {
            ret: ah,
            p1: af
        };
    }
    get bg() {
        return ObjectModelWorksheetPartManager.bh(this);
    }
    static bh(ae) {
        return ae.d;
    }
    get bl() {
        return this.bk;
    }
}
ObjectModelWorksheetPartManager.$t = markType(ObjectModelWorksheetPartManager, 'ObjectModelWorksheetPartManager', WorksheetPartManager.$);
ObjectModelWorksheetPartManager.bi = new ObjectModelWorksheetPartManager();
/**
 * @hidden
 */
export class ObjectModelStylesPartManager extends ExcelStylesPartManager {
    constructor() {
        super();
        this.ay(SpreadsheetMLMain.cj, ObjectModelStylesPartManager.a9);
        this.ay(SpreadsheetMLMain.dg, ObjectModelStylesPartManager.ba);
        this.ay(SpreadsheetMLMain.dk, ObjectModelStylesPartManager.bb);
        this.ay(SpreadsheetMLMain.dm, ObjectModelStylesPartManager.bc);
        this.ay(SpreadsheetMLMain.dn, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.tu, (b) => b.c));
        this.ay(SpreadsheetMLMain.d7, ObjectModelStylesPartManager.be);
        this.ay(SpreadsheetMLMain.d8, ObjectModelStylesPartManager.bf);
        this.ay(SpreadsheetMLMain.d9, ObjectModelStylesPartManager.bg);
        this.ay(SpreadsheetMLMain.ea, ObjectModelStylesPartManager.bh);
        this.ay(SpreadsheetMLMain.ew, ObjectModelStylesPartManager.bi);
        this.ay(SpreadsheetMLMain.gq, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.ve, (b) => b.e));
        this.ay(SpreadsheetMLMain.g5, ObjectModelStylesPartManager.bj);
        this.ax(SpreadsheetMLMain.g5, ObjectModelStylesPartManager.bk);
        this.ay(SpreadsheetMLMain.g7, ObjectModelStylesPartManager.bl);
        this.ay(SpreadsheetMLMain.ha, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.vm, (b) => b.k, Nullable$1.toNullable(ST_ConformanceClass_$type, 1)));
        this.ay(SpreadsheetMLMain.hs, ObjectModelStylesPartManager.bm);
        this.ay(SpreadsheetMLMain.hv, ObjectModelStylesPartManager.bn);
        this.ay(SpreadsheetMLMain.hx, ObjectModelStylesPartManager.bo);
        this.ay(SpreadsheetMLMain.id, ObjectModelStylesPartManager.bp);
        this.ay(SpreadsheetMLMain.ig, ObjectModelStylesPartManager.bq);
        this.ay(SpreadsheetMLMain.ix, ObjectModelStylesPartManager.br);
        this.ay(SpreadsheetMLMain.jg, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.wg, (b) => b.g));
        this.ay(SpreadsheetMLMain.j1, ObjectModelStylesPartManager.bs);
        this.ax(SpreadsheetMLMain.j1, ObjectModelStylesPartManager.bt);
        this.ay(SpreadsheetMLMain.kc, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.wo, (b) => b.i, Nullable$1.toNullable(ST_ConformanceClass_$type, 0)));
        this.ay(SpreadsheetMLMain.lh, ObjectModelStylesPartManager.bu);
        this.ay(SpreadsheetMLMain.lj, ObjectModelStylesPartManager.bv);
        this.ay(SpreadsheetMLMain.mb, ObjectModelStylesPartManager.bw);
        this.ay(SpreadsheetMLMain.m0, ObjectModelStylesPartManager.bx);
        this.ay(SpreadsheetMLMain.nx, ObjectModelStylesPartManager.by);
        this.ay(SpreadsheetMLMain.n1, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.xj, (b) => b.k, Nullable$1.toNullable(ST_ConformanceClass_$type, 0)));
        this.ay(SpreadsheetMLMain.p8, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.x9, (b) => b.i, Nullable$1.toNullable(ST_ConformanceClass_$type, 1)));
        this.ay(SpreadsheetMLMain.qc, ObjectModelStylesPartManager.bz);
        this.ay(SpreadsheetMLMain.qg, ObjectModelStylesPartManager.b0);
        this.ax(SpreadsheetMLMain.qg, ObjectModelStylesPartManager.b1);
        this.ay(SpreadsheetMLMain.qx, ObjectModelStylesPartManager.b2);
        this.ay(SpreadsheetMLMain.qy, ObjectModelStylesPartManager.b3);
        this.ay(SpreadsheetMLMain.q0, ObjectModelStylesPartManager.b4);
        this.ax(SpreadsheetMLMain.q0, ObjectModelStylesPartManager.b5);
        this.ay(SpreadsheetMLMain.re, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.yr, (b) => b.m));
        this.ay(SpreadsheetMLMain.r8, (a) => ObjectModelStylesPartManager.bd(a, SpreadsheetMLMain.yw, (b) => b.o));
        this.ay(SpreadsheetMLMain.sx, ObjectModelStylesPartManager.b6);
        ObjectModelCommonPartHelpers.ak(this, SpreadsheetMLMain.ld, SpreadsheetMLMain.wt);
    }
    u(a) {
        this.di(this.a6._b9);
        return null;
    }
    static a9(a) {
        let b = a.s.a(FormatInfo.$);
        let c = a.s.a(DxfInfo.$);
        if (b == null && c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m = SpreadsheetMLMain.tk(a, d, e, f, g, h, i, j, k, l);
        d = m.p1;
        e = m.p2;
        f = m.p3;
        g = m.p4;
        h = m.p5;
        i = m.p6;
        j = m.p7;
        k = m.p8;
        l = m.p9;
        let n = nullableEquals(d, null) ? 0 : XlsxUtilities.j(d.value);
        let o = nullableEquals(e, null) ? 2 : XlsxUtilities.x(e.value);
        let p = ((() => {
            let $ret = new AlignmentInfo(0);
            $ret.c = n;
            $ret.i = o;
            $ret.ah = f;
            $ret.u = g;
            $ret.ab = h;
            $ret.af = i;
            $ret.q = j;
            $ret.s = k;
            $ret.ad = l;
            return $ret;
        })());
        if (b != null) {
            b.b = p;
        }
        if (c != null) {
            c.b = p;
        }
    }
    static ba(a) {
        let b = a.s.a(PatternFillInfo.$);
        if (b == null) {
            return;
        }
        b.b = ObjectModelCommonPartHelpers.a(a, SpreadsheetMLMain.tq);
    }
    static bb(a) {
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.ts(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        let f = ((() => {
            let $ret = new BorderInfo();
            $ret.s = b;
            $ret.q = c;
            $ret.v = d;
            return $ret;
        })());
        let g = ObjectModelStylesPartManager.a7(a);
        let h = a.s.a(DxfInfo.$);
        if (h != null) {
            h.c = f;
        }
        else {
            if (g._b7._bb.count == 0) {
                let i = new BorderInfo();
                i.c.a = 0;
                i.e.a = 0;
                i.i.a = 0;
                i.k.a = 0;
                i.m.a = 0;
                g._b7._bb.add(i);
            }
            else {
                g._b7._bb.add(f);
            }
        }
        a.s.k(f);
    }
    static bc(a) {
        let b;
        let c = SpreadsheetMLMain.tt(a, b);
        b = c.p1;
    }
    static bd(a, b, c, d = Nullable$1.toNullable(ST_ConformanceClass_$type, null)) {
        if (nullableNotEquals(d, null)) {
        }
        let e = a.s.a(BorderInfo.$);
        if (e == null) {
            return;
        }
        let f;
        let g = b(a, f);
        f = g.p1;
        let h = c(e);
        h.a = XlsxUtilities.b(f);
        a.s.k(h.d);
    }
    static be(a) {
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h = SpreadsheetMLMain.t0(a, b, c, d, e, f, g);
        b = h.p1;
        c = h.p2;
        d = h.p3;
        e = h.p4;
        f = h.p5;
        g = h.p6;
        let i = ObjectModelStylesPartManager.a7(a);
        i._b7._bc.add(((() => {
            let $ret = new StyleInfo(0);
            $ret.e = b;
            $ret.l = c;
            $ret.h = d;
            $ret.j = e;
            $ret.d = f;
            $ret.b = g;
            return $ret;
        })()));
    }
    static bf(a) {
        let b;
        let c = SpreadsheetMLMain.t1(a, b);
        b = c.p1;
    }
    static bg(a) {
        let b;
        let c = SpreadsheetMLMain.t2(a, b);
        b = c.p1;
        let d = ObjectModelStylesPartManager.a7(a);
        a.s.k(d._b7._bd);
    }
    static bh(a) {
        let b;
        let c = SpreadsheetMLMain.t3(a, b);
        b = c.p1;
        let d = ObjectModelStylesPartManager.a7(a);
        a.s.k(d._b7._be);
    }
    static bi(a) {
    }
    static bj(a) {
        a.s.k(new DxfInfo(0));
    }
    static bk(a) {
        let b = a.s.a(DxfInfo.$);
        if (b == null) {
            return;
        }
        let c = ObjectModelStylesPartManager.a7(a);
        c._b7._g.add(b.h(c._b7));
    }
    static bl(a) {
        let b;
        let c = SpreadsheetMLMain.vj(a, b);
        b = c.p1;
    }
    static bm(a) {
        let b = a.s.a(PatternFillInfo.$);
        if (b == null) {
            return;
        }
        b.e = ObjectModelCommonPartHelpers.a(a, SpreadsheetMLMain.vy);
    }
    static bn(a) {
        let b = new FillInfo();
        a.s.k(b);
        let c = a.s.a(DxfInfo.$);
        if (c != null) {
            c.e = b;
        }
        else {
            ObjectModelStylesPartManager.a7(a)._b7._bf.add(b);
        }
    }
    static bo(a) {
        let b;
        let c = SpreadsheetMLMain.v3(a, b);
        b = c.p1;
    }
    static bp(a) {
        let b = ObjectModelStylesPartManager.a7(a);
        let c = b._by;
        let d = new WorkbookFontData(0, c);
        a.s.k(d);
        let e = new ColorInfo();
        e.d = d;
        a.s.k(e);
        let f = a.s.a(DxfInfo.$);
        if (f != null) {
            f.d = e;
            f.a = d;
        }
        else {
            b._b7._bg.add(e);
        }
    }
    static bq(a) {
        let b;
        let c = SpreadsheetMLMain.wa(a, b);
        b = c.p1;
    }
    static br(a) {
        let b = a.s.a(FillInfo.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i = SpreadsheetMLMain.we(a, c, d, e, f, g, h);
        c = i.p1;
        d = i.p2;
        e = i.p3;
        f = i.p4;
        g = i.p5;
        h = i.p6;
        let j = ((() => {
            let $ret = new GradientFillInfo();
            $ret.e = c;
            $ret.q = d;
            $ret.s = e;
            $ret.u = f;
            $ret.w = g;
            $ret.j = h;
            return $ret;
        })());
        b.b = j;
        a.s.k(j);
    }
    static bs(a) {
        a.s.k(new List$1(Color.$, 0));
    }
    static bt(a) {
        let b = a.s.a(List$1.$.specialize(Color.$));
        if (b == null) {
            return;
        }
        let c = ObjectModelStylesPartManager.a7(a)._by._palette$i;
        for (let d = 8; d < b.count; d++) {
            c._item$i(d - 8, b._inner[d]);
        }
    }
    static bu(a) {
        let b;
        let c;
        let d = SpreadsheetMLMain.wu(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = new SerializationNumberFormatInfo();
        let f = a.s.a(DxfInfo.$);
        if (f != null) {
            f.g = e;
            b = WorkbookFormatCollection.aj(b);
        }
        e.b = c;
        e.c = b;
        let g = ObjectModelStylesPartManager.a7(a)._by;
        g._b2.ap(e.c, e.b);
    }
    static bv(a) {
        let b;
        let c = SpreadsheetMLMain.wv(a, b);
        b = c.p1;
    }
    static bw(a) {
        let b = a.s.a(FillInfo.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.w7(a, c);
        c = d.p1;
        let e = new PatternFillInfo();
        e.j = XlsxUtilities.a8(c);
        b.d = e;
        a.s.k(e);
    }
    static bx(a) {
        let b = a.s.a(FormatInfo.$);
        let c = a.s.a(DxfInfo.$);
        if (b == null && c == null) {
            return;
        }
        let d;
        let e;
        let f = SpreadsheetMLMain.xf(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new ProtectionInfo();
            $ret.j = d;
            $ret.h = e;
            return $ret;
        })());
        if (b != null) {
            b.d = g;
        }
        if (c != null) {
            c.f = g;
        }
    }
    static by(a) {
        let b = a.s.a(List$1.$.specialize(Color.$));
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.xi(a, c);
        c = d.p1;
        try {
            let e = ST_UnsignedIntHex.h(c.getValueOrDefault1(ST_UnsignedIntHex.b(0)));
            e = u32BitwiseOr(e, 4278190080);
            b.add(ExcelUtils.gx(e));
        }
        catch (f) {
            return;
        }
    }
    static bz(a) {
        let b = a.s.a(GradientFillInfo.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.ya(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new StopInfo();
            $ret.g = c;
            return $ret;
        })());
        e.c = new ColorInfo();
        a.s.k(e.c);
        b.h.add(e);
    }
    static b0(a) {
        if (a.d._z == 0 && a.ab.af == SpreadsheetMLMain.ao.i(1)) {
            a.d._bn(1);
        }
    }
    static b1(a) {
        let b = ObjectModelStylesPartManager.a7(a)._b7;
        if (b._bc.count == 0) {
            b._bc.add(new StyleInfo(0));
            if (b._be.count != 0) {
                b._be._inner[0] = new FormatInfo();
            }
        }
        if (b._bd.count == 0) {
            b._bd.add(new FormatInfo());
        }
        ObjectModelStylesPartManager.b7(b);
        ObjectModelStylesPartManager.b8(b, b._bd);
        for (let c of fromEnum(b._bc)) {
            if (c.e > -1 && c.e < b._bd.count) {
                let d = b._bd._inner[c.e].g;
                let e = new BuiltInStyleInfo();
                if (nullableEquals(c.h, null) && ((() => { let f = WorkbookStyleCollection._t.tryGetValue(c.l, e); e = f.p1; return f.ret; })())) {
                    c.h = Nullable$1.toNullable(Number_$type, e.a);
                    c.j = Nullable$1.toNullable(Number_$type, e.b);
                }
                let f;
                if (nullableNotEquals(c.h, null)) {
                    let g = new WorkbookBuiltInStyle(b._b, d, c.h.value, Convert.toByte1(unwrapNullable(c.j)));
                    g._ah = c.b == true;
                    if (c.d == true) {
                        f = b._b._styles$i._e(g);
                    }
                    else {
                        f = b._b._styles$i._add(g);
                    }
                }
                else {
                    if (c.d) {
                        f = b._b._styles$i._f(d, c.l);
                    }
                    else {
                        f = b._b._styles$i._addUserDefinedStyle(d, c.l);
                    }
                }
                if (b._a7.containsKey(c.e) == false) {
                    b._a7.addItem(c.e, f);
                }
            }
        }
        ObjectModelStylesPartManager.b8(b, b._be);
    }
    static b2(a) {
        let b;
        let c;
        let d;
        let e;
        let f = SpreadsheetMLMain.yk(a, b, c, d, e);
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        let g = ObjectModelStylesPartManager.a7(a);
        if (g._b7._av == false) {
            let h = new WorksheetTableStyle(b, true);
            a.s.k(h);
            if (d) {
                g._by._customTableStyles$i.add(h);
            }
        }
    }
    static b3(a) {
        let b = a.s.a(WorksheetTableStyle.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = SpreadsheetMLMain.yl(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = c;
        if (EnumUtil.isDefined(WorksheetTableStyleArea_$type, enumGetBox(WorksheetTableStyleArea_$type, g)) == false) {
            return;
        }
        if (d != 1) {
            switch (g) {
                case 5:
                    b.rowStripeHeight = d;
                    break;
                case 6:
                    b.alternateRowStripeHeight = d;
                    break;
                case 7:
                    b.columnStripeWidth = d;
                    break;
                case 8:
                    b.alternateColumnStripeWidth = d;
                    break;
                default: break;
            }
        }
        let h = ObjectModelStylesPartManager.a7(a);
        if (e.hasValue && h._b7._av) {
            e.postDecrement();
        }
        let i = null;
        if (e.hasValue) {
            i = h._b7._g._inner[e.value];
        }
        if (i != null && (i._cd == false || h._b7._av)) {
            let j = h._by;
            if (h._b7._av) {
                j = null;
            }
            let k = b._areaFormats$i._d(j, g);
            for (let l = 1; l != 1073741824; l = (l << 1)) {
                if (WorksheetTableStyle._q(l) == false) {
                    continue;
                }
                ExcelUtils.fa(i, k, l);
            }
        }
    }
    static b4(a) {
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.yn(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        a.s.k(new ObjectModelStylesPartManager_TableStylesCollectionInfo(c));
    }
    static b5(a) {
        if (ObjectModelStylesPartManager.a7(a)._b7._av) {
            return;
        }
        let b = a.s.a(ObjectModelStylesPartManager_TableStylesCollectionInfo.$);
        if (b == null) {
            return;
        }
        let c = ObjectModelStylesPartManager.a7(a)._by;
        let d = c._cj(b.a);
        if (d == null) {
            return;
        }
        c.defaultTableStyle = d;
    }
    static b6(a) {
        let b = a.s.a(List$1.$.specialize(FormatInfo.$));
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p = SpreadsheetMLMain.y3(a, c, d, e, f, g, h, i, j, k, l, m, n, o);
        c = p.p1;
        d = p.p2;
        e = p.p3;
        f = p.p4;
        g = p.p5;
        h = p.p6;
        i = p.p7;
        j = p.p8;
        k = p.p9;
        l = p.p10;
        m = p.p11;
        n = p.p12;
        o = p.p13;
        let q = ObjectModelStylesPartManager.a7(a);
        let r = (b == q._b7._bd);
        let s = r;
        let t = 0;
        if (n.getValueOrDefault1(s)) {
            t |= 2;
        }
        if (m.getValueOrDefault1(s)) {
            t |= 8;
        }
        if (k.getValueOrDefault1(s)) {
            t |= 4;
        }
        if (j.getValueOrDefault1(s)) {
            t |= 1;
        }
        if (l.getValueOrDefault1(s)) {
            t |= 16;
        }
        if (o.getValueOrDefault1(s)) {
            t |= 32;
        }
        let u = ((() => {
            let $ret = new FormatInfo();
            $ret.i = t;
            $ret.o = f;
            $ret.r = e;
            $ret.t = d;
            $ret.v = c;
            $ret.k = i;
            $ret.m = h;
            $ret.p = g;
            return $ret;
        })());
        b.add(u);
        a.s.k(u);
    }
    static b7(a) {
        for (let b of fromEnum(a._bg)) {
            let c = b.d;
            c.colorInfo = b.c(a);
            if (a._h.count == 0) {
                a._b._av._p = c;
            }
            a._h.add(c);
        }
    }
    static b8(a, b) {
        let c = (b == a._bd);
        for (let d = 0; d < b.count; d++) {
            let e = c == false && d == 0;
            let f = c && d == 0;
            let g = b._inner[d];
            g.g = g.e(a, c, f);
            if (e) {
                a._b._ca._p = g.g;
            }
        }
    }
    b9(a) {
        ObjectModelStylesPartManager.ca(this, a);
    }
    static ca(a, b) {
        if (b == null || b.o) {
            return;
        }
        SpreadsheetMLMain.y5(a, XlsxUtilities.a9(b.c), XlsxUtilities.bc(b.i), b.ah, b.u, b.ab, b.af, b.q, b.s, b.ad);
        a.ad.k();
    }
    cb(a) {
        ObjectModelStylesPartManager.cc(this, a);
    }
    static cc(a, b) {
        ObjectModelCommonPartHelpers.an(a, b, SpreadsheetMLMain.zb);
    }
    cd(a) {
        ObjectModelStylesPartManager.ce(this, a);
    }
    static ce(a, b) {
        if (b == null) {
            return;
        }
        SpreadsheetMLMain.zd(a, b.s, b.q, b.v);
        ObjectModelStylesPartManager.df(a, b.i);
        ObjectModelStylesPartManager.cv(a, b.k);
        ObjectModelStylesPartManager.dn(a, b.m);
        ObjectModelStylesPartManager.cj(a, b.c);
        ObjectModelStylesPartManager.cq(a, b.e);
        a.ad.k();
    }
    cf(a) {
        let b = this.a6;
        SpreadsheetMLMain.ze(this, Nullable$1.toNullable(Number_$type, intSToU(a._ck.count)));
        a._ck.q(runOn(this, this.cd));
        this.ad.k();
    }
    cg(a, b) {
        ObjectModelStylesPartManager.ch(this, a, b);
    }
    static ch(a, b, c) {
        c(a, XlsxUtilities.am(b.a));
        ObjectModelCommonPartHelpers.an(a, b.d, SpreadsheetMLMain.zy);
        a.ad.k();
    }
    ci(a) {
        ObjectModelStylesPartManager.cj(this, a);
    }
    static cj(a, b) {
        ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.zf);
    }
    ck(a) {
        SpreadsheetMLMain.zl(this, intSToU(a.e), a.l, a.h, a.j, a.d, a.b);
        this.ad.k();
    }
    cl(a) {
        SpreadsheetMLMain.zm(this, Nullable$1.toNullable(Number_$type, intSToU(a._cl.count)));
        a._cl.q(runOn(this, this.ck));
        this.ad.k();
    }
    cm(a) {
        SpreadsheetMLMain.zn(this, Nullable$1.toNullable(Number_$type, intSToU(a._cm.count)));
        a._cm.q((b) => this.dq(b, true));
        this.ad.k();
    }
    cn(a) {
        SpreadsheetMLMain.zo(this, Nullable$1.toNullable(Number_$type, intSToU(a._cn.count)));
        a._cn.q((b) => this.dq(b, false));
        this.ad.k();
    }
    co() {
        let a = this.a6._by;
        if (a._palette$i.isCustom == false) {
            return;
        }
        SpreadsheetMLMain.z1(this);
        this.c5();
        this.ad.k();
    }
    cp(a) {
        ObjectModelStylesPartManager.cq(this, a);
    }
    static cq(a, b) {
        ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.aaz);
    }
    cr(a, b) {
        ObjectModelStylesPartManager.cs(this, a, b, SpreadsheetMLMain.g5);
    }
    static cs(a, b, c, d) {
        let e = new DxfInfo(1, b, c);
        SpreadsheetMLMain.aa3(a, d);
        ObjectModelCommonPartHelpers.as(a, e.a);
        ObjectModelStylesPartManager.c7(a, e.g, true);
        ObjectModelStylesPartManager.cz(a, e.e);
        ObjectModelStylesPartManager.ca(a, e.b);
        ObjectModelStylesPartManager.ce(a, e.c);
        ObjectModelStylesPartManager.dc(a, e.f);
        a.ad.k();
    }
    ct(a) {
        SpreadsheetMLMain.aa4(this, Nullable$1.toNullable(Number_$type, intSToU(a._g.count)));
        a._g.q((b) => this.cr(a, b));
        this.ad.k();
    }
    cu(a) {
        ObjectModelStylesPartManager.cv(this, a);
    }
    static cv(a, b) {
        let t1 = a.d._z;
        L0: while (true) {
            switch (t1) {
                case 1:
                    ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.aa7);
                    break;
                case 0:
                    ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.ac5);
                    break;
                default:
                    t1 = 1;
                    continue L0;
            }
            break;
        }
    }
    cw(a) {
        ObjectModelStylesPartManager.cx(this, a);
    }
    static cx(a, b) {
        ObjectModelCommonPartHelpers.an(a, b, SpreadsheetMLMain.abj);
    }
    cy(a) {
        ObjectModelStylesPartManager.cz(this, a);
    }
    static cz(a, b) {
        if (b == null) {
            return;
        }
        SpreadsheetMLMain.abn(a);
        ObjectModelStylesPartManager.da(a, b.d);
        ObjectModelStylesPartManager.c3(a, b.b);
        a.ad.k();
    }
    c0(a) {
        SpreadsheetMLMain.abo(this, Nullable$1.toNullable(Number_$type, intSToU(a._co.count)));
        a._co.q(runOn(this, this.cy));
        this.ad.k();
    }
    c1(a) {
        SpreadsheetMLMain.abv(this, Nullable$1.toNullable(Number_$type, intSToU(a._h.count)));
        a._h.q((b) => ObjectModelCommonPartHelpers.ar(this, b));
        this.ad.k();
    }
    c2(a) {
        ObjectModelStylesPartManager.c3(this, a);
    }
    static c3(a, b) {
        if (b == null) {
            return;
        }
        SpreadsheetMLMain.abz(a, b.e, b.q, b.s, b.u, b.w, b.j);
        for (let c of fromEnum(b.h)) {
            ObjectModelStylesPartManager.dh(a, c);
        }
        a.ad.k();
    }
    c4() {
        SpreadsheetMLMain.ab1(this);
        this.ad.k();
    }
    c5() {
        SpreadsheetMLMain.ab8(this);
        let a = this.a6._by._palette$i;
        for (let b = 0; b < 8 + 56; b++) {
            this.dd(ExcelUtils.g1(a._ae(b)));
        }
        this.ad.k();
    }
    c6(a, b) {
        ObjectModelStylesPartManager.c7(this, a, b);
    }
    static c7(a, b, c) {
        if (b == null) {
            return;
        }
        let d = b.c;
        if (c) {
            d = WorkbookFormatCollection.ak(d);
        }
        SpreadsheetMLMain.acg(a, d, b.b);
        a.ad.k();
    }
    c8(a) {
        let b = a._cp.count;
        if (b == 0) {
            return;
        }
        SpreadsheetMLMain.ach(this, Nullable$1.toNullable(Number_$type, intSToU(b)));
        a._cp.q((c) => this.c6(c, false));
        this.ad.k();
    }
    c9(a) {
        ObjectModelStylesPartManager.da(this, a);
    }
    static da(a, b) {
        if (b == null) {
            return;
        }
        SpreadsheetMLMain.act(a, XlsxUtilities.ba(b.j));
        ObjectModelStylesPartManager.cx(a, b.e);
        ObjectModelStylesPartManager.cc(a, b.b);
        a.ad.k();
    }
    db(a) {
        ObjectModelStylesPartManager.dc(this, a);
    }
    static dc(a, b) {
        if (b == null || b.e) {
            return;
        }
        SpreadsheetMLMain.ac1(a, b.j, b.h);
        a.ad.k();
    }
    dd(a) {
        let b = intSToU(ExcelUtils.cx(a));
        b = b & 16777215;
        SpreadsheetMLMain.ac4(this, Nullable$1.toNullable(ST_UnsignedIntHex.$, new ST_UnsignedIntHex(1, b)));
        this.ad.k();
    }
    de(a) {
        ObjectModelStylesPartManager.df(this, a);
    }
    static df(a, b) {
        let t1 = a.d._z;
        L0: while (true) {
            switch (t1) {
                case 1:
                    ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.adw);
                    break;
                case 0:
                    ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.aca);
                    break;
                default:
                    t1 = 1;
                    continue L0;
            }
            break;
        }
    }
    dg(a) {
        ObjectModelStylesPartManager.dh(this, a);
    }
    static dh(a, b) {
        SpreadsheetMLMain.adx(a, b.g);
        ObjectModelCommonPartHelpers.an(a, b.c, SpreadsheetMLMain.zy);
        a.ad.k();
    }
    di(a) {
        SpreadsheetMLMain.adz(this);
        this.c8(a);
        this.c1(a);
        this.c0(a);
        this.cf(a);
        this.cm(a);
        this.cn(a);
        this.cl(a);
        this.ct(a);
        this.dl(a);
        this.co();
        this.ad.k();
    }
    dj(a, b) {
        let c = a._aa(b);
        SpreadsheetMLMain.ad7(this, b.name, void 0, void 0, Nullable$1.toNullable(Number_$type, intSToU(c._k)));
        ExcelUtils.fm(KeyValuePair$2.$.specialize(WorksheetTableStyleArea_$type, Number_$type), c, (d) => this.dk(b, d));
        this.ad.k();
    }
    dk(a, b) {
        SpreadsheetMLMain.ad8(this, XlsxUtilities.a4(b.key), a._ak(b.key).getValueOrDefault1(1), Nullable$1.toNullable(Number_$type, b.value));
        this.ad.k();
    }
    dl(a) {
        let b = this.a6._by;
        let c = b._customTableStyles$i;
        SpreadsheetMLMain.aea(this, Nullable$1.toNullable(Number_$type, intSToU(c.count)), b.defaultTableStyle.name, "PivotStyleLight16");
        ExcelUtils.fm(WorksheetTableStyle.$, c, (d) => this.dj(a, d));
        this.ad.k();
    }
    dm(a) {
        ObjectModelStylesPartManager.dn(this, a);
    }
    static dn(a, b) {
        ObjectModelStylesPartManager.ch(a, b, SpreadsheetMLMain.aee);
    }
    dp() {
        SpreadsheetMLMain.aek(this);
        this.ad.k();
    }
    dq(a, b) {
        let c = ExcelUtils.bx(a.i, 2);
        let d = ExcelUtils.bx(a.i, 8);
        let e = ExcelUtils.bx(a.i, 16);
        let f = ExcelUtils.bx(a.i, 4);
        let g = ExcelUtils.bx(a.i, 1);
        let h = ExcelUtils.bx(a.i, 32);
        let i = b;
        SpreadsheetMLMain.aer(this, a.v, a.t, a.r, a.o, a.p, a.m, a.k, g == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, g), f == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, f), e == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, e), d == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, d), c == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, c), h == i ? Nullable$1.toNullable(Boolean_$type, null) : Nullable$1.toNullable(Boolean_$type, h));
        this.b9(a.b);
        this.db(a.d);
        this.ad.k();
    }
    get a6() {
        return ObjectModelStylesPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelStylesPartManager.$t = markType(ObjectModelStylesPartManager, 'ObjectModelStylesPartManager', ExcelStylesPartManager.$);
ObjectModelStylesPartManager.a8 = new ObjectModelStylesPartManager();
/**
 * @hidden
 */
export class ExcelThemeDocumentManager extends ExcelWorkbookDocumentManager {
    constructor(a, b, c, d, e, f, g) {
        super(a, b, c, d, e, f, g);
    }
    _bh() {
        super._bh();
        this._bl(ObjectModelThemeManagerPartManager.a6);
        this._bl(ObjectModelThemePartManager.bc);
    }
    _s() {
        throw new NotImplementedException(0);
    }
}
ExcelThemeDocumentManager.$t = markType(ExcelThemeDocumentManager, 'ExcelThemeDocumentManager', ExcelWorkbookDocumentManager.$);
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007 extends WorkbookLoadManager {
    constructor(a, b, c, d) {
        super(a, ExcelUtils.ee(b));
        this._an = new WorkbookSerializationDataExcel2007();
        this._a8 = null;
        this._ax = null;
        this._ay = null;
        this._aj = null;
        this._ak = null;
        this._a9 = null;
        this._ba = null;
        this._az = null;
        this._a0 = null;
        this._a1 = null;
        this._a3 = null;
        this._a2 = null;
        this._au = false;
        this._av = false;
        this._a8 = new List$1(ColorInfo.$, 0);
        this._ax = new Dictionary$2(String_$type, Array_$type, 0);
        this._ay = new Dictionary$2(Number_$type, UnknownShape.$, 0);
        this._aj = new WorkbookLoadManagerExcel2007_FontCollection();
        this._ak = new WorkbookLoadManagerExcel2007_FontCollection();
        this._a9 = new List$1(WorkbookLoadManagerExcel2007_NamedReferenceInfo.$, 0);
        this._ba = ((() => {
            let $ret = new List$1(WorkbookReferenceBase.$, 0);
            $ret.add(this._b._bb);
            return $ret;
        })());
        this._az = new Dictionary$2(String_$type, List$1.$.specialize(WorksheetShape.$), 0);
        this._a0 = new Dictionary$2(WorksheetShape.$, EG_Anchor.$, 0);
        this._a1 = new Dictionary$2(WorksheetShape.$, CT_Transform2D.$, 0);
        this._a3 = new Dictionary$2(Number_$type, WorkbookStyle.$, 0);
        this._a2 = new Dictionary$2(String_$type, Sheet.$, 0);
        this._au = c == null || c.isDuplicateFormulaParsingOptimized;
        this._an = new WorkbookSerializationDataExcel2007(1, new ObjectModelExcelDocumentManager(0, this, c._d, b, d));
    }
    static staticInit() {
        WorkbookStyleCollection._n = WorkbookLoadManagerExcel2007._bq;
        StandardTableStyleCollection._h = WorkbookLoadManagerExcel2007._af;
        ExcelUtils.co = WorkbookLoadManagerExcel2007._bl;
        Workbook._e1 = WorkbookLoadManagerExcel2007._ah;
        Workbook._e0 = WorkbookLoadManagerExcel2007._ag;
        WorkbookOptionsBase._e = WorkbookOptionsBase._e || (() => new PackageFactory());
    }
    disposeCore(a) {
        if (a) {
            this._ai.dispose();
        }
        super.disposeCore(a);
    }
    _r() {
        if (this._be.count == 0) {
            return null;
        }
        return this._be._inner[0].g;
    }
    _p() {
        this._i.add(this._b._bb);
        return WorkItemExtensions.a(this._ai._n(), () => {
            this._b._n = this._ai._h;
            this._b._o = this._ai._i;
            this._b._gx = this._al.d;
            this._b._gy = this._am.d;
        });
    }
    _z() {
        for (let a of fromEnum(this._bh)) {
            this._y(a.a, a.b);
        }
        for (let b of fromEnum(this._b._namedReferences$i)) {
            if (b._j != null) {
                b._j._cu(this._b);
            }
        }
        super._z();
        this._b._hn((c, d) => {
            let e = new FormulaContext(1, this._b, d);
            let f = WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a1(e, this);
            f.h();
        }, this._b._namedReferences$i, this._b._sheets$i, true);
    }
    _bo(a, b) {
        this._a2.item(b, a);
    }
    _bp(a, b) {
        let c = this._at(b);
        c.b(Tuple$2.$.specialize(Sheet.$, WorksheetShape.$), Boolean_$type, WorkbookLoadManagerExcel2007_ShapeAnchorApplicator.a, Tuple.a(Sheet.$, WorksheetShape.$, a, b));
        this._br(a, b);
        a._p._add3(b);
    }
    _at(a) {
        let b;
        let c = this._a0.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _aq(a) {
        let b;
        let c = this._a1.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _ao(a) {
        let b;
        let c = this._a2.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _ap(a) {
        let b = this._ao(a);
        return b;
    }
    static _bs(a) {
        if (stringIsNullOrEmpty(a) == false && stringStartsWith(a, "=") == false) {
            a = stringInsert(a, 0, "=");
        }
        return {
            p0: a
        };
    }
    _bu(a, b) {
        this._a0.item(a, b);
    }
    _bv(a, b) {
        this._a1.item(a, b);
    }
    static _aw(a, b, c) {
        c = null;
        let d = a.l("dxfId", b);
        if (nullableEquals(d, null)) {
            return {
                ret: false,
                p2: c
            };
        }
        let e;
        if (((() => { let f = tryParseInt32_1(d.value.d, e); e = f.p1; return f.ret; })()) == false) {
            return {
                ret: false,
                p2: c
            };
        }
        if (e < 0 || b._b7._g.count <= e) {
            return {
                ret: false,
                p2: c
            };
        }
        c = b._b7._g._inner[e];
        return {
            ret: true,
            p2: c
        };
    }
    static _bl(a) {
        for (let b of fromEnum(a.getRelationships())) {
            if (b.relationshipType != WorkbookPartManagerBase.a6 && b.relationshipType != WorkbookPartManagerBase.a5) {
                continue;
            }
            let c = PackageUtilities.ak(b);
            let d = a.getPart(c);
            switch (d.contentType) {
                case WorkbookPartManagerBase.a8:
                    {
                        if (b.relationshipType == WorkbookPartManagerBase.a5) {
                            return Nullable$1.toNullable(WorkbookFormat_$type, 6);
                        }
                        return Nullable$1.toNullable(WorkbookFormat_$type, 2);
                    }
                case WorkbookPartManagerBase.a4: return Nullable$1.toNullable(WorkbookFormat_$type, 3);
                case WorkbookPartManagerBase.a3: return Nullable$1.toNullable(WorkbookFormat_$type, 4);
                case WorkbookPartManagerBase.a7: return Nullable$1.toNullable(WorkbookFormat_$type, 5);
                default: break;
            }
        }
        return Nullable$1.toNullable(WorkbookFormat_$type, null);
    }
    static _bq(a) {
        let b = new Workbook(2);
        {
            let c = new WorkbookLoadManagerExcel2007(b, null, new WorkbookLoadOptions(), Nullable$1.toNullable(ST_ConformanceClass_$type, 0));
            try {
                c._ai._bh();
                WorkItemScheduler.b().d(c._ai._m);
                let d = WorkbookLoadManagerExcel2007._ar(c._ai);
                if (d == null) {
                    return;
                }
                WorkItemScheduler.b().d(d.a());
                for (let e of fromEnum(b._styles$i)) {
                    let f = typeCast(WorkbookBuiltInStyle.$, e);
                    if (f == null) {
                        continue;
                    }
                    a.add(f);
                }
            }
            finally {
                if (c != null) {
                    c.dispose();
                }
            }
        }
    }
    static _af(a) {
        let b = new Workbook(2);
        return Async.p(WorkbookLoadManagerExcel2007.$, Base.$, new WorkbookLoadManagerExcel2007(b, null, new WorkbookLoadOptions(), Nullable$1.toNullable(ST_ConformanceClass_$type, 0)), (c) => {
            c._av = true;
            c._ai._bh();
            WorkItemScheduler.b().d(c._ai._m);
            let d = WorkbookLoadManagerExcel2007._as(c._ai, a);
            if (d != null) {
                return d.a();
            }
            return null;
        });
    }
    static _ah(a, b, c) {
        return Async.n(WorkbookLoadManagerExcel2007.$, new WorkbookLoadManagerExcel2007(a, b, c, Nullable$1.toNullable(ST_ConformanceClass_$type, null)), (d) => d._o());
    }
    static _ag(a, b, c) {
        if (c == null) {
            c = new PackageFactory();
        }
        return Async.n(ExcelThemeDocumentManager.$, new ExcelThemeDocumentManager(a, new WorkbookLoadManagerExcel2007_FontCollection(), new WorkbookLoadManagerExcel2007_FontCollection(), c, b, true, Nullable$1.toNullable(ST_ConformanceClass_$type, 0)), (d) => d._n());
    }
    static _bj() {
        return new MemoryStream(2, Convert.fromBase64String(WorkbookLoadManagerExcel2007._bm));
    }
    static _ar(a) {
        let b = new MemoryStream(0);
        {
            let c = WorkbookLoadManagerExcel2007._bj();
            try {
                if (c == null) {
                    return null;
                }
                try {
                    {
                        let d = new GZipStream(c, 0);
                        try {
                            let e = new Array(4096);
                            while (true) {
                                let f = d.read(e, 0, e.length);
                                if (f == 0) {
                                    break;
                                }
                                b.write(e, 0, f);
                            }
                        }
                        finally {
                            if (d != null) {
                                d.dispose();
                            }
                        }
                    }
                }
                catch (g) {
                }
            }
            finally {
                if (c != null) {
                    c.dispose();
                }
            }
        }
        b.position = 0;
        return ObjectModelStylesPartManager.a8.e(a, b);
    }
    static _bk() {
        return new MemoryStream(2, Convert.fromBase64String(WorkbookLoadManagerExcel2007._bn));
    }
    static _as(a, b) {
        let c = new MemoryStream(0);
        {
            let d = WorkbookLoadManagerExcel2007._bk();
            try {
                if (d == null) {
                    return null;
                }
                try {
                    {
                        let e = new GZipStream(d, 0);
                        try {
                            let f = new Array(4096);
                            while (true) {
                                let g = e.read(f, 0, f.length);
                                if (g == 0) {
                                    break;
                                }
                                c.write(f, 0, g);
                            }
                        }
                        finally {
                            if (e != null) {
                                e.dispose();
                            }
                        }
                    }
                }
                catch (h) {
                }
            }
            finally {
                if (d != null) {
                    d.dispose();
                }
            }
        }
        c.position = 0;
        return new WorkbookLoadManagerExcel2007_PresetTableStylesPartManager(b).e(a, c);
    }
    _br(a, b) {
        let c = typeCast(WorksheetShapeGroupBase.$, b);
        if (c == null) {
            return;
        }
        for (let d of fromEnum(c._shapes$i)) {
            this._bt(a, d, c);
            this._br(a, d);
        }
        c._d3();
    }
    _bt(a, b, c) {
        let d = this._aq(b);
        let e = this._aq(c);
        let f = this._ae(d, b._b6, e, c._getBoundsInTwips());
        b._setBoundsInTwips(a, f);
    }
    get _bb() {
        return this._an.b;
    }
    get _bc() {
        return this._an.c;
    }
    get _bd() {
        return this._an.d;
    }
    get _be() {
        return this._an.e;
    }
    get _ai() {
        return this._an.a;
    }
    get _bf() {
        return this._an.f;
    }
    get _bg() {
        return this._a8;
    }
    get _a4() {
        return this._ax;
    }
    get _a5() {
        return this._ay;
    }
    get _al() {
        return this._aj;
    }
    get _am() {
        return this._ak;
    }
    get _bh() {
        return this._a9;
    }
    get _bi() {
        return this._ba;
    }
    get _a6() {
        return this._az;
    }
    get _a7() {
        return this._a3;
    }
}
WorkbookLoadManagerExcel2007.$t = markType(WorkbookLoadManagerExcel2007, 'WorkbookLoadManagerExcel2007', WorkbookLoadManager.$);
WorkbookLoadManagerExcel2007._bm = "H4sICCUTME8AAHByZXNldENlbGxTdHlsZXMueG1sAO1cac/SQBD+buJ/aOoRNWrvSxEPFDUxajyiiRrTFxastl0sRcFf724L292yvbSwmCgxpdt9Zp55ZnbaQnkHd9dRKP0AyTKA8R1Zu6nKEogncBrE8zvy2zfjG64sLVM/nvohjMEdeQOW8t3h+XODZboJwesvAKQSMhEv78hf0nRxS1GWky8g8pc34QLE6MgMJpGfot1kriwXCfCnSwyKQkVXVVuJ/CCWh4N4FY2jdClN4CpO78gmGZLyzdMpGtRlKbc2glNE5fOVy99XML19Md9cky5cv3BB/Xz19t6Bj1eyQx85h/LtjXyTYe99viorPPda2T3tkXXSya7ZJqybakVk26PNwd29W0/DKNMoed5zVmtf2WZ0OJjBuEisrsn5yHCw/CX98ENUcxqeP4EhTKQUlQ7ynY3EfgTyGSM/DM6SAA/O/CgIN/mwjgdwte3mRUEMk8w59nBsP2fK8XytGnyp7Z0xdoMjxsDo5e75Msq+IuTKb/blf23yZTX76i0u44i+tMP64vlJ5md35PEYNXJN7VBzf+XMG6nI39Gc2dbRIjPQy+k1sjOl0aExPqLD8X3n4dHk7N9Zw3Lr1VdNYHjB9RtYUJ82B796rZNjqdh0ouxwRsvs5pvssiYIQ3JZYxhyPjIcLPw0BUk8RjvS9v2bzQL5itH1c24HHWqcPU/8jaZb7QFLGAZTzGI+olM3sh+NR48yMxT0L40is84BjD564I16NzoaeV7fRnX86tnofQu/ejaaCdCbpttFY/ZuT0oDvIrUm47nea5mu67rmYZmmpnIZ9vpQTwFa4BuVezeZNpnYHnon+F6to6IqKZrHZ2BgQg4luVamqeb6L92HAb92xOdVUt4Vi3hWbV7tyc6q7bwrNrCs+r0bk90Vh3hWXWEZ9Xt3Z7orLrCs+oKz2pvF587e8Kz6gnPqtdjVrPNEmFgMgXJ9o4u+wh1NzYchGCWInwSzL/gbQoXCj6YpjBCb6aBP4exH2IPOaIVUsLfoKBg0i/B5BtyNtm/xs4nHsoD0dDEdWQ6puqYlm7rfbqOwDRYRdh3l6vd1t6pCGO58kMLBU/NebZFZHOzkFoC0Mxd7C0RfcRo4FenGDNElxgzQKcYM0S3GBuqaApXZyEo+UH/XFX9s3rJDXZTsxFT6Nkagua2i/UPNK1L0QMdv7rUTY7oUDc5oEvdZIi/6T608b2W01Lv1v13+2aJgCAMX2Nj72fk9GHjDwTXM+r7VRV/vRrv3uKTzvZtbiffUapBeiVI8heLcPN8FZ2BZJx9g1uM4lNdsfcgQxX798NgHkcgpgAvE5iCSYqeBvjH+Jj/+dTy0f7z+c/nP5//fP7zOUk+dgUfrQOfv/FvnYIeXvv8jGF8OB6mfipEzFMhop0KEeNEiFBrxxCxdoYDfzcFP8CbBhP8qAK6w8FMF2SqFMLJN7C7u1DWs+ownIow9A5hNNKukdGt8G8I9n/QNNbw8Qo+ens+fTLQqFtVQxAFapGbgihQ97oWTcHkUOjJJdVSbNqldTiXJuXySFFWXXTYHVbcXxGgrrocmoBzuJidE+sy1PpyaT5uPR8Y9yXIqbXdqk+2vA58/sa/RvV9r70gfUpA1YTWISeHoqAJouBRHESdgWkOok7BFAVRp2CKgiWIAp0J+wQ4OII4UBRc8RREdUj64lxUi6Q5iOqRFAVRLZKiIKpD0pkQ1SJpDqJ6JEVBVIukKIjqkHQmRLVImoOoHkl9eCCqRVIURHVIj+IgqEXqqoh7rD//hFKhnqmgn7Bgnq8ohiX8Cy4c5SXphnR/MkEOUbLXs0xyXPyrIEQPnG0LUalH6jukabBIswlpEKTDIt0mpLlDWhqDNPUmpEWQFou0m5A2QbIKWVyFzH1t8SAbp9aELLQ1WaTVhCy0dVmk14QstNVZhYwmZKGtzSKdBmShra2y2nIVsrnaamycehOy0NZikXYTstDWY+NUm5CFtgaLNJuQhbYOi3SbkIW2GqstV6FyN2CrR+dWT1lPndWTWzdlJW0Ww62YsoYqqwS3VsrqmSyGu47K691lMVwNHvjT3XzdYTXjxJL9cnayCn3cz4nWGovTubgvYPJNGqFRAjNYmMGFwfAZ+AHCzySzRZK2ewGegE9ftfgiy1V4rRZPMm5X4fVaPMm+W4Wvj59UgqZWGTBrDdjEQKWCVq0BhxiolNDmG4gin2Sv1O0qAdIH9RMB0SFXeVklCfqDRhtCstTi6jC0L43ND3cNPFovQj/2U5hspDdgnZKKZmvD4kY3hmEIf4Kp9AT98iEJg/gbqSw2Mdzl+hjCYr2WSpGryxPg47/xJGkkQPasodWidOLLYFFOHcogKJNFuXUok6BKDLlC7Kmns+pxXT2NF6uUADxWPm7/eIY8gCnbt0rrh1taz8EqTXyC0Uur3uVi0FV5AWFrXuUDUkBYlUTjAl6sUkoAo9RJuA3wJUjwSYVUD32OqOgYr+DPUs/WWG71PbvA64RpFV6rxZM6tKrwei2eVKRThTfq8EXP9qrwZi2+aNkVAjYloGjZJQUbWvabIA0Bwdos1uIiYOoXK6R0IcFFvPOTGC17toGW+kX+o4/irhDtFH+Obvgb2AlhytROAAA=";
WorkbookLoadManagerExcel2007._bn = "H4sICPuS504AAHByZXNldFRhYmxlU3R5bGVzLnhtbADs3d2uEjEQAOB7E9+B7L0ui/1bg3hhNDHRxKgvgLIqEVgD6++reeEj+QoW8J/qdNrptk1q4g/nzE6nB858x6Q7fP38ZX77w3YzedftD+t+d6tqrk+rSbd73q/Wu5e3qrfDi2uqur24emX+Zt8duuHp8tmmezJ83HSHib5wd7hVvRqGNzfr+vD8VbddHq73b7qd/syLfr9dDvrh/mV90NcuV4dXXTdsN/VsOhX1drneVYv5r3QPu9X67XamFvPVhxeHyfP+7W64Vcnq9Hgxf7HebBbzN8th6Pa7e/rB5Pu/n358092qDv1mvap02Ms7/abfTwZdi/5wW02G9THP9Dpv9a8bqhWzVjVTpnhVL+bPcOH1b+vrRy/Of+n6siqy3w06qY58/nva5nTt8ZNho5/1+1W3X8yH/s3koJ94/ent6amv/rqoPV2kw/Sf54uwS/0V/c9IgidOtq1+CoRSqmU3GsZmpycOF2584n7sfNO9GH58vYZXp++d5/9IfkMnl5wr3rQzpn+fN6oT6I3u1y9f+eU5ZTg9fV5p9PXHzQ1Dv/XKc06xmOsGNqyfLzdeyX4kWcxf9fv1J/3S8Ez4K81fL+Lznwf9dfzZAH/2vKaarLoXy7eb7832vP7fnbL9GfVo/a4fvkf9+veD4/PUiOr3JSa75bHsy6ZbTd7oC48bqX523j+uvLvRG94Nk+H0/fD+Vb/pTlmqid7G/dUxvP53/KtuqXf+uH//M1z8L3zo9Rfs92j+v+gX6/1h0N9ob7e7nxew/12wWV7E3wAX0OU8GfbrN792PAOvOS/y12XnF8av6/54cNCPTCRefEySMqlwAilfgbIo0sEXwmhrJlXyTCockyokk6qiYRLMY8ckmMaSSTAPhkkwGZZJMGEmTMrCZJ0uk9LApCBlUuIEkr4CZVGkgy+E0dZMyuSZlDgmZUgmZUXDJJjHjkkwjSWTYB4Mk2AyLJNgwkyYFIXJOl0mhYFJTsqkwAkkfAXKokgHXwijrZkUyTMpcEyKkEyKioZJMI8dk2AaSybBPBgmwWRYJsGEmTDJC5N1ukxyA5OMlEmOE4j7CpRFkQ6+EEZbM8mTZ5LjmOQhmeQVDZNgHjsmwTSWTIJ5MEyCybBMggkzYZIVJut0mWQGJm+QMslwAjFfgbIo0sEXwmhrJlnyTDIckywkk6yiYRLMY8ckmMaSSTAPhkkwGZZJMGEmTN4oTNbpMnnDwOSMlMnpj9fxNf1CZro1iZkQQk7lDS7bUydDxoMGZVKmgzGE0dZUNslT+ftT0bCjfkyyqWR8Js6t8hky3gtLlIgY9lC24QFzUyorimaFojpdimYGippgFIVrFKQUjVOmuYdPvTuzCU4fHCNWZPBy1b/VL1caL8fe2bmyH5LY/ARwjvy5KQzrLj9reBeWEjxNgadOF57GAM+0wDNGmaGaoTId38+zouThwe2swDMmPNMCT50uPNNLeJq2wDNGmaGaoTQdiM+zouThwe2swDMiPE1b4KmTheeIzMXHaOebgB2avKNnUmaoZihMR8zzrCh5eHA7K/CMCU+ZGAIuEBEeZYCHdmII2KHJO3omZYZqhqZjhD5nBSNWlDw8uJ0VeMaEp8zgABeICI80wEM7gwPs0OQdPZMyQzVDZjoGnWdFycOD21mBZ0x4ylQLcIGI8AgDPLRTLcAOTd7RMykzVDM0VZtpRcnDg9tZFHhGORAegLRyKPzUjMu0C3CBiHxyA5+00y5a3B2yre8dslkUGaqd4w4pl4rgin4X/FdLfv66+ruuSIC77eZslMWGPPx23Q/qvuzW575sG6GnTkJPcxK6DNoAF4goNDMITTtoQ+HwU774ZVFkqH6NO81dKoIrSl1ot92kK7TCCa2K0N5Clxkf4AIRhb5hEJp2xofE4Sd98cuiyFD9GnfsvVQEV5S60G67SVdoiRNaFqG9hS6jT8AFIgo9MwhNO/pE4PATvvhlUWSofo27P6BUBFeUutBuu0lXaIETWhShvYUuM2LABSIK3RiEpp0Rw3H4cV/8sigyVL/G3UhRKoIrSl1ot92kKzTHCc2L0N5Cl2E64AIRhTYM06GdpcNw9jFf+7IoMlS7xt1wUiqCK0odaLfdpAs0wwHNCtC+QJeZQ+AC8Xw2jBwKN3FonDdwyKTMUA0bd2tOqQiuKHWi3XaTLtHgLYYktyQWpH9PVeYzgQvEQ9ownol2OlOL+6G4dfmh2JvoduQiHd5BiTDa+hbgNpI6uDuI7M2wvX+3rWje/RDMY/c2UGAay3eIAvOcU9gaBKbLg6cyxQlcIB5PhiFOtDOcFK7zK9/On0WRMCEho615UpF4wt0+Q8+Tqmh4AvPY8QSmseQJzIPjCUyXB09l1hO4QDyeDKOeaCc9SVznl76dP4siYUJCRlvzJCPxhLt3hJ4nWdHwBOax4wlMY8kTmAfHE5guD57KLCVwgXg8GUYp0U5SErjOL3w7fxZFwoSEjLbmSUTiCXfjBD1PoqLhCcxjxxOYxpInMA+OJzBdHjyVQULgAvF4MswRoh0jxHGdn/t2/iyKhAkJGW3NE4/EE+6uAXqeeEXDE5jHjicwjSVPYB4cT2C6PHgqU3TABeLxZBiiQztDh+E6P/Pt/FkUCRMSMtqaJxaJJ9yZeXqeWEXDE5jHjicwjSVPYB4cT2C6PHgqI2TABeLxZJggQztABjz7SnJW1hsocFnyMmFGQkZbE5XHG3jQE4VyCIMNShQXNnKyoQwvAReIZ8OP2SW/ntQZrQ0t7n8Fre//CrIoEu7dIaOtXXA71f1rKdybLrW+N/rYtv0W0/ZbRNtvMW2/Rb/hUut0A1CbBRXn1lOoABeIQcVPF/7+EO2UK4Xrwsq3C2dRJNxjQ0ZbU+F2wtqVCjUWFQpDhUJQoTBUKDQVyokKlREVZeASuEA8KqYXVDS085YkrgtL3y6cRZFwjw0ZbU2F22lnVyrkWFRIDBUSQYXEUCHRVEgnKmQ+VDRl9g+4QDQqji78/SHa2T8C14WFbxfOoki4x4aMtqbC7eSxKxViLCoEhgqBoEJgqBBoKoQTFSIjKsoEGnCBeFSoSypoJ9BwXBfmvl04iyLhHhsy2poKt1PArlTwsajgGCo4ggqOoYKjqeBOVPCMqCjTYMAF4lEhL6mgnQbDcF2Y+XbhLIqEe2zIaGsq3E7kulLBxqKCYahgCCoYhgqGpoI5UcEyoqJMZgEXiEeFuKSCdjILeIyU/NhpJmXCfTZktDUXbqdjXbloxuIixcOvNlw0TlzkcWD2HFQmpYALfGvvXHLbhoEAui/QO+QG1oeiyH2P0Av0k1WBFmh7f7S2WseRBMyPQw6D8Zohh0z8XmzNDNvpYjnqIrzWxThsvsC/FV8SEnd/lkrz4NMY9WZBYFNz9L+Inu4v2AO8DcmrJNr3OCaIolK6rF14h6cTemcavTON3olE7xUJSpwcXuhN0MOd3jhD/Hr+8uP71/sPETSxRUYxxbZWGVWEoyp2XUsy1RQJSfhS8+CzGPVmQdBcczT6cwJvG3I/tG8yTPBDpRxZu36YXQ8X18PmgoMeJqEeViTWS82Dz1zUmwWBcM3RaD3wtiHXQ/smvwQ9VMqLtauHyfVwcT1sLjjoYRTqISKxXmoefLai3iwIhGuORuuBtw25Hto32SXooVIurF09jK6Hi+thc8FBD4NQDwsS66XmwWco6s2CQLjmaLQeeNuQ66F9k1uCHirlv9rVw+B6uLgeNhfs9ZCFdghIqpeaB5+UqDcLguCao9F24G1Dbof2PWYJdqiU8mrWDtnlcHE53Eywd0MSumFEMr3UPPgMRL1ZEPzWHI12A28bcjd4c1cwndeOG5K74eJuuJlg74ayJdaZVpKWpSVpXQR5juD8UGAxhZzXdby+1pRnkjXqzoOUKy+ZlhYCTGdWy1laEPhzEIZrRyZeGQ0u0Kx+4VgYXbYuOtHQmaTo7CLIc5glFEeszYPkGi8ZlhYCDExWn1haEPhzEIZrh+9ezgwu0Izvx2rmssXMKw2dqxSdXQR5DrMVxRFr8yC5xstmpYUAA5PV3JUWBP4chOHa4bvXH4MLNOP7sfw4FOV7pKEzStHZRZDnMIsojlibB8k1XjoqLQQYmKyOrLQg8OcgDNcO34Pz/WKV78ea4bko3xcaOhcpOrsI8hxmC4oj1uZBco2XT0oLAQYmq40qLQj8OQjDtcP32fl+scr3Y9HvVJTvgYbOIEVnF0GewyygOGJtHiTXeBmhtBBgYLJ6n9KCwJ+DMFw7fPfL9sEFmvH9WLVb9jplsOtm8S6dnYQJZ0xqjkbSiJeLCbcSJWceUhIt8XsSBmWHsH4PMbhAM8K+Knz98Onnt7EsYR+yPZb89zWnHKecxiGkrRiSNhwEVxdBwmDSHF02171wnju/PSdruUT77JT4n51M4Pj2Bnccgwu0wPHtd3PEcdlL4SONdFFKui6ChJGpOdo0jvntzljLRRqO41vAsV+9Di7QDMfDHsdl710PNNAFKei6CBImpuZo0zTmt49hLRdoNA5vgMb5yb8OBhdoheO8p3HZq80fvzWdQ84pTjHGdVjnZd0+lhLH67wrwWWLhwlTU3O0aSLzy/JZy4Ff7Bd8EGCGyX6LOLhAKyKnPZGVytvPn11/Jo3WeUfWDVGru4j+Ls76jJxf2TfcO42QHuv1dAjXziioU7gObHkMO2XcjoE0+vwYXoyOOQTqA175EdCsTrmPcuA8RpZviPNUxYz/vQECuEAr/697/yu1P0AROTGILPZ/3RC1gKe/iw78X+8QTPs/kfyf3P8d+J9zqZ0Z/3uDDHCBVv6Pe/8rtcdAEXllEFns/7ohagFPfxcd+L/eIZj2/0ry/+r+78D/nDQeM/73BirgAq38v+z9r9Q+BUXkyCCy2P91Q9QCnv4uOvB/vUMw7f9I8n90/3fgf861lGb87w12wAVa+T/s/a/UXgdF5IVBZLH/64aoBTz9XXTg/3qHYNr/C8n/i/u/A/9zEsfN+N8bMIELtPL/vPe/UvslFJEDg8hi/9cNUQt4+rvowP/1DsG0/wPJ/8H934H/OTfLmvG/V2SBC7Ty/7T3f9nmMeN/uGCAfB+M57HY/jUD1IOd7h46MH+tIzDt/fu+cKVl9+GUyjI3f23zP/yawvXXtITp72te1rSk215pw3v4f8H7G4ELtPp/Ybz+Bf18/vX8++PDqPfv/gCziItLhJABAA==";
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor extends FormulaTokenVisitor {
    constructor() {
        super();
        this.az = null;
    }
    g() {
        this.az = null;
        super.g();
    }
    x(a) {
        let b = a.o;
        if (((() => { let c = this.a2(b); b = c.p0; return c.ret; })())) {
            a.o = b;
        }
    }
    static a1(a, b) {
        if (WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0 == null) {
            WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0 = new WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor();
        }
        WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0.az = b;
        WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0.b = a;
        return WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0;
    }
    a2(a) {
        if (a == null || a.i || a.e == null || stringIsNullOrEmpty(a.e.x)) {
            return {
                ret: false,
                p0: a
            };
        }
        let b;
        if (((() => { let c = tryParseInt32_1(a.e.x, b); b = c.p1; return c.ret; })()) == false) {
            return {
                ret: false,
                p0: a
            };
        }
        if (b < 0 || this.az._i.count <= b) {
            return {
                ret: false,
                p0: a
            };
        }
        let c = this.az._i._inner[b];
        a = a.g(c);
        return {
            ret: true,
            p0: a
        };
    }
}
WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.$t = markType(WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor, 'WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor', FormulaTokenVisitor.$);
WorkbookLoadManagerExcel2007_UpdateIndexedWorkbookReferencesVisitor.a0 = null;
/**
 * @hidden
 */
export class WorkbookLoadManagerExcel2007_PresetTableStylesPartManager extends ObjectModelStylesPartManager {
    constructor(a) {
        super();
        this.dr = null;
        this.dr = a;
    }
    z(a) {
        if (a == "http://purl.oclc.org/ooxml/spreadsheetml/main/presetTableStyles") {
            return 3;
        }
        if (this.s.a(WorksheetTableStyle.$) != null) {
            return super.z(a);
        }
        let b = this.a6;
        b._b7._g.clear();
        b._b7._bf.clear();
        b._b7._h.clear();
        b._b7._bg.clear();
        let c = new WorksheetTableStyle(IOPath.getFileName(a), false);
        c._s = true;
        if (stringStartsWith(c.name, "Table")) {
            this.dr.add(c);
        }
        this.s.k(c);
        return 3;
    }
    t() {
        let a = super.t();
        return WorkItemExtensions.g(Base.$, a, () => {
            for (let b of fromEnum(this.dr)) {
                b._s = false;
            }
            return WorkItemExtensions.m(Base.$, a);
        });
    }
}
WorkbookLoadManagerExcel2007_PresetTableStylesPartManager.$t = markType(WorkbookLoadManagerExcel2007_PresetTableStylesPartManager, 'WorkbookLoadManagerExcel2007_PresetTableStylesPartManager', ObjectModelStylesPartManager.$);
/**
 * @hidden
 */
export class WorkbookSaveManagerExcel2007 extends WorkbookSaveManager {
    constructor(a, b, c, d) {
        super(a, ExcelUtils.ee(b), c);
        this._cb = null;
        this._ca = new WorkbookSerializationDataExcel2007();
        this._cd = null;
        this._ce = null;
        this._cu = 0;
        this._cj = null;
        this._cg = null;
        this._cc = null;
        this._ch = null;
        this._cf = null;
        this._cb = new Dictionary$2(WorksheetCellFormatData.$, Number_$type, 0);
        this._cd = ((() => {
            let $ret = new Dictionary$2(WorkbookReferenceBase.$, Number_$type, 0);
            $ret.addItem(a._bb, 0);
            return $ret;
        })());
        this._ce = new Dictionary$2(ExcelImage.$, Uri.$, 0);
        this._cj = new List$1(SerializationNumberFormatInfo.$, 0);
        this._cg = new Dictionary$2(Base.$, Number_$type, 0);
        this._ca = new WorkbookSerializationDataExcel2007(1, new ObjectModelExcelDocumentManager(1, this, c._d, b, Nullable$1.toNullable(ST_ConformanceClass_$type, d)));
    }
    static staticInit() {
        Workbook._e3 = WorkbookSaveManagerExcel2007._b7;
        WorkbookOptionsBase._e = WorkbookOptionsBase._e || (() => new PackageFactory());
    }
    disposeCore(a) {
        if (a) {
            this._b9.dispose();
        }
        super.disposeCore(a);
    }
    _a6(a) {
        let b;
        let c = this._cb.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _a7(a) {
        let b;
        let c = this._at.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _bk() {
        let a = new Dictionary$2(FillInfo.$, Number_$type, 0);
        let b = new Dictionary$2(BorderInfo.$, Number_$type, 0);
        this._cr(((() => {
            let $ret = new FillInfo();
            $ret.d = ((() => {
                let $ret = new PatternFillInfo();
                $ret.j = Nullable$1.toNullable(FillPatternStyle_$type, 0);
                return $ret;
            })());
            return $ret;
        })()), a);
        this._cr(((() => {
            let $ret = new FillInfo();
            $ret.d = ((() => {
                let $ret = new PatternFillInfo();
                $ret.j = Nullable$1.toNullable(FillPatternStyle_$type, 17);
                return $ret;
            })());
            return $ret;
        })()), a);
        this._cq(BorderInfo.a(this, new WorksheetCellFormatData(null, 1)), b);
        let c = this._b._styles$i.normalStyle;
        this._cx(c, a, b);
        this._cl.add(new StyleInfo(1, this, c));
        for (let d of fromEnum(this._b._styles$i)) {
            if (d == c || d._p == false) {
                continue;
            }
            this._cx(d, a, b);
            this._cl.add(new StyleInfo(1, this, d));
        }
        for (let e of fromEnum(this._b._styles$i._u())) {
            if (e == c) {
                continue;
            }
            this._cx(e, a, b);
            this._cl.add(new StyleInfo(1, this, e));
        }
        let f = this._b._ca;
        this._cw(f._p, a, b);
        for (let g of fromEnum(f)) {
            if (g == f._p) {
                continue;
            }
            this._cw(g, a, b);
        }
        if (this._b._ct) {
            for (let h of fromEnum(this._b._b2.m())) {
                this._cj.add(((() => {
                    let $ret = new SerializationNumberFormatInfo();
                    $ret.c = intSToU(h);
                    $ret.b = this._b._b2.ad(h);
                    return $ret;
                })()));
            }
        }
    }
    _br() {
        super._br();
        if (this._b._dz != null) {
            let a = 1;
            for (let b of fromEnum(this._b._dz.values)) {
                this._ci.addItem(b, a++);
            }
        }
    }
    get__ag() {
        return true;
    }
    get _ag() {
        return this.get__ag();
    }
    _b4(a) {
        let b = super._b4(a);
        a = b.p0;
        let c = typeCast(WorksheetChart.$, a);
        if (c != null) {
            return {
                p0: a
            };
        }
        let d = typeCast(UnknownShape.$, a);
        if (d != null) {
            if (d._eg != null && d._ef != null) {
                a = null;
                return {
                    p0: a
                };
            }
            if (d._b3 == null) {
                a = null;
                return {
                    p0: a
                };
            }
        }
        return {
            p0: a
        };
    }
    _p() {
        return this._b9._r();
    }
    _bl(a) {
        let b = ConditionalFormattingSerializer.a(a);
        if (b != null) {
            if (this._cc == null) {
                this._cc = new Dictionary$2(Worksheet.$, ConditionalFormattingSerializer.$, 0);
            }
            this._cc.addItem(a, b);
            b.w(this, a._conditionalFormats$i);
        }
    }
    _bm(a) {
        if (a._sparklineGroups$i.count > 0) {
            if (this._ch == null) {
                this._ch = new Dictionary$2(Worksheet.$, SparklinesSerializer.$, 0);
            }
            this._ch.addItem(a, new SparklinesSerializer(a));
        }
    }
    static _cy(a, b, c) {
        if (ExcelUtils.a9(a)) {
            b = 2;
            c = null;
            return {
                p1: b,
                p2: c
            };
        }
        let d = typeCast(StringElementIndex.$, a);
        if (d != null) {
            b = 4;
            c = d.c.toString();
        }
        else if (ExcelUtils.bb(a)) {
            b = 2;
            try {
                let e = Convert.toDouble3(a);
                c = numberToString(e, Workbook._fd);
            }
            catch (f) {
                c = a.toString();
            }
        }
        else if (typeCast(Boolean_$type, a) !== null) {
            b = 0;
            let g = Convert.toInt321(a);
            c = g.toString();
        }
        else {
            if (typeCast(ErrorValue.$, a) !== null) {
                b = 3;
            }
            else {
                b = 5;
            }
            c = a.toString();
        }
        return {
            p1: b,
            p2: c
        };
    }
    _cs(a) {
        let b = null;
        if (this._cf == null) {
            this._cf = new Dictionary$2(DisplayUnit_$type, String_$type, 0);
            let c = ExcelUtils.ef("LD_Chart_AxisDisplayUnits");
            let d = stringSplit(c, [","], 1);
            for (let f = 0; f < d.length; f++) {
                let e = d[f];
                let g = stringSplit(e, [":"], 1);
                if (g.length != 2) {
                    continue;
                }
                g[0].trim();
                g[1].trim();
                let h;
                if (((() => { let i = EnumUtil.tryParse$1(DisplayUnit_$type, g[0], true, h); h = i.p2; return i.ret; })()) == false) {
                    continue;
                }
                if (((() => { let i = this._cf.tryGetValue(h, b); b = i.p1; return i.ret; })()) == false) {
                    this._cf.addItem(h, g[1]);
                }
            }
        }
        if (((() => { let i = this._cf.tryGetValue(a, b); b = i.p1; return i.ret; })()) == false) {
            return null;
        }
        return b;
    }
    _ct(a) {
        if (a == null) {
            return null;
        }
        let b = new GetFormulaStringInfo(this._ci, true);
        let c = XLSXFormulaStringGenerator.bx(a, b);
        let d = c.a2();
        if (d.d == false) {
            return stringEmpty();
        }
        return d.b;
    }
    _cv(a, b, c, d) {
        d = null;
        c = false;
        let e = b._bg;
        let f;
        if (((() => { let g = this._cg.tryGetValue(e, f); f = g.p1; return g.ret; })()) == false) {
            c = true;
            d = a._c2(b);
            this._cg.item(e, f = this._cu++);
        }
        return {
            ret: f,
            p2: c,
            p3: d
        };
    }
    _b6(a, b) {
        return Async.d(WorksheetShape.$, a, (c) => {
            let d = typeCast(WorksheetShapeGroupBase.$, c);
            return Async.g(d != null, () => this._b6(d._shapes$i, b), () => {
                let e = typeCast(IWorksheetImage_$type, c);
                if (e == null) {
                    return null;
                }
                let f = e.image;
                if (f == null) {
                    return null;
                }
                let g = null;
                let h;
                return WorkItemExtensions.a(Async.g(((() => { let i = this._ce.tryGetValue(f, h); h = i.p1; return i.ret; })()), () => {
                    if (((() => { let i = b.tryGetValue(f, g); g = i.p1; return i.ret; })()) == false) {
                        g = this._b9._a1(h, this._b9._cd());
                    }
                    return null;
                }, () => WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this._b9._b0(f, e.preferredFormat), (i) => {
                    let j = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), i);
                    h = j.c;
                    g = j.d;
                    this._ce.addItem(f, h);
                })), () => b.item(f, g));
            });
        });
    }
    _cq(a, b) {
        let c;
        if (((() => { let d = b.tryGetValue(a, c); c = d.p1; return d.ret; })())) {
            return c;
        }
        c = this._ck.count;
        b.item(a, c);
        this._ck.add(a);
        return c;
    }
    _cr(a, b) {
        let c;
        if (((() => { let d = b.tryGetValue(a, c); c = d.p1; return d.ret; })())) {
            return c;
        }
        c = this._co.count;
        b.item(a, c);
        this._co.add(a);
        return c;
    }
    _cw(a, b, c) {
        this._bd(a._bp, a);
        let d = ((() => {
            let $ret = new FormatInfo();
            $ret.r = Nullable$1.toNullable(Number_$type, intSToU(this._cr(FillInfo.a(this, a), b)));
            $ret.o = Nullable$1.toNullable(Number_$type, intSToU(this._cq(BorderInfo.a(this, a), c)));
            $ret.i = a.formatOptions;
            $ret.b = AlignmentInfo.d(a);
            $ret.t = Nullable$1.toNullable(Number_$type, a._bp._r.value);
            $ret.d = ProtectionInfo.a(a);
            $ret.v = Nullable$1.toNullable(Number_$type, intSToU(a._cs));
            return $ret;
        })());
        if (a._b1 == 1) {
            this._cm.add(d);
        }
        else {
            if (a.style != null) {
                d.p = Nullable$1.toNullable(Number_$type, this._a7(a.style));
            }
            this._cb.addItem(a, this._cn.count);
            this._cn.add(d);
        }
    }
    _cx(a, b, c) {
        this._at.addItem(a, this._cm.count);
        this._cw(a._i, b, c);
    }
    static _b7(a, b, c) {
        if (a._cw) {
            return OleDataSpaces.a(b, a._l, a._f(), (d) => WorkbookSaveManagerExcel2007._b8(a, d, c));
        }
        else {
            return WorkbookSaveManagerExcel2007._b8(a, b, c);
        }
    }
    static _b8(a, b, c) {
        let d = null;
        return WorkItemExtensions.c(Async.n(WorkbookSaveManagerExcel2007.$, new WorkbookSaveManagerExcel2007(a, b, c, a.currentFormat == 6 ? 1 : 0), (e) => WorkItemExtensions.a(e._o(), () => d = e._b9._b)), () => {
            let e = typeCast(Package.$, d);
            if (e != null) {
                return e._h;
            }
            return null;
        });
    }
    get _ck() {
        return this._ca.b;
    }
    get _cl() {
        return this._ca.c;
    }
    get _cm() {
        return this._ca.d;
    }
    get _cn() {
        return this._ca.e;
    }
    get _b9() {
        return this._ca.a;
    }
    get _ci() {
        return this._cd;
    }
    get _co() {
        return this._ca.f;
    }
    get _cp() {
        return this._cj;
    }
}
WorkbookSaveManagerExcel2007.$t = markType(WorkbookSaveManagerExcel2007, 'WorkbookSaveManagerExcel2007', WorkbookSaveManager.$);
/**
 * @hidden
 */
export class CT_CommonTypeBase extends Base {
    constructor(a) {
        super();
        this.a = 0;
        this.a = a;
    }
}
CT_CommonTypeBase.$t = markType(CT_CommonTypeBase, 'CT_CommonTypeBase');
/**
 * @hidden
 */
export class CT_Extension extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "uri":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "uri";
            d = c;
            a.ad.h(e, d);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    d(a, b, c, d) {
    }
}
CT_Extension.$t = markType(CT_Extension, 'CT_Extension');
/**
 * @hidden
 */
export class CT_ExtensionList extends Base {
    constructor() {
        super();
        this.c = null;
    }
    get e() {
        if (this.c == null) {
            this.c = new List$1(CT_Extension.$, 0);
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 599:
                this.e.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static d(a) {
        return a != null ? a.e : null;
    }
    static a(a) {
        if (a == null) {
            return null;
        }
        let b = ((() => {
            let $ret = new CT_ExtensionList();
            $ret.c = a;
            return $ret;
        })());
        return b;
    }
}
CT_ExtensionList.$t = markType(CT_ExtensionList, 'CT_ExtensionList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_X extends Base {
    constructor() {
        super();
        this.b = 0;
        this.b = 0;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "v":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "v";
        d = c.toString();
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_X.$t = markType(CT_X, 'CT_X');
/**
 * @hidden
 */
export class CT_Boolean extends CT_CommonTypeBase {
    constructor(a) {
        super(a);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
        this.l = null;
        this.j = false;
        this.i = false;
        this.f = false;
        this.n = null;
        this.o = 0;
        this.l = new List$1(CT_X.$, 0);
    }
    get k() {
        return this.m.hasValue ? this.m.value : true;
    }
    static d(a, b) {
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = false;
        let e = false;
        let f = false;
        let g = null;
        let h = 0;
        let i = CT_Boolean.p(a, c, d, e, f, g, h);
        c = i.p1;
        d = i.p2;
        e = i.p3;
        f = i.p4;
        g = i.p5;
        h = i.p6;
        let j = new CT_Boolean(b);
        j.n = g;
        j.o = h;
        j.f = f;
        j.i = e;
        j.j = d;
        j.m = c;
        return j;
    }
    static p(a, b, c, d, e, f, g) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = false;
        d = false;
        e = false;
        f = null;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(h.d));
                    break;
                case "v":
                    c = ST_OnOff.e(h.d);
                    break;
                case "u":
                    d = ST_OnOff.e(h.d);
                    break;
                case "f":
                    e = ST_OnOff.e(h.d);
                    break;
                case "c":
                    f = h.d;
                    break;
                case "cp":
                    g = parseUInt32_1(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static r(a, b, c, d) {
        CT_Boolean.s(a, b, c, d.a, d.n, d.o, d.f, d.i, d.j, d.k);
    }
    static s(a, b, c, d, e, f, g, h, i, j) {
        a.ad.p(b, c);
        let k = null;
        let l = null;
        switch (d) {
            case 2:
                if (e != null) {
                    l = "c";
                    k = e;
                    a.ad.h(l, k);
                }
                l = "cp";
                k = f.toString();
                a.ad.h(l, k);
                l = "f";
                k = ST_OnOff.g(g);
                a.ad.h(l, k);
                l = "u";
                k = ST_OnOff.g(h);
                a.ad.h(l, k);
                l = "v";
                k = ST_OnOff.g(i);
                a.ad.h(l, k);
                break;
            default:
                l = "val";
                k = ST_OnOff.g(j);
                a.ad.h(l, k);
                break;
        }
    }
    q(a, b, c, d, e) {
        CT_Boolean.r(a, d, e, this);
        switch (this.a) {
            case 2:
                if (this.l.count > 0) {
                    for (let f of fromEnum(this.l)) {
                        CT_X.e(a, SpreadsheetMLMain.r3, f.b);
                        c.k();
                    }
                }
                break;
        }
        c.k();
    }
    setProperty(a, b) {
        switch (a) {
            case 1888:
                this.l.add(typeCast(CT_X.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? stringFormat("{0} ({1})", a.typeName, this.k) : super.toString();
    }
    static g(a) {
        return a != null ? a.k : false;
    }
    static b(a) {
        let b = new CT_Boolean(3);
        b.m = Nullable$1.toNullable(Boolean_$type, a);
        return b;
    }
}
CT_Boolean.$t = markType(CT_Boolean, 'CT_Boolean', CT_CommonTypeBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_UnsignedInt extends Base {
    constructor() {
        super(...arguments);
        this.g = 0;
    }
    static c(a, b = false) {
        let c;
        let d = CT_UnsignedInt.h(a, c, b);
        c = d.p1;
        return ((() => {
            let $ret = new CT_UnsignedInt();
            $ret.g = c;
            return $ret;
        })());
    }
    static h(a, b, c = false) {
        b = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    let e = d.d;
                    if (stringIsNullOrEmpty(e)) {
                        return {
                            p1: b
                        };
                    }
                    if (((() => { let f = tryParseUInt32_2(e, 511, CultureInfo.invariantCulture, b); b = f.p3; return f.ret; })())) {
                        return {
                            p1: b
                        };
                    }
                    if (c && e.charAt(0) == '-') {
                        e = e.substr(1);
                        if (((() => { let f = tryParseUInt32_2(e, 511, CultureInfo.invariantCulture, b); b = f.p3; return f.ret; })())) {
                            return {
                                p1: b
                            };
                        }
                    }
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static j(a, b, c, d) {
        a.ad.p(b, c);
        let e = null;
        let f = null;
        f = "val";
        e = d.toString();
        a.ad.h(f, e);
    }
    i(a, b, c, d, e) {
        CT_UnsignedInt.j(a, d, e, this.g);
        c.k();
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? stringFormat("{0} ({1})", a.typeName, this.g) : super.toString();
    }
    static e(a) {
        return a != null ? a.g : 0;
    }
    static a(a) {
        let b = ((() => {
            let $ret = new CT_UnsignedInt();
            $ret.g = a;
            return $ret;
        })());
        return b;
    }
}
CT_UnsignedInt.$t = markType(CT_UnsignedInt, 'CT_UnsignedInt');
/**
 * @hidden
 */
export class CT_Double extends Base {
    constructor() {
        super(...arguments);
        this.f = 0;
    }
    static c(a) {
        let b;
        let c = CT_Double.h(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new CT_Double();
            $ret.f = b;
            return $ret;
        })());
    }
    static h(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static j(a, b, c, d) {
        a.ad.p(b, c);
        let e = null;
        let f = null;
        f = "val";
        e = d.toString();
        a.ad.h(f, e);
    }
    i(a, b, c, d, e = null) {
        if (e == null) {
            e = "c";
        }
        CT_Double.j(a, d, e, this.f);
        c.k();
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static d(a) {
        return a != null ? a.f : 0;
    }
    static a(a) {
        let b = ((() => {
            let $ret = new CT_Double();
            $ret.f = a;
            return $ret;
        })());
        return b;
    }
}
CT_Double.$t = markType(CT_Double, 'CT_Double');
/**
 * @hidden
 */
export class CommonAttributes extends Base {
}
CommonAttributes.$t = markType(CommonAttributes, 'CommonAttributes');
/**
 * @hidden
 */
export class SerializationUtils extends Base {
    static x(a, b = false) {
        let c = DMLUtils.p(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(31, c);
        }
        a.s.k(c);
    }
    static ac(a, b = false) {
        let c = DMLUtils.q(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(36, c);
        }
        a.s.k(c);
    }
    static ae(a, b = false) {
        let c = DMLUtils.f(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(38, c);
        }
        a.s.k(c);
    }
    static am(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(131, c);
        }
        a.s.k(c);
    }
    static an(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(132, c);
        }
        a.s.k(c);
    }
    static ao(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(133, c);
        }
        a.s.k(c);
    }
    static av(a, b = false) {
        let c = new CT_ComplementTransform();
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(326, c);
        }
        a.s.k(c);
    }
    static a7(a, b = false) {
        let c = new CT_GammaTransform();
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(695, c);
        }
        a.s.k(c);
    }
    static ba(a, b = false) {
        let c = new CT_GrayscaleTransform();
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(731, c);
        }
        a.s.k(c);
    }
    static bc(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(733, c);
        }
        a.s.k(c);
    }
    static bd(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(734, c);
        }
        a.s.k(c);
    }
    static be(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(735, c);
        }
        a.s.k(c);
    }
    static bk(a, b = false) {
        let c = DMLUtils.o(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(802, c);
        }
        a.s.k(c);
    }
    static bl(a, b = false) {
        let c = DMLUtils.q(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(803, c);
        }
        a.s.k(c);
    }
    static bm(a, b = false) {
        let c = DMLUtils.b(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(804, c);
        }
        a.s.k(c);
    }
    static bo(a, b = false) {
        let c = new CT_InverseTransform();
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(845, c);
        }
        a.s.k(c);
    }
    static bp(a, b = false) {
        let c = new CT_InverseGammaTransform();
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(846, c);
        }
        a.s.k(c);
    }
    static bs(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(941, c);
        }
        a.s.k(c);
    }
    static bt(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(942, c);
        }
        a.s.k(c);
    }
    static bu(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(943, c);
        }
        a.s.k(c);
    }
    static b2(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1331, c);
        }
        a.s.k(c);
    }
    static b3(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1332, c);
        }
        a.s.k(c);
    }
    static b4(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1333, c);
        }
        a.s.k(c);
    }
    static b8(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1407, c);
        }
        a.s.k(c);
    }
    static b9(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1408, c);
        }
        a.s.k(c);
    }
    static ca(a, b = false) {
        let c = DMLUtils.l(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1409, c);
        }
        a.s.k(c);
    }
    static ce(a, b = false) {
        let c = DMLUtils.p(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1459, c);
        }
        a.s.k(c);
    }
    static cl(a, b = false) {
        let c = DMLUtils.p(a);
        let d = [CT_HslColor.$, CT_PresetColor.$, CT_SRgbColor_DML.$, CT_SchemeColor_DML.$, CT_ScRgbColor.$, CT_SystemColor.$, b ? CT_ColorStyleVariation.$ : CT_StyleColor.$];
        let e = SerializationUtils.j(a, d);
        if (e != null) {
            e.setProperty(1744, c);
        }
        a.s.k(c);
    }
    static as(a) {
        let b = SerializationUtils.i(CT_ColorChangeEffect.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.a = c;
        a.s.k(c);
    }
    static au(a) {
        let b = SerializationUtils.i(CT_ColorChangeEffect.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.c = c;
        a.s.k(c);
    }
    static a5(a) {
        let b = SerializationUtils.i(CT_StretchInfoProperties.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.u(a);
        b.a = c;
        a.s.k(c);
    }
    static br(a) {
        let b = SerializationUtils.i(CT_GradientFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = CT_LinearShadeProperties.f(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_LinearShadeProperties();
            $ret.a = c;
            $ret.c = d;
            return $ret;
        })());
        b.b.a = f;
        a.s.k(f);
    }
    static by(a) {
        let b = SerializationUtils.i(CT_GradientFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c;
        let d = CT_PathShadeProperties.f(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_PathShadeProperties();
            $ret.c = c;
            return $ret;
        })());
        b.b.b = e;
        a.s.k(e);
    }
    static ck(a) {
        let b = SerializationUtils.i(CT_GradientFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.u(a);
        b.c = c;
        a.s.k(c);
    }
    static bf(a) {
        let b = SerializationUtils.i(CT_GradientStopList.$, a);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveFixedPercentage();
        let d = CT_GradientStop.e(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GradientStop();
            $ret.d = c;
            return $ret;
        })());
        b.c.add(e);
        a.s.k(e);
    }
    static a6(a) {
        let b = SerializationUtils.i(CT_PathShadeProperties.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.u(a);
        b.a = c;
        a.s.k(c);
    }
    static ak(a) {
        let b = SerializationUtils.i(CT_PatternFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.a = c;
        a.s.k(c);
    }
    static a2(a) {
        let b = SerializationUtils.i(CT_PatternFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.c = c;
        a.s.k(c);
    }
    static a0(a) {
        let b = Nullable$1.toNullable(ST_EffectContainerType_$type, null);
        let c = null;
        let d = CT_EffectContainer.l(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ((() => {
            let $ret = new CT_EffectContainer();
            $ret.g = b;
            $ret.i = c;
            return $ret;
        })());
        let f = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let g = SerializationUtils.j(a, f);
        if (g != null) {
            g.setProperty(558, e);
        }
        a.s.k(e);
    }
    static a9(a) {
        let b = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = CT_GradientFillProperties.l(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ((() => {
            let $ret = new CT_GradientFillProperties();
            $ret.g = b;
            $ret.i = c;
            return $ret;
        })());
        let f = [CT_TextCharacterProperties_DML.$, CT_FillOverlayEffect.$, CT_LineProperties_DML.$, CT_ShapeProperties_DML.$];
        let g = SerializationUtils.j(a, f);
        if (g != null) {
            g.setProperty(725, e);
        }
        a.s.k(e);
    }
    static cb(a) {
        let b = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$, CT_EffectStyleItem.$];
        let c = new CT_Scene3D();
        let d = SerializationUtils.j(a, b);
        if (d != null) {
            d.setProperty(1423, c);
        }
        a.s.k(c);
    }
    static cg(a) {
        let b = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$, CT_EffectStyleItem.$];
        let c = SerializationUtils.e(a);
        let d = SerializationUtils.j(a, b);
        if (d != null) {
            d.setProperty(1564, c);
        }
        a.s.k(c);
    }
    static a8(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c;
        let d = CT_GlowEffect.g(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GlowEffect();
            $ret.e = c;
            return $ret;
        })());
        b.e = e;
        a.s.k(e);
    }
    static y(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_AlphaBiLevelEffect.d(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaBiLevelEffect();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(32, f);
        a.s.k(f);
    }
    static z(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_AlphaCeilingEffect();
        c.setProperty(33, d);
        a.s.k(d);
    }
    static aa(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_AlphaFloorEffect();
        c.setProperty(34, d);
        a.s.k(d);
    }
    static ab(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_AlphaInverseEffect();
        c.setProperty(35, d);
        a.s.k(d);
    }
    static ad(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = CT_AlphaModulateFixedEffect.e(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaModulateFixedEffect();
            $ret.b = d;
            return $ret;
        })());
        c.setProperty(37, f);
        a.s.k(f);
    }
    static af(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_AlphaReplaceEffect.d(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaReplaceEffect();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(40, f);
        a.s.k(f);
    }
    static al(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_BiLevelEffect.d(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BiLevelEffect();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(117, f);
        a.s.k(f);
    }
    static ap(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$, CT_EffectList.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = CT_BlurEffect.h(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_BlurEffect();
            $ret.c = e;
            $ret.e = d;
            return $ret;
        })());
        c.setProperty(134, g);
        a.s.k(g);
    }
    static ar(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = CT_ColorChangeEffect.i(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ColorChangeEffect();
            $ret.f = d;
            return $ret;
        })());
        c.setProperty(279, f);
        a.s.k(f);
    }
    static at(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_ColorReplaceEffect();
        c.setProperty(285, d);
        a.s.k(d);
    }
    static az(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_DuotoneEffect();
        c.setProperty(546, d);
        a.s.k(d);
    }
    static a4(a, b = null) {
        let c;
        let d = CT_FillOverlayEffect.f(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_FillOverlayEffect();
            $ret.c = c;
            return $ret;
        })());
        if (b == null) {
            b = [CT_Blip_DML.$, CT_EffectList.$];
        }
        let f = SerializationUtils.j(a, b);
        if (f != null) {
            f.setProperty(633, e);
        }
        a.s.k(e);
    }
    static bb(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d = new CT_GrayscaleEffect();
        c.setProperty(633, d);
        a.s.k(d);
    }
    static bi(a, b = null) {
        if (b == null) {
            b = [CT_Blip_DML.$];
        }
        let c = SerializationUtils.j(a, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_HSLEffect.k(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_HSLEffect();
            $ret.d = d;
            $ret.h = e;
            $ret.f = f;
            return $ret;
        })());
        c.setProperty(799, h);
        a.s.k(h);
    }
    static bn(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = CT_InnerShadowEffect.m(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_InnerShadowEffect();
            $ret.g = c;
            $ret.k = d;
            $ret.i = e;
            return $ret;
        })());
        b.g = g;
        a.s.k(g);
    }
    static bx(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let k = Nullable$1.toNullable(Boolean_$type, null);
        let l = CT_OuterShadowEffect.af(a, c, d, e, f, g, h, i, j, k);
        c = l.p1;
        d = l.p2;
        e = l.p3;
        f = l.p4;
        g = l.p5;
        h = l.p6;
        i = l.p7;
        j = l.p8;
        k = l.p9;
        let m = ((() => {
            let $ret = new CT_OuterShadowEffect();
            $ret.n = j;
            $ret.p = c;
            $ret.r = e;
            $ret.t = d;
            $ret.v = h;
            $ret.x = i;
            $ret.z = k;
            $ret.ab = f;
            $ret.ad = g;
            return $ret;
        })());
        b.i = m;
        a.s.k(m);
    }
    static b1(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c = 0;
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = CT_PresetShadowEffect.l(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_PresetShadowEffect();
            $ret.h = e;
            $ret.j = d;
            $ret.d = c;
            return $ret;
        })());
        b.k = g;
        a.s.k(g);
    }
    static b5(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Number_$type, null);
        let m = Nullable$1.toNullable(Number_$type, null);
        let n = Nullable$1.toNullable(Number_$type, null);
        let o = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let p = Nullable$1.toNullable(Boolean_$type, null);
        let q = CT_ReflectionEffect.ar(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
        c = q.p1;
        d = q.p2;
        e = q.p3;
        f = q.p4;
        g = q.p5;
        h = q.p6;
        i = q.p7;
        j = q.p8;
        k = q.p9;
        l = q.p10;
        m = q.p11;
        n = q.p12;
        o = q.p13;
        p = q.p14;
        let r = ((() => {
            let $ret = new CT_ReflectionEffect();
            $ret.o = o;
            $ret.q = c;
            $ret.s = i;
            $ret.u = h;
            $ret.w = f;
            $ret.y = g;
            $ret.aa = j;
            $ret.ac = m;
            $ret.ae = n;
            $ret.ag = p;
            $ret.ai = d;
            $ret.ak = e;
            $ret.am = k;
            $ret.ao = l;
            return $ret;
        })());
        b.m = r;
        a.s.k(r);
    }
    static cf(a) {
        let b = SerializationUtils.i(CT_EffectList.$, a);
        if (b == null) {
            return;
        }
        let c;
        let d = CT_SoftEdgesEffect.d(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_SoftEdgesEffect();
            $ret.a = c;
            return $ret;
        })());
        b.o = e;
        a.s.k(e);
    }
    static aq(a) {
        let b = SerializationUtils.i(CT_Scene3D.$, a);
        if (b == null) {
            return;
        }
        let c = 0;
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = CT_Camera.l(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_Camera();
            $ret.g = d;
            $ret.d = c;
            $ret.i = e;
            return $ret;
        })());
        b.c = g;
        a.s.k(g);
    }
    static bq(a) {
        let b = SerializationUtils.i(CT_Scene3D.$, a);
        if (b == null) {
            return;
        }
        let c = 0;
        let d = 0;
        let e = CT_LightRig.h(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_LightRig();
            $ret.c = d;
            $ret.e = c;
            return $ret;
        })());
        b.e = f;
        a.s.k(f);
    }
    static ag(a) {
        let b = SerializationUtils.i(CT_Backdrop.$, a);
        if (b == null) {
            return;
        }
        let c = 0;
        let d = 0;
        let e = 0;
        let f = CT_Point3D.h(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_Point3D();
            $ret.a = c;
            $ret.c = d;
            $ret.e = e;
            return $ret;
        })());
        b.c = g;
        a.s.k(g);
    }
    static bw(a) {
        let b = SerializationUtils.i(CT_Backdrop.$, a);
        if (b == null) {
            return;
        }
        let c = SerializationUtils.g(a);
        b.e = c;
    }
    static cm(a) {
        let b = SerializationUtils.i(CT_Backdrop.$, a);
        if (b == null) {
            return;
        }
        let c = SerializationUtils.g(a);
        b.g = c;
        a.s.k(c);
    }
    static b6(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        let e = CT_SphereCoords.h(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        let f = ((() => {
            let $ret = new CT_SphereCoords();
            $ret.a = b;
            $ret.c = c;
            $ret.e = d;
            return $ret;
        })());
        let g = [CT_Camera.$, CT_LightRig.$];
        let h = SerializationUtils.j(a, g);
        if (h != null) {
            h.setProperty(1370, f);
        }
        a.s.k(f);
    }
    static ai(a) {
        let b = SerializationUtils.i(CT_Shape3D.$, a);
        if (b == null) {
            return;
        }
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        let f = CT_Bevel.l(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_Bevel();
            $ret.e = d;
            $ret.g = e;
            $ret.i = c;
            return $ret;
        })());
        b.a = g;
        a.s.k(g);
    }
    static aj(a) {
        let b = SerializationUtils.i(CT_Shape3D.$, a);
        if (b == null) {
            return;
        }
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        let f = CT_Bevel.l(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_Bevel();
            $ret.e = d;
            $ret.g = e;
            $ret.i = c;
            return $ret;
        })());
        b.c = g;
        a.s.k(g);
    }
    static aw(a) {
        let b = SerializationUtils.i(CT_Shape3D.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.e = c;
        a.s.k(c);
    }
    static a1(a) {
        let b = SerializationUtils.i(CT_Shape3D.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_Color_DML();
        b.g = c;
        a.s.k(c);
    }
    static bj(a) {
        let b = CT_HslColor.e(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(800, b);
        }
        a.s.k(b);
    }
    static bz(a) {
        let b = CT_PresetColor.e(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(1272, b);
        }
        a.s.k(b);
    }
    static cc(a) {
        let b = CT_SchemeColor_DML.f(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(1429, b);
        }
        a.s.k(b);
    }
    static cd(a) {
        let b = CT_ScRgbColor.e(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(1431, b);
        }
        a.s.k(b);
    }
    static ch(a) {
        let b = CT_SRgbColor_DML.e(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(1586, b);
        }
        a.s.k(b);
    }
    static ci(a) {
        let b = CT_SystemColor.e(a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_GradientStop.$, CT_SolidColorFillProperties.$, CT_StyleReference.$, CT_FontReference_ChartStyle.$];
        let d = SerializationUtils.j(a, c);
        if (d != null) {
            d.setProperty(1652, b);
        }
        a.s.k(b);
    }
    static ah(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_LineJoinBevel();
        b.p.a = c;
        a.s.k(c);
    }
    static ax(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_DashStopList();
        b.l.a = c;
        a.s.k(c);
    }
    static bh(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.i(a);
        b.a = c;
        a.s.k(c);
    }
    static bv(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.j(a);
        b.p.b = c;
        a.s.k(c);
    }
    static b0(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.t(a);
        b.l.b = c;
        a.s.k(c);
    }
    static b7(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_LineJoinRound();
        b.p.c = c;
        a.s.k(c);
    }
    static cj(a) {
        let b = SerializationUtils.i(CT_LineProperties_DML.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.i(a);
        b.b = c;
        a.s.k(c);
    }
    static ay(a) {
        let b = SerializationUtils.i(CT_DashStopList.$, a);
        if (b == null) {
            return;
        }
        let c = DMLUtils.d(a);
        b.b.add(c);
        a.s.k(c);
    }
    static bg(a) {
        let b = SerializationUtils.i(CT_GradientFillProperties.$, a);
        if (b == null) {
            return;
        }
        let c = ((() => {
            let $ret = new CT_GradientStopList();
            $ret.c = new List$1(CT_GradientStop.$, 0);
            return $ret;
        })());
        b.e = c.c;
        a.s.k(c);
    }
    static a3($t, a, b, c) {
        let d = typeCast(ObjectModelThemePartManager.$, a);
        let e = [CT_BackgroundFillStyleList.$, CT_FillOverlayEffect.$, CT_FillStyleList.$, CT_LineProperties_DML.$];
        let f = SerializationUtils.j(d, e);
        if (f != null) {
            f.setProperty(c, getBoxIfEnum($t, b));
        }
        d.s.k(getBoxIfEnum($t, b));
    }
    static m($t, a, b) {
        let c = b != null ? b : new List$1($t, 0);
        c.add(a);
        return c;
    }
    static h($t, a) {
        if (a == null) {
            return null;
        }
        if (a.count == 0) {
        }
        else if (a.count > 1) {
        }
        return a.count > 0 ? a._inner[0] : null;
    }
    static i($t, a, b = true) {
        let c = a.s.a($t);
        if (b && getBoxIfEnum($t, c) == null) {
            let d = $t.typeName;
        }
        return c;
    }
    static j(a, b, c = false) {
        let d = (e) => {
            let f = typeCast(ISupportSetProperty_$type, e);
            if (f == null) {
                return false;
            }
            for (let h = 0; h < b.length; h++) {
                let g = b[h];
                if (getInstanceType(f) == g) {
                    return true;
                }
            }
            return false;
        };
        let e = typeCast(ISupportSetProperty_$type, a.s.g(d));
        if (c && e == null) {
        }
        return e;
    }
    static a(a, b) {
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = NaN;
        let h = SpreadsheetMLMain.us(a, b, c, d, e, f, g);
        c = h.p2;
        d = h.p3;
        e = h.p4;
        f = h.p5;
        g = h.p6;
        return ((() => {
            let $ret = new ColorInfo();
            $ret.i = c;
            $ret.j = d;
            $ret.k = e;
            $ret.l = f;
            $ret.g = g;
            return $ret;
        })());
    }
    static f(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null);
        let e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        let f = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        let g = Nullable$1.toNullable(ST_TextWrappingType_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Number_$type, null);
        let m = Nullable$1.toNullable(Number_$type, null);
        let n = Nullable$1.toNullable(Boolean_$type, null);
        let o = Nullable$1.toNullable(Boolean_$type, null);
        let p = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        let q = Nullable$1.toNullable(Boolean_$type, null);
        let r = Nullable$1.toNullable(Boolean_$type, null);
        let s = Nullable$1.toNullable(Boolean_$type, null);
        let t = Nullable$1.toNullable(Boolean_$type, null);
        let u = CT_TextBodyProperties_DML.ay(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
        b = u.p1;
        c = u.p2;
        d = u.p3;
        e = u.p4;
        f = u.p5;
        g = u.p6;
        h = u.p7;
        i = u.p8;
        j = u.p9;
        k = u.p10;
        l = u.p11;
        m = u.p12;
        n = u.p13;
        o = u.p14;
        p = u.p15;
        q = u.p16;
        r = u.p17;
        s = u.p18;
        t = u.p19;
        let v = new CT_TextBodyProperties_DML();
        v.l = p;
        v.m = q;
        v.p = k;
        v.r = t;
        v.t = r;
        v.v = o;
        v.x = e;
        v.z = h;
        v.ab = l;
        v.ad = j;
        v.af = b;
        v.ah = n;
        v.aj = m;
        v.al = c;
        v.an = i;
        v.ap = s;
        v.ar = f;
        v.at = d;
        v.av = g;
        return v;
    }
    static d(a) {
        let b = 0;
        let c = null;
        let d = CT_StyleReference.j(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = new CT_StyleReference();
        e.h = b;
        e.c = c;
        return e;
    }
    static c(a) {
        let b = null;
        let c = CT_StyleEntry.ab(a, b);
        b = c.p1;
        let d = new CT_StyleEntry();
        d.k = b;
        return d;
    }
    static b(a) {
        let b;
        let c;
        let d = CT_FontReference_ChartStyle.k(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ((() => {
            let $ret = new CT_FontReference_ChartStyle();
            $ret.h = b;
            $ret.d = c;
            return $ret;
        })());
        return e;
    }
    static e(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
        let f = CT_Shape3D.y(a, b, c, d, e);
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        let g = new CT_Shape3D();
        g.p = d;
        g.r = c;
        g.t = e;
        g.v = b;
        return g;
    }
    static g(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        let e = CT_Vector3D.i(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_Vector3D();
            $ret.b = b;
            $ret.d = c;
            $ret.f = d;
            return $ret;
        })());
    }
    static w(a) {
        let b = new StringBuilder(0);
        b.u("Expecting an instance of one of the following types to be on the context stack:");
        b.t();
        for (let d = 0; d < a.length; d++) {
            let c = a[d];
            b.u(c.typeName);
        }
    }
    static k(a) {
        return a.d._z;
    }
    static t(a) {
        let b = stringSplit(a.toString(), ['/'], 1);
        return b[b.length - 1];
    }
    static s(a) {
        if (stringIsNullOrEmpty(a)) {
            return a;
        }
        let b = '\"';
        let c = '\'';
        let d = '<';
        let e = '>';
        let f = '&';
        let g = new Dictionary$2(String_$type, String_$type, 0);
        g.addItem(b, "&quot;");
        g.addItem(c, "&apos;");
        g.addItem(d, "&lt;");
        g.addItem(e, "&gt;");
        g.addItem(f, "&amp;");
        let h = new StringBuilder(0);
        for (let i = 0; i < a.length; i++) {
            let j = a.charAt(i);
            switch (j) {
                case b:
                case c:
                case d:
                case e:
                case f:
                    h.l(g.item(j));
                    break;
                default:
                    h.h(j);
                    break;
            }
        }
        return h.toString();
    }
    static v(a) {
        if (stringIsNullOrEmpty(a)) {
            return a;
        }
        let b = "&quot;";
        let c = "&apos;";
        let d = "&lt;";
        let e = "&gt;";
        let f = "&amp;";
        a = stringReplace(a, b, "\"");
        a = stringReplace(a, c, "'");
        a = stringReplace(a, d, "<");
        a = stringReplace(a, e, ">");
        a = stringReplace(a, f, "&");
        return a;
    }
    static o(a) {
        return a == 0 ? 0 : intDivide(a, 5);
    }
    static n(a) {
        return a == 0 ? 0 : a / 20;
    }
    static p(a) {
        return a * 5;
    }
    static u(a) {
        if (stringIsNullOrEmpty(a)) {
            return a;
        }
        if (a.charAt(0) == '=') {
            return a.substr(1);
        }
        else {
            return a;
        }
    }
    static l(a) {
        if (!stringIsNullOrEmpty(a)) {
            let b;
            if (((() => { let c = tryParseNumber(a, b); b = c.p1; return c.ret; })())) {
                return true;
            }
            let c;
            if (((() => { let d = tryParseInt32_1(a, c); c = d.p1; return d.ret; })())) {
                return true;
            }
        }
        return false;
    }
    static q(a) {
        if (a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, a.k ? true : false);
    }
    static r(a) {
        if (a.hasValue == false) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        else if (a.value) {
            return Nullable$1.toNullable(Boolean_$type, true);
        }
        else {
            return Nullable$1.toNullable(Boolean_$type, false);
        }
    }
}
SerializationUtils.$t = markType(SerializationUtils, 'SerializationUtils');
/**
 * @hidden
 */
export class CT_SlicerCacheDefinition extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = null;
        this.h = null;
        this.j = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static k(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "name":
                    b = d.d;
                    break;
                case "sourceName":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static l(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "name";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "sourceName";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
}
CT_SlicerCacheDefinition.$t = markType(CT_SlicerCacheDefinition, 'CT_SlicerCacheDefinition');
/**
 * @hidden
 */
export class CT_SlicerCachePivotTable extends Base {
    constructor() {
        super(...arguments);
        this.d = 0;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "tabId":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "name":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "name";
            e = c;
            a.ad.h(f, e);
        }
        f = "tabId";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
}
CT_SlicerCachePivotTable.$t = markType(CT_SlicerCachePivotTable, 'CT_SlicerCachePivotTable');
/**
 * @hidden
 */
export class CT_FormControlPr extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.ay = Nullable$1.toNullable(ST_ObjectType_$type, null);
        this.s = Nullable$1.toNullable(ST_Checked_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.y = Nullable$1.toNullable(ST_DropStyle_$type, null);
        this.aa = Nullable$1.toNullable(Number_$type, null);
        this.ae = Nullable$1.toNullable(Boolean_$type, null);
        this.bi = null;
        this.bk = null;
        this.bm = null;
        this.bo = null;
        this.ag = Nullable$1.toNullable(Boolean_$type, null);
        this.ai = Nullable$1.toNullable(Number_$type, null);
        this.ak = Nullable$1.toNullable(Boolean_$type, null);
        this.am = Nullable$1.toNullable(Boolean_$type, null);
        this.ao = Nullable$1.toNullable(Number_$type, null);
        this.aq = Nullable$1.toNullable(Number_$type, null);
        this.bq = null;
        this.aw = Nullable$1.toNullable(Boolean_$type, null);
        this.av = Nullable$1.toNullable(Boolean_$type, null);
        this.a0 = Nullable$1.toNullable(Number_$type, null);
        this.a4 = Nullable$1.toNullable(Number_$type, null);
        this.a6 = Nullable$1.toNullable(ST_SelType_$type, null);
        this.a8 = Nullable$1.toNullable(ST_TextHAlign_$type, null);
        this.ba = Nullable$1.toNullable(ST_TextVAlign_$type, null);
        this.bc = Nullable$1.toNullable(Number_$type, null);
        this.bg = Nullable$1.toNullable(Number_$type, null);
        this.ac = Nullable$1.toNullable(ST_EditValidation_$type, null);
        this.as = Nullable$1.toNullable(Boolean_$type, null);
        this.be = Nullable$1.toNullable(Boolean_$type, null);
        this.a2 = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get ax() {
        return this.ay;
    }
    set ax(a) {
        this.ay = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get bh() {
        return this.bi;
    }
    set bh(a) {
        this.bi = a;
    }
    get bj() {
        return this.bk;
    }
    set bj(a) {
        this.bk = a;
    }
    get bl() {
        return this.bm;
    }
    set bl(a) {
        this.bm = a;
    }
    get bn() {
        return this.bo;
    }
    set bn(a) {
        this.bo = a;
    }
    get af() {
        return this.ag;
    }
    set af(a) {
        this.ag = a;
    }
    get ah() {
        return this.ai;
    }
    set ah(a) {
        this.ai = a;
    }
    get aj() {
        return this.ak;
    }
    set aj(a) {
        this.ak = a;
    }
    get al() {
        return this.am;
    }
    set al(a) {
        this.am = a;
    }
    get an() {
        return this.ao;
    }
    set an(a) {
        this.ao = a;
    }
    get ap() {
        return this.aq;
    }
    set ap(a) {
        this.aq = a;
    }
    get bp() {
        return this.bq;
    }
    set bp(a) {
        this.bq = a;
    }
    get at() {
        return this.aw;
    }
    set at(a) {
        this.aw = a;
    }
    get au() {
        return this.av;
    }
    set au(a) {
        this.av = a;
    }
    get az() {
        return this.a0;
    }
    set az(a) {
        this.a0 = a;
    }
    get a3() {
        return this.a4;
    }
    set a3(a) {
        this.a4 = a;
    }
    get a5() {
        return this.a6;
    }
    set a5(a) {
        this.a6 = a;
    }
    get a7() {
        return this.a8;
    }
    set a7(a) {
        this.a8 = a;
    }
    get a9() {
        return this.ba;
    }
    set a9(a) {
        this.ba = a;
    }
    get bb() {
        return this.bc;
    }
    set bb(a) {
        this.bc = a;
    }
    get bf() {
        return this.bg;
    }
    set bf(a) {
        this.bg = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get ar() {
        return this.as;
    }
    set ar(a) {
        this.as = a;
    }
    get bd() {
        return this.be;
    }
    set bd(a) {
        this.be = a;
    }
    get a1() {
        return this.a2;
    }
    set a1(a) {
        this.a2 = a;
    }
    static bv(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af) {
        b = Nullable$1.toNullable(ST_ObjectType_$type, null);
        c = Nullable$1.toNullable(ST_Checked_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(ST_DropStyle_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = null;
        j = null;
        k = null;
        l = null;
        m = Nullable$1.toNullable(Boolean_$type, null);
        n = Nullable$1.toNullable(Number_$type, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        p = Nullable$1.toNullable(Boolean_$type, null);
        q = Nullable$1.toNullable(Number_$type, null);
        r = Nullable$1.toNullable(Number_$type, null);
        s = null;
        t = Nullable$1.toNullable(Boolean_$type, null);
        u = Nullable$1.toNullable(Boolean_$type, null);
        v = Nullable$1.toNullable(Number_$type, null);
        w = Nullable$1.toNullable(Number_$type, null);
        x = Nullable$1.toNullable(ST_SelType_$type, null);
        y = Nullable$1.toNullable(ST_TextHAlign_$type, null);
        z = Nullable$1.toNullable(ST_TextVAlign_$type, null);
        aa = Nullable$1.toNullable(Number_$type, null);
        ab = Nullable$1.toNullable(Number_$type, null);
        ac = Nullable$1.toNullable(ST_EditValidation_$type, null);
        ad = Nullable$1.toNullable(Boolean_$type, null);
        ae = Nullable$1.toNullable(Boolean_$type, null);
        af = Nullable$1.toNullable(Boolean_$type, null);
        for (let ag of fromEnum(a.ab.u)) {
            switch (ag.a.e(a.d)) {
                case "objectType":
                    b = Nullable$1.toNullable(ST_ObjectType_$type, XmlNamespaceDefinitionBase.b(ST_ObjectType_$type, ag.d));
                    break;
                case "checked":
                    c = Nullable$1.toNullable(ST_Checked_$type, XmlNamespaceDefinitionBase.b(ST_Checked_$type, ag.d));
                    break;
                case "colored":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "dropLines":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "dropStyle":
                    f = Nullable$1.toNullable(ST_DropStyle_$type, XmlNamespaceDefinitionBase.b(ST_DropStyle_$type, ag.d));
                    break;
                case "dx":
                    g = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "firstButton":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "fmlaGroup":
                    i = ag.d;
                    break;
                case "fmlaLink":
                    j = ag.d;
                    break;
                case "fmlaRange":
                    k = ag.d;
                    break;
                case "fmlaTxbx":
                    l = ag.d;
                    break;
                case "horiz":
                    m = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "inc":
                    n = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "justLastX":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "lockText":
                    p = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "max":
                    q = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "min":
                    r = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "multiSel":
                    s = ag.d;
                    break;
                case "noThreeD":
                    t = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "noThreeD2":
                    u = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "page":
                    v = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "sel":
                    w = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "seltype":
                    x = Nullable$1.toNullable(ST_SelType_$type, XmlNamespaceDefinitionBase.b(ST_SelType_$type, ag.d));
                    break;
                case "textHAlign":
                    y = Nullable$1.toNullable(ST_TextHAlign_$type, XmlNamespaceDefinitionBase.b(ST_TextHAlign_$type, ag.d));
                    break;
                case "textVAlign":
                    z = Nullable$1.toNullable(ST_TextVAlign_$type, XmlNamespaceDefinitionBase.b(ST_TextVAlign_$type, ag.d));
                    break;
                case "val":
                    aa = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "widthMin":
                    ab = Nullable$1.toNullable(Number_$type, parseUInt32_1(ag.d, CultureInfo.invariantCulture));
                    break;
                case "editVal":
                    ac = Nullable$1.toNullable(ST_EditValidation_$type, XmlNamespaceDefinitionBase.b(ST_EditValidation_$type, ag.d));
                    break;
                case "multiLine":
                    ad = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "verticalBar":
                    ae = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                case "passwordEdit":
                    af = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(ag.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y,
            p25: z,
            p26: aa,
            p27: ab,
            p28: ac,
            p29: ad,
            p30: ae,
            p31: af
        };
    }
    static bw(a, b, c = Nullable$1.toNullable(ST_Checked_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(ST_DropStyle_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(ST_EditValidation_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = null, k = null, l = null, m = null, n = Nullable$1.toNullable(Boolean_$type, null), o = Nullable$1.toNullable(Number_$type, null), p = Nullable$1.toNullable(Boolean_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = Nullable$1.toNullable(Number_$type, null), s = Nullable$1.toNullable(Number_$type, null), t = Nullable$1.toNullable(Boolean_$type, null), u = null, v = Nullable$1.toNullable(Boolean_$type, null), w = Nullable$1.toNullable(Boolean_$type, null), x = Nullable$1.toNullable(ST_ObjectType_$type, null), y = Nullable$1.toNullable(Number_$type, null), z = Nullable$1.toNullable(Boolean_$type, null), aa = Nullable$1.toNullable(Number_$type, null), ab = Nullable$1.toNullable(ST_SelType_$type, null), ac = Nullable$1.toNullable(ST_TextHAlign_$type, null), ad = Nullable$1.toNullable(ST_TextVAlign_$type, null), ae = Nullable$1.toNullable(Number_$type, null), af = Nullable$1.toNullable(Boolean_$type, null), ag = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let ah = null;
        let ai = null;
        if (c.hasValue) {
            ai = "checked";
            ah = XmlNamespaceDefinitionBase.f(ST_Checked_$type, c.value);
            a.ad.h(ai, ah);
        }
        if (d.hasValue) {
            ai = "colored";
            ah = ST_OnOff.g(d.value);
            a.ad.h(ai, ah);
        }
        if (e.hasValue) {
            ai = "dropLines";
            ah = e.value.toString();
            a.ad.h(ai, ah);
        }
        if (f.hasValue) {
            ai = "dropStyle";
            ah = XmlNamespaceDefinitionBase.f(ST_DropStyle_$type, f.value);
            a.ad.h(ai, ah);
        }
        if (g.hasValue) {
            ai = "dx";
            ah = g.value.toString();
            a.ad.h(ai, ah);
        }
        if (h.hasValue) {
            ai = "editVal";
            ah = XmlNamespaceDefinitionBase.f(ST_EditValidation_$type, h.value);
            a.ad.h(ai, ah);
        }
        if (i.hasValue) {
            ai = "firstButton";
            ah = ST_OnOff.g(i.value);
            a.ad.h(ai, ah);
        }
        if (j != null) {
            ai = "fmlaGroup";
            ah = j;
            a.ad.h(ai, ah);
        }
        if (k != null) {
            ai = "fmlaLink";
            ah = k;
            a.ad.h(ai, ah);
        }
        if (l != null) {
            ai = "fmlaRange";
            ah = l;
            a.ad.h(ai, ah);
        }
        if (m != null) {
            ai = "fmlaTxbx";
            ah = m;
            a.ad.h(ai, ah);
        }
        if (n.hasValue) {
            ai = "horiz";
            ah = ST_OnOff.g(n.value);
            a.ad.h(ai, ah);
        }
        if (o.hasValue) {
            ai = "inc";
            ah = o.value.toString();
            a.ad.h(ai, ah);
        }
        if (p.hasValue) {
            ai = "justLastX";
            ah = ST_OnOff.g(p.value);
            a.ad.h(ai, ah);
        }
        if (q.hasValue) {
            ai = "lockText";
            ah = ST_OnOff.g(q.value);
            a.ad.h(ai, ah);
        }
        if (r.hasValue) {
            ai = "max";
            ah = r.value.toString();
            a.ad.h(ai, ah);
        }
        if (s.hasValue) {
            ai = "min";
            ah = s.value.toString();
            a.ad.h(ai, ah);
        }
        if (t.hasValue) {
            ai = "multiLine";
            ah = ST_OnOff.g(t.value);
            a.ad.h(ai, ah);
        }
        if (u != null) {
            ai = "multiSel";
            ah = u;
            a.ad.h(ai, ah);
        }
        if (v.hasValue) {
            ai = "noThreeD";
            ah = ST_OnOff.g(v.value);
            a.ad.h(ai, ah);
        }
        if (w.hasValue) {
            ai = "noThreeD2";
            ah = ST_OnOff.g(w.value);
            a.ad.h(ai, ah);
        }
        if (x.hasValue) {
            ai = "objectType";
            ah = XmlNamespaceDefinitionBase.f(ST_ObjectType_$type, x.value);
            a.ad.h(ai, ah);
        }
        if (y.hasValue) {
            ai = "page";
            ah = y.value.toString();
            a.ad.h(ai, ah);
        }
        if (z.hasValue) {
            ai = "passwordEdit";
            ah = ST_OnOff.g(z.value);
            a.ad.h(ai, ah);
        }
        if (aa.hasValue) {
            ai = "sel";
            ah = aa.value.toString();
            a.ad.h(ai, ah);
        }
        if (ab.hasValue) {
            ai = "seltype";
            ah = XmlNamespaceDefinitionBase.f(ST_SelType_$type, ab.value);
            a.ad.h(ai, ah);
        }
        if (ac.hasValue) {
            ai = "textHAlign";
            ah = XmlNamespaceDefinitionBase.f(ST_TextHAlign_$type, ac.value);
            a.ad.h(ai, ah);
        }
        if (ad.hasValue) {
            ai = "textVAlign";
            ah = XmlNamespaceDefinitionBase.f(ST_TextVAlign_$type, ad.value);
            a.ad.h(ai, ah);
        }
        if (ae.hasValue) {
            ai = "val";
            ah = ae.value.toString();
            a.ad.h(ai, ah);
        }
        if (af.hasValue) {
            ai = "verticalBar";
            ah = ST_OnOff.g(af.value);
            a.ad.h(ai, ah);
        }
        if (ag.hasValue) {
            ai = "widthMin";
            ah = ag.value.toString();
            a.ad.h(ai, ah);
        }
        ;
    }
}
CT_FormControlPr.$t = markType(CT_FormControlPr, 'CT_FormControlPr');
/**
 * @hidden
 */
export class CT_ListItems extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get item() {
        return this.d;
    }
    set item(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static f(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_ListItems.$t = markType(CT_ListItems, 'CT_ListItems');
/**
 * @hidden
 */
export class CT_ListItem extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "val";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_ListItem.$t = markType(CT_ListItem, 'CT_ListItem');
/**
 * @hidden
 */
export class CT_DatastoreItem extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "id":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "id";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_DatastoreItem.$t = markType(CT_DatastoreItem, 'CT_DatastoreItem');
/**
 * @hidden
 */
export class CT_SourceConnection extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SourceConnection.$t = markType(CT_SourceConnection, 'CT_SourceConnection');
/**
 * @hidden
 */
export class CT_CacheSourceExt extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_CacheSourceExt.$t = markType(CT_CacheSourceExt, 'CT_CacheSourceExt');
/**
 * @hidden
 */
export class CT_CustomFilters_SML2009 extends Base {
    constructor() {
        super();
        this.c = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "and":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "and";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
}
CT_CustomFilters_SML2009.$t = markType(CT_CustomFilters_SML2009, 'CT_CustomFilters_SML2009');
/**
 * @hidden
 */
export class CT_ProtectedRange_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
        this.l = null;
        this.f = null;
        this.h = null;
        this.n = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.j = null;
        this.p = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    static q(a, b, c, d, e, f, g, h) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = Nullable$1.toNullable(Number_$type, null);
        g = null;
        h = null;
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "password":
                    b = i.d;
                    break;
                case "algorithmName":
                    c = i.d;
                    break;
                case "hashValue":
                    d = i.d;
                    break;
                case "saltValue":
                    e = i.d;
                    break;
                case "spinCount":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "name":
                    g = i.d;
                    break;
                case "securityDescriptor":
                    h = i.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static r(a, b, c, d, e, f, g, h, i) {
        a.ad.p(b, null);
        let j = null;
        let k = null;
        if (c != null) {
            k = "algorithmName";
            j = c;
            a.ad.h(k, j);
        }
        if (d != null) {
            k = "hashValue";
            j = d;
            a.ad.h(k, j);
        }
        if (e != null) {
            k = "password";
            j = e;
            a.ad.h(k, j);
        }
        if (f != null) {
            k = "saltValue";
            j = f;
            a.ad.h(k, j);
        }
        if (g != null) {
            k = "securityDescriptor";
            j = g;
            a.ad.h(k, j);
        }
        if (h.hasValue) {
            k = "spinCount";
            j = h.value.toString();
            a.ad.h(k, j);
        }
        if (i != null) {
            k = "name";
            j = i;
            a.ad.h(k, j);
        }
        ;
    }
}
CT_ProtectedRange_SML2009.$t = markType(CT_ProtectedRange_SML2009, 'CT_ProtectedRange_SML2009');
/**
 * @hidden
 */
export class CT_IgnoredError_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
        this.q = Nullable$1.toNullable(Boolean_$type, null);
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
        this.y = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.ac = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    static ad(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "evalError":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "twoDigitTextYear":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "numberStoredAsText":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "formula":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "formulaRange":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "unlockedFormula":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "emptyCellReference":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "listDataValidation":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "calculatedColumn":
                    j = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static ae(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "calculatedColumn";
            l = ST_OnOff.g(c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "emptyCellReference";
            l = ST_OnOff.g(d.value);
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "evalError";
            l = ST_OnOff.g(e.value);
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "formula";
            l = ST_OnOff.g(f.value);
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "formulaRange";
            l = ST_OnOff.g(g.value);
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "listDataValidation";
            l = ST_OnOff.g(h.value);
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "numberStoredAsText";
            l = ST_OnOff.g(i.value);
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "twoDigitTextYear";
            l = ST_OnOff.g(j.value);
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "unlockedFormula";
            l = ST_OnOff.g(k.value);
            a.ad.h(m, l);
        }
        ;
    }
}
CT_IgnoredError_SML2009.$t = markType(CT_IgnoredError_SML2009, 'CT_IgnoredError_SML2009');
/**
 * @hidden
 */
export class CT_IgnoredErrors_SML2009 extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static f(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_IgnoredErrors_SML2009.$t = markType(CT_IgnoredErrors_SML2009, 'CT_IgnoredErrors_SML2009');
/**
 * @hidden
 */
export class CT_SlicerStyles extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "defaultSlicerStyle":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "defaultSlicerStyle";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SlicerStyles.$t = markType(CT_SlicerStyles, 'CT_SlicerStyles');
/**
 * @hidden
 */
export class CT_SlicerStyle extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SlicerStyle.$t = markType(CT_SlicerStyle, 'CT_SlicerStyle');
/**
 * @hidden
 */
export class CT_SlicerStyleElement extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_SlicerStyleType_$type, d.d);
                    break;
                case "dxfId":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "dxfId";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        f = "type";
        e = XmlNamespaceDefinitionBase.f(ST_SlicerStyleType_$type, d);
        a.ad.h(f, e);
        ;
    }
}
CT_SlicerStyleElement.$t = markType(CT_SlicerStyleElement, 'CT_SlicerStyleElement');
/**
 * @hidden
 */
export class CT_CacheField_SML2009 extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ignore":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "ignore";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
}
CT_CacheField_SML2009.$t = markType(CT_CacheField_SML2009, 'CT_CacheField_SML2009');
/**
 * @hidden
 */
export class CT_PivotHierarchy_SML2009 extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ignore":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "ignore";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
}
CT_PivotHierarchy_SML2009.$t = markType(CT_PivotHierarchy_SML2009, 'CT_PivotHierarchy_SML2009');
/**
 * @hidden
 */
export class CT_OleItem extends Base {
    constructor() {
        super();
        this.g = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
    }
    static i(a, b, c, d, e) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "icon":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "advise":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "preferPic":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static j(a, b, c, d, e, f) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "advise";
            g = ST_OnOff.g(c.value);
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "icon";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "preferPic";
            g = ST_OnOff.g(e.value);
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "name";
            g = f;
            a.ad.h(h, g);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_OleItem.$t = markType(CT_OleItem, 'CT_OleItem');
/**
 * @hidden
 */
export class CT_OleItem_SML2009 extends CT_OleItem {
    constructor() {
        super();
        this.l = null;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    static p(a, b, c, d, e) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "icon":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "advise":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "preferPic":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static q(a, b, c, d, e, f) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "advise";
            g = ST_OnOff.g(c.value);
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "icon";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "preferPic";
            g = ST_OnOff.g(e.value);
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "name";
            g = f;
            a.ad.h(h, g);
        }
        ;
    }
}
CT_OleItem_SML2009.$t = markType(CT_OleItem_SML2009, 'CT_OleItem_SML2009', CT_OleItem.$);
/**
 * @hidden
 */
export class CT_Table_SML2009 extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "altText":
                    b = d.d;
                    break;
                case "altTextSummary":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c = null, d = null) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "altText";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "altTextSummary";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
}
CT_Table_SML2009.$t = markType(CT_Table_SML2009, 'CT_Table_SML2009');
/**
 * @hidden
 */
export class CT_PivotCacheDefinition_SML2009 extends Base {
    constructor() {
        super();
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static o(a, b, c, d, e, f) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "slicerData":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "pivotCacheId":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(g.d, CultureInfo.invariantCulture));
                    break;
                case "supportSubqueryNonVisual":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "supportSubqueryCalcMem":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "supportAddCalcMems":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static p(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "pivotCacheId";
            h = c.value.toString();
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "slicerData";
            h = ST_OnOff.g(d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "supportAddCalcMems";
            h = ST_OnOff.g(e.value);
            a.ad.h(i, h);
        }
        if (f.hasValue) {
            i = "supportSubqueryCalcMem";
            h = ST_OnOff.g(f.value);
            a.ad.h(i, h);
        }
        if (g.hasValue) {
            i = "supportSubqueryNonVisual";
            h = ST_OnOff.g(g.value);
            a.ad.h(i, h);
        }
        ;
    }
}
CT_PivotCacheDefinition_SML2009.$t = markType(CT_PivotCacheDefinition_SML2009, 'CT_PivotCacheDefinition_SML2009');
/**
 * @hidden
 */
export class CT_ConditionalFormat_SML2009 extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.j = Nullable$1.toNullable(ST_Scope_$type, null);
        this.l = Nullable$1.toNullable(ST_Type_$type, null);
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.n = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    static o(a, b, c, d, e) {
        b = Nullable$1.toNullable(ST_Scope_$type, null);
        c = Nullable$1.toNullable(ST_Type_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "scope":
                    b = Nullable$1.toNullable(ST_Scope_$type, XmlNamespaceDefinitionBase.b(ST_Scope_$type, f.d));
                    break;
                case "type":
                    c = Nullable$1.toNullable(ST_Type_$type, XmlNamespaceDefinitionBase.b(ST_Type_$type, f.d));
                    break;
                case "priority":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "id":
                    e = f.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static p(a, b, c, d, e, f) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "priority";
            g = c.value.toString();
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "scope";
            g = XmlNamespaceDefinitionBase.f(ST_Scope_$type, d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "type";
            g = XmlNamespaceDefinitionBase.f(ST_Type_$type, e.value);
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "id";
            g = f;
            a.ad.h(h, g);
        }
        ;
    }
}
CT_ConditionalFormat_SML2009.$t = markType(CT_ConditionalFormat_SML2009, 'CT_ConditionalFormat_SML2009');
/**
 * @hidden
 */
export class CT_ConditionalFormats_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
}
CT_ConditionalFormats_SML2009.$t = markType(CT_ConditionalFormats_SML2009, 'CT_ConditionalFormats_SML2009');
/**
 * @hidden
 */
export class CT_PivotChange extends Base {
    constructor() {
        super();
        this.d = null;
        this.i = null;
        this.b = null;
        this.f = 0;
        this.k = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static l(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "allocationMethod":
                    b = XmlNamespaceDefinitionBase.b(ST_AllocationMethod_$type, d.d);
                    break;
                case "weightExpression":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static m(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "weightExpression";
            e = c;
            a.ad.h(f, e);
        }
        f = "allocationMethod";
        e = XmlNamespaceDefinitionBase.f(ST_AllocationMethod_$type, d);
        a.ad.h(f, e);
        ;
    }
}
CT_PivotChange.$t = markType(CT_PivotChange, 'CT_PivotChange');
/**
 * @hidden
 */
export class CT_PivotEditValue extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
}
CT_PivotEditValue.$t = markType(CT_PivotEditValue, 'CT_PivotEditValue');
/**
 * @hidden
 */
export class CT_PivotUserEdit extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
}
CT_PivotUserEdit.$t = markType(CT_PivotUserEdit, 'CT_PivotUserEdit');
/**
 * @hidden
 */
export class CT_PivotEdit extends Base {
    constructor() {
        super();
        this.f = null;
        this.h = null;
        this.d = null;
        this.b = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static i(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static j(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_PivotEdit.$t = markType(CT_PivotEdit, 'CT_PivotEdit');
/**
 * @hidden
 */
export class CT_PivotTableDefinition extends Base {
    constructor() {
        super();
        this.m = null;
        this.k = null;
        this.b = null;
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.ac = null;
        this.ae = null;
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.q = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(ST_AllocationMethod_$type, null);
        this.ag = null;
        this.y = Nullable$1.toNullable(Boolean_$type, null);
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get af() {
        return this.ag;
    }
    set af(a) {
        this.ag = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    static ah(a, b, c, d, e, f, g, h, i, j, k) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = null;
        f = null;
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(ST_AllocationMethod_$type, null);
        j = null;
        k = Nullable$1.toNullable(Boolean_$type, null);
        for (let l of fromEnum(a.ab.u)) {
            switch (l.a.e(a.d)) {
                case "fillDownLabelsDefault":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "visualTotalsForSets":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "calculatedMembersInFilters":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "altText":
                    e = l.d;
                    break;
                case "altTextSummary":
                    f = l.d;
                    break;
                case "enableEdit":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "autoApply":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "allocationMethod":
                    i = Nullable$1.toNullable(ST_AllocationMethod_$type, XmlNamespaceDefinitionBase.b(ST_AllocationMethod_$type, l.d));
                    break;
                case "weightExpression":
                    j = l.d;
                    break;
                case "hideValuesRow":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k
        };
    }
    static ai(a, b, c = Nullable$1.toNullable(ST_AllocationMethod_$type, null), d = null, e = null, f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = null) {
        a.ad.p(b, null);
        let m = null;
        let n = null;
        if (c.hasValue) {
            n = "allocationMethod";
            m = XmlNamespaceDefinitionBase.f(ST_AllocationMethod_$type, c.value);
            a.ad.h(n, m);
        }
        if (d != null) {
            n = "altText";
            m = d;
            a.ad.h(n, m);
        }
        if (e != null) {
            n = "altTextSummary";
            m = e;
            a.ad.h(n, m);
        }
        if (f.hasValue) {
            n = "autoApply";
            m = ST_OnOff.g(f.value);
            a.ad.h(n, m);
        }
        if (g.hasValue) {
            n = "calculatedMembersInFilters";
            m = ST_OnOff.g(g.value);
            a.ad.h(n, m);
        }
        if (h.hasValue) {
            n = "enableEdit";
            m = ST_OnOff.g(h.value);
            a.ad.h(n, m);
        }
        if (i.hasValue) {
            n = "fillDownLabelsDefault";
            m = ST_OnOff.g(i.value);
            a.ad.h(n, m);
        }
        if (j.hasValue) {
            n = "hideValuesRow";
            m = ST_OnOff.g(j.value);
            a.ad.h(n, m);
        }
        if (k.hasValue) {
            n = "visualTotalsForSets";
            m = ST_OnOff.g(k.value);
            a.ad.h(n, m);
        }
        if (l != null) {
            n = "weightExpression";
            m = l;
            a.ad.h(n, m);
        }
        ;
    }
}
CT_PivotTableDefinition.$t = markType(CT_PivotTableDefinition, 'CT_PivotTableDefinition');
/**
 * @hidden
 */
export class CT_PivotField_SML2009 extends Base {
    constructor() {
        super();
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static g(a, b, c) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "fillDownLabels":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                case "ignore":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "fillDownLabels";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "ignore";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
        ;
    }
}
CT_PivotField_SML2009.$t = markType(CT_PivotField_SML2009, 'CT_PivotField_SML2009');
/**
 * @hidden
 */
export class CT_DataField_SML2009 extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(ST_PivotShowAs_$type, null);
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.f = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static g(a, b, c, d) {
        b = Nullable$1.toNullable(ST_PivotShowAs_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "pivotShowAs":
                    b = Nullable$1.toNullable(ST_PivotShowAs_$type, XmlNamespaceDefinitionBase.b(ST_PivotShowAs_$type, e.d));
                    break;
                case "sourceField":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "uniqueName":
                    d = e.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static h(a, b, c = Nullable$1.toNullable(ST_PivotShowAs_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = null) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "pivotShowAs";
            f = XmlNamespaceDefinitionBase.f(ST_PivotShowAs_$type, c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "sourceField";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        if (e != null) {
            g = "uniqueName";
            f = e;
            a.ad.h(g, f);
        }
        ;
    }
}
CT_DataField_SML2009.$t = markType(CT_DataField_SML2009, 'CT_DataField_SML2009');
/**
 * @hidden
 */
export class CT_CacheHierarchy_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    static o(a, b, c, d, e) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "flattenHierarchies":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "measuresSet":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "hierarchizeDistinct":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "ignore":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static p(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "flattenHierarchies";
            g = ST_OnOff.g(c.value);
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "hierarchizeDistinct";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "ignore";
            g = ST_OnOff.g(e.value);
            a.ad.h(h, g);
        }
        if (f.hasValue) {
            h = "measuresSet";
            g = ST_OnOff.g(f.value);
            a.ad.h(h, g);
        }
        ;
    }
}
CT_CacheHierarchy_SML2009.$t = markType(CT_CacheHierarchy_SML2009, 'CT_CacheHierarchy_SML2009');
/**
 * @hidden
 */
export class CT_SetLevels extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SetLevels.$t = markType(CT_SetLevels, 'CT_SetLevels');
/**
 * @hidden
 */
export class CT_SetLevel extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "hierarchy":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "hierarchy";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
}
CT_SetLevel.$t = markType(CT_SetLevel, 'CT_SetLevel');
/**
 * @hidden
 */
export class CT_TupleSetRowItem extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "u":
                    b = d.d;
                    break;
                case "d":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c = null, d = null) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "d";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "u";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
}
CT_TupleSetRowItem.$t = markType(CT_TupleSetRowItem, 'CT_TupleSetRowItem');
/**
 * @hidden
 */
export class CT_TupleSetHeader extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "uniqueName":
                    b = d.d;
                    break;
                case "hierarchyName":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c = null, d = null) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "hierarchyName";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "uniqueName";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
}
CT_TupleSetHeader.$t = markType(CT_TupleSetHeader, 'CT_TupleSetHeader');
/**
 * @hidden
 */
export class CT_TupleSet extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static k(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "rowCount":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "columnCount":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static l(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "columnCount";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rowCount";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
}
CT_TupleSet.$t = markType(CT_TupleSet, 'CT_TupleSet');
/**
 * @hidden
 */
export class CT_CalculatedMember_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
        this.m = null;
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.o = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    static p(a, b, c, d, e, f) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = null;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "displayFolder":
                    b = g.d;
                    break;
                case "flattenHierarchies":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "dynamicSet":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "hierarchizeDistinct":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "mdxLong":
                    f = g.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static q(a, b, c = null, d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = null) {
        a.ad.p(b, null);
        let h = null;
        let i = null;
        if (c != null) {
            i = "displayFolder";
            h = c;
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "dynamicSet";
            h = ST_OnOff.g(d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "flattenHierarchies";
            h = ST_OnOff.g(e.value);
            a.ad.h(i, h);
        }
        if (f.hasValue) {
            i = "hierarchizeDistinct";
            h = ST_OnOff.g(f.value);
            a.ad.h(i, h);
        }
        if (g != null) {
            i = "mdxLong";
            h = g;
            a.ad.h(i, h);
        }
        ;
    }
}
CT_CalculatedMember_SML2009.$t = markType(CT_CalculatedMember_SML2009, 'CT_CalculatedMember_SML2009');
/**
 * @hidden
 */
export class CT_SlicerCache extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SlicerCache.$t = markType(CT_SlicerCache, 'CT_SlicerCache');
/**
 * @hidden
 */
export class CT_SlicerRef extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_SlicerRef.$t = markType(CT_SlicerRef, 'CT_SlicerRef');
/**
 * @hidden
 */
export class CT_WorkbookPr_SML2009 extends Base {
    constructor() {
        super();
        this.i = 0;
        this.c = false;
        this.e = 0;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static j(a, b, c, d) {
        b = 0;
        c = false;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "defaultImageDpi":
                    b = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "discardImageEditData":
                    c = ST_OnOff.e(e.d);
                    break;
                case "accuracyVersion":
                    d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static k(a, b, c, d, e) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        g = "accuracyVersion";
        f = c.toString();
        a.ad.h(g, f);
        g = "defaultImageDpi";
        f = d.toString();
        a.ad.h(g, f);
        g = "discardImageEditData";
        f = ST_OnOff.g(e);
        a.ad.h(g, f);
        ;
    }
}
CT_WorkbookPr_SML2009.$t = markType(CT_WorkbookPr_SML2009, 'CT_WorkbookPr_SML2009');
/**
 * @hidden
 */
export class CT_DataValidationFormula extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_DataValidationFormula.$t = markType(CT_DataValidationFormula, 'CT_DataValidationFormula');
/**
 * @hidden
 */
export class CT_DataValidation_SML2009 extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.z = Nullable$1.toNullable(ST_DataValidationType_$type, null);
        this.n = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, null);
        this.p = Nullable$1.toNullable(ST_DataValidationImeMode_$type, null);
        this.r = Nullable$1.toNullable(ST_DataValidationOperator_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.t = Nullable$1.toNullable(Boolean_$type, null);
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.v = Nullable$1.toNullable(Boolean_$type, null);
        this.ad = null;
        this.ab = null;
        this.ah = null;
        this.af = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get ac() {
        return this.ad;
    }
    set ac(a) {
        this.ad = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get ag() {
        return this.ah;
    }
    set ag(a) {
        this.ah = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    static ai(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = Nullable$1.toNullable(ST_DataValidationType_$type, null);
        c = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, null);
        d = Nullable$1.toNullable(ST_DataValidationImeMode_$type, null);
        e = Nullable$1.toNullable(ST_DataValidationOperator_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = null;
        k = null;
        l = null;
        m = null;
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_DataValidationType_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationType_$type, n.d));
                    break;
                case "errorStyle":
                    c = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationErrorStyle_$type, n.d));
                    break;
                case "imeMode":
                    d = Nullable$1.toNullable(ST_DataValidationImeMode_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationImeMode_$type, n.d));
                    break;
                case "operator":
                    e = Nullable$1.toNullable(ST_DataValidationOperator_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationOperator_$type, n.d));
                    break;
                case "allowBlank":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(n.d));
                    break;
                case "showDropDown":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(n.d));
                    break;
                case "showInputMessage":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(n.d));
                    break;
                case "showErrorMessage":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(n.d));
                    break;
                case "errorTitle":
                    j = n.d;
                    break;
                case "error":
                    k = n.d;
                    break;
                case "promptTitle":
                    l = n.d;
                    break;
                case "prompt":
                    m = n.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static aj(a, b, c = Nullable$1.toNullable(ST_DataValidationOperator_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = null, f = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, null), g = null, h = Nullable$1.toNullable(ST_DataValidationImeMode_$type, null), i = null, j = null, k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Boolean_$type, null), n = Nullable$1.toNullable(ST_DataValidationType_$type, null)) {
        a.ad.p(b, null);
        let o = null;
        let p = null;
        if (c.hasValue) {
            p = "operator";
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationOperator_$type, c.value);
            a.ad.h(p, o);
        }
        if (d.hasValue) {
            p = "allowBlank";
            o = ST_OnOff.g(d.value);
            a.ad.h(p, o);
        }
        if (e != null) {
            p = "error";
            o = e;
            a.ad.h(p, o);
        }
        if (f.hasValue) {
            p = "errorStyle";
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationErrorStyle_$type, f.value);
            a.ad.h(p, o);
        }
        if (g != null) {
            p = "errorTitle";
            o = g;
            a.ad.h(p, o);
        }
        if (h.hasValue) {
            p = "imeMode";
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationImeMode_$type, h.value);
            a.ad.h(p, o);
        }
        if (i != null) {
            p = "prompt";
            o = i;
            a.ad.h(p, o);
        }
        if (j != null) {
            p = "promptTitle";
            o = j;
            a.ad.h(p, o);
        }
        if (k.hasValue) {
            p = "showDropDown";
            o = ST_OnOff.g(k.value);
            a.ad.h(p, o);
        }
        if (l.hasValue) {
            p = "showErrorMessage";
            o = ST_OnOff.g(l.value);
            a.ad.h(p, o);
        }
        if (m.hasValue) {
            p = "showInputMessage";
            o = ST_OnOff.g(m.value);
            a.ad.h(p, o);
        }
        if (n.hasValue) {
            p = "type";
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationType_$type, n.value);
            a.ad.h(p, o);
        }
        ;
    }
}
CT_DataValidation_SML2009.$t = markType(CT_DataValidation_SML2009, 'CT_DataValidation_SML2009');
/**
 * @hidden
 */
export class CT_DataValidations_SML2009 extends Base {
    constructor() {
        super();
        this.c = null;
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Number_$type, null);
        this.k = Nullable$1.toNullable(Number_$type, null);
        this.e = Nullable$1.toNullable(Number_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static l(a, b, c, d, e) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "disablePrompts":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "xWindow":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "yWindow":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "count":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static m(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "count";
            g = c.value.toString();
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "disablePrompts";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "xWindow";
            g = e.value.toString();
            a.ad.h(h, g);
        }
        if (f.hasValue) {
            h = "yWindow";
            g = f.value.toString();
            a.ad.h(h, g);
        }
        ;
    }
}
CT_DataValidations_SML2009.$t = markType(CT_DataValidations_SML2009, 'CT_DataValidations_SML2009');
/**
 * @hidden
 */
export class CT_CfIcon extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b, c) {
        b = 0;
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "iconSet":
                    b = XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, d.d);
                    break;
                case "iconId":
                    c = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static f(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        f = "iconId";
        e = c.toString();
        a.ad.h(f, e);
        f = "iconSet";
        e = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, d);
        a.ad.h(f, e);
        ;
    }
}
CT_CfIcon.$t = markType(CT_CfIcon, 'CT_CfIcon');
/**
 * @hidden
 */
export class CT_IconSet_SML2009 extends Base {
    constructor() {
        super();
        this.h = null;
        this.f = null;
        this.l = Nullable$1.toNullable(ST_IconSetType_$type, null);
        this.r = Nullable$1.toNullable(Boolean_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.p = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static s(a, b, c, d, e, f) {
        b = Nullable$1.toNullable(ST_IconSetType_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "iconSet":
                    b = Nullable$1.toNullable(ST_IconSetType_$type, XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, g.d));
                    break;
                case "showValue":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "percent":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "reverse":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "custom":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static t(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(ST_IconSetType_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "custom";
            h = ST_OnOff.g(c.value);
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "iconSet";
            h = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "percent";
            h = ST_OnOff.g(e.value);
            a.ad.h(i, h);
        }
        if (f.hasValue) {
            i = "reverse";
            h = ST_OnOff.g(f.value);
            a.ad.h(i, h);
        }
        if (g.hasValue) {
            i = "showValue";
            h = ST_OnOff.g(g.value);
            a.ad.h(i, h);
        }
        ;
    }
}
CT_IconSet_SML2009.$t = markType(CT_IconSet_SML2009, 'CT_IconSet_SML2009');
/**
 * @hidden
 */
export class CT_Cfvo_SML2009 extends Base {
    constructor() {
        super();
        this.i = null;
        this.b = null;
        this.d = 0;
        this.g = Nullable$1.toNullable(Boolean_$type, null);
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static j(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_CfvoType_$type, d.d);
                    break;
                case "gte":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static k(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "gte";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        f = "type";
        e = XmlNamespaceDefinitionBase.f(ST_CfvoType_$type, d);
        a.ad.h(f, e);
        ;
    }
}
CT_Cfvo_SML2009.$t = markType(CT_Cfvo_SML2009, 'CT_Cfvo_SML2009');
/**
 * @hidden
 */
export class CT_DataBar_SML2009 extends Base {
    constructor() {
        super();
        this.q = null;
        this.f = null;
        this.d = null;
        this.j = null;
        this.h = null;
        this.b = null;
        this.ac = Nullable$1.toNullable(Number_$type, null);
        this.aa = Nullable$1.toNullable(Number_$type, null);
        this.ai = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.y = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(ST_DataBarDirection_$type, null);
        this.ag = Nullable$1.toNullable(Boolean_$type, null);
        this.ae = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, null);
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get ah() {
        return this.ai;
    }
    set ah(a) {
        this.ai = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get af() {
        return this.ag;
    }
    set af(a) {
        this.ag = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    static al(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(ST_DataBarDirection_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "minLength":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "maxLength":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "showValue":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "border":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "gradient":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "direction":
                    g = Nullable$1.toNullable(ST_DataBarDirection_$type, XmlNamespaceDefinitionBase.b(ST_DataBarDirection_$type, k.d));
                    break;
                case "negativeBarColorSameAsPositive":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "negativeBarBorderColorSameAsPositive":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "axisPosition":
                    j = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, XmlNamespaceDefinitionBase.b(ST_DataBarAxisPosition_$type, k.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static am(a, b, c = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(ST_DataBarDirection_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "axisPosition";
            l = XmlNamespaceDefinitionBase.f(ST_DataBarAxisPosition_$type, c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "border";
            l = ST_OnOff.g(d.value);
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "direction";
            l = XmlNamespaceDefinitionBase.f(ST_DataBarDirection_$type, e.value);
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "gradient";
            l = ST_OnOff.g(f.value);
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "maxLength";
            l = g.value.toString();
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "minLength";
            l = h.value.toString();
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "negativeBarBorderColorSameAsPositive";
            l = ST_OnOff.g(i.value);
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "negativeBarColorSameAsPositive";
            l = ST_OnOff.g(j.value);
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "showValue";
            l = ST_OnOff.g(k.value);
            a.ad.h(m, l);
        }
        ;
    }
}
CT_DataBar_SML2009.$t = markType(CT_DataBar_SML2009, 'CT_DataBar_SML2009');
/**
 * @hidden
 */
export class CT_ColorScale_SML2009 extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static e(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static f(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_ColorScale_SML2009.$t = markType(CT_ColorScale_SML2009, 'CT_ColorScale_SML2009');
/**
 * @hidden
 */
export class CT_CfRule_SML2009 extends Base {
    constructor() {
        super();
        this.r = null;
        this.d = null;
        this.f = null;
        this.j = null;
        this.h = null;
        this.b = null;
        this.ap = Nullable$1.toNullable(ST_CfType_$type, null);
        this.af = Nullable$1.toNullable(Number_$type, null);
        this.al = Nullable$1.toNullable(Boolean_$type, null);
        this.t = Nullable$1.toNullable(Boolean_$type, null);
        this.ad = Nullable$1.toNullable(Boolean_$type, null);
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.ab = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        this.at = null;
        this.an = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        this.ah = Nullable$1.toNullable(Number_$type, null);
        this.aj = Nullable$1.toNullable(Number_$type, null);
        this.z = Nullable$1.toNullable(Boolean_$type, null);
        this.v = Nullable$1.toNullable(Boolean_$type, null);
        this.ar = null;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get ao() {
        return this.ap;
    }
    set ao(a) {
        this.ap = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    get ak() {
        return this.al;
    }
    set ak(a) {
        this.al = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get ac() {
        return this.ad;
    }
    set ac(a) {
        this.ad = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get as() {
        return this.at;
    }
    set as(a) {
        this.at = a;
    }
    get am() {
        return this.an;
    }
    set am(a) {
        this.an = a;
    }
    get ag() {
        return this.ah;
    }
    set ag(a) {
        this.ah = a;
    }
    get ai() {
        return this.aj;
    }
    set ai(a) {
        this.aj = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get aq() {
        return this.ar;
    }
    set aq(a) {
        this.ar = a;
    }
    static au(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        b = Nullable$1.toNullable(ST_CfType_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        i = null;
        j = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        k = Nullable$1.toNullable(Number_$type, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Boolean_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = null;
        for (let p of fromEnum(a.ab.u)) {
            switch (p.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_CfType_$type, XmlNamespaceDefinitionBase.b(ST_CfType_$type, p.d));
                    break;
                case "priority":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "stopIfTrue":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "aboveAverage":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "percent":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "bottom":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "operator":
                    h = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, XmlNamespaceDefinitionBase.b(ST_ConditionalFormattingOperator_$type, p.d));
                    break;
                case "text":
                    i = p.d;
                    break;
                case "timePeriod":
                    j = Nullable$1.toNullable(ST_TimePeriod_$type, XmlNamespaceDefinitionBase.b(ST_TimePeriod_$type, p.d));
                    break;
                case "rank":
                    k = Nullable$1.toNullable(Number_$type, parseUInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "stdDev":
                    l = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "equalAverage":
                    m = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "activePresent":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                case "id":
                    o = p.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o
        };
    }
    static av(a, b, c = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = null, i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Boolean_$type, null), n = null, o = Nullable$1.toNullable(ST_TimePeriod_$type, null), p = Nullable$1.toNullable(ST_CfType_$type, null)) {
        a.ad.p(b, null);
        let q = null;
        let r = null;
        if (c.hasValue) {
            r = "operator";
            q = XmlNamespaceDefinitionBase.f(ST_ConditionalFormattingOperator_$type, c.value);
            a.ad.h(r, q);
        }
        if (d.hasValue) {
            r = "aboveAverage";
            q = ST_OnOff.g(d.value);
            a.ad.h(r, q);
        }
        if (e.hasValue) {
            r = "activePresent";
            q = ST_OnOff.g(e.value);
            a.ad.h(r, q);
        }
        if (f.hasValue) {
            r = "bottom";
            q = ST_OnOff.g(f.value);
            a.ad.h(r, q);
        }
        if (g.hasValue) {
            r = "equalAverage";
            q = ST_OnOff.g(g.value);
            a.ad.h(r, q);
        }
        if (h != null) {
            r = "id";
            q = h;
            a.ad.h(r, q);
        }
        if (i.hasValue) {
            r = "percent";
            q = ST_OnOff.g(i.value);
            a.ad.h(r, q);
        }
        if (j.hasValue) {
            r = "priority";
            q = j.value.toString();
            a.ad.h(r, q);
        }
        if (k.hasValue) {
            r = "rank";
            q = k.value.toString();
            a.ad.h(r, q);
        }
        if (l.hasValue) {
            r = "stdDev";
            q = l.value.toString();
            a.ad.h(r, q);
        }
        if (m.hasValue) {
            r = "stopIfTrue";
            q = ST_OnOff.g(m.value);
            a.ad.h(r, q);
        }
        if (n != null) {
            r = "text";
            q = n;
            a.ad.h(r, q);
        }
        if (o.hasValue) {
            r = "timePeriod";
            q = XmlNamespaceDefinitionBase.f(ST_TimePeriod_$type, o.value);
            a.ad.h(r, q);
        }
        if (p.hasValue) {
            r = "type";
            q = XmlNamespaceDefinitionBase.f(ST_CfType_$type, p.value);
            a.ad.h(r, q);
        }
        ;
    }
}
CT_CfRule_SML2009.$t = markType(CT_CfRule_SML2009, 'CT_CfRule_SML2009');
/**
 * @hidden
 */
export class CT_ConditionalFormatting_SML2009 extends Base {
    constructor() {
        super();
        this.g = null;
        this.d = null;
        this.b = null;
        this.i = Nullable$1.toNullable(Boolean_$type, null);
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static j(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "pivot":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static k(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "pivot";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
}
CT_ConditionalFormatting_SML2009.$t = markType(CT_ConditionalFormatting_SML2009, 'CT_ConditionalFormatting_SML2009');
/**
 * @hidden
 */
export class CT_TabularSlicerCacheItem extends Base {
    constructor() {
        super();
        this.h = 0;
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static i(a, b, c, d) {
        b = 0;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "x":
                    b = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "s":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "nd":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static j(a, b, c, d, e) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "nd";
            f = ST_OnOff.g(c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "s";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        g = "x";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
}
CT_TabularSlicerCacheItem.$t = markType(CT_TabularSlicerCacheItem, 'CT_TabularSlicerCacheItem');
/**
 * @hidden
 */
export class CT_TabularSlicerCacheItems extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
}
CT_TabularSlicerCacheItems.$t = markType(CT_TabularSlicerCacheItems, 'CT_TabularSlicerCacheItems');
/**
 * @hidden
 */
export class CT_TabularSlicerCache extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.r = 0;
        this.p = Nullable$1.toNullable(ST_TabularSlicerCacheSortOrder_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static s(a, b, c, d, e, f) {
        b = 0;
        c = Nullable$1.toNullable(ST_TabularSlicerCacheSortOrder_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "pivotCacheId":
                    b = parseUInt32_1(g.d, CultureInfo.invariantCulture);
                    break;
                case "sortOrder":
                    c = Nullable$1.toNullable(ST_TabularSlicerCacheSortOrder_$type, XmlNamespaceDefinitionBase.b(ST_TabularSlicerCacheSortOrder_$type, g.d));
                    break;
                case "customListSort":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "showMissing":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "crossFilter":
                    f = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, XmlNamespaceDefinitionBase.b(ST_SlicerCacheCrossFilter_$type, g.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static t(a, b, c, d, e, f, g) {
        a.ad.p(b, null);
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "crossFilter";
            h = XmlNamespaceDefinitionBase.f(ST_SlicerCacheCrossFilter_$type, c.value);
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "customListSort";
            h = ST_OnOff.g(d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "showMissing";
            h = ST_OnOff.g(e.value);
            a.ad.h(i, h);
        }
        if (f.hasValue) {
            i = "sortOrder";
            h = XmlNamespaceDefinitionBase.f(ST_TabularSlicerCacheSortOrder_$type, f.value);
            a.ad.h(i, h);
        }
        i = "pivotCacheId";
        h = g.toString();
        a.ad.h(i, h);
        ;
    }
}
CT_TabularSlicerCache.$t = markType(CT_TabularSlicerCache, 'CT_TabularSlicerCache');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheSelection extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "n":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "n";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_OlapSlicerCacheSelection.$t = markType(CT_OlapSlicerCacheSelection, 'CT_OlapSlicerCacheSelection');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheItemParent extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "n":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "n";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
}
CT_OlapSlicerCacheItemParent.$t = markType(CT_OlapSlicerCacheItemParent, 'CT_OlapSlicerCacheItemParent');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheSelections extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
}
CT_OlapSlicerCacheSelections.$t = markType(CT_OlapSlicerCacheSelections, 'CT_OlapSlicerCacheSelections');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheItem extends Base {
    constructor() {
        super();
        this.c = null;
        this.i = null;
        this.g = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static j(a, b, c, d) {
        b = null;
        c = null;
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "n":
                    b = e.d;
                    break;
                case "c":
                    c = e.d;
                    break;
                case "nd":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static k(a, b, c, d, e) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c != null) {
            g = "c";
            f = c;
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "nd";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e != null) {
            g = "n";
            f = e;
            a.ad.h(g, f);
        }
        ;
    }
}
CT_OlapSlicerCacheItem.$t = markType(CT_OlapSlicerCacheItem, 'CT_OlapSlicerCacheItem');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheRange extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "startItem":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "startItem";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
}
CT_OlapSlicerCacheRange.$t = markType(CT_OlapSlicerCacheRange, 'CT_OlapSlicerCacheRange');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheLevelData extends Base {
    constructor() {
        super();
        this.d = null;
        this.l = null;
        this.j = null;
        this.n = 0;
        this.h = Nullable$1.toNullable(ST_OlapSlicerCacheSortOrder_$type, null);
        this.f = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static o(a, b, c, d, e, f) {
        b = null;
        c = null;
        d = 0;
        e = Nullable$1.toNullable(ST_OlapSlicerCacheSortOrder_$type, null);
        f = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "uniqueName":
                    b = g.d;
                    break;
                case "sourceCaption":
                    c = g.d;
                    break;
                case "count":
                    d = parseUInt32_1(g.d, CultureInfo.invariantCulture);
                    break;
                case "sortOrder":
                    e = Nullable$1.toNullable(ST_OlapSlicerCacheSortOrder_$type, XmlNamespaceDefinitionBase.b(ST_OlapSlicerCacheSortOrder_$type, g.d));
                    break;
                case "crossFilter":
                    f = Nullable$1.toNullable(ST_SlicerCacheCrossFilter_$type, XmlNamespaceDefinitionBase.b(ST_SlicerCacheCrossFilter_$type, g.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static p(a, b, c, d, e, f, g) {
        a.ad.p(b, null);
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "crossFilter";
            h = XmlNamespaceDefinitionBase.f(ST_SlicerCacheCrossFilter_$type, c.value);
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "sortOrder";
            h = XmlNamespaceDefinitionBase.f(ST_OlapSlicerCacheSortOrder_$type, d.value);
            a.ad.h(i, h);
        }
        if (e != null) {
            i = "sourceCaption";
            h = e;
            a.ad.h(i, h);
        }
        i = "count";
        h = f.toString();
        a.ad.h(i, h);
        if (g != null) {
            i = "uniqueName";
            h = g;
            a.ad.h(i, h);
        }
        ;
    }
}
CT_OlapSlicerCacheLevelData.$t = markType(CT_OlapSlicerCacheLevelData, 'CT_OlapSlicerCacheLevelData');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheLevelsData extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
}
CT_OlapSlicerCacheLevelsData.$t = markType(CT_OlapSlicerCacheLevelsData, 'CT_OlapSlicerCacheLevelsData');
/**
 * @hidden
 */
export class CT_OlapSlicerCache extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.h = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    static i(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "pivotCacheId":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static j(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "pivotCacheId";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
}
CT_OlapSlicerCache.$t = markType(CT_OlapSlicerCache, 'CT_OlapSlicerCache');
/**
 * @hidden
 */
export class CT_SlicerCacheData extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
}
CT_SlicerCacheData.$t = markType(CT_SlicerCacheData, 'CT_SlicerCacheData');
/**
 * @hidden
 */
export class CT_ConditionalFormattings extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_ConditionalFormattings.$t = markType(CT_ConditionalFormattings, 'CT_ConditionalFormattings');
/**
 * @hidden
 */
export class CT_SparklineGroups extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_SparklineGroups.$t = markType(CT_SparklineGroups, 'CT_SparklineGroups');
/**
 * @hidden
 */
export class CT_SlicerRefs extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_SlicerRefs.$t = markType(CT_SlicerRefs, 'CT_SlicerRefs');
/**
 * @hidden
 */
export class CT_ProtectedRanges_SML2009 extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_ProtectedRanges_SML2009.$t = markType(CT_ProtectedRanges_SML2009, 'CT_ProtectedRanges_SML2009');
/**
 * @hidden
 */
export class CT_SlicerCaches extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_SlicerCaches.$t = markType(CT_SlicerCaches, 'CT_SlicerCaches');
/**
 * @hidden
 */
export class CT_Slicers extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_Slicers.$t = markType(CT_Slicers, 'CT_Slicers');
/**
 * @hidden
 */
export class CT_SlicerCachePivotTables extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_SlicerCachePivotTables.$t = markType(CT_SlicerCachePivotTables, 'CT_SlicerCachePivotTables');
/**
 * @hidden
 */
export class CT_OlapSlicerCacheRanges extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_OlapSlicerCacheRanges.$t = markType(CT_OlapSlicerCacheRanges, 'CT_OlapSlicerCacheRanges');
/**
 * @hidden
 */
export class CT_Sparklines extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_Sparklines.$t = markType(CT_Sparklines, 'CT_Sparklines');
/**
 * @hidden
 */
export class CT_TupleSetHeaders extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_TupleSetHeaders.$t = markType(CT_TupleSetHeaders, 'CT_TupleSetHeaders');
/**
 * @hidden
 */
export class CT_TupleSetRows extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_TupleSetRows.$t = markType(CT_TupleSetRows, 'CT_TupleSetRows');
/**
 * @hidden
 */
export class CT_TupleSetRow extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_TupleSetRow.$t = markType(CT_TupleSetRow, 'CT_TupleSetRow');
/**
 * @hidden
 */
export class CT_PivotEdits extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_PivotEdits.$t = markType(CT_PivotEdits, 'CT_PivotEdits');
/**
 * @hidden
 */
export class CT_PivotChanges extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_PivotChanges.$t = markType(CT_PivotChanges, 'CT_PivotChanges');
/**
 * @hidden
 */
export class CT_TupleItems extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_TupleItems.$t = markType(CT_TupleItems, 'CT_TupleItems');
/**
 * @hidden
 */
export class CT_SlicerStyleElements extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static c(a) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to read.");
    }
    static d(a, b) {
        throw new NotSupportedException(1, "The corresponding XML element for this class has no attributes, so there is nothing to write.");
    }
}
CT_SlicerStyleElements.$t = markType(CT_SlicerStyleElements, 'CT_SlicerStyleElements');
/**
 * @hidden
 */
export class SML2009Attributes extends Base {
}
SML2009Attributes.$t = markType(SML2009Attributes, 'SML2009Attributes');
/**
 * @hidden
 */
export class Excel2006Elements extends Base {
}
Excel2006Elements.$t = markType(Excel2006Elements, 'Excel2006Elements');
Excel2006Elements.b = "http://schemas.microsoft.com/office/excel/2006/main";
Excel2006Elements.a = Excel2006Elements.b + "/f";
Excel2006Elements.c = Excel2006Elements.b + "/ref";
Excel2006Elements.d = Excel2006Elements.b + "/sqref";
/**
 * @hidden
 */
export class CT_Ref extends Base {
    constructor() {
        super(...arguments);
        this.f = false;
        this.c = false;
        this.d = false;
        this.h = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get a() {
        return this.d;
    }
    set a(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
}
CT_Ref.$t = markType(CT_Ref, 'CT_Ref');
/**
 * @hidden
 */
export class CT_CustomFilter extends Base {
    constructor() {
        super();
        this.a = 2;
        this.e = null;
        this.b = Nullable$1.toNullable(ST_FilterOperator_$type, null);
        this.d = null;
    }
    static f(a, b, c) {
        b = Nullable$1.toNullable(ST_FilterOperator_$type, null);
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "operator":
                    b = Nullable$1.toNullable(ST_FilterOperator_$type, XmlNamespaceDefinitionBase.b(ST_FilterOperator_$type, d.d));
                    break;
                case "val":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "operator";
            e = XmlNamespaceDefinitionBase.f(ST_FilterOperator_$type, c.value);
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "val";
            e = d;
            a.ad.h(f, e);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CustomFilter.$t = markType(CT_CustomFilter, 'CT_CustomFilter');
/**
 * @hidden
 */
export class CT_IgnoredError extends Base {
    constructor() {
        super();
        this.b = null;
        this.q = Nullable$1.toNullable(Boolean_$type, null);
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
        this.y = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.ac = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    static ae(a, b, c, d, e, f, g, h, i, j, k) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        for (let l of fromEnum(a.ab.u)) {
            switch (l.a.e(a.d)) {
                case "sqref":
                    b = ST_Sqref.a(l.d);
                    break;
                case "evalError":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "twoDigitTextYear":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "numberStoredAsText":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "formula":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "formulaRange":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "unlockedFormula":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "emptyCellReference":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "listDataValidation":
                    j = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                case "calculatedColumn":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(l.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k
        };
    }
    static af(a, b, c, d, e, f, g, h, i, j, k, l) {
        a.ad.p(b, null);
        let m = null;
        let n = null;
        if (c.hasValue) {
            n = "calculatedColumn";
            m = ST_OnOff.g(c.value);
            a.ad.h(n, m);
        }
        if (d.hasValue) {
            n = "emptyCellReference";
            m = ST_OnOff.g(d.value);
            a.ad.h(n, m);
        }
        if (e.hasValue) {
            n = "evalError";
            m = ST_OnOff.g(e.value);
            a.ad.h(n, m);
        }
        if (f.hasValue) {
            n = "formula";
            m = ST_OnOff.g(f.value);
            a.ad.h(n, m);
        }
        if (g.hasValue) {
            n = "formulaRange";
            m = ST_OnOff.g(g.value);
            a.ad.h(n, m);
        }
        if (h.hasValue) {
            n = "listDataValidation";
            m = ST_OnOff.g(h.value);
            a.ad.h(n, m);
        }
        if (i.hasValue) {
            n = "numberStoredAsText";
            m = ST_OnOff.g(i.value);
            a.ad.h(n, m);
        }
        if (j.hasValue) {
            n = "twoDigitTextYear";
            m = ST_OnOff.g(j.value);
            a.ad.h(n, m);
        }
        if (k.hasValue) {
            n = "unlockedFormula";
            m = ST_OnOff.g(k.value);
            a.ad.h(n, m);
        }
        if (l != null) {
            n = "sqref";
            m = l.e();
            a.ad.h(n, m);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_IgnoredError.$t = markType(CT_IgnoredError, 'CT_IgnoredError');
/**
 * @hidden
 */
export class ST_Sqref extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    static a(a) {
        return ST_Sqref.b(a);
    }
    e() {
        return this.f();
    }
    static b(a) {
        let b = new ST_Sqref();
        let c = XmlNamespaceDefinitionBase.e(String_$type, a, (d) => d);
        if (c != null) {
            b.d = new List$1(String_$type, 2, c.count);
            for (let d of fromEnum(c)) {
                b.d.add(d);
            }
        }
        return b;
    }
    f() {
        if (this.d == null) {
            return null;
        }
        let a = new StringBuilder(0);
        let b = this.d.count - 1;
        for (let c = 0; c <= b; c++) {
            let d = this.d._inner[c];
            a.l(d);
            if (c < b) {
                a.l(" ");
            }
        }
        return a.toString();
    }
}
ST_Sqref.$t = markType(ST_Sqref, 'ST_Sqref');
/**
 * @hidden
 */
export class CT_DdeValues extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = Nullable$1.toNullable(Number_$type, null);
        this.b = Nullable$1.toNullable(Number_$type, null);
        this.a = new List$1(CT_DdeValue.$, 0);
    }
    static g(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "rows":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "cols":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "cols";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rows";
            e = d.value.toString();
            a.ad.h(f, e);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 1824:
                this.a.add(typeCast(CT_DdeValue.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DdeValues.$t = markType(CT_DdeValues, 'CT_DdeValues', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DdeValue extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = Nullable$1.toNullable(ST_DdeValueType_$type, null);
    }
    static e(a, b) {
        b = Nullable$1.toNullable(ST_DdeValueType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "t":
                    b = Nullable$1.toNullable(ST_DdeValueType_$type, XmlNamespaceDefinitionBase.b(ST_DdeValueType_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(ST_DdeValueType_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "t";
            d = XmlNamespaceDefinitionBase.f(ST_DdeValueType_$type, c.value);
            a.ad.h(e, d);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 1821:
                this.d = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DdeValue.$t = markType(CT_DdeValue, 'CT_DdeValue', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotArea extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.af = Nullable$1.toNullable(Number_$type, null);
        this.g = 0;
        this.m = false;
        this.z = false;
        this.x = false;
        this.v = false;
        this.i = false;
        this.ab = false;
        this.aj = null;
        this.k = false;
        this.ad = Nullable$1.toNullable(ST_Axis_$type, null);
        this.ah = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get ai() {
        return this.aj;
    }
    set ai(a) {
        this.aj = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get ac() {
        return this.ad;
    }
    set ac(a) {
        this.ad = a;
    }
    get ag() {
        return this.ah;
    }
    set ag(a) {
        this.ah = a;
    }
    static al(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = 0;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        i = false;
        j = null;
        k = false;
        l = Nullable$1.toNullable(ST_Axis_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "field":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                case "type":
                    c = XmlNamespaceDefinitionBase.b(ST_PivotAreaType_$type, n.d);
                    break;
                case "dataOnly":
                    d = ST_OnOff.e(n.d);
                    break;
                case "labelOnly":
                    e = ST_OnOff.e(n.d);
                    break;
                case "grandRow":
                    f = ST_OnOff.e(n.d);
                    break;
                case "grandCol":
                    g = ST_OnOff.e(n.d);
                    break;
                case "cacheIndex":
                    h = ST_OnOff.e(n.d);
                    break;
                case "outline":
                    i = ST_OnOff.e(n.d);
                    break;
                case "offset":
                    j = n.d;
                    break;
                case "collapsedLevelsAreSubtotals":
                    k = ST_OnOff.e(n.d);
                    break;
                case "axis":
                    l = Nullable$1.toNullable(ST_Axis_$type, XmlNamespaceDefinitionBase.b(ST_Axis_$type, n.d));
                    break;
                case "fieldPosition":
                    m = Nullable$1.toNullable(Number_$type, parseUInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static am(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        a.ad.p(b, null);
        let o = null;
        let p = null;
        if (c.hasValue) {
            p = "axis";
            o = XmlNamespaceDefinitionBase.f(ST_Axis_$type, c.value);
            a.ad.h(p, o);
        }
        if (d.hasValue) {
            p = "field";
            o = d.value.toString();
            a.ad.h(p, o);
        }
        if (e.hasValue) {
            p = "fieldPosition";
            o = e.value.toString();
            a.ad.h(p, o);
        }
        p = "cacheIndex";
        o = ST_OnOff.g(f);
        a.ad.h(p, o);
        p = "collapsedLevelsAreSubtotals";
        o = ST_OnOff.g(g);
        a.ad.h(p, o);
        p = "dataOnly";
        o = ST_OnOff.g(h);
        a.ad.h(p, o);
        p = "grandCol";
        o = ST_OnOff.g(i);
        a.ad.h(p, o);
        p = "grandRow";
        o = ST_OnOff.g(j);
        a.ad.h(p, o);
        p = "labelOnly";
        o = ST_OnOff.g(k);
        a.ad.h(p, o);
        if (l != null) {
            p = "offset";
            o = l;
            a.ad.h(p, o);
        }
        p = "outline";
        o = ST_OnOff.g(m);
        a.ad.h(p, o);
        p = "type";
        o = XmlNamespaceDefinitionBase.f(ST_PivotAreaType_$type, n);
        a.ad.h(p, o);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1337:
                this.c = typeCast(CT_PivotAreaReferences.$, b);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PivotArea.$t = markType(CT_PivotArea, 'CT_PivotArea', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotAreas extends Base {
    constructor() {
        super();
        this.b = null;
        this.e = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "count";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1203:
                this.a.add(typeCast(CT_PivotArea.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PivotAreas.$t = markType(CT_PivotAreas, 'CT_PivotAreas', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotAreaReference extends Base {
    constructor() {
        super();
        this.af = null;
        this.a = null;
        this.ag = Nullable$1.toNullable(Number_$type, null);
        this.ai = 0;
        this.z = false;
        this.c = false;
        this.y = false;
        this.r = false;
        this.ac = false;
        this.d = false;
        this.b = false;
        this.v = false;
        this.w = false;
        this.x = false;
        this.e = false;
        this.ab = false;
        this.aa = false;
        this.ae = false;
        this.ad = false;
        this.af = new List$1(CT_Index.$, 0);
    }
    static aj(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = 0;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        i = false;
        j = false;
        k = false;
        l = false;
        m = false;
        n = false;
        o = false;
        p = false;
        q = false;
        r = false;
        for (let s of fromEnum(a.ab.u)) {
            switch (s.a.e(a.d)) {
                case "field":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(s.d, CultureInfo.invariantCulture));
                    break;
                case "count":
                    c = parseUInt32_1(s.d, CultureInfo.invariantCulture);
                    break;
                case "selected":
                    d = ST_OnOff.e(s.d);
                    break;
                case "byPosition":
                    e = ST_OnOff.e(s.d);
                    break;
                case "relative":
                    f = ST_OnOff.e(s.d);
                    break;
                case "defaultSubtotal":
                    g = ST_OnOff.e(s.d);
                    break;
                case "sumSubtotal":
                    h = ST_OnOff.e(s.d);
                    break;
                case "countASubtotal":
                    i = ST_OnOff.e(s.d);
                    break;
                case "avgSubtotal":
                    j = ST_OnOff.e(s.d);
                    break;
                case "maxSubtotal":
                    k = ST_OnOff.e(s.d);
                    break;
                case "minSubtotal":
                    l = ST_OnOff.e(s.d);
                    break;
                case "productSubtotal":
                    m = ST_OnOff.e(s.d);
                    break;
                case "countSubtotal":
                    n = ST_OnOff.e(s.d);
                    break;
                case "stdDevSubtotal":
                    o = ST_OnOff.e(s.d);
                    break;
                case "stdDevPSubtotal":
                    p = ST_OnOff.e(s.d);
                    break;
                case "varSubtotal":
                    q = ST_OnOff.e(s.d);
                    break;
                case "varPSubtotal":
                    r = ST_OnOff.e(s.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r
        };
    }
    static ak(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) {
        a.ad.p(b, null);
        let t = null;
        let u = null;
        if (c.hasValue) {
            u = "field";
            t = c.value.toString();
            a.ad.h(u, t);
        }
        u = "avgSubtotal";
        t = ST_OnOff.g(d);
        a.ad.h(u, t);
        u = "byPosition";
        t = ST_OnOff.g(e);
        a.ad.h(u, t);
        u = "count";
        t = f.toString();
        a.ad.h(u, t);
        u = "countASubtotal";
        t = ST_OnOff.g(g);
        a.ad.h(u, t);
        u = "countSubtotal";
        t = ST_OnOff.g(h);
        a.ad.h(u, t);
        u = "defaultSubtotal";
        t = ST_OnOff.g(i);
        a.ad.h(u, t);
        u = "maxSubtotal";
        t = ST_OnOff.g(j);
        a.ad.h(u, t);
        u = "minSubtotal";
        t = ST_OnOff.g(k);
        a.ad.h(u, t);
        u = "productSubtotal";
        t = ST_OnOff.g(l);
        a.ad.h(u, t);
        u = "relative";
        t = ST_OnOff.g(m);
        a.ad.h(u, t);
        u = "selected";
        t = ST_OnOff.g(n);
        a.ad.h(u, t);
        u = "stdDevPSubtotal";
        t = ST_OnOff.g(o);
        a.ad.h(u, t);
        u = "stdDevSubtotal";
        t = ST_OnOff.g(p);
        a.ad.h(u, t);
        u = "sumSubtotal";
        t = ST_OnOff.g(q);
        a.ad.h(u, t);
        u = "varPSubtotal";
        t = ST_OnOff.g(r);
        a.ad.h(u, t);
        u = "varSubtotal";
        t = ST_OnOff.g(s);
        a.ad.h(u, t);
    }
    setProperty(a, b) {
        switch (a) {
            case 1888:
                this.af.add(typeCast(CT_Index.$, b));
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PivotAreaReference.$t = markType(CT_PivotAreaReference, 'CT_PivotAreaReference', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotAreaReferences extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = 0;
        this.a = new List$1(CT_PivotAreaReference.$, 0);
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "count";
        d = c.toString();
        a.ad.h(e, d);
    }
    setProperty(a, b) {
        switch (a) {
            case 1336:
                this.a.add(typeCast(CT_PivotAreaReference.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PivotAreaReferences.$t = markType(CT_PivotAreaReferences, 'CT_PivotAreaReferences', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Index extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "v":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "v";
        d = c.toString();
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Index.$t = markType(CT_Index, 'CT_Index');
/**
 * @hidden
 */
export class CT_ConditionalFormats extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = 0;
        this.a = new List$1(CT_ConditionalFormat.$, 0);
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "count";
        d = c.toString();
        a.ad.h(e, d);
    }
    setProperty(a, b) {
        switch (a) {
            case 333:
                this.a.add(typeCast(CT_ConditionalFormat.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ConditionalFormats.$t = markType(CT_ConditionalFormats, 'CT_ConditionalFormats', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ConditionalFormat extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
        this.d = 0;
        this.f = 0;
        this.h = 0;
    }
    static i(a, b, c, d) {
        b = 0;
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "scope":
                    b = XmlNamespaceDefinitionBase.b(ST_Scope_$type, e.d);
                    break;
                case "type":
                    c = XmlNamespaceDefinitionBase.b(ST_Type_$type, e.d);
                    break;
                case "priority":
                    d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static j(a, b, c, d, e) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        g = "priority";
        f = c.toString();
        a.ad.h(g, f);
        g = "scope";
        f = XmlNamespaceDefinitionBase.f(ST_Scope_$type, d);
        a.ad.h(g, f);
        g = "type";
        f = XmlNamespaceDefinitionBase.f(ST_Type_$type, e);
        a.ad.h(g, f);
    }
    setProperty(a, b) {
        switch (a) {
            case 1204:
                this.b = typeCast(CT_PivotAreas.$, b);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ConditionalFormat.$t = markType(CT_ConditionalFormat, 'CT_ConditionalFormat', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataValidation extends Base {
    constructor() {
        super();
        this.p = null;
        this.q = null;
        this.m = Nullable$1.toNullable(ST_DataValidationType_$type, null);
        this.g = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, null);
        this.h = Nullable$1.toNullable(ST_DataValidationImeMode_$type, null);
        this.i = Nullable$1.toNullable(ST_DataValidationOperator_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.o = null;
        this.n = null;
        this.s = null;
        this.r = null;
        this.a = null;
    }
    static u(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = Nullable$1.toNullable(ST_DataValidationType_$type, null);
        c = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, null);
        d = Nullable$1.toNullable(ST_DataValidationImeMode_$type, null);
        e = Nullable$1.toNullable(ST_DataValidationOperator_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = null;
        k = null;
        l = null;
        m = null;
        n = null;
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_DataValidationType_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationType_$type, o.d));
                    break;
                case "errorStyle":
                    c = Nullable$1.toNullable(ST_DataValidationErrorStyle_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationErrorStyle_$type, o.d));
                    break;
                case "imeMode":
                    d = Nullable$1.toNullable(ST_DataValidationImeMode_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationImeMode_$type, o.d));
                    break;
                case "operator":
                    e = Nullable$1.toNullable(ST_DataValidationOperator_$type, XmlNamespaceDefinitionBase.b(ST_DataValidationOperator_$type, o.d));
                    break;
                case "allowBlank":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "showDropDown":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "showInputMessage":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "showErrorMessage":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "errorTitle":
                    j = o.d;
                    break;
                case "error":
                    k = o.d;
                    break;
                case "promptTitle":
                    l = o.d;
                    break;
                case "prompt":
                    m = o.d;
                    break;
                case "sqref":
                    n = ST_Sqref.a(o.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static v(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        a.ad.p(b, null);
        let p = null;
        let q = null;
        if (c.hasValue) {
            q = "operator";
            p = XmlNamespaceDefinitionBase.f(ST_DataValidationOperator_$type, c.value);
            a.ad.h(q, p);
        }
        if (d.hasValue) {
            q = "allowBlank";
            p = ST_OnOff.g(d.value);
            a.ad.h(q, p);
        }
        if (e != null) {
            q = "error";
            p = e;
            a.ad.h(q, p);
        }
        if (f.hasValue) {
            q = "errorStyle";
            p = XmlNamespaceDefinitionBase.f(ST_DataValidationErrorStyle_$type, f.value);
            a.ad.h(q, p);
        }
        if (g != null) {
            q = "errorTitle";
            p = g;
            a.ad.h(q, p);
        }
        if (h.hasValue) {
            q = "imeMode";
            p = XmlNamespaceDefinitionBase.f(ST_DataValidationImeMode_$type, h.value);
            a.ad.h(q, p);
        }
        if (i != null) {
            q = "prompt";
            p = i;
            a.ad.h(q, p);
        }
        if (j != null) {
            q = "promptTitle";
            p = j;
            a.ad.h(q, p);
        }
        if (k.hasValue) {
            q = "showDropDown";
            p = ST_OnOff.g(k.value);
            a.ad.h(q, p);
        }
        if (l.hasValue) {
            q = "showErrorMessage";
            p = ST_OnOff.g(l.value);
            a.ad.h(q, p);
        }
        if (m.hasValue) {
            q = "showInputMessage";
            p = ST_OnOff.g(m.value);
            a.ad.h(q, p);
        }
        if (n.hasValue) {
            q = "type";
            p = XmlNamespaceDefinitionBase.f(ST_DataValidationType_$type, n.value);
            a.ad.h(q, p);
        }
        if (o != null) {
            q = "sqref";
            p = o.e();
            a.ad.h(q, p);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 678:
                this.p = typeCast(String_$type, b);
                break;
            case 679:
                this.q = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataValidation.$t = markType(CT_DataValidation, 'CT_DataValidation', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorScale extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.a = new List$1(CT_Cfvo.$, 0);
        this.b = new List$1(ColorInfo.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 252:
                this.a.add(typeCast(CT_Cfvo.$, b));
                break;
            case 302:
                this.b.add(typeCast(ColorInfo.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorScale.$t = markType(CT_ColorScale, 'CT_ColorScale', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CfRule extends Base {
    constructor() {
        super();
        this.k = null;
        this.b = null;
        this.c = null;
        this.d = null;
        this.a = null;
        this.e = 0;
        this.o = Nullable$1.toNullable(Number_$type, null);
        this.l = 0;
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
        this.r = Nullable$1.toNullable(Boolean_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.q = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        this.w = null;
        this.v = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        this.s = Nullable$1.toNullable(Number_$type, null);
        this.t = Nullable$1.toNullable(Number_$type, null);
        this.p = Nullable$1.toNullable(Boolean_$type, null);
        this.k = new List$1(String_$type, 0);
    }
    static y(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = 0;
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        j = null;
        k = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_CfType_$type, o.d);
                    break;
                case "dxfId":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "priority":
                    d = parseInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "stopIfTrue":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "aboveAverage":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "percent":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "bottom":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "operator":
                    i = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, XmlNamespaceDefinitionBase.b(ST_ConditionalFormattingOperator_$type, o.d));
                    break;
                case "text":
                    j = o.d;
                    break;
                case "timePeriod":
                    k = Nullable$1.toNullable(ST_TimePeriod_$type, XmlNamespaceDefinitionBase.b(ST_TimePeriod_$type, o.d));
                    break;
                case "rank":
                    l = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "stdDev":
                    m = Nullable$1.toNullable(Number_$type, parseInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "equalAverage":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static z(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        a.ad.p(b, null);
        let p = null;
        let q = null;
        if (c.hasValue) {
            q = "operator";
            p = XmlNamespaceDefinitionBase.f(ST_ConditionalFormattingOperator_$type, c.value);
            a.ad.h(q, p);
        }
        if (d.hasValue) {
            q = "aboveAverage";
            p = ST_OnOff.g(d.value);
            a.ad.h(q, p);
        }
        if (e.hasValue) {
            q = "bottom";
            p = ST_OnOff.g(e.value);
            a.ad.h(q, p);
        }
        if (f.hasValue) {
            q = "dxfId";
            p = f.value.toString();
            a.ad.h(q, p);
        }
        if (g.hasValue) {
            q = "equalAverage";
            p = ST_OnOff.g(g.value);
            a.ad.h(q, p);
        }
        if (h.hasValue) {
            q = "percent";
            p = ST_OnOff.g(h.value);
            a.ad.h(q, p);
        }
        if (i.hasValue) {
            q = "rank";
            p = i.value.toString();
            a.ad.h(q, p);
        }
        if (j.hasValue) {
            q = "stdDev";
            p = j.value.toString();
            a.ad.h(q, p);
        }
        if (k.hasValue) {
            q = "stopIfTrue";
            p = ST_OnOff.g(k.value);
            a.ad.h(q, p);
        }
        if (l != null) {
            q = "text";
            p = l;
            a.ad.h(q, p);
        }
        if (m.hasValue) {
            q = "timePeriod";
            p = XmlNamespaceDefinitionBase.f(ST_TimePeriod_$type, m.value);
            a.ad.h(q, p);
        }
        q = "priority";
        p = n.toString();
        a.ad.h(q, p);
        q = "type";
        p = XmlNamespaceDefinitionBase.f(ST_CfType_$type, o);
        a.ad.h(q, p);
    }
    setProperty(a, b) {
        switch (a) {
            case 677:
                this.k.add(typeCast(String_$type, b));
                break;
            case 310:
                this.b = typeCast(CT_ColorScale.$, b);
                break;
            case 411:
                this.c = typeCast(CT_DataBar.$, b);
                break;
            case 815:
                this.d = typeCast(CT_IconSet.$, b);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CfRule.$t = markType(CT_CfRule, 'CT_CfRule', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Cfvo extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = 0;
        this.f = null;
        this.d = Nullable$1.toNullable(Boolean_$type, null);
    }
    static g(a, b, c, d) {
        b = 0;
        c = null;
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_CfvoType_$type, e.d);
                    break;
                case "val":
                    c = e.d;
                    break;
                case "gte":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static h(a, b, c, d, e) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "gte";
            f = ST_OnOff.g(c.value);
            a.ad.h(g, f);
        }
        if (d != null) {
            g = "val";
            f = d;
            a.ad.h(g, f);
        }
        g = "type";
        f = XmlNamespaceDefinitionBase.f(ST_CfvoType_$type, e);
        a.ad.h(g, f);
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Cfvo.$t = markType(CT_Cfvo, 'CT_Cfvo', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataBar extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
        this.e = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.c = new List$1(CT_Cfvo.$, 0);
    }
    static j(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "minLength":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "maxLength":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "showValue":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static k(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "maxLength";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "minLength";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "showValue";
            f = ST_OnOff.g(e.value);
            a.ad.h(g, f);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 252:
                this.c.add(typeCast(CT_Cfvo.$, b));
                break;
            case 302:
                this.a = typeCast(ColorInfo.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataBar.$t = markType(CT_DataBar, 'CT_DataBar', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_IconSet extends Base {
    constructor() {
        super();
        this.e = null;
        this.f = Nullable$1.toNullable(ST_IconSetType_$type, null);
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.d = false;
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.e = new List$1(CT_Cfvo.$, 0);
    }
    static j(a, b, c, d, e) {
        b = Nullable$1.toNullable(ST_IconSetType_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = false;
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "iconSet":
                    b = Nullable$1.toNullable(ST_IconSetType_$type, XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, f.d));
                    break;
                case "showValue":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "percent":
                    d = ST_OnOff.e(f.d);
                    break;
                case "reverse":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static k(a, b, c, d, e, f) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "iconSet";
            g = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, c.value);
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "reverse";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "showValue";
            g = ST_OnOff.g(e.value);
            a.ad.h(h, g);
        }
        h = "percent";
        g = ST_OnOff.g(f);
        a.ad.h(h, g);
    }
    setProperty(a, b) {
        switch (a) {
            case 252:
                this.e.add(typeCast(CT_Cfvo.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_IconSet.$t = markType(CT_IconSet, 'CT_IconSet', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Font extends Base {
    constructor() {
        super();
        this.i = null;
        this.l = null;
        this.m = null;
        this.b = null;
        this.e = null;
        this.h = null;
        this.f = null;
        this.g = null;
        this.c = null;
        this.d = null;
        this.a = null;
        this.k = null;
        this.n = null;
        this.o = null;
        this.j = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1045:
                this.i = typeCast(CT_FontName.$, b);
                break;
            case 260:
                this.l = typeCast(CT_IntProperty.$, b);
                break;
            case 617:
                this.m = typeCast(CT_IntProperty.$, b);
                break;
            case 86:
                this.b = typeCast(CT_BooleanProperty.$, b);
                break;
            case 808:
                this.e = typeCast(CT_BooleanProperty.$, b);
                break;
            case 1610:
                this.h = typeCast(CT_BooleanProperty.$, b);
                break;
            case 1143:
                this.f = typeCast(CT_BooleanProperty.$, b);
                break;
            case 1460:
                this.g = typeCast(CT_BooleanProperty.$, b);
                break;
            case 332:
                this.c = typeCast(CT_BooleanProperty.$, b);
                break;
            case 600:
                this.d = typeCast(CT_BooleanProperty.$, b);
                break;
            case 302:
                this.a = typeCast(ColorInfo.$, b);
                break;
            case 1653:
                this.k = typeCast(CT_FontSize.$, b);
                break;
            case 1789:
                this.n = typeCast(CT_UnderlineProperty.$, b);
                break;
            case 1836:
                this.o = typeCast(CT_VerticalAlignFontProperty.$, b);
                break;
            case 1428:
                this.j = typeCast(CT_FontScheme_SML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Font.$t = markType(CT_Font, 'CT_Font', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Dxf extends Base {
    constructor() {
        super();
        this.l = null;
        this.n = null;
        this.j = null;
        this.f = null;
        this.d = null;
        this.h = null;
        this.b = null;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 659:
                this.k = typeCast(CT_Font.$, b);
                break;
            case 1088:
                this.m = typeCast(CT_NumFmt.$, b);
                break;
            case 630:
                this.i = typeCast(CT_Fill.$, b);
                break;
            case 27:
                this.e = typeCast(CT_CellAlignment.$, b);
                break;
            case 149:
                this.c = typeCast(CT_Border.$, b);
                break;
            case 1271:
                this.g = typeCast(CT_CellProtection.$, b);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Dxf.$t = markType(CT_Dxf, 'CT_Dxf', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BooleanProperty extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c.hasValue ? this.c.value : true;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "val";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BooleanProperty.$t = markType(CT_BooleanProperty, 'CT_BooleanProperty');
/**
 * @hidden
 */
export class CT_IntProperty extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_IntProperty.$t = markType(CT_IntProperty, 'CT_IntProperty');
/**
 * @hidden
 */
export class CT_FontName extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    static c(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c != null) {
            e = "val";
            d = c;
            a.ad.h(e, d);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FontName.$t = markType(CT_FontName, 'CT_FontName');
/**
 * @hidden
 */
export class CT_FontScheme_SML extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_FontScheme_$type, c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_FontScheme_$type, c);
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FontScheme_SML.$t = markType(CT_FontScheme_SML, 'CT_FontScheme_SML');
/**
 * @hidden
 */
export class CT_FontSize extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FontSize.$t = markType(CT_FontSize, 'CT_FontSize');
/**
 * @hidden
 */
export class CT_UnderlineProperty extends Base {
    constructor() {
        super();
        this.a = Nullable$1.toNullable(ST_UnderlineValues_$type, null);
    }
    static c(a, b) {
        b = Nullable$1.toNullable(ST_UnderlineValues_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(ST_UnderlineValues_$type, XmlNamespaceDefinitionBase.b(ST_UnderlineValues_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c = Nullable$1.toNullable(ST_UnderlineValues_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "val";
            d = XmlNamespaceDefinitionBase.f(ST_UnderlineValues_$type, c.value);
            a.ad.h(e, d);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_UnderlineProperty.$t = markType(CT_UnderlineProperty, 'CT_UnderlineProperty');
/**
 * @hidden
 */
export class CT_VerticalAlignFontProperty extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
    }
    static c(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_VerticalAlignRun_$type, c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d(a, b, c) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_VerticalAlignRun_$type, c);
        a.ad.h(e, d);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_VerticalAlignFontProperty.$t = markType(CT_VerticalAlignFontProperty, 'CT_VerticalAlignFontProperty');
/**
 * @hidden
 */
export class CT_ConditionalFormatting extends Base {
    constructor() {
        super();
        this.e = null;
        this.a = null;
        this.d = false;
        this.b = null;
        this.e = new List$1(CT_CfRule.$, 0);
    }
    static g(a, b, c) {
        b = false;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "pivot":
                    b = ST_OnOff.e(d.d);
                    break;
                case "sqref":
                    c = ST_Sqref.a(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        f = "pivot";
        e = ST_OnOff.g(c);
        a.ad.h(f, e);
        if (d != null) {
            f = "sqref";
            e = d.e();
            a.ad.h(f, e);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 251:
                this.e.add(typeCast(CT_CfRule.$, b));
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ConditionalFormatting.$t = markType(CT_ConditionalFormatting, 'CT_ConditionalFormatting', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ProtectedRange extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
        this.b = null;
        this.d = null;
    }
    static f(a, b, c, d, e) {
        b = null;
        c = null;
        d = null;
        e = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "password":
                    b = f.d;
                    break;
                case "sqref":
                    c = ST_Sqref.a(f.d);
                    break;
                case "name":
                    d = f.d;
                    break;
                case "securityDescriptor":
                    e = f.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static g(a, b, c, d, e, f) {
        a.ad.p(b, null);
        let g = null;
        let h = null;
        if (c != null) {
            h = "password";
            g = c;
            a.ad.h(h, g);
        }
        if (d != null) {
            h = "securityDescriptor";
            g = d;
            a.ad.h(h, g);
        }
        if (e != null) {
            h = "name";
            g = e;
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "sqref";
            g = f.e();
            a.ad.h(h, g);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ProtectedRange.$t = markType(CT_ProtectedRange, 'CT_ProtectedRange');
/**
 * @hidden
 */
export class CT_NumFmt extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
        this.a = null;
    }
    static d(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "numFmtId":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "formatCode":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static e(a, b, c, d) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c != null) {
            f = "formatCode";
            e = c;
            a.ad.h(f, e);
        }
        f = "numFmtId";
        e = d.toString();
        a.ad.h(f, e);
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumFmt.$t = markType(CT_NumFmt, 'CT_NumFmt');
/**
 * @hidden
 */
export class CT_Fill extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.a = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1175:
                this.b = typeCast(CT_PatternFill.$, b);
                break;
            case 726:
                this.a = typeCast(CT_GradientFill.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Fill.$t = markType(CT_Fill, 'CT_Fill', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GradientFill extends Base {
    constructor() {
        super();
        this.a = 0;
        this.b = null;
        this.m = Nullable$1.toNullable(ST_GradientType_$type, null);
        this.i = Nullable$1.toNullable(Number_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
        this.k = Nullable$1.toNullable(Number_$type, null);
        this.l = Nullable$1.toNullable(Number_$type, null);
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.b = new List$1(CT_GradientStop.$, 0);
    }
    static o(a, b, c, d, e, f, g) {
        b = Nullable$1.toNullable(ST_GradientType_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_GradientType_$type, XmlNamespaceDefinitionBase.b(ST_GradientType_$type, h.d));
                    break;
                case "degree":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(h.d, CultureInfo.invariantCulture));
                    break;
                case "left":
                    d = Nullable$1.toNullable(Number_$type, parseNumber(h.d, CultureInfo.invariantCulture));
                    break;
                case "right":
                    e = Nullable$1.toNullable(Number_$type, parseNumber(h.d, CultureInfo.invariantCulture));
                    break;
                case "top":
                    f = Nullable$1.toNullable(Number_$type, parseNumber(h.d, CultureInfo.invariantCulture));
                    break;
                case "bottom":
                    g = Nullable$1.toNullable(Number_$type, parseNumber(h.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static p(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(ST_GradientType_$type, null)) {
        a.ad.p(b, null);
        let i = null;
        let j = null;
        if (c.hasValue) {
            j = "bottom";
            i = c.value.toString();
            a.ad.h(j, i);
        }
        if (d.hasValue) {
            j = "degree";
            i = d.value.toString();
            a.ad.h(j, i);
        }
        if (e.hasValue) {
            j = "left";
            i = e.value.toString();
            a.ad.h(j, i);
        }
        if (f.hasValue) {
            j = "right";
            i = f.value.toString();
            a.ad.h(j, i);
        }
        if (g.hasValue) {
            j = "top";
            i = g.value.toString();
            a.ad.h(j, i);
        }
        if (h.hasValue) {
            j = "type";
            i = XmlNamespaceDefinitionBase.f(ST_GradientType_$type, h.value);
            a.ad.h(j, i);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 1599:
                this.b.add(typeCast(CT_GradientStop.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GradientFill.$t = markType(CT_GradientFill, 'CT_GradientFill', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PatternFill extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
        this.c = Nullable$1.toNullable(ST_PatternType_$type, null);
    }
    static e(a, b) {
        b = Nullable$1.toNullable(ST_PatternType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "patternType":
                    b = Nullable$1.toNullable(ST_PatternType_$type, XmlNamespaceDefinitionBase.b(ST_PatternType_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(ST_PatternType_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "patternType";
            d = XmlNamespaceDefinitionBase.f(ST_PatternType_$type, c.value);
            a.ad.h(e, d);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 619:
                this.b = typeCast(ColorInfo.$, b);
                break;
            case 113:
                this.a = typeCast(ColorInfo.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PatternFill.$t = markType(CT_PatternFill, 'CT_PatternFill', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CellAlignment extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_HorizontalAlignment_$type, null);
        this.h = Nullable$1.toNullable(ST_VerticalAlignment_$type, null);
        this.g = Nullable$1.toNullable(Number_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.b = Nullable$1.toNullable(Number_$type, null);
        this.e = Nullable$1.toNullable(Number_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    static k(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(ST_HorizontalAlignment_$type, null);
        c = Nullable$1.toNullable(ST_VerticalAlignment_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "horizontal":
                    b = Nullable$1.toNullable(ST_HorizontalAlignment_$type, XmlNamespaceDefinitionBase.b(ST_HorizontalAlignment_$type, k.d));
                    break;
                case "vertical":
                    c = Nullable$1.toNullable(ST_VerticalAlignment_$type, XmlNamespaceDefinitionBase.b(ST_VerticalAlignment_$type, k.d));
                    break;
                case "textRotation":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "wrapText":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "indent":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "relativeIndent":
                    g = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "justifyLastLine":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "shrinkToFit":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "readingOrder":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static l(a, b, c = Nullable$1.toNullable(ST_HorizontalAlignment_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(ST_VerticalAlignment_$type, null), k = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "horizontal";
            l = XmlNamespaceDefinitionBase.f(ST_HorizontalAlignment_$type, c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "indent";
            l = d.value.toString();
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "justifyLastLine";
            l = ST_OnOff.g(e.value);
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "readingOrder";
            l = f.value.toString();
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "relativeIndent";
            l = g.value.toString();
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "shrinkToFit";
            l = ST_OnOff.g(h.value);
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "textRotation";
            l = i.value.toString();
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "vertical";
            l = XmlNamespaceDefinitionBase.f(ST_VerticalAlignment_$type, j.value);
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "wrapText";
            l = ST_OnOff.g(k.value);
            a.ad.h(m, l);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CellAlignment.$t = markType(CT_CellAlignment, 'CT_CellAlignment');
/**
 * @hidden
 */
export class CT_Border extends Base {
    constructor() {
        super();
        this.d = null;
        this.e = null;
        this.f = null;
        this.a = null;
        this.b = null;
        this.g = null;
        this.c = null;
        this.j = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
    }
    static m(a, b, c, d) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "diagonalUp":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "diagonalDown":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "outline":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static n(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "diagonalDown";
            f = ST_OnOff.g(c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "diagonalUp";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "outline";
            f = ST_OnOff.g(e.value);
            a.ad.h(g, f);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 887:
                this.d = typeCast(CT_BorderPr.$, b);
                break;
            case 1363:
                this.e = typeCast(CT_BorderPr.$, b);
                break;
            case 1754:
                this.f = typeCast(CT_BorderPr.$, b);
                break;
            case 160:
                this.a = typeCast(CT_BorderPr.$, b);
                break;
            case 476:
                this.b = typeCast(CT_BorderPr.$, b);
                break;
            case 1838:
                this.g = typeCast(CT_BorderPr.$, b);
                break;
            case 795:
                this.c = typeCast(CT_BorderPr.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Border.$t = markType(CT_Border, 'CT_Border', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BorderPr extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = Nullable$1.toNullable(ST_BorderStyle_$type, null);
    }
    static d(a, b) {
        b = Nullable$1.toNullable(ST_BorderStyle_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "style":
                    b = Nullable$1.toNullable(ST_BorderStyle_$type, XmlNamespaceDefinitionBase.b(ST_BorderStyle_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static e(a, b, c = Nullable$1.toNullable(ST_BorderStyle_$type, null)) {
        a.ad.p(b, null);
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "style";
            d = XmlNamespaceDefinitionBase.f(ST_BorderStyle_$type, c.value);
            a.ad.h(e, d);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 302:
                this.a = typeCast(ColorInfo.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BorderPr.$t = markType(CT_BorderPr, 'CT_BorderPr', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CellProtection extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.a = Nullable$1.toNullable(Boolean_$type, null);
    }
    static d(a, b, c) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "locked":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                case "hidden":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static e(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "hidden";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "locked";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CellProtection.$t = markType(CT_CellProtection, 'CT_CellProtection');
/**
 * @hidden
 */
export class ST_CellSpans extends Base {
    constructor() {
        super();
        this.c = null;
        this.c = new List$1(String_$type, 0);
    }
    static a(a) {
        return ST_CellSpans.b(a);
    }
    d() {
        return this.e();
    }
    static b(a) {
        let b = new ST_CellSpans();
        b.c = XmlNamespaceDefinitionBase.e(String_$type, a, (c) => c);
        return b;
    }
    e() {
        let a = new StringBuilder(0);
        let b = this.c.count - 1;
        for (let c = 0; c <= b; c++) {
            let d = this.c._inner[c];
            a.l(d);
            if (c < b) {
                a.l(" ");
            }
        }
        return a.toString();
    }
}
ST_CellSpans.$t = markType(ST_CellSpans, 'ST_CellSpans');
/**
 * @hidden
 */
export class SMLAttributes extends Base {
}
SMLAttributes.$t = markType(SMLAttributes, 'SMLAttributes');
/**
 * @hidden
 */
export class CT_AudioFile extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AudioFile.$t = markType(CT_AudioFile, 'CT_AudioFile', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_VideoFile extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_VideoFile.$t = markType(CT_VideoFile, 'CT_VideoFile', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_QuickTimeFile extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:link";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_QuickTimeFile.$t = markType(CT_QuickTimeFile, 'CT_QuickTimeFile', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AudioCDTime extends Base {
    constructor() {
        super();
        this.b = 0;
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static g(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "track":
                    b = parseUInt8_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "time":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "time";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        f = "track";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AudioCDTime.$t = markType(CT_AudioCDTime, 'CT_AudioCDTime');
/**
 * @hidden
 */
export class CT_AudioCD extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1588:
                this.c = typeCast(CT_AudioCDTime.$, b);
                break;
            case 573:
                this.a = typeCast(CT_AudioCDTime.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AudioCD.$t = markType(CT_AudioCD, 'CT_AudioCD', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorScheme extends Base {
    constructor() {
        super();
        this.n = null;
        this.v = null;
        this.p = null;
        this.x = null;
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
        this.j = null;
        this.l = null;
        this.t = null;
        this.r = null;
        this.z = null;
        this.ab = null;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    static ad(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static ae(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 503:
                this.m = typeCast(CT_Color_DML.$, b);
                break;
            case 939:
                this.u = typeCast(CT_Color_DML.$, b);
                break;
            case 504:
                this.o = typeCast(CT_Color_DML.$, b);
                break;
            case 940:
                this.w = typeCast(CT_Color_DML.$, b);
                break;
            case 7:
                this.a = typeCast(CT_Color_DML.$, b);
                break;
            case 8:
                this.c = typeCast(CT_Color_DML.$, b);
                break;
            case 9:
                this.e = typeCast(CT_Color_DML.$, b);
                break;
            case 10:
                this.g = typeCast(CT_Color_DML.$, b);
                break;
            case 11:
                this.i = typeCast(CT_Color_DML.$, b);
                break;
            case 12:
                this.k = typeCast(CT_Color_DML.$, b);
                break;
            case 790:
                this.s = typeCast(CT_Color_DML.$, b);
                break;
            case 658:
                this.q = typeCast(CT_Color_DML.$, b);
                break;
            case 601:
                this.y = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorScheme.$t = markType(CT_ColorScheme, 'CT_ColorScheme', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CustomColor extends Base {
    constructor() {
        super();
        this.d = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c = null) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.g(a)) {
                    this.b.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CustomColor.$t = markType(CT_CustomColor, 'CT_CustomColor', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SupplementalFont extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.e = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "script":
                    b = d.d;
                    break;
                case "typeface":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c != null) {
            f = "script";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "typeface";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SupplementalFont.$t = markType(CT_SupplementalFont, 'CT_SupplementalFont');
/**
 * @hidden
 */
export class CT_CustomColorList extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 366:
                this.a.add(typeCast(CT_CustomColor.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CustomColorList.$t = markType(CT_CustomColorList, 'CT_CustomColorList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FontCollection extends Base {
    constructor() {
        super();
        this.h = null;
        this.f = null;
        this.d = null;
        this.j = null;
        this.b = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 875:
                this.g = typeCast(CT_TextFont.$, b);
                break;
            case 551:
                this.e = typeCast(CT_TextFont.$, b);
                break;
            case 363:
                this.c = typeCast(CT_TextFont.$, b);
                break;
            case 659:
                this.i.add(typeCast(CT_SupplementalFont.$, b));
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FontCollection.$t = markType(CT_FontCollection, 'CT_FontCollection', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EffectStyleItem extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.e = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_EffectProperties();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 1423:
                this.a = typeCast(CT_Scene3D.$, b);
                break;
            case 1564:
                this.c = typeCast(CT_Shape3D.$, b);
                break;
            default:
                if (this.f.c(a)) {
                    this.f.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EffectStyleItem.$t = markType(CT_EffectStyleItem, 'CT_EffectStyleItem', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FontScheme extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    static j(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static k(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 962:
                this.a = typeCast(CT_FontCollection.$, b);
                break;
            case 1010:
                this.c = typeCast(CT_FontCollection.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FontScheme.$t = markType(CT_FontScheme, 'CT_FontScheme', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EffectStyleList extends Base {
    constructor() {
        super();
        this.d = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 562:
                this.c.add(typeCast(CT_EffectStyleItem.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static e(a) {
        return a != null ? a.c : null;
    }
    static a(a) {
        let b = new CT_EffectStyleList();
        b.d = a;
        return b;
    }
}
CT_EffectStyleList.$t = markType(CT_EffectStyleList, 'CT_EffectStyleList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BaseStyles extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.h = null;
        this.f = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 286:
                this.a = typeCast(CT_ColorScheme.$, b);
                break;
            case 661:
                this.c = typeCast(CT_FontScheme.$, b);
                break;
            case 657:
                this.g = typeCast(CT_StyleMatrix.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BaseStyles.$t = markType(CT_BaseStyles, 'CT_BaseStyles', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_OfficeArtExtension extends Base {
    constructor() {
        super(...arguments);
        this.h = null;
        this.c = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "uri":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "uri";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    e(a, b, c, d) {
        CT_OfficeArtExtension.f(a, d, this.b);
        c.k();
    }
}
CT_OfficeArtExtension.$t = markType(CT_OfficeArtExtension, 'CT_OfficeArtExtension');
/**
 * @hidden
 */
export class CT_Ratio extends Base {
    constructor() {
        super(...arguments);
        this.d = 0;
        this.b = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b, c) {
        b = 0;
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "n":
                    b = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "d":
                    c = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        f = "d";
        e = c.toString();
        a.ad.h(f, e);
        f = "n";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Ratio.$t = markType(CT_Ratio, 'CT_Ratio');
/**
 * @hidden
 */
export class CT_GammaTransform extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GammaTransform.$t = markType(CT_GammaTransform, 'CT_GammaTransform');
/**
 * @hidden
 */
export class CT_InverseGammaTransform extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_InverseGammaTransform.$t = markType(CT_InverseGammaTransform, 'CT_InverseGammaTransform');
/**
 * @hidden
 */
export class CT_OfficeArtExtensionList extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_OfficeArtExtensionList();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.a(a)) {
                    this.b.d(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    d(a, b, c, d) {
        if (this.b.b == null || this.b.b.count == 0) {
            return;
        }
        c.p(d, "a");
        for (let e of fromEnum(this.b.b)) {
            CT_OfficeArtExtension.f(a, DrawingMLMain.dq, e.b);
            c.k();
        }
        c.k();
    }
}
CT_OfficeArtExtensionList.$t = markType(CT_OfficeArtExtensionList, 'CT_OfficeArtExtensionList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Scale2D extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1648:
                this.a = typeCast(CT_Ratio.$, b);
                break;
            case 1649:
                this.c = typeCast(CT_Ratio.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Scale2D.$t = markType(CT_Scale2D, 'CT_Scale2D', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Point3D extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = 0;
        this.f = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c, d) {
        b = 0;
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "x":
                    b = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "y":
                    c = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "z":
                    d = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static i(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        g = "x";
        f = c.toString();
        a.ad.h(g, f);
        g = "y";
        f = d.toString();
        a.ad.h(g, f);
        g = "z";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Point3D.$t = markType(CT_Point3D, 'CT_Point3D');
/**
 * @hidden
 */
export class CT_Vector3D extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
        this.e = 0;
        this.g = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static a(a) {
        let b, c, d;
        let e = CT_Vector3D.i(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_Vector3D();
            $ret.b = b;
            $ret.d = c;
            $ret.f = d;
            return $ret;
        })());
    }
    static i(a, b, c, d) {
        b = 0;
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "dx":
                    b = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "dy":
                    c = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "dz":
                    d = parseInt64_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static j(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        g = "dx";
        f = c.toString();
        a.ad.h(g, f);
        g = "dy";
        f = d.toString();
        a.ad.h(g, f);
        g = "dz";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Vector3D.$t = markType(CT_Vector3D, 'CT_Vector3D');
/**
 * @hidden
 */
export class CT_SphereCoords extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = 0;
        this.f = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c, d) {
        b = 0;
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "lat":
                    b = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "lon":
                    c = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "rev":
                    d = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static i(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        g = "lat";
        f = c.toString();
        a.ad.h(g, f);
        g = "lon";
        f = d.toString();
        a.ad.h(g, f);
        g = "rev";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SphereCoords.$t = markType(CT_SphereCoords, 'CT_SphereCoords');
/**
 * @hidden
 */
export class CT_Color_DML extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.g(a)) {
                    this.b.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    d(a, b, c, d) {
        c.p(d, "a");
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
}
CT_Color_DML.$t = markType(CT_Color_DML, 'CT_Color_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorMRU extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.g(a)) {
                    this.b.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorMRU.$t = markType(CT_ColorMRU, 'CT_ColorMRU', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AnimationDgmElement extends Base {
    constructor() {
        super();
        this.f = null;
        this.c = Nullable$1.toNullable(ST_DgmBuildStep_$type, null);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static h(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(ST_DgmBuildStep_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "id":
                    b = d.d;
                    break;
                case "bldStep":
                    c = Nullable$1.toNullable(ST_DgmBuildStep_$type, XmlNamespaceDefinitionBase.b(ST_DgmBuildStep_$type, d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(ST_DgmBuildStep_$type, null), d = null) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "bldStep";
            e = XmlNamespaceDefinitionBase.f(ST_DgmBuildStep_$type, c.value);
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "id";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AnimationDgmElement.$t = markType(CT_AnimationDgmElement, 'CT_AnimationDgmElement');
/**
 * @hidden
 */
export class CT_AnimationChartElement extends Base {
    constructor() {
        super();
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.b = 0;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static j(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "seriesIdx":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "categoryIdx":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "bldStep":
                    d = XmlNamespaceDefinitionBase.b(ST_ChartBuildStep_$type, e.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static k(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "categoryIdx";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "seriesIdx";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        g = "bldStep";
        f = XmlNamespaceDefinitionBase.f(ST_ChartBuildStep_$type, e);
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AnimationChartElement.$t = markType(CT_AnimationChartElement, 'CT_AnimationChartElement');
/**
 * @hidden
 */
export class CT_AnimationElementChoice extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_AnimationElementChoice.$t = markType(CT_AnimationElementChoice, 'CT_AnimationElementChoice', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AnimationDgmBuildProperties extends Base {
    constructor() {
        super();
        this.b = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static g(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "bld":
                    b = ST_AnimationDgmBuildType.a(d.d);
                    break;
                case "rev":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c = null, d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c != null) {
            f = "bld";
            e = c.g();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rev";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AnimationDgmBuildProperties.$t = markType(CT_AnimationDgmBuildProperties, 'CT_AnimationDgmBuildProperties');
/**
 * @hidden
 */
export class CT_AnimationChartBuildProperties extends Base {
    constructor() {
        super();
        this.b = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static g(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "bld":
                    b = ST_AnimationChartBuildType.a(d.d);
                    break;
                case "animBg":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = null) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "animBg";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "bld";
            e = d.g();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AnimationChartBuildProperties.$t = markType(CT_AnimationChartBuildProperties, 'CT_AnimationChartBuildProperties');
/**
 * @hidden
 */
export class CT_AnimationGraphicalObjectBuildProperties extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_AnimationGraphicalObjectBuildProperties.$t = markType(CT_AnimationGraphicalObjectBuildProperties, 'CT_AnimationGraphicalObjectBuildProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class ST_AnimationDgmBuildType extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(ST_AnimationBuildType_$type, null);
        this.d = Nullable$1.toNullable(ST_AnimationDgmOnlyBuildType_$type, null);
    }
    get e() {
        return this.c;
    }
    set e(a) {
        this.c = a;
    }
    get f() {
        return this.d;
    }
    set f(a) {
        this.d = a;
    }
    static a(a) {
        return ST_AnimationDgmBuildType.b(a);
    }
    g() {
        return this.h();
    }
    static b(a) {
        let b = new ST_AnimationDgmBuildType();
        let c;
        let d;
        if (((() => { let e = EnumUtil.tryParse$1(ST_AnimationBuildType_$type, a, true, d); d = e.p2; return e.ret; })())) {
            b.e = Nullable$1.toNullable(ST_AnimationBuildType_$type, d);
        }
        else if (((() => { let e = EnumUtil.tryParse$1(ST_AnimationDgmOnlyBuildType_$type, a, true, c); c = e.p2; return e.ret; })())) {
            b.f = Nullable$1.toNullable(ST_AnimationDgmOnlyBuildType_$type, c);
        }
        return b;
    }
    h() {
        return this.e.hasValue ? this.e.toString() : this.f.hasValue ? this.f.toString() : null;
    }
}
ST_AnimationDgmBuildType.$t = markType(ST_AnimationDgmBuildType, 'ST_AnimationDgmBuildType');
/**
 * @hidden
 */
export class ST_AnimationChartBuildType extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(ST_AnimationBuildType_$type, null);
        this.d = Nullable$1.toNullable(ST_AnimationChartOnlyBuildType_$type, null);
    }
    get e() {
        return this.c;
    }
    set e(a) {
        this.c = a;
    }
    get f() {
        return this.d;
    }
    set f(a) {
        this.d = a;
    }
    static a(a) {
        return ST_AnimationChartBuildType.b(a);
    }
    g() {
        return this.h();
    }
    static b(a) {
        let b = new ST_AnimationChartBuildType();
        let c;
        let d;
        if (((() => { let e = EnumUtil.tryParse$1(ST_AnimationBuildType_$type, a, true, c); c = e.p2; return e.ret; })())) {
            b.e = Nullable$1.toNullable(ST_AnimationBuildType_$type, c);
        }
        else if (((() => { let e = EnumUtil.tryParse$1(ST_AnimationChartOnlyBuildType_$type, a, true, d); d = e.p2; return e.ret; })())) {
            b.f = Nullable$1.toNullable(ST_AnimationChartOnlyBuildType_$type, d);
        }
        return b;
    }
    h() {
        return this.e.hasValue ? this.e.toString() : this.f.hasValue ? this.f.toString() : null;
    }
}
ST_AnimationChartBuildType.$t = markType(ST_AnimationChartBuildType, 'ST_AnimationChartBuildType');
/**
 * @hidden
 */
export class CT_BackgroundFormatting extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_FillProperties();
        }
        return this.c;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_EffectProperties();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.d.f(a)) {
                    this.d.j(a, b);
                    return;
                }
                else if (this.b.c(a)) {
                    this.b.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BackgroundFormatting.$t = markType(CT_BackgroundFormatting, 'CT_BackgroundFormatting', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_WholeE2oFormatting extends Base {
    constructor() {
        super();
        this.b = null;
        this.c = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_EffectProperties();
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 918:
                this.a = typeCast(CT_LineProperties_DML.$, b);
                break;
            default:
                if (this.d.c(a)) {
                    this.d.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_WholeE2oFormatting.$t = markType(CT_WholeE2oFormatting, 'CT_WholeE2oFormatting', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlUseShapeRectangle extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlUseShapeRectangle.$t = markType(CT_GvmlUseShapeRectangle, 'CT_GvmlUseShapeRectangle');
/**
 * @hidden
 */
export class CT_GvmlTextShape extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get item() {
        return this.f;
    }
    set item(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_GvmlTextShape.$t = markType(CT_GvmlTextShape, 'CT_GvmlTextShape', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlShapeNonVisual extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.a = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 203:
                this.c = typeCast(CT_NonVisualDrawingShapeProps.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlShapeNonVisual.$t = markType(CT_GvmlShapeNonVisual, 'CT_GvmlShapeNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlShape extends Base {
    constructor() {
        super();
        this.b = null;
        this.h = null;
        this.d = null;
        this.j = null;
        this.f = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1106:
                this.a = typeCast(CT_GvmlShapeNonVisual.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1784:
                this.c = typeCast(CT_GvmlTextShape.$, b);
                break;
            case 1618:
                this.i = typeCast(CT_ShapeStyle.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlShape.$t = markType(CT_GvmlShape, 'CT_GvmlShape', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlConnectorNonVisual extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.c = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 198:
                this.a = typeCast(CT_NonVisualConnectorProperties.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlConnectorNonVisual.$t = markType(CT_GvmlConnectorNonVisual, 'CT_GvmlConnectorNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlConnector extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.h = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1102:
                this.a = typeCast(CT_GvmlConnectorNonVisual.$, b);
                break;
            case 1570:
                this.e = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1618:
                this.g = typeCast(CT_ShapeStyle.$, b);
                break;
            case 601:
                this.c = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlConnector.$t = markType(CT_GvmlConnector, 'CT_GvmlConnector', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlPictureNonVisual extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.a = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 201:
                this.c = typeCast(CT_NonVisualPictureProperties.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlPictureNonVisual.$t = markType(CT_GvmlPictureNonVisual, 'CT_GvmlPictureNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlPicture extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.h = null;
        this.j = null;
        this.f = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1105:
                this.c = typeCast(CT_GvmlPictureNonVisual.$, b);
                break;
            case 128:
                this.a = typeCast(CT_BlipFillProperties_DML.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1618:
                this.i = typeCast(CT_ShapeStyle.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlPicture.$t = markType(CT_GvmlPicture, 'CT_GvmlPicture', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlGraphicFrameNonVisual extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.a = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 199:
                this.c = typeCast(CT_NonVisualGraphicFrameProperties.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlGraphicFrameNonVisual.$t = markType(CT_GvmlGraphicFrameNonVisual, 'CT_GvmlGraphicFrameNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlGraphicalObjectFrame extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.h = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1103:
                this.a = typeCast(CT_GvmlGraphicFrameNonVisual.$, b);
                break;
            case 727:
                this.e = typeCast(CT_GraphicalObject.$, b);
                break;
            case 1892:
                this.g = typeCast(CT_Transform2D.$, b);
                break;
            case 601:
                this.c = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlGraphicalObjectFrame.$t = markType(CT_GvmlGraphicalObjectFrame, 'CT_GvmlGraphicalObjectFrame', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlGroupShapeNonVisual extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.a = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 200:
                this.c = typeCast(CT_NonVisualGroupDrawingShapeProps.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GvmlGroupShapeNonVisual.$t = markType(CT_GvmlGroupShapeNonVisual, 'CT_GvmlGroupShapeNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GvmlGroupShape extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.h = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_GvmlGroupShape.$t = markType(CT_GvmlGroupShape, 'CT_GvmlGroupShape', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Camera extends Base {
    constructor() {
        super();
        this.c = null;
        this.e = 0;
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static a(a) {
        let b = 0;
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = CT_Camera.l(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_Camera();
            $ret.d = b;
            $ret.g = c;
            $ret.i = d;
            return $ret;
        })());
    }
    static l(a, b, c, d) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "prst":
                    b = XmlNamespaceDefinitionBase.b(ST_PresetCameraType_$type, e.d);
                    break;
                case "fov":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "zoom":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static m(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "fov";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "zoom";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        g = "prst";
        f = XmlNamespaceDefinitionBase.f(ST_PresetCameraType_$type, e);
        a.ad.h(g, f);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1370:
                this.b = typeCast(CT_SphereCoords.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Camera.$t = markType(CT_Camera, 'CT_Camera', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LightRig extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = 0;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static h(a, b, c) {
        b = 0;
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "rig":
                    b = XmlNamespaceDefinitionBase.b(ST_LightRigType_$type, d.d);
                    break;
                case "dir":
                    c = XmlNamespaceDefinitionBase.b(ST_LightRigDirection_$type, d.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        f = "dir";
        e = XmlNamespaceDefinitionBase.f(ST_LightRigDirection_$type, c);
        a.ad.h(f, e);
        f = "rig";
        e = XmlNamespaceDefinitionBase.f(ST_LightRigType_$type, d);
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1370:
                this.a = typeCast(CT_SphereCoords.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LightRig.$t = markType(CT_LightRig, 'CT_LightRig', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Scene3D extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.h = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 224:
                this.c = typeCast(CT_Camera.$, b);
                break;
            case 896:
                this.e = typeCast(CT_LightRig.$, b);
                break;
            case 89:
                this.a = typeCast(CT_Backdrop.$, b);
                break;
            case 601:
                this.g = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Scene3D.$t = markType(CT_Scene3D, 'CT_Scene3D', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Backdrop extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.h = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 45:
                this.c = typeCast(CT_Point3D.$, b);
                break;
            case 1072:
                this.e = typeCast(CT_Vector3D.$, b);
                break;
            case 1806:
                this.g = typeCast(CT_Vector3D.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Backdrop.$t = markType(CT_Backdrop, 'CT_Backdrop', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Bevel extends Base {
    constructor() {
        super();
        this.j = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.h = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        let e = CT_Bevel.l(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_Bevel();
            $ret.e = c;
            $ret.g = d;
            $ret.i = b;
            return $ret;
        })());
    }
    static l(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "w":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "h":
                    c = Nullable$1.toNullable(Number_$type, parseInt64_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "prst":
                    d = Nullable$1.toNullable(ST_BevelPresetType_$type, XmlNamespaceDefinitionBase.b(ST_BevelPresetType_$type, e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static m(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(ST_BevelPresetType_$type, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "h";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "prst";
            f = XmlNamespaceDefinitionBase.f(ST_BevelPresetType_$type, d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "w";
            f = e.value.toString();
            a.ad.h(g, f);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Bevel.$t = markType(CT_Bevel, 'CT_Bevel');
/**
 * @hidden
 */
export class CT_Shape3D extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.h = null;
        this.f = null;
        this.j = null;
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(Number_$type, null);
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.u = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    static k(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
        let f = CT_Shape3D.y(a, b, c, d, e);
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        return ((() => {
            let $ret = new CT_Shape3D();
            $ret.r = c;
            $ret.p = d;
            $ret.v = b;
            return $ret;
        })());
    }
    static y(a, b, c, d, e) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "z":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "extrusionH":
                    c = Nullable$1.toNullable(Number_$type, parseInt64_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "contourW":
                    d = Nullable$1.toNullable(Number_$type, parseInt64_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "prstMaterial":
                    e = Nullable$1.toNullable(ST_PresetMaterialType_$type, XmlNamespaceDefinitionBase.b(ST_PresetMaterialType_$type, f.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static z(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(ST_PresetMaterialType_$type, null), f = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "contourW";
            g = c.value.toString();
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "extrusionH";
            g = d.value.toString();
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "prstMaterial";
            g = XmlNamespaceDefinitionBase.f(ST_PresetMaterialType_$type, e.value);
            a.ad.h(h, g);
        }
        if (f.hasValue) {
            h = "z";
            g = f.value.toString();
            a.ad.h(h, g);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 110:
                this.c = typeCast(CT_Bevel.$, b);
                break;
            case 109:
                this.a = typeCast(CT_Bevel.$, b);
                break;
            case 611:
                this.g = typeCast(CT_Color_DML.$, b);
                break;
            case 347:
                this.e = typeCast(CT_Color_DML.$, b);
                break;
            case 601:
                this.i = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Shape3D.$t = markType(CT_Shape3D, 'CT_Shape3D', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FlatText extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Number_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "z":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "z";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FlatText.$t = markType(CT_FlatText, 'CT_FlatText');
/**
 * @hidden
 */
export class CT_AlphaBiLevelEffect extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "thresh":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "thresh";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaBiLevelEffect.$t = markType(CT_AlphaBiLevelEffect, 'CT_AlphaBiLevelEffect');
/**
 * @hidden
 */
export class CT_TransformEffect extends Base {
    constructor() {
        super();
        this.m = Nullable$1.toNullable(Number_$type, null);
        this.o = Nullable$1.toNullable(Number_$type, null);
        this.i = Nullable$1.toNullable(Number_$type, null);
        this.k = Nullable$1.toNullable(Number_$type, null);
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(Number_$type, null);
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = CT_TransformEffect.u(a, b, c, d, e, f, g);
        b = h.p1;
        c = h.p2;
        d = h.p3;
        e = h.p4;
        f = h.p5;
        g = h.p6;
        return ((() => {
            let $ret = new CT_TransformEffect();
            $ret.h = d;
            $ret.j = e;
            $ret.l = b;
            $ret.n = c;
            $ret.p = f;
            $ret.r = g;
            return $ret;
        })());
    }
    static u(a, b, c, d, e, f, g) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "sx":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "sy":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "kx":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "ky":
                    e = Nullable$1.toNullable(Number_$type, parseInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "tx":
                    f = Nullable$1.toNullable(Number_$type, parseInt64_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "ty":
                    g = Nullable$1.toNullable(Number_$type, parseInt64_1(h.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static v(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let i = null;
        let j = null;
        if (c.hasValue) {
            j = "kx";
            i = c.value.toString();
            a.ad.h(j, i);
        }
        if (d.hasValue) {
            j = "ky";
            i = d.value.toString();
            a.ad.h(j, i);
        }
        if (e.hasValue) {
            j = "sx";
            i = e.value.toString();
            a.ad.h(j, i);
        }
        if (f.hasValue) {
            j = "sy";
            i = f.value.toString();
            a.ad.h(j, i);
        }
        if (g.hasValue) {
            j = "tx";
            i = g.value.toString();
            a.ad.h(j, i);
        }
        if (h.hasValue) {
            j = "ty";
            i = h.value.toString();
            a.ad.h(j, i);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TransformEffect.$t = markType(CT_TransformEffect, 'CT_TransformEffect');
/**
 * @hidden
 */
export class CT_TintEffect extends Base {
    constructor() {
        super();
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(Number_$type, null);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static h(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "hue":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "amt":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "amt";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "hue";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TintEffect.$t = markType(CT_TintEffect, 'CT_TintEffect');
/**
 * @hidden
 */
export class CT_SoftEdgesEffect extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "rad":
                    b = parseInt64_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "rad";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SoftEdgesEffect.$t = markType(CT_SoftEdgesEffect, 'CT_SoftEdgesEffect');
/**
 * @hidden
 */
export class CT_RelativeOffsetEffect extends Base {
    constructor() {
        super();
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "tx":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "ty":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "tx";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "ty";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RelativeOffsetEffect.$t = markType(CT_RelativeOffsetEffect, 'CT_RelativeOffsetEffect');
/**
 * @hidden
 */
export class CT_ReflectionEffect extends Base {
    constructor() {
        super();
        this.r = Nullable$1.toNullable(Number_$type, null);
        this.aj = Nullable$1.toNullable(Number_$type, null);
        this.al = Nullable$1.toNullable(Number_$type, null);
        this.x = Nullable$1.toNullable(Number_$type, null);
        this.z = Nullable$1.toNullable(Number_$type, null);
        this.v = Nullable$1.toNullable(Number_$type, null);
        this.t = Nullable$1.toNullable(Number_$type, null);
        this.ab = Nullable$1.toNullable(Number_$type, null);
        this.an = Nullable$1.toNullable(Number_$type, null);
        this.ap = Nullable$1.toNullable(Number_$type, null);
        this.ad = Nullable$1.toNullable(Number_$type, null);
        this.af = Nullable$1.toNullable(Number_$type, null);
        this.p = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        this.ah = Nullable$1.toNullable(Boolean_$type, null);
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get ai() {
        return this.aj;
    }
    set ai(a) {
        this.aj = a;
    }
    get ak() {
        return this.al;
    }
    set ak(a) {
        this.al = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get am() {
        return this.an;
    }
    set am(a) {
        this.an = a;
    }
    get ao() {
        return this.ap;
    }
    set ao(a) {
        this.ap = a;
    }
    get ac() {
        return this.ad;
    }
    set ac(a) {
        this.ad = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get ag() {
        return this.ah;
    }
    set ag(a) {
        this.ah = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Number_$type, null);
        let m = Nullable$1.toNullable(Number_$type, null);
        let n = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let o = Nullable$1.toNullable(Boolean_$type, null);
        let p = CT_ReflectionEffect.ar(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        b = p.p1;
        c = p.p2;
        d = p.p3;
        e = p.p4;
        f = p.p5;
        g = p.p6;
        h = p.p7;
        i = p.p8;
        j = p.p9;
        k = p.p10;
        l = p.p11;
        m = p.p12;
        n = p.p13;
        o = p.p14;
        return ((() => {
            let $ret = new CT_ReflectionEffect();
            $ret.o = n;
            $ret.q = b;
            $ret.s = h;
            $ret.w = e;
            $ret.u = g;
            $ret.y = f;
            $ret.aa = i;
            $ret.ac = l;
            $ret.ae = m;
            $ret.ag = o;
            $ret.ai = c;
            $ret.ak = d;
            $ret.am = j;
            $ret.ao = k;
            return $ret;
        })());
    }
    static ar(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = Nullable$1.toNullable(Number_$type, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        for (let p of fromEnum(a.ab.u)) {
            switch (p.a.e(a.d)) {
                case "blurRad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "stA":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "stPos":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "endA":
                    e = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "endPos":
                    f = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "dist":
                    g = Nullable$1.toNullable(Number_$type, parseInt64_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "dir":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "fadeDir":
                    i = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "sx":
                    j = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "sy":
                    k = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "kx":
                    l = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "ky":
                    m = Nullable$1.toNullable(Number_$type, parseInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "algn":
                    n = Nullable$1.toNullable(ST_RectAlignment_$type, XmlNamespaceDefinitionBase.b(ST_RectAlignment_$type, p.d));
                    break;
                case "rotWithShape":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(p.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o
        };
    }
    static as(a, b, c = Nullable$1.toNullable(ST_RectAlignment_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Number_$type, null), o = Nullable$1.toNullable(Number_$type, null), p = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let q = null;
        let r = null;
        if (c.hasValue) {
            r = "algn";
            q = XmlNamespaceDefinitionBase.f(ST_RectAlignment_$type, c.value);
            a.ad.h(r, q);
        }
        if (d.hasValue) {
            r = "blurRad";
            q = d.value.toString();
            a.ad.h(r, q);
        }
        if (e.hasValue) {
            r = "dir";
            q = e.value.toString();
            a.ad.h(r, q);
        }
        if (f.hasValue) {
            r = "dist";
            q = f.value.toString();
            a.ad.h(r, q);
        }
        if (g.hasValue) {
            r = "endA";
            q = g.value.toString();
            a.ad.h(r, q);
        }
        if (h.hasValue) {
            r = "endPos";
            q = h.value.toString();
            a.ad.h(r, q);
        }
        if (i.hasValue) {
            r = "fadeDir";
            q = i.value.toString();
            a.ad.h(r, q);
        }
        if (j.hasValue) {
            r = "kx";
            q = j.value.toString();
            a.ad.h(r, q);
        }
        if (k.hasValue) {
            r = "ky";
            q = k.value.toString();
            a.ad.h(r, q);
        }
        if (l.hasValue) {
            r = "rotWithShape";
            q = ST_OnOff.g(l.value);
            a.ad.h(r, q);
        }
        if (m.hasValue) {
            r = "stA";
            q = m.value.toString();
            a.ad.h(r, q);
        }
        if (n.hasValue) {
            r = "stPos";
            q = n.value.toString();
            a.ad.h(r, q);
        }
        if (o.hasValue) {
            r = "sx";
            q = o.value.toString();
            a.ad.h(r, q);
        }
        if (p.hasValue) {
            r = "sy";
            q = p.value.toString();
            a.ad.h(r, q);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ReflectionEffect.$t = markType(CT_ReflectionEffect, 'CT_ReflectionEffect');
/**
 * @hidden
 */
export class CT_LuminanceEffect extends Base {
    constructor() {
        super();
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "bright":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "contrast":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "bright";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "contrast";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LuminanceEffect.$t = markType(CT_LuminanceEffect, 'CT_LuminanceEffect');
/**
 * @hidden
 */
export class CT_HSLEffect extends Base {
    constructor() {
        super();
        this.e = Nullable$1.toNullable(Number_$type, null);
        this.i = Nullable$1.toNullable(Number_$type, null);
        this.g = Nullable$1.toNullable(Number_$type, null);
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static k(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "hue":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "sat":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "lum":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static l(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "hue";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "lum";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "sat";
            f = e.value.toString();
            a.ad.h(g, f);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_HSLEffect.$t = markType(CT_HSLEffect, 'CT_HSLEffect');
/**
 * @hidden
 */
export class CT_GrayscaleEffect extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GrayscaleEffect.$t = markType(CT_GrayscaleEffect, 'CT_GrayscaleEffect');
/**
 * @hidden
 */
export class CT_FillOverlayEffect extends Base {
    constructor() {
        super();
        this.d = 0;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_FillProperties();
        }
        return this.a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "blend":
                    b = XmlNamespaceDefinitionBase.b(ST_BlendMode_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static h(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "blend";
        d = XmlNamespaceDefinitionBase.f(ST_BlendMode_$type, c);
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.f(a)) {
                    this.b.j(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    g(a, b, c, d) {
        CT_FillOverlayEffect.h(a, d, this.c);
        let e = this.b.k;
        if (e != null) {
            e.save1(a, b, c, DrawingMLMain.bt);
        }
        let f = this.b.a;
        if (f != null) {
            f.save1(a, b, c, DrawingMLMain.ej);
        }
        let g = this.b.l;
        if (g != null) {
            c.p(DrawingMLMain.es, "a");
            c.k();
        }
        let h = this.b.d;
        if (g != null) {
            c.p(DrawingMLMain.gy, "a");
            c.k();
        }
        let i = this.b.b;
        if (i != null) {
            i.save1(a, b, c, DrawingMLMain.hh);
        }
        c.k();
    }
}
CT_FillOverlayEffect.$t = markType(CT_FillOverlayEffect, 'CT_FillOverlayEffect', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SolidColorFillProperties extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.g(a)) {
                    this.b.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    save1(a, b, c, d) {
        c.p(d, "a");
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    get elementName() {
        return DrawingMLMain.io;
    }
    saveX(a, b, c, d) {
        this.save1(a, typeCast(WorkbookSaveManagerExcel2007.$, d), b, c);
    }
}
CT_SolidColorFillProperties.$t = markType(CT_SolidColorFillProperties, 'CT_SolidColorFillProperties', Base.$, [ISupportSetProperty_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_GradientFillProperties extends Base {
    constructor() {
        super();
        this.f = null;
        this.d = null;
        this.h = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        this.j = Nullable$1.toNullable(Boolean_$type, null);
        this.a = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ShadeProperties();
        }
        return this.a;
    }
    static l(a, b, c) {
        b = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "flip":
                    b = Nullable$1.toNullable(ST_TileFlipMode_$type, XmlNamespaceDefinitionBase.b(ST_TileFlipMode_$type, d.d));
                    break;
                case "rotWithShape":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static n(a, b, c = Nullable$1.toNullable(ST_TileFlipMode_$type, null), d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "flip";
            e = XmlNamespaceDefinitionBase.f(ST_TileFlipMode_$type, c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rotWithShape";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    save1(a, b, c, d) {
        CT_GradientFillProperties.n(a, d, this.g, this.i);
        let e = this.e;
        if (e != null) {
            c.p(DrawingMLMain.eu, "a");
            for (let f of fromEnum(e)) {
                f.f(a, b, c, DrawingMLMain.et);
            }
            c.k();
        }
        let g = this.b.a;
        if (g != null) {
            CT_LinearShadeProperties.h(a, DrawingMLMain.fu, g.a, g.c);
            c.k();
        }
        let h = this.b.b;
        if (h != null) {
            CT_PathShadeProperties.h(a, DrawingMLMain.hf, h.c);
            if (h.a != null) {
                DMLUtils.au(a, h.a, DrawingMLMain.d1);
            }
            c.k();
        }
        let i = this.c;
        if (i != null) {
            DMLUtils.au(a, i, DrawingMLMain.jk);
        }
        c.k();
    }
    get elementName() {
        return DrawingMLMain.ej;
    }
    saveX(a, b, c, d) {
        this.save1(a, typeCast(WorkbookSaveManagerExcel2007.$, d), b, c);
    }
    setProperty(a, b) {
        switch (a) {
            case 757:
                this.e = CT_GradientStopList.e(typeCast(CT_GradientStopList.$, b));
                break;
            case 1728:
                this.c = typeCast(CT_RelativeRect.$, b);
                break;
            default:
                this.b.e(a, b);
                break;
        }
    }
}
CT_GradientFillProperties.$t = markType(CT_GradientFillProperties, 'CT_GradientFillProperties', Base.$, [ISupportSetProperty_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_LinearShadeProperties extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "ang":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "scaled":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "ang";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "scaled";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    g(a, b, c, d) {
        throw new NotImplementedException(0);
    }
}
CT_LinearShadeProperties.$t = markType(CT_LinearShadeProperties, 'CT_LinearShadeProperties');
/**
 * @hidden
 */
export class CT_PathShadeProperties extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = Nullable$1.toNullable(ST_PathShadeType_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = Nullable$1.toNullable(ST_PathShadeType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "path":
                    b = Nullable$1.toNullable(ST_PathShadeType_$type, XmlNamespaceDefinitionBase.b(ST_PathShadeType_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static h(a, b, c = Nullable$1.toNullable(ST_PathShadeType_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "path";
            d = XmlNamespaceDefinitionBase.f(ST_PathShadeType_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 637:
                this.a = typeCast(CT_RelativeRect.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    g(a, b, c, d) {
        CT_PathShadeProperties.h(a, d, this.c);
        if (this.a != null) {
            DMLExtensions.ct(this.a, a, b, c, DrawingMLMain.d1);
        }
        c.k();
    }
}
CT_PathShadeProperties.$t = markType(CT_PathShadeProperties, 'CT_PathShadeProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PatternFillProperties extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = Nullable$1.toNullable(ST_PresetPatternVal_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b) {
        b = Nullable$1.toNullable(ST_PresetPatternVal_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "prst":
                    b = Nullable$1.toNullable(ST_PresetPatternVal_$type, XmlNamespaceDefinitionBase.b(ST_PresetPatternVal_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static j(a, b, c = Nullable$1.toNullable(ST_PresetPatternVal_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "prst";
            d = XmlNamespaceDefinitionBase.f(ST_PresetPatternVal_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 618:
                this.c = typeCast(CT_Color_DML.$, b);
                break;
            case 112:
                this.a = typeCast(CT_Color_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get elementName() {
        return DrawingMLMain.hh;
    }
    saveX(a, b, c, d) {
        this.save1(a, typeCast(WorkbookSaveManagerExcel2007.$, d), b, c);
    }
    save1(a, b, c, d) {
        CT_PatternFillProperties.j(a, DrawingMLMain.hh, this.e);
        let e = this.a;
        if (e != null) {
            e.d(a, b, c, DrawingMLMain.bn);
        }
        let f = this.c;
        if (f != null) {
            f.d(a, b, c, DrawingMLMain.dv);
        }
        c.k();
    }
}
CT_PatternFillProperties.$t = markType(CT_PatternFillProperties, 'CT_PatternFillProperties', Base.$, [ISupportSetProperty_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_FillEffect extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_FillProperties();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.f(a)) {
                    this.b.j(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FillEffect.$t = markType(CT_FillEffect, 'CT_FillEffect', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorChangeEffect extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.g = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static i(a, b) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "useA":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static j(a, b, c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "useA";
            d = ST_OnOff.g(c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 281:
                this.a = typeCast(CT_Color_DML.$, b);
                break;
            case 288:
                this.c = typeCast(CT_Color_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorChangeEffect.$t = markType(CT_ColorChangeEffect, 'CT_ColorChangeEffect', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BlurEffect extends Base {
    constructor() {
        super();
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static h(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "rad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "grow":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "grow";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rad";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BlurEffect.$t = markType(CT_BlurEffect, 'CT_BlurEffect');
/**
 * @hidden
 */
export class CT_BlendEffect extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "blend":
                    b = XmlNamespaceDefinitionBase.b(ST_BlendMode_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "blend";
        d = XmlNamespaceDefinitionBase.f(ST_BlendMode_$type, c);
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 344:
                this.a = typeCast(CT_EffectContainer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BlendEffect.$t = markType(CT_BlendEffect, 'CT_BlendEffect', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EffectContainer extends Base {
    constructor() {
        super();
        this.f = null;
        this.h = Nullable$1.toNullable(ST_EffectContainerType_$type, null);
        this.j = null;
        this.b = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        if (this.b == null) {
            this.b = new EG_Effect();
        }
        return this.b;
    }
    static a(a) {
        let b = Nullable$1.toNullable(ST_EffectContainerType_$type, null);
        let c = null;
        let d = CT_EffectContainer.l(a, b, c);
        b = d.p1;
        c = d.p2;
        return ((() => {
            let $ret = new CT_EffectContainer();
            $ret.i = c;
            $ret.g = b;
            return $ret;
        })());
    }
    static l(a, b, c) {
        b = Nullable$1.toNullable(ST_EffectContainerType_$type, null);
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_EffectContainerType_$type, XmlNamespaceDefinitionBase.b(ST_EffectContainerType_$type, d.d));
                    break;
                case "name":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static m(a, b, c = null, d = Nullable$1.toNullable(ST_EffectContainerType_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c != null) {
            f = "name";
            e = c;
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "type";
            e = XmlNamespaceDefinitionBase.f(ST_EffectContainerType_$type, d.value);
            a.ad.h(f, e);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.c.ae(a)) {
                    this.c.ag(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EffectContainer.$t = markType(CT_EffectContainer, 'CT_EffectContainer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AlphaCeilingEffect extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaCeilingEffect.$t = markType(CT_AlphaCeilingEffect, 'CT_AlphaCeilingEffect');
/**
 * @hidden
 */
export class CT_AlphaFloorEffect extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaFloorEffect.$t = markType(CT_AlphaFloorEffect, 'CT_AlphaFloorEffect');
/**
 * @hidden
 */
export class CT_AlphaModulateEffect extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 344:
                this.a = typeCast(CT_EffectContainer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaModulateEffect.$t = markType(CT_AlphaModulateEffect, 'CT_AlphaModulateEffect', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AlphaModulateFixedEffect extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Number_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "amt":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "amt";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaModulateFixedEffect.$t = markType(CT_AlphaModulateFixedEffect, 'CT_AlphaModulateFixedEffect');
/**
 * @hidden
 */
export class CT_AlphaOutsetEffect extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(Number_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "rad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "rad";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaOutsetEffect.$t = markType(CT_AlphaOutsetEffect, 'CT_AlphaOutsetEffect');
/**
 * @hidden
 */
export class CT_AlphaReplaceEffect extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "a":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "a";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AlphaReplaceEffect.$t = markType(CT_AlphaReplaceEffect, 'CT_AlphaReplaceEffect');
/**
 * @hidden
 */
export class CT_BiLevelEffect extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "thresh":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "thresh";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BiLevelEffect.$t = markType(CT_BiLevelEffect, 'CT_BiLevelEffect');
/**
 * @hidden
 */
export class CT_EffectReference extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ref":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "ref";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EffectReference.$t = markType(CT_EffectReference, 'CT_EffectReference');
/**
 * @hidden
 */
export class CT_GradientStopList extends Base {
    constructor() {
        super();
        this.d = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 756:
                this.c.add(typeCast(CT_GradientStop.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static e(a) {
        return a != null ? a.c : null;
    }
    static a(a) {
        let b = new CT_GradientStopList();
        b.d = a;
        return b;
    }
}
CT_GradientStopList.$t = markType(CT_GradientStopList, 'CT_GradientStopList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FillProperties extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_FillProperties();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.f(a)) {
                    this.b.j(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FillProperties.$t = markType(CT_FillProperties, 'CT_FillProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EffectList extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
        this.j = null;
        this.l = null;
        this.n = null;
        this.p = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 134:
                this.a = typeCast(CT_BlurEffect.$, b);
                break;
            case 633:
                this.c = typeCast(CT_FillOverlayEffect.$, b);
                break;
            case 724:
                this.e = typeCast(CT_GlowEffect.$, b);
                break;
            case 830:
                this.g = typeCast(CT_InnerShadowEffect.$, b);
                break;
            case 1142:
                this.i = typeCast(CT_OuterShadowEffect.$, b);
                break;
            case 1275:
                this.k = typeCast(CT_PresetShadowEffect.$, b);
                break;
            case 1338:
                this.m = typeCast(CT_ReflectionEffect.$, b);
                break;
            case 1551:
                this.o = typeCast(CT_SoftEdgesEffect.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EffectList.$t = markType(CT_EffectList, 'CT_EffectList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EffectProperties extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_EffectProperties();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.c(a)) {
                    this.b.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EffectProperties.$t = markType(CT_EffectProperties, 'CT_EffectProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PresetTextShape extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "prst":
                    b = XmlNamespaceDefinitionBase.b(ST_TextShapeType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "prst";
        d = XmlNamespaceDefinitionBase.f(ST_TextShapeType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_PresetTextShape.$t = markType(CT_PresetTextShape, 'CT_PresetTextShape', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ShapeProperties_DML extends Base {
    constructor() {
        super();
        this.p = null;
        this.b = null;
        this.f = null;
        this.h = null;
        this.d = null;
        this.r = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        this.m = null;
        this.k = null;
        this.i = null;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get n() {
        if (this.m == null) {
            this.m = new EG_Geometry();
        }
        return this.m;
    }
    get l() {
        if (this.k == null) {
            this.k = new EG_FillProperties();
        }
        return this.k;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_EffectProperties();
        }
        return this.i;
    }
    static t(a, b) {
        b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "bwMode":
                    b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static u(a, b, c = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "bwMode";
            d = XmlNamespaceDefinitionBase.f(ST_BlackWhiteMode_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1892:
                this.o = typeCast(CT_Transform2D.$, b);
                break;
            case 918:
                this.a = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 1423:
                this.e = typeCast(CT_Scene3D.$, b);
                break;
            case 1564:
                this.g = typeCast(CT_Shape3D.$, b);
                break;
            case 601:
                this.c = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.n.c(a)) {
                    this.n.e(a, b);
                    return;
                }
                else if (this.l.f(a)) {
                    this.l.j(a, b);
                    return;
                }
                else if (this.j.c(a)) {
                    this.j.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ShapeProperties_DML.$t = markType(CT_ShapeProperties_DML, 'CT_ShapeProperties_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StyleMatrixReference_DML extends Base {
    constructor() {
        super();
        this.e = 0;
        this.a = null;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "idx";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.g(a)) {
                    this.b.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StyleMatrixReference_DML.$t = markType(CT_StyleMatrixReference_DML, 'CT_StyleMatrixReference_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DefaultShapeDefinition extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.h = null;
        this.j = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.c = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 136:
                this.e = typeCast(CT_TextBodyProperties_DML.$, b);
                break;
            case 938:
                this.g = typeCast(CT_TextListStyle_DML.$, b);
                break;
            case 1618:
                this.i = typeCast(CT_ShapeStyle.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DefaultShapeDefinition.$t = markType(CT_DefaultShapeDefinition, 'CT_DefaultShapeDefinition', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ObjectStyleDefaults extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = null;
        this.h = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1568:
                this.c = typeCast(CT_DefaultShapeDefinition.$, b);
                break;
            case 921:
                this.a = typeCast(CT_DefaultShapeDefinition.$, b);
                break;
            case 1779:
                this.e = typeCast(CT_DefaultShapeDefinition.$, b);
                break;
            case 601:
                this.g = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ObjectStyleDefaults.$t = markType(CT_ObjectStyleDefaults, 'CT_ObjectStyleDefaults', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_OfficeStyleSheet extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.j = null;
        this.h = null;
        this.f = null;
        this.l = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    static n(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static o(a, b, c = null) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_OfficeStyleSheet.$t = markType(CT_OfficeStyleSheet, 'CT_OfficeStyleSheet', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorSchemeAndMapping extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 286:
                this.c = typeCast(CT_ColorScheme.$, b);
                break;
            case 282:
                this.a = typeCast(CT_ColorMapping.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorSchemeAndMapping.$t = markType(CT_ColorSchemeAndMapping, 'CT_ColorSchemeAndMapping', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorMapping extends Base {
    constructor() {
        super();
        this.c = null;
        this.q = 0;
        this.y = 0;
        this.s = 0;
        this.aa = 0;
        this.e = 0;
        this.g = 0;
        this.i = 0;
        this.k = 0;
        this.m = 0;
        this.o = 0;
        this.w = 0;
        this.u = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    static a(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        let e = 0;
        let f = 0;
        let g = 0;
        let h = 0;
        let i = 0;
        let j = 0;
        let k = 0;
        let l = 0;
        let m = 0;
        let n = CT_ColorMapping.ac(a, b, c, d, e, f, g, h, i, j, k, l, m);
        b = n.p1;
        c = n.p2;
        d = n.p3;
        e = n.p4;
        f = n.p5;
        g = n.p6;
        h = n.p7;
        i = n.p8;
        j = n.p9;
        k = n.p10;
        l = n.p11;
        m = n.p12;
        return ((() => {
            let $ret = new CT_ColorMapping();
            $ret.d = f;
            $ret.f = g;
            $ret.h = h;
            $ret.j = i;
            $ret.l = j;
            $ret.n = k;
            $ret.p = b;
            $ret.r = d;
            $ret.v = l;
            $ret.t = m;
            $ret.x = c;
            $ret.z = e;
            return $ret;
        })());
    }
    static ac(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        h = 0;
        i = 0;
        j = 0;
        k = 0;
        l = 0;
        m = 0;
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "bg1":
                    b = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "tx1":
                    c = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "bg2":
                    d = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "tx2":
                    e = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent1":
                    f = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent2":
                    g = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent3":
                    h = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent4":
                    i = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent5":
                    j = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "accent6":
                    k = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "hlink":
                    l = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                case "folHlink":
                    m = XmlNamespaceDefinitionBase.b(ST_ColorSchemeIndex_$type, n.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static ad(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        a.ad.p(b, "a");
        let o = null;
        let p = null;
        p = "accent1";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, c);
        a.ad.h(p, o);
        p = "accent2";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, d);
        a.ad.h(p, o);
        p = "accent3";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, e);
        a.ad.h(p, o);
        p = "accent4";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, f);
        a.ad.h(p, o);
        p = "accent5";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, g);
        a.ad.h(p, o);
        p = "accent6";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, h);
        a.ad.h(p, o);
        p = "bg1";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, i);
        a.ad.h(p, o);
        p = "bg2";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, j);
        a.ad.h(p, o);
        p = "folHlink";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, k);
        a.ad.h(p, o);
        p = "hlink";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, l);
        a.ad.h(p, o);
        p = "tx1";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, m);
        a.ad.h(p, o);
        p = "tx2";
        o = XmlNamespaceDefinitionBase.f(ST_ColorSchemeIndex_$type, n);
        a.ad.h(p, o);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.b = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorMapping.$t = markType(CT_ColorMapping, 'CT_ColorMapping', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BaseStylesOverride extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 286:
                this.a = typeCast(CT_ColorScheme.$, b);
                break;
            case 661:
                this.c = typeCast(CT_FontScheme.$, b);
                break;
            case 657:
                this.e = typeCast(CT_StyleMatrix.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BaseStylesOverride.$t = markType(CT_BaseStylesOverride, 'CT_BaseStylesOverride', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_EmptyElement extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_EmptyElement.$t = markType(CT_EmptyElement, 'CT_EmptyElement');
/**
 * @hidden
 */
export class CT_ColorMappingOverride extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_ColorMappingOverride.$t = markType(CT_ColorMappingOverride, 'CT_ColorMappingOverride', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorSchemeList extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 608:
                this.a.add(typeCast(CT_ColorSchemeAndMapping.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorSchemeList.$t = markType(CT_ColorSchemeList, 'CT_ColorSchemeList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ClipboardStyleSheet extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1717:
                this.a = typeCast(CT_BaseStyles.$, b);
                break;
            case 282:
                this.c = typeCast(CT_ColorMapping.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ClipboardStyleSheet.$t = markType(CT_ClipboardStyleSheet, 'CT_ClipboardStyleSheet', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Table extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_Table.$t = markType(CT_Table, 'CT_Table', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableProperties extends Base {
    constructor() {
        super();
        this.ac = null;
        this.b = null;
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.y = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.q = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(Boolean_$type, null);
        this.e = null;
        this.c = null;
    }
    get item() {
        return this.ac;
    }
    set item(a) {
        this.ac = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_FillProperties();
        }
        return this.e;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_EffectProperties();
        }
        return this.c;
    }
    static ae(a, b, c, d, e, f, g, h) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "rtl":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "firstRow":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "firstCol":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "lastRow":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "lastCol":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "bandRow":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                case "bandCol":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(i.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static af(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let j = null;
        let k = null;
        if (c.hasValue) {
            k = "bandCol";
            j = ST_OnOff.g(c.value);
            a.ad.h(k, j);
        }
        if (d.hasValue) {
            k = "bandRow";
            j = ST_OnOff.g(d.value);
            a.ad.h(k, j);
        }
        if (e.hasValue) {
            k = "firstCol";
            j = ST_OnOff.g(e.value);
            a.ad.h(k, j);
        }
        if (f.hasValue) {
            k = "firstRow";
            j = ST_OnOff.g(f.value);
            a.ad.h(k, j);
        }
        if (g.hasValue) {
            k = "lastCol";
            j = ST_OnOff.g(g.value);
            a.ad.h(k, j);
        }
        if (h.hasValue) {
            k = "lastRow";
            j = ST_OnOff.g(h.value);
            a.ad.h(k, j);
        }
        if (i.hasValue) {
            k = "rtl";
            j = ST_OnOff.g(i.value);
            a.ad.h(k, j);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_TableProperties.$t = markType(CT_TableProperties, 'CT_TableProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableCol extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "w":
                    b = parseInt64_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "w";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableCol.$t = markType(CT_TableCol, 'CT_TableCol', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableRow extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "h":
                    b = parseInt64_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static i(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "h";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1696:
                this.c.add(typeCast(CT_TableCell.$, b));
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableRow.$t = markType(CT_TableRow, 'CT_TableRow', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableCell extends Base {
    constructor() {
        super();
        this.f = null;
        this.d = null;
        this.b = null;
        this.p = Nullable$1.toNullable(Number_$type, null);
        this.l = Nullable$1.toNullable(Number_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.r = Nullable$1.toNullable(Boolean_$type, null);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    static t(a, b, c, d, e) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "rowSpan":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "gridSpan":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "hMerge":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "vMerge":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static u(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "gridSpan";
            g = c.value.toString();
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "hMerge";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e.hasValue) {
            h = "rowSpan";
            g = e.value.toString();
            a.ad.h(h, g);
        }
        if (f.hasValue) {
            h = "vMerge";
            g = ST_OnOff.g(f.value);
            a.ad.h(h, g);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1777:
                this.e = typeCast(CT_TextBody_DML.$, b);
                break;
            case 1701:
                this.c = typeCast(CT_TableCellProperties.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableCell.$t = markType(CT_TableCell, 'CT_TableCell', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableCellProperties extends Base {
    constructor() {
        super();
        this.h = null;
        this.j = null;
        this.l = null;
        this.d = null;
        this.n = null;
        this.f = null;
        this.b = null;
        this.p = null;
        this.ag = Nullable$1.toNullable(Number_$type, null);
        this.ai = Nullable$1.toNullable(Number_$type, null);
        this.ak = Nullable$1.toNullable(Number_$type, null);
        this.ae = Nullable$1.toNullable(Number_$type, null);
        this.am = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        this.aa = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        this.z = Nullable$1.toNullable(Boolean_$type, null);
        this.ac = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        this.q = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get af() {
        return this.ag;
    }
    set af(a) {
        this.ag = a;
    }
    get ah() {
        return this.ai;
    }
    set ah(a) {
        this.ai = a;
    }
    get aj() {
        return this.ak;
    }
    set aj(a) {
        this.ak = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get al() {
        return this.am;
    }
    set al(a) {
        this.am = a;
    }
    get x() {
        return this.aa;
    }
    set x(a) {
        this.aa = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get r() {
        if (this.q == null) {
            this.q = new EG_FillProperties();
        }
        return this.q;
    }
    static ao(a, b, c, d, e, f, g, h, i) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        g = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        for (let j of fromEnum(a.ab.u)) {
            switch (j.a.e(a.d)) {
                case "marL":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(j.d, CultureInfo.invariantCulture));
                    break;
                case "marR":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(j.d, CultureInfo.invariantCulture));
                    break;
                case "marT":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(j.d, CultureInfo.invariantCulture));
                    break;
                case "marB":
                    e = Nullable$1.toNullable(Number_$type, parseInt32_1(j.d, CultureInfo.invariantCulture));
                    break;
                case "vert":
                    f = Nullable$1.toNullable(ST_TextVerticalType_$type, XmlNamespaceDefinitionBase.b(ST_TextVerticalType_$type, j.d));
                    break;
                case "anchor":
                    g = Nullable$1.toNullable(ST_TextAnchoringType_$type, XmlNamespaceDefinitionBase.b(ST_TextAnchoringType_$type, j.d));
                    break;
                case "anchorCtr":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(j.d));
                    break;
                case "horzOverflow":
                    i = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextHorzOverflowType_$type, j.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i
        };
    }
    static ap(a, b, c = Nullable$1.toNullable(ST_TextAnchoringType_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(ST_TextVerticalType_$type, null)) {
        a.ad.p(b, "a");
        let k = null;
        let l = null;
        if (c.hasValue) {
            l = "anchor";
            k = XmlNamespaceDefinitionBase.f(ST_TextAnchoringType_$type, c.value);
            a.ad.h(l, k);
        }
        if (d.hasValue) {
            l = "anchorCtr";
            k = ST_OnOff.g(d.value);
            a.ad.h(l, k);
        }
        if (e.hasValue) {
            l = "horzOverflow";
            k = XmlNamespaceDefinitionBase.f(ST_TextHorzOverflowType_$type, e.value);
            a.ad.h(l, k);
        }
        if (f.hasValue) {
            l = "marB";
            k = f.value.toString();
            a.ad.h(l, k);
        }
        if (g.hasValue) {
            l = "marL";
            k = g.value.toString();
            a.ad.h(l, k);
        }
        if (h.hasValue) {
            l = "marR";
            k = h.value.toString();
            a.ad.h(l, k);
        }
        if (i.hasValue) {
            l = "marT";
            k = i.value.toString();
            a.ad.h(l, k);
        }
        if (j.hasValue) {
            l = "vert";
            k = XmlNamespaceDefinitionBase.f(ST_TextVerticalType_$type, j.value);
            a.ad.h(l, k);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 922:
                this.g = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 924:
                this.i = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 928:
                this.k = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 919:
                this.c = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 929:
                this.m = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 920:
                this.e = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 235:
                this.a = typeCast(CT_Cell3D.$, b);
                break;
            case 601:
                this.o = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.r.f(a)) {
                    this.r.j(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableCellProperties.$t = markType(CT_TableCellProperties, 'CT_TableCellProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableGrid extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 736:
                this.a.add(typeCast(CT_TableCol.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableGrid.$t = markType(CT_TableGrid, 'CT_TableGrid', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableStyleList extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "def":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "def";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1690:
                this.a.add(typeCast(CT_TableStyle.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableStyleList.$t = markType(CT_TableStyleList, 'CT_TableStyleList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableStyle extends Base {
    constructor() {
        super();
        this.d = null;
        this.ad = null;
        this.f = null;
        this.j = null;
        this.h = null;
        this.l = null;
        this.r = null;
        this.n = null;
        this.t = null;
        this.z = null;
        this.ab = null;
        this.p = null;
        this.v = null;
        this.x = null;
        this.b = null;
        this.af = null;
        this.ah = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get ac() {
        return this.ad;
    }
    set ac(a) {
        this.ad = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get ae() {
        return this.af;
    }
    set ae(a) {
        this.af = a;
    }
    get ag() {
        return this.ah;
    }
    set ag(a) {
        this.ah = a;
    }
    static aj(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "styleId":
                    b = d.d;
                    break;
                case "styleName":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static ak(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c != null) {
            f = "styleId";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "styleName";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1680:
                this.c = typeCast(CT_TableBackgroundStyle.$, b);
                break;
            case 1866:
                this.ac = typeCast(CT_TablePartStyle.$, b);
                break;
            case 92:
                this.e = typeCast(CT_TablePartStyle.$, b);
                break;
            case 94:
                this.i = typeCast(CT_TablePartStyle.$, b);
                break;
            case 93:
                this.g = typeCast(CT_TablePartStyle.$, b);
                break;
            case 95:
                this.k = typeCast(CT_TablePartStyle.$, b);
                break;
            case 871:
                this.q = typeCast(CT_TablePartStyle.$, b);
                break;
            case 643:
                this.m = typeCast(CT_TablePartStyle.$, b);
                break;
            case 873:
                this.s = typeCast(CT_TablePartStyle.$, b);
                break;
            case 1437:
                this.y = typeCast(CT_TablePartStyle.$, b);
                break;
            case 1647:
                this.aa = typeCast(CT_TablePartStyle.$, b);
                break;
            case 646:
                this.o = typeCast(CT_TablePartStyle.$, b);
                break;
            case 1052:
                this.u = typeCast(CT_TablePartStyle.$, b);
                break;
            case 1107:
                this.w = typeCast(CT_TablePartStyle.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableStyle.$t = markType(CT_TableStyle, 'CT_TableStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableBackgroundStyle extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_ThemeableFillStyle();
        }
        return this.c;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ThemeableEffectStyle();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.d.c(a)) {
                    this.d.e(a, b);
                    return;
                }
                else if (this.b.c(a)) {
                    this.b.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableBackgroundStyle.$t = markType(CT_TableBackgroundStyle, 'CT_TableBackgroundStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TablePartStyle extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1703:
                this.c = typeCast(CT_TableStyleTextStyle.$, b);
                break;
            case 1702:
                this.a = typeCast(CT_TableStyleCellStyle.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TablePartStyle.$t = markType(CT_TablePartStyle, 'CT_TablePartStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableStyleTextStyle extends Base {
    constructor() {
        super();
        this.b = null;
        this.j = Nullable$1.toNullable(ST_OnOffStyleType_$type, null);
        this.l = Nullable$1.toNullable(ST_OnOffStyleType_$type, null);
        this.e = null;
        this.c = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_ThemeableFontStyles();
        }
        return this.e;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_ColorChoice_DML();
        }
        return this.c;
    }
    static n(a, b, c) {
        b = Nullable$1.toNullable(ST_OnOffStyleType_$type, null);
        c = Nullable$1.toNullable(ST_OnOffStyleType_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "b":
                    b = Nullable$1.toNullable(ST_OnOffStyleType_$type, XmlNamespaceDefinitionBase.b(ST_OnOffStyleType_$type, d.d));
                    break;
                case "i":
                    c = Nullable$1.toNullable(ST_OnOffStyleType_$type, XmlNamespaceDefinitionBase.b(ST_OnOffStyleType_$type, d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static o(a, b, c = Nullable$1.toNullable(ST_OnOffStyleType_$type, null), d = Nullable$1.toNullable(ST_OnOffStyleType_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "b";
            e = XmlNamespaceDefinitionBase.f(ST_OnOffStyleType_$type, c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "i";
            e = XmlNamespaceDefinitionBase.f(ST_OnOffStyleType_$type, d.value);
            a.ad.h(f, e);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.f.c(a)) {
                    this.f.e(a, b);
                    return;
                }
                else if (this.d.g(a)) {
                    this.d.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableStyleTextStyle.$t = markType(CT_TableStyleTextStyle, 'CT_TableStyleTextStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableStyleCellStyle extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.e = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_ThemeableFillStyle();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 1697:
                this.c = typeCast(CT_TableCellBorderStyle.$, b);
                break;
            case 235:
                this.a = typeCast(CT_Cell3D.$, b);
                break;
            default:
                if (this.f.c(a)) {
                    this.f.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableStyleCellStyle.$t = markType(CT_TableStyleCellStyle, 'CT_TableStyleCellStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TableCellBorderStyle extends Base {
    constructor() {
        super();
        this.j = null;
        this.l = null;
        this.p = null;
        this.d = null;
        this.f = null;
        this.h = null;
        this.n = null;
        this.r = null;
        this.b = null;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 887:
                this.i = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 1363:
                this.k = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 1754:
                this.o = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 160:
                this.c = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 833:
                this.e = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 834:
                this.g = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 1749:
                this.m = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 1761:
                this.q = typeCast(CT_ThemeableLineStyle.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TableCellBorderStyle.$t = markType(CT_TableCellBorderStyle, 'CT_TableCellBorderStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ThemeableLineStyle extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get item() {
        return this.b;
    }
    set item(a) {
        this.b = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        throw new NotImplementedException(0);
    }
}
CT_ThemeableLineStyle.$t = markType(CT_ThemeableLineStyle, 'CT_ThemeableLineStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Cell3D extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.i = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static k(a, b) {
        b = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "prstMaterial":
                    b = Nullable$1.toNullable(ST_PresetMaterialType_$type, XmlNamespaceDefinitionBase.b(ST_PresetMaterialType_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static l(a, b, c = Nullable$1.toNullable(ST_PresetMaterialType_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "prstMaterial";
            d = XmlNamespaceDefinitionBase.f(ST_PresetMaterialType_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 108:
                this.a = typeCast(CT_Bevel.$, b);
                break;
            case 896:
                this.c = typeCast(CT_LightRig.$, b);
                break;
            case 601:
                this.e = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Cell3D.$t = markType(CT_Cell3D, 'CT_Cell3D', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextListStyle_DML extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.h = null;
        this.j = null;
        this.l = null;
        this.n = null;
        this.p = null;
        this.r = null;
        this.t = null;
        this.v = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 454:
                this.c = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 945:
                this.e = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 946:
                this.g = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 947:
                this.i = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 948:
                this.k = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 949:
                this.m = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 950:
                this.o = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 951:
                this.q = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 952:
                this.s = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 953:
                this.u = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextListStyle_DML.$t = markType(CT_TextListStyle_DML, 'CT_TextListStyle_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextNormalAutofit extends Base {
    constructor() {
        super();
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "fontScale":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "lnSpcReduction":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "fontScale";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "lnSpcReduction";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextNormalAutofit.$t = markType(CT_TextNormalAutofit, 'CT_TextNormalAutofit');
/**
 * @hidden
 */
export class CT_TextShapeAutofit extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextShapeAutofit.$t = markType(CT_TextShapeAutofit, 'CT_TextShapeAutofit');
/**
 * @hidden
 */
export class CT_TextNoAutofit extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextNoAutofit.$t = markType(CT_TextNoAutofit, 'CT_TextNoAutofit');
/**
 * @hidden
 */
export class CT_TextBodyProperties_DML extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.ag = Nullable$1.toNullable(Number_$type, null);
        this.am = Nullable$1.toNullable(Boolean_$type, null);
        this.au = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null);
        this.y = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        this.as = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        this.aw = Nullable$1.toNullable(ST_TextWrappingType_$type, null);
        this.aa = Nullable$1.toNullable(Number_$type, null);
        this.ao = Nullable$1.toNullable(Number_$type, null);
        this.ae = Nullable$1.toNullable(Number_$type, null);
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.ac = Nullable$1.toNullable(Number_$type, null);
        this.ak = Nullable$1.toNullable(Number_$type, null);
        this.ai = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.u = Nullable$1.toNullable(Boolean_$type, null);
        this.aq = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(Boolean_$type, null);
        this.i = null;
        this.g = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get af() {
        return this.ag;
    }
    set af(a) {
        this.ag = a;
    }
    get al() {
        return this.am;
    }
    set al(a) {
        this.am = a;
    }
    get at() {
        return this.au;
    }
    set at(a) {
        this.au = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get ar() {
        return this.as;
    }
    set ar(a) {
        this.as = a;
    }
    get av() {
        return this.aw;
    }
    set av(a) {
        this.aw = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get an() {
        return this.ao;
    }
    set an(a) {
        this.ao = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get aj() {
        return this.ak;
    }
    set aj(a) {
        this.ak = a;
    }
    get ah() {
        return this.ai;
    }
    set ah(a) {
        this.ai = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get l() {
        return this.o;
    }
    set l(a) {
        this.o = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get ap() {
        return this.aq;
    }
    set ap(a) {
        this.aq = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_TextAutofit();
        }
        return this.i;
    }
    get h() {
        if (this.g == null) {
            this.g = new EG_Text3D();
        }
        return this.g;
    }
    static ay(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null);
        e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        f = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        g = Nullable$1.toNullable(ST_TextWrappingType_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = Nullable$1.toNullable(Number_$type, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        p = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        s = Nullable$1.toNullable(Boolean_$type, null);
        t = Nullable$1.toNullable(Boolean_$type, null);
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case "rot":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "spcFirstLastPara":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "vertOverflow":
                    d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextVertOverflowType_$type, u.d));
                    break;
                case "horzOverflow":
                    e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextHorzOverflowType_$type, u.d));
                    break;
                case "vert":
                    f = Nullable$1.toNullable(ST_TextVerticalType_$type, XmlNamespaceDefinitionBase.b(ST_TextVerticalType_$type, u.d));
                    break;
                case "wrap":
                    g = Nullable$1.toNullable(ST_TextWrappingType_$type, XmlNamespaceDefinitionBase.b(ST_TextWrappingType_$type, u.d));
                    break;
                case "lIns":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "tIns":
                    i = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rIns":
                    j = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "bIns":
                    k = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "numCol":
                    l = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "spcCol":
                    m = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rtlCol":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "fromWordArt":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "anchor":
                    p = Nullable$1.toNullable(ST_TextAnchoringType_$type, XmlNamespaceDefinitionBase.b(ST_TextAnchoringType_$type, u.d));
                    break;
                case "anchorCtr":
                    q = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "forceAA":
                    r = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "upright":
                    s = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "compatLnSpc":
                    t = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static az(a, b, c = Nullable$1.toNullable(ST_TextAnchoringType_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Boolean_$type, null), o = Nullable$1.toNullable(Number_$type, null), p = Nullable$1.toNullable(Boolean_$type, null), q = Nullable$1.toNullable(Number_$type, null), r = Nullable$1.toNullable(Boolean_$type, null), s = Nullable$1.toNullable(ST_TextVerticalType_$type, null), t = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null), u = Nullable$1.toNullable(ST_TextWrappingType_$type, null)) {
        a.ad.p(b, "a");
        let v = null;
        let w = null;
        if (c.hasValue) {
            w = "anchor";
            v = XmlNamespaceDefinitionBase.f(ST_TextAnchoringType_$type, c.value);
            a.ad.h(w, v);
        }
        if (d.hasValue) {
            w = "anchorCtr";
            v = ST_OnOff.g(d.value);
            a.ad.h(w, v);
        }
        if (e.hasValue) {
            w = "bIns";
            v = e.value.toString();
            a.ad.h(w, v);
        }
        if (f.hasValue) {
            w = "compatLnSpc";
            v = ST_OnOff.g(f.value);
            a.ad.h(w, v);
        }
        if (g.hasValue) {
            w = "forceAA";
            v = ST_OnOff.g(g.value);
            a.ad.h(w, v);
        }
        if (h.hasValue) {
            w = "fromWordArt";
            v = ST_OnOff.g(h.value);
            a.ad.h(w, v);
        }
        if (i.hasValue) {
            w = "horzOverflow";
            v = XmlNamespaceDefinitionBase.f(ST_TextHorzOverflowType_$type, i.value);
            a.ad.h(w, v);
        }
        if (j.hasValue) {
            w = "lIns";
            v = j.value.toString();
            a.ad.h(w, v);
        }
        if (k.hasValue) {
            w = "numCol";
            v = k.value.toString();
            a.ad.h(w, v);
        }
        if (l.hasValue) {
            w = "rIns";
            v = l.value.toString();
            a.ad.h(w, v);
        }
        if (m.hasValue) {
            w = "rot";
            v = m.value.toString();
            a.ad.h(w, v);
        }
        if (n.hasValue) {
            w = "rtlCol";
            v = ST_OnOff.g(n.value);
            a.ad.h(w, v);
        }
        if (o.hasValue) {
            w = "spcCol";
            v = o.value.toString();
            a.ad.h(w, v);
        }
        if (p.hasValue) {
            w = "spcFirstLastPara";
            v = ST_OnOff.g(p.value);
            a.ad.h(w, v);
        }
        if (q.hasValue) {
            w = "tIns";
            v = q.value.toString();
            a.ad.h(w, v);
        }
        if (r.hasValue) {
            w = "upright";
            v = ST_OnOff.g(r.value);
            a.ad.h(w, v);
        }
        if (s.hasValue) {
            w = "vert";
            v = XmlNamespaceDefinitionBase.f(ST_TextVerticalType_$type, s.value);
            a.ad.h(w, v);
        }
        if (t.hasValue) {
            w = "vertOverflow";
            v = XmlNamespaceDefinitionBase.f(ST_TextVertOverflowType_$type, t.value);
            a.ad.h(w, v);
        }
        if (u.hasValue) {
            w = "wrap";
            v = XmlNamespaceDefinitionBase.f(ST_TextWrappingType_$type, u.value);
            a.ad.h(w, v);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1276:
                this.c = typeCast(CT_PresetTextShape.$, b);
                break;
            case 1423:
                this.e = typeCast(CT_Scene3D.$, b);
                break;
            case 601:
                this.a = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.j.d(a)) {
                    this.j.f(a, b);
                    return;
                }
                else if (this.h.c(a)) {
                    this.h.e(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBodyProperties_DML.$t = markType(CT_TextBodyProperties_DML, 'CT_TextBodyProperties_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextBulletColorFollowText extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBulletColorFollowText.$t = markType(CT_TextBulletColorFollowText, 'CT_TextBulletColorFollowText');
/**
 * @hidden
 */
export class CT_TextBulletSizeFollowText extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBulletSizeFollowText.$t = markType(CT_TextBulletSizeFollowText, 'CT_TextBulletSizeFollowText');
/**
 * @hidden
 */
export class CT_TextBulletSizePercent extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBulletSizePercent.$t = markType(CT_TextBulletSizePercent, 'CT_TextBulletSizePercent');
/**
 * @hidden
 */
export class CT_TextBulletSizePoint extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBulletSizePoint.$t = markType(CT_TextBulletSizePoint, 'CT_TextBulletSizePoint');
/**
 * @hidden
 */
export class CT_TextBulletTypefaceFollowText extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBulletTypefaceFollowText.$t = markType(CT_TextBulletTypefaceFollowText, 'CT_TextBulletTypefaceFollowText');
/**
 * @hidden
 */
export class CT_TextAutonumberBullet extends Base {
    constructor() {
        super();
        this.b = 0;
        this.e = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static g(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_TextAutonumberScheme_$type, d.d);
                    break;
                case "startAt":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "startAt";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        f = "type";
        e = XmlNamespaceDefinitionBase.f(ST_TextAutonumberScheme_$type, d);
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextAutonumberBullet.$t = markType(CT_TextAutonumberBullet, 'CT_TextAutonumberBullet');
/**
 * @hidden
 */
export class CT_TextCharBullet extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "char":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "char";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextCharBullet.$t = markType(CT_TextCharBullet, 'CT_TextCharBullet');
/**
 * @hidden
 */
export class CT_TextBlipBullet extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 127:
                this.a = typeCast(CT_Blip_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextBlipBullet.$t = markType(CT_TextBlipBullet, 'CT_TextBlipBullet', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextNoBullet extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextNoBullet.$t = markType(CT_TextNoBullet, 'CT_TextNoBullet');
/**
 * @hidden
 */
export class CT_TextUnderlineLineFollowText extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextUnderlineLineFollowText.$t = markType(CT_TextUnderlineLineFollowText, 'CT_TextUnderlineLineFollowText');
/**
 * @hidden
 */
export class CT_TextUnderlineFillFollowText extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextUnderlineFillFollowText.$t = markType(CT_TextUnderlineFillFollowText, 'CT_TextUnderlineFillFollowText');
/**
 * @hidden
 */
export class CT_TextUnderlineFillGroupWrapper extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.a = null;
    }
    get item() {
        return this.d;
    }
    set item(a) {
        this.d = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_FillProperties();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            default:
                if (this.b.f(a)) {
                    this.b.j(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextUnderlineFillGroupWrapper.$t = markType(CT_TextUnderlineFillGroupWrapper, 'CT_TextUnderlineFillGroupWrapper', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextSpacingPercent extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextSpacingPercent.$t = markType(CT_TextSpacingPercent, 'CT_TextSpacingPercent');
/**
 * @hidden
 */
export class CT_TextSpacingPoint extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextSpacingPoint.$t = markType(CT_TextSpacingPoint, 'CT_TextSpacingPoint');
/**
 * @hidden
 */
export class CT_TextTabStop extends Base {
    constructor() {
        super(...arguments);
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.b = Nullable$1.toNullable(ST_TextTabAlignType_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(ST_TextTabAlignType_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "pos":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "algn":
                    c = Nullable$1.toNullable(ST_TextTabAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextTabAlignType_$type, d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c = Nullable$1.toNullable(ST_TextTabAlignType_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "algn";
            e = XmlNamespaceDefinitionBase.f(ST_TextTabAlignType_$type, c.value);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "pos";
            e = d.value.toString();
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextTabStop.$t = markType(CT_TextTabStop, 'CT_TextTabStop');
/**
 * @hidden
 */
export class CT_TextTabStopList extends Base {
    constructor() {
        super();
        this.f = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1656:
                this.e.add(typeCast(CT_TextTabStop.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static c(a) {
        return a != null ? a.e : null;
    }
    static a(a) {
        let b = new CT_TextTabStopList();
        b.f = a;
        return b;
    }
}
CT_TextTabStopList.$t = markType(CT_TextTabStopList, 'CT_TextTabStopList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextLineBreak extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1305:
                this.a = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextLineBreak.$t = markType(CT_TextLineBreak, 'CT_TextLineBreak', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextSpacing extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.a = null;
        this.b = null;
    }
    get item() {
        return this.d;
    }
    set item(a) {
        this.d = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1566:
                this.a = typeCast(CT_TextSpacingPercent.$, b);
                break;
            case 1567:
                this.b = typeCast(CT_TextSpacingPoint.$, b);
                break;
        }
    }
    f(a, b, c, d) {
        c.p(d, "a");
        c.k();
    }
}
CT_TextSpacing.$t = markType(CT_TextSpacing, 'CT_TextSpacing', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextField extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.h = null;
        this.f = null;
        this.k = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static l(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "id":
                    b = d.d;
                    break;
                case "type":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static m(a, b, c, d) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c != null) {
            f = "type";
            e = c;
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "id";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1305:
                this.a = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            case 1154:
                this.c = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 1655:
                this.g = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextField.$t = markType(CT_TextField, 'CT_TextField', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_RegularTextRun_DML extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1305:
                this.a = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            case 1655:
                this.c = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RegularTextRun_DML.$t = markType(CT_RegularTextRun_DML, 'CT_RegularTextRun_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class DMLAttributes extends Base {
}
DMLAttributes.$t = markType(DMLAttributes, 'DMLAttributes');
/**
 * @hidden
 */
export class EG_EffectProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.v(this.a, a, b, c, DrawingMLMain.dh);
        }
        if (this.b != null) {
            DMLExtensions.w(this.b, a, b, c, DrawingMLMain.di);
        }
    }
    e(a, b) {
        switch (a) {
            case 558:
                this.a = typeCast(CT_EffectContainer.$, b);
                break;
            case 560:
                this.b = typeCast(CT_EffectList.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 558:
            case 560: return true;
        }
        return false;
    }
}
EG_EffectProperties.$t = markType(EG_EffectProperties, 'EG_EffectProperties');
/**
 * @hidden
 */
export class EG_OfficeArtExtensionList extends Base {
    constructor() {
        super();
        this.b = null;
        this.b = new List$1(CT_OfficeArtExtension.$, 0);
    }
    c(a, b, c, d) {
        if (this.b != null) {
            for (let e of fromEnum(this.b)) {
                e.e(a, b, c, DrawingMLMain.dq);
            }
        }
    }
    d(a, b) {
        switch (a) {
            case 599:
                this.b.add(typeCast(CT_OfficeArtExtension.$, b));
                break;
            default: break;
        }
    }
    a(a) {
        switch (a) {
            case 599: return true;
        }
        return false;
    }
}
EG_OfficeArtExtensionList.$t = markType(EG_OfficeArtExtensionList, 'EG_OfficeArtExtensionList');
/**
 * @hidden
 */
export class EG_FillPropertiesBase extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.d = null;
        this.b = null;
        this.c = null;
    }
    h(a, b, c, d) {
        if (this.a != null) {
            this.a.save1(a, b, c, DrawingMLMain.ej);
        }
        if (this.d != null) {
            DMLExtensions.ci(this.d, a, b, c, DrawingMLMain.gy);
        }
        if (this.b != null) {
            this.b.save1(a, b, c, DrawingMLMain.hh);
        }
        if (this.c != null) {
            this.c.save1(a, b, c, DrawingMLMain.io);
        }
    }
    j(a, b) {
        switch (a) {
            case 725:
                this.a = typeCast(CT_GradientFillProperties.$, b);
                break;
            case 1063:
                this.d = typeCast(CT_NoFillProperties.$, b);
                break;
            case 1553:
                this.c = typeCast(CT_SolidColorFillProperties.$, b);
                break;
            case 1174:
                this.b = typeCast(CT_PatternFillProperties.$, b);
                break;
            default: break;
        }
    }
    f(a) {
        switch (a) {
            case 725:
            case 1063:
            case 1553:
            case 1174: return true;
        }
        return false;
    }
    get_e() {
        return this.a != null || this.d != null || this.b != null || this.c != null;
    }
    get e() {
        return this.get_e();
    }
    i() {
        this.g();
        this.d = new CT_NoFillProperties();
    }
    g() {
        this.a = null;
        this.d = null;
        this.b = null;
        this.c = null;
    }
}
EG_FillPropertiesBase.$t = markType(EG_FillPropertiesBase, 'EG_FillPropertiesBase');
/**
 * @hidden
 */
export class EG_FillProperties extends EG_FillPropertiesBase {
    constructor() {
        super(...arguments);
        this.k = null;
        this.l = null;
    }
    h(a, b, c, d) {
        super.h(a, b, c, d);
        if (this.k != null) {
            this.k.save1(a, b, c, DrawingMLMain.bt);
        }
        if (this.l != null) {
            DMLExtensions.cb(this.l, a, b, c, DrawingMLMain.es);
        }
    }
    j(a, b) {
        switch (a) {
            case 128:
                this.k = typeCast(CT_BlipFillProperties_DML.$, b);
                break;
            case 752:
                this.l = typeCast(CT_GroupFillProperties.$, b);
                break;
            default:
                super.j(a, b);
                break;
        }
    }
    f(a) {
        switch (a) {
            case 128:
            case 752: return true;
        }
        return super.f(a);
        ;
    }
    get_e() {
        return super.get_e() || this.l != null || this.k != null;
    }
    g() {
        super.g();
        this.k = null;
        this.l = null;
    }
}
EG_FillProperties.$t = markType(EG_FillProperties, 'EG_FillProperties', EG_FillPropertiesBase.$);
/**
 * @hidden
 */
export class EG_ShadeProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            this.a.g(a, b, c, DrawingMLMain.fu);
        }
        if (this.b != null) {
            this.b.g(a, b, c, DrawingMLMain.hf);
        }
    }
    e(a, b) {
        switch (a) {
            case 903:
                this.a = typeCast(CT_LinearShadeProperties.$, b);
                break;
            case 1172:
                this.b = typeCast(CT_PathShadeProperties.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 903:
            case 1172: return true;
        }
        return false;
    }
}
EG_ShadeProperties.$t = markType(EG_ShadeProperties, 'EG_ShadeProperties');
/**
 * @hidden
 */
export class EG_Effect extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = null;
        this.e = null;
        this.f = null;
        this.g = null;
        this.h = null;
        this.i = null;
        this.j = null;
        this.k = null;
        this.l = null;
        this.m = null;
        this.o = null;
        this.n = null;
        this.p = null;
        this.q = null;
        this.r = null;
        this.s = null;
        this.t = null;
        this.u = null;
        this.v = null;
        this.w = null;
        this.x = null;
        this.y = null;
        this.z = null;
        this.aa = null;
        this.ab = null;
        this.ac = null;
        this.ad = null;
    }
    af(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.a(this.a, a, b, c, DrawingMLMain.a2);
        }
        if (this.b != null) {
            DMLExtensions.b(this.b, a, b, c, DrawingMLMain.a3);
        }
        if (this.c != null) {
            DMLExtensions.c(this.c, a, b, c, DrawingMLMain.a4);
        }
        if (this.d != null) {
            this.d.d(a, b, c, DrawingMLMain.a5);
        }
        if (this.e != null) {
            DMLExtensions.e(this.e, a, b, c, DrawingMLMain.a6);
        }
        if (this.f != null) {
            DMLExtensions.f(this.f, a, b, c, DrawingMLMain.a7);
        }
        if (this.g != null) {
            DMLExtensions.g(this.g, a, b, c, DrawingMLMain.a9);
        }
        if (this.h != null) {
            DMLExtensions.h(this.h, a, b, c, DrawingMLMain.ba);
        }
        if (this.i != null) {
            DMLExtensions.l(this.i, a, b, c, DrawingMLMain.bp);
        }
        if (this.j != null) {
            DMLExtensions.m(this.j, a, b, c, DrawingMLMain.br);
        }
        if (this.k != null) {
            DMLExtensions.p(this.k, a, b, c, DrawingMLMain.bx);
        }
        if (this.l != null) {
            DMLExtensions.s(this.l, a, b, c, DrawingMLMain.cj);
        }
        if (this.m != null) {
            this.m.d(a, b, c, DrawingMLMain.cl);
        }
        if (this.o != null) {
            DMLExtensions.v(this.o, a, b, c, DrawingMLMain.cr);
        }
        if (this.n != null) {
            this.n.d(a, b, c, DrawingMLMain.dd);
        }
        if (this.p != null) {
            DMLExtensions.y(this.p, a, b, c, DrawingMLMain.dg);
        }
        if (this.q != null) {
            DMLExtensions.ab(this.q, a, b, c, DrawingMLMain.dw);
        }
        if (this.r != null) {
            this.r.g(a, b, c, DrawingMLMain.dx);
        }
        if (this.s != null) {
            this.s.h(a, b, c, DrawingMLMain.ei);
        }
        if (this.t != null) {
            DMLExtensions.ak(this.t, a, b, c, DrawingMLMain.eo);
        }
        if (this.u != null) {
            DMLExtensions.al(this.u, a, b, c, DrawingMLMain.e6);
        }
        if (this.v != null) {
            this.v.n(a, b, c, DrawingMLMain.ff);
        }
        if (this.w != null) {
            DMLExtensions.ar(this.w, a, b, c, DrawingMLMain.f4);
        }
        if (this.x != null) {
            this.x.ag(a, b, c, DrawingMLMain.hc);
        }
        if (this.y != null) {
            this.y.m(a, b, c, DrawingMLMain.hq);
        }
        if (this.z != null) {
            DMLExtensions.a0(this.z, a, b, c, DrawingMLMain.h0);
        }
        if (this.aa != null) {
            DMLExtensions.a2(this.aa, a, b, c, DrawingMLMain.h1);
        }
        if (this.ab != null) {
            DMLExtensions.a6(this.ab, a, b, c, DrawingMLMain.im);
        }
        if (this.ac != null) {
            DMLExtensions.bu(this.ac, a, b, c, DrawingMLMain.jm);
        }
        if (this.ad != null) {
            DMLExtensions.bv(this.ad, a, b, c, DrawingMLMain.j8);
        }
    }
    ag(a, b) {
        switch (a) {
            case 344:
                this.o = typeCast(CT_EffectContainer.$, b);
                break;
            case 556:
                this.p = typeCast(CT_EffectReference.$, b);
                break;
            case 32:
                this.a = typeCast(CT_AlphaBiLevelEffect.$, b);
                break;
            case 33:
                this.b = typeCast(CT_AlphaCeilingEffect.$, b);
                break;
            case 34:
                this.c = typeCast(CT_AlphaFloorEffect.$, b);
                break;
            case 35:
                this.d = typeCast(CT_AlphaInverseEffect.$, b);
                break;
            case 36:
                this.e = typeCast(CT_AlphaModulateEffect.$, b);
                break;
            case 37:
                this.f = typeCast(CT_AlphaModulateFixedEffect.$, b);
                break;
            case 39:
                this.g = typeCast(CT_AlphaOutsetEffect.$, b);
                break;
            case 40:
                this.h = typeCast(CT_AlphaReplaceEffect.$, b);
                break;
            case 117:
                this.i = typeCast(CT_BiLevelEffect.$, b);
                break;
            case 125:
                this.j = typeCast(CT_BlendEffect.$, b);
                break;
            case 134:
                this.k = typeCast(CT_BlurEffect.$, b);
                break;
            case 279:
                this.l = typeCast(CT_ColorChangeEffect.$, b);
                break;
            case 285:
                this.m = typeCast(CT_ColorReplaceEffect.$, b);
                break;
            case 546:
                this.n = typeCast(CT_DuotoneEffect.$, b);
                break;
            case 630:
                this.q = typeCast(CT_FillEffect.$, b);
                break;
            case 633:
                this.r = typeCast(CT_FillOverlayEffect.$, b);
                break;
            case 724:
                this.s = typeCast(CT_GlowEffect.$, b);
                break;
            case 732:
                this.t = typeCast(CT_GrayscaleEffect.$, b);
                break;
            case 799:
                this.u = typeCast(CT_HSLEffect.$, b);
                break;
            case 830:
                this.v = typeCast(CT_InnerShadowEffect.$, b);
                break;
            case 941:
                this.w = typeCast(CT_LuminanceEffect.$, b);
                break;
            case 1142:
                this.x = typeCast(CT_OuterShadowEffect.$, b);
                break;
            case 1275:
                this.y = typeCast(CT_PresetShadowEffect.$, b);
                break;
            case 1338:
                this.z = typeCast(CT_ReflectionEffect.$, b);
                break;
            case 1343:
                this.aa = typeCast(CT_RelativeOffsetEffect.$, b);
                break;
            case 1551:
                this.ab = typeCast(CT_SoftEdgesEffect.$, b);
                break;
            case 1744:
                this.ac = typeCast(CT_TintEffect.$, b);
                break;
            case 1892:
                this.ad = typeCast(CT_TransformEffect.$, b);
                break;
            default: break;
        }
    }
    ae(a) {
        switch (a) {
            case 344:
            case 556:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 39:
            case 40:
            case 117:
            case 125:
            case 134:
            case 279:
            case 285:
            case 546:
            case 630:
            case 633:
            case 724:
            case 732:
            case 799:
            case 830:
            case 941:
            case 1142:
            case 1275:
            case 1338:
            case 1343:
            case 1551:
            case 1744:
            case 1892: return true;
        }
        return false;
    }
}
EG_Effect.$t = markType(EG_Effect, 'EG_Effect');
/**
 * @hidden
 */
export class EG_Geometry extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.b2(this.a, a, b, c, DrawingMLMain.cz);
        }
        if (this.b != null) {
            DMLExtensions.cr(this.b, a, b, c, DrawingMLMain.hp);
        }
    }
    e(a, b) {
        switch (a) {
            case 371:
                this.a = typeCast(CT_CustomGeometry2D.$, b);
                break;
            case 1274:
                this.b = typeCast(CT_PresetGeometry2D.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 371:
            case 1274: return true;
        }
        return false;
    }
}
EG_Geometry.$t = markType(EG_Geometry, 'EG_Geometry');
/**
 * @hidden
 */
export class EG_ThemeableFillStyle extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.ad(this.a, a, b, c, DrawingMLMain.dw);
        }
        if (this.b != null) {
            DMLExtensions.ba(this.b, a, b, c, DrawingMLMain.dz);
        }
    }
    e(a, b) {
        switch (a) {
            case 630:
                this.a = typeCast(CT_FillProperties.$, b);
                break;
            case 635:
                this.b = typeCast(CT_StyleMatrixReference_DML.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 630:
            case 635: return true;
        }
        return false;
    }
}
EG_ThemeableFillStyle.$t = markType(EG_ThemeableFillStyle, 'EG_ThemeableFillStyle');
/**
 * @hidden
 */
export class EG_ThemeableEffectStyle extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.x(this.a, a, b, c, DrawingMLMain.dg);
        }
        if (this.b != null) {
            DMLExtensions.ba(this.b, a, b, c, DrawingMLMain.dj);
        }
    }
    e(a, b) {
        switch (a) {
            case 556:
                this.a = typeCast(CT_EffectProperties.$, b);
                break;
            case 561:
                this.b = typeCast(CT_StyleMatrixReference_DML.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 556:
            case 561: return true;
        }
        return false;
    }
}
EG_ThemeableEffectStyle.$t = markType(EG_ThemeableEffectStyle, 'EG_ThemeableEffectStyle');
/**
 * @hidden
 */
export class EG_ThemeableFontStyles extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        throw new NotImplementedException(0);
    }
    e(a, b) {
        switch (a) {
            case 659:
                this.a = typeCast(CT_FontCollection.$, b);
                break;
            case 660:
                this.b = typeCast(CT_FontReference.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 659:
            case 660: return true;
        }
        return false;
    }
}
EG_ThemeableFontStyles.$t = markType(EG_ThemeableFontStyles, 'EG_ThemeableFontStyles');
/**
 * @hidden
 */
export class EG_ColorChoice_DML extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = null;
        this.e = null;
        this.f = null;
    }
    h(a, b, c, d) {
        if (this.a != null) {
            this.a.d(a, b, c);
        }
        if (this.b != null) {
            this.b.d(a, b, c);
        }
        if (this.c != null) {
            this.c.d(a, b, c);
        }
        if (this.d != null) {
            this.d.d(a, b, c);
        }
        if (this.e != null) {
            this.e.d(a, b, c);
        }
        if (this.f != null) {
            this.f.d(a, b, c);
        }
    }
    i(a, b) {
        switch (a) {
            case 800:
                this.a = typeCast(CT_HslColor.$, b);
                break;
            case 1272:
                this.b = typeCast(CT_PresetColor.$, b);
                break;
            case 1429:
                this.c = typeCast(CT_SchemeColor_DML.$, b);
                break;
            case 1431:
                this.d = typeCast(CT_ScRgbColor.$, b);
                break;
            case 1586:
                this.e = typeCast(CT_SRgbColor_DML.$, b);
                break;
            case 1652:
                this.f = typeCast(CT_SystemColor.$, b);
                break;
            default: break;
        }
    }
    g(a) {
        switch (a) {
            case 800:
            case 1272:
            case 1429:
            case 1431:
            case 1586:
            case 1652: return true;
        }
        return false;
    }
}
EG_ColorChoice_DML.$t = markType(EG_ColorChoice_DML, 'EG_ColorChoice_DML');
/**
 * @hidden
 */
export class EG_TextAutofit extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
    }
    e(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.bl(this.a, a, b, c, DrawingMLMain.gr);
        }
        if (this.b != null) {
            DMLExtensions.bn(this.b, a, b, c, DrawingMLMain.g5);
        }
        if (this.c != null) {
            DMLExtensions.bp(this.c, a, b, c, DrawingMLMain.iq);
        }
    }
    f(a, b) {
        switch (a) {
            case 1057:
                this.a = typeCast(CT_TextNoAutofit.$, b);
                break;
            case 1073:
                this.b = typeCast(CT_TextNormalAutofit.$, b);
                break;
            case 1565:
                this.c = typeCast(CT_TextShapeAutofit.$, b);
                break;
            default: break;
        }
    }
    d(a) {
        switch (a) {
            case 1057:
            case 1073:
            case 1565: return true;
        }
        return false;
    }
}
EG_TextAutofit.$t = markType(EG_TextAutofit, 'EG_TextAutofit');
/**
 * @hidden
 */
export class EG_Text3D extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.af(this.a, a, b, c, DrawingMLMain.d2);
        }
        if (this.b != null) {
            DMLExtensions.a4(this.b, a, b, c, DrawingMLMain.ip);
        }
    }
    e(a, b) {
        switch (a) {
            case 1564:
                this.b = typeCast(CT_Shape3D.$, b);
                break;
            case 650:
                this.a = typeCast(CT_FlatText.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1564:
            case 650: return true;
        }
        return false;
    }
}
EG_Text3D.$t = markType(EG_Text3D, 'EG_Text3D');
/**
 * @hidden
 */
export class EG_FillModeProperties extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.cu(this.a, a, b, c, DrawingMLMain.i2);
        }
        if (this.b != null) {
            DMLExtensions.cw(this.b, a, b, c, DrawingMLMain.jj);
        }
    }
    e(a, b) {
        switch (a) {
            case 1727:
                this.b = typeCast(CT_TileInfoProperties.$, b);
                break;
            case 1608:
                this.a = typeCast(CT_StretchInfoProperties.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1727:
            case 1608: return true;
        }
        return false;
    }
}
EG_FillModeProperties.$t = markType(EG_FillModeProperties, 'EG_FillModeProperties');
/**
 * @hidden
 */
export class EG_ColorTransform extends Base {
    constructor() {
        super();
        this.y = null;
        this.ab = null;
        this.f = null;
        this.i = null;
        this.j = null;
        this.k = null;
        this.e = null;
        this.a = null;
        this.g = null;
        this.l = null;
        this.m = null;
        this.n = null;
        this.x = null;
        this.ac = null;
        this.d = null;
        this.h = null;
        this.b = null;
        this.o = null;
        this.p = null;
        this.q = null;
        this.r = null;
        this.s = null;
        this.t = null;
        this.u = null;
        this.v = null;
        this.w = null;
        this.z = null;
        this.aa = null;
    }
    af(a, b, c, d) {
        if (this.y != null) {
            DMLUtils.aq(a, this.y, DrawingMLMain.a1);
        }
        if (this.ab != null) {
            DMLUtils.ar(a, this.ab, DrawingMLMain.a6);
        }
        if (this.f != null) {
            DMLUtils.af(a, this.f, DrawingMLMain.a8);
        }
        if (this.i != null) {
            DMLUtils.am(a, this.i, DrawingMLMain.bu);
        }
        if (this.j != null) {
            DMLUtils.am(a, this.j, DrawingMLMain.bv);
        }
        if (this.k != null) {
            DMLUtils.am(a, this.k, DrawingMLMain.bw);
        }
        if (this.e != null) {
            DMLExtensions.bz(this.e, a, b, c, DrawingMLMain.cp);
        }
        if (this.a != null) {
            DMLExtensions.ag(this.a, a, b, c, DrawingMLMain.ef);
        }
        if (this.g != null) {
            DMLExtensions.ca(this.g, a, b, c, DrawingMLMain.en);
        }
        if (this.l != null) {
            DMLExtensions.cl(this.l, a, b, c, DrawingMLMain.ep);
        }
        if (this.m != null) {
            DMLExtensions.cl(this.m, a, b, c, DrawingMLMain.eq);
        }
        if (this.n != null) {
            DMLExtensions.cl(this.n, a, b, c, DrawingMLMain.er);
        }
        if (this.x != null) {
            DMLExtensions.co(this.x, a, b, c, DrawingMLMain.e8);
        }
        if (this.ac != null) {
            DMLExtensions.cq(this.ac, a, b, c, DrawingMLMain.e9);
        }
        if (this.d != null) {
            DMLExtensions.by(this.d, a, b, c, DrawingMLMain.fa);
        }
        if (this.h != null) {
            DMLExtensions.cd(this.h, a, b, c, DrawingMLMain.fg);
        }
        if (this.b != null) {
            DMLExtensions.an(this.b, a, b, c, DrawingMLMain.fi);
        }
        if (this.o != null) {
            DMLExtensions.cl(this.o, a, b, c, DrawingMLMain.f4);
        }
        if (this.p != null) {
            DMLExtensions.cl(this.p, a, b, c, DrawingMLMain.f5);
        }
        if (this.q != null) {
            DMLExtensions.cl(this.q, a, b, c, DrawingMLMain.f6);
        }
        if (this.r != null) {
            DMLExtensions.cl(this.r, a, b, c, DrawingMLMain.hx);
        }
        if (this.s != null) {
            DMLExtensions.cl(this.s, a, b, c, DrawingMLMain.hy);
        }
        if (this.t != null) {
            DMLExtensions.cl(this.t, a, b, c, DrawingMLMain.hz);
        }
        if (this.u != null) {
            DMLExtensions.cl(this.u, a, b, c, DrawingMLMain.ia);
        }
        if (this.v != null) {
            DMLExtensions.cl(this.v, a, b, c, DrawingMLMain.ib);
        }
        if (this.w != null) {
            DMLExtensions.cl(this.w, a, b, c, DrawingMLMain.ic);
        }
        if (this.z != null) {
            DMLExtensions.cp(this.z, a, b, c, DrawingMLMain.ii);
        }
        if (this.aa != null) {
            DMLExtensions.cp(this.aa, a, b, c, DrawingMLMain.jm);
        }
    }
    ag(a, b) {
        switch (a) {
            case 1744:
                this.aa = typeCast(CT_PositiveFixedPercentage.$, b);
                break;
            case 1459:
                this.z = typeCast(CT_PositiveFixedPercentage.$, b);
                break;
            case 326:
                this.e = typeCast(CT_ComplementTransform.$, b);
                break;
            case 845:
                this.h = typeCast(CT_InverseTransform.$, b);
                break;
            case 731:
                this.g = typeCast(CT_GrayscaleTransform.$, b);
                break;
            case 31:
                this.y = typeCast(CT_PositiveFixedPercentage.$, b);
                break;
            case 38:
                this.f = typeCast(CT_FixedPercentage.$, b);
                break;
            case 36:
                this.ab = typeCast(CT_PositivePercentage.$, b);
                break;
            case 802:
                this.x = typeCast(CT_PositiveFixedAngle.$, b);
                break;
            case 804:
                this.d = typeCast(CT_Angle.$, b);
                break;
            case 803:
                this.ac = typeCast(CT_PositivePercentage.$, b);
                break;
            case 1407:
                this.u = typeCast(CT_Percentage.$, b);
                break;
            case 1409:
                this.w = typeCast(CT_Percentage.$, b);
                break;
            case 1408:
                this.v = typeCast(CT_Percentage.$, b);
                break;
            case 941:
                this.o = typeCast(CT_Percentage.$, b);
                break;
            case 943:
                this.q = typeCast(CT_Percentage.$, b);
                break;
            case 942:
                this.p = typeCast(CT_Percentage.$, b);
                break;
            case 1331:
                this.r = typeCast(CT_Percentage.$, b);
                break;
            case 1333:
                this.t = typeCast(CT_Percentage.$, b);
                break;
            case 1332:
                this.s = typeCast(CT_Percentage.$, b);
                break;
            case 733:
                this.l = typeCast(CT_Percentage.$, b);
                break;
            case 735:
                this.n = typeCast(CT_Percentage.$, b);
                break;
            case 734:
                this.m = typeCast(CT_Percentage.$, b);
                break;
            case 131:
                this.i = typeCast(CT_Percentage.$, b);
                break;
            case 133:
                this.k = typeCast(CT_Percentage.$, b);
                break;
            case 132:
                this.j = typeCast(CT_Percentage.$, b);
                break;
            case 695:
                this.a = typeCast(CT_GammaTransform.$, b);
                break;
            case 846:
                this.b = typeCast(CT_InverseGammaTransform.$, b);
                break;
            default: break;
        }
    }
    ad(a) {
        switch (a) {
            case 1744:
            case 1459:
            case 326:
            case 845:
            case 731:
            case 31:
            case 38:
            case 36:
            case 802:
            case 804:
            case 803:
            case 1407:
            case 1409:
            case 1408:
            case 941:
            case 943:
            case 942:
            case 1331:
            case 1333:
            case 1332:
            case 733:
            case 735:
            case 734:
            case 131:
            case 133:
            case 132:
            case 695:
            case 846: return true;
        }
        return false;
    }
    c() {
        if (this.y == null && this.p == null && this.q == null && this.z == null) {
            return null;
        }
        let a = Nullable$1.toNullable(Number_$type, null);
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        if (this.y != null) {
            a = Nullable$1.toNullable(Number_$type, ST_Percentage.n(ST_PositiveFixedPercentage.b(this.y.a)));
        }
        if (this.p != null) {
            b = Nullable$1.toNullable(Number_$type, ST_Percentage.n(this.p.a));
        }
        if (this.q != null) {
            c = Nullable$1.toNullable(Number_$type, ST_Percentage.n(this.q.a));
        }
        if (this.z != null) {
            d = Nullable$1.toNullable(Number_$type, ST_Percentage.n(ST_PositiveFixedPercentage.b(this.z.a)));
        }
        return ((() => {
            let $ret = new WorkbookColorTransform(Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null));
            $ret._alpha$i = a;
            $ret._luminanceModulation$i = b;
            $ret._luminanceOffset$i = c;
            $ret._shade$i = d;
            return $ret;
        })());
    }
    ae(a) {
        if (a == null || a._b() == false) {
            return;
        }
        if (a._alpha$i.hasValue) {
            this.y = ((() => {
                let $ret = new CT_PositiveFixedPercentage();
                $ret.a = ST_PositiveFixedPercentage.d(ST_Percentage.a(a._alpha$i.value));
                return $ret;
            })());
        }
        if (a._luminanceModulation$i.hasValue) {
            this.p = ((() => {
                let $ret = new CT_Percentage();
                $ret.a = ST_Percentage.a(a._luminanceModulation$i.value);
                return $ret;
            })());
        }
        if (a._luminanceOffset$i.hasValue) {
            this.q = ((() => {
                let $ret = new CT_Percentage();
                $ret.a = ST_Percentage.a(a._luminanceOffset$i.value);
                return $ret;
            })());
        }
        if (a._shade$i.hasValue) {
            this.z = ((() => {
                let $ret = new CT_PositiveFixedPercentage();
                $ret.a = ST_PositiveFixedPercentage.d(ST_Percentage.a(a._shade$i.value));
                return $ret;
            })());
        }
    }
}
EG_ColorTransform.$t = markType(EG_ColorTransform, 'EG_ColorTransform');
/**
 * @hidden
 */
export class EG_LineFillProperties extends EG_FillPropertiesBase {
    constructor() {
        super();
    }
    h(a, b, c, d) {
        super.h(a, b, c, d);
    }
    j(a, b) {
        super.j(a, b);
    }
    f(a) {
        return super.f(a);
    }
}
EG_LineFillProperties.$t = markType(EG_LineFillProperties, 'EG_LineFillProperties', EG_FillPropertiesBase.$);
/**
 * @hidden
 */
export class EG_LineDashProperties extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.b4(this.a, a, b, c, DrawingMLMain.cy);
        }
        if (this.b != null) {
            DMLExtensions.cs(this.b, a, b, c, DrawingMLMain.ho);
        }
    }
    e(a, b) {
        switch (a) {
            case 1273:
                this.b = typeCast(CT_PresetLineDashProperties.$, b);
                break;
            case 368:
                this.a = typeCast(CT_DashStopList.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1273:
            case 368: return true;
        }
        return false;
    }
}
EG_LineDashProperties.$t = markType(EG_LineDashProperties, 'EG_LineDashProperties');
/**
 * @hidden
 */
export class EG_LineJoinProperties extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
    }
    e(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.cf(this.a, a, b, c, DrawingMLMain.bk);
        }
        if (this.b != null) {
            DMLExtensions.cg(this.b, a, b, c, DrawingMLMain.gl);
        }
        if (this.c != null) {
            DMLExtensions.ch(this.c, a, b, c, DrawingMLMain.h6);
        }
    }
    f(a, b) {
        switch (a) {
            case 1373:
                this.c = typeCast(CT_LineJoinRound.$, b);
                break;
            case 108:
                this.a = typeCast(CT_LineJoinBevel.$, b);
                break;
            case 1019:
                this.b = typeCast(CT_LineJoinMiterProperties.$, b);
                break;
            default: break;
        }
    }
    d(a) {
        switch (a) {
            case 1373:
            case 108:
            case 1019: return true;
        }
        return false;
    }
}
EG_LineJoinProperties.$t = markType(EG_LineJoinProperties, 'EG_LineJoinProperties');
/**
 * @hidden
 */
export class EG_TextUnderlineLine extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            this.a.r(a, b, c, DrawingMLMain.jw);
        }
        if (this.b != null) {
            DMLExtensions.bt(this.b, a, b, c, DrawingMLMain.jx);
        }
    }
    e(a, b) {
        switch (a) {
            case 1793:
                this.b = typeCast(CT_TextUnderlineLineFollowText.$, b);
                break;
            case 1792:
                this.a = typeCast(CT_LineProperties_DML.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1793:
            case 1792: return true;
        }
        return false;
    }
}
EG_TextUnderlineLine.$t = markType(EG_TextUnderlineLine, 'EG_TextUnderlineLine');
/**
 * @hidden
 */
export class EG_TextUnderlineFill extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
    }
    d(a, b, c, d) {
        if (this.b != null) {
            DMLExtensions.bs(this.b, a, b, c, DrawingMLMain.ju);
        }
        if (this.a != null) {
            DMLExtensions.br(this.a, a, b, c, DrawingMLMain.jv);
        }
    }
    e(a, b) {
        switch (a) {
            case 1791:
                this.a = typeCast(CT_TextUnderlineFillFollowText.$, b);
                break;
            case 1790:
                this.b = typeCast(CT_TextUnderlineFillGroupWrapper.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1791:
            case 1790: return true;
        }
        return false;
    }
}
EG_TextUnderlineFill.$t = markType(EG_TextUnderlineFill, 'EG_TextUnderlineFill');
/**
 * @hidden
 */
export class EG_TextBulletColor extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
    }
    d(a, b, c, d) {
        if (this.b != null) {
            DMLExtensions.be(this.b, a, b, c, DrawingMLMain.b5);
        }
        if (this.a != null) {
            this.a.d(a, b, c, DrawingMLMain.b4);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 176:
                this.b = typeCast(CT_TextBulletColorFollowText.$, b);
                break;
            case 175:
                this.a = typeCast(CT_Color_DML.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 176:
            case 175: return true;
        }
        return false;
    }
}
EG_TextBulletColor.$t = markType(EG_TextBulletColor, 'EG_TextBulletColor', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class EG_TextBulletSize extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
    }
    e(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.bf(this.a, a, b, c, DrawingMLMain.cb);
        }
        if (this.b != null) {
            DMLExtensions.bg(this.b, a, b, c, DrawingMLMain.b9);
        }
        if (this.c != null) {
            DMLExtensions.bh(this.c, a, b, c, DrawingMLMain.ca);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 182:
                this.a = typeCast(CT_TextBulletSizeFollowText.$, b);
                break;
            case 180:
                this.b = typeCast(CT_TextBulletSizePercent.$, b);
                break;
            case 181:
                this.c = typeCast(CT_TextBulletSizePoint.$, b);
                break;
            default: break;
        }
    }
    d(a) {
        switch (a) {
            case 182:
            case 180:
            case 181: return true;
        }
        return false;
    }
}
EG_TextBulletSize.$t = markType(EG_TextBulletSize, 'EG_TextBulletSize', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class EG_TextBulletTypeface extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
    }
    d(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.bi(this.a, a, b, c, DrawingMLMain.b7);
        }
        if (this.b != null) {
            DMLExtensions.cv(this.b, a, b, c, DrawingMLMain.b6);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 178:
                this.a = typeCast(CT_TextBulletTypefaceFollowText.$, b);
                break;
            case 177:
                this.b = typeCast(CT_TextFont.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 178:
            case 177: return true;
        }
        return false;
    }
}
EG_TextBulletTypeface.$t = markType(EG_TextBulletTypeface, 'EG_TextBulletTypeface', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class EG_TextBullet extends Base {
    constructor() {
        super();
        this.d = null;
        this.a = null;
        this.c = null;
        this.b = null;
    }
    f(a, b, c, d) {
        if (this.d != null) {
            DMLExtensions.bm(this.d, a, b, c, DrawingMLMain.b8);
        }
        if (this.a != null) {
            DMLExtensions.bb(this.a, a, b, c, DrawingMLMain.b1);
        }
        if (this.c != null) {
            DMLExtensions.bj(this.c, a, b, c, DrawingMLMain.b3);
        }
        if (this.b != null) {
            DMLExtensions.bc(this.b, a, b, c, DrawingMLMain.b2);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 179:
                this.d = typeCast(CT_TextNoBullet.$, b);
                break;
            case 172:
                this.a = typeCast(CT_TextAutonumberBullet.$, b);
                break;
            case 174:
                this.c = typeCast(CT_TextCharBullet.$, b);
                break;
            case 173:
                this.b = typeCast(CT_TextBlipBullet.$, b);
                break;
            default: break;
        }
    }
    e(a) {
        switch (a) {
            case 179:
            case 172:
            case 174:
            case 173: return true;
        }
        return false;
    }
}
EG_TextBullet.$t = markType(EG_TextBullet, 'EG_TextBullet', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class EG_TextRun extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = null;
        this.b = null;
    }
    e(a, b, c, d) {
        if (this.a != null) {
            DMLExtensions.a1(this.a, a, b, c, DrawingMLMain.hu);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 1297:
                this.a = typeCast(CT_RegularTextRun_DML.$, b);
                break;
            case 164:
                this.c = typeCast(CT_TextLineBreak.$, b);
                break;
            case 651:
                this.b = typeCast(CT_TextField.$, b);
                break;
            default: break;
        }
    }
    d(a) {
        switch (a) {
            case 1297:
            case 164:
            case 651: return true;
        }
        return false;
    }
}
EG_TextRun.$t = markType(EG_TextRun, 'EG_TextRun', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class ST_HexBinary3 extends Base {
    constructor(a, b, c) {
        super();
        this.d = 0;
        this.c = 0;
        this.b = 0;
        this.d = a;
        this.c = b;
        this.b = c;
    }
    static a(a) {
        if (stringIsNullOrEmpty(a)) {
            return null;
        }
        if (a.length != 6) {
            return null;
        }
        let b, c, d;
        if (((() => { let e = tryParseInt32_1(a.substr(0, 2), b); b = e.p1; return e.ret; })()) && ((() => { let e = tryParseInt32_1(a.substr(2, 2), c); c = e.p1; return e.ret; })()) && ((() => { let e = tryParseInt32_1(a.substr(4, 2), d); d = e.p1; return e.ret; })())) {
            return new ST_HexBinary3(b, c, d);
        }
        else {
        }
        return null;
    }
    f() {
        let a = new StringBuilder(1, 6);
        a.l(intToString1(this.d, "X"));
        a.l(intToString1(this.c, "X"));
        a.l(intToString1(this.b, "X"));
        return a.toString();
    }
    toString() {
        return this.f();
    }
}
ST_HexBinary3.$t = markType(ST_HexBinary3, 'ST_HexBinary3');
/**
 * @hidden
 */
export class CT_BlipFillProperties_DML extends CT_BlipFillPropertiesBase {
    constructor() {
        super(...arguments);
        this.f = null;
        this.d = null;
    }
    get g() {
        if (this.f == null) {
            this.f = new EG_FillModeProperties();
        }
        return this.f;
    }
    setProperty(a, b) {
        switch (a) {
            case 127:
                this.d = typeCast(CT_Blip_DML.$, b);
                break;
            default:
                this.g.e(a, b);
                break;
        }
    }
    static e(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "dpi":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "rotWithShape":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_BlipFillProperties_DML();
            $ret.b = b;
            $ret.c = c;
            return $ret;
        })());
        return e;
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "dpi";
            e = intToString(c.value, CultureInfo.currentCulture);
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "rotWithShape";
            e = ST_OnOff.g(d.value);
            a.ad.h(f, e);
        }
    }
    save1(a, b, c, d) {
        CT_BlipFillProperties_DML.i(a, d, this.b, this.c);
        let e = this.d;
        if (e != null) {
            DMLExtensions.n(e, a, b, c, DrawingMLMain.bs);
        }
        let f = this.a;
        if (f != null) {
            DMLUtils.au(a, f, DrawingMLMain.iz);
        }
        if (this.g != null) {
            this.g.d(a, b, c, d);
        }
        c.k();
    }
    get elementName() {
        return DrawingMLMain.bt;
    }
    saveX(a, b, c, d) {
        this.save1(a, typeCast(WorkbookSaveManagerExcel2007.$, d), b, c);
    }
}
CT_BlipFillProperties_DML.$t = markType(CT_BlipFillProperties_DML, 'CT_BlipFillProperties_DML', CT_BlipFillPropertiesBase.$, [ISaveToXLSX_$type, ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextCharacterProperties_DML extends CT_TextCharacterPropertiesBase {
    constructor() {
        super();
        this.ac = null;
        this.aa = null;
        this.ag = null;
        this.ae = null;
        this.x = null;
        this.w = null;
        this.ak = null;
        this.ai = null;
        this.aj = null;
        this.y = null;
    }
    get ad() {
        if (this.ac == null) {
            this.ac = new EG_FillProperties();
        }
        return this.ac;
    }
    get ab() {
        if (this.aa == null) {
            this.aa = new EG_EffectProperties();
        }
        return this.aa;
    }
    get ah() {
        if (this.ag == null) {
            this.ag = new EG_TextUnderlineLine();
        }
        return this.ag;
    }
    get af() {
        if (this.ae == null) {
            this.ae = new EG_TextUnderlineFill();
        }
        return this.ae;
    }
    static z(a, b) {
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = null;
        let e = null;
        let f = Nullable$1.toNullable(ST_TextFontSize.$, null);
        let g = Nullable$1.toNullable(Boolean_$type, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = Nullable$1.toNullable(ST_TextUnderlineType_$type, null);
        let j = Nullable$1.toNullable(ST_TextStrikeType_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(ST_TextCapsType_$type, null);
        let m = Nullable$1.toNullable(ST_TextPoint.$, null);
        let n = Nullable$1.toNullable(Boolean_$type, null);
        let o = Nullable$1.toNullable(ST_Percentage.$, null);
        let p = Nullable$1.toNullable(Boolean_$type, null);
        let q = Nullable$1.toNullable(Boolean_$type, null);
        let r = Nullable$1.toNullable(Boolean_$type, null);
        let s = Nullable$1.toNullable(Boolean_$type, null);
        let t = Nullable$1.toNullable(Number_$type, null);
        let u = null;
        let v = CT_TextCharacterProperties_DML.ap(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u);
        c = v.p2;
        d = v.p3;
        e = v.p4;
        f = v.p5;
        g = v.p6;
        h = v.p7;
        i = v.p8;
        j = v.p9;
        k = v.p10;
        l = v.p11;
        m = v.p12;
        n = v.p13;
        o = v.p14;
        p = v.p15;
        q = v.p16;
        r = v.p17;
        s = v.p18;
        t = v.p19;
        u = v.p20;
        let w = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.k = c;
            $ret.v = d;
            $ret.t = e;
            $ret.r = ST_TextFontSize.g(f);
            $ret.d = g;
            $ret.i = h;
            $ret.s = i;
            $ret.q = j;
            $ret.j = k;
            $ret.f = l;
            $ret.p = m;
            $ret.m = n;
            $ret.e = o;
            $ret.l = p;
            $ret.g = q;
            $ret.n = s;
            $ret.o = t;
            $ret.u = u;
            return $ret;
        })());
        return w;
    }
    static ap(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
        let v = DrawingMLMain.ms(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, b, false);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u
        };
    }
    static ar(a, b, c = null, d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(ST_Percentage.$, null), f = null, g = Nullable$1.toNullable(ST_TextCapsType_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = null, n = Nullable$1.toNullable(Boolean_$type, null), o = Nullable$1.toNullable(Boolean_$type, null), p = Nullable$1.toNullable(Boolean_$type, null), q = Nullable$1.toNullable(Number_$type, null), r = Nullable$1.toNullable(ST_TextPoint.$, null), s = Nullable$1.toNullable(ST_TextStrikeType_$type, null), t = Nullable$1.toNullable(Number_$type, null), u = Nullable$1.toNullable(ST_TextUnderlineType_$type, null)) {
        let v = SerializationUtils.k(a);
        a.ad.p(b, "a");
        let w = null;
        let x = null;
        if (c != null) {
            x = "altLang";
            w = c;
            a.ad.h(x, w);
        }
        if (d.hasValue) {
            x = "b";
            w = ST_OnOff.g(d.value);
            a.ad.h(x, w);
        }
        if (e.hasValue) {
            x = "baseline";
            w = e.value.r(v);
            a.ad.h(x, w);
        }
        if (f != null) {
            x = "bmk";
            w = f;
            a.ad.h(x, w);
        }
        if (g.hasValue) {
            x = "cap";
            w = XmlNamespaceDefinitionBase.f(ST_TextCapsType_$type, g.value);
            a.ad.h(x, w);
        }
        if (h.hasValue) {
            x = "dirty";
            w = ST_OnOff.g(h.value);
            a.ad.h(x, w);
        }
        if (i.hasValue) {
            x = "err";
            w = ST_OnOff.g(i.value);
            a.ad.h(x, w);
        }
        if (j.hasValue) {
            x = "i";
            w = ST_OnOff.g(j.value);
            a.ad.h(x, w);
        }
        if (k.hasValue) {
            x = "kern";
            w = k.value.toString();
            a.ad.h(x, w);
        }
        if (l.hasValue) {
            x = "kumimoji";
            w = ST_OnOff.g(l.value);
            a.ad.h(x, w);
        }
        if (m != null) {
            x = "lang";
            w = m;
            a.ad.h(x, w);
        }
        if (n.hasValue) {
            x = "noProof";
            w = ST_OnOff.g(n.value);
            a.ad.h(x, w);
        }
        if (o.hasValue) {
            x = "normalizeH";
            w = ST_OnOff.g(o.value);
            a.ad.h(x, w);
        }
        if (p.hasValue) {
            x = "smtClean";
            w = ST_OnOff.g(p.value);
            a.ad.h(x, w);
        }
        if (q.hasValue) {
            x = "smtId";
            w = q.value.toString();
            a.ad.h(x, w);
        }
        if (r.hasValue) {
            x = "spc";
            w = r.value.toString();
            a.ad.h(x, w);
        }
        if (s.hasValue) {
            x = "strike";
            w = XmlNamespaceDefinitionBase.f(ST_TextStrikeType_$type, s.value);
            a.ad.h(x, w);
        }
        if (t.hasValue) {
            x = "sz";
            w = t.value.toString();
            a.ad.h(x, w);
        }
        if (u.hasValue) {
            x = "u";
            w = XmlNamespaceDefinitionBase.f(ST_TextUnderlineType_$type, u.value);
            a.ad.h(x, w);
        }
    }
    aq(a, b, c, d) {
        CT_TextCharacterProperties_DML.ar(a, d, this.t, this.d, this.e, this.u, this.f, this.g, this.h, this.i, this.j, this.k, this.v, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s);
        if (this.x != null) {
            this.x.r(a, b, c, DrawingMLMain.fw);
        }
        if (this.ad != null) {
            this.ad.h(a, b, c, null);
        }
        if (this.ab != null) {
            this.ab.d(a, b, c, null);
        }
        if (this.w != null) {
            this.w.d(a, b, c, DrawingMLMain.ey);
        }
        if (this.af != null) {
            this.af.d(a, b, c, null);
        }
        if (this.ah != null) {
            this.ah.d(a, b, c, null);
        }
        if (this.c != null) {
            DMLExtensions.cv(this.c, a, b, c, DrawingMLMain.fq);
        }
        if (this.b != null) {
            DMLExtensions.cv(this.b, a, b, c, DrawingMLMain.de);
        }
        if (this.a != null) {
            DMLExtensions.cv(this.a, a, b, c, DrawingMLMain.ct);
        }
        if (this.ak != null) {
            DMLExtensions.cv(this.ak, a, b, c, DrawingMLMain.i7);
        }
        if (this.ai != null) {
            DMLExtensions.cc(this.ai, a, b, c, DrawingMLMain.e2);
        }
        if (this.aj != null) {
            DMLExtensions.cc(this.aj, a, b, c, DrawingMLMain.e3);
        }
        c.k();
    }
    setProperty(a, b) {
        switch (a) {
            case 918:
                this.x = typeCast(CT_LineProperties_DML.$, b);
                break;
            case 789:
                this.w = typeCast(CT_Color_DML.$, b);
                break;
            case 875:
                this.c = typeCast(CT_TextFont.$, b);
                break;
            case 551:
                this.b = typeCast(CT_TextFont.$, b);
                break;
            case 363:
                this.a = typeCast(CT_TextFont.$, b);
                break;
            case 1650:
                this.ak = typeCast(CT_TextFont.$, b);
                break;
            case 791:
                this.ai = typeCast(CT_Hyperlink.$, b);
                break;
            case 793:
                this.aj = typeCast(CT_Hyperlink.$, b);
                break;
            case 601:
                this.y = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.ab != null && this.ab.c(a)) {
                    this.ab.e(a, b);
                }
                else if (this.ad != null && this.ad.f(a)) {
                    this.ad.j(a, b);
                }
                else if (this.af != null && this.af.c(a)) {
                    this.af.e(a, b);
                }
                else if (this.ah != null && this.ah.c(a)) {
                    this.ah.e(a, b);
                }
                else {
                }
                break;
        }
    }
}
CT_TextCharacterProperties_DML.$t = markType(CT_TextCharacterProperties_DML, 'CT_TextCharacterProperties_DML', CT_TextCharacterPropertiesBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Blip_DML extends CT_Blip {
    constructor() {
        super();
        this.d = null;
        this.e = null;
        this.f = null;
        this.g = null;
        this.h = null;
        this.i = null;
        this.j = null;
        this.k = null;
        this.m = null;
        this.n = null;
        this.o = null;
        this.p = null;
        this.u = null;
        this.q = null;
        this.r = null;
        this.s = null;
        this.t = null;
        this.v = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 32:
                this.d = typeCast(CT_AlphaBiLevelEffect.$, b);
                break;
            case 33:
                this.e = typeCast(CT_AlphaCeilingEffect.$, b);
                break;
            case 34:
                this.f = typeCast(CT_AlphaFloorEffect.$, b);
                break;
            case 35:
                this.g = typeCast(CT_AlphaInverseEffect.$, b);
                break;
            case 36:
                this.h = typeCast(CT_AlphaModulateEffect.$, b);
                break;
            case 37:
                this.i = typeCast(CT_AlphaModulateFixedEffect.$, b);
                break;
            case 40:
                this.j = typeCast(CT_AlphaReplaceEffect.$, b);
                break;
            case 117:
                this.k = typeCast(CT_BiLevelEffect.$, b);
                break;
            case 134:
                this.m = typeCast(CT_BlurEffect.$, b);
                break;
            case 279:
                this.n = typeCast(CT_ColorChangeEffect.$, b);
                break;
            case 285:
                this.o = typeCast(CT_ColorReplaceEffect.$, b);
                break;
            case 546:
                this.p = typeCast(CT_DuotoneEffect.$, b);
                break;
            case 601:
                this.u = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            case 633:
                this.q = typeCast(CT_FillOverlayEffect.$, b);
                break;
            case 732:
                this.r = typeCast(CT_GrayscaleEffect.$, b);
                break;
            case 799:
                this.s = typeCast(CT_HSLEffect.$, b);
                break;
            case 941:
                this.t = typeCast(CT_LuminanceEffect.$, b);
                break;
            case 1744:
                this.v = typeCast(CT_TintEffect.$, b);
                break;
            default: break;
        }
    }
    static l(a) {
        let b;
        let c;
        let d;
        let e = DrawingMLMain.kk(a, b, c, d, false);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        let f = ((() => {
            let $ret = new CT_Blip_DML();
            $ret.b = b;
            $ret.c = c;
            $ret.a = d;
            return $ret;
        })());
        return f;
    }
    static x(a, b, c = Nullable$1.toNullable(ST_BlipCompression_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "cstate";
            d = XmlNamespaceDefinitionBase.f(ST_BlipCompression_$type, c.value);
            a.ad.h(e, d);
        }
    }
}
CT_Blip_DML.$t = markType(CT_Blip_DML, 'CT_Blip_DML', CT_Blip.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LineStyleList extends Base {
    constructor() {
        super();
        this.a = null;
        this.a = new List$1(CT_LineProperties_DML.$, 0);
    }
}
CT_LineStyleList.$t = markType(CT_LineStyleList, 'CT_LineStyleList');
/**
 * @hidden
 */
export class CT_LineProperties_DML extends CT_LinePropertiesBase {
    constructor() {
        super(...arguments);
        this.m = null;
        this.k = null;
        this.o = null;
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.j = null;
    }
    get n() {
        if (this.m == null) {
            this.m = new EG_LineFillProperties();
        }
        return this.m;
    }
    get l() {
        if (this.k == null) {
            this.k = new EG_LineDashProperties();
        }
        return this.k;
    }
    get p() {
        if (this.o == null) {
            this.o = new EG_LineJoinProperties();
        }
        return this.o;
    }
    static i(a) {
        let b;
        let c;
        let d;
        let e;
        let f = DrawingMLMain.l6(a, b, c, d, e);
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        let g = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = b;
            $ret.f = c;
            $ret.g = d;
            $ret.e = e;
            return $ret;
        })());
        return g;
    }
    static s(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.e.hasValue) {
            e = "algn";
            f = EnumUtil.getName(ST_PenAlignment_$type, b.e.value);
            d.h(e, f);
        }
        if (b.f.hasValue) {
            e = "cap";
            f = EnumUtil.getName(ST_LineCap_$type, b.f.value);
            d.h(e, f);
        }
        if (b.g.hasValue) {
            e = "cmpd";
            f = EnumUtil.getName(ST_CompoundLine_$type, b.g.value);
            d.h(e, f);
        }
        if (b.h.hasValue) {
            e = "w";
            f = b.h.value.toString();
            d.h(e, f);
        }
        else if (b.q.hasValue) {
            e = "w";
            f = b.q.value.toString();
            d.h(e, f);
        }
    }
    r(a, b, c, d) {
        CT_LineProperties_DML.s(a, this, d);
        if (this.n != null) {
            this.n.h(a, b, c, null);
        }
        if (this.l != null) {
            this.l.d(a, b, c, null);
        }
        if (this.p != null) {
            this.p.e(a, b, c, null);
        }
        if (this.a != null) {
            DMLExtensions.ce(this.a, a, b, c, DrawingMLMain.ew);
        }
        if (this.b != null) {
            DMLExtensions.ce(this.b, a, b, c, DrawingMLMain.je);
        }
        if (this.j != null) {
            this.j.d(a, b, c, DrawingMLMain.dr);
        }
        c.k();
    }
    setProperty(a, b) {
        switch (a) {
            case 772:
                this.a = typeCast(CT_LineEndProperties.$, b);
                break;
            case 1675:
                this.b = typeCast(CT_LineEndProperties.$, b);
                break;
            case 601:
                this.j = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.l != null && this.l.c(a)) {
                    this.l.e(a, b);
                }
                else if (this.n != null && this.n.f(a)) {
                    this.n.j(a, b);
                }
                else if (this.p != null && this.p.d(a)) {
                    this.p.f(a, b);
                }
                else {
                }
                break;
        }
    }
}
CT_LineProperties_DML.$t = markType(CT_LineProperties_DML, 'CT_LineProperties_DML', CT_LinePropertiesBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DMLColorBase extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorTransform();
        }
        return this.a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DMLColorBase.$t = markType(CT_DMLColorBase, 'CT_DMLColorBase');
/**
 * @hidden
 */
export class CT_SRgbColor_DML extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.f = new ST_HexColorRGB();
    }
    static e(a) {
        let b = ST_HexColorRGB.a;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_HexColorRGB.d(c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_SRgbColor_DML();
            $ret.f = b;
            return $ret;
        })());
        return d;
    }
    static g(a, b) {
        let c = b.toString();
        a.ad.h("val", c);
    }
    d(a, b, c) {
        c.p(DrawingMLMain.i0, "a");
        CT_SRgbColor_DML.g(a, this.f);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
}
CT_SRgbColor_DML.$t = markType(CT_SRgbColor_DML, 'CT_SRgbColor_DML', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ScRgbColor extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.h = 0;
        this.g = 0;
        this.f = 0;
    }
    static e(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "r":
                    b = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "g":
                    c = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "b":
                    d = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_ScRgbColor();
            $ret.h = b;
            $ret.g = c;
            $ret.f = d;
            return $ret;
        })());
        return f;
    }
    static i(a, b, c, d) {
        let e = null;
        e = numberToString(b, CultureInfo.currentCulture);
        a.ad.h("r", e);
        e = numberToString(c, CultureInfo.currentCulture);
        a.ad.h("g", e);
        e = numberToString(d, CultureInfo.currentCulture);
        a.ad.h("b", e);
    }
    d(a, b, c) {
        c.p(DrawingMLMain.i0, "a");
        CT_ScRgbColor.i(a, this.h, this.g, this.f);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
}
CT_ScRgbColor.$t = markType(CT_ScRgbColor, 'CT_ScRgbColor', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_HslColor extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.f = 0;
        this.h = 0;
        this.g = 0;
    }
    static e(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "hue":
                    b = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "sat":
                    d = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "lum":
                    c = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_HslColor();
            $ret.f = b;
            $ret.h = d;
            $ret.g = c;
            return $ret;
        })());
        return f;
    }
    d(a, b, c) {
        c.p(DrawingMLMain.e7, "a");
        CT_HslColor.i(a, this.f, this.h, this.g);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
    static i(a, b, c, d) {
        let e = null;
        e = numberToString(b, CultureInfo.currentCulture);
        a.ad.h("hue", e);
        e = numberToString(c, CultureInfo.currentCulture);
        a.ad.h("sat", e);
        e = numberToString(d, CultureInfo.currentCulture);
        a.ad.h("lum", e);
    }
}
CT_HslColor.$t = markType(CT_HslColor, 'CT_HslColor', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SystemColor extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.f = 0;
        this.g = Nullable$1.toNullable(ST_HexColorRGB.$, null);
    }
    static e(a) {
        let b = 0;
        let c = Nullable$1.toNullable(ST_HexColorRGB.$, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SystemColorVal_$type, d.d);
                    break;
                case "lastClr":
                    c = Nullable$1.toNullable(ST_HexColorRGB.$, ST_HexColorRGB.d(d.d));
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_SystemColor();
            $ret.f = b;
            $ret.g = c;
            return $ret;
        })());
        return e;
    }
    static h(a, b, c) {
        let d = null;
        d = EnumUtil.getName(ST_SystemColorVal_$type, b);
        a.ad.h("val", d);
        if (c.hasValue) {
            d = c.value.toString();
            a.ad.h("lastClr", d);
        }
    }
    d(a, b, c) {
        c.p(DrawingMLMain.i8, "a");
        CT_SystemColor.h(a, this.f, this.g);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
}
CT_SystemColor.$t = markType(CT_SystemColor, 'CT_SystemColor', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SchemeColor_DML extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.g = 0;
    }
    static f(a) {
        let b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SchemeColorVal_$type, c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = b;
            return $ret;
        })());
        return d;
    }
    static h(a, b) {
        let c = null;
        c = EnumUtil.getName(ST_SchemeColorVal_$type, b);
        a.ad.h("val", c);
    }
    d(a, b, c) {
        c.p(DrawingMLMain.ie, "a");
        CT_SchemeColor_DML.h(a, this.g);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
    static e(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        let d = ((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = a;
            return $ret;
        })());
        if (b.hasValue) {
            d.b.p = ((() => {
                let $ret = new CT_Percentage();
                $ret.a = ST_Percentage.b(b.value);
                return $ret;
            })());
        }
        if (c.hasValue) {
            d.b.q = ((() => {
                let $ret = new CT_Percentage();
                $ret.a = ST_Percentage.b(c.value);
                return $ret;
            })());
        }
        return d;
    }
}
CT_SchemeColor_DML.$t = markType(CT_SchemeColor_DML, 'CT_SchemeColor_DML', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PresetColor extends CT_DMLColorBase {
    constructor() {
        super(...arguments);
        this.f = 0;
    }
    static e(a) {
        let b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_PresetColorVal_$type, c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_PresetColor();
            $ret.f = b;
            return $ret;
        })());
        return d;
    }
    static g(a, b) {
        let c = null;
        c = EnumUtil.getName(ST_PresetColorVal_$type, b);
        a.ad.h("val", c);
    }
    d(a, b, c) {
        c.p(DrawingMLMain.hn, "a");
        CT_PresetColor.g(a, this.f);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
}
CT_PresetColor.$t = markType(CT_PresetColor, 'CT_PresetColor', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StyleMatrix extends Base {
    constructor() {
        super();
        this.c = null;
        this.d = null;
        this.b = null;
        this.a = null;
        this.e = null;
    }
    static g(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static h(a, b, c = null) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c != null) {
            e = "name";
            d = c;
            a.ad.h(e, d);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StyleMatrix.$t = markType(CT_StyleMatrix, 'CT_StyleMatrix');
/**
 * @hidden
 */
export class CT_FillStyleList extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new List$1(ISaveToXLSX_$type, 0);
        }
        return this.a;
    }
    static c(a, b) {
        b = a > 1000;
        let c = b ? (a - 1001) : (a - 1);
        return {
            ret: c,
            p1: b
        };
    }
    setProperty(a, b) {
        let c = typeCast(ISaveToXLSX_$type, b);
        if (c == null) {
        }
        else {
            this.b.add(c);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FillStyleList.$t = markType(CT_FillStyleList, 'CT_FillStyleList', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BackgroundFillStyleList extends CT_FillStyleList {
    constructor() {
        super();
    }
}
CT_BackgroundFillStyleList.$t = markType(CT_BackgroundFillStyleList, 'CT_BackgroundFillStyleList', CT_FillStyleList.$);
/**
 * @hidden
 */
export class CT_ColorEffectBase extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ColorChoice_DML();
        }
        return this.a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorEffectBase.$t = markType(CT_ColorEffectBase, 'CT_ColorEffectBase');
/**
 * @hidden
 */
export class CT_PresetShadowEffect extends CT_ColorEffectBase {
    constructor() {
        super();
        this.e = 0;
        this.k = Nullable$1.toNullable(Number_$type, null);
        this.i = Nullable$1.toNullable(Number_$type, null);
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    m(a, b, c, d) {
        CT_PresetShadowEffect.n(a, d, this.h, this.j, this.d);
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
    static l(a, b, c, d) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "prst":
                    b = XmlNamespaceDefinitionBase.b(ST_PresetShadowVal_$type, e.d);
                    break;
                case "dist":
                    c = Nullable$1.toNullable(Number_$type, parseInt64_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "dir":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static n(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "dir";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "dist";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        g = "prst";
        f = XmlNamespaceDefinitionBase.f(ST_PresetShadowVal_$type, e);
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PresetShadowEffect.$t = markType(CT_PresetShadowEffect, 'CT_PresetShadowEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_OuterShadowEffect extends CT_ColorEffectBase {
    constructor() {
        super();
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.u = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(Number_$type, null);
        this.ac = Nullable$1.toNullable(Number_$type, null);
        this.ae = Nullable$1.toNullable(Number_$type, null);
        this.w = Nullable$1.toNullable(Number_$type, null);
        this.y = Nullable$1.toNullable(Number_$type, null);
        this.o = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        this.aa = Nullable$1.toNullable(Boolean_$type, null);
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get ad() {
        return this.ae;
    }
    set ad(a) {
        this.ae = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    ag(a, b, c, d) {
        CT_OuterShadowEffect.ah(a, d, this.n, this.p, this.r, this.t, this.v, this.x, this.z, this.ab, this.ad);
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
    static d(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let j = Nullable$1.toNullable(Boolean_$type, null);
        let k = CT_OuterShadowEffect.af(a, b, c, d, e, f, g, h, i, j);
        b = k.p1;
        c = k.p2;
        d = k.p3;
        e = k.p4;
        f = k.p5;
        g = k.p6;
        h = k.p7;
        i = k.p8;
        j = k.p9;
        return ((() => {
            let $ret = new CT_OuterShadowEffect();
            $ret.p = b;
            $ret.t = c;
            $ret.r = d;
            $ret.ab = e;
            $ret.ad = f;
            $ret.v = g;
            $ret.x = h;
            $ret.n = i;
            $ret.z = j;
            return $ret;
        })());
    }
    static af(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "blurRad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "dist":
                    c = Nullable$1.toNullable(Number_$type, parseInt64_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "dir":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "sx":
                    e = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "sy":
                    f = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "kx":
                    g = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "ky":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "algn":
                    i = Nullable$1.toNullable(ST_RectAlignment_$type, XmlNamespaceDefinitionBase.b(ST_RectAlignment_$type, k.d));
                    break;
                case "rotWithShape":
                    j = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static ah(a, b, c = Nullable$1.toNullable(ST_RectAlignment_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "algn";
            l = XmlNamespaceDefinitionBase.f(ST_RectAlignment_$type, c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "blurRad";
            l = d.value.toString();
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "dir";
            l = e.value.toString();
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "dist";
            l = f.value.toString();
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "kx";
            l = g.value.toString();
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "ky";
            l = h.value.toString();
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "rotWithShape";
            l = ST_OnOff.g(i.value);
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "sx";
            l = j.value.toString();
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "sy";
            l = k.value.toString();
            a.ad.h(m, l);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_OuterShadowEffect.$t = markType(CT_OuterShadowEffect, 'CT_OuterShadowEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_InnerShadowEffect extends CT_ColorEffectBase {
    constructor() {
        super();
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.l = Nullable$1.toNullable(Number_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    n(a, b, c, d) {
        CT_InnerShadowEffect.o(a, d, this.g, this.i, this.k);
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
    static m(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "blurRad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "dist":
                    c = Nullable$1.toNullable(Number_$type, parseInt64_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "dir":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static o(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "blurRad";
            f = c.value.toString();
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "dir";
            f = d.value.toString();
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "dist";
            f = e.value.toString();
            a.ad.h(g, f);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_InnerShadowEffect.$t = markType(CT_InnerShadowEffect, 'CT_InnerShadowEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GlowEffect extends CT_ColorEffectBase {
    constructor() {
        super();
        this.f = Nullable$1.toNullable(Number_$type, null);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    h(a, b, c, d) {
        CT_GlowEffect.i(a, d, this.e);
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    static g(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "rad":
                    b = Nullable$1.toNullable(Number_$type, parseInt64_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "rad";
            d = c.value.toString();
            a.ad.h(e, d);
        }
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
}
CT_GlowEffect.$t = markType(CT_GlowEffect, 'CT_GlowEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GradientStop extends CT_ColorEffectBase {
    constructor() {
        super();
        this.d = new ST_PositiveFixedPercentage();
    }
    f(a, b, c, d) {
        CT_GradientStop.g(a, d, this.d);
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
    static e(a, b) {
        b = new ST_PositiveFixedPercentage(0);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "pos":
                    b = ST_PositiveFixedPercentage.f(c.d, a.d._z);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "pos";
        d = c.u(a.d._z);
        a.ad.h(e, d);
    }
}
CT_GradientStop.$t = markType(CT_GradientStop, 'CT_GradientStop', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DuotoneEffect extends CT_ColorEffectBase {
    constructor() {
        super();
    }
    d(a, b, c, d) {
        c.p(d, "a");
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
}
CT_DuotoneEffect.$t = markType(CT_DuotoneEffect, 'CT_DuotoneEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorReplaceEffect extends CT_ColorEffectBase {
    constructor() {
        super();
    }
    d(a, b, c, d) {
        c.p(d, "a");
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
}
CT_ColorReplaceEffect.$t = markType(CT_ColorReplaceEffect, 'CT_ColorReplaceEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AlphaInverseEffect extends CT_ColorEffectBase {
    constructor() {
        super();
    }
    d(a, b, c, d) {
        c.p(d, "a");
        if (this.b != null) {
            this.b.h(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.i(a, b);
        }
    }
}
CT_AlphaInverseEffect.$t = markType(CT_AlphaInverseEffect, 'CT_AlphaInverseEffect', CT_ColorEffectBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextParagraphProperties_DML extends CT_TextParagraphProperties {
    constructor() {
        super();
        this.u = null;
        this.w = null;
        this.y = null;
        this.s = null;
        this.p = null;
        this.r = null;
        this.q = null;
        this.aa = null;
        this.n = null;
    }
    get v() {
        if (this.u == null) {
            this.u = new EG_TextBulletColor();
        }
        return this.u;
    }
    get x() {
        if (this.w == null) {
            this.w = new EG_TextBulletSize();
        }
        return this.w;
    }
    get z() {
        if (this.y == null) {
            this.y = new EG_TextBulletTypeface();
        }
        return this.y;
    }
    get t() {
        if (this.s == null) {
            this.s = new EG_TextBullet();
        }
        return this.s;
    }
    static o(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(ST_TextAlignType_$type, null);
        let g = Nullable$1.toNullable(ST_Coordinate32.$, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = Nullable$1.toNullable(Boolean_$type, null);
        let j = Nullable$1.toNullable(ST_TextFontAlignType_$type, null);
        let k = Nullable$1.toNullable(Boolean_$type, null);
        let l = Nullable$1.toNullable(Boolean_$type, null);
        let m = CT_TextParagraphProperties_DML.ab(a, b, c, d, e, f, g, h, i, j, k, l);
        b = m.p1;
        c = m.p2;
        d = m.p3;
        e = m.p4;
        f = m.p5;
        g = m.p6;
        h = m.p7;
        i = m.p8;
        j = m.p9;
        k = m.p10;
        l = m.p11;
        let n = ((() => {
            let $ret = new CT_TextParagraphProperties_DML();
            $ret.c = f;
            $ret.d = g;
            $ret.e = i;
            $ret.f = j;
            $ret.g = l;
            $ret.h = ST_TextIndent.h(e);
            $ret.i = k;
            $ret.j = ST_TextIndentLevelType.h(d);
            $ret.k = ST_TextMargin.h(b);
            $ret.l = ST_TextMargin.h(c);
            $ret.m = h;
            return $ret;
        })());
        return n;
    }
    static ab(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(ST_TextAlignType_$type, null);
        g = Nullable$1.toNullable(ST_Coordinate32.$, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(ST_TextFontAlignType_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "marL":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "marR":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "lvl":
                    d = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "indent":
                    e = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "algn":
                    f = Nullable$1.toNullable(ST_TextAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextAlignType_$type, m.d));
                    break;
                case "defTabSz":
                    g = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(m.d));
                    break;
                case "rtl":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "eaLnBrk":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "fontAlgn":
                    j = Nullable$1.toNullable(ST_TextFontAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextFontAlignType_$type, m.d));
                    break;
                case "latinLnBrk":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "hangingPunct":
                    l = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static ad(a, b, c = Nullable$1.toNullable(ST_TextAlignType_$type, null), d = Nullable$1.toNullable(ST_Coordinate32.$, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(ST_TextFontAlignType_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "a");
        let n = null;
        let o = null;
        if (c.hasValue) {
            o = "algn";
            n = XmlNamespaceDefinitionBase.f(ST_TextAlignType_$type, c.value);
            a.ad.h(o, n);
        }
        if (d.hasValue) {
            o = "defTabSz";
            n = d.value.toString();
            a.ad.h(o, n);
        }
        if (e.hasValue) {
            o = "eaLnBrk";
            n = ST_OnOff.g(e.value);
            a.ad.h(o, n);
        }
        if (f.hasValue) {
            o = "fontAlgn";
            n = XmlNamespaceDefinitionBase.f(ST_TextFontAlignType_$type, f.value);
            a.ad.h(o, n);
        }
        if (g.hasValue) {
            o = "hangingPunct";
            n = ST_OnOff.g(g.value);
            a.ad.h(o, n);
        }
        if (h.hasValue) {
            o = "indent";
            n = h.value.toString();
            a.ad.h(o, n);
        }
        if (i.hasValue) {
            o = "latinLnBrk";
            n = ST_OnOff.g(i.value);
            a.ad.h(o, n);
        }
        if (j.hasValue) {
            o = "lvl";
            n = j.value.toString();
            a.ad.h(o, n);
        }
        if (k.hasValue) {
            o = "marL";
            n = k.value.toString();
            a.ad.h(o, n);
        }
        if (l.hasValue) {
            o = "marR";
            n = l.value.toString();
            a.ad.h(o, n);
        }
        if (m.hasValue) {
            o = "rtl";
            n = ST_OnOff.g(m.value);
            a.ad.h(o, n);
        }
    }
    setProperty(a, b) {
        switch (a) {
            case 926:
                this.p = typeCast(CT_TextSpacing.$, b);
                break;
            case 1578:
                this.r = typeCast(CT_TextSpacing.$, b);
                break;
            case 1577:
                this.q = typeCast(CT_TextSpacing.$, b);
                break;
            case 1658:
                this.aa = CT_TextTabStopList.c(typeCast(CT_TextTabStopList.$, b));
                break;
            case 455:
                this.a = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            case 601:
                this.n = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default:
                if (this.v.c(a)) {
                    this.v.setProperty(a, b);
                    return;
                }
                else if (this.x.d(a)) {
                    this.x.setProperty(a, b);
                    return;
                }
                else if (this.z.c(a)) {
                    this.z.setProperty(a, b);
                    return;
                }
                else if (this.t.e(a)) {
                    this.t.setProperty(a, b);
                    return;
                }
                break;
        }
    }
    ac(a, b, c, d) {
        CT_TextParagraphProperties_DML.ad(a, d, this.c, this.d, this.e, this.f, this.g, ST_TextIndent.g(this.h), this.i, ST_TextIndentLevelType.g(this.j), ST_TextMargin.g(this.k), ST_TextMargin.g(this.l), this.m);
        if (this.p != null) {
            this.p.f(a, b, c, DrawingMLMain.fy);
        }
        if (this.r != null) {
            this.r.f(a, b, c, DrawingMLMain.it);
        }
        if (this.q != null) {
            this.q.f(a, b, c, DrawingMLMain.is);
        }
        if (this.aa != null) {
            for (let e of fromEnum(this.aa)) {
                DMLExtensions.bq(e, a, b, c, DrawingMLMain.jd);
            }
        }
        let f = typeCast(CT_TextCharacterProperties_DML.$, this.a);
        if (f != null) {
            f.aq(a, b, c, DrawingMLMain.c5);
        }
        if (this.n != null) {
            this.n.d(a, b, c, DrawingMLMain.dr);
        }
        if (this.v != null) {
            this.v.d(a, b, c, null);
        }
        if (this.x != null) {
            this.x.e(a, b, c, null);
        }
        if (this.z != null) {
            this.z.d(a, b, c, null);
        }
        if (this.t != null) {
            this.t.f(a, b, c, null);
        }
        c.k();
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextParagraphProperties_DML.$t = markType(CT_TextParagraphProperties_DML, 'CT_TextParagraphProperties_DML', CT_TextParagraphProperties.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextParagraph_DML extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.e = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new List$1(EG_TextRun.$, 0);
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 1154:
                this.c = typeCast(CT_TextParagraphProperties_DML.$, b);
                break;
            case 577:
                this.a = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            case 1297:
            case 164:
            case 651:
                let c = new EG_TextRun();
                c.setProperty(a, b);
                this.f.add(c);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextParagraph_DML.$t = markType(CT_TextParagraph_DML, 'CT_TextParagraph_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextBody_DML extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.a = null;
        this.b = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new List$1(CT_TextParagraph_DML.$, 0);
        }
        return this.c;
    }
    e(a, b, c, d) {
        c.p(d, null);
        if (this.a != null) {
            DMLExtensions.bd(this.a, a, b, c, DrawingMLMain.bz);
        }
        if (this.b != null) {
            DMLExtensions.bk(this.b, a, b, c, DrawingMLMain.f1);
        }
        if (this.d != null) {
            for (let e of fromEnum(this.d)) {
                DMLExtensions.bo(e, a, b, c, DrawingMLMain.hd);
            }
        }
        c.k();
    }
    setProperty(a, b) {
        switch (a) {
            case 136:
                this.a = typeCast(CT_TextBodyProperties_DML.$, b);
                break;
            case 938:
                this.b = typeCast(CT_TextListStyle_DML.$, b);
                break;
            case 1152:
                this.d.add(typeCast(CT_TextParagraph_DML.$, b));
                break;
        }
    }
}
CT_TextBody_DML.$t = markType(CT_TextBody_DML, 'CT_TextBody_DML', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class DMLUtils extends Base {
    static q(a) {
        let b = new ST_PositivePercentage(0);
        let c = SerializationUtils.k(a);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = ST_PositivePercentage.f(d.d, c);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_PositivePercentage();
            $ret.a = b;
            return $ret;
        })());
        return e;
    }
    static ar(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "val";
        let e = b.a.toString();
        a.ad.h(d, e);
        a.ad.k();
    }
    static av(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "idx";
        let e = b.b.toString();
        a.ad.h(d, e);
    }
    static p(a) {
        let b = new ST_PositiveFixedPercentage(0);
        let c = SerializationUtils.k(a);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = ST_PositiveFixedPercentage.f(d.d, c);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_PositiveFixedPercentage();
            $ret.a = b;
            return $ret;
        })());
        return e;
    }
    static aq(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "val";
        let e = b.a.u(a.d._z);
        a.ad.h(d, e);
        a.ad.k();
    }
    static f(a) {
        let b = new ST_FixedPercentage(0);
        let c = SerializationUtils.k(a);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = ST_FixedPercentage.c(d.d, c);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_FixedPercentage();
            $ret.a = b;
            return $ret;
        })());
        return e;
    }
    static af(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "val";
        let e = b.a.toString();
        a.ad.h(d, e);
        a.ad.k();
    }
    static l(a) {
        let b = new ST_Percentage(0);
        let c = SerializationUtils.k(a);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = ST_Percentage.d(d.d, c);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = b;
            return $ret;
        })());
        return e;
    }
    static am(a, b, c) {
        if (b == null) {
            return;
        }
        let d = SerializationUtils.k(a);
        a.ad.p(c, "a");
        let e = "val";
        let f = b.a.r(d);
        a.ad.h(e, f);
        a.ad.k();
    }
    static o(a) {
        let b = new ST_PositiveFixedAngle(0);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_PositiveFixedAngle.g(c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_PositiveFixedAngle();
            $ret.a = b;
            return $ret;
        })());
        return d;
    }
    static ap(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "val";
        let e = b.a.toString();
        a.ad.h(d, e);
        a.ad.k();
    }
    static b(a) {
        let b = new ST_Angle(0);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_Angle.b(c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_Angle();
            $ret.a = b;
            return $ret;
        })());
        return d;
    }
    static ab(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = "val";
        let e = b.a.toString();
        a.ad.h(d, e);
        a.ad.k();
    }
    static v(a, b) {
        let c = null;
        let d = null;
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = DrawingMLMain.k8(a, b, c, d, e, f);
        c = g.p2;
        d = g.p3;
        e = g.p4;
        f = g.p5;
        let h = ((() => {
            let $ret = new CT_TextFont();
            $ret.b = f;
            $ret.a = d;
            $ret.c = e;
            $ret.d = c;
            return $ret;
        })());
        return h;
    }
    static h(a, b) {
        let c = null;
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = null;
        let h = null;
        let i = null;
        let j = null;
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "action":
                    c = k.d;
                    break;
                case "endSnd":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "highlightClick":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "history":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "id":
                    g = k.d;
                    break;
                case "invalidUrl":
                    h = k.d;
                    break;
                case "tgtFrame":
                    i = k.d;
                    break;
                case "tooltip":
                    j = k.d;
                    break;
                default: break;
            }
        }
        let l = ((() => {
            let $ret = new CT_Hyperlink();
            $ret.f = c;
            $ret.b = d;
            $ret.c = e;
            $ret.d = f;
            $ret.g = g;
            $ret.h = h;
            $ret.i = i;
            $ret.j = j;
            return $ret;
        })());
        return l;
    }
    static u(a) {
        let b = new ST_Percentage(0);
        let c = new ST_Percentage(0);
        let d = new ST_Percentage(0);
        let e = new ST_Percentage(0);
        let f = SerializationUtils.k(a);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "b":
                    b = ST_Percentage.d(g.d, f);
                    break;
                case "l":
                    c = ST_Percentage.d(g.d, f);
                    break;
                case "r":
                    d = ST_Percentage.d(g.d, f);
                    break;
                case "t":
                    e = ST_Percentage.d(g.d, f);
                    break;
                default: break;
            }
        }
        let h = ((() => {
            let $ret = new CT_RelativeRect();
            $ret.a = b;
            $ret.b = c;
            $ret.c = d;
            $ret.d = e;
            return $ret;
        })());
        return h;
    }
    static w(a) {
        let b = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let c = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        let d = Nullable$1.toNullable(ST_Percentage.$, null);
        let e = Nullable$1.toNullable(ST_Percentage.$, null);
        let f = Nullable$1.toNullable(ST_Coordinate.$, null);
        let g = Nullable$1.toNullable(ST_Coordinate.$, null);
        let h = SerializationUtils.k(a);
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "algn":
                    b = Nullable$1.toNullable(ST_RectAlignment_$type, XmlNamespaceDefinitionBase.b(ST_RectAlignment_$type, i.d));
                    break;
                case "flip":
                    c = Nullable$1.toNullable(ST_TileFlipMode_$type, XmlNamespaceDefinitionBase.b(ST_TileFlipMode_$type, i.d));
                    break;
                case "sx":
                    d = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.d(i.d, h));
                    break;
                case "sy":
                    e = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.d(i.d, h));
                    break;
                case "tx":
                    f = Nullable$1.toNullable(ST_Coordinate.$, ST_Coordinate.h(i.d));
                    break;
                case "ty":
                    g = Nullable$1.toNullable(ST_Coordinate.$, ST_Coordinate.h(i.d));
                    break;
                default: break;
            }
        }
        let j = ((() => {
            let $ret = new CT_TileInfoProperties();
            $ret.a = b;
            $ret.b = c;
            $ret.c = d;
            $ret.d = e;
            $ret.e = f;
            $ret.f = g;
            return $ret;
        })());
        return j;
    }
    static e(a) {
        let b = Nullable$1.toNullable(Boolean_$type, null);
        let c = null;
        let d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "builtIn":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:embed":
                    c = e.d;
                    break;
                case "name":
                    d = e.d;
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_EmbeddedWAVAudioFile();
            $ret.b = b;
            $ret.c = c;
            $ret.d = d;
            return $ret;
        })());
        return f;
    }
    static i(a) {
        let b = Nullable$1.toNullable(ST_LineEndLength_$type, null);
        let c = Nullable$1.toNullable(ST_LineEndType_$type, null);
        let d = Nullable$1.toNullable(ST_LineEndWidth_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "len":
                    b = Nullable$1.toNullable(ST_LineEndLength_$type, XmlNamespaceDefinitionBase.b(ST_LineEndLength_$type, e.d));
                    break;
                case "type":
                    c = Nullable$1.toNullable(ST_LineEndType_$type, XmlNamespaceDefinitionBase.b(ST_LineEndType_$type, e.d));
                    break;
                case "w":
                    d = Nullable$1.toNullable(ST_LineEndWidth_$type, XmlNamespaceDefinitionBase.b(ST_LineEndWidth_$type, e.d));
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_LineEndProperties();
            $ret.a = b;
            $ret.b = c;
            $ret.c = d;
            return $ret;
        })());
        return f;
    }
    static j(a) {
        let b = Nullable$1.toNullable(ST_PositivePercentage.$, null);
        let c = SerializationUtils.k(a);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "lim":
                    b = Nullable$1.toNullable(ST_PositivePercentage.$, ST_PositivePercentage.f(d.d, c));
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_LineJoinMiterProperties();
            $ret.a = b;
            return $ret;
        })());
        return e;
    }
    static t(a) {
        let b = Nullable$1.toNullable(ST_PresetLineDashVal_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(ST_PresetLineDashVal_$type, XmlNamespaceDefinitionBase.b(ST_PresetLineDashVal_$type, c.d));
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_PresetLineDashProperties();
            $ret.a = b;
            return $ret;
        })());
        return d;
    }
    static d(a) {
        let b = new ST_PositivePercentage(0);
        let c = new ST_PositivePercentage(0);
        let d = SerializationUtils.k(a);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "d":
                    b = ST_PositivePercentage.f(e.d, d);
                    break;
                case "sp":
                    c = ST_PositivePercentage.f(e.d, d);
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_DashStop();
            $ret.a = b;
            $ret.b = c;
            return $ret;
        })());
        return f;
    }
    static s(a) {
        let b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "prst":
                    b = XmlNamespaceDefinitionBase.b(ST_ShapeType_$type, c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_PresetGeometry2D();
            $ret.b = b;
            return $ret;
        })());
        return d;
    }
    static x(a) {
        let b = Nullable$1.toNullable(Boolean_$type, null);
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(ST_Angle.$, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "flipH":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "flipV":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "rot":
                    d = Nullable$1.toNullable(ST_Angle.$, ST_Angle.b(e.d));
                    break;
                default: break;
            }
        }
        let f = ((() => {
            let $ret = new CT_Transform2D();
            $ret.i = b;
            $ret.k = c;
            $ret.j = d;
            return $ret;
        })());
        return f;
    }
    static g(a) {
        let b = new ST_AdjCoordinate(0);
        let c = new ST_AdjCoordinate(0);
        let d = new ST_AdjCoordinate(0);
        let e = new ST_AdjCoordinate(0);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "b":
                    b = ST_AdjCoordinate.a(f.d);
                    break;
                case "l":
                    c = ST_AdjCoordinate.a(f.d);
                    break;
                case "r":
                    d = ST_AdjCoordinate.a(f.d);
                    break;
                case "t":
                    e = ST_AdjCoordinate.a(f.d);
                    break;
                default: break;
            }
        }
        let g = ((() => {
            let $ret = new CT_GeomRect();
            $ret.a = b;
            $ret.b = c;
            $ret.c = d;
            $ret.d = e;
            return $ret;
        })());
        return g;
    }
    static c(a) {
        let b = new ST_AdjAngle(0);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ang":
                    b = ST_AdjAngle.a(c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_ConnectionSite();
            $ret.b = b;
            return $ret;
        })());
        return d;
    }
    static a(a) {
        let b = new ST_AdjCoordinate(0);
        let c = new ST_AdjCoordinate(0);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "x":
                    b = ST_AdjCoordinate.a(d.d);
                    break;
                case "y":
                    c = ST_AdjCoordinate.a(d.d);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_AdjPoint2D();
            $ret.a = b;
            $ret.b = c;
            return $ret;
        })());
        return e;
    }
    static m(a) {
        let b = 0;
        let c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "x":
                    b = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "y":
                    c = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_Point2D();
            $ret.a = ST_Coordinate.b(b);
            $ret.b = ST_Coordinate.b(c);
            return $ret;
        })());
        return e;
    }
    static r(a) {
        let b = 0;
        let c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "cx":
                    b = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "cy":
                    c = parseInt64_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        let e = ((() => {
            let $ret = new CT_PositiveSize2D();
            $ret.a = ST_PositiveCoordinate.a(b);
            $ret.b = ST_PositiveCoordinate.a(c);
            return $ret;
        })());
        return e;
    }
    static aa(a, b, c, d) {
        if (c == null) {
            return;
        }
        let e = [c.b.a, c.b.b, c.b.c, c.b.d, c.b.e, c.b.f];
        let f = a.ad;
        f.p(d, "a");
        for (let g = 0; g < e.length; g++) {
            let h = e[g];
            if (h == null) {
                continue;
            }
            h.d(a, b, f);
        }
        f.k();
    }
    static au(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = null;
        d = b.a.toString();
        a.ad.h("b", d);
        d = b.b.toString();
        a.ad.h("l", d);
        d = b.c.toString();
        a.ad.h("r", d);
        d = b.d.toString();
        a.ad.h("t", d);
        a.ad.k();
    }
    static ax(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.a.hasValue) {
            e = "algn";
            f = EnumUtil.getName(ST_RectAlignment_$type, b.a.value);
            d.h(e, f);
        }
        if (b.b.hasValue) {
            e = "flip";
            f = EnumUtil.getName(ST_TileFlipMode_$type, b.b.value);
            d.h(e, f);
        }
        if (b.c.hasValue) {
            e = "sx";
            f = b.c.value.toString();
            d.h(e, f);
        }
        if (b.d.hasValue) {
            e = "sy";
            f = b.d.value.toString();
            d.h(e, f);
        }
        if (b.e.hasValue) {
            e = "tx";
            f = b.e.value.toString();
            d.h(e, f);
        }
        if (b.f.hasValue) {
            e = "ty";
            f = b.f.value.toString();
            d.h(e, f);
        }
        d.k();
    }
    static aj(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.a.hasValue) {
            e = "len";
            f = EnumUtil.getName(ST_LineEndLength_$type, b.a.value);
            d.h(e, f);
        }
        if (b.b.hasValue) {
            e = "type";
            f = EnumUtil.getName(ST_LineEndType_$type, b.b.value);
            d.h(e, f);
        }
        if (b.c.hasValue) {
            e = "w";
            f = EnumUtil.getName(ST_LineEndWidth_$type, b.c.value);
            d.h(e, f);
        }
        d.k();
    }
    static ak(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.a.hasValue) {
            e = "len";
            f = b.a.value.toString();
            d.h(e, f);
        }
        d.k();
    }
    static at(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.a.hasValue) {
            e = "val";
            f = EnumUtil.getName(ST_PresetLineDashVal_$type, b.a.value);
            d.h(e, f);
        }
        d.k();
    }
    static ad(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        e = "d";
        f = b.a.toString();
        d.h(e, f);
        e = "sp";
        f = b.b.toString();
        d.h(e, f);
        d.k();
    }
    static aw(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.b.hasValue) {
            e = "charset";
            d = intToString(c.b.value, CultureInfo.currentCulture);
            a.ad.h(e, d);
        }
        if (c.a != null) {
            e = "panose";
            d = c.a.toString();
            a.ad.h(e, d);
        }
        if (nullableNotEquals(c.c, null)) {
            e = "pitchFamily";
            d = c.c.value.toString();
            a.ad.h(e, d);
        }
        if (c.d != null) {
            e = "typeface";
            d = c.d;
            a.ad.h(e, d);
        }
        a.ad.k();
    }
    static ai(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.f != null) {
            e = "action";
            d = c.f;
            a.ad.h(e, d);
        }
        if (c.b.hasValue) {
            e = "endSnd";
            d = ST_OnOff.g(c.b.value);
            a.ad.h(e, d);
        }
        if (c.c.hasValue) {
            e = "highlightClick";
            d = ST_OnOff.g(c.c.value);
            a.ad.h(e, d);
        }
        if (c.d.hasValue) {
            e = "history";
            d = ST_OnOff.g(c.d.value);
            a.ad.h(e, d);
        }
        if (c.g != null) {
            e = "id";
            d = c.g;
            a.ad.h(e, d);
        }
        if (c.h != null) {
            e = "invalidUrl";
            d = c.h;
            a.ad.h(e, d);
        }
        if (c.i != null) {
            e = "tgtFrame";
            d = c.i;
            a.ad.h(e, d);
        }
        if (c.j != null) {
            e = "tooltip";
            d = c.j;
            a.ad.h(e, d);
        }
    }
    static ae(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.b.hasValue) {
            e = "builtIn";
            d = ST_OnOff.g(c.b.value);
            a.ad.h(e, d);
        }
        if (c.c != null) {
            e = OfficeDocumentRelationships.ap;
            d = c.c;
            a.ad.h(e, d);
        }
        if (c.d != null) {
            e = "name";
            d = c.c;
            a.ad.h(e, d);
        }
        a.ad.k();
    }
    static ay(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        if (c.i.hasValue) {
            e = "flipH";
            d = ST_OnOff.g(c.i.value);
            a.ad.h(e, d);
        }
        if (c.k.hasValue) {
            e = "flipV";
            d = ST_OnOff.g(c.k.value);
            a.ad.h(e, d);
        }
        if (c.j.hasValue) {
            e = "rot";
            d = c.j.value.toString();
            a.ad.h(e, d);
        }
    }
    static ag(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "fmla";
        d = c.a;
        a.ad.h(e, d);
        e = "name";
        d = c.b;
        a.ad.h(e, d);
        a.ad.k();
    }
    static as(a, b, c) {
        a.ad.p(b, "a");
        let d = null;
        let e = null;
        e = "prst";
        d = EnumUtil.getName(ST_ShapeType_$type, c.b);
        a.ad.h(e, d);
    }
    static al(a, b, c) {
        let d = a.ad;
        d.p(b, "a");
        let e = null;
        let f = null;
        if (c.c.hasValue) {
            f = "extrusionOk";
            e = ST_OnOff.g(c.c.value);
            a.ad.h(f, e);
        }
        if (c.d.hasValue) {
            f = "fill";
            e = EnumUtil.getName(ST_PathFillMode_$type, c.d.value);
            a.ad.h(f, e);
        }
        if (c.e.hasValue) {
            f = "h";
            e = c.e.value.toString();
            a.ad.h(f, e);
        }
        if (c.f.hasValue) {
            f = "stroke";
            e = ST_OnOff.g(c.f.value);
            a.ad.h(f, e);
        }
        if (c.g.hasValue) {
            f = "w";
            e = c.g.value.toString();
            a.ad.h(f, e);
        }
    }
    static ah(a, b, c) {
        if (b == null) {
            return;
        }
        a.ad.p(c, "a");
        let d = null;
        d = b.a.toString();
        a.ad.h("b", d);
        d = b.b.toString();
        a.ad.h("l", d);
        d = b.c.toString();
        a.ad.h("r", d);
        d = b.d.toString();
        a.ad.h("t", d);
        a.ad.k();
    }
    static ao(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.b.hasValue) {
            e = "gdRefAng";
            f = b.b.value.a;
            d.h(e, f);
        }
        if (b.c.hasValue) {
            e = "gdRefR";
            f = b.c.value.a;
            d.h(e, f);
        }
        if (b.d.hasValue) {
            e = "maxAng";
            f = ST_AdjAngle.f(b.d.value);
            d.h(e, f);
        }
        if (b.e.hasValue) {
            e = "maxR";
            f = ST_AdjCoordinate.f(b.e.value);
            d.h(e, f);
        }
        if (b.f.hasValue) {
            e = "minAng";
            f = ST_AdjAngle.f(b.f.value);
            d.h(e, f);
        }
        if (b.g.hasValue) {
            e = "minR";
            f = ST_AdjCoordinate.f(b.g.value);
            d.h(e, f);
        }
    }
    static az(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = null;
        let f = null;
        if (b.b.hasValue) {
            e = "gdRefX";
            f = b.b.value.a;
            d.h(e, f);
        }
        if (b.c.hasValue) {
            e = "gdRefY";
            f = b.c.value.a;
            d.h(e, f);
        }
        if (b.d.hasValue) {
            e = "maxX";
            f = ST_AdjCoordinate.f(b.d.value);
            d.h(e, f);
        }
        if (b.e.hasValue) {
            e = "maxY";
            f = ST_AdjCoordinate.f(b.e.value);
            d.h(e, f);
        }
        if (b.f.hasValue) {
            e = "minX";
            f = ST_AdjCoordinate.f(b.f.value);
            d.h(e, f);
        }
        if (b.g.hasValue) {
            e = "minY";
            f = ST_AdjCoordinate.f(b.g.value);
            d.h(e, f);
        }
    }
    static ac(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = "ang";
        let f = ST_AdjAngle.f(b.b);
        d.h(e, f);
    }
    static an(a, b, c) {
        if (b == null) {
            return;
        }
        let d = a.ad;
        d.p(c, "a");
        let e = "x";
        let f = b.a.toString();
        d.h(e, f);
        e = "y";
        f = b.b.toString();
        d.h(e, f);
        d.k();
    }
    static y(a) {
        let b = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        let c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        let d = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        let e = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        let f = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        let g = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "gdRefX":
                    b = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, h.d));
                    break;
                case "gdRefY":
                    c = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, h.d));
                    break;
                case "maxX":
                    d = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                case "maxY":
                    e = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                case "minX":
                    f = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                case "minY":
                    g = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                default: break;
            }
        }
        let i = ((() => {
            let $ret = new CT_XYAdjustHandle();
            $ret.b = b;
            $ret.c = c;
            $ret.d = d;
            $ret.e = e;
            $ret.f = f;
            $ret.g = g;
            return $ret;
        })());
        return i;
    }
    static n(a) {
        let b = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        let c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        let d = Nullable$1.toNullable(ST_AdjAngle.$, null);
        let e = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        let f = Nullable$1.toNullable(ST_AdjAngle.$, null);
        let g = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "gdRefAng":
                    b = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, h.d));
                    break;
                case "gdRefR":
                    c = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, h.d));
                    break;
                case "maxAng":
                    d = Nullable$1.toNullable(ST_AdjAngle.$, ST_AdjAngle.a(h.d));
                    break;
                case "maxR":
                    e = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                case "minAng":
                    f = Nullable$1.toNullable(ST_AdjAngle.$, ST_AdjAngle.a(h.d));
                    break;
                case "minR":
                    g = Nullable$1.toNullable(ST_AdjCoordinate.$, ST_AdjCoordinate.a(h.d));
                    break;
                default: break;
            }
        }
        let i = ((() => {
            let $ret = new CT_PolarAdjustHandle();
            $ret.b = b;
            $ret.c = c;
            $ret.d = d;
            $ret.e = e;
            $ret.f = f;
            $ret.g = g;
            return $ret;
        })());
        return i;
    }
    static k(a) {
        let b = new ST_AdjCoordinate(0);
        let c = new ST_AdjAngle(0);
        let d = new ST_AdjAngle(0);
        let e = new ST_AdjCoordinate(0);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "hR":
                    b = ST_AdjCoordinate.a(f.d);
                    break;
                case "stAng":
                    c = ST_AdjAngle.a(f.d);
                    break;
                case "swAng":
                    d = ST_AdjAngle.a(f.d);
                    break;
                case "wR":
                    e = ST_AdjCoordinate.a(f.d);
                    break;
                default: break;
            }
        }
        let g = ((() => {
            let $ret = new CT_Path2DArcTo();
            $ret.c = b;
            $ret.a = c;
            $ret.b = d;
            $ret.d = e;
            return $ret;
        })());
        return g;
    }
}
DMLUtils.$t = markType(DMLUtils, 'DMLUtils');
/**
 * @hidden
 */
export class DMLExtensions extends Base {
    static cu(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            DMLExtensions.ct(a.a, b, c, d, DrawingMLMain.dy);
        }
        d.k();
    }
    static cw(a, b, c, d, e) {
        DMLUtils.ax(b, a, e);
    }
    static ct(a, b, c, d, e) {
        DMLUtils.au(b, a, e);
    }
    static n(a, b, c, d, e = DrawingMLMain.bs) {
        if (a == null) {
            return;
        }
        d.p(e, "a");
        CT_Blip_DML.x(b, e, a.a);
        if (a.d != null) {
            CT_AlphaBiLevelEffect.e(b, DrawingMLMain.a2, a.d.a);
        }
        if (a.e != null) {
            d.p(DrawingMLMain.a3, "a");
            d.k();
        }
        if (a.f != null) {
            d.p(DrawingMLMain.a4, "a");
            d.k();
        }
        let f = a.g;
        if (f != null) {
            f.d(b, c, d, DrawingMLMain.a5);
        }
        let g = a.h;
        if (g != null) {
            DMLExtensions.e(g, b, c, d, DrawingMLMain.a6);
        }
        let h = a.i;
        if (h != null) {
            DMLExtensions.f(h, b, c, d, DrawingMLMain.a7);
        }
        let i = a.j;
        if (i != null) {
            DMLExtensions.h(i, b, c, d, DrawingMLMain.ba);
        }
        let j = a.k;
        if (j != null) {
            DMLExtensions.l(j, b, c, d, DrawingMLMain.bp);
        }
        let k = a.m;
        if (k != null) {
            DMLExtensions.p(k, b, c, d, DrawingMLMain.bx);
        }
        let l = a.n;
        if (l != null) {
            DMLExtensions.s(l, b, c, d, DrawingMLMain.cj);
        }
        let m = a.o;
        if (m != null) {
            m.d(b, c, d, DrawingMLMain.cl);
        }
        let n = a.p;
        if (n != null) {
            n.d(b, c, d, DrawingMLMain.dd);
        }
        let o = a.u;
        if (o != null) {
            o.d(b, c, d, DrawingMLMain.dr);
        }
        let p = a.q;
        if (p != null) {
            p.g(b, c, d, DrawingMLMain.dx);
        }
        let q = a.r;
        if (q != null) {
            DMLExtensions.ak(q, b, c, d, DrawingMLMain.eo);
        }
        let r = a.s;
        if (r != null) {
            CT_HSLEffect.l(b, DrawingMLMain.e6, r.d, r.f, r.h);
            d.k();
        }
        let s = a.t;
        if (s != null) {
            CT_LuminanceEffect.i(b, DrawingMLMain.f4, s.c, s.e);
            d.k();
        }
        let t = a.v;
        if (s != null) {
            CT_TintEffect.i(b, DrawingMLMain.jm, t.c, t.e);
            d.k();
        }
        d.k();
    }
    static d(a, b, c, d, e = DrawingMLMain.a5) {
        if (a == null) {
            return;
        }
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, DrawingMLMain.e7);
        }
        d.k();
    }
    static e(a, b, c, d, e = DrawingMLMain.a6) {
        if (a == null) {
            return;
        }
        d.p(e, "a");
        if (a.a != null) {
            CT_EffectContainer.m(b, DrawingMLMain.cr, a.a.i, a.a.g);
            d.k();
        }
        d.k();
    }
    static f(a, b, c, d, e = DrawingMLMain.a7) {
        if (a == null) {
            return;
        }
        CT_AlphaModulateFixedEffect.f(b, e, a.b);
        d.k();
    }
    static h(a, b, c, d, e = DrawingMLMain.ba) {
        if (a == null) {
            return;
        }
        CT_AlphaReplaceEffect.e(b, e, a.a);
        d.k();
    }
    static l(a, b, c, d, e = DrawingMLMain.bp) {
        if (a == null) {
            return;
        }
        CT_BiLevelEffect.e(b, e, a.a);
        d.k();
    }
    static a(a, b, c, d, e = DrawingMLMain.bp) {
        if (a == null) {
            return;
        }
        CT_AlphaBiLevelEffect.e(b, e, a.a);
        d.k();
    }
    static b(a, b, c, d, e = DrawingMLMain.bp) {
        if (a == null) {
            return;
        }
        d.p(e, "a");
        d.k();
    }
    static p(a, b, c, d, e = DrawingMLMain.bx) {
        if (a == null) {
            return;
        }
        CT_BlurEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static s(a, b, c, d, e = DrawingMLMain.cj) {
        if (a == null) {
            return;
        }
        CT_ColorChangeEffect.j(b, e, a.f);
        let f = a.a;
        if (f != null) {
            DMLUtils.aa(b, c, f, DrawingMLMain.ck);
        }
        let g = a.c;
        if (g != null) {
            DMLUtils.aa(b, c, g, DrawingMLMain.cn);
        }
        d.k();
    }
    static a9(a, b, c, d, e) {
        CT_StyleMatrix.h(b, e, a.e);
        if (a.a != null) {
            DMLExtensions.j(a.a, b, c, d, DrawingMLMain.bo);
        }
        if (a.b != null) {
            DMLExtensions.aa(a.b, b, c, d, DrawingMLMain.dl);
        }
        if (a.c != null) {
            DMLExtensions.ae(a.c, b, c, d, DrawingMLMain.d0);
        }
        if (a.d != null) {
            DMLExtensions.aq(a.d, b, c, d, DrawingMLMain.fz);
        }
        d.k();
    }
    static j(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                f.saveX(b, d, e, c);
            }
        }
        d.k();
    }
    static aa(a, b, c, d, e) {
        d.p(e, "a");
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                DMLExtensions.z(f, b, c, d, DrawingMLMain.dk);
            }
        }
        d.k();
    }
    static ae(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                f.saveX(b, d, f.elementName, c);
            }
        }
        d.k();
    }
    static aq(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                f.r(b, c, d, DrawingMLMain.fw);
            }
        }
        d.k();
    }
    static o(a, b, c, d, e) {
        CT_BlipFillProperties_DML.i(b, e, a.b, a.c);
        if (a.d != null) {
            DMLExtensions.n(a.d, b, c, d, DrawingMLMain.bs);
        }
        if (a.a != null) {
            DMLExtensions.ct(a.a, b, c, d, DrawingMLMain.iz);
        }
        if (a.g != null) {
            a.g.d(b, c, d, null);
        }
        d.k();
    }
    static cb(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static ci(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static aw(a, b, c, d, e) {
        CT_PatternFillProperties.j(b, e, a.e);
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.bn);
        }
        if (a.c != null) {
            a.c.d(b, c, d, DrawingMLMain.dv);
        }
        d.k();
    }
    static a7(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static c(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static t(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static u(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static at(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.c(b, c, d, null);
        }
        d.k();
    }
    static ac(a, b, c, d, e) {
        CT_FillOverlayEffect.h(b, e, a.c);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ak(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static al(a, b, c, d, e) {
        CT_HSLEffect.l(b, e, a.d, a.f, a.h);
        d.k();
    }
    static ar(a, b, c, d, e) {
        CT_LuminanceEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static bu(a, b, c, d, e) {
        CT_TintEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static cp(a, b, c, d, e) {
        DMLUtils.aq(b, a, e);
    }
    static b6(a, b, c, d, e) {
        DMLUtils.af(b, a, e);
    }
    static cl(a, b, c, d, e) {
        DMLUtils.am(b, a, e);
    }
    static bz(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static ag(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static ca(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static co(a, b, c, d, e) {
        DMLUtils.ap(b, a, e);
    }
    static cq(a, b, c, d, e) {
        DMLUtils.ar(b, a, e);
    }
    static by(a, b, c, d, e) {
        DMLUtils.ab(b, a, e);
    }
    static cd(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static an(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static v(a, b, c, d, e) {
        CT_EffectContainer.m(b, e, a.i, a.g);
        if (a.c != null) {
            a.c.af(b, c, d, null);
        }
        d.k();
    }
    static g(a, b, c, d, e) {
        CT_AlphaOutsetEffect.f(b, e, a.b);
        d.k();
    }
    static m(a, b, c, d, e) {
        CT_BlendEffect.g(b, e, a.c);
        if (a.a != null) {
            DMLExtensions.v(a.a, b, c, d, DrawingMLMain.cr);
        }
        d.k();
    }
    static y(a, b, c, d, e) {
        CT_EffectReference.e(b, e, a.a);
        d.k();
    }
    static ab(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ah(a, b, c, d, e) {
        CT_GlowEffect.i(b, e, a.e);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static am(a, b, c, d, e) {
        CT_InnerShadowEffect.o(b, e, a.g, a.i, a.k);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static au(a, b, c, d, e) {
        CT_OuterShadowEffect.ah(b, e, a.n, a.p, a.r, a.t, a.v, a.x, a.z, a.ab, a.ad);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ay(a, b, c, d, e) {
        CT_PresetShadowEffect.n(b, e, a.h, a.j, a.d);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static a0(a, b, c, d, e) {
        CT_ReflectionEffect.as(b, e, a.o, a.q, a.s, a.u, a.w, a.y, a.aa, a.ac, a.ae, a.ag, a.ai, a.ak, a.am, a.ao);
        d.k();
    }
    static a2(a, b, c, d, e) {
        CT_RelativeOffsetEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static a6(a, b, c, d, e) {
        CT_SoftEdgesEffect.e(b, e, a.a);
        d.k();
    }
    static bv(a, b, c, d, e) {
        CT_TransformEffect.v(b, e, a.h, a.j, a.l, a.n, a.p, a.r);
        d.k();
    }
    static r(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static as(a, b, c, d, e) {
        CT_OfficeArtExtension.f(b, e, a.b);
        d.k();
    }
    static aj(a, b, c, d, e) {
        d.p(e, "a");
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                f.f(b, c, d, DrawingMLMain.et);
            }
        }
        d.k();
    }
    static ap(a, b, c, d, e) {
        CT_LinearShadeProperties.h(b, e, a.a, a.c);
        d.k();
    }
    static av(a, b, c, d, e) {
        CT_PathShadeProperties.h(b, e, a.c);
        if (a.a != null) {
            DMLExtensions.ct(a.a, b, c, d, DrawingMLMain.d1);
        }
        d.k();
    }
    static ai(a, b, c, d, e) {
        CT_GradientStop.g(b, e, a.d);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static z(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            DMLExtensions.a3(a.a, b, c, d, DrawingMLMain.id);
        }
        if (a.c != null) {
            DMLExtensions.a4(a.c, b, c, d, DrawingMLMain.ip);
        }
        if (a.f != null) {
            a.f.d(b, c, d, null);
        }
        d.k();
    }
    static w(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            DMLExtensions.p(a.a, b, c, d, DrawingMLMain.bx);
        }
        if (a.c != null) {
            a.c.g(b, c, d, DrawingMLMain.dx);
        }
        if (a.e != null) {
            a.e.h(b, c, d, DrawingMLMain.ei);
        }
        if (a.g != null) {
            a.g.n(b, c, d, DrawingMLMain.ff);
        }
        if (a.i != null) {
            a.i.ag(b, c, d, DrawingMLMain.hc);
        }
        if (a.k != null) {
            a.k.m(b, c, d, DrawingMLMain.hq);
        }
        if (a.m != null) {
            DMLExtensions.a0(a.m, b, c, d, DrawingMLMain.h0);
        }
        if (a.o != null) {
            DMLExtensions.a6(a.o, b, c, d, DrawingMLMain.im);
        }
        d.k();
    }
    static a3(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            DMLExtensions.i(a.a, b, c, d, DrawingMLMain.bi);
        }
        if (a.c != null) {
            DMLExtensions.q(a.c, b, c, d, DrawingMLMain.cd);
        }
        if (a.g != null) {
            a.g.d(b, c, d, DrawingMLMain.dr);
        }
        if (a.e != null) {
            DMLExtensions.ao(a.e, b, c, d, DrawingMLMain.ft);
        }
        d.k();
    }
    static a4(a, b, c, d, e) {
        CT_Shape3D.z(b, e, a.p, a.r, a.t, a.v);
        if (a.a != null) {
            DMLExtensions.k(a.a, b, c, d, DrawingMLMain.bl);
        }
        if (a.c != null) {
            DMLExtensions.k(a.c, b, c, d, DrawingMLMain.bm);
        }
        if (a.e != null) {
            a.e.d(b, c, d, DrawingMLMain.cs);
        }
        if (a.i != null) {
            a.i.d(b, c, d, DrawingMLMain.dr);
        }
        if (a.g != null) {
            a.g.d(b, c, d, DrawingMLMain.du);
        }
        d.k();
    }
    static i(a, b, c, d, e) {
        d.p(e, "a");
        if (a.c != null) {
            DMLExtensions.ax(a.c, b, c, d, DrawingMLMain.bc);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.dr);
        }
        if (a.e != null) {
            DMLExtensions.bw(a.e, b, c, d, DrawingMLMain.g3);
        }
        if (a.g != null) {
            DMLExtensions.bw(a.g, b, c, d, DrawingMLMain.jy);
        }
        d.k();
    }
    static q(a, b, c, d, e) {
        CT_Camera.m(b, e, a.g, a.i, a.d);
        if (a.b != null) {
            DMLExtensions.a8(a.b, b, c, d, DrawingMLMain.h3);
        }
        d.k();
    }
    static ao(a, b, c, d, e) {
        CT_LightRig.i(b, e, a.c, a.e);
        if (a.a != null) {
            DMLExtensions.a8(a.a, b, c, d, DrawingMLMain.h3);
        }
        d.k();
    }
    static ax(a, b, c, d, e) {
        CT_Point3D.i(b, e, a.a, a.c, a.e);
        d.k();
    }
    static bw(a, b, c, d, e) {
        CT_Vector3D.j(b, e, a.b, a.d, a.f);
        d.k();
    }
    static a8(a, b, c, d, e) {
        CT_SphereCoords.i(b, e, a.a, a.c, a.e);
        d.k();
    }
    static k(a, b, c, d, e) {
        CT_Bevel.m(b, e, a.e, a.g, a.i);
        d.k();
    }
    static cf(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static b4(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                DMLExtensions.b3(f, b, c, d, DrawingMLMain.dc);
            }
        }
        d.k();
    }
    static ce(a, b, c, d, e) {
        DMLUtils.aj(b, a, e);
    }
    static cg(a, b, c, d, e) {
        DMLUtils.ak(b, a, e);
    }
    static cs(a, b, c, d, e) {
        DMLUtils.at(b, a, e);
    }
    static ch(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static b3(a, b, c, d, e) {
        DMLUtils.ad(b, a, e);
    }
    static br(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bt(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bs(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static cv(a, b, c, d, e) {
        DMLUtils.aw(b, e, a);
    }
    static cc(a, b, c, d, e) {
        DMLUtils.ai(b, e, a);
        let f = typeCast(CT_OfficeArtExtensionList.$, a.e);
        if (f != null) {
            f.d(b, c, d, DrawingMLMain.dr);
        }
        if (a.a != null) {
            DMLExtensions.b5(a.a, b, c, d, DrawingMLMain.il);
        }
        d.k();
    }
    static b5(a, b, c, d, e) {
        DMLUtils.ae(b, e, a);
    }
    static ad(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ba(a, b, c, d, e) {
        CT_StyleMatrixReference_DML.g(b, e, a.d);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static x(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.d(b, c, d, null);
        }
        d.k();
    }
    static be(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bf(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bg(a, b, c, d, e) {
        CT_TextBulletSizePercent.e(b, e, a.a);
        d.k();
    }
    static bh(a, b, c, d, e) {
        CT_TextBulletSizePoint.e(b, e, a.a);
        d.k();
    }
    static bi(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bm(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bb(a, b, c, d, e) {
        CT_TextAutonumberBullet.h(b, e, a.d, a.a);
        d.k();
    }
    static bj(a, b, c, d, e) {
        CT_TextCharBullet.e(b, e, a.a);
        d.k();
    }
    static bc(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLExtensions.n(a.a, b, c, d, DrawingMLMain.bs);
        }
        d.k();
    }
    static bk(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            a.c.ac(b, c, d, DrawingMLMain.c4);
        }
        if (a.e != null) {
            a.e.ac(b, c, d, DrawingMLMain.f8);
        }
        if (a.g != null) {
            a.g.ac(b, c, d, DrawingMLMain.f9);
        }
        if (a.i != null) {
            a.i.ac(b, c, d, DrawingMLMain.ga);
        }
        if (a.k != null) {
            a.k.ac(b, c, d, DrawingMLMain.gb);
        }
        if (a.m != null) {
            a.m.ac(b, c, d, DrawingMLMain.gc);
        }
        if (a.o != null) {
            a.o.ac(b, c, d, DrawingMLMain.gd);
        }
        if (a.q != null) {
            a.q.ac(b, c, d, DrawingMLMain.ge);
        }
        if (a.s != null) {
            a.s.ac(b, c, d, DrawingMLMain.gf);
        }
        if (a.u != null) {
            a.u.ac(b, c, d, DrawingMLMain.gg);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static bd(a, b, c, d, e) {
        CT_TextBodyProperties_DML.az(b, e, a.l, a.m, a.p, a.r, a.t, a.v, a.x, a.z, a.ab, a.ad, a.af, a.ah, a.aj, a.al, a.an, a.ap, a.ar, a.at, a.av);
        if (a.c != null) {
            DMLExtensions.az(a.c, b, c, d, DrawingMLMain.hr);
        }
        if (a.e != null) {
            DMLExtensions.a3(a.e, b, c, d, DrawingMLMain.id);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.dr);
        }
        if (a.j != null) {
            a.j.e(b, c, d, null);
        }
        if (a.h != null) {
            a.h.d(b, c, d, null);
        }
        d.k();
    }
    static bq(a, b, c, d, e) {
        CT_TextTabStop.g(b, e, a.a, a.c);
        d.k();
    }
    static bo(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            a.c.ac(b, c, d, DrawingMLMain.hl);
        }
        if (a.a != null) {
            a.a.aq(b, c, d, DrawingMLMain.dm);
        }
        if (a.f != null) {
            for (let f of fromEnum(a.f)) {
                f.e(b, c, d, null);
            }
        }
        d.k();
    }
    static cx(a, b, c, d, e) {
        DMLUtils.ay(b, e, a);
    }
    static a5(a, b, c, d, e) {
        CT_ShapeProperties_DML.u(b, e, a.q);
        if (a.o != null) {
            DMLExtensions.cx(a.o, b, c, d, DrawingMLMain.j8);
        }
        if (a.n != null) {
            a.n.d(b, c, d, null);
        }
        if (a.l != null) {
            a.l.h(b, c, d, null);
        }
        if (a.a != null) {
            a.a.r(b, c, d, DrawingMLMain.fw);
        }
        if (a.j != null) {
            a.j.d(b, c, d, null);
        }
        if (a.e != null) {
            DMLExtensions.a3(a.e, b, c, d, DrawingMLMain.id);
        }
        if (a.g != null) {
            DMLExtensions.a4(a.g, b, c, d, DrawingMLMain.ip);
        }
        if (a.c != null) {
            a.c.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static af(a, b, c, d, e) {
        CT_FlatText.f(b, e, a.b);
        d.k();
    }
    static bl(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static bn(a, b, c, d, e) {
        CT_TextNormalAutofit.i(b, e, a.c, a.e);
        d.k();
    }
    static az(a, b, c, d, e) {
        CT_PresetTextShape.g(b, e, a.a);
        if (a.c != null) {
            d.p(DrawingMLMain.bg, "a");
            for (let f of fromEnum(a.c)) {
                DMLExtensions.b7(f, b, c, d, DrawingMLMain.eg);
            }
            d.k();
        }
        d.k();
    }
    static bp(a, b, c, d, e) {
        d.p(e, "a");
        d.k();
    }
    static b8(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                DMLExtensions.b7(f, b, c, d, DrawingMLMain.eg);
            }
        }
        d.k();
    }
    static b7(a, b, c, d, e) {
        DMLUtils.ag(b, e, a);
    }
    static b2(a, b, c, d, e) {
        d.p(e, "a");
        if (a.a != null) {
            DMLExtensions.bx(a.a, b, c, d, DrawingMLMain.ax);
        }
        if (a.c != null) {
            DMLExtensions.b8(a.c, b, c, d, DrawingMLMain.bg);
        }
        if (a.b != null) {
            DMLExtensions.b1(a.b, b, c, d, DrawingMLMain.c2);
        }
        if (a.d != null) {
            DMLExtensions.b8(a.d, b, c, d, DrawingMLMain.eh);
        }
        if (a.f != null) {
            DMLExtensions.ck(a.f, b, c, d, DrawingMLMain.hg);
        }
        if (a.e != null) {
            DMLExtensions.b9(a.e, b, c, d, DrawingMLMain.hw);
        }
        d.k();
    }
    static cr(a, b, c, d, e) {
        DMLUtils.as(b, e, a);
        if (a.a != null) {
            DMLExtensions.b8(a.a, b, c, d, DrawingMLMain.bg);
        }
        d.k();
    }
    static bx(a, b, c, d, e) {
        d.p(e, "a");
        for (let f of fromEnum(a.b)) {
            let g = typeCast(CT_PolarAdjustHandle.$, f);
            let h = g == null ? typeCast(CT_XYAdjustHandle.$, f) : null;
            if (g != null) {
                DMLExtensions.cn(g, b, c, d, DrawingMLMain.ay);
            }
            if (h != null) {
                DMLExtensions.cy(h, b, c, d, DrawingMLMain.az);
            }
        }
        d.k();
    }
    static b1(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                DMLExtensions.b0(f, b, c, d, DrawingMLMain.c1);
            }
        }
        d.k();
    }
    static ck(a, b, c, d, e) {
        d.p(e, "a");
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                DMLExtensions.cj(f, b, c, d, DrawingMLMain.hf);
            }
        }
        d.k();
    }
    static cj(a, b, c, d, e) {
        DMLUtils.al(b, e, a);
        if (a.b != null) {
            for (let f of fromEnum(a.b)) {
                let g = typeCast(ISaveToXLSX_$type, f);
                if (g == null) {
                    continue;
                }
                g.saveX(b, d, g.elementName, c);
            }
        }
        d.k();
    }
    static b9(a, b, c, d, e) {
        DMLUtils.ah(b, a, e);
    }
    static cn(a, b, c, d, e) {
        DMLUtils.ao(b, a, e);
        if (a.a != null) {
            a.a.c(b, DrawingMLMain.hk);
        }
        d.k();
    }
    static cy(a, b, c, d, e) {
        DMLUtils.az(b, a, e);
        if (a.a != null) {
            a.a.c(b, DrawingMLMain.hk);
        }
        d.k();
    }
    static b0(a, b, c, d, e) {
        DMLUtils.ac(b, a, e);
        if (a.a != null) {
            a.a.c(b, DrawingMLMain.hk);
        }
        d.k();
    }
    static cm(a, b, c, d, e) {
        DMLUtils.an(b, a, e);
    }
    static a1(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            a.a.aq(b, c, d, DrawingMLMain.h7);
        }
        if (a.c != null) {
            DMLExtensions.cz(a.c, b, c, d, DrawingMLMain.ja, "a");
        }
        d.k();
    }
    static cz(a, b, c, d, e, f) {
        d.p(e, f);
        if (stringIsNullOrEmpty(a) == false) {
            d.u(a);
        }
        d.k();
    }
}
DMLExtensions.$t = markType(DMLExtensions, 'DMLExtensions');
/**
 * @hidden
 */
export class CT_Drawing_SpreadsheetDrawing extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_Anchor_SpreadsheetDrawing();
        }
        return this.a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Drawing_SpreadsheetDrawing.$t = markType(CT_Drawing_SpreadsheetDrawing, 'CT_Drawing_SpreadsheetDrawing');
/**
 * @hidden
 */
export class SpreadsheetDrawingAttributes extends Base {
}
SpreadsheetDrawingAttributes.$t = markType(SpreadsheetDrawingAttributes, 'SpreadsheetDrawingAttributes');
/**
 * @hidden
 */
export class EG_Anchor_SpreadsheetDrawing extends Base {
    constructor() {
        super();
        this.c = null;
        this.b = null;
        this.a = null;
    }
    d(a, b, c, d) {
        throw new NotImplementedException(0);
    }
}
EG_Anchor_SpreadsheetDrawing.$t = markType(EG_Anchor_SpreadsheetDrawing, 'EG_Anchor_SpreadsheetDrawing');
/**
 * @hidden
 */
export class DMLSpreadsheetDrawingUtils extends Base {
}
DMLSpreadsheetDrawingUtils.$t = markType(DMLSpreadsheetDrawingUtils, 'DMLSpreadsheetDrawingUtils');
/**
 * @hidden
 */
export class CT_FullRef extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1583:
                this.a = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FullRef.$t = markType(CT_FullRef, 'CT_FullRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LevelRef extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1583:
                this.a = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LevelRef.$t = markType(CT_LevelRef, 'CT_LevelRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FormulaRef extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1583:
                this.a = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FormulaRef.$t = markType(CT_FormulaRef, 'CT_FormulaRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredCategoryTitle extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 229:
                this.a = typeCast(CT_AxDataSource.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredCategoryTitle.$t = markType(CT_FilteredCategoryTitle, 'CT_FilteredCategoryTitle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredAreaSer extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.b = typeCast(CT_AreaSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredAreaSer.$t = markType(CT_FilteredAreaSer, 'CT_FilteredAreaSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredBarSer extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.b = typeCast(CT_BarSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredBarSer.$t = markType(CT_FilteredBarSer, 'CT_FilteredBarSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredBubbleSer extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.b = typeCast(CT_BubbleSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredBubbleSer.$t = markType(CT_FilteredBubbleSer, 'CT_FilteredBubbleSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredLineSer extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.a = typeCast(CT_LineSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredLineSer.$t = markType(CT_FilteredLineSer, 'CT_FilteredLineSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredPieSer extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.a = typeCast(CT_PieSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredPieSer.$t = markType(CT_FilteredPieSer, 'CT_FilteredPieSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredRadarSer extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.a = typeCast(CT_RadarSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredRadarSer.$t = markType(CT_FilteredRadarSer, 'CT_FilteredRadarSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredScatterSer extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.a = typeCast(CT_ScatterSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredScatterSer.$t = markType(CT_FilteredScatterSer, 'CT_FilteredScatterSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredSurfaceSer extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.a = typeCast(CT_SurfaceSer.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredSurfaceSer.$t = markType(CT_FilteredSurfaceSer, 'CT_FilteredSurfaceSer', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SeriesDataLabelsRange extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.c = typeCast(String_$type, b);
                break;
            case 405:
                this.a = typeCast(CT_StrData.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SeriesDataLabelsRange.$t = markType(CT_SeriesDataLabelsRange, 'CT_SeriesDataLabelsRange', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CategoryFilterExceptions extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 193:
                this.a.add(typeCast(CT_CategoryFilterException.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CategoryFilterExceptions.$t = markType(CT_CategoryFilterExceptions, 'CT_CategoryFilterExceptions', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CategoryFilterException extends Base {
    constructor() {
        super();
        this.n = null;
        this.l = null;
        this.f = null;
        this.d = null;
        this.b = null;
        this.j = null;
        this.h = null;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1583:
                this.m = typeCast(String_$type, b);
                break;
            case 1570:
                this.k = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 598:
                this.e = typeCast(CT_UnsignedInt.$, b);
                break;
            case 848:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 183:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 979:
                this.i = typeCast(CT_Marker_Chart.$, b);
                break;
            case 401:
                this.g = typeCast(CT_DLbl.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CategoryFilterException.$t = markType(CT_CategoryFilterException, 'CT_CategoryFilterException', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataLabelFieldTable extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 403:
                this.a.add(typeCast(CT_DataLabelFieldTableEntry.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabelFieldTable.$t = markType(CT_DataLabelFieldTable, 'CT_DataLabelFieldTable', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataLabelFieldTableEntry extends Base {
    constructor() {
        super();
        this.g = null;
        this.d = null;
        this.b = null;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1787:
                this.f = typeCast(String_$type, b);
                break;
            case 612:
                this.c = typeCast(String_$type, b);
                break;
            case 402:
                this.a = typeCast(CT_StrData.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabelFieldTableEntry.$t = markType(CT_DataLabelFieldTableEntry, 'CT_DataLabelFieldTableEntry', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FilteredSeriesTitle extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1776:
                this.b = typeCast(CT_Tx.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FilteredSeriesTitle.$t = markType(CT_FilteredSeriesTitle, 'CT_FilteredSeriesTitle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class ChartAttributes extends Base {
}
ChartAttributes.$t = markType(ChartAttributes, 'ChartAttributes');
/**
 * @hidden
 */
export class EG_BarChartShared extends Base {
    constructor() {
        super();
        this.b = null;
        this.c = null;
        this.a = null;
        this.f = null;
        this.d = null;
        this.f = new List$1(CT_BarSer.$, 0);
    }
    g(a, b, c, d) {
        if (this.b != null) {
            CT_BarDir.f(a, DrawingMLChart.a5, this.b.b);
            c.k();
        }
        if (this.c != null) {
            CT_BarGrouping.f(a, DrawingMLChart.cr, this.c.b);
            c.k();
        }
        if (this.a != null) {
            CT_Boolean.r(a, DrawingMLChart.gm, "c", CT_Boolean.b(this.a.k));
            c.k();
        }
        for (let e of fromEnum(this.f)) {
            DMLChartExtensions.bi(e, a, b, c, DrawingMLChart.e9);
        }
        if (this.d != null) {
            DMLChartExtensions.br(this.d, a, b, c, DrawingMLChart.b0);
        }
    }
    h(a, b) {
        switch (a) {
            case 101:
                this.b = typeCast(CT_BarDir.$, b);
                break;
            case 749:
                this.c = typeCast(CT_BarGrouping.$, b);
                break;
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.f.add(typeCast(CT_BarSer.$, b));
                break;
            case 406:
                this.d = typeCast(CT_DLbls.$, b);
                break;
            default: break;
        }
    }
    e(a) {
        switch (a) {
            case 101:
            case 749:
            case 1833:
            case 1446:
            case 406: return true;
        }
        return false;
    }
}
EG_BarChartShared.$t = markType(EG_BarChartShared, 'EG_BarChartShared');
/**
 * @hidden
 */
export class EG_PieChartShared extends Base {
    constructor() {
        super();
        this.a = null;
        this.d = null;
        this.b = null;
        this.d = new List$1(CT_PieSer.$, 0);
    }
    e(a, b, c, d) {
        if (this.a != null) {
            CT_Boolean.r(a, DrawingMLChart.gm, "c", CT_Boolean.b(this.a.k));
            c.k();
        }
        for (let e of fromEnum(this.d)) {
            DMLChartExtensions.cn(e, a, b, c, DrawingMLChart.e9);
        }
        if (this.b != null) {
            DMLChartExtensions.br(this.b, a, b, c, DrawingMLChart.b0);
        }
    }
    f(a, b) {
        switch (a) {
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.d.add(typeCast(CT_PieSer.$, b));
                break;
            case 406:
                this.b = typeCast(CT_DLbls.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1833:
            case 1446:
            case 406: return true;
        }
        return false;
    }
}
EG_PieChartShared.$t = markType(EG_PieChartShared, 'EG_PieChartShared');
/**
 * @hidden
 */
export class EG_DLblShared extends Base {
    constructor() {
        super();
        this.h = null;
        this.i = null;
        this.j = null;
        this.g = null;
        this.c = null;
        this.f = null;
        this.b = null;
        this.e = null;
        this.d = null;
        this.a = null;
        this.l = null;
    }
    n(a, b) {
        switch (a) {
            case 1088:
                this.h = typeCast(CT_NumFmt_Chart.$, b);
                break;
            case 1570:
                this.i = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.j = typeCast(CT_TextBody_DML.$, b);
                break;
            case 404:
                this.g = typeCast(CT_DLblPos.$, b);
                break;
            case 1492:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 1498:
                this.f = typeCast(CT_Boolean.$, b);
                break;
            case 1485:
                this.b = typeCast(CT_Boolean.$, b);
                break;
            case 1497:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 1495:
                this.d = typeCast(CT_Boolean.$, b);
                break;
            case 1484:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1445:
                this.l = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    k(a) {
        switch (a) {
            case 1088:
            case 1570:
            case 1783:
            case 404:
            case 1492:
            case 1498:
            case 1485:
            case 1497:
            case 1495:
            case 1484:
            case 1445: return true;
        }
        return false;
    }
    m(a, b, c, d) {
        if (this.h != null) {
            DMLChartExtensions.ce(this.h, a, b, c, DrawingMLChart.d1);
        }
        if (this.i != null) {
            DMLExtensions.a5(this.i, a, b, c, DrawingMLChart.fw);
        }
        if (this.j != null) {
            this.j.e(a, b, c, DrawingMLChart.ge);
        }
        if (this.g != null) {
            DMLChartExtensions.bq(this.g, a, b, c, DrawingMLChart.bz);
        }
        if (this.c != null) {
            this.c.q(a, b, c, DrawingMLChart.fj, "c");
        }
        if (this.f != null) {
            this.f.q(a, b, c, DrawingMLChart.fo, "c");
        }
        if (this.b != null) {
            this.b.q(a, b, c, DrawingMLChart.fe, "c");
        }
        if (this.e != null) {
            this.e.q(a, b, c, DrawingMLChart.fn, "c");
        }
        if (this.d != null) {
            this.d.q(a, b, c, DrawingMLChart.fm, "c");
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.fd, "c");
        }
        if (this.l != null) {
            DMLExtensions.cz(this.l, a, b, c, DrawingMLChart.e8, "c");
        }
    }
}
EG_DLblShared.$t = markType(EG_DLblShared, 'EG_DLblShared');
/**
 * @hidden
 */
export class Group_DLbl extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
        this.b = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_DLblShared();
        }
        return this.c;
    }
    g(a, b) {
        switch (a) {
            case 876:
                this.a = typeCast(CT_Layout.$, b);
                break;
            case 1776:
                this.b = typeCast(CT_Tx.$, b);
                break;
            default:
                this.d.n(a, b);
                break;
        }
    }
    e(a) {
        switch (a) {
            case 876:
            case 1776: return true;
            default: return this.d.k(a);
        }
    }
    f(a, b, c, d) {
        if (this.a != null) {
            DMLChartExtensions.by(this.a, a, b, c, DrawingMLChart.c2);
        }
        if (this.b != null) {
            DMLChartExtensions.c6(this.b, a, b, c, DrawingMLChart.gd);
        }
        this.d.m(a, b, c, null);
    }
}
Group_DLbl.$t = markType(Group_DLbl, 'Group_DLbl');
/**
 * @hidden
 */
export class Group_DLbls extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
        this.b = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_DLblShared();
        }
        return this.c;
    }
    f(a, b, c, d) {
        this.d.m(a, b, c, null);
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.fi, "c");
        }
        if (this.b != null) {
            DMLChartExtensions.bk(this.b, a, b, c, DrawingMLChart.fi);
        }
    }
    g(a, b) {
        switch (a) {
            case 1491:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 886:
                this.b = typeCast(CT_ChartLines.$, b);
                break;
            default:
                this.d.n(a, b);
                break;
        }
    }
    e(a) {
        switch (a) {
            case 1491:
            case 886: return true;
            default: return this.d.k(a);
        }
    }
}
Group_DLbls.$t = markType(Group_DLbls, 'Group_DLbls');
/**
 * @hidden
 */
export class EG_LegendEntryData extends Base {
    constructor() {
        super();
        this.a = null;
    }
    c(a, b, c, d) {
        if (this.a != null) {
            this.a.e(a, b, c, DrawingMLChart.ge);
        }
    }
    d(a, b) {
        switch (a) {
            case 1783:
                this.a = typeCast(CT_TextBody_DML.$, b);
                break;
            default: break;
        }
    }
    b(a) {
        switch (a) {
            case 1783: return true;
        }
        return false;
    }
}
EG_LegendEntryData.$t = markType(EG_LegendEntryData, 'EG_LegendEntryData');
/**
 * @hidden
 */
export class EG_AxShared extends Base {
    constructor() {
        super();
        this.c = null;
        this.j = null;
        this.a = null;
        this.e = null;
        this.f = null;
        this.g = null;
        this.n = null;
        this.i = null;
        this.l = null;
        this.m = null;
        this.k = null;
        this.o = null;
        this.p = null;
        this.d = null;
        this.h = null;
        this.b = null;
    }
    r(a, b, c, d) {
        if (this.c != null) {
            this.c.i(a, b, c, DrawingMLChart.ax, "c");
        }
        if (this.j != null) {
            DMLChartExtensions.co(this.j, a, b, c, DrawingMLChart.e2);
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.br, "c");
        }
        if (this.e != null) {
            DMLChartExtensions.bf(this.e, a, b, c, DrawingMLChart.ay);
        }
        if (this.f != null) {
            DMLChartExtensions.bk(this.f, a, b, c, DrawingMLChart.df);
        }
        if (this.g != null) {
            DMLChartExtensions.bk(this.g, a, b, c, DrawingMLChart.dn);
        }
        if (this.n != null) {
            DMLChartExtensions.c2(this.n, a, b, c, DrawingMLChart.f9);
        }
        if (this.i != null) {
            DMLChartExtensions.ce(this.i, a, b, c, DrawingMLChart.d1);
        }
        if (this.l != null) {
            DMLChartExtensions.c0(this.l, a, b, c, DrawingMLChart.dg);
        }
        if (this.m != null) {
            DMLChartExtensions.c0(this.m, a, b, c, DrawingMLChart.dp);
        }
        if (this.k != null) {
            DMLChartExtensions.cz(this.k, a, b, c, DrawingMLChart.f6);
        }
        if (this.o != null) {
            DMLExtensions.a5(this.o, a, b, c, DrawingMLChart.fw);
        }
        if (this.p != null) {
            this.p.e(a, b, c, DrawingMLChart.ge);
        }
        if (this.d != null) {
            this.d.i(a, b, c, DrawingMLChart.bi, "c");
        }
        if (this.h != null) {
            DMLChartExtensions.bm(this.h, a, b, c, DrawingMLChart.bk);
        }
        if (this.b != null) {
            this.b.i(a, b, c, DrawingMLChart.bl, "c");
        }
    }
    s(a, b) {
        switch (a) {
            case 81:
                this.c = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1418:
                this.j = typeCast(CT_Scaling.$, b);
                break;
            case 467:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 82:
                this.e = typeCast(CT_AxPos.$, b);
                break;
            case 963:
                this.f = typeCast(CT_ChartLines.$, b);
                break;
            case 1011:
                this.g = typeCast(CT_ChartLines.$, b);
                break;
            case 1745:
                this.n = typeCast(CT_Title.$, b);
                break;
            case 1088:
                this.i = typeCast(CT_NumFmt_Chart.$, b);
                break;
            case 964:
                this.l = typeCast(CT_TickMark.$, b);
                break;
            case 1012:
                this.m = typeCast(CT_TickMark.$, b);
                break;
            case 1724:
                this.k = typeCast(CT_TickLblPos.$, b);
                break;
            case 1570:
                this.o = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.p = typeCast(CT_TextBody_DML.$, b);
                break;
            case 359:
                this.d = typeCast(CT_UnsignedInt.$, b);
                break;
            case 361:
                this.h = typeCast(CT_Crosses.$, b);
                break;
            case 362:
                this.b = typeCast(CT_Double.$, b);
                break;
            default: break;
        }
    }
    q(a) {
        switch (a) {
            case 81:
            case 1418:
            case 467:
            case 82:
            case 963:
            case 1011:
            case 1745:
            case 1088:
            case 964:
            case 1012:
            case 1724:
            case 1570:
            case 1783:
            case 359:
            case 361:
            case 362: return true;
        }
        return false;
    }
}
EG_AxShared.$t = markType(EG_AxShared, 'EG_AxShared');
/**
 * @hidden
 */
export class EG_SerShared extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = null;
    }
    f(a, b, c, d) {
        if (this.a != null) {
            this.a.i(a, b, c, DrawingMLChart.cy, "c");
        }
        if (this.b != null) {
            this.b.i(a, b, c, DrawingMLChart.d8, "c");
        }
        if (this.c != null) {
            DMLChartExtensions.cs(this.c, a, b, c, DrawingMLChart.gd);
        }
        if (this.d != null) {
            DMLExtensions.a5(this.d, a, b, c, DrawingMLChart.fw);
        }
    }
    g(a, b) {
        switch (a) {
            case 817:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1135:
                this.b = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1776:
                this.c = typeCast(CT_SerTx.$, b);
                break;
            case 1570:
                this.d = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            default: break;
        }
    }
    e(a) {
        switch (a) {
            case 817:
            case 1135:
            case 1776:
            case 1570: return true;
        }
        return false;
    }
}
EG_SerShared.$t = markType(EG_SerShared, 'EG_SerShared');
/**
 * @hidden
 */
export class EG_AreaChartShared extends Base {
    constructor() {
        super();
        this.d = null;
        this.a = null;
        this.f = null;
        this.c = null;
        this.b = null;
        this.f = new List$1(CT_AreaSer.$, 0);
    }
    g(a, b, c, d) {
        if (this.d != null) {
            DMLChartExtensions.bx(this.d, a, b, c, DrawingMLChart.cr);
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.gm, "c");
        }
        for (let e of fromEnum(this.f)) {
            DMLChartExtensions.bc(e, a, b, c, DrawingMLChart.e9);
        }
        if (this.c != null) {
            DMLChartExtensions.br(this.c, a, b, c, DrawingMLChart.b0);
        }
        if (this.b != null) {
            DMLChartExtensions.bk(this.b, a, b, c, DrawingMLChart.b4);
        }
    }
    h(a, b) {
        switch (a) {
            case 749:
                this.d = typeCast(CT_Grouping.$, b);
                break;
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.f.add(typeCast(CT_AreaSer.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 543:
                this.b = typeCast(CT_ChartLines.$, b);
                break;
            default: break;
        }
    }
    e(a) {
        switch (a) {
            case 749:
            case 1833:
            case 1446:
            case 406:
            case 543: return true;
        }
        return false;
    }
}
EG_AreaChartShared.$t = markType(EG_AreaChartShared, 'EG_AreaChartShared');
/**
 * @hidden
 */
export class EG_SurfaceChartShared extends Base {
    constructor() {
        super();
        this.a = null;
        this.d = null;
        this.b = null;
        this.d = new List$1(CT_SurfaceSer.$, 0);
    }
    e(a, b, c, d) {
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.gp, "c");
        }
        if (this.d != null && this.d.count > 0) {
            for (let e of fromEnum(this.d)) {
                DMLChartExtensions.cy(e, a, b, c, DrawingMLChart.e9);
            }
        }
        if (this.b != null) {
            DMLChartExtensions.bh(this.b, a, b, c, DrawingMLChart.a2);
        }
    }
    f(a, b) {
        switch (a) {
            case 1869:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.d.add(typeCast(CT_SurfaceSer.$, b));
                break;
            case 97:
                this.b = typeCast(CT_BandFmts.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1869:
            case 1446:
            case 97: return true;
        }
        return false;
    }
}
EG_SurfaceChartShared.$t = markType(EG_SurfaceChartShared, 'EG_SurfaceChartShared');
/**
 * @hidden
 */
export class EG_LineChartShared extends Base {
    constructor() {
        super();
        this.d = null;
        this.a = null;
        this.f = null;
        this.c = null;
        this.b = null;
        this.f = new List$1(CT_LineSer.$, 0);
    }
    g(a, b, c, d) {
        if (this.d != null) {
            DMLChartExtensions.bx(this.d, a, b, c, DrawingMLChart.cr);
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.gm, "c");
        }
        for (let e of fromEnum(this.f)) {
            DMLChartExtensions.b3(e, a, b, c, DrawingMLChart.e9);
        }
        if (this.c != null) {
            DMLChartExtensions.br(this.c, a, b, c, DrawingMLChart.b0);
        }
        if (this.b != null) {
            DMLChartExtensions.bk(this.b, a, b, c, DrawingMLChart.b4);
        }
    }
    h(a, b) {
        switch (a) {
            case 749:
                this.d = typeCast(CT_Grouping.$, b);
                break;
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.f.add(typeCast(CT_LineSer.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 543:
                this.b = typeCast(CT_ChartLines.$, b);
                break;
            default: break;
        }
    }
    e(a) {
        switch (a) {
            case 749:
            case 1833:
            case 1446:
            case 406:
            case 543: return true;
        }
        return false;
    }
}
EG_LineChartShared.$t = markType(EG_LineChartShared, 'EG_LineChartShared');
/**
 * @hidden
 */
export class CT_ChartSpace extends Base {
    constructor() {
        super();
        this.c = null;
        this.s = null;
        this.e = null;
        this.q = null;
        this.u = null;
        this.k = null;
        this.o = null;
        this.g = null;
        this.w = null;
        this.y = null;
        this.i = null;
        this.m = null;
        this.aa = null;
        this.ac = null;
        this.a = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get z() {
        return this.aa;
    }
    set z(a) {
        this.aa = a;
    }
    get ab() {
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 439:
                this.b = typeCast(CT_Boolean.$, b);
                break;
            case 869:
                this.r = typeCast(CT_TextLanguageID.$, b);
                break;
            case 1374:
                this.d = typeCast(CT_Boolean.$, b);
                break;
            case 1618:
                this.p = typeCast(CT_Style.$, b);
                break;
            case 283:
                this.t = typeCast(CT_ColorMapping.$, b);
                break;
            case 1223:
                this.j = typeCast(CT_PivotSource.$, b);
                break;
            case 1271:
                this.n = typeCast(CT_Protection.$, b);
                break;
            case 261:
                this.f = typeCast(CT_Chart.$, b);
                break;
            case 1570:
                this.v = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.x = typeCast(CT_TextBody_DML.$, b);
                break;
            case 604:
                this.h = typeCast(CT_ExternalData.$, b);
                break;
            case 1258:
                this.l = typeCast(CT_PrintSettings.$, b);
                break;
            case 1816:
                this.z = typeCast(CT_RelId.$, b);
                break;
            case 601:
                this.ab = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartSpace.$t = markType(CT_ChartSpace, 'CT_ChartSpace', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PageSetup_Chart extends Base {
    constructor() {
        super();
        this.t = Nullable$1.toNullable(Number_$type, null);
        this.n = Nullable$1.toNullable(Number_$type, null);
        this.r = Nullable$1.toNullable(ST_PageSetupOrientation_$type, null);
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.v = Nullable$1.toNullable(Boolean_$type, null);
        this.p = Nullable$1.toNullable(Number_$type, null);
        this.x = Nullable$1.toNullable(Number_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static ac(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(ST_PageSetupOrientation_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "paperSize":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "firstPageNumber":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "orientation":
                    d = Nullable$1.toNullable(ST_PageSetupOrientation_$type, XmlNamespaceDefinitionBase.b(ST_PageSetupOrientation_$type, k.d));
                    break;
                case "blackAndWhite":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "draft":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "useFirstPageNumber":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "horizontalDpi":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "verticalDpi":
                    i = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "copies":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static ad(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(ST_PageSetupOrientation_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "c");
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "blackAndWhite";
            l = ST_OnOff.g(c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "copies";
            l = d.value.toString();
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "draft";
            l = ST_OnOff.g(e.value);
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "firstPageNumber";
            l = f.value.toString();
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "horizontalDpi";
            l = g.value.toString();
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "orientation";
            l = XmlNamespaceDefinitionBase.f(ST_PageSetupOrientation_$type, h.value);
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "paperSize";
            l = i.value.toString();
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "useFirstPageNumber";
            l = ST_OnOff.g(j.value);
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "verticalDpi";
            l = k.value.toString();
            a.ad.h(m, l);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PageSetup_Chart.$t = markType(CT_PageSetup_Chart, 'CT_PageSetup_Chart');
/**
 * @hidden
 */
export class CT_PageMargins_Chart extends Base {
    constructor() {
        super(...arguments);
        this.i = 0;
        this.k = 0;
        this.m = 0;
        this.c = 0;
        this.g = 0;
        this.e = 0;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static a(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        let e = 0;
        let f = 0;
        let g = 0;
        let h = CT_PageMargins_Chart.o(a, b, c, d, e, f, g);
        b = h.p1;
        c = h.p2;
        d = h.p3;
        e = h.p4;
        f = h.p5;
        g = h.p6;
        return ((() => {
            let $ret = new CT_PageMargins_Chart();
            $ret.b = e;
            $ret.d = g;
            $ret.f = f;
            $ret.h = b;
            $ret.j = c;
            $ret.l = d;
            return $ret;
        })());
    }
    static o(a, b, c, d, e, f, g) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "l":
                    b = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "r":
                    c = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "t":
                    d = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "b":
                    e = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "header":
                    f = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "footer":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static p(a, b, c, d, e, f, g, h) {
        a.ad.p(b, "c");
        let i = null;
        let j = null;
        j = "b";
        i = c.toString();
        a.ad.h(j, i);
        j = "footer";
        i = d.toString();
        a.ad.h(j, i);
        j = "header";
        i = e.toString();
        a.ad.h(j, i);
        j = "l";
        i = f.toString();
        a.ad.h(j, i);
        j = "r";
        i = g.toString();
        a.ad.h(j, i);
        j = "t";
        i = h.toString();
        a.ad.h(j, i);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PageMargins_Chart.$t = markType(CT_PageMargins_Chart, 'CT_PageMargins_Chart');
/**
 * @hidden
 */
export class CT_HeaderFooter_Chart extends Base {
    constructor() {
        super();
        this.u = null;
        this.s = null;
        this.m = null;
        this.k = null;
        this.q = null;
        this.o = null;
        this.b = false;
        this.i = false;
        this.g = false;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static w(a, b, c, d) {
        b = false;
        c = false;
        d = false;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "alignWithMargins":
                    b = ST_OnOff.e(e.d);
                    break;
                case "differentOddEven":
                    c = ST_OnOff.e(e.d);
                    break;
                case "differentFirst":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static x(a, b, c, d, e) {
        a.ad.p(b, "c");
        let f = null;
        let g = null;
        g = "alignWithMargins";
        f = ST_OnOff.g(c);
        a.ad.h(g, f);
        g = "differentFirst";
        f = ST_OnOff.g(d);
        a.ad.h(g, f);
        g = "differentOddEven";
        f = ST_OnOff.g(e);
        a.ad.h(g, f);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1118:
                this.t = typeCast(String_$type, b);
                break;
            case 1117:
                this.r = typeCast(String_$type, b);
                break;
            case 597:
                this.l = typeCast(String_$type, b);
                break;
            case 596:
                this.j = typeCast(String_$type, b);
                break;
            case 645:
                this.p = typeCast(String_$type, b);
                break;
            case 644:
                this.n = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_HeaderFooter_Chart.$t = markType(CT_HeaderFooter_Chart, 'CT_HeaderFooter_Chart', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PrintSettings extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 774:
                this.a = typeCast(CT_HeaderFooter_Chart.$, b);
                break;
            case 1162:
                this.c = typeCast(CT_PageMargins_Chart.$, b);
                break;
            case 1164:
                this.e = typeCast(CT_PageSetup_Chart.$, b);
                break;
            case 889:
                this.g = typeCast(CT_RelId.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PrintSettings.$t = markType(CT_PrintSettings, 'CT_PrintSettings', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ExternalData extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b, c) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id":
                    c = d.d;
                    break;
                case DrawingMLChart.aw:
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        if (c != null) {
            e = "http://schemas.openxmlformats.org/officeDocument/2006/relationships:id";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 79:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ExternalData.$t = markType(CT_ExternalData, 'CT_ExternalData', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DispBlanksAs extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_DispBlanksAs_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_DispBlanksAs_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DispBlanksAs.$t = markType(CT_DispBlanksAs, 'CT_DispBlanksAs');
/**
 * @hidden
 */
export class CT_LegendEntry extends Base {
    constructor() {
        super();
        this.c = null;
        this.i = null;
        this.g = null;
        this.d = null;
        this.a = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get item() {
        return this.i;
    }
    set item(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get e() {
        if (this.d == null) {
            this.d = new EG_LegendEntryData();
        }
        return this.d;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.b = typeCast(CT_UnsignedInt.$, b);
                break;
            case 467:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.f = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.e.b(a)) {
                    this.e.d(a, b);
                    return;
                }
                break;
        }
    }
}
CT_LegendEntry.$t = markType(CT_LegendEntry, 'CT_LegendEntry', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LegendPos extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_LegendPos_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_LegendPos_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LegendPos.$t = markType(CT_LegendPos, 'CT_LegendPos');
/**
 * @hidden
 */
export class CT_Legend extends Base {
    constructor() {
        super();
        this.f = null;
        this.n = null;
        this.d = null;
        this.b = null;
        this.h = null;
        this.j = null;
        this.l = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 892:
                this.e = typeCast(CT_LegendPos.$, b);
                break;
            case 891:
                this.m.add(typeCast(CT_LegendEntry.$, b));
                break;
            case 876:
                this.c = typeCast(CT_Layout.$, b);
                break;
            case 1150:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.i = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Legend.$t = markType(CT_Legend, 'CT_Legend', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Layout extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 968:
                this.a = typeCast(CT_ManualLayout.$, b);
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Layout.$t = markType(CT_Layout, 'CT_Layout', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ManualLayout extends Base {
    constructor() {
        super();
        this.r = null;
        this.n = null;
        this.p = null;
        this.l = null;
        this.j = null;
        this.f = null;
        this.h = null;
        this.d = null;
        this.b = null;
        this.t = null;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 882:
                this.q = typeCast(CT_LayoutTarget.$, b);
                break;
            case 1889:
                this.m = typeCast(CT_LayoutMode.$, b);
                break;
            case 1897:
                this.o = typeCast(CT_LayoutMode.$, b);
                break;
            case 1850:
                this.k = typeCast(CT_LayoutMode.$, b);
                break;
            case 764:
                this.i = typeCast(CT_LayoutMode.$, b);
                break;
            case 1888:
                this.e = typeCast(CT_Double.$, b);
                break;
            case 1896:
                this.g = typeCast(CT_Double.$, b);
                break;
            case 1849:
                this.c = typeCast(CT_Double.$, b);
                break;
            case 762:
                this.a = typeCast(CT_Double.$, b);
                break;
            case 601:
                this.s = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ManualLayout.$t = markType(CT_ManualLayout, 'CT_ManualLayout', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LayoutTarget extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_LayoutTarget_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_LayoutTarget_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LayoutTarget.$t = markType(CT_LayoutTarget, 'CT_LayoutTarget');
/**
 * @hidden
 */
export class CT_LayoutMode extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_LayoutMode_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_LayoutMode_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LayoutMode.$t = markType(CT_LayoutMode, 'CT_LayoutMode');
/**
 * @hidden
 */
export class CT_DTable extends Base {
    constructor() {
        super();
        this.b = null;
        this.h = null;
        this.f = null;
        this.d = null;
        this.j = null;
        this.l = null;
        this.n = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1489:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1499:
                this.g = typeCast(CT_Boolean.$, b);
                break;
            case 1494:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 1490:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 1570:
                this.i = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.k = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.m = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DTable.$t = markType(CT_DTable, 'CT_DTable', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export let IAxis_$type = new Type(null, 'IAxis');
/**
 * @hidden
 */
export class CT_SerAx extends Base {
    constructor() {
        super();
        this.j = null;
        this.b = null;
        this.d = null;
        this.h = null;
        this.e = null;
    }
    get item() {
        return this.j;
    }
    set item(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_AxShared();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 1725:
                this.a = typeCast(CT_Skip.$, b);
                break;
            case 1726:
                this.c = typeCast(CT_Skip.$, b);
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.f.q(a)) {
                    this.f.s(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get axisType() {
        return 3;
    }
    get id() {
        return this.f.c.g;
    }
    get crossAxId() {
        return CT_UnsignedInt.e(this.f.d);
    }
    get sharedProps() {
        return this.f;
    }
    get axisCrossesBetween() {
        return false;
    }
    get baseUnit() {
        return null;
    }
    get dispUnits() {
        return null;
    }
    get tickLabelAlignment() {
        return unwrapNullable(this._tickLabelAlignment$i);
    }
    get _tickLabelAlignment$i() {
        return Nullable$1.toNullable(ST_LblAlgn_$type, null);
    }
    get tickLabelMultiLevel() {
        return unwrapNullable(this._tickLabelMultiLevel$i);
    }
    get _tickLabelMultiLevel$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    get tickLabelSkip() {
        return unwrapNullable(this._tickLabelSkip$i);
    }
    get _tickLabelSkip$i() {
        return this.a != null ? Nullable$1.toNullable(Number_$type, this.a.b) : Nullable$1.toNullable(Number_$type, null);
    }
    get tickMarkSkipValue() {
        return unwrapNullable(this._tickMarkSkipValue$i);
    }
    get _tickMarkSkipValue$i() {
        return this.c != null ? Nullable$1.toNullable(Number_$type, this.c.b) : Nullable$1.toNullable(Number_$type, null);
    }
    get tickLabelOffset() {
        return unwrapNullable(this._tickLabelOffset$i);
    }
    get _tickLabelOffset$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get categoryType() {
        return unwrapNullable(this._categoryType$i);
    }
    get _categoryType$i() {
        return Nullable$1.toNullable(CategoryType_$type, null);
    }
    save(a, b, c) {
        c.p(DrawingMLChart.fa, null);
        if (this.f != null) {
            this.f.r(a, b, c, null);
        }
        if (this.a != null) {
            DMLChartExtensions.cu(this.a, a, b, c, DrawingMLChart.f7);
        }
        if (this.c != null) {
            DMLChartExtensions.cu(this.c, a, b, c, DrawingMLChart.f8);
        }
        c.k();
    }
    tryGetMajorMinorUnit(major, minor) {
        arguments[0] = wrapNullable(Number_$type, arguments[0]);
        arguments[1] = wrapNullable(Number_$type, arguments[1]);
        return this._tryGetMajorMinorUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorUnit$i(a, b) {
        b = a = Nullable$1.toNullable(Number_$type, null);
        return {
            ret: false,
            p0: a,
            p1: b
        };
    }
    tryGetMajorMinorTimeUnit(major, minor) {
        arguments[0] = wrapNullable(ST_TimeUnit_$type, arguments[0]);
        arguments[1] = wrapNullable(ST_TimeUnit_$type, arguments[1]);
        return this._tryGetMajorMinorTimeUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorTimeUnit$i(a, b) {
        b = a = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        return {
            ret: false,
            p0: a,
            p1: b
        };
    }
}
CT_SerAx.$t = markType(CT_SerAx, 'CT_SerAx', Base.$, [ISupportSetProperty_$type, IAxis_$type]);
/**
 * @hidden
 */
export class CT_Scaling extends Base {
    constructor() {
        super();
        this.f = null;
        this.h = null;
        this.b = null;
        this.d = null;
        this.j = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 934:
                this.e = typeCast(CT_LogBase.$, b);
                break;
            case 1137:
                this.g = typeCast(CT_Orientation.$, b);
                break;
            case 984:
                this.a = typeCast(CT_Double.$, b);
                break;
            case 1008:
                this.c = typeCast(CT_Double.$, b);
                break;
            case 601:
                this.i = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Scaling.$t = markType(CT_Scaling, 'CT_Scaling', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LogBase extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LogBase.$t = markType(CT_LogBase, 'CT_LogBase');
/**
 * @hidden
 */
export class CT_Orientation extends Base {
    constructor() {
        super();
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_Orientation_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_Orientation_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Orientation.$t = markType(CT_Orientation, 'CT_Orientation');
/**
 * @hidden
 */
export class CT_AxPos extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_AxPos_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_AxPos_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AxPos.$t = markType(CT_AxPos, 'CT_AxPos');
/**
 * @hidden
 */
export class CT_ChartLines extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartLines.$t = markType(CT_ChartLines, 'CT_ChartLines', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Title extends Base {
    constructor() {
        super();
        this.f = null;
        this.d = null;
        this.b = null;
        this.h = null;
        this.j = null;
        this.l = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1776:
                this.e = typeCast(CT_Tx.$, b);
                break;
            case 876:
                this.c = typeCast(CT_Layout.$, b);
                break;
            case 1150:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.i = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Title.$t = markType(CT_Title, 'CT_Title', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Tx extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.a = null;
        this.b = null;
    }
    get item() {
        return this.d;
    }
    set item(a) {
        this.d = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1606:
                this.a = typeCast(CT_StrRef.$, b);
                break;
            case 1362:
                this.b = typeCast(CT_TextBody_DML.$, b);
                break;
            default: break;
        }
    }
}
CT_Tx.$t = markType(CT_Tx, 'CT_Tx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StrRef extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.d = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.e = typeCast(String_$type, b);
                break;
            case 1603:
                this.a = typeCast(CT_StrData.$, b);
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StrRef.$t = markType(CT_StrRef, 'CT_StrRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export let IProvideXValuesData_$type = new Type(null, 'IProvideXValuesData');
/**
 * @hidden
 */
export class CT_StrData extends Base {
    constructor() {
        super();
        this.c = null;
        this.g = null;
        this.e = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1278:
                this.b = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1277:
                this.f.add(typeCast(CT_StrVal.$, b));
                break;
            case 601:
                this.d = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static a(a, b, c) {
        let d = b != null ? b.g : 0;
        if (d == 0) {
            return new Array(0);
        }
        let e = new Dictionary$2(Number_$type, Base.$, 0);
        for (let f of fromEn(c)) {
            let g = 0;
            let h = null;
            let i = a.getIndexAndValue(f, g, h);
            g = i.p1;
            h = i.p2;
            e.addItem(g, h);
        }
        let j = new Array(d);
        for (let k = 0; k < d; k++) {
            let l = null;
            if (((() => { let m = e.tryGetValue(k, l); l = m.p1; return m.ret; })())) {
                j[k] = l;
            }
            else {
                j[k] = null;
            }
        }
        return j;
    }
    getIndexAndValue(a, b, c) {
        let d = typeCast(CT_StrVal.$, a);
        b = d.d;
        c = d.b;
        return {
            p1: b,
            p2: c
        };
    }
    getValues() {
        return CT_StrData.a(this, this.b, this.f);
    }
}
CT_StrData.$t = markType(CT_StrData, 'CT_StrData', Base.$, [ISupportSetProperty_$type, IProvideXValuesData_$type]);
/**
 * @hidden
 */
export class CT_StrVal extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.e = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "idx";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1818:
                this.b = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StrVal.$t = markType(CT_StrVal, 'CT_StrVal', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumFmt_Chart extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = false;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b, c) {
        b = null;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "formatCode":
                    b = d.d;
                    break;
                case "sourceLinked":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, "c");
        let e = null;
        let f = null;
        if (c != null) {
            f = "formatCode";
            e = c;
            a.ad.h(f, e);
        }
        f = "sourceLinked";
        e = ST_OnOff.g(d);
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumFmt_Chart.$t = markType(CT_NumFmt_Chart, 'CT_NumFmt_Chart');
/**
 * @hidden
 */
export class CT_TickMark extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_TickMark_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_TickMark_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TickMark.$t = markType(CT_TickMark, 'CT_TickMark');
/**
 * @hidden
 */
export class CT_TickLblPos extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_TickLblPos_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_TickLblPos_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TickLblPos.$t = markType(CT_TickLblPos, 'CT_TickLblPos');
/**
 * @hidden
 */
export class CT_Crosses extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_Crosses_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_Crosses_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Crosses.$t = markType(CT_Crosses, 'CT_Crosses');
/**
 * @hidden
 */
export class CT_Skip extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Skip.$t = markType(CT_Skip, 'CT_Skip');
/**
 * @hidden
 */
export class CT_TimeUnit extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_TimeUnit_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_TimeUnit_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TimeUnit.$t = markType(CT_TimeUnit, 'CT_TimeUnit');
/**
 * @hidden
 */
export class CT_DateAx extends Base {
    constructor() {
        super();
        this.t = null;
        this.b = null;
        this.h = null;
        this.j = null;
        this.d = null;
        this.l = null;
        this.f = null;
        this.n = null;
        this.r = null;
        this.o = null;
    }
    get item() {
        return this.t;
    }
    set item(a) {
        this.t = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get p() {
        if (this.o == null) {
            this.o = new EG_AxShared();
        }
        return this.o;
    }
    setProperty(a, b) {
        switch (a) {
            case 69:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 884:
                this.g = typeCast(CT_LblOffset.$, b);
                break;
            case 104:
                this.i = typeCast(CT_TimeUnit.$, b);
                break;
            case 967:
                this.c = typeCast(CT_AxisUnit.$, b);
                break;
            case 966:
                this.k = typeCast(CT_TimeUnit.$, b);
                break;
            case 1015:
                this.e = typeCast(CT_AxisUnit.$, b);
                break;
            case 1014:
                this.m = typeCast(CT_TimeUnit.$, b);
                break;
            case 601:
                this.q = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.p.q(a)) {
                    this.p.s(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get axisType() {
        return 1;
    }
    get id() {
        return this.p.c.g;
    }
    get crossAxId() {
        return CT_UnsignedInt.e(this.p.d);
    }
    get sharedProps() {
        return this.p;
    }
    get axisCrossesBetween() {
        return false;
    }
    get baseUnit() {
        let a = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        if (this.i != null) {
            a = Nullable$1.toNullable(ST_TimeUnit_$type, this.i.b);
        }
        let b = this.a != null ? this.a.k : true;
        return Tuple.a(Nullable$1.$.specialize(ST_TimeUnit_$type), Boolean_$type, a, b);
    }
    get dispUnits() {
        return null;
    }
    get tickLabelAlignment() {
        return unwrapNullable(this._tickLabelAlignment$i);
    }
    get _tickLabelAlignment$i() {
        return Nullable$1.toNullable(ST_LblAlgn_$type, null);
    }
    get tickLabelMultiLevel() {
        return unwrapNullable(this._tickLabelMultiLevel$i);
    }
    get _tickLabelMultiLevel$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    get tickLabelSkip() {
        return unwrapNullable(this._tickLabelSkip$i);
    }
    get _tickLabelSkip$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get tickMarkSkipValue() {
        return unwrapNullable(this._tickMarkSkipValue$i);
    }
    get _tickMarkSkipValue$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get tickLabelOffset() {
        return unwrapNullable(this._tickLabelOffset$i);
    }
    get _tickLabelOffset$i() {
        return this.g != null ? Nullable$1.toNullable(Number_$type, this.g.c) : Nullable$1.toNullable(Number_$type, null);
    }
    get categoryType() {
        return unwrapNullable(this._categoryType$i);
    }
    get _categoryType$i() {
        return Nullable$1.toNullable(CategoryType_$type, 3);
    }
    save(a, b, c) {
        c.p(DrawingMLChart.bq, null);
        if (this.p != null) {
            this.p.r(a, b, c, null);
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.au, "c");
        }
        if (this.g != null) {
            DMLChartExtensions.b2(this.g, a, b, c, DrawingMLChart.c5);
        }
        if (this.i != null) {
            DMLChartExtensions.c1(this.i, a, b, c, DrawingMLChart.a6);
        }
        if (this.c != null) {
            DMLChartExtensions.be(this.c, a, b, c, DrawingMLChart.di);
        }
        if (this.k != null) {
            DMLChartExtensions.c1(this.k, a, b, c, DrawingMLChart.dh);
        }
        if (this.e != null) {
            DMLChartExtensions.be(this.e, a, b, c, DrawingMLChart.dr);
        }
        if (this.m != null) {
            DMLChartExtensions.c1(this.m, a, b, c, DrawingMLChart.dq);
        }
        c.k();
    }
    tryGetMajorMinorUnit(major, minor) {
        arguments[0] = wrapNullable(Number_$type, arguments[0]);
        arguments[1] = wrapNullable(Number_$type, arguments[1]);
        return this._tryGetMajorMinorUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorUnit$i(a, b) {
        a = Nullable$1.toNullable(Number_$type, null);
        b = Nullable$1.toNullable(Number_$type, null);
        if (this.c != null) {
            a = Nullable$1.toNullable(Number_$type, this.c.a);
        }
        if (this.e != null) {
            b = Nullable$1.toNullable(Number_$type, this.e.a);
        }
        return {
            ret: true,
            p0: a,
            p1: b
        };
    }
    tryGetMajorMinorTimeUnit(major, minor) {
        arguments[0] = wrapNullable(ST_TimeUnit_$type, arguments[0]);
        arguments[1] = wrapNullable(ST_TimeUnit_$type, arguments[1]);
        return this._tryGetMajorMinorTimeUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorTimeUnit$i(a, b) {
        b = a = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        if (this.k != null) {
            a = Nullable$1.toNullable(ST_TimeUnit_$type, this.k.b);
        }
        if (this.m != null) {
            b = Nullable$1.toNullable(ST_TimeUnit_$type, this.m.b);
        }
        return {
            ret: true,
            p0: a,
            p1: b
        };
    }
}
CT_DateAx.$t = markType(CT_DateAx, 'CT_DateAx', Base.$, [ISupportSetProperty_$type, IAxis_$type]);
/**
 * @hidden
 */
export class CT_LblOffset extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LblOffset.$t = markType(CT_LblOffset, 'CT_LblOffset');
/**
 * @hidden
 */
export class CT_AxisUnit extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AxisUnit.$t = markType(CT_AxisUnit, 'CT_AxisUnit');
/**
 * @hidden
 */
export class CT_LblAlgn extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_LblAlgn_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_LblAlgn_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LblAlgn.$t = markType(CT_LblAlgn, 'CT_LblAlgn');
/**
 * @hidden
 */
export class CT_CatAx extends Base {
    constructor() {
        super();
        this.r = null;
        this.b = null;
        this.f = null;
        this.h = null;
        this.j = null;
        this.l = null;
        this.d = null;
        this.p = null;
        this.m = null;
    }
    get item() {
        return this.r;
    }
    set item(a) {
        this.r = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get n() {
        if (this.m == null) {
            this.m = new EG_AxShared();
        }
        return this.m;
    }
    setProperty(a, b) {
        switch (a) {
            case 69:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 883:
                this.e = typeCast(CT_LblAlgn.$, b);
                break;
            case 884:
                this.g = typeCast(CT_LblOffset.$, b);
                break;
            case 1725:
                this.i = typeCast(CT_Skip.$, b);
                break;
            case 1726:
                this.k = typeCast(CT_Skip.$, b);
                break;
            case 1066:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.o = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.n.q(a)) {
                    this.n.s(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get axisType() {
        return 1;
    }
    get id() {
        return this.n.c.g;
    }
    get crossAxId() {
        return CT_UnsignedInt.e(this.n.d);
    }
    get sharedProps() {
        return this.n;
    }
    get axisCrossesBetween() {
        return false;
    }
    get baseUnit() {
        let a = this.a != null ? this.a.k : true;
        return Tuple.a(Nullable$1.$.specialize(ST_TimeUnit_$type), Boolean_$type, Nullable$1.toNullable(ST_TimeUnit_$type, null), a);
    }
    get dispUnits() {
        return null;
    }
    get tickLabelAlignment() {
        return unwrapNullable(this._tickLabelAlignment$i);
    }
    get _tickLabelAlignment$i() {
        return this.e != null ? Nullable$1.toNullable(ST_LblAlgn_$type, this.e.a) : Nullable$1.toNullable(ST_LblAlgn_$type, null);
    }
    get tickLabelMultiLevel() {
        return unwrapNullable(this._tickLabelMultiLevel$i);
    }
    get _tickLabelMultiLevel$i() {
        return this.c != null ? Nullable$1.toNullable(Boolean_$type, this.c.k == false) : Nullable$1.toNullable(Boolean_$type, null);
    }
    get tickLabelSkip() {
        return unwrapNullable(this._tickLabelSkip$i);
    }
    get _tickLabelSkip$i() {
        return this.i != null ? Nullable$1.toNullable(Number_$type, this.i.b) : Nullable$1.toNullable(Number_$type, null);
    }
    get tickMarkSkipValue() {
        return unwrapNullable(this._tickMarkSkipValue$i);
    }
    get _tickMarkSkipValue$i() {
        return this.k != null ? Nullable$1.toNullable(Number_$type, this.k.b) : Nullable$1.toNullable(Number_$type, null);
    }
    get tickLabelOffset() {
        return unwrapNullable(this._tickLabelOffset$i);
    }
    get _tickLabelOffset$i() {
        return this.g != null ? Nullable$1.toNullable(Number_$type, this.g.c) : Nullable$1.toNullable(Number_$type, null);
    }
    get categoryType() {
        return unwrapNullable(this._categoryType$i);
    }
    get _categoryType$i() {
        return Nullable$1.toNullable(CategoryType_$type, this.a == null || this.a.k ? -4105 : 2);
    }
    save(a, b, c) {
        let d = DrawingMLChart.bd;
        c.p(d, null);
        if (this.n != null) {
            this.n.r(a, b, c, null);
        }
        if (this.a != null) {
            this.a.q(a, b, c, DrawingMLChart.au, "c");
        }
        if (this.e != null) {
            DMLChartExtensions.b1(this.e, a, b, c, DrawingMLChart.c4);
        }
        if (this.g != null) {
            DMLChartExtensions.b2(this.g, a, b, c, DrawingMLChart.c5);
        }
        if (this.i != null) {
            DMLChartExtensions.cu(this.i, a, b, c, DrawingMLChart.f7);
        }
        if (this.k != null) {
            DMLChartExtensions.cu(this.k, a, b, c, DrawingMLChart.f8);
        }
        if (this.c != null) {
            this.c.q(a, b, c, DrawingMLChart.dz, "c");
        }
        c.k();
    }
    tryGetMajorMinorUnit(major, minor) {
        arguments[0] = wrapNullable(Number_$type, arguments[0]);
        arguments[1] = wrapNullable(Number_$type, arguments[1]);
        return this._tryGetMajorMinorUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorUnit$i(a, b) {
        b = a = Nullable$1.toNullable(Number_$type, null);
        return {
            ret: false,
            p0: a,
            p1: b
        };
    }
    tryGetMajorMinorTimeUnit(major, minor) {
        arguments[0] = wrapNullable(ST_TimeUnit_$type, arguments[0]);
        arguments[1] = wrapNullable(ST_TimeUnit_$type, arguments[1]);
        return this._tryGetMajorMinorTimeUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorTimeUnit$i(a, b) {
        b = a = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        return {
            ret: false,
            p0: a,
            p1: b
        };
    }
}
CT_CatAx.$t = markType(CT_CatAx, 'CT_CatAx', Base.$, [ISupportSetProperty_$type, IAxis_$type]);
/**
 * @hidden
 */
export class CT_DispUnitsLbl extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 876:
                this.a = typeCast(CT_Layout.$, b);
                break;
            case 1776:
                this.c = typeCast(CT_Tx.$, b);
                break;
            case 1570:
                this.e = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.g = typeCast(CT_TextBody_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DispUnitsLbl.$t = markType(CT_DispUnitsLbl, 'CT_DispUnitsLbl', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BuiltInUnit extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_BuiltInUnit_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_BuiltInUnit_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BuiltInUnit.$t = markType(CT_BuiltInUnit, 'CT_BuiltInUnit');
/**
 * @hidden
 */
export class CT_DispUnits extends Base {
    constructor() {
        super();
        this.h = null;
        this.d = null;
        this.f = null;
        this.a = null;
        this.b = null;
    }
    get item() {
        return this.h;
    }
    set item(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 375:
                this.a = typeCast(CT_Double.$, b);
                break;
            case 187:
                this.b = typeCast(CT_BuiltInUnit.$, b);
                break;
            case 492:
                this.c = typeCast(CT_DispUnitsLbl.$, b);
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
}
CT_DispUnits.$t = markType(CT_DispUnits, 'CT_DispUnits', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CrossBetween extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_CrossBetween_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_CrossBetween_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CrossBetween.$t = markType(CT_CrossBetween, 'CT_CrossBetween');
/**
 * @hidden
 */
export class CT_ValAx extends Base {
    constructor() {
        super();
        this.n = null;
        this.f = null;
        this.b = null;
        this.d = null;
        this.h = null;
        this.l = null;
        this.i = null;
    }
    get item() {
        return this.n;
    }
    set item(a) {
        this.n = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get dispUnits() {
        return this.h;
    }
    set dispUnits(a) {
        this.h = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_AxShared();
        }
        return this.i;
    }
    setProperty(a, b) {
        switch (a) {
            case 360:
                this.e = typeCast(CT_CrossBetween.$, b);
                break;
            case 967:
                this.a = typeCast(CT_AxisUnit.$, b);
                break;
            case 1015:
                this.c = typeCast(CT_AxisUnit.$, b);
                break;
            case 491:
                this.dispUnits = typeCast(CT_DispUnits.$, b);
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.j.q(a)) {
                    this.j.s(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get axisType() {
        return 2;
    }
    get id() {
        return this.j.c.g;
    }
    get crossAxId() {
        return CT_UnsignedInt.e(this.j.d);
    }
    get sharedProps() {
        return this.j;
    }
    get axisCrossesBetween() {
        return this.e != null ? this.e.a == 0 : false;
    }
    get baseUnit() {
        return null;
    }
    get tickLabelAlignment() {
        return unwrapNullable(this._tickLabelAlignment$i);
    }
    get _tickLabelAlignment$i() {
        return Nullable$1.toNullable(ST_LblAlgn_$type, null);
    }
    get tickLabelMultiLevel() {
        return unwrapNullable(this._tickLabelMultiLevel$i);
    }
    get _tickLabelMultiLevel$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    get tickLabelSkip() {
        return unwrapNullable(this._tickLabelSkip$i);
    }
    get _tickLabelSkip$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get tickMarkSkipValue() {
        return unwrapNullable(this._tickMarkSkipValue$i);
    }
    get _tickMarkSkipValue$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get tickLabelOffset() {
        return unwrapNullable(this._tickLabelOffset$i);
    }
    get _tickLabelOffset$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    get categoryType() {
        return unwrapNullable(this._categoryType$i);
    }
    get _categoryType$i() {
        return Nullable$1.toNullable(CategoryType_$type, null);
    }
    save(a, b, c) {
        let d = DrawingMLChart.gl;
        c.p(d, null);
        if (this.j != null) {
            this.j.r(a, b, c, null);
        }
        if (this.e != null) {
            DMLChartExtensions.bl(this.e, a, b, c, DrawingMLChart.bj);
        }
        if (this.a != null) {
            DMLChartExtensions.be(this.a, a, b, c, DrawingMLChart.di);
        }
        if (this.c != null) {
            DMLChartExtensions.be(this.c, a, b, c, DrawingMLChart.dr);
        }
        if (this.dispUnits != null) {
            DMLChartExtensions.bn(this.dispUnits, a, b, c, DrawingMLChart.bw);
        }
        c.k();
    }
    tryGetMajorMinorUnit(major, minor) {
        arguments[0] = wrapNullable(Number_$type, arguments[0]);
        arguments[1] = wrapNullable(Number_$type, arguments[1]);
        return this._tryGetMajorMinorUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorUnit$i(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        a = Nullable$1.toNullable(Number_$type, null);
        if (this.a != null) {
            a = Nullable$1.toNullable(Number_$type, this.a.a);
        }
        if (this.c != null) {
            b = Nullable$1.toNullable(Number_$type, this.c.a);
        }
        return {
            ret: true,
            p0: a,
            p1: b
        };
    }
    tryGetMajorMinorTimeUnit(major, minor) {
        arguments[0] = wrapNullable(ST_TimeUnit_$type, arguments[0]);
        arguments[1] = wrapNullable(ST_TimeUnit_$type, arguments[1]);
        return this._tryGetMajorMinorTimeUnit$i.apply(this, arguments);
    }
    _tryGetMajorMinorTimeUnit$i(a, b) {
        b = a = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        return {
            ret: false,
            p0: a,
            p1: b
        };
    }
}
CT_ValAx.$t = markType(CT_ValAx, 'CT_ValAx', Base.$, [ISupportSetProperty_$type, IAxis_$type]);
/**
 * @hidden
 */
export class CT_SizeRepresents extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SizeRepresents_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_SizeRepresents_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SizeRepresents.$t = markType(CT_SizeRepresents, 'CT_SizeRepresents');
/**
 * @hidden
 */
export class CT_BubbleScale extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BubbleScale.$t = markType(CT_BubbleScale, 'CT_BubbleScale');
/**
 * @hidden
 */
export let ISeries_$type = new Type(null, 'ISeries');
/**
 * @hidden
 */
export class CT_BubbleSer extends Base {
    constructor() {
        super();
        this.d = null;
        this.q = null;
        this.h = null;
        this.w = null;
        this.s = null;
        this.f = null;
        this.l = null;
        this.j = null;
        this.b = null;
        this.u = null;
        this.m = null;
        this.o = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get n() {
        if (this.m == null) {
            this.m = new EG_SerShared();
        }
        return this.m;
    }
    setProperty(a, b) {
        switch (a) {
            case 848:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 408:
                this.p.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.g = typeCast(CT_DLbls.$, b);
                break;
            case 1767:
                this.v.add(typeCast(CT_Trendline.$, b));
                break;
            case 590:
                this.r.add(typeCast(CT_ErrBars.$, b));
                break;
            case 1890:
                this.e = typeCast(CT_AxDataSource.$, b);
                break;
            case 1898:
                this.k = typeCast(CT_NumDataSource.$, b);
                break;
            case 186:
                this.i = typeCast(CT_NumDataSource.$, b);
                break;
            case 183:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.t = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.n.e(a)) {
                    this.n.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.o;
    }
    get seriesType() {
        return 7;
    }
    get sharedProps() {
        return this.n;
    }
    getBubbleSizes(a, b) {
        let c = this.i;
        let d = c != null ? c.b : null;
        return typeCast(SeriesValues.$, DMLChartUtils.p(d, a, b, false));
    }
    get cT_ErrBars() {
        return this.r != null && this.r.count > 0 ? this.r._inner[0] : null;
    }
    get invertIfNegativeValue() {
        return this.c != null && this.c.k;
    }
    get cT_NumDataSource() {
        return this.k;
    }
    get cT_AxDataSource() {
        return this.e;
    }
    get cT_Marker() {
        return null;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.n.a.g;
    }
    getTrendlines() {
        return this.v;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.t));
        return {
            ret: this.g,
            p0: a
        };
    }
    getDataPoints() {
        return this.p;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.n);
    }
    get isBubble3D() {
        return this.a != null && this.a.k;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.o.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_BubbleSer.$t = markType(CT_BubbleSer, 'CT_BubbleSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_SerTx extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.a = null;
        this.e = null;
    }
    get item() {
        return this.c;
    }
    set item(a) {
        this.c = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1606:
                this.a = typeCast(CT_StrRef.$, b);
                break;
            case 1818:
                this.e = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
}
CT_SerTx.$t = markType(CT_SerTx, 'CT_SerTx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DPt extends Base {
    constructor() {
        super();
        this.h = null;
        this.d = null;
        this.j = null;
        this.b = null;
        this.f = null;
        this.n = null;
        this.l = null;
        this.p = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.g = typeCast(CT_UnsignedInt.$, b);
                break;
            case 848:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 979:
                this.i = typeCast(CT_Marker_Chart.$, b);
                break;
            case 183:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 598:
                this.e = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1570:
                this.m = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1199:
                this.k = typeCast(CT_PictureOptions.$, b);
                break;
            case 601:
                this.o = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DPt.$t = markType(CT_DPt, 'CT_DPt', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Marker_Chart extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = null;
        this.i = null;
        this.j = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1651:
                this.c = typeCast(CT_MarkerStyle.$, b);
                break;
            case 1508:
                this.a = typeCast(CT_MarkerSize.$, b);
                break;
            case 1570:
                this.e = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.h = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static g(a, b) {
        let c = Nullable$1.toNullable(Boolean_$type, null);
        b = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    try {
                        c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    }
                    catch (e) {
                    }
                    break;
                default: break;
            }
        }
        if (c.hasValue) {
            b = c.value;
            return {
                ret: true,
                p1: b
            };
        }
        return {
            ret: false,
            p1: b
        };
    }
    static l(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = ST_OnOff.g(c);
        a.ad.h(e, d);
    }
}
CT_Marker_Chart.$t = markType(CT_Marker_Chart, 'CT_Marker_Chart', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_MarkerStyle extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_MarkerStyle_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_MarkerStyle_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_MarkerStyle.$t = markType(CT_MarkerStyle, 'CT_MarkerStyle');
/**
 * @hidden
 */
export class CT_MarkerSize extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_MarkerSize.$t = markType(CT_MarkerSize, 'CT_MarkerSize');
/**
 * @hidden
 */
export class CT_PictureOptions extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.h = null;
        this.j = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 51:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 52:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 50:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1198:
                this.g = typeCast(CT_PictureFormat.$, b);
                break;
            case 1200:
                this.i = typeCast(CT_PictureStackUnit.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PictureOptions.$t = markType(CT_PictureOptions, 'CT_PictureOptions', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PictureFormat extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_PictureFormat_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_PictureFormat_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PictureFormat.$t = markType(CT_PictureFormat, 'CT_PictureFormat');
/**
 * @hidden
 */
export class CT_PictureStackUnit extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PictureStackUnit.$t = markType(CT_PictureStackUnit, 'CT_PictureStackUnit');
/**
 * @hidden
 */
export class CT_DLblPos extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_DLblPos_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_DLblPos_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DLblPos.$t = markType(CT_DLblPos, 'CT_DLblPos');
/**
 * @hidden
 */
export class CT_Trendline extends Base {
    constructor() {
        super();
        this.x = null;
        this.t = null;
        this.r = null;
        this.l = null;
        this.n = null;
        this.h = null;
        this.f = null;
        this.j = null;
        this.d = null;
        this.b = null;
        this.p = null;
        this.v = null;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1045:
                this.w = typeCast(String_$type, b);
                break;
            case 1570:
                this.s = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1770:
                this.q = typeCast(CT_TrendlineType.$, b);
                break;
            case 1135:
                this.k = typeCast(CT_Order.$, b);
                break;
            case 1178:
                this.m = typeCast(CT_Period.$, b);
                break;
            case 681:
                this.g = typeCast(CT_Double.$, b);
                break;
            case 91:
                this.e = typeCast(CT_Double.$, b);
                break;
            case 840:
                this.i = typeCast(CT_Double.$, b);
                break;
            case 490:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 489:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1769:
                this.o = typeCast(CT_TrendlineLbl.$, b);
                break;
            case 601:
                this.u = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Trendline.$t = markType(CT_Trendline, 'CT_Trendline', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TrendlineType extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_TrendlineType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_TrendlineType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TrendlineType.$t = markType(CT_TrendlineType, 'CT_TrendlineType');
/**
 * @hidden
 */
export class CT_Order extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Order.$t = markType(CT_Order, 'CT_Order');
/**
 * @hidden
 */
export class CT_Period extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Period.$t = markType(CT_Period, 'CT_Period');
/**
 * @hidden
 */
export class CT_TrendlineLbl extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.d = null;
        this.h = null;
        this.j = null;
        this.l = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 876:
                this.a = typeCast(CT_Layout.$, b);
                break;
            case 1776:
                this.e = typeCast(CT_Tx.$, b);
                break;
            case 1088:
                this.c = typeCast(CT_NumFmt_Chart.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.i = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TrendlineLbl.$t = markType(CT_TrendlineLbl, 'CT_TrendlineLbl', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ErrBars extends Base {
    constructor() {
        super();
        this.h = null;
        this.f = null;
        this.j = null;
        this.b = null;
        this.n = null;
        this.l = null;
        this.d = null;
        this.p = null;
        this.r = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 591:
                this.g = typeCast(CT_ErrDir.$, b);
                break;
            case 589:
                this.e = typeCast(CT_ErrBarType.$, b);
                break;
            case 592:
                this.i = typeCast(CT_ErrValType.$, b);
                break;
            case 1061:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1239:
                this.m = typeCast(CT_NumDataSource.$, b);
                break;
            case 1016:
                this.k = typeCast(CT_NumDataSource.$, b);
                break;
            case 1821:
                this.c = typeCast(CT_Double.$, b);
                break;
            case 1570:
                this.o = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.q = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ErrBars.$t = markType(CT_ErrBars, 'CT_ErrBars', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ErrDir extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_ErrDir_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_ErrDir_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ErrDir.$t = markType(CT_ErrDir, 'CT_ErrDir');
/**
 * @hidden
 */
export class CT_ErrBarType extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_ErrBarType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_ErrBarType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ErrBarType.$t = markType(CT_ErrBarType, 'CT_ErrBarType');
/**
 * @hidden
 */
export class CT_ErrValType extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_ErrValType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_ErrValType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ErrValType.$t = markType(CT_ErrValType, 'CT_ErrValType');
/**
 * @hidden
 */
export class CT_NumDataSource extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = null;
        this.a = null;
    }
    get item() {
        return this.d;
    }
    set item(a) {
        this.d = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1095:
                this.b = typeCast(CT_NumRef.$, b);
                break;
            case 1092:
                this.a = typeCast(CT_NumData.$, b);
                break;
            default: break;
        }
    }
}
CT_NumDataSource.$t = markType(CT_NumDataSource, 'CT_NumDataSource', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumData extends Base {
    constructor() {
        super();
        this.h = null;
        this.b = null;
        this.f = null;
        this.d = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 673:
                this.g = typeCast(String_$type, b);
                break;
            case 1278:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1277:
                this.e.add(typeCast(CT_NumVal.$, b));
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getIndexAndValue(a, b, c) {
        let d = typeCast(CT_NumVal.$, a);
        b = d.f;
        c = d.d;
        return {
            p1: b,
            p2: c
        };
    }
    getValues() {
        let a = CT_StrData.a(this, this.a, this.e);
        let b = new List$1(Base.$, 2, a.length);
        for (let d = 0; d < a.length; d++) {
            let c = a[d];
            let e = typeCast(String_$type, c);
            let f = 0;
            let g = tryParseNumber(e, f);
            f = g.p1;
            b.add1(f);
        }
        a = b.toArray();
        return a;
    }
}
CT_NumData.$t = markType(CT_NumData, 'CT_NumData', Base.$, [ISupportSetProperty_$type, IProvideXValuesData_$type]);
/**
 * @hidden
 */
export class CT_NumVal extends Base {
    constructor() {
        super(...arguments);
        this.e = null;
        this.g = 0;
        this.b = null;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static h(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "formatCode":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c, d) {
        a.ad.p(b, "c");
        let e = null;
        let f = null;
        if (c != null) {
            f = "formatCode";
            e = c;
            a.ad.h(f, e);
        }
        f = "idx";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1818:
                this.d = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumVal.$t = markType(CT_NumVal, 'CT_NumVal', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumRef extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.d = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.e = typeCast(String_$type, b);
                break;
            case 1086:
                this.a = typeCast(CT_NumData.$, b);
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumRef.$t = markType(CT_NumRef, 'CT_NumRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AxDataSource extends Base {
    constructor() {
        super(...arguments);
        this.g = null;
        this.a = null;
        this.c = null;
        this.b = null;
        this.e = null;
        this.d = null;
    }
    get item() {
        return this.g;
    }
    set item(a) {
        this.g = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1043:
                this.a = typeCast(CT_MultiLvlStrRef.$, b);
                break;
            case 1095:
                this.c = typeCast(CT_NumRef.$, b);
                break;
            case 1092:
                this.b = typeCast(CT_NumData.$, b);
                break;
            case 1606:
                this.e = typeCast(CT_StrRef.$, b);
                break;
            case 1605:
                this.d = typeCast(CT_StrData.$, b);
                break;
            default: break;
        }
    }
}
CT_AxDataSource.$t = markType(CT_AxDataSource, 'CT_AxDataSource', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_MultiLvlStrRef extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.d = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.e = typeCast(String_$type, b);
                break;
            case 1042:
                this.a = typeCast(CT_MultiLvlStrData.$, b);
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_MultiLvlStrRef.$t = markType(CT_MultiLvlStrRef, 'CT_MultiLvlStrRef', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export let IChart_$type = new Type(null, 'IChart');
/**
 * @hidden
 */
export class CT_BubbleChart extends Base {
    constructor() {
        super();
        this.f = null;
        this.r = null;
        this.j = null;
        this.b = null;
        this.h = null;
        this.d = null;
        this.l = null;
        this.n = null;
        this.p = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1833:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.q.add(typeCast(CT_BubbleSer.$, b));
                break;
            case 406:
                this.i = typeCast(CT_DLbls.$, b);
                break;
            case 183:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 185:
                this.g = typeCast(CT_BubbleScale.$, b);
                break;
            case 1493:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 1510:
                this.k = typeCast(CT_SizeRepresents.$, b);
                break;
            case 81:
                this.m.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.o = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.a;
        let d = c != null ? c.k : false;
        return d ? 87 : 15;
    }
    get seriesType() {
        return 7;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_BubbleSer.$, this.q);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.e == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.e));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.m;
    }
}
CT_BubbleChart.$t = markType(CT_BubbleChart, 'CT_BubbleChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export let IChart3D_$type = new Type(null, 'IChart3D');
/**
 * @hidden
 */
export class CT_Surface3DChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_SurfaceChartShared();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            case 81:
                this.c.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.b.c(a)) {
                    this.b.f(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.b.a;
        let d = c != null ? c.k : false;
        return d ? 86 : 85;
    }
    get seriesType() {
        return 5;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_SurfaceSer.$, this.b.d);
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    get axisIds() {
        return this.c;
    }
}
CT_Surface3DChart.$t = markType(CT_Surface3DChart, 'CT_Surface3DChart', Base.$, [ISupportSetProperty_$type, IChart_$type, IChart3D_$type]);
/**
 * @hidden
 */
export class CT_SurfaceSer extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.i = null;
        this.e = null;
        this.g = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_SerShared();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 229:
                this.a = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.c = typeCast(CT_NumDataSource.$, b);
                break;
            case 601:
                this.h = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.f.e(a)) {
                    this.f.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.g;
    }
    get seriesType() {
        return 5;
    }
    get sharedProps() {
        return this.f;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.c;
    }
    get cT_AxDataSource() {
        return this.a;
    }
    get cT_Marker() {
        return null;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.f.a.g;
    }
    getTrendlines() {
        return null;
    }
    getDLbls(a) {
        a = null;
        return {
            ret: null,
            p0: a
        };
    }
    getDataPoints() {
        return null;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.f);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.g.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_SurfaceSer.$t = markType(CT_SurfaceSer, 'CT_SurfaceSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_BandFmt extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1570:
                this.c = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BandFmt.$t = markType(CT_BandFmt, 'CT_BandFmt', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_SurfaceChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_SurfaceChartShared();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            case 81:
                this.c.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.b.c(a)) {
                    this.b.f(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.b.a;
        let d = c != null ? c.k : false;
        return d ? 84 : 83;
    }
    get seriesType() {
        return 5;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_SurfaceSer.$, this.b.d);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.c;
    }
}
CT_SurfaceChart.$t = markType(CT_SurfaceChart, 'CT_SurfaceChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_SecondPieSize extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SecondPieSize.$t = markType(CT_SecondPieSize, 'CT_SecondPieSize');
/**
 * @hidden
 */
export class CT_SplitType extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SplitType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_SplitType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SplitType.$t = markType(CT_SplitType, 'CT_SplitType');
/**
 * @hidden
 */
export class CT_OfPieType extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_OfPieType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_OfPieType_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_OfPieType.$t = markType(CT_OfPieType, 'CT_OfPieType');
/**
 * @hidden
 */
export class CT_OfPieChart extends Base {
    constructor() {
        super();
        this.f = null;
        this.d = null;
        this.j = null;
        this.b = null;
        this.n = null;
        this.h = null;
        this.r = null;
        this.p = null;
        this.k = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get l() {
        if (this.k == null) {
            this.k = new EG_PieChartShared();
        }
        return this.k;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1122:
                this.e = typeCast(CT_OfPieType.$, b);
                break;
            case 697:
                this.c = typeCast(CT_GapAmount.$, b);
                break;
            case 1582:
                this.i = typeCast(CT_SplitType.$, b);
                break;
            case 1581:
                this.a = typeCast(CT_Double.$, b);
                break;
            case 374:
                let c = typeCast(CT_CustSplit.$, b);
                if (this.m == null) {
                    this.m = new List$1(CT_UnsignedInt.$, 0);
                }
                for (let d of fromEnum(c.a)) {
                    this.m.add(d);
                }
                break;
            case 1439:
                this.g = typeCast(CT_SecondPieSize.$, b);
                break;
            case 1448:
                this.q.add(typeCast(CT_ChartLines.$, b));
                break;
            case 601:
                this.o = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.l.c(a)) {
                    this.l.f(a, b);
                    return;
                }
                break;
        }
    }
    getChartType(a, b) {
        let c = this.e;
        let d = c != null ? c.b : 0;
        switch (d) {
            case 1: return 71;
            case 0: break;
        }
        return 68;
    }
    get seriesType() {
        return 3;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_PieSer.$, this.l.d);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return this.q != null && this.q.count > 0 ? this.q._inner[0] : null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.l.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.l.a));
    }
    getGap(a, b) {
        a = null;
        b = this.c;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return null;
    }
}
CT_OfPieChart.$t = markType(CT_OfPieChart, 'CT_OfPieChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_PieSer extends Base {
    constructor() {
        super();
        this.b = null;
        this.m = null;
        this.f = null;
        this.d = null;
        this.h = null;
        this.o = null;
        this.i = null;
        this.k = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_SerShared();
        }
        return this.i;
    }
    setProperty(a, b) {
        switch (a) {
            case 598:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 408:
                this.l.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.e = typeCast(CT_DLbls.$, b);
                break;
            case 229:
                this.c = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.g = typeCast(CT_NumDataSource.$, b);
                break;
            case 601:
                this.n = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.j.e(a)) {
                    this.j.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.k;
    }
    get seriesType() {
        return 3;
    }
    get sharedProps() {
        return this.j;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.g;
    }
    get cT_AxDataSource() {
        return this.c;
    }
    get cT_Marker() {
        return null;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return this.a;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.j.a.g;
    }
    getTrendlines() {
        return null;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.n));
        return {
            ret: this.e,
            p0: a
        };
    }
    getDataPoints() {
        return this.l;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.j);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.k.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_PieSer.$t = markType(CT_PieSer, 'CT_PieSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_GapAmount extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GapAmount.$t = markType(CT_GapAmount, 'CT_GapAmount');
/**
 * @hidden
 */
export class CT_Bar3DChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.f = null;
        this.j = null;
        this.l = null;
        this.g = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get h() {
        if (this.g == null) {
            this.g = new EG_BarChartShared();
        }
        return this.g;
    }
    setProperty(a, b) {
        switch (a) {
            case 697:
                this.c = typeCast(CT_GapAmount.$, b);
                break;
            case 696:
                this.a = typeCast(CT_GapAmount.$, b);
                break;
            case 1461:
                this.e = typeCast(CT_Shape_Chart.$, b);
                break;
            case 81:
                this.i.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.h.e(a)) {
                    this.h.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.h;
        let d = c != null ? c.c : null;
        let e = c == null ? 2 : d.b;
        let f = this.e;
        let g = f != null ? Nullable$1.toNullable(ST_Shape_$type, f.b) : Nullable$1.toNullable(ST_Shape_$type, null);
        let h = this.h.b;
        let i = h != null ? Nullable$1.toNullable(ST_BarDir_$type, h.b) : Nullable$1.toNullable(ST_BarDir_$type, null);
        let j = i.hasValue && i.value == 1;
        switch (e) {
            case 1:
                if (g.hasValue) {
                    switch (g.value) {
                        case 2: return j ? 54 : 60;
                        case 0:
                        case 1: return j ? 99 : 102;
                        case 4:
                        case 5: return j ? 106 : 109;
                        case 3: return j ? 92 : 95;
                    }
                }
                else {
                    return j ? 54 : 60;
                }
                break;
            case 3:
                if (g.hasValue) {
                    switch (g.value) {
                        case 2: return j ? 55 : 61;
                        case 0:
                        case 1: return j ? 100 : 103;
                        case 4:
                        case 5: return j ? 107 : 110;
                        case 3: return j ? 93 : 96;
                    }
                }
                else {
                    return j ? 55 : 61;
                }
                break;
            case 0:
                if (g.hasValue) {
                    switch (g.value) {
                        case 2: return j ? 56 : 62;
                        case 0:
                        case 1: return j ? 101 : 104;
                        case 4:
                        case 5: return j ? 108 : 111;
                        case 3: return j ? 94 : 97;
                    }
                }
                else {
                    return j ? 56 : 62;
                }
                break;
            case 2:
                if (g.hasValue) {
                    switch (g.value) {
                        case 2: return j ? -4100 : 61;
                        case 0:
                        case 1:
                            if (j) {
                                return 105;
                            }
                            break;
                        case 4:
                        case 5:
                            if (j) {
                                return 112;
                            }
                            break;
                        case 3:
                            if (j) {
                                return 98;
                            }
                            break;
                    }
                }
                else {
                    return j ? 56 : 62;
                }
                break;
        }
        return j ? 55 : 61;
    }
    get seriesType() {
        return 1;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return this.e != null ? Nullable$1.toNullable(ST_Shape_$type, this.e.b) : Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_BarSer.$, this.h.f);
    }
    getGap(a, b) {
        a = this.a;
        b = this.c;
        return {
            p0: a,
            p1: b
        };
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.h.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.h.a));
    }
    get axisIds() {
        return this.i;
    }
}
CT_Bar3DChart.$t = markType(CT_Bar3DChart, 'CT_Bar3DChart', Base.$, [ISupportSetProperty_$type, IChart_$type, IChart3D_$type]);
/**
 * @hidden
 */
export class CT_BarDir extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_BarDir_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_BarDir_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BarDir.$t = markType(CT_BarDir, 'CT_BarDir');
/**
 * @hidden
 */
export class CT_BarGrouping extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_BarGrouping_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_BarGrouping_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BarGrouping.$t = markType(CT_BarGrouping, 'CT_BarGrouping');
/**
 * @hidden
 */
export class CT_BarSer extends Base {
    constructor() {
        super();
        this.b = null;
        this.l = null;
        this.s = null;
        this.f = null;
        this.w = null;
        this.h = null;
        this.d = null;
        this.j = null;
        this.n = null;
        this.u = null;
        this.o = null;
        this.q = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get p() {
        if (this.o == null) {
            this.o = new EG_SerShared();
        }
        return this.o;
    }
    setProperty(a, b) {
        switch (a) {
            case 848:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1199:
                this.k = typeCast(CT_PictureOptions.$, b);
                break;
            case 408:
                this.r.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.e = typeCast(CT_DLbls.$, b);
                break;
            case 1767:
                this.v.add(typeCast(CT_Trendline.$, b));
                break;
            case 590:
                this.g = typeCast(CT_ErrBars.$, b);
                break;
            case 229:
                this.c = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.i = typeCast(CT_NumDataSource.$, b);
                break;
            case 1461:
                this.m = typeCast(CT_Shape_Chart.$, b);
                break;
            case 601:
                this.t = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.p.e(a)) {
                    this.p.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.q;
    }
    get seriesType() {
        return 1;
    }
    get sharedProps() {
        return this.p;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return this.g != null ? this.g : null;
    }
    get invertIfNegativeValue() {
        return this.a != null && this.a.k;
    }
    get cT_NumDataSource() {
        return this.i;
    }
    get cT_AxDataSource() {
        return this.c;
    }
    get cT_Marker() {
        return null;
    }
    get cT_PictureOptions() {
        return this.k;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.p.a.g;
    }
    getTrendlines() {
        return this.v;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.t));
        return {
            ret: this.e,
            p0: a
        };
    }
    getDataPoints() {
        return this.r;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.p);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.q.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_BarSer.$t = markType(CT_BarSer, 'CT_BarSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_Shape_Chart extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_Shape_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_Shape_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Shape_Chart.$t = markType(CT_Shape_Chart, 'CT_Shape_Chart');
/**
 * @hidden
 */
export class CT_Overlap extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Overlap.$t = markType(CT_Overlap, 'CT_Overlap');
/**
 * @hidden
 */
export class CT_BarChart extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.l = null;
        this.h = null;
        this.j = null;
        this.e = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_BarChartShared();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 697:
                this.a = typeCast(CT_GapAmount.$, b);
                break;
            case 1149:
                this.c = typeCast(CT_Overlap.$, b);
                break;
            case 1448:
                this.k.add(typeCast(CT_ChartLines.$, b));
                break;
            case 81:
                this.g.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.i = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.f.e(a)) {
                    this.f.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = a != null && a.f != null && a.f.k != null ? a.f.k.ac : null;
        if (c != null) {
            let d = typeCast(IChart_$type, c);
            return d.getChartType(a, b);
        }
        let e = this.f;
        let f = e != null ? e.c : null;
        let g = e == null ? 2 : f.b;
        let h = this.f.b;
        let i = h != null ? Nullable$1.toNullable(ST_BarDir_$type, h.b) : Nullable$1.toNullable(ST_BarDir_$type, null);
        let j = i.hasValue && i.value == 1;
        switch (g) {
            case 1: return j ? 51 : 57;
            case 3: return j ? 52 : 58;
            case 0: return j ? 53 : 59;
            case 2: break;
        }
        return 58;
    }
    get seriesType() {
        return 1;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_BarSer.$, this.f.f);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return this.k != null && this.k.count > 0 ? this.k._inner[0] : null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return this.c != null ? Nullable$1.toNullable(Number_$type, this.c.b) : Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.f.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.f.a));
    }
    getGap(a, b) {
        a = null;
        b = this.a;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.g;
    }
}
CT_BarChart.$t = markType(CT_BarChart, 'CT_BarChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_HoleSize extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_HoleSize.$t = markType(CT_HoleSize, 'CT_HoleSize');
/**
 * @hidden
 */
export class CT_DoughnutChart extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.h = null;
        this.e = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_PieChartShared();
        }
        return this.e;
    }
    setProperty(a, b) {
        switch (a) {
            case 647:
                this.a = typeCast(CT_FirstSliceAng.$, b);
                break;
            case 794:
                this.c = typeCast(CT_HoleSize.$, b);
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.f.c(a)) {
                    this.f.f(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.f.d.count > 0 ? this.f.d._inner[0] : null;
        let d = c != null ? c.a : null;
        return d != null && d.g != 0 ? 80 : -4120;
    }
    get seriesType() {
        return 3;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_PieSer.$, this.f.d);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        if (this.c != null) {
            return Nullable$1.toNullable(Number_$type, this.c.b);
        }
        else {
            return Nullable$1.toNullable(Number_$type, null);
        }
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        if (this.a != null) {
            return Nullable$1.toNullable(Number_$type, this.a.c);
        }
        else {
            return Nullable$1.toNullable(Number_$type, null);
        }
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.f.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.f.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return null;
    }
}
CT_DoughnutChart.$t = markType(CT_DoughnutChart, 'CT_DoughnutChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_FirstSliceAng extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FirstSliceAng.$t = markType(CT_FirstSliceAng, 'CT_FirstSliceAng');
/**
 * @hidden
 */
export class CT_Pie3DChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_PieChartShared();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.b.c(a)) {
                    this.b.f(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.b.d.count > 0 ? this.b.d._inner[0] : null;
        let d = c != null ? c.a : null;
        return d != null && d.g != 0 ? 70 : -4102;
    }
    get seriesType() {
        return 3;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_PieSer.$, this.b.d);
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.b.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.b.a));
    }
    get axisIds() {
        return null;
    }
}
CT_Pie3DChart.$t = markType(CT_Pie3DChart, 'CT_Pie3DChart', Base.$, [ISupportSetProperty_$type, IChart_$type, IChart3D_$type]);
/**
 * @hidden
 */
export class CT_PieChart extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.c = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_PieChartShared();
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 647:
                this.a = typeCast(CT_FirstSliceAng.$, b);
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.d.c(a)) {
                    this.d.f(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.d.d.count > 0 ? this.d.d._inner[0] : null;
        let d = c != null ? c.a : null;
        return d != null && d.g != 0 ? 69 : 5;
    }
    get seriesType() {
        return 3;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_PieSer.$, this.d.d);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        if (this.a != null) {
            return Nullable$1.toNullable(Number_$type, this.a.c);
        }
        else {
            return Nullable$1.toNullable(Number_$type, null);
        }
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.d.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.d.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return null;
    }
}
CT_PieChart.$t = markType(CT_PieChart, 'CT_PieChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_ScatterSer extends Base {
    constructor() {
        super();
        this.h = null;
        this.o = null;
        this.f = null;
        this.u = null;
        this.q = null;
        this.d = null;
        this.j = null;
        this.b = null;
        this.s = null;
        this.k = null;
        this.m = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get l() {
        if (this.k == null) {
            this.k = new EG_SerShared();
        }
        return this.k;
    }
    setProperty(a, b) {
        switch (a) {
            case 979:
                this.g = typeCast(CT_Marker_Chart.$, b);
                break;
            case 408:
                this.n.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.e = typeCast(CT_DLbls.$, b);
                break;
            case 1767:
                this.t.add(typeCast(CT_Trendline.$, b));
                break;
            case 590:
                this.p.add(typeCast(CT_ErrBars.$, b));
                break;
            case 1890:
                this.c = typeCast(CT_AxDataSource.$, b);
                break;
            case 1898:
                this.i = typeCast(CT_NumDataSource.$, b);
                break;
            case 1547:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.r = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.l.e(a)) {
                    this.l.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.m;
    }
    get seriesType() {
        return 6;
    }
    get sharedProps() {
        return this.l;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return this.p != null && this.p.count > 0 ? this.p._inner[0] : null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.i;
    }
    get cT_AxDataSource() {
        return this.c;
    }
    get cT_Marker() {
        return this.g;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return this.a;
    }
    get index() {
        return this.l.a.g;
    }
    getTrendlines() {
        return this.t;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.r));
        return {
            ret: this.e,
            p0: a
        };
    }
    getDataPoints() {
        return this.n;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.l);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.m.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_ScatterSer.$t = markType(CT_ScatterSer, 'CT_ScatterSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_ScatterStyle extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_ScatterStyle_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_ScatterStyle_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ScatterStyle.$t = markType(CT_ScatterStyle, 'CT_ScatterStyle');
/**
 * @hidden
 */
export class CT_ScatterChart extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.l = null;
        this.d = null;
        this.h = null;
        this.j = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1420:
                this.e = typeCast(CT_ScatterStyle.$, b);
                break;
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.k.add(typeCast(CT_ScatterSer.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 81:
                this.g.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.i = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.e;
        let d = c != null ? c.b : 0;
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        if (b != null) {
            let g = b.cT_Marker;
            let h = g != null ? g.c : null;
            if (h != null) {
                e = Nullable$1.toNullable(Boolean_$type, h.a != 0);
            }
            f = DMLChartUtils.av(b.sharedProps);
        }
        let i = -4169;
        switch (d) {
            case 1:
                if (e.hasValue && e.value) {
                    i = 74;
                }
                else {
                    i = 75;
                }
                break;
            case 2:
                i = 74;
                break;
            case 4:
                i = 73;
                break;
            case 5:
                let j = DMLChartUtils.al(typeCast(IChart_$type, this));
                i = (j == false) ? 73 : 72;
                break;
            case 3: break;
            case 0: break;
        }
        if (f.hasValue) {
            switch (i) {
                case -4169:
                    if (f.value) {
                        i = 74;
                    }
                    break;
                case 74:
                    if (f.value == false) {
                        i = -4169;
                    }
                    break;
            }
        }
        if (e.hasValue) {
            switch (i) {
                case -4169: break;
                case 74:
                    if (e.hasValue && e.value == false) {
                        i = 75;
                    }
                    break;
                case 75:
                    if (e.hasValue && e.value) {
                        i = 74;
                    }
                    break;
                case 72:
                    if (e.hasValue && e.value == false) {
                        i = 73;
                    }
                    break;
                case 73:
                    if (e.hasValue && e.value) {
                        i = 72;
                    }
                    break;
            }
        }
        return i;
    }
    get seriesType() {
        return 6;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_ScatterSer.$, this.k);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.g;
    }
}
CT_ScatterChart.$t = markType(CT_ScatterChart, 'CT_ScatterChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_RadarSer extends Base {
    constructor() {
        super();
        this.f = null;
        this.m = null;
        this.d = null;
        this.b = null;
        this.h = null;
        this.o = null;
        this.i = null;
        this.k = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_SerShared();
        }
        return this.i;
    }
    setProperty(a, b) {
        switch (a) {
            case 979:
                this.e = typeCast(CT_Marker_Chart.$, b);
                break;
            case 408:
                this.l.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 229:
                this.a = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.g = typeCast(CT_NumDataSource.$, b);
                break;
            case 601:
                this.n = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.j.e(a)) {
                    this.j.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.k;
    }
    get seriesType() {
        return 4;
    }
    get sharedProps() {
        return this.j;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.g;
    }
    get cT_AxDataSource() {
        return this.a;
    }
    get cT_Marker() {
        return this.e;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.j.a.g;
    }
    getTrendlines() {
        return null;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.n));
        return {
            ret: this.c,
            p0: a
        };
    }
    getDataPoints() {
        return this.l;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.j);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.k.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_RadarSer.$t = markType(CT_RadarSer, 'CT_RadarSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_RadarStyle extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_RadarStyle_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_RadarStyle_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RadarStyle.$t = markType(CT_RadarStyle, 'CT_RadarStyle');
/**
 * @hidden
 */
export class CT_RadarChart extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.l = null;
        this.d = null;
        this.h = null;
        this.j = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1314:
                this.e = typeCast(CT_RadarStyle.$, b);
                break;
            case 1833:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1446:
                this.k.add(typeCast(CT_RadarSer.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 81:
                this.g.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.i = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.e;
        let d = c != null ? c.b : 0;
        let e = -4151;
        switch (d) {
            case 2:
                e = 82;
                break;
            case 1:
                e = 81;
                break;
            case 0: break;
        }
        if (b != null) {
            let f = Nullable$1.toNullable(Boolean_$type, null);
            let g = b.cT_Marker;
            let h = g != null ? g.c : null;
            if (h != null) {
                f = Nullable$1.toNullable(Boolean_$type, h.a != 0);
            }
            if (f.hasValue) {
                switch (e) {
                    case -4151:
                        if (f.value) {
                            e = 81;
                        }
                        break;
                    case 81:
                        if (f.value == false) {
                            e = -4151;
                        }
                        break;
                }
            }
        }
        return e;
    }
    get seriesType() {
        return 4;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_RadarSer.$, this.k);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.g;
    }
}
CT_RadarChart.$t = markType(CT_RadarChart, 'CT_RadarChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_StockChart extends Base {
    constructor() {
        super();
        this.n = null;
        this.f = null;
        this.b = null;
        this.d = null;
        this.h = null;
        this.j = null;
        this.l = null;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1446:
                this.m.add(typeCast(CT_LineSer.$, b));
                break;
            case 406:
                this.e = typeCast(CT_DLbls.$, b);
                break;
            case 543:
                this.a = typeCast(CT_ChartLines.$, b);
                break;
            case 780:
                this.c = typeCast(CT_ChartLines.$, b);
                break;
            case 1809:
                this.g = typeCast(CT_UpDownBars.$, b);
                break;
            case 81:
                this.i.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.m.count;
        let d = a != null ? a.f.k.f : null;
        if (d != null) {
            let e = d.f.f.count > 0 ? d.f.f._inner[0] : null;
            if (e != null) {
                c += 1;
            }
            return c == 4 ? 90 : 91;
        }
        return c == 3 ? 88 : 89;
    }
    get seriesType() {
        return 2;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_LineSer.$, this.m);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        return Nullable$1.toNullable(Boolean_$type, null);
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.i;
    }
}
CT_StockChart.$t = markType(CT_StockChart, 'CT_StockChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_LineSer extends Base {
    constructor() {
        super();
        this.j = null;
        this.q = null;
        this.f = null;
        this.u = null;
        this.h = null;
        this.d = null;
        this.l = null;
        this.b = null;
        this.s = null;
        this.m = null;
        this.o = null;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get n() {
        if (this.m == null) {
            this.m = new EG_SerShared();
        }
        return this.m;
    }
    setProperty(a, b) {
        switch (a) {
            case 979:
                this.i = typeCast(CT_Marker_Chart.$, b);
                break;
            case 408:
                this.p.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.e = typeCast(CT_DLbls.$, b);
                break;
            case 1767:
                this.t.add(typeCast(CT_Trendline.$, b));
                break;
            case 590:
                this.g = typeCast(CT_ErrBars.$, b);
                break;
            case 229:
                this.c = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.k = typeCast(CT_NumDataSource.$, b);
                break;
            case 1547:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.r = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.n.e(a)) {
                    this.n.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.o;
    }
    get seriesType() {
        return 2;
    }
    get sharedProps() {
        return this.n;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return this.g != null ? this.g : null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.k;
    }
    get cT_AxDataSource() {
        return this.c;
    }
    get cT_Marker() {
        return this.i;
    }
    get cT_PictureOptions() {
        return null;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return this.a;
    }
    get index() {
        return this.n.a.g;
    }
    getTrendlines() {
        return this.t;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.r));
        return {
            ret: this.e,
            p0: a
        };
    }
    getDataPoints() {
        return this.p;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.n);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.o.getChartType(null, this);
        }
        if (WorksheetChart._gk(a)) {
            return a;
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_LineSer.$t = markType(CT_LineSer, 'CT_LineSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_UpDownBars extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.d = null;
        this.h = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 697:
                this.a = typeCast(CT_GapAmount.$, b);
                break;
            case 1808:
                this.e = typeCast(CT_UpDownBar.$, b);
                break;
            case 536:
                this.c = typeCast(CT_UpDownBar.$, b);
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_UpDownBars.$t = markType(CT_UpDownBars, 'CT_UpDownBars', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_UpDownBar extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_UpDownBar.$t = markType(CT_UpDownBar, 'CT_UpDownBar', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Line3DChart extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.h = null;
        this.c = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_LineChartShared();
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 696:
                this.a = typeCast(CT_GapAmount.$, b);
                break;
            case 81:
                this.e.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.d.e(a)) {
                    this.d.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        return -4101;
    }
    get seriesType() {
        return 2;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_LineSer.$, this.d.f);
    }
    getGap(a, b) {
        a = this.a;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.d.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.d.a));
    }
    get axisIds() {
        return this.e;
    }
}
CT_Line3DChart.$t = markType(CT_Line3DChart, 'CT_Line3DChart', Base.$, [ISupportSetProperty_$type, IChart_$type, IChart3D_$type]);
/**
 * @hidden
 */
export class CT_Grouping extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_Grouping_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_Grouping_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Grouping.$t = markType(CT_Grouping, 'CT_Grouping');
/**
 * @hidden
 */
export class CT_LineChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.h = null;
        this.f = null;
        this.b = null;
        this.l = null;
        this.n = null;
        this.i = null;
        this.o = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_LineChartShared();
        }
        return this.i;
    }
    setProperty(a, b) {
        switch (a) {
            case 780:
                this.c = typeCast(CT_ChartLines.$, b);
                break;
            case 1809:
                this.g = typeCast(CT_UpDownBars.$, b);
                break;
            case 979:
                this.e = typeCast(CT_Marker_Chart.$, b);
                break;
            case 1547:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 81:
                this.k.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.m = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.j.e(a)) {
                    this.j.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.j;
        let d = c != null ? c.d : null;
        let e = this.e;
        let f = e != null ? e.c : null;
        let g = f != null ? f.a : 0;
        let h = this.o.hasValue ? this.o.value : e == null ? false : g != 0;
        if (b != null) {
            let i = b.cT_Marker;
            let j = i != null ? i.c : null;
            let k = j != null && j.a == 0;
            let l = j == null || j.a != 0;
            if (k) {
                h = false;
            }
            if (h == false && l) {
                h = true;
            }
        }
        if (d == null) {
            return h ? 4 : 65;
        }
        switch (d.b) {
            case 2: return h == false ? 63 : 66;
            case 0: return h == false ? 64 : 67;
            default: return h == false ? 4 : 65;
        }
    }
    get seriesType() {
        return 2;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_LineSer.$, this.j.f);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.j.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.j.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.k;
    }
}
CT_LineChart.$t = markType(CT_LineChart, 'CT_LineChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_Area3DChart extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.h = null;
        this.c = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_AreaChartShared();
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 696:
                this.a = typeCast(CT_GapAmount.$, b);
                break;
            case 81:
                this.e.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.d.e(a)) {
                    this.d.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.d;
        let d = c != null ? c.d : null;
        if (d == null) {
            return -4098;
        }
        switch (d.b) {
            case 2: return 78;
            case 0: return 79;
            default: return -4098;
        }
    }
    get seriesType() {
        return 0;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_AreaSer.$, this.d.f);
    }
    getGap(a, b) {
        a = this.a;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.d.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.d.a));
    }
    get axisIds() {
        return this.e;
    }
}
CT_Area3DChart.$t = markType(CT_Area3DChart, 'CT_Area3DChart', Base.$, [ISupportSetProperty_$type, IChart_$type, IChart3D_$type]);
/**
 * @hidden
 */
export class CT_AreaSer extends Base {
    constructor() {
        super();
        this.h = null;
        this.m = null;
        this.d = null;
        this.s = null;
        this.o = null;
        this.b = null;
        this.f = null;
        this.q = null;
        this.i = null;
        this.k = null;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get j() {
        if (this.i == null) {
            this.i = new EG_SerShared();
        }
        return this.i;
    }
    setProperty(a, b) {
        switch (a) {
            case 1199:
                this.g = typeCast(CT_PictureOptions.$, b);
                break;
            case 408:
                this.l.add(typeCast(CT_DPt.$, b));
                break;
            case 406:
                this.c = typeCast(CT_DLbls.$, b);
                break;
            case 1767:
                this.r.add(typeCast(CT_Trendline.$, b));
                break;
            case 590:
                this.n.add(typeCast(CT_ErrBars.$, b));
                break;
            case 229:
                this.a = typeCast(CT_AxDataSource.$, b);
                break;
            case 1821:
                this.e = typeCast(CT_NumDataSource.$, b);
                break;
            case 601:
                this.p = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.j.e(a)) {
                    this.j.g(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get chart() {
        return this.k;
    }
    get seriesType() {
        return 0;
    }
    get sharedProps() {
        return this.j;
    }
    getBubbleSizes(a, b) {
        return null;
    }
    get cT_ErrBars() {
        return this.n != null && this.n.count > 0 ? this.n._inner[0] : null;
    }
    get invertIfNegativeValue() {
        return false;
    }
    get cT_NumDataSource() {
        return this.e;
    }
    get cT_AxDataSource() {
        return this.a;
    }
    get cT_Marker() {
        return null;
    }
    get cT_PictureOptions() {
        return this.g;
    }
    getExplosion() {
        return null;
    }
    getSmooth() {
        return null;
    }
    get index() {
        return this.j.a.g;
    }
    getTrendlines() {
        return this.r;
    }
    getDLbls(a) {
        a = CT_Extension_DataLabelsRange.f(CT_ExtensionList.a(this.p));
        return {
            ret: this.c,
            p0: a
        };
    }
    getDataPoints() {
        return this.l;
    }
    get isExplicitlyNoFill() {
        return DMLChartUtils.ao(this.j);
    }
    get isBubble3D() {
        return false;
    }
    getSeriesChartType(a, b) {
        if (a == 113) {
            return this.k.getChartType(null, this);
        }
        if (WorksheetChart._f5(a)) {
            return WorksheetChart._e5(b);
        }
        return a;
    }
}
CT_AreaSer.$t = markType(CT_AreaSer, 'CT_AreaSer', Base.$, [ISupportSetProperty_$type, ISeries_$type]);
/**
 * @hidden
 */
export class CT_AreaChart extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_AreaChartShared();
        }
        return this.a;
    }
    setProperty(a, b) {
        switch (a) {
            case 81:
                this.c.add(typeCast(CT_UnsignedInt.$, b));
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                if (this.b.e(a)) {
                    this.b.h(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    getChartType(a, b) {
        let c = this.b;
        let d = c != null ? c.d : null;
        if (d == null) {
            return 1;
        }
        switch (d.b) {
            case 2: return 76;
            case 0: return 77;
            default: return 1;
        }
    }
    get seriesType() {
        return 0;
    }
    get sT_Shape() {
        return unwrapNullable(this._sT_Shape$i);
    }
    get _sT_Shape$i() {
        return Nullable$1.toNullable(ST_Shape_$type, null);
    }
    getSeries() {
        return DMLChartUtils.aq(CT_AreaSer.$, this.b.f);
    }
    getHoleSize() {
        return unwrapNullable(this._getHoleSize$i.apply(this, arguments));
    }
    _getHoleSize$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getFirstSliceAngle() {
        return unwrapNullable(this._getFirstSliceAngle$i.apply(this, arguments));
    }
    _getFirstSliceAngle$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getSerLines() {
        return null;
    }
    getOverlap() {
        return unwrapNullable(this._getOverlap$i.apply(this, arguments));
    }
    _getOverlap$i() {
        return Nullable$1.toNullable(Number_$type, null);
    }
    getVaryColors() {
        return unwrapNullable(this._getVaryColors$i.apply(this, arguments));
    }
    _getVaryColors$i() {
        if (this.b.a == null) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.b.a));
    }
    getGap(a, b) {
        a = null;
        b = null;
        return {
            p0: a,
            p1: b
        };
    }
    get axisIds() {
        return this.c;
    }
}
CT_AreaChart.$t = markType(CT_AreaChart, 'CT_AreaChart', Base.$, [ISupportSetProperty_$type, IChart_$type]);
/**
 * @hidden
 */
export class CT_Surface extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.d = null;
        this.h = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1722:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1570:
                this.e = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1199:
                this.c = typeCast(CT_PictureOptions.$, b);
                break;
            case 601:
                this.g = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Surface.$t = markType(CT_Surface, 'CT_Surface', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Perspective extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Perspective.$t = markType(CT_Perspective, 'CT_Perspective');
/**
 * @hidden
 */
export class CT_DepthPercent extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DepthPercent.$t = markType(CT_DepthPercent, 'CT_DepthPercent');
/**
 * @hidden
 */
export class CT_RotY extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RotY.$t = markType(CT_RotY, 'CT_RotY');
/**
 * @hidden
 */
export class CT_HPercent extends Base {
    constructor() {
        super();
        this.d = 0;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt16_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_HPercent.$t = markType(CT_HPercent, 'CT_HPercent');
/**
 * @hidden
 */
export class CT_RotX extends Base {
    constructor() {
        super();
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RotX.$t = markType(CT_RotX, 'CT_RotX');
/**
 * @hidden
 */
export class CT_View3D extends Base {
    constructor() {
        super();
        this.j = null;
        this.f = null;
        this.l = null;
        this.d = null;
        this.b = null;
        this.h = null;
        this.n = null;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1371:
                this.i = typeCast(CT_RotX.$, b);
                break;
            case 765:
                this.e = typeCast(CT_HPercent.$, b);
                break;
            case 1372:
                this.k = typeCast(CT_RotY.$, b);
                break;
            case 471:
                this.c = typeCast(CT_DepthPercent.$, b);
                break;
            case 1300:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1183:
                this.g = typeCast(CT_Perspective.$, b);
                break;
            case 601:
                this.m = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_View3D.$t = markType(CT_View3D, 'CT_View3D', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotFmt extends Base {
    constructor() {
        super();
        this.b = null;
        this.h = null;
        this.j = null;
        this.f = null;
        this.d = null;
        this.l = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 1570:
                this.g = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.i = typeCast(CT_TextBody_DML.$, b);
                break;
            case 979:
                this.e = typeCast(CT_Marker_Chart.$, b);
                break;
            case 401:
                this.c = typeCast(CT_DLbl.$, b);
                break;
            case 601:
                this.k = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PivotFmt.$t = markType(CT_PivotFmt, 'CT_PivotFmt', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Chart extends Base {
    constructor() {
        super();
        this.t = null;
        this.b = null;
        this.z = null;
        this.v = null;
        this.p = null;
        this.r = null;
        this.n = null;
        this.l = null;
        this.j = null;
        this.d = null;
        this.h = null;
        this.f = null;
        this.x = null;
    }
    get s() {
        return this.t;
    }
    set s(a) {
        this.t = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get q() {
        return this.r;
    }
    set q(a) {
        this.r = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1745:
                this.s = typeCast(CT_Title.$, b);
                break;
            case 78:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 1218:
                if (this.y == null) {
                    this.y = new List$1(CT_PivotFmt.$, 0);
                }
                this.y.add(typeCast(CT_PivotFmt.$, b));
                break;
            case 1841:
                this.u = typeCast(CT_View3D.$, b);
                break;
            case 654:
                this.o = typeCast(CT_Surface.$, b);
                break;
            case 1503:
                this.q = typeCast(CT_Surface.$, b);
                break;
            case 88:
                this.m = typeCast(CT_Surface.$, b);
                break;
            case 1235:
                this.k = typeCast(CT_PlotArea.$, b);
                break;
            case 890:
                this.i = typeCast(CT_Legend.$, b);
                break;
            case 1238:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 487:
                this.g = typeCast(CT_DispBlanksAs.$, b);
                break;
            case 1487:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.w = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
}
CT_Chart.$t = markType(CT_Chart, 'CT_Chart', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Protection extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.f = null;
        this.h = null;
        this.j = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 265:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 410:
                this.c = typeCast(CT_Boolean.$, b);
                break;
            case 675:
                this.e = typeCast(CT_Boolean.$, b);
                break;
            case 1442:
                this.g = typeCast(CT_Boolean.$, b);
                break;
            case 1815:
                this.i = typeCast(CT_Boolean.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Protection.$t = markType(CT_Protection, 'CT_Protection', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotSource extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = null;
        this.d = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    setProperty(a, b) {
        switch (a) {
            case 1045:
                this.e = typeCast(String_$type, b);
                break;
            case 655:
                this.a = typeCast(CT_UnsignedInt.$, b);
                break;
            case 601:
                this.c = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default: break;
        }
    }
}
CT_PivotSource.$t = markType(CT_PivotSource, 'CT_PivotSource', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Style extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt8_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Style.$t = markType(CT_Style, 'CT_Style');
/**
 * @hidden
 */
export class CT_TextLanguageID extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "c");
        let d = null;
        let e = null;
        if (c != null) {
            e = "val";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextLanguageID.$t = markType(CT_TextLanguageID, 'CT_TextLanguageID');
/**
 * @hidden
 */
export class CT_Lvl extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1277:
                this.a.add(typeCast(CT_StrVal.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Lvl.$t = markType(CT_Lvl, 'CT_Lvl', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_CustSplit extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1438:
                this.a.add(typeCast(CT_UnsignedInt.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CustSplit.$t = markType(CT_CustSplit, 'CT_CustSplit', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_BandFmts extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 96:
                this.a.add(typeCast(CT_BandFmt.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_BandFmts.$t = markType(CT_BandFmts, 'CT_BandFmts', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PivotFmts extends Base {
    constructor() {
        super();
        this.f = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1217:
                this.e.add(typeCast(CT_PivotFmt.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static c(a) {
        return a != null ? a.e : null;
    }
    static a(a) {
        let b = new CT_PivotFmts();
        b.f = a;
        return b;
    }
}
CT_PivotFmts.$t = markType(CT_PivotFmts, 'CT_PivotFmts', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DLbls extends Base {
    constructor() {
        super();
        this.g = null;
        this.d = null;
        this.a = null;
        this.b = null;
    }
    get f() {
        if (this.g == null) {
            this.g = new List$1(CT_DLbl.$, 0);
        }
        return this.g;
    }
    get e() {
        if (this.d == null) {
            this.d = new Group_DLbls();
        }
        return this.d;
    }
    setProperty(a, b) {
        switch (a) {
            case 467:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 401:
                this.f.add(typeCast(CT_DLbl.$, b));
                break;
            case 601:
                this.b = typeCast(CT_ExtensionList.$, b);
                break;
            default:
                if (this.e.e(a)) {
                    this.e.g(a, b);
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static c(a) {
        let b = null;
        if (a != null) {
            for (let c of fromEnum(a.e)) {
                b = typeCast(CT_Extension_DataLabels.$, c);
                if (b != null) {
                    break;
                }
            }
        }
        return b;
    }
}
CT_DLbls.$t = markType(CT_DLbls, 'CT_DLbls', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DLbl extends Base {
    constructor() {
        super();
        this.c = null;
        this.b = null;
        this.a = null;
        this.e = null;
        this.e = new List$1(CT_Extension.$, 0);
    }
    get d() {
        if (this.c == null) {
            this.c = new Group_DLbl();
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.b = typeCast(CT_UnsignedInt.$, b);
                break;
            case 467:
                this.a = typeCast(CT_Boolean.$, b);
                break;
            case 601:
                this.e = CT_ExtensionList.d(typeCast(CT_ExtensionList.$, b));
                break;
            default:
                this.d.g(a, b);
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DLbl.$t = markType(CT_DLbl, 'CT_DLbl', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PlotArea extends Base {
    constructor() {
        super(...arguments);
        this.ag = null;
        this.ai = null;
        this.l = null;
        this.c = null;
        this.b = null;
        this.n = null;
        this.m = null;
        this.ac = null;
        this.u = null;
        this.y = null;
        this.s = null;
        this.r = null;
        this.i = null;
        this.f = null;
        this.e = null;
        this.p = null;
        this.ae = null;
        this.ad = null;
        this.h = null;
        this.d = null;
        this.o = null;
        this.v = null;
        this.w = null;
        this.x = null;
        this.z = null;
        this.aa = null;
        this.ab = null;
        this.g = null;
        this.t = null;
        this.j = null;
        this.q = null;
        this.k = null;
        this.af = null;
        this.a = null;
    }
    get ah() {
        if (this.ag == null) {
            this.ag = new List$1(IAxis_$type, 2, 4);
        }
        return this.ag;
    }
    get aj() {
        if (this.ai == null) {
            this.ai = new List$1(IChart_$type, 0);
        }
        return this.ai;
    }
    setProperty(a, b) {
        switch (a) {
            case 876:
                this.l = typeCast(CT_Layout.$, b);
                break;
            case 55:
                if (this.c == null) {
                    this.c = typeCast(CT_AreaChart.$, b);
                }
                else if (this.d == null) {
                    this.d = typeCast(CT_AreaChart.$, b);
                }
                break;
            case 54:
                this.b = typeCast(CT_Area3DChart.$, b);
                break;
            case 907:
                if (this.n == null) {
                    this.n = typeCast(CT_LineChart.$, b);
                }
                else if (this.o == null) {
                    this.o = typeCast(CT_LineChart.$, b);
                }
                break;
            case 906:
                this.m = typeCast(CT_Line3DChart.$, b);
                break;
            case 1598:
                this.ac = typeCast(CT_StockChart.$, b);
                break;
            case 1313:
                if (this.u == null) {
                    this.u = typeCast(CT_RadarChart.$, b);
                }
                else if (this.v == null) {
                    this.v = typeCast(CT_RadarChart.$, b);
                }
                else if (this.w == null) {
                    this.w = typeCast(CT_RadarChart.$, b);
                }
                else if (this.x == null) {
                    this.x = typeCast(CT_RadarChart.$, b);
                }
                break;
            case 1419:
                if (this.y == null) {
                    this.y = typeCast(CT_ScatterChart.$, b);
                }
                else if (this.z == null) {
                    this.z = typeCast(CT_ScatterChart.$, b);
                }
                else if (this.aa == null) {
                    this.aa = typeCast(CT_ScatterChart.$, b);
                }
                else if (this.ab == null) {
                    this.ab = typeCast(CT_ScatterChart.$, b);
                }
                break;
            case 1202:
                if (this.s == null) {
                    this.s = typeCast(CT_PieChart.$, b);
                }
                else if (this.t == null) {
                    this.t = typeCast(CT_PieChart.$, b);
                }
                break;
            case 1201:
                this.r = typeCast(CT_Pie3DChart.$, b);
                break;
            case 534:
                if (this.i == null) {
                    this.i = typeCast(CT_DoughnutChart.$, b);
                }
                else if (this.j == null) {
                    this.j = typeCast(CT_DoughnutChart.$, b);
                }
                break;
            case 100:
                if (this.f == null) {
                    this.f = typeCast(CT_BarChart.$, b);
                }
                else if (this.g == null) {
                    this.g = typeCast(CT_BarChart.$, b);
                }
                break;
            case 99:
                this.e = typeCast(CT_Bar3DChart.$, b);
                break;
            case 1121:
                if (this.p == null) {
                    this.p = typeCast(CT_OfPieChart.$, b);
                }
                else if (this.q == null) {
                    this.q = typeCast(CT_OfPieChart.$, b);
                }
                break;
            case 1644:
                this.ae = typeCast(CT_SurfaceChart.$, b);
                break;
            case 1643:
                this.ad = typeCast(CT_Surface3DChart.$, b);
                break;
            case 184:
                this.h = typeCast(CT_BubbleChart.$, b);
                break;
            case 1822:
                this.ah.add(typeCast(CT_ValAx.$, b));
                break;
            case 230:
                this.ah.add(typeCast(CT_CatAx.$, b));
                break;
            case 440:
                this.ah.add(typeCast(CT_DateAx.$, b));
                break;
            case 1447:
                this.ah.add(typeCast(CT_SerAx.$, b));
                break;
            case 409:
                this.k = typeCast(CT_DTable.$, b);
                break;
            case 1570:
                this.af = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PlotArea.$t = markType(CT_PlotArea, 'CT_PlotArea', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_MultiLvlStrData extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.c = null;
        this.a = null;
    }
    get d() {
        if (this.c == null) {
            this.c = new List$1(CT_Lvl.$, 0);
        }
        return this.c;
    }
    setProperty(a, b) {
        switch (a) {
            case 1278:
                this.b = typeCast(CT_UnsignedInt.$, b);
                break;
            case 944:
                let c = typeCast(CT_Lvl.$, b);
                if (c == null) {
                }
                this.d.add(c);
                break;
            case 601:
                this.a = typeCast(CT_ExtensionList.$, b);
                break;
            default: break;
        }
    }
}
CT_MultiLvlStrData.$t = markType(CT_MultiLvlStrData, 'CT_MultiLvlStrData', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Extension_DataLabels extends CT_Extension {
    constructor() {
        super(...arguments);
        this.g = null;
        this.f = null;
        this.h = null;
        this.l = null;
        this.k = null;
        this.j = null;
    }
    static i(a) {
        if (stringEquals1(a, "{CE6537A1-D6FC-4f65-9D91-7224C49458BB}", 3)) {
            return ((() => {
                let $ret = new CT_Extension_DataLabels();
                $ret.b = a;
                return $ret;
            })());
        }
        return null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1486:
                this.g = typeCast(CT_Boolean.$, b);
                break;
            case 1491:
                this.g = typeCast(CT_Boolean.$, b);
                break;
            case 886:
                this.h = typeCast(CT_ChartLines.$, b);
                break;
            case 1570:
                this.l = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1776:
                this.k = typeCast(CT_Tx.$, b);
                break;
            case 876:
                this.j = typeCast(CT_Layout.$, b);
                break;
            default: break;
        }
    }
    d(a, b, c, d) {
        let e = DrawingMLChart.cd;
        CT_Extension_DataLabels.e(a, e, "{CE6537A1-D6FC-4f65-9D91-7224C49458BB}");
        c.l(DrawingMLChart2012.an);
        let f = d == CT_DLbls.$;
        c.p(DrawingMLChart2012.bf, "c15");
        if (this.j != null && this.j.a != null) {
            DMLChartExtensions.b6(this.j.a, a, b, c, DrawingMLChart.dj);
        }
        c.k();
        if (f && (this.h != null || CT_Boolean.g(this.g))) {
            let g = new CT_Boolean(3);
            g.m = Nullable$1.toNullable(Boolean_$type, CT_Boolean.g(this.g));
            g.q(a, b, c, DrawingMLChart2012.bq, "c15");
            if (this.h != null) {
                DMLChartExtensions.bk(this.h, a, b, c, DrawingMLChart2012.bg);
            }
        }
        if (this.f) {
            let h = new CT_Boolean(3);
            h.m = Nullable$1.toNullable(Boolean_$type, true);
            h.q(a, b, c, DrawingMLChart2012.bp, "c15");
        }
        c.k();
    }
}
CT_Extension_DataLabels.$t = markType(CT_Extension_DataLabels, 'CT_Extension_DataLabels', CT_Extension.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Extension_DataLabelsRange extends CT_Extension {
    constructor() {
        super(...arguments);
        this.h = null;
    }
    static g(a) {
        if (stringEquals1(a, "{02D57815-91ED-43cb-92C2-25804820EDAC}", 3)) {
            return ((() => {
                let $ret = new CT_Extension_DataLabelsRange();
                $ret.b = a;
                return $ret;
            })());
        }
        return null;
    }
    setProperty(a, b) {
        switch (a) {
            case 421:
                this.h = typeCast(CT_SeriesDataLabelsRange.$, b);
                break;
            default: break;
        }
    }
    static f(a) {
        if (a == null || a.e == null || a.e.count == 0) {
            return null;
        }
        let b = null;
        for (let c of fromEnum(a.e)) {
            b = typeCast(CT_Extension_DataLabelsRange.$, c);
            if (b != null) {
                break;
            }
        }
        return b;
    }
    d(a, b, c, d) {
        let e = DrawingMLChart.cd;
        CT_Extension_DataLabels.e(a, e, "{02D57815-91ED-43cb-92C2-25804820EDAC}");
        c.l(DrawingMLChart2012.an);
        if (this.h != null) {
            DMLChartExtensions.c7(this.h, a, b, c);
        }
        c.k();
    }
}
CT_Extension_DataLabelsRange.$t = markType(CT_Extension_DataLabelsRange, 'CT_Extension_DataLabelsRange', CT_Extension.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class DMLChartUtils extends Base {
    static ak(a) {
        let b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "id":
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_RelId();
            $ret.a = b;
            return $ret;
        })());
        return d;
    }
    static t(a, b) {
        let c = a != null ? a.b : null;
        return DMLChartUtils.u(c, b);
    }
    static u(a, b) {
        if (a == null || a.d == null) {
            return null;
        }
        let c = new StringBuilder(0);
        let d = new List$1(Array_$type, 0);
        let e = new List$1(String_$type, 0);
        let f = new List$1(CT_TextCharacterProperties_DML.$, 0);
        let g = Environment.newLine;
        let h = 0;
        for (let i of fromEnum(a.d)) {
            for (let j of fromEnum(i.f)) {
                let k = j.a;
                let l = (k == null) ? j.c : null;
                let m = k != null && k.c != null ? k.c.length : l != null ? g.length : 0;
                let n = k != null ? k.c : l != null ? g : null;
                if (m == 0 || stringIsNullOrEmpty(n)) {
                    continue;
                }
                c.l(n);
                d.add([h, m]);
                e.add(n);
                f.add(k != null ? k.a : null);
                h += m;
            }
        }
        if (e.count == 0) {
            return null;
        }
        let o = new FormattedString(c.toString());
        o._owner = b;
        for (let p = 0; p < e.count; p++) {
            let q = d._inner[p];
            let r = o._getFont1(q[0], q[1]);
            DMLChartUtils.a6(r, f._inner[p]);
        }
        return o;
    }
    static k(a, b) {
        if (a == null) {
            return null;
        }
        let c = a.e != null ? a.e.b : 0;
        let d = a.i != null ? a.i.b : 4;
        let e = ((() => {
            let $ret = new ErrorBars();
            $ret.direction = DMLChartExtensions.i(c);
            $ret.errorValueType = DMLChartExtensions.j(d);
            return $ret;
        })());
        let f = a.a;
        e.endStyle = f != null && f.k ? 2 : 1;
        if (a.c != null) {
            e.value = a.c.f;
        }
        let g = a.o;
        let h = g != null ? g.a : null;
        if (h != null) {
            e.fill = DMLChartUtils.d(h.n);
            if (h.h.hasValue) {
                e.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(h.h.value));
            }
        }
        return e;
    }
    static af(a) {
        return DMLChartUtils.ai(a.b);
    }
    static ai(a) {
        if (a.a != null) {
            return DMLChartUtils.ab(a.a);
        }
        else if (a.b != null) {
            return DMLChartUtils.ac(a.b);
        }
        else if (a.c != null) {
            return DMLChartUtils.ad(a.c);
        }
        else if (a.d != null) {
            return DMLChartUtils.ae(a.d);
        }
        else if (a.e != null) {
            return DMLChartUtils.ag(a.e);
        }
        else if (a.f != null) {
            return DMLChartUtils.ah(a.f);
        }
        return null;
    }
    static aj(a, b, c, d = true) {
        let e = c != null ? c.c() : null;
        let f = Nullable$1.toNullable(Number_$type, null);
        if (c != null && c.aa != null) {
            f = Nullable$1.toNullable(Number_$type, ST_Percentage.n(ST_PositiveFixedPercentage.b(c.aa.a)));
            if (d) {
                f = Nullable$1.toNullable(Number_$type, (1 - f.value));
            }
        }
        if (a.hasValue) {
            return e != null ? new WorkbookColorInfo(a.value, e) : f.hasValue ? new WorkbookColorInfo(a.value, f.value) : new WorkbookColorInfo(a.value);
        }
        else if (b.hasValue) {
            return e != null ? new WorkbookColorInfo(b.value, e) : f.hasValue ? new WorkbookColorInfo(b.value, f.value) : new WorkbookColorInfo(b.value);
        }
        return null;
    }
    static ab(a) {
        let b = ExcelUtils.gy(a.f, a.h, a.g);
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, b), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a.b);
    }
    static ac(a) {
        let b = XlsxUtilities.be(a.f);
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, b), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a.b);
    }
    static ad(a) {
        if (a == null) {
            return null;
        }
        let b = XlsxUtilities.ac(a.g);
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, null), Nullable$1.toNullable(WorkbookThemeColorType_$type, b), a.b);
    }
    static ae(a) {
        let b = Color.u(255, a.h, a.g, a.f);
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, b), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a.b);
    }
    static ag(a) {
        let b = a.b.c();
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, a.f.r), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a.b);
    }
    static ah(a) {
        let b = XlsxUtilities.bf(a.f);
        return DMLChartUtils.aj(Nullable$1.toNullable(Color.$, b), Nullable$1.toNullable(WorkbookThemeColorType_$type, null), a.b);
    }
    static a6(a, b) {
        if (b == null) {
            return;
        }
        a._bold$i = XlsxUtilities.a7(b.d);
        a._italic$i = XlsxUtilities.a7(b.i);
        a.underlineStyle = b.s.hasValue == false ? -1 : DMLChartExtensions.z(b.s.value);
        if (b.q.hasValue == false) {
            a._strikeout$i = Nullable$1.toNullable(Boolean_$type, null);
        }
        else {
            a._strikeout$i = Nullable$1.toNullable(Boolean_$type, b.q.value == 0 ? false : true);
        }
        a.name = DMLChartUtils.az(b);
        if (b.ad.c != null) {
            a.colorInfo = DMLChartUtils.af(b.ad.c);
        }
        if (b.r.hasValue) {
            a.height = SerializationUtils.o(b.r.value);
        }
    }
    static a5(a, b) {
        if (b == null || a == null) {
            return;
        }
        a._bold$i = XlsxUtilities.a7(b.d);
        a._italic$i = XlsxUtilities.a7(b.i);
        a.underlineStyle = b.s.hasValue == false ? -1 : DMLChartExtensions.z(b.s.value);
        if (b.q.hasValue == false) {
            a._strikeout$i = Nullable$1.toNullable(Boolean_$type, null);
        }
        else {
            a._strikeout$i = Nullable$1.toNullable(Boolean_$type, b.q.value == 0 ? false : true);
        }
        a.name = DMLChartUtils.az(b);
        if (b.e.hasValue) {
            let c = ST_Percentage.l(b.e.value);
            a.superscriptSubscriptStyle = c < 0 ? 2 : c > 0 ? 1 : 0;
        }
        else {
            a.superscriptSubscriptStyle = -1;
        }
        if (b.ad.c != null) {
            a.colorInfo = DMLChartUtils.af(b.ad.c);
        }
        else {
            a.colorInfo = null;
        }
        if (b.r.hasValue) {
            a.height = SerializationUtils.o(b.r.value);
        }
        else {
            a.height = -1;
        }
    }
    static az(a) {
        let b = DMLChartUtils.a3(a);
        if (stringIsNullOrEmpty(b) == false) {
            return b;
        }
        else if (a.ak != null && stringIsNullOrEmpty(a.ak.d) == false) {
            return a.ak.d;
        }
        else {
            return null;
        }
    }
    static a3(a) {
        if (a.c != null && stringIsNullOrEmpty(a.c.d) == false) {
            return a.c.d;
        }
        else if (a.b != null && stringIsNullOrEmpty(a.b.d) == false) {
            return a.b.d;
        }
        else if (a.a != null && stringIsNullOrEmpty(a.a.d) == false) {
            return a.a.d;
        }
        else {
            return null;
        }
    }
    static e(a) {
        let b = 0;
        if (a.b.b != null && a.b.b.c.hasValue) {
            b = DMLChartExtensions.k(a.b.b.c.value);
        }
        let c = 0;
        if (a.b.a != null && a.b.a.a.hasValue) {
            c = ST_Angle.j(a.b.a.a.value);
        }
        let d = new List$1(GradientStop.$, 2, a.e.count);
        for (let e of fromEnum(a.e)) {
            let f = DMLChartUtils.ai(e.b);
            let g = ST_PositiveFixedPercentage.m(e.d);
            let h = g / 100;
            let i = new GradientStop(f, h);
            d.add(i);
        }
        return new ChartGradientFill(b, d, c);
    }
    static h(a) {
        let b = DMLChartUtils.af(a);
        return new ChartSolidFill(b);
    }
    static b(a) {
        return new ChartEmptyFill();
    }
    static d(a) {
        if (a.e == false) {
            return null;
        }
        if (a.d != null) {
            return DMLChartUtils.b(a.d);
        }
        else if (a.c != null) {
            return DMLChartUtils.h(a.c);
        }
        else if (a.a != null) {
            return DMLChartUtils.e(a.a);
        }
        else {
        }
        return null;
    }
    static c(a) {
        if (a.e == false) {
            return null;
        }
        if (a.d != null) {
            return DMLChartUtils.b(a.d);
        }
        else if (a.c != null) {
            return DMLChartUtils.h(a.c);
        }
        else if (a.a != null) {
            return DMLChartUtils.e(a.a);
        }
        else {
            return null;
        }
    }
    static j(a, b) {
        b = a.a != null ? Nullable$1.toNullable(Number_$type, a.a.f) : Nullable$1.toNullable(Number_$type, null);
        if (a.a != null) {
            b = Nullable$1.toNullable(Number_$type, a.a.f);
        }
        if (a.b != null) {
            let c = a.b.b;
            switch (c) {
                case 7: return {
                    ret: -9,
                    p1: b
                };
                case 6: return {
                    ret: -8,
                    p1: b
                };
                case 0: return {
                    ret: -2,
                    p1: b
                };
                case 3: return {
                    ret: -5,
                    p1: b
                };
                case 4: return {
                    ret: -6,
                    p1: b
                };
                case 5: return {
                    ret: -7,
                    p1: b
                };
                case 2: return {
                    ret: -4,
                    p1: b
                };
                case 1: return {
                    ret: -3,
                    p1: b
                };
                case 8: return {
                    ret: -10,
                    p1: b
                };
                default: break;
            }
        }
        return {
            ret: -4142,
            p1: b
        };
    }
    static aw(a) {
        switch (a) {
            case -4142: return Nullable$1.toNullable(ST_BuiltInUnit_$type, null);
            case -4114: break;
            case -8: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 6);
            case -2: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 0);
            case -5: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 3);
            case -10: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 8);
            case -6: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 4);
            case -7: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 5);
            case -4: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 2);
            case -9: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 7);
            case -3: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 1);
            case 1: return Nullable$1.toNullable(ST_BuiltInUnit_$type, 0);
            default: break;
        }
        return Nullable$1.toNullable(ST_BuiltInUnit_$type, null);
    }
    static aa(a) {
        switch (a) {
            case 76:
            case 78:
            case 61:
            case 58:
            case 55:
            case 52:
            case 103:
            case 100:
            case 96:
            case 93:
            case 66:
            case 63:
            case 110:
            case 107: return 2;
            case 77:
            case 79:
            case 62:
            case 59:
            case 56:
            case 53:
            case 104:
            case 101:
            case 97:
            case 94:
            case 67:
            case 64:
            case 111:
            case 108: return 0;
            default: return 1;
        }
    }
    static v(a) {
        let b = 0;
        switch (a) {
            case -4151: break;
            case 82:
                b = 2;
                break;
            case 81:
                b = 1;
                break;
        }
        return ((() => {
            let $ret = new CT_RadarStyle();
            $ret.b = b;
            return $ret;
        })());
    }
    static w(a) {
        let b = a == 17 ? 1 : 2;
        return ((() => {
            let $ret = new CT_RadarStyle();
            $ret.b = b;
            return $ret;
        })());
    }
    static x(a) {
        let b = 0;
        switch (a) {
            case -4169:
            case 74:
                b = 2;
                break;
            case 75:
                b = 1;
                break;
            case 72:
                b = 5;
                break;
            case 73:
                b = 4;
                break;
        }
        return ((() => {
            let $ret = new CT_ScatterStyle();
            $ret.b = b;
            return $ret;
        })());
    }
    static y(a) {
        let b = 0;
        switch (a) {
            case 20:
                b = 5;
                break;
            case 19:
                b = 2;
                break;
        }
        return ((() => {
            let $ret = new CT_ScatterStyle();
            $ret.b = b;
            return $ret;
        })());
    }
    static f(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = a.a;
        return DMLChartUtils.g(d, b, c);
    }
    static g(a, b, c, d = false) {
        if (a == null && d == false) {
            return null;
        }
        let e = a != null ? a.a : null;
        if (e == null && d == false) {
            return null;
        }
        let f = new ChartGridLines(c);
        f._an(c, b);
        if (e != null) {
            DMLChartExtensions.a5(f, e);
        }
        return f;
    }
    static i(a) {
        if (a == null) {
            return null;
        }
        let b = new ChartTickLines(null);
        DMLChartExtensions.a8(b, a);
        return b;
    }
    static p(a, b, c, d) {
        if (a == null) {
            return null;
        }
        let e = null;
        let f = a != null ? a.e : null;
        let g = a != null ? a.a : null;
        if (g != null && g.a != null && CT_UnsignedInt.e(g.a) > 0) {
            e = new List$1(Base.$, 2, g.a.g);
            for (let h of fromEnum(g.e)) {
                let i = 0;
                if (h.d != null && ((() => { let j = tryParseNumber(h.d, i); i = j.p1; return j.ret; })())) {
                    e.add1(i);
                }
            }
        }
        let j = e != null ? e.toArray() : null;
        let k = WorkbookLoadManagerExcel2007._bs(f);
        f = k.p0;
        let l = stringIsNullOrEmpty(f) ? null : Formula._k(f, 1, 0, b.workbook.currentFormat, CultureInfo.invariantCulture, c._bi);
        if (d) {
            return XValues._aa(b, l, j, null, 2);
        }
        else {
            return SeriesValues._u(b, l, j);
        }
    }
    static s(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = null;
        let e = a != null ? a.e : null;
        let f = a != null ? a.a : null;
        if (f.b != null && CT_UnsignedInt.e(f.b) > 0) {
            d = new List$1(Base.$, 2, f.b.g);
            for (let g of fromEnum(f.f)) {
                d.add1(g.b);
            }
        }
        let h = d != null ? d.toArray() : null;
        let i = WorkbookLoadManagerExcel2007._bs(e);
        e = i.p0;
        let j = stringIsNullOrEmpty(e) ? null : Formula._k(e, 1, 0, b.workbook.currentFormat, CultureInfo.invariantCulture, c._bi);
        return XValues._aa(b, j, h, null, 0);
    }
    static q(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = a != null ? a.e : null;
        let e = null;
        let f = null;
        let g = a != null ? a.a : null;
        let h = g != null ? g.d : null;
        if (h != null) {
            let i = new List$1(Tuple$2.$.specialize(Base.$, Number_$type), 0);
            for (let j = 0; j < h.count; j++) {
                let k = h._inner[j];
                for (let l = 0; l < k.a.count; l++) {
                    let m = k.a._inner[l];
                    let n = Tuple.a(Base.$, Number_$type, m.b, j);
                    i.add(n);
                }
            }
            e = new Array(i.count);
            f = new Array(i.count);
            for (let o = 0; o < i.count; o++) {
                let p = i._inner[o];
                e[o] = p.c;
                f[o] = p.d;
            }
        }
        let q = WorkbookLoadManagerExcel2007._bs(d);
        d = q.p0;
        let r = stringIsNullOrEmpty(d) ? null : Formula._k(d, 1, 0, b.workbook.currentFormat, CultureInfo.invariantCulture, c._bi);
        return XValues._aa(b, r, e, f, 1);
    }
    static r(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = typeCast(IProvideXValuesData_$type, a);
        let e = d.getValues();
        return XValues._aa(b, null, e, null, 0);
    }
    static o(a, b, c, d) {
        if (a == null) {
            return null;
        }
        let e = typeCast(IProvideXValuesData_$type, a);
        let f = e.getValues();
        if (d) {
            return XValues._aa(b, null, f, null, 2);
        }
        else {
            return SeriesValues._u(b, null, f);
        }
    }
    static aq($t, a) {
        let b = new List$1(ISeries_$type, 2, a.count);
        for (let c of fromEnum(a)) {
            b.add(typeCast(ISeries_$type, c));
        }
        return b;
    }
    static n(a, b, c) {
        if (a == null) {
            return null;
        }
        if (a.a != null) {
            let d = a.a.e;
            if (stringIsNullOrEmpty(d) == false) {
                let e = WorkbookLoadManagerExcel2007._bs(d);
                d = e.p0;
                let f = Formula._k(d, 1, 0, b.workbook.currentFormat, CultureInfo.invariantCulture, c._bi);
                return SeriesName._b(b, f, a.e);
            }
        }
        if (stringIsNullOrEmpty(a.e) == false) {
            return SeriesName._b(b, null, a.e);
        }
        return null;
    }
    static z(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = new CT_SerTx();
        d.a = new CT_StrRef();
        if (a._d != null) {
            let e = c._ct(a._d);
            d.a.e = e;
        }
        let f = a._a();
        if (f != null && f.length > 0) {
            d.a.a = ((() => {
                let $ret = new CT_StrData();
                $ret.f = new List$1(CT_StrVal.$, 0);
                $ret.b = ((() => {
                    let $ret = new CT_UnsignedInt();
                    $ret.g = intSToU(f.length);
                    return $ret;
                })());
                return $ret;
            })());
            for (let g = 0; g < f.length; g++) {
                d.a.a.f.add(((() => {
                    let $ret = new CT_StrVal();
                    $ret.d = intSToU(g);
                    $ret.b = f[g];
                    return $ret;
                })()));
            }
        }
        return d;
    }
    static l(a, b, c) {
        if (a == null) {
            return null;
        }
        let d = new Legend();
        if (a.a != null) {
            d.overlay = a.a.k;
        }
        let e = -4105;
        let f = a.c;
        if (f != null) {
            let g, h, i, j;
            let k = Nullable$1.toNullable(Boolean_$type, null);
            let l = DMLChartUtils.a8(f, e, g, h, i, j, k);
            e = l.p1;
            g = l.p2;
            h = l.p3;
            i = l.p4;
            j = l.p5;
            k = l.p6;
            if (e == -4114) {
                d.position = 5;
                d.left = g;
                d.top = h;
                d.width = i;
                d.height = j;
            }
        }
        if (e == -4105) {
            let m = a.e != null ? Nullable$1.toNullable(ST_LegendPos_$type, a.e.b) : Nullable$1.toNullable(ST_LegendPos_$type, null);
            if (m.hasValue) {
                d.position = DMLChartExtensions.l(m.value);
            }
            else {
                d.position = 6;
            }
        }
        let n = a.g;
        let o = n != null ? n.a : null;
        if (n != null) {
            d.fill = DMLChartUtils.c(n.l);
        }
        if (o != null) {
            let p = new ChartBorder(null);
            DMLChartExtensions.a4(p, o, c);
            d.border = p;
        }
        DMLChartUtils.a7(d, a.i, c);
        let q = a.m;
        if (q != null) {
            let r = b.count;
            let s = new Array(r);
            for (let t of fromEnum(q)) {
                let u = t.b.g;
                if (u >= r) {
                    continue;
                }
                let v = DMLChartUtils.m(t, c);
                s[u] = v;
            }
            for (let w = 0; w < s.length; w++) {
                if (s[w] == null) {
                    s[w] = new LegendEntry(null);
                }
            }
            d._legendEntries$i._ag(s);
        }
        return d;
    }
    static a7(a, b, c) {
        let d = b != null ? b.a : null;
        if (d != null) {
            if (d.af.hasValue) {
                a.rotation = ST_Angle.j(d.af.value);
            }
            if (d.ar.hasValue) {
                a.textDirection = DMLChartExtensions.q(d.ar.value);
            }
        }
        let e = b != null && b.d != null && b.d.count > 0 ? b.d._inner[0] : null;
        let f = e != null ? e.c : null;
        let g = e != null ? typeCast(CT_TextCharacterProperties_DML.$, e.a) : null;
        let h = f != null ? typeCast(CT_TextCharacterProperties_DML.$, f.a) : null;
        if (h == null) {
            h = g;
        }
        if (h != null) {
            let i = a._e(c.workbook);
            DMLChartUtils.a5(i, h);
            let j = DMLChartUtils.c(h.ad);
            a.defaultFontFill = j;
        }
    }
    static m(a, b) {
        let c = new LegendEntry(null);
        if (a.a != null && a.a.k) {
            c.del();
        }
        let d = a.e.a;
        let e = c._e(b.workbook);
        let f;
        let g = DMLChartUtils.a9(d, b, e, f);
        f = g.p3;
        c.fontFill = f;
        return c;
    }
    static a8(a, b, c, d, e, f, g) {
        b = -4105;
        g = Nullable$1.toNullable(Boolean_$type, null);
        c = d = e = f = 0;
        let h = a != null ? a.a : null;
        if (h != null) {
            g = Nullable$1.toNullable(Boolean_$type, h.q != null && h.q.b == 0);
            b = -4114;
            if (h.e != null) {
                c = h.e.f;
            }
            if (h.g != null) {
                d = h.g.f;
            }
            if (h.c != null) {
                e = h.c.f;
            }
            if (h.a != null) {
                f = h.a.f;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static a9(a, b, c, d) {
        d = null;
        if (a == null) {
            return {
                p3: d
            };
        }
        let e = a.d != null && a.d.count > 0 ? a.d._inner[0] : null;
        let f = e != null ? e.c : null;
        let g = e != null ? typeCast(CT_TextCharacterProperties_DML.$, e.a) : null;
        let h = f != null ? typeCast(CT_TextCharacterProperties_DML.$, f.a) : null;
        if (h == null) {
            h = g;
        }
        if (h != null) {
            DMLChartUtils.a5(c, h);
            d = DMLChartUtils.c(h.ad);
        }
        return {
            p3: d
        };
    }
    static a4(a, b, c, d, e) {
        c = null;
        e = null;
        d = null;
        let f = b.workbook;
        let g = new CT_SolidColorFillProperties();
        if (a._themeColorType$i.hasValue) {
            c = ((() => {
                let $ret = new CT_SchemeColor_DML();
                $ret.g = XlsxUtilities.ah(a._themeColorType$i.value);
                return $ret;
            })());
            if (a.transform != null) {
                c.b.ae(a.transform);
            }
            if (a._tint$i.hasValue) {
                let h = a._tint$i.value;
                h = Math.min(h, 1);
                h = Math.max(h, 0);
                h = (1 - h);
                c.b.aa = ((() => {
                    let $ret = new CT_PositiveFixedPercentage();
                    $ret.a = ST_PositiveFixedPercentage.d(ST_Percentage.a(h));
                    return $ret;
                })());
            }
            return {
                p2: c,
                p3: d,
                p4: e
            };
        }
        let i = a._getResolvedColor1(f);
        let j = Nullable$1.toNullable(ST_SystemColorVal_$type, null);
        if (a._p) {
            j = XlsxUtilities.bb(i);
            if (j.hasValue) {
                return {
                    p2: c,
                    p3: d,
                    p4: e
                };
            }
        }
        e = ((() => {
            let $ret = new CT_SRgbColor_DML();
            $ret.f = new ST_HexColorRGB(1, i);
            return $ret;
        })());
        if (a.transform != null) {
            e.b.ae(a.transform);
        }
        return {
            p2: c,
            p3: d,
            p4: e
        };
    }
    static ao(a) {
        if (a == null || a.d == null || a.d.a == null) {
            return false;
        }
        return a == null ? false : DMLChartUtils.ap(a.d.a);
    }
    static ap(a) {
        if (a == null) {
            return false;
        }
        return a.n.d != null;
    }
    static al(a) {
        return DMLChartUtils.am(a, true);
    }
    static an(a) {
        return DMLChartUtils.am(a, false);
    }
    static am(a, b) {
        if (a == null) {
            return false;
        }
        let c = a.getSeries();
        let d = 0;
        let e = 0;
        for (let f of fromEnum(c)) {
            let g = f.cT_Marker;
            if (g == null) {
                break;
            }
            if (g.c != null) {
                if (g.c.a != 0) {
                    d += 1;
                }
                else {
                    e += 1;
                }
            }
            else {
                d += 1;
            }
        }
        return b ? d == c.count : e == c.count;
    }
    static au(a) {
        let b = a != null ? a.cT_Marker : null;
        let c = b != null ? b.c : null;
        if (c == null) {
            return Nullable$1.toNullable(ST_MarkerStyle_$type, null);
        }
        return Nullable$1.toNullable(ST_MarkerStyle_$type, c.a);
    }
    static a($t, a) {
        if (a == null) {
            return null;
        }
        let b = new Array(a.count);
        let c = 0;
        for (let d of fromEnum(a)) {
            b[c] = d;
            c += 1;
        }
        return b;
    }
    static av(a) {
        let b = Nullable$1.toNullable(Boolean_$type, null);
        let c = a != null ? a.d : null;
        let d = c != null ? c.a : null;
        let e = d != null ? d.n : null;
        let f = e != null ? e.d : null;
        if (f != null) {
            b = Nullable$1.toNullable(Boolean_$type, false);
        }
        else if (e != null && e.e) {
            b = Nullable$1.toNullable(Boolean_$type, true);
        }
        return b;
    }
}
DMLChartUtils.$t = markType(DMLChartUtils, 'DMLChartUtils');
/**
 * @hidden
 */
export class DMLChartExtensions extends Base {
    static b(a) {
        switch (a) {
            case 1: return 2;
            case 3: return 4;
            case 2: return 3;
            case 0: return 1;
        }
        return 0;
    }
    static av(a, b) {
        if (b.type == 3) {
            return Nullable$1.toNullable(ST_AxPos_$type, null);
        }
        switch (a) {
            case 1: return Nullable$1.toNullable(ST_AxPos_$type, 0);
            case 2: return Nullable$1.toNullable(ST_AxPos_$type, 1);
            case 3: return Nullable$1.toNullable(ST_AxPos_$type, 2);
            case 4: return Nullable$1.toNullable(ST_AxPos_$type, 3);
            default: return Nullable$1.toNullable(ST_AxPos_$type, DMLChartExtensions.aa(b));
        }
    }
    static aa(a) {
        let b = (a.axisGroup == 1);
        let c = (b == false);
        let d = (a.type == 1);
        let e = (d == false);
        return b && d ? 0 : c && d ? 3 : b && e ? 1 : 2;
    }
    static y(a) {
        switch (a) {
            case 2: return -4107;
            case 4: return -4117;
            case 3: return -4130;
            case 0: return -4160;
            default: return -4108;
        }
    }
    static aq(a) {
        switch (a) {
            case -4107: return 2;
            case -4117: return 4;
            case -4130: return 3;
            case -4160: return 0;
            default: return 1;
        }
    }
    static z(a) {
        let b = 1;
        switch (a) {
            case 3:
                b = 2;
                break;
            case 0:
                b = 0;
                break;
            default: break;
        }
        return b;
    }
    static a1(a) {
        switch (a) {
            case -1: return Nullable$1.toNullable(ST_TextUnderlineType_$type, null);
            case 2: return Nullable$1.toNullable(ST_TextUnderlineType_$type, 3);
            case 0: return Nullable$1.toNullable(ST_TextUnderlineType_$type, 0);
            default: return Nullable$1.toNullable(ST_TextUnderlineType_$type, 2);
        }
    }
    static k(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            case 0: return 3;
        }
        return 0;
    }
    static a0(a) {
        switch (a) {
            case 3: return Nullable$1.toNullable(ST_PathShadeType_$type, 0);
            case 1: return Nullable$1.toNullable(ST_PathShadeType_$type, 1);
            case 2: return Nullable$1.toNullable(ST_PathShadeType_$type, 2);
            default: return Nullable$1.toNullable(ST_PathShadeType_$type, null);
        }
    }
    static ay(a) {
        switch (a) {
            case 0: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 0);
            case 1: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 2);
            case 2: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 4);
            case 3: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 1);
            case 4: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 3);
            case 5: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 5);
            case 6: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 6);
            case 7: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, null);
            case 8: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 7);
            case 9: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 9);
            case 10: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 10);
            case 11: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, 8);
            default: return Nullable$1.toNullable(ST_PresetLineDashVal_$type, null);
        }
    }
    static e(a) {
        switch (a) {
            case 2: return 1;
            case 4: return 2;
            case 1: return 3;
            case 3: return 4;
            case 5: return 5;
            case 6: return 6;
            case 0: return 0;
            case 7: return 8;
            case 9: return 9;
            case 10: return 10;
            case 8: return 11;
            default: return 7;
        }
    }
    static n(a) {
        let b = DMLChartExtensions.e(a);
        return DMLChartExtensions.m(b);
    }
    static az(a) {
        let b = DMLChartExtensions.d(a);
        return DMLChartExtensions.ay(b);
    }
    static m(a) {
        let b = a;
        return b;
    }
    static d(a) {
        let b = a;
        return b;
    }
    static q(a) {
        switch (a) {
            case 4: return 3;
            case 5: return 4;
            case 1: return 1;
            case 2: return 2;
            case 3: return 5;
            case 6: return 6;
            default: return 0;
        }
    }
    static as(a) {
        switch (a) {
            case 3: return 4;
            case 4: return 5;
            case 1: return 1;
            case 2: return 2;
            case 5: return 3;
            case 6: return 6;
            default: return 0;
        }
    }
    static r(a) {
        switch (a) {
            case 0: return 1;
            default: return 0;
        }
    }
    static ar(a) {
        switch (a) {
            case 1: return 0;
            default: return 1;
        }
    }
    static s(a) {
        switch (a) {
            case 0: return 1;
            case 1: return 2;
            default: return 0;
        }
    }
    static at(a) {
        switch (a) {
            case 1: return 0;
            case 0: return 2;
            default: return 1;
        }
    }
    static w(a) {
        switch (a) {
            case 0: break;
            case 1: return 1;
            case 2: return 2;
        }
        return 0;
    }
    static al(a) {
        switch (a) {
            case 0: break;
            case 1: return 1;
            case 2: return 2;
        }
        return 0;
    }
    static aw(a) {
        switch (a) {
            case -4105: return Nullable$1.toNullable(ST_Crosses_$type, 0);
            case 2: return Nullable$1.toNullable(ST_Crosses_$type, 1);
            case 4: return Nullable$1.toNullable(ST_Crosses_$type, 2);
            default: return Nullable$1.toNullable(ST_Crosses_$type, null);
        }
    }
    static a(a) {
        switch (a) {
            case 0: break;
            case 2: return 4;
            case 1: return 2;
        }
        return -4105;
    }
    static v(a) {
        switch (a) {
            case 0: return 4;
            case 1: return 2;
            case 3: return 3;
            default: return 4142;
        }
    }
    static ak(a) {
        switch (a) {
            case 4: return 0;
            case 2: return 1;
            case 3: return 3;
            default: return 2;
        }
    }
    static u(a) {
        switch (a) {
            case 0: return -4127;
            case 1: return -4134;
            case 3: return -4142;
            default: return 4;
        }
    }
    static aj(a) {
        switch (a) {
            case -4127: return 0;
            case -4134: return 1;
            case -4142: return 3;
            default: return 2;
        }
    }
    static t(a) {
        switch (a) {
            case 0: return -4108;
            case 2: return -4152;
            default: return -4131;
        }
    }
    static ag(a) {
        switch (a) {
            case -4108: return 0;
            case -4152: return 2;
            default: return 1;
        }
    }
    static a8(a, b) {
        if (b.h.hasValue) {
            a.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(b.h.value));
        }
        a.fill = DMLChartUtils.d(b.n);
    }
    static a5(a, b) {
        if (b == null) {
            return;
        }
        if (b.h.hasValue) {
            a.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(b.h.value));
        }
        a.fill = DMLChartUtils.d(b.n);
    }
    static c(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 5;
            case 3: return 3;
            case 4: return 1;
            case 5: return 2;
            default: return 0;
        }
    }
    static ai(a) {
        switch (a) {
            case 5: return 1;
            case 4: return 0;
            case 3: return 3;
            case 2: return 5;
            case 1: return 4;
            default: return 2;
        }
    }
    static i(a) {
        switch (a) {
            case 2: return 1;
            case 1: return 2;
            default: return 0;
        }
    }
    static ae(a) {
        switch (a) {
            case 1: return 2;
            case 2: return 1;
            default: return 0;
        }
    }
    static j(a) {
        switch (a) {
            case 1: return 0;
            case 2: return 1;
            case 3: return 2;
            default: return 3;
        }
    }
    static af(a) {
        switch (a) {
            case 0: return 1;
            case 1: return 2;
            case 2: return 3;
            default: return 4;
        }
    }
    static o(a) {
        switch (a) {
            case 1: return 8;
            case 2: return -4115;
            case 3: return 2;
            case 4: return -4118;
            case 6: return -4147;
            case 5: return 9;
            case 7: return 1;
            case 8: return 5;
            case 9: return 3;
            case 10: return -4168;
            default: return -4142;
        }
    }
    static ap(a) {
        switch (a) {
            case 8: return 1;
            case -4115: return 2;
            case 2: return 3;
            case -4118: return 4;
            case -4147: return 6;
            case 9: return 5;
            case 1: return 7;
            case 5: return 8;
            case 3: return 9;
            case -4168: return 10;
            default: return 0;
        }
    }
    static p(a) {
        switch (a) {
            case 1: return 2;
            case 0: return 1;
            default: return 3;
        }
    }
    static ah(a) {
        switch (a) {
            case 2: return 1;
            case 1: return 0;
            default: return 2;
        }
    }
    static l(a) {
        switch (a) {
            case 2: return 1;
            case 3: return 2;
            case 4: return 3;
            case 1: return 4;
            default: return 0;
        }
    }
    static ax(a) {
        switch (a) {
            case 6: return Nullable$1.toNullable(ST_LegendPos_$type, null);
            case 1: return Nullable$1.toNullable(ST_LegendPos_$type, 2);
            case 3: return Nullable$1.toNullable(ST_LegendPos_$type, 4);
            case 4: return Nullable$1.toNullable(ST_LegendPos_$type, 1);
            case 2: return Nullable$1.toNullable(ST_LegendPos_$type, 3);
            default: return Nullable$1.toNullable(ST_LegendPos_$type, 0);
        }
    }
    static ab(a) {
        switch (a) {
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 109:
            case 110:
            case 111:
            case 102:
            case 103:
            case 104:
            case 95:
            case 96:
            case 97: break;
            case 51:
            case 52:
            case 53:
            case -4100:
            case 54:
            case 55:
            case 56:
            case 112:
            case 106:
            case 107:
            case 108:
            case 99:
            case 100:
            case 101:
            case 105:
            case 98:
            case 92:
            case 93:
            case 94: return 1;
            default: break;
        }
        return 0;
    }
    static ac(a) {
        switch (a) {
            case 57:
            case 60:
            case 51:
            case 54:
            case 102:
            case 99:
            case 109:
            case 106:
            case 95:
            case 92: break;
            case 58:
            case 61:
            case 52:
            case 55:
            case 103:
            case 100:
            case 110:
            case 107:
            case 96:
            case 93: return 3;
            case 59:
            case 62:
            case 53:
            case 56:
            case 104:
            case 101:
            case 111:
            case 108:
            case 97:
            case 94: return 0;
            case -4100:
            case 112:
            case 105:
            case 98: return 2;
            default: break;
        }
        return 1;
    }
    static a7(a, b, c) {
        DMLChartExtensions.a3(a, b, c);
    }
    static a3(a, b, c) {
        if (b == null) {
            return;
        }
        if (b.h.hasValue) {
            a.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(b.h.value));
        }
        a.fill = DMLChartUtils.d(b.n);
    }
    static a6(a, b, c) {
        DMLChartExtensions.a3(a, b, c);
        if (b != null && b.l.b != null && b.l.b.a.hasValue) {
            a.lineStyle = DMLChartExtensions.n(b.l.b.a.value);
        }
    }
    static a4(a, b, c) {
        if (b.h.hasValue) {
            a.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(b.h.value));
        }
        a.fill = DMLChartUtils.d(b.n);
        if (b.l.b != null && b.l.b.a.hasValue) {
            a.lineStyle = DMLChartExtensions.e(b.l.b.a.value);
        }
        else {
            a.lineStyle = a.fill != null ? 0 : 7;
        }
    }
    static h(a) {
        switch (a) {
            case 1: return 1;
            case 0: return 3;
            default: return 2;
        }
    }
    static ao(a) {
        switch (a) {
            case 1: return 1;
            case 3: return 0;
            default: return 2;
        }
    }
    static an(a, b) {
        let c = b.workbook;
        let d = new CT_SolidColorFillProperties();
        let e = null;
        let f = null;
        let g = null;
        let h = DMLChartUtils.a4(a, b, e, f, g);
        e = h.p2;
        f = h.p3;
        g = h.p4;
        d.b.c = e;
        d.b.f = f;
        d.b.e = g;
        return d;
    }
    static ba(a, b, c) {
        let d = c.workbook;
        a.k = null;
        a.a = null;
        a.l = null;
        a.d = null;
        a.b = null;
        a.c = DMLChartExtensions.an(b, c);
    }
    static a9(a, b, c) {
        let d = c.workbook;
        a.a = null;
        a.b = null;
        a.d = null;
        a.c = null;
        a.e = null;
        a.f = null;
        let e = null;
        let f = null;
        let g = null;
        let h = DMLChartUtils.a4(b, c, e, g, f);
        e = h.p2;
        g = h.p3;
        f = h.p4;
        if (e != null) {
            a.c = e;
        }
        else if (g != null) {
            a.f = g;
        }
        else if (f != null) {
            a.e = f;
        }
    }
    static a2(a) {
        switch (a) {
            case -5004: return Nullable$1.toNullable(Boolean_$type, true);
            case -5003: return Nullable$1.toNullable(Boolean_$type, false);
            default: return Nullable$1.toNullable(Boolean_$type, null);
        }
    }
    static am(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            default: return 1;
        }
    }
    static x(a) {
        switch (a) {
            case 0: return 0;
            case 2: return 2;
            case 3: return 3;
            case 4: return 4;
            case 5: return 5;
            default: return 1;
        }
    }
    static ad(a) {
        switch (a) {
            case 8: return 8;
            case 9: return 1;
            case 6: return 5;
            case 7: return 7;
            case 10: return 0;
            case 1: return 2;
            case 2: return 3;
            case 3: return 4;
            default: return 6;
        }
    }
    static g(a) {
        switch (a) {
            case 3: return 2;
            case 4: return 3;
            case 2: return 1;
            case 1: return 9;
            case 8: return 8;
            case 0: return 10;
            case 7: return 7;
            case 5: return 6;
            case 6: return 4;
            default: return 0;
        }
    }
    static f(a, b) {
        if (a == 0 || a == 5) {
            return a;
        }
        if (WorksheetChart._f9(b)) {
            switch (b) {
                case 114: switch (a) {
                    case 7:
                    case 6:
                    case 8:
                    case 9: return a;
                    default: return 8;
                }
                case 117:
                case 116: return 0;
                case 118: return 1;
                case 119: return 6;
                case 120: switch (a) {
                    case 3:
                    case 2:
                    case 4:
                    case 1: return a;
                    default: return 4;
                }
                case 115: switch (a) {
                    case 3:
                    case 2:
                    case 4:
                    case 1: return a;
                    default: return 4;
                }
            }
        }
        let c = WorksheetChart._f6(b);
        let d = WorksheetChart._ge(b);
        if (c && d == false) {
            return 0;
        }
        if (WorksheetChart._f7(b) || WorksheetChart._gl(b) || WorksheetChart._gf(b)) {
            return 0;
        }
        let e;
        let f = false;
        let g = ((() => { let h = WorksheetChart._f8(b, e, f); e = h.p1; f = h.p2; return h.ret; })());
        if (g) {
            switch (a) {
                case 1:
                case 2:
                case 3: return a;
                case 4: return f ? a : 0;
                default: return 0;
            }
        }
        if (WorksheetChart._gd(b) || WorksheetChart._gh(b)) {
            switch (a) {
                case 1:
                case 7:
                case 8:
                case 9: return a;
                default: return 0;
            }
        }
        if (d) {
            switch (a) {
                case 1:
                case 3:
                case 4:
                case 10: return a;
                default: return 0;
            }
        }
        return a;
    }
    static au(a) {
        if (nullableNotEquals(a._bold$i, null)) {
            return true;
        }
        if (WorkbookColorInfo.l_op_Inequality(a.colorInfo, null)) {
            return true;
        }
        if (a.height >= 0) {
            return true;
        }
        if (nullableNotEquals(a._italic$i, null)) {
            return true;
        }
        if (stringIsNullOrEmpty(a.name) == false) {
            return true;
        }
        if (nullableNotEquals(a._strikeout$i, null)) {
            return true;
        }
        if (a.superscriptSubscriptStyle != -1) {
            return true;
        }
        if (a.underlineStyle != -1) {
            return true;
        }
        return false;
    }
    static b1(a, b, c, d, e) {
        CT_LblAlgn.e(b, e, a.a);
        d.k();
    }
    static b2(a, b, c, d, e) {
        CT_LblOffset.f(b, e, a.c);
        d.k();
    }
    static cu(a, b, c, d, e) {
        CT_Skip.e(b, e, a.b);
        d.k();
    }
    static bn(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.bn);
        }
        if (a.b != null) {
            DMLChartExtensions.bj(a.b, b, c, d, DrawingMLChart.bb);
        }
        if (a.c != null) {
            DMLChartExtensions.bo(a.c, b, c, d, DrawingMLChart.bx);
        }
        d.k();
    }
    static bl(a, b, c, d, e) {
        CT_CrossBetween.e(b, e, a.a);
        d.k();
    }
    static be(a, b, c, d, e) {
        CT_AxisUnit.e(b, e, a.a);
        d.k();
    }
    static bj(a, b, c, d, e) {
        CT_BuiltInUnit.f(b, e, a.b);
        d.k();
    }
    static bi(a, b, c, d, e) {
        d.p(e, null);
        if (a.p != null) {
            a.p.f(b, c, d, null);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.c0, "c");
        }
        if (a.k != null) {
            DMLChartExtensions.cl(a.k, b, c, d, DrawingMLChart.eh);
        }
        if (a.r != null) {
            for (let f of fromEnum(a.r)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.e != null) {
            DMLChartExtensions.br(a.e, b, c, d, DrawingMLChart.b0);
        }
        if (a.v != null) {
            for (let g of fromEnum(a.v)) {
                DMLChartExtensions.c3(g, b, c, d, DrawingMLChart.ga);
            }
        }
        if (a.g != null) {
            DMLChartExtensions.bt(a.g, b, c, d, DrawingMLChart.b6);
        }
        if (a.c != null) {
            DMLChartExtensions.bd(a.c, b, c, d, DrawingMLChart.bc);
        }
        if (a.i != null) {
            DMLChartExtensions.cd(a.i, b, c, d, DrawingMLChart.gk);
        }
        if (a.m != null) {
            DMLChartExtensions.ct(a.m, b, c, d, DrawingMLChart.fc);
        }
        if (a.t != null) {
            DMLChartExtensions.fg(a.t, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static b3(a, b, c, d, e) {
        d.p(e, null);
        if (a.n != null) {
            a.n.f(b, c, d, null);
        }
        if (a.i != null) {
            DMLChartExtensions.b7(a.i, b, c, d, DrawingMLChart.dk);
        }
        if (a.p != null) {
            for (let f of fromEnum(a.p)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.e != null) {
            DMLChartExtensions.br(a.e, b, c, d, DrawingMLChart.b0);
        }
        if (a.t != null) {
            for (let g of fromEnum(a.t)) {
                DMLChartExtensions.c3(g, b, c, d, DrawingMLChart.ga);
            }
        }
        if (a.g != null) {
            DMLChartExtensions.bt(a.g, b, c, d, DrawingMLChart.b6);
        }
        if (a.c != null) {
            DMLChartExtensions.bd(a.c, b, c, d, DrawingMLChart.bc);
        }
        if (a.k != null) {
            DMLChartExtensions.cd(a.k, b, c, d, DrawingMLChart.gk);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.ft, "c");
        }
        if (a.r != null) {
            DMLChartExtensions.fg(a.r, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static cn(a, b, c, d, e) {
        d.p(e, null);
        if (a.j != null) {
            a.j.f(b, c, d, null);
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.cc, "c");
        }
        if (a.l != null) {
            for (let f of fromEnum(a.l)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.e != null) {
            DMLChartExtensions.br(a.e, b, c, d, DrawingMLChart.b0);
        }
        if (a.c != null) {
            DMLChartExtensions.bd(a.c, b, c, d, DrawingMLChart.bc);
        }
        if (a.g != null) {
            DMLChartExtensions.cd(a.g, b, c, d, DrawingMLChart.gk);
        }
        if (a.n != null) {
            DMLChartExtensions.fg(a.n, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static bc(a, b, c, d, e) {
        d.p(e, null);
        if (a.j != null) {
            a.j.f(b, c, d, null);
        }
        if (a.g != null) {
            DMLChartExtensions.cl(a.g, b, c, d, DrawingMLChart.eh);
        }
        if (a.l != null && a.l.count > 0) {
            for (let f of fromEnum(a.l)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.c != null) {
            DMLChartExtensions.br(a.c, b, c, d, DrawingMLChart.b0);
        }
        if (a.r != null) {
            for (let g of fromEnum(a.r)) {
                DMLChartExtensions.c3(g, b, c, d, DrawingMLChart.ga);
            }
        }
        if (a.n != null) {
            for (let h of fromEnum(a.n)) {
                DMLChartExtensions.bt(h, b, c, d, DrawingMLChart.b6);
            }
        }
        if (a.a != null) {
            DMLChartExtensions.bd(a.a, b, c, d, DrawingMLChart.bc);
        }
        if (a.e != null) {
            DMLChartExtensions.cd(a.e, b, c, d, DrawingMLChart.gk);
        }
        if (a.p != null) {
            DMLChartExtensions.fg(a.p, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static cy(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null) {
            a.f.f(b, c, d, null);
        }
        if (a.a != null) {
            DMLChartExtensions.bd(a.a, b, c, d, DrawingMLChart.bc);
        }
        if (a.c != null) {
            DMLChartExtensions.cd(a.c, b, c, d, DrawingMLChart.gk);
        }
        if (a.h != null) {
            DMLChartExtensions.fg(a.h, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static cq(a, b, c, d, e) {
        d.p(e, null);
        if (a.l != null) {
            a.l.f(b, c, d, null);
        }
        if (a.g != null) {
            DMLChartExtensions.b7(a.g, b, c, d, DrawingMLChart.dk);
        }
        if (a.n != null) {
            for (let f of fromEnum(a.n)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.e != null) {
            DMLChartExtensions.br(a.e, b, c, d, DrawingMLChart.b0);
        }
        if (a.t != null) {
            for (let g of fromEnum(a.t)) {
                DMLChartExtensions.c3(g, b, c, d, DrawingMLChart.ga);
            }
        }
        if (a.p != null && a.p._inner[0] != null) {
            DMLChartExtensions.bt(a.p._inner[0], b, c, d, DrawingMLChart.b6);
        }
        if (a.c != null) {
            DMLChartExtensions.bd(a.c, b, c, d, DrawingMLChart.gt);
        }
        if (a.i != null) {
            DMLChartExtensions.cd(a.i, b, c, d, DrawingMLChart.gw);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.ft, "c");
        }
        if (a.r != null) {
            DMLChartExtensions.fg(a.r, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static bs(a, b, c, d, e) {
        d.p(e, null);
        if (a.g != null) {
            a.g.i(b, c, d, DrawingMLChart.cy, "c");
        }
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.c0, "c");
        }
        if (a.i != null) {
            DMLChartExtensions.b7(a.i, b, c, d, DrawingMLChart.dk);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.a7, "c");
        }
        if (a.e != null) {
            a.e.i(b, c, d, DrawingMLChart.cc, "c");
        }
        if (a.m != null) {
            DMLExtensions.a5(a.m, b, c, d, DrawingMLChart.fw);
        }
        if (a.k != null) {
            DMLChartExtensions.cl(a.k, b, c, d, DrawingMLChart.eh);
        }
        d.k();
    }
    static cl(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.aq, "c");
        }
        if (a.e != null) {
            a.e.q(b, c, d, DrawingMLChart.ar, "c");
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.ap, "c");
        }
        if (a.g != null) {
            CT_PictureFormat.e(b, DrawingMLChart.eg, a.g.a);
            d.k();
        }
        if (a.i != null) {
            CT_PictureStackUnit.e(b, DrawingMLChart.ei, a.i.a);
            d.k();
        }
        d.k();
    }
    static by(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.b6(a.a, b, c, d, DrawingMLChart.dj);
        }
        d.k();
    }
    static b6(a, b, c, d, e) {
        d.p(e, null);
        if (a.q != null) {
            DMLChartExtensions.b0(a.q, b, c, d, DrawingMLChart.c3);
        }
        if (a.m != null) {
            DMLChartExtensions.bz(a.m, b, c, d, DrawingMLChart.gs);
        }
        if (a.o != null) {
            DMLChartExtensions.bz(a.o, b, c, d, DrawingMLChart.gv);
        }
        if (a.k != null) {
            DMLChartExtensions.bz(a.k, b, c, d, DrawingMLChart.gq);
        }
        if (a.i != null) {
            DMLChartExtensions.bz(a.i, b, c, d, DrawingMLChart.cv);
        }
        if (a.e != null) {
            a.e.i(b, c, d, DrawingMLChart.gr);
        }
        if (a.g != null) {
            a.g.i(b, c, d, DrawingMLChart.gu);
        }
        if (a.c != null) {
            a.c.i(b, c, d, DrawingMLChart.go);
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.cs);
        }
        d.k();
    }
    static b0(a, b, c, d, e) {
        CT_LayoutTarget.f(b, e, a.b);
        d.k();
    }
    static bz(a, b, c, d, e) {
        CT_LayoutMode.f(b, e, a.b);
        d.k();
    }
    static c6(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.cw(a.a, b, c, d, DrawingMLChart.f0);
        }
        if (a.b != null) {
            a.b.e(b, c, d, DrawingMLChart.ey);
        }
        d.k();
    }
    static cw(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLExtensions.cz(a.e, b, c, d, DrawingMLChart.cg, "c");
        }
        if (a.a != null) {
            DMLChartExtensions.cv(a.a, b, c, d, DrawingMLChart.fy);
        }
        d.k();
    }
    static cv(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null) {
            let f = ((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(a.f.count);
                return $ret;
            })());
            f.i(b, c, d, DrawingMLChart.eu, "c");
            for (let g of fromEnum(a.f)) {
                DMLChartExtensions.cx(g, b, c, d, DrawingMLChart.et);
            }
        }
        d.k();
    }
    static cx(a, b, c, d, e) {
        CT_StrVal.g(b, e, a.d);
        if (a.b != null) {
            DMLExtensions.cz(a.b, b, c, d, DrawingMLChart.gj, "c");
        }
        d.k();
    }
    static bo(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.by(a.a, b, c, d, DrawingMLChart.c2);
        }
        if (a.c != null) {
            DMLChartExtensions.c6(a.c, b, c, d, DrawingMLChart.gd);
        }
        if (a.e != null) {
            DMLExtensions.a5(a.e, b, c, d, DrawingMLChart.fw);
        }
        if (a.g != null) {
            a.g.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static cp(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLChartExtensions.cr(a.e, b, c, d, DrawingMLChart.e4);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.gm, "c");
        }
        if (a.k != null) {
            for (let f = 0; f < a.k.count; f++) {
                DMLChartExtensions.cq(a.k._inner[f], b, c, d, DrawingMLChart.e9);
            }
        }
        if (a.c != null) {
            DMLChartExtensions.br(a.c, b, c, d, DrawingMLChart.b0);
        }
        if (a.g != null) {
            for (let g of fromEnum(a.g)) {
                g.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static cr(a, b, c, d, e) {
        CT_ScatterStyle.f(b, e, a.b);
        d.k();
    }
    static cs(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.cw(a.a, b, c, d, DrawingMLChart.f0);
        }
        if (a.e != null) {
            DMLExtensions.cz(a.e, b, c, d, DrawingMLChart.gj, "c");
        }
        d.k();
    }
    static br(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null && a.f.count > 0) {
            for (let f of fromEnum(a.f)) {
                DMLChartExtensions.bp(f, b, c, d, DrawingMLChart.by);
            }
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.br, "c");
        }
        if (a.e != null) {
            a.e.f(b, c, d, null);
        }
        if (a.b != null && a.b.e.count > 0) {
            d.p(DrawingMLChart.cf, "c");
            for (let g of fromEnum(a.b.e)) {
                g.d(b, c, d, CT_DLbls.$);
            }
            d.k();
        }
        d.k();
    }
    static c3(a, b, c, d, e) {
        d.p(e, null);
        if (a.w != null) {
            DMLExtensions.cz(a.w, b, c, d, DrawingMLChart.dv, "c");
        }
        if (a.s != null) {
            DMLExtensions.a5(a.s, b, c, d, DrawingMLChart.fw);
        }
        if (a.q != null) {
            DMLChartExtensions.c5(a.q, b, c, d, DrawingMLChart.gc);
        }
        if (a.k != null) {
            DMLChartExtensions.ch(a.k, b, c, d, DrawingMLChart.d8);
        }
        if (a.m != null) {
            DMLChartExtensions.cj(a.m, b, c, d, DrawingMLChart.ee);
        }
        if (a.g != null) {
            a.g.i(b, c, d, DrawingMLChart.co);
        }
        if (a.e != null) {
            a.e.i(b, c, d, DrawingMLChart.a0);
        }
        if (a.i != null) {
            a.i.i(b, c, d, DrawingMLChart.cz);
        }
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.bv, "c");
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.bu, "c");
        }
        if (a.o != null) {
            DMLChartExtensions.c4(a.o, b, c, d, DrawingMLChart.gb);
        }
        d.k();
    }
    static ch(a, b, c, d, e) {
        CT_Order.f(b, e, a.b);
        d.k();
    }
    static bt(a, b, c, d, e) {
        d.p(e, null);
        if (a.g != null) {
            DMLChartExtensions.bv(a.g, b, c, d, DrawingMLChart.b8);
        }
        if (a.e != null) {
            DMLChartExtensions.bu(a.e, b, c, d, DrawingMLChart.b7);
        }
        if (a.i != null) {
            DMLChartExtensions.bw(a.i, b, c, d, DrawingMLChart.b9);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.dy, "c");
        }
        if (a.m != null) {
            DMLChartExtensions.cd(a.m, b, c, d, DrawingMLChart.eq);
        }
        if (a.k != null) {
            DMLChartExtensions.cd(a.k, b, c, d, DrawingMLChart.ds);
        }
        if (a.c != null) {
            a.c.i(b, c, d, DrawingMLChart.gk);
        }
        if (a.o != null) {
            DMLExtensions.a5(a.o, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static bd(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.cb(a.a, b, c, d, DrawingMLChart.du);
        }
        if (a.c != null) {
            DMLChartExtensions.cf(a.c, b, c, d, DrawingMLChart.d3);
        }
        if (a.b != null) {
            DMLChartExtensions.cc(a.b, b, c, d, DrawingMLChart.d2);
        }
        if (a.e != null) {
            DMLChartExtensions.cw(a.e, b, c, d, DrawingMLChart.f0);
        }
        if (a.d != null) {
            DMLChartExtensions.cv(a.d, b, c, d, DrawingMLChart.fz);
        }
        d.k();
    }
    static cd(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            DMLChartExtensions.cf(a.b, b, c, d, DrawingMLChart.d3);
        }
        if (a.a != null) {
            DMLChartExtensions.cc(a.a, b, c, d, DrawingMLChart.d2);
        }
        d.k();
    }
    static ct(a, b, c, d, e) {
        CT_Shape_Chart.f(b, e, a.b);
        d.k();
    }
    static e9(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            DMLChartExtensions.fb(a.c, b, c, d, DrawingMLMain.bg);
        }
        if (a.d != null) {
            DMLChartExtensions.fb(a.d, b, c, d, DrawingMLMain.eh);
        }
        if (a.a != null) {
            DMLExtensions.bx(a.a, b, c, d, DrawingMLMain.ax);
        }
        if (a.b != null) {
            DMLExtensions.b1(a.b, b, c, d, DrawingMLMain.c2);
        }
        if (a.e != null) {
            DMLExtensions.b9(a.e, b, c, d, DrawingMLMain.hw);
        }
        if (a.f != null) {
            DMLExtensions.ck(a.f, b, c, d, DrawingMLMain.hg);
        }
        d.k();
    }
    static dk(a, b, c, d, e) {
        CT_BlipFillProperties_DML.i(b, e, a.b, a.c);
        if (a.d != null) {
            DMLChartExtensions.dj(a.d, b, c, d, DrawingMLMain.bs);
        }
        if (a.a != null) {
            DMLExtensions.ct(a.a, b, c, d, DrawingMLMain.iz);
        }
        if (a.g != null) {
            a.g.d(b, c, d, null);
        }
        d.k();
    }
    static d7(a, b, c, d, e) {
        CT_PatternFillProperties.j(b, e, a.e);
        if (a.c != null) {
            a.c.d(b, c, d, DrawingMLMain.dv);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.bn);
        }
        d.k();
    }
    static dt(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.dl(a.a, b, c, d, DrawingMLMain.bx);
        }
        if (a.c != null) {
            a.c.g(b, c, d, DrawingMLMain.dx);
        }
        if (a.e != null) {
            a.e.h(b, c, d, DrawingMLMain.ei);
        }
        if (a.g != null) {
            a.g.n(b, c, d, DrawingMLMain.ff);
        }
        if (a.i != null) {
            a.i.ag(b, c, d, DrawingMLMain.hc);
        }
        if (a.k != null) {
            a.k.m(b, c, d, DrawingMLMain.hq);
        }
        if (a.m != null) {
            DMLChartExtensions.eb(a.m, b, c, d, DrawingMLMain.h0);
        }
        if (a.o != null) {
            DMLChartExtensions.ef(a.o, b, c, d, DrawingMLMain.im);
        }
        d.k();
    }
    static ds(a, b, c, d, e) {
        CT_EffectContainer.m(b, e, a.i, a.g);
        if (a.c != null) {
            a.c.af(b, c, d, null);
        }
        d.k();
    }
    static ed(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            DMLChartExtensions.dm(a.c, b, c, d, DrawingMLMain.cd);
        }
        if (a.e != null) {
            DMLChartExtensions.d4(a.e, b, c, d, DrawingMLMain.ft);
        }
        if (a.a != null) {
            DMLChartExtensions.df(a.a, b, c, d, DrawingMLMain.bi);
        }
        if (a.g != null) {
            a.g.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static ee(a, b, c, d, e) {
        CT_Shape3D.z(b, e, a.p, a.r, a.t, a.v);
        if (a.c != null) {
            DMLChartExtensions.dg(a.c, b, c, d, DrawingMLMain.bm);
        }
        if (a.a != null) {
            DMLChartExtensions.dg(a.a, b, c, d, DrawingMLMain.bl);
        }
        if (a.g != null) {
            a.g.d(b, c, d, DrawingMLMain.du);
        }
        if (a.e != null) {
            a.e.d(b, c, d, DrawingMLMain.cs);
        }
        if (a.i != null) {
            a.i.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static d5(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.c(b, c, d, null);
        }
        d.k();
    }
    static fb(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null && a.b.count > 0) {
            d.p(DrawingMLMain.eh, "a");
            for (let f of fromEnum(a.b)) {
                DMLExtensions.b7(f, b, c, d, DrawingMLMain.eg);
            }
            d.k();
        }
        d.k();
    }
    static e8(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static fd(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static fc(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static dy(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static d3(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static dj(a, b, c, d, e) {
        CT_Blip_DML.x(b, e, a.a);
        if (a.d != null) {
            DMLChartExtensions.c8(a.d, b, c, d, DrawingMLMain.a2);
        }
        if (a.e != null) {
            DMLChartExtensions.c9(a.e, b, c, d, DrawingMLMain.a3);
        }
        if (a.f != null) {
            DMLChartExtensions.da(a.f, b, c, d, DrawingMLMain.a4);
        }
        if (a.g != null) {
            a.g.d(b, c, d, DrawingMLMain.a5);
        }
        if (a.h != null) {
            DMLExtensions.e(a.h, b, c, d, DrawingMLMain.a6);
        }
        if (a.i != null) {
            DMLChartExtensions.dc(a.i, b, c, d, DrawingMLMain.a7);
        }
        if (a.j != null) {
            DMLChartExtensions.de(a.j, b, c, d, DrawingMLMain.ba);
        }
        if (a.k != null) {
            DMLChartExtensions.dh(a.k, b, c, d, DrawingMLMain.bp);
        }
        if (a.m != null) {
            DMLChartExtensions.dl(a.m, b, c, d, DrawingMLMain.bx);
        }
        if (a.n != null) {
            DMLChartExtensions.dp(a.n, b, c, d, DrawingMLMain.cj);
        }
        if (a.o != null) {
            a.o.d(b, c, d, DrawingMLMain.cl);
        }
        if (a.p != null) {
            a.p.d(b, c, d, DrawingMLMain.dd);
        }
        if (a.q != null) {
            a.q.g(b, c, d, DrawingMLMain.dx);
        }
        if (a.r != null) {
            DMLChartExtensions.d0(a.r, b, c, d, DrawingMLMain.eo);
        }
        if (a.s != null) {
            DMLChartExtensions.d1(a.s, b, c, d, DrawingMLMain.e6);
        }
        if (a.t != null) {
            DMLExtensions.ar(a.t, b, c, d, DrawingMLMain.f4);
        }
        if (a.v != null) {
            DMLExtensions.bu(a.v, b, c, d, DrawingMLMain.jm);
        }
        if (a.u != null) {
            a.u.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static c8(a, b, c, d, e) {
        CT_AlphaBiLevelEffect.e(b, e, a.a);
        d.k();
    }
    static c9(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static da(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static db(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static dc(a, b, c, d, e) {
        CT_AlphaModulateFixedEffect.f(b, e, a.b);
        d.k();
    }
    static de(a, b, c, d, e) {
        CT_AlphaReplaceEffect.e(b, e, a.a);
        d.k();
    }
    static dh(a, b, c, d, e) {
        CT_BiLevelEffect.e(b, e, a.a);
        d.k();
    }
    static dl(a, b, c, d, e) {
        CT_BlurEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static dp(a, b, c, d, e) {
        CT_ColorChangeEffect.j(b, e, a.f);
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.ck);
        }
        if (a.c != null) {
            a.c.d(b, c, d, DrawingMLMain.cn);
        }
        d.k();
    }
    static dq(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static dr(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static dw(a, b, c, d, e) {
        CT_FillOverlayEffect.h(b, e, a.c);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static d0(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static d1(a, b, c, d, e) {
        CT_HSLEffect.l(b, e, a.d, a.f, a.h);
        d.k();
    }
    static du(a, b, c, d, e) {
        CT_EffectReference.e(b, e, a.a);
        d.k();
    }
    static dd(a, b, c, d, e) {
        CT_AlphaOutsetEffect.f(b, e, a.b);
        d.k();
    }
    static di(a, b, c, d, e) {
        CT_BlendEffect.g(b, e, a.c);
        if (a.a != null) {
            DMLChartExtensions.ds(a.a, b, c, d, DrawingMLMain.cr);
        }
        d.k();
    }
    static dv(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static dz(a, b, c, d, e) {
        CT_GlowEffect.i(b, e, a.e);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static d2(a, b, c, d, e) {
        CT_InnerShadowEffect.o(b, e, a.g, a.i, a.k);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static d6(a, b, c, d, e) {
        CT_OuterShadowEffect.ah(b, e, a.n, a.p, a.r, a.t, a.v, a.x, a.z, a.ab, a.ad);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static d9(a, b, c, d, e) {
        CT_PresetShadowEffect.n(b, e, a.h, a.j, a.d);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static eb(a, b, c, d, e) {
        CT_ReflectionEffect.as(b, e, a.o, a.q, a.s, a.u, a.w, a.y, a.aa, a.ac, a.ae, a.ag, a.ai, a.ak, a.am, a.ao);
        d.k();
    }
    static ec(a, b, c, d, e) {
        CT_RelativeOffsetEffect.i(b, e, a.c, a.e);
        d.k();
    }
    static ef(a, b, c, d, e) {
        CT_SoftEdgesEffect.e(b, e, a.a);
        d.k();
    }
    static fa(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null && a.b.count > 0) {
            for (let f of fromEnum(a.b)) {
                DMLExtensions.b3(f, b, c, d, DrawingMLMain.dc);
            }
        }
        d.k();
    }
    static ff(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static fe(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static dm(a, b, c, d, e) {
        CT_Camera.m(b, e, a.g, a.i, a.d);
        if (a.b != null) {
            DMLChartExtensions.eg(a.b, b, c, d, DrawingMLMain.h3);
        }
        d.k();
    }
    static d4(a, b, c, d, e) {
        CT_LightRig.i(b, e, a.c, a.e);
        if (a.a != null) {
            DMLChartExtensions.eg(a.a, b, c, d, DrawingMLMain.h3);
        }
        d.k();
    }
    static df(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            DMLChartExtensions.d8(a.c, b, c, d, DrawingMLMain.bc);
        }
        if (a.e != null) {
            DMLChartExtensions.e7(a.e, b, c, d, DrawingMLMain.g3);
        }
        if (a.g != null) {
            DMLChartExtensions.e7(a.g, b, c, d, DrawingMLMain.jy);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static eg(a, b, c, d, e) {
        CT_SphereCoords.i(b, e, a.a, a.c, a.e);
        d.k();
    }
    static d8(a, b, c, d, e) {
        CT_Point3D.i(b, e, a.a, a.c, a.e);
        d.k();
    }
    static e7(a, b, c, d, e) {
        CT_Vector3D.j(b, e, a.b, a.d, a.f);
        d.k();
    }
    static dg(a, b, c, d, e) {
        CT_Bevel.m(b, e, a.e, a.g, a.i);
        d.k();
    }
    static dn(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ck(a, b, c, d, e) {
        CT_PictureFormat.e(b, e, a.a);
        d.k();
    }
    static cm(a, b, c, d, e) {
        CT_PictureStackUnit.e(b, e, a.a);
        d.k();
    }
    static b7(a, b, c, d, e) {
        if (a.j.hasValue) {
            CT_Marker_Chart.l(b, e, a.j.value);
            d.k();
            return;
        }
        d.p(e, null);
        if (a.c != null) {
            DMLChartExtensions.b9(a.c, b, c, d, DrawingMLChart.f4);
        }
        if (a.a != null) {
            DMLChartExtensions.b8(a.a, b, c, d, DrawingMLChart.fr);
        }
        if (a.e != null) {
            DMLExtensions.a5(a.e, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static b9(a, b, c, d, e) {
        CT_MarkerStyle.e(b, e, a.a);
        d.k();
    }
    static b8(a, b, c, d, e) {
        CT_MarkerSize.f(b, e, a.b);
        d.k();
    }
    static bp(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.i(b, c, d, DrawingMLChart.cy, "c");
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.br, "c");
        }
        if (a.d != null) {
            a.d.f(b, c, d, null);
        }
        if (a.e != null && a.e.count > 0) {
            d.p(DrawingMLChart.cf, "c");
            for (let f of fromEnum(a.e)) {
                f.d(b, c, d, CT_DLbl.$);
            }
            d.k();
        }
        d.k();
    }
    static ce(a, b, c, d, e) {
        CT_NumFmt_Chart.g(b, e, a.c, a.a);
        d.k();
    }
    static ej(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLExtensions.bd(a.a, b, c, d, DrawingMLMain.bz);
        }
        if (a.b != null) {
            DMLChartExtensions.es(a.b, b, c, d, DrawingMLMain.f1);
        }
        if (a.d != null) {
            for (let f of fromEnum(a.d)) {
                DMLChartExtensions.ew(f, b, c, d, DrawingMLMain.hd);
            }
        }
        d.k();
    }
    static bq(a, b, c, d, e) {
        CT_DLblPos.e(b, e, a.a);
        d.k();
    }
    static bk(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static es(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            a.c.ac(b, c, d, DrawingMLMain.c4);
        }
        if (a.e != null) {
            a.e.ac(b, c, d, DrawingMLMain.f8);
        }
        if (a.g != null) {
            a.g.ac(b, c, d, DrawingMLMain.f9);
        }
        if (a.i != null) {
            a.i.ac(b, c, d, DrawingMLMain.ga);
        }
        if (a.k != null) {
            a.k.ac(b, c, d, DrawingMLMain.gb);
        }
        if (a.m != null) {
            a.m.ac(b, c, d, DrawingMLMain.gc);
        }
        if (a.o != null) {
            a.o.ac(b, c, d, DrawingMLMain.gd);
        }
        if (a.q != null) {
            a.q.ac(b, c, d, DrawingMLMain.ge);
        }
        if (a.s != null) {
            a.s.ac(b, c, d, DrawingMLMain.gf);
        }
        if (a.u != null) {
            a.u.ac(b, c, d, DrawingMLMain.gg);
        }
        if (a.a != null) {
            a.a.d(b, c, d, DrawingMLMain.dr);
        }
        d.k();
    }
    static ew(a, b, c, d, e) {
        d.p(e, null);
        if (a.c != null) {
            a.c.ac(b, c, d, DrawingMLMain.hl);
        }
        if (a.a != null) {
            a.a.aq(b, c, d, DrawingMLMain.dm);
        }
        if (a.f != null) {
            for (let f of fromEnum(a.f)) {
                f.e(b, c, d, null);
            }
        }
        d.k();
    }
    static ea(a, b, c, d, e) {
        CT_PresetTextShape.g(b, e, a.a);
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                DMLChartExtensions.ea(a, b, c, d, DrawingMLMain.bg);
            }
        }
        d.k();
    }
    static et(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static ev(a, b, c, d, e) {
        CT_TextNormalAutofit.i(b, e, a.c, a.e);
        d.k();
    }
    static ey(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static dx(a, b, c, d, e) {
        CT_FlatText.f(b, e, a.b);
        d.k();
    }
    static ez(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.e0(a.a, b, c, d, DrawingMLMain.iw);
        }
        if (a.b != null) {
            DMLChartExtensions.e1(a.b, b, c, d, DrawingMLMain.ix);
        }
        d.k();
    }
    static ek(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static el(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static em(a, b, c, d, e) {
        CT_TextBulletSizePercent.e(b, e, a.a);
        d.k();
    }
    static en(a, b, c, d, e) {
        CT_TextBulletSizePoint.e(b, e, a.a);
        d.k();
    }
    static eo(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static eu(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static eh(a, b, c, d, e) {
        CT_TextAutonumberBullet.h(b, e, a.d, a.a);
        d.k();
    }
    static ep(a, b, c, d, e) {
        CT_TextCharBullet.e(b, e, a.a);
        d.k();
    }
    static ei(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.dj(a.a, b, c, d, DrawingMLMain.bs);
        }
        d.k();
    }
    static e3(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null && a.e.count > 0) {
            d.p(DrawingMLMain.jd, "a");
            for (let f of fromEnum(a.e)) {
                DMLChartExtensions.e2(f, b, c, d, DrawingMLMain.jc);
            }
            d.k();
        }
        d.k();
    }
    static e0(a, b, c, d, e) {
        CT_TextSpacingPercent.e(b, e, a.a);
        d.k();
    }
    static e1(a, b, c, d, e) {
        CT_TextSpacingPoint.e(b, e, a.a);
        d.k();
    }
    static e2(a, b, c, d, e) {
        CT_TextTabStop.g(b, e, a.a, a.c);
        d.k();
    }
    static e6(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static e4(a, b, c, d, e) {
        d.p(e, null);
        d.k();
    }
    static e5(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.h(b, c, d, null);
        }
        d.k();
    }
    static ex(a, b, c, d, e) {
        CT_TextParagraphProperties_DML.ad(b, e, a.c, a.d, a.e, a.f, a.g, ST_TextIndent.g(a.h), a.i, ST_TextIndentLevelType.g(a.j), ST_TextMargin.g(a.k), ST_TextMargin.g(a.l), a.m);
        if (a.p != null) {
            a.p.f(b, c, d, DrawingMLMain.fy);
        }
        if (a.r != null) {
            a.r.f(b, c, d, DrawingMLMain.it);
        }
        if (a.q != null) {
            a.q.f(b, c, d, DrawingMLMain.is);
        }
        if (a.aa != null && a.aa.count > 0) {
            d.p(DrawingMLMain.jd, "a");
            for (let f of fromEnum(a.aa)) {
                DMLChartExtensions.e2(f, b, c, d, DrawingMLMain.jc);
            }
            d.k();
        }
        let g = typeCast(CT_TextCharacterProperties_DML.$, a.a);
        if (g != null) {
            g.aq(b, c, d, DrawingMLMain.c5);
        }
        if (a.v != null) {
            a.v.d(b, c, d, null);
        }
        if (a.x != null) {
            a.x.e(b, c, d, null);
        }
        if (a.z != null) {
            a.z.d(b, c, d, null);
        }
        if (a.t != null) {
            a.t.f(b, c, d, null);
        }
        d.k();
    }
    static er(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            a.a.aq(b, c, d, DrawingMLMain.h7);
        }
        d.k();
    }
    static eq(a, b, c, d, e) {
        CT_TextField.m(b, e, a.j, a.e);
        if (a.a != null) {
            a.a.aq(b, c, d, DrawingMLMain.h7);
        }
        if (a.c != null) {
            a.c.ac(b, c, d, DrawingMLMain.hl);
        }
        if (a.g != null) {
            DMLExtensions.cz(a.g, b, c, d, DrawingMLMain.ja, "a");
        }
        d.k();
    }
    static c5(a, b, c, d, e) {
        CT_TrendlineType.f(b, e, a.b);
        d.k();
    }
    static cj(a, b, c, d, e) {
        CT_Period.f(b, e, a.b);
        d.k();
    }
    static c4(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.by(a.a, b, c, d, DrawingMLChart.c2);
        }
        if (a.e != null) {
            DMLChartExtensions.c6(a.e, b, c, d, DrawingMLChart.gd);
        }
        if (a.c != null) {
            DMLChartExtensions.ce(a.c, b, c, d, DrawingMLChart.d1);
        }
        if (a.g != null) {
            DMLExtensions.a5(a.g, b, c, d, DrawingMLChart.fw);
        }
        if (a.i != null) {
            a.i.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static bv(a, b, c, d, e) {
        CT_ErrDir.e(b, e, a.a);
        d.k();
    }
    static bu(a, b, c, d, e) {
        CT_ErrBarType.f(b, e, a.b);
        d.k();
    }
    static bw(a, b, c, d, e) {
        CT_ErrValType.f(b, e, a.b);
        d.k();
    }
    static cf(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLExtensions.cz(a.e, b, c, d, DrawingMLChart.cg, "c");
        }
        if (a.a != null) {
            DMLChartExtensions.cc(a.a, b, c, d, DrawingMLChart.d0);
        }
        d.k();
    }
    static cg(a, b, c, d, e) {
        CT_NumVal.i(b, e, null, a.f);
        if (a.d != null) {
            DMLExtensions.cz(a.d, b, c, d, DrawingMLChart.gj, "c");
        }
        d.k();
    }
    static cc(a, b, c, d, e) {
        d.p(e, null);
        if (a.g != null) {
            DMLExtensions.cz(a.g, b, c, d, DrawingMLChart.cm, "c");
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.eu, "c");
        }
        if (a.e != null && a.e.count > 0) {
            for (let f of fromEnum(a.e)) {
                DMLChartExtensions.cg(f, b, c, d, DrawingMLChart.et);
            }
        }
        d.k();
    }
    static cb(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLExtensions.cz(a.e, b, c, d, DrawingMLChart.cg, "c");
        }
        if (a.a != null) {
            DMLChartExtensions.ca(a.a, b, c, d, DrawingMLChart.dt);
        }
        d.k();
    }
    static ca(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.i(b, c, d, DrawingMLChart.eu, "c");
        }
        if (a.d != null && a.d.count > 0) {
            for (let f of fromEnum(a.d)) {
                DMLChartExtensions.b5(f, b, c, d, DrawingMLChart.de);
            }
        }
        d.k();
    }
    static b5(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            for (let f = 0; f < a.a.count; f++) {
                let g = a.a._inner[f];
                DMLChartExtensions.cx(g, b, c, d, DrawingMLChart.et);
            }
        }
        d.k();
    }
    static co(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLChartExtensions.b4(a.e, b, c, d, DrawingMLChart.dd);
        }
        if (a.g != null) {
            DMLChartExtensions.ci(a.g, b, c, d, DrawingMLChart.d9);
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.dl);
        }
        if (a.c != null) {
            a.c.i(b, c, d, DrawingMLChart.dm);
        }
        d.k();
    }
    static b4(a, b, c, d, e) {
        CT_LogBase.e(b, e, a.a);
        d.k();
    }
    static ci(a, b, c, d, e) {
        CT_Orientation.e(b, e, a.a);
        d.k();
    }
    static bf(a, b, c, d, e) {
        CT_AxPos.e(b, e, a.a);
        d.k();
    }
    static c2(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            DMLChartExtensions.c6(a.e, b, c, d, DrawingMLChart.gd);
        }
        if (a.c != null) {
            DMLChartExtensions.by(a.c, b, c, d, DrawingMLChart.c2);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.eb, "c");
        }
        if (a.g != null) {
            DMLExtensions.a5(a.g, b, c, d, DrawingMLChart.fw);
        }
        if (a.i != null) {
            a.i.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static c0(a, b, c, d, e) {
        CT_TickMark.f(b, e, a.b);
        d.k();
    }
    static cz(a, b, c, d, e) {
        CT_TickLblPos.f(b, e, a.b);
        d.k();
    }
    static bm(a, b, c, d, e) {
        CT_Crosses.e(b, e, a.a);
        d.k();
    }
    static bx(a, b, c, d, e) {
        CT_Grouping.f(b, e, a.b);
        d.k();
    }
    static bh(a, b, c, d, e) {
        if (a.a != null && a.a.count > 0) {
            d.p(DrawingMLChart.a2, "c");
            for (let f of fromEnum(a.a)) {
                DMLChartExtensions.bg(f, b, c, d, DrawingMLChart.a1);
            }
            d.k();
        }
    }
    static bg(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.cy, "c");
        }
        if (a.c != null) {
            DMLExtensions.a5(a.c, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static c1(a, b, c, d, e) {
        CT_TimeUnit.f(b, e, a.b);
        d.k();
    }
    static bb(a, b, c, d, e = DrawingMLChart.cf) {
        if (a == null || a.e == null || a.e.count == 0) {
            return;
        }
        DMLChartExtensions.fg(a.e, b, c, d);
    }
    static fg(a, b, c, d, e = DrawingMLChart.cf) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(DrawingMLChart.cf, "c");
        for (let f of fromEnum(a)) {
            f.d(b, c, d, null);
        }
        d.k();
    }
    static c7(a, b, c, d, e = DrawingMLChart2012.au) {
        d.p(e, "c15");
        if (stringIsNullOrEmpty(a.c) == false) {
            DMLExtensions.cz(a.c, b, c, d, DrawingMLChart2012.a1, "c15");
        }
        d.k();
    }
}
DMLChartExtensions.$t = markType(DMLChartExtensions, 'DMLChartExtensions');
/**
 * @hidden
 */
export class ISeriesSortComparer extends Base {
    compare(a, b) {
        if (a == null || b == null) {
            return 0;
        }
        return Base.compareSimple(a.index, b.index);
    }
}
ISeriesSortComparer.$t = markType(ISeriesSortComparer, 'ISeriesSortComparer', Base.$, [IComparer$1_$type.specialize(ISeries_$type)]);
/**
 * @hidden
 */
export class ChartExAttributes extends Base {
}
ChartExAttributes.$t = markType(ChartExAttributes, 'ChartExAttributes');
/**
 * @hidden
 */
export class ChartExElements extends Base {
}
ChartExElements.$t = markType(ChartExElements, 'ChartExElements');
ChartExElements.bl = "http://schemas.microsoft.com/office/drawing/2014/chartex";
ChartExElements.a = ChartExElements.bl + "/address";
ChartExElements.b = ChartExElements.bl + "/aggregation";
ChartExElements.c = ChartExElements.bl + "/autoUpdate";
ChartExElements.d = ChartExElements.bl + "/axis";
ChartExElements.e = ChartExElements.bl + "/axisId";
ChartExElements.f = ChartExElements.bl + "/binary";
ChartExElements.g = ChartExElements.bl + "/binCount";
ChartExElements.h = ChartExElements.bl + "/binning";
ChartExElements.i = ChartExElements.bl + "/binSize";
ChartExElements.j = ChartExElements.bl + "/catScaling";
ChartExElements.k = ChartExElements.bl + "/chart";
ChartExElements.l = ChartExElements.bl + "/chartData";
ChartExElements.m = ChartExElements.bl + "/chartSpace";
ChartExElements.n = ChartExElements.bl + "/clear";
ChartExElements.o = ChartExElements.bl + "/clrMapOvr";
ChartExElements.p = ChartExElements.bl + "/copyright";
ChartExElements.q = ChartExElements.bl + "/copyrights";
ChartExElements.r = ChartExElements.bl + "/data";
ChartExElements.s = ChartExElements.bl + "/dataId";
ChartExElements.t = ChartExElements.bl + "/dataLabel";
ChartExElements.u = ChartExElements.bl + "/dataLabelHidden";
ChartExElements.v = ChartExElements.bl + "/dataLabels";
ChartExElements.w = ChartExElements.bl + "/dataPt";
ChartExElements.x = ChartExElements.bl + "/entityType";
ChartExElements.y = ChartExElements.bl + "/evenFooter";
ChartExElements.z = ChartExElements.bl + "/evenHeader";
ChartExElements.aa = ChartExElements.bl + "/ext";
ChartExElements.ab = ChartExElements.bl + "/externalData";
ChartExElements.ac = ChartExElements.bl + "/extLst";
ChartExElements.ad = ChartExElements.bl + "/extremeValue";
ChartExElements.ae = ChartExElements.bl + "/f";
ChartExElements.af = ChartExElements.bl + "/firstFooter";
ChartExElements.ag = ChartExElements.bl + "/firstHeader";
ChartExElements.ah = ChartExElements.bl + "/fmtOvr";
ChartExElements.ai = ChartExElements.bl + "/fmtOvrs";
ChartExElements.aj = ChartExElements.bl + "/geoCache";
ChartExElements.ak = ChartExElements.bl + "/geoChildEntities";
ChartExElements.al = ChartExElements.bl + "/geoChildEntitiesQuery";
ChartExElements.am = ChartExElements.bl + "/geoChildEntitiesQueryResult";
ChartExElements.an = ChartExElements.bl + "/geoChildEntitiesQueryResults";
ChartExElements.ao = ChartExElements.bl + "/geoChildTypes";
ChartExElements.ap = ChartExElements.bl + "/geoData";
ChartExElements.aq = ChartExElements.bl + "/geoDataEntityQuery";
ChartExElements.ar = ChartExElements.bl + "/geoDataEntityQueryResult";
ChartExElements.as = ChartExElements.bl + "/geoDataEntityQueryResults";
ChartExElements.at = ChartExElements.bl + "/geoDataPointQuery";
ChartExElements.au = ChartExElements.bl + "/geoDataPointToEntityQuery";
ChartExElements.av = ChartExElements.bl + "/geoDataPointToEntityQueryResult";
ChartExElements.aw = ChartExElements.bl + "/geoDataPointToEntityQueryResults";
ChartExElements.ax = ChartExElements.bl + "/geography";
ChartExElements.ay = ChartExElements.bl + "/geoHierarchyEntity";
ChartExElements.az = ChartExElements.bl + "/geoLocation";
ChartExElements.a0 = ChartExElements.bl + "/geoLocationQuery";
ChartExElements.a1 = ChartExElements.bl + "/geoLocationQueryResult";
ChartExElements.a2 = ChartExElements.bl + "/geoLocationQueryResults";
ChartExElements.a3 = ChartExElements.bl + "/geoLocations";
ChartExElements.a4 = ChartExElements.bl + "/geoPolygon";
ChartExElements.a5 = ChartExElements.bl + "/geoPolygons";
ChartExElements.a6 = ChartExElements.bl + "/headerFooter";
ChartExElements.a7 = ChartExElements.bl + "/idx";
ChartExElements.a8 = ChartExElements.bl + "/layoutPr";
ChartExElements.a9 = ChartExElements.bl + "/legend";
ChartExElements.ba = ChartExElements.bl + "/lvl";
ChartExElements.bb = ChartExElements.bl + "/majorGridlines";
ChartExElements.bc = ChartExElements.bl + "/majorTickMarks";
ChartExElements.bd = ChartExElements.bl + "/max";
ChartExElements.be = ChartExElements.bl + "/maxColor";
ChartExElements.bf = ChartExElements.bl + "/mid";
ChartExElements.bg = ChartExElements.bl + "/midColor";
ChartExElements.bh = ChartExElements.bl + "/min";
ChartExElements.bi = ChartExElements.bl + "/minColor";
ChartExElements.bj = ChartExElements.bl + "/minorGridlines";
ChartExElements.bk = ChartExElements.bl + "/minorTickMarks";
ChartExElements.bn = ChartExElements.bl + "/number";
ChartExElements.bm = ChartExElements.bl + "/nf";
ChartExElements.bo = ChartExElements.bl + "/numDim";
ChartExElements.bp = ChartExElements.bl + "/numFmt";
ChartExElements.bq = ChartExElements.bl + "/oddFooter";
ChartExElements.br = ChartExElements.bl + "/oddHeader";
ChartExElements.bs = ChartExElements.bl + "/pageMargins";
ChartExElements.bt = ChartExElements.bl + "/pageSetup";
ChartExElements.bu = ChartExElements.bl + "/parentLabelLayout";
ChartExElements.bv = ChartExElements.bl + "/percent";
ChartExElements.bw = ChartExElements.bl + "/plotArea";
ChartExElements.bx = ChartExElements.bl + "/plotAreaRegion";
ChartExElements.by = ChartExElements.bl + "/plotSurface";
ChartExElements.bz = ChartExElements.bl + "/printSettings";
ChartExElements.b0 = ChartExElements.bl + "/pt";
ChartExElements.b1 = ChartExElements.bl + "/regionLabelLayout";
ChartExElements.b2 = ChartExElements.bl + "/rich";
ChartExElements.b3 = ChartExElements.bl + "/separator";
ChartExElements.b4 = ChartExElements.bl + "/series";
ChartExElements.b5 = ChartExElements.bl + "/spPr";
ChartExElements.b6 = ChartExElements.bl + "/statistics";
ChartExElements.b7 = ChartExElements.bl + "/strDim";
ChartExElements.b8 = ChartExElements.bl + "/subtotals";
ChartExElements.b9 = ChartExElements.bl + "/tickLabels";
ChartExElements.ca = ChartExElements.bl + "/title";
ChartExElements.cb = ChartExElements.bl + "/tx";
ChartExElements.cc = ChartExElements.bl + "/txData";
ChartExElements.cd = ChartExElements.bl + "/txPr";
ChartExElements.ce = ChartExElements.bl + "/units";
ChartExElements.cf = ChartExElements.bl + "/unitsLabel";
ChartExElements.ch = ChartExElements.bl + "/valScaling";
ChartExElements.cg = ChartExElements.bl + "/v";
ChartExElements.ci = ChartExElements.bl + "/valueColorPositions";
ChartExElements.cj = ChartExElements.bl + "/valueColors";
ChartExElements.ck = ChartExElements.bl + "/visibility";
/**
 * @hidden
 */
export class CT_ChartSpaceEx extends Base {
    constructor() {
        super();
        this.c = null;
        this.e = null;
        this.i = null;
        this.g = null;
        this.l = null;
        this.a = null;
        this.j = null;
        this.k = null;
        this.n = null;
        this.m = null;
        this.n = new List$1(CT_FormatOverride.$, 0);
        this.m = new List$1(CT_Extension.$, 0);
        this.l = new Dictionary$2(String_$type, NamedReference.$, 0);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1908:
                this.b = typeCast(CT_ChartData.$, b);
                break;
            case 261:
                this.d = typeCast(CT_ChartEx.$, b);
                break;
            case 1570:
                this.j = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.k = typeCast(CT_TextBody_DML.$, b);
                break;
            case 283:
                this.h = typeCast(CT_ColorMapping.$, b);
                break;
            case 1909:
                this.n.add(typeCast(CT_FormatOverride.$, b));
                break;
            case 1258:
                this.f = typeCast(CT_PrintSettingsEx.$, b);
                break;
            case 601:
                this.m.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartSpaceEx.$t = markType(CT_ChartSpaceEx, 'CT_ChartSpaceEx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ChartData extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = null;
        this.b = null;
        this.d = null;
        this.d = new List$1(CT_Extension.$, 0);
        this.c = new List$1(CT_Data.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 604:
                this.a = typeCast(CT_ExternalDataEx.$, b);
                break;
            case 410:
                this.c.add(typeCast(CT_Data.$, b));
                break;
            case 601:
                this.d.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartData.$t = markType(CT_ChartData, 'CT_ChartData', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ExternalDataEx extends CT_ExternalData {
}
CT_ExternalDataEx.$t = markType(CT_ExternalDataEx, 'CT_ExternalDataEx', CT_ExternalData.$);
/**
 * @hidden
 */
export class CT_PageSetup extends Base {
    constructor() {
        super();
        this.u = Nullable$1.toNullable(Number_$type, null);
        this.o = Nullable$1.toNullable(Number_$type, null);
        this.s = Nullable$1.toNullable(ST_PageOrientation_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
        this.w = Nullable$1.toNullable(Boolean_$type, null);
        this.q = Nullable$1.toNullable(Number_$type, null);
        this.y = Nullable$1.toNullable(Number_$type, null);
        this.k = Nullable$1.toNullable(Number_$type, null);
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get v() {
        return this.w;
    }
    set v(a) {
        this.w = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get x() {
        return this.y;
    }
    set x(a) {
        this.y = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(ST_PageOrientation_$type, null);
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Boolean_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = CT_PageSetup.ad(a, b, c, d, e, f, g, h, i, j);
        b = k.p1;
        c = k.p2;
        d = k.p3;
        e = k.p4;
        f = k.p5;
        g = k.p6;
        h = k.p7;
        i = k.p8;
        j = k.p9;
        return ((() => {
            let $ret = new CT_PageSetup();
            $ret.t = b;
            $ret.n = c;
            $ret.r = d;
            $ret.h = e;
            $ret.j = j;
            $ret.l = f;
            $ret.v = g;
            $ret.p = h;
            $ret.x = i;
            return $ret;
        })());
    }
    static ad(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(ST_PageOrientation_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "paperSize":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "firstPageNumber":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "orientation":
                    d = Nullable$1.toNullable(ST_PageOrientation_$type, XmlNamespaceDefinitionBase.b(ST_PageOrientation_$type, k.d));
                    break;
                case "blackAndWhite":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "draft":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "useFirstPageNumber":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "horizontalDpi":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "verticalDpi":
                    i = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "copies":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static ae(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(ST_PageOrientation_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "cx");
        let l = null;
        let m = null;
        if (c.hasValue) {
            m = "blackAndWhite";
            l = ST_OnOff.g(c.value);
            a.ad.h(m, l);
        }
        if (d.hasValue) {
            m = "copies";
            l = d.value.toString();
            a.ad.h(m, l);
        }
        if (e.hasValue) {
            m = "draft";
            l = ST_OnOff.g(e.value);
            a.ad.h(m, l);
        }
        if (f.hasValue) {
            m = "firstPageNumber";
            l = f.value.toString();
            a.ad.h(m, l);
        }
        if (g.hasValue) {
            m = "horizontalDpi";
            l = g.value.toString();
            a.ad.h(m, l);
        }
        if (h.hasValue) {
            m = "orientation";
            l = XmlNamespaceDefinitionBase.f(ST_PageOrientation_$type, h.value);
            a.ad.h(m, l);
        }
        if (i.hasValue) {
            m = "paperSize";
            l = i.value.toString();
            a.ad.h(m, l);
        }
        if (j.hasValue) {
            m = "useFirstPageNumber";
            l = ST_OnOff.g(j.value);
            a.ad.h(m, l);
        }
        if (k.hasValue) {
            m = "verticalDpi";
            l = k.value.toString();
            a.ad.h(m, l);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PageSetup.$t = markType(CT_PageSetup, 'CT_PageSetup');
/**
 * @hidden
 */
export class CT_PageMargins extends Base {
    constructor() {
        super(...arguments);
        this.h = 0;
        this.j = 0;
        this.l = 0;
        this.b = 0;
        this.f = 0;
        this.d = 0;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static n(a, b, c, d, e, f, g) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "l":
                    b = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "r":
                    c = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "t":
                    d = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "b":
                    e = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "header":
                    f = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "footer":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static o(a, b, c, d, e, f, g, h) {
        a.ad.p(b, "cx");
        let i = null;
        let j = null;
        j = "b";
        i = c.toString();
        a.ad.h(j, i);
        j = "footer";
        i = d.toString();
        a.ad.h(j, i);
        j = "header";
        i = e.toString();
        a.ad.h(j, i);
        j = "l";
        i = f.toString();
        a.ad.h(j, i);
        j = "r";
        i = g.toString();
        a.ad.h(j, i);
        j = "t";
        i = h.toString();
        a.ad.h(j, i);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PageMargins.$t = markType(CT_PageMargins, 'CT_PageMargins');
/**
 * @hidden
 */
export class CT_HeaderFooter extends Base {
    constructor() {
        super();
        this.u = null;
        this.s = null;
        this.m = null;
        this.k = null;
        this.q = null;
        this.o = null;
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
    }
    get t() {
        return this.u;
    }
    set t(a) {
        this.u = a;
    }
    get r() {
        return this.s;
    }
    set r(a) {
        this.s = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static w(a, b, c, d) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "alignWithMargins":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "differentOddEven":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "differentFirst":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static x(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "alignWithMargins";
            f = ST_OnOff.g(c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "differentFirst";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "differentOddEven";
            f = ST_OnOff.g(e.value);
            a.ad.h(g, f);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1118:
                this.t = typeCast(String_$type, b);
                break;
            case 1117:
                this.r = typeCast(String_$type, b);
                break;
            case 597:
                this.l = typeCast(String_$type, b);
                break;
            case 596:
                this.j = typeCast(String_$type, b);
                break;
            case 645:
                this.p = typeCast(String_$type, b);
                break;
            case 644:
                this.n = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_HeaderFooter.$t = markType(CT_HeaderFooter, 'CT_HeaderFooter', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PrintSettingsEx extends CT_PrintSettings {
    constructor() {
        super(...arguments);
        this.j = null;
    }
}
CT_PrintSettingsEx.$t = markType(CT_PrintSettingsEx, 'CT_PrintSettingsEx', CT_PrintSettings.$);
/**
 * @hidden
 */
export class CT_FormatOverride extends Base {
    constructor() {
        super();
        this.e = 0;
        this.a = null;
        this.b = null;
        this.b = new List$1(CT_Extension.$, 0);
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "idx";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.b.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FormatOverride.$t = markType(CT_FormatOverride, 'CT_FormatOverride', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_LegendEx extends Base {
    constructor() {
        super();
        this.m = Nullable$1.toNullable(ST_SidePos_$type, null);
        this.i = Nullable$1.toNullable(ST_PosAlign_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.d = null;
        this.e = null;
        this.g = null;
        this.g = new List$1(CT_Extension.$, 0);
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(ST_SidePos_$type, null);
        let c = Nullable$1.toNullable(ST_PosAlign_$type, null);
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = CT_LegendEx.o(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_LegendEx();
            $ret.h = c;
            $ret.j = d;
            $ret.l = b;
            return $ret;
        })());
    }
    static o(a, b, c, d) {
        b = Nullable$1.toNullable(ST_SidePos_$type, null);
        c = Nullable$1.toNullable(ST_PosAlign_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "pos":
                    b = Nullable$1.toNullable(ST_SidePos_$type, XmlNamespaceDefinitionBase.b(ST_SidePos_$type, e.d));
                    break;
                case "align":
                    c = Nullable$1.toNullable(ST_PosAlign_$type, XmlNamespaceDefinitionBase.b(ST_PosAlign_$type, e.d));
                    break;
                case "overlay":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static p(a, b, c = Nullable$1.toNullable(ST_PosAlign_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(ST_SidePos_$type, null)) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "align";
            f = XmlNamespaceDefinitionBase.f(ST_PosAlign_$type, c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "overlay";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "pos";
            f = XmlNamespaceDefinitionBase.f(ST_SidePos_$type, e.value);
            a.ad.h(g, f);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.d = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.e = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.g.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_LegendEx.$t = markType(CT_LegendEx, 'CT_LegendEx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TickLabels extends Base {
    constructor() {
        super();
        this.a = null;
        this.a = new List$1(CT_Extension.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TickLabels.$t = markType(CT_TickLabels, 'CT_TickLabels', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TickMarks extends Base {
    constructor() {
        super();
        this.c = Nullable$1.toNullable(ST_TickMarksType_$type, null);
        this.a = null;
        this.a = new List$1(CT_Extension.$, 0);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(ST_TickMarksType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "type":
                    b = Nullable$1.toNullable(ST_TickMarksType_$type, XmlNamespaceDefinitionBase.b(ST_TickMarksType_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c = Nullable$1.toNullable(ST_TickMarksType_$type, null)) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "type";
            d = XmlNamespaceDefinitionBase.f(ST_TickMarksType_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.a.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TickMarks.$t = markType(CT_TickMarks, 'CT_TickMarks', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Gridlines extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.b = new List$1(CT_Extension.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.b.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Gridlines.$t = markType(CT_Gridlines, 'CT_Gridlines', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_AxisUnitsLabel extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = null;
        this.d = new List$1(CT_Extension.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 1776:
                this.a = typeCast(CT_Text.$, b);
                break;
            case 1570:
                this.b = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.c = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.d.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AxisUnitsLabel.$t = markType(CT_AxisUnitsLabel, 'CT_AxisUnitsLabel', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Text extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.a = null;
        this.b = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1778:
                this.a = typeCast(CT_TextData.$, b);
                break;
            case 1362:
                this.b = typeCast(CT_TextBody_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Text.$t = markType(CT_Text, 'CT_Text', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextData extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.a = typeCast(CT_Formula.$, b);
                break;
            case 1818:
                this.c = typeCast(String_$type, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_TextData.$t = markType(CT_TextData, 'CT_TextData', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Formula extends Base {
    constructor() {
        super();
        this.b = 0;
        this.d = null;
        this.b = 0;
    }
    toString() {
        let a = null;
        if (this.b == 1) {
            a = "; (row)";
        }
        return stringFormat("Value='{0}'{1}", this.d, a);
    }
    static a(a) {
        let b;
        let c = CT_Formula.e(a, b);
        b = c.p1;
        let d = a.ab.ad;
        return ((() => {
            let $ret = new CT_Formula();
            $ret.b = b;
            $ret.d = d;
            return $ret;
        })());
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "dir":
                    b = XmlNamespaceDefinitionBase.b(ST_FormulaDirection_$type, c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(c, "cx");
        let d = null;
        let e = null;
        if (b == 1) {
            e = "dir";
            d = EnumUtil.getName(ST_FormulaDirection_$type, b);
            a.ad.h(e, d);
        }
    }
}
CT_Formula.$t = markType(CT_Formula, 'CT_Formula');
/**
 * @hidden
 */
export class CT_AxisUnits extends Base {
    constructor() {
        super();
        this.b = null;
        this.e = Nullable$1.toNullable(ST_AxisUnit_$type, null);
        this.c = null;
        this.c = new List$1(CT_Extension.$, 0);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static g(a, b) {
        b = Nullable$1.toNullable(ST_AxisUnit_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "unit":
                    b = Nullable$1.toNullable(ST_AxisUnit_$type, XmlNamespaceDefinitionBase.b(ST_AxisUnit_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static h(a, b, c = Nullable$1.toNullable(ST_AxisUnit_$type, null)) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "unit";
            d = XmlNamespaceDefinitionBase.f(ST_AxisUnit_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1805:
                this.a = typeCast(CT_AxisUnitsLabel.$, b);
                break;
            case 601:
                this.c.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AxisUnits.$t = markType(CT_AxisUnits, 'CT_AxisUnits', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class ChartExTitleBase extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.c = null;
        this.e = null;
        this.e = new List$1(CT_Extension.$, 0);
    }
    d(a, b) {
        let c = false;
        switch (a) {
            case 1776:
                this.a = typeCast(CT_Text.$, b);
                c = true;
                break;
            case 1570:
                this.b = typeCast(CT_ShapeProperties_DML.$, b);
                c = true;
                break;
            case 1783:
                this.c = typeCast(CT_TextBody_DML.$, b);
                c = true;
                break;
            case 601:
                this.e.add(typeCast(CT_Extension.$, b));
                c = true;
                break;
            default: break;
        }
        return c;
    }
}
ChartExTitleBase.$t = markType(ChartExTitleBase, 'ChartExTitleBase');
/**
 * @hidden
 */
export class CT_AxisTitle extends ChartExTitleBase {
    constructor() {
        super();
    }
    setProperty(a, b) {
        if (super.d(a, b)) {
            return;
        }
        switch (a) {
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AxisTitle.$t = markType(CT_AxisTitle, 'CT_AxisTitle', ChartExTitleBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ValueAxisScaling extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.e = null;
        this.g = null;
        this.i = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static a(a) {
        let b = null;
        let c = null;
        let d = null;
        let e = null;
        let f = CT_ValueAxisScaling.k(a, b, c, d, e);
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        return ((() => {
            let $ret = new CT_ValueAxisScaling();
            $ret.b = b;
            $ret.d = c;
            $ret.f = d;
            $ret.h = e;
            return $ret;
        })());
    }
    static k(a, b, c, d, e) {
        b = null;
        c = null;
        d = null;
        e = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "max":
                    b = ST_DoubleOrAutomatic.f(f.d);
                    break;
                case "min":
                    c = ST_DoubleOrAutomatic.f(f.d);
                    break;
                case "majorUnit":
                    d = ST_ValueAxisUnit.f(f.d);
                    break;
                case "minorUnit":
                    e = ST_ValueAxisUnit.f(f.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static l(a, b, c = null, d = null, e = null, f = null) {
        a.ad.p(b, "cx");
        let g = null;
        let h = null;
        if (c != null) {
            h = "majorUnit";
            g = c.d();
            a.ad.h(h, g);
        }
        if (d != null) {
            h = "max";
            g = d.d();
            a.ad.h(h, g);
        }
        if (e != null) {
            h = "min";
            g = e.d();
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "minorUnit";
            g = f.d();
            a.ad.h(h, g);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ValueAxisScaling.$t = markType(CT_ValueAxisScaling, 'CT_ValueAxisScaling');
/**
 * @hidden
 */
export class CT_CategoryAxisScaling extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "gapWidth":
                    b = ST_GapWidthRatio.f(c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c = null) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c != null) {
            e = "gapWidth";
            d = c.d();
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_CategoryAxisScaling.$t = markType(CT_CategoryAxisScaling, 'CT_CategoryAxisScaling');
/**
 * @hidden
 */
export class CT_Axis extends Base {
    constructor() {
        super();
        this.y = null;
        this.b = null;
        this.d = null;
        this.g = null;
        this.i = null;
        this.o = null;
        this.q = null;
        this.m = null;
        this.k = null;
        this.ab = 0;
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.e = null;
        this.r = null;
        this.s = null;
        this.t = null;
        this.v = null;
        this.v = new List$1(CT_Extension.$, 0);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get p() {
        return this.q;
    }
    set p(a) {
        this.q = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get aa() {
        return this.ab;
    }
    set aa(a) {
        this.ab = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    static ac(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "id":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "hidden":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static ad(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "hidden";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        f = "id";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 232:
                this.e = typeCast(CT_CategoryAxisScaling.$, b);
                break;
            case 1823:
                this.r = typeCast(CT_ValueAxisScaling.$, b);
                break;
            case 1745:
                this.a = typeCast(CT_AxisTitle.$, b);
                break;
            case 1804:
                this.c = typeCast(CT_AxisUnits.$, b);
                break;
            case 963:
                this.f = typeCast(CT_Gridlines.$, b);
                break;
            case 1011:
                this.h = typeCast(CT_Gridlines.$, b);
                break;
            case 965:
                this.n = typeCast(CT_TickMarks.$, b);
                break;
            case 1013:
                this.p = typeCast(CT_TickMarks.$, b);
                break;
            case 1723:
                this.l = typeCast(CT_TickLabels.$, b);
                break;
            case 1088:
                this.j = typeCast(CT_NumberFormat.$, b);
                break;
            case 1570:
                this.s = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.t = typeCast(CT_TextBody_DML.$, b);
                break;
            case 601:
                this.v.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Axis.$t = markType(CT_Axis, 'CT_Axis', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumberFormat extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "formatCode":
                    b = d.d;
                    break;
                case "sourceLinked":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "sourceLinked";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "formatCode";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumberFormat.$t = markType(CT_NumberFormat, 'CT_NumberFormat');
/**
 * @hidden
 */
export class CT_Statistics extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(ST_QuartileMethod_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = Nullable$1.toNullable(ST_QuartileMethod_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "quartileMethod":
                    b = Nullable$1.toNullable(ST_QuartileMethod_$type, XmlNamespaceDefinitionBase.b(ST_QuartileMethod_$type, c.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c = Nullable$1.toNullable(ST_QuartileMethod_$type, null)) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "quartileMethod";
            d = XmlNamespaceDefinitionBase.f(ST_QuartileMethod_$type, c.value);
            a.ad.h(e, d);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Statistics.$t = markType(CT_Statistics, 'CT_Statistics');
/**
 * @hidden
 */
export class CT_GeoHierarchyEntity extends Base {
    constructor() {
        super(...arguments);
        this.g = null;
        this.e = null;
        this.c = 0;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static a(a) {
        let b = null;
        let c = null;
        let d = 11;
        let e = CT_GeoHierarchyEntity.i(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_GeoHierarchyEntity();
            $ret.d = c;
            $ret.b = d;
            $ret.f = b;
            return $ret;
        })());
    }
    static i(a, b, c, d) {
        b = null;
        c = null;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "entityName":
                    b = e.d;
                    break;
                case "entityId":
                    c = e.d;
                    break;
                case "entityType":
                    d = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, e.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static j(a, b, c, d, e) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c != null) {
            g = "entityId";
            f = c;
            a.ad.h(g, f);
        }
        if (d != null) {
            g = "entityName";
            f = d;
            a.ad.h(g, f);
        }
        g = "entityType";
        f = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, e);
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoHierarchyEntity.$t = markType(CT_GeoHierarchyEntity, 'CT_GeoHierarchyEntity');
/**
 * @hidden
 */
export class CT_GeoChildEntitiesQuery extends Base {
    constructor() {
        super();
        this.c = null;
        this.a = null;
        this.a = new List$1(ST_EntityType_$type, 0);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static e(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "entityId":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c != null) {
            e = "entityId";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 705:
                this.a.add(EnumUtil.getEnumValue(ST_EntityType_$type, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoChildEntitiesQuery.$t = markType(CT_GeoChildEntitiesQuery, 'CT_GeoChildEntitiesQuery', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoChildEntitiesQueryResult extends Base {
    constructor() {
        super();
        this.b = null;
        this.c = null;
        this.c = new List$1(CT_GeoHierarchyEntity.$, 0);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 702:
                this.a = typeCast(CT_GeoChildEntitiesQuery.$, b);
                break;
            case 701:
                this.c.add(typeCast(CT_GeoHierarchyEntity.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoChildEntitiesQueryResult.$t = markType(CT_GeoChildEntitiesQueryResult, 'CT_GeoChildEntitiesQueryResult', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoDataPointToEntityQuery extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
        this.e = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static a(a) {
        let b = 0;
        let c = null;
        let d = CT_GeoDataPointToEntityQuery.g(a, b, c);
        b = d.p1;
        c = d.p2;
        return ((() => {
            let $ret = new CT_GeoDataPointToEntityQuery();
            $ret.d = c;
            $ret.b = b;
            return $ret;
        })());
    }
    static g(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "entityType":
                    b = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, d.d);
                    break;
                case "entityId":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static h(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c != null) {
            f = "entityId";
            e = c;
            a.ad.h(f, e);
        }
        f = "entityType";
        e = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, d);
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataPointToEntityQuery.$t = markType(CT_GeoDataPointToEntityQuery, 'CT_GeoDataPointToEntityQuery');
/**
 * @hidden
 */
export class CT_GeoDataPointQuery extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
        this.e = 0;
        this.g = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static a(a) {
        let b = 0;
        let c = 0;
        let d = 0;
        let e = CT_GeoDataPointQuery.i(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_GeoDataPointQuery();
            $ret.b = b;
            $ret.d = c;
            $ret.f = d;
            return $ret;
        })());
    }
    static i(a, b, c, d) {
        b = 0;
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "entityType":
                    b = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, e.d);
                    break;
                case "latitude":
                    c = parseNumber(e.d, CultureInfo.invariantCulture);
                    break;
                case "longitude":
                    d = parseNumber(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static j(a, b, c, d, e) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        g = "entityType";
        f = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, c);
        a.ad.h(g, f);
        g = "latitude";
        f = d.toString();
        a.ad.h(g, f);
        g = "longitude";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataPointQuery.$t = markType(CT_GeoDataPointQuery, 'CT_GeoDataPointQuery');
/**
 * @hidden
 */
export class CT_GeoDataPointToEntityQueryResult extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 710:
                this.a = typeCast(CT_GeoDataPointQuery.$, b);
                break;
            case 711:
                this.c = typeCast(CT_GeoDataPointToEntityQuery.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataPointToEntityQueryResult.$t = markType(CT_GeoDataPointToEntityQueryResult, 'CT_GeoDataPointToEntityQueryResult', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoPolygon extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.b = 0;
        this.c = null;
    }
    static a(a) {
        let b = null;
        let c = 0;
        let d = null;
        let e = CT_GeoPolygon.f(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_GeoPolygon();
            $ret.b = c;
            $ret.c = d;
            $ret.d = b;
            return $ret;
        })());
    }
    static f(a, b, c, d) {
        b = null;
        c = 0;
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "polygonId":
                    b = e.d;
                    break;
                case "numPoints":
                    c = parseInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "pcaRings":
                    d = e.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static g(a, b, c, d, e) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        g = "numPoints";
        f = c.toString();
        a.ad.h(g, f);
        if (d != null) {
            g = "pcaRings";
            f = d;
            a.ad.h(g, f);
        }
        if (e != null) {
            g = "polygonId";
            f = e;
            a.ad.h(g, f);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoPolygon.$t = markType(CT_GeoPolygon, 'CT_GeoPolygon');
/**
 * @hidden
 */
export class CT_GeoData extends Base {
    constructor() {
        super();
        this.c = null;
        this.p = null;
        this.n = null;
        this.f = 0;
        this.l = 0;
        this.h = 0;
        this.j = 0;
        this.d = null;
        this.b = null;
        this.d = new List$1(CT_GeoPolygon.$, 0);
        this.b = new List$1(String_$type, 0);
    }
    get o() {
        return this.p;
    }
    set o(a) {
        this.p = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    static a(a) {
        let b = null;
        let c = null;
        let d = 0;
        let e = 0;
        let f = 0;
        let g = 0;
        let h = CT_GeoData.r(a, b, c, d, e, f, g);
        b = h.p1;
        c = h.p2;
        d = h.p3;
        e = h.p4;
        f = h.p5;
        g = h.p6;
        return ((() => {
            let $ret = new CT_GeoData();
            $ret.e = d;
            $ret.k = e;
            $ret.g = f;
            $ret.i = g;
            $ret.m = c;
            $ret.o = b;
            return $ret;
        })());
    }
    static r(a, b, c, d, e, f, g) {
        b = null;
        c = null;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "entityName":
                    b = h.d;
                    break;
                case "entityId":
                    c = h.d;
                    break;
                case "east":
                    d = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "west":
                    e = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "north":
                    f = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "south":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static s(a, b, c, d, e, f, g, h) {
        a.ad.p(b, "cx");
        let i = null;
        let j = null;
        j = "east";
        i = c.toString();
        a.ad.h(j, i);
        if (d != null) {
            j = "entityId";
            i = d;
            a.ad.h(j, i);
        }
        if (e != null) {
            j = "entityName";
            i = e;
            a.ad.h(j, i);
        }
        j = "north";
        i = f.toString();
        a.ad.h(j, i);
        j = "south";
        i = g.toString();
        a.ad.h(j, i);
        j = "west";
        i = h.toString();
        a.ad.h(j, i);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 721:
                this.d.add(typeCast(CT_GeoPolygon.$, b));
                break;
            case 351:
                this.b.add(typeCast(String_$type, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoData.$t = markType(CT_GeoData, 'CT_GeoData', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoDataEntityQuery extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "entityType":
                    b = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, d.d);
                    break;
                case "entityId":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c != null) {
            f = "entityId";
            e = c;
            a.ad.h(f, e);
        }
        f = "entityType";
        e = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, d);
        a.ad.h(f, e);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataEntityQuery.$t = markType(CT_GeoDataEntityQuery, 'CT_GeoDataEntityQuery');
/**
 * @hidden
 */
export class CT_GeoDataEntityQueryResult extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 707:
                this.c = typeCast(CT_GeoDataEntityQuery.$, b);
                break;
            case 706:
                this.a = typeCast(CT_GeoData.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataEntityQueryResult.$t = markType(CT_GeoDataEntityQueryResult, 'CT_GeoDataEntityQueryResult', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Address extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.i = null;
        this.e = null;
        this.g = null;
        this.o = null;
        this.m = null;
        this.k = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get n() {
        return this.o;
    }
    set n(a) {
        this.o = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static a(a) {
        let b = null;
        let c = null;
        let d = null;
        let e = null;
        let f = null;
        let g = null;
        let h = null;
        let i = CT_Address.q(a, b, c, d, e, f, g, h);
        b = i.p1;
        c = i.p2;
        d = i.p3;
        e = i.p4;
        f = i.p5;
        g = i.p6;
        h = i.p7;
        return ((() => {
            let $ret = new CT_Address();
            $ret.b = b;
            $ret.h = c;
            $ret.d = d;
            $ret.f = e;
            $ret.j = h;
            $ret.n = f;
            $ret.l = g;
            return $ret;
        })());
    }
    static q(a, b, c, d, e, f, g, h) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "address1":
                    b = i.d;
                    break;
                case "countryRegion":
                    c = i.d;
                    break;
                case "adminDistrict1":
                    d = i.d;
                    break;
                case "adminDistrict2":
                    e = i.d;
                    break;
                case "postalCode":
                    f = i.d;
                    break;
                case "locality":
                    g = i.d;
                    break;
                case "isoCountryCode":
                    h = i.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static r(a, b, c = null, d = null, e = null, f = null, g = null, h = null, i = null) {
        a.ad.p(b, "cx");
        let j = null;
        let k = null;
        if (c != null) {
            k = "address1";
            j = c;
            a.ad.h(k, j);
        }
        if (d != null) {
            k = "adminDistrict1";
            j = d;
            a.ad.h(k, j);
        }
        if (e != null) {
            k = "adminDistrict2";
            j = e;
            a.ad.h(k, j);
        }
        if (f != null) {
            k = "countryRegion";
            j = f;
            a.ad.h(k, j);
        }
        if (g != null) {
            k = "isoCountryCode";
            j = g;
            a.ad.h(k, j);
        }
        if (h != null) {
            k = "locality";
            j = h;
            a.ad.h(k, j);
        }
        if (i != null) {
            k = "postalCode";
            j = i;
            a.ad.h(k, j);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Address.$t = markType(CT_Address, 'CT_Address');
/**
 * @hidden
 */
export class CT_GeoLocation extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.h = Nullable$1.toNullable(Number_$type, null);
        this.j = null;
        this.d = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static l(a, b, c, d, e) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = null;
        e = 0;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "latitude":
                    b = Nullable$1.toNullable(Number_$type, parseNumber(f.d, CultureInfo.invariantCulture));
                    break;
                case "longitude":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(f.d, CultureInfo.invariantCulture));
                    break;
                case "entityName":
                    d = f.d;
                    break;
                case "entityType":
                    e = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, f.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static m(a, b, c, d, e, f) {
        a.ad.p(b, "cx");
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "latitude";
            g = c.value.toString();
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "longitude";
            g = d.value.toString();
            a.ad.h(h, g);
        }
        if (e != null) {
            h = "entityName";
            g = e;
            a.ad.h(h, g);
        }
        h = "entityType";
        g = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, f);
        a.ad.h(h, g);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 18:
                this.a = typeCast(CT_Address.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoLocation.$t = markType(CT_GeoLocation, 'CT_GeoLocation', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoLocations extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 715:
                this.a = typeCast(CT_GeoLocation.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoLocations.$t = markType(CT_GeoLocations, 'CT_GeoLocations', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoLocationQuery extends Base {
    constructor() {
        super(...arguments);
        this.h = null;
        this.d = null;
        this.f = null;
        this.j = null;
        this.b = 0;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static l(a, b, c, d, e, f) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = 0;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "countryRegion":
                    b = g.d;
                    break;
                case "adminDistrict1":
                    c = g.d;
                    break;
                case "adminDistrict2":
                    d = g.d;
                    break;
                case "postalCode":
                    e = g.d;
                    break;
                case "entityType":
                    f = XmlNamespaceDefinitionBase.b(ST_EntityType_$type, g.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static m(a, b, c, d, e, f, g) {
        a.ad.p(b, "cx");
        let h = null;
        let i = null;
        if (c != null) {
            i = "adminDistrict1";
            h = c;
            a.ad.h(i, h);
        }
        if (d != null) {
            i = "adminDistrict2";
            h = d;
            a.ad.h(i, h);
        }
        if (e != null) {
            i = "countryRegion";
            h = e;
            a.ad.h(i, h);
        }
        if (f != null) {
            i = "postalCode";
            h = f;
            a.ad.h(i, h);
        }
        i = "entityType";
        h = XmlNamespaceDefinitionBase.f(ST_EntityType_$type, g);
        a.ad.h(i, h);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoLocationQuery.$t = markType(CT_GeoLocationQuery, 'CT_GeoLocationQuery');
/**
 * @hidden
 */
export class CT_GeoLocationQueryResult extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 716:
                this.a = typeCast(CT_GeoLocationQuery.$, b);
                break;
            case 719:
                this.c = typeCast(CT_GeoLocations.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoLocationQueryResult.$t = markType(CT_GeoLocationQueryResult, 'CT_GeoLocationQueryResult', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Clear extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.c = null;
        this.a = null;
        this.a = new List$1(CT_GeoChildEntitiesQueryResult.$, 0);
        this.b = new List$1(CT_GeoDataEntityQueryResult.$, 0);
        this.c = new List$1(CT_GeoDataPointToEntityQueryResult.$, 0);
        this.d = new List$1(CT_GeoLocationQueryResult.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 718:
                this.d.add(typeCast(CT_GeoLocationQueryResult.$, b));
                break;
            case 709:
                this.b.add(typeCast(CT_GeoDataEntityQueryResult.$, b));
                break;
            case 713:
                this.c.add(typeCast(CT_GeoDataPointToEntityQueryResult.$, b));
                break;
            case 704:
                this.a.add(typeCast(CT_GeoChildEntitiesQueryResult.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Clear.$t = markType(CT_Clear, 'CT_Clear', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoCache extends Base {
    constructor() {
        super();
        this.d = null;
        this.b = null;
        this.a = null;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static f(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "provider":
                    b = c.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c != null) {
            e = "provider";
            d = c;
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1917:
                this.b = typeCast(String_$type, b);
                break;
            case 1918:
                this.a = typeCast(CT_Clear.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoCache.$t = markType(CT_GeoCache, 'CT_GeoCache', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Geography extends Base {
    constructor() {
        super();
        this.b = null;
        this.e = Nullable$1.toNullable(ST_GeoProjectionType_$type, null);
        this.g = Nullable$1.toNullable(ST_GeoMappingLevel_$type, null);
        this.k = null;
        this.m = null;
        this.i = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get l() {
        return this.m;
    }
    set l(a) {
        this.m = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static c(a) {
        let b = Nullable$1.toNullable(ST_GeoProjectionType_$type, null);
        let c = Nullable$1.toNullable(ST_GeoMappingLevel_$type, null);
        let d = null;
        let e = null;
        let f = null;
        let g = CT_Geography.o(a, b, c, d, e, f);
        b = g.p1;
        c = g.p2;
        d = g.p3;
        e = g.p4;
        f = g.p5;
        return ((() => {
            let $ret = new CT_Geography();
            $ret.h = f;
            $ret.j = d;
            $ret.l = e;
            $ret.d = b;
            $ret.f = c;
            return $ret;
        })());
    }
    static o(a, b, c, d, e, f) {
        b = Nullable$1.toNullable(ST_GeoProjectionType_$type, null);
        c = Nullable$1.toNullable(ST_GeoMappingLevel_$type, null);
        d = null;
        e = null;
        f = null;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "projectionType":
                    b = Nullable$1.toNullable(ST_GeoProjectionType_$type, XmlNamespaceDefinitionBase.b(ST_GeoProjectionType_$type, g.d));
                    break;
                case "viewedRegionType":
                    c = Nullable$1.toNullable(ST_GeoMappingLevel_$type, XmlNamespaceDefinitionBase.b(ST_GeoMappingLevel_$type, g.d));
                    break;
                case "cultureLanguage":
                    d = g.d;
                    break;
                case "cultureRegion":
                    e = g.d;
                    break;
                case "attribution":
                    f = g.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static p(a, b, c, d, e, f, g) {
        a.ad.p(b, "cx");
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "projectionType";
            h = XmlNamespaceDefinitionBase.f(ST_GeoProjectionType_$type, c.value);
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "viewedRegionType";
            h = XmlNamespaceDefinitionBase.f(ST_GeoMappingLevel_$type, d.value);
            a.ad.h(i, h);
        }
        if (e != null) {
            i = "attribution";
            h = e;
            a.ad.h(i, h);
        }
        if (f != null) {
            i = "cultureLanguage";
            h = f;
            a.ad.h(i, h);
        }
        if (g != null) {
            i = "cultureRegion";
            h = g;
            a.ad.h(i, h);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 700:
                this.a = typeCast(CT_GeoCache.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Geography.$t = markType(CT_Geography, 'CT_Geography', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Binning extends Base {
    constructor() {
        super(...arguments);
        this.j = null;
        this.i = Nullable$1.toNullable(ST_IntervalClosedSide_$type, null);
        this.g = null;
        this.e = null;
        this.a = null;
        this.b = null;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static c(a) {
        let b = Nullable$1.toNullable(ST_IntervalClosedSide_$type, null);
        let c = null;
        let d = null;
        let e = CT_Binning.l(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_Binning();
            $ret.h = b;
            $ret.d = d;
            $ret.f = c;
            return $ret;
        })());
    }
    static l(a, b, c, d) {
        b = Nullable$1.toNullable(ST_IntervalClosedSide_$type, null);
        c = null;
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "intervalClosed":
                    b = Nullable$1.toNullable(ST_IntervalClosedSide_$type, XmlNamespaceDefinitionBase.b(ST_IntervalClosedSide_$type, e.d));
                    break;
                case "underflow":
                    c = ST_DoubleOrAutomatic.f(e.d);
                    break;
                case "overflow":
                    d = ST_DoubleOrAutomatic.f(e.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static m(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static n(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(Number_$type, parseNumber(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static o(a, b, c = Nullable$1.toNullable(ST_IntervalClosedSide_$type, null), d = null, e = null) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "intervalClosed";
            f = XmlNamespaceDefinitionBase.f(ST_IntervalClosedSide_$type, c.value);
            a.ad.h(g, f);
        }
        if (d != null) {
            g = "overflow";
            f = d.d();
            a.ad.h(g, f);
        }
        if (e != null) {
            g = "underflow";
            f = e.d();
            a.ad.h(g, f);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1910:
                this.a = CT_Double.a(b);
                break;
            case 1911:
                this.b = CT_UnsignedInt.a(typeGetValue(b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Binning.$t = markType(CT_Binning, 'CT_Binning', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Aggregation extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Aggregation.$t = markType(CT_Aggregation, 'CT_Aggregation');
/**
 * @hidden
 */
export class CT_SeriesElementVisibilities extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    static a(a) {
        let b = Nullable$1.toNullable(Boolean_$type, null);
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = CT_SeriesElementVisibilities.m(a, b, c, d, e, f);
        b = g.p1;
        c = g.p2;
        d = g.p3;
        e = g.p4;
        f = g.p5;
        return ((() => {
            let $ret = new CT_SeriesElementVisibilities();
            $ret.b = b;
            $ret.d = c;
            $ret.f = d;
            $ret.h = e;
            $ret.j = f;
            return $ret;
        })());
    }
    static m(a, b, c, d, e, f) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "connectorLines":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "meanLine":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "meanMarker":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "nonoutliers":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "outliers":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static n(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "cx");
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "connectorLines";
            h = ST_OnOff.g(c.value);
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "meanLine";
            h = ST_OnOff.g(d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "meanMarker";
            h = ST_OnOff.g(e.value);
            a.ad.h(i, h);
        }
        if (f.hasValue) {
            i = "nonoutliers";
            h = ST_OnOff.g(f.value);
            a.ad.h(i, h);
        }
        if (g.hasValue) {
            i = "outliers";
            h = ST_OnOff.g(g.value);
            a.ad.h(i, h);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SeriesElementVisibilities.$t = markType(CT_SeriesElementVisibilities, 'CT_SeriesElementVisibilities');
/**
 * @hidden
 */
export class CT_RegionLabelLayout extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_RegionLabelLayout_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_RegionLabelLayout_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RegionLabelLayout.$t = markType(CT_RegionLabelLayout, 'CT_RegionLabelLayout');
/**
 * @hidden
 */
export class CT_ParentLabelLayout extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_ParentLabelLayout_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = XmlNamespaceDefinitionBase.f(ST_ParentLabelLayout_$type, c);
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ParentLabelLayout.$t = markType(CT_ParentLabelLayout, 'CT_ParentLabelLayout');
/**
 * @hidden
 */
export class CT_SeriesLayoutProperties extends Base {
    constructor() {
        super();
        this.f = null;
        this.h = null;
        this.j = null;
        this.d = null;
        this.l = null;
        this.a = null;
        this.b = null;
        this.m = null;
        this.n = null;
        this.n = new List$1(CT_Extension.$, 0);
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1170:
                this.e = typeCast(CT_ParentLabelLayout.$, b);
                break;
            case 1339:
                this.g = typeCast(CT_RegionLabelLayout.$, b);
                break;
            case 1844:
                this.i = typeCast(CT_SeriesElementVisibilities.$, b);
                break;
            case 22:
                this.a = typeCast(CT_Aggregation.$, b);
                break;
            case 120:
                this.b = typeCast(CT_Binning.$, b);
                break;
            case 722:
                this.c = typeCast(CT_Geography.$, b);
                break;
            case 1597:
                this.k = typeCast(CT_Statistics.$, b);
                break;
            case 1636:
                this.m = b;
                break;
            case 601:
                this.n.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_SeriesLayoutProperties.$t = markType(CT_SeriesLayoutProperties, 'CT_SeriesLayoutProperties', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataId extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataId.$t = markType(CT_DataId, 'CT_DataId');
/**
 * @hidden
 */
export class CT_DataLabelHidden extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "idx";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabelHidden.$t = markType(CT_DataLabelHidden, 'CT_DataLabelHidden');
/**
 * @hidden
 */
export class ChartExDataLabelBase extends Base {
    constructor() {
        super();
        this.b = null;
        this.c = null;
        this.d = null;
        this.a = null;
        this.h = null;
        this.f = null;
        this.g = Nullable$1.toNullable(ST_DataLabelPos_$type, null);
        this.f = new List$1(CT_Extension.$, 0);
    }
    e(a, b) {
        let c = false;
        switch (a) {
            case 1088:
                this.b = typeCast(CT_NumberFormat.$, b);
                c = true;
                break;
            case 1570:
                this.c = typeCast(CT_ShapeProperties_DML.$, b);
                c = true;
                break;
            case 1783:
                this.d = typeCast(CT_TextBody_DML.$, b);
                c = true;
                break;
            case 1844:
                this.a = typeCast(CT_DataLabelVisibilities.$, b);
                c = true;
                break;
            case 1445:
                this.h = typeCast(String_$type, b);
                c = true;
                break;
            case 601:
                this.f.add(typeCast(CT_Extension.$, b));
                c = true;
                break;
            default: break;
        }
        return c;
    }
}
ChartExDataLabelBase.$t = markType(ChartExDataLabelBase, 'ChartExDataLabelBase');
/**
 * @hidden
 */
export class CT_DataLabels extends ChartExDataLabelBase {
    constructor() {
        super();
        this.i = null;
        this.j = null;
        this.i = new List$1(CT_DataLabel.$, 0);
        this.j = new List$1(CT_DataLabelHidden.$, 0);
    }
    static k(a, b) {
        b = Nullable$1.toNullable(ST_DataLabelPos_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "pos":
                    b = Nullable$1.toNullable(ST_DataLabelPos_$type, XmlNamespaceDefinitionBase.b(ST_DataLabelPos_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static l(a, b, c = Nullable$1.toNullable(ST_DataLabelPos_$type, null)) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "pos";
            d = XmlNamespaceDefinitionBase.f(ST_DataLabelPos_$type, c.value);
            a.ad.h(e, d);
        }
    }
    setProperty(a, b) {
        if (super.e(a, b)) {
            return;
        }
        switch (a) {
            case 417:
                this.i.add(typeCast(CT_DataLabel.$, b));
                break;
            case 419:
                this.j.add(typeCast(CT_DataLabelHidden.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabels.$t = markType(CT_DataLabels, 'CT_DataLabels', ChartExDataLabelBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataLabel extends ChartExDataLabelBase {
    constructor() {
        super();
        this.i = 0;
    }
    static j(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(ST_DataLabelPos_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "pos":
                    c = Nullable$1.toNullable(ST_DataLabelPos_$type, XmlNamespaceDefinitionBase.b(ST_DataLabelPos_$type, d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static k(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "pos";
            e = XmlNamespaceDefinitionBase.f(ST_DataLabelPos_$type, c.value);
            a.ad.h(f, e);
        }
        f = "idx";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1088:
                this.b = typeCast(CT_NumberFormat.$, b);
                break;
            case 1570:
                this.c = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1783:
                this.d = typeCast(CT_TextBody_DML.$, b);
                break;
            case 1844:
                this.a = typeCast(CT_DataLabelVisibilities.$, b);
                break;
            case 1445:
                this.h = typeCast(String_$type, b);
                break;
            case 601:
                this.f.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabel.$t = markType(CT_DataLabel, 'CT_DataLabel', ChartExDataLabelBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_DataLabelVisibilities extends Base {
    constructor() {
        super(...arguments);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static h(a, b, c, d) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "seriesName":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "categoryName":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                case "value":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static i(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "categoryName";
            f = ST_OnOff.g(c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "seriesName";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "value";
            f = ST_OnOff.g(e.value);
            a.ad.h(g, f);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataLabelVisibilities.$t = markType(CT_DataLabelVisibilities, 'CT_DataLabelVisibilities');
/**
 * @hidden
 */
export class CT_DataPoint extends Base {
    constructor() {
        super();
        this.e = 0;
        this.a = null;
        this.b = null;
        this.b = new List$1(CT_Extension.$, 0);
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    static f(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static g(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "idx";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.b.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_DataPoint.$t = markType(CT_DataPoint, 'CT_DataPoint', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ValueColorMiddlePosition extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1912:
                this.a = typeCast(CT_NumberColorPosition.$, b);
                break;
            case 1913:
                this.b = typeCast(CT_PercentageColorPosition.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ValueColorMiddlePosition.$t = markType(CT_ValueColorMiddlePosition, 'CT_ValueColorMiddlePosition', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumberColorPosition extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumberColorPosition.$t = markType(CT_NumberColorPosition, 'CT_NumberColorPosition');
/**
 * @hidden
 */
export class CT_PercentageColorPosition extends Base {
    constructor() {
        super(...arguments);
        this.b = 0;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static d(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static e(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PercentageColorPosition.$t = markType(CT_PercentageColorPosition, 'CT_PercentageColorPosition');
/**
 * @hidden
 */
export class CT_ExtremeValueColorPosition extends Base {
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ExtremeValueColorPosition.$t = markType(CT_ExtremeValueColorPosition, 'CT_ExtremeValueColorPosition');
/**
 * @hidden
 */
export class CT_ValueColorEndPosition extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 1914:
                this.a = typeCast(CT_ExtremeValueColorPosition.$, b);
                break;
            case 1912:
                this.b = typeCast(CT_NumberColorPosition.$, b);
                break;
            case 1913:
                this.c = typeCast(CT_PercentageColorPosition.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ValueColorEndPosition.$t = markType(CT_ValueColorEndPosition, 'CT_ValueColorEndPosition', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ValueColorPositions extends Base {
    constructor() {
        super();
        this.d = null;
        this.f = null;
        this.b = null;
        this.i = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static k(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static l(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "count";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1008:
                this.c = typeCast(CT_ValueColorEndPosition.$, b);
                break;
            case 1005:
                this.e = typeCast(CT_ValueColorMiddlePosition.$, b);
                break;
            case 984:
                this.a = typeCast(CT_ValueColorEndPosition.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ValueColorPositions.$t = markType(CT_ValueColorPositions, 'CT_ValueColorPositions', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ValueColors extends Base {
    constructor() {
        super();
        this.f = null;
        this.d = null;
        this.b = null;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1009:
                this.e = typeCast(CT_SolidColorFillProperties.$, b);
                break;
            case 1006:
                this.c = typeCast(CT_SolidColorFillProperties.$, b);
                break;
            case 985:
                this.a = typeCast(CT_SolidColorFillProperties.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ValueColors.$t = markType(CT_ValueColors, 'CT_ValueColors', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Series extends Base {
    constructor() {
        super();
        this.h = null;
        this.l = null;
        this.j = null;
        this.b = null;
        this.f = null;
        this.n = 0;
        this.x = Nullable$1.toNullable(Boolean_$type, null);
        this.z = Nullable$1.toNullable(Number_$type, null);
        this.ac = null;
        this.v = Nullable$1.toNullable(Number_$type, null);
        this.t = 0;
        this.o = null;
        this.r = null;
        this.c = null;
        this.q = null;
        this.s = null;
        this.q = new List$1(ST_AxisId.$, 0);
        this.r = new List$1(CT_DataPoint.$, 0);
        this.s = new List$1(CT_Extension.$, 0);
    }
    get g() {
        return this.h;
    }
    set g(a) {
        this.h = a;
    }
    get k() {
        return this.l;
    }
    set k(a) {
        this.l = a;
    }
    get i() {
        return this.j;
    }
    set i(a) {
        this.j = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get m() {
        return this.n;
    }
    set m(a) {
        this.n = a;
    }
    get w() {
        return this.x;
    }
    set w(a) {
        this.x = a;
    }
    get y() {
        return this.z;
    }
    set y(a) {
        this.z = a;
    }
    get ab() {
        if (this.ac == null) {
            let a = Guid.newGuid();
            this.ac = a.toString2("B");
        }
        return this.ac;
    }
    set ab(a) {
        this.ac = a;
    }
    get u() {
        return this.v;
    }
    set u(a) {
        this.v = a;
    }
    static d(a) {
        let b = 0;
        let c = Nullable$1.toNullable(Boolean_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = null;
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = CT_Series.ad(a, b, c, d, e, f);
        b = g.p1;
        c = g.p2;
        d = g.p3;
        e = g.p4;
        f = g.p5;
        return ((() => {
            let $ret = new CT_Series();
            $ret.m = b;
            $ret.y = d;
            $ret.ab = e;
            $ret.u = f;
            $ret.w = c;
            return $ret;
        })());
    }
    static ad(a, b, c, d, e, f) {
        b = 0;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = null;
        f = Nullable$1.toNullable(Number_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "layoutId":
                    b = XmlNamespaceDefinitionBase.b(ST_SeriesLayout_$type, g.d);
                    break;
                case "hidden":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "ownerIdx":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(g.d, CultureInfo.invariantCulture));
                    break;
                case "uniqueId":
                    e = g.d;
                    break;
                case "formatIdx":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(g.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static ae(a, b, c, d, e, f, g) {
        a.ad.p(b, "cx");
        let h = null;
        let i = null;
        if (c.hasValue) {
            i = "formatIdx";
            h = c.value.toString();
            a.ad.h(i, h);
        }
        if (d.hasValue) {
            i = "hidden";
            h = ST_OnOff.g(d.value);
            a.ad.h(i, h);
        }
        if (e.hasValue) {
            i = "ownerIdx";
            h = e.value.toString();
            a.ad.h(i, h);
        }
        if (f != null) {
            i = "uniqueId";
            h = f;
            a.ad.h(i, h);
        }
        i = "layoutId";
        h = XmlNamespaceDefinitionBase.f(ST_SeriesLayout_$type, g);
        a.ad.h(i, h);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1776:
                this.g = typeCast(CT_Text.$, b);
                break;
            case 1570:
                this.o = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1827:
                this.k = typeCast(CT_ValueColors.$, b);
                break;
            case 1826:
                this.i = typeCast(CT_ValueColorPositions.$, b);
                break;
            case 429:
                this.r.add(typeCast(CT_DataPoint.$, b));
                break;
            case 420:
                this.c = typeCast(CT_DataLabels.$, b);
                break;
            case 416:
                this.a = typeCast(CT_DataId.$, b);
                break;
            case 881:
                this.e = typeCast(CT_SeriesLayoutProperties.$, b);
                break;
            case 84:
                this.q.add(b);
                break;
            case 601:
                this.s.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Series.$t = markType(CT_Series, 'CT_Series', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PlotSurface extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = null;
        this.b = new List$1(CT_Extension.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 1570:
                this.a = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.b.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PlotSurface.$t = markType(CT_PlotSurface, 'CT_PlotSurface', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PlotAreaRegion extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = null;
        this.b = null;
        this.c = new List$1(CT_Series.$, 0);
        this.b = new List$1(CT_Extension.$, 0);
    }
    setProperty(a, b) {
        switch (a) {
            case 1237:
                this.a = typeCast(CT_PlotSurface.$, b);
                break;
            case 1449:
                this.c.add(typeCast(CT_Series.$, b));
                break;
            case 601:
                this.b.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PlotAreaRegion.$t = markType(CT_PlotAreaRegion, 'CT_PlotAreaRegion', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_PlotAreaEx extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
        this.c = null;
        this.e = null;
        this.d = new List$1(CT_Axis.$, 0);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1915:
                this.a = typeCast(CT_PlotAreaRegion.$, b);
                break;
            case 1916:
                this.d.add(typeCast(CT_Axis.$, b));
                break;
            case 1570:
                this.c = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 601:
                this.e.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_PlotAreaEx.$t = markType(CT_PlotAreaEx, 'CT_PlotAreaEx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ChartTitle extends ChartExTitleBase {
    constructor() {
        super();
        this.l = Nullable$1.toNullable(ST_SidePos_$type, null);
        this.j = Nullable$1.toNullable(ST_PosAlign_$type, null);
        this.k = Nullable$1.toNullable(Boolean_$type, null);
    }
    static f(a) {
        let b = Nullable$1.toNullable(ST_SidePos_$type, null);
        let c = Nullable$1.toNullable(ST_PosAlign_$type, null);
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = CT_ChartTitle.m(a, b, c, d);
        b = e.p1;
        c = e.p2;
        d = e.p3;
        return ((() => {
            let $ret = new CT_ChartTitle();
            $ret.j = c;
            $ret.k = d;
            $ret.l = b;
            return $ret;
        })());
    }
    static m(a, b, c, d) {
        b = Nullable$1.toNullable(ST_SidePos_$type, null);
        c = Nullable$1.toNullable(ST_PosAlign_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "pos":
                    b = Nullable$1.toNullable(ST_SidePos_$type, XmlNamespaceDefinitionBase.b(ST_SidePos_$type, e.d));
                    break;
                case "align":
                    c = Nullable$1.toNullable(ST_PosAlign_$type, XmlNamespaceDefinitionBase.b(ST_PosAlign_$type, e.d));
                    break;
                case "overlay":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static n(a, b, c = Nullable$1.toNullable(ST_PosAlign_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(ST_SidePos_$type, null)) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c.hasValue) {
            g = "align";
            f = XmlNamespaceDefinitionBase.f(ST_PosAlign_$type, c.value);
            a.ad.h(g, f);
        }
        if (d.hasValue) {
            g = "overlay";
            f = ST_OnOff.g(d.value);
            a.ad.h(g, f);
        }
        if (e.hasValue) {
            g = "pos";
            f = XmlNamespaceDefinitionBase.f(ST_SidePos_$type, e.value);
            a.ad.h(g, f);
        }
        ;
    }
    setProperty(a, b) {
        if (super.d(a, b)) {
            return;
        }
        switch (a) {
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartTitle.$t = markType(CT_ChartTitle, 'CT_ChartTitle', ChartExTitleBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ChartEx extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.d = null;
        this.g = null;
        this.g = new List$1(CT_Extension.$, 0);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 1745:
                this.a = typeCast(CT_ChartTitle.$, b);
                break;
            case 1235:
                this.e = typeCast(CT_PlotAreaEx.$, b);
                break;
            case 890:
                this.c = typeCast(CT_LegendEx.$, b);
                break;
            case 601:
                this.g.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ChartEx.$t = markType(CT_ChartEx, 'CT_ChartEx', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StringValue extends Base {
    constructor() {
        super(...arguments);
        this.e = 0;
        this.c = null;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    toString() {
        return this.b;
    }
    static f(a, b, c) {
        a.ad.p(c, "cx");
        a.ad.h(ChartExElements.a7, b.toString());
    }
}
CT_StringValue.$t = markType(CT_StringValue, 'CT_StringValue');
/**
 * @hidden
 */
export class CT_StringLevel extends Base {
    constructor() {
        super();
        this.b = null;
        this.g = 0;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static h(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "ptCount":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "name":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c, d) {
        a.ad.p(b, "cx");
        let e = null;
        let f = null;
        if (c != null) {
            f = "name";
            e = c;
            a.ad.h(f, e);
        }
        f = "ptCount";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1277:
                this.a.add(typeCast(CT_StringValue.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StringLevel.$t = markType(CT_StringLevel, 'CT_StringLevel', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StringDimension extends Base {
    constructor() {
        super();
        this.d = 0;
        this.a = null;
        this.b = null;
        this.e = null;
        this.e = new List$1(CT_StringLevel.$, 0);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static g(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_StringDimensionType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static h(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "type";
        d = XmlNamespaceDefinitionBase.f(ST_StringDimensionType_$type, c);
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.a = typeCast(CT_Formula.$, b);
                break;
            case 1907:
                this.b = typeCast(CT_Formula.$, b);
                break;
            case 944:
                this.e.add(typeCast(CT_StringLevel.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StringDimension.$t = markType(CT_StringDimension, 'CT_StringDimension', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumericValue extends Base {
    constructor() {
        super(...arguments);
        this.d = 0;
        this.b = 0;
    }
    toString() {
        return numberToString(this.b, CultureInfo.invariantCulture);
    }
    static a(a) {
        let b;
        let c = CT_NumericValue.e(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new CT_NumericValue();
            $ret.d = b;
            return $ret;
        })());
    }
    static e(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "type":
                    b = parseUInt32_1(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static f(a, b, c) {
        a.ad.p(c, "cx");
        a.ad.h(ChartExElements.a7, b.toString());
    }
}
CT_NumericValue.$t = markType(CT_NumericValue, 'CT_NumericValue');
/**
 * @hidden
 */
export class CT_NumericLevel extends Base {
    constructor() {
        super();
        this.b = null;
        this.i = 0;
        this.d = null;
        this.f = null;
        this.a = null;
        this.a = new List$1(CT_NumericValue.$, 0);
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    static j(a, b, c, d) {
        b = 0;
        c = null;
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "ptCount":
                    b = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "formatCode":
                    c = e.d;
                    break;
                case "name":
                    d = e.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static k(a, b, c, d, e) {
        a.ad.p(b, "cx");
        let f = null;
        let g = null;
        if (c != null) {
            g = "formatCode";
            f = c;
            a.ad.h(g, f);
        }
        if (d != null) {
            g = "name";
            f = d;
            a.ad.h(g, f);
        }
        g = "ptCount";
        f = e.toString();
        a.ad.h(g, f);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1277:
                this.a.add(typeCast(CT_NumericValue.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumericLevel.$t = markType(CT_NumericLevel, 'CT_NumericLevel', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_NumericDimension extends Base {
    constructor() {
        super();
        this.d = 0;
        this.a = null;
        this.b = null;
        this.e = null;
        this.e = new List$1(CT_NumericLevel.$, 0);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    static g(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_NumericDimensionType_$type, c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static h(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "type";
        d = XmlNamespaceDefinitionBase.f(ST_NumericDimensionType_$type, c);
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 612:
                this.a = typeCast(CT_Formula.$, b);
                break;
            case 1907:
                this.b = typeCast(CT_Formula.$, b);
                break;
            case 944:
                this.e.add(typeCast(CT_NumericLevel.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_NumericDimension.$t = markType(CT_NumericDimension, 'CT_NumericDimension', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Data extends Base {
    constructor() {
        super();
        this.g = 0;
        this.d = null;
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = new List$1(CT_Extension.$, 0);
    }
    get f() {
        return this.g;
    }
    set f(a) {
        this.g = a;
    }
    static h(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "id":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static i(a, b, c) {
        a.ad.p(b, "cx");
        let d = null;
        let e = null;
        e = "id";
        d = c.toString();
        a.ad.h(e, d);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1087:
                this.a = typeCast(CT_NumericDimension.$, b);
                break;
            case 1604:
                this.b = typeCast(CT_StringDimension.$, b);
                break;
            case 601:
                this.d.add(typeCast(CT_Extension.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Data.$t = markType(CT_Data, 'CT_Data', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoLocationQueryResults extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 717:
                this.a.add(typeCast(CT_GeoLocationQueryResult.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoLocationQueryResults.$t = markType(CT_GeoLocationQueryResults, 'CT_GeoLocationQueryResults', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoPolygons extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 720:
                this.a.add(typeCast(CT_GeoPolygon.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoPolygons.$t = markType(CT_GeoPolygons, 'CT_GeoPolygons', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Copyrights extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 350:
                this.a.add(typeCast(String_$type, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Copyrights.$t = markType(CT_Copyrights, 'CT_Copyrights', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoDataEntityQueryResults extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 708:
                this.a.add(typeCast(CT_GeoDataEntityQueryResult.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataEntityQueryResults.$t = markType(CT_GeoDataEntityQueryResults, 'CT_GeoDataEntityQueryResults', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoDataPointToEntityQueryResults extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 712:
                this.a.add(typeCast(CT_GeoDataPointToEntityQueryResult.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoDataPointToEntityQueryResults.$t = markType(CT_GeoDataPointToEntityQueryResults, 'CT_GeoDataPointToEntityQueryResults', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoChildTypes extends Base {
    constructor() {
        super();
        this.a = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 584:
                this.a.add(EnumUtil.getEnumValue(ST_EntityType_$type, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoChildTypes.$t = markType(CT_GeoChildTypes, 'CT_GeoChildTypes', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoChildEntities extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 714:
                this.a.add(typeCast(CT_GeoHierarchyEntity.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoChildEntities.$t = markType(CT_GeoChildEntities, 'CT_GeoChildEntities', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GeoChildEntitiesQueryResults extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 703:
                this.a.add(typeCast(CT_GeoChildEntitiesQueryResult.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GeoChildEntitiesQueryResults.$t = markType(CT_GeoChildEntitiesQueryResults, 'CT_GeoChildEntitiesQueryResults', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Subtotals extends Base {
    constructor() {
        super();
        this.a = null;
        this.a = new List$1(Number_$type, 0);
    }
    static b(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return b;
    }
    setProperty(a, b) {
        switch (a) {
            case 817:
                this.a.add(typeGetValue(b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Subtotals.$t = markType(CT_Subtotals, 'CT_Subtotals', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FormatOverrides extends Base {
    constructor() {
        super();
        this.b = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 656:
                this.a.add(typeCast(CT_FormatOverride.$, b));
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_FormatOverrides.$t = markType(CT_FormatOverrides, 'CT_FormatOverrides', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class DoubleOrAutoBase extends Base {
    constructor() {
        super();
        this.b = Nullable$1.toNullable(Number_$type, null);
    }
    get a() {
        return this.b.hasValue == false;
    }
    static e(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        if (stringEquals1(a, "auto", 3) == false) {
            let c;
            if (((() => { let d = tryParseNumber(a, c); c = d.p1; return d.ret; })())) {
                b = Nullable$1.toNullable(Number_$type, c);
            }
        }
        return {
            p1: b
        };
    }
    d() {
        return this.b.hasValue ? numberToString(this.b.value, CultureInfo.invariantCulture) : "auto";
    }
}
DoubleOrAutoBase.$t = markType(DoubleOrAutoBase, 'DoubleOrAutoBase');
/**
 * @hidden
 */
export class ST_DoubleOrAutomatic extends DoubleOrAutoBase {
    static f(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = DoubleOrAutoBase.e(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new ST_DoubleOrAutomatic();
            $ret.b = b;
            return $ret;
        })());
    }
}
ST_DoubleOrAutomatic.$t = markType(ST_DoubleOrAutomatic, 'ST_DoubleOrAutomatic', DoubleOrAutoBase.$);
/**
 * @hidden
 */
export class ST_GapWidthRatio extends DoubleOrAutoBase {
    static f(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = DoubleOrAutoBase.e(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new ST_GapWidthRatio();
            $ret.b = b;
            return $ret;
        })());
    }
}
ST_GapWidthRatio.$t = markType(ST_GapWidthRatio, 'ST_GapWidthRatio', DoubleOrAutoBase.$);
/**
 * @hidden
 */
export class ST_ValueAxisUnit extends DoubleOrAutoBase {
    static f(a) {
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = DoubleOrAutoBase.e(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new ST_ValueAxisUnit();
            $ret.b = b;
            return $ret;
        })());
    }
}
ST_ValueAxisUnit.$t = markType(ST_ValueAxisUnit, 'ST_ValueAxisUnit', DoubleOrAutoBase.$);
/**
 * @hidden
 */
export class ST_AxisId extends ValueType {
    constructor() {
        super();
        this.h = 0;
    }
    static c(a) {
        let b;
        let c = ST_AxisId.i(a, b);
        b = c.p1;
        return ((() => {
            let $ret = new ST_AxisId();
            $ret.h = b;
            return $ret;
        })());
    }
    static i(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static k(a, b, c = true) {
        a.ad.p(ChartExElements.e, "cx");
        let d = null;
        let e = null;
        e = "val";
        d = b.toString();
        a.ad.h(e, d);
        if (c) {
            a.ad.k();
        }
    }
    j(a, b, c, d) {
        ST_AxisId.k(a, this.h, true);
    }
    toString() {
        return this.h.toString();
    }
    static f(a) {
        return a.h;
    }
    static e(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_AxisId.f(a.value));
    }
    static a(a) {
        return ((() => {
            let $ret = new ST_AxisId();
            $ret.h = a;
            return $ret;
        })());
    }
    static d(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_AxisId.$, null);
        }
        return Nullable$1.toNullable(ST_AxisId.$, ST_AxisId.a(a.value));
    }
}
ST_AxisId.$t = markStruct(ST_AxisId, 'ST_AxisId');
/**
 * @hidden
 */
export class ChartExExtensions extends Base {
    static ag(a, b, c, d, e) {
        d.p(e, "cx");
        d.l(DrawingMLMain.an);
        if (a.b != null) {
            ChartExExtensions.ae(a.b, b, c, d, ChartExElements.l);
        }
        if (a.d != null) {
            ChartExExtensions.af(a.d, b, c, d, ChartExElements.k);
        }
        if (a.j != null) {
            DMLExtensions.a5(a.j, b, c, d, ChartExElements.b5);
        }
        if (a.k != null) {
            a.k.e(b, c, d, ChartExElements.cd);
        }
        if (a.h != null) {
            ChartExExtensions.ci(a.h, b, c, d, ChartExElements.o);
        }
        if (a.n != null) {
            ChartExExtensions.cs(a.n, b, c, d, ChartExElements.ai);
        }
        if (a.f != null) {
            ChartExExtensions.by(a.f, b, c, d, ChartExElements.bz);
        }
        if (a.m != null) {
            ChartExExtensions.ct(a.m, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static ae(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.ar(a.a, b, c, d, ChartExElements.ab);
        }
        if (a.c != null) {
            ChartExExtensions.cj(a.c, b, c, d);
        }
        if (a.d != null) {
            ChartExExtensions.ct(a.d, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static af(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.ah(a.a, b, c, d, ChartExElements.ca);
        }
        if (a.e != null) {
            ChartExExtensions.bv(a.e, b, c, d, ChartExElements.bw);
        }
        if (a.c != null) {
            ChartExExtensions.bl(a.c, b, c, d, ChartExElements.a9);
        }
        if (a.g != null) {
            ChartExExtensions.ct(a.g, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static au(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.cs(a.a, b, c, d, ChartExElements.ah);
        }
        d.k();
    }
    static by(a, b, c, d, e) {
    }
    static ar(a, b, c, d, e) {
        CT_ExternalDataEx.g(b, e, a.c);
        if (a.a != null) {
            a.a.q(b, c, d, ChartExElements.c, "cx");
        }
        d.k();
    }
    static ak(a, b, c, d, e) {
        CT_Data.i(b, e, a.f);
        if (a.a != null) {
            ChartExExtensions.bo(a.a, b, c, d, ChartExElements.bo);
        }
        else if (a.c != null) {
            ChartExExtensions.b4(a.c, b, c, d, ChartExElements.b7);
        }
        if (a.b != null) {
            ChartExExtensions.b4(a.b, b, c, d, ChartExElements.b7);
        }
        if (a.d != null) {
            ChartExExtensions.ct(a.d, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bo(a, b, c, d, e) {
        CT_NumericDimension.h(b, e, a.c);
        if (a.a != null) {
            ChartExExtensions.av(a.a, b, c, d, ChartExElements.ae);
        }
        if (a.b != null) {
            ChartExExtensions.av(a.b, b, c, d, ChartExElements.bm);
        }
        if (a.e != null) {
            ChartExExtensions.ck(a.e, b, c, d);
        }
        d.k();
    }
    static b4(a, b, c, d, e) {
        CT_StringDimension.h(b, e, a.c);
        if (a.a != null) {
            ChartExExtensions.av(a.a, b, c, d, ChartExElements.ae);
        }
        if (a.b != null) {
            ChartExExtensions.av(a.b, b, c, d, ChartExElements.bm);
        }
        if (a.e != null) {
            ChartExExtensions.cl(a.e, b, c, d);
        }
        d.k();
    }
    static av(a, b, c, d, e) {
        CT_Formula.f(b, a.b, e);
        d.u(a.d);
        d.k();
    }
    static b6(a, b, c, d, e) {
        CT_StringValue.f(b, a.d, e);
        d.u(a.b);
        d.k();
    }
    static bq(a, b, c, d, e) {
        CT_NumericValue.f(b, a.d, e);
        d.u(numberToString(a.b, CultureInfo.invariantCulture));
        d.k();
    }
    static bp(a, b, c, d, e) {
        CT_NumericLevel.k(b, e, a.c, a.e, a.h);
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                ChartExExtensions.bq(f, b, c, d, ChartExElements.b0);
            }
        }
        d.k();
    }
    static ah(a, b, c, d, e) {
        CT_ChartTitle.n(b, e, a.j, a.k, a.l);
        if (a.a != null) {
            ChartExExtensions.b8(a.a, b, c, d, ChartExElements.cb);
        }
        if (a.b != null) {
            DMLExtensions.a5(a.b, b, c, d, ChartExElements.b5);
        }
        if (a.c != null) {
            a.c.e(b, c, d, ChartExElements.cd);
        }
        if (a.e != null) {
            ChartExExtensions.ct(a.e, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bv(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.bw(a.a, b, c, d, ChartExElements.bx);
        }
        if (a.d != null && a.d.count > 0) {
            for (let f of fromEnum(a.d)) {
                ChartExExtensions.y(f, b, c, d, ChartExElements.d);
            }
        }
        if (a.c != null) {
            DMLExtensions.a5(a.c, b, c, d, ChartExElements.b5);
        }
        if (a.e != null) {
            ChartExExtensions.ct(a.e, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bl(a, b, c, d, e) {
        CT_LegendEx.p(b, e, a.h, a.j, a.l);
        if (a.d != null) {
            DMLExtensions.a5(a.d, b, c, d, ChartExElements.b5);
        }
        if (a.e != null) {
            a.e.e(b, c, d, ChartExElements.cd);
        }
        if (a.g != null) {
            ChartExExtensions.ct(a.g, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static b8(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.b9(a.a, b, c, d, ChartExElements.cc);
        }
        if (a.b != null) {
            a.b.e(b, c, d, ChartExElements.b2);
        }
        d.k();
    }
    static b9(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.av(a.a, b, c, d, ChartExElements.ae);
        }
        if (a.c != null) {
            ChartExExtensions.cw(a.c, b, c, d, ChartExElements.cg);
        }
        d.k();
    }
    static bw(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.bx(a.a, b, c, d, ChartExElements.by);
        }
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                ChartExExtensions.b0(f, b, c, d, ChartExElements.b4);
            }
        }
        if (a.b != null) {
            ChartExExtensions.ct(a.b, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static y(a, b, c, d, e) {
        CT_Axis.ad(b, e, a.w, a.aa);
        if (a.e != null) {
            ChartExExtensions.ad(a.e, b, c, d, ChartExElements.j);
        }
        if (a.r != null) {
            ChartExExtensions.cc(a.r, b, c, d, ChartExElements.ch);
        }
        if (a.a != null) {
            ChartExExtensions.z(a.a, b, c, d, ChartExElements.ca);
        }
        if (a.c != null) {
            ChartExExtensions.aa(a.c, b, c, d, ChartExElements.ce);
        }
        if (a.f != null) {
            ChartExExtensions.bj(a.f, b, c, d, ChartExElements.bb);
        }
        if (a.h != null) {
            ChartExExtensions.bj(a.h, b, c, d, ChartExElements.bj);
        }
        if (a.n != null) {
            ChartExExtensions.cb(a.n, b, c, d, ChartExElements.bc);
        }
        if (a.p != null) {
            ChartExExtensions.cb(a.p, b, c, d, ChartExElements.bk);
        }
        if (a.l != null) {
            ChartExExtensions.ca(a.l, b, c, d, ChartExElements.b9);
        }
        if (a.j != null) {
            ChartExExtensions.bn(a.j, b, c, d, ChartExElements.bp);
        }
        if (a.s != null) {
            DMLExtensions.a5(a.s, b, c, d, ChartExElements.b5);
        }
        if (a.t != null) {
            a.t.e(b, c, d, ChartExElements.cd);
        }
        if (a.v != null) {
            ChartExExtensions.ct(a.v, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static z(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            ChartExExtensions.b8(a.a, b, c, d, ChartExElements.cb);
        }
        if (a.b != null) {
            DMLExtensions.a5(a.b, b, c, d, ChartExElements.b5);
        }
        if (a.c != null) {
            a.c.e(b, c, d, ChartExElements.cd);
        }
        if (a.e != null) {
            ChartExExtensions.ct(a.e, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bx(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, ChartExElements.b5);
        }
        if (a.b != null) {
            ChartExExtensions.ct(a.b, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static b0(a, b, c, d, e) {
        CT_Series.ae(b, e, a.u, a.w, a.y, a.ab, a.m);
        if (a.g != null) {
            ChartExExtensions.b8(a.g, b, c, d, ChartExElements.cb);
        }
        if (a.o != null) {
            DMLExtensions.a5(a.o, b, c, d, ChartExElements.b5);
        }
        if (a.k != null) {
            ChartExExtensions.cg(a.k, b, c, d, ChartExElements.cj);
        }
        if (a.i != null) {
            ChartExExtensions.cf(a.i, b, c, d, ChartExElements.ci);
        }
        if (a.r != null) {
            for (let f of fromEnum(a.r)) {
                ChartExExtensions.aq(f, b, c, d, ChartExElements.w);
            }
        }
        if (a.c != null) {
            ChartExExtensions.ao(a.c, b, c, d, ChartExElements.v);
        }
        if (a.a != null) {
            ChartExExtensions.al(a.a, b, c, d, ChartExElements.s);
        }
        if (a.e != null) {
            ChartExExtensions.b2(a.e, b, c, d, ChartExElements.a8);
        }
        if (a.q != null) {
            ChartExExtensions.cm(a.q, b, c, d);
        }
        if (a.s != null) {
            ChartExExtensions.ct(a.s, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static cg(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.e != null) {
            a.e.save1(b, c, d, ChartExElements.bi);
        }
        if (a.c != null) {
            a.c.save1(b, c, d, ChartExElements.bg);
        }
        if (a.a != null) {
            a.a.save1(b, c, d, ChartExElements.be);
        }
        d.k();
    }
    static cf(a, b, c, d, e) {
        CT_ValueColorPositions.l(b, e, a.h);
        if (a.c != null) {
            ChartExExtensions.cd(a.c, b, c, d, ChartExElements.bh);
        }
        if (a.e != null) {
            ChartExExtensions.ce(a.e, b, c, d, ChartExElements.bf);
        }
        if (a.a != null) {
            ChartExExtensions.cd(a.a, b, c, d, ChartExElements.bd);
        }
        d.k();
    }
    static aq(a, b, c, d, e) {
        CT_DataPoint.g(b, e, a.d);
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, ChartExElements.b5);
        }
        if (a.b != null) {
            ChartExExtensions.ct(a.b, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static ao(a, b, c, d, e) {
        CT_DataLabels.l(b, e, a.g);
        if (a.b != null) {
            ChartExExtensions.bn(a.b, b, c, d, ChartExElements.bp);
        }
        if (a.c != null) {
            DMLExtensions.a5(a.c, b, c, d, ChartExElements.b5);
        }
        if (a.d != null) {
            a.d.e(b, c, d, ChartExElements.cd);
        }
        if (a.a != null) {
            ChartExExtensions.ap(a.a, b, c, d, ChartExElements.ck);
        }
        if (a.h != null) {
            ChartExExtensions.cw(a.h, b, c, d, ChartExElements.b3);
        }
        if (a.i != null && a.i.count > 0) {
            for (let f of fromEnum(a.i)) {
                ChartExExtensions.am(f, b, c, d, ChartExElements.t);
            }
        }
        if (a.j != null && a.j.count > 0) {
            for (let g of fromEnum(a.j)) {
                ChartExExtensions.an(g, b, c, d, ChartExElements.u);
            }
        }
        if (a.f != null) {
            ChartExExtensions.ct(a.f, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static al(a, b, c, d, e) {
        CT_DataId.e(b, e, a.b);
        d.k();
    }
    static b2(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.e != null) {
            ChartExExtensions.bt(a.e, b, c, d, ChartExElements.bu);
        }
        if (a.g != null) {
            ChartExExtensions.bz(a.g, b, c, d, ChartExElements.b1);
        }
        if (a.i != null) {
            ChartExExtensions.b1(a.i, b, c, d, ChartExElements.ck);
        }
        if (a.a != null) {
            ChartExExtensions.x(a.a, b, c, d, ChartExElements.b);
        }
        if (a.b != null) {
            ChartExExtensions.ac(a.b, b, c, d, ChartExElements.h);
        }
        if (a.c != null) {
            ChartExExtensions.ba(a.c, b, c, d, ChartExElements.ax);
        }
        if (a.k != null) {
            ChartExExtensions.b3(a.k, b, c, d, ChartExElements.b6);
        }
        if (a.m != null) {
            ChartExExtensions.b7(a.m, b, c, d, ChartExElements.b8);
        }
        if (a.n != null) {
            ChartExExtensions.ct(a.n, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static b1(a, b, c, d, e) {
        CT_SeriesElementVisibilities.n(b, e, a.b, a.d, a.f, a.h, a.j);
        d.k();
    }
    static cd(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.as(a.a, b, c, d, ChartExElements.ad);
        }
        if (a.b != null) {
            ChartExExtensions.bm(a.b, b, c, d, ChartExElements.bn);
        }
        if (a.c != null) {
            ChartExExtensions.bu(a.c, b, c, d, ChartExElements.bv);
        }
        d.k();
    }
    static ce(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.bm(a.a, b, c, d, ChartExElements.bn);
        }
        if (a.b != null) {
            ChartExExtensions.bu(a.b, b, c, d, ChartExElements.bv);
        }
        d.k();
    }
    static as(a, b, c, d, e) {
        d.p(e, "cx");
        d.k();
    }
    static bm(a, b, c, d, e) {
        CT_NumberColorPosition.e(b, e, a.a);
        d.k();
    }
    static bu(a, b, c, d, e) {
        CT_PercentageColorPosition.e(b, e, a.a);
        d.k();
    }
    static bn(a, b, c, d, e) {
        CT_NumberFormat.g(b, e, a.a, a.c);
        d.k();
    }
    static ap(a, b, c, d, e) {
        CT_DataLabelVisibilities.i(b, e, a.a, a.c, a.e);
        d.k();
    }
    static cw(a, b, c, d, e) {
        d.p(e, "cx");
        d.u(a);
        d.k();
    }
    static am(a, b, c, d, e) {
        CT_DataLabel.k(b, e, a.g, a.i);
        if (a.b != null) {
            ChartExExtensions.bn(a.b, b, c, d, ChartExElements.bp);
        }
        if (a.c != null) {
            DMLExtensions.a5(a.c, b, c, d, ChartExElements.b5);
        }
        if (a.d != null) {
            a.d.e(b, c, d, ChartExElements.cd);
        }
        if (a.a != null) {
            ChartExExtensions.ap(a.a, b, c, d, ChartExElements.ck);
        }
        if (a.h != null) {
            ChartExExtensions.cw(a.h, b, c, d, ChartExElements.b3);
        }
        if (a.f != null) {
            ChartExExtensions.ct(a.f, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static an(a, b, c, d, e) {
        CT_DataLabelHidden.e(b, e, a.b);
        d.k();
    }
    static bt(a, b, c, d, e) {
        CT_ParentLabelLayout.e(b, e, a.a);
        d.k();
    }
    static bz(a, b, c, d, e) {
        CT_RegionLabelLayout.e(b, e, a.a);
        d.k();
    }
    static x(a, b, c, d, e) {
        d.p(e, "cx");
        d.k();
    }
    static ac(a, b, c, d, e) {
        CT_Binning.o(b, e, a.h, a.d, a.f);
        if (a.a != null) {
            a.a.i(b, c, d, ChartExElements.i, "cx");
        }
        if (a.b != null) {
            a.b.i(b, c, d, ChartExElements.g, "cx");
        }
        d.k();
    }
    static ba(a, b, c, d, e) {
        CT_Geography.p(b, e, a.d, a.f, a.h, a.j, a.l);
        if (a.a != null) {
            ChartExExtensions.aw(a.a, b, c, d, ChartExElements.aj);
        }
        d.k();
    }
    static b3(a, b, c, d, e) {
        CT_Statistics.e(b, e, a.a);
        d.k();
    }
    static b7(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                let g = ((() => {
                    let $ret = new CT_UnsignedInt();
                    $ret.g = f;
                    return $ret;
                })());
                g.i(b, c, d, ChartExElements.a7, "cx");
            }
        }
        d.k();
    }
    static aw(a, b, c, d, e) {
        CT_GeoCache.g(b, e, a.c);
        if (a.b != null) {
            ChartExExtensions.cw(a.b, b, c, d, ChartExElements.f);
        }
        if (a.a != null) {
            ChartExExtensions.ai(a.a, b, c, d, ChartExElements.n);
        }
        d.k();
    }
    static ai(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.d != null) {
            ChartExExtensions.cn(a.d, b, c, d);
        }
        if (a.b != null) {
            ChartExExtensions.co(a.b, b, c, d);
        }
        if (a.c != null) {
            ChartExExtensions.cp(a.c, b, c, d);
        }
        if (a.a != null) {
            ChartExExtensions.cq(a.a, b, c, d);
        }
        d.k();
    }
    static bf(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.cn(a.a, b, c, d);
        }
        d.k();
    }
    static a5(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.co(a.a, b, c, d);
        }
        d.k();
    }
    static a9(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.cp(a.a, b, c, d);
        }
        d.k();
    }
    static a0(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.cq(a.a, b, c, d);
        }
        d.k();
    }
    static be(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.bd(a.a, b, c, d, ChartExElements.a0);
        }
        if (a.c != null) {
            ChartExExtensions.bg(a.c, b, c, d, ChartExElements.a3);
        }
        d.k();
    }
    static bd(a, b, c, d, e) {
        CT_GeoLocationQuery.m(b, e, a.c, a.e, a.g, a.i, a.a);
        d.k();
    }
    static bg(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.bc(a.a, b, c, d, ChartExElements.az);
        }
        d.k();
    }
    static bc(a, b, c, d, e) {
        CT_GeoLocation.m(b, e, a.e, a.g, a.i, a.c);
        if (a.a != null) {
            ChartExExtensions.w(a.a, b, c, d, ChartExElements.a);
        }
        d.k();
    }
    static w(a, b, c, d, e) {
        CT_Address.r(b, e, a.b, a.d, a.f, a.h, a.j, a.l, a.n);
        d.k();
    }
    static a4(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.c != null) {
            ChartExExtensions.a3(a.c, b, c, d, ChartExElements.aq);
        }
        if (a.a != null) {
            ChartExExtensions.a2(a.a, b, c, d, ChartExElements.ap);
        }
        d.k();
    }
    static a3(a, b, c, d, e) {
        CT_GeoDataEntityQuery.g(b, e, a.c, a.a);
        d.k();
    }
    static a2(a, b, c, d, e) {
        CT_GeoData.s(b, e, a.e, a.m, a.o, a.g, a.i, a.k);
        if (a.d != null) {
            ChartExExtensions.cr(a.d, b, c, d);
        }
        if (a.b != null) {
            ChartExExtensions.cv(a.b, b, c, d, ChartExElements.q, ChartExElements.p, "cx");
        }
        d.k();
    }
    static bi(a, b, c, d, e = ChartExElements.a5) {
        let f = a.a;
        if (f == null || f.count == 0) {
            return;
        }
        ChartExExtensions.cr(f, b, c, d);
    }
    static aj(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.cv(a.a, b, c, d, ChartExElements.p, null, null);
        }
        d.k();
    }
    static bh(a, b, c, d, e) {
        CT_GeoPolygon.g(b, e, a.b, a.c, a.d);
        d.k();
    }
    static a8(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.a6(a.a, b, c, d, ChartExElements.at);
        }
        if (a.c != null) {
            ChartExExtensions.a7(a.c, b, c, d, ChartExElements.au);
        }
        d.k();
    }
    static a6(a, b, c, d, e) {
        CT_GeoDataPointQuery.j(b, e, a.b, a.d, a.f);
        d.k();
    }
    static a7(a, b, c, d, e) {
        CT_GeoDataPointToEntityQuery.h(b, e, a.d, a.b);
        d.k();
    }
    static az(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.ay(a.a, b, c, d, ChartExElements.al);
        }
        if (a.c != null) {
            ChartExExtensions.cu(a.c, b, c, d, ChartExElements.ak, "cx");
        }
        d.k();
    }
    static ay(a, b, c, d, e) {
        CT_GeoChildEntitiesQuery.f(b, e, a.b);
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                ChartExExtensions.ch(f, b, c, d, ChartExElements.x);
            }
        }
        d.k();
    }
    static ax(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                ChartExExtensions.bb(f, b, c, d, ChartExElements.ay);
            }
        }
        d.k();
    }
    static a1(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            for (let f of fromEnum(a.a)) {
                ChartExExtensions.ch(f, b, c, d, ChartExElements.x);
            }
        }
        d.k();
    }
    static ch(a, b, c, d, e) {
        d.p(e, "cx");
        d.u(EnumUtil.getName(ST_EntityType_$type, a));
        d.k();
    }
    static bb(a, b, c, d, e) {
        CT_GeoHierarchyEntity.j(b, e, a.d, a.f, a.b);
        d.k();
    }
    static ad(a, b, c, d, e) {
        CT_CategoryAxisScaling.e(b, e, a.a);
        d.k();
    }
    static cc(a, b, c, d, e) {
        CT_ValueAxisScaling.l(b, e, a.f, a.b, a.d, a.h);
        d.k();
    }
    static aa(a, b, c, d, e) {
        CT_AxisUnits.h(b, e, a.d);
        if (a.a != null) {
            ChartExExtensions.ab(a.a, b, c, d, ChartExElements.cf);
        }
        if (a.c != null) {
            ChartExExtensions.ct(a.c, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bj(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, ChartExElements.b5);
        }
        if (a.b != null) {
            ChartExExtensions.ct(a.b, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static cb(a, b, c, d, e) {
        CT_TickMarks.f(b, e, a.b);
        if (a.a != null) {
            ChartExExtensions.ct(a.a, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static ca(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.ct(a.a, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static ab(a, b, c, d, e) {
        d.p(e, "cx");
        if (a.a != null) {
            ChartExExtensions.b8(a.a, b, c, d, ChartExElements.cb);
        }
        if (a.b != null) {
            DMLExtensions.a5(a.b, b, c, d, ChartExElements.b5);
        }
        if (a.c != null) {
            a.c.e(b, c, d, ChartExElements.cd);
        }
        if (a.d != null) {
            ChartExExtensions.ct(a.d, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static at(a, b, c, d, e) {
        CT_FormatOverride.g(b, e, a.d);
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, ChartExElements.b5);
        }
        if (a.b != null) {
            ChartExExtensions.ct(a.b, b, c, d, ChartExElements.ac);
        }
        d.k();
    }
    static bk(a, b, c, d, e) {
        CT_HeaderFooter.x(b, e, a.d, a.f, a.h);
        if (a.t != null) {
            ChartExExtensions.cw(a.t, b, c, d, ChartExElements.br);
        }
        if (a.r != null) {
            ChartExExtensions.cw(a.r, b, c, d, ChartExElements.bq);
        }
        if (a.l != null) {
            ChartExExtensions.cw(a.l, b, c, d, ChartExElements.z);
        }
        if (a.j != null) {
            ChartExExtensions.cw(a.j, b, c, d, ChartExElements.y);
        }
        if (a.p != null) {
            ChartExExtensions.cw(a.p, b, c, d, ChartExElements.ag);
        }
        if (a.n != null) {
            ChartExExtensions.cw(a.n, b, c, d, ChartExElements.af);
        }
        d.k();
    }
    static br(a, b, c, d, e) {
        CT_PageMargins.o(b, e, a.a, a.c, a.e, a.g, a.i, a.k);
        d.k();
    }
    static bs(a, b, c, d, e) {
        CT_PageSetup.ae(b, e, a.h, a.j, a.l, a.n, a.p, a.r, a.t, a.v, a.x);
        d.k();
    }
    static v(a, b, c, d, e) {
        CT_Extension.e(b, e, a.b);
        d.k();
    }
    static b5(a, b, c, d, e) {
        let f = a.a;
        if (f == null || f.count == 0) {
            return;
        }
        CT_StringLevel.i(b, e, a.c, a.f);
        for (let g of fromEnum(f)) {
            ChartExExtensions.b6(g, b, c, d, ChartExElements.b0);
        }
        d.k();
    }
    static ci(a, b, c, d, e) {
        CT_ColorMapping.ad(b, e, a.d, a.f, a.h, a.j, a.l, a.n, a.p, a.r, a.t, a.v, a.x, a.z);
        if (a.b != null) {
            a.b.d(b, c, d, DrawingMLMain.dr);
        }
    }
    static cs(a, b, c, d, e = ChartExElements.ai) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(e, "cx");
        for (let f of fromEnum(a)) {
            ChartExExtensions.at(f, b, c, d, ChartExElements.ah);
        }
        d.k();
    }
    static ct(a, b, c, d, e = ChartExElements.ac) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(e, "cx");
        for (let f of fromEnum(a)) {
            ChartExExtensions.v(f, b, c, d, ChartExElements.aa);
        }
        d.k();
    }
    static cj(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        for (let e of fromEnum(a)) {
            ChartExExtensions.ak(e, b, c, d, ChartExElements.r);
        }
    }
    static ck(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        for (let e of fromEnum(a)) {
            ChartExExtensions.bp(e, b, c, d, ChartExElements.ba);
        }
    }
    static cl(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        for (let e of fromEnum(a)) {
            ChartExExtensions.b5(e, b, c, d, ChartExElements.ba);
        }
    }
    static cm(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        for (let e of fromEnum(a)) {
            e.j(b, c, d, ChartExElements.e);
        }
    }
    static cn(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(ChartExElements.a2, "cx");
        for (let e of fromEnum(a)) {
            ChartExExtensions.be(e, b, c, d, ChartExElements.a1);
        }
        d.k();
    }
    static co(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(ChartExElements.as, "cx");
        for (let e of fromEnum(a)) {
            ChartExExtensions.a4(e, b, c, d, ChartExElements.ar);
        }
        d.k();
    }
    static cp(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(ChartExElements.aw, "cx");
        for (let e of fromEnum(a)) {
            ChartExExtensions.a8(e, b, c, d, ChartExElements.av);
        }
        d.k();
    }
    static cq(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(ChartExElements.an, "cx");
        for (let e of fromEnum(a)) {
            ChartExExtensions.az(e, b, c, d, ChartExElements.am);
        }
        d.k();
    }
    static cu(a, b, c, d, e, f) {
        if (a == null || a.count == 0) {
            return;
        }
        let g = stringIsNullOrEmpty(e) == false;
        if (g) {
            d.p(e, f);
        }
        for (let h of fromEnum(a)) {
            ChartExExtensions.bb(h, b, c, d, ChartExElements.ay);
        }
        if (g) {
            d.k();
        }
    }
    static cr(a, b, c, d) {
        if (a == null || a.count == 0) {
            return;
        }
        d.p(ChartExElements.a5, "cx");
        for (let e of fromEnum(a)) {
            ChartExExtensions.bh(e, b, c, d, ChartExElements.a4);
        }
        d.k();
    }
    static cv(a, b, c, d, e, f, g) {
        if (a == null || a.count == 0) {
            return;
        }
        let h = stringIsNullOrEmpty(f) == false;
        if (h) {
            d.p(f, g);
        }
        for (let i of fromEnum(a)) {
            ChartExExtensions.cw(i, b, c, d, e);
        }
        if (h) {
            d.k();
        }
    }
    static a(a) {
        switch (a) {
            case 1: return 9;
            case 0: return 10;
            case 2: return 1;
            case 3: return 2;
            case 4: return 3;
            case 5: return 6;
            case 6: return 4;
            case 7: return 7;
            case 8: return 8;
            default: return 0;
        }
    }
    static k(a) {
        switch (a) {
            case 8: return 8;
            case 9: return 1;
            case 10: return 0;
            case 1: return 2;
            case 2: return 3;
            case 3: return 4;
            case 6: return 5;
            case 7: return 7;
            default: return 6;
        }
    }
    static f(a, b) {
        switch (a) {
            case 3: return 0;
            case 1: break;
            case 0: return b == 2 ? 8 : b == 0 ? 7 : 1;
            case 2: return b == 2 ? 9 : b == 0 ? 4 : 2;
        }
        return 3;
    }
    static s(a) {
        let b = 3;
        let c = 1;
        switch (a) {
            case 6:
            case 5: return null;
            case 0:
                b = 3;
                c = 1;
                break;
            case 8:
                b = 0;
                c = 2;
                break;
            case 9:
                b = 2;
                c = 2;
                break;
            case 1:
                b = 0;
                c = 1;
                break;
            case 2:
                b = 2;
                c = 1;
                break;
            case 3:
                b = 1;
                c = 1;
                break;
            case 7:
                b = 0;
                c = 0;
                break;
            case 4:
                b = 2;
                c = 0;
                break;
        }
        return Tuple.a(ST_SidePos_$type, ST_PosAlign_$type, b, c);
    }
    static h(a) {
        switch (a) {
            case 2: return 4;
            case 0: return 2;
            case 1: return 3;
            default: return 4142;
        }
    }
    static q(a) {
        switch (a) {
            case 4: return 2;
            case 2: return 0;
            case 3: return 1;
            case 4142: break;
        }
        return 3;
    }
    static b(a) {
        switch (a) {
            case 7: return -9;
            case 6: return -8;
            case 0: return -2;
            case 3: return -5;
            case 4: return -6;
            case 9: return 1;
            case 5: return -7;
            case 2: return -4;
            case 1: return -3;
            case 8: return -10;
            default: break;
        }
        return -4142;
    }
    static i(a) {
        if (a == null) {
            return null;
        }
        return ((() => {
            let $ret = new CT_Tx();
            $ret.b = a.b;
            return $ret;
        })());
    }
    static g(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            default: return 2;
        }
    }
    static n(a) {
        switch (a) {
            case 0: return 0;
            case 1: return 1;
            default: return 2;
        }
    }
    static p(a) {
        switch (a) {
            case 114: return 0;
            case 51: break;
            case 117: break;
            case 116: return 3;
            case 118: return 5;
            case 119: return 6;
            case 120: return 7;
            case 115: return 2;
            case 121: return 4;
        }
        return 1;
    }
    static u(a, b, c, d) {
        if (a == null) {
            return;
        }
        a.clear();
        let e = new List$1(Axis.$, 0);
        switch (b.chartType) {
            case 119:
            case 118:
            case 121: return;
            case 114:
            case 117:
            case 120:
                e.add(b._axisCollection$i.item(1, 1));
                e.add(b._axisCollection$i.item(2, 1));
                break;
            case 116:
                e.add(b._axisCollection$i.item(1, 1));
                e.add(b._axisCollection$i.item(2, 1));
                e.add(b._axisCollection$i.item(2, 2));
                break;
            case 115:
                e.add(b._axisCollection$i.item(1, 1));
                e.add(b._axisCollection$i.item(2, 1));
                break;
        }
        if (e.count == 0) {
            return;
        }
        for (let f of fromEnum(e)) {
            if (f == null) {
                continue;
            }
            let g = new CT_Axis();
            ChartExExtensions.t(g, f, b, c, d);
            a.add(g);
        }
    }
    static t(a, b, c, d, e) {
        if (b == null) {
            return;
        }
        a.aa = intSToU(b._cg);
        a.w = Nullable$1.toNullable(Boolean_$type, (b.visible == false));
        if (b.type == 1) {
            let f = Nullable$1.toNullable(Number_$type, null);
            if (b._gapWidth$i.hasValue) {
                f = Nullable$1.toNullable(Number_$type, b._gapWidth$i.value / 100);
            }
            a.e = ((() => {
                let $ret = new CT_CategoryAxisScaling();
                $ret.a = ((() => {
                    let $ret = new ST_GapWidthRatio();
                    $ret.b = f;
                    return $ret;
                })());
                return $ret;
            })());
        }
        else {
            let g = Nullable$1.toNullable(Number_$type, null);
            let h = Nullable$1.toNullable(Number_$type, null);
            if (b.maximumScaleIsAuto == false) {
                g = Nullable$1.toNullable(Number_$type, b.maximumScale);
            }
            if (b.minimumScaleIsAuto == false) {
                h = Nullable$1.toNullable(Number_$type, b.minimumScale);
            }
            a.r = ((() => {
                let $ret = new CT_ValueAxisScaling();
                $ret.b = ((() => {
                    let $ret = new ST_DoubleOrAutomatic();
                    $ret.b = g;
                    return $ret;
                })());
                $ret.d = ((() => {
                    let $ret = new ST_DoubleOrAutomatic();
                    $ret.b = h;
                    return $ret;
                })());
                return $ret;
            })());
            let i = ChartExExtensions.r(b.displayUnit);
            if (i.hasValue) {
                a.c = ((() => {
                    let $ret = new CT_AxisUnits();
                    $ret.d = Nullable$1.toNullable(ST_AxisUnit_$type, i.value);
                    return $ret;
                })());
                if (b.displayUnitLabel != null) {
                    a.c.a = ChartExExtensions.j(b, d, e);
                }
            }
        }
        if (b.majorGridLines != null) {
            a.f = ((() => {
                let $ret = new CT_Gridlines();
                $ret.a = ChartSerializer.a5(d, null, b.majorGridLines, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
        }
        if (b.minorGridLines != null) {
            a.h = ((() => {
                let $ret = new CT_Gridlines();
                $ret.a = ChartSerializer.a5(d, null, b.minorGridLines, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
        }
        a.j = ((() => {
            let $ret = new CT_NumberFormat();
            $ret.c = b.tickLabels.numberFormat;
            $ret.a = Nullable$1.toNullable(Boolean_$type, b.tickLabels.numberFormatLinked);
            return $ret;
        })());
        if (b.tickLines != null) {
            a.s = ChartSerializer.a5(d, null, b.tickLines, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        let j = b.tickLabels;
        if (j._aw()) {
            let k = -1000;
            let l = ChartSerializer.a9(d, k, Nullable$1.toNullable(TextHorizontalOverflow_$type, null), Nullable$1.toNullable(TextVerticalOverflow_$type, 2), 0, true, Nullable$1.toNullable(VerticalTitleAlignment_$type, -4108));
            a.t = ChartSerializer.a7(l, j._an, null, j.readingOrder, d, null, true);
        }
        a.l = new CT_TickLabels();
        let m = ChartExExtensions.q(b.minorTickMark);
        let n = ChartExExtensions.q(b.majorTickMark);
        a.n = ((() => {
            let $ret = new CT_TickMarks();
            $ret.b = Nullable$1.toNullable(ST_TickMarksType_$type, n);
            return $ret;
        })());
        a.p = ((() => {
            let $ret = new CT_TickMarks();
            $ret.b = Nullable$1.toNullable(ST_TickMarksType_$type, m);
            return $ret;
        })());
        let o = b.axisTitle;
        if (o != null) {
            a.a = ChartExSerializer.a(o, d);
        }
    }
    static j(a, b, c) {
        let d = a != null ? a.displayUnitLabel : null;
        if (d == null) {
            return null;
        }
        let e = ChartSerializer.a9(b, d.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, 0), Nullable$1.toNullable(TextVerticalOverflow_$type, 0), d.textDirection, d.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
        let f = ((() => {
            let $ret = new CT_AxisUnitsLabel();
            $ret.b = ChartSerializer.a5(b, d.fill, d.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            return $ret;
        })());
        let g = d.text;
        if (g == null) {
            if (a.displayUnit == -4114) {
                g = new FormattedString(numberToString(a.displayUnitCustom, CultureInfo.currentCulture));
            }
            else {
                let h = c._cs(a.displayUnit);
                if (h != null) {
                    g = new FormattedString(h);
                }
            }
        }
        if (g != null) {
            let i = ChartSerializer.a7(e, d.defaultFont, g, d.readingOrder, b);
            f.a = ((() => {
                let $ret = new CT_Text();
                $ret.b = i;
                return $ret;
            })());
        }
        else {
            f.c = ChartSerializer.a7(e, d.defaultFont, null, d.readingOrder, b, null);
        }
        return f;
    }
    static r(a) {
        switch (a) {
            case -4142: return Nullable$1.toNullable(ST_AxisUnit_$type, null);
            case -8: return Nullable$1.toNullable(ST_AxisUnit_$type, 6);
            case -4114:
            case -2: return Nullable$1.toNullable(ST_AxisUnit_$type, 0);
            case -5: return Nullable$1.toNullable(ST_AxisUnit_$type, 3);
            case -10: return Nullable$1.toNullable(ST_AxisUnit_$type, 8);
            case -6: return Nullable$1.toNullable(ST_AxisUnit_$type, 4);
            case 1: return Nullable$1.toNullable(ST_AxisUnit_$type, 9);
            case -7: return Nullable$1.toNullable(ST_AxisUnit_$type, 5);
            case -4: return Nullable$1.toNullable(ST_AxisUnit_$type, 2);
            case -9: return Nullable$1.toNullable(ST_AxisUnit_$type, 7);
            case -3: return Nullable$1.toNullable(ST_AxisUnit_$type, 1);
            default: break;
        }
        return Nullable$1.toNullable(ST_AxisUnit_$type, null);
    }
    static e(a) {
        switch (a) {
            case 0: return 1;
            case 1: return 2;
            case 2: return 3;
            default: return 0;
        }
    }
    static m(a) {
        switch (a) {
            case 1: return 0;
            case 2: return 1;
            case 3: return 2;
            default: return 3;
        }
    }
    static d(a) {
        switch (a) {
            case 5: return 5;
            case 2: return 2;
            case 0: return 0;
            case 1: return 1;
            case 3: return 3;
            case 6: return 6;
            default: return 4;
        }
    }
    static l(a) {
        switch (a) {
            case 4: return 4;
            case 2: return 2;
            case 5: return 5;
            case 1: return 1;
            case 3: return 3;
            case 6: return 6;
            default: return 0;
        }
    }
    static c(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
    static o(a) {
        switch (a) {
            case 1: return 1;
            case 2: return 2;
            default: return 0;
        }
    }
}
ChartExExtensions.$t = markType(ChartExExtensions, 'ChartExExtensions');
/**
 * @hidden
 */
export class ChartExUtils extends Base {
    static a(a) {
        switch (a) {
            case 114:
            case 118:
            case 119: return false;
            default: return true;
        }
    }
    static b(a) {
        switch (a) {
            case 114:
            case 118:
            case 119: return false;
            default: return true;
        }
    }
    static c(a) {
        switch (a) {
            case 114:
            case 117:
            case 116:
            case 118:
            case 119:
            case 120: return DrawingMLChartEx2015_9_8.ap;
            case 115: return DrawingMLChartEx2015_10_21.ap;
            case 121: return DrawingMLChartEx2016_5_10.ap;
            default: return stringEmpty();
        }
    }
}
ChartExUtils.$t = markType(ChartExUtils, 'ChartExUtils');
/**
 * @hidden
 */
export class ChartDrawingAttributes extends Base {
}
ChartDrawingAttributes.$t = markType(ChartDrawingAttributes, 'ChartDrawingAttributes');
/**
 * @hidden
 */
export class ChartDrawingElements extends Base {
}
ChartDrawingElements.$t = markType(ChartDrawingElements, 'ChartDrawingElements');
ChartDrawingElements.o = "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing";
ChartDrawingElements.a = ChartDrawingElements.o + "/absSizeAnchor";
ChartDrawingElements.b = ChartDrawingElements.o + "/blipFill";
ChartDrawingElements.c = ChartDrawingElements.o + "/cNvCxnSpPr";
ChartDrawingElements.d = ChartDrawingElements.o + "/cNvGraphicFramePr";
ChartDrawingElements.e = ChartDrawingElements.o + "/cNvGrpSpPr";
ChartDrawingElements.f = ChartDrawingElements.o + "/cNvPicPr";
ChartDrawingElements.g = ChartDrawingElements.o + "/cNvPr";
ChartDrawingElements.h = ChartDrawingElements.o + "/cNvSpPr";
ChartDrawingElements.i = ChartDrawingElements.o + "/cxnSp";
ChartDrawingElements.j = ChartDrawingElements.o + "/ext";
ChartDrawingElements.k = ChartDrawingElements.o + "/from";
ChartDrawingElements.l = ChartDrawingElements.o + "/graphicFrame";
ChartDrawingElements.m = ChartDrawingElements.o + "/grpSp";
ChartDrawingElements.n = ChartDrawingElements.o + "/grpSpPr";
ChartDrawingElements.p = ChartDrawingElements.o + "/nvCxnSpPr";
ChartDrawingElements.q = ChartDrawingElements.o + "/nvGraphicFramePr";
ChartDrawingElements.r = ChartDrawingElements.o + "/nvGrpSpPr";
ChartDrawingElements.s = ChartDrawingElements.o + "/nvPicPr";
ChartDrawingElements.t = ChartDrawingElements.o + "/nvSpPr";
ChartDrawingElements.u = ChartDrawingElements.o + "/pic";
ChartDrawingElements.v = ChartDrawingElements.o + "/relSizeAnchor";
ChartDrawingElements.w = ChartDrawingElements.o + "/sp";
ChartDrawingElements.x = ChartDrawingElements.o + "/spPr";
ChartDrawingElements.y = ChartDrawingElements.o + "/style";
ChartDrawingElements.z = ChartDrawingElements.o + "/to";
ChartDrawingElements.aa = ChartDrawingElements.o + "/txBody";
ChartDrawingElements.ab = ChartDrawingElements.o + "/x";
ChartDrawingElements.ac = ChartDrawingElements.o + "/xfrm";
ChartDrawingElements.ad = ChartDrawingElements.o + "/y";
/**
 * @hidden
 */
export class CT_GraphicFrameNonVisual extends Base {
    constructor() {
        super();
        this.b = null;
        this.d = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    setProperty(a, b) {
        switch (a) {
            case 202:
                this.a = typeCast(CT_NonVisualDrawingProps.$, b);
                break;
            case 199:
                this.c = typeCast(CT_NonVisualGraphicFrameProperties.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GraphicFrameNonVisual.$t = markType(CT_GraphicFrameNonVisual, 'CT_GraphicFrameNonVisual', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_GraphicFrame extends Base {
    constructor() {
        super();
        this.b = null;
        this.f = null;
        this.d = null;
        this.k = null;
        this.i = Nullable$1.toNullable(Boolean_$type, null);
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get e() {
        return this.f;
    }
    set e(a) {
        this.f = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get j() {
        return this.k;
    }
    set j(a) {
        this.k = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    static m(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "macro":
                    b = d.d;
                    break;
                case "fPublished":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static n(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = null) {
        a.ad.p(b, "cd");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "fPublished";
            e = ST_OnOff.g(c.value);
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "macro";
            e = d;
            a.ad.h(f, e);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1103:
                this.a = typeCast(CT_GraphicFrameNonVisual.$, b);
                break;
            case 1892:
                this.e = typeCast(CT_Transform2D.$, b);
                break;
            case 727:
                this.c = typeCast(CT_GraphicalObject.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_GraphicFrame.$t = markType(CT_GraphicFrame, 'CT_GraphicFrame', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_Shape_ChartDrawing extends Base {
    constructor() {
        super();
        this.o = null;
        this.p = null;
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.e = null;
        this.a = null;
        this.g = null;
        this.c = null;
    }
    get q() {
        return this.o;
    }
    set q(a) {
        this.o = a;
    }
    get r() {
        return this.p;
    }
    set r(a) {
        this.p = a;
    }
    get m() {
        return this.k;
    }
    set m(a) {
        this.k = a;
    }
    get n() {
        return this.l;
    }
    set n(a) {
        this.l = a;
    }
    get f() {
        return this.e;
    }
    set f(a) {
        this.e = a;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    get h() {
        return this.g;
    }
    set h(a) {
        this.g = a;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    static t(a, b, c, d, e) {
        b = null;
        c = null;
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "macro":
                    b = f.d;
                    break;
                case "textlink":
                    c = f.d;
                    break;
                case "fLocksText":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                case "fPublished":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(f.d));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static u(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = null, f = null) {
        a.ad.p(b, "cd");
        let g = null;
        let h = null;
        if (c.hasValue) {
            h = "fLocksText";
            g = ST_OnOff.g(c.value);
            a.ad.h(h, g);
        }
        if (d.hasValue) {
            h = "fPublished";
            g = ST_OnOff.g(d.value);
            a.ad.h(h, g);
        }
        if (e != null) {
            h = "macro";
            g = e;
            a.ad.h(h, g);
        }
        if (f != null) {
            h = "textlink";
            g = f;
            a.ad.h(h, g);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1106:
                this.f = typeCast(CT_ShapeNonVisual.$, b);
                break;
            case 1570:
                this.b = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 1618:
                this.h = typeCast(CT_ShapeStyle.$, b);
                break;
            case 1777:
                this.d = typeCast(CT_TextBody_DML.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Shape_ChartDrawing.$t = markType(CT_Shape_ChartDrawing, 'CT_Shape_ChartDrawing', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class EG_ObjectChoices extends Base {
    constructor() {
        super();
        this.e = null;
        this.c = null;
        this.a = null;
        this.b = null;
        this.d = null;
    }
    g(a, b, c, d) {
        throw new NotImplementedException(0);
    }
    h(a, b) {
        switch (a) {
            case 1563:
                this.e = typeCast(CT_Shape.$, b);
                break;
            case 753:
                this.c = typeCast(CT_GroupShape.$, b);
                break;
            case 729:
                this.a = typeCast(CT_GraphicFrame.$, b);
                break;
            case 396:
                this.b = typeCast(CT_Connector.$, b);
                break;
            case 1194:
                this.d = typeCast(CT_Picture.$, b);
                break;
            default: break;
        }
    }
    f(a) {
        switch (a) {
            case 1563:
            case 753:
            case 729:
            case 396:
            case 1194: return true;
        }
        return false;
    }
}
EG_ObjectChoices.$t = markType(EG_ObjectChoices, 'EG_ObjectChoices');
/**
 * @hidden
 */
export class EG_Anchor_ChartDrawing extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
    }
    d(a, b, c, d) {
        throw new NotImplementedException(0);
    }
    e(a, b) {
        switch (a) {
            case 1344:
                this.b = typeCast(CT_RelSizeAnchor.$, b);
                break;
            case 1:
                this.a = typeCast(CT_AbsSizeAnchor.$, b);
                break;
            default: break;
        }
    }
    c(a) {
        switch (a) {
            case 1344:
            case 1: return true;
        }
        return false;
    }
}
EG_Anchor_ChartDrawing.$t = markType(EG_Anchor_ChartDrawing, 'EG_Anchor_ChartDrawing');
/**
 * @hidden
 */
export class CT_ChartDrawingAnchorBase extends Base {
    constructor() {
        super();
        this.a = null;
        this.c = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new EG_ObjectChoices();
        }
        return this.a;
    }
}
CT_ChartDrawingAnchorBase.$t = markType(CT_ChartDrawingAnchorBase, 'CT_ChartDrawingAnchorBase');
/**
 * @hidden
 */
export class CT_RelSizeAnchor extends CT_ChartDrawingAnchorBase {
    constructor() {
        super();
        this.d = null;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_RelSizeAnchor.$t = markType(CT_RelSizeAnchor, 'CT_RelSizeAnchor', CT_ChartDrawingAnchorBase.$);
/**
 * @hidden
 */
export class CT_AbsSizeAnchor extends Base {
    constructor() {
        super();
        this.r = null;
        this.c = null;
        this.o = null;
        this.k = null;
        this.m = null;
        this.g = null;
        this.a = null;
        this.e = null;
        this.i = null;
    }
    get item() {
        return this.r;
    }
    set item(a) {
        this.r = a;
    }
    get d() {
        if (this.c == null) {
            this.c = new EG_ObjectChoices();
        }
        return this.c;
    }
    get p() {
        return this.o;
    }
    set p(a) {
        this.o = a;
    }
    get l() {
        return this.k;
    }
    set l(a) {
        this.k = a;
    }
    get n() {
        return this.m;
    }
    set n(a) {
        this.m = a;
    }
    get h() {
        return this.g;
    }
    set h(a) {
        this.g = a;
    }
    get b() {
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    get f() {
        return this.e;
    }
    set f(a) {
        this.e = a;
    }
    get j() {
        return this.i;
    }
    set j(a) {
        this.i = a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_AbsSizeAnchor.$t = markType(CT_AbsSizeAnchor, 'CT_AbsSizeAnchor');
/**
 * @hidden
 */
export class CT_Drawing_ChartDrawing extends Base {
    constructor() {
        super();
        this.a = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new List$1(CT_ChartDrawingAnchorBase.$, 0);
        }
        return this.a;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_Drawing_ChartDrawing.$t = markType(CT_Drawing_ChartDrawing, 'CT_Drawing_ChartDrawing');
/**
 * @hidden
 */
export class DMLChartDrawingUtils extends Base {
}
DMLChartDrawingUtils.$t = markType(DMLChartDrawingUtils, 'DMLChartDrawingUtils');
/**
 * @hidden
 */
export class CT_StyleReference extends Base {
    constructor() {
        super();
        this.b = null;
        this.i = 0;
        this.d = null;
        this.e = null;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get f() {
        if (this.e == null) {
            this.e = new EG_ColorChoice_DML();
        }
        return this.e;
    }
    static j(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "idx":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "mods":
                    c = ST_StyleReferenceModifierList.a(d.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static k(a, b, c, d) {
        a.ad.p(b, "cs");
        let e = null;
        let f = null;
        if (c != null) {
            f = "mods";
            e = c.e();
            a.ad.h(f, e);
        }
        f = "idx";
        e = d.toString();
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1619:
                this.a = typeCast(CT_StyleColor.$, b);
                break;
            default:
                if (this.f.g(a)) {
                    this.f.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StyleReference.$t = markType(CT_StyleReference, 'CT_StyleReference', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_FontReference_ChartStyle extends Base {
    constructor() {
        super();
        this.c = null;
        this.i = 0;
        this.e = null;
        this.f = null;
    }
    get b() {
        return this.c;
    }
    set b(a) {
        this.c = a;
    }
    get h() {
        return this.i;
    }
    set h(a) {
        this.i = a;
    }
    get d() {
        return this.e;
    }
    set d(a) {
        this.e = a;
    }
    get g() {
        if (this.f == null) {
            this.f = new EG_ColorChoice_DML();
        }
        return this.f;
    }
    static k(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "idx":
                    b = XmlNamespaceDefinitionBase.b(ST_FontCollectionIndex_$type, d.d);
                    break;
                case "mods":
                    c = ST_StyleReferenceModifierList.a(d.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static l(a, b, c, d) {
        a.ad.p(b, "cs");
        let e = null;
        let f = null;
        if (c != null) {
            f = "mods";
            e = c.e();
            a.ad.h(f, e);
        }
        f = "idx";
        e = XmlNamespaceDefinitionBase.f(ST_FontCollectionIndex_$type, d);
        a.ad.h(f, e);
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 1619:
                this.b = typeCast(CT_StyleColor.$, b);
                break;
            default:
                if (this.g.g(a)) {
                    this.g.i(a, b);
                    return;
                }
                break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    static a(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        let e = ((() => {
            let $ret = new CT_FontReference_ChartStyle();
            $ret.h = a;
            return $ret;
        })());
        e.g.c = CT_SchemeColor_DML.e(b, c, d);
        return e;
    }
}
CT_FontReference_ChartStyle.$t = markType(CT_FontReference_ChartStyle, 'CT_FontReference_ChartStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_MarkerLayout extends Base {
    constructor() {
        super(...arguments);
        this.d = Nullable$1.toNullable(ST_MarkerStyle_$type, null);
        this.b = Nullable$1.toNullable(Number_$type, null);
    }
    get c() {
        return this.d;
    }
    set c(a) {
        this.d = a;
    }
    get a() {
        return this.b;
    }
    set a(a) {
        this.b = a;
    }
    static f(a, b, c) {
        b = Nullable$1.toNullable(ST_MarkerStyle_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "symbol":
                    b = Nullable$1.toNullable(ST_MarkerStyle_$type, XmlNamespaceDefinitionBase.b(ST_MarkerStyle_$type, d.d));
                    break;
                case "size":
                    c = Nullable$1.toNullable(Number_$type, parseUInt8_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
    static g(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(ST_MarkerStyle_$type, null)) {
        a.ad.p(b, "cs");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "size";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d.hasValue) {
            f = "symbol";
            e = XmlNamespaceDefinitionBase.f(ST_MarkerStyle_$type, d.value);
            a.ad.h(f, e);
        }
        ;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_MarkerLayout.$t = markType(CT_MarkerLayout, 'CT_MarkerLayout');
/**
 * @hidden
 */
export class CT_StyleEntry extends Base {
    constructor() {
        super();
        this.j = null;
        this.f = null;
        this.x = 0;
        this.e = null;
        this.d = null;
        this.b = null;
        this.p = null;
        this.t = null;
        this.r = null;
        this.n = null;
        this.w = null;
        this.v = null;
        this.l = null;
        this.m = null;
        this.a = null;
    }
    get k() {
        return this.j;
    }
    set k(a) {
        this.j = a;
    }
    get i() {
        return this.f;
    }
    set i(a) {
        this.f = a;
    }
    get y() {
        return this.x;
    }
    set y(a) {
        this.x = a;
    }
    get h() {
        return this.e;
    }
    set h(a) {
        this.e = a;
    }
    get g() {
        return this.d;
    }
    set g(a) {
        this.d = a;
    }
    get c() {
        return this.b;
    }
    set c(a) {
        this.b = a;
    }
    get q() {
        return this.p;
    }
    set q(a) {
        this.p = a;
    }
    get u() {
        return this.t;
    }
    set u(a) {
        this.t = a;
    }
    get s() {
        return this.r;
    }
    set s(a) {
        this.r = a;
    }
    get o() {
        return this.n;
    }
    set o(a) {
        this.n = a;
    }
    static ab(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "mods":
                    b = ST_StyleEntryModifierList.a(c.d);
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static ac(a, b, c = null) {
        a.ad.p(b, "cs");
        let d = null;
        let e = null;
        if (c != null) {
            e = "mods";
            d = c.e();
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 925:
                this.i = typeCast(CT_StyleReference.$, b);
                break;
            case 909:
                this.y = b;
                break;
            case 635:
                this.h = typeCast(CT_StyleReference.$, b);
                break;
            case 561:
                this.g = typeCast(CT_StyleReference.$, b);
                break;
            case 660:
                this.c = typeCast(CT_FontReference_ChartStyle.$, b);
                break;
            case 1570:
                this.q = typeCast(CT_ShapeProperties_DML.$, b);
                break;
            case 455:
                this.u = typeCast(CT_TextCharacterProperties_DML.$, b);
                break;
            case 136:
                this.s = typeCast(CT_TextBodyProperties_DML.$, b);
                break;
            case 601:
                this.o = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    aa(a) {
        if (a == null) {
            return;
        }
        let b = a.c;
        let c = 0;
        if (b != null && this.h != null && this.h.h > 0) {
            let d = false;
            c = ((() => { let e = CT_FillStyleList.c(this.h.h, d); d = e.p1; return e.ret; })());
            let e = d ? b.a.b._inner[c] : b.c.b._inner[c];
            if (d) {
                this.v = e;
            }
            else {
                this.w = e;
            }
        }
        if (b != null && this.g != null && this.g.h > 0) {
            c = this.g.h;
            this.l = b.b.c._inner[c];
        }
        if (b != null && this.i != null && this.i.h > 0) {
            c = this.i.h;
            this.m = b.d.a._inner[c];
        }
        if (this.c != null) {
            this.a = this.c.h == 0 ? a.a : this.c.h == 1 ? a.b : null;
        }
    }
}
CT_StyleEntry.$t = markType(CT_StyleEntry, 'CT_StyleEntry', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ChartStyle extends Base {
    constructor() {
        super();
        this.bi = Nullable$1.toNullable(Number_$type, null);
        this.e = null;
        this.f = null;
        this.g = null;
        this.h = null;
        this.i = null;
        this.j = null;
        this.k = null;
        this.l = null;
        this.m = null;
        this.c = null;
        this.n = null;
        this.o = null;
        this.p = null;
        this.q = null;
        this.r = null;
        this.s = null;
        this.t = null;
        this.u = null;
        this.v = null;
        this.w = null;
        this.x = null;
        this.y = null;
        this.z = null;
        this.aa = null;
        this.ab = null;
        this.ac = null;
        this.ad = null;
        this.ae = null;
        this.af = null;
        this.ag = null;
        this.ah = null;
        this.be = null;
    }
    get bj() {
        return this.bi;
    }
    set bj(a) {
        this.bi = a;
    }
    get ai() {
        return this.e;
    }
    set ai(a) {
        this.e = a;
    }
    get aj() {
        return this.f;
    }
    set aj(a) {
        this.f = a;
    }
    get ak() {
        return this.g;
    }
    set ak(a) {
        this.g = a;
    }
    get al() {
        return this.h;
    }
    set al(a) {
        this.h = a;
    }
    get am() {
        return this.i;
    }
    set am(a) {
        this.i = a;
    }
    get an() {
        return this.j;
    }
    set an(a) {
        this.j = a;
    }
    get ao() {
        return this.k;
    }
    set ao(a) {
        this.k = a;
    }
    get ap() {
        return this.l;
    }
    set ap(a) {
        this.l = a;
    }
    get aq() {
        return this.m;
    }
    set aq(a) {
        this.m = a;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get ar() {
        return this.n;
    }
    set ar(a) {
        this.n = a;
    }
    get as() {
        return this.o;
    }
    set as(a) {
        this.o = a;
    }
    get at() {
        return this.p;
    }
    set at(a) {
        this.p = a;
    }
    get au() {
        return this.q;
    }
    set au(a) {
        this.q = a;
    }
    get av() {
        return this.r;
    }
    set av(a) {
        this.r = a;
    }
    get aw() {
        return this.s;
    }
    set aw(a) {
        this.s = a;
    }
    get ax() {
        return this.t;
    }
    set ax(a) {
        this.t = a;
    }
    get ay() {
        return this.u;
    }
    set ay(a) {
        this.u = a;
    }
    get az() {
        return this.v;
    }
    set az(a) {
        this.v = a;
    }
    get a0() {
        return this.w;
    }
    set a0(a) {
        this.w = a;
    }
    get a1() {
        return this.x;
    }
    set a1(a) {
        this.x = a;
    }
    get a2() {
        return this.y;
    }
    set a2(a) {
        this.y = a;
    }
    get a3() {
        return this.z;
    }
    set a3(a) {
        this.z = a;
    }
    get a4() {
        return this.aa;
    }
    set a4(a) {
        this.aa = a;
    }
    get a5() {
        return this.ab;
    }
    set a5(a) {
        this.ab = a;
    }
    get a6() {
        return this.ac;
    }
    set a6(a) {
        this.ac = a;
    }
    get a7() {
        return this.ad;
    }
    set a7(a) {
        this.ad = a;
    }
    get a8() {
        return this.ae;
    }
    set a8(a) {
        this.ae = a;
    }
    get a9() {
        return this.af;
    }
    set a9(a) {
        this.af = a;
    }
    get ba() {
        return this.ag;
    }
    set ba(a) {
        this.ag = a;
    }
    get bb() {
        return this.ah;
    }
    set bb(a) {
        this.ah = a;
    }
    get bf() {
        return this.be;
    }
    set bf(a) {
        this.be = a;
    }
    static bl(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "id":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b
        };
    }
    static bn(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, "cs");
        let d = null;
        let e = null;
        if (c.hasValue) {
            e = "id";
            d = c.value.toString();
            a.ad.h(e, d);
        }
        ;
    }
    setProperty(a, b) {
        switch (a) {
            case 85:
                this.ai = typeCast(CT_StyleEntry.$, b);
                break;
            case 233:
                this.aj = typeCast(CT_StyleEntry.$, b);
                break;
            case 262:
                this.ak = typeCast(CT_StyleEntry.$, b);
                break;
            case 417:
                this.al = typeCast(CT_StyleEntry.$, b);
                break;
            case 418:
                this.am = typeCast(CT_StyleEntry.$, b);
                break;
            case 423:
                this.an = typeCast(CT_StyleEntry.$, b);
                break;
            case 424:
                this.ao = typeCast(CT_StyleEntry.$, b);
                break;
            case 425:
                this.ap = typeCast(CT_StyleEntry.$, b);
                break;
            case 426:
                this.aq = typeCast(CT_StyleEntry.$, b);
                break;
            case 427:
                this.d = typeCast(CT_MarkerLayout.$, b);
                break;
            case 428:
                this.ar = typeCast(CT_StyleEntry.$, b);
                break;
            case 433:
                this.as = typeCast(CT_StyleEntry.$, b);
                break;
            case 535:
                this.at = typeCast(CT_StyleEntry.$, b);
                break;
            case 542:
                this.au = typeCast(CT_StyleEntry.$, b);
                break;
            case 594:
                this.av = typeCast(CT_StyleEntry.$, b);
                break;
            case 654:
                this.aw = typeCast(CT_StyleEntry.$, b);
                break;
            case 739:
                this.ax = typeCast(CT_StyleEntry.$, b);
                break;
            case 740:
                this.ay = typeCast(CT_StyleEntry.$, b);
                break;
            case 779:
                this.az = typeCast(CT_StyleEntry.$, b);
                break;
            case 885:
                this.a0 = typeCast(CT_StyleEntry.$, b);
                break;
            case 890:
                this.a1 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1235:
                this.a2 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1236:
                this.a3 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1450:
                this.a4 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1451:
                this.a5 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1745:
                this.a6 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1767:
                this.a7 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1768:
                this.a8 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1807:
                this.a9 = typeCast(CT_StyleEntry.$, b);
                break;
            case 1825:
                this.ba = typeCast(CT_StyleEntry.$, b);
                break;
            case 1851:
                this.bb = typeCast(CT_StyleEntry.$, b);
                break;
            case 601:
                this.bf = typeCast(CT_OfficeArtExtensionList.$, b);
                break;
            default: break;
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
    get a() {
        let a = [this.ai, this.aj, this.ak, this.al, this.am, this.an, this.ao, this.ap, this.aq, this.ar, this.as, this.at, this.au, this.av, this.aw, this.ax, this.ay, this.az, this.a0, this.a1, this.a2, this.a3, this.a4, this.a5, this.a6, this.a7, this.a8, this.a9, this.ba, this.bb];
        return a;
    }
    static b() {
        let a = 5;
        let b = 15;
        let c = 25;
        let d = 35;
        let e = 65;
        let f = 75;
        let g = 85;
        let h = 95;
        let i = new CT_ChartStyle();
        i.bj = Nullable$1.toNullable(Number_$type, 10);
        i.ai = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ai.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.ai.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.aj = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.aj.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.aj.q = ((() => {
            let $ret = new CT_ShapeProperties_DML();
            $ret.a = ((() => {
                let $ret = new CT_LineProperties_DML();
                $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
                $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 2);
                $ret.g = Nullable$1.toNullable(ST_CompoundLine_$type, 0);
                $ret.e = Nullable$1.toNullable(ST_PenAlignment_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.aj.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, b), Nullable$1.toNullable(Number_$type, g));
        i.aj.q.a.p.c = new CT_LineJoinRound();
        i.aj.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            $ret.j = Nullable$1.toNullable(Number_$type, 1200);
            return $ret;
        })());
        i.ak = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ak.k = CT_ChartStyle.bc();
        i.ak.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.ak.q = CT_ChartStyle.bg(0);
        i.ak.q.a = new CT_LineProperties_DML();
        i.ak.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, b), Nullable$1.toNullable(Number_$type, g));
        i.ak.q.a.p.c = new CT_LineJoinRound();
        i.ak.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 1000);
            $ret.j = Nullable$1.toNullable(Number_$type, 1200);
            return $ret;
        })());
        i.al = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.al.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.al.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.am = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.am.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.am.q = CT_ChartStyle.bg(14);
        i.am.q.a = new CT_LineProperties_DML();
        i.am.q.a.n.c = CT_ChartStyle.bh(13, Nullable$1.toNullable(Number_$type, c), Nullable$1.toNullable(Number_$type, f));
        i.am.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.am.s = ((() => {
            let $ret = new CT_TextBodyProperties_DML();
            $ret.af = Nullable$1.toNullable(Number_$type, 0);
            $ret.al = Nullable$1.toNullable(Boolean_$type, true);
            $ret.at = Nullable$1.toNullable(ST_TextVertOverflowType_$type, 2);
            $ret.x = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, 1);
            $ret.ar = Nullable$1.toNullable(ST_TextVerticalType_$type, 0);
            $ret.av = Nullable$1.toNullable(ST_TextWrappingType_$type, 1);
            $ret.z = Nullable$1.toNullable(Number_$type, 36576);
            $ret.an = Nullable$1.toNullable(Number_$type, 18288);
            $ret.ad = Nullable$1.toNullable(Number_$type, 36576);
            $ret.p = Nullable$1.toNullable(Number_$type, 18288);
            $ret.l = Nullable$1.toNullable(ST_TextAnchoringType_$type, 1);
            $ret.m = Nullable$1.toNullable(Boolean_$type, true);
            return $ret;
        })());
        i.am.s.j.c = new CT_TextShapeAutofit();
        i.an = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.an.h.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.an.c = CT_FontReference_ChartStyle.a(1, 1);
        i.an.q = CT_ChartStyle.bg(12);
        i.ao = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ao.h.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.ao.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ao.q = CT_ChartStyle.bg(12);
        i.ap = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ap.i.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.ap.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ap.q = ((() => {
            let $ret = new CT_ShapeProperties_DML();
            $ret.a = ((() => {
                let $ret = new CT_LineProperties_DML();
                $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(28575)));
                $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.ap.q.a.n.c = CT_ChartStyle.bh(12);
        i.ap.q.a.p.c = new CT_LineJoinRound();
        i.aq = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.aq.h.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.aq.c = CT_FontReference_ChartStyle.a(1, 1);
        i.aq.q = CT_ChartStyle.bg(12);
        i.aq.q.a = new CT_LineProperties_DML();
        i.aq.q.a.n.c = CT_ChartStyle.bh(14);
        i.d = ((() => {
            let $ret = new CT_MarkerLayout();
            $ret.c = Nullable$1.toNullable(ST_MarkerStyle_$type, 1);
            $ret.a = Nullable$1.toNullable(Number_$type, 5);
            return $ret;
        })());
        i.ar = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ar.i.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.ar.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ar.q = new CT_ShapeProperties_DML();
        i.ar.q.a = new CT_LineProperties_DML();
        i.ar.q.a.n.c = CT_ChartStyle.bh(12);
        i.ar.q.a.p.c = new CT_LineJoinRound();
        i.as = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.as.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.as.q = new CT_ShapeProperties_DML();
        i.as.q.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
            return $ret;
        })());
        i.as.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, b), Nullable$1.toNullable(Number_$type, g));
        i.as.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.at = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.at.c = CT_FontReference_ChartStyle.a(1, 13);
        i.at.q = CT_ChartStyle.bg(13);
        i.au = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.au.c = CT_FontReference_ChartStyle.a(1, 1);
        i.av = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.av.c = CT_FontReference_ChartStyle.a(1, 1);
        i.aw = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.aw.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ax = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ax.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ax.q = new CT_ShapeProperties_DML();
        i.ax.q.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
            $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 2);
            $ret.g = Nullable$1.toNullable(ST_CompoundLine_$type, 0);
            $ret.e = Nullable$1.toNullable(ST_PenAlignment_$type, 0);
            return $ret;
        })());
        i.ax.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, b), Nullable$1.toNullable(Number_$type, g));
        i.ax.q.a.p.c = new CT_LineJoinRound();
        i.ay = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ay.c = CT_FontReference_ChartStyle.a(1, 1);
        i.ay.q = new CT_ShapeProperties_DML();
        i.ay.q.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
            $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 2);
            $ret.g = Nullable$1.toNullable(ST_CompoundLine_$type, 0);
            $ret.e = Nullable$1.toNullable(ST_PenAlignment_$type, 0);
            return $ret;
        })());
        i.ay.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, a), Nullable$1.toNullable(Number_$type, h));
        i.ay.q.a.p.c = new CT_LineJoinRound();
        i.az = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.az.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a0 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a0.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a0 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a0.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a1 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a1.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.a1.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.a2 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a2.k = CT_ChartStyle.bc();
        i.a2.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a3 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a3.k = CT_ChartStyle.bc();
        i.a3.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a4 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a4.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.a4.q = new CT_ShapeProperties_DML();
        i.a4.q.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.e = Nullable$1.toNullable(ST_PenAlignment_$type, 0);
            $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 2);
            $ret.g = Nullable$1.toNullable(ST_CompoundLine_$type, 0);
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
            return $ret;
        })());
        i.a4.q.a.n.c = CT_ChartStyle.bh(1, Nullable$1.toNullable(Number_$type, g), Nullable$1.toNullable(Number_$type, b));
        i.a4.q.a.p.c = new CT_LineJoinRound();
        i.a4.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.a5 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a5.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.a5.q = new CT_ShapeProperties_DML();
        i.a5.q.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 2);
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(9525)));
            return $ret;
        })());
        i.a5.q.a.n.c = new CT_SolidColorFillProperties();
        i.a5.q.a.n.c.b.e = ((() => {
            let $ret = new CT_SRgbColor_DML();
            $ret.f = new ST_HexColorRGB(2, 217, 217, 217);
            return $ret;
        })());
        i.a5.q.a.p.c = new CT_LineJoinRound();
        i.a6 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a6.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.a6.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 1400);
            $ret.d = Nullable$1.toNullable(Boolean_$type, false);
            $ret.j = Nullable$1.toNullable(Number_$type, 1200);
            $ret.p = Nullable$1.toNullable(ST_TextPoint.$, new ST_TextPoint(1, ST_TextPointUnqualified.a(0)));
            $ret.e = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(0));
            return $ret;
        })());
        i.a7 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a7.i.a = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = ((() => {
                let $ret = new ST_StyleColorVal();
                $ret.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, 0);
                return $ret;
            })());
            return $ret;
        })());
        i.a7.c = CT_FontReference_ChartStyle.a(1, 1);
        i.a7.q = ((() => {
            let $ret = new CT_ShapeProperties_DML();
            $ret.a = new CT_LineProperties_DML();
            return $ret;
        })());
        i.a7.q.a.n.c = CT_ChartStyle.bh(12);
        i.a7.q.a.l.b = ((() => {
            let $ret = new CT_PresetLineDashProperties();
            $ret.a = Nullable$1.toNullable(ST_PresetLineDashVal_$type, 7);
            return $ret;
        })());
        i.a8 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a8.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.a8.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            return $ret;
        })());
        i.a9 = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.a9.c = CT_FontReference_ChartStyle.a(1, 13);
        i.a9.q = CT_ChartStyle.bg(14);
        i.ba = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.ba.c = CT_FontReference_ChartStyle.a(1, 1, Nullable$1.toNullable(Number_$type, e), Nullable$1.toNullable(Number_$type, d));
        i.ba.u = ((() => {
            let $ret = new CT_TextCharacterProperties_DML();
            $ret.r = Nullable$1.toNullable(Number_$type, 900);
            $ret.j = Nullable$1.toNullable(Number_$type, 1200);
            return $ret;
        })());
        i.bb = ((() => {
            let $ret = new CT_StyleEntry();
            $ret.i = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.h = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_StyleReference();
                $ret.h = 0;
                return $ret;
            })());
            return $ret;
        })());
        i.bb.c = CT_FontReference_ChartStyle.a(1, 1);
        return i;
    }
    static bc() {
        let a = [0, 1];
        return CT_ChartStyle.bd(a);
    }
    static bd(a) {
        let b = ((() => {
            let $ret = new ST_StyleEntryModifierList();
            $ret.d = new List$1(ST_StyleEntryModifier.$, 0);
            return $ret;
        })());
        for (let d = 0; d < a.length; d++) {
            let c = a[d];
            b.d.add(((() => {
                let $ret = new ST_StyleEntryModifier();
                $ret.d = Nullable$1.toNullable(ST_StyleEntryModifierEnum_$type, c);
                return $ret;
            })()));
        }
        return b;
    }
    static bg(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        let d = new CT_ShapeProperties_DML();
        d.l.c = CT_ChartStyle.bh(a, b, c);
        return d;
    }
    static bh(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        let d = new CT_SolidColorFillProperties();
        d.b.c = CT_SchemeColor_DML.e(a, b, c);
        return d;
    }
    bm(a) {
        switch (a) {
            case 118:
            case 119:
                this.al.c.g.c = ((() => {
                    let $ret = new CT_SchemeColor_DML();
                    $ret.g = 14;
                    return $ret;
                })());
                this.al.c.g.c.b.p = null;
                this.al.c.g.c.b.q = null;
                break;
            default: break;
        }
    }
}
CT_ChartStyle.$t = markType(CT_ChartStyle, 'CT_ChartStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class ST_ColorStyleMethod extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(ST_ColorStyleMethodEnum_$type, null);
        this.e = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get h() {
        return this.e;
    }
    set h(a) {
        this.e = a;
    }
    static a(a) {
        return ST_ColorStyleMethod.b(a);
    }
    f() {
        return this.g();
    }
    static b(a) {
        let b = new ST_ColorStyleMethod();
        let c;
        if (((() => { let d = EnumUtil.tryParse$1(ST_ColorStyleMethodEnum_$type, a, true, c); c = d.p2; return d.ret; })())) {
            b.d = Nullable$1.toNullable(ST_ColorStyleMethodEnum_$type, c);
        }
        else {
            b.h = a;
        }
        return b;
    }
    g() {
        return this.d.hasValue ? EnumUtil.getName(ST_ColorStyleMethodEnum_$type, this.d.value) : this.h;
    }
}
ST_ColorStyleMethod.$t = markType(ST_ColorStyleMethod, 'ST_ColorStyleMethod');
/**
 * @hidden
 */
export class ST_StyleReferenceModifier extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(ST_StyleReferenceModifierEnum_$type, null);
        this.e = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get h() {
        return this.e;
    }
    set h(a) {
        this.e = a;
    }
    static a(a) {
        return ST_StyleReferenceModifier.b(a);
    }
    f() {
        return this.g();
    }
    static b(a) {
        let b = new ST_StyleReferenceModifier();
        let c;
        if (((() => { let d = EnumUtil.tryParse$1(ST_StyleReferenceModifierEnum_$type, a, true, c); c = d.p2; return d.ret; })())) {
            b.d = Nullable$1.toNullable(ST_StyleReferenceModifierEnum_$type, c);
        }
        else {
            b.h = a;
        }
        return b;
    }
    g() {
        if (this.d.hasValue) {
            return EnumUtil.getName(ST_StyleReferenceModifierEnum_$type, this.d.value);
        }
        else {
            return this.h;
        }
    }
}
ST_StyleReferenceModifier.$t = markType(ST_StyleReferenceModifier, 'ST_StyleReferenceModifier');
/**
 * @hidden
 */
export class ST_StyleColorVal extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(ST_StyleColorEnum_$type, null);
        this.g = null;
    }
    get e() {
        return this.c;
    }
    set e(a) {
        this.c = a;
    }
    get f() {
        return this.d;
    }
    set f(a) {
        this.d = a;
    }
    get j() {
        return this.g;
    }
    set j(a) {
        this.g = a;
    }
    static a(a) {
        return ST_StyleColorVal.b(a);
    }
    h() {
        return this.i();
    }
    static b(a) {
        let b = new ST_StyleColorVal();
        let c;
        let d;
        if (((() => { let e = tryParseUInt32_2(a, 7, null, c); c = e.p3; return e.ret; })())) {
            b.e = Nullable$1.toNullable(Number_$type, c);
        }
        else if (((() => { let e = EnumUtil.tryParse$1(ST_StyleColorEnum_$type, a, true, d); d = e.p2; return e.ret; })())) {
            b.f = Nullable$1.toNullable(ST_StyleColorEnum_$type, d);
        }
        else {
            b.j = a;
        }
        return b;
    }
    i() {
        return this.e.hasValue ? this.e.value.toString() : this.f.hasValue ? EnumUtil.getName(ST_StyleColorEnum_$type, this.f.value) : this.j;
    }
}
ST_StyleColorVal.$t = markType(ST_StyleColorVal, 'ST_StyleColorVal');
/**
 * @hidden
 */
export class ST_StyleEntryModifier extends Base {
    constructor() {
        super(...arguments);
        this.c = Nullable$1.toNullable(ST_StyleEntryModifierEnum_$type, null);
        this.e = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    get h() {
        return this.e;
    }
    set h(a) {
        this.e = a;
    }
    static a(a) {
        return ST_StyleEntryModifier.b(a);
    }
    f() {
        return this.g();
    }
    static b(a) {
        let b = new ST_StyleEntryModifier();
        let c;
        if (((() => { let d = EnumUtil.tryParse$1(ST_StyleEntryModifierEnum_$type, a, true, c); c = d.p2; return d.ret; })())) {
            b.d = Nullable$1.toNullable(ST_StyleEntryModifierEnum_$type, c);
        }
        else {
            b.h = a;
        }
        return b;
    }
    g() {
        if (this.d.hasValue) {
            return EnumUtil.getName(ST_StyleEntryModifierEnum_$type, this.d.value);
        }
        else {
            return this.h;
        }
    }
}
ST_StyleEntryModifier.$t = markType(ST_StyleEntryModifier, 'ST_StyleEntryModifier');
/**
 * @hidden
 */
export class ST_StyleReferenceModifierList extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    static a(a) {
        return ST_StyleReferenceModifierList.b(a);
    }
    e() {
        return this.f();
    }
    static b(a) {
        let b = new ST_StyleReferenceModifierList();
        let c = XmlNamespaceDefinitionBase.e(String_$type, a, (d) => d);
        if (c != null) {
            b.d = new List$1(ST_StyleReferenceModifier.$, 2, c.count);
            for (let d of fromEnum(c)) {
                let e = ST_StyleReferenceModifier.a(d);
                if (e == null) {
                    continue;
                }
                if (b.d == null) {
                    b.d = new List$1(ST_StyleReferenceModifier.$, 0);
                }
                b.d.add(e);
            }
        }
        return b;
    }
    f() {
        if (this.d == null) {
            return null;
        }
        let a = new StringBuilder(0);
        let b = this.d.count - 1;
        for (let c = 0; c <= b; c++) {
            let d = this.d._inner[c];
            a.l(d.f());
            a.l(" ");
        }
        return a.toString();
    }
}
ST_StyleReferenceModifierList.$t = markType(ST_StyleReferenceModifierList, 'ST_StyleReferenceModifierList');
/**
 * @hidden
 */
export class ST_StyleEntryModifierList extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
    }
    get d() {
        return this.c;
    }
    set d(a) {
        this.c = a;
    }
    static a(a) {
        return ST_StyleEntryModifierList.b(a);
    }
    e() {
        return this.f();
    }
    static b(a) {
        let b = new ST_StyleEntryModifierList();
        let c = XmlNamespaceDefinitionBase.e(String_$type, a, (d) => d);
        if (c != null) {
            b.d = new List$1(ST_StyleEntryModifier.$, 2, c.count);
            for (let d of fromEnum(c)) {
                let e = ST_StyleEntryModifier.a(d);
                if (e != null) {
                    b.d.add(e);
                }
            }
        }
        return b;
    }
    f() {
        if (this.d == null) {
            return null;
        }
        let a = new StringBuilder(0);
        let b = this.d.count - 1;
        for (let c = 0; c <= b; c++) {
            let d = this.d._inner[c];
            a.l(d.f());
            if (c < b) {
                a.l(" ");
            }
        }
        return a.toString();
    }
}
ST_StyleEntryModifierList.$t = markType(ST_StyleEntryModifierList, 'ST_StyleEntryModifierList');
/**
 * @hidden
 */
export class ChartStyleAttributes extends Base {
}
ChartStyleAttributes.$t = markType(ChartStyleAttributes, 'ChartStyleAttributes');
/**
 * @hidden
 */
export class ChartStyleElements extends Base {
}
ChartStyleElements.$t = markType(ChartStyleElements, 'ChartStyleElements');
ChartStyleElements.af = "http://schemas.microsoft.com/office/drawing/2012/chartStyle";
ChartStyleElements.a = ChartStyleElements.af + "/axisTitle";
ChartStyleElements.b = ChartStyleElements.af + "/bodyPr";
ChartStyleElements.c = ChartStyleElements.af + "/categoryAxis";
ChartStyleElements.d = ChartStyleElements.af + "/chartArea";
ChartStyleElements.e = ChartStyleElements.af + "/chartStyle";
ChartStyleElements.f = ChartStyleElements.af + "/colorStyle";
ChartStyleElements.g = ChartStyleElements.af + "/dataLabel";
ChartStyleElements.h = ChartStyleElements.af + "/dataLabelCallout";
ChartStyleElements.i = ChartStyleElements.af + "/dataPoint";
ChartStyleElements.j = ChartStyleElements.af + "/dataPoint3D";
ChartStyleElements.k = ChartStyleElements.af + "/dataPointLine";
ChartStyleElements.l = ChartStyleElements.af + "/dataPointMarker";
ChartStyleElements.m = ChartStyleElements.af + "/dataPointMarkerLayout";
ChartStyleElements.n = ChartStyleElements.af + "/dataPointWireframe";
ChartStyleElements.o = ChartStyleElements.af + "/dataTable";
ChartStyleElements.p = ChartStyleElements.af + "/defRPr";
ChartStyleElements.q = ChartStyleElements.af + "/downBar";
ChartStyleElements.r = ChartStyleElements.af + "/dropLine";
ChartStyleElements.s = ChartStyleElements.af + "/effectRef";
ChartStyleElements.t = ChartStyleElements.af + "/errorBar";
ChartStyleElements.u = ChartStyleElements.af + "/extLst";
ChartStyleElements.v = ChartStyleElements.af + "/fillRef";
ChartStyleElements.w = ChartStyleElements.af + "/floor";
ChartStyleElements.x = ChartStyleElements.af + "/fontRef";
ChartStyleElements.y = ChartStyleElements.af + "/gridlineMajor";
ChartStyleElements.z = ChartStyleElements.af + "/gridlineMinor";
ChartStyleElements.aa = ChartStyleElements.af + "/hiLoLine";
ChartStyleElements.ab = ChartStyleElements.af + "/leaderLine";
ChartStyleElements.ac = ChartStyleElements.af + "/legend";
ChartStyleElements.ad = ChartStyleElements.af + "/lineWidthScale";
ChartStyleElements.ae = ChartStyleElements.af + "/lnRef";
ChartStyleElements.ag = ChartStyleElements.af + "/plotArea";
ChartStyleElements.ah = ChartStyleElements.af + "/plotArea3D";
ChartStyleElements.ai = ChartStyleElements.af + "/seriesAxis";
ChartStyleElements.aj = ChartStyleElements.af + "/seriesLine";
ChartStyleElements.ak = ChartStyleElements.af + "/spPr";
ChartStyleElements.al = ChartStyleElements.af + "/styleClr";
ChartStyleElements.am = ChartStyleElements.af + "/title";
ChartStyleElements.an = ChartStyleElements.af + "/trendline";
ChartStyleElements.ao = ChartStyleElements.af + "/trendlineLabel";
ChartStyleElements.ap = ChartStyleElements.af + "/upBar";
ChartStyleElements.aq = ChartStyleElements.af + "/valueAxis";
ChartStyleElements.ar = ChartStyleElements.af + "/variation";
ChartStyleElements.as = ChartStyleElements.af + "/wall";
/**
 * @hidden
 */
export class CT_ColorStyleVariation extends CT_DMLColorBase {
    constructor() {
        super();
    }
    d(a, b, c) {
        c.p(ChartStyleElements.ar, "cs");
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorStyleVariation.$t = markType(CT_ColorStyleVariation, 'CT_ColorStyleVariation', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_StyleColor extends CT_DMLColorBase {
    constructor() {
        super();
        this.f = null;
    }
    static e(a) {
        let b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_StyleColorVal.a(c.d);
                    break;
                default: break;
            }
        }
        let d = ((() => {
            let $ret = new CT_StyleColor();
            $ret.f = b;
            return $ret;
        })());
        return d;
    }
    d(a, b, c) {
        ChartStyleUtils.b(a, ChartStyleElements.al, this.f);
        if (this.b != null) {
            this.b.af(a, b, c, null);
        }
        c.k();
    }
    setProperty(a, b) {
        if (this.b != null) {
            this.b.ag(a, b);
        }
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_StyleColor.$t = markType(CT_StyleColor, 'CT_StyleColor', CT_DMLColorBase.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_ColorStyle extends Base {
    constructor() {
        super();
        this.d = null;
        this.e = null;
        this.c = null;
        this.b = null;
        this.f = Nullable$1.toNullable(Number_$type, null);
        this.d = new List$1(CT_DMLColorBase.$, 0);
        this.e = new List$1(CT_ColorStyleVariation.$, 0);
    }
    static h(a, b, c) {
        b = null;
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "meth":
                    b = ST_ColorStyleMethod.a(d.d);
                    break;
                case "id":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static i(a, b, c, d) {
        a.ad.p(b, "cs");
        let e = null;
        let f = null;
        if (c.hasValue) {
            f = "id";
            e = c.value.toString();
            a.ad.h(f, e);
        }
        if (d != null) {
            f = "meth";
            e = d.f();
            a.ad.h(f, e);
        }
    }
    static a() {
        let a = 20;
        let b = 30;
        let c = 40;
        let d = 50;
        let e = 60;
        let f = 70;
        let g = 80;
        let h = new CT_ColorStyle();
        h.b = ((() => {
            let $ret = new ST_ColorStyleMethod();
            $ret.d = Nullable$1.toNullable(ST_ColorStyleMethodEnum_$type, 0);
            return $ret;
        })());
        h.f = Nullable$1.toNullable(Number_$type, 100);
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 4;
            return $ret;
        })()));
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 5;
            return $ret;
        })()));
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 6;
            return $ret;
        })()));
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 7;
            return $ret;
        })()));
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 8;
            return $ret;
        })()));
        h.d.add(((() => {
            let $ret = new CT_SchemeColor_DML();
            $ret.g = 9;
            return $ret;
        })()));
        let i = null;
        i = new CT_ColorStyleVariation();
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(e);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(g);
            return $ret;
        })());
        i.b.q = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(a);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(g);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(e);
            return $ret;
        })());
        i.b.q = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(c);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(d);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(f);
            return $ret;
        })());
        i.b.q = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(b);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(f);
            return $ret;
        })());
        h.e.add(i);
        i = new CT_ColorStyleVariation();
        i.b.p = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(d);
            return $ret;
        })());
        i.b.q = ((() => {
            let $ret = new CT_Percentage();
            $ret.a = ST_Percentage.b(d);
            return $ret;
        })());
        h.e.add(i);
        return h;
    }
    toString() {
        let a = getInstanceType(this);
        return a != null ? a.typeName : super.toString();
    }
}
CT_ColorStyle.$t = markType(CT_ColorStyle, 'CT_ColorStyle');
/**
 * @hidden
 */
export class ChartStyleExtensions extends Base {
    static b(a, b, c, d, e) {
        CT_ColorStyle.i(b, e, a.f, a.b);
        d.l(DrawingMLMain.an);
        if (a.c != null) {
            a.c.d(b, c, d, ChartStyleElements.u);
        }
        if (a.d != null) {
            for (let f of fromEnum(a.d)) {
                f.d(b, c, d);
            }
        }
        if (a.e != null) {
            for (let g of fromEnum(a.e)) {
                ChartStyleExtensions.c(g, b, c, d, ChartStyleElements.ar);
            }
        }
        if (a.c != null) {
            a.c.d(b, c, d, null);
        }
        d.k();
    }
    static c(a, b, c, d, e) {
        d.p(e, "cs");
        if (a.b != null) {
            a.b.af(b, c, d, null);
        }
        d.k();
    }
    static a(a, b, c, d, e) {
        CT_ChartStyle.bn(b, e, a.bj);
        b.ad.l(DrawingMLMain.an);
        if (a.ai != null) {
            ChartStyleExtensions.f(a.ai, b, c, d, ChartStyleElements.a);
        }
        if (a.aj != null) {
            ChartStyleExtensions.f(a.aj, b, c, d, ChartStyleElements.c);
        }
        if (a.ak != null) {
            ChartStyleExtensions.f(a.ak, b, c, d, ChartStyleElements.d);
        }
        if (a.al != null) {
            ChartStyleExtensions.f(a.al, b, c, d, ChartStyleElements.g);
        }
        if (a.am != null) {
            ChartStyleExtensions.f(a.am, b, c, d, ChartStyleElements.h);
        }
        if (a.an != null) {
            ChartStyleExtensions.f(a.an, b, c, d, ChartStyleElements.i);
        }
        if (a.ao != null) {
            ChartStyleExtensions.f(a.ao, b, c, d, ChartStyleElements.j);
        }
        if (a.ap != null) {
            ChartStyleExtensions.f(a.ap, b, c, d, ChartStyleElements.k);
        }
        if (a.aq != null) {
            ChartStyleExtensions.f(a.aq, b, c, d, ChartStyleElements.l);
        }
        if (a.d != null) {
            ChartStyleExtensions.e(a.d, b, c, d, ChartStyleElements.m);
        }
        if (a.ar != null) {
            ChartStyleExtensions.f(a.ar, b, c, d, ChartStyleElements.n);
        }
        if (a.as != null) {
            ChartStyleExtensions.f(a.as, b, c, d, ChartStyleElements.o);
        }
        if (a.at != null) {
            ChartStyleExtensions.f(a.at, b, c, d, ChartStyleElements.q);
        }
        if (a.au != null) {
            ChartStyleExtensions.f(a.au, b, c, d, ChartStyleElements.r);
        }
        if (a.av != null) {
            ChartStyleExtensions.f(a.av, b, c, d, ChartStyleElements.t);
        }
        if (a.bf != null) {
            a.bf.d(b, c, d, ChartStyleElements.u);
        }
        if (a.aw != null) {
            ChartStyleExtensions.f(a.aw, b, c, d, ChartStyleElements.w);
        }
        if (a.ax != null) {
            ChartStyleExtensions.f(a.ax, b, c, d, ChartStyleElements.y);
        }
        if (a.ay != null) {
            ChartStyleExtensions.f(a.ay, b, c, d, ChartStyleElements.z);
        }
        if (a.az != null) {
            ChartStyleExtensions.f(a.az, b, c, d, ChartStyleElements.aa);
        }
        if (a.a0 != null) {
            ChartStyleExtensions.f(a.a0, b, c, d, ChartStyleElements.ab);
        }
        if (a.a1 != null) {
            ChartStyleExtensions.f(a.a1, b, c, d, ChartStyleElements.ac);
        }
        if (a.a2 != null) {
            ChartStyleExtensions.f(a.a2, b, c, d, ChartStyleElements.ag);
        }
        if (a.a3 != null) {
            ChartStyleExtensions.f(a.a3, b, c, d, ChartStyleElements.ah);
        }
        if (a.a4 != null) {
            ChartStyleExtensions.f(a.a4, b, c, d, ChartStyleElements.ai);
        }
        if (a.a5 != null) {
            ChartStyleExtensions.f(a.a5, b, c, d, ChartStyleElements.aj);
        }
        if (a.a6 != null) {
            ChartStyleExtensions.f(a.a6, b, c, d, ChartStyleElements.am);
        }
        if (a.a7 != null) {
            ChartStyleExtensions.f(a.a7, b, c, d, ChartStyleElements.an);
        }
        if (a.a8 != null) {
            ChartStyleExtensions.f(a.a8, b, c, d, ChartStyleElements.ao);
        }
        if (a.a9 != null) {
            ChartStyleExtensions.f(a.a9, b, c, d, ChartStyleElements.ap);
        }
        if (a.ba != null) {
            ChartStyleExtensions.f(a.ba, b, c, d, ChartStyleElements.aq);
        }
        if (a.bb != null) {
            ChartStyleExtensions.f(a.bb, b, c, d, ChartStyleElements.as);
        }
        d.k();
    }
    static f(a, b, c, d, e) {
        CT_StyleEntry.ac(b, e, a.k);
        if (a.i != null) {
            ChartStyleExtensions.g(a.i, b, c, d, ChartStyleElements.ae);
        }
        if (a.y != 0) {
            d.p(ChartStyleElements.ad, "cs");
            d.u(numberToString(a.y, CultureInfo.invariantCulture));
            d.k();
        }
        if (a.h != null) {
            ChartStyleExtensions.g(a.h, b, c, d, ChartStyleElements.v);
        }
        if (a.g != null) {
            ChartStyleExtensions.g(a.g, b, c, d, ChartStyleElements.s);
        }
        if (a.c != null) {
            ChartStyleExtensions.d(a.c, b, c, d, ChartStyleElements.x);
        }
        if (a.q != null) {
            DMLExtensions.a5(a.q, b, c, d, ChartStyleElements.ak);
        }
        if (a.u != null) {
            a.u.aq(b, c, d, ChartStyleElements.p);
        }
        if (a.s != null) {
            DMLExtensions.bd(a.s, b, c, d, ChartStyleElements.b);
        }
        if (a.o != null) {
            a.o.d(b, c, d, ChartStyleElements.u);
        }
        d.k();
    }
    static e(a, b, c, d, e) {
        CT_MarkerLayout.g(b, e, a.a, a.c);
        d.k();
    }
    static g(a, b, c, d, e) {
        CT_StyleReference.k(b, e, a.c, a.h);
        if (a.a != null) {
            a.a.d(b, c, d);
        }
        if (a.f != null) {
            a.f.h(b, c, d, null);
        }
        d.k();
    }
    static d(a, b, c, d, e) {
        CT_FontReference_ChartStyle.l(b, e, a.d, a.h);
        if (a.b != null) {
            a.b.d(b, c, d);
        }
        if (a.g != null) {
            a.g.h(b, c, d, null);
        }
        d.k();
    }
}
ChartStyleExtensions.$t = markType(ChartStyleExtensions, 'ChartStyleExtensions');
/**
 * @hidden
 */
export class ChartStyleUtils extends Base {
    static b(a, b, c) {
        a.ad.p(b, "cs");
        let d = null;
        let e = null;
        e = "val";
        d = c.h();
        a.ad.h(e, d);
    }
}
ChartStyleUtils.$t = markType(ChartStyleUtils, 'ChartStyleUtils');
/**
 * @hidden
 */
export class ChartDeserializer extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.o = null;
    }
    static lm(a) {
        a.ay(ChartExElements.m, ChartDeserializer.by);
        a.ay(DrawingMLChart.bg, ChartDeserializer.bx);
        a.ax(DrawingMLChart.bg, ChartDeserializer.bz);
        a.ay(DrawingMLChart.bp, ChartDeserializer.cn);
        a.ay(DrawingMLChart.c1, ChartDeserializer.e9);
        a.ay(DrawingMLChart.e1, ChartDeserializer.io);
        a.ay(DrawingMLChart.f1, ChartDeserializer.ka);
        a.ay(DrawingMLChart.bh, ChartDeserializer.b3);
        a.ay(DrawingMLChart.en, ChartDeserializer.hq);
        a.ay(DrawingMLChart.es, ChartDeserializer.hx);
        a.ay(DrawingMLChart.be, ChartDeserializer.bv);
        a.ay(DrawingMLChart.fw, ChartDeserializer.j2);
        a.ay(DrawingMLChart.ge, ChartDeserializer.kw);
        a.ay(DrawingMLChart.ce, ChartDeserializer.dm);
        a.ay(DrawingMLChart.er, ChartDeserializer.hw);
        a.ay(DrawingMLChart.gi, ChartDeserializer.k5);
        a.ay(DrawingMLChart.cf, ChartDeserializer.dn);
        a.ay(DrawingMLMain.dr, ChartDeserializer.dp);
        a.ay(DrawingMLMain.dq, ChartDeserializer.dl);
        a.ay(DrawingMLChart.dv, ChartDeserializer.gq);
        a.ay(DrawingMLChart.cl, ChartDeserializer.d4);
        a.ay(DrawingMLChart.bf, ChartDeserializer.bw);
        a.ay(DrawingMLChart.bo, ChartDeserializer.cl);
        a.ay(DrawingMLChart.cn, ChartDeserializer.d6);
        a.ay(DrawingMLChart.e7, ChartDeserializer.i1);
        a.ay(DrawingMLChart.gh, ChartDeserializer.k4);
        a.ay(DrawingMLChart.f9, ChartDeserializer.kr);
        a.ay(DrawingMLChart.av, ChartDeserializer.ak);
        a.ay(DrawingMLChart.em, ChartDeserializer.hp);
        a.ay(DrawingMLChart.gn, ChartDeserializer.la);
        a.ay(DrawingMLChart.ck, ChartDeserializer.d3);
        a.ay(DrawingMLChart.fq, ChartDeserializer.jn);
        a.ay(DrawingMLChart.az, ChartDeserializer.aq);
        a.ay(DrawingMLChart.eo, ChartDeserializer.hr);
        a.ay(DrawingMLChart.c8, ChartDeserializer.fj);
        a.ay(DrawingMLChart.ep, ChartDeserializer.hs);
        a.ay(DrawingMLChart.bt, ChartDeserializer.ct);
        a.ay(DrawingMLChart.ff, ChartDeserializer.jb);
        a.ay(DrawingMLChart.gd, ChartDeserializer.kv);
        a.ay(DrawingMLChart.c2, ChartDeserializer.fb);
        a.ay(DrawingMLChart.eb, ChartDeserializer.ha);
        a.ay(DrawingMLChart.f0, ChartDeserializer.j9);
        a.ay(DrawingMLChart.ey, ChartDeserializer.ii);
        a.ay(DrawingMLChart.cg, ChartDeserializer.dr);
        a.ay(DrawingMLChart.fy, ChartDeserializer.j6);
        a.ay(DrawingMLChart.eu, ChartDeserializer.h5);
        a.ay(DrawingMLChart.et, ChartDeserializer.h3);
        a.ay(DrawingMLChart.gj, ChartDeserializer.k6);
        a.ay(DrawingMLMain.bz, ChartDeserializer.ba);
        a.ay(DrawingMLMain.f1, ChartDeserializer.fu);
        a.ay(DrawingMLMain.hd, ChartDeserializer.hb);
        a.ay(DrawingMLMain.hr, ChartDeserializer.h2);
        a.ay(DrawingMLMain.gr, ChartDeserializer.gr);
        a.ay(DrawingMLMain.g5, ChartDeserializer.gw);
        a.ay(DrawingMLMain.iq, ChartDeserializer.jv);
        a.ay(DrawingMLMain.id, ChartDeserializer.iw);
        a.ay(DrawingMLMain.ip, ChartDeserializer.ju);
        a.ay(DrawingMLMain.d2, ChartDeserializer.d1);
        a.ay(DrawingMLMain.bg, ChartDeserializer.am);
        a.ay(DrawingMLMain.eg, ChartDeserializer.eb);
        a.ay(DrawingMLMain.cd, ChartDeserializer.bs);
        a.ay(DrawingMLMain.ft, ChartDeserializer.fm);
        a.ay(DrawingMLMain.bi, ChartDeserializer.ap);
        a.ay(DrawingMLMain.h3, ChartDeserializer.ij);
        a.ay(DrawingMLMain.bc, ChartDeserializer.ac);
        a.ay(DrawingMLMain.g3, ChartDeserializer.gv);
        a.ay(DrawingMLMain.jy, ChartDeserializer.k1);
        a.ay(DrawingMLMain.bm, ChartDeserializer.a0);
        a.ay(DrawingMLMain.bl, ChartDeserializer.az);
        a.ay(DrawingMLMain.du, ChartDeserializer.dq);
        a.ay(DrawingMLMain.cs, ChartDeserializer.b8);
        a.ay(DrawingMLMain.ig, ChartDeserializer.iy);
        a.ay(DrawingMLMain.i0, ChartDeserializer.j4);
        a.ay(DrawingMLMain.e7, ChartDeserializer.ez);
        a.ay(DrawingMLMain.i8, ChartDeserializer.kf);
        a.ay(DrawingMLMain.ie, ChartDeserializer.ix);
        a.ay(DrawingMLMain.hn, ChartDeserializer.hy);
        a.ay(DrawingMLMain.jm, ChartDeserializer.kq);
        a.ay(DrawingMLMain.ii, ChartDeserializer.i6);
        a.ay(DrawingMLMain.cp, ChartDeserializer.b6);
        a.ay(DrawingMLMain.fg, ChartDeserializer.e6);
        a.ay(DrawingMLMain.en, ChartDeserializer.ef);
        a.ay(DrawingMLMain.a1, ChartDeserializer.s);
        a.ay(DrawingMLMain.a8, ChartDeserializer.z);
        a.ay(DrawingMLMain.a6, ChartDeserializer.x);
        a.ay(DrawingMLMain.e8, ChartDeserializer.e0);
        a.ay(DrawingMLMain.fa, ChartDeserializer.e2);
        a.ay(DrawingMLMain.e9, ChartDeserializer.e1);
        a.ay(DrawingMLMain.ia, ChartDeserializer.iq);
        a.ay(DrawingMLMain.ic, ChartDeserializer.is);
        a.ay(DrawingMLMain.ib, ChartDeserializer.ir);
        a.ay(DrawingMLMain.f4, ChartDeserializer.fv);
        a.ay(DrawingMLMain.f6, ChartDeserializer.fx);
        a.ay(DrawingMLMain.f5, ChartDeserializer.fw);
        a.ay(DrawingMLMain.hx, ChartDeserializer.ic);
        a.ay(DrawingMLMain.hz, ChartDeserializer.ie);
        a.ay(DrawingMLMain.hy, ChartDeserializer.id);
        a.ay(DrawingMLMain.ep, ChartDeserializer.eh);
        a.ay(DrawingMLMain.er, ChartDeserializer.ej);
        a.ay(DrawingMLMain.eq, ChartDeserializer.ei);
        a.ay(DrawingMLMain.bu, ChartDeserializer.a6);
        a.ay(DrawingMLMain.bw, ChartDeserializer.a8);
        a.ay(DrawingMLMain.bv, ChartDeserializer.a7);
        a.ay(DrawingMLMain.ef, ChartDeserializer.d8);
        a.ay(DrawingMLMain.fi, ChartDeserializer.e8);
        a.ay(DrawingMLMain.c4, ChartDeserializer.cp);
        a.ay(DrawingMLMain.f8, ChartDeserializer.fz);
        a.ay(DrawingMLMain.f9, ChartDeserializer.f0);
        a.ay(DrawingMLMain.ga, ChartDeserializer.f1);
        a.ay(DrawingMLMain.gb, ChartDeserializer.f2);
        a.ay(DrawingMLMain.gc, ChartDeserializer.f3);
        a.ay(DrawingMLMain.gd, ChartDeserializer.f4);
        a.ay(DrawingMLMain.ge, ChartDeserializer.f5);
        a.ay(DrawingMLMain.gf, ChartDeserializer.f6);
        a.ay(DrawingMLMain.gg, ChartDeserializer.f7);
        a.ay(DrawingMLMain.fy, ChartDeserializer.fr);
        a.ay(DrawingMLMain.it, ChartDeserializer.jx);
        a.ay(DrawingMLMain.is, ChartDeserializer.jw);
        a.ay(DrawingMLMain.b5, ChartDeserializer.bk);
        a.ay(DrawingMLMain.b4, ChartDeserializer.bj);
        a.ay(DrawingMLMain.cb, ChartDeserializer.br);
        a.ay(DrawingMLMain.b9, ChartDeserializer.bp);
        a.ay(DrawingMLMain.ca, ChartDeserializer.bq);
        a.ay(DrawingMLMain.b7, ChartDeserializer.bm);
        a.ay(DrawingMLMain.b6, ChartDeserializer.bl);
        a.ay(DrawingMLMain.b8, ChartDeserializer.bo);
        a.ay(DrawingMLMain.b1, ChartDeserializer.bc);
        a.ay(DrawingMLMain.b3, ChartDeserializer.bi);
        a.ay(DrawingMLMain.b2, ChartDeserializer.bh);
        a.ay(DrawingMLMain.jd, ChartDeserializer.ki);
        a.ay(DrawingMLMain.c5, ChartDeserializer.cq);
        a.ay(DrawingMLMain.iw, ChartDeserializer.jy);
        a.ay(DrawingMLMain.ix, ChartDeserializer.jz);
        a.ay(DrawingMLMain.bs, ChartDeserializer.a4);
        a.ay(DrawingMLMain.a2, ChartDeserializer.t);
        a.ay(DrawingMLMain.a3, ChartDeserializer.u);
        a.ay(DrawingMLMain.a4, ChartDeserializer.v);
        a.ay(DrawingMLMain.a5, ChartDeserializer.w);
        a.ay(DrawingMLMain.a7, ChartDeserializer.y);
        a.ay(DrawingMLMain.ba, ChartDeserializer.ab);
        a.ay(DrawingMLMain.bp, ChartDeserializer.a2);
        a.ay(DrawingMLMain.bx, ChartDeserializer.a9);
        a.ay(DrawingMLMain.cj, ChartDeserializer.b1);
        a.ay(DrawingMLMain.cl, ChartDeserializer.b4);
        a.ay(DrawingMLMain.dd, ChartDeserializer.c7);
        a.ay(DrawingMLMain.dx, ChartDeserializer.dv);
        a.ay(DrawingMLMain.eo, ChartDeserializer.eg);
        a.ay(DrawingMLMain.e6, ChartDeserializer.ey);
        a.ay(DrawingMLMain.cr, ChartDeserializer.b7);
        a.ay(DrawingMLMain.dg, ChartDeserializer.c9);
        a.ay(DrawingMLMain.a9, ChartDeserializer.aa);
        a.ay(DrawingMLMain.br, ChartDeserializer.a3);
        a.ay(DrawingMLMain.dw, ChartDeserializer.du);
        a.ay(DrawingMLMain.ei, ChartDeserializer.ed);
        a.ay(DrawingMLMain.ff, ChartDeserializer.e4);
        a.ay(DrawingMLMain.hc, ChartDeserializer.g8);
        a.ay(DrawingMLMain.hq, ChartDeserializer.h1);
        a.ay(DrawingMLMain.h0, ChartDeserializer.ig);
        a.ay(DrawingMLMain.h1, ChartDeserializer.ih);
        a.ay(DrawingMLMain.im, ChartDeserializer.js);
        a.ay(DrawingMLMain.j8, ChartDeserializer.lf);
        a.ay(DrawingMLMain.gy, ChartDeserializer.gt);
        a.ay(DrawingMLMain.io, ChartDeserializer.jt);
        a.ay(DrawingMLMain.ej, ChartDeserializer.ee);
        a.ay(DrawingMLMain.bt, ChartDeserializer.a5);
        a.ay(DrawingMLMain.hh, ChartDeserializer.hg);
        a.ay(DrawingMLMain.es, ChartDeserializer.el);
        a.ay(DrawingMLMain.eu, ChartDeserializer.en);
        a.ay(DrawingMLMain.fu, ChartDeserializer.fn);
        a.ay(DrawingMLMain.hf, ChartDeserializer.he);
        a.ay(DrawingMLMain.jk, ChartDeserializer.kp);
        a.ay(DrawingMLMain.et, ChartDeserializer.em);
        a.ay(DrawingMLMain.d1, ChartDeserializer.dx);
        a.ay(DrawingMLMain.iz, ChartDeserializer.j3);
        a.ay(DrawingMLMain.jj, ChartDeserializer.ko);
        a.ay(DrawingMLMain.i2, ChartDeserializer.j7);
        a.ay(DrawingMLMain.dy, ChartDeserializer.dw);
        a.ay(DrawingMLMain.dv, ChartDeserializer.dt);
        a.ay(DrawingMLMain.bn, ChartDeserializer.a1);
        a.ay(DrawingMLMain.ck, ChartDeserializer.b2);
        a.ay(DrawingMLMain.cn, ChartDeserializer.b5);
        a.ay(DrawingMLMain.jc, ChartDeserializer.kh);
        a.ay(DrawingMLMain.fw, ChartDeserializer.fq);
        a.ay(DrawingMLMain.di, ChartDeserializer.db);
        a.ay(DrawingMLMain.dh, ChartDeserializer.da);
        a.ay(DrawingMLMain.ey, ChartDeserializer.er);
        a.ay(DrawingMLMain.jx, ChartDeserializer.k0);
        a.ay(DrawingMLMain.jw, ChartDeserializer.kz);
        a.ay(DrawingMLMain.jv, ChartDeserializer.ky);
        a.ay(DrawingMLMain.ju, ChartDeserializer.kx);
        a.ay(DrawingMLMain.fq, ChartDeserializer.fa);
        a.ay(DrawingMLMain.de, ChartDeserializer.c8);
        a.ay(DrawingMLMain.ct, ChartDeserializer.cd);
        a.ay(DrawingMLMain.i7, ChartDeserializer.kd);
        a.ay(DrawingMLMain.e2, ChartDeserializer.et);
        a.ay(DrawingMLMain.e3, ChartDeserializer.eu);
        a.ay(DrawingMLMain.ho, ChartDeserializer.hz);
        a.ay(DrawingMLMain.cy, ChartDeserializer.cf);
        a.ay(DrawingMLMain.h6, ChartDeserializer.im);
        a.ay(DrawingMLMain.bk, ChartDeserializer.ay);
        a.ay(DrawingMLMain.gl, ChartDeserializer.gm);
        a.ay(DrawingMLMain.ew, ChartDeserializer.ep);
        a.ay(DrawingMLMain.je, ChartDeserializer.kj);
        a.ay(DrawingMLMain.dc, ChartDeserializer.c5);
        a.ay(DrawingMLMain.il, ChartDeserializer.jr);
        a.ay(DrawingMLMain.hl, ChartDeserializer.hv);
        a.ay(DrawingMLMain.hu, ChartDeserializer.h7);
        a.ay(DrawingMLMain.b0, ChartDeserializer.bb);
        a.ay(DrawingMLMain.d3, ChartDeserializer.d2);
        a.ay(DrawingMLMain.dm, ChartDeserializer.dc);
        a.ay(DrawingMLMain.h7, ChartDeserializer.ip);
        a.ay(DrawingMLMain.ja, ChartDeserializer.kg);
        a.ay(DrawingMLChart.dj, ChartDeserializer.gd);
        a.ay(DrawingMLChart.c3, ChartDeserializer.fd);
        a.ay(DrawingMLChart.gs, ChartDeserializer.lg);
        a.ay(DrawingMLChart.gv, ChartDeserializer.lj);
        a.ay(DrawingMLChart.gq, ChartDeserializer.ld);
        a.ay(DrawingMLChart.cv, ChartDeserializer.ev);
        a.ay(DrawingMLChart.gr, ChartDeserializer.le);
        a.ay(DrawingMLChart.gu, ChartDeserializer.li);
        a.ay(DrawingMLChart.go, ChartDeserializer.lb);
        a.ay(DrawingMLChart.cs, ChartDeserializer.eo);
        a.ay(DrawingMLChart.el, ChartDeserializer.ho);
        a.ay(DrawingMLChart.cy, ChartDeserializer.e3);
        a.ay(DrawingMLChart.dk, ChartDeserializer.ge);
        a.ay(DrawingMLChart.by, ChartDeserializer.cy);
        a.ay(DrawingMLChart.f4, ChartDeserializer.ke);
        a.ay(DrawingMLChart.fr, ChartDeserializer.jo);
        a.ay(DrawingMLChart.br, ChartDeserializer.cr);
        a.ay(DrawingMLChart.d1, ChartDeserializer.gy);
        a.ay(DrawingMLChart.bz, ChartDeserializer.cz);
        a.ay(DrawingMLChart.fj, ChartDeserializer.jg);
        a.ay(DrawingMLChart.fo, ChartDeserializer.jl);
        a.ay(DrawingMLChart.fe, ChartDeserializer.i9);
        a.ay(DrawingMLChart.fn, ChartDeserializer.jk);
        a.ay(DrawingMLChart.fm, ChartDeserializer.jj);
        a.ay(DrawingMLChart.fd, ChartDeserializer.i8);
        a.ay(DrawingMLChart.e8, ChartDeserializer.i2);
        a.ay(DrawingMLChart.ez, ChartDeserializer.ik);
        a.ay(DrawingMLChart.cx, ChartDeserializer.ex);
        a.ay(DrawingMLChart.e0, ChartDeserializer.il);
        a.ay(DrawingMLChart.bs, ChartDeserializer.cs);
        a.ay(DrawingMLChart.ex, ChartDeserializer.ia);
        a.ay(DrawingMLChart.ef, ChartDeserializer.hi);
        a.ay(DrawingMLChart.f5, ChartDeserializer.kk);
        a.ay(DrawingMLChart.eh, ChartDeserializer.hk);
        a.ay(DrawingMLChart.aq, ChartDeserializer.ae);
        a.ay(DrawingMLChart.ar, ChartDeserializer.af);
        a.ay(DrawingMLChart.ap, ChartDeserializer.ad);
        a.ay(DrawingMLChart.eg, ChartDeserializer.hj);
        a.ay(DrawingMLChart.ei, ChartDeserializer.hl);
        a.ay(DrawingMLChart.at, ChartDeserializer.ai);
        a.ay(DrawingMLChart.as, ChartDeserializer.ah);
        a.ay(DrawingMLChart.dc, ChartDeserializer.fp);
        a.ay(DrawingMLChart.db, ChartDeserializer.fo);
        a.ay(DrawingMLChart.fx, ChartDeserializer.j5);
        a.ay(DrawingMLChart.ev, ChartDeserializer.h8);
        a.ay(DrawingMLChart.e3, ChartDeserializer.iu);
        a.ay(DrawingMLChart.ek, ChartDeserializer.hn);
        a.ay(DrawingMLChart.ej, ChartDeserializer.hm);
        a.ay(DrawingMLChart.b1, ChartDeserializer.c1);
        a.ay(DrawingMLChart.a4, ChartDeserializer.av);
        a.ay(DrawingMLChart.a3, ChartDeserializer.au);
        a.ay(DrawingMLChart.d6, ChartDeserializer.g4);
        a.ay(DrawingMLChart.f3, ChartDeserializer.kc);
        a.ay(DrawingMLChart.f2, ChartDeserializer.kb);
        a.ay(DrawingMLChart.a8, ChartDeserializer.be);
        a.ay(DrawingMLChart.gl, ChartDeserializer.k8);
        a.ay(DrawingMLChart.bd, ChartDeserializer.bu);
        a.ay(DrawingMLChart.bq, ChartDeserializer.co);
        a.ay(DrawingMLChart.fa, ChartDeserializer.i4);
        a.ay(DrawingMLChart.b5, ChartDeserializer.c6);
        a.ay(DrawingMLChart.cr, ChartDeserializer.ek);
        a.ay(DrawingMLChart.gm, ChartDeserializer.k9);
        a.ay(DrawingMLChart.e9, ChartDeserializer.i3);
        a.ay(DrawingMLChart.b0, ChartDeserializer.c0);
        a.ay(DrawingMLChart.b4, ChartDeserializer.c4);
        a.ay(DrawingMLChart.ax, ChartDeserializer.an);
        a.ay(DrawingMLChart.d8, ChartDeserializer.g6);
        a.ay(DrawingMLChart.b3, ChartDeserializer.c3);
        a.ay(DrawingMLChart.ga, ChartDeserializer.ks);
        a.ay(DrawingMLChart.b6, ChartDeserializer.dd);
        a.ay(DrawingMLChart.bc, ChartDeserializer.bt);
        a.ay(DrawingMLChart.gk, ChartDeserializer.k7);
        a.ay(DrawingMLChart.c0, ChartDeserializer.e7);
        a.ay(DrawingMLChart.a7, ChartDeserializer.bd);
        a.ay(DrawingMLChart.cc, ChartDeserializer.dj);
        a.ay(DrawingMLChart.gc, ChartDeserializer.ku);
        a.ay(DrawingMLChart.ee, ChartDeserializer.hh);
        a.ay(DrawingMLChart.co, ChartDeserializer.d7);
        a.ay(DrawingMLChart.a0, ChartDeserializer.ar);
        a.ay(DrawingMLChart.cz, ChartDeserializer.e5);
        a.ay(DrawingMLChart.bv, ChartDeserializer.cv);
        a.ay(DrawingMLChart.bu, ChartDeserializer.cu);
        a.ay(DrawingMLChart.gb, ChartDeserializer.kt);
        a.ay(DrawingMLChart.b8, ChartDeserializer.df);
        a.ay(DrawingMLChart.b7, ChartDeserializer.de);
        a.ay(DrawingMLChart.b9, ChartDeserializer.dg);
        a.ay(DrawingMLChart.dy, ChartDeserializer.gs);
        a.ay(DrawingMLChart.eq, ChartDeserializer.ht);
        a.ay(DrawingMLChart.ds, ChartDeserializer.gl);
        a.ay(DrawingMLChart.d3, ChartDeserializer.g0);
        a.ay(DrawingMLChart.d2, ChartDeserializer.gz);
        a.ay(DrawingMLChart.d0, ChartDeserializer.gx);
        a.ay(DrawingMLChart.cm, ChartDeserializer.d5);
        a.ay(DrawingMLChart.du, ChartDeserializer.gp);
        a.ay(DrawingMLChart.fz, ChartDeserializer.j8);
        a.ay(DrawingMLChart.dt, ChartDeserializer.go);
        a.ay(DrawingMLChart.de, ChartDeserializer.fy);
        a.ay(DrawingMLChart.fi, ChartDeserializer.je);
        a.ay(DrawingMLChart.c6, ChartDeserializer.fg);
        a.ay(DrawingMLChart.cp, ChartDeserializer.d9);
        a.ay(DrawingMLChart.cu, ChartDeserializer.es);
        a.ay(DrawingMLChart.gg, ChartDeserializer.k3);
        a.ay(DrawingMLChart.ft, ChartDeserializer.jq);
        a.ay(DrawingMLChart.cq, ChartDeserializer.ea);
        a.ay(DrawingMLChart.gf, ChartDeserializer.k2);
        a.ay(DrawingMLChart.b2, ChartDeserializer.c2);
        a.ay(DrawingMLChart.ew, ChartDeserializer.h9);
        a.ay(DrawingMLChart.e4, ChartDeserializer.iv);
        a.ay(DrawingMLChart.gt, ChartDeserializer.lh);
        a.ay(DrawingMLChart.gw, ChartDeserializer.lk);
        a.ay(DrawingMLChart.cj, ChartDeserializer.d0);
        a.ay(DrawingMLChart.cw, ChartDeserializer.ew);
        a.ay(DrawingMLChart.a5, ChartDeserializer.aw);
        a.ay(DrawingMLChart.ea, ChartDeserializer.g9);
        a.ay(DrawingMLChart.fb, ChartDeserializer.i5);
        a.ay(DrawingMLChart.fc, ChartDeserializer.i7);
        a.ay(DrawingMLChart.d7, ChartDeserializer.g5);
        a.ay(DrawingMLChart.fv, ChartDeserializer.j1);
        a.ay(DrawingMLChart.fu, ChartDeserializer.j0);
        a.ay(DrawingMLChart.bm, ChartDeserializer.ch);
        a.ay(DrawingMLChart.e6, ChartDeserializer.i0);
        a.ay(DrawingMLChart.e5, ChartDeserializer.iz);
        a.ay(DrawingMLChart.gp, ChartDeserializer.lc);
        a.ay(DrawingMLChart.a2, ChartDeserializer.at);
        a.ay(DrawingMLChart.a1, ChartDeserializer.as);
        a.ay(DrawingMLChart.a9, ChartDeserializer.bf);
        a.ay(DrawingMLChart.fk, ChartDeserializer.jh);
        a.ay(DrawingMLChart.fs, ChartDeserializer.jp);
        a.ay(DrawingMLChart.ba, ChartDeserializer.bg);
        a.ay(DrawingMLChart.e2, ChartDeserializer.it);
        a.ay(DrawingMLChart.ay, ChartDeserializer.ao);
        a.ay(DrawingMLChart.df, ChartDeserializer.f9);
        a.ay(DrawingMLChart.dn, ChartDeserializer.gh);
        a.ay(DrawingMLChart.dg, ChartDeserializer.ga);
        a.ay(DrawingMLChart.dp, ChartDeserializer.gi);
        a.ay(DrawingMLChart.f6, ChartDeserializer.kl);
        a.ay(DrawingMLChart.bi, ChartDeserializer.b9);
        a.ay(DrawingMLChart.bk, ChartDeserializer.cb);
        a.ay(DrawingMLChart.bl, ChartDeserializer.cc);
        a.ay(DrawingMLChart.bj, ChartDeserializer.ca);
        a.ay(DrawingMLChart.di, ChartDeserializer.gc);
        a.ay(DrawingMLChart.dr, ChartDeserializer.gk);
        a.ay(DrawingMLChart.bw, ChartDeserializer.cw);
        a.ay(DrawingMLChart.dd, ChartDeserializer.ft);
        a.ay(DrawingMLChart.d9, ChartDeserializer.g7);
        a.ay(DrawingMLChart.dl, ChartDeserializer.gf);
        a.ay(DrawingMLChart.dm, ChartDeserializer.gg);
        a.ay(DrawingMLChart.bn, ChartDeserializer.ci);
        a.ay(DrawingMLChart.bb, ChartDeserializer.bn);
        a.ay(DrawingMLChart.bx, ChartDeserializer.cx);
        a.ay(DrawingMLChart.au, ChartDeserializer.aj);
        a.ay(DrawingMLChart.c4, ChartDeserializer.fe);
        a.ay(DrawingMLChart.c5, ChartDeserializer.ff);
        a.ay(DrawingMLChart.f7, ChartDeserializer.km);
        a.ay(DrawingMLChart.f8, ChartDeserializer.kn);
        a.ay(DrawingMLChart.dz, ChartDeserializer.gu);
        a.ay(DrawingMLChart.a6, ChartDeserializer.ax);
        a.ay(DrawingMLChart.dh, ChartDeserializer.gb);
        a.ay(DrawingMLChart.dq, ChartDeserializer.gj);
        a.ay(DrawingMLChart.fg, ChartDeserializer.jc);
        a.ay(DrawingMLChart.fp, ChartDeserializer.jm);
        a.ay(DrawingMLChart.fl, ChartDeserializer.ji);
        a.ay(DrawingMLChart.fh, ChartDeserializer.jd);
        a.ay(DrawingMLChart.da, ChartDeserializer.fl);
        a.ay(DrawingMLChart.c9, ChartDeserializer.fk);
        a.ay(DrawingMLMain.cz, ChartDeserializer.cg);
        a.ay(DrawingMLMain.hp, ChartDeserializer.h0);
        a.ay(DrawingMLMain.hb, ChartDeserializer.g3);
        a.ay(DrawingMLMain.eh, ChartDeserializer.ec);
        a.ay(DrawingMLMain.ax, ChartDeserializer.p);
        a.ay(DrawingMLMain.c2, ChartDeserializer.ck);
        a.ay(DrawingMLMain.hw, ChartDeserializer.ib);
        a.ay(DrawingMLMain.hg, ChartDeserializer.hf);
        a.ay(DrawingMLMain.az, ChartDeserializer.r);
        a.ay(DrawingMLMain.ay, ChartDeserializer.q);
        a.ay(DrawingMLMain.hk, ChartDeserializer.hu);
        a.ay(DrawingMLMain.c1, ChartDeserializer.cj);
        a.ay(DrawingMLMain.ci, ChartDeserializer.b0);
        a.ay(DrawingMLMain.gm, ChartDeserializer.gn);
        a.ay(DrawingMLMain.f0, ChartDeserializer.fs);
        a.ay(DrawingMLMain.bf, ChartDeserializer.ag);
        a.ay(DrawingMLMain.ht, ChartDeserializer.h6);
        a.ay(DrawingMLMain.cv, ChartDeserializer.ce);
        a.ay(DrawingMLMain.hs, ChartDeserializer.h4);
        a.ay(DrawingMLChart.aw, ChartDeserializer.al);
        a.ay(DrawingMLChart.ct, ChartDeserializer.eq);
        a.ay(DrawingMLChart.ec, ChartDeserializer.hc);
        a.ay(DrawingMLChart.ed, ChartDeserializer.hd);
        a.ay(DrawingMLChart.c7, ChartDeserializer.fi);
        a.ay(DrawingMLChart.d5, ChartDeserializer.g2);
        a.ay(DrawingMLChart.d4, ChartDeserializer.g1);
        a.ay(DrawingMLChart.cb, ChartDeserializer.di);
        a.ay(DrawingMLChart.ca, ChartDeserializer.dh);
        a.ay(DrawingMLChart.ci, ChartDeserializer.dz);
        a.ay(DrawingMLChart.ch, ChartDeserializer.dy);
        a.ay(DrawingMLChart.cd, ChartDeserializer.dk);
        a.ay(DrawingMLChart2012.bq, ChartDeserializer.jf);
        a.ay(DrawingMLChart2012.bp, ChartDeserializer.ja);
        a.ay(DrawingMLChart2012.bg, ChartDeserializer.fh);
        a.ay(DrawingMLChart2012.bf, ChartDeserializer.fc);
        a.ay(DrawingMLChart2012.au, ChartDeserializer.cm);
        a.ay(DrawingMLChart2012.a1, ChartDeserializer.ds);
    }
    static by(a) {
        throw new InvalidXLSXElementException(ChartExElements.m);
    }
    static bx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(ChartDeserializer.$, b, false);
        if (c == null) {
            let d = SerializationUtils.t(b.a8._d.uri);
            c = ((() => {
                let $ret = new ChartDeserializer();
                $ret.b = b.a8._by;
                $ret.o = d;
                return $ret;
            })());
            c.b = b.a8._by;
            b.s.k(c);
        }
        let e = new CT_ChartSpace();
        b.s.k(e);
    }
    static bz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(ChartDeserializer.$, b);
        if (c == null) {
            return;
        }
        let d = ChartDeserializer.a(CT_ChartSpace.$, a);
        if (d == null) {
            return;
        }
        d.a = b.a8._b3;
        if (c.b._ad == null) {
            c.b._ad = new ChartDeserializationCache();
        }
        c.b._ad.a.addItem(c.o, d);
    }
    static cn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.b = d;
    }
    static e9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextLanguageID.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextLanguageID();
            $ret.b = d;
            return $ret;
        })());
        c.r = f;
    }
    static io(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.d = d;
    }
    static ka(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Style.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Style();
            $ret.a = d;
            return $ret;
        })());
        c.p = f;
    }
    static b3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = 0;
        let e = 0;
        let f = 0;
        let g = 0;
        let h = 0;
        let i = 0;
        let j = 0;
        let k = 0;
        let l = 0;
        let m = 0;
        let n = 0;
        let o = 0;
        let p = CT_ColorMapping.ac(a, d, e, f, g, h, i, j, k, l, m, n, o);
        d = p.p1;
        e = p.p2;
        f = p.p3;
        g = p.p4;
        h = p.p5;
        i = p.p6;
        j = p.p7;
        k = p.p8;
        l = p.p9;
        m = p.p10;
        n = p.p11;
        o = p.p12;
        let q = ((() => {
            let $ret = new CT_ColorMapping();
            $ret.d = h;
            $ret.f = i;
            $ret.h = j;
            $ret.j = k;
            $ret.l = l;
            $ret.n = m;
            $ret.p = d;
            $ret.r = f;
            $ret.t = o;
            $ret.v = n;
            $ret.x = e;
            $ret.z = g;
            return $ret;
        })());
        c.t = q;
        ChartDeserializer.ll(b, q);
    }
    static hq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PivotSource();
        c.j = d;
        ChartDeserializer.ll(b, d);
    }
    static hx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Protection();
        c.n = d;
        ChartDeserializer.ll(b, d);
    }
    static bv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Chart();
        c.f = d;
        ChartDeserializer.ll(b, d);
    }
    static j2(a) {
        let b = [CT_ChartSpace.$, CT_Title.$, CT_PivotFmt.$, CT_Marker_Chart.$, CT_DLbl.$, CT_Surface.$, CT_PlotArea.$, CT_AreaSer.$, CT_DPt.$, CT_Trendline.$, CT_TrendlineLbl.$, CT_ErrBars.$, CT_DLbls.$, CT_ChartLines.$, CT_LineSer.$, CT_UpDownBar.$, CT_RadarSer.$, CT_ScatterSer.$, CT_PieSer.$, CT_BarSer.$, CT_SurfaceSer.$, CT_BandFmt.$, CT_BubbleSer.$, CT_ValAx.$, CT_DispUnitsLbl.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$, CT_DTable.$, CT_Legend.$];
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d;
        let e = CT_ShapeProperties.f(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ShapeProperties_DML();
            $ret.q = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1570, f);
        }
        ChartDeserializer.ll(c, f);
    }
    static kw(a) {
        let b = [CT_ChartSpace.$, CT_Title.$, CT_PivotFmt.$, CT_DLbl.$, CT_TrendlineLbl.$, CT_DLbls.$, CT_ValAx.$, CT_DispUnitsLbl.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$, CT_DTable.$, CT_Legend.$, CT_LegendEntry.$];
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d = new CT_TextBody_DML();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1783, d);
        }
        ChartDeserializer.ll(c, d);
    }
    static dm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c;
        let d;
        let e = CT_ExternalData.f(b, d, c);
        d = e.p1;
        c = e.p2;
        let f = ((() => {
            let $ret = new CT_ExternalData();
            $ret.c = c;
            return $ret;
        })());
        if (d.hasValue) {
            f.a = CT_Boolean.b(d.value);
        }
        let g = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (g == null) {
            return;
        }
        g.h = f;
        ChartDeserializer.ll(b, f);
    }
    static hw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = new CT_PrintSettings();
        let d = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (d == null) {
            return;
        }
        d.l = c;
        ChartDeserializer.ll(b, c);
    }
    static k5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = DMLChartUtils.ak(b);
        let d = ChartDeserializer.a(CT_ChartSpace.$, b);
        if (d == null) {
            return;
        }
        d.z = c;
        ChartDeserializer.ll(b, c);
    }
    static dn(a) {
        let b = [CT_ChartSpace.$, CT_PivotSource.$, CT_Chart.$, CT_Title.$, CT_StrRef.$, CT_StrData.$, CT_Layout.$, CT_ManualLayout.$, CT_PivotFmt.$, CT_Marker_Chart.$, CT_DLbl.$, CT_View3D.$, CT_Surface.$, CT_PlotArea.$, CT_AreaChart.$, CT_AreaSer.$, CT_DPt.$, CT_Trendline.$, CT_TrendlineLbl.$, CT_ErrBars.$, CT_NumRef.$, CT_NumData.$, CT_MultiLvlStrRef.$, CT_MultiLvlStrData.$, CT_DLbls.$, CT_Area3DChart.$, CT_LineChart.$, CT_LineSer.$, CT_UpDownBars.$, CT_Line3DChart.$, CT_StockChart.$, CT_RadarChart.$, CT_RadarSer.$, CT_ScatterChart.$, CT_ScatterSer.$, CT_PieChart.$, CT_PieSer.$, CT_Pie3DChart.$, CT_DoughnutChart.$, CT_BarChart.$, CT_BarSer.$, CT_Bar3DChart.$, CT_OfPieChart.$, CT_SurfaceChart.$, CT_SurfaceSer.$, CT_Surface3DChart.$, CT_BubbleChart.$, CT_BubbleSer.$, CT_ValAx.$, CT_Scaling.$, CT_DispUnits.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$, CT_DTable.$, CT_Legend.$, CT_LegendEntry.$];
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d = new CT_ExtensionList();
        let e = SerializationUtils.j(c, b);
        if (e == null) {
            return;
        }
        e.setProperty(601, d);
        ChartDeserializer.ll(c, d);
    }
    static dp(a) {
        let b = [CT_ColorMapping.$, CT_TextBodyProperties_DML.$, CT_Scene3D.$, CT_Backdrop.$, CT_Shape3D.$, CT_TextListStyle_DML.$, CT_TextParagraphProperties_DML.$, CT_Blip_DML.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_Hyperlink.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d = new CT_OfficeArtExtensionList();
        let e = SerializationUtils.j(c, b);
        if (e == null) {
            return;
        }
        e.setProperty(601, d);
        ChartDeserializer.ll(c, d);
    }
    static dl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = null;
        let d = CT_OfficeArtExtension.d(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_OfficeArtExtension();
            $ret.b = c;
            return $ret;
        })());
        let f = ChartDeserializer.a(CT_OfficeArtExtensionList.$, b);
        if (f == null) {
            return;
        }
        f.b.b.add(e);
    }
    static gq(a) {
        let b = [CT_PivotSource.$, CT_Trendline.$];
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d = SerializationUtils.j(c, b);
        if (d == null) {
            return;
        }
        let e = c.ab.ad;
        d.setProperty(1045, e);
    }
    static d4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PivotSource.$, b);
        if (c == null) {
            return;
        }
        let d = CT_UnsignedInt.c(b);
        c.a = d;
    }
    static bw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Protection.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static cl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Protection.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static d6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Protection.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.e = d;
    }
    static i1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Protection.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.g = d;
    }
    static k4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Protection.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.i = d;
    }
    static kr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Chart.$, CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_Title();
        d.setProperty(1745, e);
        ChartDeserializer.ll(b, e);
    }
    static ak(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static hp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_PivotFmts();
            $ret.e = new List$1(CT_PivotFmt.$, 0);
            return $ret;
        })());
        c.y = CT_PivotFmts.c(d);
        ChartDeserializer.ll(b, d);
    }
    static la(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_View3D();
        c.u = d;
        ChartDeserializer.ll(b, d);
    }
    static d3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Surface();
        c.o = d;
        ChartDeserializer.ll(b, d);
    }
    static jn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Surface();
        c.q = d;
        ChartDeserializer.ll(b, d);
    }
    static aq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Surface();
        c.m = d;
        ChartDeserializer.ll(b, d);
    }
    static hr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PlotArea();
        c.k = d;
        ChartDeserializer.ll(b, d);
    }
    static fj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Legend();
            $ret.m = new List$1(CT_LegendEntry.$, 0);
            $ret.k = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.i = d;
        ChartDeserializer.ll(b, d);
    }
    static hs(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static ct(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_DispBlanksAs.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_DispBlanksAs();
            $ret.b = d;
            return $ret;
        })());
        c.g = f;
    }
    static jb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.e = d;
    }
    static kv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        if (ChartDeserializer.n(b)) {
            return;
        }
        else if (ChartDeserializer.k(b)) {
            return;
        }
        else {
        }
    }
    static n(a) {
        let b = [CT_Title.$, CT_DLbl.$, CT_TrendlineLbl.$, CT_DispUnitsLbl.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = new CT_Tx();
        c.setProperty(1776, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static k(a) {
        let b = [CT_AreaSer.$, CT_BarSer.$, CT_PieSer.$, CT_LineSer.$, CT_BubbleSer.$, CT_SurfaceSer.$, CT_ScatterSer.$, CT_RadarSer.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = new CT_SerTx();
        c.setProperty(1776, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static fb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Title.$, CT_DLbl.$, CT_PlotArea.$, CT_TrendlineLbl.$, CT_DispUnitsLbl.$, CT_Legend.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_Layout();
        d.setProperty(876, e);
        ChartDeserializer.ll(b, e);
    }
    static ha(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Title.$, CT_Legend.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1150, e);
    }
    static j9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Tx.$, CT_SerTx.$, CT_AxDataSource.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_StrRef();
        d.setProperty(1606, e);
        ChartDeserializer.ll(b, e);
    }
    static ii(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Tx.$, CT_SerTx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_TextBody_DML();
        d.setProperty(1362, e);
        ChartDeserializer.ll(b, e);
    }
    static dr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_StrRef.$, CT_NumRef.$, CT_MultiLvlStrRef.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = b.ab.ad;
        d.setProperty(612, e);
    }
    static j6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_StrRef.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_StrData();
            $ret.f = new List$1(CT_StrVal.$, 0);
            return $ret;
        })());
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static h5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_StrData.$, CT_NumData.$, CT_MultiLvlStrData.$];
        let d = CT_UnsignedInt.c(b);
        let e = SerializationUtils.j(b, c);
        if (e == null) {
            return;
        }
        e.setProperty(1278, d);
    }
    static h3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        if (ChartDeserializer.g(b)) {
            return;
        }
        else if (ChartDeserializer.l(b)) {
            return;
        }
        else {
        }
    }
    static l(a) {
        let b = [CT_StrData.$, CT_Lvl.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d;
        let e = CT_StrVal.f(a, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_StrVal();
            $ret.d = d;
            return $ret;
        })());
        c.setProperty(1277, f);
        ChartDeserializer.ll(a, f);
        return true;
    }
    static g(a) {
        let b = ChartDeserializer.a(CT_NumData.$, a, false);
        if (b == null) {
            return false;
        }
        let c;
        let d;
        let e = CT_NumVal.h(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_NumVal();
            $ret.f = c;
            $ret.a = d;
            return $ret;
        })());
        b.e.add(f);
        ChartDeserializer.ll(a, f);
        return true;
    }
    static k6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_StrVal.$, CT_SerTx.$, CT_NumVal.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = b.ab.ad;
        d.setProperty(1818, e);
    }
    static ba(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = SerializationUtils.f(b);
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static fu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextListStyle_DML();
        c.b = d;
        ChartDeserializer.ll(b, d);
    }
    static hb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextParagraph_DML();
        c.d.add(d);
        ChartDeserializer.ll(b, d);
    }
    static h2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PresetTextShape.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PresetTextShape();
            $ret.a = d;
            return $ret;
        })());
        c.c = f;
        ChartDeserializer.ll(b, f);
    }
    static gr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextNoAutofit();
        c.setProperty(1057, d);
    }
    static gw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = CT_TextNormalAutofit.h(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextNormalAutofit();
            $ret.c = d;
            $ret.e = e;
            return $ret;
        })());
        c.setProperty(1057, g);
    }
    static jv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextShapeAutofit();
        c.setProperty(1565, d);
    }
    static iw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$];
        let d = new CT_Scene3D();
        let e = SerializationUtils.j(b, c);
        if (e == null) {
            return;
        }
        e.setProperty(1423, d);
        ChartDeserializer.ll(b, d);
    }
    static ju(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(ST_PresetMaterialType_$type, null);
        let g = CT_Shape3D.y(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_Shape3D();
            $ret.v = c;
            $ret.r = d;
            $ret.p = e;
            return $ret;
        })());
        let i = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$];
        let j = SerializationUtils.j(b, i);
        if (j == null) {
            return;
        }
        j.setProperty(1423, h);
        ChartDeserializer.ll(b, h);
    }
    static d1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_FlatText.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_FlatText();
            $ret.b = d;
            return $ret;
        })());
        c.setProperty(650, f);
        ChartDeserializer.ll(b, f);
    }
    static am(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_PresetTextShape.$, CT_CustomGeometry2D.$, CT_PresetGeometry2D.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_GeomGuideList();
        d.setProperty(80, e);
        ChartDeserializer.ll(b, e);
    }
    static eb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GeomGuideList.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_GeomGuide.c(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_GeomGuide();
            $ret.b = d;
            $ret.a = e;
            return $ret;
        })());
        c.b.add(g);
    }
    static bs(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = 0;
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = CT_Camera.l(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Camera();
            $ret.d = d;
            $ret.g = e;
            $ret.i = f;
            return $ret;
        })());
        c.c = h;
        ChartDeserializer.ll(b, h);
    }
    static fm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = 0;
        let e = 0;
        let f = CT_LightRig.h(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_LightRig();
            $ret.e = d;
            $ret.c = e;
            return $ret;
        })());
        c.e = g;
        ChartDeserializer.ll(b, g);
    }
    static ap(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Backdrop();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static ij(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Camera.$, CT_LightRig.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = 0;
        let f = 0;
        let g = 0;
        let h = CT_SphereCoords.h(a, e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        let i = ((() => {
            let $ret = new CT_SphereCoords();
            $ret.a = e;
            $ret.c = f;
            $ret.e = g;
            return $ret;
        })());
        d.setProperty(1370, i);
    }
    static ac(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_Point3D.h(b, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Point3D();
            $ret.a = d;
            $ret.c = e;
            $ret.e = f;
            return $ret;
        })());
        c.c = h;
    }
    static gv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_Vector3D.i(b, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Vector3D();
            $ret.b = d;
            $ret.d = e;
            $ret.f = f;
            return $ret;
        })());
        c.e = h;
    }
    static k1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_Vector3D.i(b, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Vector3D();
            $ret.b = d;
            $ret.d = e;
            $ret.f = f;
            return $ret;
        })());
        c.g = h;
    }
    static a0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        let g = CT_Bevel.l(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Bevel();
            $ret.i = d;
            $ret.e = e;
            $ret.g = f;
            return $ret;
        })());
        c.c = h;
    }
    static az(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(ST_BevelPresetType_$type, null);
        let g = CT_Bevel.l(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Bevel();
            $ret.i = d;
            $ret.e = e;
            $ret.g = f;
            return $ret;
        })());
        c.a = h;
    }
    static dq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.g = d;
        ChartDeserializer.ll(b, d);
    }
    static b8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.e = d;
        ChartDeserializer.ll(b, d);
    }
    static iy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_ScRgbColor.e(b);
        d.setProperty(1431, e);
        ChartDeserializer.ll(b, e);
    }
    static j4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new ST_HexColorRGB();
        let f = CT_SRgbColor.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_SRgbColor_DML();
            $ret.f = e;
            return $ret;
        })());
        d.setProperty(1586, g);
        ChartDeserializer.ll(b, g);
    }
    static ez(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_HslColor.e(b);
        d.setProperty(1586, e);
        ChartDeserializer.ll(b, e);
    }
    static kf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_SystemColor.e(b);
        d.setProperty(1652, e);
        ChartDeserializer.ll(b, e);
    }
    static ix(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_SchemeColor_DML.f(b);
        d.setProperty(1429, e);
        ChartDeserializer.ll(b, e);
    }
    static hy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_PresetColor.e(b);
        d.setProperty(1272, e);
    }
    static kq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = DMLUtils.p(b);
        d.setProperty(1744, e);
    }
    static i6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = DMLUtils.p(b);
        d.setProperty(1459, e);
    }
    static b6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_ComplementTransform();
        d.setProperty(326, e);
    }
    static e6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_InverseTransform();
        d.setProperty(845, e);
    }
    static ef(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_GrayscaleTransform();
        d.setProperty(731, e);
    }
    static s(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.x(b);
    }
    static z(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.ae(b);
    }
    static x(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.ac(b);
    }
    static e0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bk(b);
    }
    static e2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bm(b);
    }
    static e1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bl(b);
    }
    static iq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.b8(b);
    }
    static is(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.ca(b);
    }
    static ir(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.b9(b);
    }
    static fv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bs(b);
    }
    static fx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bu(b);
    }
    static fw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bt(b);
    }
    static ic(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.b2(b);
    }
    static ie(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.b4(b);
    }
    static id(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.b3(b);
    }
    static eh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bc(b);
    }
    static ej(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.be(b);
    }
    static ei(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bd(b);
    }
    static a6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.am(b);
    }
    static a8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.ao(b);
    }
    static a7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.an(b);
    }
    static d8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.a7(b);
    }
    static e8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        SerializationUtils.bp(b);
    }
    static cp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextListStyle_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TextParagraphProperties_DML.o(b);
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static fz(a) {
        ChartDeserializer.f8(a, 945);
    }
    static f0(a) {
        ChartDeserializer.f8(a, 946);
    }
    static f1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        ChartDeserializer.f8(a, 947);
    }
    static f2(a) {
        ChartDeserializer.f8(a, 948);
    }
    static f3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        ChartDeserializer.f8(a, 949);
    }
    static f4(a) {
        ChartDeserializer.f8(a, 950);
    }
    static f5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        ChartDeserializer.f8(a, 951);
    }
    static f6(a) {
        ChartDeserializer.f8(a, 952);
    }
    static f7(a) {
        ChartDeserializer.f8(a, 953);
    }
    static fr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.p = d;
        ChartDeserializer.ll(b, d);
    }
    static jx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.r = d;
        ChartDeserializer.ll(b, d);
    }
    static jw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.q = d;
        ChartDeserializer.ll(b, d);
    }
    static bk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletColorFollowText();
        c.setProperty(176, d);
    }
    static bj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.setProperty(175, d);
        ChartDeserializer.ll(b, d);
    }
    static br(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletSizeFollowText();
        c.setProperty(182, d);
        ChartDeserializer.ll(b, d);
    }
    static bp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextBulletSizePercent.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextBulletSizePercent();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(182, f);
    }
    static bq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextBulletSizePoint.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextBulletSizePoint();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(181, f);
    }
    static bm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletTypefaceFollowText();
        c.setProperty(178, d);
    }
    static bl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.b6);
        c.setProperty(177, d);
        ChartDeserializer.ll(b, d);
    }
    static bo(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextNoBullet();
        c.setProperty(179, d);
    }
    static bc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_TextAutonumberBullet.g(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextAutonumberBullet();
            $ret.d = e;
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(172, g);
    }
    static bi(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextCharBullet.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextCharBullet();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(174, f);
    }
    static bh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBlipBullet();
        c.setProperty(173, d);
        ChartDeserializer.ll(b, d);
    }
    static ki(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_TextTabStopList();
            $ret.e = new List$1(CT_TextTabStop.$, 0);
            return $ret;
        })());
        c.aa = d.e;
        ChartDeserializer.ll(b, d);
    }
    static cq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TextCharacterProperties_DML.z(b, DrawingMLMain.c5);
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static jy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextSpacing.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextSpacingPercent.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextSpacingPercent();
            $ret.a = d;
            return $ret;
        })());
        c.a = f;
    }
    static jz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextSpacing.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextSpacingPoint.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextSpacingPoint();
            $ret.a = d;
            return $ret;
        })());
        c.b = f;
    }
    static a4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextBlipBullet.$, CT_BlipFillProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Blip_DML.l(b);
        d.setProperty(127, e);
        ChartDeserializer.ll(b, e);
    }
    static t(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.y(b, c);
    }
    static u(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.z(b, c);
    }
    static v(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.aa(b, c);
    }
    static w(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.ab(b, c);
    }
    static y(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.ad(b, c);
    }
    static ab(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.af(b, c);
    }
    static a2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.al(b, c);
    }
    static a9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$, CT_EffectList.$];
        SerializationUtils.ap(b, c);
    }
    static b1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.ar(b, c);
    }
    static b4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.at(b, c);
    }
    static c7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.az(b, c);
    }
    static dv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$, CT_EffectList.$];
        SerializationUtils.a4(b, c);
    }
    static eg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.bb(b, c);
    }
    static ey(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Blip_DML.$, CT_EffectContainer.$];
        SerializationUtils.bi(b, c);
    }
    static b7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AlphaModulateEffect.$, CT_EffectContainer.$, CT_BlendEffect.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_EffectContainer.a(a);
        d.setProperty(344, e);
        ChartDeserializer.ll(b, e);
    }
    static c9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_EffectReference.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_EffectReference();
            $ret.a = d;
            return $ret;
        })());
        c.setProperty(556, f);
    }
    static aa(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_AlphaOutsetEffect.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaOutsetEffect();
            $ret.b = d;
            return $ret;
        })());
        c.setProperty(556, f);
    }
    static a3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_BlendEffect.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BlendEffect();
            $ret.c = d;
            return $ret;
        })());
        c.setProperty(125, f);
        ChartDeserializer.ll(b, f);
    }
    static du(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_FillEffect();
        c.setProperty(630, d);
        ChartDeserializer.ll(b, d);
    }
    static ed(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_GlowEffect.g(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_GlowEffect();
            $ret.e = e;
            return $ret;
        })());
        d.setProperty(724, g);
        ChartDeserializer.ll(b, g);
    }
    static e4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = CT_InnerShadowEffect.m(a, e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        let i = ((() => {
            let $ret = new CT_InnerShadowEffect();
            $ret.g = e;
            $ret.k = f;
            $ret.i = g;
            return $ret;
        })());
        d.setProperty(830, i);
        ChartDeserializer.ll(b, i);
    }
    static g8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let m = Nullable$1.toNullable(Boolean_$type, null);
        let n = CT_OuterShadowEffect.af(a, e, f, g, h, i, j, k, l, m);
        e = n.p1;
        f = n.p2;
        g = n.p3;
        h = n.p4;
        i = n.p5;
        j = n.p6;
        k = n.p7;
        l = n.p8;
        m = n.p9;
        let o = ((() => {
            let $ret = new CT_OuterShadowEffect();
            $ret.n = l;
            $ret.p = e;
            $ret.r = g;
            $ret.t = f;
            $ret.v = j;
            $ret.x = k;
            $ret.z = m;
            $ret.ab = h;
            $ret.ad = i;
            return $ret;
        })());
        d.setProperty(1142, o);
        ChartDeserializer.ll(b, o);
    }
    static h1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = 0;
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = CT_PresetShadowEffect.l(a, e, f, g);
        e = h.p1;
        f = h.p2;
        g = h.p3;
        let i = ((() => {
            let $ret = new CT_PresetShadowEffect();
            $ret.d = e;
            $ret.j = f;
            $ret.h = g;
            return $ret;
        })());
        d.setProperty(1275, i);
        ChartDeserializer.ll(b, i);
    }
    static ig(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Number_$type, null);
        let m = Nullable$1.toNullable(Number_$type, null);
        let n = Nullable$1.toNullable(Number_$type, null);
        let o = Nullable$1.toNullable(Number_$type, null);
        let p = Nullable$1.toNullable(Number_$type, null);
        let q = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        let r = Nullable$1.toNullable(Boolean_$type, null);
        let s = CT_ReflectionEffect.ar(a, e, f, g, h, i, j, k, l, m, n, o, p, q, r);
        e = s.p1;
        f = s.p2;
        g = s.p3;
        h = s.p4;
        i = s.p5;
        j = s.p6;
        k = s.p7;
        l = s.p8;
        m = s.p9;
        n = s.p10;
        o = s.p11;
        p = s.p12;
        q = s.p13;
        r = s.p14;
        let t = ((() => {
            let $ret = new CT_ReflectionEffect();
            $ret.o = q;
            $ret.q = e;
            $ret.s = k;
            $ret.u = j;
            $ret.w = h;
            $ret.y = i;
            $ret.aa = l;
            $ret.ac = o;
            $ret.ae = p;
            $ret.ag = r;
            $ret.ai = f;
            $ret.ak = g;
            $ret.am = m;
            $ret.ao = n;
            return $ret;
        })());
        d.setProperty(1338, t);
    }
    static ih(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d, e;
        let f = CT_RelativeOffsetEffect.h(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_RelativeOffsetEffect();
            $ret.c = d;
            $ret.e = e;
            return $ret;
        })());
        c.setProperty(1343, g);
    }
    static js(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_EffectContainer.$, CT_EffectList.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_SoftEdgesEffect.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_SoftEdgesEffect();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(1551, g);
    }
    static lf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = CT_TransformEffect.u(a, d, e, f, g, h, i);
        d = j.p1;
        e = j.p2;
        f = j.p3;
        g = j.p4;
        h = j.p5;
        i = j.p6;
        let k = ((() => {
            let $ret = new CT_TransformEffect();
            $ret.h = f;
            $ret.j = g;
            $ret.l = d;
            $ret.n = e;
            $ret.p = h;
            $ret.r = i;
            return $ret;
        })());
        c.setProperty(1892, k);
        ChartDeserializer.ll(b, k);
    }
    static gt(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_NoFillProperties();
        d.setProperty(1063, e);
    }
    static jt(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_SolidColorFillProperties();
        d.setProperty(1553, e);
        ChartDeserializer.ll(b, e);
    }
    static ee(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = CT_GradientFillProperties.l(a, e, f);
        e = g.p1;
        f = g.p2;
        let h = ((() => {
            let $ret = new CT_GradientFillProperties();
            $ret.g = e;
            $ret.i = f;
            return $ret;
        })());
        d.setProperty(725, h);
        ChartDeserializer.ll(b, h);
    }
    static a5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_BlipFillProperties_DML.e(b);
        d.setProperty(128, e);
        ChartDeserializer.ll(b, e);
    }
    static hg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_PatternFillProperties.h(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_PatternFillProperties();
            $ret.e = e;
            return $ret;
        })());
        d.setProperty(1174, g);
        ChartDeserializer.ll(b, g);
    }
    static el(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_GroupFillProperties();
        d.setProperty(752, e);
        ChartDeserializer.ll(b, e);
    }
    static en(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_GradientStopList();
            $ret.c = new List$1(CT_GradientStop.$, 0);
            return $ret;
        })());
        c.e = CT_GradientStopList.e(d);
        ChartDeserializer.ll(b, d);
    }
    static fn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Boolean_$type, null);
        let f = CT_LinearShadeProperties.f(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_LinearShadeProperties();
            $ret.a = d;
            $ret.c = e;
            return $ret;
        })());
        c.setProperty(903, g);
    }
    static he(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PathShadeProperties.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PathShadeProperties();
            $ret.c = d;
            return $ret;
        })());
        c.setProperty(1172, f);
        ChartDeserializer.ll(b, f);
    }
    static kp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static em(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new ST_PositiveFixedPercentage();
        let e = CT_GradientStop.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_GradientStop();
            $ret.d = d;
            return $ret;
        })());
        c.e.add(f);
        ChartDeserializer.ll(b, f);
    }
    static dx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PathShadeProperties.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.a = d;
    }
    static j3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.a = d;
    }
    static ko(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TileInfoProperties();
        c.setProperty(1727, d);
    }
    static j7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_StretchInfoProperties();
        c.setProperty(1608, d);
        ChartDeserializer.ll(b, d);
    }
    static dw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_StretchInfoProperties.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.a = d;
    }
    static dt(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PatternFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static a1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PatternFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static b2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ColorChangeEffect.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static b5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ColorChangeEffect.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static kh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextTabStopList.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(ST_TextTabAlignType_$type, null);
        let f = CT_TextTabStop.f(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextTabStop();
            $ret.a = e;
            $ret.c = d;
            return $ret;
        })());
        c.e.add(g);
    }
    static fq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_LineProperties_DML.i(b);
        d.setProperty(918, e);
        ChartDeserializer.ll(b, e);
    }
    static db(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_EffectList();
        d.setProperty(560, e);
        ChartDeserializer.ll(b, e);
    }
    static da(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_EffectContainer.a(a);
        d.setProperty(558, e);
        ChartDeserializer.ll(b, e);
    }
    static er(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.w = d;
        ChartDeserializer.ll(b, d);
    }
    static k0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineLineFollowText();
        c.setProperty(1793, d);
        ChartDeserializer.ll(b, d);
    }
    static kz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_LineProperties_DML.i(b);
        c.setProperty(1792, d);
        ChartDeserializer.ll(b, d);
    }
    static ky(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineFillFollowText();
        c.af.a = d;
        b.s.k(d);
    }
    static kx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineFillGroupWrapper();
        c.setProperty(1790, d);
        ChartDeserializer.ll(b, d);
    }
    static fa(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.fq);
        c.c = d;
    }
    static c8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.de);
        c.b = d;
    }
    static cd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.ct);
        c.a = d;
    }
    static kd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.i7);
        c.c = d;
    }
    static et(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.h(b, DrawingMLMain.e2);
        c.ai = d;
        ChartDeserializer.ll(b, d);
    }
    static eu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.h(b, DrawingMLMain.e3);
        c.aj = d;
        ChartDeserializer.ll(b, d);
    }
    static hz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.t(b);
        c.setProperty(1273, d);
    }
    static cf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DashStopList();
        c.setProperty(368, d);
        ChartDeserializer.ll(b, d);
    }
    static im(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineJoinRound();
        ChartDeserializer.ll(b, d);
    }
    static ay(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineJoinBevel();
        c.setProperty(108, d);
    }
    static gm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.j(b);
        c.setProperty(1019, d);
    }
    static ep(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.i(b);
        c.a = d;
    }
    static kj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.i(b);
        c.b = d;
    }
    static c5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DashStopList.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.d(b);
        c.b.add(d);
    }
    static jr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Hyperlink.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.e(b);
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static hv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_TextParagraph_DML.$, CT_TextField.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_TextParagraphProperties_DML.o(a);
        d.setProperty(1154, e);
        ChartDeserializer.ll(b, e);
    }
    static h7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_RegularTextRun_DML();
        c.setProperty(1297, d);
        ChartDeserializer.ll(b, d);
    }
    static bb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextLineBreak();
        c.setProperty(164, d);
        ChartDeserializer.ll(b, d);
    }
    static d2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d, e;
        let f = CT_TextField.l(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextField();
            $ret.e = d;
            $ret.j = e;
            return $ret;
        })());
        c.setProperty(651, g);
        ChartDeserializer.ll(b, g);
    }
    static dc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TextCharacterProperties_DML.z(b, DrawingMLMain.dm);
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static ip(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_RegularTextRun_DML.$, CT_TextLineBreak.$, CT_TextField.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_TextCharacterProperties_DML.z(b, DrawingMLMain.h7);
        d.setProperty(1305, e);
        ChartDeserializer.ll(b, e);
    }
    static kg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_RegularTextRun_DML.$, CT_TextField.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = b.ab.ad;
        d.setProperty(1655, e);
    }
    static gd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Layout.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ManualLayout();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static fd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LayoutTarget.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LayoutTarget();
            $ret.b = d;
            return $ret;
        })());
        c.q = f;
    }
    static lg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LayoutMode.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LayoutMode();
            $ret.b = d;
            return $ret;
        })());
        c.m = f;
    }
    static lj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LayoutMode.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LayoutMode();
            $ret.b = d;
            return $ret;
        })());
        c.o = f;
    }
    static ld(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LayoutMode.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LayoutMode();
            $ret.b = d;
            return $ret;
        })());
        c.k = f;
    }
    static ev(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LayoutMode.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LayoutMode();
            $ret.b = d;
            return $ret;
        })());
        c.i = f;
    }
    static le(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.e = d;
    }
    static li(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.g = d;
    }
    static lb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.c = d;
    }
    static eo(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ManualLayout.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.a = d;
    }
    static ho(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PivotFmts.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PivotFmt();
        c.e.add(d);
        ChartDeserializer.ll(b, d);
    }
    static e3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_PivotFmt.$, CT_DLbl.$, CT_AreaSer.$, CT_DPt.$, CT_LineSer.$, CT_RadarSer.$, CT_ScatterSer.$, CT_PieSer.$, CT_BarSer.$, CT_SurfaceSer.$, CT_BandFmt.$, CT_BubbleSer.$, CT_LegendEntry.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_UnsignedInt.c(b);
        d.setProperty(817, e);
    }
    static ge(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_PivotFmt.$, CT_DPt.$, CT_LineSer.$, CT_LineChart.$, CT_RadarSer.$, CT_ScatterSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = typeCast(CT_LineChart.$, d);
        if (e != null) {
            let f = false;
            if (((() => { let g = CT_Marker_Chart.g(b, f); f = g.p1; return g.ret; })())) {
                e.o = Nullable$1.toNullable(Boolean_$type, f);
                return;
            }
        }
        let g = new CT_Marker_Chart();
        d.setProperty(979, g);
        ChartDeserializer.ll(b, g);
    }
    static cy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_PivotFmt.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_DLbl();
        d.setProperty(401, e);
        ChartDeserializer.ll(b, e);
    }
    static ke(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Marker_Chart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_MarkerStyle.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_MarkerStyle();
            $ret.a = d;
            return $ret;
        })());
        c.c = f;
    }
    static jo(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Marker_Chart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_MarkerSize.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_MarkerSize();
            $ret.b = d;
            return $ret;
        })());
        c.a = f;
    }
    static cr(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$, CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$, CT_LegendEntry.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(467, e);
    }
    static gy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_TrendlineLbl.$, CT_DLbls.$, CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = null;
        let f = false;
        let g = CT_NumFmt_Chart.f(a, e, f);
        e = g.p1;
        f = g.p2;
        let h = ((() => {
            let $ret = new CT_NumFmt_Chart();
            $ret.c = e;
            $ret.a = f;
            return $ret;
        })());
        d.setProperty(1088, h);
    }
    static cz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_DLblPos.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_DLblPos();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(404, g);
    }
    static jg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1492, e);
    }
    static jl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1498, e);
    }
    static i9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1485, e);
    }
    static jk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1497, e);
    }
    static jj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1495, e);
    }
    static i8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1484, e);
    }
    static i2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DLbl.$, CT_DLbls.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = b.ab.ad;
        d.setProperty(1445, e);
    }
    static ik(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_RotX.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_RotX();
            $ret.b = d;
            return $ret;
        })());
        c.i = f;
    }
    static ex(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_HPercent.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_HPercent();
            $ret.c = d;
            return $ret;
        })());
        c.e = f;
    }
    static il(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_RotY.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_RotY();
            $ret.c = d;
            return $ret;
        })());
        c.k = f;
    }
    static cs(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_DepthPercent.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_DepthPercent();
            $ret.c = d;
            return $ret;
        })());
        c.c = f;
    }
    static ia(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static hi(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_View3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Perspective.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Perspective();
            $ret.b = d;
            return $ret;
        })());
        c.g = f;
    }
    static kk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Surface.$, b);
        if (c == null) {
            return;
        }
        let d = CT_UnsignedInt.c(b);
        c.a = d;
    }
    static hk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Surface.$, CT_AreaSer.$, CT_DPt.$, CT_BarSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_PictureOptions();
        d.setProperty(1199, e);
        ChartDeserializer.ll(b, e);
    }
    static ae(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PictureOptions.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static af(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PictureOptions.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.e = d;
    }
    static ad(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PictureOptions.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static hj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PictureOptions.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PictureFormat.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PictureFormat();
            $ret.a = d;
            return $ret;
        })());
        c.g = f;
    }
    static hl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PictureOptions.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PictureStackUnit.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PictureStackUnit();
            $ret.a = d;
            return $ret;
        })());
        c.i = f;
    }
    static ai(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_AreaChart();
            $ret.c = new List$1(CT_UnsignedInt.$, 0);
            $ret.e = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        if (c.c == null) {
            c.c = d;
        }
        else {
            c.d = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static ah(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Area3DChart();
            $ret.e = new List$1(CT_UnsignedInt.$, 0);
            $ret.g = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.b = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static fp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_LineChart();
            $ret.k = new List$1(CT_UnsignedInt.$, 0);
            $ret.m = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        if (c.n == null) {
            c.n = d;
        }
        else {
            c.o = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static fo(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Line3DChart();
            $ret.e = new List$1(CT_UnsignedInt.$, 0);
            $ret.g = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.m = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static j5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_StockChart();
            $ret.i = new List$1(CT_UnsignedInt.$, 0);
            $ret.m = new List$1(CT_LineSer.$, 0);
            $ret.k = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.ac = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static h8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_RadarChart();
            $ret.k = new List$1(CT_RadarSer.$, 0);
            $ret.g = new List$1(CT_UnsignedInt.$, 0);
            $ret.i = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        if (c.u == null) {
            c.u = d;
        }
        else if (c.v == null) {
            c.v = d;
        }
        else if (c.w == null) {
            c.w = d;
        }
        else if (c.x == null) {
            c.x = d;
        }
        else {
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static iu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_ScatterChart();
            $ret.g = new List$1(CT_UnsignedInt.$, 0);
            $ret.i = new List$1(CT_Extension.$, 0);
            $ret.k = new List$1(CT_ScatterSer.$, 0);
            return $ret;
        })());
        if (c.y == null) {
            c.y = d;
        }
        else if (c.z == null) {
            c.z = d;
        }
        else if (c.aa == null) {
            c.aa = d;
        }
        else if (c.ab == null) {
            c.ab = d;
        }
        else {
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static hn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_PieChart();
            $ret.e = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        if (c.s == null) {
            c.s = d;
        }
        else if (c.t == null) {
            c.t = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static hm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Pie3DChart();
        c.r = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static c1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DoughnutChart();
        if (c.i == null) {
            c.i = d;
        }
        else if (c.j == null) {
            c.j = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static av(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_BarChart();
            $ret.g = new List$1(CT_UnsignedInt.$, 0);
            $ret.k = new List$1(CT_ChartLines.$, 0);
            $ret.i = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        if (c.f == null) {
            c.f = d;
        }
        else {
            c.g = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static au(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Bar3DChart();
            $ret.i = new List$1(CT_UnsignedInt.$, 0);
            $ret.k = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.e = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static g4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_OfPieChart();
            $ret.m = new List$1(CT_UnsignedInt.$, 0);
            $ret.o = new List$1(CT_Extension.$, 0);
            $ret.q = new List$1(CT_ChartLines.$, 0);
            return $ret;
        })());
        if (c.p == null) {
            c.p = d;
        }
        else if (c.q == null) {
            c.q = d;
        }
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static kc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_SurfaceChart();
            $ret.c = new List$1(CT_UnsignedInt.$, 0);
            $ret.e = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.ae = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static kb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Surface3DChart();
            $ret.c = new List$1(CT_UnsignedInt.$, 0);
            $ret.e = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.ad = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static be(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_BubbleChart();
            $ret.o = new List$1(CT_Extension.$, 0);
            $ret.q = new List$1(CT_BubbleSer.$, 0);
            $ret.m = new List$1(CT_UnsignedInt.$, 0);
            return $ret;
        })());
        c.h = d;
        c.aj.add(d);
        ChartDeserializer.ll(b, d);
    }
    static k8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ValAx();
        c.ah.add(d);
        ChartDeserializer.ll(b, d);
    }
    static bu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_CatAx();
        c.ah.add(d);
        ChartDeserializer.ll(b, d);
    }
    static co(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DateAx();
        c.ah.add(d);
        ChartDeserializer.ll(b, d);
    }
    static i4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SerAx();
        c.ah.add(d);
        ChartDeserializer.ll(b, d);
    }
    static c6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PlotArea.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DTable();
        c.k = d;
        ChartDeserializer.ll(b, d);
    }
    static ek(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_BarChart.$, CT_Bar3DChart.$];
        let d = SerializationUtils.j(b, c, false);
        if (d != null) {
            let e;
            let f = CT_BarGrouping.e(b, e);
            e = f.p1;
            let g = ((() => {
                let $ret = new CT_BarGrouping();
                $ret.b = e;
                return $ret;
            })());
            d.setProperty(749, g);
            return;
        }
        c = [CT_AreaChart.$, CT_Area3DChart.$, CT_LineChart.$, CT_Line3DChart.$];
        d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let h;
        let i = CT_Grouping.e(b, h);
        h = i.p1;
        let j = ((() => {
            let $ret = new CT_Grouping();
            $ret.b = h;
            return $ret;
        })());
        d.setProperty(749, j);
    }
    static k9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaChart.$, CT_Area3DChart.$, CT_LineChart.$, CT_Line3DChart.$, CT_RadarChart.$, CT_ScatterChart.$, CT_PieChart.$, CT_Pie3DChart.$, CT_DoughnutChart.$, CT_BarChart.$, CT_Bar3DChart.$, CT_OfPieChart.$, CT_BubbleChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1833, e);
    }
    static i3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        if (ChartDeserializer.c(b)) {
            return;
        }
        else if (ChartDeserializer.d(b)) {
            return;
        }
        else if (ChartDeserializer.e(b)) {
            return;
        }
        else if (ChartDeserializer.f(b)) {
            return;
        }
        else if (ChartDeserializer.h(b)) {
            return;
        }
        else if (ChartDeserializer.i(b)) {
            return;
        }
        else if (ChartDeserializer.j(b)) {
            return;
        }
        else if (ChartDeserializer.m(b)) {
            return;
        }
        else {
        }
    }
    static c(a) {
        let b = [CT_AreaChart.$, CT_Area3DChart.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = ((() => {
            let $ret = new CT_AreaSer();
            $ret.l = new List$1(CT_DPt.$, 0);
            $ret.r = new List$1(CT_Trendline.$, 0);
            $ret.n = new List$1(CT_ErrBars.$, 0);
            $ret.p = new List$1(CT_Extension.$, 0);
            $ret.k = typeCast(IChart_$type, c);
            return $ret;
        })());
        c.setProperty(1446, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static d(a) {
        let b = [CT_BarChart.$, CT_Bar3DChart.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = ((() => {
            let $ret = new CT_BarSer();
            $ret.r = new List$1(CT_DPt.$, 0);
            $ret.t = new List$1(CT_Extension.$, 0);
            $ret.v = new List$1(CT_Trendline.$, 0);
            $ret.q = typeCast(IChart_$type, c);
            return $ret;
        })());
        c.setProperty(1446, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static e(a) {
        let b = ChartDeserializer.a(CT_BubbleChart.$, a, false);
        if (b == null) {
            return false;
        }
        let c = ((() => {
            let $ret = new CT_BubbleSer();
            $ret.p = new List$1(CT_DPt.$, 0);
            $ret.t = new List$1(CT_Extension.$, 0);
            $ret.v = new List$1(CT_Trendline.$, 0);
            $ret.r = new List$1(CT_ErrBars.$, 0);
            $ret.o = b;
            return $ret;
        })());
        b.q.add(c);
        ChartDeserializer.ll(a, c);
        return true;
    }
    static f(a) {
        let b = [CT_LineChart.$, CT_Line3DChart.$, CT_StockChart.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = ((() => {
            let $ret = new CT_LineSer();
            $ret.p = new List$1(CT_DPt.$, 0);
            $ret.r = new List$1(CT_Extension.$, 0);
            $ret.t = new List$1(CT_Trendline.$, 0);
            $ret.o = typeCast(IChart_$type, c);
            return $ret;
        })());
        c.setProperty(1446, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static h(a) {
        let b = [CT_PieChart.$, CT_Pie3DChart.$, CT_DoughnutChart.$, CT_OfPieChart.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = ((() => {
            let $ret = new CT_PieSer();
            $ret.l = new List$1(CT_DPt.$, 0);
            $ret.n = new List$1(CT_Extension.$, 0);
            $ret.k = typeCast(IChart_$type, c);
            return $ret;
        })());
        c.setProperty(1446, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static i(a) {
        let b = ChartDeserializer.a(CT_RadarChart.$, a, false);
        if (b == null) {
            return false;
        }
        let c = ((() => {
            let $ret = new CT_RadarSer();
            $ret.l = new List$1(CT_DPt.$, 0);
            $ret.n = new List$1(CT_Extension.$, 0);
            $ret.k = b;
            return $ret;
        })());
        b.k.add(c);
        ChartDeserializer.ll(a, c);
        return true;
    }
    static j(a) {
        let b = ChartDeserializer.a(CT_ScatterChart.$, a, false);
        if (b == null) {
            return false;
        }
        let c = ((() => {
            let $ret = new CT_ScatterSer();
            $ret.n = new List$1(CT_DPt.$, 0);
            $ret.r = new List$1(CT_Extension.$, 0);
            $ret.p = new List$1(CT_ErrBars.$, 0);
            $ret.t = new List$1(CT_Trendline.$, 0);
            $ret.m = b;
            return $ret;
        })());
        b.k.add(c);
        ChartDeserializer.ll(a, c);
        return true;
    }
    static m(a) {
        let b = [CT_SurfaceChart.$, CT_Surface3DChart.$];
        let c = SerializationUtils.j(a, b, false);
        if (c == null) {
            return false;
        }
        let d = ((() => {
            let $ret = new CT_SurfaceSer();
            $ret.h = new List$1(CT_Extension.$, 0);
            $ret.g = typeCast(IChart_$type, c);
            return $ret;
        })());
        c.setProperty(1446, d);
        ChartDeserializer.ll(a, d);
        return true;
    }
    static c0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaChart.$, CT_AreaSer.$, CT_Area3DChart.$, CT_LineChart.$, CT_LineSer.$, CT_Line3DChart.$, CT_StockChart.$, CT_RadarChart.$, CT_RadarSer.$, CT_ScatterChart.$, CT_ScatterSer.$, CT_PieChart.$, CT_PieSer.$, CT_Pie3DChart.$, CT_DoughnutChart.$, CT_BarChart.$, CT_BarSer.$, CT_Bar3DChart.$, CT_OfPieChart.$, CT_BubbleChart.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_DLbls();
        d.setProperty(406, e);
        ChartDeserializer.ll(b, e);
    }
    static c4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaChart.$, CT_Area3DChart.$, CT_LineChart.$, CT_Line3DChart.$, CT_StockChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_ChartLines();
        d.setProperty(543, e);
        ChartDeserializer.ll(b, e);
    }
    static an(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaChart.$, CT_Area3DChart.$, CT_LineChart.$, CT_Line3DChart.$, CT_StockChart.$, CT_RadarChart.$, CT_ScatterChart.$, CT_BarChart.$, CT_Bar3DChart.$, CT_SurfaceChart.$, CT_Surface3DChart.$, CT_BubbleChart.$, CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_UnsignedInt.c(b, true);
        d.setProperty(81, e);
    }
    static g6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Trendline.$, CT_AreaSer.$, CT_LineSer.$, CT_RadarSer.$, CT_ScatterSer.$, CT_PieSer.$, CT_BarSer.$, CT_SurfaceSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = typeCast(CT_Trendline.$, d);
        if (e != null) {
            let f = 0;
            let g = CT_Order.e(b, f);
            f = g.p1;
            let h = ((() => {
                let $ret = new CT_Order();
                $ret.b = f;
                return $ret;
            })());
            e.k = h;
            ChartDeserializer.ll(b, h);
            return;
        }
        let i = CT_UnsignedInt.c(b);
        d.setProperty(1135, i);
    }
    static c3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaSer.$, CT_LineSer.$, CT_RadarSer.$, CT_ScatterSer.$, CT_PieSer.$, CT_BarSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_DPt();
        d.setProperty(408, e);
        ChartDeserializer.ll(b, e);
    }
    static ks(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaSer.$, CT_LineSer.$, CT_ScatterSer.$, CT_BarSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_Trendline();
        d.setProperty(1767, e);
        ChartDeserializer.ll(b, e);
    }
    static dd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaSer.$, CT_LineSer.$, CT_ScatterSer.$, CT_BarSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_ErrBars();
        d.setProperty(590, e);
        ChartDeserializer.ll(b, e);
    }
    static bt(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_AreaSer.$, CT_LineSer.$, CT_RadarSer.$, CT_PieSer.$, CT_BarSer.$, CT_SurfaceSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_AxDataSource();
        d.setProperty(229, e);
        ChartDeserializer.ll(b, e);
    }
    static k7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b, false);
        if (c != null) {
            c.c = CT_Double.c(b);
            return;
        }
        let d = [CT_AreaSer.$, CT_LineSer.$, CT_RadarSer.$, CT_PieSer.$, CT_BarSer.$, CT_SurfaceSer.$];
        let e = SerializationUtils.j(b, d);
        if (e == null) {
            return;
        }
        let f = new CT_NumDataSource();
        e.setProperty(1821, f);
        ChartDeserializer.ll(b, f);
    }
    static e7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DPt.$, CT_BarSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(848, e);
    }
    static bd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DPt.$, CT_BubbleChart.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(183, e);
    }
    static dj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_DPt.$, CT_PieSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_UnsignedInt.c(b);
        d.setProperty(598, e);
    }
    static ku(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TrendlineType.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TrendlineType();
            $ret.b = d;
            return $ret;
        })());
        c.q = f;
    }
    static hh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Period.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Period();
            $ret.b = d;
            return $ret;
        })());
        c.m = f;
    }
    static d7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.g = d;
    }
    static ar(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.e = d;
    }
    static e5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.i = d;
    }
    static cv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static cu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static kt(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Trendline.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TrendlineLbl();
        c.o = d;
        ChartDeserializer.ll(b, d);
    }
    static df(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ErrDir.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ErrDir();
            $ret.a = d;
            return $ret;
        })());
        c.g = f;
    }
    static de(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ErrBarType.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ErrBarType();
            $ret.b = d;
            return $ret;
        })());
        c.e = f;
    }
    static dg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ErrValType.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ErrValType();
            $ret.b = d;
            return $ret;
        })());
        c.i = f;
    }
    static gs(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static ht(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_NumDataSource();
        c.m = d;
        ChartDeserializer.ll(b, d);
    }
    static gl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ErrBars.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_NumDataSource();
        c.k = d;
        ChartDeserializer.ll(b, d);
    }
    static g0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_NumDataSource.$, CT_AxDataSource.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_NumRef();
        d.setProperty(1095, e);
        ChartDeserializer.ll(b, e);
    }
    static gz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_NumDataSource.$, CT_AxDataSource.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = ((() => {
            let $ret = new CT_NumData();
            $ret.c = new List$1(CT_Extension.$, 0);
            $ret.e = new List$1(CT_NumVal.$, 0);
            return $ret;
        })());
        d.setProperty(1092, e);
        ChartDeserializer.ll(b, e);
    }
    static gx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_NumRef.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_NumData();
            $ret.c = new List$1(CT_Extension.$, 0);
            $ret.e = new List$1(CT_NumVal.$, 0);
            return $ret;
        })());
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static d5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_NumData.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.g = d;
    }
    static gp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_AxDataSource.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_MultiLvlStrRef();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static j8(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_AxDataSource.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_StrData();
            $ret.f = new List$1(CT_StrVal.$, 0);
            return $ret;
        })());
        c.d = d;
        ChartDeserializer.ll(b, d);
    }
    static go(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_MultiLvlStrRef.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_MultiLvlStrData();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static fy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_MultiLvlStrData.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_Lvl();
            $ret.a = new List$1(CT_StrVal.$, 0);
            return $ret;
        })());
        c.d.add(d);
        ChartDeserializer.ll(b, d);
    }
    static je(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DLbls.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.setProperty(1491, d);
        ChartDeserializer.ll(b, d);
    }
    static fg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DLbls.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ChartLines();
        c.setProperty(886, d);
        ChartDeserializer.ll(b, d);
    }
    static d9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Area3DChart.$, CT_Line3DChart.$, CT_Bar3DChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_GapAmount.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_GapAmount();
            $ret.c = e;
            return $ret;
        })());
        d.setProperty(696, g);
    }
    static es(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_LineChart.$, CT_StockChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_ChartLines();
        d.setProperty(780, e);
        ChartDeserializer.ll(b, e);
    }
    static k3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_LineChart.$, CT_StockChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_UpDownBars();
        d.setProperty(1809, e);
        ChartDeserializer.ll(b, e);
    }
    static jq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_LineChart.$, CT_LineSer.$, CT_ScatterSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1547, e);
    }
    static ea(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_UpDownBars.$, CT_BarChart.$, CT_Bar3DChart.$, CT_OfPieChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_GapAmount.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_GapAmount();
            $ret.c = e;
            return $ret;
        })());
        d.setProperty(697, g);
    }
    static k2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_UpDownBars.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_UpDownBar();
        c.e = d;
        ChartDeserializer.ll(b, d);
    }
    static c2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_UpDownBars.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_UpDownBar();
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static h9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_RadarChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_RadarStyle.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_RadarStyle();
            $ret.b = d;
            return $ret;
        })());
        c.e = f;
    }
    static iv(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ScatterChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ScatterStyle.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ScatterStyle();
            $ret.b = d;
            return $ret;
        })());
        c.e = f;
    }
    static lh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScatterSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_AxDataSource();
        d.setProperty(1890, e);
        ChartDeserializer.ll(b, e);
    }
    static lk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ScatterSer.$, CT_BubbleSer.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_NumDataSource();
        d.setProperty(1898, e);
        ChartDeserializer.ll(b, e);
    }
    static d0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_PieChart.$, CT_DoughnutChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_FirstSliceAng.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_FirstSliceAng();
            $ret.c = e;
            return $ret;
        })());
        d.setProperty(647, g);
    }
    static ew(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DoughnutChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_HoleSize.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_HoleSize();
            $ret.b = d;
            return $ret;
        })());
        c.c = f;
    }
    static aw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_BarChart.$, CT_Bar3DChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_BarDir.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_BarDir();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(101, g);
    }
    static g9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BarChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Overlap.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Overlap();
            $ret.b = d;
            return $ret;
        })());
        c.c = f;
    }
    static i5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_BarChart.$, CT_OfPieChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_ChartLines();
        d.setProperty(1448, e);
        ChartDeserializer.ll(b, e);
    }
    static i7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_BarSer.$, CT_Bar3DChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_Shape_Chart.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_Shape_Chart();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(1461, g);
    }
    static g5(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_OfPieChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_OfPieType.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_OfPieType();
            $ret.b = d;
            return $ret;
        })());
        c.e = f;
    }
    static j1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_OfPieChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_SplitType.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_SplitType();
            $ret.b = d;
            return $ret;
        })());
        c.i = f;
    }
    static j0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_OfPieChart.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.a = d;
    }
    static ch(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_OfPieChart.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_CustSplit();
        c.m = d.a;
        ChartDeserializer.ll(b, d);
    }
    static i0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_OfPieChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_SecondPieSize.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_SecondPieSize();
            $ret.c = d;
            return $ret;
        })());
        c.g = f;
    }
    static iz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustSplit.$, b);
        if (c == null) {
            return;
        }
        let d = CT_UnsignedInt.c(b);
        if (c.a == null) {
            c.a = new List$1(CT_UnsignedInt.$, 0);
        }
        c.a.add(d);
    }
    static lc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_SurfaceChart.$, CT_Surface3DChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(1869, e);
    }
    static at(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_SurfaceChart.$, CT_Surface3DChart.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = ((() => {
            let $ret = new CT_BandFmts();
            $ret.a = new List$1(CT_BandFmt.$, 0);
            return $ret;
        })());
        d.setProperty(97, e);
        ChartDeserializer.ll(b, e);
    }
    static as(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BandFmts.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_BandFmt();
        c.a.add(d);
        ChartDeserializer.ll(b, d);
    }
    static bf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BubbleChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_BubbleScale.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BubbleScale();
            $ret.c = d;
            return $ret;
        })());
        c.g = f;
    }
    static jh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BubbleChart.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static jp(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BubbleChart.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_SizeRepresents.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_SizeRepresents();
            $ret.b = d;
            return $ret;
        })());
        c.k = f;
    }
    static bg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_BubbleSer.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_NumDataSource();
        c.i = d;
        ChartDeserializer.ll(b, d);
    }
    static it(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = new CT_Scaling();
        d.setProperty(1418, e);
        ChartDeserializer.ll(b, e);
    }
    static ao(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_AxPos.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_AxPos();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(82, g);
    }
    static f9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e = new CT_ChartLines();
        d.setProperty(963, e);
        ChartDeserializer.ll(b, e);
    }
    static gh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e = new CT_ChartLines();
        d.setProperty(1011, e);
        ChartDeserializer.ll(b, e);
    }
    static ga(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_TickMark.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_TickMark();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(964, g);
    }
    static gi(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_TickMark.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_TickMark();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(1012, g);
    }
    static kl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_TickLblPos.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_TickLblPos();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(1724, g);
    }
    static b9(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e = CT_UnsignedInt.c(b, true);
        d.setProperty(359, e);
    }
    static cb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_Crosses.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_Crosses();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(361, g);
        ChartDeserializer.ll(b, g);
    }
    static cc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e = CT_Double.c(b);
        d.setProperty(362, e);
    }
    static ca(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_CatAx.$, CT_DateAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        let e;
        let f = CT_CrossBetween.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_CrossBetween();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(360, g);
    }
    static gc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_DateAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_AxisUnit.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_AxisUnit();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(967, g);
    }
    static gk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_ValAx.$, CT_DateAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_AxisUnit.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_AxisUnit();
            $ret.a = e;
            return $ret;
        })());
        d.setProperty(1015, g);
    }
    static cw(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ValAx.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_DispUnits();
            $ret.e = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        c.dispUnits = d;
        ChartDeserializer.ll(b, d);
    }
    static ft(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scaling.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LogBase.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LogBase();
            $ret.a = d;
            return $ret;
        })());
        c.e = f;
    }
    static g7(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scaling.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Orientation.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Orientation();
            $ret.a = d;
            return $ret;
        })());
        c.g = f;
    }
    static gf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scaling.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.a = d;
    }
    static gg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Scaling.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.c = d;
    }
    static ci(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DispUnits.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Double.c(b);
        c.a = d;
    }
    static bn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DispUnits.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_BuiltInUnit.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BuiltInUnit();
            $ret.b = d;
            return $ret;
        })());
        c.b = f;
    }
    static cx(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DispUnits.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DispUnitsLbl();
        c.c = d;
        ChartDeserializer.ll(b, d);
    }
    static aj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_CatAx.$, CT_DateAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = CT_Boolean.d(b, 3);
        d.setProperty(69, e);
    }
    static fe(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CatAx.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LblAlgn.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LblAlgn();
            $ret.a = d;
            return $ret;
        })());
        c.e = f;
    }
    static ff(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_CatAx.$, CT_DateAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_LblOffset.e(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_LblOffset();
            $ret.c = e;
            return $ret;
        })());
        d.setProperty(884, g);
    }
    static km(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_CatAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_Skip.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_Skip();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(1725, g);
    }
    static kn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_CatAx.$, CT_SerAx.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e;
        let f = CT_Skip.d(b, e);
        e = f.p1;
        let g = ((() => {
            let $ret = new CT_Skip();
            $ret.b = e;
            return $ret;
        })());
        d.setProperty(1726, g);
    }
    static gu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CatAx.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static ax(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DateAx.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TimeUnit.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TimeUnit();
            $ret.b = d;
            return $ret;
        })());
        c.i = f;
    }
    static gb(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DateAx.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TimeUnit.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TimeUnit();
            $ret.b = d;
            return $ret;
        })());
        c.k = f;
    }
    static gj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DateAx.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TimeUnit.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TimeUnit();
            $ret.b = d;
            return $ret;
        })());
        c.m = f;
    }
    static jc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DTable.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static jm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DTable.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.g = d;
    }
    static ji(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DTable.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.e = d;
    }
    static jd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_DTable.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.c = d;
    }
    static fl(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Legend.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_LegendPos.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_LegendPos();
            $ret.b = d;
            return $ret;
        })());
        c.e = f;
    }
    static fk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Legend.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LegendEntry();
        c.m.add(d);
        ChartDeserializer.ll(b, d);
    }
    static cg(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ShapeProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_CustomGeometry2D();
        c.setProperty(371, d);
        ChartDeserializer.ll(b, d);
    }
    static h0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ShapeProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PresetGeometry2D();
        c.setProperty(1274, d);
        ChartDeserializer.ll(b, d);
    }
    static g3(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Transform2D.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.m(b);
        c.a = d;
    }
    static ec(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeomGuideList();
        c.d = d;
        ChartDeserializer.ll(b, d);
    }
    static p(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_AdjustHandleList();
        c.a = d;
        ChartDeserializer.ll(b, d);
    }
    static ck(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ConnectionSiteList();
        c.b = d;
        ChartDeserializer.ll(b, d);
    }
    static ib(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.g(b);
        c.e = d;
    }
    static hf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DList();
        c.f = d;
        ChartDeserializer.ll(b, d);
    }
    static r(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_AdjustHandleList.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.y(b);
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static q(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_AdjustHandleList.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.n(b);
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static hu(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_XYAdjustHandle.$, CT_PolarAdjustHandle.$, CT_ConnectionSite.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = DMLUtils.a(b);
        d.setProperty(1241, e);
    }
    static cj(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ConnectionSiteList.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.c(b);
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static b0(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DClose();
        c.b.add(d);
    }
    static gn(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DMoveTo();
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static fs(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DLineTo();
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static ag(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.k(b);
        c.b.add(d);
    }
    static h6(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DQuadBezierTo();
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static ce(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DCubicBezierTo();
        c.b.add(d);
        ChartDeserializer.ll(b, d);
    }
    static h4(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = [CT_Path2DMoveTo.$, CT_Path2DLineTo.$, CT_Path2DQuadBezierTo.$, CT_Path2DCubicBezierTo.$];
        let d = SerializationUtils.j(b, c);
        if (d == null) {
            return;
        }
        let e = DMLUtils.a(b);
        d.setProperty(1277, e);
    }
    static al(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ExternalData.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.a = d;
    }
    static eq(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d = false;
        let e = false;
        let f = false;
        let g = CT_HeaderFooter_Chart.w(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_HeaderFooter_Chart();
            $ret.a = d;
            $ret.h = e;
            $ret.f = f;
            return $ret;
        })());
        c.a = h;
        ChartDeserializer.ll(b, h);
    }
    static hc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d = 0;
        let e = 0;
        let f = 0;
        let g = 0;
        let h = 0;
        let i = 0;
        let j = CT_PageMargins_Chart.o(a, d, e, f, g, h, i);
        d = j.p1;
        e = j.p2;
        f = j.p3;
        g = j.p4;
        h = j.p5;
        i = j.p6;
        let k = ((() => {
            let $ret = new CT_PageMargins_Chart();
            $ret.h = d;
            $ret.j = e;
            $ret.l = f;
            $ret.b = g;
            $ret.f = h;
            $ret.d = i;
            return $ret;
        })());
        c.c = k;
    }
    static hd(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = Nullable$1.toNullable(ST_PageSetupOrientation_$type, null);
        let g = Nullable$1.toNullable(Boolean_$type, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = Nullable$1.toNullable(Boolean_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Number_$type, null);
        let m = CT_PageSetup_Chart.ac(a, d, e, f, g, h, i, j, k, l);
        d = m.p1;
        e = m.p2;
        f = m.p3;
        g = m.p4;
        h = m.p5;
        i = m.p6;
        j = m.p7;
        k = m.p8;
        l = m.p9;
        let n = ((() => {
            let $ret = new CT_PageSetup_Chart();
            $ret.g = g;
            $ret.i = l;
            $ret.k = h;
            $ret.m = e;
            $ret.o = j;
            $ret.q = f;
            $ret.s = d;
            $ret.u = i;
            $ret.w = k;
            return $ret;
        })());
        c.e = n;
    }
    static fi(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d = DMLChartUtils.ak(b);
        c.g = d;
    }
    static g2(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.t = d;
    }
    static g1(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.r = d;
    }
    static di(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.l = d;
    }
    static dh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.j = d;
    }
    static dz(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.p = d;
    }
    static dy(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_HeaderFooter_Chart.$, b);
        if (c == null) {
            return;
        }
        let d = b.ab.ad;
        c.n = d;
    }
    static dk(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_ExtensionList.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Extension.c(b, d);
        d = e.p1;
        let f = CT_Extension_DataLabels.i(d);
        if (f != null) {
            c.e.add(f);
            ChartDeserializer.ll(b, f);
            return;
        }
        let g = CT_Extension_DataLabelsRange.g(d);
        if (g != null) {
            c.e.add(g);
            ChartDeserializer.ll(b, g);
            return;
        }
        let h = ((() => {
            let $ret = new CT_Extension();
            $ret.b = d;
            return $ret;
        })());
        c.e.add(h);
    }
    static jf(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Extension_DataLabels.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.g = d;
    }
    static ja(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Extension_DataLabels.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Boolean.d(b, 3);
        c.f = d;
    }
    static fh(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Extension_DataLabels.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ChartLines();
        c.h = d;
        ChartDeserializer.ll(b, d);
    }
    static fc(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Extension_DataLabels.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Layout();
        c.j = d;
        ChartDeserializer.ll(b, d);
    }
    static cm(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_Extension_DataLabelsRange.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SeriesDataLabelsRange();
        c.h = d;
        ChartDeserializer.ll(b, d);
    }
    static ds(a) {
        let b = typeCast(ObjectModelChartPartManager.$, a);
        let c = ChartDeserializer.a(CT_SeriesDataLabelsRange.$, b);
        if (c == null) {
            return;
        }
        c.c = b.ab.ad;
    }
    static a($t, a, b = false) {
        return SerializationUtils.i($t, a, b);
    }
    static ll(a, b) {
        a.s.k(b);
    }
    static f8(a, b) {
        let c = typeCast(ObjectModelChartPartManager.$, a);
        let d = ChartDeserializer.a(CT_TextListStyle_DML.$, c);
        if (d == null) {
            return;
        }
        let e = CT_TextParagraphProperties_DML.o(a);
        d.setProperty(b, e);
        ChartDeserializer.ll(c, e);
    }
}
ChartDeserializer.$t = markType(ChartDeserializer, 'ChartDeserializer');
/**
 * @hidden
 */
export class ChartExDeserializer extends Base {
    constructor(a) {
        super();
        this.d = null;
        this.h = null;
        this.d = a.a7._by;
    }
    static h1(a) {
        a.ay(ChartExElements.m, ChartExDeserializer.bb);
        a.ax(ChartExElements.m, ChartExDeserializer.bc);
        a.ay(ChartExElements.l, ChartExDeserializer.ba);
        a.ay(ChartExElements.k, ChartExDeserializer.a9);
        a.ay(ChartExElements.b5, ChartExDeserializer.g1);
        a.ay(ChartExElements.cd, ChartExDeserializer.hl);
        a.ay(ChartExElements.o, ChartExDeserializer.bh);
        a.ay(ChartExElements.ai, ChartExDeserializer.cv);
        a.ay(ChartExElements.bz, ChartExDeserializer.fy);
        a.ay(DrawingMLMain.dr, ChartExDeserializer.ch);
        a.ay(ChartExElements.ac, ChartExDeserializer.cg);
        a.ay(ChartExElements.ab, ChartExDeserializer.cf);
        a.ay(ChartExElements.r, ChartExDeserializer.bv);
        a.ay(ChartExElements.bo, ChartExDeserializer.ff);
        a.ay(ChartExElements.b7, ChartExDeserializer.g5);
        a.ay(ChartExElements.ae, ChartExDeserializer.ck);
        a.ay(ChartExElements.bm, ChartExDeserializer.e9);
        a.ay(ChartExElements.ba, ChartExDeserializer.en);
        a.ay(ChartExElements.b0, ChartExDeserializer.f4);
        a.ay(ChartExElements.ca, ChartExDeserializer.hi);
        a.ay(ChartExElements.bw, ChartExDeserializer.ft);
        a.ay(ChartExElements.a9, ChartExDeserializer.ed);
        a.ay(ChartExElements.cb, ChartExDeserializer.hj);
        a.ay(ChartExElements.cc, ChartExDeserializer.hk);
        a.ay(ChartExElements.b2, ChartExDeserializer.gf);
        a.ay(ChartExElements.cg, ChartExDeserializer.ht);
        a.ay(DrawingMLMain.bz, ChartExDeserializer.au);
        a.ay(DrawingMLMain.f1, ChartExDeserializer.ej);
        a.ay(DrawingMLMain.hd, ChartExDeserializer.fl);
        a.ay(DrawingMLMain.hr, ChartExDeserializer.f3);
        a.ay(DrawingMLMain.gr, ChartExDeserializer.fa);
        a.ay(DrawingMLMain.g5, ChartExDeserializer.fd);
        a.ay(DrawingMLMain.iq, ChartExDeserializer.gw);
        a.ay(DrawingMLMain.id, ChartExDeserializer.gm);
        a.ay(DrawingMLMain.ip, ChartExDeserializer.gv);
        a.ay(DrawingMLMain.d2, ChartExDeserializer.cs);
        a.ay(DrawingMLMain.bg, ChartExDeserializer.ab);
        a.ay(DrawingMLMain.eg, ChartExDeserializer.cx);
        a.ay(DrawingMLMain.cd, ChartExDeserializer.a7);
        a.ay(DrawingMLMain.ft, ChartExDeserializer.ee);
        a.ay(DrawingMLMain.bi, ChartExDeserializer.ae);
        a.ay(DrawingMLMain.h3, ChartExDeserializer.gg);
        a.ay(DrawingMLMain.bc, ChartExDeserializer.z);
        a.ay(DrawingMLMain.g3, ChartExDeserializer.fc);
        a.ay(DrawingMLMain.jy, ChartExDeserializer.hs);
        a.ay(DrawingMLMain.bm, ChartExDeserializer.ah);
        a.ay(DrawingMLMain.bl, ChartExDeserializer.ag);
        a.ay(DrawingMLMain.du, ChartExDeserializer.cj);
        a.ay(DrawingMLMain.cs, ChartExDeserializer.bm);
        a.ay(DrawingMLMain.ig, ChartExDeserializer.go);
        a.ay(DrawingMLMain.i0, ChartExDeserializer.g3);
        a.ay(DrawingMLMain.e7, ChartExDeserializer.d3);
        a.ay(DrawingMLMain.i8, ChartExDeserializer.g9);
        a.ay(DrawingMLMain.ie, ChartExDeserializer.gn);
        a.ay(DrawingMLMain.hn, ChartExDeserializer.fz);
        a.ay(DrawingMLMain.jm, ChartExDeserializer.hh);
        a.ay(DrawingMLMain.ii, ChartExDeserializer.gr);
        a.ay(DrawingMLMain.cp, ChartExDeserializer.bk);
        a.ay(DrawingMLMain.fg, ChartExDeserializer.d9);
        a.ay(DrawingMLMain.en, ChartExDeserializer.dp);
        a.ay(DrawingMLMain.a1, ChartExDeserializer.p);
        a.ay(DrawingMLMain.a8, ChartExDeserializer.w);
        a.ay(DrawingMLMain.a6, ChartExDeserializer.u);
        a.ay(DrawingMLMain.e8, ChartExDeserializer.d4);
        a.ay(DrawingMLMain.fa, ChartExDeserializer.d6);
        a.ay(DrawingMLMain.e9, ChartExDeserializer.d5);
        a.ay(DrawingMLMain.ia, ChartExDeserializer.gj);
        a.ay(DrawingMLMain.ic, ChartExDeserializer.gl);
        a.ay(DrawingMLMain.ib, ChartExDeserializer.gk);
        a.ay(DrawingMLMain.f4, ChartExDeserializer.ek);
        a.ay(DrawingMLMain.f6, ChartExDeserializer.em);
        a.ay(DrawingMLMain.f5, ChartExDeserializer.el);
        a.ay(DrawingMLMain.hx, ChartExDeserializer.f9);
        a.ay(DrawingMLMain.hz, ChartExDeserializer.gb);
        a.ay(DrawingMLMain.hy, ChartExDeserializer.ga);
        a.ay(DrawingMLMain.ep, ChartExDeserializer.dr);
        a.ay(DrawingMLMain.er, ChartExDeserializer.dt);
        a.ay(DrawingMLMain.eq, ChartExDeserializer.ds);
        a.ay(DrawingMLMain.bu, ChartExDeserializer.aq);
        a.ay(DrawingMLMain.bw, ChartExDeserializer.as);
        a.ay(DrawingMLMain.bv, ChartExDeserializer.ar);
        a.ay(DrawingMLMain.ef, ChartExDeserializer.cw);
        a.ay(DrawingMLMain.fi, ChartExDeserializer.ea);
        a.ay(DrawingMLMain.dq, ChartExDeserializer.ce);
        a.ay(DrawingMLMain.c4, ChartExDeserializer.b1);
        a.ay(DrawingMLMain.f8, ChartExDeserializer.eo);
        a.ay(DrawingMLMain.f9, ChartExDeserializer.ep);
        a.ay(DrawingMLMain.ga, ChartExDeserializer.eq);
        a.ay(DrawingMLMain.gb, ChartExDeserializer.er);
        a.ay(DrawingMLMain.gc, ChartExDeserializer.es);
        a.ay(DrawingMLMain.gd, ChartExDeserializer.et);
        a.ay(DrawingMLMain.ge, ChartExDeserializer.eu);
        a.ay(DrawingMLMain.gf, ChartExDeserializer.ev);
        a.ay(DrawingMLMain.gg, ChartExDeserializer.ew);
        a.ay(DrawingMLMain.fy, ChartExDeserializer.eh);
        a.ay(DrawingMLMain.it, ChartExDeserializer.gy);
        a.ay(DrawingMLMain.is, ChartExDeserializer.gx);
        a.ay(DrawingMLMain.b5, ChartExDeserializer.a0);
        a.ay(DrawingMLMain.b4, ChartExDeserializer.az);
        a.ay(DrawingMLMain.cb, ChartExDeserializer.a6);
        a.ay(DrawingMLMain.b9, ChartExDeserializer.a4);
        a.ay(DrawingMLMain.ca, ChartExDeserializer.a5);
        a.ay(DrawingMLMain.b7, ChartExDeserializer.a2);
        a.ay(DrawingMLMain.b6, ChartExDeserializer.a1);
        a.ay(DrawingMLMain.b8, ChartExDeserializer.a3);
        a.ay(DrawingMLMain.b1, ChartExDeserializer.aw);
        a.ay(DrawingMLMain.b3, ChartExDeserializer.ay);
        a.ay(DrawingMLMain.b2, ChartExDeserializer.ax);
        a.ay(DrawingMLMain.jd, ChartExDeserializer.hc);
        a.ay(DrawingMLMain.c5, ChartExDeserializer.b2);
        a.ay(DrawingMLMain.iw, ChartExDeserializer.gz);
        a.ay(DrawingMLMain.ix, ChartExDeserializer.g0);
        a.ay(DrawingMLMain.bs, ChartExDeserializer.ao);
        a.ay(DrawingMLMain.a2, ChartExDeserializer.q);
        a.ay(DrawingMLMain.a3, ChartExDeserializer.r);
        a.ay(DrawingMLMain.a4, ChartExDeserializer.s);
        a.ay(DrawingMLMain.a5, ChartExDeserializer.t);
        a.ay(DrawingMLMain.a7, ChartExDeserializer.v);
        a.ay(DrawingMLMain.ba, ChartExDeserializer.y);
        a.ay(DrawingMLMain.bp, ChartExDeserializer.aj);
        a.ay(DrawingMLMain.bx, ChartExDeserializer.at);
        a.ay(DrawingMLMain.cj, ChartExDeserializer.bf);
        a.ay(DrawingMLMain.cl, ChartExDeserializer.bi);
        a.ay(DrawingMLMain.dd, ChartExDeserializer.b4);
        a.ay(DrawingMLMain.dx, ChartExDeserializer.cn);
        a.ay(DrawingMLMain.eo, ChartExDeserializer.dq);
        a.ay(DrawingMLMain.e6, ChartExDeserializer.d2);
        a.ay(DrawingMLMain.cr, ChartExDeserializer.bl);
        a.ay(DrawingMLMain.dg, ChartExDeserializer.b6);
        a.ay(DrawingMLMain.a9, ChartExDeserializer.x);
        a.ay(DrawingMLMain.br, ChartExDeserializer.an);
        a.ay(DrawingMLMain.dw, ChartExDeserializer.cm);
        a.ay(DrawingMLMain.ei, ChartExDeserializer.dm);
        a.ay(DrawingMLMain.ff, ChartExDeserializer.d8);
        a.ay(DrawingMLMain.hc, ChartExDeserializer.fk);
        a.ay(DrawingMLMain.hq, ChartExDeserializer.f2);
        a.ay(DrawingMLMain.h0, ChartExDeserializer.gc);
        a.ay(DrawingMLMain.h1, ChartExDeserializer.ge);
        a.ay(DrawingMLMain.im, ChartExDeserializer.gt);
        a.ay(DrawingMLMain.j8, ChartExDeserializer.hy);
        a.ay(DrawingMLMain.gy, ChartExDeserializer.fb);
        a.ay(DrawingMLMain.io, ChartExDeserializer.gu);
        a.ay(DrawingMLMain.ej, ChartExDeserializer.dn);
        a.ay(DrawingMLMain.bt, ChartExDeserializer.ap);
        a.ay(DrawingMLMain.hh, ChartExDeserializer.fr);
        a.ay(DrawingMLMain.es, ChartExDeserializer.du);
        a.ay(DrawingMLMain.eu, ChartExDeserializer.dw);
        a.ay(DrawingMLMain.fu, ChartExDeserializer.ef);
        a.ay(DrawingMLMain.hf, ChartExDeserializer.fp);
        a.ay(DrawingMLMain.jk, ChartExDeserializer.hg);
        a.ay(DrawingMLMain.et, ChartExDeserializer.dv);
        a.ay(DrawingMLMain.d1, ChartExDeserializer.cp);
        a.ay(DrawingMLMain.iz, ChartExDeserializer.g2);
        a.ay(DrawingMLMain.jj, ChartExDeserializer.hf);
        a.ay(DrawingMLMain.i2, ChartExDeserializer.g6);
        a.ay(DrawingMLMain.dy, ChartExDeserializer.co);
        a.ay(DrawingMLMain.dv, ChartExDeserializer.cl);
        a.ay(DrawingMLMain.bn, ChartExDeserializer.ai);
        a.ay(DrawingMLMain.ck, ChartExDeserializer.bg);
        a.ay(DrawingMLMain.cn, ChartExDeserializer.bj);
        a.ay(DrawingMLMain.jc, ChartExDeserializer.hb);
        a.ay(DrawingMLMain.fw, ChartExDeserializer.eg);
        a.ay(DrawingMLMain.di, ChartExDeserializer.b8);
        a.ay(DrawingMLMain.dh, ChartExDeserializer.b7);
        a.ay(DrawingMLMain.ey, ChartExDeserializer.dz);
        a.ay(DrawingMLMain.jx, ChartExDeserializer.hp);
        a.ay(DrawingMLMain.jw, ChartExDeserializer.ho);
        a.ay(DrawingMLMain.jv, ChartExDeserializer.hn);
        a.ay(DrawingMLMain.ju, ChartExDeserializer.hm);
        a.ay(DrawingMLMain.fq, ChartExDeserializer.eb);
        a.ay(DrawingMLMain.de, ChartExDeserializer.b5);
        a.ay(DrawingMLMain.ct, ChartExDeserializer.bp);
        a.ay(DrawingMLMain.i7, ChartExDeserializer.g8);
        a.ay(DrawingMLMain.e2, ChartExDeserializer.d0);
        a.ay(DrawingMLMain.e3, ChartExDeserializer.d1);
        a.ay(DrawingMLMain.ho, ChartExDeserializer.f0);
        a.ay(DrawingMLMain.cy, ChartExDeserializer.br);
        a.ay(DrawingMLMain.h6, ChartExDeserializer.gh);
        a.ay(DrawingMLMain.bk, ChartExDeserializer.af);
        a.ay(DrawingMLMain.gl, ChartExDeserializer.e7);
        a.ay(DrawingMLMain.ew, ChartExDeserializer.dx);
        a.ay(DrawingMLMain.je, ChartExDeserializer.hd);
        a.ay(DrawingMLMain.dc, ChartExDeserializer.b3);
        a.ay(DrawingMLMain.il, ChartExDeserializer.gs);
        a.ay(DrawingMLMain.hl, ChartExDeserializer.fx);
        a.ay(DrawingMLMain.hu, ChartExDeserializer.f7);
        a.ay(DrawingMLMain.b0, ChartExDeserializer.av);
        a.ay(DrawingMLMain.d3, ChartExDeserializer.ct);
        a.ay(DrawingMLMain.dm, ChartExDeserializer.b9);
        a.ay(DrawingMLMain.h7, ChartExDeserializer.gi);
        a.ay(DrawingMLMain.ja, ChartExDeserializer.ha);
        a.ay(ChartExElements.bx, ChartExDeserializer.fu);
        a.ay(ChartExElements.d, ChartExDeserializer.ac);
        a.ay(ChartExElements.by, ChartExDeserializer.fv);
        a.ay(ChartExElements.b4, ChartExDeserializer.gq);
        a.ay(ChartExElements.cj, ChartExDeserializer.hw);
        a.ay(ChartExElements.ci, ChartExDeserializer.hv);
        a.ay(ChartExElements.w, ChartExDeserializer.b0);
        a.ay(ChartExElements.v, ChartExDeserializer.bz);
        a.ay(ChartExElements.s, ChartExDeserializer.bw);
        a.ay(ChartExElements.a8, ChartExDeserializer.ec);
        a.ay(ChartExElements.e, ChartExDeserializer.ad);
        a.ay(ChartExElements.bi, ChartExDeserializer.e4);
        a.ay(ChartExElements.bg, ChartExDeserializer.e2);
        a.ay(ChartExElements.be, ChartExDeserializer.e0);
        a.ay(ChartExElements.bh, ChartExDeserializer.e3);
        a.ay(ChartExElements.bf, ChartExDeserializer.e1);
        a.ay(ChartExElements.bd, ChartExDeserializer.ez);
        a.ay(ChartExElements.ad, ChartExDeserializer.ci);
        a.ay(ChartExElements.bn, ChartExDeserializer.fe);
        a.ay(ChartExElements.bv, ChartExDeserializer.fs);
        a.ay(ChartExElements.bp, ChartExDeserializer.fg);
        a.ay(ChartExElements.ck, ChartExDeserializer.hx);
        a.ay(ChartExElements.b3, ChartExDeserializer.gp);
        a.ay(ChartExElements.t, ChartExDeserializer.bx);
        a.ay(ChartExElements.u, ChartExDeserializer.by);
        a.ay(ChartExElements.bu, ChartExDeserializer.fo);
        a.ay(ChartExElements.b1, ChartExDeserializer.gd);
        a.ay(ChartExElements.b, ChartExDeserializer.l);
        a.ay(ChartExElements.h, ChartExDeserializer.al);
        a.ay(ChartExElements.ax, ChartExDeserializer.dd);
        a.ay(ChartExElements.b6, ChartExDeserializer.g4);
        a.ay(ChartExElements.b8, ChartExDeserializer.g7);
        a.ay(ChartExElements.i, ChartExDeserializer.am);
        a.ay(ChartExElements.g, ChartExDeserializer.ak);
        a.ay(ChartExElements.aj, ChartExDeserializer.cz);
        a.ay(ChartExElements.n, ChartExDeserializer.bd);
        a.ay(ChartExElements.a2, ChartExDeserializer.di);
        a.ay(ChartExElements.as, ChartExDeserializer.c8);
        a.ay(ChartExElements.aw, ChartExDeserializer.dc);
        a.ay(ChartExElements.an, ChartExDeserializer.c3);
        a.ay(ChartExElements.a1, ChartExDeserializer.dh);
        a.ay(ChartExElements.a0, ChartExDeserializer.dg);
        a.ay(ChartExElements.a3, ChartExDeserializer.dj);
        a.ay(ChartExElements.az, ChartExDeserializer.df);
        a.ay(ChartExElements.a, ChartExDeserializer.k);
        a.ay(ChartExElements.ar, ChartExDeserializer.c7);
        a.ay(ChartExElements.aq, ChartExDeserializer.c6);
        a.ay(ChartExElements.ap, ChartExDeserializer.c5);
        a.ay(ChartExElements.a5, ChartExDeserializer.dl);
        a.ay(ChartExElements.q, ChartExDeserializer.bo);
        a.ay(ChartExElements.a4, ChartExDeserializer.dk);
        a.ay(ChartExElements.p, ChartExDeserializer.bn);
        a.ay(ChartExElements.av, ChartExDeserializer.db);
        a.ay(ChartExElements.at, ChartExDeserializer.c9);
        a.ay(ChartExElements.au, ChartExDeserializer.da);
        a.ay(ChartExElements.am, ChartExDeserializer.c2);
        a.ay(ChartExElements.al, ChartExDeserializer.c1);
        a.ay(ChartExElements.ak, ChartExDeserializer.c0);
        a.ay(ChartExElements.ao, ChartExDeserializer.c4);
        a.ay(ChartExElements.x, ChartExDeserializer.ca);
        a.ay(ChartExElements.ay, ChartExDeserializer.de);
        a.ay(ChartExElements.a7, ChartExDeserializer.d7);
        a.ay(ChartExElements.j, ChartExDeserializer.a8);
        a.ay(ChartExElements.ch, ChartExDeserializer.hu);
        a.ay(ChartExElements.ce, ChartExDeserializer.hq);
        a.ay(ChartExElements.bb, ChartExDeserializer.ex);
        a.ay(ChartExElements.bj, ChartExDeserializer.e5);
        a.ay(ChartExElements.bc, ChartExDeserializer.ey);
        a.ay(ChartExElements.bk, ChartExDeserializer.e6);
        a.ay(ChartExElements.b9, ChartExDeserializer.he);
        a.ay(ChartExElements.cf, ChartExDeserializer.hr);
        a.ay(DrawingMLMain.cz, ChartExDeserializer.bs);
        a.ay(DrawingMLMain.hp, ChartExDeserializer.f1);
        a.ay(DrawingMLMain.hb, ChartExDeserializer.fj);
        a.ay(DrawingMLMain.eh, ChartExDeserializer.cy);
        a.ay(DrawingMLMain.ax, ChartExDeserializer.m);
        a.ay(DrawingMLMain.c2, ChartExDeserializer.bu);
        a.ay(DrawingMLMain.hw, ChartExDeserializer.f8);
        a.ay(DrawingMLMain.hg, ChartExDeserializer.fq);
        a.ay(DrawingMLMain.az, ChartExDeserializer.o);
        a.ay(DrawingMLMain.ay, ChartExDeserializer.n);
        a.ay(DrawingMLMain.hk, ChartExDeserializer.fw);
        a.ay(DrawingMLMain.c1, ChartExDeserializer.bt);
        a.ay(DrawingMLMain.ci, ChartExDeserializer.be);
        a.ay(DrawingMLMain.gm, ChartExDeserializer.e8);
        a.ay(DrawingMLMain.f0, ChartExDeserializer.ei);
        a.ay(DrawingMLMain.bf, ChartExDeserializer.aa);
        a.ay(DrawingMLMain.ht, ChartExDeserializer.f6);
        a.ay(DrawingMLMain.cv, ChartExDeserializer.bq);
        a.ay(DrawingMLMain.hs, ChartExDeserializer.f4);
        a.ay(ChartExElements.ah, ChartExDeserializer.cu);
        a.ay(ChartExElements.a6, ChartExDeserializer.dy);
        a.ay(ChartExElements.bs, ChartExDeserializer.fm);
        a.ay(ChartExElements.bt, ChartExDeserializer.fn);
        a.ay(ChartExElements.br, ChartExDeserializer.fi);
        a.ay(ChartExElements.bq, ChartExDeserializer.fh);
        a.ay(ChartExElements.z, ChartExDeserializer.cc);
        a.ay(ChartExElements.y, ChartExDeserializer.cb);
        a.ay(ChartExElements.ag, ChartExDeserializer.cr);
        a.ay(ChartExElements.af, ChartExDeserializer.cq);
        a.ay(ChartExElements.aa, ChartExDeserializer.cd);
    }
    static bb(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new ChartExDeserializer(b);
        c.h = SerializationUtils.t(b.a7._d.uri);
        ChartExDeserializer.h0(b, c);
        let d = new CT_ChartSpaceEx();
        ChartExDeserializer.h0(b, d);
    }
    static bc(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(ChartExDeserializer.$, b);
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, a);
        ChartExDeserializer.hz(b.a7._b7, d.l);
        d.a = b.a7._b3;
        if (c.d._ad == null) {
            c.d._ad = new ChartDeserializationCache();
        }
        c.d._ad.a.addItem(c.h, d);
    }
    static ba(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new CT_ChartData();
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, b);
        if (d == null) {
            return;
        }
        d.b = c;
        ChartExDeserializer.h0(b, c);
    }
    static a9(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new CT_ChartEx();
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, b);
        if (d == null) {
            return;
        }
        d.d = c;
        ChartExDeserializer.h0(b, c);
    }
    static g1(a) {
        let b = [CT_ChartSpaceEx.$, CT_ChartTitle.$, CT_PlotAreaEx.$, CT_PlotSurface.$, CT_Series.$, CT_DataPoint.$, CT_DataLabels.$, CT_DataLabel.$, CT_Axis.$, CT_AxisTitle.$, CT_AxisUnitsLabel.$, CT_Gridlines.$, CT_LegendEx.$, CT_FormatOverride.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        let e = CT_ShapeProperties_DML.t(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ShapeProperties_DML();
            $ret.q = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1570, f);
        }
        ChartExDeserializer.h0(c, f);
    }
    static hl(a) {
        let b = [CT_ChartSpaceEx.$, CT_ChartTitle.$, CT_DataLabels.$, CT_DataLabel.$, CT_Axis.$, CT_AxisTitle.$, CT_AxisUnitsLabel.$, CT_LegendEx.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_TextBody_DML();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1783, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static bh(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_ColorMapping.a(b);
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, b);
        if (d == null) {
            return;
        }
        d.h = c;
        ChartExDeserializer.h0(b, c);
    }
    static cv(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new CT_FormatOverrides();
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, b);
        if (d == null) {
            return;
        }
        c.a = d.n;
        ChartExDeserializer.h0(b, c);
    }
    static fy(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new CT_PrintSettingsEx();
        let d = ChartExDeserializer.c(CT_ChartSpaceEx.$, b);
        if (d == null) {
            return;
        }
        d.f = c;
        ChartExDeserializer.h0(b, c);
    }
    static cg(a) {
        let b = [CT_ChartSpaceEx.$, CT_ChartData.$, CT_Data.$, CT_ChartEx.$, CT_ChartTitle.$, CT_PlotAreaEx.$, CT_PlotAreaRegion.$, CT_PlotSurface.$, CT_Series.$, CT_DataPoint.$, CT_DataLabels.$, CT_DataLabel.$, CT_SeriesLayoutProperties.$, CT_Axis.$, CT_AxisTitle.$, CT_AxisUnits.$, CT_AxisUnitsLabel.$, CT_Gridlines.$, CT_TickMarks.$, CT_TickLabels.$, CT_LegendEx.$, CT_FormatOverride.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_ExtensionList();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(601, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static cf(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d;
        let e = CT_ExternalDataEx.f(b, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_ExternalDataEx();
            $ret.c = d;
            return $ret;
        })());
        if (c.hasValue) {
            f.a = CT_Boolean.b(c.value);
        }
        let g = ChartExDeserializer.c(CT_ChartData.$, b);
        if (g == null) {
            return;
        }
        g.a = f;
    }
    static bv(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d = CT_Data.h(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_Data();
            $ret.f = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_ChartData.$, b);
        if (f == null) {
            return;
        }
        f.c.add(e);
        ChartExDeserializer.h0(b, e);
    }
    static ff(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Data.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_NumericDimension.g(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_NumericDimension();
            $ret.c = d;
            return $ret;
        })());
        c.a = f;
        ChartExDeserializer.h0(b, f);
    }
    static g5(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Data.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_StringDimension.g(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_StringDimension();
            $ret.c = d;
            return $ret;
        })());
        switch (d) {
            case 0:
                if (c.b != null) {
                }
                c.b = f;
                break;
            case 1:
                if (c.c != null) {
                }
                c.c = f;
                break;
        }
        ChartExDeserializer.h0(b, f);
    }
    static ck(a) {
        let b = [CT_NumericDimension.$, CT_StringDimension.$, CT_TextData.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_Formula.a(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(612, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static e9(a) {
        let b = [CT_NumericDimension.$, CT_StringDimension.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_Formula.a(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1907, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static en(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_NumericDimension.$, b);
        if (c == null) {
            return;
        }
        let d = 0;
        let e = null;
        let f = null;
        let g = CT_NumericLevel.j(a, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_NumericLevel();
            $ret.c = e;
            $ret.e = f;
            $ret.h = d;
            return $ret;
        })());
        c.e.add(h);
        ChartExDeserializer.h0(b, h);
    }
    static f4(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_NumericLevel.$, b);
        if (c == null) {
            return;
        }
        let d = CT_NumericValue.a(b);
        let e = a.ab.ad;
        let f;
        let g = ((() => { let h = tryParseNumber(e, f); f = h.p1; return h.ret; })()) == false;
        if (g) {
        }
        d.b = f;
        c.a.add(d);
    }
    static hi(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = null;
        let d = ChartExDeserializer.c(CT_Axis.$, b, false);
        if (d != null) {
            let e = new CT_AxisTitle();
            d.a = e;
            c = e;
        }
        else {
            let f = CT_ChartTitle.f(b);
            let g = ChartExDeserializer.c(CT_ChartEx.$, b, false);
            if (g != null) {
                g.a = f;
                c = f;
            }
        }
        if (c != null) {
            ChartExDeserializer.h0(b, c);
        }
    }
    static ft(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ChartEx.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PlotAreaEx();
        c.e = d;
        ChartExDeserializer.h0(b, d);
    }
    static ed(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ChartEx.$, b);
        if (c == null) {
            return;
        }
        let d = CT_LegendEx.a(b);
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static hj(a) {
        let b = [CT_ChartTitle.$, CT_Series.$, CT_AxisTitle.$, CT_AxisUnitsLabel.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_Text();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1776, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static hk(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Text.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextData();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gf(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Text.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBody_DML();
        c.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static ht(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextData.$, b);
        if (c == null) {
            return;
        }
        let d = a.ab.ad;
        c.c = d;
    }
    static au(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = SerializationUtils.f(b);
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static ej(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextListStyle_DML();
        c.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static fl(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBody_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextParagraph_DML();
        c.d.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static f3(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PresetTextShape.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PresetTextShape();
            $ret.a = d;
            return $ret;
        })());
        c.c = f;
        ChartExDeserializer.h0(b, f);
    }
    static fa(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextNoAutofit();
        c.j.a = d;
    }
    static fd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_TextNormalAutofit.h(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextNormalAutofit();
            $ret.c = d;
            $ret.e = e;
            return $ret;
        })());
        c.j.b = g;
    }
    static gw(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextShapeAutofit();
        c.j.c = d;
    }
    static gm(a) {
        let b = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_Scene3D();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1423, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static gv(a) {
        let b = [CT_TextBodyProperties_DML.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_Shape3D.k(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1564, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static cs(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextBodyProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_FlatText.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_FlatText();
            $ret.b = d;
            return $ret;
        })());
        c.h.a = f;
    }
    static ch(a) {
        let b = [CT_TextBodyProperties_DML.$, CT_Scene3D.$, CT_Backdrop.$, CT_Shape3D.$, CT_TextListStyle_DML.$, CT_TextParagraphProperties_DML.$, CT_Blip_DML.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_Hyperlink.$, CT_ShapeProperties_DML.$, CT_ColorMapping.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_OfficeArtExtensionList();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(601, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static ab(a) {
        let b = [CT_PresetTextShape.$, CT_CustomGeometry2D.$, CT_PresetGeometry2D.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_GeomGuideList();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(80, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static cx(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeomGuideList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeomGuide();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static a7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Camera.a(b);
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static ee(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_LightRig.h(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = new CT_LightRig();
        c.e = g;
        ChartExDeserializer.h0(b, g);
    }
    static ae(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Backdrop();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gg(a) {
        let b = [CT_Camera.$, CT_LightRig.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d, e, f;
        let g = CT_SphereCoords.h(c, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_SphereCoords();
            $ret.a = d;
            $ret.c = e;
            $ret.e = f;
            return $ret;
        })());
        let i = SerializationUtils.j(c, b);
        if (i != null) {
            i.setProperty(1370, h);
        }
    }
    static z(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_Point3D.h(b, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_Point3D();
            $ret.a = d;
            $ret.c = e;
            $ret.e = f;
            return $ret;
        })());
        c.c = h;
    }
    static fc(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Vector3D.a(b);
        c.e = d;
    }
    static hs(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Backdrop.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Vector3D.a(b);
        c.g = d;
    }
    static ah(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Bevel.a(b);
        c.c = d;
    }
    static ag(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Bevel.a(b);
        c.a = d;
    }
    static cj(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.g = d;
        ChartExDeserializer.h0(b, d);
    }
    static bm(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Shape3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.e = d;
        ChartExDeserializer.h0(b, d);
    }
    static go(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_ScRgbColor.e(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1431, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static g3(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_SRgbColor_DML.e(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1586, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static d3(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_HslColor.e(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(800, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static g9(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_SystemColor.e(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1652, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static gn(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_SchemeColor_DML.f(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1429, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static fz(a) {
        let b = [CT_Color_DML.$, CT_AlphaInverseEffect.$, CT_SolidColorFillProperties.$, CT_GradientStop.$, CT_GlowEffect.$, CT_InnerShadowEffect.$, CT_OuterShadowEffect.$, CT_PresetShadowEffect.$, CT_ColorReplaceEffect.$, CT_DuotoneEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_PresetColor();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1272, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static hh(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_PositiveFixedPercentage();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1744, d);
        }
    }
    static gr(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_PositiveFixedPercentage();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1459, d);
        }
    }
    static bk(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_ComplementTransform();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(326, d);
        }
    }
    static d9(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_InverseTransform();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(845, d);
        }
    }
    static dp(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_GrayscaleTransform();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(731, d);
        }
    }
    static p(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.p(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(31, d);
        }
    }
    static w(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.f(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(38, d);
        }
    }
    static u(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.q(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(36, d);
        }
    }
    static d4(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.o(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(802, d);
        }
    }
    static d6(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.b(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(804, d);
        }
    }
    static d5(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.q(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(803, d);
        }
    }
    static gj(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1407, d);
        }
    }
    static gl(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1409, d);
        }
    }
    static gk(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1408, d);
        }
    }
    static ek(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(941, d);
        }
    }
    static em(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(943, d);
        }
    }
    static el(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(942, d);
        }
    }
    static f9(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1331, d);
        }
    }
    static gb(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1333, d);
        }
    }
    static ga(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1332, d);
        }
    }
    static dr(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(733, d);
        }
    }
    static dt(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(735, d);
        }
    }
    static ds(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(734, d);
        }
    }
    static aq(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(131, d);
        }
    }
    static as(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(133, d);
        }
    }
    static ar(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = DMLUtils.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(132, d);
        }
    }
    static cw(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_GammaTransform();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(695, d);
        }
    }
    static ea(a) {
        let b = [CT_ScRgbColor.$, CT_SRgbColor_DML.$, CT_HslColor.$, CT_SystemColor.$, CT_SchemeColor_DML.$, CT_PresetColor.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_InverseGammaTransform();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(846, d);
        }
    }
    static ce(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_OfficeArtExtensionList.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_OfficeArtExtension.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_OfficeArtExtension();
            $ret.b = d;
            return $ret;
        })());
        c.b.b.add(f);
    }
    static b1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.a = c;
        ChartExDeserializer.h0(b, c);
    }
    static eo(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.b = c;
        ChartExDeserializer.h0(b, c);
    }
    static ep(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.c = c;
        ChartExDeserializer.h0(b, c);
    }
    static eq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.d = c;
        ChartExDeserializer.h0(b, c);
    }
    static er(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.e = c;
        ChartExDeserializer.h0(b, c);
    }
    static es(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.f = c;
        ChartExDeserializer.h0(b, c);
    }
    static et(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.g = c;
        ChartExDeserializer.h0(b, c);
    }
    static eu(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.h = c;
        ChartExDeserializer.h0(b, c);
    }
    static ev(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.i = c;
        ChartExDeserializer.h0(b, c);
    }
    static ew(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = CT_TextParagraphProperties_DML.o(b);
        let d = ChartExDeserializer.c(CT_TextListStyle.$, b);
        if (d == null) {
            return;
        }
        d.j = c;
        ChartExDeserializer.h0(b, c);
    }
    static eh(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.p = d;
        ChartExDeserializer.h0(b, d);
    }
    static gy(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.r = d;
        ChartExDeserializer.h0(b, d);
    }
    static gx(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextSpacing();
        c.q = d;
        ChartExDeserializer.h0(b, d);
    }
    static a0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletColorFollowText();
        c.v.b = d;
    }
    static az(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.v.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static a6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletSizeFollowText();
        c.x.a = d;
    }
    static a4(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextBulletSizePercent.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextBulletSizePercent();
            $ret.a = d;
            return $ret;
        })());
        c.x.b = f;
    }
    static a5(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextBulletSizePoint.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextBulletSizePoint();
            $ret.a = d;
            return $ret;
        })());
        c.x.c = f;
    }
    static a2(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBulletTypefaceFollowText();
        c.z.a = d;
    }
    static a1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.b6);
        c.z.b = d;
    }
    static a3(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextNoBullet();
        c.t.d = d;
    }
    static aw(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_TextAutonumberBullet.g(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextAutonumberBullet();
            $ret.a = d;
            $ret.d = e;
            return $ret;
        })());
        c.t.a = g;
    }
    static ay(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextCharBullet.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextCharBullet();
            $ret.a = d;
            return $ret;
        })());
        c.t.c = f;
    }
    static ax(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextBlipBullet();
        c.t.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static hc(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_TextTabStopList();
            $ret.e = new List$1(CT_TextTabStop.$, 0);
            return $ret;
        })());
        c.aa = CT_TextTabStopList.c(d);
        ChartExDeserializer.h0(b, d);
    }
    static b2(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraphProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TextCharacterProperties_DML.z(b, DrawingMLMain.c5);
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gz(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextSpacing.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextSpacingPercent.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextSpacingPercent();
            $ret.a = d;
            return $ret;
        })());
        c.a = f;
    }
    static g0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextSpacing.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TextSpacingPoint.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TextSpacingPoint();
            $ret.a = d;
            return $ret;
        })());
        c.b = f;
    }
    static ao(a) {
        let b = [CT_TextBlipBullet.$, CT_BlipFillProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_Blip_DML.l(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(127, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static q(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_AlphaBiLevelEffect.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaBiLevelEffect();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(32, f);
        }
    }
    static r(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_AlphaCeilingEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(33, d);
        }
    }
    static s(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_AlphaFloorEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(34, d);
        }
    }
    static t(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_AlphaInverseEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(35, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static v(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_AlphaModulateFixedEffect.e(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaModulateFixedEffect();
            $ret.b = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(37, f);
        }
    }
    static y(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_AlphaReplaceEffect.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaReplaceEffect();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(40, f);
        }
    }
    static aj(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_BiLevelEffect.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BiLevelEffect();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(117, f);
        }
    }
    static at(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e;
        let f = CT_BlurEffect.h(c, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_BlurEffect();
            $ret.e = d;
            $ret.c = e;
            return $ret;
        })());
        let h = SerializationUtils.j(c, b);
        if (h != null) {
            h.setProperty(134, g);
        }
    }
    static bf(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_ColorChangeEffect.i(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ColorChangeEffect();
            $ret.f = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(279, f);
        }
        ChartExDeserializer.h0(c, f);
    }
    static bi(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_ColorReplaceEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(285, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static b4(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_DuotoneEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(546, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static cn(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_FillOverlayEffect.f(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_FillOverlayEffect();
            $ret.c = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(633, f);
        }
        ChartExDeserializer.h0(c, f);
    }
    static dq(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_GrayscaleEffect();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(732, d);
        }
    }
    static d2(a) {
        let b = [CT_Blip_DML.$, CT_EffectContainer.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d, e, f;
        let g = CT_HSLEffect.k(c, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_HSLEffect();
            $ret.d = d;
            $ret.h = e;
            $ret.f = f;
            return $ret;
        })());
        let i = SerializationUtils.j(c, b);
        if (i != null) {
            i.setProperty(799, h);
        }
    }
    static bl(a) {
        let b = [CT_AlphaModulateEffect.$, CT_EffectContainer.$, CT_BlendEffect.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_EffectContainer.a(a);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(344, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static b6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_EffectReference.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_EffectReference();
            $ret.a = d;
            return $ret;
        })());
        c.c.p = f;
    }
    static x(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_AlphaOutsetEffect.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AlphaOutsetEffect();
            $ret.b = d;
            return $ret;
        })());
        c.c.g = f;
    }
    static an(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_BlendEffect.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_BlendEffect();
            $ret.c = d;
            return $ret;
        })());
        c.c.j = f;
        ChartExDeserializer.h0(b, f);
    }
    static cm(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_FillEffect();
        c.c.q = d;
        ChartExDeserializer.h0(b, d);
    }
    static dm(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_GlowEffect.g(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_GlowEffect();
            $ret.e = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(724, f);
        }
        ChartExDeserializer.h0(c, f);
    }
    static d8(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e;
        let f;
        let g = CT_InnerShadowEffect.m(c, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_InnerShadowEffect();
            $ret.g = d;
            $ret.i = f;
            $ret.k = e;
            return $ret;
        })());
        let i = SerializationUtils.j(c, b);
        if (i != null) {
            i.setProperty(830, h);
        }
        ChartExDeserializer.h0(c, h);
    }
    static fk(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_OuterShadowEffect.d(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1142, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static f2(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e;
        let f;
        let g = CT_PresetShadowEffect.l(c, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_PresetShadowEffect();
            $ret.h = f;
            $ret.j = e;
            $ret.d = d;
            return $ret;
        })());
        let i = SerializationUtils.j(c, b);
        if (i != null) {
            i.setProperty(1275, h);
        }
        ChartExDeserializer.h0(c, h);
    }
    static gc(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_ReflectionEffect.a(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1338, d);
        }
    }
    static ge(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d, e;
        let f = CT_RelativeOffsetEffect.h(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_RelativeOffsetEffect();
            $ret.c = d;
            $ret.e = e;
            return $ret;
        })());
        c.c.aa = g;
    }
    static gt(a) {
        let b = [CT_EffectContainer.$, CT_EffectList.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_SoftEdgesEffect.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_SoftEdgesEffect();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1551, f);
        }
    }
    static hy(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_EffectContainer.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TransformEffect.a(b);
        c.c.ad = d;
    }
    static fb(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_NoFillProperties();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1063, d);
        }
    }
    static gu(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_SolidColorFillProperties();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1553, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static dn(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e;
        let f = CT_GradientFillProperties.l(c, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_GradientFillProperties();
            $ret.g = d;
            $ret.i = e;
            return $ret;
        })());
        let h = SerializationUtils.j(c, b);
        if (h != null) {
            h.setProperty(725, g);
        }
        ChartExDeserializer.h0(c, g);
    }
    static ap(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_BlipFillProperties_DML.e(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(128, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static fr(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_LineProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_PatternFillProperties.h(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PatternFillProperties();
            $ret.e = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1174, f);
        }
        ChartExDeserializer.h0(c, f);
    }
    static du(a) {
        let b = [CT_FillEffect.$, CT_FillOverlayEffect.$, CT_TextCharacterProperties_DML.$, CT_TextUnderlineFillGroupWrapper.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_GroupFillProperties();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(752, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static dw(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ((() => {
            let $ret = new CT_GradientStopList();
            $ret.c = new List$1(CT_GradientStop.$, 0);
            return $ret;
        })());
        let d = ChartExDeserializer.c(CT_GradientFillProperties.$, b);
        if (d == null) {
            return;
        }
        d.e = CT_GradientStopList.e(c);
        ChartExDeserializer.h0(b, c);
    }
    static ef(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d;
        let e = CT_LinearShadeProperties.f(b, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_LinearShadeProperties();
            $ret.a = c;
            $ret.c = d;
            return $ret;
        })());
        let g = ChartExDeserializer.c(CT_GradientFillProperties.$, b);
        if (g == null) {
            return;
        }
        g.b.a = f;
    }
    static fp(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GradientFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_PathShadeProperties.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PathShadeProperties();
            $ret.c = d;
            return $ret;
        })());
        c.b.b = f;
        ChartExDeserializer.h0(b, f);
    }
    static hg(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = DMLUtils.u(b);
        let d = ChartExDeserializer.c(CT_GradientFillProperties.$, b);
        if (d == null) {
            return;
        }
        d.c = c;
    }
    static dv(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new ST_PositiveFixedPercentage();
        let d = CT_GradientStop.e(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GradientStop();
            $ret.d = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_GradientStopList.$, b);
        if (f == null) {
            return;
        }
        f.c.add(e);
        ChartExDeserializer.h0(b, e);
    }
    static cp(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = DMLUtils.u(b);
        let d = ChartExDeserializer.c(CT_PathShadeProperties.$, b);
        if (d == null) {
            return;
        }
        d.a = c;
    }
    static g2(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = DMLUtils.u(b);
        let d = ChartExDeserializer.c(CT_BlipFillProperties_DML.$, b);
        if (d == null) {
            return;
        }
        d.a = c;
    }
    static hf(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = DMLUtils.w(b);
        let d = ChartExDeserializer.c(CT_BlipFillProperties_DML.$, b);
        if (d == null) {
            return;
        }
        d.g.b = c;
    }
    static g6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_StretchInfoProperties();
        c.g.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static co(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_StretchInfoProperties.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.a = d;
    }
    static cl(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = new CT_Color_DML();
        let d = ChartExDeserializer.c(CT_PatternFillProperties.$, b);
        if (d == null) {
            return;
        }
        d.c = c;
        ChartExDeserializer.h0(b, c);
    }
    static ai(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PatternFillProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static bg(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ColorChangeEffect.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static bj(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ColorChangeEffect.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static hb(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextTabStopList.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_TextTabStop.f(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextTabStop();
            $ret.a = e;
            $ret.c = d;
            return $ret;
        })());
        c.e.add(g);
    }
    static eg(a) {
        let b = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_LineProperties_DML.i(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(918, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static b8(a) {
        let b = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_EffectList();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(560, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static b7(a) {
        let b = [CT_TextCharacterProperties_DML.$, CT_ShapeProperties_DML.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_EffectContainer.a(a);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(558, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static dz(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Color_DML();
        c.w = d;
        ChartExDeserializer.h0(b, d);
    }
    static hp(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineLineFollowText();
        c.ah.b = d;
    }
    static ho(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_LineProperties_DML.i(b);
        c.ah.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static hn(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineFillFollowText();
        c.af.a = d;
    }
    static hm(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextUnderlineFillGroupWrapper();
        c.af.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static eb(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.fq);
        c.c = d;
    }
    static b5(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.de);
        c.b = d;
    }
    static bp(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.ct);
        c.a = d;
    }
    static g8(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.v(b, DrawingMLMain.i7);
        c.ak = d;
    }
    static d0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.h(b, DrawingMLMain.e2);
        c.ai = d;
        ChartExDeserializer.h0(b, d);
    }
    static d1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextCharacterProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.h(b, DrawingMLMain.e3);
        c.aj = d;
        ChartExDeserializer.h0(b, d);
    }
    static f0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.t(b);
        c.l.b = d;
    }
    static br(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_DashStopList();
        c.l.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gh(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineJoinRound();
        c.p.c = d;
    }
    static af(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineJoinBevel();
        c.p.a = d;
    }
    static e7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.j(b);
        c.p.b = d;
    }
    static dx(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.i(b);
        c.a = d;
    }
    static hd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_LineProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.i(b);
        c.b = d;
    }
    static b3(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_DashStopList.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.d(b);
        c.b.add(d);
    }
    static gs(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Hyperlink.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.e(b);
        c.a = d;
    }
    static fx(a) {
        let b = [CT_TextParagraph_DML.$, CT_TextField.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_TextParagraphProperties_DML.o(c);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1154, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static f7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_RegularTextRun_DML();
        c.setProperty(1297, d);
        ChartExDeserializer.h0(b, d);
    }
    static av(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TextLineBreak();
        c.setProperty(164, d);
        ChartExDeserializer.h0(b, d);
    }
    static ct(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d, e;
        let f = CT_TextField.l(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_TextField();
            $ret.e = d;
            $ret.j = e;
            return $ret;
        })());
        c.setProperty(651, g);
        ChartExDeserializer.h0(b, g);
    }
    static b9(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_TextParagraph_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_TextCharacterProperties_DML.z(b, DrawingMLMain.dm);
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gi(a) {
        let b = [CT_RegularTextRun_DML.$, CT_TextLineBreak.$, CT_TextField.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = CT_TextCharacterProperties_DML.z(c, DrawingMLMain.h7);
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1305, d);
        }
        ChartExDeserializer.h0(c, d);
    }
    static ha(a) {
        let b = [CT_RegularTextRun_DML.$, CT_TextField.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = a.ab.ad;
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1655, d);
        }
    }
    static fu(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PlotAreaEx.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PlotAreaRegion();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static ac(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PlotAreaEx.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_Axis.ac(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_Axis();
            $ret.aa = d;
            $ret.w = e;
            return $ret;
        })());
        c.d.add(g);
        ChartExDeserializer.h0(b, g);
    }
    static fv(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PlotAreaRegion.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PlotSurface();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static gq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PlotAreaRegion.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Series.d(b);
        c.c.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static hw(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ValueColors();
        c.k = d;
        ChartExDeserializer.h0(b, d);
    }
    static hv(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ValueColorPositions.k(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ValueColorPositions();
            $ret.h = d;
            return $ret;
        })());
        c.i = f;
        ChartExDeserializer.h0(b, f);
    }
    static b0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_DataPoint.f(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_DataPoint();
            $ret.d = d;
            return $ret;
        })());
        c.r.add(f);
        ChartExDeserializer.h0(b, f);
    }
    static bz(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_DataLabels.k(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_DataLabels();
            $ret.g = d;
            return $ret;
        })());
        c.c = f;
        ChartExDeserializer.h0(b, f);
    }
    static bw(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_DataId.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_DataId();
            $ret.b = d;
            return $ret;
        })());
        c.a = f;
    }
    static ec(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SeriesLayoutProperties();
        c.e = d;
        ChartExDeserializer.h0(b, d);
    }
    static ad(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Series.$, b);
        if (c == null) {
            return;
        }
        let d = ST_AxisId.c(b);
        c.q.add(d);
    }
    static e4(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColors.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SolidColorFillProperties();
        c.e = d;
        ChartExDeserializer.h0(b, d);
    }
    static e2(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColors.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SolidColorFillProperties();
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static e0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColors.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_SolidColorFillProperties();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static e3(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColorPositions.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ValueColorEndPosition();
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static e1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColorPositions.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ValueColorMiddlePosition();
        c.e = d;
        ChartExDeserializer.h0(b, d);
    }
    static ez(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColorPositions.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ValueColorEndPosition();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static ci(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ValueColorEndPosition.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ExtremeValueColorPosition();
        c.a = d;
    }
    static fe(a) {
        let b = [CT_ValueColorEndPosition.$, CT_ValueColorMiddlePosition.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_NumberColorPosition.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_NumberColorPosition();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1912, f);
        }
    }
    static fs(a) {
        let b = [CT_ValueColorEndPosition.$, CT_ValueColorMiddlePosition.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e = CT_PercentageColorPosition.d(c, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_PercentageColorPosition();
            $ret.a = d;
            return $ret;
        })());
        let g = SerializationUtils.j(c, b);
        if (g != null) {
            g.setProperty(1913, f);
        }
    }
    static fg(a) {
        let b = [CT_DataLabels.$, CT_DataLabel.$, CT_Axis.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d;
        let e;
        let f = CT_NumberFormat.f(c, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_NumberFormat();
            $ret.c = d;
            $ret.a = e;
            return $ret;
        })());
        let h = SerializationUtils.j(c, b);
        if (h != null) {
            h.setProperty(1088, g);
        }
    }
    static hx(a) {
        let b = [CT_DataLabels.$, CT_DataLabel.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, c, false);
        if (d != null) {
            let e = CT_SeriesElementVisibilities.a(c);
            d.i = e;
            return;
        }
        let f = SerializationUtils.j(c, b);
        if (f == null) {
            return;
        }
        let g;
        let h;
        let i;
        let j = CT_DataLabelVisibilities.h(c, g, h, i);
        g = j.p1;
        h = j.p2;
        i = j.p3;
        let k = ((() => {
            let $ret = new CT_DataLabelVisibilities();
            $ret.e = i;
            $ret.a = h;
            $ret.c = g;
            return $ret;
        })());
        f.setProperty(1844, k);
    }
    static gp(a) {
        let b = [CT_DataLabels.$, CT_DataLabel.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = a.ab.ad;
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1445, d);
        }
    }
    static bx(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_DataLabels.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_DataLabel.j(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_DataLabel();
            $ret.i = d;
            $ret.g = e;
            return $ret;
        })());
        c.i.add(g);
        ChartExDeserializer.h0(b, g);
    }
    static by(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d = CT_DataLabelHidden.d(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_DataLabelHidden();
            $ret.b = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_DataLabels.$, b);
        if (f == null) {
            return;
        }
        f.j.add(e);
    }
    static fo(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_ParentLabelLayout.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_ParentLabelLayout();
            $ret.a = d;
            return $ret;
        })());
        c.e = f;
    }
    static gd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_RegionLabelLayout.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_RegionLabelLayout();
            $ret.a = d;
            return $ret;
        })());
        c.g = f;
    }
    static l(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Aggregation();
        c.a = d;
    }
    static al(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Binning.c(b);
        c.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static dd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Geography.c(b);
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static g4(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_Statistics.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_Statistics();
            $ret.a = d;
            return $ret;
        })());
        c.k = f;
    }
    static g7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_SeriesLayoutProperties.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Subtotals();
        c.m = d;
        ChartExDeserializer.h0(b, d);
    }
    static am(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Binning.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = CT_Binning.n(b, d);
        d = e.p1;
        if (d.hasValue) {
            c.a = ((() => {
                let $ret = new CT_Double();
                $ret.f = d.value;
                return $ret;
            })());
        }
    }
    static ak(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Binning.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(Number_$type, null);
        let e = CT_Binning.m(b, d);
        d = e.p1;
        if (d.hasValue) {
            c.b = ((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = d.value;
                return $ret;
            })());
        }
    }
    static cz(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d = CT_GeoCache.f(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GeoCache();
            $ret.c = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_Geography.$, b);
        if (f == null) {
            return;
        }
        f.a = e;
        ChartExDeserializer.h0(b, e);
    }
    static bd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoCache.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Clear();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static di(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Clear.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoLocationQueryResults();
        d.a = c.d;
        ChartExDeserializer.h0(b, d);
    }
    static c8(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Clear.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoDataEntityQueryResults();
        d.a = c.b;
        ChartExDeserializer.h0(b, d);
    }
    static dc(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Clear.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoDataPointToEntityQueryResults();
        d.a = c.c;
        ChartExDeserializer.h0(b, d);
    }
    static c3(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Clear.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoChildEntitiesQueryResults();
        d.a = c.a;
        ChartExDeserializer.h0(b, d);
    }
    static dh(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoLocationQueryResults.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoLocationQueryResult();
        c.a.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static dg(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoLocationQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoLocationQuery();
        c.a = d;
    }
    static dj(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoLocationQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoLocations();
        c.c = d;
        ChartExDeserializer.h0(b, d);
    }
    static df(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoLocations.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoLocation();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static k(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoLocation.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Address.a(b);
        c.a = d;
    }
    static c7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataEntityQueryResults.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoDataEntityQueryResult();
        c.a.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static c6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataEntityQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = CT_GeoDataEntityQuery.f(b, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_GeoDataEntityQuery();
            $ret.c = e;
            $ret.a = d;
            return $ret;
        })());
        c.c = g;
    }
    static c5(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataEntityQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = CT_GeoData.a(b);
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static dl(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoData.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoPolygons();
        d.a = c.d;
        ChartExDeserializer.h0(b, d);
    }
    static bo(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoData.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Copyrights();
        d.a = c.b;
        ChartExDeserializer.h0(b, d);
    }
    static dk(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoPolygons.$, b);
        if (c == null) {
            return;
        }
        let d = CT_GeoPolygon.a(b);
        c.a.add(d);
    }
    static bn(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Copyrights.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.a.add(d);
    }
    static db(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataPointToEntityQueryResults.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoDataPointToEntityQueryResult();
        c.a.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static c9(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataPointToEntityQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = CT_GeoDataPointQuery.a(b);
        c.a = d;
    }
    static da(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoDataPointToEntityQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = CT_GeoDataPointToEntityQuery.a(b);
        c.c = d;
    }
    static c2(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoChildEntitiesQueryResults.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoChildEntitiesQueryResult();
        c.a.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static c1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d = CT_GeoChildEntitiesQuery.e(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GeoChildEntitiesQuery();
            $ret.b = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_GeoChildEntitiesQueryResult.$, b);
        if (f == null) {
            return;
        }
        f.a = e;
        ChartExDeserializer.h0(b, e);
    }
    static c0(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoChildEntitiesQueryResult.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoChildEntities();
        d.a = c.c;
        ChartExDeserializer.h0(b, d);
    }
    static c4(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoChildEntitiesQuery.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeoChildTypes();
        d.a = c.a;
        ChartExDeserializer.h0(b, d);
    }
    static ca(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoChildTypes.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        let e;
        if (((() => { let f = EnumUtil.tryParse$1(ST_EntityType_$type, d, true, e); e = f.p2; return f.ret; })()) == false) {
            e = 11;
        }
        c.a.add(e);
    }
    static de(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_GeoChildEntities.$, b);
        if (c == null) {
            return;
        }
        let d = CT_GeoHierarchyEntity.a(b);
        c.a.add(d);
    }
    static d7(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Subtotals.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Subtotals.b(b);
        if (d.hasValue) {
            c.a.add(d.value);
        }
    }
    static a8(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_CategoryAxisScaling.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_CategoryAxisScaling();
            $ret.a = d;
            return $ret;
        })());
        c.e = f;
    }
    static hu(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d = CT_ValueAxisScaling.a(b);
        c.r = d;
    }
    static hq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_AxisUnits.g(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_AxisUnits();
            $ret.d = d;
            return $ret;
        })());
        c.c = f;
        ChartExDeserializer.h0(b, f);
    }
    static ex(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Gridlines();
        c.f = d;
        ChartExDeserializer.h0(b, d);
    }
    static e5(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Gridlines();
        c.h = d;
        ChartExDeserializer.h0(b, d);
    }
    static ey(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c;
        let d = CT_TickMarks.e(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_TickMarks();
            $ret.b = c;
            return $ret;
        })());
        let f = ChartExDeserializer.c(CT_Axis.$, b);
        if (f == null) {
            return;
        }
        f.n = e;
        ChartExDeserializer.h0(b, e);
    }
    static e6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_TickMarks.e(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_TickMarks();
            $ret.b = d;
            return $ret;
        })());
        c.p = f;
        ChartExDeserializer.h0(b, f);
    }
    static he(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Axis.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_TickLabels();
        c.l = d;
        ChartExDeserializer.h0(b, d);
    }
    static hr(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_AxisUnits.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_AxisUnitsLabel();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static bs(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ShapeProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_CustomGeometry2D();
        c.n.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static f1(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ShapeProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PresetGeometry2D();
        c.n.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static fj(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Transform2D.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.m(b);
        c.a = d;
    }
    static cy(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_GeomGuideList();
        c.d = d;
        ChartExDeserializer.h0(b, d);
    }
    static m(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_AdjustHandleList();
        c.a = d;
        ChartExDeserializer.h0(b, d);
    }
    static bu(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ConnectionSiteList();
        c.b = d;
        ChartExDeserializer.h0(b, d);
    }
    static f8(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.g(b);
        c.e = d;
    }
    static fq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_CustomGeometry2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DList();
        c.f = d;
        ChartExDeserializer.h0(b, d);
    }
    static o(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_AdjustHandleList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_XYAdjustHandle();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static n(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_AdjustHandleList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_PolarAdjustHandle();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static fw(a) {
        let b = [CT_XYAdjustHandle.$, CT_PolarAdjustHandle.$, CT_ConnectionSite.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_AdjPoint2D();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1241, d);
        }
    }
    static bt(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ConnectionSiteList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_ConnectionSite();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static be(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DClose();
        c.b.add(d);
    }
    static e8(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DMoveTo();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static ei(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DLineTo();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static aa(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DArcTo();
        c.b.add(d);
    }
    static f6(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DQuadBezierTo();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static bq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_Path2D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Path2DCubicBezierTo();
        c.b.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static f5(a) {
        let b = [CT_Path2DMoveTo.$, CT_Path2DLineTo.$, CT_Path2DQuadBezierTo.$, CT_Path2DCubicBezierTo.$];
        let c = typeCast(ObjectModelChartExPartManager.$, a);
        let d = new CT_AdjPoint2D();
        let e = SerializationUtils.j(c, b);
        if (e != null) {
            e.setProperty(1277, d);
        }
    }
    static cu(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_FormatOverrides.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_FormatOverride();
        c.a.add(d);
        ChartExDeserializer.h0(b, d);
    }
    static dy(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d, e, f;
        let g = CT_HeaderFooter_Chart.w(b, d, e, f);
        d = g.p1;
        e = g.p2;
        f = g.p3;
        let h = ((() => {
            let $ret = new CT_HeaderFooter_Chart();
            $ret.a = d;
            $ret.h = e;
            $ret.f = f;
            return $ret;
        })());
        c.a = h;
        ChartExDeserializer.h0(b, h);
    }
    static fm(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PrintSettings.$, b);
        if (c == null) {
            return;
        }
        let d = CT_PageMargins_Chart.a(b);
        c.c = d;
    }
    static fn(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_PrintSettingsEx.$, b);
        if (c == null) {
            return;
        }
        let d = CT_PageSetup.a(b);
        c.j = d;
    }
    static fi(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.t = d;
    }
    static fh(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.r = d;
    }
    static cc(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.l = d;
    }
    static cb(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.j = d;
    }
    static cr(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.p = d;
    }
    static cq(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_HeaderFooter.$, b);
        if (c == null) {
            return;
        }
        let d = ChartExDeserializer.g(b);
        c.n = d;
    }
    static cd(a) {
        let b = typeCast(ObjectModelChartExPartManager.$, a);
        let c = ChartExDeserializer.c(CT_ExtensionList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Extension();
        c.e.add(d);
    }
    static c($t, a, b = true) {
        return SerializationUtils.i($t, a, b);
    }
    static h0(a, b) {
        a.s.k(b);
    }
    static f(a, b = true) {
        let c = a.ab.ad;
        let d;
        if (((() => { let e = tryParseNumber(c, d); d = e.p1; return e.ret; })()) == false) {
            if (b) {
            }
        }
        return d;
    }
    static i(a, b = true) {
        let c = a.ab.ad;
        let d;
        if (((() => { let e = tryParseUInt32_2(c, 0, CultureInfo.invariantCulture, d); d = e.p3; return e.ret; })()) == false) {
            if (b) {
            }
        }
        return d;
    }
    static g(a) {
        return a.ab.ad;
    }
    static hz(a, b) {
        b.clear();
        for (let c of fromEnum(a._bh)) {
            let d = null;
            if (((() => { let e = b.tryGetValue(c.a.name, d); d = e.p1; return e.ret; })())) {
                continue;
            }
            b.addItem(c.a.name, c.a);
        }
    }
    static e(a) {
        switch (a) {
            case 116: return true;
            default: return false;
        }
    }
    static b(a) {
        if (a == null) {
            return null;
        }
        let b = Nullable$1.toNullable(Number_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = false;
        let e = Nullable$1.toNullable(Number_$type, null);
        let f = false;
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = 1;
        if (a.a != null) {
            b = Nullable$1.toNullable(Number_$type, CT_Double.d(a.a));
        }
        if (a.b != null) {
            c = Nullable$1.toNullable(Number_$type, a.b.g);
        }
        if (a.d != null) {
            d = true;
            if (a.d.b.hasValue) {
                e = Nullable$1.toNullable(Number_$type, a.d.b.value);
            }
        }
        if (a.f != null) {
            f = true;
            if (a.f.b.hasValue) {
                g = Nullable$1.toNullable(Number_$type, a.f.b.value);
            }
        }
        if (a.h.hasValue && a.h.value == 0) {
            h = 0;
        }
        return new CategoryAxisBinning(b, c, d, e, f, g, h);
    }
    static a(a) {
        if (a == null) {
            return null;
        }
        let b = false;
        let c = true;
        let d = true;
        let e = false;
        let f = 0;
        if (a.i != null) {
            if (a.i.h.hasValue) {
                b = a.i.h.value;
            }
            if (a.i.j.hasValue) {
                c = a.i.j.value;
            }
            if (a.i.f.hasValue) {
                d = a.i.f.value;
            }
            if (a.i.d.hasValue) {
                e = a.i.d.value;
            }
        }
        if (a.k != null && a.k.a.hasValue) {
            f = a.k.a.value == 1 ? 1 : 0;
        }
        return new BoxAndWhiskerSettings(b, c, d, e, f);
    }
    static j(a) {
        if (a.xValues != null) {
            let b = a.xValues._u();
            let c = a.xValues.getValues();
            for (let d of fromEnum(b.c)) {
            }
        }
    }
}
ChartExDeserializer.$t = markType(ChartExDeserializer, 'ChartExDeserializer');
/**
 * @hidden
 */
export class ChartSerializer extends Base {
    constructor(a) {
        super();
        this.bc = null;
        this.bc = a;
    }
    bw(a, b, c, d) {
        if (a == null) {
            return;
        }
        a._jy();
        a._jt();
        let e = this.bc;
        let f = a.chartArea;
        let g = a.plotArea;
        let h = ((() => {
            let $ret = new CT_ChartSpace();
            $ret.b = CT_Boolean.b(false);
            $ret.r = ((() => {
                let $ret = new CT_TextLanguageID();
                $ret.b = "en-US";
                return $ret;
            })());
            $ret.d = CT_Boolean.b(f.roundedCorners);
            return $ret;
        })());
        h.v = ChartSerializer.a5(e, f.fill, f.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
        h.f = ((() => {
            let $ret = new CT_Chart();
            $ret.c = CT_Boolean.b(a.plotVisibleOnly);
            $ret.g = ((() => {
                let $ret = new CT_DispBlanksAs();
                $ret.b = DMLChartExtensions.ao(a.displayBlanksAs);
                return $ret;
            })());
            $ret.a = CT_Boolean.b(a.chartTitle == null);
            return $ret;
        })());
        if (WorksheetChart._f6(a.chartType)) {
            h.f.u = ChartSerializer.a0(a.depthPercent, a.heightPercent, a.rotationX, a.rotationY, a.perspective, a.rightAngleAxes);
            h.f.m = ChartSerializer.as(e, a, a.backWall);
            h.f.q = ChartSerializer.as(e, a, a.sideWall);
            h.f.o = ChartSerializer.as(e, a, a.floor);
        }
        else if (WorksheetChart._gl(a.chartType)) {
            h.f.u = ChartSerializer.a1();
        }
        h.f.k = ((() => {
            let $ret = new CT_PlotArea();
            $ret.af = ChartSerializer.a5(e, g.fill, g.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            $ret.l = ChartSerializer.x(e, g.position, g.left, g.top, Nullable$1.toNullable(Number_$type, g.width), Nullable$1.toNullable(Number_$type, g.height), true);
            return $ret;
        })());
        let i = ChartSerializer.bg(a, h.f.k);
        a._seriesCollection$i._av();
        ChartSerializer.bm(a, h.f.k, i, c);
        let j = a.chartTitle;
        if (j != null) {
            h.f.s = ((() => {
                let $ret = new CT_Title();
                $ret.c = ChartSerializer.x(e, j.position, j.left, j.top, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null));
                $ret.a = CT_Boolean.b(j.overlay);
                $ret.g = ChartSerializer.a5(e, j.fill, j.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            let k = ChartSerializer.a9(e, j.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, j.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, j.verticalOverflow), j.textDirection, j.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, j.verticalAlignment));
            h.f.s.e = ChartSerializer.ay(e, k, j.defaultFont, null, j.text, j.readingOrder, j._a5);
            h.f.s.i = ChartSerializer.a8(e, k, j.defaultFont, null, j.readingOrder);
        }
        h.f.i = ChartSerializer.y(e, a);
        ChartSerializerExtensions.k(h, b, c, d, DrawingMLChart.bg);
    }
    static bx(a, b, c, d, e, f, g, h, i, j, k = false) {
        let l = ChartSerializer.x(d, f, g, h, Nullable$1.toNullable(Number_$type, i), Nullable$1.toNullable(Number_$type, j));
        if (l != null) {
            ChartSerializerExtensions.s(l, a, b, c, e);
        }
    }
    static by(a, b, c) {
        c.p(DrawingMLMain.gy, "a");
        c.k();
    }
    static bm(a, b, c, d) {
        switch (a.chartType) {
            case 57:
            case 58:
            case 59:
            case 51:
            case 52:
            case 53:
                b.f = ChartSerializer.i(a, c, d);
                break;
            case 4:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
                b.n = ChartSerializer.aa(a, c, d);
                break;
            case 1:
            case 76:
            case 77:
                b.c = ChartSerializer.c(a, c, d);
                break;
            case -4098:
            case 78:
            case 79:
                b.b = ChartSerializer.b(a, c, d);
                break;
            case 5:
            case 69:
                b.s = ChartSerializer.al(a, c, d);
                break;
            case -4120:
            case 80:
                b.i = ChartSerializer.v(a, c, d);
                break;
            case -4169:
            case 74:
            case 75:
            case 72:
            case 73:
                b.y = ChartSerializer.ap(a, c, d);
                break;
            case -4151:
            case 82:
            case 81:
                b.u = ChartSerializer.an(a, c, d);
                break;
            case 15:
            case 87:
                b.h = ChartSerializer.l(a, c, d);
                break;
            case 85:
            case 86:
                b.ad = ChartSerializer.at(a, c, d);
                break;
            case 83:
            case 84:
                b.ae = ChartSerializer.au(a, c, d);
                break;
            case 60:
            case 61:
            case 62:
            case -4100:
            case 54:
            case 55:
            case 56:
            case 102:
            case 103:
            case 104:
            case 105:
            case 99:
            case 100:
            case 101:
            case 95:
            case 96:
            case 97:
            case 98:
            case 92:
            case 93:
            case 94:
            case 109:
            case 110:
            case 111:
            case 112:
            case 106:
            case 107:
            case 108:
                b.e = ChartSerializer.h(a, c, d);
                break;
            case 71:
            case 68:
                b.p = ChartSerializer.aj(a, c, d);
                break;
            case -4101:
                b.m = ChartSerializer.z(a, c, d);
                break;
            case -4102:
            case 70:
                b.r = ChartSerializer.ak(a, c, d);
                break;
            case 88:
            case 89:
                b.ac = ChartSerializer.ar(a, c, d, false);
                break;
            case 90:
            case 91:
                b.ac = ChartSerializer.ar(a, c, d, true);
                b.f = ChartSerializer.j(a, c, d);
                break;
            case 113:
                ChartSerializer.bn(a, b, c, d);
                break;
        }
    }
    static bn(a, b, c, d) {
        let e = ComboChartSerializer.e(a._seriesCollection$i);
        for (let f of fromEnum(e)) {
            ComboChartSerializer.g(a, a.sheet, c, b, f, d);
        }
    }
    static bg(a, b) {
        let c = new List$1(Axis.$, 0);
        if (WorksheetChart._f3(a.chartType) == false) {
            return c;
        }
        let d = a._axisCollection$i;
        let e = d.item(1, 1);
        let f = d.item(2, 1);
        let g = d.item(1, 2);
        let h = d.item(2, 2);
        let i = d.item(3);
        if (WorksheetChart._gy(a.chartType) == false) {
            g = null;
            h = null;
        }
        if (a.chartType == 113 && a._seriesCollection$i._ah == false) {
            g = null;
            h = null;
        }
        let j = a.chartType == 113;
        if (j) {
            let k = false;
            let l = false;
            let m = a._seriesCollection$i._as(k, l);
            k = m.p0;
            l = m.p1;
            if (k == false) {
                e = null;
                f = null;
            }
            if (l == false) {
                g = null;
                h = null;
            }
        }
        let n = [e, f, g, h];
        for (let p = 0; p < n.length; p++) {
            let o = n[p];
            if (o != null) {
                ChartSerializer.bl(a, b, o, d);
                c.add(o);
            }
        }
        if (ChartSerializer.bf(a.chartType)) {
            if (i == null) {
                i = new Axis(d, 3, 1);
            }
            ChartSerializer.bl(a, b, i, d);
            c.add(i);
        }
        return c;
    }
    static be(a) {
        if (a.chartType != 113) {
            return false;
        }
        return a._seriesCollection$i._ad(6);
    }
    static bl(a, b, c, d) {
        let e = a.sheet;
        let f = c.type;
        let g = null;
        let h = null;
        let i = null;
        let j = null;
        let k = null;
        let l = c._ac;
        switch (f) {
            case 1:
                switch (c.categoryType) {
                    case 3:
                        i = new CT_DateAx();
                        b.ah.add(i);
                        g = i.p;
                        break;
                    default:
                        h = new CT_CatAx();
                        b.ah.add(h);
                        g = h.n;
                        break;
                }
                break;
            case 2:
                j = new CT_ValAx();
                j.e = ((() => {
                    let $ret = new CT_CrossBetween();
                    $ret.a = l != null && l.axisBetweenCategories ? 0 : 1;
                    return $ret;
                })());
                b.ah.add(j);
                g = j.j;
                break;
            case 3:
                k = new CT_SerAx();
                b.ah.add(k);
                g = k.f;
                break;
            default: return;
        }
        g.c = ((() => {
            let $ret = new CT_UnsignedInt();
            $ret.g = intSToU(c._cg);
            return $ret;
        })());
        if (c.type != 3) {
            let m = a._eh(c, true);
            let n = DMLChartExtensions.av(m, c);
            if (n.hasValue) {
                g.e = ((() => {
                    let $ret = new CT_AxPos();
                    $ret.a = n.value;
                    return $ret;
                })());
            }
        }
        if (l != null) {
            g.d = ((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(l._cg);
                return $ret;
            })());
            let o = DMLChartExtensions.aw(l.crosses);
            if (o.hasValue) {
                g.h = ((() => {
                    let $ret = new CT_Crosses();
                    $ret.a = o.value;
                    return $ret;
                })());
            }
            else {
                let p = l._dp;
                if (p.hasValue) {
                    g.b = CT_Double.a(p.value);
                }
            }
        }
        g.a = CT_Boolean.b(c.visible == false);
        g.f = ChartSerializer.o(e, a, c.majorGridLines);
        g.g = ChartSerializer.o(e, a, c.minorGridLines);
        g.l = ((() => {
            let $ret = new CT_TickMark();
            $ret.b = DMLChartExtensions.ak(c.majorTickMark);
            return $ret;
        })());
        g.m = ((() => {
            let $ret = new CT_TickMark();
            $ret.b = DMLChartExtensions.ak(c.minorTickMark);
            return $ret;
        })());
        let q = ((() => {
            let $ret = new CT_NumFmt_Chart();
            $ret.c = "General";
            $ret.a = false;
            return $ret;
        })());
        if (c.tickLabels != null && stringIsNullOrEmpty(c.tickLabels.numberFormat) == false) {
            q = ChartSerializer.ah(c.tickLabels.numberFormat, c.tickLabels.numberFormatLinked);
        }
        g.i = h != null ? null : q;
        g.o = new CT_ShapeProperties_DML();
        g.o.l.d = new CT_NoFillProperties();
        g.o.a = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, null);
            $ret.q = Nullable$1.toNullable(Number_$type, ExcelUtils.dh(0.75));
            return $ret;
        })());
        if (c.tickLabels != null) {
            g.o = ChartSerializer.a5(e, c.tickLabels.fill, null, Nullable$1.toNullable(BorderLineStyle_$type, null));
            let r = ChartSerializer.a9(e, c.tickLabels.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, 0), Nullable$1.toNullable(TextVerticalOverflow_$type, 2), c.tickLabels.textDirection, false, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
            g.p = ChartSerializer.a8(e, r, c.tickLabels.font, null, c.tickLabels.readingOrder);
        }
        if (c.tickLines != null) {
            g.o.a = ChartSerializer.a4(e, c.tickLines, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        g.k = ((() => {
            let $ret = new CT_TickLblPos();
            $ret.b = DMLChartExtensions.aj(c.tickLabelPosition);
            return $ret;
        })());
        if (c.axisTitle != null) {
            g.n = ChartSerializer.aw(e, c.axisTitle);
        }
        g.j = new CT_Scaling();
        if (c.scaleType == -4133) {
            g.j.e = ((() => {
                let $ret = new CT_LogBase();
                $ret.a = c.logBase;
                return $ret;
            })());
        }
        let s = c.reversePlotOrder ? 4 : 3;
        g.j.g = ((() => {
            let $ret = new CT_Orientation();
            $ret.a = s;
            return $ret;
        })());
        if (c.maximumScaleIsAuto == false) {
            g.j.a = ((() => {
                let $ret = new CT_Double();
                $ret.f = c._b9;
                return $ret;
            })());
        }
        if (c.minimumScaleIsAuto == false) {
            g.j.c = ((() => {
                let $ret = new CT_Double();
                $ret.f = c._cb;
                return $ret;
            })());
        }
        if (h != null) {
            ChartSerializer.bo(a, b, c, h);
        }
        else if (i != null) {
            ChartSerializer.bp(a, b, c, i);
        }
        else if (j != null) {
            ChartSerializer.bv(a, b, c, j);
        }
    }
    static bo(a, b, c, d) {
        d.a = CT_Boolean.b(c.baseUnitIsAuto);
        let e = c.tickLabels;
        if (e != null) {
            d.e = ((() => {
                let $ret = new CT_LblAlgn();
                $ret.a = DMLChartExtensions.ag(e.alignment);
                return $ret;
            })());
            d.g = ((() => {
                let $ret = new CT_LblOffset();
                $ret.c = e.offset;
                return $ret;
            })());
        }
        d.a = ((() => {
            let $ret = new CT_Boolean(3);
            $ret.m = Nullable$1.toNullable(Boolean_$type, c.categoryType == -4105);
            return $ret;
        })());
    }
    static bv(a, b, c, d) {
        let e = a.sheet;
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = c._du(f, g);
        f = h.p0;
        g = h.p1;
        if (f.hasValue) {
            d.a = ((() => {
                let $ret = new CT_AxisUnit();
                $ret.a = f.value;
                return $ret;
            })());
        }
        if (g.hasValue) {
            d.c = ((() => {
                let $ret = new CT_AxisUnit();
                $ret.a = g.value;
                return $ret;
            })());
        }
        d.dispUnits = new CT_DispUnits();
        if (c.displayUnit == -4142) {
            d.dispUnits.b = null;
            d.dispUnits.a = null;
        }
        else {
            let i = DMLChartUtils.aw(c.displayUnit);
            if (i.hasValue) {
                d.dispUnits.b = ((() => {
                    let $ret = new CT_BuiltInUnit();
                    $ret.b = i.value;
                    return $ret;
                })());
            }
            else {
                d.dispUnits.a = CT_Double.a(c.displayUnitCustom);
            }
        }
        let j = c.displayUnitLabel;
        if (j != null) {
            d.dispUnits.c = ((() => {
                let $ret = new CT_DispUnitsLbl();
                $ret.a = ChartSerializer.x(e, j.position, j.left, j.top, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null));
                $ret.e = ChartSerializer.a5(e, j.fill, j.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            let k = ChartSerializer.a9(e, j.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, j.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, j.verticalOverflow), j.textDirection, j.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
            d.dispUnits.c.c = ChartSerializer.ay(e, k, j.defaultFont, null, j.text, j.readingOrder, j._a5);
            d.dispUnits.c.g = ChartSerializer.a8(e, k, j.defaultFont, null, j.readingOrder);
        }
    }
    static bp(a, b, c, d) {
        let e = a.sheet;
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = c._du(f, g);
        f = h.p0;
        g = h.p1;
        if (f.hasValue) {
            d.c = ((() => {
                let $ret = new CT_AxisUnit();
                $ret.a = f.value;
                return $ret;
            })());
        }
        if (g.hasValue) {
            d.e = ((() => {
                let $ret = new CT_AxisUnit();
                $ret.a = g.value;
                return $ret;
            })());
        }
        if (c.baseUnitIsAuto == false) {
            d.i = ((() => {
                let $ret = new CT_TimeUnit();
                $ret.b = DMLChartExtensions.al(c.baseUnit);
                return $ret;
            })());
            d.a = CT_Boolean.b(false);
        }
        else {
            d.a = CT_Boolean.b(true);
        }
        if (c.majorUnitIsAuto == false) {
            d.k = ((() => {
                let $ret = new CT_TimeUnit();
                $ret.b = DMLChartExtensions.al(c.majorUnitScale);
                return $ret;
            })());
        }
        if (c.minorUnitIsAuto == false) {
            d.m = ((() => {
                let $ret = new CT_TimeUnit();
                $ret.b = DMLChartExtensions.al(c.minorUnitScale);
                return $ret;
            })());
        }
    }
    static as(a, b, c) {
        if (c == null) {
            return null;
        }
        let d = ((() => {
            let $ret = new CT_Surface();
            $ret.e = ChartSerializer.a5(a, c.fill, c.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            $ret.a = CT_UnsignedInt.a(intSToU(c.thickness));
            return $ret;
        })());
        d.e.g = new CT_Shape3D();
        return d;
    }
    static y(a, b) {
        let c = b != null ? b.legend : null;
        if (c == null) {
            return null;
        }
        let d = c.position == 5 ? -4114 : -4105;
        let e = ((() => {
            let $ret = new CT_Legend();
            $ret.c = ChartSerializer.x(a, d, c.left, c.top, Nullable$1.toNullable(Number_$type, c.width), Nullable$1.toNullable(Number_$type, c.height));
            $ret.g = ChartSerializer.a5(a, c.fill, c.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            $ret.a = CT_Boolean.b(c.overlay);
            return $ret;
        })());
        let f = ChartSerializer.a9(a, c.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, 0), Nullable$1.toNullable(TextVerticalOverflow_$type, 2), c.textDirection, true, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
        e.i = ChartSerializer.a8(a, f, c.defaultFont, null, -5002);
        let g = DMLChartExtensions.ax(c.position);
        if (g.hasValue) {
            e.e = ((() => {
                let $ret = new CT_LegendPos();
                $ret.b = g.value;
                return $ret;
            })());
        }
        if (c._legendEntries$i != null) {
            e.m = new List$1(CT_LegendEntry.$, 0);
            let h = b._g5();
            for (let i = 0; i < h.count; i++) {
                let j = h._inner[i];
                if (j._ak() == false) {
                    continue;
                }
                let k = ((() => {
                    let $ret = new CT_LegendEntry();
                    $ret.a = CT_Boolean.b(j.isDeleted);
                    $ret.b = CT_UnsignedInt.a(intSToU(i));
                    return $ret;
                })());
                f = ChartSerializer.a9(a, 0, Nullable$1.toNullable(TextHorizontalOverflow_$type, 0), Nullable$1.toNullable(TextVerticalOverflow_$type, 2), 0, true, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
                k.e.a = ChartSerializer.a8(a, f, j.font, j.fontFill, -5002);
                let l = ((() => {
                    let $ret = new CT_TextParagraph_DML();
                    $ret.c = ChartSerializer.bb(a, j.font, -5002);
                    return $ret;
                })());
                k.e.a.d.add(l);
                e.m.add(k);
            }
        }
        return e;
    }
    static o(a, b, c) {
        return ChartSerializer.s(a, b, c);
    }
    static q(a, b, c) {
        return ChartSerializer.s(a, b, c);
    }
    static r(a, b, c) {
        return ChartSerializer.s(a, b, c);
    }
    static p(a, b, c) {
        return ChartSerializer.s(a, b, c);
    }
    static n(a, b, c) {
        return ChartSerializer.s(a, b, c);
    }
    static s(a, b, c) {
        if (c == null) {
            return null;
        }
        if (c.widthInPoints == 0.75 && c.fill == null) {
            return null;
        }
        let d = ((() => {
            let $ret = new CT_ChartLines();
            $ret.a = new CT_ShapeProperties_DML();
            return $ret;
        })());
        d.a.a = ChartSerializer.a4(a, c, Nullable$1.toNullable(BorderLineStyle_$type, null));
        return d;
    }
    static a1() {
        return ((() => {
            let $ret = new CT_View3D();
            $ret.i = ((() => {
                let $ret = new CT_RotX();
                $ret.b = 90;
                return $ret;
            })());
            $ret.k = ((() => {
                let $ret = new CT_RotY();
                $ret.c = 0;
                return $ret;
            })());
            $ret.a = ((() => {
                let $ret = new CT_Boolean(3);
                $ret.m = Nullable$1.toNullable(Boolean_$type, false);
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_Perspective();
                $ret.b = 0;
                return $ret;
            })());
            return $ret;
        })());
    }
    static a0(a, b, c, d, e, f) {
        c = truncate(ExcelUtils.cl(c));
        d = truncate(ExcelUtils.cl(d));
        let g = ((() => {
            let $ret = new CT_View3D();
            $ret.c = ((() => {
                let $ret = new CT_DepthPercent();
                $ret.c = a;
                return $ret;
            })());
            $ret.e = ((() => {
                let $ret = new CT_HPercent();
                $ret.c = b;
                return $ret;
            })());
            $ret.g = ((() => {
                let $ret = new CT_Perspective();
                $ret.b = (e * 2);
                return $ret;
            })());
            $ret.a = CT_Boolean.b(f);
            $ret.i = ((() => {
                let $ret = new CT_RotX();
                $ret.b = c;
                return $ret;
            })());
            $ret.k = ((() => {
                let $ret = new CT_RotY();
                $ret.c = d;
                return $ret;
            })());
            return $ret;
        })());
        return g;
    }
    static bq(a, b, c, d, e) {
        a.a = CT_Boolean.b(c.varyColors);
        a.b = ((() => {
            let $ret = new CT_BarDir();
            $ret.b = DMLChartExtensions.ab(c.chartType);
            return $ret;
        })());
        a.c = ((() => {
            let $ret = new CT_BarGrouping();
            $ret.b = DMLChartExtensions.ac(c.chartType);
            return $ret;
        })());
        a.a = CT_Boolean.b(false);
        for (let f = 0; f < c._seriesCollection$i.count; f++) {
            let g = c._seriesCollection$i.item(f);
            let h = ChartSerializer.k(c, g, intSToU(f), d, e);
            a.f.add(h);
        }
    }
    static br(a, b, c, d, e) {
        a.d = ((() => {
            let $ret = new CT_Grouping();
            $ret.b = d ? 1 : DMLChartUtils.aa(c.chartType);
            return $ret;
        })());
        a.a = CT_Boolean.b(c.varyColors);
        for (let f = 0; f < c._seriesCollection$i.count; f++) {
            let g = c._seriesCollection$i.item(f);
            let h = ChartSerializer.ab(c, g, intSToU(f), e);
            a.f.add(h);
        }
        a.a = CT_Boolean.b(false);
    }
    static j(a, b, c) {
        let d = new CT_BarChart();
        d.f.b = ((() => {
            let $ret = new CT_BarDir();
            $ret.b = 1;
            return $ret;
        })());
        d.f.c = ((() => {
            let $ret = new CT_BarGrouping();
            $ret.b = 1;
            return $ret;
        })());
        d.g = new List$1(CT_UnsignedInt.$, 0);
        for (let e = 0; e < b.count; e++) {
            let f = b._inner[e];
            if (f.axisGroup == 2) {
                continue;
            }
            d.g.add(((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(f._cg);
                return $ret;
            })()));
        }
        for (let g = 0; g < a._seriesCollection$i.count; g++) {
            let h = a._seriesCollection$i.item(g);
            if (h.type != 1) {
                continue;
            }
            let i = ChartSerializer.k(a, h, intSToU(g), false, c);
            d.f.f.add(i);
        }
        return d;
    }
    static i(a, b, c) {
        let d = a.sheet;
        let e = new CT_BarChart();
        let f = e.f;
        ChartSerializer.bq(f, d, a, false, c);
        e.g = ChartSerializer.bk(b);
        if (a.seriesLines != null) {
            let g = ChartSerializer.q(d, a, a.seriesLines);
            if (g != null) {
                e.k = new List$1(CT_ChartLines.$, 0);
                e.k.add(g);
            }
        }
        if (a.seriesOverlap != 0) {
            e.c = ((() => {
                let $ret = new CT_Overlap();
                $ret.b = a.seriesOverlap;
                return $ret;
            })());
        }
        let h = a._iy;
        if (h.hasValue) {
            e.a = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = h.value;
                return $ret;
            })());
        }
        return e;
    }
    static h(a, b, c) {
        let d = a.sheet;
        let e = new CT_Bar3DChart();
        let f = e.h;
        ChartSerializer.bq(f, d, a, true, c);
        e.i = ChartSerializer.bk(b);
        e.e = ((() => {
            let $ret = new CT_Shape_Chart();
            $ret.b = DMLChartExtensions.ai(a.barShapeResolved);
            return $ret;
        })());
        let g = a._iy;
        if (g.hasValue) {
            e.c = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = g.value;
                return $ret;
            })());
        }
        let h = a._ix;
        if (h.hasValue) {
            e.a = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = h.value;
                return $ret;
            })());
        }
        return e;
    }
    static z(a, b, c) {
        let d = a.sheet;
        let e = new CT_Line3DChart();
        let f = e.d;
        ChartSerializer.br(f, d, a, true, c);
        e.e = ChartSerializer.bk(b);
        if (a.gapDepth != 150) {
            e.a = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = a.gapDepth;
                return $ret;
            })());
        }
        return e;
    }
    static ak(a, b, c) {
        let d = a.sheet;
        let e = new CT_Pie3DChart();
        let f = e.b;
        ChartSerializer.bs(f, a, d, c);
        return e;
    }
    static aa(a, b, c) {
        let d = a.sheet;
        let e = new CT_LineChart();
        let f = e.j;
        ChartSerializer.br(f, d, a, false, c);
        e.k = ChartSerializer.bk(b);
        if (WorksheetChart._f4(a.chartType)) {
            e.e = ((() => {
                let $ret = new CT_Marker_Chart();
                $ret.j = Nullable$1.toNullable(Boolean_$type, true);
                return $ret;
            })());
        }
        return e;
    }
    static c(a, b, c) {
        let d = a.sheet;
        let e = new CT_AreaChart();
        let f = e.b;
        let g = DMLChartUtils.aa(a.chartType);
        f.d = ((() => {
            let $ret = new CT_Grouping();
            $ret.b = g;
            return $ret;
        })());
        f.a = CT_Boolean.b(a.varyColors);
        for (let h = 0; h < a._seriesCollection$i.count; h++) {
            let i = a._seriesCollection$i.item(h);
            let j = ChartSerializer.d(a, i, intSToU(h), c);
            f.f.add(j);
        }
        e.c = ChartSerializer.bk(b);
        return e;
    }
    static b(a, b, c) {
        let d = a.sheet;
        let e = new CT_Area3DChart();
        let f = e.d;
        let g = DMLChartUtils.aa(a.chartType);
        f.d = ((() => {
            let $ret = new CT_Grouping();
            $ret.b = g;
            return $ret;
        })());
        f.a = CT_Boolean.b(a.varyColors);
        for (let h = 0; h < a._seriesCollection$i.count; h++) {
            let i = a._seriesCollection$i.item(h);
            let j = ChartSerializer.d(a, i, intSToU(h), c);
            f.f.add(j);
        }
        e.e = ChartSerializer.bk(b);
        e.a = ((() => {
            let $ret = new CT_GapAmount();
            $ret.c = a.gapDepth;
            return $ret;
        })());
        return e;
    }
    static ap(a, b, c) {
        let d = a.sheet;
        let e = new CT_ScatterChart();
        e.e = DMLChartUtils.x(a.chartType);
        e.a = CT_Boolean.b(a.varyColors);
        e.k = new List$1(CT_ScatterSer.$, 0);
        for (let f = 0; f < a._seriesCollection$i.count; f++) {
            let g = a._seriesCollection$i.item(0);
            let h = a._seriesCollection$i.item(f);
            let i = ChartSerializer.aq(a, h, g, intSToU(f), c);
            if (i != null) {
                e.k.add(i);
            }
        }
        e.g = ChartSerializer.bk(b);
        return e;
    }
    static al(a, b, c) {
        let d = a.sheet;
        let e = new CT_PieChart();
        let f = e.d;
        ChartSerializer.bs(f, a, d, c);
        if (a.firstSliceAngle > 0) {
            e.a = ((() => {
                let $ret = new CT_FirstSliceAng();
                $ret.c = a.firstSliceAngle;
                return $ret;
            })());
        }
        return e;
    }
    static aj(a, b, c) {
        let d = a.sheet;
        let e = new CT_OfPieChart();
        let f = e.l;
        ChartSerializer.bs(f, a, d, c);
        let g = a.chartType == 68 ? 0 : 1;
        e.e = ((() => {
            let $ret = new CT_OfPieType();
            $ret.b = g;
            return $ret;
        })());
        let h = a._iy;
        if (h.hasValue) {
            e.c = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = h.value;
                return $ret;
            })());
        }
        if (a.seriesLines != null) {
            e.q = new List$1(CT_ChartLines.$, 0);
            e.q.add(((() => {
                let $ret = new CT_ChartLines();
                $ret.a = ChartSerializer.a5(d, null, a.seriesLines, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })()));
        }
        e.g = ((() => {
            let $ret = new CT_SecondPieSize();
            $ret.c = a.secondPlotSize;
            return $ret;
        })());
        return e;
    }
    static v(a, b, c) {
        let d = a.sheet;
        let e = new CT_DoughnutChart();
        let f = e.f;
        f.a = CT_Boolean.b(true);
        for (let g = 0; g < a._seriesCollection$i.count; g++) {
            let h = a._seriesCollection$i.item(g);
            let i = ChartSerializer.am(a, h, intSToU(g), c);
            f.d.add(i);
        }
        if (a.firstSliceAngle > 0) {
            e.a = ((() => {
                let $ret = new CT_FirstSliceAng();
                $ret.c = a.firstSliceAngle;
                return $ret;
            })());
        }
        e.c = ((() => {
            let $ret = new CT_HoleSize();
            $ret.b = a.doughnutHoleSize;
            return $ret;
        })());
        return e;
    }
    static an(a, b, c) {
        let d = a.sheet;
        let e = new CT_RadarChart();
        e.a = CT_Boolean.b(a.varyColors);
        e.e = DMLChartUtils.v(a.chartType);
        e.k = new List$1(CT_RadarSer.$, 0);
        for (let f = 0; f < a._seriesCollection$i.count; f++) {
            let g = a._seriesCollection$i.item(f);
            let h = ChartSerializer.ao(a, g, intSToU(f), c);
            e.k.add(h);
        }
        e.g = ChartSerializer.bk(b);
        return e;
    }
    static l(a, b, c) {
        let d = a.sheet;
        let e = (a.chartType == 87);
        let f = ((() => {
            let $ret = new CT_BubbleChart();
            $ret.m = new List$1(CT_UnsignedInt.$, 0);
            $ret.q = new List$1(CT_BubbleSer.$, 0);
            $ret.o = new List$1(CT_Extension.$, 0);
            return $ret;
        })());
        f.e = CT_Boolean.b(a.varyColors);
        f.q = new List$1(CT_BubbleSer.$, 0);
        for (let g = 0; g < a._seriesCollection$i.count; g++) {
            let h = a._seriesCollection$i.item(g);
            let i = ChartSerializer.m(a, h, intSToU(g), e, c);
            f.q.add(i);
        }
        f.m = ChartSerializer.bk(b);
        return f;
    }
    static au(a, b, c) {
        let d = a.sheet;
        let e = new CT_SurfaceChart();
        let f = e.b;
        ChartSerializer.bu(f, d, a, false, c);
        e.c = ChartSerializer.bk(b, Nullable$1.toNullable(AxisGroup_$type, null), false);
        return e;
    }
    static at(a, b, c) {
        let d = a.sheet;
        let e = new CT_Surface3DChart();
        let f = e.b;
        ChartSerializer.bu(f, d, a, true, c);
        e.c = ChartSerializer.bk(b, Nullable$1.toNullable(AxisGroup_$type, null), false);
        return e;
    }
    static ar(a, b, c, d) {
        let e = a.sheet;
        let f = WorksheetChart._i0(a.chartType);
        let g = new CT_StockChart();
        g.i = new List$1(CT_UnsignedInt.$, 0);
        for (let h = 0; h < b.count; h++) {
            let i = b._inner[h];
            if (d && i.axisGroup == 1) {
                continue;
            }
            g.i.add(((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(i._cg);
                return $ret;
            })()));
        }
        let j = f.hasValue ? f.value - 1 : a._seriesCollection$i.count - 1;
        g.m = new List$1(CT_LineSer.$, 0);
        for (let k = 0; k <= j; k++) {
            let l = a._seriesCollection$i.item(k);
            if (d && l.type != 2) {
                continue;
            }
            let m = ChartSerializer.ab(a, l, intSToU(k), c);
            g.m.add(m);
        }
        let n = a.upDownBars;
        let o = a.highLowLines;
        let p = a.dropLines;
        if (n != null) {
            g.g = ChartSerializer.az(n, e);
        }
        if (o != null) {
            g.c = ChartSerializer.p(e, a, o);
        }
        if (p != null) {
            g.a = ChartSerializer.n(e, a, p);
        }
        return g;
    }
    static bu(a, b, c, d, e) {
        let f = c.chartType == 84 || c.chartType == 86;
        a.a = CT_Boolean.b(f);
        let g = null;
        for (let h = 0; h < c._seriesCollection$i.count; h++) {
            let i = c._seriesCollection$i.item(h);
            if (g == null) {
                g = i;
            }
            let j = ChartSerializer.av(c, i, intSToU(h), d, e);
            a.d.add(j);
        }
        if (g != null) {
            a.b = ChartSerializer.g(b, c);
        }
    }
    static bz(a, b, c, d, e = true) {
        if (e && WorksheetChart._f3(b) == false) {
            return;
        }
        let f = a.item(1, 1);
        let g = a.item(2, 1);
        if (c && f == null) {
            throw new BaseError(1, ExcelUtils.eg("LE_Serialization_NoPrimaryCategoryAxis", enumGetBox(ChartType_$type, b)));
        }
        if (d && g == null) {
            throw new BaseError(1, ExcelUtils.eg("LE_Serialization_NoPrimaryValueAxis", enumGetBox(ChartType_$type, b)));
        }
    }
    static bf(a) {
        switch (a) {
            case 83:
            case 85:
            case 86:
            case 84: return true;
            default: return false;
        }
    }
    static bi(a, b, c) {
        let d = b.dataLabels._ea;
        if (b == null || stringIsNullOrEmpty(d)) {
            return c;
        }
        d = SerializationUtils.u(d);
        let e = c != null ? c : new List$1(CT_Extension.$, 0);
        let f = ((() => {
            let $ret = new CT_Extension_DataLabelsRange();
            $ret.b = "{02D57815-91ED-43cb-92C2-25804820EDAC}";
            $ret.h = ((() => {
                let $ret = new CT_SeriesDataLabelsRange();
                $ret.c = d;
                return $ret;
            })());
            return $ret;
        })());
        e.add(f);
        return e;
    }
    static k(a, b, c, d, e) {
        let f = a.sheet;
        let g = new CT_BarSer();
        let h = g.p;
        ChartSerializer.bt(h, f, b, e, c, true);
        g.a = CT_Boolean.b(b.invertIfNegative);
        let i = ChartSerializer.e(a, b);
        g.c = i;
        let j = ChartSerializer.ad(a, b);
        g.i = j;
        g.g = ChartSerializer.w(a, b);
        g.k = new CT_PictureOptions();
        ChartSerializerExtensions.a5(g.k, b);
        if (d) {
            let k = DMLChartExtensions.ai(b.barShapeResolved);
            g.m = ((() => {
                let $ret = new CT_Shape_Chart();
                $ret.b = k;
                return $ret;
            })());
        }
        g.v = ChartSerializer.bj(f, b);
        g.e = ChartSerializer.u(f, b);
        g.r = ChartSerializer.bh(f, b);
        g.t = ChartSerializer.bi(f, b, g.t);
        return g;
    }
    static ab(a, b, c, d) {
        let e = a.sheet;
        let f = new CT_LineSer();
        let g = f.n;
        let h = WorksheetChart._f6(a.chartType);
        ChartSerializer.bt(g, e, b, d, c, h);
        let i = ChartSerializer.e(a, b);
        f.c = i;
        let j = ChartSerializer.ad(a, b);
        f.k = j;
        f.g = ChartSerializer.w(a, b);
        f.a = CT_Boolean.b(b.smooth);
        f.i = ChartSerializer.ac(e, b.markerStyle, b._dk, b.markerFill, b.markerBorder, Nullable$1.toNullable(ChartType_$type, b.chartType));
        f.t = ChartSerializer.bj(e, b);
        f.e = ChartSerializer.u(e, b);
        f.p = ChartSerializer.bh(e, b);
        f.r = ChartSerializer.bi(e, b, f.r);
        return f;
    }
    static d(a, b, c, d) {
        let e = a.sheet;
        let f = new CT_AreaSer();
        let g = f.j;
        ChartSerializer.bt(g, e, b, d, c, true);
        let h = ChartSerializer.e(a, b);
        f.a = h;
        let i = ChartSerializer.ad(a, b);
        f.e = i;
        let j = ChartSerializer.w(a, b);
        if (j != null) {
            f.n = new List$1(CT_ErrBars.$, 0);
            f.n.add(j);
        }
        f.g = new CT_PictureOptions();
        ChartSerializerExtensions.a5(f.g, b);
        f.r = ChartSerializer.bj(e, b);
        f.c = ChartSerializer.u(e, b);
        f.l = ChartSerializer.bh(e, b);
        f.p = ChartSerializer.bi(e, b, f.p);
        return f;
    }
    static am(a, b, c, d) {
        let e = a.sheet;
        let f = new CT_PieSer();
        let g = f.j;
        ChartSerializer.bt(g, e, b, d, c, true);
        f.l = ChartSerializer.bh(e, b);
        let h = ChartSerializer.e(a, b);
        f.c = h;
        let i = ChartSerializer.ad(a, b);
        f.g = i;
        let j = b._dj;
        if (j.hasValue) {
            f.a = ((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(j.value);
                return $ret;
            })());
        }
        f.e = ChartSerializer.u(e, b);
        f.l = ChartSerializer.bh(e, b);
        f.n = ChartSerializer.bi(e, b, f.n);
        return f;
    }
    static aq(a, b, c, d, e, f = false) {
        let g = a.sheet;
        let h = new CT_ScatterSer();
        let i = h.l;
        let j = a.chartType == -4169;
        ChartSerializer.bt(i, g, b, e, d, false, j);
        if (f == false) {
            let k = c.xValues != null ? typeCast(SeriesValuesBase.$, c.xValues) : typeCast(SeriesValuesBase.$, c.values);
            let l = ChartSerializer.f(a, k);
            h.c = l;
        }
        let m = ChartSerializer.ad(a, b);
        h.i = m;
        h.p = new List$1(CT_ErrBars.$, 0);
        h.p.add(ChartSerializer.w(a, b));
        h.a = CT_Boolean.b(b._b5);
        let n = null;
        let o = b.chartType != 75 && b.chartType != 73;
        if (o) {
            let p = b.markerFill != null ? b.markerFill : b.line != null ? b.line.fill : ChartSerializer.a(b, d);
            let q = b.markerStyle;
            if (q == -4142) {
                q = -4105;
            }
            n = ChartSerializer.ac(g, q, b._dk, p, b.markerBorder, Nullable$1.toNullable(ChartType_$type, b.chartType));
        }
        else {
            n = ((() => {
                let $ret = new CT_Marker_Chart();
                $ret.c = ((() => {
                    let $ret = new CT_MarkerStyle();
                    $ret.a = 0;
                    return $ret;
                })());
                return $ret;
            })());
        }
        if (a.chartType == -4169 && b.markerStyle == -4142) {
            let r = b.line != null ? ExcelUtils.dh(b.line.widthInPoints) : ExcelUtils.dh(2.25);
            i.d = new CT_ShapeProperties_DML();
            i.d.l.g();
            i.d.a = ((() => {
                let $ret = new CT_LineProperties_DML();
                $ret.f = Nullable$1.toNullable(ST_LineCap_$type, 0);
                $ret.q = Nullable$1.toNullable(Number_$type, r);
                return $ret;
            })());
            i.d.a.n.d = new CT_NoFillProperties();
        }
        h.g = n;
        h.t = ChartSerializer.bj(g, b);
        h.e = ChartSerializer.u(g, b);
        h.n = ChartSerializer.bh(g, b);
        h.r = ChartSerializer.bi(g, b, h.r);
        return h;
    }
    static ao(a, b, c, d) {
        let e = a.sheet;
        let f = new CT_RadarSer();
        let g = f.j;
        ChartSerializer.bt(g, e, b, d, c, a.chartType == 82);
        f.e = ChartSerializer.ac(e, b.markerStyle, b._dk, b.markerFill, b.markerBorder, Nullable$1.toNullable(ChartType_$type, a.chartType));
        let h = ChartSerializer.e(a, b);
        f.a = h;
        let i = ChartSerializer.ad(a, b);
        f.g = i;
        f.c = ChartSerializer.u(e, b);
        f.l = ChartSerializer.bh(e, b);
        f.n = ChartSerializer.bi(e, b, f.n);
        return f;
    }
    static m(a, b, c, d, e) {
        let f = a.sheet;
        let g = new CT_BubbleSer();
        let h = g.n;
        ChartSerializer.bt(h, f, b, e, c, true);
        g.i = b.bubbleSizes != null ? ChartSerializer.ae(a, b.bubbleSizes, b) : ChartSerializer.af(a, b);
        g.e = ChartSerializer.e(a, b);
        g.k = ChartSerializer.ad(a, b);
        if (b.errorBars != null) {
            g.r = new List$1(CT_ErrBars.$, 0);
            let i = ChartSerializer.w(a, b);
            if (i != null) {
                g.r = new List$1(CT_ErrBars.$, 0);
                g.r.add(i);
            }
        }
        if (d) {
            g.a = CT_Boolean.b(true);
        }
        g.v = ChartSerializer.bj(f, b);
        g.g = ChartSerializer.u(f, b);
        g.p = ChartSerializer.bh(f, b);
        g.t = ChartSerializer.bi(f, b, g.t);
        if (b.chartType == 87) {
            g.a = CT_Boolean.b(true);
        }
        return g;
    }
    static av(a, b, c, d, e) {
        let f = a.sheet;
        let g = new CT_SurfaceSer();
        let h = g.f;
        ChartSerializer.bt(h, f, b, e, c, true);
        let i = ChartSerializer.e(a, b);
        g.a = i;
        let j = ChartSerializer.ad(a, b);
        g.c = j;
        return g;
    }
    static bh(a, b) {
        if (b == null) {
            return null;
        }
        let c = b.chart;
        let d = b.chartType == 87;
        let e = c != null ? c.varyColors : true;
        let f = b._dataPointCollection$i;
        let g = new List$1(CT_DPt.$, 2, f.count);
        for (let h = 0; h < f.count; h++) {
            let i = f.item(h);
            if (i._aw(false) == false) {
                continue;
            }
            let j = i._ai;
            if (j == null && e) {
                j = ChartSerializer.a(b, h);
            }
            let k = i._ac;
            let l = ((() => {
                let $ret = new CT_DPt();
                $ret.g = ((() => {
                    let $ret = new CT_UnsignedInt();
                    $ret.g = intSToU(h);
                    return $ret;
                })());
                $ret.m = ChartSerializer.a5(a, j, k, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            l.e = ((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(i._a3);
                return $ret;
            })());
            l.a = CT_Boolean.b(d);
            l.c = CT_Boolean.b(i._au);
            let m = WorksheetChart._gw(b.chartType);
            l.i = m ? ChartSerializer.ac(a, i._ao, Nullable$1.toNullable(Number_$type, i._a9), i._al, i._ae, Nullable$1.toNullable(ChartType_$type, null)) : null;
            ChartSerializerExtensions.a4(l.k, i);
            g.add(l);
        }
        return g;
    }
    static g(a, b) {
        let c = 0;
        for (let d of fromEnum(b._seriesCollection$i)) {
            let e = d.values;
            let f = e != null ? e.getValues() : null;
            if (f != null && f.length > c) {
                c = f.length;
            }
        }
        let g = ((() => {
            let $ret = new CT_BandFmts();
            $ret.a = new List$1(CT_BandFmt.$, 0);
            return $ret;
        })());
        for (let h = 0; h < c; h++) {
            let i = ChartSerializer.a(b, h);
            let j = ((() => {
                let $ret = new CT_BandFmt();
                $ret.a = ((() => {
                    let $ret = new CT_UnsignedInt();
                    $ret.g = intSToU(h);
                    return $ret;
                })());
                $ret.c = ChartSerializer.a5(a, i, null, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            g.a.add(j);
        }
        return g;
    }
    static bt(a, b, c, d, e, f, g = false) {
        a.a = CT_UnsignedInt.a(e);
        let h = c.chart;
        let i = h != null ? h._seriesCollection$i : null;
        let j = Nullable$1.toNullable(Number_$type, null);
        if (i != null) {
            j = i._aq(c);
        }
        if (j.hasValue) {
            a.b = CT_UnsignedInt.a(j.value);
        }
        if (c.name != null) {
            a.c = DMLChartUtils.z(c.name, b, d);
        }
        let k = f ? c.fill : null;
        let l = f ? typeCast(ChartLineBase.$, c.border) : c.line != null ? typeCast(ChartLineBase.$, c.line) : null;
        let m = c.chart;
        let n = f ? false : m != null && m._gt == false;
        if (f == false) {
            if (l == null) {
                l = new ChartLine();
            }
            if (l.fill == null) {
                l.fill = k;
            }
            k = null;
        }
        a.d = ChartSerializer.a5(b, k, l, Nullable$1.toNullable(BorderLineStyle_$type, null));
        if (f == false && g && (l == null || l.fill == null)) {
            if (a.d.a == null) {
                a.d.a = new CT_LineProperties_DML();
            }
            a.d.a.n.i();
        }
    }
    static bs(a, b, c, d) {
        a.a = CT_Boolean.b(b.varyColors);
        for (let e = 0; e < b._seriesCollection$i.count; e++) {
            let f = b._seriesCollection$i.item(e);
            let g = ChartSerializer.am(b, f, intSToU(e), d);
            a.d.add(g);
        }
    }
    static a(a, b) {
        return ExcelUtils.p(a, b);
    }
    static w(a, b) {
        let c = a.sheet;
        let d = b.errorBars;
        if (d == null) {
            return null;
        }
        let e = ((() => {
            let $ret = new CT_ErrBars();
            $ret.e = ((() => {
                let $ret = new CT_ErrBarType();
                $ret.b = DMLChartExtensions.ae(d.direction);
                return $ret;
            })());
            $ret.i = ((() => {
                let $ret = new CT_ErrValType();
                $ret.b = DMLChartExtensions.af(d.errorValueType);
                return $ret;
            })());
            return $ret;
        })());
        e.c = CT_Double.a(d.value);
        if (e.o == null) {
            e.o = new CT_ShapeProperties_DML();
        }
        if (e.o.a == null) {
            e.o.a = new CT_LineProperties_DML();
        }
        if (d.fill != null) {
            ChartSerializerExtensions.a3(EG_LineFillProperties.$, e.o.a.n, d.fill, c);
        }
        e.o.a.q = Nullable$1.toNullable(Number_$type, ExcelUtils.dh(d.widthInPoints));
        e.a = CT_Boolean.b(d.endStyle == 2);
        return e;
    }
    static e(a, b) {
        let c = a.sheet;
        let d = b.xValues;
        if (d == null) {
            return null;
        }
        let e = d._t();
        if (e == null || e.length == 0) {
            return null;
        }
        let f = new CT_AxDataSource();
        let g = d._ac > 1;
        ;
        if (g) {
            let h = intDivide(e.length, d._ac);
            f.a = new CT_MultiLvlStrRef();
            f.a.a = ((() => {
                let $ret = new CT_MultiLvlStrData();
                $ret.b = CT_UnsignedInt.a(intSToU(h));
                return $ret;
            })());
            let i = null;
            let j = new List$1(List$1.$.specialize(String_$type), 2, d._ac);
            for (let k = 0; k < d._ac; k++) {
                j.add(new List$1(String_$type, 2, h));
            }
            for (let l = 0; l < e.length; l++) {
                let m = l % d._ac;
                let n = e[l];
                let o = n == null ? stringEmpty() : n.toString();
                j._inner[m].add(o);
            }
            for (let p = 0; p < j.count; p++) {
                let q = j._inner[p];
                i = ((() => {
                    let $ret = new CT_Lvl();
                    $ret.a = new List$1(CT_StrVal.$, 0);
                    return $ret;
                })());
                f.a.a.d.add(i);
                for (let r = 0; r < q.count; r++) {
                    i.a.add(((() => {
                        let $ret = new CT_StrVal();
                        $ret.d = intSToU(r);
                        $ret.b = q._inner[r];
                        return $ret;
                    })()));
                }
            }
        }
        else {
            f.e = ((() => {
                let $ret = new CT_StrRef();
                $ret.a = new CT_StrData();
                return $ret;
            })());
            f.e.a.b = CT_UnsignedInt.a(intSToU(e.length));
            if (e.length > 0) {
                f.e.a.f = new List$1(CT_StrVal.$, 0);
            }
            for (let s = 0; s < e.length; s++) {
                let t = e[s];
                let u = t != null ? t.toString() : stringEmpty();
                f.e.a.f.add(((() => {
                    let $ret = new CT_StrVal();
                    $ret.d = intSToU(s);
                    $ret.b = u;
                    return $ret;
                })()));
            }
        }
        if (d._f != null) {
            let v = d._f._toString1(c._c);
            v = SerializationUtils.u(v);
            if (g) {
                if (f.a == null) {
                    f.a = new CT_MultiLvlStrRef();
                }
                f.a.e = v;
            }
            else {
                if (f.e == null) {
                    f.e = new CT_StrRef();
                }
                f.e.e = v;
            }
        }
        return f;
    }
    static f(a, b) {
        let c = a.sheet;
        if (b == null) {
            return null;
        }
        let d = null;
        let e = b.getValues();
        if (e == null || e.length == 0) {
            return null;
        }
        let f = new CT_AxDataSource();
        let g = typeCast(XValues.$, b);
        if (g != null && g._ab == 2) {
            f.c = ChartSerializer.ai(e);
            if (b._f != null) {
                d = b._f._toString1(c._c);
                d = SerializationUtils.u(d);
                f.c.e = d;
            }
            return f;
        }
        f.e = ((() => {
            let $ret = new CT_StrRef();
            $ret.a = new CT_StrData();
            return $ret;
        })());
        f.e.a.b = CT_UnsignedInt.a(intSToU(e.length));
        if (e.length > 0) {
            f.e.a.f = new List$1(CT_StrVal.$, 0);
        }
        for (let h = 0; h < e.length; h++) {
            let i = e[h];
            let j = i != null ? i.toString() : stringEmpty();
            f.e.a.f.add(((() => {
                let $ret = new CT_StrVal();
                $ret.d = intSToU(h);
                $ret.b = j;
                return $ret;
            })()));
        }
        if (b._f != null) {
            d = b._f._toString1(c._c);
            d = SerializationUtils.u(d);
            if (f.e == null) {
                f.e = new CT_StrRef();
            }
            f.e.e = d;
        }
        return f;
    }
    static ad(a, b) {
        return ChartSerializer.ae(a, b.values, b);
    }
    static ae(a, b, c) {
        let d = a.sheet;
        if (b == null) {
            return null;
        }
        let e = new CT_NumDataSource();
        let f = b.getValues();
        e.b = ChartSerializer.ai(f);
        if (b._f != null) {
            let g = b._f._toString1(d._c);
            g = SerializationUtils.u(g);
            if (e.b == null) {
                e.b = new CT_NumRef();
            }
            e.b.e = g;
        }
        return e;
    }
    static af(a, b) {
        let c = b.values;
        if (c == null) {
            return null;
        }
        let d = a.sheet;
        let e = ((() => {
            let $ret = new CT_NumDataSource();
            $ret.a = ((() => {
                let $ret = new CT_NumData();
                $ret.e = new List$1(CT_NumVal.$, 0);
                $ret.g = "General";
                return $ret;
            })());
            return $ret;
        })());
        let f = e.a.e;
        let g = c.getValues();
        for (let h = 0; h < g.length; h++) {
            let i = ((() => {
                let $ret = new CT_NumVal();
                $ret.f = intSToU(h);
                $ret.d = "1";
                return $ret;
            })());
            f.add(i);
        }
        return e;
    }
    static ai(a) {
        let b = null;
        if (a != null && a.length > 0) {
            b = new CT_NumRef();
            b.a = ((() => {
                let $ret = new CT_NumData();
                $ret.a = CT_UnsignedInt.a(intSToU(a.length));
                return $ret;
            })());
            b.a.a = CT_UnsignedInt.a(intSToU(a.length));
            b.a.e = new List$1(CT_NumVal.$, 0);
            for (let c = 0; c < a.length; c++) {
                let d = a[c];
                let e = d != null ? d.toString() : stringEmpty();
                if (SerializationUtils.l(e) == false) {
                    e = "0";
                }
                b.a.e.add(((() => {
                    let $ret = new CT_NumVal();
                    $ret.f = intSToU(c);
                    $ret.d = e;
                    return $ret;
                })()));
            }
        }
        return b;
    }
    static a6(a, b) {
        let c = new CT_SolidColorFillProperties();
        let d = b.color;
        if (WorkbookColorInfo.l_op_Equality(d, null)) {
            return null;
        }
        DMLChartExtensions.a9(c.b, d, a);
        return c;
    }
    static a2(a, b) {
        let c = ((() => {
            let $ret = new CT_GradientFillProperties();
            $ret.e = new List$1(CT_GradientStop.$, 0);
            return $ret;
        })());
        let d = b.getStops();
        for (let e of fromEnum(d)) {
            let f = ST_PositiveFixedPercentage.o(e.position);
            let g = ((() => {
                let $ret = new CT_GradientStop();
                $ret.d = new ST_PositiveFixedPercentage(1, ST_Percentage.b(f));
                return $ret;
            })());
            DMLChartExtensions.a9(g.b, e.color, a);
            c.e.add(g);
        }
        if (b.angle != 0) {
            c.b.a = ((() => {
                let $ret = new CT_LinearShadeProperties();
                $ret.a = Nullable$1.toNullable(Number_$type, ST_Angle.l(b.angle));
                $ret.c = Nullable$1.toNullable(Boolean_$type, true);
                return $ret;
            })());
        }
        let h = DMLChartExtensions.a0(b.gradientType);
        if (h.hasValue) {
            c.b.b = ((() => {
                let $ret = new CT_PathShadeProperties();
                $ret.c = Nullable$1.toNullable(ST_PathShadeType_$type, h.value);
                return $ret;
            })());
        }
        return c;
    }
    static bd(a, b) {
        let c = new CT_NoFillProperties();
        return c;
    }
    static x(a, b, c, d, e, f, g = false, h = true) {
        let i = new CT_Layout();
        if (b == -4114) {
            let j = ((() => {
                let $ret = new CT_ManualLayout();
                $ret.e = CT_Double.a(c);
                $ret.g = CT_Double.a(d);
                return $ret;
            })());
            if (e.hasValue) {
                j.c = CT_Double.a(e.value);
            }
            if (f.hasValue) {
                j.a = CT_Double.a(f.value);
            }
            if (h) {
                j.m = ((() => {
                    let $ret = new CT_LayoutMode();
                    $ret.b = 0;
                    return $ret;
                })());
                j.o = ((() => {
                    let $ret = new CT_LayoutMode();
                    $ret.b = 0;
                    return $ret;
                })());
            }
            if (g) {
                j.q = ((() => {
                    let $ret = new CT_LayoutTarget();
                    $ret.b = 0;
                    return $ret;
                })());
            }
            i.a = j;
        }
        return i;
    }
    static ba(a, b, c = null) {
        let d = new CT_TextCharacterProperties_DML();
        if (b.height > 0) {
            d.r = Nullable$1.toNullable(Number_$type, SerializationUtils.p(b.height));
        }
        if (nullableNotEquals(b._bold$i, null)) {
            d.d = Nullable$1.toNullable(Boolean_$type, (nullableEquals(b._bold$i, true)));
        }
        if (nullableNotEquals(b._italic$i, null)) {
            d.i = Nullable$1.toNullable(Boolean_$type, (nullableEquals(b._italic$i, true)));
        }
        if (nullableNotEquals(b._strikeout$i, null)) {
            d.q = Nullable$1.toNullable(ST_TextStrikeType_$type, nullableEquals(b._strikeout$i, true) ? 1 : 0);
        }
        if (b.underlineStyle != -1) {
            d.s = DMLChartExtensions.a1(b.underlineStyle);
        }
        if (b.superscriptSubscriptStyle != -1) {
            switch (b.superscriptSubscriptStyle) {
                case 0:
                    d.e = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(0));
                    break;
                case 2:
                    d.e = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(-25000));
                    break;
                case 1:
                    d.e = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(30000));
                    break;
            }
        }
        let e = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = stringIsNullOrEmpty(b.name) == false ? b.name : "+mn-lt";
            return $ret;
        })());
        let f = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = "+mn-ea";
            return $ret;
        })());
        let g = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = "+mn-cs";
            return $ret;
        })());
        d.c = e;
        d.b = f;
        d.a = g;
        let h = true;
        if (c != null) {
            ChartSerializerExtensions.a3(EG_FillProperties.$, d.ad, c, a);
            h = false;
        }
        if (h && WorkbookColorInfo.l_op_Inequality(b.colorInfo, null)) {
            d.ad.c = DMLChartExtensions.an(b.colorInfo, a);
        }
        return d;
    }
    static a9(a, b, c, d, e, f, g) {
        let h = new CT_TextBodyProperties_DML();
        if (b != 0) {
            h.af = Nullable$1.toNullable(Number_$type, ST_Angle.l(b));
        }
        if (e != 0) {
            h.ar = Nullable$1.toNullable(ST_TextVerticalType_$type, DMLChartExtensions.as(e));
        }
        if (d.hasValue) {
            h.at = Nullable$1.toNullable(ST_TextVertOverflowType_$type, DMLChartExtensions.at(d.value));
        }
        h.av = Nullable$1.toNullable(ST_TextWrappingType_$type, f ? 1 : 0);
        if (c.hasValue) {
            h.x = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, DMLChartExtensions.ar(c.value));
        }
        if (g.hasValue) {
            h.l = Nullable$1.toNullable(ST_TextAnchoringType_$type, DMLChartExtensions.aq(g.value));
            if (nullableEquals(h.l, 1)) {
                h.m = Nullable$1.toNullable(Boolean_$type, true);
            }
        }
        return h;
    }
    static ay(a, b, c, d, e, f, g) {
        if (e == null && g == null) {
            return null;
        }
        let h = new CT_Tx();
        if (g != null) {
            h.a = ((() => {
                let $ret = new CT_StrRef();
                $ret.e = g._toString1(a._c);
                return $ret;
            })());
        }
        if (e != null) {
            h.b = ChartSerializer.a7(b, c, e, f, a);
        }
        return h;
    }
    static a7(a, b, c, d, e, f = null, g = false) {
        let h = null;
        h = ((() => {
            let $ret = new CT_TextBody_DML();
            $ret.a = a;
            return $ret;
        })());
        let i = ((() => {
            let $ret = new CT_TextParagraph_DML();
            $ret.c = ChartSerializer.bb(e, b, d);
            return $ret;
        })());
        i.c.a = ChartSerializer.ba(e, b, f);
        if (g) {
            i.a = typeCast(CT_TextCharacterProperties_DML.$, i.c.a);
        }
        h.d.add(i);
        if (c != null) {
            let j = c._c();
            if (j.length > 0) {
                for (let l = 0; l < j.length; l++) {
                    let k = j[l];
                    let m = null;
                    if (k.h) {
                        m = k.d(e.workbook);
                    }
                    let n = ((() => {
                        let $ret = new CT_RegularTextRun_DML();
                        $ret.a = m != null ? ChartSerializer.ba(e, m) : null;
                        $ret.c = k.l;
                        return $ret;
                    })());
                    i.f.add(((() => {
                        let $ret = new EG_TextRun();
                        $ret.a = n;
                        return $ret;
                    })()));
                }
            }
            else {
                let o = ((() => {
                    let $ret = new CT_RegularTextRun_DML();
                    $ret.c = c.unformattedString;
                    return $ret;
                })());
                i.f.add(((() => {
                    let $ret = new EG_TextRun();
                    $ret.a = o;
                    return $ret;
                })()));
            }
        }
        return h;
    }
    static a8(a, b, c, d, e) {
        return ChartSerializer.a7(b, c, null, e, a, d);
    }
    static bb(a, b, c) {
        let d = ((() => {
            let $ret = new CT_TextParagraphProperties_DML();
            $ret.a = ChartSerializer.ba(a, b);
            $ret.m = DMLChartExtensions.a2(c);
            return $ret;
        })());
        return d;
    }
    static a3(a, b) {
        return ChartSerializer.a4(a, b, Nullable$1.toNullable(BorderLineStyle_$type, b.lineStyle));
    }
    static a4(a, b, c) {
        let d = b != null ? b.widthInPoints : 0.75;
        let e = ExcelUtils.dh(d);
        let f = ((() => {
            let $ret = new CT_LineProperties_DML();
            $ret.h = Nullable$1.toNullable(ST_LineWidth.$, null);
            $ret.q = Nullable$1.toNullable(Number_$type, e);
            return $ret;
        })());
        if (c.hasValue) {
            f.l.b = ((() => {
                let $ret = new CT_PresetLineDashProperties();
                $ret.a = DMLChartExtensions.ay(c.value);
                return $ret;
            })());
        }
        if (b != null) {
            let g = typeCast(ChartSolidFill.$, b.fill);
            let h = g == null ? typeCast(ChartGradientFill.$, b.fill) : null;
            let i = g == null && h == null ? typeCast(ChartEmptyFill.$, b.fill) : null;
            if (g != null) {
                f.n.c = ChartSerializer.a6(a, g);
            }
            else if (h != null) {
                f.n.a = ChartSerializer.a2(a, h);
            }
            else if (i != null) {
                f.n.d = ChartSerializer.bd(a, i);
            }
        }
        return f;
    }
    static a5(a, b, c, d) {
        if (d.hasValue == false && c != null && c._ai.hasValue) {
            d = Nullable$1.toNullable(BorderLineStyle_$type, DMLChartExtensions.d(c._ai.value));
        }
        let e = new CT_ShapeProperties_DML();
        let f = typeCast(ChartSolidFill.$, b);
        let g = f == null ? typeCast(ChartGradientFill.$, b) : null;
        let h = g == null && f == null ? typeCast(ChartEmptyFill.$, b) : null;
        if (f != null) {
            let i = ChartSerializer.a6(a, f);
            e.l.c = i;
        }
        else if (g != null) {
            let j = ChartSerializer.a2(a, g);
            e.l.a = j;
        }
        else if (h != null) {
            let k = ChartSerializer.bd(a, h);
            e.l.d = k;
        }
        if (c != null) {
            e.a = ChartSerializer.a4(a, c, d);
        }
        e.j.b = new CT_EffectList();
        return e;
    }
    static aw(a, b) {
        if (b == null) {
            return null;
        }
        let c = ChartSerializer.a9(a, b.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, b.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, b.verticalOverflow), b.textDirection, b.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, b.verticalAlignment));
        let d = ((() => {
            let $ret = new CT_Title();
            $ret.a = CT_Boolean.b(b.overlay);
            $ret.c = ChartSerializer.x(a, b.position, b.left, b.top, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null));
            $ret.g = ChartSerializer.a5(a, b.fill, b.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            $ret.e = ChartSerializer.ay(a, c, b.defaultFont, null, b.text, b.readingOrder, b._a5);
            $ret.i = ChartSerializer.a8(a, c, b.defaultFont, null, b.readingOrder);
            return $ret;
        })());
        return d;
    }
    static ax(a, b) {
        if (b == null) {
            return null;
        }
        let c = ((() => {
            let $ret = new CT_Trendline();
            $ret.q = ((() => {
                let $ret = new CT_TrendlineType();
                $ret.b = DMLChartExtensions.am(b.trendlineType);
                return $ret;
            })());
            $ret.e = b.backward != 0 ? ((() => {
                let $ret = new CT_Double();
                $ret.f = b.backward;
                return $ret;
            })()) : null;
            $ret.g = b.forward != 0 ? ((() => {
                let $ret = new CT_Double();
                $ret.f = b.forward;
                return $ret;
            })()) : null;
            $ret.w = b.name;
            return $ret;
        })());
        if (b._intercept$i.hasValue) {
            c.i = CT_Double.a(b._intercept$i.value);
        }
        let d = b.label;
        if (d != null) {
            let e = new CT_TrendlineLbl();
            e.a = ChartSerializer.x(a, d.position, d.left, d.top, Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(Number_$type, null), false, false);
            if (stringIsNullOrEmpty(d.numberFormat) == false) {
                e.c = ChartSerializer.ag(d);
            }
            let f = ChartSerializer.a9(a, d.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, d.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, d.verticalOverflow), d.textDirection, d.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, d.verticalAlignment));
            e.e = ChartSerializer.ay(a, f, d.defaultFont, null, d.text, d.readingOrder, d._a5);
            e.i = ChartSerializer.a8(a, f, d.defaultFont, null, d.readingOrder);
            if (d.fill != null || d.border != null) {
                e.g = ChartSerializer.a5(a, d.fill, d.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            }
            c.o = e;
        }
        c.a = CT_Boolean.b(d != null ? d.displayEquation : false);
        c.c = CT_Boolean.b(d != null ? d.displayRSquared : false);
        switch (b.trendlineType) {
            case 4:
                c.k = ((() => {
                    let $ret = new CT_Order();
                    $ret.b = b.order;
                    return $ret;
                })());
                break;
            case 3:
                c.m = ((() => {
                    let $ret = new CT_Period();
                    $ret.b = b.period;
                    return $ret;
                })());
                break;
        }
        if (b.line != null) {
            c.s = new CT_ShapeProperties_DML();
            let g = DMLChartExtensions.d(b.line.lineStyle);
            c.s.a = ChartSerializer.a4(a, b.line, Nullable$1.toNullable(BorderLineStyle_$type, g));
        }
        return c;
    }
    static bj(a, b) {
        if (b == null || b._bw == false) {
            return null;
        }
        let c = b.chart;
        if (c != null && WorksheetChart._f6(c.chartType)) {
            return null;
        }
        let d = new List$1(CT_Trendline.$, 2, b._trendlineCollection$i.count);
        for (let e of fromEnum(b._trendlineCollection$i)) {
            let f = ChartSerializer.ax(a, e);
            if (f != null) {
                d.add(f);
            }
        }
        return d;
    }
    static u(a, b) {
        if (b == null || b.showDataLabels == false) {
            return null;
        }
        let c = ((() => {
            let $ret = new CT_DLbls();
            $ret.b = new CT_ExtensionList();
            return $ret;
        })());
        let d = b._dataPointCollection$i;
        for (let e = 0; e < d.count; e++) {
            let f = d.item(e);
            if (f.dataLabel == null) {
                continue;
            }
            let g = ChartSerializer.t(f.dataLabel, b, e, a);
            c.f.add(g);
        }
        let h = b.dataLabels;
        let i = h != null ? h.defaultFont : null;
        if (h != null) {
            ChartSerializerExtensions.a(c.e.d, h, b, a);
        }
        c.e.a = CT_Boolean.b(h.showLeaderLines);
        let j = ((() => {
            let $ret = new CT_Extension_DataLabels();
            $ret.b = "{CE6537A1-D6FC-4f65-9D91-7224C49458BB}";
            $ret.g = CT_Boolean.b(b.dataLabels.showLeaderLines);
            $ret.f = CT_Boolean.b(stringIsNullOrEmpty(h._ea) == false);
            return $ret;
        })());
        if (b.leaderLines != null) {
            j.h = ChartSerializer.r(a, b.chart, b.leaderLines);
        }
        c.b.e.add(j);
        return c;
    }
    static t(a, b, c, d) {
        let e = new CT_DLbl();
        e.b = CT_UnsignedInt.a(intSToU(c));
        ChartSerializerExtensions.a(e.d.d, a, b, d);
        if (a.left > 0 || a.top > 0) {
            e.d.a = ((() => {
                let $ret = new CT_Layout();
                $ret.a = ((() => {
                    let $ret = new CT_ManualLayout();
                    $ret.e = CT_Double.a(a.left);
                    $ret.g = CT_Double.a(a.height);
                    return $ret;
                })());
                return $ret;
            })());
        }
        let f = null;
        if (a.width > 0 || a.height > 0) {
            f = ((() => {
                let $ret = new CT_Layout();
                $ret.a = ((() => {
                    let $ret = new CT_ManualLayout();
                    $ret.c = CT_Double.a(a.width);
                    $ret.a = CT_Double.a(a.height);
                    return $ret;
                })());
                return $ret;
            })());
        }
        let g = stringIsNullOrEmpty(b.dataLabels._ea) == false;
        if (f != null || g) {
            e.e = new List$1(CT_Extension.$, 0);
            let h = ((() => {
                let $ret = new CT_Extension_DataLabels();
                $ret.j = f;
                $ret.f = CT_Boolean.b(g);
                return $ret;
            })());
            e.e.add(h);
        }
        if (a.text != null) {
            let i = ChartSerializer.a9(d, a.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, a.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, a.verticalOverflow), a.textDirection, a.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, null));
            e.d.b = ChartSerializer.ay(d, i, a._cl, null, a.text, a.readingOrder, a._a5);
        }
        return e;
    }
    static ac(a, b, c, d, e, f) {
        let g = null;
        let h = Nullable$1.toNullable(MarkerStyle_$type, null);
        if (f.hasValue) {
            h = WorksheetChart._iz(f.value);
        }
        if (b == -4105 && h.hasValue) {
            b = h.value;
        }
        let i = b != -4105 || c.hasValue || d != null || e != null;
        if (i) {
            g = ((() => {
                let $ret = new CT_Marker_Chart();
                $ret.e = ChartSerializer.a5(a, d, e, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            if (c.hasValue) {
                g.a = ((() => {
                    let $ret = new CT_MarkerSize();
                    $ret.b = c.value;
                    return $ret;
                })());
            }
            if (b != -4105) {
                g.c = ((() => {
                    let $ret = new CT_MarkerStyle();
                    $ret.a = DMLChartExtensions.ap(b);
                    return $ret;
                })());
            }
        }
        return g;
    }
    static ag(a) {
        if (a == null) {
            return null;
        }
        return ChartSerializer.ah(a.numberFormat, a.numberFormatLinked);
    }
    static ah(a, b, c = false) {
        if (stringIsNullOrEmpty(a)) {
            if (c) {
                return null;
            }
            else {
                a = "General";
            }
        }
        else {
        }
        let d = ((() => {
            let $ret = new CT_NumFmt_Chart();
            $ret.c = a;
            $ret.a = b;
            return $ret;
        })());
        return d;
    }
    static az(a, b) {
        if (a == null) {
            return null;
        }
        let c = ((() => {
            let $ret = new CT_UpDownBars();
            $ret.a = ((() => {
                let $ret = new CT_GapAmount();
                $ret.c = a.gapWidth;
                return $ret;
            })());
            return $ret;
        })());
        let d = a.upBar;
        let e = a.downBar;
        c.e = ((() => {
            let $ret = new CT_UpDownBar();
            $ret.a = ChartSerializer.a5(b, d.fill, d.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            return $ret;
        })());
        c.c = ((() => {
            let $ret = new CT_UpDownBar();
            $ret.a = ChartSerializer.a5(b, e.fill, e.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            return $ret;
        })());
        return c;
    }
    static bk(a, b = Nullable$1.toNullable(AxisGroup_$type, null), c = true) {
        let d = new List$1(CT_UnsignedInt.$, 0);
        for (let e = 0; e < a.count; e++) {
            let f = a._inner[e];
            if (c && f.type == 3) {
                continue;
            }
            if (b.hasValue && f.axisGroup != b.value) {
                continue;
            }
            d.add(((() => {
                let $ret = new CT_UnsignedInt();
                $ret.g = intSToU(f._cg);
                return $ret;
            })()));
        }
        return d;
    }
}
ChartSerializer.$t = markType(ChartSerializer, 'ChartSerializer');
/**
 * @hidden
 */
export class ChartExSerializer extends Base {
    constructor(a) {
        super();
        this.k = null;
        this.k = a;
    }
    p(a, b, c, d) {
        if (a == null) {
            return;
        }
        ChartExSerializer.r(a);
        let e = this.k;
        let f = e != null ? e.workbook : null;
        if (f == null) {
            return;
        }
        let g = new CT_ChartSpaceEx();
        let h = c._aq;
        g.b = ChartExSerializer.b(a, h);
        g.d = new CT_ChartEx();
        if (a.chartTitle != null) {
            g.d.a = ChartExSerializer.c(a.chartTitle, e);
        }
        g.d.e = new CT_PlotAreaEx();
        g.d.e.a = new CT_PlotAreaRegion();
        let i = a.chartArea.fill;
        let j = a.chartArea.border;
        if (i != null || j != null) {
            g.j = ChartSerializer.a5(e, i, j, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        let k = a.plotArea.fill;
        let l = a.plotArea.border;
        if (k != null || l != null) {
            let m = ((() => {
                let $ret = new CT_PlotSurface();
                $ret.a = ChartSerializer.a5(e, k, l, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            g.d.e.a.a = m;
        }
        if (a.legend != null) {
            g.d.c = ChartExSerializer.f(a.legend, e);
        }
        ;
        let n = ChartExSerializer.l(a, g.b, e, c);
        for (let o of fromEnum(n)) {
            g.d.e.a.c.add(o);
        }
        ChartExExtensions.u(g.d.e.d, a, e, c);
        ChartExExtensions.ag(g, b, c, d, ChartExElements.m);
    }
    static l(a, b, c, d) {
        let e = new Dictionary$2(Series.$, CT_Series.$, 0);
        for (let f = 0; f < a._seriesCollection$i.count; f++) {
            let g = a._seriesCollection$i.item(f);
            let h = ChartExSerializer.h(g, f, b, c, d);
            e.addItem(g, h);
        }
        for (let i of fromEnum(a._seriesCollection$i)) {
            if (i.owningSeries != null) {
                let j = null;
                let k = null;
                let l = e.tryGetValue(i, j);
                j = l.p1;
                let m = e.tryGetValue(i.owningSeries, k);
                k = m.p1;
                if (j != null && k != null) {
                    j.y = Nullable$1.toNullable(Number_$type, intSToU(k.t));
                }
            }
        }
        return e.values;
    }
    static h(a, b, c, d, e) {
        if (a == null) {
            return null;
        }
        let f = a.chart;
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = null;
        if (((() => { let i = c.b.tryGetValue(a, h); h = i.p1; return i.ret; })())) {
            g = Nullable$1.toNullable(Number_$type, h.f);
        }
        let i = ((() => {
            let $ret = new CT_Series();
            $ret.m = ChartExExtensions.p(a.chartType);
            $ret.t = b;
            return $ret;
        })());
        if (g.hasValue) {
            i.a = ((() => {
                let $ret = new CT_DataId();
                $ret.b = g.value;
                return $ret;
            })());
        }
        let j = ChartExSerializer.m(a, f);
        if (j.hasValue) {
            i.q.add(j.value);
        }
        let k = a.name;
        if (k != null && k._d != null) {
            let l = null;
            if (((() => { let m = e._aq.tryGetValue(k._d, l); l = m.p1; return m.ret; })())) {
                i.g = ((() => {
                    let $ret = new CT_Text();
                    $ret.a = ((() => {
                        let $ret = new CT_TextData();
                        $ret.a = ((() => {
                            let $ret = new CT_Formula();
                            $ret.b = 0;
                            $ret.d = l;
                            return $ret;
                        })());
                        return $ret;
                    })());
                    return $ret;
                })());
            }
        }
        let m = a.fill;
        let n = null;
        if (ChartExDeserializer.e(a.chartType)) {
            n = a.line;
        }
        else {
            n = a.border;
        }
        if (m != null || n != null) {
            i.o = ChartSerializer.a5(d, m, n, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        i.e = ChartExSerializer.i(a, f.chartType, d);
        for (let o = 0; o < a._dataPointCollection$i.count; o++) {
            let p = a._dataPointCollection$i.item(o);
            if (p.fill == null && p.border == null) {
                continue;
            }
            let q = ((() => {
                let $ret = new CT_DataPoint();
                $ret.d = intSToU(o);
                $ret.a = ChartSerializer.a5(d, p.fill, p.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
                return $ret;
            })());
            i.r.add(q);
        }
        if (a.showDataLabels) {
            let r = a.dataLabels;
            i.c = ((() => {
                let $ret = new CT_DataLabels();
                $ret.g = Nullable$1.toNullable(ST_DataLabelPos_$type, ChartExExtensions.k(DMLChartExtensions.f(a.dataLabels.labelPosition, a.chartType)));
                $ret.b = ChartExSerializer.g(r.numberFormat, r.numberFormatLinked);
                $ret.a = ChartExSerializer.e(r);
                $ret.h = r.separator;
                return $ret;
            })());
            let s = ChartSerializer.a9(d, r.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, r.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, r.verticalOverflow), r.textDirection, r.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, r.verticalAlignment));
            i.c.d = ChartSerializer.a8(d, s, r.defaultFont, null, r.readingOrder);
            if (r.fill != null || r.border != null) {
                i.c.c = ChartSerializer.a5(d, r.fill, r.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
            }
            let t = null;
            for (let u = 0; u < a._dataPointCollection$i.count; u++) {
                let v = a._dataPointCollection$i.item(u).dataLabel;
                if (v == null) {
                    continue;
                }
                if (v.isDeleted) {
                    if (t == null) {
                        t = new List$1(Number_$type, 0);
                    }
                    t.add(u);
                    continue;
                }
            }
            if (t != null && t.count > 0) {
                for (let w of fromEnum(t)) {
                    i.c.j.add(((() => {
                        let $ret = new CT_DataLabelHidden();
                        $ret.b = intSToU(w);
                        return $ret;
                    })()));
                }
            }
            for (let x = 0; x < a._dataPointCollection$i.count; x++) {
                let y = a._dataPointCollection$i.item(x);
                let z = y.dataLabel;
                if (z == null) {
                    continue;
                }
                let aa = ChartExSerializer.d(z, a, x, d);
                i.c.i.add(aa);
            }
        }
        if (a.chartType == 121) {
            ChartExSerializer.q(a, i, d, e);
        }
        return i;
    }
    static q(a, b, c, d) {
        if (a == null || b == null) {
            return;
        }
        let e = a.geographicMapSettings;
        if (e == null) {
            e = GeographicMapSettings._c();
        }
        let f = ((() => {
            let $ret = new CT_Geography();
            $ret.h = e.attribution;
            $ret.j = e.cultureLanguage;
            $ret.l = e.cultureRegion;
            $ret.a = ((() => {
                let $ret = new CT_GeoCache();
                $ret.b = null;
                $ret.a = new CT_Clear();
                $ret.c = e._m;
                return $ret;
            })());
            return $ret;
        })());
        if (e._projection$i.hasValue) {
            f.d = Nullable$1.toNullable(ST_GeoProjectionType_$type, ChartExExtensions.m(e._projection$i.value));
        }
        if (e._area$i.hasValue) {
            f.f = Nullable$1.toNullable(ST_GeoMappingLevel_$type, ChartExExtensions.l(e._area$i.value));
        }
        b.e.g = ((() => {
            let $ret = new CT_RegionLabelLayout();
            $ret.a = ChartExExtensions.o(e.labels);
            return $ret;
        })());
        if (e.colors != null) {
            if (e.colors.seriesColor == 1) {
                b.i = ((() => {
                    let $ret = new CT_ValueColorPositions();
                    $ret.h = Nullable$1.toNullable(Number_$type, 3);
                    return $ret;
                })());
            }
            let g = e.colors.minimum;
            let h = e.colors.midpoint;
            let i = e.colors.maximum;
            if (WorkbookColorInfo.l_op_Inequality(g, null) || WorkbookColorInfo.l_op_Inequality(h, null) || WorkbookColorInfo.l_op_Inequality(i, null)) {
                b.k = new CT_ValueColors();
                if (WorkbookColorInfo.l_op_Inequality(g, null)) {
                    b.k.e = new CT_SolidColorFillProperties();
                    DMLChartExtensions.a9(b.k.e.b, g, c);
                }
                if (WorkbookColorInfo.l_op_Inequality(h, null)) {
                    b.k.c = new CT_SolidColorFillProperties();
                    DMLChartExtensions.a9(b.k.c.b, h, c);
                }
                if (WorkbookColorInfo.l_op_Inequality(i, null)) {
                    b.k.a = new CT_SolidColorFillProperties();
                    DMLChartExtensions.a9(b.k.a.b, i, c);
                }
            }
        }
        b.e.c = f;
    }
    static m(a, b) {
        let c = Nullable$1.toNullable(Number_$type, null);
        switch (b.chartType) {
            case 114:
            case 117:
            case 116:
            case 120:
            case 115:
                c = Nullable$1.toNullable(Number_$type, a._z._cg);
                break;
            case 118:
            case 119:
            case 121: break;
        }
        if (c.hasValue) {
            return Nullable$1.toNullable(ST_AxisId.$, ((() => {
                let $ret = new ST_AxisId();
                $ret.h = intSToU(c.value);
                return $ret;
            })()));
        }
        return Nullable$1.toNullable(ST_AxisId.$, null);
    }
    static g(a, b) {
        return ((() => {
            let $ret = new CT_NumberFormat();
            $ret.c = a;
            $ret.a = Nullable$1.toNullable(Boolean_$type, b);
            return $ret;
        })());
    }
    static d(a, b, c, d) {
        if (a == null) {
            return null;
        }
        let e = ((() => {
            let $ret = new CT_DataLabel();
            $ret.i = intSToU(c);
            $ret.g = Nullable$1.toNullable(ST_DataLabelPos_$type, ChartExExtensions.k(DMLChartExtensions.f(a.labelPosition, b.chartType)));
            $ret.b = ChartExSerializer.g(a.numberFormat, a.numberFormatLinked);
            $ret.a = ChartExSerializer.e(a);
            $ret.h = a.separator;
            return $ret;
        })());
        let f = a.fill;
        let g = a.border;
        if (f != null || g != null) {
            e.c = ChartSerializer.a5(d, f, g, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        let h = ChartSerializer.a9(d, a.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, a.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, a.verticalOverflow), a.textDirection, a.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, a.verticalAlignment));
        if (h != null) {
            h.j.c = new CT_TextShapeAutofit();
        }
        e.d = ChartSerializer.a7(h, a.defaultFont, a.text, a.readingOrder, d);
        if (e.d != null) {
            e.d.b = new CT_TextListStyle_DML();
        }
        return e;
    }
    static e(a) {
        if (a == null) {
            return null;
        }
        let b = typeCast(SeriesDataLabels.$, a);
        if (b == null && nullableEquals(a._showCategoryName$i, null) && nullableEquals(a._showSeriesName$i, null) && nullableEquals(a._showValue$i, null)) {
            return null;
        }
        let c = new CT_DataLabelVisibilities();
        if (nullableNotEquals(a._showCategoryName$i, null)) {
            c.a = Nullable$1.toNullable(Boolean_$type, (nullableEquals(a._showCategoryName$i, true)));
        }
        if (nullableNotEquals(a._showSeriesName$i, null)) {
            c.c = Nullable$1.toNullable(Boolean_$type, (nullableEquals(a._showSeriesName$i, true)));
        }
        if (nullableNotEquals(a._showValue$i, null)) {
            c.e = Nullable$1.toNullable(Boolean_$type, (nullableEquals(a._showValue$i, true)));
        }
        return c;
    }
    static i(a, b, c) {
        if (WorksheetChart._f9(b) == false) {
        }
        let d = new CT_SeriesLayoutProperties();
        switch (a.chartType) {
            case 114:
                let e = a.boxAndWhiskerSettings;
                let f = e != null ? e.showMeanLine : false;
                let g = e != null ? e.showMeanMarkers : true;
                let h = e != null ? e.showInnerPoints : false;
                let i = e != null ? e.showOutlierPoints : true;
                d.i = ((() => {
                    let $ret = new CT_SeriesElementVisibilities();
                    $ret.d = Nullable$1.toNullable(Boolean_$type, f);
                    $ret.f = Nullable$1.toNullable(Boolean_$type, g);
                    $ret.h = Nullable$1.toNullable(Boolean_$type, h);
                    $ret.j = Nullable$1.toNullable(Boolean_$type, i);
                    return $ret;
                })());
                let j = (e != null && e.quartileCalculation == 0) ? 0 : 1;
                d.k = ((() => {
                    let $ret = new CT_Statistics();
                    $ret.a = Nullable$1.toNullable(ST_QuartileMethod_$type, j);
                    return $ret;
                })());
                break;
            case 51:
                let k = a.axisBinning;
                if (k != null) {
                    d.b = new CT_Binning();
                    d.b.h = Nullable$1.toNullable(ST_IntervalClosedSide_$type, (k._a == 0) ? 0 : 1);
                    if (k._binWidth$i.hasValue) {
                        d.b.a = CT_Double.a(k._binWidth$i.value);
                    }
                    if (k._numberOfBins$i.hasValue) {
                        d.b.b = CT_UnsignedInt.a(intSToU(k._numberOfBins$i.value));
                    }
                    if (k._overflowThreshold$i.hasValue) {
                        d.b.d = ((() => {
                            let $ret = new ST_DoubleOrAutomatic();
                            $ret.b = Nullable$1.toNullable(Number_$type, k._overflowThreshold$i.value);
                            return $ret;
                        })());
                    }
                    else if (k.overflow) {
                        d.b.d = new ST_DoubleOrAutomatic();
                    }
                    if (k._underflowThreshold$i.hasValue) {
                        d.b.f = ((() => {
                            let $ret = new ST_DoubleOrAutomatic();
                            $ret.b = Nullable$1.toNullable(Number_$type, k._underflowThreshold$i.value);
                            return $ret;
                        })());
                    }
                    else if (k.underflow) {
                        d.b.f = new ST_DoubleOrAutomatic();
                    }
                }
                else {
                    d.a = new CT_Aggregation();
                }
                break;
            case 119:
                d.e = ((() => {
                    let $ret = new CT_ParentLabelLayout();
                    $ret.a = ChartExExtensions.n(a.dataLabels.parentLabelLayout);
                    return $ret;
                })());
                break;
            case 120:
                d.i = ((() => {
                    let $ret = new CT_SeriesElementVisibilities();
                    $ret.b = Nullable$1.toNullable(Boolean_$type, a.showWaterfallConnectorLines);
                    return $ret;
                })());
                let l = false;
                for (let m = 0; m < a._dataPointCollection$i.count; m++) {
                    let n = a._dataPointCollection$i.item(m);
                    if (n.setAsTotal == true) {
                        l = true;
                        break;
                    }
                }
                if (l) {
                    d.m = new CT_Subtotals();
                    for (let o = 0; o < a._dataPointCollection$i.count; o++) {
                        let p = a._dataPointCollection$i.item(o);
                        if (p.setAsTotal == false) {
                            continue;
                        }
                        d.m.a.add(intSToU(o));
                    }
                }
                break;
            case 115:
                d = null;
                break;
        }
        return d;
    }
    static c(a, b) {
        if (a == null) {
            return null;
        }
        let c = ((() => {
            let $ret = new CT_ChartTitle();
            $ret.k = Nullable$1.toNullable(Boolean_$type, a.overlay);
            return $ret;
        })());
        let d;
        let e;
        let f = ChartExSerializer.n(a.position, d, e);
        d = f.p1;
        e = f.p2;
        c.l = Nullable$1.toNullable(ST_SidePos_$type, d);
        c.j = Nullable$1.toNullable(ST_PosAlign_$type, e);
        ChartExSerializer.o(c, a, b, false);
        return c;
    }
    static a(a, b) {
        if (a == null) {
            return null;
        }
        let c = new CT_AxisTitle();
        ChartExSerializer.o(c, a, b, true);
        return c;
    }
    static o(a, b, c, d) {
        if (a == null || b == null) {
            return;
        }
        if (b._cc() == false) {
            return;
        }
        a.b = ChartSerializer.a5(c, b.fill, b.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
        let e = ChartSerializer.a9(c, b.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, b.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, b.verticalOverflow), b.textDirection, b.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, b.verticalAlignment));
        let f = b._b7;
        a.a = ((() => {
            let $ret = new CT_Text();
            $ret.b = ChartSerializer.a7(e, f, b.text, b.readingOrder, c);
            return $ret;
        })());
    }
    static n(a, b, c) {
        b = 1;
        c = 1;
        switch (a) {
            case -4105:
            case -4114:
            case 100: break;
            case 101:
                b = 0;
                c = 1;
                break;
            case 102:
                b = 2;
                c = 1;
                break;
            case 103:
                b = 3;
                c = 1;
                break;
            case 104:
                b = 1;
                c = 0;
                break;
            case 105:
                b = 1;
                c = 2;
                break;
            case 106:
                b = 3;
                c = 0;
                break;
            case 107:
                b = 3;
                c = 2;
                break;
            case 108:
                b = 0;
                c = 0;
                break;
            case 109:
                b = 0;
                c = 2;
                break;
            case 110:
                b = 2;
                c = 0;
                break;
            case 111:
                b = 2;
                c = 2;
                break;
        }
        return {
            p1: b,
            p2: c
        };
    }
    static b(a, b) {
        let c = a._seriesCollection$i;
        let d = ((() => {
            let $ret = new CT_ChartData();
            $ret.b = new Dictionary$2(Series.$, CT_Data.$, 0);
            return $ret;
        })());
        for (let e of fromEnum(c)) {
            let f = e._b1 ? e.xValues : null;
            let g = e._b0 ? e.values : null;
            if (f == null && g == null) {
                continue;
            }
            let h = new CT_Data();
            if (f != null) {
                let i = null;
                if (((() => { let j = b.tryGetValue(f._f, i); i = j.p1; return j.ret; })()) == false) {
                }
                else {
                    let j = f._ad.hasValue && f._ad.value ? 1 : 0;
                    h.b = ((() => {
                        let $ret = new CT_StringDimension();
                        $ret.c = 0;
                        $ret.a = ((() => {
                            let $ret = new CT_Formula();
                            $ret.b = j;
                            $ret.d = i;
                            return $ret;
                        })());
                        return $ret;
                    })());
                }
            }
            if (g != null) {
                let k = null;
                if (((() => { let l = b.tryGetValue(g._f, k); k = l.p1; return l.ret; })()) == false) {
                }
                else {
                    let l = 0;
                    if (g._v) {
                        h.c = ((() => {
                            let $ret = new CT_StringDimension();
                            $ret.c = 1;
                            $ret.a = ((() => {
                                let $ret = new CT_Formula();
                                $ret.b = l;
                                $ret.d = k;
                                return $ret;
                            })());
                            return $ret;
                        })());
                    }
                    else {
                        let m = ChartExSerializer.j(e.chartType);
                        h.a = ((() => {
                            let $ret = new CT_NumericDimension();
                            $ret.c = m;
                            $ret.a = ((() => {
                                let $ret = new CT_Formula();
                                $ret.b = l;
                                $ret.d = k;
                                return $ret;
                            })());
                            return $ret;
                        })());
                    }
                }
            }
            let n = d.c.count;
            h.f = intSToU(n);
            d.b.addItem(e, h);
            d.c.add(h);
        }
        return d;
    }
    static j(a) {
        switch (a) {
            case 118:
            case 119: return 3;
            case 121: return 4;
            default: return 0;
        }
    }
    static f(a, b) {
        if (a == null) {
            return null;
        }
        let c = new CT_LegendEx();
        let d = ChartExExtensions.s(a.position);
        if (d != null) {
            c.l = Nullable$1.toNullable(ST_SidePos_$type, d.c);
            c.h = Nullable$1.toNullable(ST_PosAlign_$type, d.d);
        }
        c.j = Nullable$1.toNullable(Boolean_$type, a.overlay);
        if (a.fill != null) {
            c.d = ChartSerializer.a5(b, a.fill, a.border, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        if (a._as()) {
            let e = ChartSerializer.a9(b, a.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, 0), Nullable$1.toNullable(TextVerticalOverflow_$type, 0), a.textDirection, false, Nullable$1.toNullable(VerticalTitleAlignment_$type, -4108));
            c.e = ChartSerializer.a7(e, a._an, null, -5002, b, a.defaultFontFill);
        }
        return c;
    }
    static r(a) {
        let b = a.chartType;
        let c = a._seriesCollection$i.count > 0 ? a._seriesCollection$i.item(0) : null;
        let d = a._seriesCollection$i.count > 1 ? a._seriesCollection$i.item(1) : null;
        let e = c != null && d != null ? [c.chartType, d.chartType] : c != null ? [c.chartType] : new Array(0);
        let f = null;
        switch (b) {
            case 116:
                if (e.length < 2) {
                    f = ExcelUtils.ef("LE_WorksheetChart_Save_Series_Pareto");
                }
                else {
                    let g = e[0] == 51 || e[1] == 51;
                    let h = e[0] == 116 || e[1] == 116;
                    if (g == false || h == false) {
                        f = ExcelUtils.ef("LE_WorksheetChart_Save_Series_Pareto");
                    }
                }
                break;
            case 117:
                if (e.length < 1 || e[0] != 51) {
                    f = ExcelUtils.eg("LE_WorksheetChart_Save_Series", enumGetBox(ChartType_$type, b));
                }
                break;
            default:
                if (e.length < 1 || e[0] != b) {
                    f = ExcelUtils.eg("LE_WorksheetChart_Save_Series", enumGetBox(ChartType_$type, b));
                }
                break;
        }
        if (f != null) {
            throw new BaseError(1, f);
        }
    }
}
ChartExSerializer.$t = markType(ChartExSerializer, 'ChartExSerializer');
/**
 * @hidden
 */
export class ComboChartSerializer extends Base {
    static e(a) {
        let b = new Dictionary$2(String_$type, SeriesGroup.$, 0);
        let c = new Dictionary$2(Series.$, Number_$type, 0);
        for (let d = 0; d < a.count; d++) {
            c.addItem(a.item(d), d);
        }
        for (let e = 0; e < a.count; e++) {
            let f = a.item(e);
            let g;
            let h = ((() => { let i = ComboChartGroup._as(f.chartType, f.axisGroup, g); g = i.p2; return i.ret; })());
            if (g == 0) {
                continue;
            }
            let i = null;
            if (((() => { let j = b.tryGetValue(h, i); i = j.p1; return j.ret; })()) == false) {
                i = new SeriesGroup(g, f.axisGroup);
                b.addItem(h, i);
            }
            let j = a._aq(f);
            i.h(f, c.item(f), j.hasValue ? j.value : e);
        }
        return b.values;
    }
    static g(a, b, c, d, e, f) {
        let g = e.b;
        let h = false;
        let i = ((() => { let j = ComboChartSerializer.d(g, h); h = j.p1; return j.ret; })());
        let j = a._ft(g, e.a);
        switch (g) {
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
                let k = ComboChartSerializer.c(g);
                let l = new CT_BarChart();
                let m = h ? 0 : i ? 3 : 1;
                l.f.a = CT_Boolean.b(true);
                l.f.c = ((() => {
                    let $ret = new CT_BarGrouping();
                    $ret.b = m;
                    return $ret;
                })());
                let n = k ? 1 : 0;
                l.f.b = ((() => {
                    let $ret = new CT_BarDir();
                    $ret.b = n;
                    return $ret;
                })());
                for (let o = 0; o < e.d.count; o++) {
                    let p = e.d._inner[o];
                    let q = e.g(p);
                    let r = ChartSerializer.k(a, p, q, false, f);
                    l.f.f.add(r);
                }
                l.g = ComboChartSerializer.f(c, e.a, true);
                if (j != null) {
                    if (j._gapWidth$i.hasValue) {
                        l.a = ((() => {
                            let $ret = new CT_GapAmount();
                            $ret.c = j._gapWidth$i.value;
                            return $ret;
                        })());
                    }
                    if (j._seriesOverlap$i.hasValue) {
                        l.c = ((() => {
                            let $ret = new CT_Overlap();
                            $ret.b = j._seriesOverlap$i.value;
                            return $ret;
                        })());
                    }
                }
                if (d.f == null) {
                    d.f = l;
                }
                else if (d.g == null) {
                    d.g = l;
                }
                break;
            case 10:
            case 11:
            case 12:
                let s = new CT_LineChart();
                let t = h ? 0 : i ? 2 : 1;
                s.j.a = CT_Boolean.b(true);
                s.j.d = ((() => {
                    let $ret = new CT_Grouping();
                    $ret.b = t;
                    return $ret;
                })());
                s.a = CT_Boolean.b(false);
                for (let u = 0; u < e.d.count; u++) {
                    let v = e.d._inner[u];
                    let w = e.g(v);
                    let x = ChartSerializer.ab(a, v, w, f);
                    s.j.f.add(x);
                }
                s.k = ComboChartSerializer.f(c, e.a, true);
                if (d.n == null) {
                    d.n = s;
                }
                else if (d.o == null) {
                    d.o = s;
                }
                break;
            case 1:
            case 2:
            case 3:
                let y = new CT_AreaChart();
                let z = h ? 0 : i ? 2 : 1;
                y.b.d = ((() => {
                    let $ret = new CT_Grouping();
                    $ret.b = z;
                    return $ret;
                })());
                y.b.a = CT_Boolean.b(true);
                for (let aa = 0; aa < e.d.count; aa++) {
                    let ab = e.d._inner[aa];
                    let ac = e.g(ab);
                    let ad = ChartSerializer.d(a, ab, ac, f);
                    y.b.f.add(ad);
                }
                y.c = ComboChartSerializer.f(c, e.a, true);
                if (d.c == null) {
                    d.c = y;
                }
                else if (d.d == null) {
                    d.d = y;
                }
                break;
            case 13:
                let ae = new CT_PieChart();
                ae.d.a = CT_Boolean.b(true);
                for (let af = 0; af < e.d.count; af++) {
                    let ag = e.d._inner[af];
                    let ah = e.g(ag);
                    let ai = ChartSerializer.am(a, ag, ah, f);
                    ae.d.d.add(ai);
                }
                if (j != null) {
                    if (j._firstSliceAngle$i.hasValue) {
                        ae.a = ((() => {
                            let $ret = new CT_FirstSliceAng();
                            $ret.c = j._firstSliceAngle$i.value;
                            return $ret;
                        })());
                    }
                }
                if (d.s == null) {
                    d.s = ae;
                }
                else if (d.t == null) {
                    d.t = ae;
                }
                break;
            case 16:
                let aj = new CT_DoughnutChart();
                aj.f.a = CT_Boolean.b(true);
                for (let ak = 0; ak < e.d.count; ak++) {
                    let al = e.d._inner[ak];
                    let am = e.g(al);
                    let an = ChartSerializer.am(a, al, am, f);
                    aj.f.d.add(an);
                }
                if (j != null) {
                    if (j._firstSliceAngle$i.hasValue) {
                        aj.c = ((() => {
                            let $ret = new CT_HoleSize();
                            $ret.b = j._doughnutHoleSize$i.value;
                            return $ret;
                        })());
                    }
                }
                if (d.i == null) {
                    d.i = aj;
                }
                else if (d.j == null) {
                    d.j = aj;
                }
                break;
            case 15:
            case 14:
                let ao = new CT_OfPieChart();
                let ap = g == 15 ? 1 : 0;
                ao.e = ((() => {
                    let $ret = new CT_OfPieType();
                    $ret.b = ap;
                    return $ret;
                })());
                ao.l.a = CT_Boolean.b(true);
                for (let aq = 0; aq < e.d.count; aq++) {
                    let ar = e.d._inner[aq];
                    let as = e.g(ar);
                    let at = ChartSerializer.am(a, ar, as, f);
                    ao.l.d.add(at);
                }
                if (j != null) {
                    if (j._gapWidth$i.hasValue) {
                        ao.c = ((() => {
                            let $ret = new CT_GapAmount();
                            $ret.c = j._gapWidth$i.value;
                            return $ret;
                        })());
                    }
                }
                if (d.p == null) {
                    d.p = ao;
                }
                else if (d.q == null) {
                    d.q = ao;
                }
                break;
            case 20:
            case 19:
                let au = new CT_ScatterChart();
                au.a = CT_Boolean.b(true);
                au.e = DMLChartUtils.y(g);
                let av = e.d.count > 0 ? e.d._inner[0] : null;
                au.k = new List$1(CT_ScatterSer.$, 0);
                for (let aw = 0; aw < e.d.count; aw++) {
                    let ax = e.d._inner[aw];
                    let ay = e.g(ax);
                    let az = ChartSerializer.aq(a, ax, av, ay, f, true);
                    au.k.add(az);
                }
                au.g = ComboChartSerializer.f(c, e.a, true);
                if (d.y == null) {
                    d.y = au;
                }
                else if (d.z == null) {
                    d.z = au;
                }
                else if (d.aa == null) {
                    d.aa = au;
                }
                else if (d.ab == null) {
                    d.ab = au;
                }
                break;
            case 17:
            case 18:
                let a0 = new CT_RadarChart();
                a0.a = CT_Boolean.b(true);
                a0.e = DMLChartUtils.w(g);
                a0.k = new List$1(CT_RadarSer.$, 0);
                for (let a1 = 0; a1 < e.d.count; a1++) {
                    let a2 = e.d._inner[a1];
                    let a3 = e.g(a2);
                    let a4 = ChartSerializer.ao(a, a2, a3, f);
                    a0.k.add(a4);
                }
                a0.g = ComboChartSerializer.f(c, e.a, true);
                if (d.u == null) {
                    d.u = a0;
                }
                else if (d.v == null) {
                    d.v = a0;
                }
                else if (d.w == null) {
                    d.w = a0;
                }
                else if (d.x == null) {
                    d.x = a0;
                }
                break;
            default: break;
        }
    }
    static d(a, b) {
        b = false;
        let c = false;
        switch (a) {
            case 2:
            case 5:
            case 8:
            case 11:
                c = true;
                break;
            case 3:
            case 6:
            case 9:
            case 12:
                c = true;
                b = true;
                break;
            default: return {
                ret: false,
                p1: b
            };
        }
        return {
            ret: c,
            p1: b
        };
    }
    static c(a) {
        switch (a) {
            case 7:
            case 8:
            case 9: return true;
            default: return false;
        }
    }
    static a(a) {
        switch (a) {
            case 57:
            case 58:
            case 59:
            case 51:
            case 52:
            case 53:
            case 4:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 1:
            case 76:
            case 77:
            case 5:
            case -4120:
            case 68:
            case 71:
            case -4169:
            case 74:
            case 75:
            case 72:
            case 73:
            case -4151:
            case 82:
            case 81: return a;
        }
        let b = false;
        let c = ((() => { let d = WorksheetChart._gj(a, b); b = d.p1; return d.ret; })());
        let d, e;
        if (((() => { let f = WorksheetChart._f8(a, d, e); d = f.p1; e = f.p2; return f.ret; })())) {
            if (d) {
                return b ? 53 : c ? 52 : 51;
            }
            else {
                return b ? 59 : c ? 58 : 57;
            }
        }
        if (WorksheetChart._gd(a)) {
            return b ? 64 : c ? 63 : 4;
        }
        if (WorksheetChart._f7(a)) {
            return b ? 77 : c ? 76 : 1;
        }
        if (WorksheetChart._ge(a)) {
            switch (a) {
                case -4102:
                case 70: return 5;
                case 80: return 80;
            }
        }
        if (WorksheetChart._gk(a)) {
            return 4;
        }
        switch (a) {
            case 15:
            case 87: return -4169;
            case 83:
            case 85:
            case 86:
            case 84: return 1;
        }
        return 57;
    }
    static f(a, b, c) {
        return ChartSerializer.bk(a, Nullable$1.toNullable(AxisGroup_$type, b), c);
    }
    static b(a) {
        switch (a) {
            case 1:
            case 2:
            case 3: return 0;
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9: return 1;
            case 13:
            case 14:
            case 15:
            case 16: return 3;
            case 10:
            case 11:
            case 12: return 2;
            case 17:
            case 18: return 4;
            case 20:
            case 19: return 6;
            default: break;
        }
        return 1;
    }
}
ComboChartSerializer.$t = markType(ComboChartSerializer, 'ComboChartSerializer');
/**
 * @hidden
 */
export class SeriesGroup extends Base {
    constructor(a, b) {
        super();
        this.c = null;
        this.d = null;
        this.b = 0;
        this.a = 0;
        this.b = a;
        this.a = b;
        this.d = new List$1(Series.$, 0);
        this.c = new Dictionary$2(Series.$, Number_$type, 0);
    }
    get e() {
        return ComboChartGroup._at(this.b, this.a);
    }
    toString() {
        return stringFormat("{0}; {1} series", this.e, this.d.count);
    }
    h(a, b, c) {
        this.d.add(a);
        this.c.addItem(a, b);
    }
    g(a) {
        let b = 0;
        if (((() => { let c = this.c.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
            return intSToU(b);
        }
        else {
        }
        return 0;
    }
}
SeriesGroup.$t = markType(SeriesGroup, 'SeriesGroup');
/**
 * @hidden
 */
export class ChartSerializerExtensions extends Base {
    static a(a, b, c, d) {
        if (b == null) {
            return;
        }
        a.a = CT_Boolean.b(b._co);
        a.b = CT_Boolean.b(b._cp);
        a.c = CT_Boolean.b(b._cq);
        a.d = CT_Boolean.b(b._cr);
        a.e = CT_Boolean.b(b._ct);
        a.f = CT_Boolean.b(b._cu);
        let e = b._ad;
        let f = b._ch;
        let g = b._cl;
        if (e != null || f != null) {
            a.i = ChartSerializer.a5(d, e, f, Nullable$1.toNullable(BorderLineStyle_$type, null));
        }
        let h = ChartSerializer.a9(d, b.rotation, Nullable$1.toNullable(TextHorizontalOverflow_$type, b.horizontalOverflow), Nullable$1.toNullable(TextVerticalOverflow_$type, b.verticalOverflow), b.textDirection, b.wrapText, Nullable$1.toNullable(VerticalTitleAlignment_$type, b.verticalAlignment));
        a.j = ChartSerializer.a8(d, h, g, null, b.readingOrder);
        if (stringIsNullOrEmpty(b.numberFormat) == false) {
            a.h = ChartSerializer.ag(b);
        }
        if (stringIsNullOrEmpty(b.separator) == false) {
            a.l = b.separator;
        }
        let i = DMLChartExtensions.f(b.labelPosition, c.chartType);
        if (i != 0 && i != 5) {
            a.g = ((() => {
                let $ret = new CT_DLblPos();
                $ret.a = DMLChartExtensions.ad(i);
                return $ret;
            })());
        }
    }
    static a6(a, b) {
        a.a = CT_Boolean.b(b.applyPicToEnd);
        a.c = CT_Boolean.b(b.applyPicToFront);
        a.e = CT_Boolean.b(b.applyPicToSides);
        a.g = ((() => {
            let $ret = new CT_PictureFormat();
            $ret.a = DMLChartExtensions.ah(b.pictureType);
            return $ret;
        })());
        a.i = ((() => {
            let $ret = new CT_PictureStackUnit();
            $ret.a = b.pictureUnit;
            return $ret;
        })());
    }
    static a5(a, b) {
        a.a = CT_Boolean.b(b.applyPicToEnd);
        a.c = CT_Boolean.b(b.applyPicToFront);
        a.e = CT_Boolean.b(b.applyPicToSides);
        a.g = ((() => {
            let $ret = new CT_PictureFormat();
            $ret.a = DMLChartExtensions.ah(b.pictureType);
            return $ret;
        })());
        a.i = ((() => {
            let $ret = new CT_PictureStackUnit();
            $ret.a = b.pictureUnit;
            return $ret;
        })());
    }
    static a4(a, b) {
        let c = ExcelUtils.du(b._applyPicToEnd$i);
        let d = ExcelUtils.du(b._applyPicToFront$i);
        let e = ExcelUtils.du(b._applyPicToSides$i);
        if (c.hasValue) {
            a.a = CT_Boolean.b(c.value);
        }
        if (d.hasValue) {
            a.c = CT_Boolean.b(d.value);
        }
        if (e.hasValue) {
            a.e = CT_Boolean.b(e.value);
        }
    }
    static a3($t, a, b, c) {
        let d = typeCast(ChartSolidFill.$, b);
        let e = d == null ? typeCast(ChartGradientFill.$, b) : null;
        if (d != null) {
            a.c = ChartSerializer.a6(c, d);
        }
        else if (e != null) {
            a.a = ChartSerializer.a2(c, e);
        }
    }
    static s(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            ChartSerializerExtensions.aa(a.a, b, c, d, DrawingMLChart.dj);
        }
        d.k();
    }
    static aa(a, b, c, d, e) {
        d.p(e, null);
        if (a.q != null) {
            ChartSerializerExtensions.u(a.q, b, c, d, DrawingMLChart.c3);
        }
        if (a.m != null) {
            ChartSerializerExtensions.t(a.m, b, c, d, DrawingMLChart.gs);
        }
        if (a.o != null) {
            ChartSerializerExtensions.t(a.o, b, c, d, DrawingMLChart.gv);
        }
        if (a.k != null) {
            ChartSerializerExtensions.t(a.k, b, c, d, DrawingMLChart.gq);
        }
        if (a.i != null) {
            ChartSerializerExtensions.t(a.i, b, c, d, DrawingMLChart.cv);
        }
        if (a.e != null) {
            a.e.i(b, c, d, DrawingMLChart.gr);
        }
        if (a.g != null) {
            a.g.i(b, c, d, DrawingMLChart.gu);
        }
        if (a.c != null) {
            a.c.i(b, c, d, DrawingMLChart.go);
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.cs);
        }
        d.k();
    }
    static t(a, b, c, d, e) {
        CT_LayoutMode.f(b, e, a.b);
        d.k();
    }
    static u(a, b, c, d, e) {
        CT_LayoutTarget.f(b, e, a.b);
        d.k();
    }
    static ax(a, b, c, d, e) {
        CT_TextLanguageID.e(b, e, a.b);
        d.k();
    }
    static k(a, b, c, d, e, f = true) {
        d.p(e, null);
        if (f) {
            d.l(DrawingMLMain.an);
            d.l(DrawingMLChart.an);
        }
        if (a.b != null) {
            a.b.q(b, c, d, DrawingMLChart.bp, "c");
        }
        if (a.r != null) {
            ChartSerializerExtensions.ax(a.r, b, c, d, DrawingMLChart.c1);
        }
        if (a.d != null) {
            a.d.q(b, c, d, DrawingMLChart.e1, "c");
        }
        if (a.f != null) {
            ChartSerializerExtensions.i(a.f, b, c, d, DrawingMLChart.be);
        }
        if (a.v != null) {
            DMLExtensions.a5(a.v, b, c, d, DrawingMLChart.fw);
        }
        if (a.x != null) {
            a.x.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static i(a, b, c, d, e) {
        d.p(e, null);
        if (a.s != null) {
            ChartSerializerExtensions.ay(a.s, b, c, d, DrawingMLChart.f9);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.av, "c");
        }
        if (a.u != null) {
            ChartSerializerExtensions.a2(a.u, b, c, d, DrawingMLChart.gn);
        }
        if (a.o != null) {
            ChartSerializerExtensions.at(a.o, b, c, d, DrawingMLChart.ck);
        }
        if (a.q != null) {
            ChartSerializerExtensions.at(a.q, b, c, d, DrawingMLChart.fq);
        }
        if (a.m != null) {
            ChartSerializerExtensions.at(a.m, b, c, d, DrawingMLChart.az);
        }
        if (a.k != null) {
            ChartSerializerExtensions.aj(a.k, b, c, d, DrawingMLChart.eo);
        }
        if (a.i != null) {
            ChartSerializerExtensions.v(a.i, b, c, d, DrawingMLChart.c8);
        }
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.ep, "c");
        }
        if (a.g != null) {
            ChartSerializerExtensions.m(a.g, b, c, d, DrawingMLChart.bt);
        }
        if (a.e != null) {
            a.e.q(b, c, d, DrawingMLChart.ff, "c");
        }
        d.k();
    }
    static m(a, b, c, d, e) {
        CT_DispBlanksAs.f(b, e, a.b);
        d.k();
    }
    static v(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            ChartSerializerExtensions.x(a.e, b, c, d, DrawingMLChart.da);
        }
        if (a.m != null) {
            for (let f of fromEnum(a.m)) {
                ChartSerializerExtensions.w(f, b, c, d, DrawingMLChart.c9);
            }
        }
        if (a.c != null) {
            ChartSerializerExtensions.s(a.c, b, c, d, DrawingMLChart.c2);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.eb, "c");
        }
        if (a.g != null) {
            DMLExtensions.a5(a.g, b, c, d, DrawingMLChart.fw);
        }
        if (a.i != null) {
            a.i.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static w(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.i(b, c, d, DrawingMLChart.cy, "c");
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.br, "c");
        }
        if (a.e != null) {
            a.e.c(b, c, d, null);
        }
        d.k();
    }
    static x(a, b, c, d, e) {
        CT_LegendPos.f(b, e, a.b);
        d.k();
    }
    static at(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.f5, "c");
        }
        if (a.e != null) {
            DMLExtensions.a5(a.e, b, c, d, DrawingMLChart.fw);
        }
        if (a.c != null) {
            DMLChartExtensions.cl(a.c, b, c, d, DrawingMLChart.eh);
        }
        d.k();
    }
    static af(a, b, c, d, e) {
        CT_PictureFormat.e(b, e, a.a);
        d.k();
    }
    static ag(a, b, c, d, e) {
        CT_PictureStackUnit.e(b, e, a.a);
        d.k();
    }
    static aj(a, b, c, d, e) {
        d.p(e, null);
        if (a.l != null) {
            ChartSerializerExtensions.s(a.l, b, c, d, DrawingMLChart.c2);
        }
        if (a.c != null) {
            ChartSerializerExtensions.c(a.c, b, c, d, DrawingMLChart.at);
        }
        if (a.d != null) {
            ChartSerializerExtensions.c(a.d, b, c, d, DrawingMLChart.at);
        }
        if (a.b != null) {
            ChartSerializerExtensions.b(a.b, b, c, d, DrawingMLChart.as);
        }
        if (a.n != null) {
            ChartSerializerExtensions.z(a.n, b, c, d, DrawingMLChart.dc);
        }
        if (a.o != null) {
            ChartSerializerExtensions.z(a.o, b, c, d, DrawingMLChart.dc);
        }
        if (a.m != null) {
            ChartSerializerExtensions.y(a.m, b, c, d, DrawingMLChart.db);
        }
        if (a.f != null) {
            ChartSerializerExtensions.e(a.f, b, c, d, DrawingMLChart.a4);
        }
        if (a.g != null) {
            ChartSerializerExtensions.e(a.g, b, c, d, DrawingMLChart.a4);
        }
        if (a.ac != null) {
            ChartSerializerExtensions.as(a.ac, b, c, d, DrawingMLChart.fx);
        }
        if (a.u != null) {
            ChartSerializerExtensions.ak(a.u, b, c, d, DrawingMLChart.ev);
        }
        if (a.v != null) {
            ChartSerializerExtensions.ak(a.v, b, c, d, DrawingMLChart.ev);
        }
        if (a.w != null) {
            ChartSerializerExtensions.ak(a.w, b, c, d, DrawingMLChart.ev);
        }
        if (a.x != null) {
            ChartSerializerExtensions.ak(a.x, b, c, d, DrawingMLChart.ev);
        }
        if (a.y != null) {
            DMLChartExtensions.cp(a.y, b, c, d, DrawingMLChart.e3);
        }
        if (a.z != null) {
            DMLChartExtensions.cp(a.z, b, c, d, DrawingMLChart.e3);
        }
        if (a.aa != null) {
            DMLChartExtensions.cp(a.aa, b, c, d, DrawingMLChart.e3);
        }
        if (a.ab != null) {
            DMLChartExtensions.cp(a.ab, b, c, d, DrawingMLChart.e3);
        }
        if (a.s != null) {
            ChartSerializerExtensions.ai(a.s, b, c, d, DrawingMLChart.ek);
        }
        if (a.t != null) {
            ChartSerializerExtensions.ai(a.t, b, c, d, DrawingMLChart.ek);
        }
        if (a.r != null) {
            ChartSerializerExtensions.ah(a.r, b, c, d, DrawingMLChart.ej);
        }
        if (a.i != null) {
            ChartSerializerExtensions.n(a.i, b, c, d, DrawingMLChart.b1);
        }
        if (a.j != null) {
            ChartSerializerExtensions.n(a.j, b, c, d, DrawingMLChart.b1);
        }
        if (a.e != null) {
            ChartSerializerExtensions.d(a.e, b, c, d, DrawingMLChart.a3);
        }
        if (a.p != null) {
            ChartSerializerExtensions.ab(a.p, b, c, d, DrawingMLChart.d6);
        }
        if (a.q != null) {
            ChartSerializerExtensions.ab(a.q, b, c, d, DrawingMLChart.d6);
        }
        if (a.ae != null) {
            ChartSerializerExtensions.av(a.ae, b, c, d, DrawingMLChart.f3);
        }
        if (a.ad != null) {
            ChartSerializerExtensions.au(a.ad, b, c, d, DrawingMLChart.f2);
        }
        if (a.h != null) {
            ChartSerializerExtensions.f(a.h, b, c, d, DrawingMLChart.a8);
        }
        for (let f of fromEnum(a.ah)) {
            f.save(b, c, d);
        }
        if (a.af != null) {
            DMLExtensions.a5(a.af, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static e(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null) {
            a.f.g(b, c, d, null);
        }
        if (a.a != null) {
            ChartSerializerExtensions.p(a.a, b, c, d, DrawingMLChart.cq);
        }
        if (a.c != null) {
            ChartSerializerExtensions.ad(a.c, b, c, d, DrawingMLChart.ea);
        }
        if (a.k != null) {
            for (let f of fromEnum(a.k)) {
                ChartSerializerExtensions.j(f, b, c, d, DrawingMLChart.fb);
            }
        }
        if (a.g != null) {
            for (let g of fromEnum(a.g)) {
                g.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static z(a, b, c, d, e) {
        d.p(e, null);
        if (a.j != null) {
            a.j.g(b, c, d, null);
        }
        if (a.c != null) {
            ChartSerializerExtensions.j(a.c, b, c, d, DrawingMLChart.cu);
        }
        if (a.e != null) {
            DMLChartExtensions.b7(a.e, b, c, d, DrawingMLChart.dk);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.ft, "c");
        }
        if (a.k != null) {
            for (let f of fromEnum(a.k)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static c(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.g(b, c, d, null);
        }
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static ai(a, b, c, d, e) {
        d.p(e, null);
        if (a.d != null) {
            a.d.e(b, c, d, null);
        }
        if (a.a != null) {
            ChartSerializerExtensions.o(a.a, b, c, d, DrawingMLChart.cj);
        }
        d.k();
    }
    static n(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null) {
            a.f.e(b, c, d, null);
        }
        if (a.a != null) {
            ChartSerializerExtensions.o(a.a, b, c, d, DrawingMLChart.cj);
        }
        if (a.c != null) {
            ChartSerializerExtensions.q(a.c, b, c, d, DrawingMLChart.cw);
        }
        d.k();
    }
    static q(a, b, c, d, e) {
        CT_HoleSize.f(b, e, a.b);
        d.k();
    }
    static o(a, b, c, d, e) {
        CT_FirstSliceAng.f(b, e, a.c);
        d.k();
    }
    static j(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
    static p(a, b, c, d, e) {
        CT_GapAmount.f(b, e, a.c);
        d.k();
    }
    static ad(a, b, c, d, e) {
        CT_Overlap.f(b, e, a.b);
        d.k();
    }
    static ay(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            ChartSerializerExtensions.az(a.e, b, c, d, DrawingMLChart.gd);
        }
        if (a.c != null) {
            ChartSerializerExtensions.s(a.c, b, c, d, DrawingMLChart.c2);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.eb, "c");
        }
        if (a.g != null) {
            DMLExtensions.a5(a.g, b, c, d, DrawingMLChart.fw);
        }
        if (a.i != null) {
            a.i.e(b, c, d, DrawingMLChart.ge);
        }
        d.k();
    }
    static az(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLChartExtensions.cw(a.a, b, c, d, DrawingMLChart.f0);
        }
        if (a.b != null) {
            a.b.e(b, c, d, DrawingMLChart.ey);
        }
        d.k();
    }
    static a2(a, b, c, d, e) {
        d.p(e, null);
        if (a.i != null) {
            ChartSerializerExtensions.an(a.i, b, c, d, DrawingMLChart.ez);
        }
        if (a.e != null) {
            ChartSerializerExtensions.r(a.e, b, c, d, DrawingMLChart.cx);
        }
        if (a.k != null) {
            ChartSerializerExtensions.ao(a.k, b, c, d, DrawingMLChart.e0);
        }
        if (a.c != null) {
            ChartSerializerExtensions.l(a.c, b, c, d, DrawingMLChart.bs);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.ex, "c");
        }
        if (a.g != null) {
            ChartSerializerExtensions.ae(a.g, b, c, d, DrawingMLChart.ef);
        }
        d.k();
    }
    static an(a, b, c, d, e) {
        CT_RotX.f(b, e, a.b);
        d.k();
    }
    static r(a, b, c, d, e) {
        CT_HPercent.f(b, e, a.c);
        d.k();
    }
    static ao(a, b, c, d, e) {
        CT_RotY.f(b, e, a.c);
        d.k();
    }
    static l(a, b, c, d, e) {
        CT_DepthPercent.f(b, e, a.c);
        d.k();
    }
    static ae(a, b, c, d, e) {
        CT_Perspective.f(b, e, a.b);
        d.k();
    }
    static ak(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            ChartSerializerExtensions.am(a.e, b, c, d, DrawingMLChart.ew);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.gm, "c");
        }
        if (a.k != null) {
            for (let f of fromEnum(a.k)) {
                ChartSerializerExtensions.al(f, b, c, d, DrawingMLChart.e9);
            }
        }
        if (a.c != null) {
            DMLChartExtensions.br(a.c, b, c, d, DrawingMLChart.b0);
        }
        if (a.g != null) {
            for (let g of fromEnum(a.g)) {
                g.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static am(a, b, c, d, e) {
        CT_RadarStyle.f(b, e, a.b);
        d.k();
    }
    static al(a, b, c, d, e) {
        d.p(e, null);
        if (a.j != null) {
            a.j.f(b, c, d, null);
        }
        if (a.e != null) {
            DMLChartExtensions.b7(a.e, b, c, d, DrawingMLChart.dk);
        }
        if (a.l != null) {
            for (let f of fromEnum(a.l)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.c != null) {
            DMLChartExtensions.br(a.c, b, c, d, DrawingMLChart.b0);
        }
        if (a.a != null) {
            DMLChartExtensions.bd(a.a, b, c, d, DrawingMLChart.bc);
        }
        if (a.g != null) {
            DMLChartExtensions.cd(a.g, b, c, d, DrawingMLChart.gk);
        }
        d.k();
    }
    static f(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            a.e.q(b, c, d, DrawingMLChart.gm, "c");
        }
        if (a.q != null) {
            for (let f of fromEnum(a.q)) {
                ChartSerializerExtensions.h(f, b, c, d, DrawingMLChart.e9);
            }
        }
        if (a.i != null) {
            DMLChartExtensions.br(a.i, b, c, d, DrawingMLChart.b0);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.a7, "c");
        }
        if (a.g != null) {
            ChartSerializerExtensions.g(a.g, b, c, d, DrawingMLChart.a9);
        }
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.fk, "c");
        }
        if (a.k != null) {
            ChartSerializerExtensions.aq(a.k, b, c, d, DrawingMLChart.fs);
        }
        if (a.m != null) {
            for (let g of fromEnum(a.m)) {
                g.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static h(a, b, c, d, e) {
        d.p(e, null);
        if (a.n != null) {
            a.n.f(b, c, d, null);
        }
        if (a.c != null) {
            a.c.q(b, c, d, DrawingMLChart.c0, "c");
        }
        if (a.p != null) {
            for (let f of fromEnum(a.p)) {
                DMLChartExtensions.bs(f, b, c, d, DrawingMLChart.b3);
            }
        }
        if (a.g != null) {
            DMLChartExtensions.br(a.g, b, c, d, DrawingMLChart.b0);
        }
        if (a.v != null) {
            for (let g of fromEnum(a.v)) {
                DMLChartExtensions.c3(g, b, c, d, DrawingMLChart.ga);
            }
        }
        if (a.r != null && a.r.count > 0) {
            DMLChartExtensions.bt(a.r._inner[0], b, c, d, DrawingMLChart.b6);
        }
        if (a.e != null) {
            DMLChartExtensions.bd(a.e, b, c, d, DrawingMLChart.gt);
        }
        if (a.k != null) {
            DMLChartExtensions.cd(a.k, b, c, d, DrawingMLChart.gw);
        }
        if (a.i != null) {
            DMLChartExtensions.cd(a.i, b, c, d, DrawingMLChart.ba);
        }
        if (a.a != null) {
            a.a.q(b, c, d, DrawingMLChart.a7, "c");
        }
        d.k();
    }
    static g(a, b, c, d, e) {
        CT_BubbleScale.f(b, e, a.c);
        d.k();
    }
    static aq(a, b, c, d, e) {
        CT_SizeRepresents.f(b, e, a.b);
        d.k();
    }
    static av(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.e(b, c, d, null);
        }
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static aw(a, b, c, d, e) {
        d.p(e, null);
        if (a.f != null) {
            a.f.f(b, c, d, null);
        }
        if (a.a != null) {
            DMLChartExtensions.bd(a.a, b, c, d, DrawingMLChart.bc);
        }
        if (a.c != null) {
            DMLChartExtensions.cd(a.c, b, c, d, DrawingMLChart.gk);
        }
        d.k();
    }
    static d(a, b, c, d, e) {
        d.p(e, null);
        if (a.h != null) {
            a.h.g(b, c, d, null);
        }
        if (a.c != null) {
            ChartSerializerExtensions.p(a.c, b, c, d, DrawingMLChart.cq);
        }
        if (a.a != null) {
            ChartSerializerExtensions.p(a.a, b, c, d, DrawingMLChart.cp);
        }
        if (a.e != null) {
            DMLChartExtensions.ct(a.e, b, c, d, DrawingMLChart.fc);
        }
        if (a.i != null) {
            for (let f of fromEnum(a.i)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static y(a, b, c, d, e) {
        d.p(e, null);
        if (a.d != null) {
            a.d.g(b, c, d, null);
        }
        if (a.a != null) {
            ChartSerializerExtensions.p(a.a, b, c, d, DrawingMLChart.cp);
        }
        if (a.e != null) {
            for (let f of fromEnum(a.e)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static ah(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.e(b, c, d, null);
        }
        d.k();
    }
    static au(a, b, c, d, e) {
        d.p(e, null);
        if (a.b != null) {
            a.b.e(b, c, d, null);
        }
        if (a.c != null) {
            for (let f of fromEnum(a.c)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static ab(a, b, c, d, e) {
        d.p(e, null);
        if (a.e != null) {
            ChartSerializerExtensions.ac(a.e, b, c, d, DrawingMLChart.d7);
        }
        if (a.l != null) {
            a.l.e(b, c, d, null);
        }
        if (a.c != null) {
            ChartSerializerExtensions.p(a.c, b, c, d, DrawingMLChart.cq);
        }
        if (a.i != null) {
            ChartSerializerExtensions.ar(a.i, b, c, d, DrawingMLChart.fv);
        }
        if (a.a != null) {
            a.a.i(b, c, d, DrawingMLChart.fu);
        }
        if (a.g != null) {
            ChartSerializerExtensions.ap(a.g, b, c, d, DrawingMLChart.e6);
        }
        if (a.q != null) {
            for (let f of fromEnum(a.q)) {
                ChartSerializerExtensions.j(f, b, c, d, DrawingMLChart.fb);
            }
        }
        d.k();
    }
    static ac(a, b, c, d, e) {
        CT_OfPieType.f(b, e, a.b);
        d.k();
    }
    static ar(a, b, c, d, e) {
        CT_SplitType.f(b, e, a.b);
        d.k();
    }
    static b(a, b, c, d, e) {
        d.p(e, null);
        if (a.d != null) {
            a.d.g(b, c, d, null);
        }
        if (a.a != null) {
            ChartSerializerExtensions.p(a.a, b, c, d, DrawingMLChart.cp);
        }
        if (a.e != null) {
            for (let f of fromEnum(a.e)) {
                f.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        d.k();
    }
    static ap(a, b, c, d, e) {
        CT_SecondPieSize.f(b, e, a.c);
        d.k();
    }
    static as(a, b, c, d, e) {
        d.p(e, null);
        if (a.m != null) {
            for (let f of fromEnum(a.m)) {
                DMLChartExtensions.b3(f, b, c, d, DrawingMLChart.e9);
            }
        }
        if (a.e != null) {
            DMLChartExtensions.br(a.e, b, c, d, DrawingMLChart.b0);
        }
        if (a.a != null) {
            ChartSerializerExtensions.j(a.a, b, c, d, DrawingMLChart.b4);
        }
        if (a.c != null) {
            ChartSerializerExtensions.j(a.c, b, c, d, DrawingMLChart.cu);
        }
        if (a.g != null) {
            ChartSerializerExtensions.a1(a.g, b, c, d, DrawingMLChart.gg);
        }
        if (a.i != null) {
            for (let g of fromEnum(a.i)) {
                g.i(b, c, d, DrawingMLChart.ax, "c");
            }
        }
        if (a.k != null) {
            ChartExExtensions.ct(a.k, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static a1(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            ChartSerializerExtensions.p(a.a, b, c, d, DrawingMLChart.cq);
        }
        if (a.e != null) {
            ChartSerializerExtensions.a0(a.e, b, c, d, DrawingMLChart.gf);
        }
        if (a.c != null) {
            ChartSerializerExtensions.a0(a.c, b, c, d, DrawingMLChart.b2);
        }
        if (a.g != null) {
            ChartExExtensions.ct(a.g, b, c, d, DrawingMLChart.cf);
        }
        d.k();
    }
    static a0(a, b, c, d, e) {
        d.p(e, null);
        if (a.a != null) {
            DMLExtensions.a5(a.a, b, c, d, DrawingMLChart.fw);
        }
        d.k();
    }
}
ChartSerializerExtensions.$t = markType(ChartSerializerExtensions, 'ChartSerializerExtensions');
/**
 * @hidden
 */
export class WorksheetChartExtensions extends Base {
    static aq(a, b, c, d) {
        let e = c.workbook;
        a._i8(c);
        try {
            let f = b.f;
            let g = f.a == null || f.a.k == false;
            let h = b.f.k;
            if (h == null) {
                return;
            }
            let i = WorksheetChartExtensions.d(b);
            a.chartType = i;
            if (g && f.s != null) {
                a.chartTitle = new ChartTitle();
                a.chartTitle._l(a);
                WorksheetChartExtensions.aa(a.chartTitle, f.s, f, null, c, d);
            }
            let j = new Dictionary$2(Number_$type, Tuple$2.$.specialize(Axis.$, IAxis_$type), 0);
            WorksheetChartExtensions.r(a, b, c, d, j);
            let k = WorksheetChartExtensions.n(h);
            let l = WorksheetChartExtensions.o(k);
            let m = new Dictionary$2(Series.$, ISeries_$type, 0);
            for (let n of fromEnum(l)) {
                let o = a._seriesCollection$i.add();
                WorksheetChartExtensions.av(a, o, n, b, c, d);
                m.addItem(o, n);
            }
            if (a.chartType == 74) {
                let p = 0;
                let q = 0;
                let r = 0;
                for (let s of fromEnum(l)) {
                    if (s.isExplicitlyNoFill) {
                        p += 1;
                    }
                    let t = DMLChartUtils.au(s);
                    if (t.hasValue) {
                        switch (t.value) {
                            case 0:
                                r += 1;
                                break;
                            default:
                                q += 1;
                                break;
                        }
                    }
                }
                if (p == l.count) {
                    a.chartType = -4169;
                    a._seriesCollection$i._aw(74, a.chartType);
                }
                if (r == l.count) {
                    a.chartType = 75;
                    a._seriesCollection$i._aw(74, a.chartType);
                }
            }
            let u = DMLChartUtils.l(b.f.i, a._seriesCollection$i, c);
            a.legend = u;
            WorksheetChartExtensions.az(b.f.i, a._seriesCollection$i, c);
            let v = f.u;
            if (v != null) {
                if (v.e != null) {
                    a.autoScaling = true;
                }
                if (v.a != null) {
                    a.rightAngleAxes = v.a.k;
                }
                if (v.g != null) {
                    let w = intDivide(v.g.b, 2);
                    w = Math.min(w, 120);
                    a.perspective = w;
                }
                if (v.c != null) {
                    a.depthPercent = v.c.c;
                }
                if (v.e != null) {
                    a.heightPercent = v.e.c;
                }
                if (v.i != null) {
                    let x = v.i.b;
                    x = Math.min(x, 359);
                    a.rotationX = x;
                }
                if (v.k != null) {
                    let y = v.k.c;
                    y = Math.max(y, -90);
                    y = Math.min(y, 90);
                    a.rotationY = y;
                }
            }
            if (f.m != null) {
                WorksheetChartExtensions.ap(a.backWall, f.m, 0, c);
            }
            if (f.q != null) {
                WorksheetChartExtensions.ap(a.sideWall, f.q, 1, c);
            }
            if (f.o != null) {
                WorksheetChartExtensions.ap(a.floor, f.o, 2, c);
            }
            if (f.g != null) {
                a.displayBlanksAs = DMLChartExtensions.h(f.g.b);
            }
            for (let z of fromEnum(k)) {
                let aa = null;
                let ab = null;
                let ac = z.getGap(aa, ab);
                aa = ac.p0;
                ab = ac.p1;
                if (aa != null) {
                    a.gapDepth = aa.c;
                }
                if (ab != null) {
                    a.gapWidth = ab.c;
                }
            }
            for (let ad of fromEnum(k)) {
                let ae = ad._getFirstSliceAngle$i();
                let af = ad._getHoleSize$i();
                if (ae.hasValue) {
                    a.firstSliceAngle = ae.value;
                }
                if (af.hasValue) {
                    a.doughnutHoleSize = af.value;
                }
                let ag = ad._getOverlap$i();
                if (ag.hasValue) {
                    a.seriesOverlap = ag.value;
                }
                let ah = ad._getVaryColors$i();
                if (ah.hasValue) {
                    a.varyColors = ah.value;
                }
            }
            if (f.c != null) {
                a.plotVisibleOnly = f.c.k;
            }
            let ai = b.v;
            let aj = ai != null ? ai.a : null;
            if (ai != null) {
                a.chartArea.fill = DMLChartUtils.c(ai.l);
            }
            if (aj != null) {
                let ak = new ChartBorder();
                DMLChartExtensions.a4(ak, aj, c);
                a.chartArea.border = ak;
            }
            a.chartArea.roundedCorners = CT_Boolean.g(b.d);
            ai = h.af;
            aj = ai != null ? ai.a : null;
            if (ai != null) {
                a.plotArea.fill = DMLChartUtils.c(ai.l);
            }
            if (aj != null) {
                let al = new ChartBorder();
                DMLChartExtensions.a4(al, aj, c);
                a.plotArea.border = al;
            }
            let am = null;
            for (let an of fromEnum(k)) {
                am = an.getSerLines();
                if (am != null) {
                    break;
                }
            }
            if (am != null) {
                a.seriesLines = new ChartSeriesLines();
                WorksheetChartExtensions.z(a.seriesLines, am, c, d);
            }
            let ao = -4105;
            let ap = 0, aq = 0, ar = 0, as = 0;
            let at = Nullable$1.toNullable(Boolean_$type, null);
            let au = h.l;
            if (au != null) {
                let av = DMLChartUtils.a8(au, ao, ap, aq, ar, as, at);
                ao = av.p1;
                ap = av.p2;
                aq = av.p3;
                ar = av.p4;
                as = av.p5;
                at = av.p6;
                if (at.hasValue) {
                }
                a.plotArea.position = ao;
                a.plotArea.height = as;
                a.plotArea.left = ap;
                a.plotArea.top = aq;
                a.plotArea.width = ar;
            }
            switch (i) {
                case -4120:
                case 5:
                    for (let aw of fromEnum(a._seriesCollection$i)) {
                        if (aw.explosion > 0) {
                            a.chartType = i == -4120 ? 80 : 69;
                        }
                    }
                    break;
                case 4:
                case 63:
                case 64:
                case -4151:
                case 75:
                case 73:
                    for (let ax of fromEnum(a._seriesCollection$i)) {
                        if (ax.markerStyle != -4142) {
                            switch (i) {
                                case 4:
                                    a.chartType = 65;
                                    break;
                                case 63:
                                    a.chartType = 66;
                                    break;
                                case 64:
                                    a.chartType = 67;
                                    break;
                                case -4151:
                                    a.chartType = 81;
                                    break;
                                case 75:
                                    a.chartType = 74;
                                    break;
                                case 73:
                                    a.chartType = 72;
                                    break;
                            }
                        }
                    }
                    break;
            }
            let ay = WorksheetChart._gy(a.chartType);
            if (ay == false) {
                let az = a._axisCollection$i.item(2, 2);
                if (az != null) {
                    a._axisCollection$i._ao(az);
                }
                for (let a0 of fromEnum(a._axisCollection$i)) {
                    if (a0._ab == az) {
                        switch (a0.type) {
                            case 1:
                                a0._ab = a._axisCollection$i.item(2);
                                break;
                            case 2:
                            case 3:
                                a0._ab = a._axisCollection$i.item(1);
                                break;
                        }
                    }
                }
            }
            let a1 = h.ac;
            if (a1 != null) {
                let a2 = a1.c;
                let a3 = a1.a;
                let a4 = a1.g;
                if (a3 != null) {
                    let a5 = new ChartDropLines();
                    WorksheetChartExtensions.w(a5, a3, c, d);
                    a.dropLines = a5;
                }
                if (a2 != null) {
                    let a6 = new ChartHighLowLines();
                    WorksheetChartExtensions.x(a6, a2, c, d);
                    a.highLowLines = a6;
                }
                if (a4 != null) {
                    let a7 = new UpDownBars();
                    WorksheetChartExtensions.ao(a7, a4, c, d);
                    a.upDownBars = a7;
                }
            }
            WorksheetChartExtensions.aw(a._axisCollection$i, j, m);
            if (a.chartType == 113) {
                let a8 = false;
                for (let a9 of fromEnum(k)) {
                    if (a9.axisIds != null) {
                        for (let ba of fromEnum(a9.axisIds)) {
                            for (let bb of fromEnum(j)) {
                                if (bb.key == ba.g) {
                                    if (bb.value.c.axisGroup == 1) {
                                        a8 = true;
                                        break;
                                    }
                                }
                            }
                            if (a8) {
                                break;
                            }
                        }
                    }
                }
                let bc = 0;
                for (let bd of fromEnum(k)) {
                    let be = null;
                    let bf = null;
                    let bg = bd.getGap(be, bf);
                    be = bg.p0;
                    bf = bg.p1;
                    let bh = bd._getFirstSliceAngle$i();
                    let bi = bd._getHoleSize$i();
                    let bj = bd._getOverlap$i();
                    if (bf != null || bh.hasValue || bi.hasValue || bj.hasValue) {
                        let bk = Nullable$1.toNullable(AxisGroup_$type, null);
                        if (bd.axisIds != null) {
                            for (let bl of fromEnum(bd.axisIds)) {
                                for (let bm of fromEnum(j)) {
                                    if (bm.key == bl.g) {
                                        bk = Nullable$1.toNullable(AxisGroup_$type, bm.value.c.axisGroup);
                                        break;
                                    }
                                }
                                if (bk.hasValue) {
                                    break;
                                }
                            }
                        }
                        else {
                            bc += 1;
                            bk = Nullable$1.toNullable(AxisGroup_$type, a8 ? 2 : bc == 1 ? 1 : 2);
                        }
                        let bn = bd.getSeries();
                        let bo = bn.count > 0 ? bn._inner[0] : null;
                        if (bk.hasValue && bo != null) {
                            let bp = bd.getChartType(b, bo);
                            if (WorksheetChart._go(bp)) {
                                let bq = a._fr(bp, bk.value);
                                if (bf != null) {
                                    bq._gapWidth$i = Nullable$1.toNullable(Number_$type, bf.c);
                                }
                                if (bh.hasValue) {
                                    bq._firstSliceAngle$i = Nullable$1.toNullable(Number_$type, bh.value);
                                }
                                if (bj.hasValue) {
                                    bq._seriesOverlap$i = Nullable$1.toNullable(Number_$type, bj.value);
                                }
                                if (bi.hasValue) {
                                    bq._doughnutHoleSize$i = Nullable$1.toNullable(Number_$type, bi.value);
                                }
                            }
                        }
                    }
                }
            }
        }
        finally {
            a._ja();
        }
    }
    static ap(a, b, c, d) {
        if (b == null) {
            return;
        }
        if (b.a != null) {
            a.thickness = b.a.g;
        }
        let e = b.e;
        let f = e != null ? e.a : null;
        if (e != null) {
            a.fill = DMLChartUtils.c(e.l);
        }
        if (f != null) {
            let g = new ChartBorder(null);
            DMLChartExtensions.a4(g, f, d);
            a.border = g;
        }
    }
    static aa(a, b, c, d, e, f) {
        let g = b.g;
        let h = g != null ? g.a : null;
        WorksheetChartExtensions.t(a, g, h, b.e, b.i, b.c, e, f);
        if (b.a != null && b.a.k) {
            a.overlay = true;
        }
    }
    static ag(a, b, c, d) {
        if (b == null) {
            return;
        }
        WorksheetChartExtensions.ah(a, b.e, b.c, b.g, b.a, c, d);
    }
    static ah(a, b, c, d, e, f, g) {
        let h = b != null ? b.a : null;
        WorksheetChartExtensions.t(a, b, h, c, d, e, f, g);
    }
    static z(a, b, c, d) {
        let e = typeCast(ChartLineBase.$, a);
        WorksheetChartExtensions.y(e, b, c, d);
    }
    static al(a, b, c, d) {
        let e = b.q != null ? DMLChartExtensions.x(b.q.b) : 1;
        a.trendlineType = e;
        a.backward = b.e != null ? b.e.f : 0;
        a.forward = b.g != null ? b.g.f : 0;
        a._intercept$i = b.i != null ? Nullable$1.toNullable(Number_$type, b.i.f) : Nullable$1.toNullable(Number_$type, null);
        a.order = b.k != null ? b.k.b : 2;
        a.period = b.m != null ? b.m.b : 2;
        a.name = b.w;
        let f = b.s;
        let g = f != null ? f.a : null;
        if (g != null) {
            a.line = new TrendlineLine();
            DMLChartExtensions.a6(a.line, g, c);
        }
        let h = null;
        let i = b.o;
        if (i != null) {
            h = new TrendlineLabel();
            WorksheetChartExtensions.am(h, b, c, d);
        }
        a.label = h;
    }
    static am(a, b, c, d) {
        let e = b != null ? b.o : null;
        if (e == null) {
            return;
        }
        let f = e.g;
        let g = f != null ? f.a : null;
        let h = e.e;
        let i = e.i;
        WorksheetChartExtensions.t(a, f, g, e.e, e.i, e.a, c, d);
        if (e.c != null) {
            let j;
            let k;
            if (((() => { let l = WorksheetChartExtensions.l(e.c, j, k); j = l.p1; k = l.p2; return l.ret; })())) {
                a.numberFormat = j;
                a.numberFormatLinked = k;
            }
        }
        a.displayEquation = CT_Boolean.g(b.a);
        a.displayRSquared = CT_Boolean.g(b.c);
    }
    static ab(a, b, c, d, e) {
        WorksheetChartExtensions.ad(a, b.d.d, b.d.b, c, d, e);
        a.isDeleted = CT_Boolean.g(b.a);
        let f = b.d.a;
        let g = c != null ? c.j : null;
        let h;
        let i, j, k, l;
        let m;
        if (f != null) {
            let n = DMLChartUtils.a8(f, h, i, j, k, l, m);
            h = n.p1;
            i = n.p2;
            j = n.p3;
            k = n.p4;
            l = n.p5;
            m = n.p6;
            a.left = i;
            a.top = j;
            if (f.a != null) {
                a.labelPosition = 5;
            }
        }
        if (g != null) {
            let o = DMLChartUtils.a8(g, h, i, j, k, l, m);
            h = o.p1;
            i = o.p2;
            j = o.p3;
            k = o.p4;
            l = o.p5;
            m = o.p6;
            a.width = k;
            a.height = l;
        }
    }
    static ac(a, b, c, d, e) {
        WorksheetChartExtensions.ad(a, b.e.d, null, c, d, e);
    }
    static ad(a, b, c, d, e, f) {
        let g = d != null ? d.f : null;
        a._showBubbleSize$i = SerializationUtils.q(b.a);
        a._showCategoryName$i = SerializationUtils.q(b.b);
        a._showLegendKey$i = SerializationUtils.q(b.c);
        a._showPercentage$i = SerializationUtils.q(b.d);
        a._showRange$i = Nullable$1.toNullable(Boolean_$type, g ? true : false);
        a._showSeriesName$i = SerializationUtils.q(b.e);
        a._showValue$i = SerializationUtils.q(b.f);
        if (b.g != null) {
            a.labelPosition = DMLChartExtensions.g(b.g.a);
        }
        a.separator = b.l;
        let h;
        let i;
        if (((() => { let j = WorksheetChartExtensions.l(b.h, h, i); h = j.p1; i = j.p2; return j.ret; })())) {
            a.numberFormat = h;
            a.numberFormatLinked = i;
        }
        let j = b.i;
        let k = j != null ? j.a : null;
        WorksheetChartExtensions.t(a, j, k, c, b.j, null, e, f);
        if (WorksheetChartExtensions.m(c) == false) {
            a.text = null;
        }
    }
    static af(a, b, c, d, e) {
        if (c != null) {
            let f = c.m;
            let g = f != null ? f.a : null;
            let h = f != null ? f.l : null;
            if (h != null) {
                a.fill = DMLChartUtils.c(h);
            }
            if (g != null) {
                let i = new ChartBorder();
                DMLChartExtensions.a4(i, g, d);
                a.border = i;
            }
            a._invertIfNegative$i = ExcelUtils.dv(CT_Boolean.g(c.c));
            if (c.e != null) {
                let j = Math.min(400, c.e.g);
                a._explosion$i = Nullable$1.toNullable(Number_$type, j);
            }
        }
    }
    static y(a, b, c, d) {
        if (b == null) {
            return;
        }
        let e = b.a;
        let f = e != null ? e.a : null;
        if (f != null) {
            a.fill = DMLChartUtils.d(f.n);
        }
        if (f != null && f.h.hasValue) {
            a.widthInPoints = ExcelUtils.cj(ST_LineWidth.m(f.h.value));
        }
    }
    static w(a, b, c, d) {
        let e = typeCast(ChartLineBase.$, a);
        WorksheetChartExtensions.y(e, b, c, d);
    }
    static x(a, b, c, d) {
        let e = typeCast(ChartLineBase.$, a);
        WorksheetChartExtensions.y(e, b, c, d);
    }
    static ao(a, b, c, d) {
        if (b == null) {
            return;
        }
        a.gapWidth = b.a != null ? b.a.c : 150;
        let e = b.e;
        let f = b.c;
        if (e != null) {
            WorksheetChartExtensions.an(a.upBar, e, c, d);
        }
        if (f != null) {
            WorksheetChartExtensions.an(a.downBar, f, c, d);
        }
    }
    static an(a, b, c, d) {
        if (b == null) {
            return;
        }
        let e = b.a;
        let f = e != null ? e.a : null;
        if (e != null) {
            a.fill = DMLChartUtils.c(e.l);
        }
        if (f != null) {
            let g = new ChartBorder();
            DMLChartExtensions.a4(g, f, c);
            a.border = g;
        }
    }
    static ar(a, b, c, d) {
        let e = b.d;
        let f = e != null ? e.e : null;
        let g = f != null ? f.a : null;
        let h = b.b;
        if (h == null) {
            return;
        }
        if (g == null) {
            return;
        }
        if (g.c == null || g.c.count == 0) {
            return;
        }
        a._i8();
        try {
            let i = null;
            let j = null;
            let k = null;
            let l = WorksheetChartExtensions.e(b, g.c);
            a.chartType = l;
            j = b.j;
            k = j != null ? j.a : null;
            if (j != null) {
                a.chartArea.fill = DMLChartUtils.c(j.l);
                if (k != null) {
                    i = new ChartBorder();
                    DMLChartExtensions.a4(i, k, c);
                    a.chartArea.border = i;
                }
            }
            let m = g.a;
            if (m != null) {
                j = m.a;
                k = j != null ? j.a : null;
                a.plotArea.fill = DMLChartUtils.c(j.l);
                if (k != null) {
                    i = new ChartBorder();
                    DMLChartExtensions.a4(i, k, c);
                    a.plotArea.border = i;
                }
            }
            WorksheetChartExtensions.ay(a, e.a, b, c, d);
            let n = new Dictionary$2(Number_$type, CT_Data.$, 0);
            for (let o of fromEnum(h.c)) {
                n.addItem(o.f, o);
            }
            let p = new Dictionary$2(Number_$type, Axis.$, 0);
            let q = 0;
            let r = 0;
            for (let s = 0; s < f.d.count; s++) {
                let t = f.d._inner[s];
                let u = t.e != null ? 1 : 2;
                let v = 1;
                switch (u) {
                    case 1:
                        q += 1;
                        v = q == 1 ? 1 : 2;
                        break;
                    case 2:
                        r += 1;
                        v = r == 1 ? 1 : 2;
                        break;
                }
                let w = a._axisCollection$i.add(u, v);
                WorksheetChartExtensions.v(w, t, b, c, d);
                p.addItem(t.aa, w);
            }
            let x = new HashSet$1(Number_$type, 0);
            let y = new Dictionary$2(Number_$type, CT_Series.$, 0);
            for (let z = 0; z < g.c.count; z++) {
                let aa = g.c._inner[z];
                y.addItem(intSToU(z), aa);
                if (aa.w.hasValue && aa.w.value) {
                    x.add_1(intSToU(z));
                }
            }
            let ab = new Dictionary$2(CT_Series.$, Series.$, 0);
            for (let ac of fromEnum(g.c)) {
                if (ac.w.hasValue && ac.w.value) {
                    continue;
                }
                if (ac.y.hasValue) {
                    if (x.contains(ac.y.value)) {
                        continue;
                    }
                }
                let ad = a._seriesCollection$i.add();
                WorksheetChartExtensions.aj(ad, a, ac, b, c, d, n, p, y);
                ab.addItem(ac, ad);
            }
            for (let ae = 0; ae < g.c.count; ae++) {
                let af = g.c._inner[ae];
                if (af.y.hasValue) {
                    let ag = af.y.value;
                    if (ag >= 0 && ag < g.c.count) {
                        let ah = g.c._inner[ag];
                        let ai = null;
                        let aj = null;
                        if (((() => { let ak = ab.tryGetValue(af, ai); ai = ak.p1; return ak.ret; })()) && ((() => { let ak = ab.tryGetValue(ah, aj); aj = ak.p1; return ak.ret; })())) {
                            ai.owningSeries = aj;
                        }
                    }
                }
            }
            if (e.c != null) {
                let ak = new Legend();
                WorksheetChartExtensions.ai(ak, e.c, a, c, d);
                a.legend = ak;
            }
        }
        finally {
            a._ja();
        }
    }
    static aj(a, b, c, d, e, f, g, h, i) {
        a.chartType = WorksheetChartExtensions.f(c.m);
        let j = null;
        let k = c.a;
        if (k == null) {
        }
        let l = null;
        if (k != null) {
            let m;
            if (((() => { let n = g.tryGetValue(k.b, m); m = n.p1; return n.ret; })()) == false) {
                return;
            }
            if (m.b != null) {
                if (m.b.a != null) {
                    if (((() => { let n = d.l.tryGetValue(m.b.a.d, l); l = n.p1; return n.ret; })())) {
                        j = l._j;
                    }
                }
                a.xValues = new XValues(e, j, 0, null, null);
            }
            if (m.a != null) {
                if (m.a.a != null) {
                    if (((() => { let n = d.l.tryGetValue(m.a.a.d, l); l = n.p1; return n.ret; })())) {
                        j = l._j;
                    }
                }
                a.values = new SeriesValues(e, j, null, false);
            }
            else if (m.c != null) {
                if (m.c.a != null) {
                    if (((() => { let n = d.l.tryGetValue(m.c.a.d, l); l = n.p1; return n.ret; })())) {
                        j = l._j;
                    }
                }
                a.values = new SeriesValues(e, j, null, false);
                a.values._v = true;
            }
        }
        if (c.g != null && c.g.a != null) {
            j = null;
            if (c.g.a.a != null && ((() => { let n = d.l.tryGetValue(c.g.a.a.d, l); l = n.p1; return n.ret; })())) {
                j = l._j;
            }
            let n = c.g.a.c;
            a.name = SeriesName._b(e, j, n);
        }
        let o = c.o;
        let p = o != null ? o.a : null;
        if (o != null) {
            a.fill = DMLChartUtils.c(o.l);
        }
        if (p != null) {
            let q = ChartExDeserializer.e(a.chartType);
            if (q) {
                let r = new ChartLine();
                DMLChartExtensions.a6(r, p, e);
                a.line = r;
            }
            else {
                let s = new ChartBorder();
                DMLChartExtensions.a4(s, p, e);
                a.border = s;
            }
        }
        for (let t of fromEnum(c.q)) {
            let u = null;
            if (((() => { let v = h.tryGetValue(t.h, u); u = v.p1; return v.ret; })()) == false) {
                continue;
            }
            if (u.type == 2) {
                a.axisGroup = u.axisGroup;
                break;
            }
        }
        let v = c.e;
        let w = v != null ? v.b : null;
        if (w != null) {
            a.axisBinning = ChartExDeserializer.b(w);
        }
        if (a.chartType == 114) {
            a.boxAndWhiskerSettings = ChartExDeserializer.a(v);
        }
        if (v != null && v.i != null && v.i.b.hasValue) {
            a.showWaterfallConnectorLines = v.i.b.value;
        }
        if (v != null && v.c != null) {
            a.geographicMapSettings = WorksheetChartExtensions.i(v.c, c.k, c.i, v.g, e);
        }
        let x = c.r;
        let y = x.count > 0 ? new Dictionary$2(Number_$type, DataPoint.$, 0) : null;
        for (let z = 0; z < x.count; z++) {
            let aa = x._inner[z];
            o = aa.a;
            p = o != null ? o.a : null;
            let ab = DMLChartUtils.c(o.l);
            let ac = null;
            if (p != null) {
                ac = new ChartBorder();
                DMLChartExtensions.a4(ac, p, e);
            }
            let ad = new DataPoint(null);
            ad.fill = ab;
            ad.border = ac;
            let ae = aa.d;
            let af = null;
            if (((() => { let ag = y.tryGetValue(ae, af); af = ag.p1; return ag.ret; })()) == false) {
                y.addItem(ae, ad);
            }
        }
        let ag = v != null ? v.m : null;
        if (ag != null && ag.a.count > 0) {
            if (y == null) {
                y = new Dictionary$2(Number_$type, DataPoint.$, 0);
            }
            for (let ah of fromEnum(ag.a)) {
                let ai = ah;
                let aj = null;
                if (((() => { let ak = y.tryGetValue(ai, aj); aj = ak.p1; return ak.ret; })()) == false) {
                    aj = new DataPoint(null);
                    y.addItem(ai, aj);
                }
                aj.setAsTotal = true;
            }
        }
        let ak = c.c;
        if (ak != null) {
            let al = Nullable$1.toNullable(DataLabelPosition_$type, null);
            if (a.chart.chartType == 118) {
                al = Nullable$1.toNullable(DataLabelPosition_$type, 1);
            }
            a.showDataLabels = true;
            WorksheetChartExtensions.ak(a.dataLabels, ak, v, e, f);
            if (al.hasValue) {
                a.dataLabels.labelPosition = al.value;
            }
            if (ak.i.count > 0) {
                if (y == null) {
                    y = new Dictionary$2(Number_$type, DataPoint.$, 0);
                }
                for (let am of fromEnum(ak.i)) {
                    let an = am.i;
                    let ao = null;
                    if (((() => { let ap = y.tryGetValue(an, ao); ao = ap.p1; return ap.ret; })()) == false) {
                        ao = new DataPoint(null);
                        y.addItem(an, ao);
                    }
                    let ap = new DataLabel();
                    WorksheetChartExtensions.ae(ap, am, e, f);
                    if (al.hasValue) {
                        ap.labelPosition = al.value;
                    }
                    ao.dataLabel = ap;
                }
                for (let aq of fromEnum(ak.j)) {
                    let ar = aq.b;
                    let as = null;
                    if (((() => { let at = y.tryGetValue(ar, as); as = at.p1; return at.ret; })()) == false) {
                        as = new DataPoint(null);
                        y.addItem(ar, as);
                    }
                    let at = as.dataLabel;
                    if (at == null) {
                        at = new DataLabel();
                    }
                    at.isDeleted = true;
                    if (al.hasValue) {
                        at.labelPosition = al.value;
                    }
                    as.dataLabel = at;
                }
            }
        }
        if (y != null) {
            a._dataPointCollection$i._ak(y);
        }
    }
    static ai(a, b, c, d, e) {
        if (b == null) {
            return;
        }
        if (b.j.hasValue) {
            a.overlay = b.j.value;
        }
        if (b.l.hasValue) {
            let f = b.h.hasValue ? b.h.value : 1;
            a.position = ChartExExtensions.f(b.l.value, f);
        }
        let g = b.d;
        let h = g != null ? g.a : null;
        if (g != null) {
            a.fill = DMLChartUtils.c(g.l);
        }
        if (h != null) {
            let i = new ChartBorder();
            DMLChartExtensions.a4(i, h, d);
            a.border = i;
        }
        let j = b.e;
        if (j != null) {
            DMLChartUtils.a7(a, j, d);
        }
        let k = c._seriesCollection$i.count;
        let l = new Array(k);
        for (let m = 0; m < k; m++) {
            l[m] = new LegendEntry(a);
        }
        a._legendEntries$i._ag(l);
    }
    static ak(a, b, c, d, e) {
        WorksheetChartExtensions.ae(a, b, d, e);
        if (c != null && c.e != null) {
            a.parentLabelLayout = ChartExExtensions.g(c.e.a);
        }
    }
    static ae(a, b, c, d) {
        if (b == null) {
            return;
        }
        if (b.b != null) {
            a.numberFormat = b.b.c;
            a.numberFormatLinked = b.b.a.hasValue ? b.b.a.value : stringIsNullOrEmpty(a.numberFormat);
        }
        let e = b.c;
        let f = e != null ? e.a : null;
        let g = null;
        let h = b.d;
        WorksheetChartExtensions.t(a, e, f, g, h, null, c, d);
        a.separator = b.h;
        WorksheetChartExtensions.au(a, b.a, c, d);
        if (b.g.hasValue) {
            a.labelPosition = ChartExExtensions.a(b.g.value);
        }
    }
    static au(a, b, c, d) {
        if (b == null) {
            return;
        }
        a._showCategoryName$i = SerializationUtils.r(b.a);
        a._showSeriesName$i = SerializationUtils.r(b.c);
        a._showValue$i = SerializationUtils.r(b.e);
    }
    static v(a, b, c, d, e) {
        let f = d.workbook;
        WorksheetChartExtensions.at(a, b.t, f, true);
        let g = b.s;
        let h = g != null ? g.a : null;
        if (g != null) {
            a.tickLabels.fill = DMLChartUtils.c(g.l);
        }
        if (h != null) {
            let i = new ChartTickLines();
            DMLChartExtensions.a7(i, h, d);
            a.tickLines = i;
        }
        WorksheetChartExtensions.as(a, b.e, b.r, d, e);
        WorksheetChartExtensions.ax(a, b.a, c, d, e);
        if (b.j != null) {
            a.tickLabels.numberFormat = b.j.c;
            if (b.j.a.hasValue) {
                a.tickLabels.numberFormatLinked = b.j.a.value;
            }
        }
        if (b.f != null) {
            let j = DMLChartUtils.g(b.f.a, 0, a, true);
            a.majorGridLines = j;
        }
        if (b.h != null) {
            let k = DMLChartUtils.g(b.h.a, 1, a, true);
            a.minorGridLines = k;
        }
        if (b.n != null && b.n.b.hasValue) {
            a.majorTickMark = ChartExExtensions.h(b.n.b.value);
        }
        else {
            a.majorTickMark = 4142;
        }
        if (b.p != null && b.p.b.hasValue) {
            a.minorTickMark = ChartExExtensions.h(b.p.b.value);
        }
        else {
            a.minorTickMark = 4142;
        }
        if (b.w.hasValue && b.w.value) {
            a.visible = false;
        }
        let l = b.c;
        if (l != null) {
            if (l.d.hasValue) {
                a.displayUnit = ChartExExtensions.b(l.d.value);
            }
            else {
                a.displayUnit = -4114;
            }
            let m = l.a;
            if (m != null) {
                let n = new DisplayUnitLabel();
                let o = null;
                if (m.a != null) {
                    o = ChartExExtensions.i(m.a);
                }
                WorksheetChartExtensions.ah(n, m.b, o, m.c, null, d, e);
                a.displayUnitLabel = n;
                if (a.displayUnit == -4114 && n.text != null) {
                    let p = n.text.unformattedString;
                    let q;
                    if (((() => { let r = tryParseNumber(p, q); q = r.p1; return r.ret; })())) {
                        a.displayUnit = -4114;
                        a.displayUnitCustom = q;
                        n.text = null;
                    }
                }
            }
        }
    }
    static as(a, b, c, d, e) {
        if (b != null) {
            if (b.a != null && b.a.b.hasValue) {
                let f = b.a.b.value * 100;
                f = Math.min(f, 500);
                f = Math.max(f, 0);
                a._gapWidth$i = Nullable$1.toNullable(Number_$type, f);
            }
        }
        else if (c != null) {
            if (c.b == null) {
                a.maximumScaleIsAuto = true;
            }
            else {
                a.maximumScaleIsAuto = c.b.a;
                if (c.b.b.hasValue) {
                    a.maximumScale = c.b.b.value;
                }
            }
            if (c.d == null) {
                a.minimumScaleIsAuto = true;
            }
            else {
                a.minimumScaleIsAuto = c.d.a;
                if (c.d.b.hasValue) {
                    a.minimumScale = c.d.b.value;
                }
            }
            if (c.f == null) {
                a.majorUnitIsAuto = true;
            }
            else {
                a.majorUnitIsAuto = c.f.a;
                if (c.f.b.hasValue) {
                    a.majorUnit = c.f.b.value;
                }
            }
            if (c.h == null) {
                a.minorUnitIsAuto = true;
            }
            else {
                a.minorUnitIsAuto = c.h.a;
                if (c.h.b.hasValue) {
                    a.minorUnit = c.h.b.value;
                }
            }
        }
    }
    static c(a, b, c, d) {
        if (a == null) {
            return null;
        }
        let e = new ChartTitle();
        let f = a.b;
        let g = f != null ? f.a : null;
        let h = a.a != null ? a.a.b : null;
        let i = ((() => {
            let $ret = new CT_Tx();
            $ret.b = h;
            return $ret;
        })());
        WorksheetChartExtensions.t(e, f, g, i, a.c, new CT_Layout(), c, d);
        if (a.a != null && a.a.a != null) {
            let j = a.a.a.a;
            if (j != null) {
                let k;
                if (((() => { let l = b.l.tryGetValue(j.d, k); k = l.p1; return l.ret; })())) {
                    e._a5 = k._j;
                }
            }
            let l = a.a.a.c;
            if (e.text == null && stringIsNullOrEmpty(l) == false) {
                e.text = new FormattedString(l);
            }
        }
        return e;
    }
    static ax(a, b, c, d, e) {
        if (b == null) {
            return;
        }
        a.axisTitle = WorksheetChartExtensions.c(b, c, d, e);
    }
    static ay(a, b, c, d, e) {
        if (b == null) {
            return;
        }
        let f = WorksheetChartExtensions.c(b, c, d, e);
        if (b.k.hasValue) {
            f.overlay = b.k.value;
        }
        f.position = WorksheetChartExtensions.h(b.l, b.j);
        a.chartTitle = f;
    }
    static h(a, b) {
        if (a.hasValue == false) {
            a = Nullable$1.toNullable(ST_SidePos_$type, 1);
        }
        if (b.hasValue == false) {
            b = Nullable$1.toNullable(ST_PosAlign_$type, 1);
        }
        switch (a.value) {
            case 1:
                switch (b.value) {
                    case 1: return 100;
                    case 0: return 104;
                    case 2: return 105;
                }
                break;
            case 3:
                switch (b.value) {
                    case 1: return 103;
                    case 0: return 106;
                    case 2: return 107;
                }
                break;
            case 0:
                switch (b.value) {
                    case 1: return 101;
                    case 0: return 108;
                    case 2: return 109;
                }
                break;
            case 2:
                switch (b.value) {
                    case 1: return 102;
                    case 0: return 110;
                    case 2: return 111;
                }
                break;
        }
        return 100;
    }
    static e(a, b) {
        let c = 0;
        for (let d of fromEnum(b)) {
            switch (d.m) {
                case 1:
                    c += 1;
                    continue;
                case 3: return 116;
                case 0: return 114;
                case 2: return 115;
                case 4: return 121;
                case 5: return 118;
                case 6: return 119;
                case 7: return 120;
            }
        }
        return c > 0 ? 117 : 0;
    }
    static f(a) {
        switch (a) {
            case 0: return 114;
            case 1: return 51;
            case 3: return 116;
            case 5: return 118;
            case 6: return 119;
            case 7: return 120;
            case 2: return 115;
            case 4: return 121;
            default: return 0;
        }
    }
    static i(a, b, c, d, e) {
        if (a == null && b == null && c == null && d == null) {
            return null;
        }
        let f = c != null && c.h.hasValue && c.h.value > 2 ? 1 : 0;
        let g = null;
        let h = null;
        let i = null;
        if (b != null) {
            if (b.e != null) {
                g = DMLChartUtils.af(b.e);
            }
            if (b.c != null) {
                h = DMLChartUtils.af(b.c);
            }
            if (b.a != null) {
                i = DMLChartUtils.af(b.a);
            }
        }
        let j = null;
        if (WorkbookColorInfo.l_op_Inequality(g, null) || WorkbookColorInfo.l_op_Inequality(h, null) || WorkbookColorInfo.l_op_Inequality(i, null) || f != 0) {
            j = new GeographicMapColors(f, g, h, i);
        }
        let k = a != null ? a.j : "en-US";
        let l = a != null ? a.l : "US";
        let m = a != null ? a.h : "Powered by Bing";
        let n = d != null ? ChartExExtensions.c(d.a) : 0;
        let o = Nullable$1.toNullable(GeographicMapProjection_$type, null);
        let p = Nullable$1.toNullable(GeographicMappingArea_$type, null);
        if (a != null && a.d.hasValue) {
            o = Nullable$1.toNullable(GeographicMapProjection_$type, ChartExExtensions.e(a.d.value));
        }
        if (a != null && a.f.hasValue) {
            p = Nullable$1.toNullable(GeographicMappingArea_$type, ChartExExtensions.d(a.f.value));
        }
        let q = new GeographicMapSettings(k, l, m, o, p, n, j);
        return q;
    }
    static aw(a, b, c) {
        let d = false;
        let e = 0;
        for (let f of fromEnum(c)) {
            let g = f.key;
            let h = f.value.chart;
            if (h.axisIds == null) {
                e += 1;
                continue;
            }
            for (let i of fromEnum(h.axisIds)) {
                let j = null;
                if (((() => { let k = b.tryGetValue(i.g, j); j = k.p1; return k.ret; })())) {
                    if (j.c.type == 2) {
                        g.axisGroup = j.c.axisGroup;
                        if (g.axisGroup == 1) {
                            d = true;
                        }
                        break;
                    }
                }
            }
        }
        if (e == 0) {
            return;
        }
        let k = 0;
        for (let l of fromEnum(c)) {
            let m = l.key;
            let n = l.value.chart;
            if (n.axisIds != null) {
                continue;
            }
            k += 1;
            if (d == false) {
                m.axisGroup = k == 1 ? 1 : 2;
            }
            else {
                m.axisGroup = 2;
            }
        }
    }
    static l(a, b, c) {
        b = null;
        c = false;
        if (a == null) {
            return {
                ret: false,
                p1: b,
                p2: c
            };
        }
        b = SerializationUtils.v(a.c);
        c = a.a;
        return {
            ret: true,
            p1: b,
            p2: c
        };
    }
    static az(a, b, c) {
        if (a == null || a.m == null || a.m.count == 0) {
            return;
        }
        let d = new List$1(Trendline.$, 0);
        for (let e of fromEnum(b)) {
            for (let f of fromEnum(e._trendlineCollection$i)) {
                d.add(f);
            }
        }
        if (d.count == 0) {
            return;
        }
        let g = new Dictionary$2(Number_$type, CT_LegendEntry.$, 0);
        let h = b.count - 1;
        for (let i of fromEnum(a.m)) {
            let j = i.b.g;
            if (j <= h) {
                continue;
            }
            g.addItem(j, i);
        }
        for (let k = 0; k < d.count; k++) {
            let l = b.count + k;
            let m = null;
            if (((() => { let n = g.tryGetValue(l, m); m = n.p1; return n.ret; })())) {
                let n = d._inner[k];
                n.legendEntry = DMLChartUtils.m(m, c);
            }
        }
    }
    static m(a) {
        if (a == null) {
            return false;
        }
        let b = a.b;
        let c = b != null ? b.d : null;
        let d = false;
        if (c != null) {
            for (let e of fromEnum(c)) {
                if (e.f == null) {
                    return false;
                }
                for (let f of fromEnum(e.f)) {
                    if (f.b != null) {
                        return false;
                    }
                    if (f.a != null && stringIsNullOrEmpty(f.a.c) == false) {
                        d = true;
                    }
                }
            }
        }
        return d;
    }
    static o(a, b = true) {
        let c = new List$1(ISeries_$type, 0);
        for (let d of fromEnum(a)) {
            let e = d.getSeries();
            c.o(e);
        }
        if (b) {
            DocCoreUtils.ar(ISeries_$type, c, new ISeriesSortComparer());
        }
        return c;
    }
    static n(a) {
        if (a == null) {
            return null;
        }
        let b = new List$1(IChart_$type, 0);
        if (a.c != null) {
            b.add(a.c);
        }
        if (a.d != null) {
            b.add(a.d);
        }
        if (a.b != null) {
            b.add(a.b);
        }
        if (a.e != null) {
            b.add(a.e);
        }
        if (a.f != null) {
            b.add(a.f);
        }
        if (a.g != null) {
            b.add(a.g);
        }
        if (a.h != null) {
            b.add(a.h);
        }
        if (a.i != null) {
            b.add(a.i);
        }
        if (a.j != null) {
            b.add(a.j);
        }
        if (a.m != null) {
            b.add(a.m);
        }
        if (a.n != null) {
            b.add(a.n);
        }
        if (a.o != null) {
            b.add(a.o);
        }
        if (a.p != null) {
            b.add(a.p);
        }
        if (a.q != null) {
            b.add(a.q);
        }
        if (a.r != null) {
            b.add(a.r);
        }
        if (a.s != null) {
            b.add(a.s);
        }
        if (a.t != null) {
            b.add(a.t);
        }
        if (a.u != null) {
            b.add(a.u);
        }
        if (a.v != null) {
            b.add(a.v);
        }
        if (a.w != null) {
            b.add(a.w);
        }
        if (a.x != null) {
            b.add(a.x);
        }
        if (a.y != null) {
            b.add(a.y);
        }
        if (a.z != null) {
            b.add(a.z);
        }
        if (a.aa != null) {
            b.add(a.aa);
        }
        if (a.ab != null) {
            b.add(a.ab);
        }
        if (a.ac != null) {
            b.add(a.ac);
        }
        if (a.ad != null) {
            b.add(a.ad);
        }
        if (a.ae != null) {
            b.add(a.ae);
        }
        return b;
    }
    static t(a, b, c, d, e, f, g, h) {
        let i = g.workbook;
        if (c != null) {
            let j = new ChartBorder(a.owner);
            DMLChartExtensions.a4(j, c, g);
            a.border = j;
        }
        if (b != null) {
            a.fill = DMLChartUtils.c(b.l);
        }
        if (d != null) {
            if (d.a != null) {
                let k = d.a.e;
                let l = WorkbookLoadManagerExcel2007._bs(k);
                k = l.p0;
                let m = Formula._k(k, 1, 0, i.currentFormat, CultureInfo.invariantCulture, h._bi);
                a._b2(g, m);
            }
            else {
                a.text = DMLChartUtils.t(d, a);
            }
        }
        else if (e != null) {
            a.text = DMLChartUtils.u(e, a);
        }
        let n = e != null ? e.a : null;
        if (n == null && d != null && d.b != null) {
            n = d.b.a;
        }
        if (n != null) {
            if (n.x.hasValue) {
                a.horizontalOverflow = DMLChartExtensions.r(n.x.value);
            }
            if (n.at.hasValue) {
                a.verticalOverflow = DMLChartExtensions.s(n.at.value);
            }
            if (n.ar.hasValue) {
                a.textDirection = DMLChartExtensions.q(n.ar.value);
            }
            if (n.af.hasValue) {
                let o = ST_Angle.j(n.af.value);
                a.rotation = ExcelUtils.cl(o);
            }
            if (n.av.hasValue) {
                a.wrapText = n.av.value == 1;
            }
            if (n.l.hasValue) {
                a.verticalAlignment = DMLChartExtensions.y(n.l.value);
            }
        }
        let p = e != null && e.d != null && e.d.count > 0 ? e.d._inner[0] : null;
        let q = p != null ? p.c : null;
        if (q == null && d != null && d.b != null && d.b.d != null && d.b.d.count > 0) {
            q = d.b.d._inner[0].c;
        }
        if (q != null) {
            a.readingOrder = q.m.hasValue == false ? -5002 : q.m.value ? -5004 : -5003;
            if (q.a != null) {
                let r = a._e(i);
                DMLChartUtils.a5(r, typeCast(CT_TextCharacterProperties_DML.$, q.a));
                if (nullableEquals(q.a.r, null) && r.height >= 0) {
                }
            }
        }
        let s = -4105;
        let t, u, v, w;
        let x = Nullable$1.toNullable(Boolean_$type, null);
        let y = DMLChartUtils.a8(f, s, t, u, v, w, x);
        s = y.p1;
        t = y.p2;
        u = y.p3;
        v = y.p4;
        w = y.p5;
        x = y.p6;
        a.position = s;
        a.left = t;
        a.top = u;
    }
    static r(a, b, c, d, e) {
        let f = b.f.k.ah;
        let g = new List$1(Axis.$, 0);
        let h = 1;
        let i = 1;
        let j = new Dictionary$2(Number_$type, Axis.$, 1, 4);
        let k = new List$1(Tuple$2.$.specialize(Number_$type, Axis.$), 0);
        let l = 0;
        for (let m = 0; m < f.count; m++) {
            let n = f._inner[m];
            let o = 1;
            switch (n.axisType) {
                case 1:
                    o = h;
                    h = 2;
                    break;
                case 2:
                    o = i;
                    i = 2;
                    break;
                case 3:
                    o = 1;
                    break;
            }
            let p = n.axisType;
            if (l > 1) {
                p = 1;
            }
            let q = a._axisCollection$i.add(p, o);
            if (n.axisType == 2) {
                l += 1;
            }
            WorksheetChartExtensions.s(q, n, b, c, d);
            j.addItem(n.id, q);
            k.add(Tuple.a(Number_$type, Axis.$, n.crossAxId, q));
            e.addItem(n.id, Tuple.a(Axis.$, IAxis_$type, q, n));
        }
        if (WorksheetChart._gr(a.chartType) == false) {
            let r = a._axisCollection$i.item(2, 1);
            let s = a._axisCollection$i.item(2, 2);
            if (r != null && s != null) {
                r._ab = s;
                s._ab = r;
            }
            return;
        }
        for (let t of fromEnum(k)) {
            let u = null;
            if (((() => { let v = j.tryGetValue(t.c, u); u = v.p1; return v.ret; })())) {
                t.d._ab = u;
            }
        }
        let v = new Dictionary$2(Axis.$, AxisCrosses_$type, 0);
        let w = new Dictionary$2(Axis.$, Number_$type, 0);
        let x = new Dictionary$2(Axis.$, Boolean_$type, 0);
        for (let y of fromEnum(e.values)) {
            let z = y.c._ab;
            if (z == null) {
                continue;
            }
            let aa = -4105;
            if (((() => { let ab = v.tryGetValue(z, aa); aa = ab.p1; return ab.ret; })()) == false) {
                v.addItem(z, y.c.crosses);
            }
            let ab = NaN;
            if (((() => { let ac = w.tryGetValue(z, ab); ab = ac.p1; return ac.ret; })()) == false) {
                w.addItem(z, y.c.crossesAt);
            }
            let ac = false;
            if (((() => { let ad = x.tryGetValue(z, ac); ac = ad.p1; return ad.ret; })()) == false) {
                x.addItem(z, y.c.axisBetweenCategories);
            }
        }
        for (let ad of fromEnum(v)) {
            ad.key.crosses = ad.value;
        }
        for (let ae of fromEnum(w)) {
            ae.key._dy(ae.value, false);
        }
        for (let af of fromEnum(x)) {
            af.key.axisBetweenCategories = af.value;
        }
    }
    static s(a, b, c, d, e) {
        let f = d.workbook;
        let g = b.sharedProps;
        let h = c.f;
        let i = a.chart;
        if (g.e != null) {
            a.position = DMLChartExtensions.b(g.e.a);
        }
        if (g.n != null) {
            let j = new ChartTitle();
            j._l(i);
            WorksheetChartExtensions.aa(j, g.n, h, b, d, e);
            a.axisTitle = j;
        }
        let k = b.baseUnit;
        if (k != null) {
            a.baseUnit = k.c.hasValue ? DMLChartExtensions.w(k.c.value) : 0;
            a.baseUnitIsAuto = k.d;
        }
        let l = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        let m = Nullable$1.toNullable(ST_TimeUnit_$type, null);
        if (((() => { let n = b._tryGetMajorMinorTimeUnit$i(m, l); m = n.p0; l = n.p1; return n.ret; })())) {
            if (m.hasValue) {
                a.majorUnitScale = DMLChartExtensions.w(m.value);
                a.majorUnitIsAuto = false;
            }
            else {
                a.majorUnitIsAuto = true;
            }
            if (l.hasValue) {
                a.minorUnitScale = DMLChartExtensions.w(l.value);
                a.minorUnitIsAuto = false;
            }
            else {
                a.minorUnitIsAuto = true;
            }
        }
        let n = g.o;
        let o = n != null ? n.a : null;
        a.categoryType = b._categoryType$i.hasValue ? b._categoryType$i.value : -4105;
        let p = g.h != null ? g.h.a : 0;
        a.crosses = DMLChartExtensions.a(p);
        if (g.b != null) {
            a.crossesAt = g.b.f;
        }
        a.axisBetweenCategories = b.axisCrossesBetween;
        let q = b.dispUnits;
        let r = Nullable$1.toNullable(Number_$type, null);
        a.displayUnit = q != null ? ((() => { let s = DMLChartUtils.j(q, r); r = s.p1; return s.ret; })()) : -4142;
        if (r.hasValue) {
            a.displayUnitCustom = r.value;
        }
        let s = q != null ? q.c : null;
        if (s != null) {
            let t = new DisplayUnitLabel();
            WorksheetChartExtensions.ag(t, s, d, e);
            a.displayUnitLabel = t;
        }
        let u;
        let v;
        if (((() => { let w = WorksheetChartExtensions.l(g.i, u, v); u = w.p1; v = w.p2; return w.ret; })())) {
            a.tickLabels.numberFormat = u;
            a.tickLabels.numberFormatLinked = v;
        }
        let w = g.j;
        if (w != null) {
            if (w.g != null) {
                a.reversePlotOrder = (w.g.a == 4);
            }
            let x = w.e;
            if (x != null) {
                a.logBase = x.a;
            }
            a.scaleType = x != null ? -4133 : -4132;
            a.minimumScaleIsAuto = true;
            a.maximumScaleIsAuto = true;
            if (w.c != null) {
                a.minimumScaleIsAuto = false;
                a.minimumScale = w.c.f;
            }
            if (w.a != null) {
                a.maximumScaleIsAuto = false;
                a.maximumScale = w.a.f;
            }
        }
        let y, z;
        if (((() => { let aa = b._tryGetMajorMinorUnit$i(y, z); y = aa.p0; z = aa.p1; return aa.ret; })())) {
            if (z.hasValue && y.hasValue && z.value >= y.value) {
                z = nullableDivide(y, 5);
            }
            a._dt(y, z);
        }
        if (g.k != null) {
            a.tickLabelPosition = DMLChartExtensions.u(g.k.b);
        }
        a.majorTickMark = g.l != null ? DMLChartExtensions.v(g.l.b) : 4142;
        a.minorTickMark = g.m != null ? DMLChartExtensions.v(g.m.b) : 4142;
        if (o != null) {
            let aa = DMLChartUtils.i(o);
            a.tickLines = aa;
        }
        if (n != null) {
            a.tickLabels.fill = DMLChartUtils.c(n.l);
        }
        let ab = g.p;
        WorksheetChartExtensions.at(a, ab, f, false);
        let ac = b._tickLabelAlignment$i;
        if (ac.hasValue) {
            a.tickLabels.alignment = DMLChartExtensions.t(ac.value);
        }
        if (b._tickLabelMultiLevel$i.hasValue) {
            a.tickLabels.multiLevel = b._tickLabelMultiLevel$i.value;
        }
        let ad = b._tickMarkSkipValue$i;
        let ae = b._tickLabelSkip$i;
        if (ad.hasValue) {
            a.tickMarkSpacing = ad.value;
        }
        a.tickLabelSpacingIsAuto = true;
        if (ae.hasValue) {
            a.tickLabelSpacing = ae.value;
            a.tickLabelSpacingIsAuto = false;
        }
        let af = b._tickLabelOffset$i;
        if (af.hasValue) {
            a.tickLabels.offset = af.value;
        }
        let ag = ab != null ? ab.a : null;
        if (ag != null && ag.ar.hasValue) {
            a.tickLabels.textDirection = DMLChartExtensions.q(ag.ar.value);
        }
        if (ag != null && ag.af.hasValue) {
            if (ag.af.value == -60000000) {
                let ah = Nullable$1.toNullable(Number_$type, null);
                let ai = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
                let aj = g.n;
                ab = aj != null ? aj.i : null;
                ag = ab != null ? ab.a : null;
                if (ag != null) {
                    ai = ag.ar;
                    ah = ag.af;
                }
                if (a.axisTitle != null && ai.hasValue == false && ah.hasValue == false) {
                    a.axisTitle.textDirection = 2;
                    a.axisTitle.rotation = 0;
                }
            }
            else {
                let ak = ST_Angle.j(ag.af.value);
                a.tickLabels.rotation = ExcelUtils.cl(ak);
            }
        }
        if (g.f != null) {
            let al = DMLChartUtils.f(g.f, 0, a);
            a.majorGridLines = al;
        }
        if (g.g != null) {
            let am = DMLChartUtils.f(g.g, 1, a);
            a.minorGridLines = am;
        }
        a.visible = g.a == null || g.a.k == false;
    }
    static at(a, b, c, d) {
        if (b != null && b.d != null && b.d.count > 0) {
            let e = b.d._inner[0];
            let f = e != null ? e.c : null;
            let g = f != null ? typeCast(CT_TextCharacterProperties_DML.$, f.a) : null;
            let h = e != null ? typeCast(CT_TextCharacterProperties_DML.$, e.a) : null;
            if (g == null) {
                g = h;
            }
            if (g != null) {
                let i = a.tickLabels._e(c);
                DMLChartUtils.a5(i, g);
            }
            if (f != null) {
                a.tickLabels.readingOrder = f.m.hasValue == false ? -5002 : f.m.value ? -5004 : -5003;
            }
        }
        let j = b != null ? b.a : null;
        if (d && j != null) {
            let k = a.tickLabels;
            let l;
            let m;
            let n = WorksheetChartExtensions.q(j, l, m);
            l = n.p1;
            m = n.p2;
            k.rotation = l;
            k.textDirection = m;
            if (j.l.hasValue && j.l.value == 1) {
                k.alignment = -4108;
            }
            else if (j.m.hasValue && j.m.value) {
                k.alignment = -4108;
            }
        }
    }
    static av(a, b, c, d, e, f) {
        let g = e.workbook;
        let h = c.chart;
        let i = c.sharedProps;
        let j = i.d;
        let k = j != null ? j.l : null;
        let l = i.c;
        b.name = DMLChartUtils.n(l, e, f);
        let m = h._sT_Shape$i;
        if (m.hasValue) {
            b._barShape$i = Nullable$1.toNullable(BarShape_$type, DMLChartExtensions.c(m.value));
        }
        let n = c.getSeriesChartType(a.chartType, c.seriesType);
        if (j != null && j.a != null) {
            let o = new ChartBorder(null);
            DMLChartExtensions.a4(o, j.a, e);
            if (WorksheetChart._gd(n, 1)) {
                let p = new ChartLine();
                p.fill = o.fill;
                p.widthInPoints = o.widthInPoints;
                p.lineStyle = DMLChartExtensions.m(o.lineStyle);
                b.line = p;
            }
            else {
                b.border = o;
            }
        }
        b.chartType = n;
        b.type = h.seriesType;
        if (k != null) {
            let q = DMLChartUtils.c(k);
            b.fill = q;
        }
        b.bubbleSizes = c.getBubbleSizes(e, f);
        let r = c.cT_ErrBars;
        if (r != null) {
            b.errorBars = DMLChartUtils.k(r, e);
        }
        b.invertIfNegative = c.invertIfNegativeValue;
        let s = c.cT_NumDataSource;
        if (s != null) {
            if (s.b != null) {
                b.values = typeCast(SeriesValues.$, DMLChartUtils.p(s.b, e, f, false));
            }
            else if (s.a != null) {
                b.values = typeCast(SeriesValues.$, DMLChartUtils.o(s.a, e, f, false));
            }
        }
        let t = c.cT_AxDataSource;
        if (t != null) {
            if (t.e != null) {
                b.xValues = DMLChartUtils.s(t.e, e, f);
            }
            else if (t.a != null) {
                b.xValues = DMLChartUtils.q(t.a, e, f);
            }
            else if (t.c != null) {
                b.xValues = typeCast(XValues.$, DMLChartUtils.p(t.c, e, f, true));
            }
            else if (t.d != null) {
                b.xValues = typeCast(XValues.$, DMLChartUtils.r(t.d, e, f));
            }
            else if (t.b != null) {
                b.xValues = typeCast(XValues.$, DMLChartUtils.o(t.b, e, f, true));
            }
        }
        let u = c.cT_Marker;
        if (u != null) {
            let v = null;
            let w = null;
            let x = Nullable$1.toNullable(Number_$type, null);
            let y = Nullable$1.toNullable(MarkerStyle_$type, null);
            let z = WorksheetChartExtensions.p(u, e, v, w, x, y);
            v = z.p2;
            w = z.p3;
            x = z.p4;
            y = z.p5;
            b.markerFill = v;
            b.markerBorder = w;
            if (x.hasValue) {
                b.markerSize = x.value;
            }
            if (y.hasValue) {
                b.markerStyle = y.value;
            }
        }
        else if (WorksheetChart._f4(a.chartType)) {
            b.markerStyle = -4105;
        }
        if (i.b != null) {
            b.plotOrder = i.b.g;
        }
        let aa = c.cT_PictureOptions;
        if (aa != null) {
            b.applyPicToEnd = aa.a != null ? aa.a.k : false;
            b.applyPicToFront = aa.c != null ? aa.c.k : false;
            b.applyPicToSides = aa.e != null ? aa.e.k : false;
            if (aa.g != null) {
                b.pictureType = DMLChartExtensions.p(aa.g.a);
            }
            if (aa.i != null) {
                b.pictureUnit = aa.i.a;
            }
        }
        let ab = c.getExplosion();
        if (ab != null) {
            let ac = Math.min(400, ab.g);
            b.explosion = ac;
            if (b.explosion > 0) {
                switch (b.chartType) {
                    case 5:
                        b.chartType = 69;
                        break;
                    case -4102:
                        b.chartType = 70;
                        break;
                    case -4120:
                        b.chartType = 80;
                        break;
                }
            }
        }
        let ad = c.getSmooth();
        if (ad != null) {
            b.smooth = ad.k;
        }
        let ae = c.getTrendlines();
        if (ae != null) {
            let af = b._trendlineCollection$i;
            for (let ag of fromEnum(ae)) {
                let ah = new Trendline(af);
                WorksheetChartExtensions.al(ah, ag, e, f);
                af._al(ah);
            }
        }
        let ai = null;
        let aj = null;
        let ak = ((() => { let al = c.getDLbls(aj); aj = al.p0; return al.ret; })());
        if (ak != null) {
            ai = CT_DLbls.c(ak.b);
        }
        let al = c.getDataPoints();
        WorksheetChartExtensions.u(a, b, c, ak, ai, aj, al, e, f);
        if (c.isBubble3D) {
            a.chartType = 87;
            b.chartType = 87;
        }
    }
    static u(a, b, c, d, e, f, g, h, i) {
        let j = h.workbook;
        let k = b._dataPointCollection$i;
        let l = null;
        let m = null;
        let n = new Dictionary$2(Number_$type, CT_DPt.$, 0);
        let o = new Dictionary$2(Number_$type, CT_DLbl.$, 0);
        let p = new Dictionary$2(Number_$type, DataPoint.$, 0);
        b.showDataLabels = false;
        if (d != null) {
            b.showDataLabels = true;
            let q = d.e.b;
            let r = CT_Boolean.g(d.e.a);
            let s = false;
            let t = d.e.d;
            if (e != null) {
                if (e.h != null) {
                    q = e.h;
                }
                if (e.g != null) {
                    r = e.g.k;
                }
                if (e.f != null) {
                    s = CT_Boolean.g(e.f);
                }
            }
            let u = b.dataLabels;
            WorksheetChartExtensions.ad(u, t, null, e, h, i);
            b.dataLabels.showLeaderLines = r;
            if (q != null) {
                l = q.a;
                m = l != null ? l.a : null;
                let v = new LeaderLines();
                DMLChartExtensions.a7(v, m, h);
                b.leaderLines = v;
            }
            if (d.f != null && d.f.count > 0) {
                for (let w of fromEnum(d.f)) {
                    let x = w.b;
                    if (x == null) {
                        continue;
                    }
                    o.addItem(x.g, w);
                }
            }
        }
        if (g != null && g.count > 0) {
            for (let y of fromEnum(g)) {
                let z = y.g;
                if (z == null) {
                    continue;
                }
                n.addItem(z.g, y);
            }
            for (let aa of fromEnum(n)) {
                let ab = aa.value;
                let ac = null;
                let ad = o.tryGetValue(aa.key, ac);
                ac = ad.p1;
                let ae = WorksheetChartExtensions.g(ab, ac, b, k, h, i);
                p.addItem(aa.key, ae);
            }
        }
        for (let af of fromEnum(o)) {
            let ag = null;
            if (((() => { let ah = n.tryGetValue(af.key, ag); ag = ah.p1; return ah.ret; })()) == false) {
                let ah = WorksheetChartExtensions.g(ag, af.value, b, k, h, i);
                p.addItem(af.key, ah);
            }
        }
        k._ak(p);
        if (f != null && f.h != null) {
            let ai = f.h.c;
            if (stringIsNullOrEmpty(ai) == false) {
                let aj = WorkbookLoadManagerExcel2007._bs(ai);
                ai = aj.p0;
                let ak = typeCast(SingleTargetFormula.$, Formula._k(ai, 1, 0, j.currentFormat, CultureInfo.invariantCulture, i._bi));
                b.dataLabels._eb(h, ak);
            }
        }
    }
    static g(a, b, c, d, e, f) {
        let g = new DataPoint(d);
        if (a != null) {
            WorksheetChartExtensions.af(g, c, a, e, f);
        }
        if (b != null) {
            let h = new DataLabel();
            let i = CT_DLbls.c(CT_ExtensionList.a(b.e));
            WorksheetChartExtensions.ab(h, b, i, e, f);
            g.dataLabel = h;
        }
        let j = a != null ? a.i : null;
        if (j != null) {
            let k = null;
            let l = null;
            let m = Nullable$1.toNullable(Number_$type, null);
            let n = Nullable$1.toNullable(MarkerStyle_$type, null);
            let o = WorksheetChartExtensions.p(j, e, k, l, m, n);
            k = o.p2;
            l = o.p3;
            m = o.p4;
            n = o.p5;
            g.markerFill = k;
            g.markerBorder = l;
            if (m.hasValue) {
                g._markerSize$i = Nullable$1.toNullable(Number_$type, m.value);
            }
            if (n.hasValue) {
                g._markerStyle$i = Nullable$1.toNullable(MarkerStyle_$type, n.value);
            }
        }
        if (a != null && a.e != null) {
            g._explosion$i = Nullable$1.toNullable(Number_$type, a.e.g);
        }
        let p = a != null ? a.k : null;
        if (p != null) {
            if (p.a != null) {
                g._applyPicToEnd$i = ExcelUtils.dv(p.a.k);
            }
            if (p.c != null) {
                g._applyPicToFront$i = ExcelUtils.dv(p.c.k);
            }
            if (p.e != null) {
                g._applyPicToSides$i = ExcelUtils.dv(p.e.k);
            }
        }
        return g;
    }
    static p(a, b, c, d, e, f) {
        c = null;
        d = null;
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(MarkerStyle_$type, null);
        if (a != null) {
            let g = a.e;
            let h = g != null ? g.a : null;
            if (g != null) {
                c = DMLChartUtils.c(g.l);
            }
            if (h != null) {
                d = new ChartBorder(null);
                DMLChartExtensions.a4(d, h, b);
            }
            if (a.a != null) {
                e = Nullable$1.toNullable(Number_$type, a.a.b);
            }
            if (a.c != null) {
                f = Nullable$1.toNullable(MarkerStyle_$type, DMLChartExtensions.o(a.c.a));
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static d(a) {
        let b = WorksheetChartExtensions.b(a);
        if (b.length > 1) {
            let c = b[0];
            switch (c) {
                case 88:
                case 89:
                case 90:
                case 91: return c;
                default: break;
            }
            return 113;
        }
        let d = WorksheetChartExtensions.j(a);
        return d != null ? d.getChartType(a, null) : 0;
    }
    static b(a) {
        let b = WorksheetChartExtensions.a(a);
        let c = new List$1(ChartType_$type, 0);
        for (let e = 0; e < b.length; e++) {
            let d = b[e];
            c.add(d.getChartType(a, null));
        }
        return c.toArray();
    }
    static a(a) {
        let b = a != null ? a.f : null;
        let c = b != null ? b.k : null;
        let d = [c.b, c.c, c.d, c.e, c.f, c.g, c.h, c.i, c.j, c.m, c.n, c.o, c.p, c.q, c.r, c.s, c.t, c.u, c.v, c.w, c.x, c.y, c.z, c.aa, c.ab, c.ac, c.ad, c.ae];
        let e = new List$1(IChart_$type, 0);
        for (let g = 0; g < d.length; g++) {
            let f = d[g];
            if (f != null) {
                e.add(f);
            }
        }
        return e.toArray();
    }
    static j(a) {
        let b = a.f != null ? a.f.k : null;
        if (b == null) {
            return null;
        }
        if (b.b != null) {
            return b.b;
        }
        else if (b.c != null) {
            return b.c;
        }
        else if (b.ac != null) {
            return b.ac;
        }
        else if (b.e != null) {
            return b.e;
        }
        else if (b.f != null) {
            return b.f;
        }
        else if (b.h != null) {
            return b.h;
        }
        else if (b.i != null) {
            return b.i;
        }
        else if (b.n != null) {
            return b.n;
        }
        else if (b.m != null) {
            return b.m;
        }
        else if (b.p != null) {
            return b.p;
        }
        else if (b.p != null) {
            return b.p;
        }
        else if (b.s != null) {
            return b.s;
        }
        else if (b.r != null) {
            return b.r;
        }
        else if (b.u != null) {
            return b.u;
        }
        else if (b.y != null) {
            return b.y;
        }
        else if (b.ae != null) {
            return b.ae;
        }
        else if (b.ad != null) {
            return b.ad;
        }
        else {
            return null;
        }
    }
    static k($t, a) {
        if (getBoxIfEnum($t, a) == null) {
        }
        return getBoxIfEnum($t, a) != null;
    }
    static q(a, b, c) {
        let d = 0;
        if (a.af.hasValue) {
            d = a.af.value;
        }
        if (d == -60000000) {
            c = 2;
            b = 0;
        }
        else {
            let e = ST_Angle.j(d);
            b = ExcelUtils.cl(e);
            if (a.ar.hasValue) {
                c = DMLChartExtensions.q(a.ar.value);
            }
            else {
                c = 0;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
}
WorksheetChartExtensions.$t = markType(WorksheetChartExtensions, 'WorksheetChartExtensions');
/**
 * @hidden
 */
export class InvalidXLSXElementException extends BaseError {
    constructor(a) {
        super(1, a);
        this._elementName_1 = null;
        this._elementName = a;
    }
    get _elementName() {
        return this._elementName_1;
    }
    set _elementName(a) {
        this._elementName_1 = a;
    }
}
InvalidXLSXElementException.$t = markType(InvalidXLSXElementException, 'InvalidXLSXElementException', BaseError.$);
/**
 * @hidden
 */
export class DeserializedChartInfo extends Base {
    constructor() {
        super();
        this.c = null;
        this.d = null;
        this.f = null;
        this.b = null;
        this.e = null;
        this.g = 0;
        this.c = new Dictionary$2(String_$type, CT_ChartSpace.$, 0);
        this.d = new Dictionary$2(String_$type, CT_ChartSpaceEx.$, 0);
        this.f = new Dictionary$2(String_$type, CT_ChartStyle.$, 0);
        this.e = new Dictionary$2(String_$type, CT_ColorStyle.$, 0);
        this.g = 0;
    }
    static a(a) {
        let b = ((() => {
            let $ret = new DeserializedChartInfo();
            $ret.b = typeCast(CT_StyleMatrix.$, a.d);
            return $ret;
        })());
        for (let c of fromEnum(a.a)) {
            let d = typeCast(CT_ChartSpace.$, c.value);
            let e = d == null ? typeCast(CT_ChartSpaceEx.$, c.value) : null;
            if (d == null && e == null) {
                continue;
            }
            if (d != null) {
                b.c.addItem(c.key, d);
            }
            else if (e != null) {
                b.d.addItem(c.key, e);
            }
        }
        for (let f of fromEnum(a.b)) {
            let g = typeCast(CT_ChartStyle.$, f.value);
            if (g == null) {
                continue;
            }
            b.f.addItem(f.key, g);
        }
        for (let h of fromEnum(a.c)) {
            let i = typeCast(CT_ColorStyle.$, h.value);
            if (i == null) {
                continue;
            }
            b.e.addItem(h.key, i);
        }
        return b;
    }
}
DeserializedChartInfo.$t = markType(DeserializedChartInfo, 'DeserializedChartInfo');
/**
 * @hidden
 */
export class ConditionalFormattingSerializer extends Base {
    constructor(a) {
        super();
        this.p = null;
        this.s = null;
        this.m = null;
        this.m = a;
    }
    static a(a) {
        if (a._conditionalFormats$i.count == 0) {
            return null;
        }
        else {
            return new ConditionalFormattingSerializer(a);
        }
    }
    get n() {
        return this.s != null && this.s.count > 0;
    }
    w(a, b) {
        if (this.p != null) {
            this.p.clear();
        }
        else {
            this.p = new Dictionary$2(ConditionalFormatBase.$, Number_$type, 0);
        }
        for (let c of fromEnum(b)) {
            let d = typeCast(ConditionalFormatBase.$, c);
            if (d == null || d._bw == null) {
                continue;
            }
            let e = a._ba(d._bw);
            this.p.item(d, e);
        }
    }
    x(a, b, c) {
        let d = this.m._conditionalFormats$i;
        let e = ConditionalFormattingSerializer.q(d);
        this.s = new List$1(ConditionX14Wrapper.$, 0);
        for (let f of fromEnum(e.values)) {
            if (f.a == false) {
                for (let g of fromEnum(f.e)) {
                    let h = ((() => {
                        let $ret = new ConditionX14Wrapper();
                        $ret.a = g;
                        $ret.d = ConditionX14Wrapper.c();
                        $ret.b = false;
                        return $ret;
                    })());
                    this.s.add(h);
                }
                continue;
            }
            let i = new List$1(String_$type, 0);
            ConditionBase._a1(this.m, f.c, 1, false, true, i);
            SpreadsheetMLMain.z7(a, i, f.b);
            for (let j = 0; j < f.e.count; j++) {
                let k = null;
                let l = f.e._inner[j];
                k = this.l(a, b, c, l);
                if (k != null) {
                    this.s.add(k);
                }
            }
            c.k();
        }
    }
    y(a, b, c, d = false) {
        if (this.n == false) {
            return;
        }
        if (d) {
            SpreadsheetMLMain.abg(a);
        }
        SpreadsheetMLMain.aba(a, "{78C0D931-6437-407d-A8EE-F0AAD7539E65}", SpreadsheetML2009Main.b0);
        SpreadsheetML2009Main.de(a);
        let e = ConditionalFormattingSerializer.r(this.s);
        for (let f of fromEnum(e.values)) {
            SpreadsheetML2009Main.dd(a, Excel2006Main.aq, Nullable$1.toNullable(Boolean_$type, f.b));
            for (let g of fromEnum(f.e)) {
                X14Serializer.f(a, b, c, g);
            }
            let h = ConditionBase._a1(this.m, f.c, 1, false, true, null, Nullable$1.toNullable(String_$type, ConditionalFormattingSerializer.o));
            Excel2006Main.av(a, h);
            c.k();
            c.k();
        }
        c.k();
        c.k();
        if (d) {
            c.k();
        }
    }
    l(a, b, c, d) {
        switch (d.conditionType) {
            case 0: return this.i(typeCast(OperatorConditionalFormat.$, d), a, b, c);
            case 1: return this.g(typeCast(FormulaConditionalFormat.$, d), a, b, c);
            case 11: return this.b(typeCast(AverageConditionalFormat.$, d), a, b, c);
            case 4: return this.j(typeCast(RankConditionalFormat.$, d), a, b, c);
            case 8: return this.k(typeCast(TextOperatorConditionalFormat.$, d), a, b, c);
            case 10: return this.f(typeCast(DateTimeConditionalFormat.$, d), a, b, c);
            case 3: return this.e(typeCast(DataBarConditionalFormat.$, d), a, b, c);
            case 2: return this.c(typeCast(ColorScaleConditionalFormat.$, d), a, b, c);
            case 5: return this.h(typeCast(IconSetConditionalFormat.$, d), a, b, c);
            case 7:
            case 6:
            case 13:
            case 14:
            case 9:
            case 12:
                let e = typeCast(ConditionalFormatBase.$, d);
                return this.d(e, a, b, c);
            default: return null;
        }
    }
    i(a, b, c, d) {
        if (ConditionBaseExtensions.b(a)) {
            let e = ((() => {
                let $ret = new ConditionX14Wrapper();
                $ret.a = a;
                $ret.d = ConditionX14Wrapper.c();
                $ret.b = false;
                return $ret;
            })());
            return e;
        }
        let f = this.t(a);
        let g = EnumConverter.j(a.operator);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 1), f, a.priority, a.stopIfTrue, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, g));
        let h = c._ct(a.operand1);
        let i = c._ct(a.operand2);
        ConditionalFormattingSerializer.ae(b, d, h);
        ConditionalFormattingSerializer.ae(b, d, i);
        d.k();
        return null;
    }
    g(a, b, c, d) {
        if (ConditionBaseExtensions.b(a)) {
            let e = ((() => {
                let $ret = new ConditionX14Wrapper();
                $ret.a = a;
                $ret.d = ConditionX14Wrapper.c();
                $ret.b = false;
                return $ret;
            })());
            return e;
        }
        let f = this.t(a);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 0), f, a.priority, a.stopIfTrue);
        let g = c._ct(a.formula);
        ConditionalFormattingSerializer.ae(b, d, g);
        d.k();
        return null;
    }
    b(a, b, c, d) {
        let e = this.t(a);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = ConditionalFormattingSerializer.v(a, f, g, h);
        f = i.p1;
        g = i.p2;
        h = i.p3;
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 17), e, a.priority, a.stopIfTrue, f, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), null, Nullable$1.toNullable(ST_TimePeriod_$type, null), Nullable$1.toNullable(Number_$type, null), g, h);
        d.k();
        return null;
    }
    j(a, b, c, d) {
        let e = this.t(a);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Boolean_$type, null);
        let h = intSToU(a.rank);
        if (a.isPercent) {
            f = Nullable$1.toNullable(Boolean_$type, true);
        }
        if (a.topBottom == 0) {
            g = Nullable$1.toNullable(Boolean_$type, true);
        }
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 5), e, a.priority, a.stopIfTrue, Nullable$1.toNullable(Boolean_$type, null), f, g, Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), null, Nullable$1.toNullable(ST_TimePeriod_$type, null), Nullable$1.toNullable(Number_$type, h));
        d.k();
        return null;
    }
    k(a, b, c, d) {
        let e = this.t(a);
        let f = a.textOperator;
        let g = EnumConverter.g(a.conditionType, Nullable$1.toNullable(FormatConditionTextOperator_$type, f));
        let h = EnumConverter.i(f);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, g), e, a.priority, a.stopIfTrue, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, h), a.text);
        let i = ConditionalFormattingUtils.f(a);
        if (stringIsNullOrEmpty(i) == false) {
            ConditionalFormattingSerializer.ae(b, d, i);
        }
        d.k();
        return null;
    }
    f(a, b, c, d) {
        let e = this.t(a);
        let f = EnumConverter.n(a.dateOperator);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 16), e, a.priority, a.stopIfTrue, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), null, Nullable$1.toNullable(ST_TimePeriod_$type, f));
        let g = ConditionalFormattingUtils.e(a);
        if (stringIsNullOrEmpty(g) == false) {
            ConditionalFormattingSerializer.ae(b, d, g);
        }
        d.k();
        return null;
    }
    d(a, b, c, d) {
        let e = a.conditionType;
        switch (e) {
            case 13:
            case 14:
            case 9:
            case 12:
            case 6:
            case 7: break;
            default: return null;
        }
        let f = this.t(a);
        let g = EnumConverter.g(e, Nullable$1.toNullable(FormatConditionTextOperator_$type, null));
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, g), f, a.priority, a.stopIfTrue);
        let h = false;
        switch (e) {
            case 13:
            case 14:
            case 9:
            case 12:
                h = true;
                break;
        }
        if (h) {
            let i = ConditionalFormattingUtils.d(a);
            if (stringIsNullOrEmpty(i) == false) {
                ConditionalFormattingSerializer.ae(b, d, i);
            }
        }
        d.k();
        return null;
    }
    e(a, b, c, d) {
        let e = Nullable$1.toNullable(Number_$type, null);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 3), e, a.priority, a.stopIfTrue);
        let f = c._ct(a.formula);
        ConditionalFormattingSerializer.ae(b, d, f);
        let g = Nullable$1.toNullable(Number_$type, intSToU(a.fillPercentMin));
        let h = Nullable$1.toNullable(Number_$type, intSToU(a.fillPercentMax));
        let i = Nullable$1.toNullable(Boolean_$type, null);
        if (a.showValue == false) {
            i = Nullable$1.toNullable(Boolean_$type, false);
        }
        SpreadsheetMLMain.aao(b, g, h, i);
        let j = a.worksheet;
        let k = [a.minPoint, a.maxPoint];
        ConditionValueExtensions.b(a.minPoint, b, c, d, j, false);
        ConditionValueExtensions.b(a.maxPoint, b, c, d, j, false);
        ConditionalFormattingSerializer.z(b, d, j, a._cv, SpreadsheetMLMain.et);
        d.k();
        let l = null;
        if (ConditionBaseExtensions.b(a)) {
            l = ((() => {
                let $ret = new ConditionX14Wrapper();
                $ret.a = a;
                $ret.d = ConditionX14Wrapper.c();
                $ret.b = true;
                return $ret;
            })());
            this.aa(b, d, l.d);
        }
        d.k();
        return l;
    }
    h(a, b, c, d) {
        if (ConditionBaseExtensions.b(a)) {
            let e = ((() => {
                let $ret = new ConditionX14Wrapper();
                $ret.a = a;
                $ret.d = ConditionX14Wrapper.c();
                $ret.b = false;
                return $ret;
            })());
            return e;
        }
        let f = Nullable$1.toNullable(Number_$type, null);
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 4), f, a.priority, a.stopIfTrue);
        let g = c._ct(a.formula);
        ConditionalFormattingSerializer.ae(b, d, g);
        let h = ExcelUtils.aj(a.iconSet);
        SpreadsheetMLMain.ab6(b, SpreadsheetMLMain.js, Nullable$1.toNullable(ST_IconSetType_$type, h), Nullable$1.toNullable(Boolean_$type, a._cm), Nullable$1.toNullable(Boolean_$type, a.isReverseOrder), Nullable$1.toNullable(Boolean_$type, a.showValue), Nullable$1.toNullable(Boolean_$type, false));
        let i = a.worksheet;
        for (let j = 0; j < a._iconCriteria$i.count; j++) {
            let k = a._iconCriteria$i.item(j);
            let l = k.comparison == 0;
            ConditionValueExtensions.b(k._b, b, c, d, i, false, Nullable$1.toNullable(Boolean_$type, l));
        }
        d.k();
        d.k();
        return null;
    }
    c(a, b, c, d) {
        if (ConditionBaseExtensions.b(a)) {
            let e = ((() => {
                let $ret = new ConditionX14Wrapper();
                $ret.a = a;
                $ret.d = ConditionX14Wrapper.c();
                $ret.b = false;
                return $ret;
            })());
            return e;
        }
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = a.worksheet;
        SpreadsheetMLMain.zp(b, SpreadsheetMLMain.ef, Nullable$1.toNullable(ST_CfType_$type, 2), f, a.priority, a.stopIfTrue);
        let h = c._ct(a.formula);
        ConditionalFormattingSerializer.ae(b, d, h);
        SpreadsheetMLMain.z0(b);
        ConditionValueExtensions.b(a.minimumThreshold._b, b, c, d, g, false);
        if (a.colorScaleType == 1) {
            ConditionValueExtensions.b(a.midpointThreshold._b, b, c, d, g, false);
        }
        ConditionValueExtensions.b(a.maximumThreshold._b, b, c, d, g, false);
        ColorInfoExtensions.d(a.minimumThreshold._al, b, d, g, SpreadsheetMLMain.et);
        if (a.colorScaleType == 1) {
            ColorInfoExtensions.d(a.midpointThreshold._al, b, d, g, SpreadsheetMLMain.et);
        }
        ColorInfoExtensions.d(a.maximumThreshold._al, b, d, g, SpreadsheetMLMain.et);
        d.k();
        d.k();
        return null;
    }
    static z(a, b, c, d, e) {
        if (WorkbookColorInfo.l_op_Equality(d, null)) {
            return;
        }
        ColorInfoExtensions.d(d, a, b, c, e);
    }
    aa(a, b, c) {
        SpreadsheetMLMain.abg(a);
        SpreadsheetMLMain.aba(a, "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}", SpreadsheetML2009Main.b0);
        if (stringIsNullOrEmpty(c) == false) {
            SpreadsheetML2009Main.dk(a, c);
            b.k();
        }
        b.k();
        b.k();
    }
    static ae(a, b, c) {
        if (stringIsNullOrEmpty(c)) {
            return;
        }
        SpreadsheetMLMain.aby(a, c);
        b.k();
    }
    static q(a) {
        let b = new Dictionary$2(String_$type, ConditionalFormattingWrapper.$, 1, a.count);
        for (let c of fromEnum(a)) {
            let d = c._a0(1, false);
            let e = ConditionalFormattingWrapperBase.d(d, c._af);
            let f = null;
            if (((() => { let g = b.tryGetValue(e, f); f = g.p1; return g.ret; })()) == false) {
                f = new ConditionalFormattingWrapper(c.regions);
                f.b = c._af;
                b.addItem(e, f);
            }
            f.e.add(c);
        }
        for (let g of fromEnum(b.values)) {
            let h = false;
            for (let i of fromEnum(g.e)) {
                let j = ConditionBaseExtensions.a(i);
                if (j != 1) {
                    h = true;
                    break;
                }
            }
            g.a = h;
        }
        return b;
    }
    static r(a) {
        let b = new Dictionary$2(String_$type, ConditionalFormattingX14Wrapper.$, 1, a.count);
        for (let c of fromEnum(a)) {
            let d = c.a;
            let e = d._a0(1, false);
            let f = ConditionalFormattingWrapperBase.d(e, d._af);
            let g = null;
            if (((() => { let h = b.tryGetValue(f, g); g = h.p1; return h.ret; })()) == false) {
                g = new ConditionalFormattingX14Wrapper(d.regions);
                g.b = d._af;
                b.addItem(f, g);
            }
            g.e.add(c);
        }
        return b;
    }
    t(a) {
        if (this.p == null) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        if (a._bw == null) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        let b = 0;
        if (((() => { let c = this.p.tryGetValue(a, b); b = c.p1; return c.ret; })())) {
            return Nullable$1.toNullable(Number_$type, b);
        }
        else {
            return Nullable$1.toNullable(Number_$type, null);
        }
    }
    static v(a, b, c, d) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        let e = a.aboveBelow;
        switch (e) {
            case 0: break;
            case 4:
            case 2:
                if (e == 2) {
                    d = Nullable$1.toNullable(Boolean_$type, true);
                }
                break;
            case 1:
            case 5:
            case 3:
                b = Nullable$1.toNullable(Boolean_$type, false);
                if (e == 3) {
                    d = Nullable$1.toNullable(Boolean_$type, true);
                }
                break;
        }
        switch (e) {
            case 4:
            case 5:
                c = Nullable$1.toNullable(Number_$type, a.numericStandardDeviation);
                break;
            default: break;
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static u(a) {
        if (isNaN_(a)) {
            a = 0;
        }
        return numberToString(a, CultureInfo.invariantCulture);
    }
    static ab(a, b, c, d) {
        let e = b._ct(d);
        ConditionalFormattingSerializer.ad(a, c, e);
    }
    static ac(a, b, c) {
        let d = ConditionalFormattingSerializer.u(c);
        ConditionalFormattingSerializer.ac(a, b, c);
    }
    static ad(a, b, c) {
        if (stringIsNullOrEmpty(c)) {
            return;
        }
        Excel2006Main.au(a, c);
        b.k();
    }
}
ConditionalFormattingSerializer.$t = markType(ConditionalFormattingSerializer, 'ConditionalFormattingSerializer');
ConditionalFormattingSerializer.o = ' ';
/**
 * @hidden
 */
export class ConditionalFormattingWrapperBase extends Base {
    constructor(a) {
        super();
        this.a = false;
        this.b = false;
        this.c = null;
        this.c = a;
    }
    static d(a, b) {
        return stringFormat("{0}_{1}", a, b);
    }
}
ConditionalFormattingWrapperBase.$t = markType(ConditionalFormattingWrapperBase, 'ConditionalFormattingWrapperBase');
/**
 * @hidden
 */
export class ConditionalFormattingWrapper extends ConditionalFormattingWrapperBase {
    constructor(a) {
        super(a);
        this.e = null;
        this.e = new List$1(ConditionBase.$, 0);
    }
}
ConditionalFormattingWrapper.$t = markType(ConditionalFormattingWrapper, 'ConditionalFormattingWrapper', ConditionalFormattingWrapperBase.$);
/**
 * @hidden
 */
export class ConditionalFormattingX14Wrapper extends ConditionalFormattingWrapperBase {
    constructor(a) {
        super(a);
        this.e = null;
        this.e = new List$1(ConditionX14Wrapper.$, 0);
    }
}
ConditionalFormattingX14Wrapper.$t = markType(ConditionalFormattingX14Wrapper, 'ConditionalFormattingX14Wrapper', ConditionalFormattingWrapperBase.$);
/**
 * @hidden
 */
export class ConditionX14Wrapper extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.d = null;
        this.b = false;
    }
    static c() {
        return Guid.newGuid().toString2("B").toUpperCase();
    }
}
ConditionX14Wrapper.$t = markType(ConditionX14Wrapper, 'ConditionX14Wrapper');
/**
 * @hidden
 */
export class X14Serializer extends Base {
    static f(a, b, c, d) {
        let e = d.a;
        let f = d.d;
        let g = d.b;
        switch (e.conditionType) {
            case 0:
                X14Serializer.e(a, b, c, typeCast(OperatorConditionalFormat.$, e), f);
                break;
            case 1:
                X14Serializer.c(a, b, c, typeCast(FormulaConditionalFormat.$, e), f);
                break;
            case 2:
                X14Serializer.a(a, b, c, typeCast(ColorScaleConditionalFormat.$, e), f);
                break;
            case 3:
                X14Serializer.b(a, b, c, typeCast(DataBarConditionalFormat.$, e), f, g);
                break;
            case 5:
                X14Serializer.d(a, b, c, typeCast(IconSetConditionalFormat.$, e), f);
                break;
            case 11:
            case 4:
            case 7:
            case 6:
            case 8:
            case 10:
            case 13:
            case 14:
            case 9:
            case 12: break;
            default: break;
        }
    }
    static a(a, b, c, d, e) {
        let f = 2;
        let g = false;
        let h = g ? 0 : d.priority;
        let i = g && d.stopIfTrue;
        let j = d.worksheet;
        let k = d.formula;
        let l = k != null;
        SpreadsheetML2009Main.da(a, e, Nullable$1.toNullable(ST_CfType_$type, f), h, i, Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), Nullable$1.toNullable(Boolean_$type, l));
        if (k != null) {
            ConditionalFormattingSerializer.ab(a, b, c, k);
        }
        SpreadsheetML2009Main.dc(a);
        ConditionValueExtensions.b(d.minimumThreshold._b, a, b, c, d.worksheet, true, Nullable$1.toNullable(Boolean_$type, null));
        if (d.colorScaleType == 1) {
            ConditionValueExtensions.b(d.midpointThreshold._b, a, b, c, d.worksheet, true, Nullable$1.toNullable(Boolean_$type, null));
        }
        ConditionValueExtensions.b(d.maximumThreshold._b, a, b, c, d.worksheet, true, Nullable$1.toNullable(Boolean_$type, null));
        ColorInfoExtensions.d(d.minimumThreshold._al, a, c, j, SpreadsheetML2009Main.ay);
        if (d.colorScaleType == 1) {
            ColorInfoExtensions.d(d.midpointThreshold._al, a, c, j, SpreadsheetML2009Main.ay);
        }
        ColorInfoExtensions.d(d.maximumThreshold._al, a, c, j, SpreadsheetML2009Main.ay);
        c.k();
        c.k();
    }
    static b(a, b, c, d, e, f) {
        let g = 3;
        let h = f ? 0 : d.priority;
        let i = f && d.stopIfTrue;
        let j = d.formula;
        let k = j != null;
        SpreadsheetML2009Main.da(a, e, Nullable$1.toNullable(ST_CfType_$type, g), h, i, Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), Nullable$1.toNullable(Boolean_$type, k));
        if (j != null) {
            ConditionalFormattingSerializer.ab(a, b, c, j);
        }
        let l = d.barFillType == 1;
        let m = EnumConverter.m(d.direction);
        let n = d.negativeBarFormat.barColorType == 1;
        let o = d.negativeBarFormat.barBorderColorType == 1;
        let p = EnumConverter.l(d.axisPosition);
        SpreadsheetML2009Main.df(a, Nullable$1.toNullable(Number_$type, intSToU(d.fillPercentMin)), Nullable$1.toNullable(Number_$type, intSToU(d.fillPercentMax)), Nullable$1.toNullable(Boolean_$type, d.showValue), Nullable$1.toNullable(Boolean_$type, d.showBorder), Nullable$1.toNullable(Boolean_$type, l), Nullable$1.toNullable(ST_DataBarDirection_$type, m), Nullable$1.toNullable(Boolean_$type, n), Nullable$1.toNullable(Boolean_$type, o), Nullable$1.toNullable(ST_DataBarAxisPosition_$type, p));
        ConditionValueExtensions.b(d.minPoint, a, b, c, d.worksheet, true, Nullable$1.toNullable(Boolean_$type, null));
        ConditionValueExtensions.b(d.maxPoint, a, b, c, d.worksheet, true, Nullable$1.toNullable(Boolean_$type, null));
        if (d.showBorder) {
            ColorInfoExtensions.d(d._ct, a, c, d.worksheet, SpreadsheetML2009Main.au);
        }
        if (d.negativeBarFormat.barColorType == 0) {
            ColorInfoExtensions.d(d.negativeBarFormat._r, a, c, d.worksheet, SpreadsheetML2009Main.b4);
        }
        if (d.negativeBarFormat.barBorderColorType == 0) {
            ColorInfoExtensions.d(d.negativeBarFormat._p, a, c, d.worksheet, SpreadsheetML2009Main.b3);
        }
        if (WorkbookColorInfo.l_op_Inequality(d.axisColor, null)) {
            ColorInfoExtensions.d(d.axisColor, a, c, d.worksheet, SpreadsheetML2009Main.ar);
        }
        c.k();
        c.k();
    }
    static d(a, b, c, d, e) {
        let f = 4;
        let g = false;
        let h = g ? 0 : d.priority;
        let i = g && d.stopIfTrue;
        let j = d.formula;
        let k = j != null;
        SpreadsheetML2009Main.da(a, e, Nullable$1.toNullable(ST_CfType_$type, f), h, i, Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), Nullable$1.toNullable(Boolean_$type, k));
        if (j != null) {
            ConditionalFormattingSerializer.ab(a, b, c, j);
        }
        let l = ExcelUtils.aj(d.iconSet);
        let m = d.isCustom;
        let n = Nullable$1.toNullable(Boolean_$type, null);
        let o = Nullable$1.toNullable(Boolean_$type, null);
        let p = d.showValue;
        SpreadsheetMLMain.ab6(a, SpreadsheetML2009Main.bt, Nullable$1.toNullable(ST_IconSetType_$type, l), n, o, Nullable$1.toNullable(Boolean_$type, p), Nullable$1.toNullable(Boolean_$type, m));
        ConditionalFormattingSerializer.ab(a, b, c, d.formula);
        let q = d.worksheet;
        for (let r = 0; r < d._iconCriteria$i.count; r++) {
            let s = d._iconCriteria$i.item(r);
            let t = s.comparison == 0;
            ConditionValueExtensions.b(s._b, a, b, c, q, true, Nullable$1.toNullable(Boolean_$type, t));
        }
        let u = d.isReverseOrder;
        let v = u ? d._iconCriteria$i.count : 0;
        let w = u ? -1 : d._iconCriteria$i.count;
        let x = u ? -1 : 1;
        for (let y = v; y != w; y += x) {
            let z = d._iconCriteria$i.item(y);
            let aa = z.iconSet;
            let ab = z.icon == -1 ? 0 : intSToU(((() => { let ac = IconSetConditionalFormat._cp(z.icon, aa); aa = ac.p1; return ac.ret; })()));
            let ac = z.icon == -1 ? 20 : ExcelUtils.aj(aa);
            SpreadsheetML2009Main.c9(a, ac, ab);
            c.k();
        }
        c.k();
        c.k();
    }
    static e(a, b, c, d, e) {
        let f = false;
        let g = 1;
        let h = f ? 0 : d.priority;
        let i = f && d.stopIfTrue;
        let j = EnumConverter.j(d.operator);
        SpreadsheetML2009Main.da(a, e, Nullable$1.toNullable(ST_CfType_$type, g), h, i, Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, j));
        ConditionalFormattingSerializer.ab(a, b, c, d.operand1);
        ConditionalFormattingSerializer.ab(a, b, c, d.operand2);
        if (d._bw != null) {
            ObjectModelStylesPartManager.cs(a, b, d._bw, SpreadsheetML2009Main.bi);
        }
        c.k();
    }
    static c(a, b, c, d, e) {
        let f = false;
        let g = 0;
        let h = f ? 0 : d.priority;
        let i = f && d.stopIfTrue;
        SpreadsheetML2009Main.da(a, e, Nullable$1.toNullable(ST_CfType_$type, g), h, i);
        ConditionalFormattingSerializer.ab(a, b, c, d.formula);
        if (d._bw != null) {
            ObjectModelStylesPartManager.cs(a, b, d._bw, SpreadsheetML2009Main.bi);
        }
        c.k();
    }
}
X14Serializer.$t = markType(X14Serializer, 'X14Serializer');
/**
 * @hidden
 */
export class ConditionBaseExtensions extends Base {
    static a(a) {
        let b = a.conditionType == 3 ? typeCast(DataBarConditionalFormat.$, a) : null;
        if (b != null) {
            return b._cz ? 2 : 0;
        }
        let c = a.conditionType == 5 ? typeCast(IconSetConditionalFormat.$, a) : null;
        if (c != null && c.isCustom) {
            return 1;
        }
        return a._z ? 1 : 0;
    }
    static b(a) {
        let b = ConditionBaseExtensions.a(a);
        return b != 0;
    }
}
ConditionBaseExtensions.$t = markType(ConditionBaseExtensions, 'ConditionBaseExtensions');
/**
 * @hidden
 */
export class FormatSchemeDeserializer extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
    }
    static cp(a) {
        a.ay(DrawingMLMain.d7, FormatSchemeDeserializer.a0);
        a.ax(DrawingMLMain.d7, FormatSchemeDeserializer.a1);
        a.ay(DrawingMLMain.bo, FormatSchemeDeserializer.v);
        a.ay(DrawingMLMain.dl, FormatSchemeDeserializer.ar);
        a.ay(DrawingMLMain.d0, FormatSchemeDeserializer.ay);
        a.ay(DrawingMLMain.fz, FormatSchemeDeserializer.bp);
        a.ay(DrawingMLMain.bt, FormatSchemeDeserializer.y);
        a.ay(DrawingMLMain.ej, FormatSchemeDeserializer.a4);
        a.ay(DrawingMLMain.es, FormatSchemeDeserializer.ba);
        a.ay(DrawingMLMain.gy, FormatSchemeDeserializer.bu);
        a.ay(DrawingMLMain.hh, FormatSchemeDeserializer.by);
        a.ay(DrawingMLMain.io, FormatSchemeDeserializer.cg);
        a.ay(DrawingMLMain.bs, FormatSchemeDeserializer.x);
        a.ay(DrawingMLMain.iz, FormatSchemeDeserializer.ci);
        a.ay(DrawingMLMain.i2, FormatSchemeDeserializer.cj);
        a.ay(DrawingMLMain.jj, FormatSchemeDeserializer.cl);
        a.ay(DrawingMLMain.a2, FormatSchemeDeserializer.h);
        a.ay(DrawingMLMain.a3, FormatSchemeDeserializer.i);
        a.ay(DrawingMLMain.a4, FormatSchemeDeserializer.j);
        a.ay(DrawingMLMain.a5, FormatSchemeDeserializer.k);
        a.ay(DrawingMLMain.a6, FormatSchemeDeserializer.l);
        a.ay(DrawingMLMain.a7, FormatSchemeDeserializer.m);
        a.ay(DrawingMLMain.ba, FormatSchemeDeserializer.o);
        a.ay(DrawingMLMain.bp, FormatSchemeDeserializer.w);
        a.ay(DrawingMLMain.bx, FormatSchemeDeserializer.ac);
        a.ay(DrawingMLMain.cj, FormatSchemeDeserializer.ae);
        a.ay(DrawingMLMain.cl, FormatSchemeDeserializer.ag);
        a.ay(DrawingMLMain.dd, FormatSchemeDeserializer.an);
        a.ay(DrawingMLMain.dr, FormatSchemeDeserializer.at);
        a.ay(DrawingMLMain.dx, FormatSchemeDeserializer.aw);
        a.ay(DrawingMLMain.eo, FormatSchemeDeserializer.a6);
        a.ay(DrawingMLMain.e6, FormatSchemeDeserializer.be);
        a.ay(DrawingMLMain.f4, FormatSchemeDeserializer.bq);
        a.ay(DrawingMLMain.jm, FormatSchemeDeserializer.cn);
        a.ay(DrawingMLMain.e7, FormatSchemeDeserializer.bf);
        a.ay(DrawingMLMain.hn, FormatSchemeDeserializer.bz);
        a.ay(DrawingMLMain.ie, FormatSchemeDeserializer.cc);
        a.ay(DrawingMLMain.ig, FormatSchemeDeserializer.cd);
        a.ay(DrawingMLMain.a1, FormatSchemeDeserializer.g);
        a.ay(DrawingMLMain.a8, FormatSchemeDeserializer.n);
        a.ay(DrawingMLMain.bu, FormatSchemeDeserializer.z);
        a.ay(DrawingMLMain.bv, FormatSchemeDeserializer.aa);
        a.ay(DrawingMLMain.bw, FormatSchemeDeserializer.ab);
        a.ay(DrawingMLMain.cp, FormatSchemeDeserializer.ai);
        a.ay(DrawingMLMain.ef, FormatSchemeDeserializer.a2);
        a.ay(DrawingMLMain.en, FormatSchemeDeserializer.a5);
        a.ay(DrawingMLMain.ep, FormatSchemeDeserializer.a7);
        a.ay(DrawingMLMain.eq, FormatSchemeDeserializer.a8);
        a.ay(DrawingMLMain.er, FormatSchemeDeserializer.a9);
        a.ay(DrawingMLMain.e8, FormatSchemeDeserializer.bg);
        a.ay(DrawingMLMain.e9, FormatSchemeDeserializer.bh);
        a.ay(DrawingMLMain.fa, FormatSchemeDeserializer.bi);
        a.ay(DrawingMLMain.fg, FormatSchemeDeserializer.bk);
        a.ay(DrawingMLMain.fi, FormatSchemeDeserializer.bl);
        a.ay(DrawingMLMain.f5, FormatSchemeDeserializer.br);
        a.ay(DrawingMLMain.f6, FormatSchemeDeserializer.bs);
        a.ay(DrawingMLMain.hx, FormatSchemeDeserializer.b2);
        a.ay(DrawingMLMain.hy, FormatSchemeDeserializer.b3);
        a.ay(DrawingMLMain.hz, FormatSchemeDeserializer.b4);
        a.ay(DrawingMLMain.ia, FormatSchemeDeserializer.b8);
        a.ay(DrawingMLMain.ib, FormatSchemeDeserializer.b9);
        a.ay(DrawingMLMain.ic, FormatSchemeDeserializer.ca);
        a.ay(DrawingMLMain.ii, FormatSchemeDeserializer.ce);
        a.ay(DrawingMLMain.cr, FormatSchemeDeserializer.aj);
        a.ay(DrawingMLMain.ck, FormatSchemeDeserializer.af);
        a.ay(DrawingMLMain.cn, FormatSchemeDeserializer.ah);
        a.ay(DrawingMLMain.dq, FormatSchemeDeserializer.as);
        a.ay(DrawingMLMain.dy, FormatSchemeDeserializer.ax);
        a.ay(DrawingMLMain.eu, FormatSchemeDeserializer.bc);
        a.ay(DrawingMLMain.fu, FormatSchemeDeserializer.bn);
        a.ay(DrawingMLMain.hf, FormatSchemeDeserializer.bx);
        a.ay(DrawingMLMain.jk, FormatSchemeDeserializer.cm);
        a.ay(DrawingMLMain.et, FormatSchemeDeserializer.bb);
        a.ay(DrawingMLMain.d1, FormatSchemeDeserializer.az);
        a.ay(DrawingMLMain.bn, FormatSchemeDeserializer.u);
        a.ay(DrawingMLMain.dv, FormatSchemeDeserializer.av);
        a.ay(DrawingMLMain.dk, FormatSchemeDeserializer.aq);
        a.ay(DrawingMLMain.dh, FormatSchemeDeserializer.ao);
        a.ay(DrawingMLMain.di, FormatSchemeDeserializer.ap);
        a.ay(DrawingMLMain.id, FormatSchemeDeserializer.cb);
        a.ay(DrawingMLMain.ip, FormatSchemeDeserializer.ch);
        a.ay(DrawingMLMain.ei, FormatSchemeDeserializer.a3);
        a.ay(DrawingMLMain.ff, FormatSchemeDeserializer.bj);
        a.ay(DrawingMLMain.hc, FormatSchemeDeserializer.bw);
        a.ay(DrawingMLMain.hq, FormatSchemeDeserializer.b1);
        a.ay(DrawingMLMain.h0, FormatSchemeDeserializer.b5);
        a.ay(DrawingMLMain.im, FormatSchemeDeserializer.cf);
        a.ay(DrawingMLMain.bi, FormatSchemeDeserializer.q);
        a.ay(DrawingMLMain.cd, FormatSchemeDeserializer.ad);
        a.ay(DrawingMLMain.ft, FormatSchemeDeserializer.bm);
        a.ay(DrawingMLMain.bc, FormatSchemeDeserializer.p);
        a.ay(DrawingMLMain.g3, FormatSchemeDeserializer.bv);
        a.ay(DrawingMLMain.jy, FormatSchemeDeserializer.co);
        a.ay(DrawingMLMain.h3, FormatSchemeDeserializer.b6);
        a.ay(DrawingMLMain.bl, FormatSchemeDeserializer.s);
        a.ay(DrawingMLMain.bm, FormatSchemeDeserializer.t);
        a.ay(DrawingMLMain.cs, FormatSchemeDeserializer.ak);
        a.ay(DrawingMLMain.du, FormatSchemeDeserializer.au);
        a.ay(DrawingMLMain.fw, FormatSchemeDeserializer.bo);
        a.ay(DrawingMLMain.bk, FormatSchemeDeserializer.r);
        a.ay(DrawingMLMain.cy, FormatSchemeDeserializer.al);
        a.ay(DrawingMLMain.ew, FormatSchemeDeserializer.bd);
        a.ay(DrawingMLMain.gl, FormatSchemeDeserializer.bt);
        a.ay(DrawingMLMain.ho, FormatSchemeDeserializer.b0);
        a.ay(DrawingMLMain.h6, FormatSchemeDeserializer.b7);
        a.ay(DrawingMLMain.je, FormatSchemeDeserializer.ck);
        a.ay(DrawingMLMain.dc, FormatSchemeDeserializer.am);
    }
    static a0(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = null;
        let d = CT_StyleMatrix.g(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_StyleMatrix();
            $ret.e = c;
            return $ret;
        })());
        let f = FormatSchemeDeserializer.b(FormatSchemeDeserializer.$, b, false);
        f = ((() => {
            let $ret = new FormatSchemeDeserializer();
            $ret.c = e;
            return $ret;
        })());
        b.s.k(f);
        b.s.k(e);
    }
    static a1(a) {
        let b = FormatSchemeDeserializer.b(FormatSchemeDeserializer.$, a);
        if (b == null) {
            return;
        }
        let c = typeCast(ObjectModelThemePartManager.$, a);
        c.a9._bu.c = b.c;
        let d = typeCast(CT_StyleMatrix.$, a.s.h());
        b = typeCast(FormatSchemeDeserializer.$, a.s.h());
    }
    static v(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_StyleMatrix.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_BackgroundFillStyleList();
        c.a = d;
        b.s.k(d);
    }
    static ar(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_StyleMatrix.$, b);
        if (c == null) {
            return;
        }
        let d = ((() => {
            let $ret = new CT_EffectStyleList();
            $ret.c = new List$1(CT_EffectStyleItem.$, 0);
            return $ret;
        })());
        c.b = d;
        b.s.k(d);
    }
    static ay(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_StyleMatrix.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_FillStyleList();
        c.c = d;
        b.s.k(d);
    }
    static bp(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_StyleMatrix.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineStyleList();
        c.d = d;
        b.s.k(d);
    }
    static y(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = CT_BlipFillProperties_DML.e(b);
        let d = [CT_BackgroundFillStyleList.$, CT_FillStyleList.$, CT_FillOverlayEffect.$];
        let e = SerializationUtils.j(b, d);
        if (e != null) {
            e.setProperty(128, c);
        }
        b.s.k(c);
    }
    static a4(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = CT_GradientFillProperties.l(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_GradientFillProperties();
            $ret.g = c;
            $ret.i = d;
            return $ret;
        })());
        let g = [CT_BackgroundFillStyleList.$, CT_FillStyleList.$, CT_FillOverlayEffect.$, CT_LineProperties_DML.$];
        let h = SerializationUtils.j(b, g);
        if (h != null) {
            h.setProperty(725, f);
        }
        b.s.k(f);
    }
    static ba(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = [CT_BackgroundFillStyleList.$, CT_FillStyleList.$, CT_FillOverlayEffect.$];
        let d = new CT_GroupFillProperties();
        let e = SerializationUtils.j(b, c);
        if (e != null) {
            e.setProperty(752, d);
        }
        b.s.k(d);
    }
    static bu(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = new CT_NoFillProperties();
        SerializationUtils.a3(CT_NoFillProperties.$, b, c, 1063);
    }
    static by(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = Nullable$1.toNullable(ST_PresetPatternVal_$type, null);
        let d = CT_PatternFillProperties.h(b, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_PatternFillProperties();
            $ret.e = c;
            return $ret;
        })());
        SerializationUtils.a3(CT_PatternFillProperties.$, a, e, 1174);
    }
    static cg(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = new CT_SolidColorFillProperties();
        SerializationUtils.a3(CT_SolidColorFillProperties.$, b, c, 1553);
    }
    static x(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = CT_Blip_DML.l(a);
        c.d = d;
        b.s.k(d);
    }
    static ci(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.u(b);
        c.a = d;
        b.s.k(d);
    }
    static cj(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_StretchInfoProperties();
        c.g.a = d;
        b.s.k(d);
    }
    static cl(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_BlipFillProperties_DML.$, b);
        if (c == null) {
            return;
        }
        let d = DMLUtils.w(b);
        c.g.b = d;
        b.s.k(d);
    }
    static h(a) {
        SerializationUtils.y(a);
    }
    static i(a) {
        SerializationUtils.z(a);
    }
    static j(a) {
        SerializationUtils.aa(a);
    }
    static k(a) {
        SerializationUtils.ab(a);
    }
    static l(a) {
        SerializationUtils.ac(a);
    }
    static m(a) {
        SerializationUtils.ad(a);
    }
    static o(a) {
        SerializationUtils.af(a);
    }
    static w(a) {
        SerializationUtils.al(a);
    }
    static ac(a) {
        SerializationUtils.ap(a);
    }
    static ae(a) {
        SerializationUtils.ar(a);
    }
    static ag(a) {
        SerializationUtils.at(a);
    }
    static an(a) {
        SerializationUtils.az(a);
    }
    static at(a) {
        if (FormatSchemeDeserializer.d(a) == false) {
            return;
        }
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = new CT_OfficeArtExtensionList();
        let d = [CT_Blip_DML.$, CT_Scene3D.$, CT_Backdrop.$, CT_Shape3D.$, CT_LineProperties_DML.$];
        let e = SerializationUtils.j(b, d);
        if (e != null) {
            e.setProperty(601, c);
        }
        b.s.k(c);
    }
    static aw(a) {
        SerializationUtils.a4(a);
    }
    static a6(a) {
        SerializationUtils.bb(a);
    }
    static be(a) {
        SerializationUtils.bi(a);
    }
    static bq(a) {
        SerializationUtils.bs(a);
    }
    static cn(a) {
        SerializationUtils.cl(a);
    }
    static bf(a) {
        SerializationUtils.bj(a);
    }
    static bz(a) {
        SerializationUtils.bz(a);
    }
    static cc(a) {
        SerializationUtils.cc(a);
    }
    static cd(a) {
        SerializationUtils.cd(a);
    }
    static e(a) {
        let b = FormatSchemeDeserializer.b(CT_StyleMatrix.$, a, false);
        if (b == null) {
            return false;
        }
        SerializationUtils.ch(a);
        return true;
    }
    static f(a) {
        let b = FormatSchemeDeserializer.b(CT_StyleMatrix.$, a, false);
        if (b == null) {
            return false;
        }
        SerializationUtils.ci(a);
        return true;
    }
    static g(a) {
        SerializationUtils.x(a);
    }
    static n(a) {
        SerializationUtils.ae(a);
    }
    static z(a) {
        SerializationUtils.am(a);
    }
    static aa(a) {
        SerializationUtils.an(a);
    }
    static ab(a) {
        SerializationUtils.ao(a);
    }
    static ai(a) {
        SerializationUtils.av(a);
    }
    static a2(a) {
        SerializationUtils.a7(a);
    }
    static a5(a) {
        SerializationUtils.ba(a);
    }
    static a7(a) {
        SerializationUtils.bc(a);
    }
    static a8(a) {
        SerializationUtils.bd(a);
    }
    static a9(a) {
        SerializationUtils.be(a);
    }
    static bg(a) {
        SerializationUtils.bk(a);
    }
    static bh(a) {
        SerializationUtils.bl(a);
    }
    static bi(a) {
        SerializationUtils.bm(a);
    }
    static bk(a) {
        SerializationUtils.bo(a);
    }
    static bl(a) {
        SerializationUtils.bp(a);
    }
    static br(a) {
        SerializationUtils.bt(a);
    }
    static bs(a) {
        SerializationUtils.bu(a);
    }
    static b2(a) {
        SerializationUtils.b2(a);
    }
    static b3(a) {
        SerializationUtils.b3(a);
    }
    static b4(a) {
        SerializationUtils.b4(a);
    }
    static b8(a) {
        SerializationUtils.b8(a);
    }
    static b9(a) {
        SerializationUtils.b9(a);
    }
    static ca(a) {
        SerializationUtils.ca(a);
    }
    static ce(a) {
        SerializationUtils.ce(a);
    }
    static aj(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_AlphaModulateEffect.$, b);
        if (c == null) {
            return;
        }
        let d = Nullable$1.toNullable(ST_EffectContainerType_$type, null);
        let e = null;
        let f = CT_EffectContainer.l(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ((() => {
            let $ret = new CT_EffectContainer();
            $ret.g = d;
            $ret.i = e;
            return $ret;
        })());
        c.a = g;
        b.s.k(g);
    }
    static af(a) {
        SerializationUtils.as(a);
    }
    static ah(a) {
        SerializationUtils.au(a);
    }
    static as(a) {
        if (FormatSchemeDeserializer.d(a) == false) {
            return;
        }
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_OfficeArtExtensionList.$, b);
        if (c == null) {
            return;
        }
        let d;
        let e = CT_OfficeArtExtension.d(b, d);
        d = e.p1;
        let f = ((() => {
            let $ret = new CT_OfficeArtExtension();
            $ret.b = d;
            return $ret;
        })());
        c.b.b.add(f);
    }
    static ax(a) {
        SerializationUtils.a5(a);
    }
    static bc(a) {
        SerializationUtils.bg(a);
    }
    static bn(a) {
        SerializationUtils.br(a);
    }
    static bx(a) {
        SerializationUtils.by(a);
    }
    static cm(a) {
        SerializationUtils.ck(a);
    }
    static bb(a) {
        SerializationUtils.bf(a);
    }
    static az(a) {
        SerializationUtils.a6(a);
    }
    static u(a) {
        SerializationUtils.ak(a);
    }
    static av(a) {
        SerializationUtils.a2(a);
    }
    static aq(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_EffectStyleList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_EffectStyleItem();
        c.c.add(d);
        b.s.k(d);
    }
    static ao(a) {
        SerializationUtils.a0(a);
    }
    static ap(a) {
        let b = FormatSchemeDeserializer.b(CT_EffectStyleItem.$, a);
        if (b == null) {
            return;
        }
        let c = new CT_EffectList();
        b.f.b = c;
        a.s.k(c);
    }
    static cb(a) {
        SerializationUtils.cb(a);
    }
    static ch(a) {
        SerializationUtils.cg(a);
    }
    static a3(a) {
        SerializationUtils.a8(a);
    }
    static bj(a) {
        SerializationUtils.bn(a);
    }
    static bw(a) {
        SerializationUtils.bx(a);
    }
    static b1(a) {
        SerializationUtils.b1(a);
    }
    static b5(a) {
        SerializationUtils.b5(a);
    }
    static cf(a) {
        SerializationUtils.cf(a);
    }
    static q(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_Scene3D.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_Backdrop();
        c.a = d;
        b.s.k(d);
    }
    static ad(a) {
        SerializationUtils.aq(a);
    }
    static bm(a) {
        SerializationUtils.bq(a);
    }
    static p(a) {
        SerializationUtils.ag(a);
    }
    static bv(a) {
        SerializationUtils.bw(a);
    }
    static co(a) {
        SerializationUtils.cm(a);
    }
    static b6(a) {
        SerializationUtils.b6(a);
    }
    static s(a) {
        SerializationUtils.ai(a);
    }
    static t(a) {
        SerializationUtils.aj(a);
    }
    static ak(a) {
        SerializationUtils.aw(a);
    }
    static au(a) {
        SerializationUtils.a1(a);
    }
    static bo(a) {
        let b = typeCast(ObjectModelThemePartManager.$, a);
        let c = FormatSchemeDeserializer.b(CT_LineStyleList.$, b);
        if (c == null) {
            return;
        }
        let d = new CT_LineProperties_DML();
        c.a.add(d);
        b.s.k(d);
    }
    static r(a) {
        SerializationUtils.ah(a);
    }
    static al(a) {
        SerializationUtils.ax(a);
    }
    static bd(a) {
        SerializationUtils.bh(a);
    }
    static bt(a) {
        SerializationUtils.bv(a);
    }
    static b0(a) {
        SerializationUtils.b0(a);
    }
    static b7(a) {
        SerializationUtils.b7(a);
    }
    static ck(a) {
        SerializationUtils.cj(a);
    }
    static am(a) {
        SerializationUtils.ay(a);
    }
    static d(a) {
        let b = FormatSchemeDeserializer.b(FormatSchemeDeserializer.$, a, false);
        return b != null;
    }
    static b($t, a, b = true) {
        return SerializationUtils.i($t, a, b);
    }
    static a(a, b) {
        return SerializationUtils.a(a, b);
    }
}
FormatSchemeDeserializer.$t = markType(FormatSchemeDeserializer, 'FormatSchemeDeserializer');
/**
 * @hidden
 */
export class FormatSchemeSerializer extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
    static b(a, b, c) {
        let d = a.ad;
        DMLExtensions.a9(c, a, b, d, DrawingMLMain.d7);
    }
}
FormatSchemeSerializer.$t = markType(FormatSchemeSerializer, 'FormatSchemeSerializer');
/**
 * @hidden
 */
export class LegacyShapeTypeData extends Base {
    constructor() {
        super(...arguments);
        this.f = null;
        this.e = null;
        this.d = Nullable$1.toNullable(Number_$type, null);
        this.g = null;
        this.c = null;
        this.b = null;
        this.a = null;
    }
}
LegacyShapeTypeData.$t = markType(LegacyShapeTypeData, 'LegacyShapeTypeData');
/**
 * @hidden
 */
export class LegacyShapeStrokeData extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, null);
    }
}
LegacyShapeStrokeData.$t = markType(LegacyShapeStrokeData, 'LegacyShapeStrokeData');
/**
 * @hidden
 */
export class LegacyShapePathData extends Base {
    constructor() {
        super(...arguments);
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.a = Nullable$1.toNullable(ST_ConnectType_$type, null);
    }
}
LegacyShapePathData.$t = markType(LegacyShapePathData, 'LegacyShapePathData');
/**
 * @hidden
 */
export class LegacyShapeLockData extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_Ext_$type, null);
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
    }
}
LegacyShapeLockData.$t = markType(LegacyShapeLockData, 'LegacyShapeLockData');
/**
 * @hidden
 */
export class SparklinesSerializer extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
    b(a, b, c) {
        let d = this.a._sparklineGroups$i;
        if (d.count == 0) {
            return;
        }
        let e = false;
        for (let f of fromEnum(d)) {
            if (f._sparklines$i.count > 0) {
                e = true;
                break;
            }
        }
        if (e == false) {
            return;
        }
        SpreadsheetMLMain.aba(a, "{05C60535-1F16-4fd2-B633-F4F36F0B64E0}", SpreadsheetML2009Main.b0);
        SparklinesSerializer.c(a);
        for (let g of fromEnum(d)) {
            if (g._sparklines$i.count == 0) {
                continue;
            }
            let h = Nullable$1.toNullable(Number_$type, null);
            let i = Nullable$1.toNullable(Number_$type, null);
            let j = Nullable$1.toNullable(Number_$type, null);
            let k = Nullable$1.toNullable(ST_SparklineType_$type, null);
            let l = Nullable$1.toNullable(Boolean_$type, null);
            let m = Nullable$1.toNullable(ST_DispBlanksAs_$type, null);
            let n = Nullable$1.toNullable(Boolean_$type, null);
            let o = Nullable$1.toNullable(Boolean_$type, null);
            let p = Nullable$1.toNullable(Boolean_$type, null);
            let q = Nullable$1.toNullable(Boolean_$type, null);
            let r = Nullable$1.toNullable(Boolean_$type, null);
            let s = Nullable$1.toNullable(Boolean_$type, null);
            let t = Nullable$1.toNullable(Boolean_$type, null);
            let u = Nullable$1.toNullable(Boolean_$type, null);
            let v = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
            let w = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, null);
            let x = Nullable$1.toNullable(Boolean_$type, null);
            if (g.dateAxis) {
                l = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.displayBlanksAs != 2) {
                m = Nullable$1.toNullable(ST_DispBlanksAs_$type, SparklineExtensions.c(g.displayBlanksAs));
            }
            if (g.displayHidden) {
                u = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.displayXAxis) {
                t = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.firstPoint) {
                q = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.highPoint) {
                o = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.lastPoint) {
                r = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.lineWeight != 0.75) {
                j = Nullable$1.toNullable(Number_$type, g.lineWeight);
            }
            if (g.lowPoint) {
                p = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.verticalAxisMax != 0) {
                h = Nullable$1.toNullable(Number_$type, g.verticalAxisMax);
            }
            if (g.verticalAxisMaxType != 0) {
                w = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, SparklineExtensions.a(g.verticalAxisMaxType));
            }
            if (g.verticalAxisMin != 0) {
                i = Nullable$1.toNullable(Number_$type, g.verticalAxisMin);
            }
            if (g.verticalAxisMinType != 0) {
                v = Nullable$1.toNullable(ST_SparklineAxisMinMax_$type, SparklineExtensions.a(g.verticalAxisMinType));
            }
            if (g.markers) {
                n = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.negativePoints) {
                s = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.rightToLeft) {
                x = Nullable$1.toNullable(Boolean_$type, true);
            }
            if (g.type != 0) {
                k = Nullable$1.toNullable(ST_SparklineType_$type, SparklineExtensions.b(g.type));
            }
            CT_SparklineGroup.bi(a, SpreadsheetML2009Main.cn, l, m, u, t, q, o, r, j, p, h, i, n, w, v, s, x, k);
            if (WorkbookColorInfo.l_op_Inequality(g.colorSeries, null)) {
                ColorInfoExtensions.d(g.colorSeries, a, c, this.a, SpreadsheetML2009Main.a7);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorNegativePoints, null)) {
                ColorInfoExtensions.d(g.colorNegativePoints, a, c, this.a, SpreadsheetML2009Main.a5);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorAxis, null)) {
                ColorInfoExtensions.d(g.colorAxis, a, c, this.a, SpreadsheetML2009Main.az);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorMarkers, null)) {
                ColorInfoExtensions.d(g.colorMarkers, a, c, this.a, SpreadsheetML2009Main.a4);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorFirstPoint, null)) {
                ColorInfoExtensions.d(g.colorFirstPoint, a, c, this.a, SpreadsheetML2009Main.a0);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorLastPoint, null)) {
                ColorInfoExtensions.d(g.colorLastPoint, a, c, this.a, SpreadsheetML2009Main.a2);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorHighPoint, null)) {
                ColorInfoExtensions.d(g.colorHighPoint, a, c, this.a, SpreadsheetML2009Main.a1);
            }
            if (WorkbookColorInfo.l_op_Inequality(g.colorLowPoint, null)) {
                ColorInfoExtensions.d(g.colorLowPoint, a, c, this.a, SpreadsheetML2009Main.a3);
            }
            if (g.dateRangeFormula != null) {
                let y = b._ct(g.dateRangeFormula);
                Excel2006Main.au(a, y);
                c.k();
            }
            if (g._sparklines$i.count > 0) {
                SparklinesSerializer.d(a, SpreadsheetML2009Main.cq);
                for (let z of fromEnum(g._sparklines$i)) {
                    SparklinesSerializer.d(a, SpreadsheetML2009Main.cm);
                    let aa = new WorksheetCellAddress(1, z.location.firstRow, z.location._v);
                    let ab = aa.toString();
                    let ac = z.dataRegion;
                    let ad = ac != null ? ac._toString2(1, true, true, true) : z.dataRegionName;
                    Excel2006Main.au(a, ad);
                    c.k();
                    Excel2006Main.av(a, ab);
                    c.k();
                    c.k();
                }
                c.k();
            }
            c.k();
        }
        c.k();
        c.k();
    }
    static c(a) {
        a.ad.o(SpreadsheetML2009Main.co);
        a.ad.i("xmlns", "xm", null, Excel2006Elements.b);
    }
    static d(a, b) {
        a.ad.o(b);
    }
}
SparklinesSerializer.$t = markType(SparklinesSerializer, 'SparklinesSerializer');
/**
 * @hidden
 */
export class ObjectModelChartExPartManager extends ChartExPartManager {
    constructor() {
        super();
        this.ba = null;
        this.bc = null;
        this.bf = 100;
        this.be = null;
        ChartExDeserializer.h1(this);
    }
    u(a) {
        let b = typeCast(WorksheetChart.$, a);
        let c = this.a7;
        let d = new ChartExSerializer(b.sheet);
        d.p(b, this, this.a7._b9, this.ad);
        return null;
    }
    t() {
        return super.t();
    }
    a() {
        let a = this.a7;
        let b = null;
        a._b3 = ((() => { let c = ObjectModelChartPartManager.a7(this.l, a, b); b = c.p2; return c.ret; })());
        if (this.l.canSeek) {
            this.l.position = 0;
        }
        else {
            this.l = new MemoryStream(2, b);
        }
        return super.a();
    }
    b(a) {
        let b = typeCast(WorksheetChart.$, a);
        if (b == null) {
            return null;
        }
        let c = b._gu;
        let d = b._gv;
        let e = b._fx;
        if (e == null) {
            if (c) {
                return null;
            }
        }
        if (e != null && e.a == null) {
            if (c) {
                return null;
            }
        }
        let f = this.a7;
        if (c || d) {
            let g = null;
            if (c) {
                this.l.write(e.a.a, 0, e.a.a.length);
            }
            else {
                g = super.b(a);
            }
            return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(Async.g(e.e != null, () => f._j(ObjectModelChartUserShapePartManager.v, e, e.e.c)), () => Async.g(g != null, () => g)), () => Async.g(e.c != null, () => f._j(ObjectModelChartColorStylePartManager.a8, e, e.c.c))), () => Async.g(e.d != null, () => f._j(ObjectModelChartStylePartManager.a8, e, e.d.c))), () => {
                if (e.b == null) {
                    return null;
                }
                return Async.d(Tuple$2.$.specialize(IPackageRelationship_$type, ImageData.$), e.b, (h) => f._bz(h.d, h.c.id));
            });
        }
        else {
            return WorkItemExtensions.i(Tuple$2.$.specialize(Uri.$, String_$type), WorkItemExtensions.i(Tuple$2.$.specialize(Uri.$, String_$type), super.b(a), () => {
                let h = this.bd;
                return this.a7._j(ObjectModelChartColorStylePartManager.a8, h);
            }), () => {
                let h = this.bb;
                h.bm(b.chartType);
                return this.a7._j(ObjectModelChartStylePartManager.a8, h);
            });
        }
    }
    get bb() {
        if (this.ba == null) {
            this.ba = CT_ChartStyle.b();
        }
        this.ba.bj = Nullable$1.toNullable(Number_$type, this.bf);
        this.bf += 1;
        return this.ba;
    }
    get bd() {
        if (this.bc == null) {
            this.bc = CT_ColorStyle.a();
        }
        return this.bc;
    }
    get a7() {
        return ObjectModelChartExPartManager.a8(this);
    }
    static a8(a) {
        return a.d;
    }
}
ObjectModelChartExPartManager.$t = markType(ObjectModelChartExPartManager, 'ObjectModelChartExPartManager', ChartExPartManager.$);
ObjectModelChartExPartManager.a9 = new ObjectModelChartExPartManager();
/**
 * @hidden
 */
export class ObjectModelChartsheetPartManager extends ChartsheetPartManager {
    constructor() {
        super();
        this.bc = null;
        this.bb = 0;
        this.bd = null;
        this.a7 = null;
        this.ay(SpreadsheetMLMain.ei, ObjectModelChartsheetPartManager.bf);
        this.ax(SpreadsheetMLMain.ei, ObjectModelChartsheetPartManager.bh);
        this.ay(SpreadsheetMLMain.fp, ObjectModelChartsheetPartManager.bj);
        this.ay(SpreadsheetMLMain.fq, ObjectModelChartsheetPartManager.bk);
        this.ay(SpreadsheetMLMain.g1, ObjectModelChartsheetPartManager.bm);
        this.ay(SpreadsheetMLMain.i4, ObjectModelWorksheetPartManager.d1);
        this.ay(SpreadsheetMLMain.ll, ObjectModelWorksheetPartManager.el);
        this.ay(SpreadsheetMLMain.lm, ObjectModelWorksheetPartManager.em);
        this.ay(SpreadsheetMLMain.l1, ObjectModelWorksheetPartManager.ep);
        this.ay(SpreadsheetMLMain.l3, ObjectModelWorksheetPartManager.eq);
        this.ay(SpreadsheetMLMain.mh, ObjectModelChartsheetPartManager.bo);
        this.ay(SpreadsheetMLMain.ov, ObjectModelChartsheetPartManager.bq);
        this.ay(SpreadsheetMLMain.ow, ObjectModelChartsheetPartManager.bs);
        this.ay(SpreadsheetMLMain.oy, ObjectModelChartsheetPartManager.bu);
        this.ay(SpreadsheetMLMain.oz, ObjectModelChartsheetPartManager.bv);
        this.ay(SpreadsheetMLMain.qp, ObjectModelChartsheetPartManager.bx);
    }
    t() {
        let a = this.a8;
        let b = a._d.uri.toString();
        this.a7 = a._b7._ao(b);
        if (this.a7 == null) {
            return null;
        }
        return super.t();
    }
    u(a) {
        let b = typeCast(Chartsheet.$, a);
        if (b == null) {
            return null;
        }
        this.a7 = b;
        this.bb = this.a7.workbook.currentFormat;
        let c = this.a8;
        let d = c._b9;
        let e = d._s(b);
        this.by(b, e);
        let f = false;
        for (let g = 0; g < b._p.count; g++) {
            let h = d._z(b._p.item(g));
            if (h != null) {
                f = true;
                break;
            }
        }
        let i = new SheetRelationships();
        let j = b._bf == null ? null : ExcelUtils.y(b._bf, b._a7);
        return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(Async.g(j != null, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._b0(j, b._a7), (k) => e.a = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d)), () => Async.g(f, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelDrawingPartManager.bf, b), (k) => i.a = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => Async.g(this.bd.count != 0, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelVmlDrawingPartManager.ba, this.bd), (k) => i.c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => Async.g(b._bb != null, () => WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), String_$type, c._j(ObjectModelVmlDrawingPartManager.ba, b._bb), (k) => i.b = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), k).d))), () => this.a6(d, i));
    }
    ai(a) {
        switch (a) {
            case SpreadsheetMLMain.hj:
                {
                    let b;
                    let c = SpreadsheetMLMain.vp(this, b);
                    b = c.p1;
                    switch (b) {
                        default: return false;
                    }
                }
        }
        return super.ai(a);
    }
    get a8() {
        return ObjectModelChartsheetPartManager.a9(this);
    }
    static a9(a) {
        return a.d;
    }
    static bf(a) {
        a.be();
    }
    be() {
        this.s.k(this.a7._g);
    }
    static bh(a) {
        a.bg();
    }
    bg() {
        this.a7._p._ao();
    }
    static bj(a) {
        a.bi();
    }
    bi() {
        let a = new ST_Guid();
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.uw(this, a, b, c, d);
        a = e.p1;
        b = e.p2;
        c = e.p3;
        d = e.p4;
        let f = this.a8;
        let g = f._by;
        let h = g._customViews$i;
        let i = h._item(ST_Guid.e(a));
        if (i == null) {
            return;
        }
        let j = i.getSheetPrintOptions(this.a7, true);
        if (j != null) {
            this.s.k(j);
        }
        let k = i.getSheetDisplayOptions(this.a7, true);
        if (k == null) {
            return;
        }
        this.s.k(k);
        k.magnification = b;
        k.visibility = XlsxUtilities.ae(c);
        k.sizeWithWindow = d;
    }
    static bk(a) {
    }
    static bm(a) {
        a.bl();
    }
    bl() {
        let a;
        let b = SpreadsheetMLMain.vg(this, a);
        a = b.p1;
        let c = this.a8;
        let d = c._b7;
        let e = PackageUtilities.ak(c._g(a)).originalString;
        let f;
        if (((() => { let g = d._a6.tryGetValue(e, f); f = g.p1; return g.ret; })())) {
            for (let g of fromEnum(f)) {
                d._bp(this.a7, g);
            }
        }
        else {
        }
    }
    static bo(a) {
        a.bn();
    }
    bn() {
        let a;
        let b = SpreadsheetMLMain.w8(this, a);
        a = b.p1;
        let c = this.a8;
        let d = typeCast(ImageData.$, c._au(a));
        if (d != null) {
            let e = XlsxUtilities.u(d);
            this.a7._bf = ExcelUtils.g4(e);
            this.a7._a7 = e.d;
        }
        else {
        }
    }
    static bq(a) {
        a.bp();
    }
    bp() {
        let a;
        let b;
        let c = SpreadsheetMLMain.t8(this, a, b);
        a = c.p1;
        b = c.p2;
        this.a7._ak = b;
    }
    static bu(a) {
        a.bt();
    }
    bt() {
        let a;
        let b;
        let c;
        let d;
        let e = SpreadsheetMLMain.ub(this, a, b, c, d);
        a = e.p1;
        b = e.p2;
        c = e.p3;
        d = e.p4;
        let f = this.a7.displayOptions;
        this.s.k(f);
        if (this.a7._r) {
            return;
        }
        this.a7._r = true;
        this.a7._w = b;
        let g = c;
        let h = ExcelUtils.fj(g);
        g = h.p0;
        f.magnification = g;
        f.sizeWithWindow = d;
    }
    static bv(a) {
    }
    static bs(a) {
        a.br();
    }
    br() {
        let a = null;
        let b, c;
        if (SpreadsheetMLMain.b3(this)) {
            let d, e, f;
            let g;
            let h = SpreadsheetMLMain.ua(this, d, e, f, g, b, c);
            d = h.p1;
            e = h.p2;
            f = h.p3;
            g = h.p4;
            b = h.p5;
            c = h.p6;
            if (e != null && f != null && nullableNotEquals(g, null)) {
                a = ProtectionValidationInfo.b(d, Convert.fromBase64String(e), Convert.fromBase64String(f), g.value);
            }
        }
        else {
            let i;
            let j = SpreadsheetMLMain.t9(this, i, b, c);
            i = j.p1;
            b = j.p2;
            c = j.p3;
            if (i.hasValue) {
                a = ProtectionValidationInfo.c(i.value.e());
            }
        }
        let k = this.a7.protection;
        k.allowEditObjects = b == false;
        k.allowEditContents = c == false;
        k._c.b = a;
        k._c.j(b || c);
    }
    static bx(a) {
        a.bw();
    }
    bw() {
        this.a7.tabColorInfo = ObjectModelCommonPartHelpers.c(this, SpreadsheetMLMain.ye);
    }
    by(a, b) {
        this.bc = new List$1(UnknownShape.$, 0);
        this.bd = new List$1(WorksheetShape.$, 0);
        ObjectModelWorksheetPartManager.f0(a._p, this.bc, this.bd);
    }
    a6(a, b) {
        let c = a._b;
        let d = this.a7.printOptions;
        let e = a._s(this.a7);
        SpreadsheetMLMain.zr(this);
        if (b.c != null || b.b != null) {
            this.ad.l(VmlNamespace.an);
        }
        this.b2();
        this.b5();
        this.b3();
        this.b0();
        ObjectModelWorksheetPartManager.gp(this, d);
        ObjectModelWorksheetPartManager.gq(this, d);
        ObjectModelWorksheetPartManager.gh(this, d);
        ObjectModelWorksheetPartManager.ge(this, b.a);
        ObjectModelWorksheetPartManager.gk(this, b.c);
        ObjectModelWorksheetPartManager.gl(this, b.b);
        ObjectModelWorksheetPartManager.gt(this, a, e);
        return null;
    }
    b1(a) {
        if (a._ag() == false) {
            return;
        }
        let b = null;
        if (a._c != null) {
            let c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), this.d._j(ObjectModelPrinterSettingsPartManager.a7, a._c));
            if (c != null) {
                b = c.d;
            }
        }
        SpreadsheetMLMain.acq(this, a.paperSize, void 0, void 0, void 0, intSToU(a.startPageNumber), void 0, void 0, void 0, XlsxUtilities.av(a.orientation), void 0, a.printInBlackAndWhite, a.draftQuality, XlsxUtilities.ap(a.printNotes), a.pageNumbering == 1, XlsxUtilities.az(a.printErrors), intSToU(a.resolution), intSToU(a.verticalResolution), intSToU(a.numberOfCopies), b);
        this.ad.k();
    }
    bz(a) {
        let b = a.getSheetDisplayOptions(this.a7, false);
        if (b == null) {
            return;
        }
        SpreadsheetMLMain.aah(this, ST_Guid.a(a._t), intSToU(b.magnification), XlsxUtilities.a1(b.visibility), b.sizeWithWindow);
        if (a.savePrintOptions) {
            let c = a.getSheetPrintOptions(this.a7, false);
            if (c != null) {
                ObjectModelWorksheetPartManager.gp(this, c);
                ObjectModelWorksheetPartManager.gq(this, c);
                ObjectModelWorksheetPartManager.gh(this, c);
            }
        }
        this.ad.k();
    }
    b0() {
        let a = this.a8._by;
        if (a._cq == false) {
            return;
        }
        if (Enumerable.d(CustomView.$, a._customViews$i, (b) => b.getSheetDisplayOptions(this.a7, false) != null) == false) {
            return;
        }
        SpreadsheetMLMain.aal(this);
        ExcelUtils.fm(CustomView.$, a._customViews$i, runOn(this, this.bz));
        this.ad.k();
    }
    b2() {
        let a = null;
        if (this.a7.workbook._k != null) {
            a = this.a7._ak;
        }
        SpreadsheetMLMain.adl(this, void 0, void 0, void 0, void 0, void 0, void 0, a);
        this.b6();
        this.ad.k();
    }
    b3() {
        let a = this.a7.protection;
        let b = this.d._z == 0;
        if (b && nullableEquals(a._c.h(), 0)) {
            b = false;
        }
        if (b == false) {
            let c;
            let d, e;
            let f;
            let g = a._c.e(c, d, e, f);
            c = g.p0;
            d = g.p1;
            e = g.p2;
            f = g.p3;
            SpreadsheetMLMain.zu(this, c, d != null ? Convert.toBase64String(d) : null, e != null ? Convert.toBase64String(e) : null, f, a.allowEditObjects == false, a.allowEditContents == false);
        }
        else {
            let h = a._c.h();
            let i = h.hasValue ? Nullable$1.toNullable(ST_UnsignedShortHex.$, new ST_UnsignedShortHex(1, h.value)) : Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
            SpreadsheetMLMain.zt(this, i, a.allowEditObjects == false, a.allowEditContents == false);
        }
        this.ad.k();
    }
    b4() {
        let a = this.a8._by;
        let b = this.a7.displayOptions;
        (((c, d, e, f, g) => SpreadsheetMLMain.zv(c, d, f, e, g))(this, 0, intSToU(b.magnification), a.windowOptions.selectedSheet == this.a7 || this.a7._w, b.sizeWithWindow));
        this.ad.k();
    }
    b5() {
        SpreadsheetMLMain.adq(this);
        this.b4();
        this.ad.k();
    }
    b6() {
        if (WorkbookColorInfo.l_op_Equality(this.a7.tabColorInfo, null)) {
            return;
        }
        ObjectModelCommonPartHelpers.ao(this, this.a7.tabColorInfo, 4, SpreadsheetMLMain.ad1);
    }
}
ObjectModelChartsheetPartManager.$t = markType(ObjectModelChartsheetPartManager, 'ObjectModelChartsheetPartManager', ChartsheetPartManager.$);
ObjectModelChartsheetPartManager.ba = new ObjectModelChartsheetPartManager();
/**
 * @hidden
 */
export class ObjectModelActiveXBinaryPartManager extends ActiveXBinaryPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    get v() {
        return ObjectModelActiveXBinaryPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelActiveXBinaryPartManager.$t = markType(ObjectModelActiveXBinaryPartManager, 'ObjectModelActiveXBinaryPartManager', ActiveXBinaryPartManager.$);
ObjectModelActiveXBinaryPartManager.x = new ObjectModelActiveXBinaryPartManager();
/**
 * @hidden
 */
export class ObjectModelActiveXPartManager extends ActiveXPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, RoundTripDataPartManager.r(this.v, this.l, this.m));
    }
    b(a) {
        let b = typeCast(RoundTripControlData.$, a);
        if (b == null) {
            return null;
        }
        return RoundTripDataPartManager.s(b, this.v, this.l);
    }
    get v() {
        return ObjectModelActiveXPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelActiveXPartManager.$t = markType(ObjectModelActiveXPartManager, 'ObjectModelActiveXPartManager', ActiveXPartManager.$);
ObjectModelActiveXPartManager.x = new ObjectModelActiveXPartManager();
/**
 * @hidden
 */
export class ObjectModelCalcChainPartManager extends CalcChainPartManager {
    constructor() {
        super();
    }
    u(a) {
        return null;
    }
}
ObjectModelCalcChainPartManager.$t = markType(ObjectModelCalcChainPartManager, 'ObjectModelCalcChainPartManager', CalcChainPartManager.$);
ObjectModelCalcChainPartManager.a6 = new ObjectModelCalcChainPartManager();
/**
 * @hidden
 */
export class ObjectModelChartColorStylePartManager extends ChartColorStylePartManager {
    constructor() {
        super();
    }
    get_aj() {
        return false;
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(CT_ColorStyle.$, a);
        if (b != null) {
            return super.b(a);
        }
        let c = typeCast(Excel2007ChartData.$, a);
        if (c == null) {
            return null;
        }
        if (c.c != null) {
            this.l.write(c.c.d.a, 0, c.c.d.a.length);
        }
        return null;
    }
    u(a) {
        let b = typeCast(CT_ColorStyle.$, a);
        if (b != null) {
            ChartStyleExtensions.b(b, this, this.a6._b9, this.ad, ChartStyleElements.f);
        }
        return null;
    }
    get a6() {
        return ObjectModelChartColorStylePartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelChartColorStylePartManager.$t = markType(ObjectModelChartColorStylePartManager, 'ObjectModelChartColorStylePartManager', ChartColorStylePartManager.$);
ObjectModelChartColorStylePartManager.a8 = new ObjectModelChartColorStylePartManager();
/**
 * @hidden
 */
export class ObjectModelChartPartManager extends ChartPartManager {
    constructor() {
        super();
        this.bb = null;
        this.bc = null;
        ChartDeserializer.lm(this);
    }
    u(a) {
        let b = typeCast(WorksheetChart.$, a);
        let c = this.a8;
        let d = new ChartSerializer(b.sheet);
        d.bw(b, this, this.a8._b9, this.ad);
        return null;
    }
    t() {
        return super.t();
    }
    a() {
        let a = this.a8;
        let b = null;
        a._b3 = ((() => { let c = ObjectModelChartPartManager.a7(this.l, a, b); b = c.p2; return c.ret; })());
        if (this.l.canSeek) {
            this.l.position = 0;
        }
        else {
            this.l = new MemoryStream(2, b);
        }
        let c = false;
        return WorkItemExtensions.l(Base.$, Base.$, Async.k(InvalidXLSXElementException.$, Base.$, () => super.a(), (d) => {
            a._b3 = null;
            switch (d._elementName) {
                case ChartExElements.m:
                    c = true;
                    break;
                default: break;
            }
        }), (d) => {
            if (c) {
                return Async.q(Stream.$, Base.$, a._d.getStream(3, 1), (e) => {
                    let f = ObjectModelChartExPartManager.a9.e(a, e);
                    return f.a();
                });
            }
            return WorkItem.g(Base.$, WorkItemExtensions.m(Base.$, d));
        });
    }
    b(a) {
        let b = typeCast(WorksheetChart.$, a);
        if (b == null) {
            return null;
        }
        let c = b._gu;
        let d = b._fx;
        if (d == null) {
            if (c) {
                return null;
            }
        }
        if (d != null && d.a == null) {
            if (c) {
                return null;
            }
        }
        let e = this.a8;
        if (c) {
            this.l.write(d.a.a, 0, d.a.a.length);
            return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(Async.g(d.e != null, () => e._j(ObjectModelChartUserShapePartManager.v, d, d.e.c)), () => Async.g(d.c != null, () => e._j(ObjectModelChartColorStylePartManager.a8, d, d.c.c))), () => Async.g(d.d != null, () => e._j(ObjectModelChartStylePartManager.a8, d, d.d.c))), () => {
                if (d.b == null) {
                    return null;
                }
                return Async.d(Tuple$2.$.specialize(IPackageRelationship_$type, ImageData.$), d.b, (f) => e._bz(f.d, f.c.id));
            });
        }
        else {
            return super.b(a);
        }
    }
    get a8() {
        return ObjectModelChartPartManager.a9(this);
    }
    static a9(a) {
        return a.d;
    }
    static a7(a, b, c) {
        c = DocCoreUtils.c(a);
        let d = new Excel2007ChartData();
        d.a = new BinaryData(c);
        d.e = b._bc(BinaryData.$, ObjectModelChartUserShapePartManager.v);
        d.c = b._bc(BinaryData.$, ObjectModelChartColorStylePartManager.a8);
        d.d = b._bc(BinaryData.$, ObjectModelChartStylePartManager.a8);
        let e = ImagePartManagerBase.v(b._z);
        let f = b._d.getRelationships();
        for (let g of fromEnum(f)) {
            if (g.relationshipType == e) {
                let h = typeCast(ImageData.$, b._as(g));
                if (h == null) {
                    continue;
                }
                if (d.b == null) {
                    d.b = new List$1(Tuple$2.$.specialize(IPackageRelationship_$type, ImageData.$), 0);
                }
                d.b.add(Tuple.a(IPackageRelationship_$type, ImageData.$, g, h));
            }
        }
        return {
            ret: d,
            p2: c
        };
    }
}
ObjectModelChartPartManager.$t = markType(ObjectModelChartPartManager, 'ObjectModelChartPartManager', ChartPartManager.$);
ObjectModelChartPartManager.ba = new ObjectModelChartPartManager();
/**
 * @hidden
 */
export class ObjectModelChartStylePartManager extends ChartStylePartManager {
    constructor() {
        super();
    }
    get a6() {
        return ObjectModelChartStylePartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    u(a) {
        let b = typeCast(CT_ChartStyle.$, a);
        if (b != null) {
            ChartStyleExtensions.a(b, this, this.a6._b9, this.ad, ChartStyleElements.e);
        }
        return null;
    }
    b(a) {
        let b = typeCast(CT_ChartStyle.$, a);
        if (b != null) {
            return super.b(a);
        }
        let c = typeCast(Excel2007ChartData.$, a);
        if (c == null) {
            return null;
        }
        if (c.d != null) {
            this.l.write(c.d.d.a, 0, c.d.d.a.length);
        }
        return null;
    }
    get_aj() {
        return false;
    }
}
ObjectModelChartStylePartManager.$t = markType(ObjectModelChartStylePartManager, 'ObjectModelChartStylePartManager', ChartStylePartManager.$);
ObjectModelChartStylePartManager.a8 = new ObjectModelChartStylePartManager();
/**
 * @hidden
 */
export class ObjectModelChartUserShapePartManager extends ChartUserShapePartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(Excel2007ChartData.$, a);
        if (b == null) {
            return null;
        }
        if (b.e != null) {
            this.l.write(b.e.d.a, 0, b.e.d.a.length);
        }
        return null;
    }
}
ObjectModelChartUserShapePartManager.$t = markType(ObjectModelChartUserShapePartManager, 'ObjectModelChartUserShapePartManager', ChartUserShapePartManager.$);
ObjectModelChartUserShapePartManager.v = new ObjectModelChartUserShapePartManager();
/**
 * @hidden
 */
export class ObjectModelConnectionsPartManager extends ConnectionsPartManager {
    constructor() {
        super();
    }
    a() {
        let a = RoundTripDataPartManager.r(this.a6, this.l, this.m);
        this.a6._by._m = a;
        return WorkItem.g(Base.$, a);
    }
    b(a) {
        let b = this.a6._by._m;
        if (b == null) {
            return null;
        }
        return RoundTripDataPartManager.s(b, this.a6, this.l);
    }
    u(a) {
        throw new NotImplementedException(0);
    }
    get a6() {
        return ObjectModelConnectionsPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelConnectionsPartManager.$t = markType(ObjectModelConnectionsPartManager, 'ObjectModelConnectionsPartManager', ConnectionsPartManager.$);
ObjectModelConnectionsPartManager.a8 = new ObjectModelConnectionsPartManager();
/**
 * @hidden
 */
export class ObjectModelCorePropertiesPartManager extends CorePropertiesPartManager {
    constructor() {
        super();
        this.ay(CoreProperties.ap, ObjectModelCorePropertiesPartManager.a9);
        this.ay(CoreProperties.aq, ObjectModelCorePropertiesPartManager.ba);
        this.ay(CoreProperties.ar, ObjectModelCorePropertiesPartManager.bb);
        this.ay(CoreProperties.as, ObjectModelCorePropertiesPartManager.bf);
        this.ay(CoreProperties.at, ObjectModelCorePropertiesPartManager.bg);
        this.ay("http://purl.org/dc/elements/1.1/creator", ObjectModelCorePropertiesPartManager.bd);
        this.ay(DcElements.aq, ObjectModelCorePropertiesPartManager.be);
        this.ay("http://purl.org/dc/elements/1.1/subject", ObjectModelCorePropertiesPartManager.bi);
        this.ay("http://purl.org/dc/elements/1.1/title", ObjectModelCorePropertiesPartManager.bj);
        this.ay("http://purl.org/dc/terms/created", ObjectModelCorePropertiesPartManager.bc);
        this.ay("http://purl.org/dc/terms/modified", ObjectModelCorePropertiesPartManager.bh);
    }
    u(a) {
        let b = this.a6._by;
        CoreProperties.a6(this);
        if (stringIsNullOrEmpty(b.documentProperties.title) == false) {
            DcElements.a1(this, b.documentProperties.title);
            this.ad.k();
        }
        if (stringIsNullOrEmpty(b.documentProperties.subject) == false) {
            DcElements.a0(this, b.documentProperties.subject);
            this.ad.k();
        }
        if (stringIsNullOrWhiteSpace(b.documentProperties.author) == false) {
            DcElements.ay(this, b.documentProperties.author.trim());
            this.ad.k();
        }
        if (stringIsNullOrEmpty(b.documentProperties.keywords) == false) {
            CoreProperties.a7(this, null, b.documentProperties.keywords);
            this.ad.k();
        }
        if (stringIsNullOrEmpty(b.documentProperties.comments) == false) {
            DcElements.az(this, b.documentProperties.comments);
            this.ad.k();
        }
        if (stringIsNullOrWhiteSpace(b.documentProperties.author) == false) {
            CoreProperties.a8(this, b.documentProperties.author.trim());
            this.ad.k();
        }
        let c = dateNow();
        DcTerms.av(this, c);
        this.ad.k();
        DcTerms.aw(this, c);
        this.ad.k();
        if (stringIsNullOrEmpty(b.documentProperties.category) == false) {
            CoreProperties.a4(this, b.documentProperties.category);
            this.ad.k();
        }
        if (stringIsNullOrEmpty(b.documentProperties.status) == false) {
            CoreProperties.a5(this, b.documentProperties.status);
            this.ad.k();
        }
        this.ad.k();
        return null;
    }
    static a9(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = CoreProperties.ax(a, c);
        c = d.p1;
        b.category = c;
    }
    static ba(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = CoreProperties.ay(a, c);
        c = d.p1;
        b.status = c;
    }
    static bb(a) {
        let b = ObjectModelCorePropertiesPartManager.a7(a)._by;
        a.s.k(b.documentProperties);
    }
    static bc(a) {
        let b;
        let c = DcTerms.at(a, b);
        b = c.p1;
    }
    static bd(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DcElements.au(a, c);
        c = d.p1;
        b.author = c;
    }
    static be(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DcElements.av(a, c);
        c = d.p1;
        b.comments = c;
    }
    static bf(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = CoreProperties.a0(a, c, d);
        c = e.p1;
        d = e.p2;
        b.keywords = d;
    }
    static bg(a) {
        let b;
        let c = CoreProperties.a1(a, b);
        b = c.p1;
    }
    static bh(a) {
        let b;
        let c = DcTerms.au(a, b);
        b = c.p1;
    }
    static bi(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DcElements.aw(a, c);
        c = d.p1;
        b.subject = c;
    }
    static bj(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DcElements.ax(a, c);
        c = d.p1;
        b.title = c;
    }
    get a6() {
        return ObjectModelCorePropertiesPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelCorePropertiesPartManager.$t = markType(ObjectModelCorePropertiesPartManager, 'ObjectModelCorePropertiesPartManager', CorePropertiesPartManager.$);
ObjectModelCorePropertiesPartManager.a8 = new ObjectModelCorePropertiesPartManager();
/**
 * @hidden
 */
export class ObjectModelCtrlPropPartManager extends CtrlPropPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, RoundTripDataPartManager.r(this.v, this.l, this.m));
    }
    b(a) {
        let b = typeCast(RoundTripControlData.$, a);
        if (b == null) {
            return null;
        }
        return RoundTripDataPartManager.s(b, this.v, this.l);
    }
    get v() {
        return ObjectModelCtrlPropPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelCtrlPropPartManager.$t = markType(ObjectModelCtrlPropPartManager, 'ObjectModelCtrlPropPartManager', CtrlPropPartManager.$);
ObjectModelCtrlPropPartManager.x = new ObjectModelCtrlPropPartManager();
/**
 * @hidden
 */
export class ObjectModelCustomXmlItemPartManager extends CustomXmlItemPartManager {
    constructor() {
        super();
    }
    a() {
        let a = new BinaryData(DocCoreUtils.c(this.l));
        this.v._by._g7(a);
        return WorkItem.g(Base.$, a);
    }
    b(a) {
        let b = typeCast(Tuple$2.$.specialize(BinaryData.$, BinaryData.$), a);
        if (b == null) {
            return null;
        }
        return WorkItemExtensions.a(this.d._j(ObjectModelCustomXmlItemPropsPartManager.x, b.d), () => {
            let c = b.c;
            this.l.write(c.a, 0, c.a.length);
        });
    }
    get v() {
        return ObjectModelCustomXmlItemPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelCustomXmlItemPartManager.$t = markType(ObjectModelCustomXmlItemPartManager, 'ObjectModelCustomXmlItemPartManager', CustomXmlItemPartManager.$);
ObjectModelCustomXmlItemPartManager.x = new ObjectModelCustomXmlItemPartManager();
/**
 * @hidden
 */
export class ObjectModelCustomXmlItemPropsPartManager extends CustomXmlItemPropsPartManager {
    constructor() {
        super();
    }
    a() {
        let a = new BinaryData(DocCoreUtils.c(this.l));
        this.v._by._g8(a);
        return WorkItem.g(Base.$, a);
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    get v() {
        return ObjectModelCustomXmlItemPropsPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelCustomXmlItemPropsPartManager.$t = markType(ObjectModelCustomXmlItemPropsPartManager, 'ObjectModelCustomXmlItemPropsPartManager', CustomXmlItemPropsPartManager.$);
ObjectModelCustomXmlItemPropsPartManager.x = new ObjectModelCustomXmlItemPropsPartManager();
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager extends DrawingPartManager {
    constructor() {
        super();
        this.bt = 0;
        this.bh = null;
        this.bq = null;
        this.bp = null;
        this.bg = null;
        this.ay(DrawingMLSpreadsheetDrawing.el, ObjectModelDrawingPartManager.b6);
        this.ay(DrawingMLMain.cw, ObjectModelDrawingPartManager.b1);
        this.ay(DrawingMLMain.cx, ObjectModelDrawingPartManager.b2);
        this.ay(DrawingMLMain.ds, ObjectModelDrawingPartManager.b3);
        this.ay(DrawingMLMain.dt, ObjectModelDrawingPartManager.b4);
        ObjectModelCommonPartHelpers.am(this);
    }
    z(a) {
        switch (a) {
            case DrawingMLMain.cz: return 1;
        }
        return super.z(a);
    }
    p() {
        super.p();
        this.bg = new ObjectModelDrawingPartManager_ShapeLoader(this);
        DrawingPartManagerHelpers.ce(this);
        this.b7(DrawingMLSpreadsheetDrawing.dy);
        this.b7(DrawingMLSpreadsheetDrawing.d4);
        this.b7(DrawingMLSpreadsheetDrawing.d5);
        this.b7(DrawingMLSpreadsheetDrawing.eb);
        this.b7(DrawingMLSpreadsheetDrawing.ef);
        this.ax(DrawingMLSpreadsheetDrawing.ds, runOn(this, this.b0));
        this.ax(DrawingMLSpreadsheetDrawing.ea, runOn(this, this.b0));
        this.ax(DrawingMLSpreadsheetDrawing.ej, runOn(this, this.b0));
    }
    t() {
        this.bq = new List$1(WorksheetShape.$, 0);
        let a = this.bd;
        let b = a._b7;
        b._a6.addItem(a._d.uri.toString(), this.bq);
        return super.t();
    }
    aw(a, b) {
        switch (a) {
            case DrawingMLMain.cz:
                {
                    let c = this.s.a(CT_ShapeProperties.$);
                    if (c == null) {
                        return;
                    }
                    let d = ((() => {
                        let $ret = new CT_CustomGeometry2D();
                        $ret.g = b;
                        return $ret;
                    })());
                    c.e = d;
                    this.s.k(d);
                    break;
                }
        }
        super.aw(a, b);
    }
    u(a) {
        let b = typeCast(Sheet.$, a);
        if (b == null) {
            return null;
        }
        let c = this.bd._b9;
        this.by(c, b);
        let d = new Dictionary$2(ExcelImage.$, String_$type, 0);
        return WorkItemExtensions.c(c._b6(b._p, d), () => {
            this.s.k(d);
            let e = b._p;
            let f = new List$1(WorksheetShape.$, 2, e.count);
            for (let g = 0; g < e.count; g++) {
                let h = c._z(e.item(g));
                if (h != null) {
                    f.add(h);
                }
            }
            DrawingMLSpreadsheetDrawing.ff(this);
            if (b.type == 1) {
                return WorkItemExtensions.a(Async.d(WorksheetShape.$, f, (i) => this.ba(c, i)), () => this.ad.k());
            }
            return WorkItemExtensions.a(Async.d(WorksheetShape.$, f, (i) => this.bc(c, i)), () => this.ad.k());
        });
    }
    by(a, b) {
        this.bp = new Dictionary$2(WorksheetShape.$, ObjectModelDrawingPartManager_ShapeIdentity.$, 0);
        let c = 1;
        let d = this.bx(a, b._p, c);
        c = d.p2;
    }
    bx(a, b, c) {
        for (let d = 0; d < b.count; d++) {
            let e = a._z(b.item(d));
            if (e == null) {
                continue;
            }
            this.bp.addItem(e, new ObjectModelDrawingPartManager_ShapeIdentity(e, c++));
            let f = typeCast(WorksheetShapeGroupBase.$, e);
            if (f != null) {
                let g = this.bx(a, f._shapes$i, c);
                c = g.p2;
            }
        }
        return {
            p2: c
        };
    }
    bi(a) {
        if (a._b1.hasValue == false) {
            return null;
        }
        let b = this.bp.item(a);
        return ((() => {
            let $ret = new CT_Connector();
            $ret.c = a._b7;
            $ret.b = a._a0;
            $ret.a = ((() => {
                let $ret = new CT_ConnectorNonVisual();
                $ret.a = ((() => {
                    let $ret = new CT_NonVisualDrawingProps();
                    $ret.c = ST_DrawingElementId.a(b.c);
                    $ret.f = b.a;
                    $ret.d = a.visible == false;
                    return $ret;
                })());
                $ret.b = ((() => {
                    let $ret = new CT_NonVisualConnectorProperties();
                    return $ret;
                })());
                return $ret;
            })());
            $ret.spPr = ((() => {
                let $ret = new CT_ShapeProperties();
                $ret.e = ((() => {
                    let $ret = new CT_PresetGeometry2D();
                    $ret.b = a._b1.value;
                    $ret.a = ((() => {
                        let $ret = new CT_GeomGuideList();
                        return $ret;
                    })());
                    return $ret;
                })());
                $ret.a = a._k._c(ObjectModelExcelDocumentManager.$, IEG_FillProperties_$type, IEG_ShapeFillVisitor.a, this.bd);
                $ret.c = a._n._c(ObjectModelExcelDocumentManager.$, CT_LineProperties.$, CT_ShapeOutlineVisitor.a, this.bd);
                $ret.d = XlsxUtilities.ag(a);
                return $ret;
            })());
            $ret.style = ObjectModelDrawingPartManager.bl(a);
            return $ret;
        })());
    }
    a6(a) {
        if (a._b3 == null) {
            if (a._fx != null && a._fx.a == null) {
                return null;
            }
        }
        let b = this.bd;
        if (WorksheetChart._f9(a.chartType)) {
            return WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), IGraphicalObjectContent_$type, b._j(ObjectModelChartExPartManager.a9, a), (c) => {
                let d = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), c);
                let e = d.c;
                let f = d.d;
                let g = this.bp.item(a);
                let h = ObjectModelDrawingPartManager.bw(f);
                let i = stringIsNullOrEmpty(a._b8) == false ? a._b8 : h.hasValue ? stringFormat("Chart {0}", h.value) : null;
                return ((() => {
                    let $ret = new CT_GraphicalObjectFrame();
                    $ret.a = ((() => {
                        let $ret = new CT_GraphicalObject();
                        $ret.a = ((() => {
                            let $ret = new CT_GraphicalObjectData();
                            $ret.b = ((() => {
                                let $ret = new List$1(Tuple$2.$.specialize(String_$type, Base.$), 0);
                                $ret.add(Tuple.a(String_$type, Base.$, DrawingMLChart2014.ap, ((() => {
                                    let $ret = new CT_RelId();
                                    $ret.a = f;
                                    return $ret;
                                })())));
                                return $ret;
                            })());
                            $ret.c = DrawingMLChart2014.an.i(b._z);
                            return $ret;
                        })());
                        return $ret;
                    })());
                    $ret.e = a._b7;
                    $ret.d = a._a0;
                    $ret.c = XlsxUtilities.ag(a);
                    $ret.b = h.hasValue ? ((() => {
                        let $ret = new CT_GraphicalObjectFrameNonVisual();
                        $ret.a = ((() => {
                            let $ret = new CT_NonVisualDrawingProps();
                            $ret.c = new ST_DrawingElementId(1, intSToU(h.value));
                            $ret.f = i;
                            return $ret;
                        })());
                        $ret.b = new CT_NonVisualGraphicFrameProperties();
                        return $ret;
                    })()) : null;
                    return $ret;
                })());
            });
        }
        return WorkItemExtensions.k(Tuple$2.$.specialize(Uri.$, String_$type), IGraphicalObjectContent_$type, b._j(ObjectModelChartPartManager.ba, a), (c) => {
            let d = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), c);
            let e = d.c;
            let f = d.d;
            let g = this.bp.item(a);
            let h = ObjectModelDrawingPartManager.bw(f);
            let i = stringIsNullOrEmpty(a._b8) == false ? a._b8 : h.hasValue ? stringFormat("Chart {0}", h.value) : null;
            return ((() => {
                let $ret = new CT_GraphicalObjectFrame();
                $ret.a = ((() => {
                    let $ret = new CT_GraphicalObject();
                    $ret.a = ((() => {
                        let $ret = new CT_GraphicalObjectData();
                        $ret.b = ((() => {
                            let $ret = new List$1(Tuple$2.$.specialize(String_$type, Base.$), 0);
                            $ret.add(Tuple.a(String_$type, Base.$, DrawingMLChart.be, ((() => {
                                let $ret = new CT_RelId();
                                $ret.a = f;
                                return $ret;
                            })())));
                            return $ret;
                        })());
                        $ret.c = DrawingMLChart.an.i(b._z);
                        return $ret;
                    })());
                    return $ret;
                })());
                $ret.e = a._b7;
                $ret.d = a._a0;
                $ret.c = XlsxUtilities.ag(a);
                $ret.b = h.hasValue ? ((() => {
                    let $ret = new CT_GraphicalObjectFrameNonVisual();
                    $ret.a = ((() => {
                        let $ret = new CT_NonVisualDrawingProps();
                        $ret.c = new ST_DrawingElementId(1, intSToU(h.value));
                        $ret.f = i;
                        return $ret;
                    })());
                    $ret.b = new CT_NonVisualGraphicFrameProperties();
                    return $ret;
                })()) : null;
                return $ret;
            })());
        });
    }
    static bw(a) {
        if (stringIsNullOrEmpty(a)) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        let b = stringReplace(a, "rId", stringEmpty());
        let c = 0;
        if (((() => { let d = tryParseInt32_1(b, c); c = d.p1; return d.ret; })())) {
            return Nullable$1.toNullable(Number_$type, c);
        }
        return Nullable$1.toNullable(Number_$type, null);
    }
    bo(a) {
        if (a._b9 == null) {
            return null;
        }
        let b = this.bd;
        let c = this.bp.item(a);
        let d = ((() => {
            let $ret = new CT_GraphicalObjectFrame();
            $ret.a = ((() => {
                let $ret = new CT_GraphicalObject();
                $ret.a = ((() => {
                    let $ret = new CT_GraphicalObjectData();
                    $ret.c = Drawing2010Slicer.an.i(b._z);
                    $ret.b = ((() => {
                        let $ret = new List$1(Tuple$2.$.specialize(String_$type, Base.$), 0);
                        $ret.add(Tuple.a(String_$type, Base.$, Drawing2010Slicer.as, ((() => {
                            let $ret = new CT_Slicer();
                            $ret.a = a._b9;
                            return $ret;
                        })())));
                        return $ret;
                    })());
                    return $ret;
                })());
                return $ret;
            })());
            $ret.e = a._b7;
            $ret.d = a._a0;
            $ret.b = ((() => {
                let $ret = new CT_GraphicalObjectFrameNonVisual();
                $ret.a = ((() => {
                    let $ret = new CT_NonVisualDrawingProps();
                    $ret.c = ST_DrawingElementId.a(c.c);
                    $ret.f = a._b9;
                    return $ret;
                })());
                $ret.b = new CT_NonVisualGraphicFrameProperties();
                return $ret;
            })());
            $ret.c = XlsxUtilities.ag(a);
            return $ret;
        })());
        return ExcelUtils.ab(IGraphicalObjectContent_$type, d, a._b4);
    }
    a7(a, b) {
        let c = this.bp.item(b);
        let d = ((() => {
            let $ret = new CT_GroupShape();
            $ret.a = ((() => {
                let $ret = new CT_GroupShapeNonVisual();
                $ret.a = ((() => {
                    let $ret = new CT_NonVisualDrawingProps();
                    $ret.c = ST_DrawingElementId.a(c.c);
                    $ret.f = c.a;
                    $ret.d = b.visible == false;
                    return $ret;
                })());
                $ret.b = ((() => {
                    let $ret = new CT_NonVisualGroupDrawingShapeProps();
                    return $ret;
                })());
                return $ret;
            })());
            $ret.b = ((() => {
                let $ret = new CT_GroupShapeProperties();
                $ret.c = XlsxUtilities.af(b);
                return $ret;
            })());
            return $ret;
        })());
        return WorkItemExtensions.g(IGraphicalObjectContent_$type, Async.c(0, b._shapes$i.count, 1, (e) => {
            let f = a._z(b._shapes$i.item(e));
            return Async.g(f != null, () => WorkItemExtensions.e(IGraphicalObjectContent_$type, this.a8(a, f), (g) => d.d.add(WorkItemExtensions.m(IGraphicalObjectContent_$type, g))));
        }), () => d);
    }
    bj(a) {
        let b = this.s.a(Dictionary$2.$.specialize(ExcelImage.$, String_$type));
        if (b == null) {
            return null;
        }
        let c = this.bp.item(a);
        return ((() => {
            let $ret = new CT_Picture();
            $ret.d = a._b7;
            $ret.c = a._a0;
            $ret.b = ((() => {
                let $ret = new CT_PictureNonVisual();
                $ret.a = ((() => {
                    let $ret = new CT_NonVisualDrawingProps();
                    $ret.c = ST_DrawingElementId.a(c.c);
                    $ret.f = c.a;
                    $ret.e = c.a;
                    $ret.d = a.visible == false;
                    return $ret;
                })());
                $ret.b = ((() => {
                    let $ret = new CT_NonVisualPictureProperties();
                    $ret.a = ((() => {
                        let $ret = new CT_PictureLocking();
                        $ret.c = true;
                        return $ret;
                    })());
                    return $ret;
                })());
                return $ret;
            })());
            $ret.a = ((() => {
                let $ret = new CT_BlipFillProperties();
                $ret.d = ((() => {
                    let $ret = new CT_Blip();
                    $ret.b = b.item(a._image);
                    return $ret;
                })());
                $ret.e = ((() => {
                    let $ret = new CT_StretchInfoProperties();
                    $ret.a = ((() => {
                        let $ret = new CT_RelativeRect();
                        return $ret;
                    })());
                    return $ret;
                })());
                return $ret;
            })());
            $ret.spPr = ((() => {
                let $ret = new CT_ShapeProperties();
                $ret.e = ((() => {
                    let $ret = new CT_PresetGeometry2D();
                    $ret.b = 4;
                    $ret.a = ((() => {
                        let $ret = new CT_GeomGuideList();
                        return $ret;
                    })());
                    return $ret;
                })());
                $ret.d = XlsxUtilities.ag(a);
                return $ret;
            })());
            return $ret;
        })());
    }
    bk(a) {
        let b = null;
        if (typeCast(UnknownShape.$, a) !== null && typeCast(CT_CustomGeometry2D.$, a._en) !== null) {
            b = a._en;
        }
        else if (a._b1.hasValue) {
            b = ((() => {
                let $ret = new CT_PresetGeometry2D();
                $ret.b = a._b1.value;
                $ret.a = ((() => {
                    let $ret = new CT_GeomGuideList();
                    return $ret;
                })());
                return $ret;
            })());
        }
        if (b == null) {
            return null;
        }
        let c = this.bp.item(a);
        return ((() => {
            let $ret = new CT_Shape();
            $ret.e = a._b7;
            $ret.f = a._ca;
            $ret.c = a._ax;
            $ret.d = a._a0;
            $ret.a = ((() => {
                let $ret = new CT_ShapeNonVisual();
                $ret.a = ((() => {
                    let $ret = new CT_NonVisualDrawingProps();
                    $ret.c = ST_DrawingElementId.a(c.c);
                    $ret.f = c.a;
                    $ret.d = a.visible == false;
                    return $ret;
                })());
                $ret.b = ((() => {
                    let $ret = new CT_NonVisualDrawingShapeProps();
                    return $ret;
                })());
                return $ret;
            })());
            $ret.spPr = ((() => {
                let $ret = new CT_ShapeProperties();
                $ret.e = b;
                $ret.a = a._k._c(ObjectModelExcelDocumentManager.$, IEG_FillProperties_$type, IEG_ShapeFillVisitor.a, this.bd);
                $ret.c = a._n._c(ObjectModelExcelDocumentManager.$, CT_LineProperties.$, CT_ShapeOutlineVisitor.a, this.bd);
                $ret.d = XlsxUtilities.ag(a);
                return $ret;
            })());
            $ret.style = ObjectModelDrawingPartManager.bl(a);
            $ret.b = this.bn(a);
            return $ret;
        })());
    }
    static bm(a) {
        let b;
        if (a.isAutomatic) {
            b = ((() => {
                let $ret = new CT_SysColor();
                $ret.d = 27;
                $ret.c = ST_HexColorRGB.b(SystemColorsInternal.bb);
                return $ret;
            })());
        }
        else {
            if (nullableNotEquals(a._themeColorType$i, null)) {
                b = ((() => {
                    let $ret = new CT_SchemeColor();
                    $ret.c = XlsxUtilities.ah(a._themeColorType$i.value);
                    return $ret;
                })());
            }
            else if (Color.e(a._color$i, Nullable$1.toNullable(Color.$, null))) {
                let c = a._color$i.value;
                let d = XlsxUtilities.bb(c);
                if (nullableNotEquals(d, null)) {
                    b = ((() => {
                        let $ret = new CT_SysColor();
                        $ret.d = d.value;
                        $ret.c = ST_HexColorRGB.b(c);
                        return $ret;
                    })());
                }
                else {
                    b = ((() => {
                        let $ret = new CT_SRgbColor();
                        $ret.c = ST_HexColorRGB.b(c);
                        return $ret;
                    })());
                    if (c.l != 255) {
                        b.b.add(((() => {
                            let $ret = new ColorTransform_Alpha();
                            $ret.a = ST_PositiveFixedPercentage.d(new ST_Percentage(1, (c.l / 255) * 100));
                            return $ret;
                        })()));
                    }
                }
            }
            else {
                b = ((() => {
                    let $ret = new CT_SRgbColor();
                    $ret.c = ST_HexColorRGB.b(ExcelUtils.g1(a._aj(null, false, true)));
                    return $ret;
                })());
            }
            if (nullableNotEquals(a._tint$i, null)) {
                let e = a._tint$i.value;
                if (e < 0) {
                    b.b.add(((() => {
                        let $ret = new ColorTransform_LumMod();
                        $ret.a = ST_Percentage.b((1 + e) * 100);
                        return $ret;
                    })()));
                }
                else {
                    b.b.add(((() => {
                        let $ret = new ColorTransform_LumMod();
                        $ret.a = ST_Percentage.b(e * 100);
                        return $ret;
                    })()));
                    b.b.add(((() => {
                        let $ret = new ColorTransform_LumOff();
                        $ret.a = ST_Percentage.b((1 - e) * 100);
                        return $ret;
                    })()));
                }
            }
        }
        let f = ((() => {
            let $ret = new CT_SolidFillProperties();
            $ret.a = b;
            return $ret;
        })());
        return f;
    }
    bn(a) {
        let b = this.bp.item(a);
        let c = this.bd._by;
        let d = typeCast(WorksheetShapeWithText.$, a);
        if (d == null || d.text == null) {
            return null;
        }
        let e = ((() => {
            let $ret = new CT_TextBody();
            $ret.b = new CT_TextListStyle();
            return $ret;
        })());
        e.a = CT_TextBodyProperties.b(d.text._o);
        e.a.d = Nullable$1.toNullable(ST_TextAnchoringType_$type, XlsxUtilities.aj(d.text.verticalAlignment));
        if (d.text._s.hasValue && d.text._s.value == 0) {
            e.a.e = Nullable$1.toNullable(Boolean_$type, true);
        }
        for (let f of fromEnum(d.text._paragraphs$i)) {
            let g = ((() => {
                let $ret = new CT_TextParagraph();
                $ret.a = ((() => {
                    let $ret = new CT_TextParagraphProperties();
                    $ret.c = Nullable$1.toNullable(ST_TextAlignType_$type, XlsxUtilities.ai(f.alignment));
                    return $ret;
                })());
                return $ret;
            })());
            for (let h of fromEnum(f._getFormattingRuns(c))) {
                let i = h;
                let j = ((() => {
                    let $ret = new CT_RegularTextRun();
                    $ret.a = i.o || new CT_TextCharacterProperties();
                    $ret.b = i.l;
                    return $ret;
                })());
                let k = i.h ? i.f(c) : null;
                if (k != null) {
                    if (k.height > 0) {
                        j.a.r = Nullable$1.toNullable(Number_$type, SerializationUtils.p(k.height));
                    }
                    if (nullableEquals(k._bold$i, true)) {
                        j.a.d = ExcelUtils.du(k._bold$i);
                    }
                    if (nullableEquals(k._italic$i, true)) {
                        j.a.i = ExcelUtils.du(k._italic$i);
                    }
                    let l = k.underlineStyle;
                    if (l != -1) {
                        j.a.s = Nullable$1.toNullable(ST_TextUnderlineType_$type, XlsxUtilities.ak(l));
                    }
                    if (nullableEquals(k._strikeout$i, true)) {
                        j.a.q = Nullable$1.toNullable(ST_TextStrikeType_$type, 1);
                    }
                    switch (k.superscriptSubscriptStyle) {
                        case 2:
                            j.a.e = Nullable$1.toNullable(ST_Percentage.$, new ST_Percentage(1, -25));
                            break;
                        case 1:
                            j.a.e = Nullable$1.toNullable(ST_Percentage.$, new ST_Percentage(1, 30));
                            break;
                    }
                    if (WorkbookColorInfo.l_op_Inequality(k.colorInfo, null)) {
                        j.a.y = ObjectModelDrawingPartManager.bm(k.colorInfo);
                    }
                    if (stringIsNullOrEmpty(k.name) == false) {
                        j.a.c = ((() => {
                            let $ret = new CT_TextFont();
                            $ret.d = k.name;
                            return $ret;
                        })());
                    }
                }
                g.c.add(j);
            }
            e.d.add(g);
        }
        return e;
    }
    static bl(a) {
        let b = ((() => {
            let $ret = new CT_ShapeStyle();
            $ret.d = ((() => {
                let $ret = new CT_StyleMatrixReference();
                $ret.b = a._a5 ? 1 : 2;
                $ret.a = ((() => {
                    let $ret = new CT_SchemeColor();
                    $ret.c = 4;
                    return $ret;
                })());
                return $ret;
            })());
            $ret.c = ((() => {
                let $ret = new CT_StyleMatrixReference();
                $ret.b = a._a5 ? 0 : 1;
                $ret.a = ((() => {
                    let $ret = new CT_SchemeColor();
                    $ret.c = 4;
                    return $ret;
                })());
                return $ret;
            })());
            $ret.b = ((() => {
                let $ret = new CT_StyleMatrixReference();
                $ret.b = 0;
                $ret.a = ((() => {
                    let $ret = new CT_SchemeColor();
                    $ret.c = 4;
                    return $ret;
                })());
                return $ret;
            })());
            $ret.a = ((() => {
                let $ret = new CT_FontReference();
                $ret.b = 1;
                $ret.a = ((() => {
                    let $ret = new CT_SchemeColor();
                    $ret.c = a._a5 ? 1 : 14;
                    return $ret;
                })());
                return $ret;
            })());
            return $ret;
        })());
        if (a._a5 == false) {
            b.d.a.b.add(((() => {
                let $ret = new ColorTransform_Shade();
                $ret.a = ST_PositiveFixedPercentage.d(new ST_Percentage(1, 50));
                return $ret;
            })()));
        }
        return b;
    }
    a8(a, b) {
        return WorkItemExtensions.k(IGraphicalObjectContent_$type, IGraphicalObjectContent_$type, this.a9(a, b), (c) => {
            let d = WorkItemExtensions.m(IGraphicalObjectContent_$type, c);
            d = ExcelUtils.ab(IGraphicalObjectContent_$type, d, b._b3);
            let e = this.bo(b);
            if (e != null) {
                return ((() => {
                    let $ret = new AlternateGraphicalObjectContent();
                    $ret.b = ((() => {
                        let $ret = new List$1(Tuple$2.$.specialize(Array_$type, IGraphicalObjectContent_$type), 0);
                        $ret.add(Tuple.a(Array_$type, IGraphicalObjectContent_$type, [Drawing2010Main.an], e));
                        return $ret;
                    })());
                    $ret.a = d;
                    return $ret;
                })());
            }
            return d;
        });
    }
    a9(a, b) {
        let c = typeCast(WorksheetShapeGroup.$, b);
        if (c != null) {
            return this.a7(a, c);
        }
        let d = typeCast(WorksheetImage.$, b);
        if (d != null) {
            return WorkItem.g(IGraphicalObjectContent_$type, this.bj(d));
        }
        let e = typeCast(WorksheetChart.$, b);
        if (e != null) {
            return this.a6(e);
        }
        if (b._bc) {
            return WorkItem.g(IGraphicalObjectContent_$type, this.bi(b));
        }
        return WorkItem.g(IGraphicalObjectContent_$type, this.bk(b));
    }
    static bz(a, b, c, d) {
        let e = a.worksheet;
        let f = e._gd(a.columnIndex);
        let g = e._gh(a.rowIndex) * (e.workbook._jk.height / Workbook._jh.height);
        let h = b.x / 100;
        let i = b.y / 100;
        c = ExcelUtils.dm(MathUtilities.f(h * f));
        d = ExcelUtils.dm(MathUtilities.f(i * g));
        return {
            p2: c,
            p3: d
        };
    }
    b0(a) {
        if (this.bh == null) {
            return;
        }
        let b = a.s.a(EG_Anchor.$);
        if (b == null) {
            return;
        }
        if (b.a == null) {
            return;
        }
        this.bh._ay = b.a.a;
        this.bh._az = b.a.b;
    }
    static b1(a) {
        let b;
        let c = DrawingMLMain.k9(a, b);
        b = c.p1;
    }
    static b2(a) {
    }
    static b3(a) {
    }
    static b4(a) {
    }
    b5(a) {
        let b = a.s.a(IGraphicalObjectContent_$type);
        let c = a.s.a(Sheet.$);
        let d = a.s.a(EG_Anchor.$);
        if (b == null || c == null || d == null) {
            return;
        }
        this.bt--;
        if (0 < this.bt) {
            return;
        }
        let e = ((() => {
            let $ret = new ObjectModelDrawingPartManager_ShapeLoadContext();
            $ret.a = c;
            $ret.b = this.bq;
            return $ret;
        })());
        this.bh = b._accept$2$i(ObjectModelDrawingPartManager_ShapeLoadContext.$, WorksheetShape.$, this.bg, e);
        if (this.bh != null) {
            this.bd._b7._bu(this.bh, d);
        }
        else if (this.ab.s) {
            this.ab.aj();
        }
    }
    static b6(a) {
        let b = ObjectModelDrawingPartManager.be(a);
        let c = b._d;
        if (c == null) {
            return;
        }
        let d = null;
        if (b._an.f != 0) {
            let e = b._an.d();
            d = b._b7._ao(e.uri.toString());
        }
        if (d == null) {
            return;
        }
        a.s.k(d);
    }
    b7(a) {
        let b = this.x(a).b;
        this.ay(a, (c) => {
            this.bt++;
            b(c);
        }, false);
        this.ax(a, runOn(this, this.b5));
    }
    ba(a, b) {
        DrawingMLSpreadsheetDrawing.e1(this);
        this.cd(b);
        this.cb(b);
        return WorkItemExtensions.e(IGraphicalObjectContent_$type, this.a8(a, b), (c) => {
            DrawingPartManagerHelpers.dd(this, WorkItemExtensions.m(IGraphicalObjectContent_$type, c));
            this.b8(b);
            this.ad.k();
        });
    }
    b8(a) {
        DrawingMLSpreadsheetDrawing.e2(this, a._ay, a._az);
        this.ad.k();
    }
    b9(a) {
        DrawingMLSpreadsheetDrawing.e3(this, a);
        this.ad.k();
    }
    ca(a) {
        DrawingMLSpreadsheetDrawing.e4(this, ST_Coordinate.b(a));
        this.ad.k();
    }
    cb(a) {
        let b = a._getBoundsInTwips();
        DrawingMLSpreadsheetDrawing.e6(this, new ST_PositiveCoordinate(1, ExcelUtils.dm(b.width)), new ST_PositiveCoordinate(1, ExcelUtils.dm(b.height)));
        this.ad.k();
    }
    cc(a) {
        DrawingMLSpreadsheetDrawing.e7(this);
        this.ch(a.topLeftCornerCell, a._topLeftCornerPosition$i);
        this.ad.k();
    }
    bb(a, b) {
        DrawingMLSpreadsheetDrawing.e8(this);
        this.cc(b);
        this.cb(b);
        return WorkItemExtensions.e(IGraphicalObjectContent_$type, this.a8(a, b), (c) => {
            DrawingPartManagerHelpers.dd(this, WorkItemExtensions.m(IGraphicalObjectContent_$type, c));
            this.b8(b);
            this.ad.k();
        });
    }
    cd(a) {
        let b = a._getBoundsInTwips();
        DrawingMLSpreadsheetDrawing.e9(this, new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.x))), new ST_Coordinate(1, ST_CoordinateUnqualified.a(ExcelUtils.dm(b.y))));
        this.ad.k();
    }
    ce(a) {
        DrawingMLSpreadsheetDrawing.fa(this, a);
        this.ad.k();
    }
    cf(a) {
        DrawingMLSpreadsheetDrawing.fb(this, ST_Coordinate.b(a));
        this.ad.k();
    }
    cg(a) {
        DrawingMLSpreadsheetDrawing.fd(this);
        this.ch(a.bottomRightCornerCell, a._bottomRightCornerPosition$i);
        this.ad.k();
    }
    ch(a, b) {
        let c;
        let d;
        let e = ObjectModelDrawingPartManager.bz(a, b, c, d);
        c = e.p2;
        d = e.p3;
        this.b9(a.columnIndex);
        this.ca(c);
        this.ce(a.rowIndex);
        this.cf(d);
    }
    bc(a, b) {
        DrawingMLSpreadsheetDrawing.fe(this, XlsxUtilities.at(b.positioningMode));
        this.cc(b);
        this.cg(b);
        let c = typeCast(WorksheetChart.$, b);
        let d = c != null && WorksheetChart._f9(c.chartType);
        if (d) {
            let e = ChartExUtils.c(c.chartType);
            this.ci(e);
            return WorkItemExtensions.e(IGraphicalObjectContent_$type, this.a8(a, b), (f) => {
                DrawingPartManagerHelpers.dd(this, WorkItemExtensions.m(IGraphicalObjectContent_$type, f));
                this.ad.k();
                this.cj();
                this.ad.k();
                this.b8(b);
                this.ad.k();
            });
        }
        else {
            return WorkItemExtensions.e(IGraphicalObjectContent_$type, this.a8(a, b), (f) => {
                DrawingPartManagerHelpers.dd(this, WorkItemExtensions.m(IGraphicalObjectContent_$type, f));
                this.b8(b);
                this.ad.k();
            });
        }
    }
    ci(a) {
        MarkupCompatibility2006.ay(this);
        let b = null;
        let c = null;
        switch (a) {
            case DrawingMLChartEx2015_9_8.ap:
                b = DrawingMLChartEx2015_9_8.an;
                c = "cx1";
                break;
            case DrawingMLChartEx2015_10_21.ap:
                b = DrawingMLChartEx2015_10_21.an;
                c = "cx2";
                break;
            case DrawingMLChartEx2016_5_10.ap:
                b = DrawingMLChartEx2016_5_10.an;
                c = "cx4";
                break;
            default: break;
        }
        MarkupCompatibility2006.a0(this, c);
        this.ad.l(b);
    }
    cj() {
        let a = this.ad;
        MarkupCompatibility2006.a1(this);
        a.p(DrawingMLSpreadsheetDrawing.ef, "xdr");
        a.h("macro", stringEmpty());
        a.h("textlink", stringEmpty());
        a.p(DrawingMLSpreadsheetDrawing.d9, "xdr");
        a.p(DrawingMLSpreadsheetDrawing.du, "xdr");
        a.h("id", "0");
        a.h("name", stringEmpty());
        a.k();
        a.p(DrawingMLSpreadsheetDrawing.dv, "xdr");
        a.p(DrawingMLMain.iy, "a");
        a.h("noTextEdit", "1");
        a.k();
        a.k();
        a.k();
        a.p(DrawingMLSpreadsheetDrawing.eg, "xdr");
        a.p(DrawingMLMain.hp, "a");
        a.h("prst", "rect");
        a.p(DrawingMLMain.bg, "a");
        a.k();
        a.k();
        a.p(DrawingMLMain.io, "a");
        a.p(DrawingMLMain.hn, "a");
        a.h("val", "white");
        a.k();
        a.k();
        a.p(DrawingMLMain.fw, "a");
        a.h("w", "1");
        a.p(DrawingMLMain.io, "a");
        a.p(DrawingMLMain.hn, "a");
        a.h("val", "green");
        a.k();
        a.k();
        a.k();
        a.k();
        a.p(DrawingMLSpreadsheetDrawing.ek, "xdr");
        a.p(DrawingMLMain.bz, "a");
        a.h("vertOverflow", "clip");
        a.h("horzOverflow", "clip");
        a.k();
        a.p(DrawingMLMain.f1, "a");
        a.k();
        a.p(DrawingMLMain.hd, "a");
        let b = (c) => {
            a.p(DrawingMLMain.hu, "a");
            a.p(DrawingMLMain.h7, "a");
            a.h("lang", "en-US");
            a.h("sz", "1100");
            a.k();
            a.p(DrawingMLMain.ja, "a");
            a.u(c);
            a.k();
            a.k();
        };
        let c = ExcelUtils.ef("LD_Fallback_ChartEx_Line1");
        b(c);
        a.o(DrawingMLMain.b0);
        a.k();
        a.o(DrawingMLMain.b0);
        a.k();
        let d = ExcelUtils.ef("LD_Fallback_ChartEx_Line2");
        b(d);
        a.k();
        a.k();
        a.k();
        a.k();
    }
    get bd() {
        return ObjectModelDrawingPartManager.be(this);
    }
    static be(a) {
        return a.d;
    }
}
ObjectModelDrawingPartManager.$t = markType(ObjectModelDrawingPartManager, 'ObjectModelDrawingPartManager', DrawingPartManager.$);
ObjectModelDrawingPartManager.bf = new ObjectModelDrawingPartManager();
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeIdentity extends Base {
    constructor(a, b) {
        super();
        this.c = 0;
        this.a = null;
        this.c = b;
        this.a = a._b8 != null ? a._b8 : ObjectModelDrawingPartManager_ShapeIdentity.b(a, b);
    }
    static b(a, b) {
        let c;
        if (typeCast(WorksheetImage.$, a) !== null) {
            c = "WorksheetShapeSerialization_ImageName";
        }
        else if (typeCast(WorksheetShapeGroup.$, a) !== null) {
            c = "WorksheetShapeSerialization_GroupName";
        }
        else {
            c = "WorksheetShapeSerialization_ShapeName";
        }
        return stringFormat("{0} {1}", ExcelUtils.ef(c), b);
    }
}
ObjectModelDrawingPartManager_ShapeIdentity.$t = markType(ObjectModelDrawingPartManager_ShapeIdentity, 'ObjectModelDrawingPartManager_ShapeIdentity');
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoadContext extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.a = null;
    }
}
ObjectModelDrawingPartManager_ShapeLoadContext.$t = markType(ObjectModelDrawingPartManager_ShapeLoadContext, 'ObjectModelDrawingPartManager_ShapeLoadContext');
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoader extends Base {
    constructor(a) {
        super();
        this.d = null;
        this.b = null;
        this.c = null;
        this.c = new ObjectModelDrawingPartManager_ShapeLoader_ShapeFillCreator(this);
        this.d = a.bd._b7;
        this.b = a;
    }
    _visitAlternateGraphicalObjectContent$i(a, b) {
        return null;
    }
    _visitCT_Connector$i(a, b) {
        let c;
        if (a.spPr != null && a.spPr.e != null) {
            c = a.spPr.e._accept$2$i(Boolean_$type, WorksheetShape.$, ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator.a, null);
        }
        else {
            c = new UnknownShape(1);
        }
        c._b3 = a;
        c._b7 = a.c;
        c._a0 = a.b;
        c._b8 = ObjectModelDrawingPartManager_ShapeLoader.i(a.a);
        c._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.a).getValueOrDefault());
        c.visible = (ObjectModelDrawingPartManager_ShapeLoader.g(a.a) == false);
        c._bc = true;
        this.j(c, a.style, b);
        if (a.spPr != null) {
            if (a.spPr.a != null) {
                c.fill = a.spPr.a._accept$2$i(Workbook.$, ShapeFill.$, this.c, b.a.workbook);
            }
            if (a.spPr.c != null) {
                c.outline = this.e(c.outline, a.spPr.c, b);
            }
            this.k(c, a.spPr.d);
        }
        b.b.add(c);
        return c;
    }
    _visitCT_GraphicalObjectFrame$i(a, b) {
        if (a.a == null || a.a.a == null) {
            return null;
        }
        let c = false;
        let d = Enumerable.ag(Tuple$2.$.specialize(String_$type, Base.$), a.a.a.b, (e) => e.c == DrawingMLChart.be);
        if (d == null) {
            d = Enumerable.ag(Tuple$2.$.specialize(String_$type, Base.$), a.a.a.b, (e) => e.c == DrawingMLChart2014.ap);
            c = d != null;
        }
        if (d != null) {
            let e = typeCast(CT_RelId.$, d.d);
            if (e == null || e.a == null) {
                return null;
            }
            let f = null;
            let g = null;
            let h = this.b.bd._d;
            let i = h.getRelationships();
            let j = c ? ChartExPartManager.a5 : ChartPartManager.a5;
            let k = c ? ChartExPartManager.a6 : ChartPartManager.a6;
            if (c) {
                let l = false;
                for (let m of fromEnum(i)) {
                    if (m.relationshipType == k || m.relationshipType == j) {
                        l = true;
                        break;
                    }
                }
                if (l == false) {
                    j = ChartPartManager.a5;
                    k = ChartPartManager.a6;
                }
            }
            for (let n of fromEnum(i)) {
                if (n.relationshipType != k && n.relationshipType != j) {
                    continue;
                }
                let o = n.id;
                if (o != e.a) {
                    continue;
                }
                if (this.b.bd._ca == null) {
                    this.b.bd._ca = new HashSet$1(String_$type, 0);
                }
                let p = stringFormat("{0}/{1}", h.uri.toString(), o);
                if (this.b.bd._ca.add_1(p) == false) {
                    continue;
                }
                let q = SerializationUtils.t(n.targetUri);
                let r = this.b.bd._b4();
                if (r == null) {
                }
                else {
                    if (((() => { let s = r.c.tryGetValue(q, f); f = s.p1; return s.ret; })()) == false) {
                        let s = r.d.tryGetValue(q, g);
                        g = s.p1;
                    }
                }
                if (f != null || g != null) {
                    break;
                }
            }
            if (f == null && g == null) {
            }
            let t = ((() => {
                let $ret = new WorksheetChart(0);
                $ret._b3 = a;
                $ret._fx = f != null ? f.a : g != null ? g.a : null;
                $ret._a0 = a.d;
                $ret._b7 = a.e;
                $ret._b8 = ObjectModelDrawingPartManager_ShapeLoader.i(a.b);
                $ret._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.b).getValueOrDefault());
                $ret.visible = (ObjectModelDrawingPartManager_ShapeLoader.g(a.b) == false);
                return $ret;
            })());
            if (f != null) {
                WorksheetChartExtensions.aq(t, f, b.a, this.d);
            }
            else if (g != null) {
                WorksheetChartExtensions.ar(t, g, b.a, this.d);
            }
            this.k(t, a.c);
            b.b.add(t);
            return t;
        }
        let u = Enumerable.ag(Tuple$2.$.specialize(String_$type, Base.$), a.a.a.b, (v) => v.c == Drawing2010Slicer.as);
        if (u != null) {
            let v = typeCast(CT_Slicer.$, u.d);
            if (v == null || v.a == null) {
                return null;
            }
            let w = ((() => {
                let $ret = new RectangleShape();
                $ret._b9 = v.a;
                $ret._b4 = a;
                $ret._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.b).getValueOrDefault());
                $ret.fill = ShapeFill._fromColor$i(ColorsInternal.e);
                $ret.outline = ShapeOutline._fromColor$i(ColorsInternal.d);
                return $ret;
            })());
            w.text = new FormattedText("This shape represents a slicer. Slicers can be used in at least Excel 2010.\r\n\r\nIf the shape was modified in an earlier version of Excel, or if the workbook was saved in Excel 2003 or earlier, the slicer cannot be used.");
            this.k(w, a.c);
            b.b.add(w);
            return w;
        }
        return null;
    }
    _visitCT_GroupShape$i(a, b) {
        let c = ((() => {
            let $ret = new WorksheetShapeGroup(true);
            $ret._b3 = a;
            $ret._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.a).getValueOrDefault());
            $ret._b8 = ObjectModelDrawingPartManager_ShapeLoader.i(a.a);
            $ret.visible = (ObjectModelDrawingPartManager_ShapeLoader.g(a.a) == false);
            return $ret;
        })());
        if (a.b != null) {
            if (a.b.a != null) {
                c.fill = a.b.a._accept$2$i(Workbook.$, ShapeFill.$, this.c, b.a.workbook);
            }
            this.l(c, a.b.c);
        }
        let d = ((() => {
            let $ret = new ObjectModelDrawingPartManager_ShapeLoadContext();
            $ret.a = b.a;
            $ret.b = c._shapes$i;
            return $ret;
        })());
        a.d.q((e) => e._accept$2$i(ObjectModelDrawingPartManager_ShapeLoadContext.$, WorksheetShape.$, this, d));
        b.b.add(c);
        return c;
    }
    _visitCT_Picture$i(a, b) {
        let c = null;
        if (a.a != null) {
            let d = a.a.d;
            if (d != null) {
                let e = this.b.bd;
                if (d.c != null) {
                    let f = typeCast(Uri.$, e._au(d.c));
                    if (f != null) {
                        ExcelUtils.e(e._b7._b, f);
                    }
                }
                if (c == null && d.b != null) {
                    c = typeCast(ImageData.$, e._au(d.b));
                }
                d.b = null;
                d.c = null;
            }
        }
        if (c == null) {
            return null;
        }
        let g = ((() => {
            let $ret = new WorksheetImage(false);
            $ret._b3 = a;
            $ret._a0 = a.c;
            $ret._b7 = a.d;
            $ret._b8 = ObjectModelDrawingPartManager_ShapeLoader.i(a.b);
            $ret._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.b).getValueOrDefault());
            $ret.visible = (ObjectModelDrawingPartManager_ShapeLoader.g(a.b) == false);
            return $ret;
        })());
        let h = XlsxUtilities.u(c);
        g._image = h.b;
        g.preferredFormat = h.d;
        if (a.spPr != null) {
            if (a.spPr.a != null) {
                g.fill = a.spPr.a._accept$2$i(Workbook.$, ShapeFill.$, this.c, b.a.workbook);
            }
            if (a.spPr.c != null) {
                g.outline = this.e(g.outline, a.spPr.c, b);
            }
            this.k(g, a.spPr.d);
        }
        b.b.add(g);
        return g;
    }
    _visitCT_Shape$i(a, b) {
        let c;
        if (a.spPr != null && a.spPr.e != null) {
            c = a.spPr.e._accept$2$i(Boolean_$type, WorksheetShape.$, ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator.a, null);
        }
        else {
            c = new UnknownShape(1);
        }
        c._b3 = a;
        c._b7 = a.e;
        c._ca = a.f;
        c._ax = a.c;
        c._a0 = a.d;
        c._b8 = ObjectModelDrawingPartManager_ShapeLoader.i(a.a);
        c._cn = ST_DrawingElementId.h(ObjectModelDrawingPartManager_ShapeLoader.h(a.a).getValueOrDefault());
        c.visible = (ObjectModelDrawingPartManager_ShapeLoader.g(a.a) == false);
        let d = typeCast(WorksheetShapeWithText.$, c);
        if (d != null) {
            d.text = this.a(a.b, this.f(a));
        }
        else {
        }
        c._bc = false;
        this.j(c, a.style, b);
        if (a.spPr != null) {
            if (a.spPr.a != null) {
                c.fill = a.spPr.a._accept$2$i(Workbook.$, ShapeFill.$, this.c, b.a.workbook);
            }
            if (a.spPr.c != null) {
                c.outline = this.e(c.outline, a.spPr.c, b);
            }
            this.k(c, a.spPr.d);
        }
        b.b.add(c);
        return c;
    }
    j(a, b, c) {
        if (b == null) {
            return;
        }
        if (b.c != null) {
            if (b.c.a != null && b.c.b != 0 && b.c.b != 1000) {
                a.fill = new ShapeFillSolid(XlsxUtilities.aa(b.c.a, c.a.workbook));
            }
        }
        if (b.d != null) {
            if (b.d.a != null) {
                a.outline = new ShapeOutlineSolid(XlsxUtilities.aa(b.d.a, c.a.workbook));
            }
        }
    }
    k(a, b) {
        if (b == null) {
            return;
        }
        a._b6 = b.d().n();
        a.flippedHorizontally = b.g();
        a.flippedVertically = b.h();
        this.d._bv(a, b);
    }
    l(a, b) {
        if (b == null) {
            return;
        }
        a._b6 = b.d().n();
        a.flippedHorizontally = b.g();
        a.flippedVertically = b.h();
        this.d._bv(a, b);
    }
    a(a, b) {
        if (a == null || a.d.count == 0) {
            return null;
        }
        let c = this.b.bd;
        let d = c._by;
        let e = new ObjectModelDrawingPartManager_ShapeLoader_RunCreator(this.b, b);
        let f = ((() => {
            let $ret = new FormattedText();
            $ret._o = a.a;
            return $ret;
        })());
        if (a.a != null) {
            if (nullableNotEquals(a.a.d, null)) {
                f.verticalAlignment = XlsxUtilities.z(a.a.d.value);
            }
        }
        let g = a.b != null ? a.b.b : null;
        let h = g != null ? typeCast(CT_TextCharacterProperties.$, g.a) : null;
        if (g != null && g.c.hasValue) {
            f._s = Nullable$1.toNullable(HorizontalTextAlignment_$type, XlsxUtilities.l(g.c.value));
        }
        let i = null;
        if (h != null) {
            let j = this.b.s.a(IWorkbookFontDefaultsResolver_$type);
            if (j == null) {
                i = new DefRprFontResolver(h, d);
                this.b.s.k(i);
            }
        }
        for (let k of fromEnum(a.d)) {
            let l = f._paragraphs$i._add1(stringEmpty());
            if (k.a != null) {
                if (nullableNotEquals(k.a.c, null)) {
                    l.alignment = XlsxUtilities.l(k.a.c.value);
                }
            }
            k.c.q((m) => m._accept$2$i(FormattedTextParagraph.$, FormattedTextRun.$, e, l));
        }
        if (i != null) {
            this.b.s.l(i);
        }
        return f;
    }
    static g(a) {
        if (a == null) {
            return false;
        }
        if (a.a == null) {
            return false;
        }
        return a.a.d;
    }
    static h(a) {
        if (a == null) {
            return Nullable$1.toNullable(ST_DrawingElementId.$, null);
        }
        if (a.a == null) {
            return Nullable$1.toNullable(ST_DrawingElementId.$, null);
        }
        return Nullable$1.toNullable(ST_DrawingElementId.$, a.a.c);
    }
    static i(a) {
        if (a == null) {
            return null;
        }
        if (a.a == null) {
            return null;
        }
        return a.a.f;
    }
    f(a) {
        let b = a.style;
        if (b == null) {
            return null;
        }
        let c = b.a;
        if (b == null) {
            return null;
        }
        return XlsxUtilities.aa(c.a, this.b.bd._by);
    }
    e(a, b, c) {
        if (b != null) {
            if (b.i != null) {
                a = b.i._accept$2$i(Workbook.$, ShapeOutline.$, ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator.a, c.a.workbook);
            }
            if (a == null) {
                return null;
            }
            if (ST_LineWidth.j(b.h, Nullable$1.toNullable(ST_LineWidth.$, null))) {
                a._d = ST_LineWidth.m(b.h.value);
            }
            a._e = b.a;
            a._f = b.b;
        }
        return a;
    }
}
ObjectModelDrawingPartManager_ShapeLoader.$t = markType(ObjectModelDrawingPartManager_ShapeLoader, 'ObjectModelDrawingPartManager_ShapeLoader', Base.$, [IGraphicalObjectContentVisitor$2_$type.specialize(ObjectModelDrawingPartManager_ShapeLoadContext.$, WorksheetShape.$)]);
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoader_RunCreator extends Base {
    constructor(a, b) {
        super();
        this.a = null;
        this.c = null;
        this.b = null;
        this.a = a;
        this.c = b;
        this.b = this.a.bd._by;
    }
    _visitCT_RegularTextRun$i(a, b) {
        let c = ((() => {
            let $ret = new FormattedTextRun(b, b.unformattedString.length);
            $ret.o = a.a;
            return $ret;
        })());
        b._u(c);
        b.unformattedString += a.b;
        let d = this.a.s.a(IWorkbookFontDefaultsResolver_$type);
        let e = c.f(this.b);
        if (WorkbookColorInfo.l_op_Inequality(this.c, null)) {
            e.colorInfo = this.c;
        }
        let f = e.d._ak(d);
        let g = a.a;
        if (g != null) {
            if (nullableNotEquals(g.r, null)) {
                f.height = truncate(Math.ceil((g.r.value / 100) * 20));
            }
            if (nullableNotEquals(g.d, null)) {
                f._bold$i = XlsxUtilities.a6(g.d.value);
            }
            if (ST_Percentage.h(g.e, Nullable$1.toNullable(ST_Percentage.$, null))) {
                if (ST_Percentage.l(g.e.value) >= 30) {
                    f.superscriptSubscriptStyle = 1;
                }
                else if (ST_Percentage.l(g.e.value) <= -25) {
                    f.superscriptSubscriptStyle = 2;
                }
                else {
                    f.superscriptSubscriptStyle = 0;
                }
            }
            if (g.y != null) {
                f.colorInfo = XlsxUtilities.ab(g.y, this.b);
            }
            if (nullableNotEquals(g.i, null)) {
                f._italic$i = XlsxUtilities.a6(g.i.value);
            }
            if (nullableNotEquals(g.s, null)) {
                f.underlineStyle = XlsxUtilities.h(g.s.value);
            }
            if (nullableNotEquals(g.q, null)) {
                f._strikeout$i = Nullable$1.toNullable(Boolean_$type, g.q.value == 0 ? false : true);
            }
            if (g.c != null && g.c.d != null) {
                f.name = g.c.d;
            }
        }
        e.setFontFormatting(f);
        return c;
    }
}
ObjectModelDrawingPartManager_ShapeLoader_RunCreator.$t = markType(ObjectModelDrawingPartManager_ShapeLoader_RunCreator, 'ObjectModelDrawingPartManager_ShapeLoader_RunCreator', Base.$, [IEG_TextRunVisitor$2_$type.specialize(FormattedTextParagraph.$, FormattedTextRun.$)]);
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoader_ShapeFillCreator extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
    _visitCT_BlipFillProperties$i(a, b) {
        if (a.d != null) {
            if (a.d.b != null) {
                let c = typeCast(ImageData.$, this.a.d._ai._au(a.d.b));
                if (c != null) {
                    return new ShapeFillImage(c);
                }
                else {
                }
            }
        }
        return null;
    }
    _visitCT_GroupFillProperties$i(a, b) {
        return null;
    }
    _visitCT_NoFillProperties$i(a, b) {
        return null;
    }
    _visitCT_SolidFillProperties$i(a, b) {
        if (a.a == null) {
            return null;
        }
        return new ShapeFillSolid(XlsxUtilities.aa(a.a, b));
    }
}
ObjectModelDrawingPartManager_ShapeLoader_ShapeFillCreator.$t = markType(ObjectModelDrawingPartManager_ShapeLoader_ShapeFillCreator, 'ObjectModelDrawingPartManager_ShapeLoader_ShapeFillCreator', Base.$, [IEG_FillPropertiesVisitor$2_$type.specialize(Workbook.$, ShapeFill.$)]);
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator extends Base {
    constructor() {
        super();
    }
    _visitCT_NoFillProperties$i(a, b) {
        return null;
    }
    _visitCT_SolidFillProperties$i(a, b) {
        if (a.a == null) {
            return null;
        }
        return new ShapeOutlineSolid(XlsxUtilities.aa(a.a, b));
    }
}
ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator.$t = markType(ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator, 'ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator', Base.$, [IEG_LineFillPropertiesVisitor$2_$type.specialize(Workbook.$, ShapeOutline.$)]);
ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator.a = new ObjectModelDrawingPartManager_ShapeLoader_ShapeOutlineCreator();
/**
 * @hidden
 */
export class ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator extends Base {
    constructor() {
        super();
    }
    _visitCT_PresetGeometry2D$i(a, b) {
        let c = WorksheetShape._bz(a.b);
        if (nullableNotEquals(c, null)) {
            let d = c.value;
            if (EnumUtil.isDefined(PredefinedShapeType_$type, enumGetBox(PredefinedShapeType_$type, d))) {
                return WorksheetShape._al(d, false);
            }
        }
        let e = new UnknownShape(1);
        e._eq(c, a.b);
        return e;
    }
    _visitCT_CustomGeometry2D$i(a, b) {
        let c = new UnknownShape(1);
        c._en = a;
        return c;
    }
}
ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator.$t = markType(ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator, 'ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator', Base.$, [IEG_GeometryVisitor$2_$type.specialize(Boolean_$type, WorksheetShape.$)]);
ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator.a = new ObjectModelDrawingPartManager_ShapeLoader_ShapeTypeCreator();
/**
 * @hidden
 */
export class IEG_ShapeFillVisitor extends Base {
    _visitImage$i(a, b) {
        let c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), b._bz(a._f));
        return ((() => {
            let $ret = new CT_BlipFillProperties();
            $ret.d = ((() => {
                let $ret = new CT_Blip();
                $ret.b = c.d;
                return $ret;
            })());
            return $ret;
        })());
    }
    _visitNoFill$i(a, b) {
        return new CT_NoFillProperties();
    }
    _visitSolid$i(a, b) {
        return ObjectModelDrawingPartManager.bm(a.colorInfo);
    }
}
IEG_ShapeFillVisitor.$t = markType(IEG_ShapeFillVisitor, 'IEG_ShapeFillVisitor', Base.$, [IShapeFillVisitor$2_$type.specialize(ObjectModelExcelDocumentManager.$, IEG_FillProperties_$type)]);
IEG_ShapeFillVisitor.a = new IEG_ShapeFillVisitor();
/**
 * @hidden
 */
export class CT_ShapeOutlineVisitor extends Base {
    static b(a, b) {
        if (a._e != null) {
            b.a = a._e;
        }
        if (a._f != null) {
            b.b = a._f;
        }
    }
    visitNoOutline(outline, argument) {
        return this._visitNoOutline$i.apply(this, arguments);
    }
    _visitNoOutline$i(a, b) {
        let c = new CT_LineProperties();
        c.i = new CT_NoFillProperties();
        CT_ShapeOutlineVisitor.b(a, c);
        return c;
    }
    visitSolid(outline, argument) {
        return this._visitSolid$i.apply(this, arguments);
    }
    _visitSolid$i(a, b) {
        let c = new CT_LineProperties();
        c.i = ObjectModelDrawingPartManager.bm(a.colorInfo);
        if (a._d != 0) {
            c.h = Nullable$1.toNullable(ST_LineWidth.$, new ST_LineWidth(1, ST_Coordinate32Unqualified.a(a._d)));
        }
        CT_ShapeOutlineVisitor.b(a, c);
        return c;
    }
}
CT_ShapeOutlineVisitor.$t = markType(CT_ShapeOutlineVisitor, 'CT_ShapeOutlineVisitor', Base.$, [IShapeOutlineVisitor$2_$type.specialize(ObjectModelExcelDocumentManager.$, CT_LineProperties.$)]);
CT_ShapeOutlineVisitor.a = new CT_ShapeOutlineVisitor();
/**
 * @hidden
 */
export class DefRprFontResolver extends Base {
    constructor(a, b) {
        super();
        this.a = null;
        this.d = null;
        this.b = null;
        this.d = a;
        this.a = b;
    }
    resolveDefaults(a) {
        if (a == null) {
            return;
        }
        if (this.b == null) {
            this.b = DefRprFontResolver.c(this.d, this.a);
        }
        if (nullableEquals(a._bold$i, null)) {
            a._bold$i = this.b._bold$i;
        }
        if (WorkbookColorInfo.l_op_Equality(a.colorInfo, null)) {
            a.colorInfo = this.b.colorInfo;
        }
        if (a.height < 0) {
            a.height = this.b.height;
        }
        if (nullableEquals(a._italic$i, null)) {
            a._italic$i = this.b._italic$i;
        }
        if (stringIsNullOrEmpty(a.name)) {
            a.name = this.b.name;
        }
        if (nullableEquals(a._strikeout$i, null)) {
            a._strikeout$i = this.b._strikeout$i;
        }
        if (a.superscriptSubscriptStyle == -1) {
            a.superscriptSubscriptStyle = this.b.superscriptSubscriptStyle;
        }
        if (a.underlineStyle == -1) {
            a.underlineStyle = this.b.underlineStyle;
        }
        UltimateFontDefaultsResolver.a.resolveDefaults(a);
    }
    static c(a, b) {
        if (a == null) {
            return null;
        }
        let c = new WorkbookFontData(0, b);
        c._bold$i = XlsxUtilities.a7(a.d);
        c._italic$i = XlsxUtilities.a7(a.i);
        c.underlineStyle = a.s.hasValue == false ? -1 : XlsxUtilities.h(a.s.value);
        if (a.q.hasValue == false) {
            c._strikeout$i = Nullable$1.toNullable(Boolean_$type, null);
        }
        else {
            c._strikeout$i = Nullable$1.toNullable(Boolean_$type, a.q.value == 0 ? false : true);
        }
        c.name = DMLChartUtils.a3(a);
        if (a.y != null) {
            c.colorInfo = XlsxUtilities.ab(a.y, b);
        }
        if (a.r.hasValue) {
            c.height = SerializationUtils.o(a.r.value);
        }
        return c;
    }
}
DefRprFontResolver.$t = markType(DefRprFontResolver, 'DefRprFontResolver', Base.$, [IWorkbookFontDefaultsResolver_$type]);
/**
 * @hidden
 */
export class ObjectModelExtendedPropertiesPartManager extends ExtendedPropertiesPartManager {
    constructor() {
        super();
        this.ay(OfficeDocumentExtendedProperties.aq, ObjectModelExtendedPropertiesPartManager.bh);
        this.ay(OfficeDocumentExtendedProperties.ap, ObjectModelExtendedPropertiesPartManager.bg);
        this.ay(OfficeDocumentExtendedProperties.at, ObjectModelExtendedPropertiesPartManager.bi);
        this.ay(OfficeDocumentExtendedProperties.au, ObjectModelExtendedPropertiesPartManager.bj);
        this.ay(OfficeDocumentExtendedProperties.av, ObjectModelExtendedPropertiesPartManager.bk);
        this.ay(OfficeDocumentExtendedProperties.ay, ObjectModelExtendedPropertiesPartManager.bl);
        this.ay(OfficeDocumentExtendedProperties.a0, ObjectModelExtendedPropertiesPartManager.bm);
        this.ay(OfficeDocumentExtendedProperties.a1, ObjectModelExtendedPropertiesPartManager.bn);
        this.ay(OfficeDocumentExtendedProperties.a9, ObjectModelExtendedPropertiesPartManager.bo);
        this.ay(OfficeDocumentExtendedProperties.ba, ObjectModelExtendedPropertiesPartManager.bp);
        this.ay(OfficeDocumentExtendedProperties.bb, ObjectModelExtendedPropertiesPartManager.bq);
        this.ay(OfficeDocumentExtendedProperties.be, ObjectModelExtendedPropertiesPartManager.br);
        OfficeDocumentDocPropsVTypes.cb(this);
        this.ax(OfficeDocumentDocPropsVTypes.ba, ObjectModelExtendedPropertiesPartManager.bs);
    }
    u(a) {
        let b = this.a6._by;
        OfficeDocumentExtendedProperties.cq(this);
        OfficeDocumentExtendedProperties.b8(this, "Microsoft Excel");
        this.ad.k();
        OfficeDocumentExtendedProperties.cd(this, 0);
        this.ad.k();
        OfficeDocumentExtendedProperties.cr(this, false);
        this.ad.k();
        let c = this.a6._b9._az;
        let d = 0;
        let e = 0;
        for (let f = 0; f < c.count; f++) {
            let g = c.item(f);
            if (g.type == 0) {
                d++;
            }
            else if (g.type == 1) {
                e++;
            }
        }
        let h = new List$1(Base.$, 0);
        if (d > 0) {
            h.add1("Worksheets");
            h.add1(d);
        }
        ;
        if (e > 0) {
            h.add1("Charts");
            h.add1(e);
        }
        ;
        if (b._namedReferences$i.count != 0) {
            h.add1("Named Ranges");
            h.add1(b._namedReferences$i.count);
        }
        let i = new CT_Vector(1, h, 0);
        OfficeDocumentExtendedProperties.ce(this);
        OfficeDocumentDocPropsVTypes.ce(this, i);
        this.ad.k();
        i = new CT_Vector(0, c.count, 11);
        for (let j = 0; j < i.a.length; j++) {
            i.a[j] = c.item(j).name;
        }
        OfficeDocumentExtendedProperties.cu(this);
        OfficeDocumentDocPropsVTypes.ce(this, i);
        this.ad.k();
        if (stringIsNullOrWhiteSpace(b.documentProperties.manager) == false) {
            OfficeDocumentExtendedProperties.ck(this, b.documentProperties.manager.trim());
            this.ad.k();
        }
        if (stringIsNullOrEmpty(b.documentProperties.company) == false) {
            OfficeDocumentExtendedProperties.cc(this, b.documentProperties.company);
            this.ad.k();
        }
        OfficeDocumentExtendedProperties.cj(this, false);
        this.ad.k();
        OfficeDocumentExtendedProperties.cs(this, false);
        this.ad.k();
        OfficeDocumentExtendedProperties.ch(this, false);
        this.ad.k();
        OfficeDocumentExtendedProperties.b9(this, "12.0000");
        this.ad.k();
        this.ad.k();
        return null;
    }
    static bh(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.bi(a, b);
        b = c.p1;
    }
    static bg(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.bh(a, b);
        b = c.p1;
    }
    static bi(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentExtendedProperties.bl(a, c);
        c = d.p1;
        b.company = c;
    }
    static bj(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.bm(a, b);
        b = c.p1;
    }
    static bk(a) {
    }
    static bl(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.bq(a, b);
        b = c.p1;
    }
    static bm(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.bs(a, b);
        b = c.p1;
    }
    static bn(a) {
        let b = a.s.a(DocumentProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentExtendedProperties.bt(a, c);
        c = d.p1;
        b.manager = c;
    }
    static bo(a) {
        let b = ObjectModelExtendedPropertiesPartManager.a7(a);
        a.s.k(b._by.documentProperties);
    }
    static bp(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.b0(a, b);
        b = c.p1;
    }
    static bq(a) {
        let b;
        let c = OfficeDocumentExtendedProperties.b1(a, b);
        b = c.p1;
    }
    static br(a) {
    }
    static bs(a) {
        let b = a.s.a(CT_Vector.$);
        if (b == null) {
            return;
        }
    }
    get a6() {
        return ObjectModelExtendedPropertiesPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelExtendedPropertiesPartManager.$t = markType(ObjectModelExtendedPropertiesPartManager, 'ObjectModelExtendedPropertiesPartManager', ExtendedPropertiesPartManager.$);
ObjectModelExtendedPropertiesPartManager.a8 = new ObjectModelExtendedPropertiesPartManager();
/**
 * @hidden
 */
export class ObjectModelExternalLinkPartManager extends ExternalLinkPartManager {
    constructor() {
        super();
        this.a9 = 0;
        this.ay(SpreadsheetMLMain.d4, ObjectModelExternalLinkPartManager.ba);
        this.ay(SpreadsheetMLMain.f4, (a) => ObjectModelExternalLinkPartManager.bb(a));
        this.ay(SpreadsheetMLMain.f5, ObjectModelExternalLinkPartManager.bc);
        this.ay(SpreadsheetMLMain.f6, ObjectModelExternalLinkPartManager.bd);
        this.ay(SpreadsheetMLMain.hl, ObjectModelExternalLinkPartManager.be);
        this.ay(SpreadsheetMLMain.hm, ObjectModelExternalLinkPartManager.bf);
        this.ay(SpreadsheetMLMain.lo, (a) => ObjectModelExternalLinkPartManager.bg(a, false));
        this.ay(SpreadsheetML2009Main.b5, (a) => ObjectModelExternalLinkPartManager.bg(a, true));
        this.ay(SpreadsheetMLMain.lp, ObjectModelExternalLinkPartManager.bh);
        this.ay(SpreadsheetMLMain.lq, ObjectModelExternalLinkPartManager.bi);
        this.ay(SpreadsheetMLMain.n4, ObjectModelExternalLinkPartManager.bj);
        this.ay(SpreadsheetMLMain.op, ObjectModelExternalLinkPartManager.bk);
        this.ay(SpreadsheetMLMain.oq, ObjectModelExternalLinkPartManager.bl);
        this.ay(SpreadsheetMLMain.ot, ObjectModelExternalLinkPartManager.bm);
        this.ay(SpreadsheetMLMain.ou, ObjectModelExternalLinkPartManager.bn);
        this.ay(SpreadsheetMLMain.r3, ObjectModelExternalLinkPartManager.bo);
        ObjectModelCommonPartHelpers.aj(this);
    }
    u(a) {
        SpreadsheetMLMain.abd(this);
        let b = typeCast(ExternalWorkbookReference.$, a);
        if (b != null) {
            this.bq(b);
        }
        else {
            let c = typeCast(OleLinkWorkbookReference.$, a);
            if (c != null) {
                this.br(c);
            }
            else {
                let d = typeCast(DdeLinkWorkbookReference.$, a);
                if (d != null) {
                    this.bp(d);
                }
                else {
                }
            }
        }
        this.ad.k();
        return null;
    }
    static ba(a) {
        let b = a.s.a(WorksheetReferenceExternalRowValues.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = SpreadsheetMLMain.tz(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = a;
        let h;
        if (((() => { let i = ExcelUtils.bm(c, 2, CultureInfo.invariantCulture, g.a9, h); g.a9 = i.p3; h = i.p4; return i.ret; })()) == false) {
        }
        a.s.k(enumGetBox(ST_CellType_$type, d));
    }
    static bb(a) {
        let b = a.s.a(DdeLinkWorkbookReference.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.u8(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        b.ag.add(new DdeItem(c, d, e, f));
    }
    static bc(a) {
    }
    static bd(a) {
        let b;
        let c;
        let d = SpreadsheetMLMain.va(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ObjectModelExternalLinkPartManager.a7(a);
        let f = e._by._bc(b, c);
        e._b7._i.add(f);
        a.an = f;
        a.s.k(f);
    }
    static be(a) {
        let b;
        let c = SpreadsheetMLMain.vr(a, b);
        b = c.p1;
        let d = ObjectModelExternalLinkPartManager.a7(a);
        let e = typeCast(Uri.$, d._au(b));
        if (e == null) {
            return;
        }
        let f = ExcelUtils.ez(e).toString();
        f = ExcelUtils.ek(f);
        let g = d._by._bf(f);
        d._b7._i.add(g);
        let h = typeCast(ExternalWorkbookReference.$, g);
        if (h == null) {
            return;
        }
        a.an = h;
        a.s.k(h);
    }
    static bf(a) {
    }
    static bj(a) {
        let b = a.s.a(WorksheetReferenceExternal.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.xm(a, c);
        c = d.p1;
        a.s.k(b.t(c));
    }
    static bg(a, b) {
        let c = a.s.a(OleLinkWorkbookReference.$);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        if (b) {
            let h = SpreadsheetML2009Main.c3(a, d, e, f, g);
            d = h.p1;
            e = h.p2;
            f = h.p3;
            g = h.p4;
        }
        else {
            let i = SpreadsheetMLMain.wy(a, d, e, f, g);
            d = i.p1;
            e = i.p2;
            f = i.p3;
            g = i.p4;
        }
        c.ag.add(new OleItem(d, e, f, g));
    }
    static bh(a) {
    }
    static bi(a) {
        let b;
        let c;
        let d = SpreadsheetMLMain.w0(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ObjectModelExternalLinkPartManager.a7(a);
        let f = typeCast(Uri.$, e._au(b));
        if (f == null) {
            return;
        }
        let g = e._by._bd(c, ExcelUtils.ez(f));
        e._b7._i.add(g);
        a.an = g;
        a.s.k(g);
    }
    static bk(a) {
        let b = a.s.a(ExternalWorkbookReference.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = SpreadsheetMLMain.xt(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = b.i(c);
        a.s.k(f);
    }
    static bl(a) {
    }
    static bm(a) {
        let b = a.s.a(ExternalWorkbookReference.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetMLMain.xx(a, c);
        c = d.p1;
        b.ag.add(c);
    }
    static bn(a) {
    }
    static bo(a) {
        let b = a.s.a(WorksheetReferenceExternalRowValues.$);
        if (b == null) {
            return;
        }
        let c = a;
        let d = ObjectModelCommonPartHelpers.d(a, c.a9);
        b.i(c.a9, d);
    }
    bp(a) {
        let b = this.a6;
        let c = b._b9;
        let d = c._b;
        SpreadsheetMLMain.aav(this, a.ak, a.al);
        SpreadsheetMLMain.aau(this);
        for (let e of fromEnum(a.ag)) {
            SpreadsheetMLMain.aat(this, e.d, e.b, e.a, e.c);
            this.ad.k();
        }
        this.ad.k();
        this.ad.k();
    }
    bq(a) {
        let b = this.a6;
        let c = b._b9;
        let d = c._b;
        let e = a.x;
        let f = ExcelUtils.d9(e);
        let g = stringStartsWith(f, "file://");
        let h;
        if (g) {
            h = new Uri(1, f, 1);
        }
        else if (c._l != null) {
            if (IOPath.isPathRooted(e) == false || IOPath.getPathRoot(e) == IOPath.getPathRoot(c._l)) {
                let i = PackageUtilities.q(c._l, a.x, ExcelUtils.b2, true);
                if (stringStartsWith(i, "//")) {
                    i = i.substr(1);
                }
                h = UriUtilities.b(ExcelUtils.d9(i));
            }
            else if (stringStartsWith(f, "/")) {
                h = UriUtilities.b(f);
            }
            else {
                if (g == false) {
                    f = stringInsert(f, 0, "file:///");
                }
                h = new Uri(1, f, 1);
            }
        }
        else {
            if (IOPath.isPathRooted(f)) {
                let j = f;
                if (g == false) {
                    f = stringInsert(f, 0, "file:///");
                }
                try {
                    h = new Uri(1, f, 1);
                }
                catch (k) {
                    let l = IOPath.getPathRoot(j);
                    if (l != null && l != j) {
                        f = j.substr(l.length);
                    }
                    h = UriUtilities.b(f);
                }
            }
            else {
                h = UriUtilities.b(f);
            }
        }
        let m = b._az(h, b._bq());
        SpreadsheetMLMain.abc(this, m);
        if (a.ag.count > 0) {
            SpreadsheetMLMain.adk(this);
            for (let n of fromEnum(a.ag)) {
                SpreadsheetMLMain.adj(this, n);
                this.ad.k();
            }
            this.ad.k();
        }
        if (a.u.count > 0) {
            ObjectModelCommonPartHelpers.aq(this, a);
        }
        if (a.ag.count > 0) {
            SpreadsheetMLMain.adg(this);
            for (let o = 0; o < a.ag.count; o++) {
                let p = typeCast(WorksheetReferenceExternal.$, a.i(o));
                if (p == null) {
                    continue;
                }
                SpreadsheetMLMain.adf(this, intSToU(o));
                for (let q of fromEnum(p.x)) {
                    SpreadsheetMLMain.ac8(this, intSToU((q.g + 1)));
                    for (let r of fromEnum(q.e)) {
                        let s;
                        let t;
                        let u = WorkbookSaveManagerExcel2007._cy(r.value, s, t);
                        s = u.p1;
                        t = u.p2;
                        SpreadsheetMLMain.zk(this, CellAddress.u(q.g, r.key, d.currentFormat), s);
                        SpreadsheetMLMain.aeh(this, t);
                        this.ad.k();
                        this.ad.k();
                    }
                    this.ad.k();
                }
                this.ad.k();
            }
            this.ad.k();
        }
        this.ad.k();
    }
    br(a) {
        let b = this.a6;
        let c = b._b9;
        let d = c._b;
        let e = b._az(a.ak, b._br());
        SpreadsheetMLMain.acm(this, e, a.ai);
        SpreadsheetMLMain.acl(this);
        for (let f of fromEnum(a.ag)) {
            SpreadsheetMLMain.ack(this, f.d, f.b, f.a, f.c);
            this.ad.k();
        }
        this.ad.k();
        this.ad.k();
    }
    get a6() {
        return ObjectModelExternalLinkPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelExternalLinkPartManager.$t = markType(ObjectModelExternalLinkPartManager, 'ObjectModelExternalLinkPartManager', ExternalLinkPartManager.$);
ObjectModelExternalLinkPartManager.a8 = new ObjectModelExternalLinkPartManager();
/**
 * @hidden
 */
export class ObjectModelWorkbookPartManagerBase extends WorkbookPartManagerBase {
    constructor() {
        super();
        this.bg = null;
        this.ay(SpreadsheetMLMain.dj, ObjectModelWorkbookPartManagerBase.bh);
        this.ay(SpreadsheetMLMain.d0, ObjectModelWorkbookPartManagerBase.bi);
        this.ay(SpreadsheetMLMain.fs, ObjectModelWorkbookPartManagerBase.bj);
        this.ay(SpreadsheetMLMain.ft, ObjectModelWorkbookPartManagerBase.bk);
        this.ay(SpreadsheetMLMain.hj, ObjectModelWorkbookPartManagerBase.bl);
        this.ay(SpreadsheetMLMain.hn, ObjectModelWorkbookPartManagerBase.bm);
        this.ay(SpreadsheetMLMain.ho, ObjectModelWorkbookPartManagerBase.bn);
        this.ay(SpreadsheetMLMain.hp, ObjectModelWorkbookPartManagerBase.bo);
        this.ay(SpreadsheetMLMain.ht, ObjectModelWorkbookPartManagerBase.bp);
        this.ay(SpreadsheetMLMain.mk, ObjectModelWorkbookPartManagerBase.bq);
        this.ay(SpreadsheetMLMain.ml, ObjectModelWorkbookPartManagerBase.bs);
        this.ay(SpreadsheetMLMain.om, ObjectModelWorkbookPartManagerBase.bt);
        this.ay(SpreadsheetMLMain.ox, ObjectModelWorkbookPartManagerBase.bu);
        this.ay(SpreadsheetMLMain.sj, ObjectModelWorkbookPartManagerBase.bx);
        this.ay(SpreadsheetMLMain.so, ObjectModelWorkbookPartManagerBase.by);
        this.ay(SpreadsheetMLMain.sp, ObjectModelWorkbookPartManagerBase.bz);
        this.ay(SpreadsheetMLMain.ss, ObjectModelWorkbookPartManagerBase.b0);
        this.ay(SpreadsheetML2009Main.cg, ObjectModelWorkbookPartManagerBase.bv);
        this.ay(SpreadsheetML2009Main.ch, ObjectModelWorkbookPartManagerBase.bw);
        this.ay(SpreadsheetML2009Main.b7, ObjectModelWorkbookPartManagerBase.br);
        ObjectModelCommonPartHelpers.aj(this);
    }
    j() {
        return ((() => {
            let $ret = new Dictionary$2(PartManagerBase.$, Number_$type, 0);
            $ret.addItem(ObjectModelThemePartManager.bb, 0);
            $ret.addItem(ObjectModelStylesPartManager.a8, 1);
            $ret.addItem(ObjectModelSharedStringsPartManager.a8, 2);
            return $ret;
        })());
    }
    t() {
        let a = super.t();
        return WorkItemExtensions.g(Base.$, a, () => {
            this.be._b7._z();
            return WorkItemExtensions.m(Base.$, a);
        });
    }
    u(a) {
        let b = this.be;
        let c = this.be._b9;
        let d = c._b;
        this.bg = new Dictionary$2(RoundTripControlData.$, String_$type, 0);
        return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.i(Tuple$2.$.specialize(Uri.$, String_$type), WorkItemExtensions.i(Tuple$2.$.specialize(Uri.$, String_$type), WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(Async.g(d._m != null, () => b._j(ObjectModelConnectionsPartManager.a8)), () => Async.d(PivotCacheInfo.$, d._d8(), (e) => WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this.be._j(ObjectModelPivotCacheDefinitionPartManager.a8, e.a), (f) => this.bg.addItem(e.a, WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), f).d)))), () => Async.d(PivotCacheInfo.$, d._d9(), (e) => WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this.be._j(ObjectModelPivotCacheDefinitionPartManager.a8, e.a), (f) => this.bg.addItem(e.a, WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), f).d)))), () => Async.d(Sheet.$, c._az, (e) => {
            if (e.type == 0) {
                return b._j(ObjectModelWorksheetPartManager.bi, e);
            }
            else if (e.type == 1) {
                return b._j(ObjectModelChartsheetPartManager.ba, e);
            }
            else {
                return null;
            }
        })), () => b._j(ObjectModelStylesPartManager.a8)), () => b._j(ObjectModelThemePartManager.bb)), () => Async.g(c._a1 != 0, () => b._j(ObjectModelSharedStringsPartManager.a8))), () => Async.d(WorkbookReferenceBase.$, c._ci.keys, (e) => {
            if (typeCast(CurrentWorkbookReference.$, e) !== null) {
                return null;
            }
            return b._j(ObjectModelExternalLinkPartManager.a8, e);
        })), () => Async.g(d._k != null, () => b._j(ObjectModelVbaProjectPartManager.x))), () => this.bd(c));
    }
    i(a) {
        if (typeCast(ObjectModelWorksheetPartManager.$, a) !== null || typeCast(ObjectModelChartsheetPartManager.$, a) !== null) {
            return true;
        }
        return super.i(a);
    }
    ai(a) {
        switch (a) {
            case SpreadsheetMLMain.hj:
                {
                    let b;
                    let c = SpreadsheetMLMain.vp(this, b);
                    b = c.p1;
                    switch (b) {
                        case "{BBE1A952-AA13-448e-AADC-164F8A28A991}":
                        case "{876F7934-8845-4945-9796-88D515C7AA90}": return true;
                        default: return false;
                    }
                }
        }
        return super.ai(a);
    }
    static bh(a) {
    }
    static bi(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p = SpreadsheetMLMain.tw(a, c, d, e, f, g, h, i, j, k, l, m, n, o);
        c = p.p1;
        d = p.p2;
        e = p.p3;
        f = p.p4;
        g = p.p5;
        h = p.p6;
        i = p.p7;
        j = p.p8;
        k = p.p9;
        l = p.p10;
        m = p.p11;
        n = p.p12;
        o = p.p13;
        b.calculationMode = XlsxUtilities.a(d);
        b.cellReferenceMode = XlsxUtilities.c(f);
        b.iterativeCalculationsEnabled = g;
        b.maxRecursionIterations = h;
        b.maxChangeInIteration = i;
        b.precision = j ? 1 : 0;
        b.recalculateBeforeSave = l;
    }
    static bj(a) {
        let b = a.s.a(CustomViewCollection.$);
        if (b == null) {
            return;
        }
        let c;
        let d = new ST_Guid();
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x;
        let y;
        let z;
        let aa = SpreadsheetMLMain.u1(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);
        c = aa.p1;
        d = aa.p2;
        e = aa.p3;
        f = aa.p4;
        g = aa.p5;
        h = aa.p6;
        i = aa.p7;
        j = aa.p8;
        k = aa.p9;
        l = aa.p10;
        m = aa.p11;
        n = aa.p12;
        o = aa.p13;
        p = aa.p14;
        q = aa.p15;
        r = aa.p16;
        s = aa.p17;
        t = aa.p18;
        u = aa.p19;
        v = aa.p20;
        w = aa.p21;
        x = aa.p22;
        y = aa.p23;
        z = aa.p24;
        let ab = b._item(ST_Guid.e(d));
        if (ab == null) {
            ab = new CustomView(b._e, true, true);
            ab._t = ST_Guid.e(d);
            b._add1(ab);
        }
        let ac = ab.windowOptions;
        ab.name = c;
        ab._ab(m);
        ab._aa(n);
        ac.maximized = o;
        ac.scrollBars = 0;
        if (q) {
            ac.scrollBars |= 1;
        }
        if (r) {
            ac.scrollBars |= 2;
        }
        ac.tabBarVisible = s;
        ac._boundsInPixels$i = ExcelUtils.g9(t, u, f, g);
        ac.tabBarWidth = v;
        ac._ao = e;
        ac.showFormulaBar = w;
        ac.showStatusBar = x;
        ac.objectDisplayStyle = XlsxUtilities.m(z);
    }
    static bk(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        a.s.k(b._customViews$i);
    }
    static bl(a) {
        let b;
        let c = SpreadsheetMLMain.vp(a, b);
        b = c.p1;
    }
    static bm(a) {
        let b;
        let c = SpreadsheetMLMain.vt(a, b);
        b = c.p1;
        let d = ObjectModelWorkbookPartManagerBase.bf(a);
        let e = typeCast(WorkbookReferenceBase.$, d._au(b));
        d._b7._bi.add(e);
    }
    static bn(a) {
    }
    static bo(a) {
    }
    static bp(a) {
    }
    static bq(a) {
        let b = a.ab.r(SpreadsheetML2009Main.b7);
        let c = a.s.a(Workbook.$);
        if (c == null) {
            return;
        }
        let d;
        let e;
        let f = SpreadsheetMLMain.w9(a, d, e);
        d = f.p1;
        e = f.p2;
        let g = ObjectModelWorkbookPartManagerBase.bf(a);
        let h = typeCast(RoundTripControlData.$, g._au(e));
        if (h != null) {
            let i = new PivotCacheInfo(h, d);
            if (b) {
                c._hc(i);
            }
            else {
                c._hb(i);
            }
        }
    }
    static bs(a) {
    }
    static br(a) {
    }
    static bt(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = SpreadsheetMLMain.xv(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        if (stringIsNullOrEmpty(f)) {
            return;
        }
        let h = a.d._g(f);
        let i;
        if (h.relationshipType == ObjectModelWorksheetPartManager.a5 || h.relationshipType == ObjectModelWorksheetPartManager.a4) {
            i = 0;
        }
        else if (h.relationshipType == ObjectModelChartsheetPartManager.a5 || h.relationshipType == ObjectModelChartsheetPartManager.a4) {
            i = 1;
        }
        else {
            i = 0;
        }
        let j = b._sheets$i._add2(c, d, i);
        if (j.type == 0) {
            j._ek = false;
        }
        j._e.visibility = XlsxUtilities.ae(e);
        let k = PackageUtilities.ak(h).originalString;
        ObjectModelWorkbookPartManagerBase.bf(a)._b7._bo(j, k);
    }
    static bu(a) {
    }
    static bv(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c;
        let d = SpreadsheetML2009Main.c5(a, c);
        c = d.p1;
        let e = ObjectModelWorkbookPartManagerBase.bf(a);
        let f = typeCast(BinaryData.$, e._au(c));
        if (f != null) {
            b._hd(f);
        }
    }
    static bw(a) {
    }
    static bx(a) {
        let b;
        let c = SpreadsheetMLMain.yx(a, b);
        b = c.p1;
        a.s.k(ObjectModelWorkbookPartManagerBase.bf(a)._by);
    }
    static by(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v = SpreadsheetMLMain.yy(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        b.dateSystem = c ? 1 : 0;
        b.windowOptions.objectDisplayStyle = XlsxUtilities.m(d);
        b._g0 = l;
        b.saveExternalLinkedValues = j;
        b._gk = t;
    }
    static bz(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = null;
        if (Enumerable.d(AttributeValue.$, a.ab.u, (g) => g.a.e(a.d) == "workbookPassword")) {
            let g;
            let h;
            let i = SpreadsheetMLMain.yz(a, c, d, e, g, h);
            c = i.p1;
            d = i.p2;
            e = i.p3;
            g = i.p4;
            h = i.p5;
            if (g.hasValue) {
                f = ProtectionValidationInfo.c(g.value);
            }
        }
        else {
            let j;
            let k;
            let l;
            let m;
            let n;
            let o;
            let p;
            let q;
            let r = SpreadsheetMLMain.y0(a, c, d, e, j, k, l, m, n, o, p, q);
            c = r.p1;
            d = r.p2;
            e = r.p3;
            j = r.p4;
            k = r.p5;
            l = r.p6;
            m = r.p7;
            n = r.p8;
            o = r.p9;
            p = r.p10;
            q = r.p11;
            if (o != null && p != null && nullableNotEquals(q, null)) {
                f = ProtectionValidationInfo.b(n, Convert.fromBase64String(o), Convert.fromBase64String(p), q.value);
            }
        }
        b.protection.allowEditStructure = c == false;
        b.protection.allowEditWindows = d == false;
        b.protection._b.b = f;
        b.protection._b.j(c || d);
    }
    static b0(a) {
        let b = a.s.a(Workbook.$);
        if (b == null) {
            return;
        }
        let c = b.windowOptions;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q = SpreadsheetMLMain.y1(a, d, e, f, g, h, i, j, k, l, m, n, o, p);
        d = q.p1;
        e = q.p2;
        f = q.p3;
        g = q.p4;
        h = q.p5;
        i = q.p6;
        j = q.p7;
        k = q.p8;
        l = q.p9;
        m = q.p10;
        n = q.p11;
        o = q.p12;
        p = q.p13;
        c.minimized = e;
        c.scrollBars = 0;
        if (f) {
            c.scrollBars |= 1;
        }
        if (g) {
            c.scrollBars |= 2;
        }
        c.tabBarVisible = h;
        c._boundsInTwips$i = ExcelUtils.g9(i.getValueOrDefault(), j.getValueOrDefault(), k.getValueOrDefault(), l.getValueOrDefault());
        c.tabBarWidth = m;
        c.firstVisibleTabIndex = n;
        c._as = o;
    }
    b1(a) {
        let b = a.windowOptions;
        let c = b._boundsInPixels$i;
        SpreadsheetMLMain.aam(this, a.name, ST_Guid.a(a._t), b.selectedSheet == null ? 0 : b.selectedSheet._am, truncate(c.width), truncate(c.height), void 0, Nullable$1.toNullable(Number_$type, null), void 0, void 0, void 0, a.savePrintOptions, a.saveHiddenRowsAndColumns, b.maximized, void 0, EnumUtil.enumHasFlag(b.scrollBars, 1), EnumUtil.enumHasFlag(b.scrollBars, 2), b.tabBarVisible, truncate(c.x), truncate(c.y), intSToU(b.tabBarWidth), b.showFormulaBar, b.showStatusBar, void 0, XlsxUtilities.au(b.objectDisplayStyle));
        this.ad.k();
    }
    a9(a) {
        if (a._cz == false) {
            return null;
        }
        SpreadsheetMLMain.aba(this, "{876F7934-8845-4945-9796-88D515C7AA90}");
        this.ad.l(SpreadsheetML2009Main.an);
        SpreadsheetML2009Main.dm(this);
        return WorkItemExtensions.a(Async.d(PivotCacheInfo.$, a._d9(), (b) => {
            this.b3(b);
            return null;
        }), () => {
            this.ad.k();
            this.ad.k();
        });
    }
    ba(a) {
        if (a._c1 == false) {
            return null;
        }
        SpreadsheetMLMain.aba(this, "{BBE1A952-AA13-448e-AADC-164F8A28A991}");
        this.ad.l(SpreadsheetML2009Main.an);
        SpreadsheetML2009Main.dp(this);
        return WorkItemExtensions.a(Async.d(BinaryData.$, a._ea(), runOn(this, this.bc)), () => {
            this.ad.k();
            this.ad.k();
        });
    }
    bb(a) {
        let b = a._c1 || a._cz;
        if (b == false) {
            return null;
        }
        SpreadsheetMLMain.abg(this);
        return WorkItemExtensions.a(WorkItemExtensions.c(this.a9(a), () => this.ba(a)), () => this.ad.k());
    }
    b2(a) {
    }
    b3(a) {
        let b = this.bg.item(a.a);
        SpreadsheetMLMain.acv(this, a.b, b);
        this.ad.k();
    }
    b4(a) {
        if (a._cy == false) {
            return;
        }
        SpreadsheetMLMain.acw(this);
        ExcelUtils.fm(PivotCacheInfo.$, a._d8(), runOn(this, this.b3));
        this.ad.k();
    }
    b5(a) {
        let b = this.d._f(a).id;
        SpreadsheetMLMain.adh(this, a.name, a._am, XlsxUtilities.a1(a._e.visibility), b);
        this.ad.k();
    }
    bc(a) {
        return WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), this.be._j(ObjectModelSlicerCachePartManager.a7, a), (b) => {
            let c = WorkItemExtensions.m(Tuple$2.$.specialize(Uri.$, String_$type), b).d;
            SpreadsheetML2009Main.dn(this, c);
            this.ad.k();
        });
    }
    bd(a) {
        let b = a._b;
        let c = b.windowOptions;
        let d = c._boundsInTwips$i;
        SpreadsheetMLMain.ael(this, a._b9._z);
        SpreadsheetMLMain.abm(this, "xl", "5", "5", "9303");
        this.ad.k();
        this.b2(b);
        SpreadsheetMLMain.aem(this, b.dateSystem == 1, XlsxUtilities.au(c.objectDisplayStyle), void 0, void 0, void 0, void 0, void 0, b.saveExternalLinkedValues, void 0, b._k != null ? b._g0 : null, void 0, void 0, void 0, void 0, void 0, void 0, void 0, b._gk);
        this.ad.k();
        this.b6(b);
        SpreadsheetMLMain.zc(this);
        let e = a._az.indexOf(c.selectedSheet);
        let f = Math.min(c.firstVisibleTabIndex, a._az.count - 1);
        SpreadsheetMLMain.aep(this, void 0, c.minimized, EnumUtil.enumHasFlag(c.scrollBars, 1), EnumUtil.enumHasFlag(c.scrollBars, 2), c.tabBarVisible, d.x == 0 ? Nullable$1.toNullable(Number_$type, null) : Nullable$1.toNullable(Number_$type, truncate(d.x)), d.y == 0 ? Nullable$1.toNullable(Number_$type, null) : Nullable$1.toNullable(Number_$type, truncate(d.y)), d.width == 0 ? Nullable$1.toNullable(Number_$type, null) : Nullable$1.toNullable(Number_$type, truncate(d.width)), d.height == 0 ? Nullable$1.toNullable(Number_$type, null) : Nullable$1.toNullable(Number_$type, truncate(d.height)), intSToU(c.tabBarWidth), intSToU(f), intSToU(e));
        this.ad.k();
        this.ad.k();
        SpreadsheetMLMain.ado(this);
        ExcelUtils.fm(Sheet.$, a._az, runOn(this, this.b5));
        this.ad.k();
        let g = ObjectModelExternalLinkPartManager.a8.o(a._b9._z);
        let h = new List$1(IPackageRelationship_$type, 1, Enumerable.u(IPackageRelationship_$type, a._b9._d.getRelationships(), (i) => i.relationshipType == g));
        if (h.count != 0) {
            SpreadsheetMLMain.abf(this);
            for (let i of fromEnum(h)) {
                SpreadsheetMLMain.abe(this, i.id);
                this.ad.k();
            }
            this.ad.k();
        }
        ObjectModelCommonPartHelpers.aq(this, b._bb);
        SpreadsheetMLMain.zh(this, Nullable$1.toNullable(Number_$type, 162913), XlsxUtilities.an(b.calculationMode), void 0, XlsxUtilities.a0(b.cellReferenceMode), b.iterativeCalculationsEnabled, intSToU(b.maxRecursionIterations), b.maxChangeInIteration, b.precision == 1, void 0, b.recalculateBeforeSave);
        this.ad.k();
        if (b._cq) {
            SpreadsheetMLMain.aan(this);
            ExcelUtils.fm(CustomView.$, b._customViews$i, runOn(this, this.b1));
            this.ad.k();
        }
        this.b4(b);
        return WorkItemExtensions.a(this.bb(b), () => this.ad.k());
    }
    b6(a) {
        if (a.isProtected == false) {
            return;
        }
        let b = a.protection;
        if (this.d._z == 0) {
            SpreadsheetMLMain.aen(this, b.allowEditStructure == false, b.allowEditWindows == false, void 0, b._b.h());
        }
        else {
            let c;
            let d, e;
            let f;
            let g = b._b.e(c, d, e, f);
            c = g.p0;
            d = g.p1;
            e = g.p2;
            f = g.p3;
            SpreadsheetMLMain.aeo(this, b.allowEditStructure == false, b.allowEditWindows == false, void 0, void 0, void 0, void 0, Nullable$1.toNullable(Number_$type, null), c, d != null ? Convert.toBase64String(d) : null, e != null ? Convert.toBase64String(e) : null, f);
        }
        this.ad.k();
    }
    get be() {
        return ObjectModelWorkbookPartManagerBase.bf(this);
    }
    static bf(a) {
        return a.d;
    }
}
ObjectModelWorkbookPartManagerBase.$t = markType(ObjectModelWorkbookPartManagerBase, 'ObjectModelWorkbookPartManagerBase', WorkbookPartManagerBase.$);
/**
 * @hidden
 */
export class ObjectModelMacroEnabledTemplatePartManager extends ObjectModelWorkbookPartManagerBase {
    constructor() {
        super();
    }
    get_m() {
        return WorkbookPartManagerBase.a3;
    }
    get m() {
        return this.get_m();
    }
}
ObjectModelMacroEnabledTemplatePartManager.$t = markType(ObjectModelMacroEnabledTemplatePartManager, 'ObjectModelMacroEnabledTemplatePartManager', ObjectModelWorkbookPartManagerBase.$);
ObjectModelMacroEnabledTemplatePartManager.b7 = new ObjectModelMacroEnabledTemplatePartManager();
/**
 * @hidden
 */
export class ObjectModelMacroEnabledWorkbookPartManager extends ObjectModelWorkbookPartManagerBase {
    constructor() {
        super();
    }
    get_m() {
        return WorkbookPartManagerBase.a4;
    }
    get m() {
        return this.get_m();
    }
}
ObjectModelMacroEnabledWorkbookPartManager.$t = markType(ObjectModelMacroEnabledWorkbookPartManager, 'ObjectModelMacroEnabledWorkbookPartManager', ObjectModelWorkbookPartManagerBase.$);
ObjectModelMacroEnabledWorkbookPartManager.b7 = new ObjectModelMacroEnabledWorkbookPartManager();
/**
 * @hidden
 */
export class ObjectModelPivotCacheDefinitionPartManager extends PivotCacheDefinitionPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, RoundTripDataPartManager.r(this.a6, this.l, this.m));
    }
    b(a) {
        let b = typeCast(RoundTripControlData.$, a);
        if (b == null) {
            return null;
        }
        return RoundTripDataPartManager.s(b, this.a6, this.l);
    }
    u(a) {
        throw new NotImplementedException(0);
    }
    get a6() {
        return ObjectModelPivotCacheDefinitionPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelPivotCacheDefinitionPartManager.$t = markType(ObjectModelPivotCacheDefinitionPartManager, 'ObjectModelPivotCacheDefinitionPartManager', PivotCacheDefinitionPartManager.$);
ObjectModelPivotCacheDefinitionPartManager.a8 = new ObjectModelPivotCacheDefinitionPartManager();
/**
 * @hidden
 */
export class ObjectModelPivotCacheRecordsPartManager extends PivotCacheRecordsPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    u(a) {
        throw new NotImplementedException(0);
    }
    get a6() {
        return ObjectModelPivotCacheRecordsPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelPivotCacheRecordsPartManager.$t = markType(ObjectModelPivotCacheRecordsPartManager, 'ObjectModelPivotCacheRecordsPartManager', PivotCacheRecordsPartManager.$);
ObjectModelPivotCacheRecordsPartManager.a8 = new ObjectModelPivotCacheRecordsPartManager();
/**
 * @hidden
 */
export class ObjectModelPivotTablePartManager extends PivotTablePartManager {
    constructor() {
        super();
    }
    z(a) {
        return 2;
    }
    av(a) {
        this.an = a;
        this.bb(a);
        let b = this.ba();
        if (b == null) {
            return;
        }
        b._g6(new PivotTableInfo(a, this.a6()));
    }
    u(a) {
        let b = typeCast(PivotTableInfo.$, a);
        if (b == null) {
            return null;
        }
        this.ad.t(b.b);
        if (b.a != null) {
            let c = this.a7._bd(b.a);
            if (c != null) {
                this.a7._a0(c, ObjectModelPivotCacheDefinitionPartManager.a8);
            }
        }
        return null;
    }
    y(a, b) {
        switch (a.b.e(this.a7)) {
            case SpreadsheetMLMain.ij:
                {
                    let c = typeCast(WorksheetCellFormatData.$, a.n);
                    if (c != null) {
                        let d = this.a7._b9._ba(c);
                        for (let e = 0; e < a.j.count; e++) {
                            let f = a.j._inner[e];
                            if (f.a.f == "dxfId") {
                                a.j._inner[e] = new AttributeValue(2, f.a, d.toString());
                                break;
                            }
                        }
                    }
                }
                break;
            default: break;
        }
        return 0;
    }
    a6() {
        let a = this.d;
        let b = ObjectModelPivotCacheDefinitionPartManager.a8.o(a._z);
        let c = Enumerable.af(IPackageRelationship_$type, Enumerable.u(IPackageRelationship_$type, a._d.getRelationships(), (d) => d.targetMode == 0 && d.relationshipType == b));
        if (c == null) {
            return null;
        }
        return typeCast(RoundTripControlData.$, a._as(c));
    }
    ba() {
        let a = this.a7;
        let b = a._b7;
        if (a._an.f == 0) {
            return null;
        }
        let c = a._an.d().uri.toString();
        return b._ao(c);
    }
    bb(a) {
        let b = this.a7;
        let c = b._b7;
        if (a.b.b.e(b) != SpreadsheetMLMain.mm) {
            return;
        }
        let d = a.b.c(SpreadsheetMLMain.ip, b);
        if (d == null) {
            return;
        }
        for (let e of fromEnum(d.f(SpreadsheetMLMain.ij, b))) {
            let f;
            if (((() => { let g = WorkbookLoadManagerExcel2007._aw(e, b, f); f = g.p2; return g.ret; })())) {
                e.n = f;
            }
            else {
            }
        }
    }
    get a7() {
        return ObjectModelPivotTablePartManager.a8(this);
    }
    static a8(a) {
        return a.d;
    }
}
ObjectModelPivotTablePartManager.$t = markType(ObjectModelPivotTablePartManager, 'ObjectModelPivotTablePartManager', PivotTablePartManager.$);
ObjectModelPivotTablePartManager.a9 = new ObjectModelPivotTablePartManager();
/**
 * @hidden
 */
export class ObjectModelPrinterSettingsPartManager extends PrinterSettingsPartManager {
    constructor() {
        super();
    }
    get_m() {
        return PrinterSettingsPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
}
ObjectModelPrinterSettingsPartManager.$t = markType(ObjectModelPrinterSettingsPartManager, 'ObjectModelPrinterSettingsPartManager', PrinterSettingsPartManager.$);
ObjectModelPrinterSettingsPartManager.a7 = new ObjectModelPrinterSettingsPartManager();
/**
 * @hidden
 */
export class ObjectModelSharedStringsPartManager extends SharedStringsPartManager {
    constructor() {
        super();
        this.ay(SpreadsheetMLMain.pv, ObjectModelSharedStringsPartManager.a9);
        this.ax(SpreadsheetMLMain.pv, ObjectModelSharedStringsPartManager.ba);
        this.ay(SpreadsheetMLMain.p7, ObjectModelSharedStringsPartManager.bb);
        ObjectModelCommonPartHelpers.al(this);
    }
    u(a) {
        let b = this.a6._b9;
        SpreadsheetMLMain.adv(this, Nullable$1.toNullable(Number_$type, b._bc), Nullable$1.toNullable(Number_$type, intSToU(b._a1)));
        let c = b._b.shouldRemoveCarriageReturnsOnSave;
        let d = 0;
        return WorkItemExtensions.a(Async.e(StringElement.$, b._ax(), (e) => {
            this.bc(b, e, c);
            if (1000 < ++d) {
                d = 0;
                return false;
            }
            return true;
        }), () => this.ad.k());
    }
    static a9(a) {
        a.s.k(new FormattedStringElement(0));
    }
    static ba(a) {
        let b = a.s.a(FormattedStringElement.$);
        if (b == null) {
            return;
        }
        let c = b;
        if (b._u == false) {
            c = c._q();
        }
        ObjectModelSharedStringsPartManager.a7(a)._b7._u.add(c);
    }
    static bb(a) {
        let b;
        let c;
        let d = SpreadsheetMLMain.x8(a, b, c);
        b = d.p1;
        c = d.p2;
    }
    bc(a, b, c) {
        if (c) {
            b = b._s(a._b);
        }
        ObjectModelCommonPartHelpers.au(this, a, b, SpreadsheetMLMain.adr);
    }
    get a6() {
        return ObjectModelSharedStringsPartManager.a7(this);
    }
    static a7(a) {
        return a.d;
    }
}
ObjectModelSharedStringsPartManager.$t = markType(ObjectModelSharedStringsPartManager, 'ObjectModelSharedStringsPartManager', SharedStringsPartManager.$);
ObjectModelSharedStringsPartManager.a8 = new ObjectModelSharedStringsPartManager();
/**
 * @hidden
 */
export class ObjectModelSlicerCachePartManager extends SlicerCachePartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    u(a) {
        throw new NotImplementedException(0);
    }
    get a5() {
        return ObjectModelSlicerCachePartManager.a6(this);
    }
    static a6(a) {
        return a.d;
    }
}
ObjectModelSlicerCachePartManager.$t = markType(ObjectModelSlicerCachePartManager, 'ObjectModelSlicerCachePartManager', SlicerCachePartManager.$);
ObjectModelSlicerCachePartManager.a7 = new ObjectModelSlicerCachePartManager();
/**
 * @hidden
 */
export class ObjectModelSlicerPartManager extends SlicerPartManager {
    constructor() {
        super();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    u(a) {
        throw new NotImplementedException(0);
    }
    get a5() {
        return ObjectModelSlicerPartManager.a6(this);
    }
    static a6(a) {
        return a.d;
    }
}
ObjectModelSlicerPartManager.$t = markType(ObjectModelSlicerPartManager, 'ObjectModelSlicerPartManager', SlicerPartManager.$);
ObjectModelSlicerPartManager.a7 = new ObjectModelSlicerPartManager();
/**
 * @hidden
 */
export class ObjectModelTemplatePartManager extends ObjectModelWorkbookPartManagerBase {
    constructor() {
        super();
    }
    get_m() {
        return WorkbookPartManagerBase.a7;
    }
    get m() {
        return this.get_m();
    }
}
ObjectModelTemplatePartManager.$t = markType(ObjectModelTemplatePartManager, 'ObjectModelTemplatePartManager', ObjectModelWorkbookPartManagerBase.$);
ObjectModelTemplatePartManager.b7 = new ObjectModelTemplatePartManager();
/**
 * @hidden
 */
export class ObjectModelThemeManagerPartManager extends ThemeManagerPartManager {
    constructor() {
        super();
        this.ay(DrawingMLMain.ji, ObjectModelThemeManagerPartManager.a7);
    }
    av(a) {
        let b = Enumerable.ag(AttributeValue.$, a.b.j, (c) => c.a.e(this.d) == IGOfficeExtensions.ap);
        if (b.d == null || ST_OnOff.e(b.d) == false) {
            this.d._bj();
        }
    }
    u(a) {
        DrawingMLMain.p9(this);
        this.ad.k();
        let b = this.d;
        return b._j(ObjectModelThemePartManager.bc);
    }
    static a7(a) {
    }
}
ObjectModelThemeManagerPartManager.$t = markType(ObjectModelThemeManagerPartManager, 'ObjectModelThemeManagerPartManager', ThemeManagerPartManager.$);
ObjectModelThemeManagerPartManager.a6 = new ObjectModelThemeManagerPartManager();
/**
 * @hidden
 */
export class ObjectModelThemePartManager extends ThemePartManager {
    constructor(a) {
        super(a);
        this.ay(DrawingMLMain.aq, ObjectModelThemePartManager.bf);
        this.ay(DrawingMLMain.ar, ObjectModelThemePartManager.bg);
        this.ay(DrawingMLMain.as, ObjectModelThemePartManager.bh);
        this.ay(DrawingMLMain.at, ObjectModelThemePartManager.bi);
        this.ay(DrawingMLMain.au, ObjectModelThemePartManager.bj);
        this.ay(DrawingMLMain.av, ObjectModelThemePartManager.bk);
        this.ay(DrawingMLMain.cm, ObjectModelThemePartManager.bl);
        this.ay(DrawingMLMain.c9, ObjectModelThemePartManager.bm);
        this.ay(DrawingMLMain.da, ObjectModelThemePartManager.bn);
        this.ay(DrawingMLMain.d8, ObjectModelThemePartManager.bo);
        this.ay(DrawingMLMain.d9, ObjectModelThemePartManager.bp);
        this.ay(DrawingMLMain.ec, ObjectModelThemePartManager.bq);
        this.ay(DrawingMLMain.e1, ObjectModelThemePartManager.br);
        this.ay(DrawingMLMain.fq, ObjectModelThemePartManager.bs);
        this.ay(DrawingMLMain.f2, ObjectModelThemePartManager.bt);
        this.ay(DrawingMLMain.f3, ObjectModelThemePartManager.bu);
        this.ay(DrawingMLMain.gh, ObjectModelThemePartManager.bv);
        this.ay(DrawingMLMain.gk, ObjectModelThemePartManager.bw);
        this.ay(DrawingMLMain.i0, ObjectModelThemePartManager.bx);
        this.ay(DrawingMLMain.i8, ObjectModelThemePartManager.by);
        this.ay(DrawingMLMain.jg, ObjectModelThemePartManager.bz);
        this.ay(DrawingMLMain.jh, ObjectModelThemePartManager.b0);
        FormatSchemeDeserializer.cp(this);
    }
    a0() {
        if (this.l.canSeek) {
            let a = this.l.position;
            let b = DocCoreUtils.c(this.l);
            this.l.position = a;
            this.a9._by._i = b;
            this.a9._by._du = this.a9._z;
        }
        return super.a0();
    }
    static bd() {
        return new MemoryStream(2, Convert.fromBase64String(ObjectModelThemePartManager.be));
    }
    b(a) {
        let b = this.a9._by;
        if (b._i != null) {
            {
                let c = new MemoryStream(2, b._i);
                try {
                    this.b1(c, b._du);
                }
                finally {
                    if (c != null) {
                        c.dispose();
                    }
                }
            }
        }
        else {
            {
                let d = ObjectModelThemePartManager.bd();
                try {
                    this.b1(d, 0);
                }
                finally {
                    if (d != null) {
                        d.dispose();
                    }
                }
            }
        }
        return null;
    }
    b1(a, b) {
        if (this.d._z != b) {
            {
                let c = new StreamReader(a);
                try {
                    let d = c.h();
                    d = stringReplace(d, DrawingMLMain.an.i(b), DrawingMLMain.an.i(this.d._z));
                    let e = Encoding.uTF8.getBytes1(d);
                    this.l.write(e, 0, e.length);
                }
                finally {
                    if (c != null) {
                        c.dispose();
                    }
                }
            }
        }
        else {
            let f;
            let g = new Array(1024);
            while ((f = a.read(g, 0, 1024)) != 0) {
                this.l.write(g, 0, f);
            }
            this.l.flush();
        }
    }
    u(a) {
        return null;
    }
    static bf(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 4));
    }
    static bg(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 5));
    }
    static bh(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 6));
    }
    static bi(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 7));
    }
    static bj(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 8));
    }
    static bk(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 9));
    }
    static bl(a) {
        let b;
        let c = DrawingMLMain.ks(a, b);
        b = c.p1;
    }
    static bm(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 1));
    }
    static bn(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 3));
    }
    static bo(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 11));
    }
    static bp(a) {
        let b = a.s.a(WorkbookLoadManagerExcel2007_FontCollection.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = DrawingMLMain.lm(a, c, d);
        c = e.p1;
        d = e.p2;
        if (c == null || d == null) {
            return;
        }
        b.f(c, d);
    }
    static bq(a) {
        let b;
        let c = DrawingMLMain.lo(a, b);
        b = c.p1;
    }
    static br(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 10));
    }
    static bs(a) {
        let b = a.s.a(WorkbookLoadManagerExcel2007_FontCollection.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = DrawingMLMain.l5(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        b.d = c;
    }
    static bt(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 0));
    }
    static bu(a) {
        a.s.k(enumGetBox(WorkbookThemeColorType_$type, 2));
    }
    static bv(a) {
        a.s.k(ObjectModelThemePartManager.ba(a)._bv);
    }
    static bw(a) {
        a.s.k(ObjectModelThemePartManager.ba(a)._bw);
    }
    static bx(a) {
        if (FormatSchemeDeserializer.e(a)) {
            return;
        }
        let b = a.s.a(Nullable$1.$.specialize(WorkbookThemeColorType_$type));
        if (nullableEquals(b, null)) {
            return;
        }
        let c = new ST_HexColorRGB();
        let d = DrawingMLMain.m1(a, c);
        c = d.p1;
        ObjectModelThemePartManager.ba(a)._by._h[b.value] = ExcelUtils.g2(c.r);
    }
    static by(a) {
        if (FormatSchemeDeserializer.f(a)) {
            return;
        }
        let b = a.s.a(Nullable$1.$.specialize(WorkbookThemeColorType_$type));
        if (nullableEquals(b, null)) {
            return;
        }
        let c;
        let d = new ST_HexColorRGB();
        let e = DrawingMLMain.m3(a, c, d);
        c = e.p1;
        d = e.p2;
        ObjectModelThemePartManager.ba(a)._by._h[b.value] = ExcelUtils.g2(XlsxUtilities.bf(c));
    }
    static bz(a) {
        let b;
        let c = DrawingMLMain.m6(a, b);
        b = c.p1;
        if (a.d._z == 0 && a.ab.af == DrawingMLMain.an.i(1)) {
            a.d._bn(1);
        }
    }
    static b0(a) {
    }
    get a9() {
        return ObjectModelThemePartManager.ba(this);
    }
    static ba(a) {
        return a.d;
    }
}
ObjectModelThemePartManager.$t = markType(ObjectModelThemePartManager, 'ObjectModelThemePartManager', ThemePartManager.$);
ObjectModelThemePartManager.bb = new ObjectModelThemePartManager(false);
ObjectModelThemePartManager.bc = new ObjectModelThemePartManager(true);
ObjectModelThemePartManager.be = "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPGE6dGhlbWUgeG1sbnM6YT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW4iIG5hbWU9Ik9mZmljZSBUaGVtZSI+PGE6dGhlbWVFbGVtZW50cz48YTpjbHJTY2hlbWUgbmFtZT0iT2ZmaWNlIj48YTpkazE+PGE6c3lzQ2xyIHZhbD0id2luZG93VGV4dCIgbGFzdENscj0iMDAwMDAwIi8+PC9hOmRrMT48YTpsdDE+PGE6c3lzQ2xyIHZhbD0id2luZG93IiBsYXN0Q2xyPSJGRkZGRkYiLz48L2E6bHQxPjxhOmRrMj48YTpzcmdiQ2xyIHZhbD0iMUY0OTdEIi8+PC9hOmRrMj48YTpsdDI+PGE6c3JnYkNsciB2YWw9IkVFRUNFMSIvPjwvYTpsdDI+PGE6YWNjZW50MT48YTpzcmdiQ2xyIHZhbD0iNEY4MUJEIi8+PC9hOmFjY2VudDE+PGE6YWNjZW50Mj48YTpzcmdiQ2xyIHZhbD0iQzA1MDREIi8+PC9hOmFjY2VudDI+PGE6YWNjZW50Mz48YTpzcmdiQ2xyIHZhbD0iOUJCQjU5Ii8+PC9hOmFjY2VudDM+PGE6YWNjZW50ND48YTpzcmdiQ2xyIHZhbD0iODA2NEEyIi8+PC9hOmFjY2VudDQ+PGE6YWNjZW50NT48YTpzcmdiQ2xyIHZhbD0iNEJBQ0M2Ii8+PC9hOmFjY2VudDU+PGE6YWNjZW50Nj48YTpzcmdiQ2xyIHZhbD0iRjc5NjQ2Ii8+PC9hOmFjY2VudDY+PGE6aGxpbms+PGE6c3JnYkNsciB2YWw9IjAwMDBGRiIvPjwvYTpobGluaz48YTpmb2xIbGluaz48YTpzcmdiQ2xyIHZhbD0iODAwMDgwIi8+PC9hOmZvbEhsaW5rPjwvYTpjbHJTY2hlbWU+PGE6Zm9udFNjaGVtZSBuYW1lPSJPZmZpY2UiPjxhOm1ham9yRm9udD48YTpsYXRpbiB0eXBlZmFjZT0iQ2FtYnJpYSIvPjxhOmVhIHR5cGVmYWNlPSIiLz48YTpjcyB0eXBlZmFjZT0iIi8+PGE6Zm9udCBzY3JpcHQ9IkpwYW4iIHR5cGVmYWNlPSLvvK3vvLMg77yw44K044K344OD44KvIi8+PGE6Zm9udCBzY3JpcHQ9IkhhbmciIHR5cGVmYWNlPSLrp5HsnYAg6rOg65SVIi8+PGE6Zm9udCBzY3JpcHQ9IkhhbnMiIHR5cGVmYWNlPSLlrovkvZMiLz48YTpmb250IHNjcmlwdD0iSGFudCIgdHlwZWZhY2U9IuaWsOe0sOaYjumrlCIvPjxhOmZvbnQgc2NyaXB0PSJBcmFiIiB0eXBlZmFjZT0iVGltZXMgTmV3IFJvbWFuIi8+PGE6Zm9udCBzY3JpcHQ9IkhlYnIiIHR5cGVmYWNlPSJUaW1lcyBOZXcgUm9tYW4iLz48YTpmb250IHNjcmlwdD0iVGhhaSIgdHlwZWZhY2U9IlRhaG9tYSIvPjxhOmZvbnQgc2NyaXB0PSJFdGhpIiB0eXBlZmFjZT0iTnlhbGEiLz48YTpmb250IHNjcmlwdD0iQmVuZyIgdHlwZWZhY2U9IlZyaW5kYSIvPjxhOmZvbnQgc2NyaXB0PSJHdWpyIiB0eXBlZmFjZT0iU2hydXRpIi8+PGE6Zm9udCBzY3JpcHQ9IktobXIiIHR5cGVmYWNlPSJNb29sQm9yYW4iLz48YTpmb250IHNjcmlwdD0iS25kYSIgdHlwZWZhY2U9IlR1bmdhIi8+PGE6Zm9udCBzY3JpcHQ9Ikd1cnUiIHR5cGVmYWNlPSJSYWF2aSIvPjxhOmZvbnQgc2NyaXB0PSJDYW5zIiB0eXBlZmFjZT0iRXVwaGVtaWEiLz48YTpmb250IHNjcmlwdD0iQ2hlciIgdHlwZWZhY2U9IlBsYW50YWdlbmV0IENoZXJva2VlIi8+PGE6Zm9udCBzY3JpcHQ9IllpaWkiIHR5cGVmYWNlPSJNaWNyb3NvZnQgWWkgQmFpdGkiLz48YTpmb250IHNjcmlwdD0iVGlidCIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBIaW1hbGF5YSIvPjxhOmZvbnQgc2NyaXB0PSJUaGFhIiB0eXBlZmFjZT0iTVYgQm9saSIvPjxhOmZvbnQgc2NyaXB0PSJEZXZhIiB0eXBlZmFjZT0iTWFuZ2FsIi8+PGE6Zm9udCBzY3JpcHQ9IlRlbHUiIHR5cGVmYWNlPSJHYXV0YW1pIi8+PGE6Zm9udCBzY3JpcHQ9IlRhbWwiIHR5cGVmYWNlPSJMYXRoYSIvPjxhOmZvbnQgc2NyaXB0PSJTeXJjIiB0eXBlZmFjZT0iRXN0cmFuZ2VsbyBFZGVzc2EiLz48YTpmb250IHNjcmlwdD0iT3J5YSIgdHlwZWZhY2U9IkthbGluZ2EiLz48YTpmb250IHNjcmlwdD0iTWx5bSIgdHlwZWZhY2U9IkthcnRpa2EiLz48YTpmb250IHNjcmlwdD0iTGFvbyIgdHlwZWZhY2U9IkRva0NoYW1wYSIvPjxhOmZvbnQgc2NyaXB0PSJTaW5oIiB0eXBlZmFjZT0iSXNrb29sYSBQb3RhIi8+PGE6Zm9udCBzY3JpcHQ9Ik1vbmciIHR5cGVmYWNlPSJNb25nb2xpYW4gQmFpdGkiLz48YTpmb250IHNjcmlwdD0iVmlldCIgdHlwZWZhY2U9IlRpbWVzIE5ldyBSb21hbiIvPjxhOmZvbnQgc2NyaXB0PSJVaWdoIiB0eXBlZmFjZT0iTWljcm9zb2Z0IFVpZ2h1ciIvPjwvYTptYWpvckZvbnQ+PGE6bWlub3JGb250PjxhOmxhdGluIHR5cGVmYWNlPSJDYWxpYnJpIi8+PGE6ZWEgdHlwZWZhY2U9IiIvPjxhOmNzIHR5cGVmYWNlPSIiLz48YTpmb250IHNjcmlwdD0iSnBhbiIgdHlwZWZhY2U9Iu+8re+8syDvvLDjgrTjgrfjg4Pjgq8iLz48YTpmb250IHNjcmlwdD0iSGFuZyIgdHlwZWZhY2U9IuunkeydgCDqs6DrlJUiLz48YTpmb250IHNjcmlwdD0iSGFucyIgdHlwZWZhY2U9IuWui+S9kyIvPjxhOmZvbnQgc2NyaXB0PSJIYW50IiB0eXBlZmFjZT0i5paw57Sw5piO6auUIi8+PGE6Zm9udCBzY3JpcHQ9IkFyYWIiIHR5cGVmYWNlPSJBcmlhbCIvPjxhOmZvbnQgc2NyaXB0PSJIZWJyIiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVGhhaSIgdHlwZWZhY2U9IlRhaG9tYSIvPjxhOmZvbnQgc2NyaXB0PSJFdGhpIiB0eXBlZmFjZT0iTnlhbGEiLz48YTpmb250IHNjcmlwdD0iQmVuZyIgdHlwZWZhY2U9IlZyaW5kYSIvPjxhOmZvbnQgc2NyaXB0PSJHdWpyIiB0eXBlZmFjZT0iU2hydXRpIi8+PGE6Zm9udCBzY3JpcHQ9IktobXIiIHR5cGVmYWNlPSJEYXVuUGVuaCIvPjxhOmZvbnQgc2NyaXB0PSJLbmRhIiB0eXBlZmFjZT0iVHVuZ2EiLz48YTpmb250IHNjcmlwdD0iR3VydSIgdHlwZWZhY2U9IlJhYXZpIi8+PGE6Zm9udCBzY3JpcHQ9IkNhbnMiIHR5cGVmYWNlPSJFdXBoZW1pYSIvPjxhOmZvbnQgc2NyaXB0PSJDaGVyIiB0eXBlZmFjZT0iUGxhbnRhZ2VuZXQgQ2hlcm9rZWUiLz48YTpmb250IHNjcmlwdD0iWWlpaSIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBZaSBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJUaWJ0IiB0eXBlZmFjZT0iTWljcm9zb2Z0IEhpbWFsYXlhIi8+PGE6Zm9udCBzY3JpcHQ9IlRoYWEiIHR5cGVmYWNlPSJNViBCb2xpIi8+PGE6Zm9udCBzY3JpcHQ9IkRldmEiIHR5cGVmYWNlPSJNYW5nYWwiLz48YTpmb250IHNjcmlwdD0iVGVsdSIgdHlwZWZhY2U9IkdhdXRhbWkiLz48YTpmb250IHNjcmlwdD0iVGFtbCIgdHlwZWZhY2U9IkxhdGhhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cmMiIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJPcnlhIiB0eXBlZmFjZT0iS2FsaW5nYSIvPjxhOmZvbnQgc2NyaXB0PSJNbHltIiB0eXBlZmFjZT0iS2FydGlrYSIvPjxhOmZvbnQgc2NyaXB0PSJMYW9vIiB0eXBlZmFjZT0iRG9rQ2hhbXBhIi8+PGE6Zm9udCBzY3JpcHQ9IlNpbmgiIHR5cGVmYWNlPSJJc2tvb2xhIFBvdGEiLz48YTpmb250IHNjcmlwdD0iTW9uZyIgdHlwZWZhY2U9Ik1vbmdvbGlhbiBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJWaWV0IiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVWlnaCIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBVaWdodXIiLz48L2E6bWlub3JGb250PjwvYTpmb250U2NoZW1lPjxhOmZtdFNjaGVtZSBuYW1lPSJPZmZpY2UiPjxhOmZpbGxTdHlsZUxzdD48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT0iMSI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPSIwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjUwMDAwIi8+PGE6c2F0TW9kIHZhbD0iMzAwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSIzNTAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSIzNzAwMCIvPjxhOnNhdE1vZCB2YWw9IjMwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz0iMTAwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjE1MDAwIi8+PGE6c2F0TW9kIHZhbD0iMzUwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PC9hOmdzTHN0PjxhOmxpbiBhbmc9IjE2MjAwMDAwIiBzY2FsZWQ9IjEiLz48L2E6Z3JhZEZpbGw+PGE6Z3JhZEZpbGwgcm90V2l0aFNoYXBlPSIxIj48YTpnc0xzdD48YTpncyBwb3M9IjAiPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpzaGFkZSB2YWw9IjUxMDAwIi8+PGE6c2F0TW9kIHZhbD0iMTMwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSI4MDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iOTMwMDAiLz48YTpzYXRNb2QgdmFsPSIxMzAwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjEwMDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iOTQwMDAiLz48YTpzYXRNb2QgdmFsPSIxMzUwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz0iMTYyMDAwMDAiIHNjYWxlZD0iMCIvPjwvYTpncmFkRmlsbD48L2E6ZmlsbFN0eWxlTHN0PjxhOmxuU3R5bGVMc3Q+PGE6bG4gdz0iOTUyNSIgY2FwPSJmbGF0IiBjbXBkPSJzbmciIGFsZ249ImN0ciI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpzaGFkZSB2YWw9Ijk1MDAwIi8+PGE6c2F0TW9kIHZhbD0iMTA1MDAwIi8+PC9hOnNjaGVtZUNscj48L2E6c29saWRGaWxsPjxhOnByc3REYXNoIHZhbD0ic29saWQiLz48L2E6bG4+PGE6bG4gdz0iMjU0MDAiIGNhcD0iZmxhdCIgY21wZD0ic25nIiBhbGduPSJjdHIiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPSJwaENsciIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPSJzb2xpZCIvPjwvYTpsbj48YTpsbiB3PSIzODEwMCIgY2FwPSJmbGF0IiBjbXBkPSJzbmciIGFsZ249ImN0ciI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIi8+PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9InNvbGlkIi8+PC9hOmxuPjwvYTpsblN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlPjxhOmVmZmVjdExzdD48YTpvdXRlclNoZHcgYmx1clJhZD0iNDAwMDAiIGRpc3Q9IjIwMDAwIiBkaXI9IjU0MDAwMDAiIHJvdFdpdGhTaGFwZT0iMCI+PGE6c3JnYkNsciB2YWw9IjAwMDAwMCI+PGE6YWxwaGEgdmFsPSIzODAwMCIvPjwvYTpzcmdiQ2xyPjwvYTpvdXRlclNoZHc+PC9hOmVmZmVjdExzdD48L2E6ZWZmZWN0U3R5bGU+PGE6ZWZmZWN0U3R5bGU+PGE6ZWZmZWN0THN0PjxhOm91dGVyU2hkdyBibHVyUmFkPSI0MDAwMCIgZGlzdD0iMjMwMDAiIGRpcj0iNTQwMDAwMCIgcm90V2l0aFNoYXBlPSIwIj48YTpzcmdiQ2xyIHZhbD0iMDAwMDAwIj48YTphbHBoYSB2YWw9IjM1MDAwIi8+PC9hOnNyZ2JDbHI+PC9hOm91dGVyU2hkdz48L2E6ZWZmZWN0THN0PjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3Q+PGE6b3V0ZXJTaGR3IGJsdXJSYWQ9IjQwMDAwIiBkaXN0PSIyMzAwMCIgZGlyPSI1NDAwMDAwIiByb3RXaXRoU2hhcGU9IjAiPjxhOnNyZ2JDbHIgdmFsPSIwMDAwMDAiPjxhOmFscGhhIHZhbD0iMzUwMDAiLz48L2E6c3JnYkNscj48L2E6b3V0ZXJTaGR3PjwvYTplZmZlY3RMc3Q+PGE6c2NlbmUzZD48YTpjYW1lcmEgcHJzdD0ib3J0aG9ncmFwaGljRnJvbnQiPjxhOnJvdCBsYXQ9IjAiIGxvbj0iMCIgcmV2PSIwIi8+PC9hOmNhbWVyYT48YTpsaWdodFJpZyByaWc9InRocmVlUHQiIGRpcj0idCI+PGE6cm90IGxhdD0iMCIgbG9uPSIwIiByZXY9IjEyMDAwMDAiLz48L2E6bGlnaHRSaWc+PC9hOnNjZW5lM2Q+PGE6c3AzZD48YTpiZXZlbFQgdz0iNjM1MDAiIGg9IjI1NDAwIi8+PC9hOnNwM2Q+PC9hOmVmZmVjdFN0eWxlPjwvYTplZmZlY3RTdHlsZUxzdD48YTpiZ0ZpbGxTdHlsZUxzdD48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT0iMSI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPSIwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjQwMDAwIi8+PGE6c2F0TW9kIHZhbD0iMzUwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSI0MDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI0NTAwMCIvPjxhOnNoYWRlIHZhbD0iOTkwMDAiLz48YTpzYXRNb2QgdmFsPSIzNTAwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjEwMDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iMjAwMDAiLz48YTpzYXRNb2QgdmFsPSIyNTUwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6cGF0aCBwYXRoPSJjaXJjbGUiPjxhOmZpbGxUb1JlY3QgbD0iNTAwMDAiIHQ9Ii04MDAwMCIgcj0iNTAwMDAiIGI9IjE4MDAwMCIvPjwvYTpwYXRoPjwvYTpncmFkRmlsbD48YTpncmFkRmlsbCByb3RXaXRoU2hhcGU9IjEiPjxhOmdzTHN0PjxhOmdzIHBvcz0iMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI4MDAwMCIvPjxhOnNhdE1vZCB2YWw9IjMwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz0iMTAwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6c2hhZGUgdmFsPSIzMDAwMCIvPjxhOnNhdE1vZCB2YWw9IjIwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjwvYTpnc0xzdD48YTpwYXRoIHBhdGg9ImNpcmNsZSI+PGE6ZmlsbFRvUmVjdCBsPSI1MDAwMCIgdD0iNTAwMDAiIHI9IjUwMDAwIiBiPSI1MDAwMCIvPjwvYTpwYXRoPjwvYTpncmFkRmlsbD48L2E6YmdGaWxsU3R5bGVMc3Q+PC9hOmZtdFNjaGVtZT48L2E6dGhlbWVFbGVtZW50cz48YTpvYmplY3REZWZhdWx0cy8+PGE6ZXh0cmFDbHJTY2hlbWVMc3QvPjwvYTp0aGVtZT4=";
/**
 * @hidden
 */
export class ObjectModelVbaProjectPartManager extends VbaProjectPartManager {
    constructor() {
        super();
    }
    a() {
        let a = this.v._by;
        a._k = new BinaryData(DocCoreUtils.c(this.l));
        return WorkItem.g(Base.$, a._k);
    }
    b(a) {
        let b = this.v._by;
        this.l.write(b._k.a, 0, b._k.a.length);
        return null;
    }
    get v() {
        return ObjectModelVbaProjectPartManager.w(this);
    }
    static w(a) {
        return a.d;
    }
}
ObjectModelVbaProjectPartManager.$t = markType(ObjectModelVbaProjectPartManager, 'ObjectModelVbaProjectPartManager', VbaProjectPartManager.$);
ObjectModelVbaProjectPartManager.x = new ObjectModelVbaProjectPartManager();
/**
 * @hidden
 */
export class ObjectModelVmlDrawingPartManager extends VmlDrawingPartManager {
    constructor() {
        super(false);
        this.ay("xml", ObjectModelVmlDrawingPartManager.ch);
        this.ay("urn:schemas-microsoft-com:vml/imagedata", ObjectModelVmlDrawingPartManager.bs);
        this.ay("urn:schemas-microsoft-com:vml/path", ObjectModelVmlDrawingPartManager.b2);
        this.ay("urn:schemas-microsoft-com:vml/shadow", ObjectModelVmlDrawingPartManager.b8);
        this.ay("urn:schemas-microsoft-com:vml/shape", ObjectModelVmlDrawingPartManager.b9);
        this.ay("urn:schemas-microsoft-com:vml/shapetype", ObjectModelVmlDrawingPartManager.ca);
        this.ay("urn:schemas-microsoft-com:vml/stroke", ObjectModelVmlDrawingPartManager.cc);
        this.ay(OfficeNamespace.ao, ObjectModelVmlDrawingPartManager.bv);
        this.ay(ExcelNamespace.ap, ObjectModelVmlDrawingPartManager.bb);
        this.ay(ExcelNamespace.aq, ObjectModelVmlDrawingPartManager.bc);
        this.ay(ExcelNamespace.ar, ObjectModelVmlDrawingPartManager.bd);
        this.ay(ExcelNamespace.as, ObjectModelVmlDrawingPartManager.be);
        this.ay(ExcelNamespace.aw, ObjectModelVmlDrawingPartManager.bf);
        this.ay(ExcelNamespace.ax, ObjectModelVmlDrawingPartManager.bg);
        this.ay(ExcelNamespace.ay, ObjectModelVmlDrawingPartManager.bh);
        this.ay(ExcelNamespace.az, ObjectModelVmlDrawingPartManager.bi);
        this.ay(ExcelNamespace.a1, ObjectModelVmlDrawingPartManager.bj);
        this.ay(ExcelNamespace.a4, ObjectModelVmlDrawingPartManager.bk);
        this.ay(ExcelNamespace.a7, ObjectModelVmlDrawingPartManager.bl);
        this.ay(ExcelNamespace.a8, ObjectModelVmlDrawingPartManager.bm);
        this.ay(ExcelNamespace.a9, ObjectModelVmlDrawingPartManager.bn);
        this.ay(ExcelNamespace.ba, ObjectModelVmlDrawingPartManager.bo);
        this.ay(ExcelNamespace.bb, ObjectModelVmlDrawingPartManager.bp);
        this.ay(ExcelNamespace.bc, ObjectModelVmlDrawingPartManager.bq);
        this.ay(ExcelNamespace.bd, ObjectModelVmlDrawingPartManager.br);
        this.ay(ExcelNamespace.bg, ObjectModelVmlDrawingPartManager.bt);
        this.ay(ExcelNamespace.bi, ObjectModelVmlDrawingPartManager.bu);
        this.ay(ExcelNamespace.bl, ObjectModelVmlDrawingPartManager.bw);
        this.ay(ExcelNamespace.bm, ObjectModelVmlDrawingPartManager.bx);
        this.ay(ExcelNamespace.bn, ObjectModelVmlDrawingPartManager.by);
        this.ay(ExcelNamespace.bo, ObjectModelVmlDrawingPartManager.bz);
        this.ay(ExcelNamespace.br, ObjectModelVmlDrawingPartManager.b0);
        this.ay(ExcelNamespace.bu, ObjectModelVmlDrawingPartManager.b1);
        this.ay(ExcelNamespace.bv, ObjectModelVmlDrawingPartManager.b3);
        this.ay(ExcelNamespace.by, ObjectModelVmlDrawingPartManager.b5);
        this.ay(ExcelNamespace.bx, ObjectModelVmlDrawingPartManager.b4);
        this.ay(ExcelNamespace.b0, ObjectModelVmlDrawingPartManager.b6);
        this.ay(ExcelNamespace.b1, ObjectModelVmlDrawingPartManager.b7);
        this.ay(ExcelNamespace.b2, ObjectModelVmlDrawingPartManager.cb);
        this.ay(ExcelNamespace.b3, ObjectModelVmlDrawingPartManager.cd);
        this.ay(ExcelNamespace.b4, ObjectModelVmlDrawingPartManager.ce);
        this.ay(ExcelNamespace.b6, ObjectModelVmlDrawingPartManager.cf);
        this.ay(ExcelNamespace.b8, ObjectModelVmlDrawingPartManager.cg);
    }
    z(a) {
        switch (a) {
            case "urn:schemas-microsoft-com:vml/textbox": return 2;
        }
        return super.z(a);
    }
    a() {
        let a = this.a8;
        let b = DocCoreUtils.c(this.l);
        a._b7._a4.addItem(a._d.uri.toString(), b);
        try {
            if (this.l.canSeek) {
                this.l.position = 0;
            }
        }
        catch (c) {
        }
        if (this.l.canSeek == false || this.l.position != 0) {
            this.l = new MemoryStream(2, b);
        }
        return super.a();
    }
    av(a) {
        let b = a.b.b.e(this.d);
        switch (b) {
            case "urn:schemas-microsoft-com:vml/textbox":
                {
                    let c = this.s.a(LegacyShapeData.$);
                    if (c == null) {
                        return;
                    }
                    c.i = a;
                    break;
                }
            default:
                super.av(a);
                break;
        }
    }
    u(a) {
        let b = this.a8;
        let c = typeCast(LegacyDrawingHFInfo.$, a);
        if (c != null) {
            this.l.write(c.a, 0, c.a.length);
            return Async.d(LegacyShapeData.$, c.b, (d) => {
                let e = d.f;
                if (e == null) {
                    return null;
                }
                return b._b0(e.b, e.d, d.aq);
            });
        }
        this.dn(b._b9);
        return null;
    }
    get_aj() {
        return false;
    }
    static bb(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.ca(a, c);
        c = d.p1;
        c = c.trim();
        let e = c.split(',');
        if (e.length != 8) {
            return;
        }
        let f = new Array(8);
        for (let g = 0; g < 8; g++) {
            let h = e[g];
            h = h.trim();
            let i;
            if (((() => { let j = tryParseInt32_1(h, i); i = j.p1; return j.ret; })()) == false) {
                return;
            }
            b.b[g] = i;
        }
    }
    static bc(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cb(a, c);
        c = d.p1;
        b.n = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bd(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cc(a, c);
        c = d.p1;
        b.o = Nullable$1.toNullable(Boolean_$type, c);
    }
    static be(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cd(a, c);
        c = d.p1;
        b.p = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bf(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.ch(a, c);
        c = d.p1;
        b.q = Nullable$1.toNullable(ST_CF_$type, c);
    }
    static bg(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.ci(a, c);
        c = d.p1;
        b.r = Nullable$1.toNullable(Number_$type, c);
    }
    static bh(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cj(a, c);
        c = d.p1;
        b.j = c;
    }
    static bi(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.ck(a, c);
        c = d.p1;
        b.s = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bj(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cm(a, c);
        c = d.p1;
        b.t = Nullable$1.toNullable(Number_$type, c);
    }
    static bk(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cp(a, c);
        c = d.p1;
        b.u = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bl(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cs(a, c);
        c = d.p1;
        b.v = Nullable$1.toNullable(Number_$type, c);
    }
    static bm(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.ct(a, c);
        c = d.p1;
        b.an = c;
    }
    static bn(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cu(a, c);
        c = d.p1;
        b.w = Nullable$1.toNullable(Number_$type, c);
    }
    static bo(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cv(a, c);
        c = d.p1;
        b.x = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bp(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cw(a, c);
        c = d.p1;
        b.ao = c != null ? c : stringEmpty();
    }
    static bq(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cx(a, c);
        c = d.p1;
        try {
            let e = ObjectModelVmlDrawingPartManager.a9(a);
            let f = e._by;
            let g = FormulaParser.l(f, a.s.a(Worksheet.$), null, -1, CultureInfo.invariantCulture, 1, 3);
            let h = WorkbookLoadManagerExcel2007._bs(c);
            c = h.p0;
            b.fmlaMacro = Formula._o(c, 3, g, e._b7._bi);
        }
        catch (i) {
        }
    }
    static br(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.cy(a, c);
        c = d.p1;
        if (c == null) {
            c = stringEmpty();
        }
        b.ap = c;
    }
    static bs(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x;
        let y;
        let z;
        let aa = VmlNamespace.dq(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);
        c = aa.p1;
        d = aa.p2;
        e = aa.p3;
        f = aa.p4;
        g = aa.p5;
        h = aa.p6;
        i = aa.p7;
        j = aa.p8;
        k = aa.p9;
        l = aa.p10;
        m = aa.p11;
        n = aa.p12;
        o = aa.p13;
        p = aa.p14;
        q = aa.p15;
        r = aa.p16;
        s = aa.p17;
        t = aa.p18;
        u = aa.p19;
        v = aa.p20;
        w = aa.p21;
        x = aa.p22;
        y = aa.p23;
        z = aa.p24;
        if (w == null) {
            return;
        }
        let ab = ObjectModelVmlDrawingPartManager.a9(a);
        let ac = typeCast(ImageData.$, ab._au(w));
        if (ac == null) {
            return;
        }
        b.aq = w;
        b.f = XlsxUtilities.u(ac);
    }
    static bt(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c1(a, c);
        c = d.p1;
        b.y = Nullable$1.toNullable(Number_$type, c);
    }
    static bu(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c3(a, c);
        c = d.p1;
        b.ar = c;
    }
    static bv(a) {
        let b = a.s.a(LegacyShapeData.$);
        let c = a.s.a(LegacyShapeTypeData.$);
        if (b == null && c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p = OfficeNamespace.ci(a, d, e, f, g, h, i, j, k, l, m, n, o);
        d = p.p1;
        e = p.p2;
        f = p.p3;
        g = p.p4;
        h = p.p5;
        i = p.p6;
        j = p.p7;
        k = p.p8;
        l = p.p9;
        m = p.p10;
        n = p.p11;
        o = p.p12;
        let q = new LegacyShapeLockData();
        if (c != null) {
            c.a = q;
        }
        else if (b != null) {
            b.c = q;
        }
        q.a = d;
        q.c = o;
        q.b = i;
    }
    static bw(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c6(a, c);
        c = d.p1;
        b.aa = Nullable$1.toNullable(Boolean_$type, c);
    }
    static bx(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c7(a, c);
        c = d.p1;
        b.ab = Nullable$1.toNullable(Number_$type, c);
    }
    static by(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c8(a, c);
        c = d.p1;
        b.ac = Nullable$1.toNullable(Number_$type, c);
    }
    static bz(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.c9(a, c);
        c = d.p1;
        b.ad = Nullable$1.toNullable(Boolean_$type, c);
    }
    static b0(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dc(a, c);
        c = d.p1;
        b.ae = Nullable$1.toNullable(Boolean_$type, c);
    }
    static b1(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dd(a, c);
        c = d.p1;
        b.af = Nullable$1.toNullable(Number_$type, c);
    }
    static b2(a) {
        let b = a.s.a(LegacyShapeData.$);
        let c = a.s.a(LegacyShapeTypeData.$);
        if (b == null && c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s = VmlNamespace.dr(a, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r);
        d = s.p1;
        e = s.p2;
        f = s.p3;
        g = s.p4;
        h = s.p5;
        i = s.p6;
        j = s.p7;
        k = s.p8;
        l = s.p9;
        m = s.p10;
        n = s.p11;
        o = s.p12;
        p = s.p13;
        q = s.p14;
        r = s.p15;
        let t = new LegacyShapePathData();
        if (c != null) {
            c.b = t;
        }
        else if (b != null) {
            b.d = t;
        }
        t.e = j;
        t.b = r;
        t.f = i;
        t.c = h;
        t.d = l;
        t.a = o;
    }
    static b3(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.de(a, c);
        c = d.p1;
        b.ag = Nullable$1.toNullable(Boolean_$type, c);
    }
    static b4(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dg(a, c);
        c = d.p1;
        b.ah = Nullable$1.toNullable(Number_$type, c);
    }
    static b5(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dh(a, c);
        c = d.p1;
        b.ai = Nullable$1.toNullable(Boolean_$type, c);
    }
    static b6(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dj(a, c);
        c = d.p1;
        b.m = c;
    }
    static b7(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dk(a, c);
        c = d.p1;
        b.as = c;
    }
    static b8(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n = VmlNamespace.ds(a, c, d, e, f, g, h, i, j, k, l, m);
        c = n.p1;
        d = n.p2;
        e = n.p3;
        f = n.p4;
        g = n.p5;
        h = n.p6;
        i = n.p7;
        j = n.p8;
        k = n.p9;
        l = n.p10;
        m = n.p11;
        b.k = true;
    }
    static b9(a) {
        let b = a.s.a(List$1.$.specialize(LegacyShapeData.$));
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x;
        let y;
        let z;
        let aa;
        let ab;
        let ac;
        let ad;
        let ae;
        let af;
        let ag;
        let ah;
        let ai;
        let aj;
        let ak;
        let al;
        let am;
        let an;
        let ao;
        let ap;
        let aq;
        let ar;
        let as;
        let at;
        let au;
        let av;
        let aw;
        let ax;
        let ay;
        let az;
        let a0;
        let a1;
        let a2;
        let a3;
        let a4;
        let a5;
        let a6;
        let a7;
        let a8 = VmlNamespace.dt(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4, a5, a6, a7);
        c = a8.p1;
        d = a8.p2;
        e = a8.p3;
        f = a8.p4;
        g = a8.p5;
        h = a8.p6;
        i = a8.p7;
        j = a8.p8;
        k = a8.p9;
        l = a8.p10;
        m = a8.p11;
        n = a8.p12;
        o = a8.p13;
        p = a8.p14;
        q = a8.p15;
        r = a8.p16;
        s = a8.p17;
        t = a8.p18;
        u = a8.p19;
        v = a8.p20;
        w = a8.p21;
        x = a8.p22;
        y = a8.p23;
        z = a8.p24;
        aa = a8.p25;
        ab = a8.p26;
        ac = a8.p27;
        ad = a8.p28;
        ae = a8.p29;
        af = a8.p30;
        ag = a8.p31;
        ah = a8.p32;
        ai = a8.p33;
        aj = a8.p34;
        ak = a8.p35;
        al = a8.p36;
        am = a8.p37;
        an = a8.p38;
        ao = a8.p39;
        ap = a8.p40;
        aq = a8.p41;
        ar = a8.p42;
        as = a8.p43;
        at = a8.p44;
        au = a8.p45;
        av = a8.p46;
        aw = a8.p47;
        ax = a8.p48;
        ay = a8.p49;
        az = a8.p50;
        a0 = a8.p51;
        a1 = a8.p52;
        a2 = a8.p53;
        a3 = a8.p54;
        a4 = a8.p55;
        a5 = a8.p56;
        a6 = a8.p57;
        a7 = a8.p58;
        let a9 = ((() => {
            let $ret = new LegacyShapeData();
            $ret.at = c;
            $ret.au = n;
            $ret.az = a3;
            $ret.aw = d;
            $ret.ak = ao;
            $ret.av = ap;
            $ret.z = aj;
            return $ret;
        })());
        b.add(a9);
        a.s.k(a9);
    }
    static ca(a) {
        let b = a.s.a(List$1.$.specialize(LegacyShapeData.$));
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x;
        let y;
        let z;
        let aa;
        let ab;
        let ac;
        let ad;
        let ae;
        let af;
        let ag;
        let ah;
        let ai;
        let aj;
        let ak;
        let al;
        let am;
        let an;
        let ao;
        let ap;
        let aq;
        let ar;
        let as;
        let at;
        let au;
        let av;
        let aw;
        let ax;
        let ay;
        let az;
        let a0;
        let a1;
        let a2;
        let a3;
        let a4;
        let a5;
        let a6 = VmlNamespace.du(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4, a5);
        c = a6.p1;
        d = a6.p2;
        e = a6.p3;
        f = a6.p4;
        g = a6.p5;
        h = a6.p6;
        i = a6.p7;
        j = a6.p8;
        k = a6.p9;
        l = a6.p10;
        m = a6.p11;
        n = a6.p12;
        o = a6.p13;
        p = a6.p14;
        q = a6.p15;
        r = a6.p16;
        s = a6.p17;
        t = a6.p18;
        u = a6.p19;
        v = a6.p20;
        w = a6.p21;
        x = a6.p22;
        y = a6.p23;
        z = a6.p24;
        aa = a6.p25;
        ab = a6.p26;
        ac = a6.p27;
        ad = a6.p28;
        ae = a6.p29;
        af = a6.p30;
        ag = a6.p31;
        ah = a6.p32;
        ai = a6.p33;
        aj = a6.p34;
        ak = a6.p35;
        al = a6.p36;
        am = a6.p37;
        an = a6.p38;
        ao = a6.p39;
        ap = a6.p40;
        aq = a6.p41;
        ar = a6.p42;
        as = a6.p43;
        at = a6.p44;
        au = a6.p45;
        av = a6.p46;
        aw = a6.p47;
        ax = a6.p48;
        ay = a6.p49;
        az = a6.p50;
        a0 = a6.p51;
        a1 = a6.p52;
        a2 = a6.p53;
        a3 = a6.p54;
        a4 = a6.p55;
        a5 = a6.p56;
        a.s.k(new LegacyShapeTypeData());
    }
    static cb(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dl(a, c);
        c = d.p1;
        b.aj = Nullable$1.toNullable(Boolean_$type, c);
    }
    static cc(a) {
        let b = a.s.a(LegacyShapeTypeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v;
        let w;
        let x;
        let y;
        let z;
        let aa;
        let ab;
        let ac;
        let ad;
        let ae;
        let af = VmlNamespace.dv(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae);
        c = af.p1;
        d = af.p2;
        e = af.p3;
        f = af.p4;
        g = af.p5;
        h = af.p6;
        i = af.p7;
        j = af.p8;
        k = af.p9;
        l = af.p10;
        m = af.p11;
        n = af.p12;
        o = af.p13;
        p = af.p14;
        q = af.p15;
        r = af.p16;
        s = af.p17;
        t = af.p18;
        u = af.p19;
        v = af.p20;
        w = af.p21;
        x = af.p22;
        y = af.p23;
        z = af.p24;
        aa = af.p25;
        ab = af.p26;
        ac = af.p27;
        ad = af.p28;
        ae = af.p29;
        b.c = ((() => {
            let $ret = new LegacyShapeStrokeData();
            $ret.a = j;
            return $ret;
        })());
    }
    static cd(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dn(a, c);
        c = d.p1;
        b.ax = c != null ? c : stringEmpty();
    }
    static ce(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dp(a, c);
        c = d.p1;
        b.ay = c != null ? c : stringEmpty();
    }
    static cf(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dr(a, c);
        c = d.p1;
        b.al = Nullable$1.toNullable(Number_$type, c);
    }
    static cg(a) {
        let b = a.s.a(LegacyShapeData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = ExcelNamespace.dt(a, c);
        c = d.p1;
        b.am = Nullable$1.toNullable(Boolean_$type, c);
    }
    static ch(a) {
        let b = new List$1(LegacyShapeData.$, 0);
        a.an = b;
        a.s.k(b);
    }
    ci(a) {
        ExcelNamespace.dv(this, stringJoin1(Number_$type, ", ", a.b));
        this.ad.k();
    }
    cj(a) {
        if (nullableEquals(a.n, null)) {
            return;
        }
        ExcelNamespace.dw(this, a.n.value);
        this.ad.k();
    }
    ck(a) {
        if (nullableEquals(a.o, null)) {
            return;
        }
        ExcelNamespace.dx(this, a.o.value);
        this.ad.k();
    }
    cl(a) {
        if (nullableEquals(a.p, null)) {
            return;
        }
        ExcelNamespace.dy(this, a.p.value);
        this.ad.k();
    }
    cm(a) {
        if (nullableEquals(a.q, null)) {
            return;
        }
        ExcelNamespace.d2(this, a.q.value);
        this.ad.k();
    }
    cn(a) {
        if (nullableEquals(a.r, null)) {
            return;
        }
        ExcelNamespace.d3(this, a.r.value);
        this.ad.k();
    }
    co(a, b) {
        ExcelNamespace.d4(this, b.j);
        this.c8(b.d);
        this.c1(b.c);
        if (b.i != null) {
            this.ad.t(b.i);
        }
        this.c5(b);
        this.dh(b);
        this.ci(b);
        this.da(b);
        this.cq(b);
        this.dm(b);
        this.db(b);
        this.cp(b);
        this.cr(b);
        this.c9(b);
        this.cj(b);
        this.ck(b);
        this.dl(b);
        this.c4(b);
        this.c3(b);
        this.cz(b);
        this.c7(b);
        this.cu(b);
        this.cm(b);
        this.cl(b);
        this.c2(b);
        this.cw(b);
        this.cx(a, b);
        this.cy(b);
        this.dc(b);
        this.dd(b);
        this.c0(b);
        this.ct(b);
        this.cs(b);
        this.dj(b);
        this.dk(b);
        this.cn(b);
        this.c6(b);
        this.cv(b);
        this.ad.k();
    }
    cp(a) {
        if (nullableEquals(a.s, null)) {
            return;
        }
        ExcelNamespace.d5(this, a.s.value);
        this.ad.k();
    }
    cq(a) {
        if (nullableEquals(a.t, null)) {
            return;
        }
        ExcelNamespace.d7(this, a.t.value);
        this.ad.k();
    }
    cr(a) {
        if (nullableEquals(a.u, null)) {
            return;
        }
        ExcelNamespace.ea(this, a.u.value);
        this.ad.k();
    }
    cs(a) {
        if (a.v.hasValue == false) {
            return;
        }
        ExcelNamespace.ed(this, a.v.value);
        this.ad.k();
    }
    ct(a) {
        if (stringIsNullOrEmpty(a.an)) {
            return;
        }
        ExcelNamespace.ee(this, a.an);
        this.ad.k();
    }
    cu(a) {
        if (a.w.hasValue == false) {
            return;
        }
        ExcelNamespace.ef(this, a.w.value);
        this.ad.k();
    }
    cv(a) {
        if (nullableEquals(a.x, null)) {
            return;
        }
        ExcelNamespace.eg(this, a.x.value);
        this.ad.k();
    }
    cw(a) {
        if (stringIsNullOrEmpty(a.ao)) {
            return;
        }
        ExcelNamespace.eh(this, a.ao);
        this.ad.k();
    }
    cx(a, b) {
        if (b.fmlaMacro == null) {
            return;
        }
        ExcelNamespace.ei(this, a._ct(b.fmlaMacro));
        this.ad.k();
    }
    cy(a) {
        if (stringIsNullOrEmpty(a.ap)) {
            return;
        }
        ExcelNamespace.ej(this, a.ap);
        this.ad.k();
    }
    cz(a) {
        if (a.y.hasValue == false) {
            return;
        }
        ExcelNamespace.em(this, a.y.value);
        this.ad.k();
    }
    c0(a) {
        if (stringIsNullOrEmpty(a.ar)) {
            return;
        }
        ExcelNamespace.eo(this, a.ar);
        this.ad.k();
    }
    c1(a) {
        if (a == null) {
            return;
        }
        OfficeNamespace.cl(this, a.a, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), a.b, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), a.c);
        this.ad.k();
    }
    c3(a) {
        if (a.ab.hasValue == false) {
            return;
        }
        ExcelNamespace.es(this, a.ab.value);
        this.ad.k();
    }
    c4(a) {
        if (a.ac.hasValue == false) {
            return;
        }
        ExcelNamespace.et(this, a.ac.value);
        this.ad.k();
    }
    c2(a) {
        if (nullableEquals(a.aa, null)) {
            return;
        }
        ExcelNamespace.er(this, a.aa.value);
        this.ad.k();
    }
    c5(a) {
        if (nullableEquals(a.ad, null)) {
            return;
        }
        ExcelNamespace.eu(this, a.ad.value);
        this.ad.k();
    }
    c6(a) {
        if (nullableEquals(a.ae, null)) {
            return;
        }
        ExcelNamespace.ex(this, a.ae.value);
        this.ad.k();
    }
    c7(a) {
        if (a.af.hasValue == false) {
            return;
        }
        ExcelNamespace.ey(this, a.af.value);
        this.ad.k();
    }
    c8(a) {
        if (a == null) {
            return;
        }
        VmlNamespace.d0(this, void 0, void 0, void 0, void 0, a.c, a.f, a.e, Nullable$1.toNullable(Boolean_$type, null), a.d, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), a.a, void 0, void 0, a.b);
        this.ad.k();
    }
    c9(a) {
        if (nullableEquals(a.ag, null)) {
            return;
        }
        ExcelNamespace.ez(this, a.ag.value);
        this.ad.k();
    }
    da(a) {
        if (nullableEquals(a.ah, null)) {
            return;
        }
        ExcelNamespace.e1(this, a.ah.value);
        this.ad.k();
    }
    db(a) {
        if (nullableEquals(a.ai, null)) {
            return;
        }
        ExcelNamespace.e2(this, a.ai.value);
        this.ad.k();
    }
    dc(a) {
        if (stringIsNullOrEmpty(a.as)) {
            return;
        }
        ExcelNamespace.e4(this, a.m);
        this.ad.k();
    }
    dd(a) {
        if (stringIsNullOrEmpty(a.as)) {
            return;
        }
        ExcelNamespace.e5(this, a.as);
        this.ad.k();
    }
    de() {
        VmlNamespace.d1(this, void 0, Nullable$1.toNullable(Boolean_$type, true), Nullable$1.toNullable(ST_ShadowType_$type, 0), Nullable$1.toNullable(Boolean_$type, true), "black");
        this.ad.k();
    }
    df(a, b) {
        let c = null;
        let d = typeCast(ShapeFillSolid.$, b.h._k);
        if (d != null) {
            c = ExcelUtils.d2(ExcelUtils.g1(d.colorInfo._aj(a._b, false)));
        }
        let e = Nullable$1.toNullable(Boolean_$type, null);
        if (typeCast(ShapeFillNoFill.$, b.h._k) !== null) {
            e = Nullable$1.toNullable(Boolean_$type, false);
        }
        (((f, g, h, i, j, k, l, m, n, o) => VmlNamespace.d2(f, g, h, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, Nullable$1.toNullable(Boolean_$type, null), i, Nullable$1.toNullable(Boolean_$type, null), void 0, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(ST_HrAlign_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), void 0, void 0, void 0, void 0, void 0, void 0, void 0, j, void 0, l, k, void 0, m, n, void 0, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(ST_ConnectorType_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), o, void 0, void 0, void 0, void 0))(this, b.at, b.aw, b.au, b.z, c, e, b.ak, b.av, b.az));
        if (b.k) {
            this.de();
        }
        this.co(a, b);
        this.ad.k();
    }
    dg(p) {
        VmlNamespace.d3(this, p.f, void 0, void 0, void 0, void 0, void 0, void 0, p.e, void 0, void 0, Nullable$1.toNullable(Boolean_$type, null), void 0, Nullable$1.toNullable(Boolean_$type, null), void 0, Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Number_$type, null), Nullable$1.toNullable(ST_HrAlign_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), void 0, void 0, void 0, void 0, void 0, void 0, void 0, Nullable$1.toNullable(ST_InsetMode_$type, null), void 0, Nullable$1.toNullable(Boolean_$type, null), void 0, void 0, Nullable$1.toNullable(Boolean_$type, null), void 0, void 0, Nullable$1.toNullable(Boolean_$type, null), p.d, Nullable$1.toNullable(ST_ConnectorType_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(ST_BWMode_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), Nullable$1.toNullable(Boolean_$type, null), void 0, p.g);
        this.di(p.c);
        this.c8(p.b);
        this.c1(p.a);
        this.ad.k();
    }
    dh(p) {
        if (nullableEquals(p.aj, null)) {
            return;
        }
        ExcelNamespace.e6(this, p.aj.value);
        this.ad.k();
    }
    di(p) {
        if (p == null) {
            return;
        }
        VmlNamespace.d4(this, void 0, Nullable$1.toNullable(Boolean_$type, null), void 0, void 0, void 0, Nullable$1.toNullable(ST_StrokeLineStyle_$type, null), Nullable$1.toNullable(Number_$type, null), p.a);
        this.ad.k();
    }
    dj(p) {
        if (p.ax == null) {
            return;
        }
        ExcelNamespace.e8(this, p.ax);
        this.ad.k();
    }
    dk(p) {
        if (p.ay == null) {
            return;
        }
        ExcelNamespace.e9(this, p.ay);
        this.ad.k();
    }
    dl(p) {
        if (p.al.hasValue == false) {
            return;
        }
        ExcelNamespace.fb(this, p.al.value);
        this.ad.k();
    }
    dm(p) {
        if (nullableEquals(p.am, null)) {
            return;
        }
        ExcelNamespace.fd(this, p.am.value);
        this.ad.k();
    }
    dn(p) {
        let q = this.s.a(List$1.$.specialize(WorksheetShape.$));
        if (q == null) {
            return;
        }
        let r = this.a8;
        let s = new List$1(LegacyShapeData.$, 0);
        let t = false;
        let u = false;
        for (let v of fromEnum(q)) {
            let w = typeCast(UnknownShape.$, v);
            let x = null;
            if (w != null) {
                x = w._eg;
            }
            else if (typeCast(WorksheetCellComment.$, v) !== null) {
                x = new LegacyShapeData();
            }
            if (x != null) {
                if (typeCast(WorksheetCellComment.$, v) !== null) {
                    t = true;
                }
                else {
                    u = true;
                }
                v._am(LegacyShapeData.$, Boolean_$type, ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData.d, x);
                s.add(x);
            }
            else {
            }
        }
        let y = new List$1(LegacyShapeTypeData.$, 0);
        if (t) {
            let z = new LegacyShapeTypeData();
            z.f = "_x0000_t202";
            z.e = "21600,21600";
            z.d = Nullable$1.toNullable(Number_$type, 202);
            z.g = "m,l,21600r21600,l21600,xe";
            z.c = new LegacyShapeStrokeData();
            z.c.a = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, 2);
            z.b = new LegacyShapePathData();
            z.b.d = Nullable$1.toNullable(Boolean_$type, true);
            z.b.a = Nullable$1.toNullable(ST_ConnectType_$type, 1);
            y.add(z);
        }
        if (u) {
            let aa = new LegacyShapeTypeData();
            aa.f = "_x0000_t201";
            aa.e = "21600,21600";
            aa.d = Nullable$1.toNullable(Number_$type, 201);
            aa.g = "m,l,21600r21600,l21600,xe";
            aa.c = new LegacyShapeStrokeData();
            aa.c.a = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, 2);
            aa.b = new LegacyShapePathData();
            aa.b.e = Nullable$1.toNullable(Boolean_$type, false);
            aa.b.b = Nullable$1.toNullable(Boolean_$type, false);
            aa.b.f = Nullable$1.toNullable(Boolean_$type, false);
            aa.b.c = Nullable$1.toNullable(Boolean_$type, false);
            aa.b.a = Nullable$1.toNullable(ST_ConnectType_$type, 1);
            aa.a = new LegacyShapeLockData();
            aa.a.a = Nullable$1.toNullable(ST_Ext_$type, 1);
            aa.a.c = Nullable$1.toNullable(Boolean_$type, true);
            y.add(aa);
        }
        EmptyNamespace.aq(this);
        this.ad.l(ExcelNamespace.an);
        y.q(runOn(this, this.dg));
        s.q((ab) => this.df(p, ab));
        this.ad.k();
    }
    get a8() {
        return ObjectModelVmlDrawingPartManager.a9(this);
    }
    static a9(p) {
        return p.d;
    }
}
ObjectModelVmlDrawingPartManager.$t = markType(ObjectModelVmlDrawingPartManager, 'ObjectModelVmlDrawingPartManager', VmlDrawingPartManager.$);
ObjectModelVmlDrawingPartManager.ba = new ObjectModelVmlDrawingPartManager();
/**
 * @hidden
 */
export class ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData extends WorksheetShapeVisitor$2 {
    constructor() {
        super(LegacyShapeData.$, Boolean_$type);
    }
    visitWorksheetCellComment(value, shapeData) {
        return this._visitWorksheetCellComment$i.apply(this, arguments);
    }
    _visitWorksheetCellComment$i(a, b) {
        if (b == null) {
            return true;
        }
        let c = a.cell.worksheet;
        if (c == null) {
            return true;
        }
        b.s = Nullable$1.toNullable(Boolean_$type, c._ec(a.cell._ab));
        b.t = Nullable$1.toNullable(Number_$type, a.cell._ab);
        b.ai = Nullable$1.toNullable(Boolean_$type, c._eg(a.cell.rowIndex));
        b.ah = Nullable$1.toNullable(Number_$type, a.cell.rowIndex);
        b.k = true;
        b.z = Nullable$1.toNullable(ST_InsetMode_$type, 0);
        b.j = 10;
        b.az = "#_x0000_t202";
        super._visitWorksheetCellComment$i(a, b);
        b.am = Nullable$1.toNullable(Boolean_$type, a.visible);
        return true;
    }
    b(a, b) {
        if (b == null) {
            return true;
        }
        b.a0(a);
        b.au = "_x0000_s" + a._cn;
        b.am = Nullable$1.toNullable(Boolean_$type, null);
        if (a.visible == false || b.l == false) {
            let c = b.aw != null ? b.aw : "";
            let d = c.indexOf("visibility:");
            if (0 <= d) {
                let e = c.indexOf(";", d);
                if (e < 0) {
                    c = stringRemove(c, d);
                }
                else {
                    c = stringRemove(c, d, e - d + 1);
                }
            }
            if (c.length != 0) {
                c += ";";
            }
            c += "visibility:hidden";
            b.aw = c;
        }
        if (WorksheetCell.l_op_Inequality(a._aa, null)) {
            if (a._aa._o != null) {
                b.ao = a._aa._toString2(1, false, false, false);
            }
            else {
                a._aa = null;
            }
        }
        let t1 = a.positioningMode;
        L0: while (true) {
            switch (t1) {
                case 3:
                    b.ad = Nullable$1.toNullable(Boolean_$type, true);
                    b.aj = Nullable$1.toNullable(Boolean_$type, true);
                    break;
                case 0:
                    b.ad = Nullable$1.toNullable(Boolean_$type, null);
                    b.aj = Nullable$1.toNullable(Boolean_$type, null);
                    break;
                case 2:
                    b.ad = Nullable$1.toNullable(Boolean_$type, null);
                    b.aj = Nullable$1.toNullable(Boolean_$type, true);
                    break;
                default:
                    t1 = 0;
                    continue L0;
            }
            break;
        }
        return true;
    }
}
ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData.$t = markType(ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData, 'ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData', WorksheetShapeVisitor$2.$.specialize(LegacyShapeData.$, Boolean_$type));
ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData.d = new ObjectModelVmlDrawingPartManager_UpdateLegacyShapeData();
/**
 * @hidden
 */
export class ObjectModelWorkbookPartManager extends ObjectModelWorkbookPartManagerBase {
    constructor() {
        super();
    }
    get_m() {
        return WorkbookPartManagerBase.a8;
    }
    get m() {
        return this.get_m();
    }
}
ObjectModelWorkbookPartManager.$t = markType(ObjectModelWorkbookPartManager, 'ObjectModelWorkbookPartManager', ObjectModelWorkbookPartManagerBase.$);
ObjectModelWorkbookPartManager.b7 = new ObjectModelWorkbookPartManager();
/**
 * @hidden
 */
export class SheetRelationships extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.c = null;
        this.b = null;
    }
}
SheetRelationships.$t = markType(SheetRelationships, 'SheetRelationships');
callStaticConstructors();
//# sourceMappingURL=excel.openxml.js.map
