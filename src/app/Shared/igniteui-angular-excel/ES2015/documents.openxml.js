/*
*
* An XmlReader implementation for loading SGML (including HTML) converting it
* to well formed XML, by adding missing quotes, empty attribute values, ignoring
* duplicate attributes, case folding on tag names, adding missing closing tags
* based on SGML DTD information, and so on.
*
* Copyright (c) 2002 Microsoft Corporation. All rights reserved.
*
* Chris Lovett
*
*/
/* MD 2/27/13
 * This software is being re-used under the Microsoft Public License (MS-PL):
 * -----------------------------------------------------------------------------
 * This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the
 * license, do not use the software.
 *
 * 1. Definitions
 * The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under U.S. copyright law.
 * A "contribution" is the original software, or any additions or changes to the software. A "contributor" is any person that distributes
 * its contribution under this license. "Licensed patents" are a contributor's patent claims that read directly on its contribution.
 *
 * 2. Grant of Rights
 * (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each
 *     contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare
 *     derivative works of its contribution, and distribute its contribution or any derivative works that you create.
 * (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each
 *     contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use,
 *     sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution
 *     in the software.
 *
 * 3. Conditions and Limitations
 * (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks.
 * (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license
 *     from such contributor to the software ends automatically.
 * (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are
 *     present in the software.
 * (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete
 *     copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may
 *     only do so under a license that complies with this license.
 * (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees or conditions.
 *     You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your
 *     local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.
 * -----------------------------------------------------------------------------
 *
 * Note: edits have also been made to support namespace prefixes. Those changes are tagged with the following comment:
 * // MD - Added support for namespaces
 *
 * In addition, the public classes have been made internal and the namespace has been changed from Sgml to
 * Infragistics.Documents.Excel.Serialization.Excel2007.Sgml
 *
 * Also, I updated the code to work with Silverlight and WinRT.
 */
import { ValueType, markEnum, Type, Base, BaseError, markType, Stream, IDisposable_$type, fromEn, EnumUtil, fromEnum, IEnumerable_$type, String_$type, getEnumerator, NotSupportedException, typeCast, runOn, markStruct, Nullable$1, Number_$type, Boolean_$type, typeCastObjTo$t, toEnum, Array_$type, getBoxIfEnum, enumGetBox, typeGetValue, Date_$type } from "../../igniteui-angular-core/ES2015/type";
import { Uri } from "../../igniteui-angular-core/ES2015/Uri";
import { TextReader } from "../../igniteui-angular-core/ES2015/TextReader";
import { StringUtilities, IPackagePart_$type, WorkItem, IPackage_$type, ExternalEventWorkItem$1, ExternalEventWorkItem, IPackageRelationship_$type, IInvalidPackageRelationshipTarget_$type, WorkItemExtensions, Async, RelationshipTargetMode_$type, IPackagePartEx_$type, IPackageFactory_$type, UriUtilities, DocCoreUtils, ST_Angle, CT_Transform2D, CT_GroupTransform2D, ST_PositiveCoordinate, ST_Coordinate, ST_UniversalMeasure, CT_TextBodyPropertiesBase, IShallowCloneable_$type, RoundTripControlData, ContextStack, ImageData, ImageFormat, CT_PositiveSize2D, CT_Point2D, IgnoreChildrenMarker, BinaryData, RoundTripPartData, ST_ShapeType_$type, ST_IconSetType_$type, ST_CellType_$type, ST_FilterOperator_$type, ST_DateTimeGrouping_$type, ST_DynamicFilterType_$type, ST_SortBy_$type, ST_TotalsRowFunction_$type, ST_TableStyleType_$type } from "./documents.core";
import { StringReader } from "../../igniteui-angular-core/ES2015/StringReader";
import { Encoding } from "../../igniteui-angular-core/ES2015/Encoding";
import { StringBuilder } from "../../igniteui-angular-core/ES2015/StringBuilder";
import { Convert } from "../../igniteui-angular-core/ES2015/Convert";
import { stringCompare1, isLetter, stringFormat, isLetterOrDigit, stringFormat1, startsWith1, b64toUint8Array, stringSplit, trimStart, trimEnd } from "../../igniteui-angular-core/ES2015/stringExtended";
import { Decoder } from "../../igniteui-angular-core/ES2015/Decoder";
import { MemoryStream } from "../../igniteui-angular-core/ES2015/MemoryStream";
import { UnicodeEncoding } from "../../igniteui-angular-core/ES2015/UnicodeEncoding";
import { u32LS, u32BitwiseOr, intSToU, intToString1, parseInt32_2, tryParseInt32_2, numberToString, tryParseNumber1, parseInt32_1, parseUInt32_2, tryParseUInt32_2, tryParseUInt64_2, parseUInt8_2, parseUInt16_2, parseInt8_1, parseNumber, parseInt64_1, parseInt16_1, parseUInt8_1, parseUInt32_1, parseUInt64_1, parseUInt16_1 } from "../../igniteui-angular-core/ES2015/numberExtended";
import { arrayCopy1, arrayCopy2 } from "../../igniteui-angular-core/ES2015/arrayExtended";
import { stringCreateFromCharArraySlice, stringEmpty, stringReplace, stringIsNullOrEmpty, stringStartsWith, stringEndsWith, stringConcat, stringJoin1, stringToString$1, stringIsNullOrWhiteSpace, stringToLocaleUpper } from "../../igniteui-angular-core/ES2015/string";
import { intDivide, truncate } from "../../igniteui-angular-core/ES2015/number";
import { List$1 } from "../../igniteui-angular-core/ES2015/List$1";
import { Dictionary$2 } from "../../igniteui-angular-core/ES2015/Dictionary$2";
import { NotImplementedException } from "../../igniteui-angular-core/ES2015/NotImplementedException";
import { XmlReader } from "../../igniteui-angular-core/ES2015/XmlReader";
import { NameTable } from "../../igniteui-angular-core/ES2015/NameTable";
import { XmlNamespaceManager } from "../../igniteui-angular-core/ES2015/XmlNamespaceManager";
import { IndexOutOfRangeException } from "../../igniteui-angular-core/ES2015/IndexOutOfRangeException";
import { InvalidOperationException } from "../../igniteui-angular-core/ES2015/InvalidOperationException";
import { StringWriter } from "../../igniteui-angular-core/ES2015/StringWriter";
import { XmlWriter } from "../../igniteui-angular-core/ES2015/XmlWriter";
import { XmlTextWriter } from "../../igniteui-angular-core/ES2015/XmlTextWriter";
import { IOPath } from "../../igniteui-angular-core/ES2015/IOPath";
import { ArgumentException } from "../../igniteui-angular-core/ES2015/ArgumentException";
import { Enumerable } from "../../igniteui-angular-core/ES2015/Enumerable";
import { XmlTextReader } from "../../igniteui-angular-core/ES2015/XmlTextReader";
import { StringComparer } from "../../igniteui-angular-core/ES2015/StringComparer";
import { Regex } from "../../igniteui-angular-core/ES2015/Regex";
import { toUniversalTime, dateToStringFormat, toLocalTime, dateParse, dateToString } from "../../igniteui-angular-core/ES2015/dateExtended";
import { dateNow } from "../../igniteui-angular-core/ES2015/date";
import { Tuple$2 } from "../../igniteui-angular-core/ES2015/Tuple$2";
import { Tuple } from "../../igniteui-angular-core/ES2015/Tuple";
import { nullableNotEquals, nullableEquals } from "../../igniteui-angular-core/ES2015/nullable";
import { CultureInfo } from "../../igniteui-angular-core/ES2015/culture";
import { Stack$1 } from "../../igniteui-angular-core/ES2015/Stack$1";
import { HashSet$1 } from "../../igniteui-angular-core/ES2015/HashSet$1";
import { Color } from "../../igniteui-angular-core/ES2015/Color";
import { parseBool, tryParseBool } from "../../igniteui-angular-core/ES2015/bool";
import { ArgumentOutOfRangeException } from "../../igniteui-angular-core/ES2015/ArgumentOutOfRangeException";
import { StreamReader } from "../../igniteui-angular-core/ES2015/StreamReader";
import { EqualityComparer$1 } from "../../igniteui-angular-core/ES2015/EqualityComparer$1";
import { Guid } from "../../igniteui-angular-core/ES2015/Guid";
import * as JSZip from "jszip/dist/jszip";
/**
 * @hidden
 */
export let ST_DataBarAxisPosition_$type = markEnum('ST_DataBarAxisPosition', 'automatic,0|middle,1|none,2');
/**
 * @hidden
 */
export let ST_DataBarDirection_$type = markEnum('ST_DataBarDirection', 'context,0|leftToRight,1|rightToLeft,2');
/**
 * @hidden
 */
export let ST_Visibility_$type = markEnum('ST_Visibility', 'visible,0|hidden,1|veryHidden,2');
/**
 * @hidden
 */
export let ST_VerticalAlignment_$type = markEnum('ST_VerticalAlignment', 'top,0|center,1|bottom,2|justify,3|distributed,4');
/**
 * @hidden
 */
export let ST_UpdateLinks_$type = markEnum('ST_UpdateLinks', 'userSet,0|never,1|always,2');
/**
 * @hidden
 */
export let ST_UnderlineValues_$type = markEnum('ST_UnderlineValues', '_single,0|_double,1|singleAccounting,2|doubleAccounting,3|none,4');
/**
 * @hidden
 */
export let ST_TimePeriod_$type = markEnum('ST_TimePeriod', 'today,0|yesterday,1|tomorrow,2|last7Days,3|thisMonth,4|lastMonth,5|nextMonth,6|thisWeek,7|lastWeek,8|nextWeek,9');
/**
 * @hidden
 */
export let ST_TableType_$type = markEnum('ST_TableType', 'worksheet,0|xml,1|queryTable,2');
/**
 * @hidden
 */
export let ST_SortMethod_$type = markEnum('ST_SortMethod', 'none,0|pinYin,1|stroke,2');
/**
 * @hidden
 */
export let ST_SheetViewType_$type = markEnum('ST_SheetViewType', 'normal,0|pageBreakPreview,1|pageLayout,2');
/**
 * @hidden
 */
export let ST_SheetState_$type = markEnum('ST_SheetState', 'visible,0|hidden,1|veryHidden,2');
/**
 * @hidden
 */
export let ST_RefMode_$type = markEnum('ST_RefMode', 'A1,0|R1C1,1');
/**
 * @hidden
 */
export let ST_PrintError_$type = markEnum('ST_PrintError', 'displayed,0|blank,1|dash,2|NA,3');
/**
 * @hidden
 */
export let ST_PatternType_$type = markEnum('ST_PatternType', 'none,0|solid,1|mediumGray,2|darkGray,3|lightGray,4|darkHorizontal,5|darkVertical,6|darkDown,7|darkUp,8|darkGrid,9|darkTrellis,10|lightHorizontal,11|lightVertical,12|lightDown,13|lightUp,14|lightGrid,15|lightTrellis,16|gray125,17|gray0625,18');
/**
 * @hidden
 */
export let ST_PaneState_$type = markEnum('ST_PaneState', 'split,0|frozen,1|frozenSplit,2');
/**
 * @hidden
 */
export let ST_Pane_$type = markEnum('ST_Pane', 'bottomRight,0|topRight,1|bottomLeft,2|topLeft,3');
/**
 * @hidden
 */
export let ST_PageOrder_$type = markEnum('ST_PageOrder', 'downThenOver,0|overThenDown,1');
/**
 * @hidden
 */
export let ST_Orientation_$type = markEnum('ST_Orientation', '_default,0|portrait,1|landscape,2|minMax,3|maxMin,4');
/**
 * @hidden
 */
export let ST_ObjectType_$type = markEnum('ST_ObjectType', 'Button,0|Checkbox,1|Dialog,2|Drop,3|Edit,4|GBox,5|Label,6|LineA,7|List,8|Movie,9|Note,10|Pict,11|Radio,12|RectA,13|Scroll,14|Spin,15|Shape,16|Group,17|Rect,18');
/**
 * @hidden
 */
export let ST_Objects_$type = markEnum('ST_Objects', 'all,0|placeholders,1|none,2');
/**
 * @hidden
 */
export let ST_HorizontalAlignment_$type = markEnum('ST_HorizontalAlignment', 'general,0|left,1|center,2|right,3|fill,4|justify,5|centerContinuous,6|distributed,7');
/**
 * @hidden
 */
export let ST_GradientType_$type = markEnum('ST_GradientType', 'linear,0|path,1');
/**
 * @hidden
 */
export let ST_FontScheme_$type = markEnum('ST_FontScheme', 'none,0|major,1|minor,2');
/**
 * @hidden
 */
export let ST_EditAs_$type = markEnum('ST_EditAs', 'twoCell,0|oneCell,1|absolute,2');
/**
 * @hidden
 */
export let ST_DataValidationType_$type = markEnum('ST_DataValidationType', 'none,0|whole,1|_decimal,2|list,3|date,4|time,5|textLength,6|custom,7');
/**
 * @hidden
 */
export let ST_DataValidationOperator_$type = markEnum('ST_DataValidationOperator', 'between,0|notBetween,1|equal,2|notEqual,3|lessThan,4|lessThanOrEqual,5|greaterThan,6|greaterThanOrEqual,7');
/**
 * @hidden
 */
export let ST_DataValidationImeMode_$type = markEnum('ST_DataValidationImeMode', 'noControl,0|off,1|on,2|disabled,3|hiragana,4|fullKatakana,5|halfKatakana,6|fullAlpha,7|halfAlpha,8|fullHangul,9|halfHangul,10');
/**
 * @hidden
 */
export let ST_DataValidationErrorStyle_$type = markEnum('ST_DataValidationErrorStyle', 'stop,0|warning,1|information,2');
/**
 * @hidden
 */
export let ST_ConditionalFormattingOperator_$type = markEnum('ST_ConditionalFormattingOperator', 'lessThan,0|lessThanOrEqual,1|equal,2|notEqual,3|greaterThanOrEqual,4|greaterThan,5|between,6|notBetween,7|containsText,8|notContains,9|beginsWith,10|endsWith,11');
/**
 * @hidden
 */
export let ST_Comments_$type = markEnum('ST_Comments', 'commNone,0|commIndicator,1|commIndAndComment,2');
/**
 * @hidden
 */
export let ST_CfvoType_$type = markEnum('ST_CfvoType', 'num,0|percent,1|max,2|min,3|formula,4|percentile,5|autoMin,6|autoMax,7');
/**
 * @hidden
 */
export let ST_CfType_$type = markEnum('ST_CfType', 'expression,0|cellIs,1|colorScale,2|dataBar,3|iconSet,4|top10,5|uniqueValues,6|duplicateValues,7|containsText,8|notContainsText,9|beginsWith,10|endsWith,11|containsBlanks,12|notContainsBlanks,13|containsErrors,14|notContainsErrors,15|timePeriod,16|aboveAverage,17');
/**
 * @hidden
 */
export let ST_CellFormulaType_$type = markEnum('ST_CellFormulaType', 'normal,0|array,1|dataTable,2|shared,3');
/**
 * @hidden
 */
export let ST_CellComments_$type = markEnum('ST_CellComments', 'none,0|asDisplayed,1|atEnd,2');
/**
 * @hidden
 */
export let ST_CalendarType_$type = markEnum('ST_CalendarType', 'gregorian,0|gregorianArabic,1|gregorianMeFrench,2|gregorianUs,3|gregorianXlitEnglish,4|gregorianXlitFrench,5|hebrew,6|hijri,7|japan,8|korea,9|none,10|saka,11|taiwan,12|thai,13');
/**
 * @hidden
 */
export let ST_CalcMode_$type = markEnum('ST_CalcMode', 'manual,0|auto,1|autoNoTable,2');
/**
 * @hidden
 */
export let ST_BorderStyle_$type = markEnum('ST_BorderStyle', 'none,0|thin,1|medium,2|dashed,3|dotted,4|thick,5|_double,6|hair,7|mediumDashed,8|dashDot,9|mediumDashDot,10|dashDotDot,11|mediumDashDotDot,12|slantDashDot,13');
/**
 * @hidden
 */
export let XmlNamespaceDefinitionBase_PreserveSpaceMode_$type = markEnum('XmlNamespaceDefinitionBase_PreserveSpaceMode', 'None,0|HonorLeadingWhitespace,2|HonorTrailingWhitespace,4|HonorBoth,6');
/**
 * @hidden
 */
export let ST_VerticalAlignRun_$type = markEnum('ST_VerticalAlignRun', 'baseline,0|superscript,1|subscript,2');
/**
 * @hidden
 */
export let ST_VectorBaseType_$type = markEnum('ST_VectorBaseType', 'variant,0|i1,1|i2,2|i4,3|i8,4|ui1,5|ui2,6|ui4,7|ui8,8|r4,9|r8,10|lpstr,11|lpwstr,12|bstr,13|date,14|filetime,15|_bool,16|cy,17|error,18|clsid,19');
/**
 * @hidden
 */
export let ST_TileFlipMode_$type = markEnum('ST_TileFlipMode', 'none,0|x,1|y,2|xy,3');
/**
 * @hidden
 */
export let ST_TextWrappingType_$type = markEnum('ST_TextWrappingType', 'none,0|square,1');
/**
 * @hidden
 */
export let ST_TextVertOverflowType_$type = markEnum('ST_TextVertOverflowType', 'overflow,0|ellipsis,1|clip,2');
/**
 * @hidden
 */
export let ST_TextVerticalType_$type = markEnum('ST_TextVerticalType', 'horz,0|vert,1|vert270,2|wordArtVert,3|eaVert,4|mongolianVert,5|wordArtVertRtl,6');
/**
 * @hidden
 */
export let ST_TextUnderlineType_$type = markEnum('ST_TextUnderlineType', 'none,0|words,1|sng,2|dbl,3|heavy,4|dotted,5|dottedHeavy,6|dash,7|dashHeavy,8|dashLong,9|dashLongHeavy,10|dotDash,11|dotDashHeavy,12|dotDotDash,13|dotDotDashHeavy,14|wavy,15|wavyHeavy,16|wavyDbl,17');
/**
 * @hidden
 */
export let ST_TextStrikeType_$type = markEnum('ST_TextStrikeType', 'noStrike,0|sngStrike,1|dblStrike,2');
/**
 * @hidden
 */
export let ST_TextHorzOverflowType_$type = markEnum('ST_TextHorzOverflowType', 'overflow,0|clip,1');
/**
 * @hidden
 */
export let ST_TextFontAlignType_$type = markEnum('ST_TextFontAlignType', 'auto,0|t,1|ctr,2|_base,3|b,4');
/**
 * @hidden
 */
export let ST_TextCapsType_$type = markEnum('ST_TextCapsType', 'none,0|small,1|all,2');
/**
 * @hidden
 */
export let ST_TextAnchoringType_$type = markEnum('ST_TextAnchoringType', 't,0|ctr,1|b,2|just,3|dist,4');
/**
 * @hidden
 */
export let ST_TextAlignType_$type = markEnum('ST_TextAlignType', 'l,0|ctr,1|r,2|just,3|justLow,4|dist,5|thaiDist,6');
/**
 * @hidden
 */
export let ST_SystemColorVal_$type = markEnum('ST_SystemColorVal', 'activeBorder,0|activeCaption,1|captionText,2|appWorkspace,3|btnFace,4|_3dDkShadow,5|btnShadow,6|_3dLight,7|btnHighlight,8|btnText,9|background,10|gradientActiveCaption,11|gradientInactiveCaption,12|grayText,13|highlight,14|highlightText,15|hotLight,16|inactiveBorder,17|inactiveCaption,18|inactiveCaptionText,19|infoText,20|infoBk,21|menu,22|menuBar,23|menuHighlight,24|menuText,25|scrollBar,26|window,27|windowFrame,28|windowText,29');
/**
 * @hidden
 */
export let ST_StrokeLineStyle_$type = markEnum('ST_StrokeLineStyle', 'single,0|thinThin,1|thinThick,2|thickThin,3|thickBetweenThin,4');
/**
 * @hidden
 */
export let ST_StrokeJoinStyle_$type = markEnum('ST_StrokeJoinStyle', 'round,0|bevel,1|miter,2');
/**
 * @hidden
 */
export let ST_StrokeEndCap_$type = markEnum('ST_StrokeEndCap', 'flat,0|square,1|round,2');
/**
 * @hidden
 */
export let ST_StrokeArrowWidth_$type = markEnum('ST_StrokeArrowWidth', 'narrow,0|medium,1|wide,2');
/**
 * @hidden
 */
export let ST_StrokeArrowType_$type = markEnum('ST_StrokeArrowType', 'none,0|block,1|classic,2|oval,3|diamond,4|open,5');
/**
 * @hidden
 */
export let ST_StrokeArrowLength_$type = markEnum('ST_StrokeArrowLength', '_short,0|medium,1|_long,2');
/**
 * @hidden
 */
export let ST_ShadowType_$type = markEnum('ST_ShadowType', 'single,0|_double,1|emboss,2|perspective,3');
/**
 * @hidden
 */
export let ST_SchemeColorVal_$type = markEnum('ST_SchemeColorVal', 'bg1,0|tx1,1|bg2,2|tx2,3|accent1,4|accent2,5|accent3,6|accent4,7|accent5,8|accent6,9|hlink,10|folHlink,11|phClr,12|dk1,13|lt1,14|dk2,15|lt2,16');
/**
 * @hidden
 */
export let ST_RectAlignment_$type = markEnum('ST_RectAlignment', 'tl,0|t,1|tr,2|l,3|ctr,4|r,5|bl,6|b,7|br,8');
/**
 * @hidden
 */
export let ST_PresetPatternVal_$type = markEnum('ST_PresetPatternVal', 'pct5,0|pct10,1|pct20,2|pct25,3|pct30,4|pct40,5|pct50,6|pct60,7|pct70,8|pct75,9|pct80,10|pct90,11|horz,12|vert,13|ltHorz,14|ltVert,15|dkHorz,16|dkVert,17|narHorz,18|narVert,19|dashHorz,20|dashVert,21|cross,22|dnDiag,23|upDiag,24|ltDnDiag,25|ltUpDiag,26|dkDnDiag,27|dkUpDiag,28|wdDnDiag,29|wdUpDiag,30|dashDnDiag,31|dashUpDiag,32|diagCross,33|smCheck,34|lgCheck,35|smGrid,36|lgGrid,37|dotGrid,38|smConfetti,39|lgConfetti,40|horzBrick,41|diagBrick,42|solidDmnd,43|openDmnd,44|dotDmnd,45|plaid,46|sphere,47|weave,48|divot,49|shingle,50|wave,51|trellis,52|zigZag,53');
/**
 * @hidden
 */
export let ST_PresetLineDashVal_$type = markEnum('ST_PresetLineDashVal', 'solid,0|dot,1|dash,2|lgDash,3|dashDot,4|lgDashDot,5|lgDashDotDot,6|sysDash,7|sysDot,8|sysDashDot,9|sysDashDotDot,10');
/**
 * @hidden
 */
export let ST_PresetColorVal_$type = markEnum('ST_PresetColorVal', 'aliceBlue,0|antiqueWhite,1|aqua,2|aquamarine,3|azure,4|beige,5|bisque,6|black,7|blanchedAlmond,8|blue,9|blueViolet,10|brown,11|burlyWood,12|cadetBlue,13|chartreuse,14|chocolate,15|coral,16|cornflowerBlue,17|cornsilk,18|crimson,19|cyan,20|dkBlue,21|dkCyan,22|dkGoldenrod,23|dkGray,24|dkGreen,25|dkKhaki,26|dkMagenta,27|dkOliveGreen,28|dkOrange,29|dkOrchid,30|dkRed,31|dkSalmon,32|dkSeaGreen,33|dkSlateBlue,34|dkSlateGray,35|dkTurquoise,36|dkViolet,37|deepPink,38|deepSkyBlue,39|dimGray,40|dodgerBlue,41|firebrick,42|floralWhite,43|forestGreen,44|fuchsia,45|gainsboro,46|ghostWhite,47|gold,48|goldenrod,49|gray,50|green,51|greenYellow,52|honeydew,53|hotPink,54|indianRed,55|indigo,56|ivory,57|khaki,58|lavender,59|lavenderBlush,60|lawnGreen,61|lemonChiffon,62|ltBlue,63|ltCoral,64|ltCyan,65|ltGoldenrodYellow,66|ltGray,67|ltGreen,68|ltPink,69|ltSalmon,70|ltSeaGreen,71|ltSkyBlue,72|ltSlateGray,73|ltSteelBlue,74|ltYellow,75|lime,76|limeGreen,77|linen,78|magenta,79|maroon,80|medAquamarine,81|medBlue,82|medOrchid,83|medPurple,84|medSeaGreen,85|medSlateBlue,86|medSpringGreen,87|medTurquoise,88|medVioletRed,89|midnightBlue,90|mintCream,91|mistyRose,92|moccasin,93|navajoWhite,94|navy,95|oldLace,96|olive,97|oliveDrab,98|orange,99|orangeRed,100|orchid,101|paleGoldenrod,102|paleGreen,103|paleTurquoise,104|paleVioletRed,105|papayaWhip,106|peachPuff,107|peru,108|pink,109|plum,110|powderBlue,111|purple,112|red,113|rosyBrown,114|royalBlue,115|saddleBrown,116|salmon,117|sandyBrown,118|seaGreen,119|seaShell,120|sienna,121|silver,122|skyBlue,123|slateBlue,124|slateGray,125|snow,126|springGreen,127|steelBlue,128|tan,129|teal,130|thistle,131|tomato,132|turquoise,133|violet,134|wheat,135|white,136|whiteSmoke,137|yellow,138|yellowGreen,139');
/**
 * @hidden
 */
export let ST_PenAlignment_$type = markEnum('ST_PenAlignment', 'ctr,0|_in,1');
/**
 * @hidden
 */
export let ST_PathFillMode_$type = markEnum('ST_PathFillMode', 'none,0|norm,1|lighten,2|lightenLess,3|darken,4|darkenLess,5');
/**
 * @hidden
 */
export let ST_LineEndType_$type = markEnum('ST_LineEndType', 'none,0|triangle,1|stealth,2|diamond,3|oval,4|arrow,5');
/**
 * @hidden
 */
export let ST_LineEndWidth_$type = markEnum('ST_LineEndWidth', 'sm,0|med,1|lg,2');
/**
 * @hidden
 */
export let ST_LineEndLength_$type = markEnum('ST_LineEndLength', 'sm,0|med,1|lg,2');
/**
 * @hidden
 */
export let ST_LineCap_$type = markEnum('ST_LineCap', 'rnd,0|sq,1|flat,2');
/**
 * @hidden
 */
export let ST_InsetMode_$type = markEnum('ST_InsetMode', 'auto,0|custom,1');
/**
 * @hidden
 */
export let ST_ImageAspect_$type = markEnum('ST_ImageAspect', 'ignore,0|atMost,1|atLeast,2');
/**
 * @hidden
 */
export let ST_HrAlign_$type = markEnum('ST_HrAlign', 'left,0|right,1|center,2');
/**
 * @hidden
 */
export let ST_FontCollectionIndex_$type = markEnum('ST_FontCollectionIndex', 'major,0|minor,1|none,2');
/**
 * @hidden
 */
export let ST_FillType_$type = markEnum('ST_FillType', 'gradientCenter,0|solid,1|pattern,2|tile,3|frame,4|gradientUnscaled,5|gradientRadial,6|gradient,7|background,8');
/**
 * @hidden
 */
export let ST_FillMethod_$type = markEnum('ST_FillMethod', 'none,0|linear,1|sigma,2|any,3|linearsigma,4');
/**
 * @hidden
 */
export let ST_Ext_$type = markEnum('ST_Ext', 'view,0|edit,1|backwardCompatible,2');
/**
 * @hidden
 */
export let ST_ConnectType_$type = markEnum('ST_ConnectType', 'none,0|rect,1|segments,2|custom,3');
/**
 * @hidden
 */
export let ST_ConnectorType_$type = markEnum('ST_ConnectorType', 'none,0|straight,1|elbow,2|curved,3');
/**
 * @hidden
 */
export let ST_ConformanceClass_$type = markEnum('ST_ConformanceClass', 'transitional,0|strict,1');
/**
 * @hidden
 */
export let ST_CompoundLine_$type = markEnum('ST_CompoundLine', 'sng,0|dbl,1|thickThin,2|thinThick,3|tri,4');
/**
 * @hidden
 */
export let ST_CF_$type = markEnum('ST_CF', 'PictOld,0|Pict,1|Bitmap,2|PictPrint,3|PictScreen,4');
/**
 * @hidden
 */
export let ST_BWMode_$type = markEnum('ST_BWMode', 'color,0|auto,1|grayScale,2|lightGrayscale,3|inverseGray,4|grayOutline,5|highContrast,6|black,7|white,8|hide,9|undrawn,10|blackTextAndLines,11');
/**
 * @hidden
 */
export let ST_BlipCompression_$type = markEnum('ST_BlipCompression', 'none,0|email,1|hqprint,2|print,3|screen,4');
/**
 * @hidden
 */
export let ST_BlackWhiteMode_$type = markEnum('ST_BlackWhiteMode', 'clr,0|auto,1|gray,2|ltGray,3|invGray,4|grayWhite,5|blackGray,6|blackWhite,7|black,8|white,9|hidden,10');
/**
 * @hidden
 */
export let XmlReadManager_AlternateContentStatus_$type = markEnum('XmlReadManager_AlternateContentStatus', 'NotInAlternateContent,0|InAlternateContentPendingAcceptableChoice,1|InAlternateContentChoiceAccepted,2');
/**
 * @hidden
 */
export let ElementPropertyIds_$type = markEnum('ElementPropertyIds', 'AbbreviatedCaseNumber,0|AbsSizeAnchor,1|AbsoluteAnchor,2|AbstractNum,3|AbstractNumId,4|Acc,5|AccPr,6|Accent1,7|Accent2,8|Accent3,9|Accent4,10|Accent5,11|Accent6,12|Active,13|ActiveRecord,14|ActiveTabTopLevelEntity,15|ActiveWritingStyle,16|AdditionalCharacteristics,17|Address,18|AddressFieldName,19|Adj,20|AdjustRightInd,21|Aggregation,22|AhLst,23|AlbumTitle,24|Align,25|AlignBordersAndEdges,26|Alignment,27|AllowPNG,28|Aln,29|AlnScr,30|Alpha,31|AlphaBiLevel,32|AlphaCeiling,33|AlphaFloor,34|AlphaInv,35|AlphaMod,36|AlphaModFix,37|AlphaOff,38|AlphaOutset,39|AlphaRepl,40|AltChunk,41|AltChunkPr,42|AlwaysMergeEmptyNamespace,43|AlwaysShowPlaceholderText,44|Anchor,45|Anchorlock,46|AnimLvl,47|AnimOne,48|AnnotationRef,49|ApplyToEnd,50|ApplyToFront,51|ApplyToSides,52|Arc,53|Area3DChart,54|AreaChart,55|ArgPr,56|ArgSz,57|Array,58|Artist,59|AttachedSchema,60|AttachedTemplate,61|Attr,62|AttrName,63|AttrNameLst,64|AudioCd,65|AudioFile,66|Author,67|Authors,68|Auto,69|AutoCaption,70|AutoCaptions,71|AutoFilter,72|AutoFormatOverride,73|AutoHyphenation,74|AutoSpaceDE,75|AutoSpaceDN,76|AutoSortScope,77|AutoTitleDeleted,78|AutoUpdate,79|AvLst,80|AxId,81|AxPos,82|AxisColor,83|AxisId,84|AxisTitle,85|B,86|BCs,87|BackWall,88|Backdrop,89|Background,90|Backward,91|Band1H,92|Band1V,93|Band2H,94|Band2V,95|BandFmt,96|BandFmts,97|Bar,98|Bar3DChart,99|BarChart,100|BarDir,101|BarPr,102|BaseJc,103|BaseTimeUnit,104|Bdr,105|BegChr,106|Between,107|Bevel,108|BevelB,109|BevelT,110|Bg,111|BgClr,112|BgColor,113|BgFillStyleLst,114|BgPr,115|BgRef,116|BiLevel,117|Bidi,118|BidiVisual,119|Binning,120|Bk,121|BldChart,122|BldDgm,123|BldLst,124|Blend,125|Blinds,126|Blip,127|BlipFill,128|Blob,129|BlockQuote,130|Blue,131|BlueMod,132|BlueOff,133|Blur,134|BodyDiv,135|BodyPr,136|BodyStyle,137|Bold,138|BoldItalic,139|BookAuthor,140|BookFoldPrinting,141|BookFoldPrintingSheets,142|BookFoldRevPrinting,143|BookTitle,144|BookViews,145|BookmarkEnd,146|BookmarkStart,147|Bool,148|Border,149|BorderBox,150|BorderBoxPr,151|BorderColor,152|Borderbottom,153|Borderleft,154|Borderright,155|Borders,156|BordersDoNotSurroundFooter,157|BordersDoNotSurroundHeader,158|Bordertop,159|Bottom,160|Bounds,161|Box,162|BoxPr,163|Br,164|Brk,165|BrkBin,166|BrkBinSub,167|BroadcastTitle,168|Broadcaster,169|Browse,170|Bstr,171|BuAutoNum,172|BuBlip,173|BuChar,174|BuClr,175|BuClrTx,176|BuFont,177|BuFontTx,178|BuNone,179|BuSzPct,180|BuSzPts,181|BuSzTx,182|Bubble3D,183|BubbleChart,184|BubbleScale,185|BubbleSize,186|BuiltInUnit,187|BulletEnabled,188|By,189|C,190|CalculatedItems,191|CalculatedMembers,192|CategoryFilterException,193|CBhvr,194|CGp,195|CGpRule,196|CMediaNode,197|CNvCxnSpPr,198|CNvGraphicFramePr,199|CNvGrpSpPr,200|CNvPicPr,201|CNvPr,202|CNvSpPr,203|CSld,204|CSldViewPr,205|CSp,206|CTn,207|CViewPr,208|CacheField,209|CacheFields,210|CacheHierarchy,211|CacheHierarchies,212|CacheSource,213|CachedUniqueName,214|CachedUniqueNames,215|CalcChain,216|CalcPr,217|CalculatedColumnFormula,218|CalculatedItem,219|CalculatedMember,220|CalculatedTimeColumn,221|Calendar,222|Callout,223|Camera,224|Caps,225|Caption,226|Captions,227|CaseNumber,228|Cat,229|CatAx,230|CatLst,231|CatScaling,232|CategoryAxis,233|Cell,234|Cell3D,235|CellDel,236|CellIns,237|CellMerge,238|CellMetadata,239|CellSmartTag,240|CellSmartTags,241|CellSmartTagPr,242|CellStyle,243|CellStyleXfs,244|CellStyles,245|CellWatch,246|CellWatches,247|CellXfs,248|Cf,249|CfIcon,250|CfRule,251|Cfvo,252|ChExt,253|ChMax,254|ChOff,255|ChPref,256|ChapterNumber,257|CharacterSpacingControl,258|Characteristic,259|Charset,260|Chart,261|ChartArea,262|ChartFormat,263|ChartFormats,264|ChartObject,265|ChartSpace,266|ChartStyle,267|Chartsheet,268|CheckErrors,269|Checked,270|Checker,271|ChildTnLst,272|Chr,273|Circle,274|City,275|ClickAndTypeStyle,276|ClientData,277|Clippath,278|ClrChange,279|ClrData,280|ClrFrom,281|ClrMap,282|ClrMapOvr,283|ClrMru,284|ClrRepl,285|ClrScheme,286|ClrSchemeMapping,287|ClrTo,288|Clsid,289|Cm,290|CmAuthor,291|CmAuthorLst,292|CmLst,293|CnfStyle,294|Col,295|ColBreaks,296|ColDelim,297|ColFields,298|ColHierarchiesUsage,299|ColHierarchyUsage,300|ColItems,301|Color,302|ColorAxis,303|ColorFirst,304|ColorHigh,305|ColorLast,306|ColorLow,307|ColorMarkers,308|ColorNegative,309|ColorScale,310|ColorSeries,311|ColorStyle,312|Colors,313|ColorsDef,314|ColorsDefHdr,315|ColorsDefHdrLst,316|Cols,317|Column,318|Comb,319|Comment,320|CommentList,321|CommentRangeEnd,322|CommentRangeStart,323|CommentReference,324|Comments,325|Comp,326|Compat,327|Compiler,328|Complex,329|Composer,330|Cond,331|Condense,332|ConditionalFormat,333|ConditionalFormats,334|ConditionalFormatting,335|ConditionalFormattings,336|Conductor,337|ConferenceName,338|ConnectString,339|Connection,340|Connections,341|ConsecutiveHyphenLimit,342|Constr,343|Cont,344|ContextualSpacing,345|ContinuationSeparator,346|ContourClr,347|Control,348|Controls,349|Copyright,350|Copyrights,351|Corporate,352|Counsel,353|Count,354|CountryRegion,355|Court,356|Cover,357|Cr,358|CrossAx,359|CrossBetween,360|Crosses,361|CrossesAt,362|Cs,363|CtrlPr,364|Curve,365|CustClr,366|CustClrLst,367|CustDash,368|CustData,369|CustDataLst,370|CustGeom,371|CustShow,372|CustShowLst,373|CustSplit,374|CustUnit,375|CustomFilter,376|CustomFilters,377|CustomPr,378|CustomProperties,379|CustomSheetView,380|CustomSheetViews,381|CustomWorkbookView,382|CustomWorkbookViews,383|CustomXmlDelRangeEnd,384|CustomXmlDelRangeStart,385|CustomXmlInsRangeEnd,386|CustomXmlInsRangeStart,387|CustomXmlMoveFromRangeEnd,388|CustomXmlMoveFromRangeStart,389|CustomXmlMoveToRangeEnd,390|CustomXmlMoveToRangeStart,391|CustomXmlPr,392|Cut,393|Cxn,394|CxnLst,395|CxnSp,396|CxnSpLocks,397|Cy,398|D,399|DdeLink,400|DLbl,401|DlblFieldTableCache,402|DlblFTEntry,403|DLblPos,404|DlblRangeCache,405|DLbls,406|DPr,407|DPt,408|DTable,409|Data,410|DataBar,411|DataBinding,412|DataConsolidate,413|DataField,414|DataFields,415|DataId,416|DataLabel,417|DataLabelCallout,418|DataLabelHidden,419|DataLabels,420|DataLabelsRange,421|DataModel,422|DataPoint,423|DataPoint3D,424|DataPointLine,425|DataPointMarker,426|DataPointMarkerLayout,427|DataPointWireframe,428|DataPt,429|DataRef,430|DataRefs,431|DataSource,432|DataTable,433|DataType,434|DataValidation,435|DataValidations,436|DatastoreItem,437|Date,438|Date1904,439|DateAx,440|DateFormat,441|DateGroupItem,442|Day,443|DayAccessed,444|DayLong,445|DayShort,446|DbTable,447|DbTables,448|DdeItem,449|DdeItems,450|Decimal,451|DecimalSymbol,452|DefJc,453|DefPPr,454|DefRPr,455|Default,456|DefaultTabStop,457|DefaultTableStyle,458|DefaultTextStyle,459|DefinedName,460|DefinedNames,461|Deg,462|DegHide,463|Del,464|DelInstrText,465|DelText,466|Delete:del,467|DeletedField,468|Den,469|Department,470|DepthPercent,471|Desc,472|DescriptionPr,473|Destination,474|Dgm,475|Diagonal,476|Diagram,477|Dialogsheet,478|Diamond,479|Diff,480|Dimension,481|Dimensions,482|Dir,483|Director,484|Dirty,485|DiscretePr,486|DispBlanksAs,487|DispDef,488|DispEq,489|DispRSqr,490|DispUnits,491|DispUnitsLbl,492|DisplayBackgroundShape,493|DisplayHorizontalDrawingGridEvery,494|DisplayVerticalDrawingGridEvery,495|Dissolve,496|Distributor,497|Div,498|DivBdr,499|DivId,500|Divs,501|DivsChild,502|Dk1,503|Dk2,504|DoNotAutoCompressPictures,505|DoNotDemarcateInvalidXml,506|DoNotDisplayPageBoundaries,507|DoNotEmbedSmartTags,508|DoNotHyphenateCaps,509|DoNotIncludeSubdocsInStats,510|DoNotOrganizeInFolder,511|DoNotRelyOnCSS,512|DoNotSaveAsSingleFile,513|DoNotShadeFormData,514|DoNotSuppressBlankLines,515|DoNotTrackFormatting,516|DoNotTrackMoves,517|DoNotUseLongFileNames,518|DoNotUseMarginsForDrawingGridOrigin,519|DoNotValidateAgainstSchema,520|DocDefaults,521|DocGrid,522|DocPartBody,523|DocPartCategory,524|DocPartGallery,525|DocPartPr,526|DocPartUnique,527|DocPr,528|DocVar,529|DocVars,530|Document,531|DocumentProtection,532|DocumentType,533|DoughnutChart,534|DownBar,535|DownBars,536|Drawing,537|DrawingGridHorizontalOrigin,538|DrawingGridHorizontalSpacing,539|DrawingGridVerticalOrigin,540|DrawingGridVerticalSpacing,541|DropLine,542|DropLines,543|Ds,544|Dstrike,545|Duotone,546|Dxf,547|Dxfs,548|DynamicAddress,549|E,550|Ea,551|EastAsianLayout,552|EditValue,553|Edition,554|Editor,555|Effect,556|EffectClrLst,557|EffectDag,558|EffectExtent,559|EffectLst,560|EffectRef,561|EffectStyle,562|EffectStyleLst,563|Else,564|Em,565|EmbedSystemFonts,566|EmbedTrueTypeFonts,567|EmbeddedFont,568|EmbeddedFontLst,569|Emboss,570|Empty,571|Encoding,572|End,573|EndChr,574|EndCondLst,575|EndCxn,576|EndParaRPr,577|EndSync,578|Endnote,579|EndnotePr,580|EndnoteRef,581|EndnoteReference,582|Endnotes,583|EntityType,584|Entries,585|Entry,586|EqArr,587|EqArrPr,588|ErrBarType,589|ErrBars,590|ErrDir,591|ErrValType,592|Error,593|ErrorBar,594|EvenAndOddHeaders,595|EvenFooter,596|EvenHeader,597|Explosion,598|Ext,599|Extend,600|ExtLst,601|Extent,602|ExternalBook,603|ExternalData,604|ExternalLink,605|ExternalReference,606|ExternalReferences,607|ExtraClrScheme,608|ExtraClrSchemeLst,609|Extrusion,610|ExtrusionClr,611|F,612|FHdr,613|FName,614|FPr,615|Fade,616|Family,617|FgClr,618|FgColor,619|Field,620|FieldCodes,621|FieldGroup,622|FieldMapData,623|FieldUsage,624|FieldsUsage,625|FileRecoveryPr,626|FileSharing,627|FileVersion,628|Filetime,629|Fill,630|FillClrLst,631|FillColor,632|FillOverlay,633|FillRect,634|FillRef,635|FillStyleLst,636|FillToRect,637|Fills,638|Filter,639|FilterColumn,640|Filters,641|First,642|FirstCol,643|FirstFooter,644|FirstHeader,645|FirstRow,646|FirstSliceAng,647|FitText,648|FlatBorders,649|FlatTx,650|Fld,651|FldChar,652|FldData,653|Floor,654|FmtId,655|FmtOvr,656|FmtScheme,657|FolHlink,658|Font,659|FontRef,660|FontScheme,661|Fonts,662|FooterReference,663|Footnote,664|FootnotePr,665|FootnoteRef,666|FootnoteReference,667|Footnotes,668|ForceUpgrade,669|FormControlPr,670|FormProt,671|Format,672|FormatCode,673|Formats,674|Formatting,675|FormsDesign,676|Formula,677|Formula1,678|Formula2,679|Formulas,680|Forward,681|Frame,682|FrameLayout,683|FramePr,684|Frameset,685|FramesetSplitbar,686|From,687|Ftr,688|Func,689|FuncPr,690|FunctionGroup,691|FunctionGroups,692|FutureMetadata,693|Gallery,694|Gamma,695|GapDepth,696|GapWidth,697|Gd,698|GdLst,699|GeoCache,700|GeoChildEntities,701|GeoChildEntitiesQuery,702|GeoChildEntitiesQueryResult,703|GeoChildEntitiesQueryResults,704|GeoChildTypes,705|GeoData,706|GeoDataEntityQuery,707|GeoDataEntityQueryResult,708|GeoDataEntityQueryResults,709|GeoDataPointQuery,710|GeoDataPointToEntityQuery,711|GeoDataPointToEntityQueryResult,712|GeoDataPointToEntityQueryResults,713|GeoHierarchyEntity,714|GeoLocation,715|GeoLocationQuery,716|GeoLocationQueryResult,717|GeoLocationQueryResults,718|GeoLocations,719|GeoPolygon,720|GeoPolygons,721|Geography,722|GlossaryDocument,723|Glow,724|GradFill,725|GradientFill,726|Graphic,727|GraphicData,728|GraphicFrame,729|GraphicFrameLocks,730|Gray,731|Grayscl,732|Green,733|GreenMod,734|GreenOff,735|GridCol,736|GridSpacing,737|GridSpan,738|GridlineMajor,739|GridlineMinor,740|Group,741|GroupChr,742|GroupChrPr,743|GroupItems,744|GroupLevel,745|GroupLevels,746|GroupMember,747|GroupMembers,748|Grouping,749|Groups,750|Grow,751|GrpFill,752|GrpSp,753|GrpSpLocks,754|GrpSpPr,755|Gs,756|GsLst,757|Guid,758|Guide,759|GuideLst,760|GutterAtTop,761|H,762|HMerge,763|HMode,764|HPercent,765|Handles,766|HandoutMaster,767|HandoutMasterId,768|HandoutMasterIdLst,769|Hdr,770|HdrShapeDefaults,771|HeadEnd,772|Header,773|HeaderFooter,774|HeaderReference,775|HeaderSource,776|Headers,777|Hf,778|HiLoLine,779|HiLowLines,780|HideBot,781|HideGrammaticalErrors,782|HideLeft,783|HideMark,784|HideRight,785|HideSpellingErrors,786|HideTop,787|HierBranch,788|Highlight,789|Hlink,790|HlinkClick,791|HlinkHover,792|HlinkMouseOver,793|HoleSize,794|Horizontal,795|Hps,796|HpsBaseText,797|HpsRaise,798|Hsl,799|HslClr,800|HtmlPubPr,801|Hue,802|HueMod,803|HueOff,804|Hyperlink,805|Hyperlinks,806|HyphenationZone,807|I,808|I1,809|I2,810|I4,811|I8,812|ICs,813|IconFilter,814|IconSet,815|Id,816|Idx,817|If,818|IgnoreMixedContent,819|IgnoredError,820|IgnoredErrors,821|Ilvl,822|Image,823|Imagedata,824|Imprint,825|Ind,826|IndexedColors,827|Ink,828|Inline,829|InnerShdw,830|InputCells,831|Ins,832|InsideH,833|InsideV,834|Institution,835|InstrText,836|Int,837|IntLim,838|InterSp,839|Intercept,840|InternetSiteTitle,841|Interviewee,842|Interviewer,843|IntraSp,844|Inv,845|InvGamma,846|Inventor,847|InvertIfNegative,848|Is,849|Iscomment,850|Issue,851|Italic,852|Item,853|ItemLst,854|Items,855|Iterate,856|Jc,857|JournalName,858|K,859|KeepLines,860|KeepNext,861|Kern,862|Kinsoku,863|Kiosk,864|Kpi,865|Kpis,866|LCID,867|LMargin,868|Lang,869|Last,870|LastCol,871|LastRenderedPageBreak,872|LastRow,873|LatentStyles,874|Latin,875|Layout,876|LayoutDef,877|LayoutDefHdr,878|LayoutDefHdrLst,879|LayoutNode,880|LayoutPr,881|LayoutTarget,882|LblAlgn,883|LblOffset,884|LeaderLine,885|LeaderLines,886|Left,887|LegacyDrawing,888|LegacyDrawingHF,889|Legend,890|LegendEntry,891|LegendPos,892|Level,893|Levels,894|Lid,895|LightRig,896|Lim,897|LimLoc,898|LimLow,899|LimLowPr,900|LimUpp,901|LimUppPr,902|Lin,903|LinClrLst,904|Line,905|Line3DChart,906|LineChart,907|LineTo,908|LineWidthScale,909|LinkStyles,910|LinkToQuery,911|LinkType,912|LinkedToFile,913|ListEntry,914|ListItem,915|ListSeparator,916|Lit,917|Ln,918|LnB,919|LnBlToTr,920|LnDef,921|LnL,922|LnNumType,923|LnR,924|LnRef,925|LnSpc,926|LnStyleLst,927|LnT,928|LnTlToBr,929|Location,930|Lock,931|LockedCanvas,932|LockedField,933|LogBase,934|Lpstr,935|Lpwstr,936|LsdException,937|LstStyle,938|Lt1,939|Lt2,940|Lum,941|LumMod,942|LumOff,943|Lvl,944|Lvl1pPr,945|Lvl2pPr,946|Lvl3pPr,947|Lvl4pPr,948|Lvl5pPr,949|Lvl6pPr,950|Lvl7pPr,951|Lvl8pPr,952|Lvl9pPr,953|LvlOverride,954|M,955|MPr,956|MailAsAttachment,957|MailMerge,958|MailSubject,959|Main,960|MainDocumentType,961|MajorFont,962|MajorGridlines,963|MajorTickMark,964|MajorTickMarks,965|MajorTimeUnit,966|MajorUnit,967|ManualLayout,968|Map,969|Maps,970|MapInfo,971|MappedName,972|MarBottom,973|MarH,974|MarLeft,975|MarRight,976|MarTop,977|MarW,978|Marker,979|MasterClrMapping,980|MatchSrc,981|MathFont,982|MathPr,983|Max,984|MaxColor,985|MaxDist,986|MaxLength,987|Mc,988|McJc,989|McPr,990|Mcs,991|Mdx,992|MdxMetadata,993|MeasureGroup,994|MeasureGroups,995|Medium,996|Member,997|Members,998|MergeCell,999|MergeCells,1000|Metadata,1001|MetadataStrings,1002|MetadataType,1003|MetadataTypes,1004|Mid,1005|MidColor,1006|Middle,1007|Min,1008|MinColor,1009|MinorFont,1010|MinorGridlines,1011|MinorTickMark,1012|MinorTickMarks,1013|MinorTimeUnit,1014|MinorUnit,1015|Minus,1016|MirrorIndents,1017|MirrorMargins,1018|Miter,1019|ModelRelationship,1020|ModelTable,1021|ModelTimeGrouping,1022|ModelTimeGroupings,1023|ModifyVerifier,1024|Month,1025|MonthAccessed,1026|MonthLong,1027|MonthShort,1028|MoveFrom,1029|MoveFromRangeEnd,1030|MoveFromRangeStart,1031|MoveTo,1032|MoveToRangeEnd,1033|MoveToRangeStart,1034|Mp,1035|Mps,1036|MpMap,1037|Mr,1038|MruColors,1039|Ms,1040|MultiLevelType,1041|MultiLvlStrCache,1042|MultiLvlStrRef,1043|N,1044|Name:Name1,1045|NameList,1046|Nary,1047|NaryLim,1048|NaryPr,1049|Nc,1050|Ndxf,1051|NeCell,1052|NegativeBorderColor,1053|NegativeFillColor,1054|Newsflash,1055|NextCondLst,1056|NoAutofit,1057|NoBorder,1058|NoBreak,1059|NoBreakHyphen,1060|NoEndCap,1061|NoEndnote,1062|NoFill,1063|NoLineBreaksAfter,1064|NoLineBreaksBefore,1065|NoMultiLvlLbl,1066|NoProof,1067|NoPunctuationKerning,1068|NoResizeAllowed,1069|NoWrap,1070|Nor,1071|Norm,1072|NormAutofit,1073|NormalViewPr,1074|Notes,1075|NotesMaster,1076|NotesMasterId,1077|NotesMasterIdLst,1078|NotesStyle,1079|NotesSz,1080|NotesTextViewPr,1081|NotesViewPr,1082|Nsid,1083|Null,1084|Num,1085|NumCache,1086|NumDim,1087|NumFmt,1088|NumFmts,1089|NumId,1090|NumIdMacAtCleanup,1091|NumLit,1092|NumPicBullet,1093|NumPr,1094|NumRef,1095|NumRestart,1096|NumStart,1097|NumStyleLink,1098|NumberVolumes,1099|Numbering,1100|NumberingChange,1101|NvCxnSpPr,1102|NvGraphicFramePr,1103|NvGrpSpPr,1104|NvPicPr,1105|NvSpPr,1106|NwCell,1107|OLEObject,1108|OMath,1109|OMathPara,1110|OMathParaPr,1111|ObjDist,1112|Object:object1,1113|ObjectDefaults,1114|Oblob,1115|Oc,1116|OddFooter,1117|OddHeader,1118|Odso,1119|Odxf,1120|OfPieChart,1121|OfPieType,1122|Off,1123|OldFormula,1124|OleItem,1125|OleItems,1126|OleLink,1127|OleObj,1128|OleObject,1129|OleObjects,1130|OleSize,1131|OneCellAnchor,1132|OpEmu,1133|OptimizeForBrowser,1134|Order,1135|OrgChart,1136|Orientation,1137|Origin,1138|Ostorage,1139|Ostream,1140|OtherStyle,1141|OuterShdw,1142|Outline,1143|OutlineLvl,1144|OutlinePr,1145|OutlineViewPr,1146|Oval,1147|OverflowPunct,1148|Overlap,1149|Overlay,1150|OverrideClrMapping,1151|P,1152|PBdr,1153|PPr,1154|PPrDefault,1155|PStyle,1156|Page,1157|PageBreakBefore,1158|PageField,1159|PageFields,1160|PageItem,1161|PageMargins,1162|PageSetUpPr,1163|PageSetup,1164|Pages,1165|Pane,1166|PaperSrc,1167|Param,1168|Parameter,1169|ParentLabelLayout,1170|PatentNumber,1171|Path,1172|PathLst,1173|PattFill,1174|PatternFill,1175|PenClr,1176|Performer,1177|Period,1178|PeriodicalTitle,1179|PermEnd,1180|PermStart,1181|Person,1182|Perspective,1183|PgBorders,1184|PgMar,1185|PgNum,1186|PgNumType,1187|PgSz,1188|Ph,1189|Phant,1190|PhantPr,1191|PhoneticPr,1192|PhotoAlbum,1193|Pic,1194|PicLocks,1195|Pict,1196|Picture,1197|PictureFormat,1198|PictureOptions,1199|PictureStackUnit,1200|Pie3DChart,1201|PieChart,1202|PivotArea,1203|PivotAreas,1204|PivotCache,1205|PivotCacheDefinition,1206|PivotCacheIdVersion,1207|PivotCacheRecords,1208|PivotCaches,1209|PivotChange,1210|PivotChanges,1211|PivotEdit,1212|PivotEdits,1213|PivotField,1214|PivotFields,1215|PivotFilter,1216|PivotFmt,1217|PivotFmts,1218|PivotHierarchies,1219|PivotHierarchy,1220|PivotRow,1221|PivotSelection,1222|PivotSource,1223|PivotTable,1224|PivotTableData,1225|PivotTableDefinition,1226|PivotTableReference,1227|PivotTableReferences,1228|PivotTableStyleInfo,1229|PivotTableUISettings,1230|PivotTables,1231|PixelsPerInch,1232|Placeholder,1233|PlcHide,1234|PlotArea,1235|PlotArea3D,1236|PlotSurface,1237|PlotVisOnly,1238|Plus,1239|Polyline,1240|Pos,1241|PosOffset,1242|Position,1243|PositionH,1244|PositionV,1245|PostSp,1246|PrSet,1247|PreSp,1248|PresLayoutVars,1249|Present,1250|Presentation,1251|PresentationPr,1252|PrevCondLst,1253|PrintFormsData,1254|PrintFractionalCharacterWidth,1255|PrintOptions,1256|PrintPostScriptOverText,1257|PrintSettings,1258|PrintTwoOnOne,1259|PrinterSettings,1260|PrnPr,1261|ProducerName,1262|ProductionCompany,1263|Progress,1264|ProofErr,1265|ProofState,1266|Properties,1267|Property,1268|ProtectedRange,1269|ProtectedRanges,1270|Protection,1271|PrstClr,1272|PrstDash,1273|PrstGeom,1274|PrstShdw,1275|PrstTxWarp,1276|Pt,1277|PtCount,1278|PtLst,1279|Ptab,1280|PublicationTitle,1281|Publisher,1282|Pull,1283|Push,1284|Query,1285|QueryCache,1286|QueryTable,1287|QueryTableDeletedFields,1288|QueryTableField,1289|QueryTableFields,1290|QueryTableRefresh,1291|Question,1292|QuestionPr,1293|Questions,1294|QuestionsPr,1295|QuickTimeFile,1296|R,1297|R4,1298|R8,1299|RAngAx,1300|RCtr,1301|RFonts,1302|RMargin,1303|RPh,1304|RPr,1305|RPrChange,1306|RPrDefault,1307|RSp,1308|RSpRule,1309|RStyle,1310|Rad,1311|RadPr,1312|RadarChart,1313|RadarStyle,1314|Random,1315|RandomBar,1316|Range,1317|RangePr,1318|RangeSet,1319|RangeSets,1320|Ranges,1321|Rc,1322|Rcc,1323|Rcmt,1324|Rcv,1325|ReadModeInkLockDown,1326|RecipientData,1327|Recipients,1328|RecordingNumber,1329|Rect,1330|Red,1331|RedMod,1332|RedOff,1333|Ref,1334|RefOrder,1335|Reference,1336|References,1337|Reflection,1338|RegionLabelLayout,1339|Regular,1340|Rel,1341|RelIds,1342|RelOff,1343|RelSizeAnchor,1344|Relationtable,1345|RelyOnVML,1346|RemoveDateAndTime,1347|RemovePersonalInformation,1348|Reporter,1349|ResizeHandles,1350|RestoredLeft,1351|RestoredTop,1352|Result,1353|Reviewed,1354|ReviewedList,1355|RevisionPtr,1356|RevisionView,1357|Revisions,1358|Rfmt,1359|RFont,1360|RgbColor,1361|Rich,1362|Right,1363|Ris,1364|Raf,1365|Rdn,1366|Rcft,1367|Rqt,1368|Rm,1369|Rot,1370|RotX,1371|RotY,1372|Round,1373|RoundedCorners,1374|Roundrect,1375|Row,1376|RowBreaks,1377|RowFields,1378|RowHierarchiesUsage,1379|RowHierarchyUsage,1380|RowItem,1381|RowItems,1382|Rows,1383|Rrc,1384|Rsid,1385|RsidRoot,1386|Rsids,1387|Rsnm,1388|Rt,1389|Rtl,1390|RtlGutter,1391|Ruby,1392|RubyAlign,1393|RubyBase,1394|RubyPr,1395|Rule,1396|S,1397|SPre,1398|SPrePr,1399|SSub,1400|SSubPr,1401|SSubSup,1402|SSubSupPr,1403|SSup,1404|SSupPr,1405|SampData,1406|Sat,1407|SatMod,1408|SatOff,1409|SaveFormsData,1410|SaveInvalidXml,1411|SavePreviewPicture,1412|SaveSmartTagsAsXml,1413|SaveSubsetFonts,1414|SaveThroughXslt,1415|SaveXmlDataOnly,1416|Scale,1417|Scaling,1418|ScatterChart,1419|ScatterStyle,1420|Scenario,1421|Scenarios,1422|Scene3d,1423|Schema,1424|SchemaLibrary,1425|SchemaRef,1426|SchemaRefs,1427|Scheme,1428|SchemeClr,1429|Scr,1430|ScrgbClr,1431|Scrollbar,1432|Sdt,1433|SdtContent,1434|SdtEndPr,1435|SdtPr,1436|SeCell,1437|SecondPiePt,1438|SecondPieSize,1439|SectPr,1440|SectPrChange,1441|Selection,1442|Selections,1443|SepChr,1444|Separator,1445|Ser,1446|SerAx,1447|SerLines,1448|Series,1449|SeriesAxis,1450|SeriesLine,1451|ServerFormat,1452|ServerFormats,1453|Set,1454|SetLevel,1455|SetLevels,1456|Sets,1457|Settings,1458|Shade,1459|Shadow,1460|Shape,1461|ShapeDefaults,1462|Shapedefaults,1463|Shapelayout,1464|Shapetype,1465|SharedItems,1466|Shd,1467|Sheet,1468|SheetCalcPr,1469|SheetData,1470|SheetDataSet,1471|SheetFormatPr,1472|SheetId,1473|SheetIdMap,1474|SheetName,1475|SheetNames,1476|SheetPr,1477|SheetProtection,1478|SheetView,1479|SheetViews,1480|Sheets,1481|ShortTitle,1482|Show,1483|ShowBubbleSize,1484|ShowCatName,1485|ShowDataLabelsRange,1486|ShowDLblsOverMax,1487|ShowEnvelope,1488|ShowHorzBorder,1489|ShowKeys,1490|ShowLeaderLines,1491|ShowLegendKey,1492|ShowNegBubbles,1493|ShowOutline,1494|ShowPercent,1495|ShowPr,1496|ShowSerName,1497|ShowVal,1498|ShowVertBorder,1499|ShowXMLTags,1500|Shp,1501|Si,1502|SideWall,1503|Signatureline,1504|SimplePos,1505|SingleXmlCell,1506|SingleXmlCells,1507|Size,1508|SizeAuto,1509|SizeRepresents,1510|Skew,1511|Sld,1512|SldAll,1513|SldId,1514|SldIdLst,1515|SldLayout,1516|SldLayoutId,1517|SldLayoutIdLst,1518|SldLst,1519|SldMaster,1520|SldMasterId,1521|SldMasterIdLst,1522|SldRg,1523|SldSyncPr,1524|SldSz,1525|Slicer,1526|SlicerCache,1527|SlicerCacheDefinition,1528|SlicerCacheHideItemsWithNoData,1529|SlicerCacheOlapLevelName,1530|SlicerCachePivotTables,1531|SlicerCaches,1532|SlicerList,1533|SlicerStyle,1534|SlicerStyleElement,1535|SlicerStyleElements,1536|SlicerStyles,1537|Slicers,1538|SlideViewPr,1539|SmallCaps,1540|SmallFrac,1541|SmartTag,1542|SmartTagPr,1543|SmartTagType,1544|SmartTagTypes,1545|SmartTags,1546|Smooth,1547|SnapToGrid,1548|Snd,1549|SndAc,1550|SoftEdge,1551|SoftHyphen,1552|SolidFill,1553|SortByTuple,1554|SortCondition,1555|SortState,1556|SorterViewPr,1557|Source,1558|SourceConnection,1559|SourceFileName,1560|SourceType,1561|Sources,1562|Sp,1563|Sp3d,1564|SpAutoFit,1565|SpcPct,1566|SpcPts,1567|SpDef,1568|SpLocks,1569|SpPr,1570|SpTree,1571|Spacing,1572|Sparkline,1573|SparklineGroup,1574|SparklineGroups,1575|Sparklines,1576|SpcAft,1577|SpcBef,1578|SpecVanish,1579|Split,1580|SplitPos,1581|SplitType,1582|Sqref,1583|Src,1584|SrcRect,1585|SrgbClr,1586|Sst,1587|St,1588|StCondLst,1589|StCxn,1590|StandardNumber,1591|Start,1592|StartOverride,1593|State,1594|StateProvince,1595|Station,1596|Statistics,1597|StockChart,1598|Stop,1599|Storage,1600|StoreMappedDataAs,1601|Stp,1602|StrCache,1603|StrDim,1604|StrLit,1605|StrRef,1606|Stream,1607|Stretch,1608|StrictFirstAndLastChars,1609|Strike,1610|StrikeBLTR,1611|StrikeH,1612|StrikeTLBR,1613|StrikeV,1614|Strips,1615|Stroke,1616|Sty,1617|Style,1618|StyleClr,1619|StyleData,1620|StyleDef,1621|StyleDefHdr,1622|StyleDefHdrLst,1623|StyleLbl,1624|StyleLink,1625|StyleLockQFSet,1626|StyleLockTheme,1627|StylePaneFormatFilter,1628|StylePaneSortMethod,1629|StyleSheet,1630|Styles,1631|Sub,1632|SubDoc,1633|SubHide,1634|SubTnLst,1635|Subtotals,1636|SummaryLength,1637|Sup,1638|SupHide,1639|SuppressAutoHyphens,1640|SuppressLineNumbers,1641|SuppressOverlap,1642|Surface3DChart,1643|SurfaceChart,1644|Survey,1645|SurveyPr,1646|SwCell,1647|Sx,1648|Sy,1649|Sym,1650|Symbol,1651|SysClr,1652|Sz,1653|SzCs,1654|T,1655|Tab,1656|TabColor,1657|TabLst,1658|Table,1659|TableColumn,1660|TableColumns,1661|TablePart,1662|TableParts,1663|TableSlicerCache,1664|TableStyle,1665|TableStyleElement,1666|TableStyleId,1667|TableStyleInfo,1668|TableStyles,1669|Tables,1670|Tabs,1671|Tag,1672|TagLst,1673|Tags,1674|TailEnd,1675|TargetScreenSz,1676|Tav,1677|TavLst,1678|Tbl,1679|TblBg,1680|TblBorders,1681|TblCellMar,1682|TblCellSpacing,1683|TblGrid,1684|TblInd,1685|TblLayout,1686|TblLook,1687|TblOverlap,1688|TblPr,1689|TblStyle,1690|TblStyleColBandSize,1691|TblStyleLst,1692|TblStyleRowBandSize,1693|TblW,1694|TblpPr,1695|Tc,1696|TcBdr,1697|TcBorders,1698|TcFitText,1699|TcMar,1700|TcPr,1701|TcStyle,1702|TcTxStyle,1703|TcW,1704|Text,1705|TextAlignment,1706|TextDirection,1707|TextField,1708|TextFields,1709|Textbox,1710|TextboxTightWrap,1711|Textdata,1712|Textpath,1713|TgtEl,1714|Theater,1715|Theme,1716|ThemeElements,1717|ThemeFontLang,1718|ThemeManager,1719|ThemeOverride,1720|ThesisType,1721|Thickness,1722|TickLabels,1723|TickLblPos,1724|TickLblSkip,1725|TickMarkSkip,1726|Tile,1727|TileRect,1728|Timeline,1729|TimelineCacheDefinition,1730|TimelineCachePivotCaches,1731|TimelineCacheRef,1732|TimelineCacheRefs,1733|TimelinePivotCacheDefinition,1734|TimelinePivotFilter,1735|TimelineRef,1736|TimelineRefs,1737|TimelineStyle,1738|TimelineStyleElement,1739|TimelineStyleElements,1740|TimelineStyles,1741|Timelines,1742|Timing,1743|Tint,1744|Title,1745|TitlePg,1746|TitlePr,1747|TitleStyle,1748|Tl2br,1749|Tmpl,1750|TmplLst,1751|TnLst,1752|To,1753|Top,1754|TopLinePunct,1755|TotalsRowFormula,1756|Tp,1757|Tpl,1758|Tpls,1759|Tr,1760|Tr2bl,1761|TrPr,1762|TrackRevisions,1763|Transition,1764|Translator,1765|Transp,1766|Trendline,1767|TrendlineLabel,1768|TrendlineLbl,1769|TrendlineType,1770|TupleCache,1771|TupleItem,1772|TupleItems,1773|TupleSet,1774|TwoCellAnchor,1775|Tx,1776|TxBody,1777|TxData,1778|TxDef,1779|TxEffectClrLst,1780|TxFillClrLst,1781|TxLinClrLst,1782|TxPr,1783|TxSp,1784|TxStyles,1785|TxbxContent,1786|TxfldGUID,1787|Type,1788|U,1789|UFill,1790|UFillTx,1791|ULn,1792|ULnTx,1793|Undo,1794|URL,1795|Udl,1796|Ui1,1797|Ui2,1798|Ui4,1799|Ui8,1800|UiCompat97To2003,1801|Uint,1802|UniqueTag,1803|Units,1804|UnitsLabel,1805|Up,1806|UpBar,1807|UpBars,1808|UpDownBars,1809|UpdateFields,1810|UseSpRect,1811|UseXSLTWhenSaving,1812|UserEdit,1813|UserInfo,1814|UserInterface,1815|UserShapes,1816|Users,1817|V,1818|VAlign,1819|VMerge,1820|Val,1821|ValAx,1822|ValScaling,1823|Value,1824|ValueAxis,1825|ValueColorPositions,1826|ValueColors,1827|ValueMetadata,1828|Values,1829|Vanish,1830|Variant,1831|Variation,1832|VaryColors,1833|Vector,1834|Version,1835|VertAlign,1836|VertJc,1837|Vertical,1838|VideoFile,1839|View,1840|View3D,1841|ViewMergedData,1842|ViewPr,1843|Visibility,1844|VolType,1845|VolTypes,1846|Volume,1847|Vstream,1848|W,1849|WMode,1850|Wall,1851|WavAudioFile,1852|WebExtension,1853|WebExtensions,1854|WebHidden,1855|WebPr,1856|WebPublishItem,1857|WebPublishItems,1858|WebPublishObject,1859|WebPublishObjects,1860|WebPublishing,1861|WebSettings,1862|Wedge,1863|Wheel,1864|Whole,1865|WholeTbl,1866|WidowControl,1867|Wipe,1868|Wireframe,1869|WordWrap,1870|Workbook,1871|WorkbookPr,1872|WorkbookProtection,1873|WorkbookView,1874|Worksheet,1875|Wrap,1876|WrapIndent,1877|WrapNone,1878|WrapPolygon,1879|WrapRight,1880|WrapSquare,1881|WrapThrough,1882|WrapTight,1883|WrapTopAndBottom,1884|WriteProtection,1885|Writer,1886|WsDr,1887|X,1888|XMode,1889|XVal,1890|Xf,1891|Xfrm,1892|XmlCellPr,1893|XmlColumnPr,1894|XmlPr,1895|Y,1896|YMode,1897|YVal,1898|Year,1899|YearAccessed,1900|YearLong,1901|YearShort,1902|ZeroAsc,1903|ZeroDesc,1904|ZeroWid,1905|Zoom,1906|Nf,1907|ChartData,1908|FmtOvrs,1909|BinSize,1910|BinCount,1911|Number,1912|Percent,1913|ExtremeValue,1914|PlotAreaRegion,1915|Axis,1916|Binary,1917|Clear,1918');
/**
 * @hidden
 */
export let UnknownElementAction_$type = markEnum('UnknownElementAction', 'Ignore,0|CacheXml,1|CacheStructure,2|LoadChildrenNormally,3');
/**
 * @hidden
 */
export let ShapeType_$type = markEnum('ShapeType', 'NotPrimitive,0|Rectangle,1|RoundRectangle,2|Ellipse,3|Diamond,4|IsocelesTriangle,5|RightTriangle,6|Parallelogram,7|Trapezoid,8|Hexagon,9|Octagon,10|Plus,11|Star,12|Arrow,13|ThickArrow,14|HomePlate,15|Cube,16|Balloon,17|Seal,18|Arc,19|Line,20|Plaque,21|Can,22|Donut,23|TextSimple,24|TextOctagon,25|TextHexagon,26|TextCurve,27|TextWave,28|TextRing,29|TextOnCurve,30|TextOnRing,31|StraightConnector1,32|BentConnector2,33|BentConnector3,34|BentConnector4,35|BentConnector5,36|CurvedConnector2,37|CurvedConnector3,38|CurvedConnector4,39|CurvedConnector5,40|Callout1,41|Callout2,42|Callout3,43|AccentCallout1,44|AccentCallout2,45|AccentCallout3,46|BorderCallout1,47|BorderCallout2,48|BorderCallout3,49|AccentBorderCallout1,50|AccentBorderCallout2,51|AccentBorderCallout3,52|Ribbon,53|Ribbon2,54|Chevron,55|Pentagon,56|NoSmoking,57|Seal8,58|Seal16,59|Seal32,60|WedgeRectCallout,61|WedgeRRectCallout,62|WedgeEllipseCallout,63|Wave,64|FoldedCorner,65|LeftArrow,66|DownArrow,67|UpArrow,68|LeftRightArrow,69|UpDownArrow,70|IrregularSeal1,71|IrregularSeal2,72|LightningBolt,73|Heart,74|PictureFrame,75|QuadArrow,76|LeftArrowCallout,77|RightArrowCallout,78|UpArrowCallout,79|DownArrowCallout,80|LeftRightArrowCallout,81|UpDownArrowCallout,82|QuadArrowCallout,83|Bevel,84|LeftBracket,85|RightBracket,86|LeftBrace,87|RightBrace,88|LeftUpArrow,89|BentUpArrow,90|BentArrow,91|Seal24,92|StripedRightArrow,93|NotchedRightArrow,94|BlockArc,95|SmileyFace,96|VerticalScroll,97|HorizontalScroll,98|CircularArrow,99|NotchedCircularArrow,100|UturnArrow,101|CurvedRightArrow,102|CurvedLeftArrow,103|CurvedUpArrow,104|CurvedDownArrow,105|CloudCallout,106|EllipseRibbon,107|EllipseRibbon2,108|FlowChartProcess,109|FlowChartDecision,110|FlowChartInputOutput,111|FlowChartPredefinedProcess,112|FlowChartInternalStorage,113|FlowChartDocument,114|FlowChartMultidocument,115|FlowChartTerminator,116|FlowChartPreparation,117|FlowChartManualInput,118|FlowChartManualOperation,119|FlowChartConnector,120|FlowChartPunchedCard,121|FlowChartPunchedTape,122|FlowChartSummingJunction,123|FlowChartOr,124|FlowChartCollate,125|FlowChartSort,126|FlowChartExtract,127|FlowChartMerge,128|FlowChartOfflineStorage,129|FlowChartOnlineStorage,130|FlowChartMagneticTape,131|FlowChartMagneticDisk,132|FlowChartMagneticDrum,133|FlowChartDisplay,134|FlowChartDelay,135|TextPlainText,136|TextStop,137|TextTriangle,138|TextTriangleInverted,139|TextChevron,140|TextChevronInverted,141|TextRingInside,142|TextRingOutside,143|TextArchUpCurve,144|TextArchDownCurve,145|TextCircleCurve,146|TextButtonCurve,147|TextArchUpPour,148|TextArchDownPour,149|TextCirclePour,150|TextButtonPour,151|TextCurveUp,152|TextCurveDown,153|TextCascadeUp,154|TextCascadeDown,155|TextWave1,156|TextWave2,157|TextWave3,158|TextWave4,159|TextInflate,160|TextDeflate,161|TextInflateBottom,162|TextDeflateBottom,163|TextInflateTop,164|TextDeflateTop,165|TextDeflateInflate,166|TextDeflateInflateDeflate,167|TextFadeRight,168|TextFadeLeft,169|TextFadeUp,170|TextFadeDown,171|TextSlantUp,172|TextSlantDown,173|TextCanUp,174|TextCanDown,175|FlowChartAlternateProcess,176|FlowChartOffpageConnector,177|Callout90,178|AccentCallout90,179|BorderCallout90,180|AccentBorderCallout90,181|LeftRightUpArrow,182|Sun,183|Moon,184|BracketPair,185|BracePair,186|Seal4,187|DoubleWave,188|ActionButtonBlank,189|ActionButtonHome,190|ActionButtonHelp,191|ActionButtonInformation,192|ActionButtonForwardNext,193|ActionButtonBackPrevious,194|ActionButtonEnd,195|ActionButtonBeginning,196|ActionButtonReturn,197|ActionButtonDocument,198|ActionButtonSound,199|ActionButtonMovie,200|HostControl,201|TextBox,202');
/**
 * @hidden
 */
export let OverwriteRoundTripDataResult_$type = markEnum('OverwriteRoundTripDataResult', 'NothingWritten,0|ElementStartWritten,1|ElementAndDescendantsWritten,2');
/**
 * @hidden
 */
export let OfficeApplication_$type = markEnum('OfficeApplication', 'Excel,0|Word,1|PowerPoint,2');
/**
 * @hidden
 */
export let State_$type = markEnum('State', 'Initial,0|Markup,1|EndTag,2|Attr,3|AttrValue,4|Text,5|PartialTag,6|AutoClose,7|CData,8|PartialText,9|PseudoStartTag,10|Eof,11');
/**
 * @hidden
 */
export let CaseFolding_$type = markEnum('CaseFolding', 'None,0|ToUpper,1|ToLower,2');
/**
 * @hidden
 */
export let AttributePresence_$type = markEnum('AttributePresence', 'DEFAULT,0|FIXED,1|REQUIRED,2|IMPLIED,3');
/**
 * @hidden
 */
export let AttributeType_$type = markEnum('AttributeType', 'DEFAULT,0|CDATA,1|ENTITY,2|ENTITIES,3|ID,4|IDREF,5|IDREFS,6|NAME,7|NAMES,8|NMTOKEN,9|NMTOKENS,10|NUMBER,11|NUMBERS,12|NUTOKEN,13|NUTOKENS,14|NOTATION,15|ENUMERATION,16');
/**
 * @hidden
 */
export let Occurrence_$type = markEnum('Occurrence', 'Required,0|Optional,1|ZeroOrMore,2|OneOrMore,3');
/**
 * @hidden
 */
export let GroupType_$type = markEnum('GroupType', 'None,0|And,1|Or,2|Sequence,3');
/**
 * @hidden
 */
export let DeclaredContent_$type = markEnum('DeclaredContent', 'Default,0|CDATA,1|RCDATA,2|EMPTY,3');
/**
 * @hidden
 */
export let LiteralType_$type = markEnum('LiteralType', 'CDATA,0|SDATA,1|PI,2');
/**
 * @hidden
 */
export class Entity extends Base {
    constructor(a, ..._rest) {
        super();
        this.v = null;
        this.u = null;
        this.e = false;
        this.w = null;
        this.aa = null;
        this.t = null;
        this.c = 0;
        this.b = null;
        this.d = false;
        this.n = 0;
        this.j = '\0';
        this.g = false;
        this.ab = null;
        this.ad = null;
        this.q = null;
        this.h = false;
        this.p = 0;
        this.m = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    this.u = c;
                    this.w = d;
                    this.aa = e;
                    this.v = f;
                    this.d = (c != null && StringUtilitiesSgml.a(c, "html"));
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.u = c;
                    this.t = d;
                    this.e = true;
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    this.u = c;
                    this.e = true;
                    this.q = e;
                    this.ad = d;
                    this.v = f;
                    this.d = (stringCompare1(c, "html", StringUtilities.g) == 0);
                }
                break;
        }
    }
    get ae() {
        if (this.ad != null) {
            return this.ad;
        }
        else if (this.b != null) {
            return this.b.ae;
        }
        return null;
    }
    get o() {
        return this.m - this.p + 1;
    }
    k() {
        let a = String.fromCharCode(this.q.b());
        if (a.charCodeAt(0) == 0) {
            a = ' ';
        }
        this.m++;
        if (a.charCodeAt(0) == 10) {
            this.g = true;
            this.p = this.m + 1;
            this.n++;
        }
        else if (a == ' ' || a == '\t') {
            this.g = true;
            if (this.j.charCodeAt(0) == 13) {
                this.p = this.m;
                this.n++;
            }
        }
        else if (a.charCodeAt(0) == 13) {
            this.g = true;
        }
        else {
            this.g = false;
            if (this.j.charCodeAt(0) == 13) {
                this.n++;
                this.p = this.m;
            }
        }
        this.j = a;
        return a;
    }
    ak(a, b) {
        this.b = a;
        if (a != null) {
            this.d = a.d;
        }
        this.n = 1;
        if (this.e) {
            if (this.t != null) {
                this.q = new StringReader(this.t);
            }
        }
        else if (this.aa == null) {
            this.aj("Unresolvable entity '{0}'", this.u);
        }
        else {
            this.aj("Unresolvable entity '{0}'", this.u);
        }
    }
    ac() {
        return this.ab;
    }
    af() {
        if (this.h) {
            this.q.i();
        }
    }
    l() {
        let a = this.j;
        while (a != "\uffff" && (a == ' ' || a == '\r' || a == '\n' || a == '\t')) {
            a = this.k();
        }
        return a;
    }
    z(a, b, c) {
        a.c = 0;
        let d = this.j;
        if (c && d != '_' && !isLetter(d)) {
            throw new BaseError(1, stringFormat("Invalid name start character '{0}'", d));
        }
        while (d != "\uffff" && b.indexOf(d) < 0) {
            if (!c || d == '_' || d == '.' || d == '-' || d == ':' || isLetterOrDigit(d)) {
                a.h(d);
            }
            else {
                throw new BaseError(1, stringFormat("Invalid name character '{0}'", d));
            }
            d = this.k();
        }
        return a.toString();
    }
    x(a, b) {
        a.c = 0;
        let c = this.k();
        while (c != "\uffff" && c != b) {
            if (c == '&') {
                c = this.k();
                if (c == '#') {
                    let d = this.s();
                    a.l(d);
                    c = this.j;
                }
                else {
                    a.h('&');
                    a.h(c);
                    c = this.k();
                }
            }
            else {
                a.h(c);
                c = this.k();
            }
        }
        this.k();
        return a.toString();
    }
    y(a, b, c) {
        if (a != null) {
            a.c = 0;
        }
        let d = this.n;
        let e = this.k();
        let f = 0;
        let g = c.charAt(f);
        while (e != "\uffff") {
            if (e == g) {
                f++;
                if (f >= c.length) {
                    break;
                }
                g = c.charAt(f);
            }
            else if (f > 0) {
                let h = f - 1;
                let i = 0;
                while (h >= 0 && i == 0) {
                    if (c.charAt(h) == e) {
                        let j = 1;
                        while (h - j >= 0) {
                            if (c.charAt(h - j) != c.charAt(f - j)) {
                                break;
                            }
                            j++;
                        }
                        if (j > h) {
                            i = h + 1;
                        }
                    }
                    else {
                        h--;
                    }
                }
                if (a != null) {
                    h = (h < 0) ? 1 : 0;
                    for (let k = 0; k <= f - i - h; k++) {
                        a.h(c.charAt(k));
                    }
                    if (h > 0) {
                        a.h(e);
                    }
                }
                f = i;
                g = c.charAt(i);
            }
            else {
                if (a != null) {
                    a.h(e);
                }
            }
            e = this.k();
        }
        if (e.charCodeAt(0) == 0) {
            this.ai(b + " starting on line {0} was never closed", d);
        }
        this.k();
        if (a != null) {
            return a.toString();
        }
        return "";
    }
    s() {
        let a = this.k();
        let b = 0;
        if (a == 'x') {
            a = this.k();
            for (; a != "\uffff" && a != ';'; a = this.k()) {
                let c = 0;
                if (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0)) {
                    c = (a.charCodeAt(0) - '0'.charCodeAt(0));
                }
                else if (a.charCodeAt(0) >= 'a'.charCodeAt(0) && a.charCodeAt(0) <= 'f'.charCodeAt(0)) {
                    c = (a.charCodeAt(0) - 'a'.charCodeAt(0)) + 10;
                }
                else if (a.charCodeAt(0) >= 'A'.charCodeAt(0) && a.charCodeAt(0) <= 'F'.charCodeAt(0)) {
                    c = (a.charCodeAt(0) - 'A'.charCodeAt(0)) + 10;
                }
                else {
                    break;
                }
                b = (b * 16) + c;
            }
        }
        else {
            for (; a != "\uffff" && a != ';'; a = this.k()) {
                if (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0)) {
                    b = (b * 10) + (a.charCodeAt(0) - '0'.charCodeAt(0));
                }
                else {
                    break;
                }
            }
        }
        if (a.charCodeAt(0) == 0) {
            this.ah("Premature {0} parsing entity reference", a);
        }
        else if (a == ';') {
            this.k();
        }
        if (this.d && b >= 128 && b <= 159) {
            let d = Entity.a.length;
            let e = b - 128;
            let f = Entity.a[e];
            return Convert.toChar1(f).toString();
        }
        return Convert.toChar1(b).toString();
    }
    ag(a) {
        throw new BaseError(1, a);
    }
    ah(a, b) {
        let c = (b == "\uffff") ? "EOF" : b.toString();
        throw new BaseError(1, stringFormat(a, c));
    }
    ai(a, b) {
        throw new BaseError(1, stringFormat(a, b));
    }
    aj(a, b) {
        throw new BaseError(1, stringFormat(a, b));
    }
    r() {
        let a = this;
        let b = new StringBuilder(0);
        while (a != null) {
            let c;
            if (a.e) {
                c = stringFormat("\nReferenced on line {0}, position {1} of internal entity '{2}'", a.n, a.o, a.u);
            }
            else {
                c = stringFormat1("\nReferenced on line {0}, position {1} of '{2}' entity at [{3}]", a.n, a.o, a.u, a.ae.absolutePath);
            }
            b.l(c);
            a = a.b;
        }
        return b.toString();
    }
    static f(a) {
        return (a == "CDATA" || a == "SDATA" || a == "PI");
    }
    al(a) {
        switch (a) {
            case "CDATA":
                this.c = 0;
                break;
            case "SDATA":
                this.c = 1;
                break;
            case "PI":
                this.c = 2;
                break;
        }
    }
}
Entity.$t = markType(Entity, 'Entity');
Entity.a = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
/**
 * @hidden
 */
export class HtmlStream extends TextReader {
    constructor(a, b) {
        super();
        this._x = null;
        this._l = null;
        this._r = 0;
        this._s = 0;
        this._ah = null;
        this._ae = null;
        this._k = null;
        this._v = 0;
        this._q = 0;
        if (b == null) {
            b = Encoding.uTF8;
        }
        if (!a.canSeek) {
            a = this._w(a);
        }
        this._x = a;
        this._l = new Array(16384);
        this._s = a.read(this._l, 0, 4);
        this._k = new Array(16384);
        this._ae = ((() => { let c = HtmlStream._ad(this._l, this._r, this._s); this._r = c.p1; return c.ret; })());
        let c = this._r;
        if (this._ae == null) {
            this._ae = b.getDecoder();
            this._s += a.read(this._l, 4, 16384 - 4);
            this._aj();
            let d = this._af();
            if (d != null) {
                this._ae = d;
            }
        }
        this._x.seek(0, 0);
        this._q = this._v = 0;
        if (c > 0) {
            a.read(this._l, 0, c);
        }
        this._r = this._s = 0;
    }
    get _ai() {
        return this._ah;
    }
    _w(a) {
        let b = 100000;
        let c = new Array(b);
        let d;
        let e = new MemoryStream(0);
        while ((d = a.read(c, 0, b)) > 0) {
            e.write(c, 0, d);
        }
        e.seek(0, 0);
        a.dispose();
        return e;
    }
    _aj() {
        if (this._q > 0) {
            if (this._q < this._v) {
                arrayCopy1(this._k, this._q, this._k, 0, this._v - this._q);
            }
            this._v -= this._q;
            this._q = 0;
        }
        let a = this._ae.a(this._l, this._r, this._s - this._r);
        let b = this._k.length - this._v;
        if (b < a) {
            let c = new Array(this._k.length + a);
            arrayCopy1(this._k, this._q, c, 0, this._v - this._q);
            this._k = c;
        }
        this._v = this._q + this._ae.c(this._l, this._r, this._s - this._r, this._k, this._q);
        this._r = this._s;
    }
    static _ad(a, b, c) {
        if (4 <= (c - b)) {
            let d = u32BitwiseOr(u32BitwiseOr(u32BitwiseOr(u32LS(a[b + 0], 24), u32LS(a[b + 1], 16)), u32LS(a[b + 2], 8)), a[b + 3]);
            let t1 = d;
            L0: while (true) {
                switch (t1) {
                    case 4278189823:
                        b += 4;
                        return {
                            ret: new Ucs4DecoderBigEngian(),
                            p1: b
                        };
                    case 4294901758:
                        b += 4;
                        return {
                            ret: new Ucs4DecoderLittleEndian(),
                            p1: b
                        };
                    case 1006632960:
                        t1 = 4278189823;
                        continue L0;
                    case 60:
                        t1 = 4294901758;
                        continue L0;
                }
                break;
            }
            d >>>= 8;
            if (d == 15711167) {
                b += 3;
                return {
                    ret: Encoding.uTF8.getDecoder(),
                    p1: b
                };
            }
            d >>>= 8;
            {
                let t1 = d;
                L0: while (true) {
                    switch (t1) {
                        case 65279:
                            b += 2;
                            return {
                                ret: Encoding.bigEndianUnicode.getDecoder(),
                                p1: b
                            };
                        case 65534:
                            b += 2;
                            return {
                                ret: new UnicodeEncoding(1, false, false).getDecoder(),
                                p1: b
                            };
                        case 15360:
                            t1 = 65279;
                            continue L0;
                        case 60:
                            t1 = 65534;
                            continue L0;
                    }
                    break;
                }
            }
        }
        return {
            ret: null,
            p1: b
        };
    }
    _t() {
        if (this._q < this._v) {
            return this._k[this._q++].charCodeAt(0);
        }
        return -1;
    }
    _p() {
        let a = this._t();
        if (a != -1) {
            this._q--;
        }
        return a;
    }
    _m(a) {
        let b = this._p();
        if (b != a.charAt(0).charCodeAt(0)) {
            return false;
        }
        for (let c = 0, d = a.length; b != -1 && c < d; c++) {
            b = this._t();
            let e = a.charAt(c);
            if (b != e.charCodeAt(0)) {
                return false;
            }
        }
        return true;
    }
    _an() {
        let a = String.fromCharCode(this._p());
        while (a == ' ' || a == '\t' || a == '\r' || a == '\n') {
            let b = this._q;
            a = String.fromCharCode(this._t());
            if (a != ' ' && a != '\t' && a != '\r' && a != '\n') {
                this._q = b;
            }
        }
    }
    _ab() {
        let a = this._p();
        if (a == '\''.charCodeAt(0) || a == '\"'.charCodeAt(0)) {
            this._t();
            let b = this._q;
            let c = this._t();
            while (c != -1 && c != a) {
                c = this._t();
            }
            return (this._q > b) ? stringCreateFromCharArraySlice(this._k, b, this._q - b - 1) : "";
        }
        return null;
    }
    _z(a) {
        this._an();
        let b = this._ac();
        if (a == b) {
            this._an();
            if (this._m("=")) {
                this._an();
                return this._ab();
            }
        }
        return null;
    }
    _aa(a) {
        this._an();
        a = this._ac();
        if (a != null) {
            this._an();
            if (this._m("=")) {
                this._an();
                return {
                    ret: this._ab(),
                    p0: a
                };
            }
        }
        return {
            ret: null,
            p0: a
        };
    }
    _am(a) {
        let b = this._t();
        let c = 0;
        let d = a.length;
        while (c < d && b != -1) {
            if (a.charAt(c).charCodeAt(0) == b) {
                c++;
                if (c == d) {
                    break;
                }
            }
            else {
                c = 0;
            }
            b = this._t();
        }
    }
    _af() {
        let a = null;
        if (this._m("<?xml")) {
            let b = this._z("version");
            if (b != null) {
                let c = this._z("encoding");
                if (c != null) {
                    try {
                        let d = Encoding.getEncoding(c);
                        if (d != null) {
                            this._ah = d;
                            return d.getDecoder();
                        }
                    }
                    catch (e) {
                    }
                }
                this._am(">");
            }
        }
        if (a == null) {
            return this._ag();
        }
        return null;
    }
    _ag() {
        let a = this._t();
        while (a != -1) {
            let b = String.fromCharCode(a);
            if (b == '<') {
                let c = this._ac();
                if (c != null && StringUtilitiesSgml.a(c, "meta")) {
                    let d = null;
                    let e = null;
                    while (true) {
                        let f = ((() => { let g = this._aa(c); c = g.p0; return g.ret; })());
                        if (c == null) {
                            break;
                        }
                        if (StringUtilitiesSgml.a(c, "http-equiv")) {
                            d = f;
                        }
                        else if (StringUtilitiesSgml.a(c, "content")) {
                            e = f;
                        }
                    }
                    if (d != null && StringUtilitiesSgml.a(d, "content-type") && e != null) {
                        let g = e.indexOf("charset");
                        if (g >= 0) {
                            g = e.indexOf("=", g);
                            if (g >= 0) {
                                g++;
                                let h = e.indexOf(";", g);
                                if (h < 0) {
                                    h = e.length;
                                }
                                let i = e.substr(g, h - g).trim();
                                try {
                                    let j = Encoding.getEncoding(i);
                                    this._ah = j;
                                    return j.getDecoder();
                                }
                                catch (k) {
                                }
                            }
                        }
                    }
                }
            }
            a = this._t();
        }
        return null;
    }
    _ac() {
        let a = this._p();
        if (a == -1) {
            return null;
        }
        let b = String.fromCharCode(a);
        let c = this._q;
        while (this._q < this._v - 1 && (isLetterOrDigit(b) || b == '-' || b == '_' || b == ':')) {
            b = this._k[++this._q];
        }
        if (c == this._q) {
            return null;
        }
        return stringCreateFromCharArraySlice(this._k, c, this._q - c);
    }
    _al() {
        let a = String.fromCharCode(this._p());
        while (this._q < this._v - 1 && (a == ' ' || a == '\r' || a == '\n')) {
            a = this._k[++this._q];
        }
    }
    _ak(a) {
        let b = String.fromCharCode(this._p());
        while (this._q < this._v - 1 && (b != a)) {
            b = this._k[++this._q];
        }
    }
    _y() {
        this._ak('=');
        if (this._q < this._v) {
            this._q++;
            this._al();
            if (this._q < this._v) {
                let a = this._k[this._q];
                this._q++;
                let b = this._q;
                this._ak(a);
                if (this._q < this._v) {
                    let c = stringCreateFromCharArraySlice(this._k, b, this._q - b);
                    this._q++;
                    return c;
                }
            }
        }
        return null;
    }
    a() {
        let a = this.b();
        if (a != -1) {
            this._q--;
        }
        return a;
    }
    b() {
        if (this._q == this._v) {
            this._s = this._x.read(this._l, 0, this._l.length);
            this._r = 0;
            if (this._s == 0) {
                return -1;
            }
            this._aj();
        }
        if (this._q < this._v) {
            return this._k[this._q++].charCodeAt(0);
        }
        return -1;
    }
    c(a, b, c) {
        if (this._q == this._v) {
            this._s = this._x.read(this._l, 0, this._l.length);
            this._r = 0;
            if (this._s == 0) {
                return -1;
            }
            this._aj();
        }
        if (this._q < this._v) {
            c = Math.min(this._v - this._q, c);
            arrayCopy1(this._k, this._q, a, b, c);
            this._q += c;
            return c;
        }
        return 0;
    }
    d(a, b, c) {
        return this.c(a, b, c);
    }
    _u(a, b, c) {
        let d = 0;
        let e = this._t();
        while (e != -1) {
            a[d + b] = String.fromCharCode(e);
            d++;
            if (d + b == c) {
                break;
            }
            if (e == '\r'.charCodeAt(0)) {
                if (this._p() == '\n'.charCodeAt(0)) {
                    e = this._t();
                    a[d + b] = String.fromCharCode(e);
                    d++;
                }
                break;
            }
            else if (e == '\n'.charCodeAt(0)) {
                break;
            }
            e = this._t();
        }
        return d;
    }
    h() {
        let a = new Array(100000);
        let b = 0;
        let c = new StringBuilder(0);
        while ((b = this.c(a, 0, a.length)) > 0) {
            c.g(a, 0, b);
        }
        return c.toString();
    }
    dispose1(a) {
        if (a) {
            this._x.dispose();
        }
    }
}
HtmlStream.$t = markType(HtmlStream, 'HtmlStream', TextReader.$);
/**
 * @hidden
 */
export class Ucs4Decoder extends Decoder {
    constructor() {
        super(...arguments);
        this._g = new Array(4);
        this._j = 0;
    }
    a(a, b, c) {
        return intDivide((c + this._j), 4);
    }
    c(a, b, c, d, e) {
        let f = this._j;
        if (this._j > 0) {
            for (; f < 4; f++) {
                this._g[f] = a[b];
                b++;
                c--;
            }
            f = 1;
            this._i(this._g, 0, 4, d, e);
            e++;
        }
        else {
            f = 0;
        }
        f = this._i(a, b, c, d, e) + f;
        let g = (this._j + c) % 4;
        c += b;
        b = c - g;
        this._j = 0;
        if (b >= 0) {
            for (; b < c; b++) {
                this._g[this._j] = a[b];
                this._j++;
            }
        }
        return f;
    }
    _h(a) {
        let b, c;
        b = (55232 + (a >>> 10));
        c = (u32BitwiseOr(56320, a & 1023));
        return String.fromCharCode(((c << 8) | b));
    }
}
Ucs4Decoder.$t = markType(Ucs4Decoder, 'Ucs4Decoder', Decoder.$);
/**
 * @hidden
 */
export class Ucs4DecoderBigEngian extends Ucs4Decoder {
    _i(a, b, c, d, e) {
        let f;
        let g, h;
        c += b;
        for (g = b, h = e; g + 3 < c;) {
            f = intSToU((((a[g + 3]) << 24) | (a[g + 2] << 16) | (a[g + 1] << 8) | (a[g])));
            if (f > 1114111) {
                throw new BaseError(1, "Invalid character 0x" + intToString1(f, "x") + " in encoding");
            }
            else if (f > 65535) {
                d[h] = this._h(f);
                h++;
            }
            else {
                if (f >= 55296 && f <= 57343) {
                    throw new BaseError(1, "Invalid character 0x" + intToString1(f, "x") + " in encoding");
                }
                else {
                    d[h] = String.fromCharCode(f);
                }
            }
            h++;
            g += 4;
        }
        return h - e;
    }
}
Ucs4DecoderBigEngian.$t = markType(Ucs4DecoderBigEngian, 'Ucs4DecoderBigEngian', Ucs4Decoder.$);
/**
 * @hidden
 */
export class Ucs4DecoderLittleEndian extends Ucs4Decoder {
    _i(a, b, c, d, e) {
        let f;
        let g, h;
        c += b;
        for (g = b, h = e; g + 3 < c;) {
            f = intSToU((((a[g]) << 24) | (a[g + 1] << 16) | (a[g + 2] << 8) | (a[g + 3])));
            if (f > 1114111) {
                throw new BaseError(1, "Invalid character 0x" + intToString1(f, "x") + " in encoding");
            }
            else if (f > 65535) {
                d[h] = this._h(f);
                h++;
            }
            else {
                if (f >= 55296 && f <= 57343) {
                    throw new BaseError(1, "Invalid character 0x" + intToString1(f, "x") + " in encoding");
                }
                else {
                    d[h] = String.fromCharCode(f);
                }
            }
            h++;
            g += 4;
        }
        return h - e;
    }
}
Ucs4DecoderLittleEndian.$t = markType(Ucs4DecoderLittleEndian, 'Ucs4DecoderLittleEndian', Ucs4Decoder.$);
/**
 * @hidden
 */
export class ElementDecl extends Base {
    constructor(a, b, c, d, e, f) {
        super();
        this.i = null;
        this.h = false;
        this.g = false;
        this.e = null;
        this.b = null;
        this.a = null;
        this.d = null;
        this.i = a;
        this.h = b;
        this.g = c;
        this.e = d;
        this.b = e;
        this.a = f;
    }
    c(a) {
        return this.d._item(a.toUpperCase());
    }
    j(a) {
        if (this.d == null) {
            this.d = a;
        }
        else {
            for (let b of fromEn(a)) {
                if (this.d._item(b.f) == null) {
                    this.d._c(b);
                }
            }
        }
    }
    f(a, b) {
        if (this.a != null) {
            let e = this.a;
            for (let d = 0; d < e.length; d++) {
                let c = e[d];
                if (c == a) {
                    return false;
                }
            }
        }
        if (this.b != null) {
            let h = this.b;
            for (let g = 0; g < h.length; g++) {
                let f = h[g];
                if (f == a) {
                    return true;
                }
            }
        }
        return this.e.c(a, b);
    }
}
ElementDecl.$t = markType(ElementDecl, 'ElementDecl');
/**
 * @hidden
 */
export class ContentModel extends Base {
    constructor() {
        super();
        this.a = 0;
        this.d = 0;
        this.b = null;
        this.b = new Group(null);
    }
    i() {
        this.b = new Group(this.b);
        this.d++;
    }
    e() {
        if (this.d == 0) {
            return -1;
        }
        this.d--;
        this.b.a.i(this.b);
        this.b = this.b.a;
        return this.d;
    }
    h(a) {
        this.b.k(a);
    }
    f(a) {
        this.b.h(a);
    }
    g(a) {
        this.b.j(a);
    }
    j(a) {
        switch (a) {
            case "EMPTY":
                this.a = 3;
                break;
            case "RCDATA":
                this.a = 2;
                break;
            case "CDATA":
                this.a = 1;
                break;
            default: throw new BaseError(1, stringFormat("Declared content type '{0}' is not supported", a));
        }
    }
    c(a, b) {
        if (this.a != 0) {
            return false;
        }
        return this.b.d(a, b);
    }
}
ContentModel.$t = markType(ContentModel, 'ContentModel');
/**
 * @hidden
 */
export class Group extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.g = null;
        this.b = 0;
        this.c = 0;
        this.e = false;
        this.a = a;
        this.g = new List$1(Base.$, 0);
        this.b = 0;
        this.c = 0;
    }
    get f() {
        return this.e && this.g.count == 0;
    }
    i(a) {
        this.g.add1(a);
    }
    k(a) {
        if (a == "#PCDATA") {
            this.e = true;
        }
        else {
            this.g.add1(a);
        }
    }
    h(a) {
        if (!this.e && this.g.count == 0) {
            throw new BaseError(1, stringFormat("Missing token before connector '{0}'.", a));
        }
        let b = 0;
        switch (a) {
            case ',':
                b = 3;
                break;
            case '|':
                b = 2;
                break;
            case '&':
                b = 1;
                break;
        }
        if (this.b != 0 && this.b != b) {
            throw new BaseError(1, stringFormat("Connector '{0}' is inconsistent with {1} group.", a, EnumUtil.getName(GroupType_$type, this.b)));
        }
        this.b = b;
    }
    j(a) {
        let b = 0;
        switch (a) {
            case '?':
                b = 1;
                break;
            case '+':
                b = 3;
                break;
            case '*':
                b = 2;
                break;
        }
        this.c = b;
    }
    d(a, b) {
        for (let c of fromEnum(this.g)) {
            if (typeof c === 'string') {
                if (c == a) {
                    return true;
                }
            }
        }
        for (let d of fromEnum(this.g)) {
            if (typeof d === 'string') {
                let e = d;
                let f = b.d(e);
                if (f != null) {
                    if (f.h) {
                        if (f.f(a, b)) {
                            return true;
                        }
                    }
                }
            }
            else {
                let g = d;
                if (g.d(a, b)) {
                    return true;
                }
            }
        }
        return false;
    }
}
Group.$t = markType(Group, 'Group');
/**
 * @hidden
 */
export class AttDef extends Base {
    constructor(a) {
        super();
        this.f = null;
        this.c = 0;
        this.a = null;
        this.e = null;
        this.b = 0;
        this.f = a;
    }
    g(a) {
        switch (a) {
            case "CDATA":
                this.c = 1;
                break;
            case "ENTITY":
                this.c = 2;
                break;
            case "ENTITIES":
                this.c = 3;
                break;
            case "ID":
                this.c = 4;
                break;
            case "IDREF":
                this.c = 5;
                break;
            case "IDREFS":
                this.c = 6;
                break;
            case "NAME":
                this.c = 7;
                break;
            case "NAMES":
                this.c = 8;
                break;
            case "NMTOKEN":
                this.c = 9;
                break;
            case "NMTOKENS":
                this.c = 10;
                break;
            case "NUMBER":
                this.c = 11;
                break;
            case "NUMBERS":
                this.c = 12;
                break;
            case "NUTOKEN":
                this.c = 13;
                break;
            case "NUTOKENS":
                this.c = 14;
                break;
            default: throw new BaseError(1, "Attribute type '" + a + "' is not supported");
        }
    }
    d(a) {
        let b = true;
        if (a == "FIXED") {
            this.b = 1;
        }
        else if (a == "REQUIRED") {
            this.b = 2;
            b = false;
        }
        else if (a == "IMPLIED") {
            this.b = 3;
            b = false;
        }
        else {
            throw new BaseError(1, stringFormat("Attribute value '{0}' not supported", a));
        }
        return b;
    }
}
AttDef.$t = markType(AttDef, 'AttDef');
/**
 * @hidden
 */
export class AttList extends Base {
    constructor() {
        super();
        this._b = null;
        this._b = new Dictionary$2(String_$type, AttDef.$, 0);
    }
    _c(a) {
        this._b.addItem(a.f, a);
    }
    _item(a) {
        return this._b.item(a);
    }
    getEnumeratorObject() {
        return getEnumerator(this._b.values);
    }
}
AttList.$t = markType(AttList, 'AttList', Base.$, [IEnumerable_$type]);
/**
 * @hidden
 */
export class SgmlDtd extends Base {
    constructor(a, b) {
        super();
        this.r = null;
        this.m = null;
        this.o = null;
        this.n = null;
        this.w = null;
        this.e = null;
        this.am = null;
        this.am = b;
        this.r = a;
        this.m = new Dictionary$2(String_$type, ElementDecl.$, 0);
        this.o = new Dictionary$2(String_$type, Entity.$, 0);
        this.n = new Dictionary$2(String_$type, Entity.$, 0);
        this.w = new StringBuilder(0);
    }
    get an() {
        return this.am;
    }
    static j(a, b, c, d, e, f, g) {
        let h = new SgmlDtd(b, g);
        if (d != null && d != "") {
            h.al(a, new Entity(0, h.r, c, d, f));
        }
        if (e != null && e != "") {
            h.al(a, new Entity(1, b, e));
        }
        try {
            h.x();
        }
        catch (i) {
            throw new BaseError(1, i.message + h.e.r());
        }
        return h;
    }
    static i(a, b, c, d, e, f, g) {
        let h = new SgmlDtd(b, g);
        h.al(a, new Entity(2, h.r, a, d, f));
        if (e != null && e != "") {
            h.al(a, new Entity(1, b, e));
        }
        try {
            h.x();
        }
        catch (i) {
            throw new BaseError(1, i.message + h.e.r());
        }
        return h;
    }
    f(a) {
        return this.n.item(a);
    }
    d(a) {
        return this.m.item(a.toUpperCase());
    }
    al(a, b) {
        b.ak(this.e, a);
        this.e = b;
        this.e.k();
    }
    ak() {
        if (this.e != null) {
            this.e.af();
        }
        if (this.e.b != null) {
            this.e = this.e.b;
        }
        else {
            this.e = null;
        }
    }
    x() {
        let a = this.e.j;
        while (true) {
            switch (a) {
                case "\uffff":
                    this.ak();
                    if (this.e == null) {
                        return;
                    }
                    a = this.e.j;
                    break;
                case ' ':
                case '\n':
                case '\r':
                case '\t':
                    a = this.e.k();
                    break;
                case '<':
                    this.ah();
                    a = this.e.k();
                    break;
                case '%':
                    let b = this.h(SgmlDtd.v);
                    try {
                        this.al(this.e.ae, b);
                    }
                    catch (c) {
                    }
                    a = this.e.j;
                    break;
                default:
                    this.e.ah("Unexpected character '{0}'", a);
                    break;
            }
        }
    }
    ah() {
        let a = this.e.k();
        if (a != '!') {
            this.e.ag("Found '{0}', but expecing declaration starting with '<!'");
            return;
        }
        a = this.e.k();
        if (a == '-') {
            a = this.e.k();
            if (a != '-') {
                this.e.ah("Expecting comment '<!--' but found {0}", a);
            }
            this.e.y(this.w, "Comment", "-->");
        }
        else if (a == '[') {
            this.ag();
        }
        else {
            let b = this.e.z(this.w, SgmlDtd.v, true);
            switch (b) {
                case "ENTITY":
                    this.ad();
                    break;
                case "ELEMENT":
                    this.ac();
                    break;
                case "ATTLIST":
                    this.z();
                    break;
                default:
                    this.e.aj("Invalid declaration '<!{0}'.  Expecting 'ENTITY', 'ELEMENT' or 'ATTLIST'.", b);
                    break;
            }
        }
    }
    l() {
        let a = this.e.j;
        while (a == '-') {
            a = this.k(true);
        }
        return a;
    }
    k(a) {
        let b = this.e.n;
        let c = this.e.k();
        if (a && c != '-') {
            this.e.ah("Expecting comment delimiter '--' but found {0}", c);
        }
        this.e.y(this.w, "Markup Comment", "--");
        return this.e.l();
    }
    ag() {
        this.e.k();
        let a = this.u("[");
        if (a == "INCLUDE") {
            this.af();
        }
        else if (a == "IGNORE") {
            this.ae();
        }
        else {
            this.e.aj("Unsupported marked section type '{0}'", a);
        }
    }
    af() {
        throw new NotImplementedException(1, "Include Section");
    }
    ae() {
        let a = this.e.n;
        let b = this.e.l();
        if (b != '[') {
            this.e.ah("Expecting '[' but found {0}", b);
        }
        this.e.y(this.w, "Conditional Section", "]]>");
    }
    u(a) {
        let b = this.e.l();
        if (b == '%') {
            let c = this.h(a);
            b = this.e.j;
            if (!c.e) {
                throw new NotSupportedException(1, "External parameter entity resolution");
            }
            return c.t.trim();
        }
        else {
            return this.e.z(this.w, a, true);
        }
    }
    h(a) {
        let b = this.e.k();
        let c = this.e.z(this.w, ";" + a, false);
        c = this.am.b(c);
        if (this.e.j == ';') {
            this.e.k();
        }
        let d = this.g(c);
        return d;
    }
    g(a) {
        let b = this.o.item(a);
        if (b == null) {
            this.e.aj("Reference to undefined parameter entity '{0}'", a);
        }
        return b;
    }
    ad() {
        let a = this.e.l();
        let b = (a == '%');
        if (b) {
            this.e.k();
            a = this.e.l();
        }
        let c = this.e.z(this.w, SgmlDtd.v, true);
        c = this.am.b(c);
        a = this.e.l();
        let d = null;
        if (a == '\"' || a == '\'') {
            let e = this.e.x(this.w, a);
            d = new Entity(1, c, e);
        }
        else {
            let f = null;
            let g = null;
            let h = this.e.z(this.w, SgmlDtd.v, true);
            if (Entity.f(h)) {
                a = this.e.l();
                let i = this.e.x(this.w, a);
                d = new Entity(1, c, i);
                d.al(h);
            }
            else {
                g = h;
                if (g == "PUBLIC") {
                    a = this.e.l();
                    if (a == '\"' || a == '\'') {
                        f = this.e.x(this.w, a);
                    }
                    else {
                        this.e.ah("Expecting public identifier literal but found '{0}'", a);
                    }
                }
                else if (g != "SYSTEM") {
                    this.e.aj("Invalid external identifier '{0}'.  Expecing 'PUBLIC' or 'SYSTEM'.", g);
                }
                let j = null;
                a = this.e.l();
                if (a == '\"' || a == '\'') {
                    j = this.e.x(this.w, a);
                }
                else if (a != '>') {
                    this.e.ah("Expecting system identifier literal but found '{0}'", a);
                }
                d = new Entity(0, c, f, j, this.e.v);
            }
        }
        a = this.e.l();
        if (a == '-') {
            a = this.l();
        }
        if (a != '>') {
            this.e.ah("Expecting end of entity declaration '>' but found '{0}'", a);
        }
        if (b) {
            this.o.addItem(d.u, d);
        }
        else {
            this.n.addItem(d.u, d);
        }
    }
    ac() {
        let a = this.e.l();
        let b = this.a(a, true);
        a = this.e.l().toUpperCase();
        let c = false;
        let d = false;
        if (a == 'O' || a == '-') {
            c = (a == 'O');
            this.e.k();
            a = this.e.l().toUpperCase();
            if (a == 'O' || a == '-') {
                d = (a == 'O');
                a = this.e.k();
            }
        }
        a = this.e.l();
        let e = this.c(a);
        a = this.e.l();
        let f = null;
        let g = null;
        if (a == '-') {
            a = this.e.k();
            if (a == '(') {
                f = this.a(a, true);
                a = this.e.l();
            }
            else if (a == '-') {
                a = this.k(false);
            }
            else {
                this.e.ah("Invalid syntax at '{0}'", a);
            }
        }
        if (a == '-') {
            a = this.l();
        }
        if (a == '+') {
            a = this.e.k();
            if (a != '(') {
                this.e.ah("Expecting inclusions name group", a);
            }
            g = this.a(a, true);
            a = this.e.l();
        }
        if (a == '-') {
            a = this.l();
        }
        if (a != '>') {
            this.e.ah("Expecting end of ELEMENT declaration '>' but found '{0}'", a);
        }
        for (let i = 0; i < b.length; i++) {
            let h = b[i];
            let j = h.toUpperCase();
            j = this.am.b(h);
            this.m.addItem(j, new ElementDecl(j, c, d, e, g, f));
        }
    }
    a(a, b) {
        let c = new List$1(String_$type, 0);
        if (a == '(') {
            a = this.e.k();
            a = this.e.l();
            while (a != ')') {
                a = this.e.l();
                if (a == '%') {
                    let d = this.h(SgmlDtd.s);
                    this.al(this.e.ae, d);
                    this.aj(c, b);
                    this.ak();
                    a = this.e.j;
                }
                else {
                    let e = this.e.z(this.w, SgmlDtd.s, b);
                    e = e.toUpperCase();
                    let f = this.am.b(e);
                    c.add(f);
                }
                a = this.e.l();
                if (a == '|' || a == ',') {
                    a = this.e.k();
                }
            }
            this.e.k();
        }
        else {
            let g = this.e.z(this.w, SgmlDtd.v, b);
            g = g.toUpperCase();
            g = this.am.b(g);
            c.add(g);
        }
        return c.toArray();
    }
    aj(a, b) {
        let c = this.e.j;
        c = this.e.l();
        while (c != "\uffff") {
            let d;
            if (c == '%') {
                let e = this.h(SgmlDtd.s);
                this.al(this.e.ae, e);
                this.aj(a, b);
                this.ak();
                c = this.e.j;
            }
            else {
                d = this.e.z(this.w, SgmlDtd.s, true);
                d = d.toUpperCase();
                d = this.am.b(d);
                a.add(d);
            }
            c = this.e.l();
            if (c == '|') {
                c = this.e.k();
                c = this.e.l();
            }
        }
    }
    c(a) {
        let b = new ContentModel();
        if (a == '(') {
            this.e.k();
            this.ai(')', b);
            a = this.e.k();
            if (a == '?' || a == '+' || a == '*') {
                b.g(a);
                this.e.k();
            }
        }
        else if (a == '%') {
            let c = this.h(SgmlDtd.q);
            this.al(this.e.ae, c);
            b = this.c(this.e.j);
            this.ak();
        }
        else {
            let d = this.u(SgmlDtd.q);
            b.j(d);
        }
        return b;
    }
    ai(a, b) {
        let c = b.d;
        let d = this.e.j;
        d = this.e.l();
        while (d != a || b.d > c) {
            if (d == "\uffff") {
                this.e.ag("Content Model was not closed");
            }
            if (d == '%') {
                let e = this.h(SgmlDtd.p);
                this.al(this.e.ae, e);
                this.ai("\uffff", b);
                this.ak();
                d = this.e.l();
            }
            else if (d == '(') {
                b.i();
                this.e.k();
                d = this.e.l();
            }
            else if (d == ')') {
                d = this.e.k();
                if (d == '*' || d == '+' || d == '?') {
                    b.g(d);
                    d = this.e.k();
                }
                if (b.e() < c) {
                    this.e.ag("Parameter entity cannot close a paren outside it's own scope");
                }
                d = this.e.l();
            }
            else if (d == ',' || d == '|' || d == '&') {
                b.f(d);
                this.e.k();
                d = this.e.l();
            }
            else {
                let f;
                if (d == '#') {
                    d = this.e.k();
                    f = "#" + this.e.z(this.w, SgmlDtd.p, true);
                }
                else {
                    f = this.e.z(this.w, SgmlDtd.p, true);
                }
                f = f.toUpperCase();
                f = this.am.b(f);
                d = this.e.j;
                if (d == '?' || d == '+' || d == '*') {
                    b.i();
                    b.h(f);
                    b.g(d);
                    b.e();
                    this.e.k();
                    d = this.e.l();
                }
                else {
                    b.h(f);
                    d = this.e.l();
                }
            }
        }
    }
    z() {
        let a = this.e.l();
        let b = this.a(a, true);
        let c = new AttList();
        this.aa(c, '>');
        for (let e = 0; e < b.length; e++) {
            let d = b[e];
            let f = this.m.item(d);
            if (f == null) {
                this.e.aj("ATTLIST references undefined ELEMENT {0}", d);
            }
            f.j(c);
        }
    }
    aa(a, b) {
        let c = this.e.l();
        while (c != b) {
            if (c == '%') {
                let d = this.h(SgmlDtd.t);
                this.al(this.e.ae, d);
                this.aa(a, "\uffff");
                this.ak();
                c = this.e.l();
            }
            else if (c == '-') {
                c = this.l();
            }
            else {
                let e = this.b(c);
                a._c(e);
            }
            c = this.e.l();
        }
    }
    b(a) {
        a = this.e.l();
        let b = this.u(SgmlDtd.v);
        b = b.toUpperCase();
        b = this.am.b(b);
        let c = new AttDef(b);
        a = this.e.l();
        if (a == '-') {
            a = this.l();
        }
        this.ab(a, c);
        a = this.e.l();
        if (a == '-') {
            a = this.l();
        }
        this.y(a, c);
        a = this.e.l();
        if (a == '-') {
            a = this.l();
        }
        return c;
    }
    ab(a, b) {
        if (a == '%') {
            let c = this.h(SgmlDtd.v);
            this.al(this.e.ae, c);
            this.ab(this.e.j, b);
            this.ak();
            a = this.e.j;
            return;
        }
        if (a == '(') {
            b.a = this.a(a, false);
            b.c = 16;
        }
        else {
            let d = this.u(SgmlDtd.v);
            if (d == "NOTATION") {
                a = this.e.l();
                if (a != '(') {
                    this.e.ah("Expecting name group '(', but found '{0}'", a);
                }
                b.c = 15;
                b.a = this.a(a, true);
            }
            else {
                b.g(d);
            }
        }
    }
    y(a, b) {
        if (a == '%') {
            let c = this.h(SgmlDtd.v);
            this.al(this.e.ae, c);
            this.y(this.e.j, b);
            this.ak();
            a = this.e.j;
            return;
        }
        let d = true;
        if (a == '#') {
            this.e.k();
            let e = this.e.z(this.w, SgmlDtd.v, true);
            d = b.d(e);
            a = this.e.l();
        }
        if (d) {
            if (a == '\'' || a == '\"') {
                let f = this.e.x(this.w, a);
                b.e = f;
                a = this.e.l();
            }
            else {
                let g = this.e.z(this.w, SgmlDtd.v, false);
                g = g.toUpperCase();
                g = this.am.b(g);
                b.e = g;
                a = this.e.l();
            }
        }
    }
}
SgmlDtd.$t = markType(SgmlDtd, 'SgmlDtd');
SgmlDtd.v = " \r\n\t";
SgmlDtd.s = " \r\n\t|,)";
SgmlDtd.q = " \r\n\t>";
SgmlDtd.p = " \r\n\t,&|()?+*";
SgmlDtd.t = " \t\r\n>";
/**
 * @hidden
 */
export class StringUtilitiesSgml extends Base {
    static a(a, b) {
        return stringCompare1(a, b, StringUtilities.g) == 0;
    }
}
StringUtilitiesSgml.$t = markType(StringUtilitiesSgml, 'StringUtilitiesSgml');
/**
 * @hidden
 */
export class HWStack extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.e = 0;
        this.b = 0;
        this.d = 0;
        this.d = a;
    }
    get c() {
        return this.b;
    }
    set c(a) {
        this.b = a;
    }
    get f() {
        return this.e;
    }
    item(a, b) {
        if (arguments.length === 2) {
            this.a[a] = b;
            return b;
        }
        else {
            return (a >= 0 && a < this.e) ? this.a[a] : null;
        }
    }
    h() {
        this.b--;
        if (this.b > 0) {
            return this.a[this.b - 1];
        }
        return null;
    }
    i() {
        if (this.b == this.e) {
            let a = this.e + this.d;
            let b = new Array(a);
            if (this.a != null) {
                arrayCopy2(this.a, b, this.e);
            }
            this.e = a;
            this.a = b;
        }
        return this.a[this.b++];
    }
    j(a) {
        this.a[a] = null;
        arrayCopy1(this.a, a + 1, this.a, a, this.b - a - 1);
        this.b--;
    }
}
HWStack.$t = markType(HWStack, 'HWStack');
/**
 * @hidden
 */
export class Attribute extends Base {
    constructor() {
        super(...arguments);
        this.e = null;
        this.a = null;
        this.c = '\0';
        this.d = null;
    }
    g(a, b, c) {
        this.e = a;
        this.d = b;
        this.c = c;
        this.a = null;
    }
    get f() {
        if (this.d != null) {
            return this.d;
        }
        if (this.a != null) {
            return this.a.e;
        }
        return null;
    }
    set f(a) {
        this.d = a;
    }
    get b() {
        return (this.d == null);
    }
}
Attribute.$t = markType(Attribute, 'Attribute');
/**
 * @hidden
 */
export class Node extends Base {
    constructor() {
        super(...arguments);
        this.p = 0;
        this.k = null;
        this.q = 0;
        this.l = null;
        this.f = false;
        this.j = null;
        this.c = null;
        this.e = 0;
        this.g = false;
        this.d = new HWStack(10);
    }
    o(a, b, c) {
        this.k = c;
        this.j = a;
        this.p = b;
        this.q = 0;
        this.l = null;
        this.f = true;
        this.d.c = 0;
        this.c = null;
    }
    a(a, b, c, d) {
        let e;
        for (let f = 0, g = this.d.c; f < g; f++) {
            e = this.d.item(f);
            if (d && stringCompare1(e.e, a, 1) == 0) {
                return null;
            }
            else if (e.e == a) {
                return null;
            }
        }
        e = this.d.i();
        if (e == null) {
            e = new Attribute();
            this.d.item(this.d.c - 1, e);
        }
        e.g(a, b, c);
        return e;
    }
    n(a) {
        for (let b = 0, c = this.d.c; b < c; b++) {
            let d = this.d.item(b);
            if (d.e == a) {
                this.d.j(b);
                return;
            }
        }
    }
    m(a) {
        for (let b = 0, c = a.d.c; b < c; b++) {
            let d = a.d.item(b);
            let e = this.a(d.e, d.f, d.c, false);
            e.a = d.a;
        }
    }
    get h() {
        return this.d.c;
    }
    i(a) {
        for (let b = 0, c = this.d.c; b < c; b++) {
            let d = this.d.item(b);
            if (d.e == a) {
                return b;
            }
        }
        return -1;
    }
    b(a) {
        if (a >= 0 && a < this.d.c) {
            let b = this.d.item(a);
            return b;
        }
        return null;
    }
}
Node.$t = markType(Node, 'Node');
/**
 * @hidden
 */
export class SgmlReader extends XmlReader {
    constructor() {
        super();
        this._bk = null;
        this._bc = null;
        this._bm = 0;
        this._dh = null;
        this._b2 = '\0';
        this._ca = null;
        this._be = null;
        this._bg = null;
        this._a9 = null;
        this._b3 = 0;
        this._c0 = null;
        this._cz = null;
        this._cy = null;
        this._b9 = null;
        this._bn = false;
        this._bf = null;
        this._b4 = 0;
        this._b5 = 0;
        this._bo = false;
        this._cp = null;
        this._ci = null;
        this._bd = null;
        this._cm = null;
        this._b6 = null;
        this._ct = null;
        this._cn = null;
        this._cs = null;
        this._cf = null;
        this._de = 0;
        this._bb = 0;
        this._b0 = true;
        this._dg = null;
        this.c2();
        this._dh = new NameTable();
        this._dg = new XmlNamespaceManager(this._dh);
    }
    get _bl() {
        this._c3(this._c0);
        return this._bk;
    }
    set _bl(a) {
        this._bk = a;
    }
    _c3(a) {
        if (this._bk == null) {
            if (this._bk != null && this._bk.r != null) {
                switch (this._ba) {
                    case 1:
                        this._cp = this._bk.r.toUpperCase();
                        break;
                    case 2:
                        this._cp = this._bk.r.toLowerCase();
                        break;
                    default:
                        this._cp = this._bk.r;
                        break;
                }
                this._bo = StringUtilitiesSgml.a(this._bk.r, "html");
            }
        }
    }
    get _cg() {
        return this._cf;
    }
    set _cg(a) {
        this._cf = a;
    }
    get _co() {
        return this._cn;
    }
    set _co(a) {
        this._cn = a;
    }
    get _cu() {
        return this._ct;
    }
    set _cu(a) {
        this._ct = a;
    }
    get _ck() {
        return this._cs;
    }
    set _ck(a) {
        this._cs = a;
    }
    get _b7() {
        return this._b6;
    }
    set _b7(a) {
        this._b6 = a;
        this.c2();
    }
    get _cw() {
        return this._cm;
    }
    set _cw(a) {
        this._cm = a;
    }
    _c9(a) {
        this._c0 = new Uri(0, a);
    }
    get _cj() {
        return this._ci;
    }
    set _cj(a) {
        this._ci = a;
        this.c2();
        if (this._c0 == null) {
            if (this._ci.indexOf("://") > 0) {
                this._c0 = new Uri(0, this._ci);
            }
        }
    }
    get _b1() {
        return this._b0;
    }
    set _b1(a) {
        this._b0 = a;
    }
    get _ba() {
        return this._bb;
    }
    set _ba(a) {
        this._bb = a;
    }
    get _b8() {
        return this._b9;
    }
    set _b8(a) {
        this._b9 = a;
    }
    _c4(a, ...b) {
        if (this._b8 != null) {
            let c = stringFormat1(a, ...b);
            if (this._bd != this._bc) {
                c = c + "    " + this._bc.r();
                this._bd = this._bc;
                this._b8.an("### Error:" + c);
            }
            else {
                let d = "";
                if (this._bc.ae != null) {
                    d = this._bc.ae.absolutePath;
                }
                this._b8.an("### Error in " + d + "#" + this._bc.u + ", line " + this._bc.n + ", position " + this._bc.o + ": " + c);
            }
        }
    }
    _c5(a, b) {
        this._c4(a, b.toString());
    }
    c2() {
        this._bm = 0;
        this._be = new HWStack(10);
        this._bg = this._bi(null, 9, null);
        this._bg.f = false;
        this._cz = new StringBuilder(0);
        this._cy = new StringBuilder(0);
        this._b4 = 0;
        this._bc = null;
        this._b2 = '\0';
        this._ca = null;
        this._a9 = null;
        this._b3 = 0;
        this._bf = null;
        this._b5 = 0;
        this._bn = false;
    }
    _bi(a, b, c) {
        let d = this._be.i();
        if (d == null) {
            d = new Node();
            this._be.item(this._be.c - 1, d);
        }
        d.o(a, b, c);
        this._bg = d;
        return d;
    }
    _da() {
        let a = this._be.c - 1;
        if (a > 0) {
            let b = this._be.item(a - 1);
            this._be.item(a - 1, this._be.item(a));
            this._be.item(a, b);
        }
    }
    _bh(a) {
        let b = this._bi(a.j, a.p, a.k);
        b.c = a.c;
        b.f = a.f;
        b.q = a.q;
        b.l = a.l;
        b.e = a.e;
        b.m(a);
        this._bg = b;
        return b;
    }
    _c8() {
        if (this._be.c > 1) {
            this._bg = this._be.h();
        }
    }
    _bj() {
        let a = this._be.c - 1;
        if (a > 0) {
            return this._be.item(a);
        }
        return null;
    }
    get_a7() {
        if (this._bm == 3) {
            return 2;
        }
        else if (this._bm == 4) {
            return 3;
        }
        else if (this._bm == 2 || this._bm == 7) {
            return 15;
        }
        return this._bg.p;
    }
    get a7() {
        return this.get_a7();
    }
    get_ai() {
        let a = null;
        if (this._bm == 3) {
            a = this._a9.e;
        }
        else if (this._bm == 4) {
            a = null;
        }
        else {
            a = this._bg.j;
        }
        return a;
    }
    get ai() {
        return this.get_ai();
    }
    get_ag() {
        let a = this.ai;
        let b = this.ak;
        if (b.length != 0) {
            return a.substr(b.length + 1);
        }
        return a;
    }
    get ag() {
        return this.get_ag();
    }
    get_aj() {
        if (this._bm == 3 && StringUtilitiesSgml.a(this._a9.e, "xmlns")) {
            return "http://www.w3.org/2000/xmlns/";
        }
        let a = this.ak;
        switch (a) {
            case "xmlns": return "http://www.w3.org/2000/xmlns/";
            case "xml": return "http://www.w3.org/XML/1998/namespace";
            case "": return stringEmpty();
            default: return this.ah(a);
        }
    }
    get aj() {
        return this.get_aj();
    }
    get_ak() {
        let a = this.ai;
        if (a == null) {
            return stringEmpty();
        }
        let b = a.indexOf(':');
        if (b < 0) {
            return stringEmpty();
        }
        return a.substr(0, b);
    }
    get ak() {
        return this.get_ak();
    }
    get_f() {
        if (this._bm == 3 || this._bm == 4) {
            return true;
        }
        return (this._bg.k != null);
    }
    get f() {
        return this.get_f();
    }
    get_ar() {
        if (this._bm == 3 || this._bm == 4) {
            return this._a9.f;
        }
        return this._bg.k;
    }
    get ar() {
        return this.get_ar();
    }
    get_x() {
        if (this._bm == 3) {
            return this._be.c;
        }
        else if (this._bm == 4) {
            return this._be.c + 1;
        }
        return this._be.c - 1;
    }
    get x() {
        return this.get_x();
    }
    get_z() {
        return this._c0 == null ? "" : this._c0.absoluteUri;
    }
    get z() {
        return this.get_z();
    }
    get_i() {
        if (this._bm == 1 || this._bm == 3 || this._bm == 4) {
            return this._bg.f;
        }
        return false;
    }
    get i() {
        return this.get_i();
    }
    get_h() {
        if (this._bm == 3 || this._bm == 4) {
            return this._a9.b;
        }
        return false;
    }
    get h() {
        return this.get_h();
    }
    get_v() {
        if (this._a9 != null) {
            return this._a9.c;
        }
        return '\0';
    }
    get v() {
        return this.get_v();
    }
    get_a8() {
        for (let a = this._be.c - 1; a > 1; a--) {
            let b = this._be.item(a);
            let c = b.q;
            if (c != 0) {
                return c;
            }
        }
        return 0;
    }
    get a8() {
        return this.get_a8();
    }
    get_as() {
        for (let a = this._be.c - 1; a > 1; a--) {
            let b = this._be.item(a);
            let c = b.l;
            if (c != null) {
                return c;
            }
        }
        return stringEmpty();
    }
    get as() {
        return this.get_as();
    }
    get _df() {
        return this._de;
    }
    set _df(a) {
        this._de = a;
    }
    get_w() {
        if (this._bm == 3 || this._bm == 4) {
            return 0;
        }
        if (this._bg.p == 1 || this._bg.p == 10) {
            return this._bg.h;
        }
        return 0;
    }
    get w() {
        return this.get_w();
    }
    ab(a) {
        if (this._bm != 3 && this._bm != 4) {
            let b = this._bg.i(a);
            if (b >= 0) {
                return this.aa(b);
            }
        }
        return null;
    }
    ac(a, b) {
        return this.ab(a);
    }
    aa(a) {
        if (this._bm != 3 && this._bm != 4) {
            let b = this._bg.b(a);
            if (b != null) {
                return b.f;
            }
        }
        throw new IndexOutOfRangeException(0);
    }
    item(a) {
        return this.aa(a);
    }
    item1(a) {
        return this.ab(a);
    }
    item2(a, b) {
        return this.ac(a, b);
    }
    o(a) {
        let b = this._bg.i(a);
        if (b >= 0) {
            this.aw(b);
            return true;
        }
        return false;
    }
    p(a, b) {
        return this.o(a);
    }
    aw(a) {
        let b = this._bg.b(a);
        if (b != null) {
            this._b3 = a;
            this._a9 = b;
            if (this._bm != 3) {
                this._bg.e = this._bm;
            }
            this._bm = 3;
            return;
        }
        throw new IndexOutOfRangeException(0);
    }
    r() {
        if (this._bg.h > 0) {
            this.aw(0);
            return true;
        }
        return false;
    }
    s() {
        if (this._bm != 3 && this._bm != 4) {
            return this.r();
        }
        if (this._b3 < this._bg.h - 1) {
            this.aw(this._b3 + 1);
            return true;
        }
        return false;
    }
    q() {
        if (this._bm == 3 || this._bm == 4) {
            this._bm = this._bg.e;
            this._a9 = null;
            return true;
        }
        return (this._bg.p == 1);
    }
    get _bp() {
        return this._bo;
    }
    _cx() {
        if (this._bc == null) {
            this._c6();
        }
        return this._bc.ac();
    }
    _c6() {
        this._c3(this._c0);
        if (this._cj != null) {
            this._bc = new Entity(0, "#document", null, this._ci, this._cm);
        }
        else if (this._b6 != null) {
            this._bc = new Entity(2, "#document", null, this._b6, this._cm);
        }
        else {
            throw new InvalidOperationException(1, "You must specify input either via Href or InputStream properties");
        }
        this._bc.d = this._bp;
        this._bc.ak(null, this._c0);
        if (this._bc.ae != null) {
            this._c0 = this._bc.ae;
        }
        if (this._bc.d && this._bk == null) {
            this._cf = "HTML";
            this._c3(this._c0);
        }
    }
    t() {
        if (this._bc == null) {
            this._c6();
        }
        let a = this._bm;
        if (this._bg.g) {
            this._bg.g = false;
            this._bg = this._bj();
            this._bm = this._bg.e;
            return true;
        }
        let b = false;
        while (!b) {
            let t1 = this._bm;
            L0: while (true) {
                switch (t1) {
                    case 0:
                        this._bm = 1;
                        this._bc.k();
                        t1 = 1;
                        continue L0;
                    case 11:
                        if (this._bc.b != null) {
                            this._bc.af();
                            this._bc = this._bc.b;
                        }
                        else {
                            return false;
                        }
                        break;
                    case 2:
                        if (this._ca == this._bg.j) {
                            this._c8();
                            this._bm = 1;
                            t1 = 1;
                            continue L0;
                        }
                        this._c8();
                        b = true;
                        break;
                    case 1:
                        if (this._bg.f) {
                            this._c8();
                        }
                        let c = this._bg;
                        b = this._bv();
                        break;
                    case 6:
                        this._c8();
                        this._bm = 1;
                        b = this._by(this._b2);
                        break;
                    case 10:
                        b = this._bx('<');
                        break;
                    case 7:
                        this._c8();
                        if (this._be.c <= this._b4) {
                            this._bm = 1;
                            if (this._bf != null) {
                                this._bh(this._bf);
                                this._bf = null;
                                this._bm = 1;
                            }
                            else if (this._bg.p == 9) {
                                this._bm = 11;
                                t1 = 11;
                                continue L0;
                            }
                        }
                        b = true;
                        break;
                    case 8:
                        b = this._br();
                        break;
                    case 3:
                        t1 = 4;
                        continue L0;
                    case 4:
                        this._bm = 1;
                        t1 = 1;
                        continue L0;
                    case 5:
                        this._c8();
                        t1 = 1;
                        continue L0;
                    case 9:
                        if (this._bz(this._bc.j, false)) {
                            this._bg.p = 13;
                        }
                        b = true;
                        break;
                }
                break;
            }
            if (b && this._bg.p == 13 && this._de == 2) {
                b = false;
            }
            if (!b && this._bm == 11 && this._be.c > 1) {
                this._b4 = 1;
                this._bm = 7;
                this._bg = this._bj();
                return true;
            }
        }
        if (!this._bn && (this.a7 == 1 || this.a7 == 3 || this.a7 == 4)) {
            this._bn = true;
            if (this._bp && (this.a7 != 1 || stringCompare1(this.ag, "html", StringUtilities.g) != 0)) {
                this._bg.e = this._bm;
                let d = this._bi("html", 1, null);
                this._da();
                this._bg = d;
                d.g = true;
                d.f = false;
                this._bm = 1;
            }
            return true;
        }
        return true;
    }
    _bv() {
        let a = this._bc.j;
        if (a == '<') {
            a = this._bc.k();
            return this._by(a);
        }
        else if (a != "\uffff") {
            if (this._bg.c != null && this._bg.c.e.a == 1) {
                this._b2 = '\0';
                this._bm = 8;
                return false;
            }
            else if (this._bz(a, true)) {
                this._bg.p = 13;
            }
            return true;
        }
        this._bm = 11;
        return false;
    }
    _by(a) {
        if (a == '%') {
            return this._bq();
        }
        if (a == '!') {
            a = this._bc.k();
            if (a == '-') {
                return this._bs();
            }
            else if (a == '[') {
                return this._bt();
            }
            else if (a != '_' && !isLetter(a)) {
                let b = this._bc.y(this._cz, "Recovering", ">");
                this._c4("Ignoring invalid markup '<!" + b + ">");
                return false;
            }
            else {
                let c = this._bc.z(this._cz, SgmlReader._ce, false);
                if (c == "DOCTYPE") {
                    this._c7();
                    if (this.ab("SYSTEM") == null && this.ab("PUBLIC") != null) {
                        this._bg.a("SYSTEM", "", '\"', this._bb == 0);
                    }
                    if (this._b0) {
                        return false;
                    }
                    else {
                        this._bg.p = 10;
                        return true;
                    }
                }
                else {
                    this._c4("Invalid declaration '<!{0}...'.  Expecting '<!DOCTYPE' only.", c);
                    this._bc.y(null, "Recovering", ">");
                    return false;
                }
            }
        }
        else if (a == '?') {
            this._bc.k();
            return this._bw();
        }
        else if (a == '/') {
            return this._bu();
        }
        else {
            return this._bx(a);
        }
    }
    _cr(a) {
        let b = this._bc.z(this._cz, a, false);
        switch (this._bb) {
            case 1:
                b = b.toUpperCase();
                break;
            case 2:
                b = b.toLowerCase();
                break;
        }
        return this._dh.b(b);
    }
    _bx(a) {
        let b = null;
        if (this._bm != 10) {
            if (SgmlReader._cv.indexOf(a) >= 0) {
                this._cz.c = 0;
                this._cz.h('<');
                this._bm = 9;
                return false;
            }
            b = this._cr(SgmlReader._cv);
        }
        else {
            this._bm = 1;
        }
        let c = this._bi(b, 1, null);
        c.f = false;
        this._db(c);
        a = this._bc.l();
        this._dg.ac();
        while (a != "\uffff" && a != '>') {
            if (a == '/') {
                this._dg.h();
                c.f = true;
                a = this._bc.k();
                if (a != '>') {
                    this._c5("Expected empty start tag '/>' sequence instead of '{0}'", a);
                    this._bc.y(null, "Recovering", ">");
                    return false;
                }
                break;
            }
            else if (a == '<') {
                this._c4("Start tag '{0}' is missing '>'", b);
                break;
            }
            let d = this._cr(SgmlReader._cb);
            a = this._bc.l();
            if (d == "," || d == "=" || d == ":" || d == ";") {
                continue;
            }
            let e = null;
            let f = '\0';
            if (a == '=' || a == '\"' || a == '\'') {
                if (a == '=') {
                    this._bc.k();
                    a = this._bc.l();
                }
                if (a == '\'' || a == '\"') {
                    f = a;
                    e = this._cq(this._cz, a);
                }
                else if (a != '>') {
                    let g = SgmlReader._cc;
                    e = this._bc.z(this._cz, g, false);
                }
            }
            if (d.length > 0) {
                let h = c.a(d, e, f, this._bb == 0);
                if (h == null) {
                    this._c4("Duplicate attribute '{0}' ignored", d);
                }
                else {
                    this._dc(c, h);
                    if (startsWith1(h.e, "xmlns:", StringUtilities.g)) {
                        let i = h.e.substr(6);
                        this._dg.x(i, h.f);
                    }
                }
            }
            a = this._bc.l();
        }
        if (a == "\uffff") {
            this._bc.aj("Unexpected EOF parsing start tag '{0}'", b);
        }
        else if (a == '>') {
            this._bc.k();
        }
        if (this.x == 1) {
            if (this._b5 == 1) {
                this._bm = 11;
                return false;
            }
            this._b5++;
        }
        this._dd(c);
        return true;
    }
    _bu() {
        this._dg.h();
        this._bm = 2;
        this._bc.k();
        let a = this._cr(SgmlReader._cv);
        let b = this._bc.l();
        if (b != '>') {
            this._c5("Expected empty start tag '/>' sequence instead of '{0}'", b);
            this._bc.y(null, "Recovering", ">");
        }
        this._bc.k();
        this._ca = a;
        let c = (this._bb == 0);
        this._bg = this._be.item(this._be.c - 1);
        for (let d = this._be.c - 1; d > 0; d--) {
            let e = this._be.item(d);
            if (c && stringCompare1(e.j, a, 1) == 0) {
                this._ca = e.j;
                return true;
            }
            else if (e.j == a) {
                return true;
            }
        }
        this._c4("No matching start tag for '</{0}>'", a);
        this._bm = 1;
        return false;
    }
    _bq() {
        let a = "<%" + this._bc.y(this._cz, "AspNet", "%>") + "%>";
        this._bi(null, 4, a);
        return true;
    }
    _bs() {
        let a = this._bc.k();
        if (a != '-') {
            this._c5("Expecting comment '<!--' but found {0}", a);
            this._bc.y(null, "Comment", ">");
            return false;
        }
        let b = this._bc.y(this._cz, "Comment", "-->");
        let c = b.indexOf("--");
        while (c >= 0) {
            let d = c + 2;
            while (d < b.length && b.charAt(d) == '-') {
                d++;
            }
            if (c > 0) {
                b = b.substr(0, c - 1) + "-" + b.substr(d);
            }
            else {
                b = "-" + b.substr(d);
            }
            c = b.indexOf("--");
        }
        if (b.length > 0 && b.charAt(b.length - 1) == '-') {
            b += " ";
        }
        this._bi(null, 8, b);
        return true;
    }
    _bt() {
        let a = this._bc.k();
        a = this._bc.l();
        let b = this._bc.z(this._cz, SgmlReader._cd, false);
        if (b != "CDATA") {
            this._c4("Expecting CDATA but found '{0}'", b);
            this._bc.y(null, "CDATA", ">");
            return false;
        }
        a = this._bc.l();
        if (a != '[') {
            this._c5("Expecting '[' but found '{0}'", a);
            this._bc.y(null, "CDATA", ">");
            return false;
        }
        let c = this._bc.y(this._cz, "CDATA", "]]>");
        this._bi(null, 4, c);
        return true;
    }
    _c7() {
        let a = this._bc.l();
        let b = this._cr(SgmlReader._ch);
        this._bi(b, 10, null);
        a = this._bc.l();
        if (a != '>') {
            let c = "";
            let d = "";
            let e = "";
            if (a != '[') {
                let f = this._bc.z(this._cz, SgmlReader._ch, false);
                if (f == "PUBLIC") {
                    a = this._bc.l();
                    if (a == '\"' || a == '\'') {
                        d = this._bc.x(this._cz, a);
                        this._bg.a(f, d, a, this._bb == 0);
                    }
                }
                else if (f != "SYSTEM") {
                    this._c4("Unexpected token in DOCTYPE '{0}'", f);
                    this._bc.y(null, "DOCTYPE", ">");
                }
                a = this._bc.l();
                if (a == '\"' || a == '\'') {
                    f = this._dh.b("SYSTEM");
                    e = this._bc.x(this._cz, a);
                    this._bg.a(f, e, a, this._bb == 0);
                }
                a = this._bc.l();
            }
            if (a == '[') {
                c = this._bc.y(this._cz, "Internal Subset", "]");
                this._bg.k = c;
            }
            a = this._bc.l();
            if (a != '>') {
                this._c5("Expecting end of DOCTYPE tag, but found '{0}'", a);
                this._bc.y(null, "DOCTYPE", ">");
            }
            if (this._bk == null) {
                this._cf = b;
                this._cn = d;
                this._ct = e;
                this._cs = c;
                this._c3(this._bc.ae);
            }
        }
        this._bc.k();
    }
    _bw() {
        let a = this._bc.z(this._cz, SgmlReader._cl, false);
        let b = null;
        if (this._bc.j != '?') {
            b = this._bc.y(this._cz, "Processing Instruction", ">");
        }
        else {
            b = this._bc.y(this._cz, "Processing Instruction", ">");
        }
        if (a != "xml") {
            this._bi(this._dh.b(a), 7, b);
            return true;
        }
        return false;
    }
    _bz(a, b) {
        let c = !b || this._bc.g;
        if (b) {
            this._cz.c = 0;
        }
        this._bm = 5;
        while (a != "\uffff") {
            if (a == '<') {
                a = this._bc.k();
                if (a == '/' || a == '!' || a == '?' || isLetter(a)) {
                    this._bm = 6;
                    this._b2 = a;
                    break;
                }
                else {
                    this._cz.h('<');
                    this._cz.h(a);
                    c = false;
                    a = this._bc.k();
                }
            }
            else if (a == '&') {
                this._c1(this._cz, '<');
                c = false;
                a = this._bc.j;
            }
            else {
                if (!this._bc.g) {
                    c = false;
                }
                this._cz.h(a);
                a = this._bc.k();
            }
        }
        let d = this._cz.toString();
        this._bi(null, 3, d);
        return c;
    }
    _cq(a, b) {
        a.c = 0;
        let c = this._bc.k();
        while (c != "\uffff" && c != b) {
            if (c == '&') {
                this._c1(this._cz, b);
                c = this._bc.j;
            }
            else {
                a.h(c);
                c = this._bc.k();
            }
        }
        this._bc.k();
        return a.toString();
    }
    _br() {
        let a = this._bc.g;
        this._cz.c = 0;
        let b = this._bc.j;
        if (this._b2 != '\0') {
            this._c8();
            switch (this._b2) {
                case '!':
                    this._b2 = ' ';
                    return this._bs();
                case '?':
                    this._b2 = ' ';
                    return this._bw();
                case '/':
                    this._bm = 2;
                    return true;
                case ' ': break;
            }
        }
        else {
            b = this._bc.k();
        }
        while (b != "\uffff") {
            if (b == '<') {
                b = this._bc.k();
                if (b == '!') {
                    b = this._bc.k();
                    if (b == '-') {
                        if (a) {
                            this._b2 = ' ';
                            return this._bs();
                        }
                        else {
                            this._b2 = '!';
                            break;
                        }
                    }
                    else {
                        this._cz.h('<');
                        this._cz.h('!');
                        this._cz.h(b);
                        a = false;
                    }
                }
                else if (b == '?') {
                    this._bc.k();
                    if (a) {
                        this._b2 = ' ';
                        return this._bw();
                    }
                    else {
                        this._b2 = '?';
                        break;
                    }
                }
                else if (b == '/') {
                    let c = this._cz.toString();
                    if (this._bu() && this._ca == this._bg.j) {
                        if (a || c == "") {
                            return true;
                        }
                        else {
                            this._b2 = '/';
                            this._cz.c = 0;
                            this._cz.l(c);
                            this._bm = 8;
                            break;
                        }
                    }
                    else {
                        this._cz.c = 0;
                        this._cz.l(c);
                        this._cz.l("</" + this._ca + ">");
                        a = false;
                    }
                }
                else {
                    this._cz.h('<');
                    this._cz.h(b);
                    a = false;
                }
            }
            else {
                if (!this._bc.g && a) {
                    a = false;
                }
                this._cz.h(b);
            }
            b = this._bc.k();
        }
        let d = this._cz.toString();
        this._bi(null, 4, d);
        if (this._b2 == '\0') {
            this._b2 = ' ';
        }
        return true;
    }
    _c1(a, b) {
        let c = this._bc.k();
        if (c == '#') {
            let d = this._bc.s();
            a.l(d);
            c = this._bc.j;
        }
        else {
            this._cy.c = 0;
            while (c != "\uffff" && (isLetter(c) || c == '_' || c == '-')) {
                this._cy.h(c);
                c = this._bc.k();
            }
            let e = this._cy.toString();
            if (this._bk != null && e != "") {
                let f = this._bk.f(e);
                if (f != null) {
                    if (f.e) {
                        a.l(f.t);
                        if (c != b) {
                            c = this._bc.k();
                        }
                        return;
                    }
                    else {
                        let g = new Entity(0, e, f.w, f.aa, this._bc.v);
                        f.ak(this._bc, new Uri(0, f.aa));
                        this._bc = g;
                        this._bc.k();
                        return;
                    }
                }
                else {
                    this._c4("Undefined entity '{0}'", e);
                }
            }
            a.l("&");
            a.l(e);
            if (c != b) {
                a.h(c);
                c = this._bc.k();
            }
        }
    }
    get_d() {
        return this._bm == 11;
    }
    get d() {
        return this.get_d();
    }
    au() {
        this.disposeCore(true);
    }
    disposeCore(a) {
        if (a) {
            if (this._bc != null) {
                this._bc.af();
                this._bc = null;
            }
            if (this._b9 != null) {
                this._b9.i();
                this._b9 = null;
            }
        }
    }
    get_a3() {
        if (this._bm == 0) {
            return 0;
        }
        else if (this._bm == 11) {
            return 3;
        }
        return 1;
    }
    get a3() {
        return this.get_a3();
    }
    aq() {
        if (this._bg.p == 1) {
            this._cz.c = 0;
            while (this.t()) {
                switch (this.a7) {
                    case 4:
                    case 14:
                    case 13:
                    case 3:
                        this._cz.l(this._bg.k);
                        break;
                    default: return this._cz.toString();
                }
            }
            return this._cz.toString();
        }
        return this._bg.k;
    }
    ao() {
        let a = new StringWriter(0);
        {
            let b = new XmlTextWriter(1, a);
            try {
                switch (this.a7) {
                    case 1:
                        this.t();
                        while (!this.d && this.a7 != 15) {
                            b.ac(this, true);
                        }
                        this.t();
                        break;
                    case 2:
                        a.v(this.ar);
                        break;
                    default: break;
                }
            }
            finally {
                if (b != null) {
                    b.dispose();
                }
            }
        }
        return a.toString();
    }
    ap() {
        let a = new StringWriter(0);
        {
            let b = new XmlTextWriter(1, a);
            try {
                b.ac(this, true);
            }
            finally {
                if (b != null) {
                    b.dispose();
                }
            }
        }
        return a.toString();
    }
    get_a5() {
        return this._dh;
    }
    get a5() {
        return this.get_a5();
    }
    ah(a) {
        return this._dg.lookupNamespace(a);
    }
    a1() {
        throw new InvalidOperationException(1, "Not on an entity reference.");
    }
    u() {
        if (this._bm == 3) {
            this._bm = 4;
            return true;
        }
        else if (this._bm == 4) {
            return false;
        }
        throw new InvalidOperationException(1, "Not on an attribute.");
    }
    _db(a) {
        if (this._bk != null) {
            let b = this._bk.d(a.j);
            if (b != null) {
                a.c = b;
                if (b.e.a == 3) {
                    a.f = true;
                }
            }
        }
    }
    _dc(a, b) {
        let c = a.c;
        if (c != null) {
            let d = c.c(b.e);
            if (d != null) {
                b.a = d;
            }
        }
    }
    _dd(a) {
        if (this._bk != null) {
            let b = this._dh.b(a.j.toUpperCase());
            let c = 0;
            let d = this._be.c - 2;
            if (a.c != null) {
                for (c = d; c > 0; c--) {
                    let e = this._be.item(c);
                    if (e.f) {
                        continue;
                    }
                    let f = e.c;
                    if (f != null) {
                        if (f.i == this._bk.r) {
                            break;
                        }
                        if (f.f(b, this._bk)) {
                            break;
                        }
                        else if (!f.g) {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            if (c == 0) {
            }
            else if (c < d) {
                let g = this._be.item(d);
                if (c == d - 1 && b == g.j) {
                }
                else {
                    let h = "";
                    for (let i = d; i >= c + 1; i--) {
                        if (h != "") {
                            h += ",";
                        }
                        let j = this._be.item(i);
                        h += "<" + j.j + ">";
                    }
                    this._c4("Element '{0}' not allowed inside '{1}', closing {2}.", b, g.j, h);
                }
                this._bm = 7;
                this._bf = a;
                this._c8();
                this._b4 = c + 1;
            }
        }
    }
}
SgmlReader.$t = markType(SgmlReader, 'SgmlReader', XmlReader.$);
SgmlReader._ce = " \t\r\n><";
SgmlReader._cv = " \t\r\n=/><";
SgmlReader._cb = " \t\r\n='\"/>";
SgmlReader._cc = " \t\r\n>";
SgmlReader._cd = "\t\r\n[<>";
SgmlReader._ch = " \t\r\n>";
SgmlReader._cl = " \t\r\n?";
/**
 * @hidden
 */
export class OverrideContentTypePart extends Base {
    constructor(a, b) {
        super();
        this.b = null;
        this.a = null;
        this.a = a;
        this.b = b != null ? b : a.contentType;
    }
    get $package() {
        return this.a.$package;
    }
    get uri() {
        return this.a.uri;
    }
    get contentType() {
        return this.b;
    }
    getStream(a, b) {
        return this.a.getStream(a, b);
    }
    createRelationship(a, b, c, d) {
        return this.a.createRelationship(a, b, c, d);
    }
    getRelationships() {
        return this.a.getRelationships();
    }
    getRelationship(a) {
        return this.a.getRelationship(a);
    }
}
OverrideContentTypePart.$t = markType(OverrideContentTypePart, 'OverrideContentTypePart', Base.$, [IPackagePart_$type]);
/**
 * @hidden
 */
export let IZipFile_$type = new Type(null, 'IZipFile');
/**
 * @hidden
 */
export let IZipEntry_$type = new Type(null, 'IZipEntry');
/**
 * @hidden
 */
export class InvalidPackage extends Base {
    createPart(a, b) {
        throw new InvalidOperationException(0);
    }
    createRelationship(a, b, c, d) {
        throw new InvalidOperationException(0);
    }
    dispose() {
        throw new InvalidOperationException(0);
    }
    getPart(a) {
        throw new InvalidOperationException(0);
    }
    getParts() {
        throw new InvalidOperationException(0);
    }
    getRelationship(a) {
        throw new InvalidOperationException(0);
    }
    getRelationships() {
        throw new InvalidOperationException(0);
    }
    partExists(a) {
        throw new InvalidOperationException(0);
    }
}
InvalidPackage.$t = markType(InvalidPackage, 'InvalidPackage', Base.$, [IPackage_$type]);
/**
 * @hidden
 */
export class ZipFile extends Base {
    constructor() {
        super();
        this.a = new List$1(IZipEntry_$type, 0);
        this.b = null;
        this.b = typeof JSZip.default === "function" ? new JSZip.default() : new JSZip();
    }
    createFile(fileName, directoryName, stream) {
        arguments[2] = (typeof arguments[2] === 'string' ? b64toUint8Array(arguments[2]) : arguments[2]);
        arguments[2] = (typeCast(Stream.$, arguments[2]) ? arguments[2] : new MemoryStream(2, arguments[2]));
        return this._createFile$i.apply(this, arguments);
    }
    _createFile$i(a, b, c) {
        return ZipEntry.a(a, b, c);
    }
    load(stream) {
        arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
        arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
        return this._load$i.apply(this, arguments);
    }
    _load$i(a) {
        let b = null;
        let c = typeCast(MemoryStream.$, a);
        if (c != null) {
            b = c.getBuffer();
            if (b.length != a.length) {
                b = null;
            }
        }
        if (b == null) {
            b = new Array(a.length);
            a.read(b, 0, b.length);
        }
        let d = null;
        let e = null;
        let f = new ExternalEventWorkItem$1(IZipFile_$type);
        let g = (h) => {
            let i = (Base.getArrayOfValues(this.b.files));
            for (let j = 0; j < i.length; j++) {
                this.a.add(new ZipEntry(0, i[j]));
            }
            f.ag(this);
        };
        let h = (i) => f.ag(null, new BaseError(1, i != null ? i.toString() : "Load error"));
        this.b.loadAsync(b).then(g, h);
        return f;
    }
    get entries() {
        return this.a;
    }
    save(stream) {
        arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
        arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
        return this._save$i.apply(this, arguments);
    }
    _save$i(a) {
        for (let b of fromEnum(this.a)) {
            let c = b;
            let d = c.name;
            if (d.charAt(0) == '/') {
                d = d.substr(1);
            }
            if (c.isDirectory) {
                this.b.folder(d);
            }
            else {
                let e = new Array(c.b.length);
                c.b.position = 0;
                c.b.read(e, 0, e.length);
                this.b.file(d, e);
            }
        }
        let f = (JSZip.support.uint8array) ? "uint8array" : "array";
        let g = null;
        let h = null;
        let i = new ExternalEventWorkItem();
        let j = (k) => {
            let l = k;
            a.write(l, 0, l.length);
            i.af();
        };
        let k = (l) => i.af(new BaseError(1, l != null ? l.toString() : "Load error"));
        this.b.generateAsync({ type: f, compression: 'DEFLATE' }).then(j, k);
        return i;
    }
}
ZipFile.$t = markType(ZipFile, 'ZipFile', Base.$, [IZipFile_$type]);
/**
 * @hidden
 */
export class ZipEntry extends Base {
    constructor(a, ..._rest) {
        super();
        this.c = null;
        this.b = null;
        this._name = null;
        this._isDirectory = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    this.c = c;
                    this.isDirectory = (this.c.dir);
                    this.name = (this.c.name);
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.name = c;
                    this.b = d;
                }
                break;
        }
    }
    get name() {
        return this._name;
    }
    set name(a) {
        this._name = a;
    }
    get isDirectory() {
        return this._isDirectory;
    }
    set isDirectory(a) {
        this._isDirectory = a;
    }
    static a(a, b, c) {
        return new ZipEntry(1, stringReplace(IOPath.combine1(b, a), '\\', '/'), c);
    }
    openReader() {
        if (this.c != null) {
            let a = (JSZip.support.uint8array);
            let b = null;
            let c = null;
            let d = new ExternalEventWorkItem$1(Stream.$);
            let e = a ? "uint8array" : "binarystring";
            let f = (g) => d.ag(new MemoryStream(2, g));
            let g = (h) => d.ag(null, new BaseError(1, h != null ? h.toString() : "Open ZipObject Error"));
            this.c.async(e).then(f, g);
            return d;
        }
        return WorkItem.g(Stream.$, this.b);
    }
}
ZipEntry.$t = markType(ZipEntry, 'ZipEntry', Base.$, [IZipEntry_$type]);
/**
 * @hidden
 */
export class PackagePartExposedStream extends Stream {
    constructor(a) {
        super();
        this._o = null;
        this._o = a;
    }
    get_canRead() {
        return this._o.canRead;
    }
    get canRead() {
        return this.get_canRead();
    }
    get_canSeek() {
        return this._o.canSeek;
    }
    get canSeek() {
        return this.get_canSeek();
    }
    get_canWrite() {
        return this._o.canWrite;
    }
    get canWrite() {
        return this.get_canWrite();
    }
    flush() {
        this._o.flush();
    }
    get_length() {
        return this._o.length;
    }
    get length() {
        return this.get_length();
    }
    get_position() {
        return this._o.position;
    }
    set_position(a) {
        this._o.position = a;
    }
    get position() {
        return this.get_position();
    }
    set position(a) {
        this.set_position(a);
    }
    read(a, b, c) {
        return this._o.read(a, b, c);
    }
    seek(a, b) {
        return this._o.seek(a, b);
    }
    setLength(a) {
        this._o.setLength(a);
    }
    write(a, b, c) {
        this._o.write(a, b, c);
    }
}
PackagePartExposedStream.$t = markType(PackagePartExposedStream, 'PackagePartExposedStream', Stream.$);
/**
 * @hidden
 */
export class PackageRelationship extends Base {
    constructor(a, ..._rest) {
        super();
        this._sourceUri = null;
        this._targetUri = null;
        this._id = null;
        this._relationshipType = null;
        this._targetMode = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = [new Uri(1, "/", 2), c, d, e, f];
                    {
                        let i = g[0];
                        let j = g[1];
                        let k = g[2];
                        let l = g[3];
                        let m = g[4];
                        this.sourceUri = i;
                        this.targetMode = k;
                        this.targetUri = j;
                        this.id = m;
                        this.relationshipType = l;
                    }
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = _rest[4];
                    this.sourceUri = c;
                    this.targetMode = e;
                    this.targetUri = d;
                    this.id = g;
                    this.relationshipType = f;
                }
                break;
        }
    }
    get sourceUri() {
        return this._sourceUri;
    }
    set sourceUri(a) {
        this._sourceUri = a;
    }
    get_targetUri() {
        return this._targetUri;
    }
    set_targetUri(a) {
        this._targetUri = a;
    }
    get targetUri() {
        return this.get_targetUri();
    }
    set targetUri(a) {
        this.set_targetUri(a);
    }
    get id() {
        return this._id;
    }
    set id(a) {
        this._id = a;
    }
    get relationshipType() {
        return this._relationshipType;
    }
    set relationshipType(a) {
        this._relationshipType = a;
    }
    get targetMode() {
        return this._targetMode;
    }
    set targetMode(a) {
        this._targetMode = a;
    }
}
PackageRelationship.$t = markType(PackageRelationship, 'PackageRelationship', Base.$, [IPackageRelationship_$type]);
/**
 * @hidden
 */
export class InvalidTargetPackageRelationship extends PackageRelationship {
    constructor(a, b, c, d, e) {
        super(1, a, null, c, d, e);
        this._targetString = null;
        this.targetString = b;
    }
    get_targetUri() {
        if (this.targetString != null && super.get_targetUri() == null) {
            this.targetUri = new Uri(1, this.targetString, 0);
        }
        return super.get_targetUri();
    }
    set_targetUri(a) {
        super.set_targetUri(a);
    }
    get targetString() {
        return this._targetString;
    }
    set targetString(a) {
        this._targetString = a;
    }
}
InvalidTargetPackageRelationship.$t = markType(InvalidTargetPackageRelationship, 'InvalidTargetPackageRelationship', PackageRelationship.$, [IInvalidPackageRelationshipTarget_$type]);
/**
 * @hidden
 */
export class PackagePart extends Base {
    constructor(a, b, c) {
        super();
        this.f = null;
        this.d = null;
        this._$package = null;
        this._uri = null;
        this._contentType = null;
        this.b = null;
        this.f = new MemoryStream(0);
        this.$package = a;
        this.uri = b;
        this.contentType = c;
        let d = typeCast(Package.$, this.$package);
        if (d == null) {
            throw new ArgumentException(2, "The expected type for package parameter is type of Package.", "package");
        }
        if (d._q == 2) {
            let e = IOPath.getFileName(b.toString());
            let f = IOPath.getDirectoryName(b.toString());
            f = stringReplace(f, '\\', '/');
            this.b = d._c._createFile$i(e, f, new MemoryStream(0));
            d._c.entries.add(this.b);
        }
    }
    get $package() {
        return this._$package;
    }
    set $package(a) {
        this._$package = a;
    }
    get uri() {
        return this._uri;
    }
    set uri(a) {
        this._uri = a;
    }
    get contentType() {
        return this._contentType;
    }
    set contentType(a) {
        this._contentType = a;
    }
    getStream(a, b) {
        return WorkItemExtensions.l(Stream.$, Stream.$, this.b.openReader(), (c) => WorkItem.g(Stream.$, new PackagePartExposedStream(WorkItemExtensions.m(Stream.$, c))));
    }
    createRelationship(a, b, c, d) {
        let e = new PackageRelationship(1, this.uri, a, b, c, d);
        return this.a(e);
    }
    createExternalRelationship(a, b, c) {
        let d;
        if (((() => { let e = Uri.tryCreate(a, 0, d); d = e.p2; return e.ret; })())) {
            return this.createRelationship(d, 1, b, c);
        }
        let e = new InvalidTargetPackageRelationship(this.uri, a, 1, b, c);
        return this.a(e);
    }
    a(a) {
        if (this.d == null) {
            this.d = new Dictionary$2(String_$type, IPackageRelationship_$type, 1, 1);
        }
        if (this.d.count == 0) {
            let b = IOPath.getFileName(this.uri.toString()) + ".rels";
            let c = IOPath.getDirectoryName(this.uri.toString()) + "/_rels";
            if (c.charAt(0) == '\\') {
                c = c.substr(1);
            }
            let d = this.$package;
            let e = d._c._createFile$i(b, c, this.f);
            d._c.entries.add(e);
        }
        this.d.addItem(a.id, a);
        return a;
    }
    getRelationships() {
        this.j();
        return this.d.values;
    }
    getRelationship(a) {
        this.j();
        let b = null;
        let c = this.d.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    get e() {
        return this.getRelationships();
    }
    c() {
        this.d = new Dictionary$2(String_$type, IPackageRelationship_$type, 0);
        let a = stringReplace(IOPath.getDirectoryName(DocCoreExtensions.fixDirectoryPath(this.uri.toString())), "\\", "/");
        let b = IOPath.getFileName(this.uri.toString());
        let c = this.$package;
        let d = c._c;
        let e = a + "/_rels/" + b + ".rels";
        let f = Enumerable.u(IZipEntry_$type, d.entries, (g) => g.name == e);
        if (Enumerable.aj(IZipEntry_$type, f) != 1) {
            return null;
        }
        c._b = Enumerable.ad(IZipEntry_$type, f);
        return Async.o(Stream.$, c._b.openReader(), (g) => {
            this.f = g;
            {
                let h = new XmlTextReader(1, this.f);
                try {
                    while (h.t()) {
                        if (h.l() && h.ai == "Relationship") {
                            if (h.e) {
                                let i = h.ab("TargetMode");
                                let j = h.ab("Target");
                                let k = h.ab("Id");
                                let l = h.ab("Type");
                                let m = 0;
                                if (stringIsNullOrEmpty(i) == false) {
                                    m = EnumUtil.getEnumValue(RelationshipTargetMode_$type, EnumUtil.parse(RelationshipTargetMode_$type, i, true));
                                }
                                let n = new PackageRelationship(1, this.uri, new Uri(1, j, 0), m, l, k);
                                this.d.addItem(k, n);
                            }
                        }
                    }
                }
                finally {
                    if (h != null) {
                        h.dispose();
                    }
                }
            }
            return null;
        });
    }
    j() {
        if (this.d == null) {
            this.d = new Dictionary$2(String_$type, IPackageRelationship_$type, 0);
        }
    }
}
PackagePart.$t = markType(PackagePart, 'PackagePart', Base.$, [IPackagePart_$type, IPackagePartEx_$type]);
/**
 * @hidden
 */
export class Package extends Base {
    constructor() {
        super();
        this._i = false;
        this._j = false;
        this._s = null;
        this._t = null;
        this._r = null;
        this._m = new Dictionary$2(String_$type, PackagePart.$, 0);
        this._p = null;
        this._k = new Dictionary$2(String_$type, String_$type, 2, StringComparer.g);
        this._l = new Dictionary$2(String_$type, String_$type, 2, StringComparer.g);
        this._q = 0;
        this._c = null;
        this._b = null;
        this._a = null;
        this._h = null;
    }
    get _o() {
        return this._p;
    }
    get _n() {
        return this._m;
    }
    static _d(a, b) {
        return Package._e(a, b, new ZipFile());
    }
    static _e(a, b, c) {
        let d = new Package();
        d._q = b;
        d._c = c;
        if (b == 3) {
            a.position = 0;
            return WorkItemExtensions.g(IPackage_$type, WorkItemExtensions.c(WorkItemExtensions.c(d._c._load$i(a), runOn(d, d._f)), runOn(d, d._g)), () => d);
        }
        else {
            d._s = a;
            return WorkItem.g(IPackage_$type, d);
        }
    }
    createPart(a, b) {
        if (!this._i) {
            this._ah();
        }
        let c = new PackagePart(this, a, b);
        this._l.addItem(a.toString(), b);
        if (this.partExists(a)) {
            this._m.item(a.originalString, c);
        }
        else {
            this._m.addItem(a.originalString, c);
        }
        return c;
    }
    createRelationship(a, b, c, d) {
        if (!this._j) {
            this._ai();
        }
        let e = new PackageRelationship(0, a, b, c, d);
        this._p.add(e);
        return e;
    }
    getRelationships() {
        if (this._p == null) {
            this._ai();
        }
        return this._p;
    }
    getPart(a) {
        let b = null;
        if (this.partExists(a)) {
            b = this._m.item(a.originalString);
        }
        return b;
    }
    getParts() {
        return this._m.values;
    }
    getRelationship(a) {
        if (this._p == null) {
            this._ai();
        }
        return Enumerable.af(IPackageRelationship_$type, Enumerable.u(IPackageRelationship_$type, this._p, (b) => b.id == a));
    }
    _aa(a) {
        if (this._l.containsKey(a)) {
            return this._l.item(a);
        }
        let b = IOPath.getExtension(a).substr(1);
        if (this._k.containsKey(b)) {
            return this._k.item(b);
        }
        return null;
    }
    _f() {
        let a = Enumerable.ad(IZipEntry_$type, Enumerable.u(IZipEntry_$type, this._c.entries, (b) => b.name == "[Content_Types].xml"));
        return WorkItemExtensions.c(Async.o(Stream.$, a.openReader(), (b) => {
            {
                let c = new XmlTextReader(1, b);
                try {
                    while (c.t()) {
                        if (c.l() && c.ai == "Types") {
                            while (c.t()) {
                                if (c.l()) {
                                    if (c.ai == "Override") {
                                        let d = c.ab("PartName");
                                        let e = c.ab("ContentType");
                                        if (!this._l.containsKey(d)) {
                                            this._l.addItem(d, e);
                                        }
                                    }
                                    else if (c.ai == "Default") {
                                        let f = c.ab("Extension");
                                        let g = c.ab("ContentType");
                                        if (!this._k.containsKey(f)) {
                                            this._k.addItem(f, g);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                finally {
                    if (c != null) {
                        c.dispose();
                    }
                }
            }
            return null;
        }), () => Async.d(IZipEntry_$type, Enumerable.u(IZipEntry_$type, this._c.entries, (b) => b.name != "[Content_Types].xml" && !b.isDirectory), (b) => {
            let c = "/" + b.name;
            let d = this._aa(c);
            let e = new PackagePart(this, new Uri(1, c, 2), d);
            e.b = b;
            this._m.addItem(e.uri.originalString, e);
            return e.c();
        }));
    }
    _g() {
        this._p = new List$1(IPackageRelationship_$type, 0);
        this._b = Enumerable.ad(IZipEntry_$type, Enumerable.u(IZipEntry_$type, this._c.entries, (a) => a.name == "_rels/.rels"));
        return Async.o(Stream.$, this._b.openReader(), (a) => {
            this._t = a;
            {
                let b = new XmlTextReader(1, a);
                try {
                    while (b.t()) {
                        if (b.l() && b.ai == "Relationship") {
                            if (b.e) {
                                let c = b.ab("TargetMode");
                                let d = b.ab("Id");
                                let e = b.ab("Type");
                                let f = b.ab("Target");
                                let g = 0;
                                if (stringIsNullOrEmpty(c) == false) {
                                    g = EnumUtil.getEnumValue(RelationshipTargetMode_$type, EnumUtil.parse(RelationshipTargetMode_$type, c, true));
                                }
                                let h = new PackageRelationship(1, new Uri(1, "/", 2), new Uri(1, f, 0), g, e, d);
                                this._p.add(h);
                            }
                        }
                    }
                }
                finally {
                    if (b != null) {
                        b.dispose();
                    }
                }
            }
            return null;
        });
    }
    partExists(a) {
        return this._m.containsKey(a.originalString);
    }
    dispose() {
        if (this._q == 2) {
            if (this._t != null) {
                RelationshipsWriter.j(this._o, this._t);
            }
            for (let a of fromEnum(this._m.values)) {
                if (a.f != null) {
                    RelationshipsWriter.j(a.e, a.f);
                }
            }
            if (this._r != null) {
                ContentTypesWriter.j(this, this._r);
            }
            if (this._s != null) {
                this._h = WorkItem.d(() => this._c._save$i(this._s));
            }
        }
    }
    _ah() {
        this._r = new MemoryStream(0);
        this._a = ZipEntry.a("[Content_Types].xml", "/", this._r);
        this._c.entries.add(this._a);
        this._i = true;
    }
    _ai() {
        this._t = new MemoryStream(0);
        this._b = ZipEntry.a(".rels", "/_rels", this._t);
        this._c.entries.add(this._b);
        if (this._p == null) {
            this._p = new List$1(IPackageRelationship_$type, 0);
        }
        this._j = true;
    }
}
Package.$t = markType(Package, 'Package', Base.$, [IPackage_$type]);
Package._v = "http://schemas.openxmlformats.org/package/2006/content-types";
/**
 * @hidden
 */
export class PackageFactory extends Base {
    open(stream, packageMode) {
        arguments[0] = (typeof arguments[0] === 'string' ? b64toUint8Array(arguments[0]) : arguments[0]);
        arguments[0] = (typeCast(Stream.$, arguments[0]) ? arguments[0] : new MemoryStream(2, arguments[0]));
        return this._open$i.apply(this, arguments);
    }
    _open$i(a, b) {
        return Package._d(a, b);
    }
}
PackageFactory.$t = markType(PackageFactory, 'PackageFactory', Base.$, [IPackageFactory_$type]);
/**
 * @hidden
 */
export class ContentTypesWriter extends Base {
    static k(a, b, c) {
        a.an("Default", ContentTypesWriter.b);
        a.h("Extension", c);
        a.h("ContentType", b);
        a.v();
    }
    static l(a, b, c) {
        a.an("Override", ContentTypesWriter.b);
        a.h("PartName", c);
        a.h("ContentType", b);
        a.v();
    }
    static j(a, b) {
        {
            let c = new XmlTextWriter(0, b, Encoding.uTF8);
            try {
                c.ad("xml", "version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"");
                c.an("Types", ContentTypesWriter.b);
                ContentTypesWriter.k(c, ContentTypesWriter.d, "rels");
                ContentTypesWriter.k(c, "application/xml", "xml");
                for (let d of fromEnum(a._l)) {
                    ContentTypesWriter.l(c, d.value, d.key);
                }
                c.v();
            }
            finally {
                if (c != null) {
                    c.dispose();
                }
            }
        }
    }
}
ContentTypesWriter.$t = markType(ContentTypesWriter, 'ContentTypesWriter');
ContentTypesWriter.d = "application/vnd.openxmlformats-package.relationships+xml";
ContentTypesWriter.b = "http://schemas.openxmlformats.org/package/2006/content-types";
/**
 * @hidden
 */
export class RelationshipsWriter extends Base {
    static j(a, b) {
        {
            let c = new XmlTextWriter(0, b, Encoding.uTF8);
            try {
                c.ad("xml", "version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"");
                c.an("Relationships", RelationshipsWriter.c);
                for (let d of fromEnum(a)) {
                    c.an("Relationship", RelationshipsWriter.c);
                    c.h("Id", d.id);
                    c.h("Type", d.relationshipType);
                    if (d.targetMode == 1) {
                        c.h("Target", d.targetUri.originalString);
                        c.h("TargetMode", "External");
                    }
                    else {
                        c.h("Target", DocCoreExtensions.fixDirectoryPath(d.targetUri.toString()));
                    }
                    c.v();
                }
                c.v();
            }
            finally {
                if (c != null) {
                    c.dispose();
                }
            }
        }
    }
}
RelationshipsWriter.$t = markType(RelationshipsWriter, 'RelationshipsWriter');
RelationshipsWriter.c = "http://schemas.openxmlformats.org/package/2006/relationships";
RelationshipsWriter.a = [RelationshipsWriter.c];
/**
 * @hidden
 */
export class DocCoreExtensions extends Base {
    static fixDirectoryPath(a) {
        if (stringStartsWith(a, "\\")) {
            return a.substr(1);
        }
        if (stringStartsWith(a, "/")) {
            return a.substr(1);
        }
        return a;
    }
}
DocCoreExtensions.$t = markType(DocCoreExtensions, 'DocCoreExtensions');
/**
 * @hidden
 */
export class PackageUtilities extends Base {
    static j(a, b) {
        if (stringStartsWith(b, ".." + "/")) {
            return PackageUtilities.j(PackageUtilities.n(a), b.substr(3));
        }
        let c = a.length > 0 && a.charAt(a.length - 1) == "/";
        let d = b.length > 0 && b.charAt(0) == "/";
        if (d) {
            return b;
        }
        if (c != d) {
            return a + b;
        }
        if (c) {
            return a + b.substr(1);
        }
        return a + "/" + b;
    }
    static ag(a, b) {
        let c = a.toString();
        let d = b.toString();
        return UriUtilities.b(PackageUtilities.j(c, d));
    }
    static a(a, b) {
        return Package._d(a, b ? 3 : 2);
    }
    static k(a) {
        let b = toUniversalTime(a);
        return dateToStringFormat(b, "s") + "Z";
    }
    static m(a) {
        let b = PackageUtilities.n(a);
        let c = PackageUtilities.o(a);
        let d = PackageUtilities.j(b, "_rels");
        let e = c + ".rels";
        return PackageUtilities.j(d, e);
    }
    static n(a) {
        let b = a.lastIndexOf("/");
        if (b < 0) {
            return a;
        }
        return a.substr(0, b);
    }
    static ah(a) {
        return new Uri(1, PackageUtilities.n(a.toString()), 2);
    }
    static o(a) {
        let b = a.lastIndexOf("/");
        if (b < 0) {
            return a;
        }
        return a.substr(b + 1);
    }
    static e(a) {
        if (a == null || a.length != 3 || a.charAt(0) != '%') {
            PackageUtilities.al("The value passed to GetPercentEncodedValue was not expoected: " + a);
            return 0;
        }
        try {
            return Convert.toByte2(a.substr(1), 16);
        }
        catch (b) {
            PackageUtilities.al("The value passed to GetPercentEncodedValue was not expoected: " + a);
            return 0;
        }
    }
    static ai(a, b) {
        return PackageUtilities.aj(a, b, "/");
    }
    static aj(a, b, c) {
        let d = PackageUtilities.q(a.toString(), b.toString(), "/", false);
        return UriUtilities.b(d);
    }
    static p(a, b) {
        return PackageUtilities.q(a, b, "/", false);
    }
    static q(a, b, c, d) {
        let e = PackageUtilities.h(a, c);
        let f = PackageUtilities.h(b, c);
        for (let g = 0; g < e.count - 1 && g < f.count; g++) {
            if (e._inner[g] == f._inner[g]) {
                e.removeAt(g);
                f.removeAt(g);
                g--;
                continue;
            }
            else {
                if (d) {
                    let h = PackageUtilities.w.g(b, stringEmpty());
                    return stringReplace(h, c, "/");
                }
                else {
                    for (let i = 0; i < e.count - 1; i++) {
                        f.insert(0, "..");
                    }
                }
                break;
            }
        }
        let j = new StringBuilder(0);
        for (let k of fromEnum(f)) {
            if (c != "/") {
                j.l(stringReplace(k, c, "/"));
            }
            else {
                j.l(k);
            }
            j.h("/");
        }
        j.y(j.c - 1, 1);
        return j.toString();
    }
    static g(a) {
        return PackageUtilities.h(a, "/");
    }
    static h(a, b) {
        if (stringIsNullOrEmpty(a)) {
            return new List$1(String_$type, 0);
        }
        return new List$1(String_$type, 1, a.split(b));
    }
    static ak(a) {
        let b = PackageUtilities.ah(a.sourceUri);
        let c = PackageUtilities.ag(b, a.targetUri);
        return c;
    }
    static b(a) {
        let b = PackageUtilities.g(a);
        if (b.count == 0) {
            return false;
        }
        if (b._inner[0].length != 0) {
            return false;
        }
        for (let c = 1; c < b.count; c++) {
            if (PackageUtilities.d(b._inner[c]) == false) {
                return false;
            }
        }
        return true;
    }
    static c(a) {
        return PackageUtilities.b(a.toString());
    }
    static d(a) {
        if (stringIsNullOrEmpty(a)) {
            return false;
        }
        if (a.charAt(a.length - 1) == '.') {
            return false;
        }
        let b = PackageUtilities.ae.i(a);
        if (b.i == false || b.d != a.length) {
            return false;
        }
        let c = PackageUtilities.aa.i(a);
        while (c.i) {
            let d = PackageUtilities.e(c.g);
            let e = Convert.toChar(d);
            switch (e) {
                case '\\':
                case '/': return false;
            }
            let f = e.toString();
            if (PackageUtilities.ac.i(f).i) {
                return false;
            }
            c = c.o();
        }
        return true;
    }
    static i(a) {
        if (stringEndsWith(a, "Z") == false) {
            PackageUtilities.al("The date format was not correct.");
            return dateNow();
        }
        a = a.substr(0, a.length - 1);
        let b;
        if (!((() => { let c = DocCoreUtils.g(a, "s", null, b); b = c.p3; return c.ret; })())) {
            if (!((() => { let c = DocCoreUtils.g(a, "o", null, b); b = c.p3; return c.ret; })())) {
                PackageUtilities.al("Error occurred while parsing the date in W3CDTF format: " + a);
                return dateNow();
            }
        }
        return toLocalTime(b);
    }
    static get aa() {
        if (PackageUtilities.z == null) {
            PackageUtilities.z = new Regex(1, "%[0-9A-F]{2}", 8 | 1);
        }
        return PackageUtilities.z;
    }
    static get ac() {
        if (PackageUtilities.ab == null) {
            PackageUtilities.ab = new Regex(1, "[\\-\\._~0-9A-Z]", 8 | 1);
        }
        return PackageUtilities.ab;
    }
    static get ae() {
        if (PackageUtilities.ad == null) {
            PackageUtilities.ad = new Regex(1, "([:@\\-\\._~!$&'()*+,;=0-9A-Z]|(%[0-9A-F]{2}))*", 8 | 1);
        }
        return PackageUtilities.ad;
    }
    static get y() {
        if (PackageUtilities.x == null) {
            PackageUtilities.x = new Regex(1, "[^.]", 8 | 1);
        }
        return PackageUtilities.x;
    }
    static get w() {
        if (PackageUtilities.v == null) {
            PackageUtilities.v = new Regex(1, "\\w:", 8);
        }
        return PackageUtilities.v;
    }
    static al(a) {
        if (DocCoreUtils.f) {
            return;
        }
    }
}
PackageUtilities.$t = markType(PackageUtilities, 'PackageUtilities');
PackageUtilities.z = null;
PackageUtilities.ab = null;
PackageUtilities.ad = null;
PackageUtilities.x = null;
PackageUtilities.v = null;
/**
 * @hidden
 */
export class AlternateContentChoice extends Base {
    constructor(a, ..._rest) {
        super();
        this.a = null;
        this.b = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = [[c], d];
                    {
                        let g = e[0];
                        let h = e[1];
                        this.a = h;
                        this.b = g;
                    }
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.a = d;
                    this.b = c;
                }
                break;
        }
    }
}
AlternateContentChoice.$t = markType(AlternateContentChoice, 'AlternateContentChoice');
/**
 * @hidden
 */
export class AttributeValue extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new QualifiedNameInfo();
        this.d = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    this.a = new QualifiedNameInfo(1, c, d, e);
                    this.d = f;
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.a = c;
                    this.d = d;
                }
                break;
        }
    }
    toString() {
        return this.a.toString() + "=\"" + this.d + "\"";
    }
    e(a, b, c, d) {
        this.a.i(a, b, c);
        this.d = d;
    }
    get b() {
        return this.a.c;
    }
    get c() {
        if (this.a.g == "http://www.w3.org/2000/xmlns/") {
            if (this.a.f == "xmlns" || this.a.h == "xmlns") {
                return true;
            }
        }
        return false;
    }
}
AttributeValue.$t = markStruct(AttributeValue, 'AttributeValue');
/**
 * @hidden
 */
export class CT_GraphicalObject extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_GraphicalObject.$t = markType(CT_GraphicalObject, 'CT_GraphicalObject');
/**
 * @hidden
 */
export let IGraphicalObjectContent_$type = new Type(null, 'IGraphicalObjectContent');
/**
 * @hidden
 */
export class AlternateGraphicalObjectContent extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.a = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitAlternateGraphicalObjectContent$i(this, b);
    }
    getStrictElementName(a) {
        return MarkupCompatibility2006.ap;
    }
}
AlternateGraphicalObjectContent.$t = markType(AlternateGraphicalObjectContent, 'AlternateGraphicalObjectContent', Base.$, [IGraphicalObjectContent_$type]);
/**
 * @hidden
 */
export class CT_AdjustHandleList extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(IAdjustHandle_$type, 0);
    }
    get b() {
        return this.a;
    }
}
CT_AdjustHandleList.$t = markType(CT_AdjustHandleList, 'CT_AdjustHandleList');
/**
 * @hidden
 */
export class CT_AdjPoint2D extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_AdjCoordinate();
        this.b = new ST_AdjCoordinate();
    }
    c(a, b) {
        CT_AdjPoint2D.d(a, b, this);
    }
    static d(a, b, c) {
        let d = a.ad;
        d.p(b, null);
        let e = null;
        let f = null;
        f = "x";
        e = ST_AdjCoordinate.f(c.a);
        a.ad.h(f, e);
        f = "y";
        e = ST_AdjCoordinate.f(c.b);
        a.ad.h(f, e);
        d.k();
    }
}
CT_AdjPoint2D.$t = markType(CT_AdjPoint2D, 'CT_AdjPoint2D');
/**
 * @hidden
 */
export class CT_Angle extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_Angle();
    }
}
CT_Angle.$t = markType(CT_Angle, 'CT_Angle');
/**
 * @hidden
 */
export class CT_Blip extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_BlipCompression_$type, null);
        this.b = null;
        this.c = null;
    }
}
CT_Blip.$t = markType(CT_Blip, 'CT_Blip');
/**
 * @hidden
 */
export class CT_BlipFillPropertiesBase extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(Number_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
        this.a = null;
    }
}
CT_BlipFillPropertiesBase.$t = markType(CT_BlipFillPropertiesBase, 'CT_BlipFillPropertiesBase');
/**
 * @hidden
 */
export let IEG_FillProperties_$type = new Type(null, 'IEG_FillProperties');
/**
 * @hidden
 */
export class CT_BlipFillProperties extends CT_BlipFillPropertiesBase {
    constructor() {
        super(...arguments);
        this.d = null;
        this.e = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_BlipFillProperties$i(this, b);
    }
}
CT_BlipFillProperties.$t = markType(CT_BlipFillProperties, 'CT_BlipFillProperties', CT_BlipFillPropertiesBase.$, [IEG_FillProperties_$type]);
/**
 * @hidden
 */
export class CT_Color extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_Color.$t = markType(CT_Color, 'CT_Color');
/**
 * @hidden
 */
export class CT_ComplementTransform extends Base {
}
CT_ComplementTransform.$t = markType(CT_ComplementTransform, 'CT_ComplementTransform');
/**
 * @hidden
 */
export class CT_Connection extends Base {
    constructor() {
        super(...arguments);
        this.a = 0;
        this.b = 0;
    }
}
CT_Connection.$t = markType(CT_Connection, 'CT_Connection');
/**
 * @hidden
 */
export class CT_ConnectionSite extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = new ST_AdjAngle();
    }
}
CT_ConnectionSite.$t = markType(CT_ConnectionSite, 'CT_ConnectionSite');
/**
 * @hidden
 */
export class CT_ConnectionSiteList extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(CT_ConnectionSite.$, 0);
    }
    get b() {
        return this.a;
    }
}
CT_ConnectionSiteList.$t = markType(CT_ConnectionSiteList, 'CT_ConnectionSiteList');
/**
 * @hidden
 */
export let ICT_ShapePropertiesOwner_$type = new Type(null, 'ICT_ShapePropertiesOwner');
/**
 * @hidden
 */
export let ICT_ShapeStyleOwner_$type = new Type(null, 'ICT_ShapeStyleOwner');
/**
 * @hidden
 */
export class CT_Connector extends Base {
    constructor() {
        super(...arguments);
        this.b = false;
        this.c = null;
        this.a = null;
        this._spPr = null;
        this._style = null;
    }
    get spPr() {
        return this._spPr;
    }
    set spPr(a) {
        this._spPr = a;
    }
    get style() {
        return this._style;
    }
    set style(a) {
        this._style = a;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_Connector$i(this, b);
    }
    getStrictElementName(a) {
        return a._t.av;
    }
}
CT_Connector.$t = markType(CT_Connector, 'CT_Connector', Base.$, [IGraphicalObjectContent_$type, ICT_ShapePropertiesOwner_$type, ICT_ShapeStyleOwner_$type]);
/**
 * @hidden
 */
export class CT_ConnectorLocking extends Base {
    constructor() {
        super(...arguments);
        this.f = false;
        this.j = false;
        this.i = false;
        this.c = false;
        this.g = false;
        this.h = false;
        this.e = false;
        this.a = false;
        this.b = false;
        this.d = false;
    }
}
CT_ConnectorLocking.$t = markType(CT_ConnectorLocking, 'CT_ConnectorLocking');
/**
 * @hidden
 */
export class CT_NonVisualBase extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_NonVisualBase.$t = markType(CT_NonVisualBase, 'CT_NonVisualBase');
/**
 * @hidden
 */
export class CT_ConnectorNonVisual extends CT_NonVisualBase {
    constructor() {
        super(...arguments);
        this.b = null;
    }
}
CT_ConnectorNonVisual.$t = markType(CT_ConnectorNonVisual, 'CT_ConnectorNonVisual', CT_NonVisualBase.$);
/**
 * @hidden
 */
export let IEG_Geometry_$type = new Type(null, 'IEG_Geometry');
/**
 * @hidden
 */
export class CT_CustomGeometry2D extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.d = null;
        this.a = null;
        this.b = null;
        this.e = null;
        this.f = null;
        this.g = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_CustomGeometry2D$i(this, b);
    }
}
CT_CustomGeometry2D.$t = markType(CT_CustomGeometry2D, 'CT_CustomGeometry2D', Base.$, [IEG_Geometry_$type]);
/**
 * @hidden
 */
export class CT_DashStop extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_PositivePercentage();
        this.b = new ST_PositivePercentage();
    }
}
CT_DashStop.$t = markType(CT_DashStop, 'CT_DashStop');
/**
 * @hidden
 */
export let IEG_LineDashProperties_$type = new Type(null, 'IEG_LineDashProperties');
/**
 * @hidden
 */
export class CT_DashStopList extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(CT_DashStop.$, 0);
    }
    get b() {
        return this.a;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_DashStopList$i(this, b);
    }
}
CT_DashStopList.$t = markType(CT_DashStopList, 'CT_DashStopList', Base.$, [IEG_LineDashProperties_$type]);
/**
 * @hidden
 */
export class CT_EmbeddedWAVAudioFile extends Base {
    constructor() {
        super();
        this.c = null;
        this.d = null;
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.d = "";
    }
}
CT_EmbeddedWAVAudioFile.$t = markType(CT_EmbeddedWAVAudioFile, 'CT_EmbeddedWAVAudioFile');
CT_EmbeddedWAVAudioFile.a = false;
/**
 * @hidden
 */
export class CT_FixedPercentage extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_FixedPercentage();
    }
}
CT_FixedPercentage.$t = markType(CT_FixedPercentage, 'CT_FixedPercentage');
/**
 * @hidden
 */
export class CT_FontReference extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = 0;
    }
}
CT_FontReference.$t = markType(CT_FontReference, 'CT_FontReference');
/**
 * @hidden
 */
export class CT_GeomGuide extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    static c(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "name":
                    b = d.d;
                    break;
                case "fmla":
                    c = d.d;
                    break;
                default: break;
            }
        }
        ;
        return {
            p1: b,
            p2: c
        };
    }
}
CT_GeomGuide.$t = markType(CT_GeomGuide, 'CT_GeomGuide');
/**
 * @hidden
 */
export class CT_GeomGuideList extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(CT_GeomGuide.$, 0);
    }
    get b() {
        return this.a;
    }
}
CT_GeomGuideList.$t = markType(CT_GeomGuideList, 'CT_GeomGuideList');
/**
 * @hidden
 */
export class CT_GeomRect extends Base {
    constructor() {
        super(...arguments);
        this.b = new ST_AdjCoordinate();
        this.d = new ST_AdjCoordinate();
        this.c = new ST_AdjCoordinate();
        this.a = new ST_AdjCoordinate();
    }
}
CT_GeomRect.$t = markType(CT_GeomRect, 'CT_GeomRect');
/**
 * @hidden
 */
export let IShapesOwner_$type = new Type(null, 'IShapesOwner');
/**
 * @hidden
 */
export class CT_GraphicalObjectData extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.c = null;
    }
    get b() {
        if (this.a == null) {
            this.a = new List$1(Tuple$2.$.specialize(String_$type, Base.$), 0);
        }
        return this.a;
    }
    set b(a) {
        this.a = a;
    }
    addShape(a, b) {
        this.b.add(Tuple.a(String_$type, Base.$, b.getStrictElementName(a), b));
    }
}
CT_GraphicalObjectData.$t = markType(CT_GraphicalObjectData, 'CT_GraphicalObjectData', Base.$, [IShapesOwner_$type]);
/**
 * @hidden
 */
export class CT_GraphicalObjectFrame extends Base {
    constructor() {
        super(...arguments);
        this.d = false;
        this.a = null;
        this.e = null;
        this.b = null;
        this.c = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_GraphicalObjectFrame$i(this, b);
    }
    getStrictElementName(a) {
        return a._t.a3;
    }
}
CT_GraphicalObjectFrame.$t = markType(CT_GraphicalObjectFrame, 'CT_GraphicalObjectFrame', Base.$, [IGraphicalObjectContent_$type]);
/**
 * @hidden
 */
export class CT_GraphicalObjectFrameLocking extends Base {
    constructor() {
        super(...arguments);
        this.c = false;
        this.b = false;
        this.f = false;
        this.a = false;
        this.d = false;
        this.e = false;
    }
}
CT_GraphicalObjectFrameLocking.$t = markType(CT_GraphicalObjectFrameLocking, 'CT_GraphicalObjectFrameLocking');
/**
 * @hidden
 */
export class CT_GraphicalObjectFrameNonVisual extends CT_NonVisualBase {
    constructor() {
        super(...arguments);
        this.b = null;
    }
}
CT_GraphicalObjectFrameNonVisual.$t = markType(CT_GraphicalObjectFrameNonVisual, 'CT_GraphicalObjectFrameNonVisual', CT_NonVisualBase.$);
/**
 * @hidden
 */
export class CT_GrayscaleTransform extends Base {
}
CT_GrayscaleTransform.$t = markType(CT_GrayscaleTransform, 'CT_GrayscaleTransform');
/**
 * @hidden
 */
export let ISaveToXLSX_$type = new Type(null, 'ISaveToXLSX');
/**
 * @hidden
 */
export class CT_GroupFillProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    get elementName() {
        return DrawingMLMain.es;
    }
    saveX(a, b, c, d) {
        b.p(c, null);
        b.k();
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_GroupFillProperties$i(this, b);
    }
}
CT_GroupFillProperties.$t = markType(CT_GroupFillProperties, 'CT_GroupFillProperties', Base.$, [IEG_FillProperties_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_GroupLocking extends Base {
    constructor() {
        super(...arguments);
        this.b = false;
        this.g = false;
        this.f = false;
        this.e = false;
        this.a = false;
        this.c = false;
        this.d = false;
    }
}
CT_GroupLocking.$t = markType(CT_GroupLocking, 'CT_GroupLocking');
/**
 * @hidden
 */
export class CT_GroupShape extends Base {
    constructor() {
        super(...arguments);
        this.b = null;
        this.a = null;
        this.c = new List$1(IGraphicalObjectContent_$type, 0);
    }
    get d() {
        return this.c;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_GroupShape$i(this, b);
    }
    getStrictElementName(a) {
        return a._t.a4;
    }
    addShape(a, b) {
        this.d.add(b);
    }
}
CT_GroupShape.$t = markType(CT_GroupShape, 'CT_GroupShape', Base.$, [IGraphicalObjectContent_$type, IShapesOwner_$type]);
/**
 * @hidden
 */
export class CT_GroupShapeNonVisual extends CT_NonVisualBase {
    constructor() {
        super(...arguments);
        this.b = null;
    }
}
CT_GroupShapeNonVisual.$t = markType(CT_GroupShapeNonVisual, 'CT_GroupShapeNonVisual', CT_NonVisualBase.$);
/**
 * @hidden
 */
export class CT_ShapePropertiesBase extends Base {
    constructor() {
        super(...arguments);
        this.b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        this.a = null;
    }
}
CT_ShapePropertiesBase.$t = markType(CT_ShapePropertiesBase, 'CT_ShapePropertiesBase');
/**
 * @hidden
 */
export class CT_GroupShapeProperties extends CT_ShapePropertiesBase {
    constructor() {
        super(...arguments);
        this.c = null;
    }
}
CT_GroupShapeProperties.$t = markType(CT_GroupShapeProperties, 'CT_GroupShapeProperties', CT_ShapePropertiesBase.$);
/**
 * @hidden
 */
export let ISupportSetProperty_$type = new Type(null, 'ISupportSetProperty');
/**
 * @hidden
 */
export class CT_Hyperlink extends Base {
    constructor() {
        super();
        this.f = null;
        this.b = Nullable$1.toNullable(Boolean_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.g = null;
        this.h = null;
        this.a = null;
        this.i = null;
        this.j = null;
        this.e = null;
        this.h = "";
        this.f = "";
        this.i = "";
        this.j = "";
        this.d = Nullable$1.toNullable(Boolean_$type, true);
    }
    setProperty(a, b) {
        switch (a) {
            case 601:
                this.e = b;
                break;
            case 1549:
                this.a = typeCast(CT_EmbeddedWAVAudioFile.$, b);
                break;
        }
    }
}
CT_Hyperlink.$t = markType(CT_Hyperlink, 'CT_Hyperlink', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_InverseTransform extends Base {
}
CT_InverseTransform.$t = markType(CT_InverseTransform, 'CT_InverseTransform');
/**
 * @hidden
 */
export class CT_LineEndProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_LineEndLength_$type, null);
        this.b = Nullable$1.toNullable(ST_LineEndType_$type, null);
        this.c = Nullable$1.toNullable(ST_LineEndWidth_$type, null);
    }
}
CT_LineEndProperties.$t = markType(CT_LineEndProperties, 'CT_LineEndProperties');
/**
 * @hidden
 */
export let IEG_LineJoinProperties_$type = new Type(null, 'IEG_LineJoinProperties');
/**
 * @hidden
 */
export class CT_LineJoinBevel extends Base {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_LineJoinBevel$i(this, b);
    }
}
CT_LineJoinBevel.$t = markType(CT_LineJoinBevel, 'CT_LineJoinBevel', Base.$, [IEG_LineJoinProperties_$type]);
/**
 * @hidden
 */
export class ST_PositivePercentage extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new ST_Percentage();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_PositivePercentage.$, ST_Percentage.l(c), "value", 0, 1.7976931348623157E+308);
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_PositivePercentage.$, typeCast(ST_PositivePercentage.$, a));
        if (ST_PositivePercentage.j(b, Nullable$1.toNullable(ST_PositivePercentage.$, null))) {
            return false;
        }
        return ST_PositivePercentage.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.a.getHashCode();
    }
    toString() {
        return this.s(1);
    }
    s(a) {
        return this.a.r(a);
    }
    static f(a, b) {
        let c = ST_PositivePercentage.r(a, b);
        if (ST_PositivePercentage.j(c, Nullable$1.toNullable(ST_PositivePercentage.$, null))) {
            return c.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_PositivePercentage.$, a);
    }
    static r(a, b) {
        return ST_PositivePercentage.q(ST_Percentage.q(a, b));
    }
    static g(a, b) {
        return ST_Percentage.e(a.a, b.a);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_PositivePercentage.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_PositivePercentage.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_PositivePercentage.i(a.value, b.value);
    }
    static d(a) {
        return new ST_PositivePercentage(1, a);
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_PositivePercentage.$, null);
        }
        return Nullable$1.toNullable(ST_PositivePercentage.$, ST_PositivePercentage.d(a.value));
    }
    static b(a) {
        return a.a;
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Percentage.$, null);
        }
        return Nullable$1.toNullable(ST_Percentage.$, ST_PositivePercentage.b(a.value));
    }
    static m(a) {
        return ST_Percentage.l(a.a);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_PositivePercentage.m(a.value));
    }
}
ST_PositivePercentage.$t = markStruct(ST_PositivePercentage, 'ST_PositivePercentage');
/**
 * @hidden
 */
export class CT_LineJoinMiterProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_PositivePercentage.$, null);
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_LineJoinMiterProperties$i(this, b);
    }
}
CT_LineJoinMiterProperties.$t = markType(CT_LineJoinMiterProperties, 'CT_LineJoinMiterProperties', Base.$, [IEG_LineJoinProperties_$type]);
/**
 * @hidden
 */
export class CT_LineJoinRound extends Base {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_LineJoinRound$i(this, b);
    }
}
CT_LineJoinRound.$t = markType(CT_LineJoinRound, 'CT_LineJoinRound', Base.$, [IEG_LineJoinProperties_$type]);
/**
 * @hidden
 */
export class ST_LineWidth extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new ST_Coordinate32Unqualified();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_LineWidth.$, ST_Coordinate32Unqualified.e(c), "value", 0, 20116800);
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_LineWidth.$, typeCast(ST_LineWidth.$, a));
        if (ST_LineWidth.j(b, Nullable$1.toNullable(ST_LineWidth.$, null))) {
            return false;
        }
        return ST_LineWidth.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return Base.getHashCodeStatic(this.a);
    }
    toString() {
        return this.a.toString();
    }
    static f(a) {
        let b = ST_LineWidth.t(a);
        if (ST_LineWidth.j(b, Nullable$1.toNullable(ST_LineWidth.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_LineWidth.$, a);
    }
    static t(a) {
        return ST_LineWidth.s(ST_Coordinate32Unqualified.j(a));
    }
    static g(a, b) {
        return ST_Coordinate32Unqualified.e(a.a) == ST_Coordinate32Unqualified.e(b.a);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_LineWidth.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_LineWidth.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_LineWidth.i(a.value, b.value);
    }
    static d(a) {
        return new ST_LineWidth(1, a);
    }
    static s(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_LineWidth.$, null);
        }
        return Nullable$1.toNullable(ST_LineWidth.$, ST_LineWidth.d(a.value));
    }
    static b(a) {
        return a.a;
    }
    static r(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, ST_LineWidth.b(a.value));
    }
    static m(a) {
        return ST_Coordinate32Unqualified.e(a.a);
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_LineWidth.m(a.value));
    }
}
ST_LineWidth.$t = markStruct(ST_LineWidth, 'ST_LineWidth');
/**
 * @hidden
 */
export class CT_LinePropertiesBase extends Base {
    constructor() {
        super(...arguments);
        this.e = Nullable$1.toNullable(ST_PenAlignment_$type, null);
        this.f = Nullable$1.toNullable(ST_LineCap_$type, null);
        this.g = Nullable$1.toNullable(ST_CompoundLine_$type, null);
        this.a = null;
        this.c = null;
        this.d = null;
        this.b = null;
        this.h = Nullable$1.toNullable(ST_LineWidth.$, null);
    }
}
CT_LinePropertiesBase.$t = markType(CT_LinePropertiesBase, 'CT_LinePropertiesBase');
/**
 * @hidden
 */
export class CT_LineProperties extends CT_LinePropertiesBase {
    constructor() {
        super(...arguments);
        this.i = null;
    }
}
CT_LineProperties.$t = markType(CT_LineProperties, 'CT_LineProperties', CT_LinePropertiesBase.$);
/**
 * @hidden
 */
export let IEG_LineFillProperties_$type = new Type(null, 'IEG_LineFillProperties');
/**
 * @hidden
 */
export class CT_NoFillProperties extends Base {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_NoFillProperties$i(this, b);
    }
    _accept$21$i($tArg, $tResult, a, b) {
        return a._visitCT_NoFillProperties$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.gy;
    }
    saveX(a, b, c, d) {
        b.p(c, null);
        b.k();
    }
}
CT_NoFillProperties.$t = markType(CT_NoFillProperties, 'CT_NoFillProperties', Base.$, [IEG_FillProperties_$type, IEG_LineFillProperties_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_NonVisualConnectorProperties extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.a = null;
        this.b = null;
    }
}
CT_NonVisualConnectorProperties.$t = markType(CT_NonVisualConnectorProperties, 'CT_NonVisualConnectorProperties');
/**
 * @hidden
 */
export class CT_NonVisualDrawingProps extends Base {
    constructor() {
        super(...arguments);
        this.e = null;
        this.d = false;
        this.a = null;
        this.b = null;
        this.c = new ST_DrawingElementId();
        this.f = null;
        this.g = null;
    }
}
CT_NonVisualDrawingProps.$t = markType(CT_NonVisualDrawingProps, 'CT_NonVisualDrawingProps');
/**
 * @hidden
 */
export class CT_NonVisualGraphicFrameProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_NonVisualGraphicFrameProperties.$t = markType(CT_NonVisualGraphicFrameProperties, 'CT_NonVisualGraphicFrameProperties');
/**
 * @hidden
 */
export class CT_NonVisualGroupDrawingShapeProps extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_NonVisualGroupDrawingShapeProps.$t = markType(CT_NonVisualGroupDrawingShapeProps, 'CT_NonVisualGroupDrawingShapeProps');
/**
 * @hidden
 */
export class CT_NonVisualPictureProperties extends Base {
    constructor() {
        super();
        this.a = null;
        this.b = false;
        this.b = true;
    }
}
CT_NonVisualPictureProperties.$t = markType(CT_NonVisualPictureProperties, 'CT_NonVisualPictureProperties');
/**
 * @hidden
 */
export class CT_NonVisualDrawingShapeProps extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = false;
    }
}
CT_NonVisualDrawingShapeProps.$t = markType(CT_NonVisualDrawingShapeProps, 'CT_NonVisualDrawingShapeProps');
/**
 * @hidden
 */
export class CT_Path2D extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(IPath2DCommand_$type, 0);
        this.g = Nullable$1.toNullable(ST_PositiveCoordinate.$, null);
        this.e = Nullable$1.toNullable(ST_PositiveCoordinate.$, null);
        this.d = Nullable$1.toNullable(ST_PathFillMode_$type, null);
        this.f = Nullable$1.toNullable(Boolean_$type, null);
        this.c = Nullable$1.toNullable(Boolean_$type, null);
    }
    get b() {
        return this.a;
    }
}
CT_Path2D.$t = markType(CT_Path2D, 'CT_Path2D');
/**
 * @hidden
 */
export let IPath2DCommand_$type = new Type(null, 'IPath2DCommand');
/**
 * @hidden
 */
export class CT_Path2DArcTo extends Base {
    constructor() {
        super(...arguments);
        this.d = new ST_AdjCoordinate();
        this.c = new ST_AdjCoordinate();
        this.a = new ST_AdjAngle();
        this.b = new ST_AdjAngle();
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DArcTo$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.bf;
    }
    saveX(a, b, c, d) {
        CT_Path2DArcTo.e(a, c, this);
    }
    static e(a, b, c) {
        let d = a.ad;
        d.p(b, null);
        let e = null;
        let f = null;
        f = "hR";
        e = ST_AdjCoordinate.f(c.c);
        a.ad.h(f, e);
        f = "stAng";
        e = ST_AdjAngle.f(c.a);
        a.ad.h(f, e);
        f = "swAng";
        e = ST_AdjAngle.f(c.b);
        a.ad.h(f, e);
        f = "wR";
        e = ST_AdjCoordinate.f(c.d);
        a.ad.h(f, e);
        d.k();
    }
}
CT_Path2DArcTo.$t = markType(CT_Path2DArcTo, 'CT_Path2DArcTo', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Path2DClose extends Base {
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DClose$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.ci;
    }
    saveX(a, b, c, d) {
        b.o(c);
        b.k();
    }
}
CT_Path2DClose.$t = markType(CT_Path2DClose, 'CT_Path2DClose', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Path2DCubicBezierTo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DCubicBezierTo$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.cv;
    }
    saveX(a, b, c, d) {
        b.o(c);
        if (this.a != null) {
            this.a.c(a, DrawingMLMain.hs);
        }
        if (this.b != null) {
            this.b.c(a, DrawingMLMain.hs);
        }
        if (this.c != null) {
            this.c.c(a, DrawingMLMain.hs);
        }
        b.k();
    }
}
CT_Path2DCubicBezierTo.$t = markType(CT_Path2DCubicBezierTo, 'CT_Path2DCubicBezierTo', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Path2DLineTo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DLineTo$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.f0;
    }
    saveX(a, b, c, d) {
        b.o(c);
        if (this.a != null) {
            this.a.c(a, DrawingMLMain.hs);
        }
        b.k();
    }
}
CT_Path2DLineTo.$t = markType(CT_Path2DLineTo, 'CT_Path2DLineTo', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Path2DList extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(CT_Path2D.$, 0);
    }
    get b() {
        return this.a;
    }
}
CT_Path2DList.$t = markType(CT_Path2DList, 'CT_Path2DList');
/**
 * @hidden
 */
export class CT_Path2DMoveTo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DMoveTo$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.gm;
    }
    saveX(a, b, c, d) {
        b.o(c);
        if (this.a != null) {
            this.a.c(a, DrawingMLMain.hs);
        }
        b.k();
    }
}
CT_Path2DMoveTo.$t = markType(CT_Path2DMoveTo, 'CT_Path2DMoveTo', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Path2DQuadBezierTo extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_Path2DQuadBezierTo$i(this, b);
    }
    get elementName() {
        return DrawingMLMain.ht;
    }
    saveX(a, b, c, d) {
        b.o(c);
        if (this.a != null) {
            this.a.c(a, DrawingMLMain.hs);
        }
        if (this.b != null) {
            this.b.c(a, DrawingMLMain.hs);
        }
        b.k();
    }
}
CT_Path2DQuadBezierTo.$t = markType(CT_Path2DQuadBezierTo, 'CT_Path2DQuadBezierTo', Base.$, [IPath2DCommand_$type, ISaveToXLSX_$type]);
/**
 * @hidden
 */
export class CT_Percentage extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_Percentage();
    }
}
CT_Percentage.$t = markType(CT_Percentage, 'CT_Percentage');
/**
 * @hidden
 */
export class CT_Picture extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.c = false;
        this.d = null;
        this.b = null;
        this._spPr = null;
    }
    get spPr() {
        return this._spPr;
    }
    set spPr(a) {
        this._spPr = a;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_Picture$i(this, b);
    }
    getStrictElementName(a) {
        return a._t.bs;
    }
}
CT_Picture.$t = markType(CT_Picture, 'CT_Picture', Base.$, [IGraphicalObjectContent_$type, ICT_ShapePropertiesOwner_$type]);
/**
 * @hidden
 */
export class CT_PictureLocking extends Base {
    constructor() {
        super(...arguments);
        this.a = false;
        this.b = false;
        this.c = false;
        this.d = false;
        this.e = false;
        this.f = false;
        this.g = false;
        this.h = false;
        this.i = false;
        this.j = false;
        this.k = false;
    }
}
CT_PictureLocking.$t = markType(CT_PictureLocking, 'CT_PictureLocking');
/**
 * @hidden
 */
export class CT_PictureNonVisual extends CT_NonVisualBase {
    constructor() {
        super(...arguments);
        this.b = null;
    }
}
CT_PictureNonVisual.$t = markType(CT_PictureNonVisual, 'CT_PictureNonVisual', CT_NonVisualBase.$);
/**
 * @hidden
 */
export class ST_GeomGuideName extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.a = c;
                }
                break;
        }
    }
}
ST_GeomGuideName.$t = markStruct(ST_GeomGuideName, 'ST_GeomGuideName');
/**
 * @hidden
 */
export class ST_AdjCoordinate extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = Nullable$1.toNullable(ST_Coordinate.$, null);
        this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_Coordinate.$, null);
                    this.c = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, c));
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_Coordinate.$, c);
                    this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
                }
                break;
        }
    }
    get e() {
        return this.c;
    }
    get d() {
        return this.b;
    }
    static a(a) {
        let b = ST_Coordinate.s(a);
        if (nullableNotEquals(b, null)) {
            return new ST_AdjCoordinate(2, b.value);
        }
        return new ST_AdjCoordinate(1, a);
    }
    static f(a) {
        if (a.d.hasValue) {
            return a.d.value.toString();
        }
        else if (a.e.hasValue) {
            return a.e.value.toString();
        }
        else {
            return stringEmpty();
        }
    }
}
ST_AdjCoordinate.$t = markStruct(ST_AdjCoordinate, 'ST_AdjCoordinate');
/**
 * @hidden
 */
export class ST_AdjAngle extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = Nullable$1.toNullable(ST_Angle.$, null);
        this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_Angle.$, null);
                    this.c = Nullable$1.toNullable(ST_GeomGuideName.$, new ST_GeomGuideName(1, c));
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_Angle.$, c);
                    this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
                }
                break;
        }
    }
    get e() {
        return this.c;
    }
    get d() {
        return this.b;
    }
    static a(a) {
        let b = ST_Angle.m(a);
        if (b.hasValue) {
            return new ST_AdjAngle(2, b.value);
        }
        return new ST_AdjAngle(1, a);
    }
    static f(a) {
        if (a.d.hasValue) {
            return a.d.value.toString();
        }
        else if (a.e.hasValue) {
            return a.e.value.toString();
        }
        else {
            return stringEmpty();
        }
    }
}
ST_AdjAngle.$t = markStruct(ST_AdjAngle, 'ST_AdjAngle');
/**
 * @hidden
 */
export let IAdjustHandle_$type = new Type(null, 'IAdjustHandle');
/**
 * @hidden
 */
export class CT_PolarAdjustHandle extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        this.g = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        this.e = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        this.b = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        this.f = Nullable$1.toNullable(ST_AdjAngle.$, null);
        this.d = Nullable$1.toNullable(ST_AdjAngle.$, null);
    }
}
CT_PolarAdjustHandle.$t = markType(CT_PolarAdjustHandle, 'CT_PolarAdjustHandle', Base.$, [IAdjustHandle_$type]);
/**
 * @hidden
 */
export class CT_PositiveFixedAngle extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_PositiveFixedAngle();
    }
}
CT_PositiveFixedAngle.$t = markType(CT_PositiveFixedAngle, 'CT_PositiveFixedAngle');
/**
 * @hidden
 */
export class CT_PositiveFixedPercentage extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_PositiveFixedPercentage();
    }
}
CT_PositiveFixedPercentage.$t = markType(CT_PositiveFixedPercentage, 'CT_PositiveFixedPercentage');
/**
 * @hidden
 */
export class CT_PositivePercentage extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_PositivePercentage();
    }
}
CT_PositivePercentage.$t = markType(CT_PositivePercentage, 'CT_PositivePercentage');
/**
 * @hidden
 */
export let IEG_ColorChoice_$type = new Type(null, 'IEG_ColorChoice');
/**
 * @hidden
 */
export class EG_ColorChoice extends Base {
    constructor() {
        super(...arguments);
        this.a = new List$1(IEG_ColorTransform_$type, 0);
    }
    get b() {
        return this.a;
    }
}
EG_ColorChoice.$t = markType(EG_ColorChoice, 'EG_ColorChoice', Base.$, [IEG_ColorChoice_$type]);
/**
 * @hidden
 */
export class CT_PresetColor_Core extends EG_ColorChoice {
    constructor() {
        super(...arguments);
        this.c = 0;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_PresetColor$i(this, b);
    }
}
CT_PresetColor_Core.$t = markType(CT_PresetColor_Core, 'CT_PresetColor_Core', EG_ColorChoice.$, [IEG_ColorChoice_$type]);
/**
 * @hidden
 */
export class CT_PresetGeometry2D extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = 0;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_PresetGeometry2D$i(this, b);
    }
}
CT_PresetGeometry2D.$t = markType(CT_PresetGeometry2D, 'CT_PresetGeometry2D', Base.$, [IEG_Geometry_$type]);
/**
 * @hidden
 */
export class CT_PresetLineDashProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_PresetLineDashVal_$type, null);
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_PresetLineDashProperties$i(this, b);
    }
}
CT_PresetLineDashProperties.$t = markType(CT_PresetLineDashProperties, 'CT_PresetLineDashProperties', Base.$, [IEG_LineDashProperties_$type]);
/**
 * @hidden
 */
export let IEG_TextRun_$type = new Type(null, 'IEG_TextRun');
/**
 * @hidden
 */
export class CT_RegularTextRun extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_RegularTextRun$i(this, b);
    }
}
CT_RegularTextRun.$t = markType(CT_RegularTextRun, 'CT_RegularTextRun', Base.$, [IEG_TextRun_$type]);
/**
 * @hidden
 */
export class CT_RelId extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_RelId.$t = markType(CT_RelId, 'CT_RelId');
/**
 * @hidden
 */
export class CT_RelativeRect extends Base {
    constructor() {
        super(...arguments);
        this.a = new ST_Percentage();
        this.b = new ST_Percentage();
        this.c = new ST_Percentage();
        this.d = new ST_Percentage();
    }
    get e() {
        return ST_Percentage.e(this.a, ST_Percentage.b(0)) || ST_Percentage.e(this.b, ST_Percentage.b(0)) || ST_Percentage.e(this.c, ST_Percentage.b(0)) || ST_Percentage.e(this.d, ST_Percentage.b(0));
    }
}
CT_RelativeRect.$t = markType(CT_RelativeRect, 'CT_RelativeRect');
/**
 * @hidden
 */
export class CT_SchemeColor extends EG_ColorChoice {
    constructor() {
        super(...arguments);
        this.c = 0;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_SchemeColor$i(this, b);
    }
}
CT_SchemeColor.$t = markType(CT_SchemeColor, 'CT_SchemeColor', EG_ColorChoice.$, [IEG_ColorChoice_$type]);
/**
 * @hidden
 */
export class CT_Shape extends Base {
    constructor() {
        super(...arguments);
        this.c = false;
        this.d = false;
        this.e = null;
        this.f = null;
        this.a = null;
        this._spPr = null;
        this._style = null;
        this.b = null;
    }
    get spPr() {
        return this._spPr;
    }
    set spPr(a) {
        this._spPr = a;
    }
    get style() {
        return this._style;
    }
    set style(a) {
        this._style = a;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_Shape$i(this, b);
    }
    getStrictElementName(a) {
        return a._t.bw;
    }
}
CT_Shape.$t = markType(CT_Shape, 'CT_Shape', Base.$, [IGraphicalObjectContent_$type, ICT_ShapePropertiesOwner_$type, ICT_ShapeStyleOwner_$type]);
/**
 * @hidden
 */
export class CT_ShapeLocking extends Base {
    constructor() {
        super(...arguments);
        this.f = false;
        this.j = false;
        this.i = false;
        this.c = false;
        this.g = false;
        this.h = false;
        this.e = false;
        this.a = false;
        this.b = false;
        this.d = false;
        this.k = false;
    }
}
CT_ShapeLocking.$t = markType(CT_ShapeLocking, 'CT_ShapeLocking');
/**
 * @hidden
 */
export class CT_ShapeNonVisual extends CT_NonVisualBase {
    constructor() {
        super(...arguments);
        this.b = null;
    }
}
CT_ShapeNonVisual.$t = markType(CT_ShapeNonVisual, 'CT_ShapeNonVisual', CT_NonVisualBase.$);
/**
 * @hidden
 */
export class CT_ShapeProperties extends CT_ShapePropertiesBase {
    constructor() {
        super(...arguments);
        this.e = null;
        this.c = null;
        this.d = null;
    }
    static f(a, b) {
        b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "bwMode":
                    b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
}
CT_ShapeProperties.$t = markType(CT_ShapeProperties, 'CT_ShapeProperties', CT_ShapePropertiesBase.$);
/**
 * @hidden
 */
export class CT_ShapeStyle extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.b = null;
        this.d = null;
        this.a = null;
    }
}
CT_ShapeStyle.$t = markType(CT_ShapeStyle, 'CT_ShapeStyle');
/**
 * @hidden
 */
export class CT_Slicer extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
CT_Slicer.$t = markType(CT_Slicer, 'CT_Slicer');
/**
 * @hidden
 */
export class CT_SolidFillProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_SolidFillProperties$i(this, b);
    }
    _accept$21$i($tArg, $tResult, a, b) {
        return a._visitCT_SolidFillProperties$i(this, b);
    }
}
CT_SolidFillProperties.$t = markType(CT_SolidFillProperties, 'CT_SolidFillProperties', Base.$, [IEG_FillProperties_$type, IEG_LineFillProperties_$type]);
/**
 * @hidden
 */
export class CT_SRgbColor extends EG_ColorChoice {
    constructor() {
        super(...arguments);
        this.c = new ST_HexColorRGB();
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_SRgbColor$i(this, b);
    }
    static d(a, b) {
        b = new ST_HexColorRGB(0);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_HexColorRGB.d(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
}
CT_SRgbColor.$t = markType(CT_SRgbColor, 'CT_SRgbColor', EG_ColorChoice.$, [IEG_ColorChoice_$type]);
/**
 * @hidden
 */
export let IEG_FillModeProperties_$type = new Type(null, 'IEG_FillModeProperties');
/**
 * @hidden
 */
export class CT_StretchInfoProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_StretchInfoProperties$i(this, b);
    }
}
CT_StretchInfoProperties.$t = markType(CT_StretchInfoProperties, 'CT_StretchInfoProperties', Base.$, [IEG_FillModeProperties_$type]);
/**
 * @hidden
 */
export class CT_StyleMatrixReference extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = 0;
    }
}
CT_StyleMatrixReference.$t = markType(CT_StyleMatrixReference, 'CT_StyleMatrixReference');
/**
 * @hidden
 */
export class CT_SysColor extends EG_ColorChoice {
    constructor() {
        super(...arguments);
        this.c = new ST_HexColorRGB();
        this.d = 0;
    }
    _accept$2$i($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_SysColor$i(this, b);
    }
}
CT_SysColor.$t = markType(CT_SysColor, 'CT_SysColor', EG_ColorChoice.$, [IEG_ColorChoice_$type]);
/**
 * @hidden
 */
export class CT_TextBody extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = new List$1(CT_TextParagraph.$, 0);
    }
    get d() {
        return this.c;
    }
}
CT_TextBody.$t = markType(CT_TextBody, 'CT_TextBody');
/**
 * @hidden
 */
export class ST_Coordinate32Unqualified extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.d = c;
                }
                break;
        }
    }
    get g() {
        return this.d;
    }
    static c(a) {
        return ST_Coordinate32Unqualified.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static j(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, ST_Coordinate32Unqualified.a(b));
        }
        return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_Coordinate32Unqualified.e(a.value));
    }
    static a(a) {
        return new ST_Coordinate32Unqualified(1, a);
    }
    static i(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, ST_Coordinate32Unqualified.a(a.value));
    }
}
ST_Coordinate32Unqualified.$t = markStruct(ST_Coordinate32Unqualified, 'ST_Coordinate32Unqualified');
/**
 * @hidden
 */
export class ST_Coordinate32 extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.k = Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
        this.l = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.k = Nullable$1.toNullable(ST_Coordinate32Unqualified.$, c);
                    this.l = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.k = Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
                    this.l = Nullable$1.toNullable(ST_UniversalMeasure.$, c);
                }
                break;
        }
    }
    j() {
        if (nullableNotEquals(this.k, null)) {
            return this.k.value.g;
        }
        if (ST_UniversalMeasure.f(this.l, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.l.value.m();
        }
        return 0;
    }
    static g(a) {
        let b = ST_Coordinate32.q(a);
        if (nullableNotEquals(b, null)) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_Coordinate32.$, a);
    }
    static q(a) {
        let b = ST_Coordinate32Unqualified.j(a);
        if (nullableNotEquals(b, null)) {
            return Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.b(b.getValueOrDefault()));
        }
        let c = ST_UniversalMeasure.o(a);
        if (ST_UniversalMeasure.f(c, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.c(c.getValueOrDefault()));
        }
        return Nullable$1.toNullable(ST_Coordinate32.$, null);
    }
    toString() {
        if (nullableNotEquals(this.k, null)) {
            return this.k.getValueOrDefault().toString();
        }
        if (ST_UniversalMeasure.f(this.l, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.l.getValueOrDefault().toString();
        }
        return stringEmpty();
    }
    static a(a) {
        return new ST_Coordinate32(1, ST_Coordinate32Unqualified.a(a));
    }
    static n(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.a(a.value));
    }
    static b(a) {
        return new ST_Coordinate32(1, a);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.b(a.value));
    }
    static h(a) {
        return a.k.value;
    }
    static m(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32Unqualified.$, ST_Coordinate32.h(a.value));
    }
    static c(a) {
        return new ST_Coordinate32(2, a);
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Coordinate32.$, null);
        }
        return Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.c(a.value));
    }
}
ST_Coordinate32.$t = markStruct(ST_Coordinate32, 'ST_Coordinate32');
/**
 * @hidden
 */
export class CT_TextBodyProperties extends CT_TextBodyPropertiesBase {
    constructor() {
        super(...arguments);
        this.d = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(ST_Coordinate32.$, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.j = Nullable$1.toNullable(ST_Coordinate32.$, null);
        this.k = Nullable$1.toNullable(Number_$type, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.m = Nullable$1.toNullable(ST_Coordinate32.$, null);
        this.n = Nullable$1.toNullable(Number_$type, null);
        this.o = Nullable$1.toNullable(Number_$type, null);
        this.p = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        this.c = false;
        this.q = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null);
        this.r = Nullable$1.toNullable(ST_TextWrappingType_$type, null);
        this.s = Nullable$1.toNullable(ST_Coordinate32.$, null);
        this.t = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
    }
    static b(a) {
        let b = null;
        if (a != null) {
            b = typeCast(CT_TextBodyProperties.$, a);
            if (b == null) {
                b = new CT_TextBodyProperties();
                b.a = a.a;
            }
        }
        return b || new CT_TextBodyProperties();
    }
}
CT_TextBodyProperties.$t = markType(CT_TextBodyProperties, 'CT_TextBodyProperties', CT_TextBodyPropertiesBase.$);
/**
 * @hidden
 */
export class ST_TextPointUnqualified extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_TextPointUnqualified.$, c, "value", -400000, 400000);
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_TextPointUnqualified.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static i(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_TextPointUnqualified.$, ST_TextPointUnqualified.a(b));
        }
        return Nullable$1.toNullable(ST_TextPointUnqualified.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_TextPointUnqualified.e(a.value));
    }
    static a(a) {
        return new ST_TextPointUnqualified(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TextPointUnqualified.$, null);
        }
        return Nullable$1.toNullable(ST_TextPointUnqualified.$, ST_TextPointUnqualified.a(a.value));
    }
}
ST_TextPointUnqualified.$t = markStruct(ST_TextPointUnqualified, 'ST_TextPointUnqualified');
/**
 * @hidden
 */
export class ST_TextPoint extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = Nullable$1.toNullable(ST_TextPointUnqualified.$, null);
        this.c = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_TextPointUnqualified.$, c);
                    this.c = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.b = Nullable$1.toNullable(ST_TextPointUnqualified.$, null);
                    this.c = Nullable$1.toNullable(ST_UniversalMeasure.$, c);
                }
                break;
        }
    }
    toString() {
        if (nullableNotEquals(this.b, null)) {
            return this.b.toString();
        }
        if (ST_UniversalMeasure.f(this.c, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.c.toString();
        }
        return stringEmpty();
    }
    static a(a) {
        let b = ST_TextPointUnqualified.i(a);
        if (nullableNotEquals(b, null)) {
            return new ST_TextPoint(1, b.value);
        }
        let c = ST_UniversalMeasure.o(a);
        if (ST_UniversalMeasure.f(c, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return new ST_TextPoint(2, c.value);
        }
        throw DocCoreUtils.n(ST_TextPoint.$, a);
    }
}
ST_TextPoint.$t = markStruct(ST_TextPoint, 'ST_TextPoint');
/**
 * @hidden
 */
export class ST_Percentage extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.k = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.k = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_Percentage.$, typeCast(ST_Percentage.$, a));
        if (ST_Percentage.h(b, Nullable$1.toNullable(ST_Percentage.$, null))) {
            return false;
        }
        return ST_Percentage.e(this, b.getValueOrDefault());
    }
    getHashCode() {
        return (this.k);
    }
    toString() {
        return this.r(1);
    }
    r(a) {
        let t1 = a;
        L0: while (true) {
            switch (t1) {
                case 0: return truncate(DocCoreUtils.j(this.k * 1000)).toString();
                case 1: return numberToString(this.k, CultureInfo.invariantCulture) + "%";
                default:
                    t1 = 0;
                    continue L0;
            }
            break;
        }
    }
    static d(a, b) {
        let c = ST_Percentage.q(a, b);
        if (ST_Percentage.h(c, Nullable$1.toNullable(ST_Percentage.$, null))) {
            return c.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_Percentage.$, a);
    }
    static q(a, b) {
        if (stringIsNullOrEmpty(a)) {
            return Nullable$1.toNullable(ST_Percentage.$, null);
        }
        let t1 = b;
        L0: while (true) {
            switch (t1) {
                case 0:
                    {
                        if (a.charAt(a.length - 1) == '%') {
                            t1 = 1;
                            continue L0;
                        }
                        let c;
                        if (((() => { let d = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, c); c = d.p3; return d.ret; })()) == false) {
                            return Nullable$1.toNullable(ST_Percentage.$, null);
                        }
                        return Nullable$1.toNullable(ST_Percentage.$, new ST_Percentage(1, c / 1000));
                    }
                case 1:
                    {
                        if (a.charAt(a.length - 1) != '%') {
                            t1 = 0;
                            continue L0;
                        }
                        let d;
                        if (((() => { let e = tryParseNumber1(a.substr(0, a.length - 1), 167 | 64, CultureInfo.invariantCulture, d); d = e.p3; return e.ret; })()) == false) {
                            return Nullable$1.toNullable(ST_Percentage.$, null);
                        }
                        return Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(d));
                    }
                default: return Nullable$1.toNullable(ST_Percentage.$, null);
            }
            break;
        }
    }
    static n(a) {
        return a.k / 100;
    }
    static a(a) {
        return new ST_Percentage(1, a * 100);
    }
    static e(a, b) {
        return a.k == b.k;
    }
    static f(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_Percentage.e(a.value, b.value);
    }
    static g(a, b) {
        return !(ST_Percentage.e(a, b));
    }
    static h(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_Percentage.g(a.value, b.value);
    }
    static b(a) {
        return new ST_Percentage(1, a);
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Percentage.$, null);
        }
        return Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.b(a.value));
    }
    static l(a) {
        return a.k;
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_Percentage.l(a.value));
    }
}
ST_Percentage.$t = markStruct(ST_Percentage, 'ST_Percentage');
/**
 * @hidden
 */
export class CT_TextCharacterPropertiesBase extends Base {
    constructor() {
        super(...arguments);
        this.c = null;
        this.b = null;
        this.a = null;
        this.k = Nullable$1.toNullable(Boolean_$type, null);
        this.v = null;
        this.t = null;
        this.r = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(Boolean_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.s = Nullable$1.toNullable(ST_TextUnderlineType_$type, null);
        this.q = Nullable$1.toNullable(ST_TextStrikeType_$type, null);
        this.j = Nullable$1.toNullable(Number_$type, null);
        this.f = Nullable$1.toNullable(ST_TextCapsType_$type, null);
        this.p = Nullable$1.toNullable(ST_TextPoint.$, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
        this.e = Nullable$1.toNullable(ST_Percentage.$, null);
        this.l = Nullable$1.toNullable(Boolean_$type, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.h = Nullable$1.toNullable(Boolean_$type, null);
        this.n = Nullable$1.toNullable(Boolean_$type, null);
        this.o = Nullable$1.toNullable(Number_$type, null);
        this.u = null;
    }
}
CT_TextCharacterPropertiesBase.$t = markType(CT_TextCharacterPropertiesBase, 'CT_TextCharacterPropertiesBase');
/**
 * @hidden
 */
export class CT_TextCharacterProperties extends CT_TextCharacterPropertiesBase {
    constructor() {
        super(...arguments);
        this.y = null;
        this.w = null;
    }
    cloneShallow() {
        return this.memberwiseClone();
    }
}
CT_TextCharacterProperties.$t = markType(CT_TextCharacterProperties, 'CT_TextCharacterProperties', CT_TextCharacterPropertiesBase.$, [IShallowCloneable_$type]);
/**
 * @hidden
 */
export class CT_TextFont extends Base {
    constructor() {
        super(...arguments);
        this.d = null;
        this.a = null;
        this.c = Nullable$1.toNullable(Number_$type, null);
        this.b = Nullable$1.toNullable(Number_$type, null);
    }
}
CT_TextFont.$t = markType(CT_TextFont, 'CT_TextFont');
/**
 * @hidden
 */
export class CT_TextListStyle extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = null;
        this.c = null;
        this.d = null;
        this.e = null;
        this.f = null;
        this.g = null;
        this.h = null;
        this.i = null;
        this.j = null;
        this.k = null;
    }
    setProperty(a, b) {
        switch (a) {
            case 454:
                this.a = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 945:
                this.b = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 946:
                this.c = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 947:
                this.d = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 948:
                this.e = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 949:
                this.f = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 950:
                this.g = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 951:
                this.h = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 952:
                this.i = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 953:
                this.j = typeCast(CT_TextParagraphProperties.$, b);
                break;
            case 601:
                this.k = b;
                break;
        }
    }
}
CT_TextListStyle.$t = markType(CT_TextListStyle, 'CT_TextListStyle', Base.$, [ISupportSetProperty_$type]);
/**
 * @hidden
 */
export class CT_TextParagraph extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = new List$1(IEG_TextRun_$type, 0);
    }
    get c() {
        return this.b;
    }
}
CT_TextParagraph.$t = markType(CT_TextParagraph, 'CT_TextParagraph');
/**
 * @hidden
 */
export class ST_TextMargin extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_TextMargin.$, c, "value", 0, 51206400);
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_TextMargin.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static i(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_TextMargin.$, ST_TextMargin.a(b));
        }
        return Nullable$1.toNullable(ST_TextMargin.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_TextMargin.e(a.value));
    }
    static a(a) {
        return new ST_TextMargin(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TextMargin.$, null);
        }
        return Nullable$1.toNullable(ST_TextMargin.$, ST_TextMargin.a(a.value));
    }
}
ST_TextMargin.$t = markStruct(ST_TextMargin, 'ST_TextMargin');
/**
 * @hidden
 */
export class ST_TextIndentLevelType extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_TextIndentLevelType.$, c, "value", 0, 8);
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_TextIndentLevelType.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static i(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_TextIndentLevelType.$, ST_TextIndentLevelType.a(b));
        }
        return Nullable$1.toNullable(ST_TextIndentLevelType.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_TextIndentLevelType.e(a.value));
    }
    static a(a) {
        return new ST_TextIndentLevelType(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TextIndentLevelType.$, null);
        }
        return Nullable$1.toNullable(ST_TextIndentLevelType.$, ST_TextIndentLevelType.a(a.value));
    }
}
ST_TextIndentLevelType.$t = markStruct(ST_TextIndentLevelType, 'ST_TextIndentLevelType');
/**
 * @hidden
 */
export class ST_TextIndent extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_TextIndent.$, c, "value", -51206400, 51206400);
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_TextIndent.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static i(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_TextIndent.$, ST_TextIndent.a(b));
        }
        return Nullable$1.toNullable(ST_TextIndent.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_TextIndent.e(a.value));
    }
    static a(a) {
        return new ST_TextIndent(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TextIndent.$, null);
        }
        return Nullable$1.toNullable(ST_TextIndent.$, ST_TextIndent.a(a.value));
    }
}
ST_TextIndent.$t = markStruct(ST_TextIndent, 'ST_TextIndent');
/**
 * @hidden
 */
export class CT_TextParagraphProperties extends Base {
    constructor() {
        super(...arguments);
        this.k = Nullable$1.toNullable(ST_TextMargin.$, null);
        this.l = Nullable$1.toNullable(ST_TextMargin.$, null);
        this.j = Nullable$1.toNullable(ST_TextIndentLevelType.$, null);
        this.h = Nullable$1.toNullable(ST_TextIndent.$, null);
        this.c = Nullable$1.toNullable(ST_TextAlignType_$type, null);
        this.d = Nullable$1.toNullable(ST_Coordinate32.$, null);
        this.m = Nullable$1.toNullable(Boolean_$type, null);
        this.e = Nullable$1.toNullable(Boolean_$type, null);
        this.f = Nullable$1.toNullable(ST_TextFontAlignType_$type, null);
        this.i = Nullable$1.toNullable(Boolean_$type, null);
        this.g = Nullable$1.toNullable(Boolean_$type, null);
        this.a = null;
    }
    static b(a) {
        let b = Nullable$1.toNullable(ST_TextAlignType_$type, null);
        let c = Nullable$1.toNullable(Number_$type, null);
        let d = Nullable$1.toNullable(Boolean_$type, null);
        let e = Nullable$1.toNullable(ST_TextFontAlignType_$type, null);
        let f = Nullable$1.toNullable(Boolean_$type, null);
        let g = Nullable$1.toNullable(Number_$type, null);
        let h = Nullable$1.toNullable(Boolean_$type, null);
        let i = Nullable$1.toNullable(Number_$type, null);
        let j = Nullable$1.toNullable(Number_$type, null);
        let k = Nullable$1.toNullable(Number_$type, null);
        let l = Nullable$1.toNullable(Boolean_$type, null);
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "algn":
                    b = Nullable$1.toNullable(ST_TextAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextAlignType_$type, m.d));
                    break;
                case "defTabSz":
                    c = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "eaLnBrk":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "fontAlgn":
                    e = Nullable$1.toNullable(ST_TextFontAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextFontAlignType_$type, m.d));
                    break;
                case "hangingPunct":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "indent":
                    g = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "latinLnBrk":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "lvl":
                    i = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "marL":
                    j = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "marR":
                    k = Nullable$1.toNullable(Number_$type, parseInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "rtl":
                    l = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                default: break;
            }
        }
        let n = ((() => {
            let $ret = new CT_TextParagraphProperties();
            $ret.c = b;
            $ret.d = ST_Coordinate32.n(c);
            $ret.e = d;
            $ret.f = e;
            $ret.g = f;
            $ret.h = ST_TextIndent.h(g);
            $ret.i = h;
            $ret.j = ST_TextIndentLevelType.h(i);
            $ret.k = ST_TextMargin.h(j);
            $ret.l = ST_TextMargin.h(k);
            $ret.m = l;
            return $ret;
        })());
        return n;
    }
}
CT_TextParagraphProperties.$t = markType(CT_TextParagraphProperties, 'CT_TextParagraphProperties');
/**
 * @hidden
 */
export class CT_TileInfoProperties extends Base {
    constructor() {
        super(...arguments);
        this.a = Nullable$1.toNullable(ST_RectAlignment_$type, null);
        this.b = Nullable$1.toNullable(ST_TileFlipMode_$type, null);
        this.c = Nullable$1.toNullable(ST_Percentage.$, null);
        this.d = Nullable$1.toNullable(ST_Percentage.$, null);
        this.e = Nullable$1.toNullable(ST_Coordinate.$, null);
        this.f = Nullable$1.toNullable(ST_Coordinate.$, null);
    }
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitCT_TileInfoProperties$i(this, b);
    }
}
CT_TileInfoProperties.$t = markType(CT_TileInfoProperties, 'CT_TileInfoProperties', Base.$, [IEG_FillModeProperties_$type]);
/**
 * @hidden
 */
export class CT_XYAdjustHandle extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
        this.b = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        this.f = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        this.d = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        this.c = Nullable$1.toNullable(ST_GeomGuideName.$, null);
        this.g = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
        this.e = Nullable$1.toNullable(ST_AdjCoordinate.$, null);
    }
}
CT_XYAdjustHandle.$t = markType(CT_XYAdjustHandle, 'CT_XYAdjustHandle', Base.$, [IAdjustHandle_$type]);
/**
 * @hidden
 */
export let IEG_ColorChoiceVisitor$2_$type = new Type(null, 'IEG_ColorChoiceVisitor$2');
/**
 * @hidden
 */
export let IEG_ColorTransform_$type = new Type(null, 'IEG_ColorTransform');
/**
 * @hidden
 */
export let IEG_ColorTransformVisitor$2_$type = new Type(null, 'IEG_ColorTransformVisitor$2');
/**
 * @hidden
 */
export let IEG_FillModePropertiesVisitor$2_$type = new Type(null, 'IEG_FillModePropertiesVisitor$2');
/**
 * @hidden
 */
export let IEG_FillPropertiesVisitor$2_$type = new Type(null, 'IEG_FillPropertiesVisitor$2');
/**
 * @hidden
 */
export let IEG_GeometryVisitor$2_$type = new Type(null, 'IEG_GeometryVisitor$2');
/**
 * @hidden
 */
export let IEG_LineDashPropertiesVisitor$2_$type = new Type(null, 'IEG_LineDashPropertiesVisitor$2');
/**
 * @hidden
 */
export let IEG_LineFillPropertiesVisitor$2_$type = new Type(null, 'IEG_LineFillPropertiesVisitor$2');
/**
 * @hidden
 */
export let IEG_LineJoinPropertiesVisitor$2_$type = new Type(null, 'IEG_LineJoinPropertiesVisitor$2');
/**
 * @hidden
 */
export let IEG_TextRunVisitor$2_$type = new Type(null, 'IEG_TextRunVisitor$2');
/**
 * @hidden
 */
export let IGraphicalObjectContentVisitor$2_$type = new Type(null, 'IGraphicalObjectContentVisitor$2');
/**
 * @hidden
 */
export let IPath2DCommandVisitor$2_$type = new Type(null, 'IPath2DCommandVisitor$2');
/**
 * @hidden
 */
export class ColorTransform_Alpha extends CT_PositiveFixedPercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Alpha$i(this, b);
    }
}
ColorTransform_Alpha.$t = markType(ColorTransform_Alpha, 'ColorTransform_Alpha', CT_PositiveFixedPercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_AlphaOff extends CT_FixedPercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_AlphaOff$i(this, b);
    }
}
ColorTransform_AlphaOff.$t = markType(ColorTransform_AlphaOff, 'ColorTransform_AlphaOff', CT_FixedPercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_AlphaMod extends CT_PositivePercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_AlphaMod$i(this, b);
    }
}
ColorTransform_AlphaMod.$t = markType(ColorTransform_AlphaMod, 'ColorTransform_AlphaMod', CT_PositivePercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Blue extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Blue$i(this, b);
    }
}
ColorTransform_Blue.$t = markType(ColorTransform_Blue, 'ColorTransform_Blue', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_BlueOff extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_BlueOff$i(this, b);
    }
}
ColorTransform_BlueOff.$t = markType(ColorTransform_BlueOff, 'ColorTransform_BlueOff', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_BlueMod extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_BlueMod$i(this, b);
    }
}
ColorTransform_BlueMod.$t = markType(ColorTransform_BlueMod, 'ColorTransform_BlueMod', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Comp extends CT_ComplementTransform {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Comp$i(this, b);
    }
}
ColorTransform_Comp.$t = markType(ColorTransform_Comp, 'ColorTransform_Comp', CT_ComplementTransform.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Gray extends CT_GrayscaleTransform {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Gray$i(this, b);
    }
}
ColorTransform_Gray.$t = markType(ColorTransform_Gray, 'ColorTransform_Gray', CT_GrayscaleTransform.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Green extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Green$i(this, b);
    }
}
ColorTransform_Green.$t = markType(ColorTransform_Green, 'ColorTransform_Green', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_GreenOff extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_GreenOff$i(this, b);
    }
}
ColorTransform_GreenOff.$t = markType(ColorTransform_GreenOff, 'ColorTransform_GreenOff', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_GreenMod extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_GreenMod$i(this, b);
    }
}
ColorTransform_GreenMod.$t = markType(ColorTransform_GreenMod, 'ColorTransform_GreenMod', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Hue extends CT_PositiveFixedAngle {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Hue$i(this, b);
    }
}
ColorTransform_Hue.$t = markType(ColorTransform_Hue, 'ColorTransform_Hue', CT_PositiveFixedAngle.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_HueOff extends CT_Angle {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_HueOff$i(this, b);
    }
}
ColorTransform_HueOff.$t = markType(ColorTransform_HueOff, 'ColorTransform_HueOff', CT_Angle.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_HueMod extends CT_PositivePercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_HueMod$i(this, b);
    }
}
ColorTransform_HueMod.$t = markType(ColorTransform_HueMod, 'ColorTransform_HueMod', CT_PositivePercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Inv extends CT_InverseTransform {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Inv$i(this, b);
    }
}
ColorTransform_Inv.$t = markType(ColorTransform_Inv, 'ColorTransform_Inv', CT_InverseTransform.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Lum extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Lum$i(this, b);
    }
}
ColorTransform_Lum.$t = markType(ColorTransform_Lum, 'ColorTransform_Lum', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_LumOff extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_LumOff$i(this, b);
    }
}
ColorTransform_LumOff.$t = markType(ColorTransform_LumOff, 'ColorTransform_LumOff', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_LumMod extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_LumMod$i(this, b);
    }
}
ColorTransform_LumMod.$t = markType(ColorTransform_LumMod, 'ColorTransform_LumMod', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Red extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Red$i(this, b);
    }
}
ColorTransform_Red.$t = markType(ColorTransform_Red, 'ColorTransform_Red', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_RedOff extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_RedOff$i(this, b);
    }
}
ColorTransform_RedOff.$t = markType(ColorTransform_RedOff, 'ColorTransform_RedOff', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_RedMod extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_RedMod$i(this, b);
    }
}
ColorTransform_RedMod.$t = markType(ColorTransform_RedMod, 'ColorTransform_RedMod', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Sat extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Sat$i(this, b);
    }
}
ColorTransform_Sat.$t = markType(ColorTransform_Sat, 'ColorTransform_Sat', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_SatOff extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_SatOff$i(this, b);
    }
}
ColorTransform_SatOff.$t = markType(ColorTransform_SatOff, 'ColorTransform_SatOff', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_SatMod extends CT_Percentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_SatMod$i(this, b);
    }
}
ColorTransform_SatMod.$t = markType(ColorTransform_SatMod, 'ColorTransform_SatMod', CT_Percentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Shade extends CT_PositiveFixedPercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Shade$i(this, b);
    }
}
ColorTransform_Shade.$t = markType(ColorTransform_Shade, 'ColorTransform_Shade', CT_PositiveFixedPercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ColorTransform_Tint extends CT_PositiveFixedPercentage {
    _accept$2$i($tArg, $tResult, a, b) {
        return a._visitColorTransform_Tint$i(this, b);
    }
}
ColorTransform_Tint.$t = markType(ColorTransform_Tint, 'ColorTransform_Tint', CT_PositiveFixedPercentage.$, [IEG_ColorTransform_$type]);
/**
 * @hidden
 */
export class ElementLoadCallbacks extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = null;
        this.a = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.b = c;
                    this.a = d;
                }
                break;
        }
    }
    get c() {
        return this.b == null && this.a == null;
    }
}
ElementLoadCallbacks.$t = markStruct(ElementLoadCallbacks, 'ElementLoadCallbacks');
/**
 * @hidden
 */
export class OfficeDocumentManager extends Base {
    constructor(a, b, c, d) {
        super();
        this._c = null;
        this._ap = Nullable$1.toNullable(ST_ConformanceClass_$type, null);
        this._ab = false;
        this._aj = null;
        this._al = null;
        this._ag = null;
        this._am = null;
        this._aq = null;
        this._ah = null;
        this._ai = null;
        this._y = null;
        this._a = null;
        this._ao = null;
        this._h = null;
        this._i = null;
        this._m = null;
        this._ax = null;
        this._av = null;
        this._aw = null;
        this._af = false;
        this._aj = new HashSet$1(String_$type, 0);
        this._al = new Stack$1(IPackagePart_$type);
        this._ag = new Dictionary$2(String_$type, Base.$, 0);
        this._am = new Stack$1(OfficeDocumentManager_PartRelationshipCounter.$);
        this._am.h(new OfficeDocumentManager_PartRelationshipCounter());
        this._aq = {};
        this._ah = new Dictionary$2(String_$type, PartManagerBase.$, 0);
        this._ai = new Dictionary$2(String_$type, PartManagerBase.$, 0);
        this._ap = d;
        this._ab = c;
        this._ao = b;
        if (a != null && this._ao != null) {
            this._a = new InvalidPackage();
            let e = WorkItemExtensions.f(IPackage_$type, a._open$i(this._ao, this._ab ? 3 : 2), (f) => {
                this._a = WorkItemExtensions.m(IPackage_$type, f);
                return null;
            });
            this._m = e;
        }
        else {
            this._m = WorkItem.g(Base.$, null);
        }
    }
    dispose() {
        this.disposeCore(true);
    }
    _a0(a, b) {
        return this._a1(a, b.o(this._z));
    }
    _a1(a, b) {
        return this._a2(a, b, 0);
    }
    _az(a, b) {
        return this._a2(a, b, 1);
    }
    _ay(a, b) {
        let c;
        if (((() => { let d = UriUtilities.a(a, c); c = d.p1; return d.ret; })())) {
            return this._az(c, b);
        }
        return this._a2(null, b, 1, a);
    }
    _j(a, b = null, c = null) {
        let d = a.n(this._v);
        if (a.g) {
            d = this._a6(d, a.h == false);
        }
        return this._k(a, d, b, c);
    }
    _k(a, b, c = null, d = null) {
        let e = UriUtilities.b(b);
        let f;
        if (d != null && this._ae(d)) {
            f = d;
            this._be(e, a.o(this._z), 0, f, null);
        }
        else {
            f = this._a2(e, a.o(this._z), 0);
        }
        let g = this._c;
        return WorkItemExtensions.g(Tuple$2.$.specialize(Uri.$, String_$type), Async.h(() => {
            if (g != null) {
                this._al.h(g);
            }
            let h = this._a.createPart(e, a.m);
            this._c = h;
            this._am.h(new OfficeDocumentManager_PartRelationshipCounter());
            return WorkItemExtensions.a(Async.o(Stream.$, h.getStream(2, 2), (i) => {
                let j = a.e(this, i);
                return j.b(c);
            }), () => {
                this._am.e();
                this._ag.addItem(b, c);
            });
        }, () => {
            if (g != null) {
                this._al.e();
            }
            this._c = g;
        }), () => Tuple.a(Uri.$, String_$type, e, f));
    }
    _l(a, b, c = null, d = null) {
        if (b == null) {
            return null;
        }
        let e = this._w(a);
        if (e == null) {
            return null;
        }
        return this._k(e, b, c, d);
    }
    _a5() {
        if (this._ao == null) {
            return null;
        }
        return DocCoreUtils.y(this._ao);
    }
    _u(a) {
        return (this._aq[a] || null);
    }
    _e(a) {
        return this._b.getPart(a);
    }
    _ar(a) {
        return this._at(a.uri.toString());
    }
    _as(a) {
        let b = PackageUtilities.ak(a).originalString;
        return this._at(b);
    }
    _bd(a) {
        for (let b of fromEnum(this._ag)) {
            if (Base.equalsStatic(b.value, a)) {
                return UriUtilities.b(b.key);
            }
        }
        return null;
    }
    _au(a) {
        let b = this._g(a);
        if (b == null) {
            return null;
        }
        if (b.targetMode == 1) {
            if (typeCast(IInvalidPackageRelationshipTarget_$type, b) !== null) {
                return b.targetString;
            }
            return b.targetUri;
        }
        return this._as(b);
    }
    _bc($tData, a) {
        let b = a.o(this._z);
        for (let c of fromEnum(this._ak())) {
            if (c.relationshipType == b) {
                let d = this._au(c.id);
                if (d != null) {
                    return Tuple.a(String_$type, $tData, c.id, typeCastObjTo$t($tData, d));
                }
                break;
            }
        }
        return null;
    }
    _g(a) {
        return this._c != null ? this._c.getRelationship(a) : this._a.getRelationship(a);
    }
    _f(a) {
        for (let b of fromEnum(this._ak())) {
            if (this._as(b) == a) {
                return b;
            }
        }
        return null;
    }
    _a7(a, b) {
        let c = a;
        let d = c == 0 ? 1 : 0;
        for (let e of fromEnum(this._ai)) {
            let f = e.value.o(d);
            let g = e.value.o(c);
            if (f == b || b == g) {
                return g;
            }
        }
        return null;
    }
    _bh() {
        this._bk(XmlNamespace.an);
        this._bk(VmlNamespace.an);
        this._bk(CoreProperties.an);
        this._bk(DcDcmiType.an);
        this._bk(DcElements.an);
        this._bk(DcTerms.an);
        this._bk(Drawing2010Main.an);
        this._bk(Drawing2010Slicer.an);
        this._bk(DrawingMLChart.an);
        this._bk(DrawingMLChart2014.an);
        this._bk(DrawingMLChartEx2015_9_8.an);
        this._bk(DrawingMLChartEx2015_10_21.an);
        this._bk(DrawingMLChartEx2016_5_10.an);
        this._bk(DrawingMLMain.an);
        this._bk(EmptyNamespace.an);
        this._bk(MarkupCompatibility2006.an);
        this._bk(OfficeDocumentDocPropsVTypes.an);
        this._bk(OfficeDocumentExtendedProperties.an);
        this._bk(OfficeDocumentRelationships.an);
        this._bk(OfficeNamespace.an);
        this._bk(XmlSchemaInstance.an);
        this._bk(IGOfficeExtensions.an);
        let a = this._t;
        if (a != null) {
            this._bk(a);
        }
        if (nullableEquals(this._ap, null)) {
            this._ap = Nullable$1.toNullable(ST_ConformanceClass_$type, this._aa());
        }
    }
    _ad(a) {
        return (this._aq[a] != null);
    }
    _n() {
        return WorkItemExtensions.c(this._m, () => {
            this._bh();
            return this._o();
        });
    }
    _bj() {
    }
    _bb(a) {
        if (a == null || a.length == 0) {
            if (this._aw != null) {
                return this._aw;
            }
        }
        else if (Base.equalsStatic(a, this._ax)) {
            return this._av;
        }
        else {
            this._ax = a;
        }
        let b = this._u(a);
        if (b != null) {
            a = b.i(1);
        }
        if (a == null || a.length == 0) {
            this._aw = a;
        }
        else {
            this._av = a;
        }
        return a;
    }
    _r() {
        this._bh();
        return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(this._m, () => this._s()), () => Async.g(this._h != null, () => this._j(Office2007ExtensibilityPartManager.a4))), () => Async.g(this._i != null, () => this._j(Office2010ExtensibilityPartManager.a4)));
    }
    _bn(a) {
        this._ap = Nullable$1.toNullable(ST_ConformanceClass_$type, a);
    }
    disposeCore(a) {
        if (this._a != null) {
            this._a.dispose();
            this._a = null;
        }
    }
    _o() {
        return WorkItemExtensions.f(Boolean_$type, this._q(null, null, this._a.getRelationships(), false), (a) => {
            let b = WorkItemExtensions.m(Boolean_$type, a);
            return Async.g((this._y != null && this._af == false), () => {
                let c = this._a6(this._y.n(this._v), void 0, true);
                let d = null;
                return Async.g((this._aj.contains(c) == false && ((() => { let e = Uri.tryCreate(c, 2, d); d = e.p2; return e.ret; })()) && this._a.partExists(d)), () => this._p(this._a.getPart(d)));
            });
        });
    }
    _bi(a) {
        this._bj();
    }
    _bk(a) {
        this._aq[a.i(1)] = a;
        this._aq[a.i(0)] = a;
    }
    _bl(a, b = true) {
        if (b) {
            this._ah.item(a.m, a);
        }
        this._ai.item(a.o(this._z), a);
        let c = typeCast(ThemePartManager.$, a);
        if (c != null) {
            this._y = c;
        }
    }
    _a2(a, b, c, d = null) {
        let e;
        let f = this._am.d();
        e = OfficeDocumentManager._a3(f.b);
        this._be(a, b, c, e, d);
        return e;
    }
    _be(a, b, c, d, e) {
        this._am.d().c();
        let f;
        if (c == 0) {
            if (this._c == null) {
                let g = new Uri(1, "/".toString(), 0);
                f = PackageUtilities.ai(g, a);
            }
            else {
                f = PackageUtilities.ai(this._c.uri, a);
            }
        }
        else {
            if (a == null && e != null) {
                let h = typeCast(IPackagePartEx_$type, this._c);
                if (h != null) {
                    h.createExternalRelationship(e, b, d);
                    return;
                }
            }
            f = a;
        }
        if (this._c == null) {
            this._a.createRelationship(f, c, b, d);
        }
        else {
            this._c.createRelationship(f, c, b, d);
        }
    }
    static _a3(a) {
        return "rId" + (a + 1).toString();
    }
    _ak() {
        if (this._c != null) {
            return this._c.getRelationships();
        }
        return this._a.getRelationships();
    }
    _a4() {
        switch (this._z) {
            case 0: return OfficeDocumentManager._a9;
            case 1: return OfficeDocumentManager._a8;
            default: return OfficeDocumentManager._a9;
        }
    }
    _a6(a, b = false, c = false) {
        let d = new HashSet$1(String_$type, 2, StringUtilities.e);
        if (c == false && b) {
            for (let e of fromEnum(this._a.getParts())) {
                let f = e.uri.toString();
                let g = IOPath.getExtension(f);
                let h = f.substr(0, f.length - g.length);
                d.add_1(h);
            }
        }
        let i = IOPath.getExtension(a);
        let j = a.substr(0, a.length - i.length);
        let k = 1;
        while (true) {
            if (b) {
                let l = j + k;
                if (c || d.contains(l) == false) {
                    l += i;
                    return l;
                }
            }
            else {
                let m = j + k + i;
                if (c || this._a.partExists(UriUtilities.b(m)) == false) {
                    return m;
                }
            }
            k++;
        }
    }
    _at(a) {
        let b;
        let c = this._ag.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _w(a) {
        let b;
        let c = this._ah.tryGetValue(a, b);
        b = c.p1;
        return b;
    }
    _x(a) {
        let b;
        if (((() => { let c = this._ai.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
            let c = "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet";
            let d = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet";
            let e = "http://purl.oclc.org/ooxml/officeDocument/relationships/drawing";
            let f = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";
            switch (a) {
                case c:
                    let g = this._ai.tryGetValue(d, b);
                    b = g.p1;
                    break;
                case e:
                    let h = this._ai.tryGetValue(f, b);
                    b = h.p1;
                    break;
            }
        }
        return b;
    }
    _ae(a) {
        for (let b of fromEnum(this._ak())) {
            if (b.id == a) {
                return false;
            }
        }
        return true;
    }
    _p(a, b = null) {
        if (b == null) {
            b = this._w(a.contentType);
        }
        let c = a.getRelationships();
        let d = a.uri.toString();
        if (this._aj.add_1(d) == false) {
            return null;
        }
        let e = null;
        let f = null;
        return WorkItemExtensions.f(Boolean_$type, this._q(a, b, c, false), (g) => {
            let h = WorkItemExtensions.m(Boolean_$type, g);
            return WorkItemExtensions.a(WorkItemExtensions.c(Async.g((b != null), () => {
                let i = this._c;
                return Async.h(() => {
                    this._c = a;
                    return Async.o(Stream.$, a.getStream(3, 1), (j) => {
                        f = b.e(this, j);
                        return WorkItemExtensions.e(Base.$, f.a(), (k) => e = WorkItemExtensions.m(Base.$, k));
                    });
                }, () => this._c = i);
            }, () => {
                this._bi(a);
                return null;
            }), () => {
                if (e != null) {
                    this._ag.item(d, e);
                }
                return Async.g(h, () => this._q(a, b, c, true));
            }), () => {
                if (f != null) {
                    f.q();
                }
            });
        });
    }
    _q(a, b, c, d) {
        let e = false;
        return WorkItemExtensions.g(Boolean_$type, Async.h(() => {
            if (a != null) {
                this._al.h(a);
            }
            let f = this._bm(b, c);
            c = f.p1;
            return Async.d(IPackageRelationship_$type, c, (g) => {
                if (g.relationshipType == this._a4()) {
                    return null;
                }
                switch (g.targetMode) {
                    case 0:
                        {
                            if (b != null) {
                                let h = this._x(g.relationshipType);
                                let i = h != null && b.i(h);
                                if (d != i) {
                                    e = true;
                                    return null;
                                }
                            }
                            if (g.targetUri != null && g.targetUri.originalString == "NULL") {
                                return null;
                            }
                            let j = PackageUtilities.ak(g);
                            let k = this._a.getPart(j);
                            let l = null;
                            if (b != null) {
                                l = b.f(k, g);
                            }
                            if (l == null && k != null && k.contentType == "application/xml") {
                                let m = this._x(g.relationshipType);
                                if (m != null && m.m != k.contentType) {
                                    k = new OverrideContentTypePart(k, m.m);
                                }
                                l = m;
                            }
                            return this._p(k, l);
                        }
                    case 1: break;
                    default: break;
                }
                return null;
            });
        }, () => {
            if (a != null) {
                this._al.e();
            }
        }), () => e);
    }
    _bm(a, b) {
        if (a == null) {
            return {
                p1: b
            };
        }
        let c = a.j();
        if (c == null) {
            return {
                p1: b
            };
        }
        let d = new Dictionary$2(String_$type, Number_$type, 0);
        for (let e of fromEnum(c)) {
            d.addItem(e.key.o(this._z), e.value);
        }
        let f = new List$1(IPackageRelationship_$type, 1, b);
        f.aa((g, h) => {
            let i;
            let j = ((() => { let k = d.tryGetValue(g.relationshipType, i); i = k.p1; return k.ret; })());
            let k;
            let l = ((() => { let m = d.tryGetValue(h.relationshipType, k); k = m.p1; return m.ret; })());
            if (j == false && l == false) {
                return 0;
            }
            else if (j && l == false) {
                return -1;
            }
            else if (j == false && l) {
                return 1;
            }
            return Base.compareSimple(i, k);
        });
        b = f;
        return {
            p1: b
        };
    }
    get _d() {
        return this._c;
    }
    get _z() {
        return this._ap.getValueOrDefault1(0);
    }
    get _ac() {
        return this._ab;
    }
    get _an() {
        return this._al;
    }
    get _b() {
        return this._a;
    }
}
OfficeDocumentManager.$t = markType(OfficeDocumentManager, 'OfficeDocumentManager', Base.$, [IDisposable_$type]);
OfficeDocumentManager._a9 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
OfficeDocumentManager._a8 = "http://purl.oclc.org/ooxml/officeDocument/relationships/hyperlink";
/**
 * @hidden
 */
export class OfficeDocumentManager_PartRelationshipCounter extends Base {
    constructor() {
        super();
        this.a = 0;
    }
    c() {
        this.a++;
    }
    get b() {
        return this.a;
    }
}
OfficeDocumentManager_PartRelationshipCounter.$t = markType(OfficeDocumentManager_PartRelationshipCounter, 'OfficeDocumentManager_PartRelationshipCounter');
/**
 * @hidden
 */
export class QualifiedNameInfo extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.h = null;
        this.g = null;
        this.f = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    if (c == stringEmpty()) {
                        c = null;
                    }
                    this.h = c;
                    this.g = d;
                    this.f = e;
                }
                break;
        }
    }
    toString() {
        if (this.h != null) {
            return this.h + ":" + this.f;
        }
        return this.f;
    }
    static d(a, b) {
        if (stringIsNullOrEmpty(a)) {
            return b;
        }
        let c;
        if (a.charAt(a.length - 1) != "/") {
            a += "/";
        }
        c = a + b;
        return c;
    }
    e(a) {
        if (this.g == null) {
            return this.f;
        }
        if (a == null) {
            return QualifiedNameInfo.d(this.g, this.f);
        }
        return QualifiedNameInfo.d(a._bb(this.g), this.f);
    }
    i(a, b, c) {
        if (a == stringEmpty()) {
            a = null;
        }
        this.h = a;
        this.g = b;
        this.f = c;
    }
    b(a) {
        if (this.g == null) {
            return this;
        }
        if (a == null) {
            return this;
        }
        return new QualifiedNameInfo(1, this.h, a._bb(this.g), this.f);
    }
    get c() {
        return this.f == null;
    }
}
QualifiedNameInfo.$t = markStruct(QualifiedNameInfo, 'QualifiedNameInfo');
QualifiedNameInfo.a = new QualifiedNameInfo(0);
/**
 * @hidden
 */
export class UnknownElementCache extends Base {
    constructor(a, b) {
        super();
        this.h = null;
        this.i = null;
        this.a = new QualifiedNameInfo();
        this.m = null;
        this.o = null;
        this.a = a;
        this.o = b;
    }
    l(a, b) {
        for (let c of fromEnum(this.j)) {
            if (c.a.e(b) == a) {
                return Nullable$1.toNullable(AttributeValue.$, c);
            }
        }
        return Nullable$1.toNullable(AttributeValue.$, null);
    }
    c(a, b) {
        return Enumerable.ag(UnknownElementCache.$, this.k, (c) => c.b.e(b) == a);
    }
    f(a, b) {
        return Enumerable.u(UnknownElementCache.$, this.k, (c) => c.b.e(b) == a);
    }
    *_g(a, b) {
        for (let c of fromEnum(this.k)) {
            if (c.b.e(b) == a) {
                yield c;
            }
            for (let d of fromEnum(c.g(a, b))) {
                yield d;
            }
        }
    }
    g(a, b) {
        return toEnum(() => this._g(a, b));
    }
    get j() {
        if (this.h == null) {
            this.h = new List$1(AttributeValue.$, 0);
        }
        return this.h;
    }
    get d() {
        return this.h != null && this.h.count != 0;
    }
    get k() {
        if (this.i == null) {
            this.i = new List$1(UnknownElementCache.$, 0);
        }
        return this.i;
    }
    get e() {
        return this.i != null && this.i.count != 0;
    }
    get b() {
        return this.a;
    }
    get n() {
        return this.m;
    }
    set n(a) {
        this.m = a;
    }
    get p() {
        return this.o;
    }
    set p(a) {
        this.o = a;
    }
}
UnknownElementCache.$t = markType(UnknownElementCache, 'UnknownElementCache');
/**
 * @hidden
 */
export class UnknownStructure extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
    get b() {
        return this.a;
    }
}
UnknownStructure.$t = markType(UnknownStructure, 'UnknownStructure');
/**
 * @hidden
 */
export class XmlReadManager extends Base {
    constructor(a, b) {
        super();
        this.u = null;
        this.ab = 0;
        this.k = new QualifiedNameInfo();
        this.ad = null;
        this.v = null;
        this.z = 0;
        this.m = null;
        this.b = null;
        this.i = null;
        this.j = null;
        this.ao = null;
        this.aa = 0;
        this.w = new Stack$1(XmlReadManager_LoadChildContext.$);
        this.x = new Stack$1(XmlReadManager_LoadFastContext.$);
        this.a = ([]);
        this.y = 0;
        this.v = new Stack$1(XmlReadManager_AlternateContentChoiceContext.$);
        this.u = new List$1(AttributeValue.$, 0);
        this.z = -1;
        this.b = new Array(16);
        this.i = a.d;
        this.j = a;
        this.ao = b;
    }
    q(a) {
        for (let b = 0; b <= this.z; b++) {
            if (this.b[b].a(a)) {
                return true;
            }
        }
        return false;
    }
    r(a) {
        if (this.w.f > 0) {
            let b = this.w.d();
            if (a == b.b.e(this.i)) {
                return true;
            }
        }
        return false;
    }
    d() {
        this.aa = 0;
        return this.f(this.w.f);
    }
    f(a, b = 0, c = 0, d = false, e = false) {
        let f = new XmlReadManager_LoadChildContext();
        if (d) {
            f = this.w.e();
        }
        else {
            f = new XmlReadManager_LoadChildContext();
            f.h = b;
            f.c = c;
        }
        let g = null;
        while (true) {
            if (e == true) {
                e = false;
            }
            else {
                if (this.ao.a7 == 15) {
                    if (this.w.f == a) {
                        break;
                    }
                    f = this.w.e();
                    e = true;
                    continue;
                }
                f.b = this.l();
                if (f.b.c) {
                    if (this.w.f == a) {
                        break;
                    }
                    f = this.w.e();
                    e = true;
                    continue;
                }
                this.al();
                f.f = true;
                f.g = true;
                f.e = false;
                g = f.b.e(this.i);
                let h = null;
                switch (g) {
                    case MarkupCompatibility2006.ap: return WorkItemExtensions.c(this.c(f.b, f.h), () => {
                        if (f.g && this.ao.t() == false) {
                            if (this.w.f == a) {
                                return null;
                            }
                            f = this.w.e();
                            e = true;
                        }
                        else {
                            if (f.f) {
                                f.h++;
                            }
                            this.ak();
                        }
                        this.w.h(f);
                        return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
                    });
                    case MarkupCompatibility2006.aq:
                        h = this.g(f.b, f.h, f.c);
                        break;
                    case MarkupCompatibility2006.ar:
                        h = this.h(f.b, f.h, f.c);
                        break;
                    default:
                        f.e = true;
                        break;
                }
                if (h != null) {
                    return WorkItemExtensions.f(Boolean_$type, h, (i) => {
                        if (WorkItemExtensions.m(Boolean_$type, i) == false) {
                            f.f = false;
                            f.g = false;
                        }
                        else {
                            f.c = 2;
                        }
                        if (f.g && this.ao.t() == false) {
                            if (this.w.f == a) {
                                return null;
                            }
                            f = this.w.e();
                            e = true;
                        }
                        else {
                            if (f.f) {
                                f.h++;
                            }
                            this.ak();
                        }
                        this.w.h(f);
                        return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
                    });
                }
                if (f.e) {
                    let i = false;
                    f.a = this.j.x(g);
                    if (f.a.c) {
                        if (this.t(f.b, f.h)) {
                            f.g = false;
                            i = true;
                        }
                    }
                    if (!i) {
                        let j = this.ao.i;
                        this.am(f.b, false);
                        f.d = j;
                        if (f.a.b != null) {
                            this.k = f.b;
                            this.ab = f.h;
                            f.a.b(this.j);
                        }
                        if (f.d == false) {
                            if (this.j.ai(f.b.e(this.i))) {
                                if (this.b[this.z].b) {
                                    return WorkItemExtensions.c(WorkItemExtensions.a(this.e(this.x.f), () => {
                                    }), () => {
                                        this.w.h(f);
                                        return WorkItem.d(() => this.f(a, f.h, f.c, true, true), 2);
                                    });
                                }
                                else {
                                    this.w.h(f);
                                    f = new XmlReadManager_LoadChildContext();
                                    f.h = 0;
                                    f.c = 0;
                                    continue;
                                }
                            }
                            else {
                                while (this.ao.a7 != 15) {
                                    this.ao.a2();
                                }
                            }
                        }
                    }
                }
            }
            if (f.e) {
                if (f.a.a != null) {
                    this.k = f.b;
                    this.ab = f.h;
                    f.a.a(this.j);
                }
            }
            if (f.g && this.ao.t() == false) {
                if (this.w.f == a) {
                    break;
                }
                f = this.w.e();
                e = true;
                continue;
            }
            if (f.f) {
                f.h++;
            }
            this.ak();
            this.aa++;
            if (1000 < this.aa) {
                this.aa = 0;
                this.w.h(f);
                return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
            }
        }
        return null;
    }
    e(a, b = false, c = false) {
        let d = b ? this.x.e() : new XmlReadManager_LoadFastContext();
        let e = null;
        while (true) {
            if (c == false) {
                if (this.ao.a7 == 15) {
                    if (this.x.f == a) {
                        break;
                    }
                    d = this.x.e();
                    c = true;
                    continue;
                }
                d.b = this.l();
                if (d.b.c) {
                    if (this.x.f == a) {
                        break;
                    }
                    d = this.x.e();
                    c = true;
                    continue;
                }
                this.al();
                e = d.b.e(this.i);
            }
            if (c == false && e == MarkupCompatibility2006.ap) {
                return WorkItemExtensions.c(this.c(d.b, 0), () => {
                    if (this.ao.t() == false) {
                        if (this.x.f == a) {
                            return null;
                        }
                        d = this.x.e();
                        c = true;
                    }
                    else {
                        d.c++;
                        this.ak();
                    }
                    this.x.h(d);
                    return WorkItem.d(() => this.e(a, true, c), 2);
                });
            }
            else {
                if (c) {
                    c = false;
                }
                else {
                    d.a = this.j.x(e);
                    let f = this.ao.i;
                    this.am(d.b, false);
                    if (d.a.b != null) {
                        this.k = d.b;
                        this.ab = d.c;
                        d.a.b(this.j);
                    }
                    if (f == false) {
                        this.x.h(d);
                        d = new XmlReadManager_LoadFastContext();
                        continue;
                    }
                }
                if (d.a.a != null) {
                    this.k = d.b;
                    this.ab = d.c;
                    d.a.a(this.j);
                }
            }
            if (this.ao.t() == false) {
                if (this.x.f == a) {
                    break;
                }
                d = this.x.e();
                c = true;
                continue;
            }
            d.c++;
            this.ak();
            if (1000 < ++this.aa) {
                this.aa = 0;
                this.x.h(d);
                return WorkItem.d(() => this.e(a, true, c), 2);
            }
        }
        return null;
    }
    ae(a) {
        return this.ao.ah(a);
    }
    aj() {
        if (this.v.f == 0) {
            return;
        }
        this.v.d().a = true;
    }
    an() {
        this.b[this.z].b = true;
    }
    ah(a, ...b) {
        for (let c = 0; c < b.length; c++) {
            let d = this.ae(b[c]);
            if (d != null) {
                a.add_1(d);
            }
        }
    }
    c(a, b) {
        let c = this.ao.i;
        this.am(a, false);
        this.k = a;
        this.ab = b;
        if (c == false) {
            return this.f(this.w.f, b, 1);
        }
        return null;
    }
    o(a, b) {
        b = this.ao.i;
        this.am(a, true, true);
        let c = new UnknownElementCache(a, this.ad);
        if (this.u.count != 0) {
            c.j.o(this.u);
        }
        return {
            ret: c,
            p1: b
        };
    }
    p(a, b) {
        this.al();
        let c;
        let d = ((() => { let e = this.o(a, c); c = e.p1; return e.ret; })());
        let e = this.j.w(a);
        if (e.b != null) {
            this.k = a;
            this.ab = b;
            this.m = d;
            e.b(this.j);
            this.m = null;
        }
        if (c == false) {
            if (this.j.ai(a.e(this.i))) {
                this.ai(d);
            }
            else {
                while (this.ao.a7 != 15) {
                    this.ao.a2();
                }
            }
        }
        if (e.a != null) {
            this.k = a;
            this.ab = b;
            this.m = d;
            e.a(this.j);
            this.m = null;
        }
        this.j.au(d);
        this.ak();
        return d;
    }
    ai(a) {
        let b = 0;
        while (this.ao.a7 != 15) {
            let c = this.l();
            if (c.c) {
                break;
            }
            a.k.add(this.p(c, b));
            if (this.ao.t() == false) {
                break;
            }
            b++;
        }
    }
    t(a, b) {
        let c = a.e(this.i);
        let d = this.j.z(c);
        let t1 = d;
        L0: while (true) {
            switch (t1) {
                case 0:
                    this.ao.a2();
                    return true;
                case 1:
                    {
                        let e = this.ao.ap();
                        this.j.aw(c, e);
                        return true;
                    }
                case 2:
                    {
                        let f = this.p(a, b);
                        let g = new UnknownStructure(f);
                        this.j.av(g);
                        this.ao.t();
                        return true;
                    }
                case 3: return false;
                default:
                    t1 = 0;
                    continue L0;
            }
            break;
        }
    }
    l() {
        switch (this.ao.a7) {
            case 1: return new QualifiedNameInfo(1, this.ao.ak, this.ao.aj, this.ao.ag);
            case 2: break;
            case 15:
            case 14:
            case 3:
            case 0: break;
            case 17:
            case 13:
            case 8:
                {
                    do {
                        this.ao.t();
                    } while (this.ao.a7 == 13 || this.ao.a7 == 17 || this.ao.a7 == 8);
                    return this.l();
                }
            default: break;
        }
        return QualifiedNameInfo.a;
    }
    ak() {
        this.j.s.j(this.b[this.z].e, this.b[this.z].f);
        this.b[this.z] = (null);
        this.z--;
    }
    al() {
        this.z++;
        while (this.b.length <= this.z) {
            let a = new Array(this.b.length * 2);
            arrayCopy2(this.b, a, this.b.length);
            this.b = a;
        }
        this.b[this.z] = new XmlReadManager_ElementContext(1, this);
    }
    am(a, b, c = false) {
        this.y = 0;
        this.u.clear();
        this.ad = null;
        let d = this.ao.i;
        if (this.ao.r()) {
            do {
                let e = this.ao.aj;
                if (b == false && e == "http://www.w3.org/2000/xmlns/") {
                    if (this.ao.ag == "xmlns" || this.ao.ak == "xmlns") {
                        continue;
                    }
                }
                let f = new AttributeValue();
                if (c) {
                    f = new AttributeValue(1, this.ao.ak, e, this.ao.ag, this.ao.ar);
                }
                else if (this.y < this.a.length) {
                    f = (this.a[this.y++]);
                    f.e(this.ao.ak, e, this.ao.ag, this.ao.ar);
                }
                else {
                    f = new AttributeValue(1, this.ao.ak, e, this.ao.ag, this.ao.ar);
                    this.a.push(f);
                    this.y++;
                }
                if (f.a.f == "Ignorable" && f.a.e(this.i) == MarkupCompatibility2006.as) {
                    this.ah(this.b[this.z].d, ...stringSplit(f.d, [' '], 1));
                    continue;
                }
                this.u.add(f);
            } while (this.ao.s());
            this.ao.q();
        }
        if (d == false && this.ao.t()) {
            if (this.ao.a7 == 13 && a.f == "t" && a.e(this.i) == DrawingMLMain.ja) {
                this.ad = this.ao.ar;
            }
            else {
                while (this.ao.a7 == 13) {
                    this.ao.t();
                }
                if (this.ao.a7 == 14 || this.ao.a7 == 3) {
                    this.ad = this.ao.ar;
                    this.ao.t();
                }
            }
        }
    }
    ag(a) {
        let b = a.indexOf(':');
        if (b < 0) {
            return a;
        }
        let c = a.substr(0, b);
        let d = a.substr(b + 1);
        let e = this.ae(c);
        let f = new QualifiedNameInfo(1, c, e, d);
        return f.e(this.i);
    }
    g(a, b, c) {
        if (c != 1) {
            this.ao.a2();
            return WorkItem.g(Boolean_$type, false);
        }
        let d = this.ao.i;
        this.am(a, false);
        this.k = a;
        this.ab = b;
        let e;
        let f = MarkupCompatibility2006.aw(this.j, e);
        e = f.p1;
        if (this.j.ah(e) == false) {
            while (this.ao.a7 == 1) {
                this.ao.a2();
                if (this.ao.a7 == 13) {
                    this.ao.a2();
                }
            }
            if (this.ao.t() == false) {
            }
            return WorkItem.g(Boolean_$type, false);
        }
        let g = true;
        return WorkItemExtensions.g(Boolean_$type, Async.g(d == false, () => {
            this.v.h(new XmlReadManager_AlternateContentChoiceContext());
            let h = this.f(this.w.f);
            let i = this.v.e();
            if (i.a) {
                if (this.ao.t() == false) {
                }
                g = false;
            }
            return h;
        }), () => g);
    }
    h(a, b, c) {
        if (c != 1) {
            this.ao.a2();
            return WorkItem.g(Boolean_$type, false);
        }
        let d = this.ao.i;
        this.am(a, false);
        this.k = a;
        this.ab = b;
        return WorkItemExtensions.g(Boolean_$type, Async.g(d == false, () => this.f(this.w.f)), () => true);
    }
    get n() {
        return this.m;
    }
    get s() {
        return this.v.f != 0;
    }
    get af() {
        return this.ao.aj;
    }
}
XmlReadManager.$t = markType(XmlReadManager, 'XmlReadManager');
/**
 * @hidden
 */
export class XmlReadManager_AlternateContentChoiceContext extends Base {
    constructor() {
        super(...arguments);
        this.a = false;
    }
}
XmlReadManager_AlternateContentChoiceContext.$t = markType(XmlReadManager_AlternateContentChoiceContext, 'XmlReadManager_AlternateContentChoiceContext');
/**
 * @hidden
 */
export class XmlReadManager_ElementContext extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.e = 0;
        this.f = null;
        this.c = null;
        this.b = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.e = c.j.s.e;
                    this.f = c.j.s.f;
                    this.b = false;
                    this.c = null;
                }
                break;
        }
    }
    a(a) {
        return this.c != null && this.c.contains(a);
    }
    get d() {
        if (this.c == null) {
            this.c = new HashSet$1(String_$type, 0);
        }
        return this.c;
    }
}
XmlReadManager_ElementContext.$t = markStruct(XmlReadManager_ElementContext, 'XmlReadManager_ElementContext');
/**
 * @hidden
 */
export class XmlReadManager_LoadChildContext extends ValueType {
    constructor() {
        super();
        this.h = 0;
        this.c = 0;
        this.b = new QualifiedNameInfo();
        this.a = new ElementLoadCallbacks();
        this.g = false;
        this.f = false;
        this.e = false;
        this.d = false;
    }
}
XmlReadManager_LoadChildContext.$t = markStruct(XmlReadManager_LoadChildContext, 'XmlReadManager_LoadChildContext');
/**
 * @hidden
 */
export class XmlReadManager_LoadFastContext extends ValueType {
    constructor() {
        super();
        this.c = 0;
        this.b = new QualifiedNameInfo();
        this.a = new ElementLoadCallbacks();
    }
}
XmlReadManager_LoadFastContext.$t = markStruct(XmlReadManager_LoadFastContext, 'XmlReadManager_LoadFastContext');
/**
 * @hidden
 */
export class ST_DecimalNumber extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.e = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.e = c;
                }
                break;
        }
    }
    static d(a) {
        return ST_DecimalNumber.b(parseInt32_1(a, CultureInfo.invariantCulture));
    }
    static j(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7 | 4, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_DecimalNumber.$, ST_DecimalNumber.b(b));
        }
        return Nullable$1.toNullable(ST_DecimalNumber.$, null);
    }
    toString() {
        return this.e.toString();
    }
    static f(a) {
        return a.e;
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_DecimalNumber.f(a.value));
    }
    static b(a) {
        return new ST_DecimalNumber(1, a);
    }
    static i(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_DecimalNumber.$, null);
        }
        return Nullable$1.toNullable(ST_DecimalNumber.$, ST_DecimalNumber.b(a.value));
    }
}
ST_DecimalNumber.$t = markStruct(ST_DecimalNumber, 'ST_DecimalNumber');
ST_DecimalNumber.a = new ST_DecimalNumber(0);
/**
 * @hidden
 */
export class ST_DecimalNumberOrPercent extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = false;
        this.a = new ST_Percentage();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.b = d;
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, typeCast(ST_DecimalNumberOrPercent.$, a));
        if (ST_DecimalNumberOrPercent.f(b, Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null))) {
            return false;
        }
        return ST_DecimalNumberOrPercent.c(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.a.getHashCode();
    }
    toString() {
        return this.k(0);
    }
    k(a) {
        if (this.b) {
            return (ST_Percentage.l(this.a)).toString();
        }
        return this.a.r(a);
    }
    i(a) {
        a = this.b;
        return {
            ret: ST_Percentage.l(this.a),
            p0: a
        };
    }
    static j(a, b) {
        let c = ST_DecimalNumber.j(a);
        if (nullableNotEquals(c, null)) {
            return Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, new ST_DecimalNumberOrPercent(1, new ST_Percentage(1, ST_DecimalNumber.f(c.getValueOrDefault())), true));
        }
        let d = ST_Percentage.q(a, b);
        if (ST_Percentage.h(d, Nullable$1.toNullable(ST_Percentage.$, null))) {
            return Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, new ST_DecimalNumberOrPercent(1, d.getValueOrDefault(), false));
        }
        return Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null);
    }
    static c(a, b) {
        return ST_Percentage.e(a.a, b.a);
    }
    static d(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_DecimalNumberOrPercent.c(a.value, b.value);
    }
    static e(a, b) {
        return !(ST_DecimalNumberOrPercent.c(a, b));
    }
    static f(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_DecimalNumberOrPercent.e(a.value, b.value);
    }
}
ST_DecimalNumberOrPercent.$t = markStruct(ST_DecimalNumberOrPercent, 'ST_DecimalNumberOrPercent');
/**
 * @hidden
 */
export class ST_DrawingElementId extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.g = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.g = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_DrawingElementId.a(parseUInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static f(a) {
        let b;
        if (((() => { let c = tryParseUInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_DrawingElementId.$, ST_DrawingElementId.a(b));
        }
        return Nullable$1.toNullable(ST_DrawingElementId.$, null);
    }
    toString() {
        return this.g.toString();
    }
    static h(a) {
        return a.g;
    }
    static e(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_DrawingElementId.h(a.value));
    }
    static a(a) {
        return new ST_DrawingElementId(1, a);
    }
    static d(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_DrawingElementId.$, null);
        }
        return Nullable$1.toNullable(ST_DrawingElementId.$, ST_DrawingElementId.a(a.value));
    }
}
ST_DrawingElementId.$t = markStruct(ST_DrawingElementId, 'ST_DrawingElementId');
/**
 * @hidden
 */
export class ST_EighthPointMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = new ST_UnsignedDecimalNumber();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.d = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_EighthPointMeasure.$, typeCast(ST_EighthPointMeasure.$, a));
        if (ST_EighthPointMeasure.j(b, Nullable$1.toNullable(ST_EighthPointMeasure.$, null))) {
            return false;
        }
        return ST_EighthPointMeasure.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return Base.getHashCodeStatic(this.d);
    }
    toString() {
        return this.d.toString();
    }
    static c(a) {
        let b = ST_EighthPointMeasure.p(a);
        if (ST_EighthPointMeasure.j(b, Nullable$1.toNullable(ST_EighthPointMeasure.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_EighthPointMeasure.$, a);
    }
    static p(a) {
        let b = ST_UnsignedDecimalNumber.f(a);
        if (nullableNotEquals(b, null)) {
            return Nullable$1.toNullable(ST_EighthPointMeasure.$, ST_EighthPointMeasure.a(b.getValueOrDefault()));
        }
        return Nullable$1.toNullable(ST_EighthPointMeasure.$, null);
    }
    static g(a, b) {
        return ST_UnsignedDecimalNumber.h(a.d) == ST_UnsignedDecimalNumber.h(b.d);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_EighthPointMeasure.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_EighthPointMeasure.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_EighthPointMeasure.i(a.value, b.value);
    }
    static a(a) {
        return new ST_EighthPointMeasure(1, a);
    }
    static m(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_EighthPointMeasure.$, null);
        }
        return Nullable$1.toNullable(ST_EighthPointMeasure.$, ST_EighthPointMeasure.a(a.value));
    }
    static e(a) {
        return a.d;
    }
    static n(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
        }
        return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, ST_EighthPointMeasure.e(a.value));
    }
    static q(a) {
        return ST_UnsignedDecimalNumber.h(a.d);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_EighthPointMeasure.q(a.value));
    }
}
ST_EighthPointMeasure.$t = markStruct(ST_EighthPointMeasure, 'ST_EighthPointMeasure');
/**
 * @hidden
 */
export class ST_FixedAngle extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new ST_Angle();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_FixedAngle.$, c.n(), "value", -5400000, 5400000);
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_FixedAngle.$, typeCast(ST_FixedAngle.$, a));
        if (ST_FixedAngle.k(b, Nullable$1.toNullable(ST_FixedAngle.$, null))) {
            return false;
        }
        return ST_FixedAngle.h(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.a.getHashCode();
    }
    toString() {
        return this.a.toString();
    }
    static d(a) {
        return ST_FixedAngle.e(ST_Angle.a(a));
    }
    static g(a) {
        let b = ST_FixedAngle.r(a);
        if (ST_FixedAngle.k(b, Nullable$1.toNullable(ST_FixedAngle.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_FixedAngle.$, a);
    }
    s() {
        return this.a.n();
    }
    static r(a) {
        return ST_FixedAngle.q(ST_Angle.m(a));
    }
    static h(a, b) {
        return ST_Angle.c(a.a, b.a);
    }
    static i(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_FixedAngle.h(a.value, b.value);
    }
    static j(a, b) {
        return !(ST_FixedAngle.h(a, b));
    }
    static k(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_FixedAngle.j(a.value, b.value);
    }
    static e(a) {
        return new ST_FixedAngle(1, a);
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_FixedAngle.$, null);
        }
        return Nullable$1.toNullable(ST_FixedAngle.$, ST_FixedAngle.e(a.value));
    }
    static b(a) {
        return a.a;
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Angle.$, null);
        }
        return Nullable$1.toNullable(ST_Angle.$, ST_FixedAngle.b(a.value));
    }
}
ST_FixedAngle.$t = markStruct(ST_FixedAngle, 'ST_FixedAngle');
/**
 * @hidden
 */
export class ST_FixedPercentage extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = new ST_Percentage();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_FixedPercentage.$, ST_Percentage.l(c), "value", -100, 100);
                    this.d = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_FixedPercentage.$, typeCast(ST_FixedPercentage.$, a));
        if (ST_FixedPercentage.j(b, Nullable$1.toNullable(ST_FixedPercentage.$, null))) {
            return false;
        }
        return ST_FixedPercentage.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.d.getHashCode();
    }
    toString() {
        return this.s(1);
    }
    s(a) {
        return this.d.r(a);
    }
    static c(a, b) {
        let c = ST_FixedPercentage.r(a, b);
        if (ST_FixedPercentage.j(c, Nullable$1.toNullable(ST_FixedPercentage.$, null))) {
            return c.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_FixedPercentage.$, a);
    }
    static r(a, b) {
        return ST_FixedPercentage.p(ST_Percentage.q(a, b));
    }
    static g(a, b) {
        return ST_Percentage.e(a.d, b.d);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_FixedPercentage.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_FixedPercentage.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_FixedPercentage.i(a.value, b.value);
    }
    static a(a) {
        return new ST_FixedPercentage(1, a);
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_FixedPercentage.$, null);
        }
        return Nullable$1.toNullable(ST_FixedPercentage.$, ST_FixedPercentage.a(a.value));
    }
    static e(a) {
        return a.d;
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Percentage.$, null);
        }
        return Nullable$1.toNullable(ST_Percentage.$, ST_FixedPercentage.e(a.value));
    }
    static m(a) {
        return ST_Percentage.l(a.d);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_FixedPercentage.m(a.value));
    }
}
ST_FixedPercentage.$t = markStruct(ST_FixedPercentage, 'ST_FixedPercentage');
/**
 * @hidden
 */
export class ST_HexColorRGB extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.m = 0;
        this.l = 0;
        this.k = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = [c.o, c.n, c.m];
                    {
                        let f = d[0];
                        let g = d[1];
                        let h = d[2];
                        this.m = f;
                        this.l = g;
                        this.k = h;
                    }
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    this.m = c;
                    this.l = d;
                    this.k = e;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_HexColorRGB.$, typeCast(ST_HexColorRGB.$, a));
        if (ST_HexColorRGB.h(b, Nullable$1.toNullable(ST_HexColorRGB.$, null))) {
            return false;
        }
        return ST_HexColorRGB.e(this, b.getValueOrDefault());
    }
    getHashCode() {
        return (this.m << 16) | (this.l << 8) | this.k;
    }
    static d(a) {
        let b = ST_HexColorRGB.p(a);
        if (ST_HexColorRGB.h(b, Nullable$1.toNullable(ST_HexColorRGB.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_HexColorRGB.$, a);
    }
    static p(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 515, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })()) == false) {
            return Nullable$1.toNullable(ST_HexColorRGB.$, null);
        }
        let c = ((b & 16711680) >> 16);
        let d = ((b & 65280) >> 8);
        let e = ((b & 255) >> 0);
        return Nullable$1.toNullable(ST_HexColorRGB.$, new ST_HexColorRGB(2, c, d, e));
    }
    toString() {
        return intToString1(this.m, "X2", CultureInfo.invariantCulture) + intToString1(this.l, "X2", CultureInfo.invariantCulture) + intToString1(this.k, "X2", CultureInfo.invariantCulture);
    }
    get r() {
        return Color.u(255, this.m, this.l, this.k);
    }
    q() {
        return this.toString();
    }
    static e(a, b) {
        return a.k == b.k && a.l == b.l && a.m == b.m;
    }
    static f(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_HexColorRGB.e(a.value, b.value);
    }
    static g(a, b) {
        return !(ST_HexColorRGB.e(a, b));
    }
    static h(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_HexColorRGB.g(a.value, b.value);
    }
    static s(a) {
        return a.r;
    }
    static n(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Color.$, null);
        }
        return Nullable$1.toNullable(Color.$, ST_HexColorRGB.s(a.value));
    }
    static b(a) {
        return new ST_HexColorRGB(2, a.o, a.n, a.m);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HexColorRGB.$, null);
        }
        return Nullable$1.toNullable(ST_HexColorRGB.$, ST_HexColorRGB.b(a.value));
    }
}
ST_HexColorRGB.$t = markStruct(ST_HexColorRGB, 'ST_HexColorRGB');
ST_HexColorRGB.a = new ST_HexColorRGB(0);
/**
 * @hidden
 */
export class ST_HexColorAuto extends ValueType {
    constructor() {
        super();
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_HexColorAuto.$, typeCast(ST_HexColorAuto.$, a));
        if (ST_HexColorAuto.f(b, Nullable$1.toNullable(ST_HexColorAuto.$, null))) {
            return false;
        }
        return ST_HexColorAuto.c(this, b.getValueOrDefault());
    }
    getHashCode() {
        return 0;
    }
    static b(a) {
        let b = ST_HexColorAuto.i(a);
        if (ST_HexColorAuto.f(b, Nullable$1.toNullable(ST_HexColorAuto.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_HexColorAuto.$, a);
    }
    static i(a) {
        if (a == "auto") {
            return Nullable$1.toNullable(ST_HexColorAuto.$, ST_HexColorAuto.a);
        }
        return Nullable$1.toNullable(ST_HexColorAuto.$, null);
    }
    toString() {
        return "auto";
    }
    static c(a, b) {
        return true;
    }
    static d(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_HexColorAuto.c(a.value, b.value);
    }
    static e(a, b) {
        return false;
    }
    static f(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_HexColorAuto.e(a.value, b.value);
    }
}
ST_HexColorAuto.$t = markStruct(ST_HexColorAuto, 'ST_HexColorAuto');
ST_HexColorAuto.a = new ST_HexColorAuto();
/**
 * @hidden
 */
export class ST_HexColor extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.p = Nullable$1.toNullable(ST_HexColorRGB.$, null);
        this.q = Nullable$1.toNullable(ST_HexColorAuto.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.p = Nullable$1.toNullable(ST_HexColorRGB.$, c);
                    this.q = Nullable$1.toNullable(ST_HexColorAuto.$, null);
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.p = Nullable$1.toNullable(ST_HexColorRGB.$, null);
                    this.q = Nullable$1.toNullable(ST_HexColorAuto.$, c);
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_HexColor.$, typeCast(ST_HexColor.$, a));
        if (ST_HexColor.m(b, Nullable$1.toNullable(ST_HexColor.$, null))) {
            return false;
        }
        return ST_HexColor.j(this, b.getValueOrDefault());
    }
    getHashCode() {
        if (ST_HexColorRGB.h(this.p, Nullable$1.toNullable(ST_HexColorRGB.$, null))) {
            return this.p.value.getHashCode();
        }
        if (ST_HexColorAuto.f(this.q, Nullable$1.toNullable(ST_HexColorAuto.$, null))) {
            return this.q.value.getHashCode();
        }
        return 0;
    }
    static e(a) {
        let b = ST_HexColor.u(a);
        if (ST_HexColor.m(b, Nullable$1.toNullable(ST_HexColor.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_HexColor.$, a);
    }
    static u(a) {
        let b = ST_HexColorAuto.i(a);
        if (ST_HexColorAuto.f(b, Nullable$1.toNullable(ST_HexColorAuto.$, null))) {
            return Nullable$1.toNullable(ST_HexColor.$, ST_HexColor.a(b.getValueOrDefault()));
        }
        let c = ST_HexColorRGB.p(a);
        if (ST_HexColorRGB.h(c, Nullable$1.toNullable(ST_HexColorRGB.$, null))) {
            return Nullable$1.toNullable(ST_HexColor.$, ST_HexColor.b(c.getValueOrDefault()));
        }
        return Nullable$1.toNullable(ST_HexColor.$, null);
    }
    toString() {
        if (ST_HexColorRGB.h(this.p, Nullable$1.toNullable(ST_HexColorRGB.$, null))) {
            return this.p.getValueOrDefault().toString();
        }
        if (ST_HexColorAuto.f(this.q, Nullable$1.toNullable(ST_HexColorAuto.$, null))) {
            return this.q.getValueOrDefault().toString();
        }
        return stringEmpty();
    }
    get h() {
        return ST_HexColorAuto.f(this.q, Nullable$1.toNullable(ST_HexColorAuto.$, null));
    }
    get i() {
        return ST_HexColorRGB.h(this.p, Nullable$1.toNullable(ST_HexColorRGB.$, null));
    }
    static j(a, b) {
        return ST_HexColorRGB.f(a.p, b.p) && ST_HexColorAuto.d(a.q, b.q);
    }
    static k(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_HexColor.j(a.value, b.value);
    }
    static l(a, b) {
        return !(ST_HexColor.j(a, b));
    }
    static m(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_HexColor.l(a.value, b.value);
    }
    static b(a) {
        return new ST_HexColor(1, a);
    }
    static t(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HexColor.$, null);
        }
        return Nullable$1.toNullable(ST_HexColor.$, ST_HexColor.b(a.value));
    }
    static f(a) {
        return a.p.value;
    }
    static r(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HexColorRGB.$, null);
        }
        return Nullable$1.toNullable(ST_HexColorRGB.$, ST_HexColor.f(a.value));
    }
    static a(a) {
        return new ST_HexColor(2, a);
    }
    static s(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HexColor.$, null);
        }
        return Nullable$1.toNullable(ST_HexColor.$, ST_HexColor.a(a.value));
    }
}
ST_HexColor.$t = markStruct(ST_HexColor, 'ST_HexColor');
/**
 * @hidden
 */
export class ST_PositiveUniversalMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.b = 0;
        this.c = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.c = c;
                    this.b = d;
                }
                break;
        }
    }
    toString() {
        return ST_UniversalMeasure.p(this.c, this.b);
    }
    d() {
        return ST_UniversalMeasure.l(this.c, this.b);
    }
    static a(a) {
        let b = ST_PositiveUniversalMeasure.e(a);
        if (nullableNotEquals(b, null)) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_PositiveUniversalMeasure.$, a);
    }
    static e(a) {
        let b;
        let c;
        if (((() => { let d = ST_UniversalMeasure.i(a, b, c); b = d.p1; c = d.p2; return d.ret; })()) == false) {
            return Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
        }
        return Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, new ST_PositiveUniversalMeasure(1, b, c));
    }
}
ST_PositiveUniversalMeasure.$t = markStruct(ST_PositiveUniversalMeasure, 'ST_PositiveUniversalMeasure');
/**
 * @hidden
 */
export class ST_UnsignedDecimalNumber extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.g = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.g = c;
                }
                break;
        }
    }
    static f(a) {
        let b;
        if (((() => { let c = tryParseUInt64_2(a, 7 | 4, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, ST_UnsignedDecimalNumber.b(b));
        }
        return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
    }
    toString() {
        return this.g.toString();
    }
    static h(a) {
        return a.g;
    }
    static e(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_UnsignedDecimalNumber.h(a.value));
    }
    static b(a) {
        return new ST_UnsignedDecimalNumber(1, a);
    }
    static d(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
        }
        return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, ST_UnsignedDecimalNumber.b(a.value));
    }
}
ST_UnsignedDecimalNumber.$t = markStruct(ST_UnsignedDecimalNumber, 'ST_UnsignedDecimalNumber');
ST_UnsignedDecimalNumber.a = new ST_UnsignedDecimalNumber(0);
/**
 * @hidden
 */
export class ST_HpsMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.g = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
        this.h = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = [new ST_PositiveUniversalMeasure(1, c, 3)];
                    {
                        let f = d[0];
                        this.g = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, f);
                        this.h = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
                    }
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.g = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, c);
                    this.h = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
                }
                break;
            case 3:
                {
                    let c = _rest[0];
                    this.g = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
                    this.h = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, c);
                }
                break;
        }
    }
    toString() {
        if (nullableNotEquals(this.g, null)) {
            return this.g.getValueOrDefault().toString();
        }
        if (nullableNotEquals(this.h, null)) {
            return this.h.getValueOrDefault().toString();
        }
        return stringEmpty();
    }
    f() {
        if (nullableNotEquals(this.g, null)) {
            return this.g.getValueOrDefault().d();
        }
        if (nullableNotEquals(this.h, null)) {
            return (ST_UnsignedDecimalNumber.h(this.h.getValueOrDefault()) * 10);
        }
        return 0;
    }
    static e(a) {
        let b = ST_HpsMeasure.k(a);
        if (nullableNotEquals(b, null)) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_HpsMeasure.$, a);
    }
    static k(a) {
        let b = ST_PositiveUniversalMeasure.e(a);
        if (nullableNotEquals(b, null)) {
            return Nullable$1.toNullable(ST_HpsMeasure.$, ST_HpsMeasure.a(b.getValueOrDefault()));
        }
        let c = ST_UnsignedDecimalNumber.f(a);
        if (nullableNotEquals(c, null)) {
            return Nullable$1.toNullable(ST_HpsMeasure.$, ST_HpsMeasure.b(c.getValueOrDefault()));
        }
        return Nullable$1.toNullable(ST_HpsMeasure.$, null);
    }
    static a(a) {
        return new ST_HpsMeasure(2, a);
    }
    static i(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HpsMeasure.$, null);
        }
        return Nullable$1.toNullable(ST_HpsMeasure.$, ST_HpsMeasure.a(a.value));
    }
    static b(a) {
        return new ST_HpsMeasure(3, a);
    }
    static j(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_HpsMeasure.$, null);
        }
        return Nullable$1.toNullable(ST_HpsMeasure.$, ST_HpsMeasure.b(a.value));
    }
}
ST_HpsMeasure.$t = markStruct(ST_HpsMeasure, 'ST_HpsMeasure');
/**
 * @hidden
 */
export class ST_LongHexNumber extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.e = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.e = c;
                }
                break;
        }
    }
    static d(a) {
        return ST_LongHexNumber.b(parseInt32_2(a, 515, CultureInfo.invariantCulture));
    }
    toString() {
        return intToString1(this.e, "X8", CultureInfo.invariantCulture);
    }
    static b(a) {
        return new ST_LongHexNumber(1, a);
    }
    static f(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_LongHexNumber.$, null);
        }
        return Nullable$1.toNullable(ST_LongHexNumber.$, ST_LongHexNumber.b(a.value));
    }
}
ST_LongHexNumber.$t = markStruct(ST_LongHexNumber, 'ST_LongHexNumber');
ST_LongHexNumber.a = new ST_LongHexNumber(0);
/**
 * @hidden
 */
export class ST_MeasurementOrPercent extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.m = Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null);
        this.n = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.m = Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, c);
                    this.n = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.m = Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null);
                    this.n = Nullable$1.toNullable(ST_UniversalMeasure.$, c);
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_MeasurementOrPercent.$, typeCast(ST_MeasurementOrPercent.$, a));
        if (ST_MeasurementOrPercent.j(b, Nullable$1.toNullable(ST_MeasurementOrPercent.$, null))) {
            return false;
        }
        return ST_MeasurementOrPercent.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        if (ST_DecimalNumberOrPercent.f(this.m, Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null))) {
            return this.m.getValueOrDefault().getHashCode();
        }
        if (ST_UniversalMeasure.f(this.n, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.n.getValueOrDefault().getHashCode() << 1;
        }
        return 0;
    }
    toString() {
        return this.r(1);
    }
    r(a) {
        if (ST_DecimalNumberOrPercent.f(this.m, Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null))) {
            return this.m.getValueOrDefault().k(a);
        }
        if (ST_UniversalMeasure.f(this.n, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.n.getValueOrDefault().toString();
        }
        return stringEmpty();
    }
    o(a) {
        if (ST_DecimalNumberOrPercent.f(this.m, Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null))) {
            return {
                ret: Nullable$1.toNullable(Number_$type, ((() => { let b = this.m.getValueOrDefault().i(a); a = b.p0; return b.ret; })())),
                p0: a
            };
        }
        a = true;
        if (ST_UniversalMeasure.f(this.n, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return {
                ret: this.n.getValueOrDefault().n(),
                p0: a
            };
        }
        return {
            ret: Nullable$1.toNullable(Number_$type, null),
            p0: a
        };
    }
    static e(a, b) {
        let c = ST_DecimalNumberOrPercent.j(a, b);
        if (ST_DecimalNumberOrPercent.f(c, Nullable$1.toNullable(ST_DecimalNumberOrPercent.$, null))) {
            return ST_MeasurementOrPercent.a(c.getValueOrDefault());
        }
        let d = ST_UniversalMeasure.o(a);
        if (ST_UniversalMeasure.f(d, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return ST_MeasurementOrPercent.b(d.getValueOrDefault());
        }
        throw DocCoreUtils.n(ST_MeasurementOrPercent.$, a);
    }
    get f() {
        return ST_UniversalMeasure.f(this.n, Nullable$1.toNullable(ST_UniversalMeasure.$, null));
    }
    static g(a, b) {
        if (ST_DecimalNumberOrPercent.f(a.m, b.m)) {
            return false;
        }
        if (!a.n.hasValue) {
            return !b.n.hasValue;
        }
        if (!b.n.hasValue) {
            return false;
        }
        return ST_UniversalMeasure.b(a.n.value, b.n.value);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_MeasurementOrPercent.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_MeasurementOrPercent.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_MeasurementOrPercent.i(a.value, b.value);
    }
    static a(a) {
        return new ST_MeasurementOrPercent(1, a);
    }
    static p(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_MeasurementOrPercent.$, null);
        }
        return Nullable$1.toNullable(ST_MeasurementOrPercent.$, ST_MeasurementOrPercent.a(a.value));
    }
    static b(a) {
        return new ST_MeasurementOrPercent(2, a);
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_MeasurementOrPercent.$, null);
        }
        return Nullable$1.toNullable(ST_MeasurementOrPercent.$, ST_MeasurementOrPercent.b(a.value));
    }
}
ST_MeasurementOrPercent.$t = markStruct(ST_MeasurementOrPercent, 'ST_MeasurementOrPercent');
/**
 * @hidden
 */
export class ST_OnOff extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.d = c;
                }
                break;
        }
    }
    static e(a) {
        switch (a) {
            case "1": return true;
            case "0": return false;
        }
        return parseBool(a);
    }
    toString() {
        return this.d ? "1" : "0";
    }
    static g(a) {
        return a ? "1" : "0";
    }
    static b(a) {
        return a ? ST_OnOff.c : ST_OnOff.a;
    }
    f() {
        return this.d;
    }
}
ST_OnOff.$t = markStruct(ST_OnOff, 'ST_OnOff');
ST_OnOff.a = new ST_OnOff(1, false);
ST_OnOff.c = new ST_OnOff(1, true);
/**
 * @hidden
 */
export class ST_Panose extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.a = a;
    }
    toString() {
        return stringConcat(...Enumerable.a(String_$type, Enumerable.o(Number_$type, String_$type, this.a, (a) => intToString1(a, "X2", CultureInfo.invariantCulture))));
    }
    static b(a) {
        let b = new Array(intDivide(a.length, 2));
        for (let c = 0; c < b.length; c++) {
            let d = a.charAt(c * 2);
            let e = a.charAt(c * 2 + 1);
            b[c] = (DocCoreUtils.r(d) << 4 | DocCoreUtils.r(e));
        }
        return new ST_Panose(b);
    }
}
ST_Panose.$t = markType(ST_Panose, 'ST_Panose');
/**
 * @hidden
 */
export class ST_PointMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = new ST_UnsignedDecimalNumber();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.d = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_PointMeasure.$, typeCast(ST_PointMeasure.$, a));
        if (ST_PointMeasure.j(b, Nullable$1.toNullable(ST_PointMeasure.$, null))) {
            return false;
        }
        return ST_PointMeasure.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return Base.getHashCodeStatic(this.d);
    }
    toString() {
        return this.d.toString();
    }
    static c(a) {
        let b = ST_PointMeasure.p(a);
        if (ST_PointMeasure.j(b, Nullable$1.toNullable(ST_PointMeasure.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_PointMeasure.$, a);
    }
    static p(a) {
        let b = ST_UnsignedDecimalNumber.f(a);
        if (nullableNotEquals(b, null)) {
            return Nullable$1.toNullable(ST_PointMeasure.$, ST_PointMeasure.a(b.getValueOrDefault()));
        }
        return Nullable$1.toNullable(ST_PointMeasure.$, null);
    }
    static g(a, b) {
        return ST_UnsignedDecimalNumber.h(a.d) == ST_UnsignedDecimalNumber.h(b.d);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_PointMeasure.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_PointMeasure.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_PointMeasure.i(a.value, b.value);
    }
    static a(a) {
        return new ST_PointMeasure(1, a);
    }
    static m(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_PointMeasure.$, null);
        }
        return Nullable$1.toNullable(ST_PointMeasure.$, ST_PointMeasure.a(a.value));
    }
    static e(a) {
        return a.d;
    }
    static n(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
        }
        return Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, ST_PointMeasure.e(a.value));
    }
    static q(a) {
        return ST_UnsignedDecimalNumber.h(a.d);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_PointMeasure.q(a.value));
    }
}
ST_PointMeasure.$t = markStruct(ST_PointMeasure, 'ST_PointMeasure');
/**
 * @hidden
 */
export class ST_PositiveFixedAngle extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new ST_Angle();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_PositiveFixedAngle.$, c.n(), "value", 0, 21600000);
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_PositiveFixedAngle.$, typeCast(ST_PositiveFixedAngle.$, a));
        if (ST_PositiveFixedAngle.k(b, Nullable$1.toNullable(ST_PositiveFixedAngle.$, null))) {
            return false;
        }
        return ST_PositiveFixedAngle.h(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.a.getHashCode();
    }
    toString() {
        return this.a.toString();
    }
    static d(a) {
        return ST_PositiveFixedAngle.e(ST_Angle.a(a));
    }
    q() {
        return this.a.n();
    }
    static g(a) {
        let b = ST_PositiveFixedAngle.p(a);
        if (ST_PositiveFixedAngle.k(b, Nullable$1.toNullable(ST_PositiveFixedAngle.$, null))) {
            return b.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_PositiveFixedAngle.$, a);
    }
    static p(a) {
        return ST_PositiveFixedAngle.o(ST_Angle.m(a));
    }
    static h(a, b) {
        return ST_Angle.c(a.a, b.a);
    }
    static i(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_PositiveFixedAngle.h(a.value, b.value);
    }
    static j(a, b) {
        return !(ST_PositiveFixedAngle.h(a, b));
    }
    static k(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_PositiveFixedAngle.j(a.value, b.value);
    }
    static e(a) {
        return new ST_PositiveFixedAngle(1, a);
    }
    static o(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_PositiveFixedAngle.$, null);
        }
        return Nullable$1.toNullable(ST_PositiveFixedAngle.$, ST_PositiveFixedAngle.e(a.value));
    }
    static b(a) {
        return a.a;
    }
    static n(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Angle.$, null);
        }
        return Nullable$1.toNullable(ST_Angle.$, ST_PositiveFixedAngle.b(a.value));
    }
}
ST_PositiveFixedAngle.$t = markStruct(ST_PositiveFixedAngle, 'ST_PositiveFixedAngle');
/**
 * @hidden
 */
export class ST_PositiveFixedPercentage extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.a = new ST_Percentage();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_PositiveFixedPercentage.$, ST_Percentage.l(c), "value", 0, 100);
                    this.a = c;
                }
                break;
        }
    }
    equals(a) {
        let b = Nullable$1.toNullable(ST_PositiveFixedPercentage.$, typeCast(ST_PositiveFixedPercentage.$, a));
        if (ST_PositiveFixedPercentage.j(b, Nullable$1.toNullable(ST_PositiveFixedPercentage.$, null))) {
            return false;
        }
        return ST_PositiveFixedPercentage.g(this, b.getValueOrDefault());
    }
    getHashCode() {
        return this.a.getHashCode();
    }
    toString() {
        return this.u(1);
    }
    u(a) {
        return this.a.r(a);
    }
    static f(a, b) {
        let c = ST_PositiveFixedPercentage.t(a, b);
        if (ST_PositiveFixedPercentage.j(c, Nullable$1.toNullable(ST_PositiveFixedPercentage.$, null))) {
            return c.getValueOrDefault();
        }
        throw DocCoreUtils.n(ST_PositiveFixedPercentage.$, a);
    }
    static t(a, b) {
        return ST_PositiveFixedPercentage.s(ST_Percentage.q(a, b));
    }
    static o(a) {
        if (a < 0 || a > 1) {
            throw new ArgumentOutOfRangeException(1, "value");
        }
        return (a * 100);
    }
    static p(a) {
        return truncate((a * 1000));
    }
    static g(a, b) {
        return ST_Percentage.e(a.a, b.a);
    }
    static h(a, b) {
        if (!a.hasValue) {
            return !b.hasValue;
        }
        else if (!b.hasValue) {
            return false;
        }
        return ST_PositiveFixedPercentage.g(a.value, b.value);
    }
    static i(a, b) {
        return !(ST_PositiveFixedPercentage.g(a, b));
    }
    static j(a, b) {
        if (!a.hasValue) {
            return b.hasValue;
        }
        else if (!b.hasValue) {
            return true;
        }
        return ST_PositiveFixedPercentage.i(a.value, b.value);
    }
    static d(a) {
        return new ST_PositiveFixedPercentage(1, a);
    }
    static s(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_PositiveFixedPercentage.$, null);
        }
        return Nullable$1.toNullable(ST_PositiveFixedPercentage.$, ST_PositiveFixedPercentage.d(a.value));
    }
    static b(a) {
        return a.a;
    }
    static r(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Percentage.$, null);
        }
        return Nullable$1.toNullable(ST_Percentage.$, ST_PositiveFixedPercentage.b(a.value));
    }
    static m(a) {
        return ST_Percentage.l(a.a);
    }
    static q(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_PositiveFixedPercentage.m(a.value));
    }
}
ST_PositiveFixedPercentage.$t = markStruct(ST_PositiveFixedPercentage, 'ST_PositiveFixedPercentage');
/**
 * @hidden
 */
export class ST_SignedHpsMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.c = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(Number_$type, truncate((c * 2)));
                    this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(Number_$type, null);
                    this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, c);
                }
                break;
        }
    }
    toString() {
        if (nullableNotEquals(this.c, null)) {
            return this.c.value.toString();
        }
        if (ST_UniversalMeasure.f(this.d, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.d.toString();
        }
        return stringEmpty();
    }
    b() {
        if (nullableNotEquals(this.c, null)) {
            return this.c.value * 10;
        }
        if (ST_UniversalMeasure.f(this.d, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.d.value.k();
        }
        return 0;
    }
    static a(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return new ST_SignedHpsMeasure(1, intDivide(b, 2));
        }
        let c = ST_UniversalMeasure.o(a);
        if (ST_UniversalMeasure.f(c, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return new ST_SignedHpsMeasure(2, c.value);
        }
        throw DocCoreUtils.n(ST_SignedHpsMeasure.$, a);
    }
}
ST_SignedHpsMeasure.$t = markStruct(ST_SignedHpsMeasure, 'ST_SignedHpsMeasure');
/**
 * @hidden
 */
export class ST_SignedTwipsMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.c = Nullable$1.toNullable(Number_$type, null);
        this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = [truncate(c)];
                    {
                        let f = d[0];
                        this.c = Nullable$1.toNullable(Number_$type, f);
                        this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                    }
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(Number_$type, c);
                    this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, null);
                }
                break;
            case 3:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(Number_$type, null);
                    this.d = Nullable$1.toNullable(ST_UniversalMeasure.$, c);
                }
                break;
        }
    }
    toString() {
        if (nullableNotEquals(this.c, null)) {
            return this.c.value.toString();
        }
        if (ST_UniversalMeasure.f(this.d, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.d.toString();
        }
        return stringEmpty();
    }
    b() {
        if (nullableNotEquals(this.c, null)) {
            return this.c.value;
        }
        if (ST_UniversalMeasure.f(this.d, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return this.d.value.k();
        }
        return 0;
    }
    static a(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return new ST_SignedTwipsMeasure(2, b);
        }
        let c = ST_UniversalMeasure.o(a);
        if (ST_UniversalMeasure.f(c, Nullable$1.toNullable(ST_UniversalMeasure.$, null))) {
            return new ST_SignedTwipsMeasure(3, c.value);
        }
        throw DocCoreUtils.n(ST_SignedTwipsMeasure.$, a);
    }
}
ST_SignedTwipsMeasure.$t = markStruct(ST_SignedTwipsMeasure, 'ST_SignedTwipsMeasure');
/**
 * @hidden
 */
export class ST_TextFontSize extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    DocCoreUtils.av(ST_TextFontSize.$, c, "value", 100, 400000);
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_TextFontSize.a(parseInt32_2(a, 7, CultureInfo.invariantCulture));
    }
    static i(a) {
        let b;
        if (((() => { let c = tryParseInt32_2(a, 7, CultureInfo.invariantCulture, b); b = c.p3; return c.ret; })())) {
            return Nullable$1.toNullable(ST_TextFontSize.$, ST_TextFontSize.a(b));
        }
        return Nullable$1.toNullable(ST_TextFontSize.$, null);
    }
    toString() {
        return this.d.toString();
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_TextFontSize.e(a.value));
    }
    static a(a) {
        return new ST_TextFontSize(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TextFontSize.$, null);
        }
        return Nullable$1.toNullable(ST_TextFontSize.$, ST_TextFontSize.a(a.value));
    }
}
ST_TextFontSize.$t = markStruct(ST_TextFontSize, 'ST_TextFontSize');
/**
 * @hidden
 */
export class ST_TrueFalse extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.f = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.f = c;
                }
                break;
        }
    }
    static d(a) {
        switch (a) {
            case "t": return ST_TrueFalse.b(true);
            case "f": return ST_TrueFalse.b(false);
        }
        return ST_TrueFalse.b(parseBool(a));
    }
    toString() {
        return this.f ? "t" : "f";
    }
    static k(a) {
        return a.toString();
    }
    static g(a) {
        return a.f;
    }
    static i(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Boolean_$type, null);
        }
        return Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(a.value));
    }
    static b(a) {
        return new ST_TrueFalse(1, a);
    }
    static j(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_TrueFalse.$, null);
        }
        return Nullable$1.toNullable(ST_TrueFalse.$, ST_TrueFalse.b(a.value));
    }
}
ST_TrueFalse.$t = markStruct(ST_TrueFalse, 'ST_TrueFalse');
ST_TrueFalse.a = new ST_TrueFalse(1, false);
ST_TrueFalse.e = new ST_TrueFalse(1, true);
/**
 * @hidden
 */
export class ST_TrueFalseBlank extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.c = false;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.c = c;
                }
                break;
        }
    }
    static d(a) {
        if (stringIsNullOrEmpty(a)) {
            return true;
        }
        switch (a) {
            case "t":
            case "True": return true;
            case "f":
            case "False": return false;
        }
        throw DocCoreUtils.n(ST_TrueFalseBlank.$, a);
    }
    toString() {
        if (this.c) {
            return stringEmpty();
        }
        return "False";
    }
    static e(a) {
        return a.toString();
    }
    static f(a) {
        return (a ? ST_TrueFalseBlank.b : ST_TrueFalseBlank.a).toString();
    }
}
ST_TrueFalseBlank.$t = markStruct(ST_TrueFalseBlank, 'ST_TrueFalseBlank');
ST_TrueFalseBlank.a = new ST_TrueFalseBlank(1, false);
ST_TrueFalseBlank.b = new ST_TrueFalseBlank(1, true);
/**
 * @hidden
 */
export class ST_TwipsMeasure extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.c = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
        this.d = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    let d = [ST_UnsignedDecimalNumber.b(truncate(DocCoreUtils.j(c)))];
                    {
                        let f = d[0];
                        this.c = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, f);
                        this.d = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
                    }
                }
                break;
            case 2:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, c);
                    this.d = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, null);
                }
                break;
            case 3:
                {
                    let c = _rest[0];
                    this.c = Nullable$1.toNullable(ST_UnsignedDecimalNumber.$, null);
                    this.d = Nullable$1.toNullable(ST_PositiveUniversalMeasure.$, c);
                }
                break;
        }
    }
    toString() {
        if (nullableNotEquals(this.c, null)) {
            return this.c.value.toString();
        }
        if (nullableNotEquals(this.d, null)) {
            return this.d.value.toString();
        }
        return stringEmpty();
    }
    b() {
        if (nullableNotEquals(this.c, null)) {
            return ST_UnsignedDecimalNumber.h(this.c.value);
        }
        if (nullableNotEquals(this.d, null)) {
            return this.d.value.d();
        }
        return 0;
    }
    static a(a) {
        let b = ST_UnsignedDecimalNumber.f(a);
        if (nullableNotEquals(b, null)) {
            return new ST_TwipsMeasure(2, b.value);
        }
        let c = ST_PositiveUniversalMeasure.e(a);
        if (nullableNotEquals(c, null)) {
            return new ST_TwipsMeasure(3, c.value);
        }
        throw DocCoreUtils.n(ST_TwipsMeasure.$, a);
    }
}
ST_TwipsMeasure.$t = markStruct(ST_TwipsMeasure, 'ST_TwipsMeasure');
/**
 * @hidden
 */
export class ST_UcharHexNumber extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.e = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.e = c;
                }
                break;
        }
    }
    static d(a) {
        return ST_UcharHexNumber.b(parseUInt8_2(a, 515, CultureInfo.invariantCulture));
    }
    toString() {
        return intToString1(this.e, "X2", CultureInfo.invariantCulture);
    }
    static b(a) {
        return new ST_UcharHexNumber(1, a);
    }
    static i(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_UcharHexNumber.$, null);
        }
        return Nullable$1.toNullable(ST_UcharHexNumber.$, ST_UcharHexNumber.b(a.value));
    }
    static f(a) {
        return a.e;
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_UcharHexNumber.f(a.value));
    }
}
ST_UcharHexNumber.$t = markStruct(ST_UcharHexNumber, 'ST_UcharHexNumber');
ST_UcharHexNumber.a = new ST_UcharHexNumber(0);
/**
 * @hidden
 */
export class ST_UnsignedIntHex extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.g = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.g = c;
                }
                break;
        }
    }
    static d(a) {
        return ST_UnsignedIntHex.b(parseUInt32_2(a, 515, CultureInfo.invariantCulture));
    }
    toString() {
        return intToString1(this.g, "X8", CultureInfo.invariantCulture);
    }
    static b(a) {
        return new ST_UnsignedIntHex(1, a);
    }
    static e(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        }
        return Nullable$1.toNullable(ST_UnsignedIntHex.$, ST_UnsignedIntHex.b(a.value));
    }
    static h(a) {
        return a.g;
    }
    static f(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Number_$type, null);
        }
        return Nullable$1.toNullable(Number_$type, ST_UnsignedIntHex.h(a.value));
    }
}
ST_UnsignedIntHex.$t = markStruct(ST_UnsignedIntHex, 'ST_UnsignedIntHex');
ST_UnsignedIntHex.a = new ST_UnsignedIntHex(0);
/**
 * @hidden
 */
export class ST_UnsignedShortHex extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.c = 0;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.c = c;
                }
                break;
        }
    }
    static d(a) {
        return parseUInt16_2(a, 515, CultureInfo.invariantCulture);
    }
    static b(a) {
        return new ST_UnsignedShortHex(1, ST_UnsignedShortHex.d(a));
    }
    toString() {
        return intToString1(this.c, "X4", CultureInfo.invariantCulture);
    }
    e() {
        return this.c;
    }
}
ST_UnsignedShortHex.$t = markStruct(ST_UnsignedShortHex, 'ST_UnsignedShortHex');
ST_UnsignedShortHex.a = new ST_UnsignedShortHex(0);
/**
 * @hidden
 */
export class XmlWriteManager extends Base {
    constructor(a, b) {
        super();
        this.a = null;
        this.c = null;
        this.b = null;
        this.w = null;
        this.c = new List$1(String_$type, 0);
        this.a = a.d;
        this.b = a;
        this.w = b;
    }
    d(a) {
        return this.w.a(a.i(this.a._z));
    }
    e(a, b, c, d) {
        let e = a.lastIndexOf("/");
        if (e < 0) {
            c = a;
            d = "";
            b = stringEmpty();
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        c = a.substr(e + 1);
        d = a.substr(0, e);
        if (this.a._z != 1) {
            let f = this.a._u(d);
            if (f != null) {
                d = f.i(this.a._z);
            }
        }
        b = this.w.a(d);
        if (stringIsNullOrEmpty(b)) {
            let g = d + "/";
            b = this.w.a(g);
            if (stringIsNullOrEmpty(b) == false) {
                d = g;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    f() {
        if (this.c.count == 0) {
            return;
        }
        this.l(MarkupCompatibility2006.an);
        this.h(MarkupCompatibility2006.as, stringJoin1(String_$type, " ", this.c));
        this.c.clear();
    }
    g(a, b = null, c = true) {
        if (a != null) {
            let d = new HashSet$1(XmlNamespaceDefinitionBase.$, 0);
            for (let e of fromEnum(a)) {
                for (let f of fromEnum(Enumerable.u(XmlNamespaceDefinitionBase.$, e.b, (g) => this.d(g) == null))) {
                    d.add_1(f);
                }
            }
            MarkupCompatibility2006.ay(this.b);
            for (let g of fromEnum(d)) {
                this.l(g);
            }
            for (let h of fromEnum(a)) {
                MarkupCompatibility2006.az(this.b, h.b);
                h.a();
                this.k();
            }
        }
        if (b != null) {
            MarkupCompatibility2006.a1(this.b);
            b();
            this.k();
        }
        if (c) {
            this.k();
        }
    }
    h(a, b) {
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = this.e(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        this.i(c, d, e, b);
    }
    i(a, b, c, d) {
        this.w.j(a, b, c, d);
    }
    j(a, b) {
        this.w.h(a, b);
    }
    k() {
        this.f();
        this.w.v();
    }
    o(a) {
        this.p(a, null);
    }
    p(a, b) {
        let c;
        let d;
        let e;
        let f = this.e(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        this.q(c != null ? c : b, d, e);
    }
    q(a, b, c) {
        this.f();
        this.w.ao(a, b, c);
    }
    r(a) {
        this.w.am(a);
    }
    l(a, b = false) {
        this.m(a.j, a.i(this.a._z), b);
    }
    m(a, b, c = false) {
        let d = b;
        if (this.a._z != 1) {
            let e = this.a._u(b);
            if (e != null) {
                d = e.i(this.a._z);
            }
        }
        this.w.j("xmlns", a, "http://www.w3.org/2000/xmlns/", d);
        if (c) {
            this.c.add(a);
        }
    }
    n(a) {
        this.f();
        this.w.ah(a);
    }
    t(a) {
        this.f();
        let b = new Stack$1(UnknownElementCache.$);
        this.s(a.b, b);
    }
    s(a, b) {
        let c = this.b.y(a, b);
        let t1 = c;
        L0: while (true) {
            switch (t1) {
                case 0:
                    {
                        let d = a.b.b(this.a);
                        this.q(d.h, d.f, d.g);
                        if (a.d) {
                            for (let e of fromEnum(a.j)) {
                                let f = e.a.b(this.a);
                                this.i(f.h, f.f, f.g, e.d);
                            }
                        }
                        if (a.p != null) {
                            this.u(a.p);
                        }
                    }
                    t1 = 1;
                    continue L0;
                case 1:
                    {
                        if (a.e) {
                            b.h(a);
                            for (let g of fromEnum(a.k)) {
                                this.s(g, b);
                            }
                            b.e();
                        }
                        this.k();
                    }
                    break;
                case 2: break;
                default:
                    t1 = 0;
                    continue L0;
            }
            break;
        }
    }
    u(a) {
        this.f();
        this.w.ap(a);
    }
    v(a, b, c) {
        this.f();
        let d = new StringBuilder(2, "version=\"" + a + "\"");
        if (b.length > 0) {
            d.l(" encoding=\"");
            d.l(b);
            d.l("\"");
        }
        if (c.length > 0) {
            d.l(" standalone=\"");
            d.l(c);
            d.l("\"");
        }
        let e = d.toString();
        this.w.ad("xml", e);
    }
}
XmlWriteManager.$t = markType(XmlWriteManager, 'XmlWriteManager');
/**
 * @hidden
 */
export class PartManagerBase extends Base {
    constructor() {
        super();
        this.c = null;
        this.k = null;
    }
    e(a, b) {
        let c = this.memberwiseClone();
        c.k = b;
        c.c = a;
        c.p();
        return c;
    }
    j() {
        return null;
    }
    f(a, b) {
        return null;
    }
    p() {
    }
    q() {
    }
    i(a) {
        return false;
    }
    get d() {
        return this.c;
    }
    get_h() {
        return true;
    }
    get h() {
        return this.get_h();
    }
    get l() {
        return this.k;
    }
    set l(a) {
        this.k = a;
    }
}
PartManagerBase.$t = markType(PartManagerBase, 'PartManagerBase');
/**
 * @hidden
 */
export class ActiveXBinaryPartManager extends PartManagerBase {
    get_m() {
        return "application/vnd.ms-office.activeX";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/activeX.bin";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ActiveXBinaryPartManager.u;
            case 1: return ActiveXBinaryPartManager.t;
            default: return ActiveXBinaryPartManager.u;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ActiveXBinaryPartManager.$t = markType(ActiveXBinaryPartManager, 'ActiveXBinaryPartManager', PartManagerBase.$);
ActiveXBinaryPartManager.u = "http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary";
ActiveXBinaryPartManager.t = "http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary";
/**
 * @hidden
 */
export class ActiveXPartManager extends PartManagerBase {
    get_m() {
        return "application/vnd.ms-office.activeX+xml";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/activeX.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ActiveXPartManager.u;
            case 1: return ActiveXPartManager.t;
            default: return ActiveXPartManager.u;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ActiveXPartManager.$t = markType(ActiveXPartManager, 'ActiveXPartManager', PartManagerBase.$);
ActiveXPartManager.u = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/control";
ActiveXPartManager.t = "http://purl.oclc.org/ooxml/officeDocument/relationships/control";
/**
 * @hidden
 */
export class ImagePartManagerBase extends PartManagerBase {
    n(a) {
        switch (a) {
            case 0: return this.s;
            case 1: return this.u;
            case 2: return this.t;
            default: return null;
        }
    }
    o(a) {
        return ImagePartManagerBase.v(a);
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
    a() {
        return WorkItem.g(Base.$, new ImageData(1, this.r(this.d._d.uri.toString()), this.l));
    }
    get_h() {
        return false;
    }
    b(a) {
        let b = typeCast(ImageData.$, a);
        if (b != null) {
            b.f(this.l);
        }
        return null;
    }
    static v(a) {
        switch (a) {
            case 0: return ImagePartManagerBase.x;
            case 1: return ImagePartManagerBase.w;
            default: return ImagePartManagerBase.x;
        }
    }
}
ImagePartManagerBase.$t = markType(ImagePartManagerBase, 'ImagePartManagerBase', PartManagerBase.$);
ImagePartManagerBase.x = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
ImagePartManagerBase.w = "http://purl.oclc.org/ooxml/officeDocument/relationships/image";
/**
 * @hidden
 */
export class BmpPartManager extends ImagePartManagerBase {
    constructor(a) {
        super();
        this.aa = false;
        this.aa = a;
    }
    get_s() {
        return this.aa ? "/xl/media/image.dib" : "/xl/media/image.bmp";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return this.aa ? "/ppt/media/image.dib" : "/ppt/media/image.bmp";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return this.aa ? "/word/media/image.dib" : "/word/media/image.bmp";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/bmp";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        let b = IOPath.getExtension(a);
        if (b.toLowerCase() == ".dib") {
            return ImageFormat.b;
        }
        return ImageFormat.a;
    }
}
BmpPartManager.$t = markType(BmpPartManager, 'BmpPartManager', ImagePartManagerBase.$);
BmpPartManager.y = new BmpPartManager(false);
BmpPartManager.z = new BmpPartManager(true);
/**
 * @hidden
 */
export class XmlPartManagerBase extends PartManagerBase {
    constructor() {
        super();
        this.r = null;
        this.am = null;
        this.al = 0;
        this.aa = null;
        this.ac = null;
        this.v = new ElementLoadCallbacks(0);
        this.an = null;
        this.ae = false;
        this.am = {};
    }
    p() {
        super.p();
        let a = this.am;
        this.am = {};
        for (var p in a) {
            if (a.hasOwnProperty(p)) {
                this.am[p] = a[p];
            }
        }
        ;
    }
    a() {
        return Async.i(Base.$, () => {
            this.r = new ContextStack();
            return this.t();
        }, () => {
            this.r = null;
            this.aa = null;
        });
    }
    b(a) {
        this.r = new ContextStack();
        if (a != null) {
            this.r.k(a);
        }
        return Async.n(XmlWriter.$, this.a1(), (b) => {
            this.ac = new XmlWriteManager(this, b);
            if (this.aj) {
                this.ac.v("1.0", "UTF-8", "yes");
            }
            return this.u(a);
        });
    }
    as() {
        this.al++;
    }
    at() {
        this.al--;
        if (this.al == 0) {
            this.ae = false;
        }
    }
    ar(a) {
    }
    w(a) {
        return this.x(a.e(this.d));
    }
    x(a) {
        return (this.am[a] || this.v);
    }
    z(a) {
        this.d._bj();
        return 0;
    }
    au(a) {
    }
    av(a) {
    }
    aw(a, b) {
    }
    ax(a, b, c = true) {
        switch (a) {
            case MarkupCompatibility2006.ap:
            case MarkupCompatibility2006.aq:
            case MarkupCompatibility2006.ar: return;
        }
        let d = (this.am[a]);
        let e = (d != null);
        let f = e ? new ElementLoadCallbacks(1, d.b, b) : new ElementLoadCallbacks(1, null, b);
        this.am[a] = f;
    }
    static ag(a, b) {
        if (a == null || b == null) {
            return false;
        }
        return a == b;
    }
    ay(a, b, c = true) {
        switch (a) {
            case MarkupCompatibility2006.ap:
            case MarkupCompatibility2006.aq:
            case MarkupCompatibility2006.ar: return;
        }
        let d = (this.am[a]);
        let e = (d != null);
        let f = e ? new ElementLoadCallbacks(1, b, d.a) : new ElementLoadCallbacks(1, b, null);
        this.am[a] = f;
    }
    ah(a) {
        if (stringIsNullOrEmpty(a)) {
            return true;
        }
        let b = a.split(' ');
        for (let d = 0; d < b.length; d++) {
            let c = b[d];
            let e = this.aa.ae(c);
            if (stringIsNullOrEmpty(e)) {
                continue;
            }
            if (this.d._ad(e) == false) {
                return false;
            }
        }
        return true;
    }
    ai(a) {
        return this.s.c == false;
    }
    y(a, b) {
        return 0;
    }
    az(a) {
        let b = this.aa.k.e(this.d);
    }
    a0() {
        return new XmlTextReader(1, this.l);
    }
    a1() {
        return new XmlTextWriter(0, this.l, Encoding.uTF8);
    }
    t() {
        return WorkItemExtensions.g(Base.$, Async.n(XmlReader.$, this.a0(), (a) => Async.g(a.t(), () => {
            this.aa = new XmlReadManager(this, a);
            return this.aa.d();
        })), () => this.an);
    }
    get s() {
        return this.r;
    }
    get af() {
        return this.al != 0;
    }
    get_aj() {
        return true;
    }
    get aj() {
        return this.get_aj();
    }
    get ab() {
        return this.aa;
    }
    get ad() {
        return this.ac;
    }
}
XmlPartManagerBase.$t = markType(XmlPartManagerBase, 'XmlPartManagerBase', PartManagerBase.$);
/**
 * @hidden
 */
export class CorePropertiesPartManager extends XmlPartManagerBase {
    get_m() {
        return CorePropertiesPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        return "/docProps/core.xml";
    }
    o(a) {
        switch (a) {
            case 0: return CorePropertiesPartManager.a5;
            case 1: return CorePropertiesPartManager.a4;
            default: return CorePropertiesPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
CorePropertiesPartManager.$t = markType(CorePropertiesPartManager, 'CorePropertiesPartManager', XmlPartManagerBase.$);
CorePropertiesPartManager.a2 = "application/vnd.openxmlformats-package.core-properties+xml";
CorePropertiesPartManager.a5 = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
CorePropertiesPartManager.a4 = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
/**
 * @hidden
 */
export class CustomXmlItemPartManager extends PartManagerBase {
    get_m() {
        return "application/xml";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/customXml/item.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return CustomXmlItemPartManager.u;
            case 1: return CustomXmlItemPartManager.t;
            default: return CustomXmlItemPartManager.u;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
CustomXmlItemPartManager.$t = markType(CustomXmlItemPartManager, 'CustomXmlItemPartManager', PartManagerBase.$);
CustomXmlItemPartManager.u = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml";
CustomXmlItemPartManager.t = "http://purl.oclc.org/ooxml/officeDocument/relationships/customXml";
/**
 * @hidden
 */
export class CustomXmlItemPropsPartManager extends PartManagerBase {
    get_m() {
        return CustomXmlItemPropsPartManager.s;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/customXml/itemProps.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return CustomXmlItemPropsPartManager.u;
            case 1: return CustomXmlItemPropsPartManager.t;
            default: return CustomXmlItemPropsPartManager.u;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
CustomXmlItemPropsPartManager.$t = markType(CustomXmlItemPropsPartManager, 'CustomXmlItemPropsPartManager', PartManagerBase.$);
CustomXmlItemPropsPartManager.s = "application/vnd.openxmlformats-officedocument.customXmlProperties+xml";
CustomXmlItemPropsPartManager.u = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps";
CustomXmlItemPropsPartManager.t = "http://purl.oclc.org/ooxml/officeDocument/relationships/customXmlProps";
/**
 * @hidden
 */
export class DownRevPartManager extends XmlPartManagerBase {
    get_m() {
        return DownRevPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        return "/drs/downrev.xml";
    }
    o(a) {
        switch (a) {
            case 0: return DownRevPartManager.a4;
            case 1: return DownRevPartManager.a4;
            default: return DownRevPartManager.a4;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
DownRevPartManager.$t = markType(DownRevPartManager, 'DownRevPartManager', XmlPartManagerBase.$);
DownRevPartManager.a2 = "application/vnd.ms-office.DrsDownRev+xml";
DownRevPartManager.a4 = "http://schemas.microsoft.com/office/2006/relationships/downRev";
/**
 * @hidden
 */
export class DrawingPartManagerHelpers extends Base {
    static a(a, b) {
        let c = a.s.a(CT_Color.$);
        if (c != null) {
            c.a = b;
            return;
        }
        let d = a.s.a(CT_SolidFillProperties.$);
        if (d != null) {
            d.a = b;
            return;
        }
        let e = a.s.a(CT_StyleMatrixReference.$);
        if (e != null) {
            e.a = b;
            return;
        }
        let f = a.s.a(CT_FontReference.$);
        if (f != null) {
            f.a = b;
            return;
        }
    }
    static b($t, a, b) {
        let c = typeCast(CT_LineProperties.$, a.s.f);
        if (c != null) {
            c.i = b;
            return;
        }
        let d = typeCast(CT_ShapePropertiesBase.$, a.s.f);
        if (d != null) {
            d.a = b;
            return;
        }
        let e = typeCast(CT_TextCharacterProperties.$, a.s.f);
        if (e != null) {
            e.y = b;
            return;
        }
    }
    static c($t, a, b) {
        let c = typeCast(CT_ShapePropertiesBase.$, a.s.f);
        if (c != null) {
            c.a = b;
            return;
        }
    }
    static g(a) {
        let b = a.s.a(CT_PresetGeometry2D.$);
        if (b == null) {
            return;
        }
        let c = new CT_GeomGuideList();
        b.a = c;
        a.s.k(c);
    }
    static d(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveFixedPercentage();
        let d = DrawingMLMain.kg(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Alpha();
            $ret.a = c;
            return $ret;
        })()));
    }
    static e(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositivePercentage();
        let d = DrawingMLMain.kh(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_AlphaMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static f(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_FixedPercentage();
        let d = DrawingMLMain.ki(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_AlphaOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static h(a) {
        let b = a.s.a(CT_BlipFillProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = DrawingMLMain.kk(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_Blip();
            $ret.b = c;
            $ret.c = d;
            $ret.a = Nullable$1.toNullable(ST_BlipCompression_$type, e.value);
            return $ret;
        })());
        b.d = g;
        a.s.k(g);
    }
    static i(a) {
        let b = a.s.a(CT_Picture.$);
        if (b != null) {
            let c;
            let d;
            let e = a.d._t.b4(a, c, d);
            c = e.p1;
            d = e.p2;
            let f = ((() => {
                let $ret = new CT_BlipFillProperties();
                $ret.b = c;
                $ret.c = d;
                return $ret;
            })());
            b.a = f;
            a.s.k(f);
            return;
        }
        else {
            let g;
            let h;
            let i = DrawingMLMain.kl(a, g, h);
            g = i.p1;
            h = i.p2;
            let j = ((() => {
                let $ret = new CT_BlipFillProperties();
                $ret.b = g;
                $ret.c = h;
                return $ret;
            })());
            DrawingPartManagerHelpers.c(CT_BlipFillProperties.$, a, j);
            a.s.k(j);
        }
    }
    static j(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.km(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Blue();
            $ret.a = c;
            return $ret;
        })()));
    }
    static k(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.kn(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_BlueMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static l(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.ko(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_BlueOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static m(a) {
        let b = a.s.a(CT_TextBody.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v = DrawingMLMain.kp(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        b.a = ((() => {
            let $ret = new CT_TextBodyProperties();
            $ret.n = c;
            $ret.l = d;
            $ret.q = e;
            $ret.p = f;
            $ret.t = g;
            $ret.r = h;
            $ret.j = i;
            $ret.s = j;
            $ret.m = k;
            $ret.f = l;
            $ret.k = m;
            $ret.o = n;
            $ret.a = o;
            $ret.i = p;
            $ret.d = q;
            $ret.e = r;
            $ret.h = s;
            $ret.c = t;
            $ret.g = u;
            return $ret;
        })());
        a.s.k(b.a);
    }
    static n(a) {
        let b = a.s.a(CT_GraphicalObjectData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLChart.gx(a, c);
        c = d.p1;
        let e = DrawingMLChart.be;
        if (b.c == DrawingMLChart2014.aq) {
            e = DrawingMLChart2014.ap;
        }
        b.b.add(Tuple.a(String_$type, Base.$, e, ((() => {
            let $ret = new CT_RelId();
            $ret.a = c;
            return $ret;
        })())));
    }
    static o(a) {
        let b = a.s.a(CT_GraphicalObjectData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLChart2014.at(a, c);
        c = d.p1;
        b.b.add(Tuple.a(String_$type, Base.$, DrawingMLChart2014.ap, ((() => {
            let $ret = new CT_RelId();
            $ret.a = c;
            return $ret;
        })())));
    }
    static p(a) {
        let b = a.s.a(CT_GroupTransform2D.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveCoordinate();
        let d = new ST_PositiveCoordinate();
        let e = DrawingMLMain.kq(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_PositiveSize2D();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.m = f;
        a.s.k(f);
    }
    static q(a) {
        let b = a.s.a(CT_GroupTransform2D.$);
        if (b == null) {
            return;
        }
        let c = new ST_Coordinate();
        let d = new ST_Coordinate();
        let e = DrawingMLMain.kr(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Point2D();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.l = f;
        a.s.k(f);
    }
    static r(a) {
        let b = a.s.a(CT_ConnectorNonVisual.$);
        if (b == null) {
            return;
        }
        let c = new CT_NonVisualConnectorProperties();
        b.b = c;
        a.s.k(c);
    }
    static s(a) {
        let b = a.s.a(CT_GraphicalObjectFrameNonVisual.$);
        if (b == null) {
            return;
        }
        let c = new CT_NonVisualGraphicFrameProperties();
        b.b = c;
        a.s.k(c);
    }
    static t(a) {
        let b = a.s.a(CT_GroupShapeNonVisual.$);
        if (b == null) {
            return;
        }
        let c = new CT_NonVisualGroupDrawingShapeProps();
        b.b = c;
        a.s.k(c);
    }
    static u(a) {
        let b = a.s.a(CT_PictureNonVisual.$);
        if (b == null) {
            return;
        }
        let c;
        let d = a.d._t.b8(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_NonVisualPictureProperties();
            $ret.b = c;
            return $ret;
        })());
        b.b = e;
        a.s.k(e);
    }
    static v(a) {
        let b = a.s.a(CT_NonVisualBase.$);
        if (b == null) {
            return;
        }
        let c = new ST_DrawingElementId();
        let d;
        let e;
        let f;
        let g;
        let h = a.d._t.b9(a, c, d, e, f, g);
        c = h.p1;
        d = h.p2;
        e = h.p3;
        f = h.p4;
        g = h.p5;
        let i = ((() => {
            let $ret = new CT_NonVisualDrawingProps();
            $ret.c = c;
            $ret.f = d;
            $ret.e = e;
            $ret.d = f;
            $ret.g = g;
            return $ret;
        })());
        b.a = i;
        a.s.k(i);
    }
    static w(a) {
        let b = a.s.a(CT_ShapeNonVisual.$);
        if (b == null) {
            return;
        }
        let c;
        let d = a.d._t.ca(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_NonVisualDrawingShapeProps();
            $ret.b = c;
            return $ret;
        })());
        b.b = e;
        a.s.k(e);
    }
    static z(a) {
        let b = a.s.a(IShapesOwner_$type);
        let c;
        let d;
        let e = a.d._t.cc(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Connector();
            $ret.c = c;
            $ret.b = d;
            return $ret;
        })());
        if (b != null) {
            b.addShape(a.d, f);
        }
        a.s.k(f);
    }
    static x(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        b.b.add(new ColorTransform_Comp());
    }
    static y(a) {
        let b = a.s.a(CT_TextCharacterProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = DrawingMLMain.ku(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = c;
            $ret.a = d;
            $ret.c = e;
            $ret.b = f;
            return $ret;
        })());
        b.a = h;
        a.s.k(h);
    }
    static aa(a) {
        let b = a.s.a(CT_NonVisualConnectorProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m = a.d._t.cd(a, c, d, e, f, g, h, i, j, k, l);
        c = m.p1;
        d = m.p2;
        e = m.p3;
        f = m.p4;
        g = m.p5;
        h = m.p6;
        i = m.p7;
        j = m.p8;
        k = m.p9;
        l = m.p10;
        let n = ((() => {
            let $ret = new CT_ConnectorLocking();
            $ret.f = c;
            $ret.j = d;
            $ret.i = e;
            $ret.c = f;
            $ret.g = g;
            $ret.h = h;
            $ret.e = i;
            $ret.a = j;
            $ret.b = k;
            $ret.d = l;
            return $ret;
        })());
        b.c = n;
        a.s.k(n);
    }
    static ac(a) {
        let b = a.s.a(CT_TextCharacterProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = DrawingMLMain.ld(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = c;
            $ret.a = d;
            $ret.c = e;
            $ret.b = Nullable$1.toNullable(Number_$type, f);
            return $ret;
        })());
        b.b = h;
        a.s.k(h);
    }
    static ad(a) {
        let b = a.s.a(CT_ShapeStyle.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.le(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_StyleMatrixReference();
            $ret.b = c;
            return $ret;
        })());
        b.b = e;
        a.s.k(e);
    }
    static ae(a) {
        let b = a.s.a(CT_NonVisualConnectorProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = a.d._t.ce(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Connection();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.a = f;
        a.s.k(f);
    }
    static af(a) {
        let b = a.s.a(CT_Transform2D.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveCoordinate();
        let d = new ST_PositiveCoordinate();
        let e = DrawingMLMain.lf(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_PositiveSize2D();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.b = f;
        a.s.k(f);
    }
    static ag(a) {
        a.s.k(IgnoreChildrenMarker.a);
    }
    static ah(a) {
        let b = a.s.a(CT_StretchInfoProperties.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = new ST_Percentage();
        let e = new ST_Percentage();
        let f = new ST_Percentage();
        let g = DrawingMLMain.lj(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_RelativeRect();
            $ret.b = c;
            $ret.d = d;
            $ret.c = e;
            $ret.a = f;
            return $ret;
        })());
        b.a = h;
        a.s.k(h);
    }
    static ai(a) {
        let b = a.s.a(CT_ShapeStyle.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.lk(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_StyleMatrixReference();
            $ret.b = c;
            return $ret;
        })());
        b.c = e;
        a.s.k(e);
    }
    static aj(a) {
        let b = a.s.a(CT_TextParagraph.$);
        if (b == null) {
            return;
        }
        let c = new CT_RegularTextRun();
        b.c.add(c);
        a.s.k(c);
    }
    static ak(a) {
        let b = a.s.a(CT_ShapeStyle.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.ln(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_FontReference();
            $ret.b = c;
            return $ret;
        })());
        b.a = e;
        a.s.k(e);
    }
    static al(a) {
        let b = a.s.a(CT_GeomGuideList.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = DrawingMLMain.lp(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_GeomGuide();
            $ret.b = c;
            $ret.a = d;
            return $ret;
        })());
        b.b.add(f);
        a.s.k(f);
    }
    static an(a) {
        let b = a.s.a(CT_GraphicalObjectFrame.$);
        let c = new CT_GraphicalObject();
        if (b != null) {
            b.a = c;
        }
        a.s.k(c);
    }
    static am(a) {
        let b = a.s.a(CT_GraphicalObject.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.lq(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GraphicalObjectData();
            $ret.c = c;
            return $ret;
        })());
        b.a = e;
        a.s.k(e);
    }
    static ao(a) {
        let b = a.s.a(IShapesOwner_$type);
        let c;
        let d;
        let e = a.d._t.cf(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_GraphicalObjectFrame();
            $ret.e = c;
            $ret.d = d;
            return $ret;
        })());
        if (b != null) {
            b.addShape(a.d, f);
        }
        a.s.k(f);
    }
    static ap(a) {
        let b = Enumerable.ag(AttributeValue.$, a.ab.u, (c) => c.a.e(a.d) == IGOfficeExtensions.ap);
        if (b.d == null || ST_OnOff.e(b.d) == false) {
            a.d._bj();
        }
    }
    static aq(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        b.b.add(new ColorTransform_Gray());
    }
    static ar(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.lu(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Green();
            $ret.a = c;
            return $ret;
        })()));
    }
    static as(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.lv(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_GreenMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static at(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.lw(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_GreenOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static au(a) {
        let b = new CT_GroupFillProperties();
        DrawingPartManagerHelpers.c(CT_GroupFillProperties.$, a, b);
        a.s.k(b);
    }
    static av(a) {
        let b = a.s.a(IShapesOwner_$type);
        let c = new CT_GroupShape();
        if (b != null) {
            b.addShape(a.d, c);
        }
        a.s.k(c);
    }
    static aw(a) {
        let b = a.s.a(CT_NonVisualGroupDrawingShapeProps.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j = a.d._t.ch(a, c, d, e, f, g, h, i);
        c = j.p1;
        d = j.p2;
        e = j.p3;
        f = j.p4;
        g = j.p5;
        h = j.p6;
        i = j.p7;
        let k = ((() => {
            let $ret = new CT_GroupLocking();
            $ret.b = c;
            $ret.g = d;
            $ret.f = e;
            $ret.e = f;
            $ret.a = g;
            $ret.c = h;
            $ret.d = i;
            return $ret;
        })());
        b.a = k;
        a.s.k(k);
    }
    static ax(a) {
        let b = a.s.a(CT_GroupShape.$);
        if (b == null) {
            return;
        }
        let c;
        let d = a.d._t.ci(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_GroupShapeProperties();
            $ret.b = c;
            return $ret;
        })());
        b.b = e;
        a.s.k(e);
    }
    static ay(a) {
        let b = a.s.a(CT_LineProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = DrawingMLMain.ly(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_LineEndProperties();
            $ret.b = c;
            $ret.c = d;
            $ret.a = e;
            return $ret;
        })());
        b.a = g;
        a.s.k(g);
    }
    static az(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveFixedAngle();
        let d = DrawingMLMain.l1(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Hue();
            $ret.a = c;
            return $ret;
        })()));
    }
    static a0(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositivePercentage();
        let d = DrawingMLMain.l2(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_HueMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static a1(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Angle();
        let d = DrawingMLMain.l3(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_HueOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static a2(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        b.b.add(new ColorTransform_Inv());
    }
    static a3(a) {
        let b = a.s.a(CT_TextCharacterProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g = DrawingMLMain.l5(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_TextFont();
            $ret.d = c;
            $ret.a = d;
            $ret.c = e;
            $ret.b = Nullable$1.toNullable(Number_$type, f);
            return $ret;
        })());
        b.c = h;
        a.s.k(h);
    }
    static a4(a) {
        let b = a.s.a(CT_ShapeProperties.$);
        let c = b == null ? a.s.a(CT_TextCharacterProperties.$) : null;
        if (b == null && c == null) {
            return;
        }
        let d;
        let e;
        let f;
        let g;
        let h = DrawingMLMain.l6(a, d, e, f, g);
        d = h.p1;
        e = h.p2;
        f = h.p3;
        g = h.p4;
        let i = ((() => {
            let $ret = new CT_LineProperties();
            $ret.h = d;
            $ret.f = e;
            $ret.g = f;
            $ret.e = g;
            return $ret;
        })());
        if (b != null) {
            b.c = i;
        }
        else {
            c.w = i;
        }
        a.s.k(i);
    }
    static a5(a) {
        let b = a.s.a(CT_ShapeStyle.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.l7(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_StyleMatrixReference();
            $ret.b = c;
            return $ret;
        })());
        b.d = e;
        a.s.k(e);
    }
    static a6(a) {
        let b = a.s.a(CT_TextBody.$);
        if (b == null) {
            return;
        }
        let c = new CT_TextListStyle();
        b.b = c;
        a.s.k(c);
    }
    static ba(a) {
        let b = a.s.a(CT_TextListStyle.$);
        if (b == null) {
            return;
        }
        let c = CT_TextParagraphProperties.b(a);
        b.b = c;
        a.s.k(c);
    }
    static ab(a) {
        let b = a.s.a(CT_TextParagraphProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v = DrawingMLMain.ms(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, DrawingMLMain.c5);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        let w = ((() => {
            let $ret = new CT_TextCharacterProperties();
            $ret.k = c;
            $ret.v = d;
            $ret.t = e;
            $ret.r = ST_TextFontSize.g(f);
            $ret.d = g;
            $ret.i = h;
            $ret.s = i;
            $ret.q = j;
            $ret.j = k;
            $ret.f = l;
            $ret.p = m;
            $ret.m = n;
            $ret.e = o;
            $ret.l = p;
            $ret.g = q;
            $ret.h = r;
            $ret.n = s;
            $ret.o = t;
            $ret.u = u;
            return $ret;
        })());
        b.a = w;
        a.s.k(w);
    }
    static a7(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mb(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Lum();
            $ret.a = c;
            return $ret;
        })()));
    }
    static a8(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mc(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_LumMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static a9(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.md(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_LumOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bb(a) {
        let b = new CT_NoFillProperties();
        DrawingPartManagerHelpers.b(CT_NoFillProperties.$, a, b);
        a.s.k(b);
    }
    static bc(a) {
        let b = a.s.a(CT_Connector.$);
        if (b == null) {
            return;
        }
        let c = new CT_ConnectorNonVisual();
        b.a = c;
        a.s.k(c);
    }
    static bd(a) {
        let b = a.s.a(CT_GraphicalObjectFrame.$);
        if (b == null) {
            return;
        }
        let c = new CT_GraphicalObjectFrameNonVisual();
        b.b = c;
        a.s.k(c);
    }
    static be(a) {
        let b = a.s.a(CT_GroupShape.$);
        if (b == null) {
            return;
        }
        let c = new CT_GroupShapeNonVisual();
        b.a = c;
        a.s.k(c);
    }
    static bf(a) {
        let b = a.s.a(CT_Picture.$);
        if (b == null) {
            return;
        }
        let c = new CT_PictureNonVisual();
        b.b = c;
        a.s.k(c);
    }
    static bg(a) {
        let b = a.s.a(CT_Shape.$);
        if (b == null) {
            return;
        }
        let c = new CT_ShapeNonVisual();
        b.a = c;
        a.s.k(c);
    }
    static bh(a) {
        let b = a.s.a(CT_Transform2D.$);
        if (b == null) {
            return;
        }
        let c = new ST_Coordinate();
        let d = new ST_Coordinate();
        let e = DrawingMLMain.mi(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Point2D();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.a = f;
        a.s.k(f);
    }
    static bi(a) {
        let b = a.s.a(CT_TextBody.$);
        if (b == null) {
            return;
        }
        let c = new CT_TextParagraph();
        b.d.add(c);
        a.s.k(c);
    }
    static bj(a) {
        let b = a.s.a(IShapesOwner_$type);
        let c;
        let d;
        let e = a.d._t.co(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Picture();
            $ret.d = c;
            $ret.c = d;
            return $ret;
        })());
        if (b != null) {
            b.addShape(a.d, f);
        }
        a.s.k(f);
    }
    static bk(a) {
        let b = a.s.a(CT_NonVisualPictureProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n = DrawingMLMain.mk(a, c, d, e, f, g, h, i, j, k, l, m);
        c = n.p1;
        d = n.p2;
        e = n.p3;
        f = n.p4;
        g = n.p5;
        h = n.p6;
        i = n.p7;
        j = n.p8;
        k = n.p9;
        l = n.p10;
        m = n.p11;
        let o = ((() => {
            let $ret = new CT_PictureLocking();
            $ret.g = c;
            $ret.k = d;
            $ret.j = e;
            $ret.c = f;
            $ret.h = g;
            $ret.i = h;
            $ret.f = i;
            $ret.a = j;
            $ret.b = k;
            $ret.d = l;
            $ret.e = m;
            return $ret;
        })());
        b.a = o;
        a.s.k(o);
    }
    static bl(a) {
        let b = a.s.a(CT_TextParagraph.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n = DrawingMLMain.ml(a, c, d, e, f, g, h, i, j, k, l, m);
        c = n.p1;
        d = n.p2;
        e = n.p3;
        f = n.p4;
        g = n.p5;
        h = n.p6;
        i = n.p7;
        j = n.p8;
        k = n.p9;
        l = n.p10;
        m = n.p11;
        let o = ((() => {
            let $ret = new CT_TextParagraphProperties();
            $ret.k = c;
            $ret.l = d;
            $ret.j = e;
            $ret.h = f;
            $ret.c = g;
            $ret.d = h;
            $ret.m = i;
            $ret.e = j;
            $ret.f = k;
            $ret.i = l;
            $ret.g = m;
            return $ret;
        })());
        b.a = o;
        a.s.k(o);
    }
    static bm(a) {
        let b;
        let c = DrawingMLMain.mm(a, b);
        b = c.p1;
        let d = ((() => {
            let $ret = new CT_PresetColor_Core();
            $ret.c = b;
            return $ret;
        })());
        a.s.k(d);
        DrawingPartManagerHelpers.a(a, d);
    }
    static bn(a) {
        let b = a.s.a(CT_ShapeProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.mn(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_PresetGeometry2D();
            $ret.b = c;
            return $ret;
        })());
        b.e = e;
        a.s.k(e);
    }
    static bo(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mo(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Red();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bp(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mp(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_RedMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bq(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mq(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_RedOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static br(a) {
        let b = a.s.a(CT_TextParagraph.$);
        if (b == null) {
            return;
        }
        let c = new CT_RegularTextRun();
        b.c.add(c);
        a.s.k(c);
    }
    static bs(a) {
        let b = a.s.a(CT_RegularTextRun.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        let u;
        let v = DrawingMLMain.ms(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u);
        c = v.p1;
        d = v.p2;
        e = v.p3;
        f = v.p4;
        g = v.p5;
        h = v.p6;
        i = v.p7;
        j = v.p8;
        k = v.p9;
        l = v.p10;
        m = v.p11;
        n = v.p12;
        o = v.p13;
        p = v.p14;
        q = v.p15;
        r = v.p16;
        s = v.p17;
        t = v.p18;
        u = v.p19;
        let w = ((() => {
            let $ret = new CT_TextCharacterProperties();
            $ret.k = c;
            $ret.v = d;
            $ret.t = e;
            $ret.r = ST_TextFontSize.g(f);
            $ret.d = g;
            $ret.i = h;
            $ret.s = i;
            $ret.q = j;
            $ret.j = k;
            $ret.f = l;
            $ret.p = m;
            $ret.m = n;
            $ret.e = o;
            $ret.l = p;
            $ret.g = q;
            $ret.h = r;
            $ret.n = s;
            $ret.o = t;
            $ret.u = u;
            return $ret;
        })());
        b.a = w;
        a.s.k(w);
    }
    static bt(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mt(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Sat();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bu(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mu(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_SatMod();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bv(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = DrawingMLMain.mv(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_SatOff();
            $ret.a = c;
            return $ret;
        })()));
    }
    static bw(a) {
        let b;
        let c = DrawingMLMain.mw(a, b);
        b = c.p1;
        let d = ((() => {
            let $ret = new CT_SchemeColor();
            $ret.c = b;
            return $ret;
        })());
        a.s.k(d);
        DrawingPartManagerHelpers.a(a, d);
    }
    static bx(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveFixedPercentage();
        let d = DrawingMLMain.mx(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Shade();
            $ret.a = c;
            return $ret;
        })()));
    }
    static by(a) {
        let b = a.s.a(CT_GraphicalObjectData.$);
        if (b == null) {
            return;
        }
        let c;
        let d = Drawing2010Slicer.at(a, c);
        c = d.p1;
        b.b.add(Tuple.a(String_$type, Base.$, Drawing2010Slicer.as, ((() => {
            let $ret = new CT_Slicer();
            $ret.a = c;
            return $ret;
        })())));
    }
    static bz(a) {
        let b = new CT_SolidFillProperties();
        DrawingPartManagerHelpers.b(CT_SolidFillProperties.$, a, b);
        a.s.k(b);
    }
    static b0(a) {
        let b = a.s.a(IShapesOwner_$type);
        let c;
        let d;
        let e;
        let f;
        let g = a.d._t.cp(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_Shape();
            $ret.e = c;
            $ret.f = d;
            $ret.c = e;
            $ret.d = f;
            return $ret;
        })());
        if (b != null) {
            b.addShape(a.d, h);
        }
        a.s.k(h);
    }
    static b1(a) {
        let b = a.s.a(CT_NonVisualDrawingShapeProps.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n = DrawingMLMain.mz(a, c, d, e, f, g, h, i, j, k, l, m);
        c = n.p1;
        d = n.p2;
        e = n.p3;
        f = n.p4;
        g = n.p5;
        h = n.p6;
        i = n.p7;
        j = n.p8;
        k = n.p9;
        l = n.p10;
        m = n.p11;
        let o = ((() => {
            let $ret = new CT_ShapeLocking();
            $ret.f = c;
            $ret.j = d;
            $ret.i = e;
            $ret.c = f;
            $ret.g = g;
            $ret.h = h;
            $ret.e = i;
            $ret.a = j;
            $ret.b = k;
            $ret.d = l;
            $ret.k = m;
            return $ret;
        })());
        b.a = o;
        a.s.k(o);
    }
    static b2(a) {
        let b = a.s.a(ICT_ShapePropertiesOwner_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = a.d._t.cq(a, c);
        c = d.p1;
        let e = ((() => {
            let $ret = new CT_ShapeProperties();
            $ret.b = c;
            return $ret;
        })());
        b.spPr = e;
        a.s.k(e);
    }
    static b3(a) {
        let b = a.s.a(CT_BlipFillProperties.$);
        if (b == null) {
            return;
        }
        let c = new ST_Percentage();
        let d = new ST_Percentage();
        let e = new ST_Percentage();
        let f = new ST_Percentage();
        let g = DrawingMLMain.m0(a, c, d, e, f);
        c = g.p1;
        d = g.p2;
        e = g.p3;
        f = g.p4;
        let h = ((() => {
            let $ret = new CT_RelativeRect();
            $ret.b = c;
            $ret.d = d;
            $ret.c = e;
            $ret.a = f;
            return $ret;
        })());
        b.a = h;
        a.s.k(h);
    }
    static b4(a) {
        let b = new ST_HexColorRGB();
        let c = DrawingMLMain.m1(a, b);
        b = c.p1;
        let d = ((() => {
            let $ret = new CT_SRgbColor();
            $ret.c = b;
            return $ret;
        })());
        a.s.k(d);
        DrawingPartManagerHelpers.a(a, d);
    }
    static b5(a) {
        let b = a.s.a(CT_NonVisualConnectorProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e = a.d._t.cr(a, c, d);
        c = e.p1;
        d = e.p2;
        let f = ((() => {
            let $ret = new CT_Connection();
            $ret.a = c;
            $ret.b = d;
            return $ret;
        })());
        b.b = f;
        a.s.k(f);
    }
    static b6(a) {
        let b = a.s.a(CT_BlipFillProperties.$);
        if (b == null) {
            return;
        }
        let c = new CT_StretchInfoProperties();
        b.e = c;
        a.s.k(c);
    }
    static b7(a) {
        let b = a.s.a(ICT_ShapeStyleOwner_$type);
        if (b == null) {
            return;
        }
        let c = new CT_ShapeStyle();
        b.style = c;
        a.s.k(c);
    }
    static b8(a) {
        let b;
        let c = new ST_HexColorRGB();
        let d = DrawingMLMain.m3(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = ((() => {
            let $ret = new CT_SysColor();
            $ret.d = b;
            $ret.c = c;
            return $ret;
        })());
        a.s.k(e);
        DrawingPartManagerHelpers.a(a, e);
    }
    static b9(a) {
        let b = a.s.a(CT_LineProperties.$);
        if (b == null) {
            return;
        }
        let c;
        let d;
        let e;
        let f = DrawingMLMain.m4(a, c, d, e);
        c = f.p1;
        d = f.p2;
        e = f.p3;
        let g = ((() => {
            let $ret = new CT_LineEndProperties();
            $ret.b = c;
            $ret.c = d;
            $ret.a = e;
            return $ret;
        })());
        b.b = g;
        a.s.k(g);
    }
    static ca(a) {
        let b = a.s.a(CT_RegularTextRun.$);
        if (b == null) {
            return;
        }
        let c;
        let d = DrawingMLMain.m5(a, c);
        c = d.p1;
        b.b = c != null ? c : stringEmpty();
    }
    static cb(a) {
        let b = a.s.a(EG_ColorChoice.$);
        if (b == null) {
            return;
        }
        let c = new ST_PositiveFixedPercentage();
        let d = DrawingMLMain.m9(a, c);
        c = d.p1;
        b.b.add(((() => {
            let $ret = new ColorTransform_Tint();
            $ret.a = c;
            return $ret;
        })()));
    }
    static cc(a) {
        let b = a.s.a(CT_Shape.$);
        if (b == null) {
            return;
        }
        let c = new CT_TextBody();
        b.b = c;
        a.s.k(c);
    }
    static cd(a) {
        let b = new ST_Angle();
        let c;
        let d;
        let e = a.s.a(CT_GraphicalObjectFrame.$);
        if (e != null) {
            let f = a.d._t.cu(a, b, c, d);
            b = f.p1;
            c = f.p2;
            d = f.p3;
            let g = ((() => {
                let $ret = new CT_Transform2D();
                $ret.j = Nullable$1.toNullable(ST_Angle.$, b);
                $ret.i = Nullable$1.toNullable(Boolean_$type, c);
                $ret.k = Nullable$1.toNullable(Boolean_$type, d);
                return $ret;
            })());
            e.c = g;
            a.s.k(g);
            return;
        }
        let h = DrawingMLMain.na(a, b, c, d);
        b = h.p1;
        c = h.p2;
        d = h.p3;
        let i = a.s.a(CT_ShapeProperties.$);
        if (i != null) {
            let j = ((() => {
                let $ret = new CT_Transform2D();
                $ret.j = Nullable$1.toNullable(ST_Angle.$, b);
                $ret.i = Nullable$1.toNullable(Boolean_$type, c);
                $ret.k = Nullable$1.toNullable(Boolean_$type, d);
                return $ret;
            })());
            i.d = j;
            a.s.k(j);
            return;
        }
        let k = a.s.a(CT_GroupShapeProperties.$);
        if (k != null) {
            let l = ((() => {
                let $ret = new CT_GroupTransform2D();
                $ret.j = Nullable$1.toNullable(ST_Angle.$, b);
                $ret.i = Nullable$1.toNullable(Boolean_$type, c);
                $ret.k = Nullable$1.toNullable(Boolean_$type, d);
                return $ret;
            })());
            k.c = l;
            a.s.k(l);
            return;
        }
    }
    static ce(a) {
        a.ay(DrawingMLMain.a1, DrawingPartManagerHelpers.d);
        a.ay(DrawingMLMain.a6, DrawingPartManagerHelpers.e);
        a.ay(DrawingMLMain.a8, DrawingPartManagerHelpers.f);
        a.ay(DrawingMLMain.bg, DrawingPartManagerHelpers.g);
        a.ay(DrawingMLMain.bs, DrawingPartManagerHelpers.h);
        a.ay(DrawingMLMain.bt, DrawingPartManagerHelpers.i);
        a.ay(DrawingMLMain.bu, DrawingPartManagerHelpers.j);
        a.ay(DrawingMLMain.bv, DrawingPartManagerHelpers.k);
        a.ay(DrawingMLMain.bw, DrawingPartManagerHelpers.l);
        a.ay(DrawingMLMain.bz, DrawingPartManagerHelpers.m);
        a.ay(DrawingMLMain.cg, DrawingPartManagerHelpers.p);
        a.ay(DrawingMLMain.ch, DrawingPartManagerHelpers.q);
        a.ay(DrawingMLMain.cp, DrawingPartManagerHelpers.x);
        a.ay(DrawingMLMain.ct, DrawingPartManagerHelpers.y);
        a.ay(DrawingMLMain.c5, DrawingPartManagerHelpers.ab);
        a.ay(DrawingMLMain.de, DrawingPartManagerHelpers.ac);
        a.ay(DrawingMLMain.dj, DrawingPartManagerHelpers.ad);
        a.ay(DrawingMLMain.dq, DrawingPartManagerHelpers.af);
        a.ay(DrawingMLMain.dr, DrawingPartManagerHelpers.ag);
        a.ay(DrawingMLMain.dy, DrawingPartManagerHelpers.ah);
        a.ay(DrawingMLMain.dz, DrawingPartManagerHelpers.ai);
        a.ay(DrawingMLMain.d3, DrawingPartManagerHelpers.aj);
        a.ay(DrawingMLMain.eb, DrawingPartManagerHelpers.ak);
        a.ay(DrawingMLMain.eg, DrawingPartManagerHelpers.al);
        a.ay(DrawingMLMain.ek, DrawingPartManagerHelpers.an);
        a.ay(DrawingMLMain.el, DrawingPartManagerHelpers.am);
        a.ay(DrawingMLMain.em, DrawingPartManagerHelpers.ap);
        a.ay(DrawingMLMain.en, DrawingPartManagerHelpers.aq);
        a.ay(DrawingMLMain.ep, DrawingPartManagerHelpers.ar);
        a.ay(DrawingMLMain.eq, DrawingPartManagerHelpers.as);
        a.ay(DrawingMLMain.er, DrawingPartManagerHelpers.at);
        a.ay(DrawingMLMain.es, DrawingPartManagerHelpers.au);
        a.ay(DrawingMLMain.ew, DrawingPartManagerHelpers.ay);
        a.ay(DrawingMLMain.e8, DrawingPartManagerHelpers.az);
        a.ay(DrawingMLMain.e9, DrawingPartManagerHelpers.a0);
        a.ay(DrawingMLMain.fa, DrawingPartManagerHelpers.a1);
        a.ay(DrawingMLMain.fg, DrawingPartManagerHelpers.a2);
        a.ay(DrawingMLMain.fq, DrawingPartManagerHelpers.a3);
        a.ay(DrawingMLMain.fw, DrawingPartManagerHelpers.a4);
        a.ay(DrawingMLMain.fx, DrawingPartManagerHelpers.a5);
        a.ay(DrawingMLMain.f1, DrawingPartManagerHelpers.a6);
        a.ay(DrawingMLMain.f4, DrawingPartManagerHelpers.a7);
        a.ay(DrawingMLMain.f5, DrawingPartManagerHelpers.a8);
        a.ay(DrawingMLMain.f6, DrawingPartManagerHelpers.a9);
        a.ay(DrawingMLMain.f8, DrawingPartManagerHelpers.ba);
        a.ay(DrawingMLMain.gy, DrawingPartManagerHelpers.bb);
        a.ay(DrawingMLMain.hb, DrawingPartManagerHelpers.bh);
        a.ay(DrawingMLMain.hd, DrawingPartManagerHelpers.bi);
        a.ay(DrawingMLMain.hi, DrawingPartManagerHelpers.bk);
        a.ay(DrawingMLMain.hl, DrawingPartManagerHelpers.bl);
        a.ay(DrawingMLMain.hn, DrawingPartManagerHelpers.bm);
        a.ay(DrawingMLMain.hp, DrawingPartManagerHelpers.bn);
        a.ay(DrawingMLMain.hu, DrawingPartManagerHelpers.br);
        a.ay(DrawingMLMain.hx, DrawingPartManagerHelpers.bo);
        a.ay(DrawingMLMain.hy, DrawingPartManagerHelpers.bp);
        a.ay(DrawingMLMain.hz, DrawingPartManagerHelpers.bq);
        a.ay(DrawingMLMain.h7, DrawingPartManagerHelpers.bs);
        a.ay(DrawingMLMain.ia, DrawingPartManagerHelpers.bt);
        a.ay(DrawingMLMain.ib, DrawingPartManagerHelpers.bu);
        a.ay(DrawingMLMain.ic, DrawingPartManagerHelpers.bv);
        a.ay(DrawingMLMain.ie, DrawingPartManagerHelpers.bw);
        a.ay(DrawingMLMain.ii, DrawingPartManagerHelpers.bx);
        a.ay(DrawingMLMain.io, DrawingPartManagerHelpers.bz);
        a.ay(DrawingMLMain.iy, DrawingPartManagerHelpers.b1);
        a.ay(DrawingMLMain.iz, DrawingPartManagerHelpers.b3);
        a.ay(DrawingMLMain.i0, DrawingPartManagerHelpers.b4);
        a.ay(DrawingMLMain.i2, DrawingPartManagerHelpers.b6);
        a.ay(DrawingMLMain.i8, DrawingPartManagerHelpers.b8);
        a.ay(DrawingMLMain.ja, DrawingPartManagerHelpers.ca);
        a.ay(DrawingMLMain.je, DrawingPartManagerHelpers.b9);
        a.ay(DrawingMLMain.jm, DrawingPartManagerHelpers.cb);
        a.ay(DrawingMLMain.j8, DrawingPartManagerHelpers.cd);
        a.ay(DrawingMLChart.be, DrawingPartManagerHelpers.n);
        a.ay(DrawingMLChart2014.ap, DrawingPartManagerHelpers.o);
        a.ay(Drawing2010Slicer.as, DrawingPartManagerHelpers.by);
        let b = a.d._t;
        if (b != null) {
            a.ay(b.an, DrawingPartManagerHelpers.i);
            a.ay(b.ap, DrawingPartManagerHelpers.r);
            a.ay(b.aq, DrawingPartManagerHelpers.s);
            a.ay(b.ar, DrawingPartManagerHelpers.t);
            a.ay(b.as, DrawingPartManagerHelpers.u);
            a.ay(b.at, DrawingPartManagerHelpers.v);
            a.ay(b.au, DrawingPartManagerHelpers.w);
            a.ay(b.av, DrawingPartManagerHelpers.z);
            a.ay(b.aw, DrawingPartManagerHelpers.aa);
            a.ay(b.ay, DrawingPartManagerHelpers.ae);
            a.ay(b.a3, DrawingPartManagerHelpers.ao);
            a.ay(b.a4, DrawingPartManagerHelpers.av);
            a.ay(b.a5, DrawingPartManagerHelpers.aw);
            a.ay(b.a6, DrawingPartManagerHelpers.ax);
            a.ay(b.bn, DrawingPartManagerHelpers.bc);
            a.ay(b.bo, DrawingPartManagerHelpers.bd);
            a.ay(b.bp, DrawingPartManagerHelpers.be);
            a.ay(b.bq, DrawingPartManagerHelpers.bf);
            a.ay(b.br, DrawingPartManagerHelpers.bg);
            a.ay(b.bs, DrawingPartManagerHelpers.bj);
            a.ay(b.bw, DrawingPartManagerHelpers.b0);
            a.ay(b.bx, DrawingPartManagerHelpers.b2);
            a.ay(b.by, DrawingPartManagerHelpers.b5);
            a.ay(b.bz, DrawingPartManagerHelpers.b7);
            a.ay(b.b1, DrawingPartManagerHelpers.cc);
            a.ay(b.b3, DrawingPartManagerHelpers.cd);
        }
    }
    static cf(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nh(a, b.a);
        a.ad.k();
    }
    static cg(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ni(a, b.a);
        a.ad.k();
    }
    static ch(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nj(a, b.a);
        a.ad.k();
    }
    static ci(a, b) {
        if (b == null) {
            return;
        }
        a.ad.g(Enumerable.o(Tuple$2.$.specialize(Array_$type, IGraphicalObjectContent_$type), AlternateContentChoice.$, b.b, (c) => new AlternateContentChoice(1, c.c, () => c.d._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a))), b.a == null ? null : () => b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
    }
    static cj(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nk(a);
        b.b.q((c) => DrawingPartManagerHelpers.dc(a, c));
        a.ad.k();
    }
    static ck(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nl(a, b.b, b.c, b.a);
        a.ad.k();
    }
    static cl(a, b, c = false) {
        if (b == null) {
            return;
        }
        if (c) {
            a.d._t.cv(a, nullableEquals(b.b, 0) ? Nullable$1.toNullable(Number_$type, null) : b.b, nullableEquals(b.c, false) ? Nullable$1.toNullable(Boolean_$type, null) : b.c);
        }
        else {
            DrawingMLMain.nm(a, nullableEquals(b.b, 0) ? Nullable$1.toNullable(Number_$type, null) : b.b, nullableEquals(b.c, false) ? Nullable$1.toNullable(Boolean_$type, null) : b.c);
        }
        DrawingPartManagerHelpers.ck(a, b.d);
        DrawingPartManagerHelpers.et(a, b.a);
        if (b.e != null) {
            b.e._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static cm(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nn(a, b.a);
        a.ad.k();
    }
    static cn(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.no(a, b.a);
        a.ad.k();
    }
    static co(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.np(a, b.a);
        a.ad.k();
    }
    static cp(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nq(a, b.n, b.l, b.q, b.p, b.t, b.r, b.j, b.s, b.m, b.f, b.k, b.o, b.a, b.i, b.d, b.e, b.h, b.c, b.g);
        a.ad.k();
    }
    static cq(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nr(a, b.a, b.b);
        a.ad.k();
    }
    static cr(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ns(a, b.a, b.b);
        a.ad.k();
    }
    static cs(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.cw(a);
        DrawingPartManagerHelpers.c4(a, b.c);
        DrawingPartManagerHelpers.ev(a, b.b);
        DrawingPartManagerHelpers.c7(a, b.a);
        a.ad.k();
    }
    static ct(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.cx(a);
        DrawingPartManagerHelpers.di(a, b.a);
        a.ad.k();
    }
    static cu(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.cy(a);
        DrawingPartManagerHelpers.dp(a, b.a);
        a.ad.k();
    }
    static cv(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.cz(a, b.b);
        DrawingPartManagerHelpers.eb(a, b.a);
        a.ad.k();
    }
    static cw(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c0(a, b.c, b.f, b.e, b.d, b.g);
        a.ad.k();
    }
    static cx(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c1(a, b.b);
        DrawingPartManagerHelpers.er(a, b.a);
        a.ad.k();
    }
    static cy(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.nu(a);
        a.ad.k();
    }
    static cz(a, b) {
        if (b == null) {
            return;
        }
        let c = b.b.hasValue ? b.b.value : 1;
        DrawingMLMain.nv(a, b.d, b.a, b.c, c);
        a.ad.k();
    }
    static c0(a, b, c) {
        if (b == null) {
            return;
        }
        c(a, b.b, b.c, b.a);
        a.ad.k();
    }
    static c1(a, b, c) {
        if (b == null) {
            return;
        }
        c(a, b.b, b.d, b.c, b.a);
        a.ad.k();
    }
    static c2(a, b) {
        if (b == null) {
            return;
        }
        a.ad.n(b.g);
    }
    static c3(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c3(a);
        DrawingPartManagerHelpers.d3(a, b.a);
        DrawingPartManagerHelpers.es(a, b.spPr);
        DrawingPartManagerHelpers.ex(a, b.style);
        a.ad.k();
    }
    static c4(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c4(a, b.f, b.j, b.i, b.c, b.g, b.h, b.e, b.a, b.b, b.d);
        a.ad.k();
    }
    static c5(a, b) {
        if (b == null) {
            return;
        }
        let c = b.b.hasValue ? b.b.value : 1;
        DrawingMLMain.oe(a, b.d, b.a, b.c, c);
        a.ad.k();
    }
    static c6(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.of(a, b.b);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static c7(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c5(a, b.a, b.b);
        a.ad.k();
    }
    static c8(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.og(a, b.a, b.b);
        a.ad.k();
    }
    static c9(a, b) {
        DrawingPartManagerHelpers.c1(a, b, DrawingMLMain.ok);
    }
    static da(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ol(a, b.b);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static db(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.oo(a, b.b);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static dc(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.oq(a, b.b, b.a);
        a.ad.k();
    }
    static de(a, b) {
        let c = typeCast(IGraphicalObjectContent_$type, b.d);
        if (c != null) {
            c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
            return;
        }
        let d = typeCast(CT_RelId.$, b.d);
        if (d != null) {
            switch (b.c) {
                case DrawingMLChart.be:
                    DrawingMLChart.gy(a, d.a);
                    a.ad.k();
                    break;
                case DrawingMLChart2014.ap:
                    DrawingMLChart2014.au(a, d.a);
                    a.ad.k();
                    break;
                default: break;
            }
            return;
        }
        let e = typeCast(CT_Slicer.$, b.d);
        if (e != null) {
            switch (b.c) {
                case Drawing2010Slicer.as:
                    Drawing2010Slicer.au(a, e.a);
                    a.ad.k();
                    break;
                default: break;
            }
            return;
        }
    }
    static df(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.or(a, b.c);
        b.b.q((c) => DrawingPartManagerHelpers.de(a, c));
        a.ad.k();
    }
    static dg(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.os(a);
        DrawingPartManagerHelpers.df(a, b.a);
        a.ad.k();
    }
    static dh(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c6(a, b.e, b.d);
        DrawingPartManagerHelpers.d4(a, b.b);
        DrawingPartManagerHelpers.e3(a, b.c, runOn(a.d._t, a.d._t.dm));
        DrawingPartManagerHelpers.dg(a, b.a);
        a.ad.k();
    }
    static di(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ot(a, b.c, b.b, b.f, b.a, b.d, b.e);
        a.ad.k();
    }
    static dj(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ou(a);
        a.ad.k();
    }
    static dk(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ov(a, b.a);
        a.ad.k();
    }
    static dl(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ow(a, b.a);
        a.ad.k();
    }
    static dm(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ox(a, b.a);
        a.ad.k();
    }
    static dn(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c7(a);
        DrawingPartManagerHelpers.d5(a, b.a);
        DrawingPartManagerHelpers.dq(a, b.b);
        b.d.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static dp(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c8(a, b.b, b.g, b.f, b.e, b.a, b.c, b.d);
        a.ad.k();
    }
    static dq(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.c9(a, b.b);
        DrawingPartManagerHelpers.e2(a, b.c);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static dr(a, b) {
        DrawingPartManagerHelpers.c0(a, b, DrawingMLMain.oz);
    }
    static ds(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o2(a, b.a);
        a.ad.k();
    }
    static dt(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o3(a, b.a);
        a.ad.k();
    }
    static du(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o4(a, b.a);
        a.ad.k();
    }
    static dv(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o5(a);
        a.ad.k();
    }
    static dw(a, b) {
        if (b == null) {
            return;
        }
        let c = b.b.hasValue ? b.b.value : 1;
        DrawingMLMain.o6(a, b.d, b.a, b.c, c);
        a.ad.k();
    }
    static dx(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o7(a, b.h, b.f, b.g, b.e);
        if (b.i != null) {
            b.i._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        if (b.c != null) {
            b.c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        if (b.d != null) {
            b.d._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        DrawingPartManagerHelpers.dr(a, b.a);
        DrawingPartManagerHelpers.ez(a, b.b);
        a.ad.k();
    }
    static dy(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.o8(a, b.b);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static dz(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pc(a, b.a);
        a.ad.k();
    }
    static d0(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pd(a, b.a);
        a.ad.k();
    }
    static d1(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pe(a, b.a);
        a.ad.k();
    }
    static d2(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ph(a);
        a.ad.k();
    }
    static d3(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.db(a);
        DrawingPartManagerHelpers.cw(a, b.a);
        DrawingPartManagerHelpers.cs(a, b.b);
        a.ad.k();
    }
    static d4(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dc(a);
        DrawingPartManagerHelpers.cw(a, b.a);
        DrawingPartManagerHelpers.ct(a, b.b);
        a.ad.k();
    }
    static d5(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dd(a);
        DrawingPartManagerHelpers.cw(a, b.a);
        DrawingPartManagerHelpers.cu(a, b.b);
        a.ad.k();
    }
    static d6(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.de(a);
        DrawingPartManagerHelpers.cw(a, b.a);
        DrawingPartManagerHelpers.cv(a, b.b);
        a.ad.k();
    }
    static d7(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.df(a);
        DrawingPartManagerHelpers.cw(a, b.a);
        DrawingPartManagerHelpers.cx(a, b.b);
        a.ad.k();
    }
    static d8(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pj(a, b.a, b.b);
        a.ad.k();
    }
    static d9(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pk(a);
        DrawingPartManagerHelpers.ec(a, b.a);
        b.c.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static ea(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dg(a);
        DrawingPartManagerHelpers.d6(a, b.b);
        DrawingPartManagerHelpers.cl(a, b.a, true);
        DrawingPartManagerHelpers.es(a, b.spPr);
        a.ad.k();
    }
    static eb(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pl(a, b.g, b.k, b.j, b.c, b.h, b.i, b.f, b.a, b.b, b.d, b.e);
        a.ad.k();
    }
    static ec(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pm(a, b.k, b.l, b.j, b.h, b.c, b.d, b.m, b.e, b.f, b.i, b.g);
        a.ad.k();
    }
    static ed(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pn(a, b.c);
        b.b.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static ee(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.po(a, b.b);
        DrawingPartManagerHelpers.cj(a, b.a);
        a.ad.k();
    }
    static ef(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pp(a, b.a);
        a.ad.k();
    }
    static eg(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pq(a, b.a);
        a.ad.k();
    }
    static eh(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pr(a, b.a);
        a.ad.k();
    }
    static ei(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.ps(a);
        DrawingPartManagerHelpers.ej(a, b.a);
        DrawingMLMain.p6(a, b.b);
        a.ad.k();
        a.ad.k();
    }
    static ej(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pt(a, b.k, b.v, b.t, ST_TextFontSize.h(b.r), b.d, b.i, b.s, b.q, b.j, b.f, b.p, b.m, b.e, b.l, b.g, b.h, b.n, b.o, b.u);
        DrawingPartManagerHelpers.dx(a, b.w);
        if (b.y != null) {
            b.y._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        DrawingPartManagerHelpers.dw(a, b.c);
        DrawingPartManagerHelpers.c5(a, b.b);
        DrawingPartManagerHelpers.cz(a, b.a);
        a.ad.k();
    }
    static ek(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pu(a, b.a);
        a.ad.k();
    }
    static el(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pv(a, b.a);
        a.ad.k();
    }
    static em(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pw(a, b.a);
        a.ad.k();
    }
    static en(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.px(a, b.c);
        b.b.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static dd(a, b) {
        if (b == null) {
            return;
        }
        b._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
    }
    static ep(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.pz(a);
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        a.ad.k();
    }
    static eq(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dh(a);
        DrawingPartManagerHelpers.d7(a, b.a);
        DrawingPartManagerHelpers.es(a, b.spPr);
        DrawingPartManagerHelpers.ex(a, b.style);
        DrawingPartManagerHelpers.e1(a, b.b);
        a.ad.k();
    }
    static er(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.p0(a, b.f, b.j, b.i, b.c, b.g, b.h, b.e, b.a, b.b, b.d, b.k);
        a.ad.k();
    }
    static es(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.di(a, b.b);
        DrawingPartManagerHelpers.e3(a, b.d, DrawingMLMain.qb);
        if (b.e != null) {
            b.e._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        if (b.a != null) {
            b.a._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a);
        }
        DrawingPartManagerHelpers.dx(a, b.c);
        a.ad.k();
    }
    static et(a, b) {
        DrawingPartManagerHelpers.c1(a, b, DrawingMLMain.p1);
    }
    static eo(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.py(a, b.a);
        a.ad.k();
    }
    static eu(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.p2(a, b.c);
        b.b.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static ev(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dj(a, b.a, b.b);
        a.ad.k();
    }
    static ew(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.p3(a);
        DrawingPartManagerHelpers.c9(a, b.a);
        a.ad.k();
    }
    static ex(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dk(a);
        DrawingPartManagerHelpers.dy(a, b.d);
        DrawingPartManagerHelpers.da(a, b.c);
        DrawingPartManagerHelpers.c6(a, b.b);
        DrawingPartManagerHelpers.db(a, b.a);
        a.ad.k();
    }
    static ey(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.p4(a, b.d, b.c);
        b.b.q((c) => c._accept$2$i(XmlPartManagerBase.$, Boolean_$type, DrawingPartManagerHelpers_DrawingSerializationHelper.a, a));
        a.ad.k();
    }
    static ez(a, b) {
        DrawingPartManagerHelpers.c0(a, b, DrawingMLMain.p5);
    }
    static e0(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.qa(a, b.a);
        a.ad.k();
    }
    static e1(a, b) {
        if (b == null) {
            return;
        }
        a.d._t.dl(a);
        DrawingPartManagerHelpers.cp(a, b.a);
        b.d.q((c) => DrawingPartManagerHelpers.d9(a, c));
        a.ad.k();
    }
    static e3(a, b, c) {
        if (b == null) {
            return;
        }
        c(a, b.d(), b.g(), b.h());
        DrawingPartManagerHelpers.d8(a, b.a);
        DrawingPartManagerHelpers.c8(a, b.b);
        a.ad.k();
    }
    static e2(a, b) {
        if (b == null) {
            return;
        }
        DrawingMLMain.qb(a, b.d(), b.g(), b.h());
        DrawingPartManagerHelpers.d8(a, b.a);
        DrawingPartManagerHelpers.c8(a, b.b);
        DrawingPartManagerHelpers.cr(a, b.l);
        DrawingPartManagerHelpers.cq(a, b.m);
        a.ad.k();
    }
}
DrawingPartManagerHelpers.$t = markType(DrawingPartManagerHelpers, 'DrawingPartManagerHelpers');
/**
 * @hidden
 */
export class DrawingPartManagerHelpers_DrawingSerializationHelper extends Base {
    constructor() {
        super();
    }
    _visitCT_SchemeColor$i(a, b) {
        DrawingPartManagerHelpers.en(b, a);
        return true;
    }
    _visitCT_SRgbColor$i(a, b) {
        DrawingPartManagerHelpers.eu(b, a);
        return true;
    }
    _visitCT_SysColor$i(a, b) {
        DrawingPartManagerHelpers.ey(b, a);
        return true;
    }
    _visitCT_PresetColor$i(a, b) {
        DrawingPartManagerHelpers.ed(b, a);
        return true;
    }
    _visitColorTransform_Alpha$i(a, b) {
        DrawingPartManagerHelpers.cf(b, a);
        return false;
    }
    _visitColorTransform_AlphaMod$i(a, b) {
        DrawingPartManagerHelpers.cg(b, a);
        return false;
    }
    _visitColorTransform_AlphaOff$i(a, b) {
        DrawingPartManagerHelpers.ch(b, a);
        return false;
    }
    _visitColorTransform_Blue$i(a, b) {
        DrawingPartManagerHelpers.cm(b, a);
        return false;
    }
    _visitColorTransform_BlueMod$i(a, b) {
        DrawingPartManagerHelpers.cn(b, a);
        return false;
    }
    _visitColorTransform_BlueOff$i(a, b) {
        DrawingPartManagerHelpers.co(b, a);
        return false;
    }
    _visitColorTransform_Comp$i(a, b) {
        DrawingPartManagerHelpers.cy(b, a);
        return false;
    }
    _visitColorTransform_Gray$i(a, b) {
        DrawingPartManagerHelpers.dj(b, a);
        return false;
    }
    _visitColorTransform_Green$i(a, b) {
        DrawingPartManagerHelpers.dk(b, a);
        return false;
    }
    _visitColorTransform_GreenMod$i(a, b) {
        DrawingPartManagerHelpers.dl(b, a);
        return false;
    }
    _visitColorTransform_GreenOff$i(a, b) {
        DrawingPartManagerHelpers.dm(b, a);
        return false;
    }
    _visitColorTransform_Hue$i(a, b) {
        DrawingPartManagerHelpers.ds(b, a);
        return false;
    }
    _visitColorTransform_HueMod$i(a, b) {
        DrawingPartManagerHelpers.dt(b, a);
        return false;
    }
    _visitColorTransform_HueOff$i(a, b) {
        DrawingPartManagerHelpers.du(b, a);
        return false;
    }
    _visitColorTransform_Inv$i(a, b) {
        DrawingPartManagerHelpers.dv(b, a);
        return false;
    }
    _visitColorTransform_Lum$i(a, b) {
        DrawingPartManagerHelpers.dz(b, a);
        return false;
    }
    _visitColorTransform_LumMod$i(a, b) {
        DrawingPartManagerHelpers.d0(b, a);
        return false;
    }
    _visitColorTransform_LumOff$i(a, b) {
        DrawingPartManagerHelpers.d1(b, a);
        return false;
    }
    _visitColorTransform_Red$i(a, b) {
        DrawingPartManagerHelpers.ef(b, a);
        return false;
    }
    _visitColorTransform_RedMod$i(a, b) {
        DrawingPartManagerHelpers.eg(b, a);
        return false;
    }
    _visitColorTransform_RedOff$i(a, b) {
        DrawingPartManagerHelpers.eh(b, a);
        return false;
    }
    _visitColorTransform_Sat$i(a, b) {
        DrawingPartManagerHelpers.ek(b, a);
        return false;
    }
    _visitColorTransform_SatMod$i(a, b) {
        DrawingPartManagerHelpers.el(b, a);
        return false;
    }
    _visitColorTransform_SatOff$i(a, b) {
        DrawingPartManagerHelpers.em(b, a);
        return false;
    }
    _visitColorTransform_Shade$i(a, b) {
        DrawingPartManagerHelpers.eo(b, a);
        return false;
    }
    _visitColorTransform_Tint$i(a, b) {
        DrawingPartManagerHelpers.e0(b, a);
        return false;
    }
    _visitCT_StretchInfoProperties$i(a, b) {
        DrawingPartManagerHelpers.ew(b, a);
        return true;
    }
    _visitCT_TileInfoProperties$i(a, b) {
        return true;
    }
    _visitCT_BlipFillProperties$i(a, b) {
        DrawingPartManagerHelpers.cl(b, a);
        return true;
    }
    _visitCT_GroupFillProperties$i(a, b) {
        return true;
    }
    _visitCT_NoFillProperties$i(a, b) {
        DrawingPartManagerHelpers.d2(b, a);
        return true;
    }
    _visitCT_SolidFillProperties$i(a, b) {
        DrawingPartManagerHelpers.ep(b, a);
        return true;
    }
    _visitCT_PresetGeometry2D$i(a, b) {
        DrawingPartManagerHelpers.ee(b, a);
        return true;
    }
    _visitCT_CustomGeometry2D$i(a, b) {
        DrawingPartManagerHelpers.c2(b, a);
        return true;
    }
    _visitCT_DashStopList$i(a, b) {
        return true;
    }
    _visitCT_PresetLineDashProperties$i(a, b) {
        return true;
    }
    _visitCT_NoFillProperties1$i(a, b) {
        DrawingPartManagerHelpers.d2(b, a);
        return true;
    }
    _visitCT_SolidFillProperties1$i(a, b) {
        DrawingPartManagerHelpers.ep(b, a);
        return true;
    }
    _visitCT_LineJoinBevel$i(a, b) {
        return true;
    }
    _visitCT_LineJoinMiterProperties$i(a, b) {
        return true;
    }
    _visitCT_LineJoinRound$i(a, b) {
        return true;
    }
    _visitCT_RegularTextRun$i(a, b) {
        DrawingPartManagerHelpers.ei(b, a);
        return true;
    }
    _visitAlternateGraphicalObjectContent$i(a, b) {
        DrawingPartManagerHelpers.ci(b, a);
        return true;
    }
    _visitCT_Connector$i(a, b) {
        DrawingPartManagerHelpers.c3(b, a);
        return true;
    }
    _visitCT_GraphicalObjectFrame$i(a, b) {
        DrawingPartManagerHelpers.dh(b, a);
        return true;
    }
    _visitCT_GroupShape$i(a, b) {
        DrawingPartManagerHelpers.dn(b, a);
        return true;
    }
    _visitCT_Picture$i(a, b) {
        DrawingPartManagerHelpers.ea(b, a);
        return true;
    }
    _visitCT_Shape$i(a, b) {
        DrawingPartManagerHelpers.eq(b, a);
        return true;
    }
}
DrawingPartManagerHelpers_DrawingSerializationHelper.$t = markType(DrawingPartManagerHelpers_DrawingSerializationHelper, 'DrawingPartManagerHelpers_DrawingSerializationHelper', Base.$, [IEG_ColorChoiceVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_ColorTransformVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_FillModePropertiesVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_FillPropertiesVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_GeometryVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_LineDashPropertiesVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_LineFillPropertiesVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_LineJoinPropertiesVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IEG_TextRunVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type), IGraphicalObjectContentVisitor$2_$type.specialize(XmlPartManagerBase.$, Boolean_$type)]);
DrawingPartManagerHelpers_DrawingSerializationHelper.a = new DrawingPartManagerHelpers_DrawingSerializationHelper();
/**
 * @hidden
 */
export class EmfPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.emf";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.emf";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.emf";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/x-emf";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.c;
    }
}
EmfPartManager.$t = markType(EmfPartManager, 'EmfPartManager', ImagePartManagerBase.$);
EmfPartManager.y = new EmfPartManager();
/**
 * @hidden
 */
export class ExtendedPropertiesPartManager extends XmlPartManagerBase {
    get_m() {
        return ExtendedPropertiesPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        return "/docProps/app.xml";
    }
    o(a) {
        switch (a) {
            case 0: return ExtendedPropertiesPartManager.a5;
            case 1: return ExtendedPropertiesPartManager.a4;
            default: return ExtendedPropertiesPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
ExtendedPropertiesPartManager.$t = markType(ExtendedPropertiesPartManager, 'ExtendedPropertiesPartManager', XmlPartManagerBase.$);
ExtendedPropertiesPartManager.a2 = "application/vnd.openxmlformats-officedocument.extended-properties+xml";
ExtendedPropertiesPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";
ExtendedPropertiesPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/extendedProperties";
/**
 * @hidden
 */
export class OfficeExtensibilityPartManagerBase extends XmlPartManagerBase {
    get_m() {
        return "application/xml";
    }
    get m() {
        return this.get_m();
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
    f(a, b) {
        let c = PackageUtilities.ak(b);
        return new RoundTripDataPartManager(a.contentType, c.toString(), b.relationshipType, this.d);
    }
    a() {
        let a = RoundTripDataPartManager.r(this.d, this.l, this.m);
        this.a2 = a;
        return WorkItem.g(Base.$, a);
    }
    b(a) {
        let b = this.a2;
        if (b == null) {
            return null;
        }
        return RoundTripDataPartManager.s(b, this.d, this.l, true);
    }
    u(a) {
        throw new NotImplementedException(0);
    }
}
OfficeExtensibilityPartManagerBase.$t = markType(OfficeExtensibilityPartManagerBase, 'OfficeExtensibilityPartManagerBase', XmlPartManagerBase.$);
/**
 * @hidden
 */
export class Office2007ExtensibilityPartManager extends OfficeExtensibilityPartManagerBase {
    constructor() {
        super();
    }
    get_a2() {
        return this.d._h;
    }
    set_a2(a) {
        this.d._h = a;
    }
    get a2() {
        return this.get_a2();
    }
    set a2(a) {
        this.set_a2(a);
    }
    n(a) {
        return "/customUI/customUI.xml";
    }
    o(a) {
        switch (a) {
            case 0:
            case 1: return Office2007ExtensibilityPartManager.a6;
            default: return Office2007ExtensibilityPartManager.a6;
        }
    }
}
Office2007ExtensibilityPartManager.$t = markType(Office2007ExtensibilityPartManager, 'Office2007ExtensibilityPartManager', OfficeExtensibilityPartManagerBase.$);
Office2007ExtensibilityPartManager.a6 = "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility";
Office2007ExtensibilityPartManager.a4 = new Office2007ExtensibilityPartManager();
/**
 * @hidden
 */
export class Office2010ExtensibilityPartManager extends OfficeExtensibilityPartManagerBase {
    constructor() {
        super();
    }
    get_a2() {
        return this.d._i;
    }
    set_a2(a) {
        this.d._i = a;
    }
    get a2() {
        return this.get_a2();
    }
    set a2(a) {
        this.set_a2(a);
    }
    n(a) {
        return "/customUI/customUI14.xml";
    }
    o(a) {
        switch (a) {
            case 0:
            case 1: return Office2010ExtensibilityPartManager.a6;
            default: return Office2010ExtensibilityPartManager.a6;
        }
    }
}
Office2010ExtensibilityPartManager.$t = markType(Office2010ExtensibilityPartManager, 'Office2010ExtensibilityPartManager', OfficeExtensibilityPartManagerBase.$);
Office2010ExtensibilityPartManager.a6 = "http://schemas.microsoft.com/office/2007/relationships/ui/extensibility";
Office2010ExtensibilityPartManager.a4 = new Office2010ExtensibilityPartManager();
/**
 * @hidden
 */
export class GifPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.gif";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.gif";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.gif";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/gif";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.e;
    }
}
GifPartManager.$t = markType(GifPartManager, 'GifPartManager', ImagePartManagerBase.$);
GifPartManager.y = new GifPartManager();
/**
 * @hidden
 */
export class JpegPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.jpeg";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.jpeg";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.jpeg";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/jpeg";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.f;
    }
}
JpegPartManager.$t = markType(JpegPartManager, 'JpegPartManager', ImagePartManagerBase.$);
JpegPartManager.y = new JpegPartManager();
/**
 * @hidden
 */
export class PngPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.png";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.png";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.png";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/png";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.g;
    }
}
PngPartManager.$t = markType(PngPartManager, 'PngPartManager', ImagePartManagerBase.$);
PngPartManager.y = new PngPartManager();
/**
 * @hidden
 */
export class PrinterSettingsPartManager extends XmlPartManagerBase {
    n(a) {
        switch (a) {
            case 0: return "/xl" + "/printerSettings/printerSettings.bin";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return PrinterSettingsPartManager.a6;
            case 1: return PrinterSettingsPartManager.a5;
            default: return PrinterSettingsPartManager.a6;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    u(a) {
        throw new InvalidOperationException(0);
    }
}
PrinterSettingsPartManager.$t = markType(PrinterSettingsPartManager, 'PrinterSettingsPartManager', XmlPartManagerBase.$);
PrinterSettingsPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings";
PrinterSettingsPartManager.a4 = "application/vnd.openxmlformats-officedocument.wordprocessingml.printerSettings";
PrinterSettingsPartManager.a6 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/printerSettings";
PrinterSettingsPartManager.a5 = "http://purl.oclc.org/ooxml/officeDocument/relationships/printerSettings";
/**
 * @hidden
 */
export class RoundTripDataPartManager extends PartManagerBase {
    constructor(a, b, c, d) {
        super();
        this.u = null;
        this.v = null;
        this.w = null;
        this.t = null;
        this.u = a;
        this.v = b;
        this.w = c;
        this.t = d;
    }
    a() {
        return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
    }
    b(a) {
        let b = typeCast(BinaryData.$, a);
        if (b == null) {
            return null;
        }
        this.l.write(b.a, 0, b.a.length);
        return null;
    }
    n(a) {
        return this.v;
    }
    o(a) {
        return this.t._a7(a, this.w);
    }
    get_m() {
        return this.u;
    }
    get m() {
        return this.get_m();
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
    static r(a, b, c) {
        let d = new RoundTripControlData(c, a._d.uri.toString(), DocCoreUtils.c(b));
        for (let e of fromEnum(a._d.getRelationships())) {
            if (e.targetMode != 0) {
                continue;
            }
            let f = typeCast(BinaryData.$, a._as(e));
            if (f == null) {
                continue;
            }
            let g = PackageUtilities.ak(e);
            let h = a._e(g);
            let i = PackageUtilities.ak(e).toString();
            d.c.add(((() => {
                let $ret = new RoundTripPartData();
                $ret.b = h.contentType;
                $ret.d = e.id;
                $ret.a = f;
                $ret.e = e.relationshipType;
                $ret.c = g.toString();
                return $ret;
            })()));
        }
        return d;
    }
    static s(a, b, c, d = false) {
        return WorkItemExtensions.a(Async.d(RoundTripPartData.$, a.c, (e) => {
            if (d) {
                let f = (((g) => g != null ? g : e.e)(b._a7(b._z, e.e)));
                let g = new RoundTripDataPartManager(e.b, e.c, f, b);
                return b._j(g, e.a, e.d);
            }
            return WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), b._l(e.b, e.c, e.a, e.d), (h) => {
            });
        }), () => c.write(a.a, 0, a.a.length));
    }
}
RoundTripDataPartManager.$t = markType(RoundTripDataPartManager, 'RoundTripDataPartManager', PartManagerBase.$);
/**
 * @hidden
 */
export class ThemeManagerPartManager extends XmlPartManagerBase {
    get_m() {
        return ThemeManagerPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0:
            case 1: return "/theme/theme/themeManager.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ThemeManagerPartManager.a5;
            case 1: return ThemeManagerPartManager.a4;
            default: return ThemeManagerPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
ThemeManagerPartManager.$t = markType(ThemeManagerPartManager, 'ThemeManagerPartManager', XmlPartManagerBase.$);
ThemeManagerPartManager.a2 = "application/vnd.openxmlformats-officedocument.themeManager+xml";
ThemeManagerPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument";
ThemeManagerPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument";
/**
 * @hidden
 */
export class ThemePartManager extends XmlPartManagerBase {
    constructor(a) {
        super();
        this.a2 = false;
        this.a2 = a;
    }
    get_m() {
        return ThemePartManager.a6;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        if (this.a2) {
            switch (a) {
                case 0: return "/theme/theme/theme.xml";
                case 1: return "/theme/theme/theme.xml";
                default: return null;
            }
        }
        else {
            switch (a) {
                case 0: return "/xl/theme/theme.xml";
                case 1: return "/word/theme/theme.xml";
                default: return null;
            }
        }
    }
    o(a) {
        switch (a) {
            case 0: return ThemePartManager.a8;
            case 1: return ThemePartManager.a7;
            default: return ThemePartManager.a8;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
    a() {
        this.d._af = true;
        return super.a();
    }
}
ThemePartManager.$t = markType(ThemePartManager, 'ThemePartManager', XmlPartManagerBase.$);
ThemePartManager.a6 = "application/vnd.openxmlformats-officedocument.theme+xml";
ThemePartManager.a8 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
ThemePartManager.a7 = "http://purl.oclc.org/ooxml/officeDocument/relationships/theme";
/**
 * @hidden
 */
export class TiffPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.tiff";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.tiff";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.tiff";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/tiff";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.h;
    }
}
TiffPartManager.$t = markType(TiffPartManager, 'TiffPartManager', ImagePartManagerBase.$);
TiffPartManager.y = new TiffPartManager();
/**
 * @hidden
 */
export class VbaProjectPartManager extends PartManagerBase {
    get_m() {
        return "application/vnd.ms-office.vbaProject";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/vbaProject.bin";
            case 1: return "/word/vbaProject.bin";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return VbaProjectPartManager.u;
            case 1: return VbaProjectPartManager.u;
            default: return VbaProjectPartManager.u;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
VbaProjectPartManager.$t = markType(VbaProjectPartManager, 'VbaProjectPartManager', PartManagerBase.$);
VbaProjectPartManager.u = "http://schemas.microsoft.com/office/2006/relationships/vbaProject";
/**
 * @hidden
 */
export class VmlDrawingPartManager extends XmlPartManagerBase {
    constructor(a) {
        super();
        this.a2 = false;
        this.a2 = a;
    }
    get_m() {
        return VmlDrawingPartManager.a6;
    }
    get m() {
        return this.get_m();
    }
    a0() {
        return ((() => {
            let $ret = new SgmlReader();
            $ret._b7 = new StreamReader(this.l);
            return $ret;
        })());
    }
    n(a) {
        if (this.a2) {
            switch (a) {
                case 1: return "/theme/drawings/vmlDrawing.vml";
                default: return null;
            }
        }
        else {
            switch (a) {
                case 0: return "/xl/drawings/vmlDrawing.vml";
                case 1: return "/word/drawings/vmlDrawing.vml";
                default: return null;
            }
        }
    }
    o(a) {
        switch (a) {
            case 0:
            case 1: return VmlDrawingPartManager.a7;
            default: return VmlDrawingPartManager.a7;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
VmlDrawingPartManager.$t = markType(VmlDrawingPartManager, 'VmlDrawingPartManager', XmlPartManagerBase.$);
VmlDrawingPartManager.a6 = "application/vnd.openxmlformats-officedocument.vmlDrawing";
VmlDrawingPartManager.a7 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing";
/**
 * @hidden
 */
export class WmfPartManager extends ImagePartManagerBase {
    constructor() {
        super();
    }
    get_s() {
        return "/xl/media/image.wmf";
    }
    get s() {
        return this.get_s();
    }
    get_t() {
        return "/ppt/media/image.wmf";
    }
    get t() {
        return this.get_t();
    }
    get_u() {
        return "/word/media/image.wmf";
    }
    get u() {
        return this.get_u();
    }
    get_m() {
        return "image/x-wmf";
    }
    get m() {
        return this.get_m();
    }
    r(a) {
        return ImageFormat.i;
    }
}
WmfPartManager.$t = markType(WmfPartManager, 'WmfPartManager', ImagePartManagerBase.$);
WmfPartManager.y = new WmfPartManager();
/**
 * @hidden
 */
export class XmlNamespaceDefinitionBase extends Base {
    static k(a, b) {
    }
    static g($t, a, b, c) {
        if (c == false && EqualityComparer$1.defaultEqualityComparerValue($t).equalsC(a, b)) {
            return null;
        }
        return XmlNamespaceDefinitionBase.f($t, a);
    }
    static f($t, value_) {
        let a = $t;
        if (a == ST_FillMethod_$type && Base.equalsStatic(getBoxIfEnum($t, value_), enumGetBox(ST_FillMethod_$type, 4))) {
            return "linear sigma";
        }
        let b = stringToString$1($t, value_);
        if (b.charAt(0) == '_') {
            return b.substr(1);
        }
        return b;
    }
    static h(a) {
        let b = a.lastIndexOf('/');
        if (b < 0) {
            return a;
        }
        return a.substr(b + 1);
    }
    static b($t, a, b = Type.createInstance($t)) {
        if (stringIsNullOrEmpty(a)) {
            return b;
        }
        let c = false;
        switch (a) {
            case "continue":
            case "decimal":
            case "default":
            case "double":
            case "fixed":
            case "long":
            case "short":
            case "base":
                c = true;
                break;
            case "linear sigma":
                a = EnumUtil.getName(ST_FillMethod_$type, 4);
                break;
            default:
                if ('0'.charCodeAt(0) <= a.charAt(0).charCodeAt(0) && a.charAt(0).charCodeAt(0) <= '9'.charCodeAt(0)) {
                    c = true;
                }
                break;
        }
        let d;
        if (c == false && ((() => { let e = EnumUtil.tryParse$1($t, a, false, d); d = e.p2; return e.ret; })())) {
            return d;
        }
        if (((() => { let e = EnumUtil.tryParse$1($t, "_" + a, false, d); d = e.p2; return e.ret; })())) {
            return d;
        }
        return b;
    }
    static c($t, a, b, c) {
        if (stringIsNullOrEmpty(a.d)) {
            return b;
        }
        return c(a.d);
    }
    static e($t, a, b) {
        let c = new List$1($t, 0);
        let d = -1;
        for (let e = 0; e < a.length; e++) {
            switch (a.charAt(e)) {
                case ' ':
                case '\t':
                case '\r':
                case '\n':
                    if (d != -1) {
                        c.add(b(a.substr(d, e - d)));
                        d = -1;
                    }
                    break;
                default:
                    if (d == -1) {
                        d = e;
                    }
                    break;
            }
        }
        if (d != -1) {
            c.add(b(a.substr(d)));
        }
        return c;
    }
    static l(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        if (((() => { let e = tryParseBool(a.ab.ad, c); c = e.p1; return e.ret; })()) == false) {
            c = ST_OnOff.e(a.ab.ad);
        }
        return {
            p2: c
        };
    }
    static z(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString().toLowerCase());
    }
    static m(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseInt8_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static aa(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static n(a, b, c) {
        let d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case XmlSchemaInstance.aq:
                    d = a.ab.ag(e.d);
                    break;
                default: break;
            }
        }
        c = PackageUtilities.i(a.ab.ad);
        return {
            p2: c
        };
    }
    static ab(a, b, c, d) {
        a.ad.p(b, c);
        let e = new QualifiedNameInfo(1, DcTerms.an.j, DcTerms.an.i(a.d._z), XmlNamespaceDefinitionBase.h("http://purl.org/dc/terms/W3CDTF"));
        a.ad.h(XmlSchemaInstance.aq, e.toString());
        a.ad.u(PackageUtilities.k(d));
    }
    static o(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ac(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(numberToString(d, CultureInfo.invariantCulture));
    }
    static p(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ad(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(numberToString(d, CultureInfo.invariantCulture));
    }
    static q(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ae(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(numberToString(d, CultureInfo.invariantCulture));
    }
    static r(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseInt32_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static af(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static s(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseInt64_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ag(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static t(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseInt16_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ah(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static d(a) {
        switch (a) {
            case ' ':
            case '\r':
            case '\n':
            case '\t': return true;
            default: return false;
        }
    }
    static u(a, b, c, d = 0) {
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case XmlNamespace.ar:
                    if (e.d == "preserve") {
                        d = 6;
                    }
                    break;
                default: break;
            }
        }
        c = a.ab.ad;
        if (c != null) {
            if ((d & 2) == 0) {
                c = trimStart(c, ...XmlNamespaceDefinitionBase.a);
            }
            if ((d & 4) == 0 && stringIsNullOrWhiteSpace(c) == false) {
                c = trimEnd(c, ...XmlNamespaceDefinitionBase.a);
            }
        }
        return {
            p2: c
        };
    }
    static ai(a, b, c, d, e = null, f = 0) {
        a.ad.p(b, c);
        if (f != 6) {
            if (stringIsNullOrEmpty(d) == false) {
                if ((XmlNamespaceDefinitionBase.d(d.charAt(0)) && (f & 2) == 0) || (XmlNamespaceDefinitionBase.d(d.charAt(d.length - 1)) && (f & 4) == 0)) {
                    XmlNamespace.as(a.ad);
                }
            }
        }
        if (e != null) {
            e();
        }
        a.ad.u(d);
    }
    static v(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseUInt8_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static aj(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static w(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseUInt32_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static ak(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static x(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseUInt64_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static al(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
    static y(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = parseUInt16_1(a.ab.ad, CultureInfo.invariantCulture);
        return {
            p2: c
        };
    }
    static am(a, b, c, d) {
        a.ad.p(b, c);
        a.ad.u(d.toString());
    }
}
XmlNamespaceDefinitionBase.$t = markType(XmlNamespaceDefinitionBase, 'XmlNamespaceDefinitionBase');
XmlNamespaceDefinitionBase.a = [' ', '\r', '\n', '\t'];
/**
 * @hidden
 */
export class CoreProperties extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return CoreProperties.au;
            default: return CoreProperties.au;
        }
    }
    get_j() {
        return "cp";
    }
    get j() {
        return this.get_j();
    }
    static ax(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, CoreProperties.ap, b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a4(a, b) {
        XmlNamespaceDefinitionBase.ai(a, CoreProperties.ap, "cp", b, void 0, 6);
    }
    static ay(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, CoreProperties.aq, b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a5(a, b) {
        XmlNamespaceDefinitionBase.ai(a, CoreProperties.aq, "cp", b, void 0, 6);
    }
    static az(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static a6(a) {
        a.ad.p(CoreProperties.ar, "cp");
        let b = a.d._z;
        a.ad.l(CoreProperties.an);
        a.ad.l(DcElements.an);
        a.ad.l(DcTerms.an);
        a.ad.l(DcDcmiType.an);
        a.ad.l(XmlSchemaInstance.an);
    }
    static a0(a, b, c) {
        b = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case XmlNamespace.ap:
                    b = d.d;
                    break;
                default: break;
            }
        }
        c = a.ab.ad;
        return {
            p1: b,
            p2: c
        };
    }
    static a7(a, b, c) {
        a.ad.p(CoreProperties.as, "cp");
        let d;
        d = b;
        a.ad.h(XmlNamespace.ap, d);
        a.ad.u(c);
    }
    static a1(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, CoreProperties.at, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a8(a, b) {
        XmlNamespaceDefinitionBase.ai(a, CoreProperties.at, "cp", b);
    }
    static a2(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, CoreProperties.av, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a9(a, b) {
        XmlNamespaceDefinitionBase.ai(a, CoreProperties.av, "cp", b);
    }
    static a3(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, CoreProperties.aw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ba(a, b) {
        XmlNamespaceDefinitionBase.ai(a, CoreProperties.aw, "cp", b);
    }
}
CoreProperties.$t = markType(CoreProperties, 'CoreProperties', XmlNamespaceDefinitionBase.$);
CoreProperties.au = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties";
CoreProperties.ap = CoreProperties.au + "/category";
CoreProperties.aq = CoreProperties.au + "/contentStatus";
CoreProperties.ar = CoreProperties.au + "/coreProperties";
CoreProperties.as = CoreProperties.au + "/keywords";
CoreProperties.at = CoreProperties.au + "/lastModifiedBy";
CoreProperties.av = CoreProperties.au + "/revision";
CoreProperties.aw = CoreProperties.au + "/version";
CoreProperties.an = new CoreProperties();
/**
 * @hidden
 */
export class DcDcmiType extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "http://purl.org/dc/dcmitype/";
            default: return "http://purl.org/dc/dcmitype/";
        }
    }
    get_j() {
        return "dcmitype";
    }
    get j() {
        return this.get_j();
    }
}
DcDcmiType.$t = markType(DcDcmiType, 'DcDcmiType', XmlNamespaceDefinitionBase.$);
DcDcmiType.an = new DcDcmiType();
/**
 * @hidden
 */
export class DcElements extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "http://purl.org/dc/elements/1.1/";
            default: return "http://purl.org/dc/elements/1.1/";
        }
    }
    get_j() {
        return "dc";
    }
    get j() {
        return this.get_j();
    }
    static au(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/creator", b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ay(a, b) {
        XmlNamespaceDefinitionBase.ai(a, "http://purl.org/dc/elements/1.1/creator", "dc", b);
    }
    static av(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, DcElements.aq, b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static az(a, b) {
        XmlNamespaceDefinitionBase.ai(a, DcElements.aq, "dc", b, void 0, 6);
    }
    static aw(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/subject", b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a0(a, b) {
        XmlNamespaceDefinitionBase.ai(a, "http://purl.org/dc/elements/1.1/subject", "dc", b, void 0, 6);
    }
    static ax(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/title", b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static a1(a, b) {
        XmlNamespaceDefinitionBase.ai(a, "http://purl.org/dc/elements/1.1/title", "dc", b, void 0, 6);
    }
}
DcElements.$t = markType(DcElements, 'DcElements', XmlNamespaceDefinitionBase.$);
DcElements.aq = "http://purl.org/dc/elements/1.1/" + "description";
DcElements.an = new DcElements();
/**
 * @hidden
 */
export class DcTerms extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "http://purl.org/dc/terms/";
            default: return "http://purl.org/dc/terms/";
        }
    }
    get_j() {
        return "dcterms";
    }
    get j() {
        return this.get_j();
    }
    static at(a, b) {
        let c = XmlNamespaceDefinitionBase.n(a, "http://purl.org/dc/terms/created", b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static av(a, b) {
        XmlNamespaceDefinitionBase.ab(a, "http://purl.org/dc/terms/created", "dcterms", b);
    }
    static au(a, b) {
        let c = XmlNamespaceDefinitionBase.n(a, "http://purl.org/dc/terms/modified", b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aw(a, b) {
        XmlNamespaceDefinitionBase.ab(a, "http://purl.org/dc/terms/modified", "dcterms", b);
    }
}
DcTerms.$t = markType(DcTerms, 'DcTerms', XmlNamespaceDefinitionBase.$);
DcTerms.an = new DcTerms();
/**
 * @hidden
 */
export class Drawing2010Main extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return Drawing2010Main.ap;
            default: return Drawing2010Main.ap;
        }
    }
    get_j() {
        return "a14";
    }
    get j() {
        return this.get_j();
    }
}
Drawing2010Main.$t = markType(Drawing2010Main, 'Drawing2010Main', XmlNamespaceDefinitionBase.$);
Drawing2010Main.ap = "http://schemas.microsoft.com/office/drawing/2010/main";
Drawing2010Main.an = new Drawing2010Main();
/**
 * @hidden
 */
export class Drawing2010Slicer extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return Drawing2010Slicer.ar;
            default: return Drawing2010Slicer.ar;
        }
    }
    get_j() {
        return "sle";
    }
    get j() {
        return this.get_j();
    }
    static at(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static au(a, b) {
        a.ad.p(Drawing2010Slicer.as, "sle");
        let c;
        c = b;
        a.ad.h("name", c);
    }
}
Drawing2010Slicer.$t = markType(Drawing2010Slicer, 'Drawing2010Slicer', XmlNamespaceDefinitionBase.$);
Drawing2010Slicer.ar = "http://schemas.microsoft.com/office/drawing/2010/slicer";
Drawing2010Slicer.as = Drawing2010Slicer.ar + "/slicer";
Drawing2010Slicer.an = new Drawing2010Slicer();
/**
 * @hidden
 */
export class DrawingMLChart extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChart.dx;
            case 1: return DrawingMLChart.dw;
            default: return DrawingMLChart.dx;
        }
    }
    get_j() {
        return "c";
    }
    get j() {
        return this.get_j();
    }
    static gx(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static gy(a, b = null) {
        a.ad.p(DrawingMLChart.be, "c");
        a.ad.l(DrawingMLChart.an);
        a.ad.l(OfficeDocumentRelationships.an);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
}
DrawingMLChart.$t = markType(DrawingMLChart, 'DrawingMLChart', XmlNamespaceDefinitionBase.$);
DrawingMLChart.dx = "http://schemas.openxmlformats.org/drawingml/2006/chart";
DrawingMLChart.dw = "http://purl.oclc.org/ooxml/drawingml/chart";
DrawingMLChart.ap = DrawingMLChart.dw + "/applyToEnd";
DrawingMLChart.aq = DrawingMLChart.dw + "/applyToFront";
DrawingMLChart.ar = DrawingMLChart.dw + "/applyToSides";
DrawingMLChart.as = DrawingMLChart.dw + "/area3DChart";
DrawingMLChart.at = DrawingMLChart.dw + "/areaChart";
DrawingMLChart.au = DrawingMLChart.dw + "/auto";
DrawingMLChart.av = DrawingMLChart.dw + "/autoTitleDeleted";
DrawingMLChart.aw = DrawingMLChart.dw + "/autoUpdate";
DrawingMLChart.ax = DrawingMLChart.dw + "/axId";
DrawingMLChart.ay = DrawingMLChart.dw + "/axPos";
DrawingMLChart.az = DrawingMLChart.dw + "/backWall";
DrawingMLChart.a0 = DrawingMLChart.dw + "/backward";
DrawingMLChart.a1 = DrawingMLChart.dw + "/bandFmt";
DrawingMLChart.a2 = DrawingMLChart.dw + "/bandFmts";
DrawingMLChart.a3 = DrawingMLChart.dw + "/bar3DChart";
DrawingMLChart.a4 = DrawingMLChart.dw + "/barChart";
DrawingMLChart.a5 = DrawingMLChart.dw + "/barDir";
DrawingMLChart.a6 = DrawingMLChart.dw + "/baseTimeUnit";
DrawingMLChart.a7 = DrawingMLChart.dw + "/bubble3D";
DrawingMLChart.a8 = DrawingMLChart.dw + "/bubbleChart";
DrawingMLChart.a9 = DrawingMLChart.dw + "/bubbleScale";
DrawingMLChart.ba = DrawingMLChart.dw + "/bubbleSize";
DrawingMLChart.bb = DrawingMLChart.dw + "/builtInUnit";
DrawingMLChart.bc = DrawingMLChart.dw + "/cat";
DrawingMLChart.bd = DrawingMLChart.dw + "/catAx";
DrawingMLChart.be = DrawingMLChart.dw + "/chart";
DrawingMLChart.bf = DrawingMLChart.dw + "/chartObject";
DrawingMLChart.bg = DrawingMLChart.dw + "/chartSpace";
DrawingMLChart.bh = DrawingMLChart.dw + "/clrMapOvr";
DrawingMLChart.bi = DrawingMLChart.dw + "/crossAx";
DrawingMLChart.bj = DrawingMLChart.dw + "/crossBetween";
DrawingMLChart.bk = DrawingMLChart.dw + "/crosses";
DrawingMLChart.bl = DrawingMLChart.dw + "/crossesAt";
DrawingMLChart.bm = DrawingMLChart.dw + "/custSplit";
DrawingMLChart.bn = DrawingMLChart.dw + "/custUnit";
DrawingMLChart.bo = DrawingMLChart.dw + "/data";
DrawingMLChart.bp = DrawingMLChart.dw + "/date1904";
DrawingMLChart.bq = DrawingMLChart.dw + "/dateAx";
DrawingMLChart.br = DrawingMLChart.dw + "/delete";
DrawingMLChart.bs = DrawingMLChart.dw + "/depthPercent";
DrawingMLChart.bt = DrawingMLChart.dw + "/dispBlanksAs";
DrawingMLChart.bu = DrawingMLChart.dw + "/dispEq";
DrawingMLChart.bv = DrawingMLChart.dw + "/dispRSqr";
DrawingMLChart.bw = DrawingMLChart.dw + "/dispUnits";
DrawingMLChart.bx = DrawingMLChart.dw + "/dispUnitsLbl";
DrawingMLChart.by = DrawingMLChart.dw + "/dLbl";
DrawingMLChart.bz = DrawingMLChart.dw + "/dLblPos";
DrawingMLChart.b0 = DrawingMLChart.dw + "/dLbls";
DrawingMLChart.b1 = DrawingMLChart.dw + "/doughnutChart";
DrawingMLChart.b2 = DrawingMLChart.dw + "/downBars";
DrawingMLChart.b3 = DrawingMLChart.dw + "/dPt";
DrawingMLChart.b4 = DrawingMLChart.dw + "/dropLines";
DrawingMLChart.b5 = DrawingMLChart.dw + "/dTable";
DrawingMLChart.b6 = DrawingMLChart.dw + "/errBars";
DrawingMLChart.b7 = DrawingMLChart.dw + "/errBarType";
DrawingMLChart.b8 = DrawingMLChart.dw + "/errDir";
DrawingMLChart.b9 = DrawingMLChart.dw + "/errValType";
DrawingMLChart.ca = DrawingMLChart.dw + "/evenFooter";
DrawingMLChart.cb = DrawingMLChart.dw + "/evenHeader";
DrawingMLChart.cc = DrawingMLChart.dw + "/explosion";
DrawingMLChart.cd = DrawingMLChart.dw + "/ext";
DrawingMLChart.ce = DrawingMLChart.dw + "/externalData";
DrawingMLChart.cf = DrawingMLChart.dw + "/extLst";
DrawingMLChart.cg = DrawingMLChart.dw + "/f";
DrawingMLChart.ch = DrawingMLChart.dw + "/firstFooter";
DrawingMLChart.ci = DrawingMLChart.dw + "/firstHeader";
DrawingMLChart.cj = DrawingMLChart.dw + "/firstSliceAng";
DrawingMLChart.ck = DrawingMLChart.dw + "/floor";
DrawingMLChart.cl = DrawingMLChart.dw + "/fmtId";
DrawingMLChart.cm = DrawingMLChart.dw + "/formatCode";
DrawingMLChart.cn = DrawingMLChart.dw + "/formatting";
DrawingMLChart.co = DrawingMLChart.dw + "/forward";
DrawingMLChart.cp = DrawingMLChart.dw + "/gapDepth";
DrawingMLChart.cq = DrawingMLChart.dw + "/gapWidth";
DrawingMLChart.cr = DrawingMLChart.dw + "/grouping";
DrawingMLChart.cs = DrawingMLChart.dw + "/h";
DrawingMLChart.ct = DrawingMLChart.dw + "/headerFooter";
DrawingMLChart.cu = DrawingMLChart.dw + "/hiLowLines";
DrawingMLChart.cv = DrawingMLChart.dw + "/hMode";
DrawingMLChart.cw = DrawingMLChart.dw + "/holeSize";
DrawingMLChart.cx = DrawingMLChart.dw + "/hPercent";
DrawingMLChart.cy = DrawingMLChart.dw + "/idx";
DrawingMLChart.cz = DrawingMLChart.dw + "/intercept";
DrawingMLChart.c0 = DrawingMLChart.dw + "/invertIfNegative";
DrawingMLChart.c1 = DrawingMLChart.dw + "/lang";
DrawingMLChart.c2 = DrawingMLChart.dw + "/layout";
DrawingMLChart.c3 = DrawingMLChart.dw + "/layoutTarget";
DrawingMLChart.c4 = DrawingMLChart.dw + "/lblAlgn";
DrawingMLChart.c5 = DrawingMLChart.dw + "/lblOffset";
DrawingMLChart.c6 = DrawingMLChart.dw + "/leaderLines";
DrawingMLChart.c7 = DrawingMLChart.dw + "/legacyDrawingHF";
DrawingMLChart.c8 = DrawingMLChart.dw + "/legend";
DrawingMLChart.c9 = DrawingMLChart.dw + "/legendEntry";
DrawingMLChart.da = DrawingMLChart.dw + "/legendPos";
DrawingMLChart.db = DrawingMLChart.dw + "/line3DChart";
DrawingMLChart.dc = DrawingMLChart.dw + "/lineChart";
DrawingMLChart.dd = DrawingMLChart.dw + "/logBase";
DrawingMLChart.de = DrawingMLChart.dw + "/lvl";
DrawingMLChart.df = DrawingMLChart.dw + "/majorGridlines";
DrawingMLChart.dg = DrawingMLChart.dw + "/majorTickMark";
DrawingMLChart.dh = DrawingMLChart.dw + "/majorTimeUnit";
DrawingMLChart.di = DrawingMLChart.dw + "/majorUnit";
DrawingMLChart.dj = DrawingMLChart.dw + "/manualLayout";
DrawingMLChart.dk = DrawingMLChart.dw + "/marker";
DrawingMLChart.dl = DrawingMLChart.dw + "/max";
DrawingMLChart.dm = DrawingMLChart.dw + "/min";
DrawingMLChart.dn = DrawingMLChart.dw + "/minorGridlines";
DrawingMLChart.dp = DrawingMLChart.dw + "/minorTickMark";
DrawingMLChart.dq = DrawingMLChart.dw + "/minorTimeUnit";
DrawingMLChart.dr = DrawingMLChart.dw + "/minorUnit";
DrawingMLChart.ds = DrawingMLChart.dw + "/minus";
DrawingMLChart.dt = DrawingMLChart.dw + "/multiLvlStrCache";
DrawingMLChart.du = DrawingMLChart.dw + "/multiLvlStrRef";
DrawingMLChart.dv = DrawingMLChart.dw + "/name";
DrawingMLChart.dy = DrawingMLChart.dw + "/noEndCap";
DrawingMLChart.dz = DrawingMLChart.dw + "/noMultiLvlLbl";
DrawingMLChart.d0 = DrawingMLChart.dw + "/numCache";
DrawingMLChart.d1 = DrawingMLChart.dw + "/numFmt";
DrawingMLChart.d2 = DrawingMLChart.dw + "/numLit";
DrawingMLChart.d3 = DrawingMLChart.dw + "/numRef";
DrawingMLChart.d4 = DrawingMLChart.dw + "/oddFooter";
DrawingMLChart.d5 = DrawingMLChart.dw + "/oddHeader";
DrawingMLChart.d6 = DrawingMLChart.dw + "/ofPieChart";
DrawingMLChart.d7 = DrawingMLChart.dw + "/ofPieType";
DrawingMLChart.d8 = DrawingMLChart.dw + "/order";
DrawingMLChart.d9 = DrawingMLChart.dw + "/orientation";
DrawingMLChart.ea = DrawingMLChart.dw + "/overlap";
DrawingMLChart.eb = DrawingMLChart.dw + "/overlay";
DrawingMLChart.ec = DrawingMLChart.dw + "/pageMargins";
DrawingMLChart.ed = DrawingMLChart.dw + "/pageSetup";
DrawingMLChart.ee = DrawingMLChart.dw + "/period";
DrawingMLChart.ef = DrawingMLChart.dw + "/perspective";
DrawingMLChart.eg = DrawingMLChart.dw + "/pictureFormat";
DrawingMLChart.eh = DrawingMLChart.dw + "/pictureOptions";
DrawingMLChart.ei = DrawingMLChart.dw + "/pictureStackUnit";
DrawingMLChart.ej = DrawingMLChart.dw + "/pie3DChart";
DrawingMLChart.ek = DrawingMLChart.dw + "/pieChart";
DrawingMLChart.el = DrawingMLChart.dw + "/pivotFmt";
DrawingMLChart.em = DrawingMLChart.dw + "/pivotFmts";
DrawingMLChart.en = DrawingMLChart.dw + "/pivotSource";
DrawingMLChart.eo = DrawingMLChart.dw + "/plotArea";
DrawingMLChart.ep = DrawingMLChart.dw + "/plotVisOnly";
DrawingMLChart.eq = DrawingMLChart.dw + "/plus";
DrawingMLChart.er = DrawingMLChart.dw + "/printSettings";
DrawingMLChart.es = DrawingMLChart.dw + "/protection";
DrawingMLChart.et = DrawingMLChart.dw + "/pt";
DrawingMLChart.eu = DrawingMLChart.dw + "/ptCount";
DrawingMLChart.ev = DrawingMLChart.dw + "/radarChart";
DrawingMLChart.ew = DrawingMLChart.dw + "/radarStyle";
DrawingMLChart.ex = DrawingMLChart.dw + "/rAngAx";
DrawingMLChart.ey = DrawingMLChart.dw + "/rich";
DrawingMLChart.ez = DrawingMLChart.dw + "/rotX";
DrawingMLChart.e0 = DrawingMLChart.dw + "/rotY";
DrawingMLChart.e1 = DrawingMLChart.dw + "/roundedCorners";
DrawingMLChart.e2 = DrawingMLChart.dw + "/scaling";
DrawingMLChart.e3 = DrawingMLChart.dw + "/scatterChart";
DrawingMLChart.e4 = DrawingMLChart.dw + "/scatterStyle";
DrawingMLChart.e5 = DrawingMLChart.dw + "/secondPiePt";
DrawingMLChart.e6 = DrawingMLChart.dw + "/secondPieSize";
DrawingMLChart.e7 = DrawingMLChart.dw + "/selection";
DrawingMLChart.e8 = DrawingMLChart.dw + "/separator";
DrawingMLChart.e9 = DrawingMLChart.dw + "/ser";
DrawingMLChart.fa = DrawingMLChart.dw + "/serAx";
DrawingMLChart.fb = DrawingMLChart.dw + "/serLines";
DrawingMLChart.fc = DrawingMLChart.dw + "/shape";
DrawingMLChart.fd = DrawingMLChart.dw + "/showBubbleSize";
DrawingMLChart.fe = DrawingMLChart.dw + "/showCatName";
DrawingMLChart.ff = DrawingMLChart.dw + "/showDLblsOverMax";
DrawingMLChart.fg = DrawingMLChart.dw + "/showHorzBorder";
DrawingMLChart.fh = DrawingMLChart.dw + "/showKeys";
DrawingMLChart.fi = DrawingMLChart.dw + "/showLeaderLines";
DrawingMLChart.fj = DrawingMLChart.dw + "/showLegendKey";
DrawingMLChart.fk = DrawingMLChart.dw + "/showNegBubbles";
DrawingMLChart.fl = DrawingMLChart.dw + "/showOutline";
DrawingMLChart.fm = DrawingMLChart.dw + "/showPercent";
DrawingMLChart.fn = DrawingMLChart.dw + "/showSerName";
DrawingMLChart.fo = DrawingMLChart.dw + "/showVal";
DrawingMLChart.fp = DrawingMLChart.dw + "/showVertBorder";
DrawingMLChart.fq = DrawingMLChart.dw + "/sideWall";
DrawingMLChart.fr = DrawingMLChart.dw + "/size";
DrawingMLChart.fs = DrawingMLChart.dw + "/sizeRepresents";
DrawingMLChart.ft = DrawingMLChart.dw + "/smooth";
DrawingMLChart.fu = DrawingMLChart.dw + "/splitPos";
DrawingMLChart.fv = DrawingMLChart.dw + "/splitType";
DrawingMLChart.fw = DrawingMLChart.dw + "/spPr";
DrawingMLChart.fx = DrawingMLChart.dw + "/stockChart";
DrawingMLChart.fy = DrawingMLChart.dw + "/strCache";
DrawingMLChart.fz = DrawingMLChart.dw + "/strLit";
DrawingMLChart.f0 = DrawingMLChart.dw + "/strRef";
DrawingMLChart.f1 = DrawingMLChart.dw + "/style";
DrawingMLChart.f2 = DrawingMLChart.dw + "/surface3DChart";
DrawingMLChart.f3 = DrawingMLChart.dw + "/surfaceChart";
DrawingMLChart.f4 = DrawingMLChart.dw + "/symbol";
DrawingMLChart.f5 = DrawingMLChart.dw + "/thickness";
DrawingMLChart.f6 = DrawingMLChart.dw + "/tickLblPos";
DrawingMLChart.f7 = DrawingMLChart.dw + "/tickLblSkip";
DrawingMLChart.f8 = DrawingMLChart.dw + "/tickMarkSkip";
DrawingMLChart.f9 = DrawingMLChart.dw + "/title";
DrawingMLChart.ga = DrawingMLChart.dw + "/trendline";
DrawingMLChart.gb = DrawingMLChart.dw + "/trendlineLbl";
DrawingMLChart.gc = DrawingMLChart.dw + "/trendlineType";
DrawingMLChart.gd = DrawingMLChart.dw + "/tx";
DrawingMLChart.ge = DrawingMLChart.dw + "/txPr";
DrawingMLChart.gf = DrawingMLChart.dw + "/upBars";
DrawingMLChart.gg = DrawingMLChart.dw + "/upDownBars";
DrawingMLChart.gh = DrawingMLChart.dw + "/userInterface";
DrawingMLChart.gi = DrawingMLChart.dw + "/userShapes";
DrawingMLChart.gj = DrawingMLChart.dw + "/v";
DrawingMLChart.gk = DrawingMLChart.dw + "/val";
DrawingMLChart.gl = DrawingMLChart.dw + "/valAx";
DrawingMLChart.gm = DrawingMLChart.dw + "/varyColors";
DrawingMLChart.gn = DrawingMLChart.dw + "/view3D";
DrawingMLChart.go = DrawingMLChart.dw + "/w";
DrawingMLChart.gp = DrawingMLChart.dw + "/wireframe";
DrawingMLChart.gq = DrawingMLChart.dw + "/wMode";
DrawingMLChart.gr = DrawingMLChart.dw + "/x";
DrawingMLChart.gs = DrawingMLChart.dw + "/xMode";
DrawingMLChart.gt = DrawingMLChart.dw + "/xVal";
DrawingMLChart.gu = DrawingMLChart.dw + "/y";
DrawingMLChart.gv = DrawingMLChart.dw + "/yMode";
DrawingMLChart.gw = DrawingMLChart.dw + "/yVal";
DrawingMLChart.an = new DrawingMLChart();
/**
 * @hidden
 */
export class DrawingMLChart2012 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChart2012.bl;
            case 1: return DrawingMLChart2012.bk;
            default: return DrawingMLChart2012.bl;
        }
    }
    get_j() {
        return "c15";
    }
    get j() {
        return this.get_j();
    }
}
DrawingMLChart2012.$t = markType(DrawingMLChart2012, 'DrawingMLChart2012', XmlNamespaceDefinitionBase.$);
DrawingMLChart2012.bl = "http://schemas.microsoft.com/office/drawing/2012/chart";
DrawingMLChart2012.bk = "http://purl.oclc.org/ooxml/drawing/2012/chart";
DrawingMLChart2012.bj = DrawingMLChart2012.bl;
DrawingMLChart2012.ap = DrawingMLChart2012.bj + "/autoCat";
DrawingMLChart2012.aq = DrawingMLChart2012.bj + "/bubble3D";
DrawingMLChart2012.ar = DrawingMLChart2012.bj + "/cat";
DrawingMLChart2012.as = DrawingMLChart2012.bj + "/categoryFilterException";
DrawingMLChart2012.at = DrawingMLChart2012.bj + "/categoryFilterExceptions";
DrawingMLChart2012.au = DrawingMLChart2012.bj + "/datalabelsRange";
DrawingMLChart2012.av = DrawingMLChart2012.bj + "/dLbl";
DrawingMLChart2012.aw = DrawingMLChart2012.bj + "/dlblFieldTable";
DrawingMLChart2012.ax = DrawingMLChart2012.bj + "/dlblFieldTableCache";
DrawingMLChart2012.ay = DrawingMLChart2012.bj + "/dlblFTEntry";
DrawingMLChart2012.az = DrawingMLChart2012.bj + "/dlblRangeCache";
DrawingMLChart2012.a0 = DrawingMLChart2012.bj + "/explosion";
DrawingMLChart2012.a1 = DrawingMLChart2012.bj + "/f";
DrawingMLChart2012.a2 = DrawingMLChart2012.bj + "/filteredAreaSeries";
DrawingMLChart2012.a3 = DrawingMLChart2012.bj + "/filteredBarSeries";
DrawingMLChart2012.a4 = DrawingMLChart2012.bj + "/filteredBubbleSeries";
DrawingMLChart2012.a5 = DrawingMLChart2012.bj + "/filteredCategoryTitle";
DrawingMLChart2012.a6 = DrawingMLChart2012.bj + "/filteredLineSeries";
DrawingMLChart2012.a7 = DrawingMLChart2012.bj + "/filteredPieSeries";
DrawingMLChart2012.a8 = DrawingMLChart2012.bj + "/filteredRadarSeries";
DrawingMLChart2012.a9 = DrawingMLChart2012.bj + "/filteredScatterSeries";
DrawingMLChart2012.ba = DrawingMLChart2012.bj + "/filteredSeriesTitle";
DrawingMLChart2012.bb = DrawingMLChart2012.bj + "/filteredSurfaceSeries";
DrawingMLChart2012.bc = DrawingMLChart2012.bj + "/formulaRef";
DrawingMLChart2012.bd = DrawingMLChart2012.bj + "/fullRef";
DrawingMLChart2012.be = DrawingMLChart2012.bj + "/invertIfNegative";
DrawingMLChart2012.bf = DrawingMLChart2012.bj + "/layout";
DrawingMLChart2012.bg = DrawingMLChart2012.bj + "/leaderLines";
DrawingMLChart2012.bh = DrawingMLChart2012.bj + "/levelRef";
DrawingMLChart2012.bi = DrawingMLChart2012.bj + "/marker";
DrawingMLChart2012.bm = DrawingMLChart2012.bj + "/numFmt";
DrawingMLChart2012.bn = DrawingMLChart2012.bj + "/pivotSource";
DrawingMLChart2012.bo = DrawingMLChart2012.bj + "/ser";
DrawingMLChart2012.bp = DrawingMLChart2012.bj + "/showDataLabelsRange";
DrawingMLChart2012.bq = DrawingMLChart2012.bj + "/showLeaderLines";
DrawingMLChart2012.br = DrawingMLChart2012.bj + "/spPr";
DrawingMLChart2012.bs = DrawingMLChart2012.bj + "/sqref";
DrawingMLChart2012.bt = DrawingMLChart2012.bj + "/tx";
DrawingMLChart2012.bu = DrawingMLChart2012.bj + "/txfldGUID";
DrawingMLChart2012.bv = DrawingMLChart2012.bj + "/xForSave";
DrawingMLChart2012.an = new DrawingMLChart2012();
/**
 * @hidden
 */
export class DrawingMLChart2014 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChart2014.as;
            case 1: return DrawingMLChart2014.ar;
            default: return DrawingMLChart2014.as;
        }
    }
    get_j() {
        return "cx";
    }
    get j() {
        return this.get_j();
    }
    static at(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static au(a, b = null) {
        a.ad.p(DrawingMLChart2014.ap, "cx");
        a.ad.l(DrawingMLChart2014.an);
        a.ad.l(OfficeDocumentRelationships.an);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
}
DrawingMLChart2014.$t = markType(DrawingMLChart2014, 'DrawingMLChart2014', XmlNamespaceDefinitionBase.$);
DrawingMLChart2014.as = "http://schemas.microsoft.com/office/drawing/2014/chartex";
DrawingMLChart2014.ar = DrawingMLChart2014.as;
DrawingMLChart2014.aq = DrawingMLChart2014.as;
DrawingMLChart2014.ap = DrawingMLChart2014.as + "/chart";
DrawingMLChart2014.an = new DrawingMLChart2014();
/**
 * @hidden
 */
export class DrawingMLChartEx2015_9_8 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChartEx2015_9_8.ar;
            case 1: return DrawingMLChartEx2015_9_8.aq;
            default: return DrawingMLChartEx2015_9_8.ar;
        }
    }
    get_j() {
        return "cx1";
    }
    get j() {
        return this.get_j();
    }
}
DrawingMLChartEx2015_9_8.$t = markType(DrawingMLChartEx2015_9_8, 'DrawingMLChartEx2015_9_8', XmlNamespaceDefinitionBase.$);
DrawingMLChartEx2015_9_8.ar = "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex";
DrawingMLChartEx2015_9_8.aq = "http://purl.oclc.org/ooxml/drawing/2015/9/8/chartex";
DrawingMLChartEx2015_9_8.ap = DrawingMLChartEx2015_9_8.ar;
DrawingMLChartEx2015_9_8.an = new DrawingMLChartEx2015_9_8();
/**
 * @hidden
 */
export class DrawingMLChartEx2015_10_21 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChartEx2015_10_21.ar;
            case 1: return DrawingMLChartEx2015_10_21.aq;
            default: return DrawingMLChartEx2015_10_21.ar;
        }
    }
    get_j() {
        return "cx2";
    }
    get j() {
        return this.get_j();
    }
}
DrawingMLChartEx2015_10_21.$t = markType(DrawingMLChartEx2015_10_21, 'DrawingMLChartEx2015_10_21', XmlNamespaceDefinitionBase.$);
DrawingMLChartEx2015_10_21.ar = "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex";
DrawingMLChartEx2015_10_21.aq = "http://purl.oclc.org/ooxml/drawing/2015/10/21/chartex";
DrawingMLChartEx2015_10_21.ap = DrawingMLChartEx2015_10_21.ar;
DrawingMLChartEx2015_10_21.an = new DrawingMLChartEx2015_10_21();
/**
 * @hidden
 */
export class DrawingMLChartEx2016_5_10 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLChartEx2016_5_10.ar;
            case 1: return DrawingMLChartEx2016_5_10.aq;
            default: return DrawingMLChartEx2016_5_10.ar;
        }
    }
    get_j() {
        return "cx4";
    }
    get j() {
        return this.get_j();
    }
}
DrawingMLChartEx2016_5_10.$t = markType(DrawingMLChartEx2016_5_10, 'DrawingMLChartEx2016_5_10', XmlNamespaceDefinitionBase.$);
DrawingMLChartEx2016_5_10.ar = "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex";
DrawingMLChartEx2016_5_10.aq = "http://purl.oclc.org/ooxml/drawing/2016/5/10/chartex";
DrawingMLChartEx2016_5_10.ap = DrawingMLChartEx2016_5_10.ar;
DrawingMLChartEx2016_5_10.an = new DrawingMLChartEx2016_5_10();
/**
 * @hidden
 */
export class DrawingMLMain extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return DrawingMLMain.gp;
            case 1: return DrawingMLMain.go;
            default: return DrawingMLMain.gp;
        }
    }
    get_j() {
        return "a";
    }
    get j() {
        return this.get_j();
    }
    static kv(a, b, c) {
        c = ST_Angle.a(0);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_Angle.b(d.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static nw(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.toString();
        a.ad.h("val", d);
    }
    static kw(a, b) {
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                default: break;
            }
        }
    }
    static nx(a, b) {
        a.ad.p(b, "a");
    }
    static kx(a, b, c) {
        c = new ST_FixedPercentage();
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_FixedPercentage.c(d.d, a.d._z);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static ny(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.s(a.d._z);
        a.ad.h("val", d);
    }
    static ky(a, b, c, d, e) {
        c = Nullable$1.toNullable(ST_LineEndType_$type, null);
        d = Nullable$1.toNullable(ST_LineEndWidth_$type, null);
        e = Nullable$1.toNullable(ST_LineEndLength_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "type":
                    c = Nullable$1.toNullable(ST_LineEndType_$type, XmlNamespaceDefinitionBase.b(ST_LineEndType_$type, f.d));
                    break;
                case "w":
                    d = Nullable$1.toNullable(ST_LineEndWidth_$type, XmlNamespaceDefinitionBase.b(ST_LineEndWidth_$type, f.d));
                    break;
                case "len":
                    e = Nullable$1.toNullable(ST_LineEndLength_$type, XmlNamespaceDefinitionBase.b(ST_LineEndLength_$type, f.d));
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e
        };
    }
    static nz(a, b, c, d, e) {
        a.ad.p(b, "a");
        let f;
        if (nullableNotEquals(c, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_LineEndType_$type, c.value);
            a.ad.h("type", f);
        }
        if (nullableNotEquals(d, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_LineEndWidth_$type, d.value);
            a.ad.h("w", f);
        }
        if (nullableNotEquals(e, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_LineEndLength_$type, e.value);
            a.ad.h("len", f);
        }
    }
    static kz(a, b, c, d, e, f, g) {
        c = new ST_DrawingElementId();
        d = null;
        e = null;
        f = false;
        g = null;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "id":
                    c = ST_DrawingElementId.c(h.d);
                    break;
                case "name":
                    d = h.d;
                    break;
                case "descr":
                    e = h.d;
                    break;
                case "hidden":
                    f = ST_OnOff.e(h.d);
                    break;
                case "title":
                    g = h.d;
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static n0(a, b, c, d, e, f, g) {
        a.ad.p(b, "a");
        let h;
        h = c.toString();
        a.ad.h("id", h);
        h = d;
        a.ad.h("name", h);
        h = e;
        a.ad.h("descr", h);
        if (f != false) {
            h = ST_OnOff.g(f);
            a.ad.h("hidden", h);
        }
        h = g;
        a.ad.h("title", h);
    }
    static k0(a, b, c) {
        c = new ST_Percentage();
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_Percentage.d(d.d, a.d._z);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static n1(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.r(a.d._z);
        a.ad.h("val", d);
    }
    static k1(a, b, c, d) {
        c = new ST_Coordinate();
        d = new ST_Coordinate();
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "x":
                    c = ST_Coordinate.h(e.d);
                    break;
                case "y":
                    d = ST_Coordinate.h(e.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d
        };
    }
    static n2(a, b, c, d) {
        a.ad.p(b, "a");
        let e;
        e = c.toString();
        a.ad.h("x", e);
        e = d.toString();
        a.ad.h("y", e);
    }
    static k2(a, b, c) {
        c = ST_PositiveFixedAngle.e(ST_Angle.a(0));
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_PositiveFixedAngle.g(d.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static n3(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.toString();
        a.ad.h("val", d);
    }
    static k3(a, b, c) {
        c = new ST_PositiveFixedPercentage();
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_PositiveFixedPercentage.f(d.d, a.d._z);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static n4(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.u(a.d._z);
        a.ad.h("val", d);
    }
    static k4(a, b, c) {
        c = new ST_PositivePercentage();
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_PositivePercentage.f(d.d, a.d._z);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static n5(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.s(a.d._z);
        a.ad.h("val", d);
    }
    static k5(a, b, c, d) {
        c = new ST_PositiveCoordinate();
        d = new ST_PositiveCoordinate();
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "cx":
                    c = ST_PositiveCoordinate.c(e.d);
                    break;
                case "cy":
                    d = ST_PositiveCoordinate.c(e.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d
        };
    }
    static n6(a, b, c, d) {
        a.ad.p(b, "a");
        let e;
        e = c.toString();
        a.ad.h("cx", e);
        e = d.toString();
        a.ad.h("cy", e);
    }
    static k6(a, b, c, d, e, f) {
        c = ST_Percentage.b(0);
        d = ST_Percentage.b(0);
        e = ST_Percentage.b(0);
        f = ST_Percentage.b(0);
        let g = a.d._z;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "l":
                    c = ST_Percentage.d(h.d, g);
                    break;
                case "t":
                    d = ST_Percentage.d(h.d, g);
                    break;
                case "r":
                    e = ST_Percentage.d(h.d, g);
                    break;
                case "b":
                    f = ST_Percentage.d(h.d, g);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static n7(a, b, c, d, e, f) {
        a.ad.p(b, "a");
        let g;
        let h = a.d._z;
        if (ST_Percentage.g(c, ST_Percentage.b(0))) {
            g = c.r(h);
            a.ad.h("l", g);
        }
        if (ST_Percentage.g(d, ST_Percentage.b(0))) {
            g = d.r(h);
            a.ad.h("t", g);
        }
        if (ST_Percentage.g(e, ST_Percentage.b(0))) {
            g = e.r(h);
            a.ad.h("r", g);
        }
        if (ST_Percentage.g(f, ST_Percentage.b(0))) {
            g = f.r(h);
            a.ad.h("b", g);
        }
    }
    static k7(a, b, c) {
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "idx":
                    c = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static n8(a, b, c) {
        a.ad.p(b, "a");
        let d;
        d = c.toString();
        a.ad.h("idx", d);
    }
    static k8(a, b, c, d, e, f, g = true) {
        c = null;
        d = null;
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        let h = 1;
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "typeface":
                    c = i.d;
                    break;
                case "panose":
                    d = ST_Panose.b(i.d);
                    break;
                case "pitchFamily":
                    e = Nullable$1.toNullable(Number_$type, parseInt8_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "charset":
                    f = Nullable$1.toNullable(Number_$type, parseInt8_1(i.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        if (g && f.hasValue == false) {
            f = Nullable$1.toNullable(Number_$type, h);
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static n9(a, b, c, d, e, f) {
        a.ad.p(b, "a");
        let g;
        g = c != null ? c : "";
        a.ad.h("typeface", g);
        if (d != null) {
            g = d.toString();
            a.ad.h("panose", g);
        }
        if (nullableNotEquals(e, null)) {
            g = e.value.toString();
            a.ad.h("pitchFamily", g);
        }
        if (f != 1) {
            g = f.toString();
            a.ad.h("charset", g);
        }
    }
    static ka(a) {
    }
    static nb(a) {
        DrawingMLMain.nx(a, DrawingMLMain.aq);
    }
    static kb(a) {
    }
    static nc(a) {
        DrawingMLMain.nx(a, DrawingMLMain.ar);
    }
    static kc(a) {
    }
    static nd(a) {
        DrawingMLMain.nx(a, DrawingMLMain.as);
    }
    static kd(a) {
    }
    static ne(a) {
        DrawingMLMain.nx(a, DrawingMLMain.at);
    }
    static ke(a) {
    }
    static nf(a) {
        DrawingMLMain.nx(a, DrawingMLMain.au);
    }
    static kf(a) {
    }
    static ng(a) {
        DrawingMLMain.nx(a, DrawingMLMain.av);
    }
    static kg(a, b) {
        let c = DrawingMLMain.k3(a, DrawingMLMain.a1, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static nh(a, b) {
        DrawingMLMain.n4(a, DrawingMLMain.a1, b);
    }
    static kh(a, b) {
        let c = DrawingMLMain.k4(a, DrawingMLMain.a6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ni(a, b) {
        DrawingMLMain.n5(a, DrawingMLMain.a6, b);
    }
    static ki(a, b) {
        let c = DrawingMLMain.kx(a, DrawingMLMain.a8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static nj(a, b) {
        DrawingMLMain.ny(a, DrawingMLMain.a8, b);
    }
    static kj(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static nk(a) {
        a.ad.p(DrawingMLMain.bg, "a");
    }
    static kk(a, b, c, d, e = true) {
        b = null;
        c = null;
        if (e) {
            d = Nullable$1.toNullable(ST_BlipCompression_$type, 0);
        }
        else {
            d = Nullable$1.toNullable(ST_BlipCompression_$type, null);
        }
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case OfficeDocumentRelationships.ap:
                    b = f.d;
                    break;
                case OfficeDocumentRelationships.as:
                    c = f.d;
                    break;
                case "cstate":
                    d = Nullable$1.toNullable(ST_BlipCompression_$type, XmlNamespaceDefinitionBase.b(ST_BlipCompression_$type, f.d, 0));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static nl(a, b, c, d) {
        a.ad.p(DrawingMLMain.bs, "a");
        let e;
        e = b;
        a.ad.h(OfficeDocumentRelationships.ap, e);
        e = c;
        a.ad.h(OfficeDocumentRelationships.as, e);
        if (d.hasValue && d.value != 0) {
            e = XmlNamespaceDefinitionBase.f(ST_BlipCompression_$type, d.value);
            a.ad.h("cstate", e);
        }
    }
    static kl(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "dpi":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "rotWithShape":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static nm(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(DrawingMLMain.bt, "a");
        let d;
        if (nullableNotEquals(b, null)) {
            d = b.value.toString();
            a.ad.h("dpi", d);
        }
        if (nullableNotEquals(c, null)) {
            d = ST_OnOff.g(c.value);
            a.ad.h("rotWithShape", d);
        }
    }
    static km(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.bu, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static nn(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.bu, b);
    }
    static kn(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.bv, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static no(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.bv, b);
    }
    static ko(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.bw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static np(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.bw, b);
    }
    static kp(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null);
        e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null);
        f = Nullable$1.toNullable(ST_TextVerticalType_$type, null);
        g = Nullable$1.toNullable(ST_TextWrappingType_$type, null);
        h = Nullable$1.toNullable(ST_Coordinate32.$, null);
        i = Nullable$1.toNullable(ST_Coordinate32.$, null);
        j = Nullable$1.toNullable(ST_Coordinate32.$, null);
        k = Nullable$1.toNullable(ST_Coordinate32.$, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        p = Nullable$1.toNullable(ST_TextAnchoringType_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        s = false;
        t = Nullable$1.toNullable(Boolean_$type, null);
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case "rot":
                    b = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "spcFirstLastPara":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "vertOverflow":
                    d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextVertOverflowType_$type, u.d));
                    break;
                case "horzOverflow":
                    e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextHorzOverflowType_$type, u.d));
                    break;
                case "vert":
                    f = Nullable$1.toNullable(ST_TextVerticalType_$type, XmlNamespaceDefinitionBase.b(ST_TextVerticalType_$type, u.d));
                    break;
                case "wrap":
                    g = Nullable$1.toNullable(ST_TextWrappingType_$type, XmlNamespaceDefinitionBase.b(ST_TextWrappingType_$type, u.d));
                    break;
                case "lIns":
                    h = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                    break;
                case "tIns":
                    i = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                    break;
                case "rIns":
                    j = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                    break;
                case "bIns":
                    k = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                    break;
                case "numCol":
                    l = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "spcCol":
                    m = Nullable$1.toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rtlCol":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "fromWordArt":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "anchor":
                    p = Nullable$1.toNullable(ST_TextAnchoringType_$type, XmlNamespaceDefinitionBase.b(ST_TextAnchoringType_$type, u.d));
                    break;
                case "anchorCtr":
                    q = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "forceAA":
                    r = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                case "upright":
                    s = ST_OnOff.e(u.d);
                    break;
                case "compatLnSpc":
                    t = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(u.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static nq(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(ST_TextVertOverflowType_$type, null), e = Nullable$1.toNullable(ST_TextHorzOverflowType_$type, null), f = Nullable$1.toNullable(ST_TextVerticalType_$type, null), g = Nullable$1.toNullable(ST_TextWrappingType_$type, null), h = Nullable$1.toNullable(ST_Coordinate32.$, null), i = Nullable$1.toNullable(ST_Coordinate32.$, null), j = Nullable$1.toNullable(ST_Coordinate32.$, null), k = Nullable$1.toNullable(ST_Coordinate32.$, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Boolean_$type, null), o = Nullable$1.toNullable(Boolean_$type, null), p = Nullable$1.toNullable(ST_TextAnchoringType_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = Nullable$1.toNullable(Boolean_$type, null), s = false, t = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(DrawingMLMain.bz, "a");
        let u;
        if (nullableNotEquals(b, null)) {
            u = b.value.toString();
            a.ad.h("rot", u);
        }
        if (nullableNotEquals(c, null)) {
            u = ST_OnOff.g(c.value);
            a.ad.h("spcFirstLastPara", u);
        }
        if (nullableNotEquals(d, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextVertOverflowType_$type, d.value);
            a.ad.h("vertOverflow", u);
        }
        if (nullableNotEquals(e, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextHorzOverflowType_$type, e.value);
            a.ad.h("horzOverflow", u);
        }
        if (nullableNotEquals(f, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextVerticalType_$type, f.value);
            a.ad.h("vert", u);
        }
        if (nullableNotEquals(g, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextWrappingType_$type, g.value);
            a.ad.h("wrap", u);
        }
        if (nullableNotEquals(h, null)) {
            u = h.value.toString();
            a.ad.h("lIns", u);
        }
        if (nullableNotEquals(i, null)) {
            u = i.value.toString();
            a.ad.h("tIns", u);
        }
        if (nullableNotEquals(j, null)) {
            u = j.value.toString();
            a.ad.h("rIns", u);
        }
        if (nullableNotEquals(k, null)) {
            u = k.value.toString();
            a.ad.h("bIns", u);
        }
        if (nullableNotEquals(l, null)) {
            u = l.value.toString();
            a.ad.h("numCol", u);
        }
        if (nullableNotEquals(m, null)) {
            u = m.value.toString();
            a.ad.h("spcCol", u);
        }
        if (nullableNotEquals(n, null)) {
            u = ST_OnOff.g(n.value);
            a.ad.h("rtlCol", u);
        }
        if (nullableNotEquals(o, null)) {
            u = ST_OnOff.g(o.value);
            a.ad.h("fromWordArt", u);
        }
        if (nullableNotEquals(p, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextAnchoringType_$type, p.value);
            a.ad.h("anchor", u);
        }
        if (nullableNotEquals(q, null)) {
            u = ST_OnOff.g(q.value);
            a.ad.h("anchorCtr", u);
        }
        if (nullableNotEquals(r, null)) {
            u = ST_OnOff.g(r.value);
            a.ad.h("forceAA", u);
        }
        if (s != false) {
            u = ST_OnOff.g(s);
            a.ad.h("upright", u);
        }
        if (nullableNotEquals(t, null)) {
            u = ST_OnOff.g(t.value);
            a.ad.h("compatLnSpc", u);
        }
    }
    static kq(a, b, c) {
        let d = DrawingMLMain.k5(a, DrawingMLMain.cg, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static nr(a, b, c) {
        DrawingMLMain.n6(a, DrawingMLMain.cg, b, c);
    }
    static kr(a, b, c) {
        let d = DrawingMLMain.k1(a, DrawingMLMain.ch, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static ns(a, b, c) {
        DrawingMLMain.n2(a, DrawingMLMain.ch, b, c);
    }
    static ks(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static nt(a, b) {
        a.ad.p(DrawingMLMain.cm, "a");
        let c;
        c = b;
        a.ad.h("name", c);
    }
    static kt(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static nu(a) {
        a.ad.p(DrawingMLMain.cp, "a");
    }
    static ku(a, b, c, d, e, f = true) {
        let g = DrawingMLMain.k8(a, DrawingMLMain.ct, b, c, d, e);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static nv(a, b, c = null, d = Nullable$1.toNullable(Number_$type, null), e = 1) {
        DrawingMLMain.n9(a, DrawingMLMain.ct, b, c, d, e);
    }
    static k9(a, b) {
        b = "";
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static oa(a, b = "") {
        a.ad.p(DrawingMLMain.cw, "a");
        let c;
        if (b != "") {
            c = b;
            a.ad.h("name", c);
        }
    }
    static la(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ob(a) {
        a.ad.p(DrawingMLMain.cx, "a");
    }
    static lb(a) {
    }
    static oc(a) {
        DrawingMLMain.nx(a, DrawingMLMain.c9);
    }
    static lc(a) {
    }
    static od(a) {
        DrawingMLMain.nx(a, DrawingMLMain.da);
    }
    static ld(a, b, c, d, e) {
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = DrawingMLMain.k8(a, DrawingMLMain.de, b, c, d, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        f = g.p5;
        e = f.hasValue ? f.value : 1;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static oe(a, b, c = null, d = Nullable$1.toNullable(Number_$type, null), e = 1) {
        DrawingMLMain.n9(a, DrawingMLMain.de, b, c, d, e);
    }
    static le(a, b) {
        let c = DrawingMLMain.k7(a, DrawingMLMain.dj, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static of(a, b) {
        DrawingMLMain.n8(a, DrawingMLMain.dj, b);
    }
    static lf(a, b, c) {
        let d = DrawingMLMain.k5(a, DrawingMLMain.dq, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static og(a, b, c) {
        DrawingMLMain.n6(a, DrawingMLMain.dq, b, c);
    }
    static lg(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static oh(a) {
        a.ad.p(DrawingMLMain.dr, "a");
    }
    static lh(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static oi(a) {
        a.ad.p(DrawingMLMain.ds, "a");
    }
    static li(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static oj(a) {
        a.ad.p(DrawingMLMain.dt, "a");
    }
    static lj(a, b, c, d, e) {
        let f = DrawingMLMain.k6(a, DrawingMLMain.dy, b, c, d, e);
        b = f.p2;
        c = f.p3;
        d = f.p4;
        e = f.p5;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static ok(a, b, c, d, e) {
        DrawingMLMain.n7(a, DrawingMLMain.dy, b, c, d, e);
    }
    static lk(a, b) {
        let c = DrawingMLMain.k7(a, DrawingMLMain.dz, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ol(a, b) {
        DrawingMLMain.n8(a, DrawingMLMain.dz, b);
    }
    static ll(a) {
    }
    static om(a) {
        DrawingMLMain.nx(a, DrawingMLMain.d8);
    }
    static lm(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "script":
                    b = d.d;
                    break;
                case "typeface":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static on(a, b, c) {
        a.ad.p(DrawingMLMain.d9, "a");
        let d;
        d = b;
        a.ad.h("script", d);
        d = c;
        a.ad.h("typeface", d);
    }
    static ln(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "idx":
                    b = XmlNamespaceDefinitionBase.b(ST_FontCollectionIndex_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static oo(a, b) {
        a.ad.p(DrawingMLMain.eb, "a");
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_FontCollectionIndex_$type, b);
        a.ad.h("idx", c);
    }
    static lo(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static op(a, b) {
        a.ad.p(DrawingMLMain.ec, "a");
        let c;
        c = b;
        a.ad.h("name", c);
    }
    static lp(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "name":
                    b = d.d;
                    break;
                case "fmla":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static oq(a, b, c) {
        a.ad.p(DrawingMLMain.eg, "a");
        let d;
        d = b;
        a.ad.h("name", d);
        d = c;
        a.ad.h("fmla", d);
    }
    static lq(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "uri":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static or(a, b) {
        a.ad.p(DrawingMLMain.el, "a");
        let c;
        c = b;
        a.ad.h("uri", c);
    }
    static lr(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static os(a) {
        a.ad.p(DrawingMLMain.ek, "a");
    }
    static ls(a, b, c, d, e, f, g) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = false;
        g = false;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "noGrp":
                    b = ST_OnOff.e(h.d);
                    break;
                case "noDrilldown":
                    c = ST_OnOff.e(h.d);
                    break;
                case "noSelect":
                    d = ST_OnOff.e(h.d);
                    break;
                case "noChangeAspect":
                    e = ST_OnOff.e(h.d);
                    break;
                case "noMove":
                    f = ST_OnOff.e(h.d);
                    break;
                case "noResize":
                    g = ST_OnOff.e(h.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static ot(a, b = false, c = false, d = false, e = false, f = false, g = false) {
        a.ad.p(DrawingMLMain.em, "a");
        let h;
        if (b != false) {
            h = ST_OnOff.g(b);
            a.ad.h("noGrp", h);
        }
        if (c != false) {
            h = ST_OnOff.g(c);
            a.ad.h("noDrilldown", h);
        }
        if (d != false) {
            h = ST_OnOff.g(d);
            a.ad.h("noSelect", h);
        }
        if (e != false) {
            h = ST_OnOff.g(e);
            a.ad.h("noChangeAspect", h);
        }
        if (f != false) {
            h = ST_OnOff.g(f);
            a.ad.h("noMove", h);
        }
        if (g != false) {
            h = ST_OnOff.g(g);
            a.ad.h("noResize", h);
        }
    }
    static lt(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ou(a) {
        a.ad.p(DrawingMLMain.en, "a");
    }
    static lu(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.ep, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ov(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.ep, b);
    }
    static lv(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.eq, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ow(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.eq, b);
    }
    static lw(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.er, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ox(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.er, b);
    }
    static lx(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static oy(a) {
        a.ad.p(DrawingMLMain.es, "a");
    }
    static ly(a, b, c, d) {
        let e = DrawingMLMain.ky(a, DrawingMLMain.ew, b, c, d);
        b = e.p2;
        c = e.p3;
        d = e.p4;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static oz(a, b, c, d) {
        DrawingMLMain.nz(a, DrawingMLMain.ew, b, c, d);
    }
    static lz(a, b, c, d, e, f, g, h, i) {
        b = null;
        c = "";
        d = "";
        e = "";
        f = "";
        g = true;
        h = false;
        i = false;
        for (let j of fromEnum(a.ab.u)) {
            switch (j.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = j.d;
                    break;
                case "invalidUrl":
                    c = j.d;
                    break;
                case "action":
                    d = j.d;
                    break;
                case "tgtFrame":
                    e = j.d;
                    break;
                case "tooltip":
                    f = j.d;
                    break;
                case "history":
                    g = ST_OnOff.e(j.d);
                    break;
                case "highlightClick":
                    h = ST_OnOff.e(j.d);
                    break;
                case "endSnd":
                    i = ST_OnOff.e(j.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i
        };
    }
    static o0(a, b = null, c = "", d = "", e = "", f = "", g = true, h = false, i = false) {
        a.ad.p(DrawingMLMain.e2, "a");
        let j;
        j = b;
        a.ad.h(OfficeDocumentRelationships.ar, j);
        j = c;
        a.ad.h("invalidUrl", j);
        j = d;
        a.ad.h("action", j);
        j = e;
        a.ad.h("tgtFrame", j);
        j = f;
        a.ad.h("tooltip", j);
        if (g != true) {
            j = ST_OnOff.g(g);
            a.ad.h("history", j);
        }
        if (h != false) {
            j = ST_OnOff.g(h);
            a.ad.h("highlightClick", j);
        }
        if (i != false) {
            j = ST_OnOff.g(i);
            a.ad.h("endSnd", j);
        }
    }
    static l0(a) {
    }
    static o1(a) {
        DrawingMLMain.nx(a, DrawingMLMain.e1);
    }
    static l1(a, b) {
        let c = DrawingMLMain.k2(a, DrawingMLMain.e8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static o2(a, b) {
        DrawingMLMain.n3(a, DrawingMLMain.e8, b);
    }
    static l2(a, b) {
        let c = DrawingMLMain.k4(a, DrawingMLMain.e9, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static o3(a, b) {
        DrawingMLMain.n5(a, DrawingMLMain.e9, b);
    }
    static l3(a, b) {
        let c = DrawingMLMain.kv(a, DrawingMLMain.fa, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static o4(a, b) {
        DrawingMLMain.nw(a, DrawingMLMain.fa, b);
    }
    static l4(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static o5(a) {
        a.ad.p(DrawingMLMain.fg, "a");
    }
    static l5(a, b, c, d, e) {
        let f = Nullable$1.toNullable(Number_$type, null);
        let g = DrawingMLMain.k8(a, DrawingMLMain.fq, b, c, d, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        f = g.p5;
        e = f.hasValue ? f.value : 1;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static o6(a, b, c = null, d = Nullable$1.toNullable(Number_$type, null), e = 1) {
        DrawingMLMain.n9(a, DrawingMLMain.fq, b, c, d, e);
    }
    static l6(a, b, c, d, e) {
        b = Nullable$1.toNullable(ST_LineWidth.$, null);
        c = Nullable$1.toNullable(ST_LineCap_$type, null);
        d = Nullable$1.toNullable(ST_CompoundLine_$type, null);
        e = Nullable$1.toNullable(ST_PenAlignment_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "w":
                    b = Nullable$1.toNullable(ST_LineWidth.$, ST_LineWidth.f(f.d));
                    break;
                case "cap":
                    c = Nullable$1.toNullable(ST_LineCap_$type, XmlNamespaceDefinitionBase.b(ST_LineCap_$type, f.d));
                    break;
                case "cmpd":
                    d = Nullable$1.toNullable(ST_CompoundLine_$type, XmlNamespaceDefinitionBase.b(ST_CompoundLine_$type, f.d));
                    break;
                case "algn":
                    e = Nullable$1.toNullable(ST_PenAlignment_$type, XmlNamespaceDefinitionBase.b(ST_PenAlignment_$type, f.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static o7(a, b, c, d, e) {
        a.ad.p(DrawingMLMain.fw, "a");
        let f;
        if (ST_LineWidth.j(b, Nullable$1.toNullable(ST_LineWidth.$, null))) {
            f = b.toString();
            a.ad.h("w", f);
        }
        if (nullableNotEquals(c, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_LineCap_$type, c.value);
            a.ad.h("cap", f);
        }
        if (nullableNotEquals(d, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_CompoundLine_$type, d.value);
            a.ad.h("cmpd", f);
        }
        if (nullableNotEquals(e, null)) {
            f = XmlNamespaceDefinitionBase.f(ST_PenAlignment_$type, e.value);
            a.ad.h("algn", f);
        }
    }
    static l7(a, b) {
        let c = DrawingMLMain.k7(a, DrawingMLMain.fx, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static o8(a, b) {
        DrawingMLMain.n8(a, DrawingMLMain.fx, b);
    }
    static l8(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static o9(a) {
        a.ad.p(DrawingMLMain.f1, "a");
    }
    static l9(a) {
    }
    static pa(a) {
        DrawingMLMain.nx(a, DrawingMLMain.f2);
    }
    static ma(a) {
    }
    static pb(a) {
        DrawingMLMain.nx(a, DrawingMLMain.f3);
    }
    static mb(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.f4, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pc(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.f4, b);
    }
    static mc(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.f5, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pd(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.f5, b);
    }
    static md(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.f6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pe(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.f6, b);
    }
    static me(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static pf(a) {
        a.ad.p(DrawingMLMain.gh, "a");
    }
    static mf(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static pg(a) {
        a.ad.p(DrawingMLMain.gk, "a");
    }
    static mg(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ph(a) {
        a.ad.p(DrawingMLMain.gy, "a");
    }
    static mh(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static pi(a) {
        a.ad.p(DrawingMLMain.ha, "a");
    }
    static mi(a, b, c) {
        let d = DrawingMLMain.k1(a, DrawingMLMain.hb, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static pj(a, b, c) {
        DrawingMLMain.n2(a, DrawingMLMain.hb, b, c);
    }
    static mj(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static pk(a) {
        a.ad.p(DrawingMLMain.hd, "a");
    }
    static mk(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        i = false;
        j = false;
        k = false;
        l = false;
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "noGrp":
                    b = ST_OnOff.e(m.d);
                    break;
                case "noSelect":
                    c = ST_OnOff.e(m.d);
                    break;
                case "noRot":
                    d = ST_OnOff.e(m.d);
                    break;
                case "noChangeAspect":
                    e = ST_OnOff.e(m.d);
                    break;
                case "noMove":
                    f = ST_OnOff.e(m.d);
                    break;
                case "noResize":
                    g = ST_OnOff.e(m.d);
                    break;
                case "noEditPoints":
                    h = ST_OnOff.e(m.d);
                    break;
                case "noAdjustHandles":
                    i = ST_OnOff.e(m.d);
                    break;
                case "noChangeArrowheads":
                    j = ST_OnOff.e(m.d);
                    break;
                case "noChangeShapeType":
                    k = ST_OnOff.e(m.d);
                    break;
                case "noCrop":
                    l = ST_OnOff.e(m.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static pl(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false, l = false) {
        a.ad.p(DrawingMLMain.hi, "a");
        let m;
        if (b != false) {
            m = ST_OnOff.g(b);
            a.ad.h("noGrp", m);
        }
        if (c != false) {
            m = ST_OnOff.g(c);
            a.ad.h("noSelect", m);
        }
        if (d != false) {
            m = ST_OnOff.g(d);
            a.ad.h("noRot", m);
        }
        if (e != false) {
            m = ST_OnOff.g(e);
            a.ad.h("noChangeAspect", m);
        }
        if (f != false) {
            m = ST_OnOff.g(f);
            a.ad.h("noMove", m);
        }
        if (g != false) {
            m = ST_OnOff.g(g);
            a.ad.h("noResize", m);
        }
        if (h != false) {
            m = ST_OnOff.g(h);
            a.ad.h("noEditPoints", m);
        }
        if (i != false) {
            m = ST_OnOff.g(i);
            a.ad.h("noAdjustHandles", m);
        }
        if (j != false) {
            m = ST_OnOff.g(j);
            a.ad.h("noChangeArrowheads", m);
        }
        if (k != false) {
            m = ST_OnOff.g(k);
            a.ad.h("noChangeShapeType", m);
        }
        if (l != false) {
            m = ST_OnOff.g(l);
            a.ad.h("noCrop", m);
        }
    }
    static ml(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = Nullable$1.toNullable(ST_TextMargin.$, null);
        c = Nullable$1.toNullable(ST_TextMargin.$, null);
        d = Nullable$1.toNullable(ST_TextIndentLevelType.$, null);
        e = Nullable$1.toNullable(ST_TextIndent.$, null);
        f = Nullable$1.toNullable(ST_TextAlignType_$type, null);
        g = Nullable$1.toNullable(ST_Coordinate32.$, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(ST_TextFontAlignType_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "marL":
                    b = Nullable$1.toNullable(ST_TextMargin.$, ST_TextMargin.c(m.d));
                    break;
                case "marR":
                    c = Nullable$1.toNullable(ST_TextMargin.$, ST_TextMargin.c(m.d));
                    break;
                case "lvl":
                    d = Nullable$1.toNullable(ST_TextIndentLevelType.$, ST_TextIndentLevelType.c(m.d));
                    break;
                case "indent":
                    e = Nullable$1.toNullable(ST_TextIndent.$, ST_TextIndent.c(m.d));
                    break;
                case "algn":
                    f = Nullable$1.toNullable(ST_TextAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextAlignType_$type, m.d));
                    break;
                case "defTabSz":
                    g = Nullable$1.toNullable(ST_Coordinate32.$, ST_Coordinate32.g(m.d));
                    break;
                case "rtl":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "eaLnBrk":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "fontAlgn":
                    j = Nullable$1.toNullable(ST_TextFontAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextFontAlignType_$type, m.d));
                    break;
                case "latinLnBrk":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                case "hangingPunct":
                    l = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(m.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static pm(a, b = Nullable$1.toNullable(ST_TextMargin.$, null), c = Nullable$1.toNullable(ST_TextMargin.$, null), d = Nullable$1.toNullable(ST_TextIndentLevelType.$, null), e = Nullable$1.toNullable(ST_TextIndent.$, null), f = Nullable$1.toNullable(ST_TextAlignType_$type, null), g = Nullable$1.toNullable(ST_Coordinate32.$, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(ST_TextFontAlignType_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(DrawingMLMain.hl, "a");
        let m;
        if (nullableNotEquals(b, null)) {
            m = b.value.toString();
            a.ad.h("marL", m);
        }
        if (nullableNotEquals(c, null)) {
            m = c.value.toString();
            a.ad.h("marR", m);
        }
        if (nullableNotEquals(d, null)) {
            m = d.value.toString();
            a.ad.h("lvl", m);
        }
        if (nullableNotEquals(e, null)) {
            m = e.value.toString();
            a.ad.h("indent", m);
        }
        if (nullableNotEquals(f, null)) {
            m = XmlNamespaceDefinitionBase.f(ST_TextAlignType_$type, f.value);
            a.ad.h("algn", m);
        }
        if (nullableNotEquals(g, null)) {
            m = g.value.toString();
            a.ad.h("defTabSz", m);
        }
        if (nullableNotEquals(h, null)) {
            m = ST_OnOff.g(h.value);
            a.ad.h("rtl", m);
        }
        if (nullableNotEquals(i, null)) {
            m = ST_OnOff.g(i.value);
            a.ad.h("eaLnBrk", m);
        }
        if (nullableNotEquals(j, null)) {
            m = XmlNamespaceDefinitionBase.f(ST_TextFontAlignType_$type, j.value);
            a.ad.h("fontAlgn", m);
        }
        if (nullableNotEquals(k, null)) {
            m = ST_OnOff.g(k.value);
            a.ad.h("latinLnBrk", m);
        }
        if (nullableNotEquals(l, null)) {
            m = ST_OnOff.g(l.value);
            a.ad.h("hangingPunct", m);
        }
    }
    static mm(a, b) {
        b = 7;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_PresetColorVal_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static pn(a, b) {
        a.ad.p(DrawingMLMain.hn, "a");
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_PresetColorVal_$type, b);
        a.ad.h("val", c);
    }
    static mn(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "prst":
                    b = XmlNamespaceDefinitionBase.b(ST_ShapeType_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static po(a, b) {
        a.ad.p(DrawingMLMain.hp, "a");
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_ShapeType_$type, b);
        a.ad.h("prst", c);
    }
    static mo(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.hx, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pp(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.hx, b);
    }
    static mp(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.hy, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pq(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.hy, b);
    }
    static mq(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.hz, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pr(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.hz, b);
    }
    static mr(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ps(a) {
        a.ad.p(DrawingMLMain.hu, "a");
    }
    static ms(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = DrawingMLMain.h7, v = true) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = null;
        d = null;
        e = Nullable$1.toNullable(ST_TextFontSize.$, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(ST_TextUnderlineType_$type, null);
        i = Nullable$1.toNullable(ST_TextStrikeType_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = Nullable$1.toNullable(ST_TextCapsType_$type, null);
        l = Nullable$1.toNullable(ST_TextPoint.$, null);
        m = Nullable$1.toNullable(Boolean_$type, null);
        n = Nullable$1.toNullable(ST_Percentage.$, null);
        o = Nullable$1.toNullable(Boolean_$type, null);
        p = Nullable$1.toNullable(Boolean_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        s = Nullable$1.toNullable(Number_$type, null);
        let w = true;
        let x = false;
        let y = true;
        let z = 0;
        t = null;
        for (let aa of fromEnum(a.ab.u)) {
            switch (aa.a.e(a.d)) {
                case "kumimoji":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "lang":
                    c = aa.d;
                    break;
                case "altLang":
                    d = aa.d;
                    break;
                case "sz":
                    e = Nullable$1.toNullable(ST_TextFontSize.$, ST_TextFontSize.c(aa.d));
                    break;
                case "b":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "i":
                    g = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "u":
                    h = Nullable$1.toNullable(ST_TextUnderlineType_$type, XmlNamespaceDefinitionBase.b(ST_TextUnderlineType_$type, aa.d));
                    break;
                case "strike":
                    i = Nullable$1.toNullable(ST_TextStrikeType_$type, XmlNamespaceDefinitionBase.b(ST_TextStrikeType_$type, aa.d));
                    break;
                case "kern":
                    j = Nullable$1.toNullable(Number_$type, parseInt32_1(aa.d, CultureInfo.invariantCulture));
                    break;
                case "cap":
                    k = Nullable$1.toNullable(ST_TextCapsType_$type, XmlNamespaceDefinitionBase.b(ST_TextCapsType_$type, aa.d));
                    break;
                case "spc":
                    l = Nullable$1.toNullable(ST_TextPoint.$, ST_TextPoint.a(aa.d));
                    break;
                case "normalizeH":
                    m = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "baseline":
                    n = Nullable$1.toNullable(ST_Percentage.$, ST_Percentage.d(aa.d, a.d._z));
                    break;
                case "noProof":
                    o = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "dirty":
                    p = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "err":
                    q = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "smtClean":
                    r = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                    break;
                case "smtId":
                    s = Nullable$1.toNullable(Number_$type, parseUInt32_1(aa.d, CultureInfo.invariantCulture));
                    break;
                case "bmk":
                    t = aa.d;
                    break;
                default: break;
            }
            if (v) {
                if (p.hasValue == false) {
                    p = Nullable$1.toNullable(Boolean_$type, w);
                }
                if (q.hasValue == false) {
                    q = Nullable$1.toNullable(Boolean_$type, x);
                }
                if (r.hasValue == false) {
                    r = Nullable$1.toNullable(Boolean_$type, y);
                }
                if (s.hasValue == false) {
                    s = Nullable$1.toNullable(Number_$type, z);
                }
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static pt(a, b = Nullable$1.toNullable(Boolean_$type, null), c = null, d = null, e = Nullable$1.toNullable(ST_TextFontSize.$, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(ST_TextUnderlineType_$type, null), i = Nullable$1.toNullable(ST_TextStrikeType_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(ST_TextCapsType_$type, null), l = Nullable$1.toNullable(ST_TextPoint.$, null), m = Nullable$1.toNullable(Boolean_$type, null), n = Nullable$1.toNullable(ST_Percentage.$, null), o = Nullable$1.toNullable(Boolean_$type, null), p = Nullable$1.toNullable(Boolean_$type, true), q = Nullable$1.toNullable(Boolean_$type, false), r = Nullable$1.toNullable(Boolean_$type, true), s = Nullable$1.toNullable(Number_$type, 0), t = null) {
        a.ad.p(DrawingMLMain.h7, "a");
        let u;
        if (nullableNotEquals(b, null)) {
            u = ST_OnOff.g(b.value);
            a.ad.h("kumimoji", u);
        }
        u = c;
        a.ad.h("lang", u);
        u = d;
        a.ad.h("altLang", u);
        if (nullableNotEquals(e, null)) {
            u = e.value.toString();
            a.ad.h("sz", u);
        }
        if (nullableNotEquals(f, null)) {
            u = ST_OnOff.g(f.value);
            a.ad.h("b", u);
        }
        if (nullableNotEquals(g, null)) {
            u = ST_OnOff.g(g.value);
            a.ad.h("i", u);
        }
        if (nullableNotEquals(h, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextUnderlineType_$type, h.value);
            a.ad.h("u", u);
        }
        if (nullableNotEquals(i, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextStrikeType_$type, i.value);
            a.ad.h("strike", u);
        }
        if (nullableNotEquals(j, null)) {
            u = j.value.toString();
            a.ad.h("kern", u);
        }
        if (nullableNotEquals(k, null)) {
            u = XmlNamespaceDefinitionBase.f(ST_TextCapsType_$type, k.value);
            a.ad.h("cap", u);
        }
        if (nullableNotEquals(l, null)) {
            u = l.value.toString();
            a.ad.h("spc", u);
        }
        if (nullableNotEquals(m, null)) {
            u = ST_OnOff.g(m.value);
            a.ad.h("normalizeH", u);
        }
        if (ST_Percentage.h(n, Nullable$1.toNullable(ST_Percentage.$, null))) {
            u = n.value.r(a.d._z);
            a.ad.h("baseline", u);
        }
        if (nullableNotEquals(o, null)) {
            u = ST_OnOff.g(o.value);
            a.ad.h("noProof", u);
        }
        if (p.hasValue && nullableNotEquals(p, true)) {
            u = ST_OnOff.g(p.value);
            a.ad.h("dirty", u);
        }
        if (q.hasValue && nullableNotEquals(q, false)) {
            u = ST_OnOff.g(q.value);
            a.ad.h("err", u);
        }
        if (r.hasValue && nullableNotEquals(r, true)) {
            u = ST_OnOff.g(r.value);
            a.ad.h("smtClean", u);
        }
        if (s.hasValue && nullableNotEquals(s, 0)) {
            u = s.value.toString();
            a.ad.h("smtId", u);
        }
        u = t;
        a.ad.h("bmk", u);
    }
    static mt(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.ia, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pu(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.ia, b);
    }
    static mu(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.ib, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pv(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.ib, b);
    }
    static mv(a, b) {
        let c = DrawingMLMain.k0(a, DrawingMLMain.ic, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static pw(a, b) {
        DrawingMLMain.n1(a, DrawingMLMain.ic, b);
    }
    static mw(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SchemeColorVal_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static px(a, b) {
        a.ad.p(DrawingMLMain.ie, "a");
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_SchemeColorVal_$type, b);
        a.ad.h("val", c);
    }
    static mx(a, b) {
        let c = DrawingMLMain.k3(a, DrawingMLMain.ii, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static py(a, b) {
        DrawingMLMain.n4(a, DrawingMLMain.ii, b);
    }
    static my(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static pz(a) {
        a.ad.p(DrawingMLMain.io, "a");
    }
    static mz(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        i = false;
        j = false;
        k = false;
        l = false;
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "noGrp":
                    b = ST_OnOff.e(m.d);
                    break;
                case "noSelect":
                    c = ST_OnOff.e(m.d);
                    break;
                case "noRot":
                    d = ST_OnOff.e(m.d);
                    break;
                case "noChangeAspect":
                    e = ST_OnOff.e(m.d);
                    break;
                case "noMove":
                    f = ST_OnOff.e(m.d);
                    break;
                case "noResize":
                    g = ST_OnOff.e(m.d);
                    break;
                case "noEditPoints":
                    h = ST_OnOff.e(m.d);
                    break;
                case "noAdjustHandles":
                    i = ST_OnOff.e(m.d);
                    break;
                case "noChangeArrowheads":
                    j = ST_OnOff.e(m.d);
                    break;
                case "noChangeShapeType":
                    k = ST_OnOff.e(m.d);
                    break;
                case "noTextEdit":
                    l = ST_OnOff.e(m.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static p0(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false, l = false) {
        a.ad.p(DrawingMLMain.iy, "a");
        let m;
        if (b != false) {
            m = ST_OnOff.g(b);
            a.ad.h("noGrp", m);
        }
        if (c != false) {
            m = ST_OnOff.g(c);
            a.ad.h("noSelect", m);
        }
        if (d != false) {
            m = ST_OnOff.g(d);
            a.ad.h("noRot", m);
        }
        if (e != false) {
            m = ST_OnOff.g(e);
            a.ad.h("noChangeAspect", m);
        }
        if (f != false) {
            m = ST_OnOff.g(f);
            a.ad.h("noMove", m);
        }
        if (g != false) {
            m = ST_OnOff.g(g);
            a.ad.h("noResize", m);
        }
        if (h != false) {
            m = ST_OnOff.g(h);
            a.ad.h("noEditPoints", m);
        }
        if (i != false) {
            m = ST_OnOff.g(i);
            a.ad.h("noAdjustHandles", m);
        }
        if (j != false) {
            m = ST_OnOff.g(j);
            a.ad.h("noChangeArrowheads", m);
        }
        if (k != false) {
            m = ST_OnOff.g(k);
            a.ad.h("noChangeShapeType", m);
        }
        if (l != false) {
            m = ST_OnOff.g(l);
            a.ad.h("noTextEdit", m);
        }
    }
    static m0(a, b, c, d, e) {
        let f = DrawingMLMain.k6(a, DrawingMLMain.iz, b, c, d, e);
        b = f.p2;
        c = f.p3;
        d = f.p4;
        e = f.p5;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static p1(a, b, c, d, e) {
        DrawingMLMain.n7(a, DrawingMLMain.iz, b, c, d, e);
    }
    static m1(a, b) {
        b = ST_HexColorRGB.a;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = ST_HexColorRGB.d(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static p2(a, b) {
        a.ad.p(DrawingMLMain.i0, "a");
        let c;
        c = b.toString();
        a.ad.h("val", c);
    }
    static m2(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static p3(a) {
        a.ad.p(DrawingMLMain.i2, "a");
    }
    static m3(a, b, c) {
        b = 0;
        c = ST_HexColorRGB.a;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_SystemColorVal_$type, d.d, b);
                    break;
                case "lastClr":
                    c = ST_HexColorRGB.d(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static p4(a, b, c) {
        a.ad.p(DrawingMLMain.i8, "a");
        let d;
        d = XmlNamespaceDefinitionBase.f(ST_SystemColorVal_$type, b);
        a.ad.h("val", d);
        d = c.toString();
        a.ad.h("lastClr", d);
    }
    static m4(a, b, c, d) {
        let e = DrawingMLMain.ky(a, DrawingMLMain.je, b, c, d);
        b = e.p2;
        c = e.p3;
        d = e.p4;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static p5(a, b, c, d) {
        DrawingMLMain.nz(a, DrawingMLMain.je, b, c, d);
    }
    static m5(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, DrawingMLMain.ja, b, 6);
        b = c.p2;
        return {
            p1: b
        };
    }
    static p6(a, b) {
        XmlNamespaceDefinitionBase.ai(a, DrawingMLMain.ja, "a", b, void 0, 6);
    }
    static m6(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "name":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static p7(a, b) {
        a.ad.p(DrawingMLMain.jg, "a");
        let c;
        c = b;
        a.ad.h("name", c);
        a.ad.l(IGOfficeExtensions.an, true);
    }
    static m7(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static p8(a) {
        a.ad.p(DrawingMLMain.jh, "a");
    }
    static m8(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static p9(a) {
        a.ad.p(DrawingMLMain.ji, "a");
    }
    static m9(a, b) {
        let c = DrawingMLMain.k3(a, DrawingMLMain.jm, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static qa(a, b) {
        DrawingMLMain.n4(a, DrawingMLMain.jm, b);
    }
    static na(a, b, c, d) {
        b = ST_Angle.a(0);
        c = false;
        d = false;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "rot":
                    b = ST_Angle.b(e.d);
                    break;
                case "flipH":
                    c = ST_OnOff.e(e.d);
                    break;
                case "flipV":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static qb(a, b = new ST_Angle(), c = false, d = false) {
        a.ad.p(DrawingMLMain.j8, "a");
        let e;
        if (b.n() != 0) {
            e = b.toString();
            a.ad.h("rot", e);
        }
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("flipH", e);
        }
        if (d != false) {
            e = ST_OnOff.g(d);
            a.ad.h("flipV", e);
        }
    }
}
DrawingMLMain.$t = markType(DrawingMLMain, 'DrawingMLMain', XmlNamespaceDefinitionBase.$);
DrawingMLMain.gp = "http://schemas.openxmlformats.org/drawingml/2006/main";
DrawingMLMain.go = "http://purl.oclc.org/ooxml/drawingml/main";
DrawingMLMain.aq = DrawingMLMain.go + "/accent1";
DrawingMLMain.ar = DrawingMLMain.go + "/accent2";
DrawingMLMain.as = DrawingMLMain.go + "/accent3";
DrawingMLMain.at = DrawingMLMain.go + "/accent4";
DrawingMLMain.au = DrawingMLMain.go + "/accent5";
DrawingMLMain.av = DrawingMLMain.go + "/accent6";
DrawingMLMain.ay = DrawingMLMain.go + "/ahPolar";
DrawingMLMain.az = DrawingMLMain.go + "/ahXY";
DrawingMLMain.a1 = DrawingMLMain.go + "/alpha";
DrawingMLMain.a6 = DrawingMLMain.go + "/alphaMod";
DrawingMLMain.a8 = DrawingMLMain.go + "/alphaOff";
DrawingMLMain.bf = DrawingMLMain.go + "/arcTo";
DrawingMLMain.bg = DrawingMLMain.go + "/avLst";
DrawingMLMain.bs = DrawingMLMain.go + "/blip";
DrawingMLMain.bt = DrawingMLMain.go + "/blipFill";
DrawingMLMain.bu = DrawingMLMain.go + "/blue";
DrawingMLMain.bv = DrawingMLMain.go + "/blueMod";
DrawingMLMain.bw = DrawingMLMain.go + "/blueOff";
DrawingMLMain.bz = DrawingMLMain.go + "/bodyPr";
DrawingMLMain.cg = DrawingMLMain.go + "/chExt";
DrawingMLMain.ch = DrawingMLMain.go + "/chOff";
DrawingMLMain.ci = DrawingMLMain.go + "/close";
DrawingMLMain.cm = DrawingMLMain.go + "/clrScheme";
DrawingMLMain.cp = DrawingMLMain.go + "/comp";
DrawingMLMain.ct = DrawingMLMain.go + "/cs";
DrawingMLMain.cv = DrawingMLMain.go + "/cubicBezTo";
DrawingMLMain.cw = DrawingMLMain.go + "/custClr";
DrawingMLMain.cx = DrawingMLMain.go + "/custClrLst";
DrawingMLMain.cz = DrawingMLMain.go + "/custGeom";
DrawingMLMain.c9 = DrawingMLMain.go + "/dk1";
DrawingMLMain.da = DrawingMLMain.go + "/dk2";
DrawingMLMain.de = DrawingMLMain.go + "/ea";
DrawingMLMain.dj = DrawingMLMain.go + "/effectRef";
DrawingMLMain.dq = DrawingMLMain.go + "/ext";
DrawingMLMain.dr = DrawingMLMain.go + "/extLst";
DrawingMLMain.ds = DrawingMLMain.go + "/extraClrScheme";
DrawingMLMain.dt = DrawingMLMain.go + "/extraClrSchemeLst";
DrawingMLMain.dy = DrawingMLMain.go + "/fillRect";
DrawingMLMain.dz = DrawingMLMain.go + "/fillRef";
DrawingMLMain.d7 = DrawingMLMain.go + "/fmtScheme";
DrawingMLMain.d8 = DrawingMLMain.go + "/folHlink";
DrawingMLMain.d9 = DrawingMLMain.go + "/font";
DrawingMLMain.eb = DrawingMLMain.go + "/fontRef";
DrawingMLMain.ec = DrawingMLMain.go + "/fontScheme";
DrawingMLMain.eg = DrawingMLMain.go + "/gd";
DrawingMLMain.ek = DrawingMLMain.go + "/graphic";
DrawingMLMain.el = DrawingMLMain.go + "/graphicData";
DrawingMLMain.em = DrawingMLMain.go + "/graphicFrameLocks";
DrawingMLMain.en = DrawingMLMain.go + "/gray";
DrawingMLMain.ep = DrawingMLMain.go + "/green";
DrawingMLMain.eq = DrawingMLMain.go + "/greenMod";
DrawingMLMain.er = DrawingMLMain.go + "/greenOff";
DrawingMLMain.es = DrawingMLMain.go + "/grpFill";
DrawingMLMain.ew = DrawingMLMain.go + "/headEnd";
DrawingMLMain.e1 = DrawingMLMain.go + "/hlink";
DrawingMLMain.e2 = DrawingMLMain.go + "/hlinkClick";
DrawingMLMain.e8 = DrawingMLMain.go + "/hue";
DrawingMLMain.e9 = DrawingMLMain.go + "/hueMod";
DrawingMLMain.fa = DrawingMLMain.go + "/hueOff";
DrawingMLMain.fg = DrawingMLMain.go + "/inv";
DrawingMLMain.fq = DrawingMLMain.go + "/latin";
DrawingMLMain.fw = DrawingMLMain.go + "/ln";
DrawingMLMain.fx = DrawingMLMain.go + "/lnRef";
DrawingMLMain.f0 = DrawingMLMain.go + "/lnTo";
DrawingMLMain.f1 = DrawingMLMain.go + "/lstStyle";
DrawingMLMain.f2 = DrawingMLMain.go + "/lt1";
DrawingMLMain.f3 = DrawingMLMain.go + "/lt2";
DrawingMLMain.f4 = DrawingMLMain.go + "/lum";
DrawingMLMain.f5 = DrawingMLMain.go + "/lumMod";
DrawingMLMain.f6 = DrawingMLMain.go + "/lumOff";
DrawingMLMain.gh = DrawingMLMain.go + "/majorFont";
DrawingMLMain.gk = DrawingMLMain.go + "/minorFont";
DrawingMLMain.gm = DrawingMLMain.go + "/moveTo";
DrawingMLMain.gy = DrawingMLMain.go + "/noFill";
DrawingMLMain.ha = DrawingMLMain.go + "/objectDefaults";
DrawingMLMain.hb = DrawingMLMain.go + "/off";
DrawingMLMain.hd = DrawingMLMain.go + "/p";
DrawingMLMain.hi = DrawingMLMain.go + "/picLocks";
DrawingMLMain.hl = DrawingMLMain.go + "/pPr";
DrawingMLMain.hn = DrawingMLMain.go + "/prstClr";
DrawingMLMain.hp = DrawingMLMain.go + "/prstGeom";
DrawingMLMain.hs = DrawingMLMain.go + "/pt";
DrawingMLMain.ht = DrawingMLMain.go + "/quadBezTo";
DrawingMLMain.hu = DrawingMLMain.go + "/r";
DrawingMLMain.hx = DrawingMLMain.go + "/red";
DrawingMLMain.hy = DrawingMLMain.go + "/redMod";
DrawingMLMain.hz = DrawingMLMain.go + "/redOff";
DrawingMLMain.h7 = DrawingMLMain.go + "/rPr";
DrawingMLMain.ia = DrawingMLMain.go + "/sat";
DrawingMLMain.ib = DrawingMLMain.go + "/satMod";
DrawingMLMain.ic = DrawingMLMain.go + "/satOff";
DrawingMLMain.ie = DrawingMLMain.go + "/schemeClr";
DrawingMLMain.ii = DrawingMLMain.go + "/shade";
DrawingMLMain.io = DrawingMLMain.go + "/solidFill";
DrawingMLMain.iy = DrawingMLMain.go + "/spLocks";
DrawingMLMain.iz = DrawingMLMain.go + "/srcRect";
DrawingMLMain.i0 = DrawingMLMain.go + "/srgbClr";
DrawingMLMain.i2 = DrawingMLMain.go + "/stretch";
DrawingMLMain.i8 = DrawingMLMain.go + "/sysClr";
DrawingMLMain.ja = DrawingMLMain.go + "/t";
DrawingMLMain.je = DrawingMLMain.go + "/tailEnd";
DrawingMLMain.jg = DrawingMLMain.go + "/theme";
DrawingMLMain.jh = DrawingMLMain.go + "/themeElements";
DrawingMLMain.ji = DrawingMLMain.go + "/themeManager";
DrawingMLMain.jm = DrawingMLMain.go + "/tint";
DrawingMLMain.j8 = DrawingMLMain.go + "/xfrm";
DrawingMLMain.gr = DrawingMLMain.go + "/noAutofit";
DrawingMLMain.g5 = DrawingMLMain.go + "/normAutofit";
DrawingMLMain.hr = DrawingMLMain.go + "/prstTxWarp";
DrawingMLMain.id = DrawingMLMain.go + "/scene3d";
DrawingMLMain.ip = DrawingMLMain.go + "/sp3d";
DrawingMLMain.iq = DrawingMLMain.go + "/spAutoFit";
DrawingMLMain.bi = DrawingMLMain.go + "/backdrop";
DrawingMLMain.bl = DrawingMLMain.go + "/bevelB";
DrawingMLMain.bm = DrawingMLMain.go + "/bevelT";
DrawingMLMain.cd = DrawingMLMain.go + "/camera";
DrawingMLMain.ft = DrawingMLMain.go + "/lightRig";
DrawingMLMain.hc = DrawingMLMain.go + "/outerShdw";
DrawingMLMain.bc = DrawingMLMain.go + "/anchor";
DrawingMLMain.g3 = DrawingMLMain.go + "/norm";
DrawingMLMain.jy = DrawingMLMain.go + "/up";
DrawingMLMain.h3 = DrawingMLMain.go + "/rot";
DrawingMLMain.cs = DrawingMLMain.go + "/contourClr";
DrawingMLMain.du = DrawingMLMain.go + "/extrusionClr";
DrawingMLMain.e7 = DrawingMLMain.go + "/hslClr";
DrawingMLMain.ig = DrawingMLMain.go + "/scrgbClr";
DrawingMLMain.ef = DrawingMLMain.go + "/gamma";
DrawingMLMain.fi = DrawingMLMain.go + "/invGamma";
DrawingMLMain.dh = DrawingMLMain.go + "/effectDag";
DrawingMLMain.di = DrawingMLMain.go + "/effectLst";
DrawingMLMain.ej = DrawingMLMain.go + "/gradFill";
DrawingMLMain.ey = DrawingMLMain.go + "/highlight";
DrawingMLMain.e3 = DrawingMLMain.go + "/hlinkMouseOver";
DrawingMLMain.hh = DrawingMLMain.go + "/pattFill";
DrawingMLMain.i7 = DrawingMLMain.go + "/sym";
DrawingMLMain.ju = DrawingMLMain.go + "/uFill";
DrawingMLMain.jv = DrawingMLMain.go + "/uFillTx";
DrawingMLMain.jw = DrawingMLMain.go + "/uLn";
DrawingMLMain.jx = DrawingMLMain.go + "/uLnTx";
DrawingMLMain.a2 = DrawingMLMain.go + "/alphaBiLevel";
DrawingMLMain.a3 = DrawingMLMain.go + "/alphaCeiling";
DrawingMLMain.a4 = DrawingMLMain.go + "/alphaFloor";
DrawingMLMain.a5 = DrawingMLMain.go + "/alphaInv";
DrawingMLMain.a7 = DrawingMLMain.go + "/alphaModFix";
DrawingMLMain.ba = DrawingMLMain.go + "/alphaRepl";
DrawingMLMain.a9 = DrawingMLMain.go + "/alphaOutset";
DrawingMLMain.br = DrawingMLMain.go + "/blend";
DrawingMLMain.jj = DrawingMLMain.go + "/tile";
DrawingMLMain.bp = DrawingMLMain.go + "/biLevel";
DrawingMLMain.bx = DrawingMLMain.go + "/blur";
DrawingMLMain.cj = DrawingMLMain.go + "/clrChange";
DrawingMLMain.cl = DrawingMLMain.go + "/clrRepl";
DrawingMLMain.dd = DrawingMLMain.go + "/duotone";
DrawingMLMain.dg = DrawingMLMain.go + "/effect";
DrawingMLMain.dw = DrawingMLMain.go + "/fill";
DrawingMLMain.dx = DrawingMLMain.go + "/fillOverlay";
DrawingMLMain.eo = DrawingMLMain.go + "/grayscl";
DrawingMLMain.e6 = DrawingMLMain.go + "/hsl";
DrawingMLMain.ck = DrawingMLMain.go + "/clrFrom";
DrawingMLMain.cn = DrawingMLMain.go + "/clrTo";
DrawingMLMain.ei = DrawingMLMain.go + "/glow";
DrawingMLMain.ff = DrawingMLMain.go + "/innerShdw";
DrawingMLMain.hq = DrawingMLMain.go + "/prstShdw";
DrawingMLMain.h0 = DrawingMLMain.go + "/reflection";
DrawingMLMain.im = DrawingMLMain.go + "/softEdge";
DrawingMLMain.eu = DrawingMLMain.go + "/gsLst";
DrawingMLMain.fu = DrawingMLMain.go + "/lin";
DrawingMLMain.hf = DrawingMLMain.go + "/path";
DrawingMLMain.jk = DrawingMLMain.go + "/tileRect";
DrawingMLMain.et = DrawingMLMain.go + "/gs";
DrawingMLMain.il = DrawingMLMain.go + "/snd";
DrawingMLMain.bk = DrawingMLMain.go + "/bevel";
DrawingMLMain.cy = DrawingMLMain.go + "/custDash";
DrawingMLMain.ho = DrawingMLMain.go + "/prstDash";
DrawingMLMain.gl = DrawingMLMain.go + "/miter";
DrawingMLMain.h6 = DrawingMLMain.go + "/round";
DrawingMLMain.dc = DrawingMLMain.go + "/ds";
DrawingMLMain.bn = DrawingMLMain.go + "/bgClr";
DrawingMLMain.dv = DrawingMLMain.go + "/fgClr";
DrawingMLMain.ax = DrawingMLMain.go + "/ahLst";
DrawingMLMain.c2 = DrawingMLMain.go + "/cxnLst";
DrawingMLMain.eh = DrawingMLMain.go + "/gdLst";
DrawingMLMain.hg = DrawingMLMain.go + "/pathLst";
DrawingMLMain.hw = DrawingMLMain.go + "/rect";
DrawingMLMain.c1 = DrawingMLMain.go + "/cxn";
DrawingMLMain.hk = DrawingMLMain.go + "/pos";
DrawingMLMain.d2 = DrawingMLMain.go + "/flatTx";
DrawingMLMain.bo = DrawingMLMain.go + "/bgFillStyleLst";
DrawingMLMain.dl = DrawingMLMain.go + "/effectStyleLst";
DrawingMLMain.d0 = DrawingMLMain.go + "/fillStyleLst";
DrawingMLMain.fz = DrawingMLMain.go + "/lnStyleLst";
DrawingMLMain.cr = DrawingMLMain.go + "/cont";
DrawingMLMain.d1 = DrawingMLMain.go + "/fillToRect";
DrawingMLMain.dk = DrawingMLMain.go + "/effectStyle";
DrawingMLMain.h1 = DrawingMLMain.go + "/relOff";
DrawingMLMain.c4 = DrawingMLMain.go + "/defPPr";
DrawingMLMain.f8 = DrawingMLMain.go + "/lvl1pPr";
DrawingMLMain.f9 = DrawingMLMain.go + "/lvl2pPr";
DrawingMLMain.ga = DrawingMLMain.go + "/lvl3pPr";
DrawingMLMain.gb = DrawingMLMain.go + "/lvl4pPr";
DrawingMLMain.gc = DrawingMLMain.go + "/lvl5pPr";
DrawingMLMain.gd = DrawingMLMain.go + "/lvl6pPr";
DrawingMLMain.ge = DrawingMLMain.go + "/lvl7pPr";
DrawingMLMain.gf = DrawingMLMain.go + "/lvl8pPr";
DrawingMLMain.gg = DrawingMLMain.go + "/lvl9pPr";
DrawingMLMain.fy = DrawingMLMain.go + "/lnSpc";
DrawingMLMain.is = DrawingMLMain.go + "/spcAft";
DrawingMLMain.it = DrawingMLMain.go + "/spcBef";
DrawingMLMain.iw = DrawingMLMain.go + "/spcPct";
DrawingMLMain.ix = DrawingMLMain.go + "/spcPts";
DrawingMLMain.b4 = DrawingMLMain.go + "/buClr";
DrawingMLMain.b5 = DrawingMLMain.go + "/buClrTx";
DrawingMLMain.b6 = DrawingMLMain.go + "/buFont";
DrawingMLMain.b7 = DrawingMLMain.go + "/buFontTx";
DrawingMLMain.b9 = DrawingMLMain.go + "/buSzPct";
DrawingMLMain.ca = DrawingMLMain.go + "/buSzPts";
DrawingMLMain.cb = DrawingMLMain.go + "/buSzTx";
DrawingMLMain.b1 = DrawingMLMain.go + "/buAutoNum";
DrawingMLMain.b8 = DrawingMLMain.go + "/buNone";
DrawingMLMain.b2 = DrawingMLMain.go + "/buBlip";
DrawingMLMain.b3 = DrawingMLMain.go + "/buChar";
DrawingMLMain.c5 = DrawingMLMain.go + "/defRPr";
DrawingMLMain.jc = DrawingMLMain.go + "/tab";
DrawingMLMain.b0 = DrawingMLMain.go + "/br";
DrawingMLMain.d3 = DrawingMLMain.go + "/fld";
DrawingMLMain.dm = DrawingMLMain.go + "/endParaRPr";
DrawingMLMain.jd = DrawingMLMain.go + "/tabLst";
DrawingMLMain.an = new DrawingMLMain();
/**
 * @hidden
 */
export class DrawingNamespaceDefinitionBase extends XmlNamespaceDefinitionBase {
    constructor(a, b) {
        super();
        this.an = null;
        this.ap = null;
        this.aq = null;
        this.ar = null;
        this.as = null;
        this.at = null;
        this.au = null;
        this.av = null;
        this.aw = null;
        this.ay = null;
        this.a3 = null;
        this.a4 = null;
        this.a5 = null;
        this.a6 = null;
        this.bn = null;
        this.bo = null;
        this.bp = null;
        this.bq = null;
        this.br = null;
        this.bs = null;
        this.bw = null;
        this.bx = null;
        this.by = null;
        this.bz = null;
        this.b1 = null;
        this.b3 = null;
        this.ba = null;
        this.bb = null;
        this.ba = a;
        this.bb = b;
        this.an = a + "/blipFill";
        this.ap = a + "/cNvCxnSpPr";
        this.aq = a + "/cNvGraphicFramePr";
        this.ar = a + "/cNvGrpSpPr";
        this.as = a + "/cNvPicPr";
        this.at = a + "/cNvPr";
        this.au = a + "/cNvSpPr";
        this.av = a + "/cxnSp";
        this.aw = a + "/cxnSpLocks";
        this.ay = a + "/endCxn";
        this.a3 = a + "/graphicFrame";
        this.a4 = a + "/grpSp";
        this.a5 = a + "/grpSpLocks";
        this.a6 = a + "/grpSpPr";
        this.bn = a + "/nvCxnSpPr";
        this.bo = a + "/nvGraphicFramePr";
        this.bp = a + "/nvGrpSpPr";
        this.bq = a + "/nvPicPr";
        this.br = a + "/nvSpPr";
        this.bs = a + "/pic";
        this.bw = a + "/sp";
        this.bx = a + "/spPr";
        this.by = a + "/stCxn";
        this.bz = a + "/style";
        this.b1 = a + "/txBody";
        this.b3 = a + "/xfrm";
    }
    i(a) {
        switch (a) {
            case 0: return this.bb;
            case 1: return this.ba;
            default: return this.bb;
        }
    }
    cb(a, b, c, d) {
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "id":
                    c = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "idx":
                    d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d
        };
    }
    c2(a, b, c = 0, d = 0) {
        a.ad.p(b, this.j);
        let e;
        if (c != 0) {
            e = c.toString();
            a.ad.h("id", e);
        }
        if (d != 0) {
            e = d.toString();
            a.ad.h("idx", e);
        }
    }
    static da(a, b) {
        if (stringIsNullOrEmpty(b)) {
            return;
        }
        DrawingNamespaceDefinitionBase.da(a, b);
    }
    b4(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "dpi":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "rotWithShape":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    cv(a, b, c) {
        a.ad.p(this.an, this.j);
        let d;
        if (nullableNotEquals(b, null)) {
            d = b.value.toString();
            a.ad.h("dpi", d);
        }
        if (nullableNotEquals(c, null)) {
            d = ST_OnOff.g(c.value);
            a.ad.h("rotWithShape", d);
        }
    }
    b5(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    cw(a) {
        a.ad.p(this.ap, this.j);
    }
    b6(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    cx(a) {
        a.ad.p(this.aq, this.j);
    }
    b7(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    cy(a) {
        a.ad.p(this.ar, this.j);
    }
    b8(a, b) {
        b = true;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "preferRelativeResize":
                    b = ST_OnOff.e(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    cz(a, b = true) {
        a.ad.p(this.as, this.j);
        let c;
        if (b != true) {
            c = ST_OnOff.g(b);
            a.ad.h("preferRelativeResize", c);
        }
    }
    b9(a, b, c, d, e, f) {
        let g = DrawingMLMain.kz(a, this.at, b, c, d, e, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        f = g.p6;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    c0(a, b, c, d = null, e = false, f = null) {
        DrawingMLMain.n0(a, this.at, b, c, d, e, f);
    }
    ca(a, b) {
        b = false;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "txBox":
                    b = ST_OnOff.e(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    c1(a, b = false) {
        a.ad.p(this.au, this.j);
        let c;
        if (b != false) {
            c = ST_OnOff.g(b);
            a.ad.h("txBox", c);
        }
    }
    cc(a, b, c) {
        b = null;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "macro":
                    b = d.d;
                    break;
                case "fPublished":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    c3(a, b = null, c = false) {
        a.ad.p(this.av, this.j);
        let d;
        d = b;
        DrawingNamespaceDefinitionBase.da(a, d);
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("fPublished", d);
        }
    }
    cd(a, b, c, d, e, f, g, h, i, j, k) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        i = false;
        j = false;
        k = false;
        for (let l of fromEnum(a.ab.u)) {
            switch (l.a.e(a.d)) {
                case "noGrp":
                    b = ST_OnOff.e(l.d);
                    break;
                case "noSelect":
                    c = ST_OnOff.e(l.d);
                    break;
                case "noRot":
                    d = ST_OnOff.e(l.d);
                    break;
                case "noChangeAspect":
                    e = ST_OnOff.e(l.d);
                    break;
                case "noMove":
                    f = ST_OnOff.e(l.d);
                    break;
                case "noResize":
                    g = ST_OnOff.e(l.d);
                    break;
                case "noEditPoints":
                    h = ST_OnOff.e(l.d);
                    break;
                case "noAdjustHandles":
                    i = ST_OnOff.e(l.d);
                    break;
                case "noChangeArrowheads":
                    j = ST_OnOff.e(l.d);
                    break;
                case "noChangeShapeType":
                    k = ST_OnOff.e(l.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k
        };
    }
    c4(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false) {
        a.ad.p(this.aw, this.j);
        let l;
        if (b != false) {
            l = ST_OnOff.g(b);
            a.ad.h("noGrp", l);
        }
        if (c != false) {
            l = ST_OnOff.g(c);
            a.ad.h("noSelect", l);
        }
        if (d != false) {
            l = ST_OnOff.g(d);
            a.ad.h("noRot", l);
        }
        if (e != false) {
            l = ST_OnOff.g(e);
            a.ad.h("noChangeAspect", l);
        }
        if (f != false) {
            l = ST_OnOff.g(f);
            a.ad.h("noMove", l);
        }
        if (g != false) {
            l = ST_OnOff.g(g);
            a.ad.h("noResize", l);
        }
        if (h != false) {
            l = ST_OnOff.g(h);
            a.ad.h("noEditPoints", l);
        }
        if (i != false) {
            l = ST_OnOff.g(i);
            a.ad.h("noAdjustHandles", l);
        }
        if (j != false) {
            l = ST_OnOff.g(j);
            a.ad.h("noChangeArrowheads", l);
        }
        if (k != false) {
            l = ST_OnOff.g(k);
            a.ad.h("noChangeShapeType", l);
        }
    }
    ce(a, b, c) {
        let d = this.cb(a, this.ay, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    c5(a, b = 0, c = 0) {
        this.c2(a, this.ay, b, c);
    }
    cf(a, b, c) {
        b = null;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "macro":
                    b = d.d;
                    break;
                case "fPublished":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    c6(a, b = null, c = false) {
        a.ad.p(this.a3, this.j);
        let d;
        d = b;
        DrawingNamespaceDefinitionBase.da(a, d);
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("fPublished", d);
        }
    }
    cg(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    c7(a) {
        a.ad.p(this.a4, this.j);
    }
    ch(a, b, c, d, e, f, g, h) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = false;
        g = false;
        h = false;
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "noGrp":
                    b = ST_OnOff.e(i.d);
                    break;
                case "noUngrp":
                    c = ST_OnOff.e(i.d);
                    break;
                case "noSelect":
                    d = ST_OnOff.e(i.d);
                    break;
                case "noRot":
                    e = ST_OnOff.e(i.d);
                    break;
                case "noChangeAspect":
                    f = ST_OnOff.e(i.d);
                    break;
                case "noMove":
                    g = ST_OnOff.e(i.d);
                    break;
                case "noResize":
                    h = ST_OnOff.e(i.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    c8(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false) {
        a.ad.p(this.a5, this.j);
        let i;
        if (b != false) {
            i = ST_OnOff.g(b);
            a.ad.h("noGrp", i);
        }
        if (c != false) {
            i = ST_OnOff.g(c);
            a.ad.h("noUngrp", i);
        }
        if (d != false) {
            i = ST_OnOff.g(d);
            a.ad.h("noSelect", i);
        }
        if (e != false) {
            i = ST_OnOff.g(e);
            a.ad.h("noRot", i);
        }
        if (f != false) {
            i = ST_OnOff.g(f);
            a.ad.h("noChangeAspect", i);
        }
        if (g != false) {
            i = ST_OnOff.g(g);
            a.ad.h("noMove", i);
        }
        if (h != false) {
            i = ST_OnOff.g(h);
            a.ad.h("noResize", i);
        }
    }
    ci(a, b) {
        b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "bwMode":
                    b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    c9(a, b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null)) {
        a.ad.p(this.a6, this.j);
        let c;
        if (nullableNotEquals(b, null)) {
            c = XmlNamespaceDefinitionBase.f(ST_BlackWhiteMode_$type, b.value);
            a.ad.h("bwMode", c);
        }
    }
    cj(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    db(a) {
        a.ad.p(this.bn, this.j);
    }
    ck(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    dc(a) {
        a.ad.p(this.bo, this.j);
    }
    cl(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    dd(a) {
        a.ad.p(this.bp, this.j);
    }
    cm(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    de(a) {
        a.ad.p(this.bq, this.j);
    }
    cn(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    df(a) {
        a.ad.p(this.br, this.j);
    }
    co(a, b, c) {
        b = "";
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "macro":
                    b = d.d;
                    break;
                case "fPublished":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    dg(a, b = "", c = false) {
        a.ad.p(this.bs, this.j);
        let d;
        d = b;
        DrawingNamespaceDefinitionBase.da(a, d);
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("fPublished", d);
        }
    }
    cp(a, b, c, d, e) {
        b = null;
        c = null;
        d = true;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "macro":
                    b = f.d;
                    break;
                case "textlink":
                    c = f.d;
                    break;
                case "fLocksText":
                    d = ST_OnOff.e(f.d);
                    break;
                case "fPublished":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    dh(a, b = null, c = null, d = true, e = false) {
        a.ad.p(this.bw, this.j);
        let f;
        f = b;
        DrawingNamespaceDefinitionBase.da(a, f);
        f = c;
        a.ad.h("textlink", f);
        if (d != true) {
            f = ST_OnOff.g(d);
            a.ad.h("fLocksText", f);
        }
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("fPublished", f);
        }
    }
    cq(a, b) {
        b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "bwMode":
                    b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    di(a, b = Nullable$1.toNullable(ST_BlackWhiteMode_$type, null)) {
        a.ad.p(this.bx, this.j);
        let c;
        if (nullableNotEquals(b, null)) {
            c = XmlNamespaceDefinitionBase.f(ST_BlackWhiteMode_$type, b.value);
            a.ad.h("bwMode", c);
        }
    }
    cr(a, b, c) {
        let d = this.cb(a, this.by, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    dj(a, b = 0, c = 0) {
        this.c2(a, this.by, b, c);
    }
    cs(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    dk(a) {
        a.ad.p(this.bz, this.j);
    }
    ct(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    dl(a) {
        a.ad.p(this.b1, this.j);
    }
    cu(a, b, c, d) {
        b = ST_Angle.a(0);
        c = false;
        d = false;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "rot":
                    b = ST_Angle.b(e.d);
                    break;
                case "flipH":
                    c = ST_OnOff.e(e.d);
                    break;
                case "flipV":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    dm(a, b = new ST_Angle(), c = false, d = false) {
        a.ad.p(this.b3, this.j);
        let e;
        if (b.n() != 0) {
            e = b.toString();
            a.ad.h("rot", e);
        }
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("flipH", e);
        }
        if (d != false) {
            e = ST_OnOff.g(d);
            a.ad.h("flipV", e);
        }
    }
}
DrawingNamespaceDefinitionBase.$t = markType(DrawingNamespaceDefinitionBase, 'DrawingNamespaceDefinitionBase', XmlNamespaceDefinitionBase.$);
/**
 * @hidden
 */
export class EmptyNamespace extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        return stringEmpty();
    }
    get_j() {
        return stringEmpty();
    }
    get j() {
        return this.get_j();
    }
    static ap(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aq(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.o("xml");
        let d = a.d._z;
        a.ad.l(VmlNamespace.an);
        a.ad.l(OfficeNamespace.an);
    }
}
EmptyNamespace.$t = markType(EmptyNamespace, 'EmptyNamespace', XmlNamespaceDefinitionBase.$);
EmptyNamespace.an = new EmptyNamespace();
/**
 * @hidden
 */
export class IGOfficeExtensions extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        return IGOfficeExtensions.ar;
    }
    get_j() {
        return "ig";
    }
    get j() {
        return this.get_j();
    }
}
IGOfficeExtensions.$t = markType(IGOfficeExtensions, 'IGOfficeExtensions', XmlNamespaceDefinitionBase.$);
IGOfficeExtensions.ar = "http://schemas.infragistics.com/officeExtensions";
IGOfficeExtensions.ap = IGOfficeExtensions.ar + "/isSupported";
IGOfficeExtensions.aq = IGOfficeExtensions.ar + "/listId";
IGOfficeExtensions.as = IGOfficeExtensions.ar + "/nodeId";
IGOfficeExtensions.at = IGOfficeExtensions.ar + "/unclosedParagraph";
IGOfficeExtensions.an = new IGOfficeExtensions();
/**
 * @hidden
 */
export class MarkupCompatibility2006 extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        return MarkupCompatibility2006.at;
    }
    get_j() {
        return "mc";
    }
    get j() {
        return this.get_j();
    }
    static av(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ay(a) {
        a.ad.p(MarkupCompatibility2006.ap, "mc");
    }
    static aw(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "Requires":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static az(a, b) {
        MarkupCompatibility2006.a0(a, stringJoin1(String_$type, " ", Enumerable.o(XmlNamespaceDefinitionBase.$, String_$type, b, (c) => c.j)));
    }
    static a0(a, b) {
        a.ad.p(MarkupCompatibility2006.aq, "mc");
        let c;
        c = b;
        a.ad.h("Requires", c);
    }
    static ax(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static a1(a) {
        a.ad.p(MarkupCompatibility2006.ar, "mc");
    }
}
MarkupCompatibility2006.$t = markType(MarkupCompatibility2006, 'MarkupCompatibility2006', XmlNamespaceDefinitionBase.$);
MarkupCompatibility2006.at = "http://schemas.openxmlformats.org/markup-compatibility/2006";
MarkupCompatibility2006.ap = MarkupCompatibility2006.at + "/AlternateContent";
MarkupCompatibility2006.aq = MarkupCompatibility2006.at + "/Choice";
MarkupCompatibility2006.ar = MarkupCompatibility2006.at + "/Fallback";
MarkupCompatibility2006.as = MarkupCompatibility2006.at + "/Ignorable";
MarkupCompatibility2006.an = new MarkupCompatibility2006();
/**
 * @hidden
 */
export class OfficeDocumentDocPropsVTypes extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return OfficeDocumentDocPropsVTypes.a1;
            case 1: return OfficeDocumentDocPropsVTypes.a0;
            default: return OfficeDocumentDocPropsVTypes.a1;
        }
    }
    get_j() {
        return "vt";
    }
    get j() {
        return this.get_j();
    }
    static bt(a, b) {
        let c = XmlNamespaceDefinitionBase.o(a, OfficeDocumentDocPropsVTypes.at, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cf(a, b) {
        XmlNamespaceDefinitionBase.ac(a, OfficeDocumentDocPropsVTypes.at, "vt", b);
    }
    static bu(a, b) {
        let c = XmlNamespaceDefinitionBase.o(a, OfficeDocumentDocPropsVTypes.ao, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cg(a, b) {
        XmlNamespaceDefinitionBase.ac(a, OfficeDocumentDocPropsVTypes.ao, "vt", b);
    }
    static bv(a, b) {
        let c = XmlNamespaceDefinitionBase.m(a, OfficeDocumentDocPropsVTypes.au, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ch(a, b) {
        XmlNamespaceDefinitionBase.aa(a, OfficeDocumentDocPropsVTypes.au, "vt", b);
    }
    static bw(a, b) {
        let c = XmlNamespaceDefinitionBase.t(a, OfficeDocumentDocPropsVTypes.av, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ci(a, b) {
        XmlNamespaceDefinitionBase.ah(a, OfficeDocumentDocPropsVTypes.av, "vt", b);
    }
    static bx(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentDocPropsVTypes.aw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cj(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentDocPropsVTypes.aw, "vt", b);
    }
    static by(a, b) {
        let c = XmlNamespaceDefinitionBase.s(a, OfficeDocumentDocPropsVTypes.ax, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ck(a, b) {
        XmlNamespaceDefinitionBase.ag(a, OfficeDocumentDocPropsVTypes.ax, "vt", b);
    }
    static bz(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentDocPropsVTypes.ap, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cl(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentDocPropsVTypes.ap, "vt", b);
    }
    static b0(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentDocPropsVTypes.ay, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cm(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentDocPropsVTypes.ay, "vt", b);
    }
    static b1(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentDocPropsVTypes.az, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cn(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentDocPropsVTypes.az, "vt", b);
    }
    static b2(a, b) {
        let c = XmlNamespaceDefinitionBase.q(a, OfficeDocumentDocPropsVTypes.a2, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static co(a, b) {
        XmlNamespaceDefinitionBase.ae(a, OfficeDocumentDocPropsVTypes.a2, "vt", b);
    }
    static b3(a, b) {
        let c = XmlNamespaceDefinitionBase.p(a, OfficeDocumentDocPropsVTypes.a3, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cp(a, b) {
        XmlNamespaceDefinitionBase.ad(a, OfficeDocumentDocPropsVTypes.a3, "vt", b);
    }
    static b4(a, b) {
        let c = XmlNamespaceDefinitionBase.v(a, OfficeDocumentDocPropsVTypes.a5, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cq(a, b) {
        XmlNamespaceDefinitionBase.aj(a, OfficeDocumentDocPropsVTypes.a5, "vt", b);
    }
    static b5(a, b) {
        let c = XmlNamespaceDefinitionBase.y(a, OfficeDocumentDocPropsVTypes.a6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cr(a, b) {
        XmlNamespaceDefinitionBase.am(a, OfficeDocumentDocPropsVTypes.a6, "vt", b);
    }
    static b6(a, b) {
        let c = XmlNamespaceDefinitionBase.w(a, OfficeDocumentDocPropsVTypes.a7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cs(a, b) {
        XmlNamespaceDefinitionBase.ak(a, OfficeDocumentDocPropsVTypes.a7, "vt", b);
    }
    static b7(a, b) {
        let c = XmlNamespaceDefinitionBase.x(a, OfficeDocumentDocPropsVTypes.a8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ct(a, b) {
        XmlNamespaceDefinitionBase.al(a, OfficeDocumentDocPropsVTypes.a8, "vt", b);
    }
    static b8(a, b) {
        let c = XmlNamespaceDefinitionBase.w(a, OfficeDocumentDocPropsVTypes.a7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cu(a, b) {
        XmlNamespaceDefinitionBase.ak(a, OfficeDocumentDocPropsVTypes.a7, "vt", b);
    }
    static b9(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static cv(a) {
        a.ad.p(OfficeDocumentDocPropsVTypes.a9, "vt");
    }
    static ca(a, b, c) {
        b = 0;
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "baseType":
                    b = XmlNamespaceDefinitionBase.b(ST_VectorBaseType_$type, d.d, b);
                    break;
                case "size":
                    c = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static cw(a, b, c) {
        a.ad.p(OfficeDocumentDocPropsVTypes.ba, "vt");
        let d;
        d = XmlNamespaceDefinitionBase.f(ST_VectorBaseType_$type, b);
        a.ad.h("baseType", d);
        d = c.toString();
        a.ad.h("size", d);
    }
    static bb(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bu(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bc(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bu(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bd(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bv(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static be(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bw(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bf(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bx(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bg(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.by(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bh(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.bz(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bi(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b0(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bj(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b1(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bk(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b2(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bl(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b3(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bm(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b4(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bn(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b5(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bo(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b6(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bp(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b7(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static bq(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c;
        let d = OfficeDocumentDocPropsVTypes.b8(a, c);
        c = d.p1;
        b.setValue(c, a.ab.ab);
    }
    static br(a) {
        let b = a.s.a(IVariantValueContainer_$type);
        if (b == null) {
            return;
        }
        let c = new OfficeDocumentDocPropsVTypes_VariantPlaceholder(b, a.ab.ab);
        a.s.k(c);
    }
    static bs(a) {
        let b;
        let c;
        let d = OfficeDocumentDocPropsVTypes.ca(a, b, c);
        b = d.p1;
        c = d.p2;
        let e = new CT_Vector(0, c, b);
        a.s.k(e);
    }
    static cb(a) {
        a.ay(OfficeDocumentDocPropsVTypes.at, OfficeDocumentDocPropsVTypes.bb);
        a.ay(OfficeDocumentDocPropsVTypes.ao, OfficeDocumentDocPropsVTypes.bc);
        a.ay(OfficeDocumentDocPropsVTypes.au, OfficeDocumentDocPropsVTypes.bd);
        a.ay(OfficeDocumentDocPropsVTypes.av, OfficeDocumentDocPropsVTypes.be);
        a.ay(OfficeDocumentDocPropsVTypes.aw, OfficeDocumentDocPropsVTypes.bf);
        a.ay(OfficeDocumentDocPropsVTypes.ax, OfficeDocumentDocPropsVTypes.bg);
        a.ay(OfficeDocumentDocPropsVTypes.ap, OfficeDocumentDocPropsVTypes.bh);
        a.ay(OfficeDocumentDocPropsVTypes.ay, OfficeDocumentDocPropsVTypes.bi);
        a.ay(OfficeDocumentDocPropsVTypes.az, OfficeDocumentDocPropsVTypes.bj);
        a.ay(OfficeDocumentDocPropsVTypes.a2, OfficeDocumentDocPropsVTypes.bk);
        a.ay(OfficeDocumentDocPropsVTypes.a3, OfficeDocumentDocPropsVTypes.bl);
        a.ay(OfficeDocumentDocPropsVTypes.a5, OfficeDocumentDocPropsVTypes.bm);
        a.ay(OfficeDocumentDocPropsVTypes.a6, OfficeDocumentDocPropsVTypes.bn);
        a.ay(OfficeDocumentDocPropsVTypes.a7, OfficeDocumentDocPropsVTypes.bo);
        a.ay(OfficeDocumentDocPropsVTypes.a8, OfficeDocumentDocPropsVTypes.bp);
        a.ay(OfficeDocumentDocPropsVTypes.ar, OfficeDocumentDocPropsVTypes.bq);
        a.ay(OfficeDocumentDocPropsVTypes.a9, OfficeDocumentDocPropsVTypes.br);
        a.ay(OfficeDocumentDocPropsVTypes.ba, OfficeDocumentDocPropsVTypes.bs);
    }
    static cc(a, b) {
        let c = typeCast(String_$type, b);
        if (c != null) {
            OfficeDocumentDocPropsVTypes.cm(a, c);
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cj(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.ch(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.ci(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.ck(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cq(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cr(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cs(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.ct(a, typeGetValue(b));
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.co(a, b);
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cp(a, b);
        }
        else if (typeof b === 'number') {
            OfficeDocumentDocPropsVTypes.cg(a, b);
        }
        else {
            return;
        }
        a.ad.k();
    }
    static cd(a, b) {
        OfficeDocumentDocPropsVTypes.cv(a);
        OfficeDocumentDocPropsVTypes.cc(a, b);
        a.ad.k();
    }
    static ce(a, b) {
        OfficeDocumentDocPropsVTypes.cw(a, b.b, intSToU(b.a.length));
        if (b.b == 0) {
            DocCoreUtils.an(Base.$, b.a, (c) => OfficeDocumentDocPropsVTypes.cd(a, c));
        }
        else {
            DocCoreUtils.an(Base.$, b.a, (c) => OfficeDocumentDocPropsVTypes.cc(a, c));
        }
        a.ad.k();
    }
}
OfficeDocumentDocPropsVTypes.$t = markType(OfficeDocumentDocPropsVTypes, 'OfficeDocumentDocPropsVTypes', XmlNamespaceDefinitionBase.$);
OfficeDocumentDocPropsVTypes.a1 = "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes";
OfficeDocumentDocPropsVTypes.a0 = "http://purl.oclc.org/ooxml/officeDocument/docPropsVTypes";
OfficeDocumentDocPropsVTypes.at = OfficeDocumentDocPropsVTypes.a0 + "/cy";
OfficeDocumentDocPropsVTypes.ao = OfficeDocumentDocPropsVTypes.a0 + "/decimal";
OfficeDocumentDocPropsVTypes.au = OfficeDocumentDocPropsVTypes.a0 + "/i1";
OfficeDocumentDocPropsVTypes.av = OfficeDocumentDocPropsVTypes.a0 + "/i2";
OfficeDocumentDocPropsVTypes.aw = OfficeDocumentDocPropsVTypes.a0 + "/i4";
OfficeDocumentDocPropsVTypes.ax = OfficeDocumentDocPropsVTypes.a0 + "/i8";
OfficeDocumentDocPropsVTypes.ap = OfficeDocumentDocPropsVTypes.a0 + "/int";
OfficeDocumentDocPropsVTypes.a2 = OfficeDocumentDocPropsVTypes.a0 + "/r4";
OfficeDocumentDocPropsVTypes.a3 = OfficeDocumentDocPropsVTypes.a0 + "/r8";
OfficeDocumentDocPropsVTypes.a5 = OfficeDocumentDocPropsVTypes.a0 + "/ui1";
OfficeDocumentDocPropsVTypes.a6 = OfficeDocumentDocPropsVTypes.a0 + "/ui2";
OfficeDocumentDocPropsVTypes.a7 = OfficeDocumentDocPropsVTypes.a0 + "/ui4";
OfficeDocumentDocPropsVTypes.a8 = OfficeDocumentDocPropsVTypes.a0 + "/ui8";
OfficeDocumentDocPropsVTypes.ar = OfficeDocumentDocPropsVTypes.a0 + "/uint";
OfficeDocumentDocPropsVTypes.ay = OfficeDocumentDocPropsVTypes.a0 + "/lpstr";
OfficeDocumentDocPropsVTypes.az = OfficeDocumentDocPropsVTypes.a0 + "/lpwstr";
OfficeDocumentDocPropsVTypes.a9 = OfficeDocumentDocPropsVTypes.a0 + "/variant";
OfficeDocumentDocPropsVTypes.ba = OfficeDocumentDocPropsVTypes.a0 + "/vector";
OfficeDocumentDocPropsVTypes.an = new OfficeDocumentDocPropsVTypes();
/**
 * @hidden
 */
export let IVariantValueContainer_$type = new Type(null, 'IVariantValueContainer');
/**
 * @hidden
 */
export class OfficeDocumentDocPropsVTypes_VariantPlaceholder extends Base {
    constructor(a, b) {
        super();
        this.a = null;
        this.b = 0;
        this.a = a;
        this.b = b;
    }
    setValue(a, b) {
        this.a.setValue(a, this.b);
    }
}
OfficeDocumentDocPropsVTypes_VariantPlaceholder.$t = markType(OfficeDocumentDocPropsVTypes_VariantPlaceholder, 'OfficeDocumentDocPropsVTypes_VariantPlaceholder', Base.$, [IVariantValueContainer_$type]);
/**
 * @hidden
 */
export class CT_Vector extends Base {
    constructor(a, ..._rest) {
        super();
        this.b = 0;
        this.a = null;
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.b = d;
                    this.a = new Array(c);
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    this.b = d;
                    this.a = c.toArray();
                }
                break;
        }
    }
    setValue(a, b) {
        this.a[b] = a;
    }
}
CT_Vector.$t = markType(CT_Vector, 'CT_Vector', Base.$, [IVariantValueContainer_$type]);
/**
 * @hidden
 */
export class OfficeDocumentExtendedProperties extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return OfficeDocumentExtendedProperties.a4;
            case 1: return OfficeDocumentExtendedProperties.a3;
            default: return OfficeDocumentExtendedProperties.a4;
        }
    }
    get_j() {
        return null;
    }
    get j() {
        return this.get_j();
    }
    static bh(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.ap, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static b8(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.ap, null, b);
    }
    static bi(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.aq, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static b9(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.aq, null, b);
    }
    static bj(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.ar, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ca(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.ar, null, b);
    }
    static bk(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.as, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cb(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.as, null, b);
    }
    static bl(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.at, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cc(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.at, null, b);
    }
    static bm(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.au, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cd(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.au, null, b);
    }
    static bn(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ce(a) {
        a.ad.p(OfficeDocumentExtendedProperties.av, null);
    }
    static bo(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.aw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cf(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.aw, null, b);
    }
    static bp(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.ax, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cg(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.ax, null, b);
    }
    static bq(a, b) {
        let c = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.ay, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ch(a, b) {
        XmlNamespaceDefinitionBase.z(a, OfficeDocumentExtendedProperties.ay, null, b);
    }
    static br(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.az, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ci(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.az, null, b);
    }
    static bs(a, b) {
        let c = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a0, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cj(a, b) {
        XmlNamespaceDefinitionBase.z(a, OfficeDocumentExtendedProperties.a0, null, b);
    }
    static bt(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.a1, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ck(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.a1, null, b);
    }
    static bu(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.a2, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cl(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.a2, null, b);
    }
    static bv(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.a5, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cm(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.a5, null, b);
    }
    static bw(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.a6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cn(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.a6, null, b);
    }
    static bx(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.a7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static co(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.a7, null, b);
    }
    static by(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.a8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cp(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.a8, null, b);
    }
    static bz(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static cq(a) {
        a.ad.p(OfficeDocumentExtendedProperties.a9, null);
        let b = a.d._z;
        a.ad.l(OfficeDocumentExtendedProperties.an);
        a.ad.l(OfficeDocumentDocPropsVTypes.an);
    }
    static b0(a, b) {
        let c = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.ba, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cr(a, b) {
        XmlNamespaceDefinitionBase.z(a, OfficeDocumentExtendedProperties.ba, null, b);
    }
    static b1(a, b) {
        let c = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.bb, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cs(a, b) {
        XmlNamespaceDefinitionBase.z(a, OfficeDocumentExtendedProperties.bb, null, b);
    }
    static b2(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.bc, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static b7(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.bc, null, b);
    }
    static b3(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.bd, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ct(a, b) {
        XmlNamespaceDefinitionBase.ai(a, OfficeDocumentExtendedProperties.bd, null, b);
    }
    static b4(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static cu(a) {
        a.ad.p(OfficeDocumentExtendedProperties.be, null);
    }
    static b5(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.bf, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cv(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.bf, null, b);
    }
    static b6(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, OfficeDocumentExtendedProperties.bg, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static cw(a, b) {
        XmlNamespaceDefinitionBase.af(a, OfficeDocumentExtendedProperties.bg, null, b);
    }
}
OfficeDocumentExtendedProperties.$t = markType(OfficeDocumentExtendedProperties, 'OfficeDocumentExtendedProperties', XmlNamespaceDefinitionBase.$);
OfficeDocumentExtendedProperties.a4 = "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";
OfficeDocumentExtendedProperties.a3 = "http://purl.oclc.org/ooxml/officeDocument/extendedProperties";
OfficeDocumentExtendedProperties.ap = OfficeDocumentExtendedProperties.a3 + "/Application";
OfficeDocumentExtendedProperties.aq = OfficeDocumentExtendedProperties.a3 + "/AppVersion";
OfficeDocumentExtendedProperties.ar = OfficeDocumentExtendedProperties.a3 + "/Characters";
OfficeDocumentExtendedProperties.as = OfficeDocumentExtendedProperties.a3 + "/CharactersWithSpaces";
OfficeDocumentExtendedProperties.at = OfficeDocumentExtendedProperties.a3 + "/Company";
OfficeDocumentExtendedProperties.au = OfficeDocumentExtendedProperties.a3 + "/DocSecurity";
OfficeDocumentExtendedProperties.av = OfficeDocumentExtendedProperties.a3 + "/HeadingPairs";
OfficeDocumentExtendedProperties.aw = OfficeDocumentExtendedProperties.a3 + "/HiddenSlides";
OfficeDocumentExtendedProperties.ax = OfficeDocumentExtendedProperties.a3 + "/HyperlinkBase";
OfficeDocumentExtendedProperties.ay = OfficeDocumentExtendedProperties.a3 + "/HyperlinksChanged";
OfficeDocumentExtendedProperties.az = OfficeDocumentExtendedProperties.a3 + "/Lines";
OfficeDocumentExtendedProperties.a0 = OfficeDocumentExtendedProperties.a3 + "/LinksUpToDate";
OfficeDocumentExtendedProperties.a1 = OfficeDocumentExtendedProperties.a3 + "/Manager";
OfficeDocumentExtendedProperties.a2 = OfficeDocumentExtendedProperties.a3 + "/MMClips";
OfficeDocumentExtendedProperties.a5 = OfficeDocumentExtendedProperties.a3 + "/Notes";
OfficeDocumentExtendedProperties.a6 = OfficeDocumentExtendedProperties.a3 + "/Pages";
OfficeDocumentExtendedProperties.a7 = OfficeDocumentExtendedProperties.a3 + "/Paragraphs";
OfficeDocumentExtendedProperties.a9 = OfficeDocumentExtendedProperties.a3 + "/Properties";
OfficeDocumentExtendedProperties.a8 = OfficeDocumentExtendedProperties.a3 + "/PresentationFormat";
OfficeDocumentExtendedProperties.ba = OfficeDocumentExtendedProperties.a3 + "/ScaleCrop";
OfficeDocumentExtendedProperties.bb = OfficeDocumentExtendedProperties.a3 + "/SharedDoc";
OfficeDocumentExtendedProperties.bc = OfficeDocumentExtendedProperties.a3 + "/Slides";
OfficeDocumentExtendedProperties.bd = OfficeDocumentExtendedProperties.a3 + "/Template";
OfficeDocumentExtendedProperties.be = OfficeDocumentExtendedProperties.a3 + "/TitlesOfParts";
OfficeDocumentExtendedProperties.bf = OfficeDocumentExtendedProperties.a3 + "/TotalTime";
OfficeDocumentExtendedProperties.bg = OfficeDocumentExtendedProperties.a3 + "/Words";
OfficeDocumentExtendedProperties.an = new OfficeDocumentExtendedProperties();
/**
 * @hidden
 */
export class OfficeDocumentRelationships extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return OfficeDocumentRelationships.au;
            case 1: return OfficeDocumentRelationships.at;
            default: return OfficeDocumentRelationships.au;
        }
    }
    get_j() {
        return "r";
    }
    get j() {
        return this.get_j();
    }
}
OfficeDocumentRelationships.$t = markType(OfficeDocumentRelationships, 'OfficeDocumentRelationships', XmlNamespaceDefinitionBase.$);
OfficeDocumentRelationships.au = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
OfficeDocumentRelationships.at = "http://purl.oclc.org/ooxml/officeDocument/relationships";
OfficeDocumentRelationships.ap = OfficeDocumentRelationships.at + "/embed";
OfficeDocumentRelationships.aq = OfficeDocumentRelationships.at + "/href";
OfficeDocumentRelationships.ar = OfficeDocumentRelationships.at + "/id";
OfficeDocumentRelationships.as = OfficeDocumentRelationships.at + "/link";
OfficeDocumentRelationships.av = OfficeDocumentRelationships.at + "/pict";
OfficeDocumentRelationships.an = new OfficeDocumentRelationships();
/**
 * @hidden
 */
export class OfficeNamespace extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "urn:schemas-microsoft-com:office:office";
            default: return "urn:schemas-microsoft-com:office:office";
        }
    }
    get_j() {
        return "o";
    }
    get j() {
        return this.get_j();
    }
    static ch(a, b, c) {
        b = Nullable$1.toNullable(ST_Ext_$type, null);
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "urn:schemas-microsoft-com:vml/ext":
                    b = Nullable$1.toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, d.d));
                    break;
                case "data":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static ck(a, b = Nullable$1.toNullable(ST_Ext_$type, null), c = null) {
        a.ad.p(OfficeNamespace.br, "o");
        let d;
        if (nullableNotEquals(b, null)) {
            d = XmlNamespaceDefinitionBase.f(ST_Ext_$type, b.value);
            a.ad.h("urn:schemas-microsoft-com:vml/ext", d);
        }
        d = c;
        a.ad.h("data", d);
    }
    static ci(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = Nullable$1.toNullable(ST_Ext_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = Nullable$1.toNullable(Boolean_$type, null);
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "urn:schemas-microsoft-com:vml/ext":
                    b = Nullable$1.toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, n.d));
                    break;
                case "position":
                    c = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "selection":
                    d = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "grouping":
                    e = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "ungrouping":
                    f = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "rotation":
                    g = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "cropping":
                    h = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "verticies":
                    i = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "adjusthandles":
                    j = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "text":
                    k = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "aspectratio":
                    l = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                case "shapetype":
                    m = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static cl(a, b = Nullable$1.toNullable(ST_Ext_$type, null), c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(OfficeNamespace.ao, "o");
        let n;
        if (nullableNotEquals(b, null)) {
            n = XmlNamespaceDefinitionBase.f(ST_Ext_$type, b.value);
            a.ad.h("urn:schemas-microsoft-com:vml/ext", n);
        }
        if (nullableNotEquals(c, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
            a.ad.h("position", n);
        }
        if (nullableNotEquals(d, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(d.value));
            a.ad.h("selection", n);
        }
        if (nullableNotEquals(e, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
            a.ad.h("grouping", n);
        }
        if (nullableNotEquals(f, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(f.value));
            a.ad.h("ungrouping", n);
        }
        if (nullableNotEquals(g, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(g.value));
            a.ad.h("rotation", n);
        }
        if (nullableNotEquals(h, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(h.value));
            a.ad.h("cropping", n);
        }
        if (nullableNotEquals(i, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(i.value));
            a.ad.h("verticies", n);
        }
        if (nullableNotEquals(j, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(j.value));
            a.ad.h("adjusthandles", n);
        }
        if (nullableNotEquals(k, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
            a.ad.h("text", n);
        }
        if (nullableNotEquals(l, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
            a.ad.h("aspectratio", n);
        }
        if (nullableNotEquals(m, null)) {
            n = ST_TrueFalse.k(ST_TrueFalse.b(m.value));
            a.ad.h("shapetype", n);
        }
    }
    static cj(a, b) {
        b = Nullable$1.toNullable(ST_Ext_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "urn:schemas-microsoft-com:vml/ext":
                    b = Nullable$1.toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static cm(a, b = Nullable$1.toNullable(ST_Ext_$type, null)) {
        a.ad.p(OfficeNamespace.b6, "o");
        let c;
        if (nullableNotEquals(b, null)) {
            c = XmlNamespaceDefinitionBase.f(ST_Ext_$type, b.value);
            a.ad.h("urn:schemas-microsoft-com:vml/ext", c);
        }
    }
}
OfficeNamespace.$t = markType(OfficeNamespace, 'OfficeNamespace', XmlNamespaceDefinitionBase.$);
OfficeNamespace.br = "urn:schemas-microsoft-com:office:office" + "/idmap";
OfficeNamespace.ao = "urn:schemas-microsoft-com:office:office" + "/lock";
OfficeNamespace.b6 = "urn:schemas-microsoft-com:office:office" + "/shapelayout";
OfficeNamespace.ar = "urn:schemas-microsoft-com:office:office" + "/allowincell";
OfficeNamespace.at = "urn:schemas-microsoft-com:office:office" + "/althref";
OfficeNamespace.as = "urn:schemas-microsoft-com:office:office" + "/allowoverlap";
OfficeNamespace.a1 = "urn:schemas-microsoft-com:office:office" + "/bwmode";
OfficeNamespace.a2 = "urn:schemas-microsoft-com:office:office" + "/bwnormal";
OfficeNamespace.a3 = "urn:schemas-microsoft-com:office:office" + "/bwpure";
OfficeNamespace.av = "urn:schemas-microsoft-com:office:office" + "/borderbottomcolor";
OfficeNamespace.aw = "urn:schemas-microsoft-com:office:office" + "/borderleftcolor";
OfficeNamespace.ax = "urn:schemas-microsoft-com:office:office" + "/borderrightcolor";
OfficeNamespace.ay = "urn:schemas-microsoft-com:office:office" + "/bordertopcolor";
OfficeNamespace.az = "urn:schemas-microsoft-com:office:office" + "/bullet";
OfficeNamespace.a0 = "urn:schemas-microsoft-com:office:office" + "/button";
OfficeNamespace.a4 = "urn:schemas-microsoft-com:office:office" + "/clip";
OfficeNamespace.a5 = "urn:schemas-microsoft-com:office:office" + "/cliptowrap";
OfficeNamespace.a6 = "urn:schemas-microsoft-com:office:office" + "/connectangles";
OfficeNamespace.a7 = "urn:schemas-microsoft-com:office:office" + "/connectlocs";
OfficeNamespace.a8 = "urn:schemas-microsoft-com:office:office" + "/connectortype";
OfficeNamespace.a9 = "urn:schemas-microsoft-com:office:office" + "/connecttype";
OfficeNamespace.bc = "urn:schemas-microsoft-com:office:office" + "/detectmouseclick";
OfficeNamespace.bd = "urn:schemas-microsoft-com:office:office" + "/dgmlayout";
OfficeNamespace.be = "urn:schemas-microsoft-com:office:office" + "/dgmlayoutmru";
OfficeNamespace.bf = "urn:schemas-microsoft-com:office:office" + "/dgmnodekind";
OfficeNamespace.bg = "urn:schemas-microsoft-com:office:office" + "/doubleclicknotify";
OfficeNamespace.bh = "urn:schemas-microsoft-com:office:office" + "/extrusionok";
OfficeNamespace.bi = "urn:schemas-microsoft-com:office:office" + "/forcedash";
OfficeNamespace.bj = "urn:schemas-microsoft-com:office:office" + "/gfxdata";
OfficeNamespace.bl = "urn:schemas-microsoft-com:office:office" + "/hr";
OfficeNamespace.bm = "urn:schemas-microsoft-com:office:office" + "/hralign";
OfficeNamespace.bn = "urn:schemas-microsoft-com:office:office" + "/href";
OfficeNamespace.bo = "urn:schemas-microsoft-com:office:office" + "/hrnoshade";
OfficeNamespace.bp = "urn:schemas-microsoft-com:office:office" + "/hrpct";
OfficeNamespace.bq = "urn:schemas-microsoft-com:office:office" + "/hrstd";
OfficeNamespace.bs = "urn:schemas-microsoft-com:office:office" + "/insetmode";
OfficeNamespace.bt = "urn:schemas-microsoft-com:office:office" + "/movie";
OfficeNamespace.bv = "urn:schemas-microsoft-com:office:office" + "/ole";
OfficeNamespace.bw = "urn:schemas-microsoft-com:office:office" + "/oleicon";
OfficeNamespace.bx = "urn:schemas-microsoft-com:office:office" + "/oleid";
OfficeNamespace.by = "urn:schemas-microsoft-com:office:office" + "/oned";
OfficeNamespace.bz = "urn:schemas-microsoft-com:office:office" + "/opacity2";
OfficeNamespace.b1 = "urn:schemas-microsoft-com:office:office" + "/preferrelative";
OfficeNamespace.b2 = "urn:schemas-microsoft-com:office:office" + "/regroupid";
OfficeNamespace.b3 = "urn:schemas-microsoft-com:office:office" + "/relid";
OfficeNamespace.b8 = "urn:schemas-microsoft-com:office:office" + "/singleclick";
OfficeNamespace.b9 = "urn:schemas-microsoft-com:office:office" + "/spid";
OfficeNamespace.ca = "urn:schemas-microsoft-com:office:office" + "/spt";
OfficeNamespace.cc = "urn:schemas-microsoft-com:office:office" + "/title";
OfficeNamespace.ce = "urn:schemas-microsoft-com:office:office" + "/userdrawn";
OfficeNamespace.cf = "urn:schemas-microsoft-com:office:office" + "/userhidden";
OfficeNamespace.an = new OfficeNamespace();
/**
 * @hidden
 */
export class VmlNamespace extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "urn:schemas-microsoft-com:vml";
            default: return "urn:schemas-microsoft-com:vml";
        }
    }
    get_j() {
        return "v";
    }
    get j() {
        return this.get_j();
    }
    static dn(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "startAngle":
                    b = Nullable$1.toNullable(Number_$type, parseNumber(d.d, CultureInfo.invariantCulture));
                    break;
                case "endAngle":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static dx(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p("urn:schemas-microsoft-com:vml/arc", "v");
        let d;
        if (nullableNotEquals(b, null)) {
            d = numberToString(b.value, CultureInfo.invariantCulture);
            a.ad.h("startAngle", d);
        }
        if (nullableNotEquals(c, null)) {
            d = numberToString(c.value, CultureInfo.invariantCulture);
            a.ad.h("endAngle", d);
        }
    }
    static dp(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab) {
        b = null;
        c = Nullable$1.toNullable(ST_FillType_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = null;
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = null;
        l = null;
        m = null;
        n = Nullable$1.toNullable(ST_ImageAspect_$type, null);
        o = null;
        p = Nullable$1.toNullable(Number_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = null;
        s = null;
        t = null;
        u = Nullable$1.toNullable(ST_FillMethod_$type, null);
        v = Nullable$1.toNullable(Boolean_$type, null);
        w = null;
        x = null;
        y = Nullable$1.toNullable(Boolean_$type, null);
        z = Nullable$1.toNullable(Boolean_$type, null);
        aa = null;
        ab = null;
        for (let ac of fromEnum(a.ab.u)) {
            switch (ac.a.e(a.d)) {
                case "id":
                    b = ac.d;
                    break;
                case "type":
                    c = Nullable$1.toNullable(ST_FillType_$type, XmlNamespaceDefinitionBase.b(ST_FillType_$type, ac.d));
                    break;
                case "on":
                    d = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                    break;
                case "color":
                    e = ac.d;
                    break;
                case "opacity":
                    f = ac.d;
                    break;
                case "color2":
                    g = ac.d;
                    break;
                case "src":
                    h = ac.d;
                    break;
                case OfficeNamespace.bn:
                    i = ac.d;
                    break;
                case OfficeNamespace.at:
                    j = ac.d;
                    break;
                case "size":
                    k = ac.d;
                    break;
                case "origin":
                    l = ac.d;
                    break;
                case "position":
                    m = ac.d;
                    break;
                case "aspect":
                    n = Nullable$1.toNullable(ST_ImageAspect_$type, XmlNamespaceDefinitionBase.b(ST_ImageAspect_$type, ac.d));
                    break;
                case "colors":
                    o = ac.d;
                    break;
                case "angle":
                    p = Nullable$1.toNullable(Number_$type, parseNumber(ac.d, CultureInfo.invariantCulture));
                    break;
                case "alignshape":
                    q = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                    break;
                case "focus":
                    r = ac.d;
                    break;
                case "focussize":
                    s = ac.d;
                    break;
                case "focusposition":
                    t = ac.d;
                    break;
                case "method":
                    u = Nullable$1.toNullable(ST_FillMethod_$type, XmlNamespaceDefinitionBase.b(ST_FillMethod_$type, ac.d));
                    break;
                case OfficeNamespace.bc:
                    v = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                    break;
                case OfficeNamespace.cc:
                    w = ac.d;
                    break;
                case OfficeNamespace.bz:
                    x = ac.d;
                    break;
                case "recolor":
                    y = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                    break;
                case "rotate":
                    z = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                    break;
                case OfficeDocumentRelationships.ar:
                    aa = ac.d;
                    break;
                case OfficeNamespace.b3:
                    ab = ac.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y,
            p25: z,
            p26: aa,
            p27: ab
        };
    }
    static dy(a, b = null, c = Nullable$1.toNullable(ST_FillType_$type, null), d = Nullable$1.toNullable(Boolean_$type, null), e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = null, m = null, n = Nullable$1.toNullable(ST_ImageAspect_$type, null), o = null, p = Nullable$1.toNullable(Number_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = null, s = null, t = null, u = Nullable$1.toNullable(ST_FillMethod_$type, null), v = Nullable$1.toNullable(Boolean_$type, null), w = null, x = null, y = Nullable$1.toNullable(Boolean_$type, null), z = Nullable$1.toNullable(Boolean_$type, null), aa = null, ab = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/fill", "v");
        let ac;
        ac = b;
        a.ad.h("id", ac);
        if (nullableNotEquals(c, null)) {
            ac = XmlNamespaceDefinitionBase.f(ST_FillType_$type, c.value);
            a.ad.h("type", ac);
        }
        if (nullableNotEquals(d, null)) {
            ac = ST_TrueFalse.k(ST_TrueFalse.b(d.value));
            a.ad.h("on", ac);
        }
        ac = e;
        a.ad.h("color", ac);
        ac = f;
        a.ad.h("opacity", ac);
        ac = g;
        a.ad.h("color2", ac);
        ac = h;
        a.ad.h("src", ac);
        ac = i;
        a.ad.h(OfficeNamespace.bn, ac);
        ac = j;
        a.ad.h(OfficeNamespace.at, ac);
        ac = k;
        a.ad.h("size", ac);
        ac = l;
        a.ad.h("origin", ac);
        ac = m;
        a.ad.h("position", ac);
        if (nullableNotEquals(n, null)) {
            ac = XmlNamespaceDefinitionBase.f(ST_ImageAspect_$type, n.value);
            a.ad.h("aspect", ac);
        }
        ac = o;
        a.ad.h("colors", ac);
        if (nullableNotEquals(p, null)) {
            ac = numberToString(p.value, CultureInfo.invariantCulture);
            a.ad.h("angle", ac);
        }
        if (nullableNotEquals(q, null)) {
            ac = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
            a.ad.h("alignshape", ac);
        }
        ac = r;
        a.ad.h("focus", ac);
        ac = s;
        a.ad.h("focussize", ac);
        ac = t;
        a.ad.h("focusposition", ac);
        if (nullableNotEquals(u, null)) {
            ac = XmlNamespaceDefinitionBase.f(ST_FillMethod_$type, u.value);
            a.ad.h("method", ac);
        }
        if (nullableNotEquals(v, null)) {
            ac = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
            a.ad.h(OfficeNamespace.bc, ac);
        }
        ac = w;
        a.ad.h(OfficeNamespace.cc, ac);
        ac = x;
        a.ad.h(OfficeNamespace.bz, ac);
        if (nullableNotEquals(y, null)) {
            ac = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
            a.ad.h("recolor", ac);
        }
        if (nullableNotEquals(z, null)) {
            ac = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
            a.ad.h("rotate", ac);
        }
        ac = aa;
        a.ad.h(OfficeDocumentRelationships.ar, ac);
        ac = ab;
        a.ad.h(OfficeNamespace.b3, ac);
    }
    static dq(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = null;
        n = null;
        o = null;
        p = null;
        q = null;
        r = null;
        s = Nullable$1.toNullable(Number_$type, null);
        t = Nullable$1.toNullable(Boolean_$type, null);
        u = Nullable$1.toNullable(Number_$type, null);
        v = null;
        w = null;
        x = null;
        y = null;
        for (let z of fromEnum(a.ab.u)) {
            switch (z.a.e(a.d)) {
                case "id":
                    b = z.d;
                    break;
                case "src":
                    c = z.d;
                    break;
                case "cropleft":
                    d = z.d;
                    break;
                case "croptop":
                    e = z.d;
                    break;
                case "cropright":
                    f = z.d;
                    break;
                case "cropbottom":
                    g = z.d;
                    break;
                case "gain":
                    h = z.d;
                    break;
                case "blacklevel":
                    i = z.d;
                    break;
                case "gamma":
                    j = z.d;
                    break;
                case "grayscale":
                    k = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                    break;
                case "bilevel":
                    l = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                    break;
                case "chromakey":
                    m = z.d;
                    break;
                case "embosscolor":
                    n = z.d;
                    break;
                case "recolortarget":
                    o = z.d;
                    break;
                case OfficeNamespace.bn:
                    p = z.d;
                    break;
                case OfficeNamespace.at:
                    q = z.d;
                    break;
                case OfficeNamespace.cc:
                    r = z.d;
                    break;
                case OfficeNamespace.bx:
                    s = Nullable$1.toNullable(Number_$type, parseNumber(z.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.bc:
                    t = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                    break;
                case OfficeNamespace.bt:
                    u = Nullable$1.toNullable(Number_$type, parseNumber(z.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.b3:
                    v = z.d;
                    break;
                case OfficeDocumentRelationships.ar:
                    w = z.d;
                    break;
                case OfficeDocumentRelationships.av:
                    x = z.d;
                    break;
                case OfficeDocumentRelationships.aq:
                    y = z.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y
        };
    }
    static dz(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = null, n = null, o = null, p = null, q = null, r = null, s = Nullable$1.toNullable(Number_$type, null), t = Nullable$1.toNullable(Boolean_$type, null), u = Nullable$1.toNullable(Number_$type, null), v = null, w = null, x = null, y = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/imagedata", "v");
        let z;
        z = b;
        a.ad.h("id", z);
        z = c;
        a.ad.h("src", z);
        z = d;
        a.ad.h("cropleft", z);
        z = e;
        a.ad.h("croptop", z);
        z = f;
        a.ad.h("cropright", z);
        z = g;
        a.ad.h("cropbottom", z);
        z = h;
        a.ad.h("gain", z);
        z = i;
        a.ad.h("blacklevel", z);
        z = j;
        a.ad.h("gamma", z);
        if (nullableNotEquals(k, null)) {
            z = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
            a.ad.h("grayscale", z);
        }
        if (nullableNotEquals(l, null)) {
            z = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
            a.ad.h("bilevel", z);
        }
        z = m;
        a.ad.h("chromakey", z);
        z = n;
        a.ad.h("embosscolor", z);
        z = o;
        a.ad.h("recolortarget", z);
        z = p;
        a.ad.h(OfficeNamespace.bn, z);
        z = q;
        a.ad.h(OfficeNamespace.at, z);
        z = r;
        a.ad.h(OfficeNamespace.cc, z);
        if (nullableNotEquals(s, null)) {
            z = numberToString(s.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.bx, z);
        }
        if (nullableNotEquals(t, null)) {
            z = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
            a.ad.h(OfficeNamespace.bc, z);
        }
        if (nullableNotEquals(u, null)) {
            z = numberToString(u.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.bt, z);
        }
        z = v;
        a.ad.h(OfficeNamespace.b3, z);
        z = w;
        a.ad.h(OfficeDocumentRelationships.ar, z);
        z = x;
        a.ad.h(OfficeDocumentRelationships.av, z);
        z = y;
        a.ad.h(OfficeDocumentRelationships.aq, z);
    }
    static dr(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(Boolean_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = Nullable$1.toNullable(ST_ConnectType_$type, null);
        n = null;
        o = null;
        p = Nullable$1.toNullable(Boolean_$type, null);
        for (let q of fromEnum(a.ab.u)) {
            switch (q.a.e(a.d)) {
                case "id":
                    b = q.d;
                    break;
                case "v":
                    c = q.d;
                    break;
                case "limo":
                    d = q.d;
                    break;
                case "textboxrect":
                    e = q.d;
                    break;
                case "fillok":
                    f = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "strokeok":
                    g = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "shadowok":
                    h = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "arrowok":
                    i = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "gradientshapeok":
                    j = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "textpathok":
                    k = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case "insetpenok":
                    l = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                case OfficeNamespace.a9:
                    m = Nullable$1.toNullable(ST_ConnectType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectType_$type, q.d));
                    break;
                case OfficeNamespace.a7:
                    n = q.d;
                    break;
                case OfficeNamespace.a6:
                    o = q.d;
                    break;
                case OfficeNamespace.bh:
                    p = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p
        };
    }
    static d0(a, b = null, c = null, d = null, e = null, f = Nullable$1.toNullable(Boolean_$type, null), g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(ST_ConnectType_$type, null), n = null, o = null, p = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p("urn:schemas-microsoft-com:vml/path", "v");
        let q;
        q = b;
        a.ad.h("id", q);
        q = c;
        a.ad.h("v", q);
        q = d;
        a.ad.h("limo", q);
        q = e;
        a.ad.h("textboxrect", q);
        if (nullableNotEquals(f, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(f.value));
            a.ad.h("fillok", q);
        }
        if (nullableNotEquals(g, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(g.value));
            a.ad.h("strokeok", q);
        }
        if (nullableNotEquals(h, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(h.value));
            a.ad.h("shadowok", q);
        }
        if (nullableNotEquals(i, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(i.value));
            a.ad.h("arrowok", q);
        }
        if (nullableNotEquals(j, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(j.value));
            a.ad.h("gradientshapeok", q);
        }
        if (nullableNotEquals(k, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
            a.ad.h("textpathok", q);
        }
        if (nullableNotEquals(l, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
            a.ad.h("insetpenok", q);
        }
        if (nullableNotEquals(m, null)) {
            q = XmlNamespaceDefinitionBase.f(ST_ConnectType_$type, m.value);
            a.ad.h(OfficeNamespace.a9, q);
        }
        q = n;
        a.ad.h(OfficeNamespace.a7, q);
        q = o;
        a.ad.h(OfficeNamespace.a6, q);
        if (nullableNotEquals(p, null)) {
            q = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
            a.ad.h(OfficeNamespace.bh, q);
        }
    }
    static ds(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(ST_ShadowType_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = null;
        l = null;
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "id":
                    b = m.d;
                    break;
                case "on":
                    c = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(m.d)));
                    break;
                case "type":
                    d = Nullable$1.toNullable(ST_ShadowType_$type, XmlNamespaceDefinitionBase.b(ST_ShadowType_$type, m.d));
                    break;
                case "obscured":
                    e = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(m.d)));
                    break;
                case "color":
                    f = m.d;
                    break;
                case "opacity":
                    g = m.d;
                    break;
                case "offset":
                    h = m.d;
                    break;
                case "color2":
                    i = m.d;
                    break;
                case "offset2":
                    j = m.d;
                    break;
                case "origin":
                    k = m.d;
                    break;
                case "matrix":
                    l = m.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static d1(a, b = null, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(ST_ShadowType_$type, null), e = Nullable$1.toNullable(Boolean_$type, null), f = null, g = null, h = null, i = null, j = null, k = null, l = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/shadow", "v");
        let m;
        m = b;
        a.ad.h("id", m);
        if (nullableNotEquals(c, null)) {
            m = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
            a.ad.h("on", m);
        }
        if (nullableNotEquals(d, null)) {
            m = XmlNamespaceDefinitionBase.f(ST_ShadowType_$type, d.value);
            a.ad.h("type", m);
        }
        if (nullableNotEquals(e, null)) {
            m = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
            a.ad.h("obscured", m);
        }
        m = f;
        a.ad.h("color", m);
        m = g;
        a.ad.h("opacity", m);
        m = h;
        a.ad.h("offset", m);
        m = i;
        a.ad.h("color2", m);
        m = j;
        a.ad.h("offset2", m);
        m = k;
        a.ad.h("origin", m);
        m = l;
        a.ad.h("matrix", m);
    }
    static dt(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4, a5, a6) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = null;
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = null;
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = null;
        p = Nullable$1.toNullable(Boolean_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        s = Nullable$1.toNullable(Boolean_$type, null);
        t = Nullable$1.toNullable(Boolean_$type, null);
        u = Nullable$1.toNullable(Boolean_$type, null);
        v = Nullable$1.toNullable(Boolean_$type, null);
        w = Nullable$1.toNullable(Number_$type, null);
        x = Nullable$1.toNullable(ST_HrAlign_$type, null);
        y = Nullable$1.toNullable(Boolean_$type, null);
        z = Nullable$1.toNullable(Boolean_$type, null);
        aa = Nullable$1.toNullable(Boolean_$type, null);
        ab = null;
        ac = null;
        ad = null;
        ae = null;
        af = null;
        ag = null;
        ah = null;
        ai = Nullable$1.toNullable(ST_InsetMode_$type, null);
        aj = null;
        ak = Nullable$1.toNullable(Boolean_$type, null);
        al = null;
        am = null;
        an = Nullable$1.toNullable(Boolean_$type, null);
        ao = null;
        ap = null;
        aq = Nullable$1.toNullable(Boolean_$type, null);
        ar = Nullable$1.toNullable(Number_$type, null);
        as = Nullable$1.toNullable(ST_ConnectorType_$type, null);
        at = Nullable$1.toNullable(ST_BWMode_$type, null);
        au = Nullable$1.toNullable(ST_BWMode_$type, null);
        av = Nullable$1.toNullable(ST_BWMode_$type, null);
        aw = Nullable$1.toNullable(Boolean_$type, null);
        ax = Nullable$1.toNullable(Boolean_$type, null);
        ay = Nullable$1.toNullable(Boolean_$type, null);
        az = Nullable$1.toNullable(Boolean_$type, null);
        a0 = Nullable$1.toNullable(Boolean_$type, null);
        a1 = Nullable$1.toNullable(Boolean_$type, null);
        a2 = null;
        a3 = null;
        a4 = null;
        a5 = null;
        a6 = null;
        for (let a7 of fromEnum(a.ab.u)) {
            switch (a7.a.e(a.d)) {
                case "id":
                    b = a7.d;
                    break;
                case "style":
                    c = a7.d;
                    break;
                case "href":
                    d = a7.d;
                    break;
                case "target":
                    e = a7.d;
                    break;
                case "class":
                    f = a7.d;
                    break;
                case "title":
                    g = a7.d;
                    break;
                case "alt":
                    h = a7.d;
                    break;
                case "coordsize":
                    i = a7.d;
                    break;
                case "coordorigin":
                    j = a7.d;
                    break;
                case "wrapcoords":
                    k = a7.d;
                    break;
                case "print":
                    l = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.b9:
                    m = a7.d;
                    break;
                case OfficeNamespace.by:
                    n = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.b2:
                    o = a7.d;
                    break;
                case OfficeNamespace.bg:
                    p = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.a0:
                    q = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.cf:
                    r = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.az:
                    s = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bl:
                    t = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bq:
                    u = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bo:
                    v = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bp:
                    w = Nullable$1.toNullable(Number_$type, parseNumber(a7.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.bm:
                    x = Nullable$1.toNullable(ST_HrAlign_$type, XmlNamespaceDefinitionBase.b(ST_HrAlign_$type, a7.d));
                    break;
                case OfficeNamespace.ar:
                    y = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.as:
                    z = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.ce:
                    aa = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case "bordertopcolor":
                    ab = a7.d;
                    break;
                case "borderleftcolor":
                    ac = a7.d;
                    break;
                case "borderbottomcolor":
                    ad = a7.d;
                    break;
                case "borderrightcolor":
                    ae = a7.d;
                    break;
                case OfficeNamespace.bd:
                    af = a7.d;
                    break;
                case OfficeNamespace.bf:
                    ag = a7.d;
                    break;
                case OfficeNamespace.be:
                    ah = a7.d;
                    break;
                case OfficeNamespace.bs:
                    ai = Nullable$1.toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, a7.d));
                    break;
                case "chromakey":
                    aj = a7.d;
                    break;
                case "filled":
                    ak = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case "fillcolor":
                    al = a7.d;
                    break;
                case "opacity":
                    am = a7.d;
                    break;
                case "stroked":
                    an = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case "strokecolor":
                    ao = a7.d;
                    break;
                case "strokeweight":
                    ap = a7.d;
                    break;
                case "insetpen":
                    aq = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.ca:
                    ar = Nullable$1.toNullable(Number_$type, parseNumber(a7.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.a8:
                    as = Nullable$1.toNullable(ST_ConnectorType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectorType_$type, a7.d));
                    break;
                case "bwmode":
                    at = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                    break;
                case "bwpure":
                    au = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                    break;
                case "bwnormal":
                    av = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                    break;
                case OfficeNamespace.bi:
                    aw = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bw:
                    ax = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.bv:
                    ay = Nullable$1.toNullable(Boolean_$type, ST_TrueFalseBlank.d(a7.d));
                    break;
                case OfficeNamespace.b1:
                    az = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.a5:
                    a0 = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case OfficeNamespace.a4:
                    a1 = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                    break;
                case "type":
                    a2 = a7.d;
                    break;
                case "adj":
                    a3 = a7.d;
                    break;
                case "path":
                    a4 = a7.d;
                    break;
                case "gfxdata":
                    a5 = a7.d;
                    break;
                case "equationxml":
                    a6 = a7.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y,
            p25: z,
            p26: aa,
            p27: ab,
            p28: ac,
            p29: ad,
            p30: ae,
            p31: af,
            p32: ag,
            p33: ah,
            p34: ai,
            p35: aj,
            p36: ak,
            p37: al,
            p38: am,
            p39: an,
            p40: ao,
            p41: ap,
            p42: aq,
            p43: ar,
            p44: as,
            p45: at,
            p46: au,
            p47: av,
            p48: aw,
            p49: ax,
            p50: ay,
            p51: az,
            p52: a0,
            p53: a1,
            p54: a2,
            p55: a3,
            p56: a4,
            p57: a5,
            p58: a6
        };
    }
    static d2(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = Nullable$1.toNullable(Boolean_$type, null), m = null, n = Nullable$1.toNullable(Boolean_$type, null), o = null, p = Nullable$1.toNullable(Boolean_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = Nullable$1.toNullable(Boolean_$type, null), s = Nullable$1.toNullable(Boolean_$type, null), t = Nullable$1.toNullable(Boolean_$type, null), u = Nullable$1.toNullable(Boolean_$type, null), v = Nullable$1.toNullable(Boolean_$type, null), w = Nullable$1.toNullable(Number_$type, null), x = Nullable$1.toNullable(ST_HrAlign_$type, null), y = Nullable$1.toNullable(Boolean_$type, null), z = Nullable$1.toNullable(Boolean_$type, null), aa = Nullable$1.toNullable(Boolean_$type, null), ab = null, ac = null, ad = null, ae = null, af = null, ag = null, ah = null, ai = Nullable$1.toNullable(ST_InsetMode_$type, null), aj = null, ak = Nullable$1.toNullable(Boolean_$type, null), al = null, am = null, an = Nullable$1.toNullable(Boolean_$type, null), ao = null, ap = null, aq = Nullable$1.toNullable(Boolean_$type, null), ar = Nullable$1.toNullable(Number_$type, null), as = Nullable$1.toNullable(ST_ConnectorType_$type, null), at = Nullable$1.toNullable(ST_BWMode_$type, null), au = Nullable$1.toNullable(ST_BWMode_$type, null), av = Nullable$1.toNullable(ST_BWMode_$type, null), aw = Nullable$1.toNullable(Boolean_$type, null), ax = Nullable$1.toNullable(Boolean_$type, null), ay = Nullable$1.toNullable(Boolean_$type, null), az = Nullable$1.toNullable(Boolean_$type, null), a0 = Nullable$1.toNullable(Boolean_$type, null), a1 = Nullable$1.toNullable(Boolean_$type, null), a2 = null, a3 = null, a4 = null, a5 = null, a6 = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/shape", "v");
        let a7;
        a7 = b;
        a.ad.h("id", a7);
        a7 = c;
        a.ad.h("style", a7);
        a7 = d;
        a.ad.h("href", a7);
        a7 = e;
        a.ad.h("target", a7);
        a7 = f;
        a.ad.h("class", a7);
        a7 = g;
        a.ad.h("title", a7);
        a7 = h;
        a.ad.h("alt", a7);
        a7 = i;
        a.ad.h("coordsize", a7);
        a7 = j;
        a.ad.h("coordorigin", a7);
        a7 = k;
        a.ad.h("wrapcoords", a7);
        if (nullableNotEquals(l, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
            a.ad.h("print", a7);
        }
        a7 = m;
        a.ad.h(OfficeNamespace.b9, a7);
        if (nullableNotEquals(n, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(n.value));
            a.ad.h(OfficeNamespace.by, a7);
        }
        a7 = o;
        a.ad.h(OfficeNamespace.b2, a7);
        if (nullableNotEquals(p, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
            a.ad.h(OfficeNamespace.bg, a7);
        }
        if (nullableNotEquals(q, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
            a.ad.h(OfficeNamespace.a0, a7);
        }
        if (nullableNotEquals(r, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(r.value));
            a.ad.h(OfficeNamespace.cf, a7);
        }
        if (nullableNotEquals(s, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(s.value));
            a.ad.h(OfficeNamespace.az, a7);
        }
        if (nullableNotEquals(t, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
            a.ad.h(OfficeNamespace.bl, a7);
        }
        if (nullableNotEquals(u, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(u.value));
            a.ad.h(OfficeNamespace.bq, a7);
        }
        if (nullableNotEquals(v, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
            a.ad.h(OfficeNamespace.bo, a7);
        }
        if (nullableNotEquals(w, null)) {
            a7 = numberToString(w.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.bp, a7);
        }
        if (nullableNotEquals(x, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_HrAlign_$type, x.value);
            a.ad.h(OfficeNamespace.bm, a7);
        }
        if (nullableNotEquals(y, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
            a.ad.h(OfficeNamespace.ar, a7);
        }
        if (nullableNotEquals(z, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
            a.ad.h(OfficeNamespace.as, a7);
        }
        if (nullableNotEquals(aa, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
            a.ad.h(OfficeNamespace.ce, a7);
        }
        a7 = ab;
        a.ad.h("bordertopcolor", a7);
        a7 = ac;
        a.ad.h("borderleftcolor", a7);
        a7 = ad;
        a.ad.h("borderbottomcolor", a7);
        a7 = ae;
        a.ad.h("borderrightcolor", a7);
        a7 = af;
        a.ad.h(OfficeNamespace.bd, a7);
        a7 = ag;
        a.ad.h(OfficeNamespace.bf, a7);
        a7 = ah;
        a.ad.h(OfficeNamespace.be, a7);
        if (nullableNotEquals(ai, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_InsetMode_$type, ai.value);
            a.ad.h(OfficeNamespace.bs, a7);
        }
        a7 = aj;
        a.ad.h("chromakey", a7);
        if (nullableNotEquals(ak, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(ak.value));
            a.ad.h("filled", a7);
        }
        a7 = al;
        a.ad.h("fillcolor", a7);
        a7 = am;
        a.ad.h("opacity", a7);
        if (nullableNotEquals(an, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(an.value));
            a.ad.h("stroked", a7);
        }
        a7 = ao;
        a.ad.h("strokecolor", a7);
        a7 = ap;
        a.ad.h("strokeweight", a7);
        if (nullableNotEquals(aq, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(aq.value));
            a.ad.h("insetpen", a7);
        }
        if (nullableNotEquals(ar, null)) {
            a7 = numberToString(ar.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.ca, a7);
        }
        if (nullableNotEquals(as, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_ConnectorType_$type, as.value);
            a.ad.h(OfficeNamespace.a8, a7);
        }
        if (nullableNotEquals(at, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, at.value);
            a.ad.h("bwmode", a7);
        }
        if (nullableNotEquals(au, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, au.value);
            a.ad.h("bwpure", a7);
        }
        if (nullableNotEquals(av, null)) {
            a7 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, av.value);
            a.ad.h("bwnormal", a7);
        }
        if (nullableNotEquals(aw, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(aw.value));
            a.ad.h(OfficeNamespace.bi, a7);
        }
        if (nullableNotEquals(ax, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(ax.value));
            a.ad.h(OfficeNamespace.bw, a7);
        }
        if (nullableNotEquals(ay, null)) {
            a7 = ST_TrueFalseBlank.f(ay.value);
            a.ad.h(OfficeNamespace.bv, a7);
        }
        if (nullableNotEquals(az, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(az.value));
            a.ad.h(OfficeNamespace.b1, a7);
        }
        if (nullableNotEquals(a0, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(a0.value));
            a.ad.h(OfficeNamespace.a5, a7);
        }
        if (nullableNotEquals(a1, null)) {
            a7 = ST_TrueFalse.k(ST_TrueFalse.b(a1.value));
            a.ad.h(OfficeNamespace.a4, a7);
        }
        a7 = a2;
        a.ad.h("type", a7);
        a7 = a3;
        a.ad.h("adj", a7);
        a7 = a4;
        a.ad.h("path", a7);
        a7 = a5;
        a.ad.h("gfxdata", a7);
        a7 = a6;
        a.ad.h("equationxml", a7);
    }
    static du(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = null;
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = null;
        n = Nullable$1.toNullable(Boolean_$type, null);
        o = null;
        p = Nullable$1.toNullable(Boolean_$type, null);
        q = Nullable$1.toNullable(Boolean_$type, null);
        r = Nullable$1.toNullable(Boolean_$type, null);
        s = Nullable$1.toNullable(Boolean_$type, null);
        t = Nullable$1.toNullable(Boolean_$type, null);
        u = Nullable$1.toNullable(Boolean_$type, null);
        v = Nullable$1.toNullable(Boolean_$type, null);
        w = Nullable$1.toNullable(Number_$type, null);
        x = Nullable$1.toNullable(ST_HrAlign_$type, null);
        y = Nullable$1.toNullable(Boolean_$type, null);
        z = Nullable$1.toNullable(Boolean_$type, null);
        aa = Nullable$1.toNullable(Boolean_$type, null);
        ab = null;
        ac = null;
        ad = null;
        ae = null;
        af = null;
        ag = null;
        ah = null;
        ai = Nullable$1.toNullable(ST_InsetMode_$type, null);
        aj = null;
        ak = Nullable$1.toNullable(Boolean_$type, null);
        al = null;
        am = null;
        an = Nullable$1.toNullable(Boolean_$type, null);
        ao = null;
        ap = null;
        aq = Nullable$1.toNullable(Boolean_$type, null);
        ar = Nullable$1.toNullable(Number_$type, null);
        as = Nullable$1.toNullable(ST_ConnectorType_$type, null);
        at = Nullable$1.toNullable(ST_BWMode_$type, null);
        au = Nullable$1.toNullable(ST_BWMode_$type, null);
        av = Nullable$1.toNullable(ST_BWMode_$type, null);
        aw = Nullable$1.toNullable(Boolean_$type, null);
        ax = Nullable$1.toNullable(Boolean_$type, null);
        ay = Nullable$1.toNullable(Boolean_$type, null);
        az = Nullable$1.toNullable(Boolean_$type, null);
        a0 = Nullable$1.toNullable(Boolean_$type, null);
        a1 = Nullable$1.toNullable(Boolean_$type, null);
        a2 = null;
        a3 = null;
        a4 = null;
        for (let a5 of fromEnum(a.ab.u)) {
            switch (a5.a.e(a.d)) {
                case "id":
                    b = a5.d;
                    break;
                case "style":
                    c = a5.d;
                    break;
                case "href":
                    d = a5.d;
                    break;
                case "target":
                    e = a5.d;
                    break;
                case "class":
                    f = a5.d;
                    break;
                case "title":
                    g = a5.d;
                    break;
                case "alt":
                    h = a5.d;
                    break;
                case "coordsize":
                    i = a5.d;
                    break;
                case "coordorigin":
                    j = a5.d;
                    break;
                case "wrapcoords":
                    k = a5.d;
                    break;
                case "print":
                    l = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.b9:
                    m = a5.d;
                    break;
                case OfficeNamespace.by:
                    n = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.b2:
                    o = a5.d;
                    break;
                case OfficeNamespace.bg:
                    p = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.a0:
                    q = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.cf:
                    r = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.az:
                    s = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bl:
                    t = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bq:
                    u = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bo:
                    v = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bp:
                    w = Nullable$1.toNullable(Number_$type, parseNumber(a5.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.bm:
                    x = Nullable$1.toNullable(ST_HrAlign_$type, XmlNamespaceDefinitionBase.b(ST_HrAlign_$type, a5.d));
                    break;
                case OfficeNamespace.ar:
                    y = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.as:
                    z = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.ce:
                    aa = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case "bordertopcolor":
                    ab = a5.d;
                    break;
                case "borderleftcolor":
                    ac = a5.d;
                    break;
                case "borderbottomcolor":
                    ad = a5.d;
                    break;
                case "borderrightcolor":
                    ae = a5.d;
                    break;
                case OfficeNamespace.bd:
                    af = a5.d;
                    break;
                case OfficeNamespace.bf:
                    ag = a5.d;
                    break;
                case OfficeNamespace.be:
                    ah = a5.d;
                    break;
                case OfficeNamespace.bs:
                    ai = Nullable$1.toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, a5.d));
                    break;
                case "chromakey":
                    aj = a5.d;
                    break;
                case "filled":
                    ak = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case "fillcolor":
                    al = a5.d;
                    break;
                case "opacity":
                    am = a5.d;
                    break;
                case "stroked":
                    an = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case "strokecolor":
                    ao = a5.d;
                    break;
                case "strokeweight":
                    ap = a5.d;
                    break;
                case "insetpen":
                    aq = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.ca:
                    ar = Nullable$1.toNullable(Number_$type, parseNumber(a5.d, CultureInfo.invariantCulture));
                    break;
                case OfficeNamespace.a8:
                    as = Nullable$1.toNullable(ST_ConnectorType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectorType_$type, a5.d));
                    break;
                case "bwmode":
                    at = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                    break;
                case "bwpure":
                    au = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                    break;
                case "bwnormal":
                    av = Nullable$1.toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                    break;
                case OfficeNamespace.bi:
                    aw = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bw:
                    ax = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.bv:
                    ay = Nullable$1.toNullable(Boolean_$type, ST_TrueFalseBlank.d(a5.d));
                    break;
                case OfficeNamespace.b1:
                    az = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.a5:
                    a0 = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case OfficeNamespace.a4:
                    a1 = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                    break;
                case "adj":
                    a2 = a5.d;
                    break;
                case "path":
                    a3 = a5.d;
                    break;
                case "master":
                    a4 = a5.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y,
            p25: z,
            p26: aa,
            p27: ab,
            p28: ac,
            p29: ad,
            p30: ae,
            p31: af,
            p32: ag,
            p33: ah,
            p34: ai,
            p35: aj,
            p36: ak,
            p37: al,
            p38: am,
            p39: an,
            p40: ao,
            p41: ap,
            p42: aq,
            p43: ar,
            p44: as,
            p45: at,
            p46: au,
            p47: av,
            p48: aw,
            p49: ax,
            p50: ay,
            p51: az,
            p52: a0,
            p53: a1,
            p54: a2,
            p55: a3,
            p56: a4
        };
    }
    static d3(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = Nullable$1.toNullable(Boolean_$type, null), m = null, n = Nullable$1.toNullable(Boolean_$type, null), o = null, p = Nullable$1.toNullable(Boolean_$type, null), q = Nullable$1.toNullable(Boolean_$type, null), r = Nullable$1.toNullable(Boolean_$type, null), s = Nullable$1.toNullable(Boolean_$type, null), t = Nullable$1.toNullable(Boolean_$type, null), u = Nullable$1.toNullable(Boolean_$type, null), v = Nullable$1.toNullable(Boolean_$type, null), w = Nullable$1.toNullable(Number_$type, null), x = Nullable$1.toNullable(ST_HrAlign_$type, null), y = Nullable$1.toNullable(Boolean_$type, null), z = Nullable$1.toNullable(Boolean_$type, null), aa = Nullable$1.toNullable(Boolean_$type, null), ab = null, ac = null, ad = null, ae = null, af = null, ag = null, ah = null, ai = Nullable$1.toNullable(ST_InsetMode_$type, null), aj = null, ak = Nullable$1.toNullable(Boolean_$type, null), al = null, am = null, an = Nullable$1.toNullable(Boolean_$type, null), ao = null, ap = null, aq = Nullable$1.toNullable(Boolean_$type, null), ar = Nullable$1.toNullable(Number_$type, null), as = Nullable$1.toNullable(ST_ConnectorType_$type, null), at = Nullable$1.toNullable(ST_BWMode_$type, null), au = Nullable$1.toNullable(ST_BWMode_$type, null), av = Nullable$1.toNullable(ST_BWMode_$type, null), aw = Nullable$1.toNullable(Boolean_$type, null), ax = Nullable$1.toNullable(Boolean_$type, null), ay = Nullable$1.toNullable(Boolean_$type, null), az = Nullable$1.toNullable(Boolean_$type, null), a0 = Nullable$1.toNullable(Boolean_$type, null), a1 = Nullable$1.toNullable(Boolean_$type, null), a2 = null, a3 = null, a4 = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/shapetype", "v");
        let a5;
        a5 = b;
        a.ad.h("id", a5);
        a5 = c;
        a.ad.h("style", a5);
        a5 = d;
        a.ad.h("href", a5);
        a5 = e;
        a.ad.h("target", a5);
        a5 = f;
        a.ad.h("class", a5);
        a5 = g;
        a.ad.h("title", a5);
        a5 = h;
        a.ad.h("alt", a5);
        a5 = i;
        a.ad.h("coordsize", a5);
        a5 = j;
        a.ad.h("coordorigin", a5);
        a5 = k;
        a.ad.h("wrapcoords", a5);
        if (nullableNotEquals(l, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
            a.ad.h("print", a5);
        }
        a5 = m;
        a.ad.h(OfficeNamespace.b9, a5);
        if (nullableNotEquals(n, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(n.value));
            a.ad.h(OfficeNamespace.by, a5);
        }
        a5 = o;
        a.ad.h(OfficeNamespace.b2, a5);
        if (nullableNotEquals(p, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
            a.ad.h(OfficeNamespace.bg, a5);
        }
        if (nullableNotEquals(q, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
            a.ad.h(OfficeNamespace.a0, a5);
        }
        if (nullableNotEquals(r, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(r.value));
            a.ad.h(OfficeNamespace.cf, a5);
        }
        if (nullableNotEquals(s, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(s.value));
            a.ad.h(OfficeNamespace.az, a5);
        }
        if (nullableNotEquals(t, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
            a.ad.h(OfficeNamespace.bl, a5);
        }
        if (nullableNotEquals(u, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(u.value));
            a.ad.h(OfficeNamespace.bq, a5);
        }
        if (nullableNotEquals(v, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
            a.ad.h(OfficeNamespace.bo, a5);
        }
        if (nullableNotEquals(w, null)) {
            a5 = numberToString(w.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.bp, a5);
        }
        if (nullableNotEquals(x, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_HrAlign_$type, x.value);
            a.ad.h(OfficeNamespace.bm, a5);
        }
        if (nullableNotEquals(y, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
            a.ad.h(OfficeNamespace.ar, a5);
        }
        if (nullableNotEquals(z, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
            a.ad.h(OfficeNamespace.as, a5);
        }
        if (nullableNotEquals(aa, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
            a.ad.h(OfficeNamespace.ce, a5);
        }
        a5 = ab;
        a.ad.h("bordertopcolor", a5);
        a5 = ac;
        a.ad.h("borderleftcolor", a5);
        a5 = ad;
        a.ad.h("borderbottomcolor", a5);
        a5 = ae;
        a.ad.h("borderrightcolor", a5);
        a5 = af;
        a.ad.h(OfficeNamespace.bd, a5);
        a5 = ag;
        a.ad.h(OfficeNamespace.bf, a5);
        a5 = ah;
        a.ad.h(OfficeNamespace.be, a5);
        if (nullableNotEquals(ai, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_InsetMode_$type, ai.value);
            a.ad.h(OfficeNamespace.bs, a5);
        }
        a5 = aj;
        a.ad.h("chromakey", a5);
        if (nullableNotEquals(ak, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(ak.value));
            a.ad.h("filled", a5);
        }
        a5 = al;
        a.ad.h("fillcolor", a5);
        a5 = am;
        a.ad.h("opacity", a5);
        if (nullableNotEquals(an, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(an.value));
            a.ad.h("stroked", a5);
        }
        a5 = ao;
        a.ad.h("strokecolor", a5);
        a5 = ap;
        a.ad.h("strokeweight", a5);
        if (nullableNotEquals(aq, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(aq.value));
            a.ad.h("insetpen", a5);
        }
        if (nullableNotEquals(ar, null)) {
            a5 = numberToString(ar.value, CultureInfo.invariantCulture);
            a.ad.h(OfficeNamespace.ca, a5);
        }
        if (nullableNotEquals(as, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_ConnectorType_$type, as.value);
            a.ad.h(OfficeNamespace.a8, a5);
        }
        if (nullableNotEquals(at, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, at.value);
            a.ad.h("bwmode", a5);
        }
        if (nullableNotEquals(au, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, au.value);
            a.ad.h("bwpure", a5);
        }
        if (nullableNotEquals(av, null)) {
            a5 = XmlNamespaceDefinitionBase.f(ST_BWMode_$type, av.value);
            a.ad.h("bwnormal", a5);
        }
        if (nullableNotEquals(aw, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(aw.value));
            a.ad.h(OfficeNamespace.bi, a5);
        }
        if (nullableNotEquals(ax, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(ax.value));
            a.ad.h(OfficeNamespace.bw, a5);
        }
        if (nullableNotEquals(ay, null)) {
            a5 = ST_TrueFalseBlank.f(ay.value);
            a.ad.h(OfficeNamespace.bv, a5);
        }
        if (nullableNotEquals(az, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(az.value));
            a.ad.h(OfficeNamespace.b1, a5);
        }
        if (nullableNotEquals(a0, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(a0.value));
            a.ad.h(OfficeNamespace.a5, a5);
        }
        if (nullableNotEquals(a1, null)) {
            a5 = ST_TrueFalse.k(ST_TrueFalse.b(a1.value));
            a.ad.h(OfficeNamespace.a4, a5);
        }
        a5 = a2;
        a.ad.h("adj", a5);
        a5 = a3;
        a.ad.h("path", a5);
        a5 = a4;
        a.ad.h("master", a5);
    }
    static dv(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = null;
        e = null;
        f = null;
        g = Nullable$1.toNullable(ST_StrokeLineStyle_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, null);
        j = Nullable$1.toNullable(ST_StrokeEndCap_$type, null);
        k = null;
        l = Nullable$1.toNullable(ST_FillType_$type, null);
        m = null;
        n = Nullable$1.toNullable(ST_ImageAspect_$type, null);
        o = null;
        p = Nullable$1.toNullable(Boolean_$type, null);
        q = null;
        r = Nullable$1.toNullable(ST_StrokeArrowType_$type, null);
        s = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, null);
        t = Nullable$1.toNullable(ST_StrokeArrowLength_$type, null);
        u = Nullable$1.toNullable(ST_StrokeArrowType_$type, null);
        v = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, null);
        w = Nullable$1.toNullable(ST_StrokeArrowLength_$type, null);
        x = null;
        y = null;
        z = null;
        aa = Nullable$1.toNullable(Boolean_$type, null);
        ab = null;
        ac = Nullable$1.toNullable(Boolean_$type, null);
        ad = null;
        for (let ae of fromEnum(a.ab.u)) {
            switch (ae.a.e(a.d)) {
                case "id":
                    b = ae.d;
                    break;
                case "on":
                    c = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                    break;
                case "weight":
                    d = ae.d;
                    break;
                case "color":
                    e = ae.d;
                    break;
                case "opacity":
                    f = ae.d;
                    break;
                case "linestyle":
                    g = Nullable$1.toNullable(ST_StrokeLineStyle_$type, XmlNamespaceDefinitionBase.b(ST_StrokeLineStyle_$type, ae.d));
                    break;
                case "miterlimit":
                    h = Nullable$1.toNullable(Number_$type, parseNumber(ae.d, CultureInfo.invariantCulture));
                    break;
                case "joinstyle":
                    i = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, XmlNamespaceDefinitionBase.b(ST_StrokeJoinStyle_$type, ae.d));
                    break;
                case "endcap":
                    j = Nullable$1.toNullable(ST_StrokeEndCap_$type, XmlNamespaceDefinitionBase.b(ST_StrokeEndCap_$type, ae.d));
                    break;
                case "dashstyle":
                    k = ae.d;
                    break;
                case "filltype":
                    l = Nullable$1.toNullable(ST_FillType_$type, XmlNamespaceDefinitionBase.b(ST_FillType_$type, ae.d));
                    break;
                case "src":
                    m = ae.d;
                    break;
                case "imageaspect":
                    n = Nullable$1.toNullable(ST_ImageAspect_$type, XmlNamespaceDefinitionBase.b(ST_ImageAspect_$type, ae.d));
                    break;
                case "imagesize":
                    o = ae.d;
                    break;
                case "imagealignshape":
                    p = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                    break;
                case "color2":
                    q = ae.d;
                    break;
                case "startarrow":
                    r = Nullable$1.toNullable(ST_StrokeArrowType_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowType_$type, ae.d));
                    break;
                case "startarrowwidth":
                    s = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowWidth_$type, ae.d));
                    break;
                case "startarrowlength":
                    t = Nullable$1.toNullable(ST_StrokeArrowLength_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowLength_$type, ae.d));
                    break;
                case "endarrow":
                    u = Nullable$1.toNullable(ST_StrokeArrowType_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowType_$type, ae.d));
                    break;
                case "endarrowwidth":
                    v = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowWidth_$type, ae.d));
                    break;
                case "endarrowlength":
                    w = Nullable$1.toNullable(ST_StrokeArrowLength_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowLength_$type, ae.d));
                    break;
                case OfficeNamespace.bn:
                    x = ae.d;
                    break;
                case OfficeNamespace.at:
                    y = ae.d;
                    break;
                case OfficeNamespace.cc:
                    z = ae.d;
                    break;
                case OfficeNamespace.bi:
                    aa = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                    break;
                case OfficeDocumentRelationships.ar:
                    ab = ae.d;
                    break;
                case "insetpen":
                    ac = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                    break;
                case OfficeNamespace.b3:
                    ad = ae.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y,
            p25: z,
            p26: aa,
            p27: ab,
            p28: ac,
            p29: ad
        };
    }
    static d4(a, b = null, c = Nullable$1.toNullable(Boolean_$type, null), d = null, e = null, f = null, g = Nullable$1.toNullable(ST_StrokeLineStyle_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(ST_StrokeJoinStyle_$type, null), j = Nullable$1.toNullable(ST_StrokeEndCap_$type, null), k = null, l = Nullable$1.toNullable(ST_FillType_$type, null), m = null, n = Nullable$1.toNullable(ST_ImageAspect_$type, null), o = null, p = Nullable$1.toNullable(Boolean_$type, null), q = null, r = Nullable$1.toNullable(ST_StrokeArrowType_$type, null), s = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, null), t = Nullable$1.toNullable(ST_StrokeArrowLength_$type, null), u = Nullable$1.toNullable(ST_StrokeArrowType_$type, null), v = Nullable$1.toNullable(ST_StrokeArrowWidth_$type, null), w = Nullable$1.toNullable(ST_StrokeArrowLength_$type, null), x = null, y = null, z = null, aa = Nullable$1.toNullable(Boolean_$type, null), ab = null, ac = Nullable$1.toNullable(Boolean_$type, null), ad = null) {
        a.ad.p("urn:schemas-microsoft-com:vml/stroke", "v");
        let ae;
        ae = b;
        a.ad.h("id", ae);
        if (nullableNotEquals(c, null)) {
            ae = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
            a.ad.h("on", ae);
        }
        ae = d;
        a.ad.h("weight", ae);
        ae = e;
        a.ad.h("color", ae);
        ae = f;
        a.ad.h("opacity", ae);
        if (nullableNotEquals(g, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeLineStyle_$type, g.value);
            a.ad.h("linestyle", ae);
        }
        if (nullableNotEquals(h, null)) {
            ae = numberToString(h.value, CultureInfo.invariantCulture);
            a.ad.h("miterlimit", ae);
        }
        if (nullableNotEquals(i, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeJoinStyle_$type, i.value);
            a.ad.h("joinstyle", ae);
        }
        if (nullableNotEquals(j, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeEndCap_$type, j.value);
            a.ad.h("endcap", ae);
        }
        ae = k;
        a.ad.h("dashstyle", ae);
        if (nullableNotEquals(l, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_FillType_$type, l.value);
            a.ad.h("filltype", ae);
        }
        ae = m;
        a.ad.h("src", ae);
        if (nullableNotEquals(n, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_ImageAspect_$type, n.value);
            a.ad.h("imageaspect", ae);
        }
        ae = o;
        a.ad.h("imagesize", ae);
        if (nullableNotEquals(p, null)) {
            ae = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
            a.ad.h("imagealignshape", ae);
        }
        ae = q;
        a.ad.h("color2", ae);
        if (nullableNotEquals(r, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowType_$type, r.value);
            a.ad.h("startarrow", ae);
        }
        if (nullableNotEquals(s, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowWidth_$type, s.value);
            a.ad.h("startarrowwidth", ae);
        }
        if (nullableNotEquals(t, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowLength_$type, t.value);
            a.ad.h("startarrowlength", ae);
        }
        if (nullableNotEquals(u, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowType_$type, u.value);
            a.ad.h("endarrow", ae);
        }
        if (nullableNotEquals(v, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowWidth_$type, v.value);
            a.ad.h("endarrowwidth", ae);
        }
        if (nullableNotEquals(w, null)) {
            ae = XmlNamespaceDefinitionBase.f(ST_StrokeArrowLength_$type, w.value);
            a.ad.h("endarrowlength", ae);
        }
        ae = x;
        a.ad.h(OfficeNamespace.bn, ae);
        ae = y;
        a.ad.h(OfficeNamespace.at, ae);
        ae = z;
        a.ad.h(OfficeNamespace.cc, ae);
        if (nullableNotEquals(aa, null)) {
            ae = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
            a.ad.h(OfficeNamespace.bi, ae);
        }
        ae = ab;
        a.ad.h(OfficeDocumentRelationships.ar, ae);
        if (nullableNotEquals(ac, null)) {
            ae = ST_TrueFalse.k(ST_TrueFalse.b(ac.value));
            a.ad.h("insetpen", ae);
        }
        ae = ad;
        a.ad.h(OfficeNamespace.b3, ae);
    }
    static dw(a, b, c, d, e, f) {
        b = null;
        c = null;
        d = null;
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(ST_InsetMode_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "id":
                    b = g.d;
                    break;
                case "style":
                    c = g.d;
                    break;
                case "inset":
                    d = g.d;
                    break;
                case OfficeNamespace.b8:
                    e = Nullable$1.toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(g.d)));
                    break;
                case OfficeNamespace.bs:
                    f = Nullable$1.toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, g.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static d5(a, b = null, c = null, d = null, e = Nullable$1.toNullable(Boolean_$type, null), f = Nullable$1.toNullable(ST_InsetMode_$type, null)) {
        a.ad.p("urn:schemas-microsoft-com:vml/textbox", "v");
        let g;
        g = b;
        a.ad.h("id", g);
        g = c;
        a.ad.h("style", g);
        g = d;
        a.ad.h("inset", g);
        if (nullableNotEquals(e, null)) {
            g = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
            a.ad.h(OfficeNamespace.b8, g);
        }
        if (nullableNotEquals(f, null)) {
            g = XmlNamespaceDefinitionBase.f(ST_InsetMode_$type, f.value);
            a.ad.h(OfficeNamespace.bs, g);
        }
    }
}
VmlNamespace.$t = markType(VmlNamespace, 'VmlNamespace', XmlNamespaceDefinitionBase.$);
VmlNamespace.aw = "urn:schemas-microsoft-com:vml" + "/background";
VmlNamespace.an = new VmlNamespace();
/**
 * @hidden
 */
export class XmlNamespace extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "http://www.w3.org/XML/1998/namespace";
            default: return "http://www.w3.org/XML/1998/namespace";
        }
    }
    get_j() {
        return "xml";
    }
    get j() {
        return this.get_j();
    }
    static as(a) {
        a.i("xml", "space", "http://www.w3.org/XML/1998/namespace", "preserve");
    }
}
XmlNamespace.$t = markType(XmlNamespace, 'XmlNamespace', XmlNamespaceDefinitionBase.$);
XmlNamespace.ap = "http://www.w3.org/XML/1998/namespace" + "/lang";
XmlNamespace.ar = "http://www.w3.org/XML/1998/namespace" + "/space";
XmlNamespace.an = new XmlNamespace();
/**
 * @hidden
 */
export class XmlSchemaInstance extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return XmlSchemaInstance.ap;
            default: return XmlSchemaInstance.ap;
        }
    }
    get_j() {
        return "xsi";
    }
    get j() {
        return this.get_j();
    }
}
XmlSchemaInstance.$t = markType(XmlSchemaInstance, 'XmlSchemaInstance', XmlNamespaceDefinitionBase.$);
XmlSchemaInstance.ap = "http://www.w3.org/2001/XMLSchema-instance";
XmlSchemaInstance.aq = XmlSchemaInstance.ap + "/type";
XmlSchemaInstance.an = new XmlSchemaInstance();
/**
 * @hidden
 */
export class EG_Anchor extends Base {
    constructor() {
        super(...arguments);
        this.a = null;
    }
}
EG_Anchor.$t = markType(EG_Anchor, 'EG_Anchor');
/**
 * @hidden
 */
export class CT_AbsoluteAnchor extends EG_Anchor {
    constructor() {
        super(...arguments);
        this.c = null;
        this.d = null;
    }
    b($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_AbsoluteAnchor$i(this, b);
    }
}
CT_AbsoluteAnchor.$t = markType(CT_AbsoluteAnchor, 'CT_AbsoluteAnchor', EG_Anchor.$);
/**
 * @hidden
 */
export class CT_AnchorClientData extends Base {
    constructor() {
        super(...arguments);
        this.a = false;
        this.b = false;
    }
}
CT_AnchorClientData.$t = markType(CT_AnchorClientData, 'CT_AnchorClientData');
/**
 * @hidden
 */
export class CT_OneCellAnchor extends EG_Anchor {
    constructor() {
        super(...arguments);
        this.d = null;
        this.c = null;
    }
    b($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_OneCellAnchor$i(this, b);
    }
}
CT_OneCellAnchor.$t = markType(CT_OneCellAnchor, 'CT_OneCellAnchor', EG_Anchor.$);
/**
 * @hidden
 */
export class CT_TwoCellAnchor extends EG_Anchor {
    constructor() {
        super(...arguments);
        this.e = 0;
        this.c = null;
        this.d = null;
    }
    b($tArg, $tResult, a, b = Type.getDefaultValue($tArg)) {
        return a._visitCT_TwoCellAnchor$i(this, b);
    }
}
CT_TwoCellAnchor.$t = markType(CT_TwoCellAnchor, 'CT_TwoCellAnchor', EG_Anchor.$);
/**
 * @hidden
 */
export let IEG_AnchorVisitor$2_$type = new Type(null, 'IEG_AnchorVisitor$2');
/**
 * @hidden
 */
export class ExcelDocumentManager extends OfficeDocumentManager {
    constructor(a, b, c, d) {
        super(a, b, c, d);
    }
    get__v() {
        return 0;
    }
    get _v() {
        return this.get__v();
    }
    _aa() {
        if (this._ac == false) {
            return 0;
        }
        for (let a of fromEnum(this._b.getRelationships())) {
            switch (a.relationshipType) {
                case WorkbookPartManagerBase.a6: return 0;
                case WorkbookPartManagerBase.a5: return 1;
            }
        }
        return 0;
    }
    _bh() {
        super._bh();
        this._bk(DrawingMLSpreadsheetDrawing.dn);
        this._bk(ExcelNamespace.an);
        this._bk(Excel2006Main.an);
        this._bk(SpreadsheetMLMain.ao);
        this._bk(SpreadsheetML2009Main.an);
        this._bl(BmpPartManager.y);
        this._bl(EmfPartManager.y);
        this._bl(GifPartManager.y);
        this._bl(JpegPartManager.y);
        this._bl(PngPartManager.y);
        this._bl(TiffPartManager.y);
        this._bl(WmfPartManager.y);
    }
    get__t() {
        return DrawingMLSpreadsheetDrawing.dn;
    }
    get _t() {
        return this.get__t();
    }
    _bq() {
        switch (this._z) {
            case 0: return ExcelDocumentManager._bp;
            case 1: return ExcelDocumentManager._bo;
            default: return ExcelDocumentManager._bp;
        }
    }
    _br() {
        switch (this._z) {
            case 0: return ExcelDocumentManager._bt;
            case 1: return ExcelDocumentManager._bs;
            default: return ExcelDocumentManager._bt;
        }
    }
}
ExcelDocumentManager.$t = markType(ExcelDocumentManager, 'ExcelDocumentManager', OfficeDocumentManager.$);
ExcelDocumentManager._bp = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath";
ExcelDocumentManager._bo = "http://purl.oclc.org/ooxml/officeDocument/relationships/externalLinkPath";
ExcelDocumentManager._bt = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject";
ExcelDocumentManager._bs = "http://purl.oclc.org/ooxml/officeDocument/relationships/oleObject";
/**
 * @hidden
 */
export class XLOpenXmlUtilities extends Base {
    static a(a) {
        let t1 = a;
        L0: while (true) {
            switch (t1) {
                case 0: return "b";
                case 1: return "d";
                case 2: return "n";
                case 3: return "e";
                case 4: return "s";
                case 5: return "str";
                case 6: return "inlineStr";
                default:
                    t1 = 5;
                    continue L0;
            }
            break;
        }
    }
}
XLOpenXmlUtilities.$t = markType(XLOpenXmlUtilities, 'XLOpenXmlUtilities');
/**
 * @hidden
 */
export class CT_Marker extends Base {
    constructor() {
        super(...arguments);
        this.c = 0;
        this.a = new ST_Coordinate();
        this.d = 0;
        this.b = new ST_Coordinate();
    }
}
CT_Marker.$t = markType(CT_Marker, 'CT_Marker');
/**
 * @hidden
 */
export class ST_Guid extends ValueType {
    constructor(a, ..._rest) {
        super();
        this.d = new Guid();
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0: break;
            case 1:
                {
                    let c = _rest[0];
                    this.d = c;
                }
                break;
        }
    }
    static c(a) {
        return ST_Guid.a(new Guid(3, a));
    }
    toString() {
        return stringToLocaleUpper(this.d.toString2("B"), CultureInfo.invariantCulture);
    }
    static a(a) {
        return new ST_Guid(1, a);
    }
    static h(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(ST_Guid.$, null);
        }
        return Nullable$1.toNullable(ST_Guid.$, ST_Guid.a(a.value));
    }
    static e(a) {
        return a.d;
    }
    static g(a) {
        if (!a.hasValue) {
            return Nullable$1.toNullable(Guid.$, null);
        }
        return Nullable$1.toNullable(Guid.$, ST_Guid.e(a.value));
    }
}
ST_Guid.$t = markStruct(ST_Guid, 'ST_Guid');
/**
 * @hidden
 */
export class CalcChainPartManager extends XmlPartManagerBase {
    get_m() {
        return CalcChainPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/calcChain.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return CalcChainPartManager.a5;
            case 1: return CalcChainPartManager.a4;
            default: return CalcChainPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
CalcChainPartManager.$t = markType(CalcChainPartManager, 'CalcChainPartManager', XmlPartManagerBase.$);
CalcChainPartManager.a2 = "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml";
CalcChainPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain";
CalcChainPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/calcChain";
/**
 * @hidden
 */
export class ChartColorStylePartManager extends XmlPartManagerBase {
    get_m() {
        return ChartColorStylePartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/charts/colors.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartColorStylePartManager.a5;
            case 1: return ChartColorStylePartManager.a4;
            default: return ChartColorStylePartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartColorStylePartManager.$t = markType(ChartColorStylePartManager, 'ChartColorStylePartManager', XmlPartManagerBase.$);
ChartColorStylePartManager.a3 = "application/vnd.ms-office.chartcolorstyle+xml";
ChartColorStylePartManager.a5 = "http://schemas.microsoft.com/office/2011/relationships/chartColorStyle";
ChartColorStylePartManager.a4 = "http://schemas.microsoft.com/office/2011/relationships/chartColorStyle";
/**
 * @hidden
 */
export class ChartExPartManager extends XmlPartManagerBase {
    get_m() {
        return "application/vnd.ms-office.chartex+xml";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/charts/chartEx.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartExPartManager.a6;
            case 1: return ChartExPartManager.a5;
            default: return ChartExPartManager.a6;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartExPartManager.$t = markType(ChartExPartManager, 'ChartExPartManager', XmlPartManagerBase.$);
ChartExPartManager.a6 = "http://schemas.microsoft.com/office/2014/relationships/chartEx";
ChartExPartManager.a5 = "http://purl.oclc.org/ooxml/office/2014/relationships/chartEx";
/**
 * @hidden
 */
export class ChartPartManager extends XmlPartManagerBase {
    get_m() {
        return ChartPartManager.a4;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/charts/chart.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartPartManager.a6;
            case 1: return ChartPartManager.a5;
            default: return ChartPartManager.a6;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartPartManager.$t = markType(ChartPartManager, 'ChartPartManager', XmlPartManagerBase.$);
ChartPartManager.a4 = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml";
ChartPartManager.a6 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart";
ChartPartManager.a5 = "http://purl.oclc.org/ooxml/officeDocument/relationships/chart";
/**
 * @hidden
 */
export class ChartsheetPartManager extends XmlPartManagerBase {
    get_m() {
        return ChartsheetPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/chartsheets/sheet.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartsheetPartManager.a5;
            case 1: return ChartsheetPartManager.a4;
            default: return ChartsheetPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartsheetPartManager.$t = markType(ChartsheetPartManager, 'ChartsheetPartManager', XmlPartManagerBase.$);
ChartsheetPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml";
ChartsheetPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet";
ChartsheetPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/chartsheet";
/**
 * @hidden
 */
export class ChartStylePartManager extends XmlPartManagerBase {
    get_m() {
        return ChartStylePartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/charts/style.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartStylePartManager.a5;
            case 1: return ChartStylePartManager.a4;
            default: return ChartStylePartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartStylePartManager.$t = markType(ChartStylePartManager, 'ChartStylePartManager', XmlPartManagerBase.$);
ChartStylePartManager.a3 = "application/vnd.ms-office.chartstyle+xml";
ChartStylePartManager.a5 = "http://schemas.microsoft.com/office/2011/relationships/chartStyle";
ChartStylePartManager.a4 = "http://schemas.microsoft.com/office/2011/relationships/chartStyle";
/**
 * @hidden
 */
export class ChartUserShapePartManager extends PartManagerBase {
    get_m() {
        return ChartUserShapePartManager.s;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/drawings/drawing.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ChartUserShapePartManager.u;
            case 1: return ChartUserShapePartManager.t;
            default: return ChartUserShapePartManager.u;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ChartUserShapePartManager.$t = markType(ChartUserShapePartManager, 'ChartUserShapePartManager', PartManagerBase.$);
ChartUserShapePartManager.s = "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml";
ChartUserShapePartManager.u = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes";
ChartUserShapePartManager.t = "http://purl.oclc.org/ooxml/officeDocument/relationships/chart";
/**
 * @hidden
 */
export class CommentsPartManager extends XmlPartManagerBase {
    get_m() {
        return CommentsPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/comments.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return CommentsPartManager.a5;
            case 1: return CommentsPartManager.a4;
            default: return CommentsPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
CommentsPartManager.$t = markType(CommentsPartManager, 'CommentsPartManager', XmlPartManagerBase.$);
CommentsPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml";
CommentsPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments";
CommentsPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/comments";
/**
 * @hidden
 */
export class ConnectionsPartManager extends XmlPartManagerBase {
    get_m() {
        return ConnectionsPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/connections.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ConnectionsPartManager.a5;
            case 1: return ConnectionsPartManager.a4;
            default: return ConnectionsPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
ConnectionsPartManager.$t = markType(ConnectionsPartManager, 'ConnectionsPartManager', XmlPartManagerBase.$);
ConnectionsPartManager.a2 = "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml";
ConnectionsPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections";
ConnectionsPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/connections";
/**
 * @hidden
 */
export class CtrlPropPartManager extends PartManagerBase {
    get_m() {
        return CtrlPropPartManager.s;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/ctrlProp.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return CtrlPropPartManager.u;
            case 1: return CtrlPropPartManager.t;
            default: return CtrlPropPartManager.u;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
CtrlPropPartManager.$t = markType(CtrlPropPartManager, 'CtrlPropPartManager', PartManagerBase.$);
CtrlPropPartManager.s = "application/vnd.ms-excel.controlproperties+xml";
CtrlPropPartManager.u = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/ctrlProp";
CtrlPropPartManager.t = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/ctrlProp";
/**
 * @hidden
 */
export class DrawingPartManager extends XmlPartManagerBase {
    get_m() {
        return DrawingPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/drawings/drawing.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return DrawingPartManager.a5;
            case 1: return DrawingPartManager.a4;
            default: return DrawingPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
DrawingPartManager.$t = markType(DrawingPartManager, 'DrawingPartManager', XmlPartManagerBase.$);
DrawingPartManager.a3 = "application/vnd.openxmlformats-officedocument.drawing+xml";
DrawingPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";
DrawingPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/drawing";
/**
 * @hidden
 */
export class ExternalLinkPartManager extends XmlPartManagerBase {
    get_m() {
        return ExternalLinkPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/externalLinks/externalLink.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ExternalLinkPartManager.a5;
            case 1: return ExternalLinkPartManager.a4;
            default: return ExternalLinkPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
ExternalLinkPartManager.$t = markType(ExternalLinkPartManager, 'ExternalLinkPartManager', XmlPartManagerBase.$);
ExternalLinkPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml";
ExternalLinkPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink";
ExternalLinkPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/externalLink";
/**
 * @hidden
 */
export class PivotCacheDefinitionPartManager extends XmlPartManagerBase {
    get_m() {
        return PivotCacheDefinitionPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/pivotCache/pivotCacheDefinition.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return PivotCacheDefinitionPartManager.a5;
            case 1: return PivotCacheDefinitionPartManager.a4;
            default: return PivotCacheDefinitionPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
PivotCacheDefinitionPartManager.$t = markType(PivotCacheDefinitionPartManager, 'PivotCacheDefinitionPartManager', XmlPartManagerBase.$);
PivotCacheDefinitionPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml";
PivotCacheDefinitionPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheDefinition";
PivotCacheDefinitionPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/pivotCacheDefinition";
/**
 * @hidden
 */
export class PivotCacheRecordsPartManager extends XmlPartManagerBase {
    get_m() {
        return PivotCacheRecordsPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/pivotCache/pivotCacheDefinition.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return PivotCacheRecordsPartManager.a5;
            case 1: return PivotCacheRecordsPartManager.a4;
            default: return PivotCacheRecordsPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
PivotCacheRecordsPartManager.$t = markType(PivotCacheRecordsPartManager, 'PivotCacheRecordsPartManager', XmlPartManagerBase.$);
PivotCacheRecordsPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml";
PivotCacheRecordsPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheRecords";
PivotCacheRecordsPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/pivotCacheRecords";
/**
 * @hidden
 */
export class PivotTablePartManager extends XmlPartManagerBase {
    get_m() {
        return PivotTablePartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/pivotTables/pivotTable.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return PivotTablePartManager.a5;
            case 1: return PivotTablePartManager.a4;
            default: return PivotTablePartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
PivotTablePartManager.$t = markType(PivotTablePartManager, 'PivotTablePartManager', XmlPartManagerBase.$);
PivotTablePartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml";
PivotTablePartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotTable";
PivotTablePartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/pivotTable";
/**
 * @hidden
 */
export class SharedStringsPartManager extends XmlPartManagerBase {
    get_m() {
        return SharedStringsPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/sharedStrings.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return SharedStringsPartManager.a5;
            case 1: return SharedStringsPartManager.a4;
            default: return SharedStringsPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
SharedStringsPartManager.$t = markType(SharedStringsPartManager, 'SharedStringsPartManager', XmlPartManagerBase.$);
SharedStringsPartManager.a2 = "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml";
SharedStringsPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings";
SharedStringsPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/sharedStrings";
/**
 * @hidden
 */
export class SlicerCachePartManager extends XmlPartManagerBase {
    get_m() {
        return SlicerCachePartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/slicerCaches/slicerCache.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0:
            case 1: return SlicerCachePartManager.a4;
            default: return SlicerCachePartManager.a4;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
SlicerCachePartManager.$t = markType(SlicerCachePartManager, 'SlicerCachePartManager', XmlPartManagerBase.$);
SlicerCachePartManager.a3 = "application/vnd.ms-excel.slicerCache+xml";
SlicerCachePartManager.a4 = "http://schemas.microsoft.com/office/2007/relationships/slicerCache";
/**
 * @hidden
 */
export class SlicerPartManager extends XmlPartManagerBase {
    get_m() {
        return "application/vnd.ms-excel.slicer+xml";
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/slicers/slicer.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0:
            case 1: return SlicerPartManager.a4;
            default: return SlicerPartManager.a4;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
SlicerPartManager.$t = markType(SlicerPartManager, 'SlicerPartManager', XmlPartManagerBase.$);
SlicerPartManager.a4 = "http://schemas.microsoft.com/office/2007/relationships/slicer";
/**
 * @hidden
 */
export class ExcelStylesPartManager extends XmlPartManagerBase {
    get_m() {
        return ExcelStylesPartManager.a2;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/styles.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return ExcelStylesPartManager.a5;
            case 1: return ExcelStylesPartManager.a4;
            default: return ExcelStylesPartManager.a5;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
ExcelStylesPartManager.$t = markType(ExcelStylesPartManager, 'ExcelStylesPartManager', XmlPartManagerBase.$);
ExcelStylesPartManager.a2 = "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml";
ExcelStylesPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles";
ExcelStylesPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/styles";
/**
 * @hidden
 */
export class TablePartManager extends XmlPartManagerBase {
    get_m() {
        return TablePartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/tables/table.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return TablePartManager.a5;
            case 1: return TablePartManager.a4;
            default: return TablePartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
TablePartManager.$t = markType(TablePartManager, 'TablePartManager', XmlPartManagerBase.$);
TablePartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml";
TablePartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table";
TablePartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/table";
/**
 * @hidden
 */
export class WorkbookPartManagerBase extends XmlPartManagerBase {
    n(a) {
        switch (a) {
            case 0: return "/xl/workbook.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return WorkbookPartManagerBase.a6;
            case 1: return WorkbookPartManagerBase.a5;
            default: return WorkbookPartManagerBase.a6;
        }
    }
    get_g() {
        return false;
    }
    get g() {
        return this.get_g();
    }
}
WorkbookPartManagerBase.$t = markType(WorkbookPartManagerBase, 'WorkbookPartManagerBase', XmlPartManagerBase.$);
WorkbookPartManagerBase.a3 = "application/vnd.ms-excel.template.macroEnabled.main+xml";
WorkbookPartManagerBase.a4 = "application/vnd.ms-excel.sheet.macroEnabled.main+xml";
WorkbookPartManagerBase.a7 = "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml";
WorkbookPartManagerBase.a8 = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml";
WorkbookPartManagerBase.a6 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument";
WorkbookPartManagerBase.a5 = "http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument";
/**
 * @hidden
 */
export class WorksheetPartManager extends XmlPartManagerBase {
    get_m() {
        return WorksheetPartManager.a3;
    }
    get m() {
        return this.get_m();
    }
    n(a) {
        switch (a) {
            case 0: return "/xl/worksheets/sheet.xml";
            default: return null;
        }
    }
    o(a) {
        switch (a) {
            case 0: return WorksheetPartManager.a5;
            case 1: return WorksheetPartManager.a4;
            default: return WorksheetPartManager.a5;
        }
    }
    get_g() {
        return true;
    }
    get g() {
        return this.get_g();
    }
}
WorksheetPartManager.$t = markType(WorksheetPartManager, 'WorksheetPartManager', XmlPartManagerBase.$);
WorksheetPartManager.a3 = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml";
WorksheetPartManager.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet";
WorksheetPartManager.a4 = "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet";
/**
 * @hidden
 */
export class DrawingMLSpreadsheetDrawing extends DrawingNamespaceDefinitionBase {
    constructor() {
        super(DrawingMLSpreadsheetDrawing.dq, DrawingMLSpreadsheetDrawing.dr);
    }
    get_j() {
        return "xdr";
    }
    get j() {
        return this.get_j();
    }
    static eq(a, b) {
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                default: break;
            }
        }
    }
    static e5(a, b) {
        a.ad.p(b, "xdr");
    }
    static ex(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = ST_Coordinate.h(a.ab.ad);
        return {
            p2: c
        };
    }
    static fc(a, b, c) {
        a.ad.p(b, "xdr");
        a.ad.u(c.toString());
    }
    static em(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static e1(a) {
        a.ad.p(DrawingMLSpreadsheetDrawing.ds, "xdr");
    }
    static en(a, b, c) {
        b = true;
        c = true;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "fLocksWithSheet":
                    b = ST_OnOff.e(d.d);
                    break;
                case "fPrintsWithSheet":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static e2(a, b = true, c = true) {
        a.ad.p(DrawingMLSpreadsheetDrawing.dt, "xdr");
        let d;
        if (b != true) {
            d = ST_OnOff.g(b);
            a.ad.h("fLocksWithSheet", d);
        }
        if (c != true) {
            d = ST_OnOff.g(c);
            a.ad.h("fPrintsWithSheet", d);
        }
    }
    static eo(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, DrawingMLSpreadsheetDrawing.dw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e3(a, b) {
        XmlNamespaceDefinitionBase.af(a, DrawingMLSpreadsheetDrawing.dw, "xdr", b);
    }
    static ep(a, b) {
        let c = DrawingMLSpreadsheetDrawing.ex(a, DrawingMLSpreadsheetDrawing.dx, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e4(a, b) {
        DrawingMLSpreadsheetDrawing.fc(a, DrawingMLSpreadsheetDrawing.dx, b);
    }
    static er(a, b, c) {
        let d = DrawingMLMain.k5(a, DrawingMLSpreadsheetDrawing.d0, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static e6(a, b, c) {
        DrawingMLMain.n6(a, DrawingMLSpreadsheetDrawing.d0, b, c);
    }
    static es(a) {
    }
    static e7(a) {
        DrawingMLSpreadsheetDrawing.e5(a, DrawingMLSpreadsheetDrawing.d3);
    }
    static et(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static e8(a) {
        a.ad.p(DrawingMLSpreadsheetDrawing.ea, "xdr");
    }
    static eu(a, b, c) {
        let d = DrawingMLMain.k1(a, DrawingMLSpreadsheetDrawing.ec, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static e9(a, b, c) {
        DrawingMLMain.n2(a, DrawingMLSpreadsheetDrawing.ec, b, c);
    }
    static ev(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, DrawingMLSpreadsheetDrawing.ed, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fa(a, b) {
        XmlNamespaceDefinitionBase.af(a, DrawingMLSpreadsheetDrawing.ed, "xdr", b);
    }
    static ew(a, b) {
        let c = DrawingMLSpreadsheetDrawing.ex(a, DrawingMLSpreadsheetDrawing.ee, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fb(a, b) {
        DrawingMLSpreadsheetDrawing.fc(a, DrawingMLSpreadsheetDrawing.ee, b);
    }
    static ey(a) {
    }
    static fd(a) {
        DrawingMLSpreadsheetDrawing.e5(a, DrawingMLSpreadsheetDrawing.ei);
    }
    static ez(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "editAs":
                    b = XmlNamespaceDefinitionBase.b(ST_EditAs_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static fe(a, b = 0) {
        a.ad.p(DrawingMLSpreadsheetDrawing.ej, "xdr");
        let c;
        if (b != 0) {
            c = XmlNamespaceDefinitionBase.f(ST_EditAs_$type, b);
            a.ad.h("editAs", c);
        }
    }
    static e0(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ff(a) {
        a.ad.p(DrawingMLSpreadsheetDrawing.el, "xdr");
        let b = a.d._z;
        a.ad.l(DrawingMLMain.an);
        a.ad.l(DrawingMLSpreadsheetDrawing.dn);
    }
}
DrawingMLSpreadsheetDrawing.$t = markType(DrawingMLSpreadsheetDrawing, 'DrawingMLSpreadsheetDrawing', DrawingNamespaceDefinitionBase.$);
DrawingMLSpreadsheetDrawing.dr = "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing";
DrawingMLSpreadsheetDrawing.dq = "http://purl.oclc.org/ooxml/drawingml/spreadsheetDrawing";
DrawingMLSpreadsheetDrawing.ds = DrawingMLSpreadsheetDrawing.dq + "/absoluteAnchor";
DrawingMLSpreadsheetDrawing.dt = DrawingMLSpreadsheetDrawing.dq + "/clientData";
DrawingMLSpreadsheetDrawing.dw = DrawingMLSpreadsheetDrawing.dq + "/col";
DrawingMLSpreadsheetDrawing.dx = DrawingMLSpreadsheetDrawing.dq + "/colOff";
DrawingMLSpreadsheetDrawing.d0 = DrawingMLSpreadsheetDrawing.dq + "/ext";
DrawingMLSpreadsheetDrawing.d3 = DrawingMLSpreadsheetDrawing.dq + "/from";
DrawingMLSpreadsheetDrawing.ea = DrawingMLSpreadsheetDrawing.dq + "/oneCellAnchor";
DrawingMLSpreadsheetDrawing.ec = DrawingMLSpreadsheetDrawing.dq + "/pos";
DrawingMLSpreadsheetDrawing.ed = DrawingMLSpreadsheetDrawing.dq + "/row";
DrawingMLSpreadsheetDrawing.ee = DrawingMLSpreadsheetDrawing.dq + "/rowOff";
DrawingMLSpreadsheetDrawing.ei = DrawingMLSpreadsheetDrawing.dq + "/to";
DrawingMLSpreadsheetDrawing.ej = DrawingMLSpreadsheetDrawing.dq + "/twoCellAnchor";
DrawingMLSpreadsheetDrawing.el = DrawingMLSpreadsheetDrawing.dq + "/wsDr";
DrawingMLSpreadsheetDrawing.dy = DrawingMLSpreadsheetDrawing.dq + "/cxnSp";
DrawingMLSpreadsheetDrawing.d4 = DrawingMLSpreadsheetDrawing.dq + "/graphicFrame";
DrawingMLSpreadsheetDrawing.d5 = DrawingMLSpreadsheetDrawing.dq + "/grpSp";
DrawingMLSpreadsheetDrawing.eb = DrawingMLSpreadsheetDrawing.dq + "/pic";
DrawingMLSpreadsheetDrawing.ef = DrawingMLSpreadsheetDrawing.dq + "/sp";
DrawingMLSpreadsheetDrawing.d9 = DrawingMLSpreadsheetDrawing.dq + "/nvSpPr";
DrawingMLSpreadsheetDrawing.du = DrawingMLSpreadsheetDrawing.dq + "/cNvPr";
DrawingMLSpreadsheetDrawing.dv = DrawingMLSpreadsheetDrawing.dq + "/cNvSpPr";
DrawingMLSpreadsheetDrawing.eg = DrawingMLSpreadsheetDrawing.dq + "/spPr";
DrawingMLSpreadsheetDrawing.ek = DrawingMLSpreadsheetDrawing.dq + "/txBody";
DrawingMLSpreadsheetDrawing.dn = new DrawingMLSpreadsheetDrawing();
/**
 * @hidden
 */
export class Excel2006Main extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return Excel2006Main.aq;
            default: return Excel2006Main.aq;
        }
    }
    get_j() {
        return "xm";
    }
    get j() {
        return this.get_j();
    }
    static as(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, Excel2006Main.ap, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static au(a, b) {
        XmlNamespaceDefinitionBase.ai(a, Excel2006Main.ap, "xm", b);
    }
    static at(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, Excel2006Main.ar, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static av(a, b) {
        XmlNamespaceDefinitionBase.ai(a, Excel2006Main.ar, "xm", b);
    }
}
Excel2006Main.$t = markType(Excel2006Main, 'Excel2006Main', XmlNamespaceDefinitionBase.$);
Excel2006Main.aq = "http://schemas.microsoft.com/office/excel/2006/main";
Excel2006Main.ap = Excel2006Main.aq + "/f";
Excel2006Main.ar = Excel2006Main.aq + "/sqref";
Excel2006Main.an = new Excel2006Main();
/**
 * @hidden
 */
export class ExcelNamespace extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return "urn:schemas-microsoft-com:office:excel";
            default: return "urn:schemas-microsoft-com:office:excel";
        }
    }
    get_j() {
        return "x";
    }
    get j() {
        return this.get_j();
    }
    static dm(a, b, c) {
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                default: break;
            }
        }
        c = ST_TrueFalseBlank.d(a.ab.ad);
        return {
            p2: c
        };
    }
    static e7(a, b, c, d) {
        a.ad.p(b, c);
        let e = ST_TrueFalseBlank.f(d);
        if (stringIsNullOrEmpty(e) == false) {
            a.ad.u(e);
        }
    }
    static ca(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.ap, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dv(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.ap, "x", b);
    }
    static cb(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.aq, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dw(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.aq, "x", b);
    }
    static cc(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.ar, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dx(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.ar, "x", b);
    }
    static cd(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.as, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dy(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.as, "x", b);
    }
    static ce(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.at, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dz(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.at, "x", b);
    }
    static cf(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.au, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d0(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.au, "x", b);
    }
    static cg(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.av, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d1(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.av, "x", b);
    }
    static ch(a, b) {
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                default: break;
            }
        }
        b = XmlNamespaceDefinitionBase.b(ST_CF_$type, a.ab.ad);
        return {
            p1: b
        };
    }
    static d2(a, b) {
        a.ad.p(ExcelNamespace.aw, "x");
        a.ad.u(XmlNamespaceDefinitionBase.f(ST_CF_$type, b));
    }
    static ci(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.ax, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d3(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.ax, "x", b);
    }
    static cj(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ObjectType":
                    b = XmlNamespaceDefinitionBase.b(ST_ObjectType_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static d4(a, b) {
        a.ad.p(ExcelNamespace.ay, "x");
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_ObjectType_$type, b);
        a.ad.h("ObjectType", c);
    }
    static ck(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.az, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d5(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.az, "x", b);
    }
    static cl(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a0, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d6(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a0, "x", b);
    }
    static cm(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.a1, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d7(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.a1, "x", b);
    }
    static cn(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a2, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d8(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a2, "x", b);
    }
    static co(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a3, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static d9(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a3, "x", b);
    }
    static cp(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a4, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ea(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a4, "x", b);
    }
    static cq(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a5, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eb(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a5, "x", b);
    }
    static cr(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.a6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ec(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.a6, "x", b);
    }
    static cs(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.a7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ed(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.a7, "x", b);
    }
    static ct(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.a8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ee(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.a8, "x", b);
    }
    static cu(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.a9, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ef(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.a9, "x", b);
    }
    static cv(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.ba, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eg(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.ba, "x", b);
    }
    static cw(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.bb, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eh(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.bb, "x", b);
    }
    static cx(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.bc, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ei(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.bc, "x", b);
    }
    static cy(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.bd, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ej(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.bd, "x", b);
    }
    static cz(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.be, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ek(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.be, "x", b);
    }
    static c0(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bf, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static el(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bf, "x", b);
    }
    static c1(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.bg, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static em(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.bg, "x", b);
    }
    static c2(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bh, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static en(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bh, "x", b);
    }
    static c3(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.bi, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eo(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.bi, "x", b);
    }
    static c5(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bk, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eq(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bk, "x", b);
    }
    static c4(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bj, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ep(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bj, "x", b);
    }
    static c6(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bl, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static er(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bl, "x", b);
    }
    static c7(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.bm, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static es(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.bm, "x", b);
    }
    static c8(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.bn, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static et(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.bn, "x", b);
    }
    static c9(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bo, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static eu(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bo, "x", b);
    }
    static da(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bp, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ev(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bp, "x", b);
    }
    static dc(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.br, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ex(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.br, "x", b);
    }
    static db(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bs, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ew(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bs, "x", b);
    }
    static dd(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.bu, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ey(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.bu, "x", b);
    }
    static de(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bv, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ez(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bv, "x", b);
    }
    static df(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bw, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e0(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bw, "x", b);
    }
    static dg(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.bx, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e1(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.bx, "x", b);
    }
    static dh(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.by, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e2(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.by, "x", b);
    }
    static di(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.bz, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e3(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.bz, "x", b);
    }
    static dj(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.b0, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e4(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.b0, "x", b);
    }
    static dk(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.b1, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e5(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.b1, "x", b);
    }
    static dl(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.b2, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e6(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.b2, "x", b);
    }
    static dn(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.b3, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e8(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.b3, "x", b);
    }
    static dp(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, ExcelNamespace.b4, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static e9(a, b) {
        XmlNamespaceDefinitionBase.ai(a, ExcelNamespace.b4, "x", b);
    }
    static dq(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.b5, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fa(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.b5, "x", b);
    }
    static du(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.b9, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fe(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.b9, "x", b);
    }
    static ds(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.b7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fc(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.b7, "x", b);
    }
    static dr(a, b) {
        let c = XmlNamespaceDefinitionBase.r(a, ExcelNamespace.b6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fb(a, b) {
        XmlNamespaceDefinitionBase.af(a, ExcelNamespace.b6, "x", b);
    }
    static dt(a, b) {
        let c = ExcelNamespace.dm(a, ExcelNamespace.b8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static fd(a, b) {
        ExcelNamespace.e7(a, ExcelNamespace.b8, "x", b);
    }
}
ExcelNamespace.$t = markType(ExcelNamespace, 'ExcelNamespace', XmlNamespaceDefinitionBase.$);
ExcelNamespace.ap = "urn:schemas-microsoft-com:office:excel" + "/Anchor";
ExcelNamespace.aq = "urn:schemas-microsoft-com:office:excel" + "/AutoFill";
ExcelNamespace.ar = "urn:schemas-microsoft-com:office:excel" + "/AutoLine";
ExcelNamespace.as = "urn:schemas-microsoft-com:office:excel" + "/AutoPict";
ExcelNamespace.at = "urn:schemas-microsoft-com:office:excel" + "/AutoScale";
ExcelNamespace.au = "urn:schemas-microsoft-com:office:excel" + "/Camera";
ExcelNamespace.av = "urn:schemas-microsoft-com:office:excel" + "/Cancel";
ExcelNamespace.aw = "urn:schemas-microsoft-com:office:excel" + "/CF";
ExcelNamespace.ax = "urn:schemas-microsoft-com:office:excel" + "/Checked";
ExcelNamespace.ay = "urn:schemas-microsoft-com:office:excel" + "/ClientData";
ExcelNamespace.az = "urn:schemas-microsoft-com:office:excel" + "/ColHidden";
ExcelNamespace.a0 = "urn:schemas-microsoft-com:office:excel" + "/Colored";
ExcelNamespace.a1 = "urn:schemas-microsoft-com:office:excel" + "/Column";
ExcelNamespace.a2 = "urn:schemas-microsoft-com:office:excel" + "/DDE";
ExcelNamespace.a3 = "urn:schemas-microsoft-com:office:excel" + "/Default";
ExcelNamespace.a4 = "urn:schemas-microsoft-com:office:excel" + "/DefaultSize";
ExcelNamespace.a5 = "urn:schemas-microsoft-com:office:excel" + "/Disabled";
ExcelNamespace.a6 = "urn:schemas-microsoft-com:office:excel" + "/Dismiss";
ExcelNamespace.a7 = "urn:schemas-microsoft-com:office:excel" + "/DropLines";
ExcelNamespace.a8 = "urn:schemas-microsoft-com:office:excel" + "/DropStyle";
ExcelNamespace.a9 = "urn:schemas-microsoft-com:office:excel" + "/Dx";
ExcelNamespace.ba = "urn:schemas-microsoft-com:office:excel" + "/FirstButton";
ExcelNamespace.bb = "urn:schemas-microsoft-com:office:excel" + "/FmlaLink";
ExcelNamespace.bc = "urn:schemas-microsoft-com:office:excel" + "/FmlaMacro";
ExcelNamespace.bd = "urn:schemas-microsoft-com:office:excel" + "/FmlaRange";
ExcelNamespace.be = "urn:schemas-microsoft-com:office:excel" + "/Help";
ExcelNamespace.bf = "urn:schemas-microsoft-com:office:excel" + "/Horiz";
ExcelNamespace.bg = "urn:schemas-microsoft-com:office:excel" + "/Inc";
ExcelNamespace.bh = "urn:schemas-microsoft-com:office:excel" + "/JustLastX";
ExcelNamespace.bi = "urn:schemas-microsoft-com:office:excel" + "/LCT";
ExcelNamespace.bk = "urn:schemas-microsoft-com:office:excel" + "/LockText";
ExcelNamespace.bj = "urn:schemas-microsoft-com:office:excel" + "/Locked";
ExcelNamespace.bn = "urn:schemas-microsoft-com:office:excel" + "/Min";
ExcelNamespace.bl = "urn:schemas-microsoft-com:office:excel" + "/MapOCX";
ExcelNamespace.bm = "urn:schemas-microsoft-com:office:excel" + "/Max";
ExcelNamespace.bo = "urn:schemas-microsoft-com:office:excel" + "/MoveWithCells";
ExcelNamespace.bp = "urn:schemas-microsoft-com:office:excel" + "/MultiLine";
ExcelNamespace.br = "urn:schemas-microsoft-com:office:excel" + "/NoThreeD";
ExcelNamespace.bs = "urn:schemas-microsoft-com:office:excel" + "/NoThreeD2";
ExcelNamespace.bu = "urn:schemas-microsoft-com:office:excel" + "/Page";
ExcelNamespace.bv = "urn:schemas-microsoft-com:office:excel" + "/PrintObject";
ExcelNamespace.bw = "urn:schemas-microsoft-com:office:excel" + "/RecalcAlways";
ExcelNamespace.bx = "urn:schemas-microsoft-com:office:excel" + "/Row";
ExcelNamespace.by = "urn:schemas-microsoft-com:office:excel" + "/RowHidden";
ExcelNamespace.bz = "urn:schemas-microsoft-com:office:excel" + "/SecretEdit";
ExcelNamespace.b0 = "urn:schemas-microsoft-com:office:excel" + "/Sel";
ExcelNamespace.b1 = "urn:schemas-microsoft-com:office:excel" + "/SelType";
ExcelNamespace.b2 = "urn:schemas-microsoft-com:office:excel" + "/SizeWithCells";
ExcelNamespace.b3 = "urn:schemas-microsoft-com:office:excel" + "/TextHAlign";
ExcelNamespace.b4 = "urn:schemas-microsoft-com:office:excel" + "/TextVAlign";
ExcelNamespace.b5 = "urn:schemas-microsoft-com:office:excel" + "/UIObj";
ExcelNamespace.b9 = "urn:schemas-microsoft-com:office:excel" + "/VScroll";
ExcelNamespace.b6 = "urn:schemas-microsoft-com:office:excel" + "/Val";
ExcelNamespace.b7 = "urn:schemas-microsoft-com:office:excel" + "/ValidIds";
ExcelNamespace.b8 = "urn:schemas-microsoft-com:office:excel" + "/Visible";
ExcelNamespace.an = new ExcelNamespace();
/**
 * @hidden
 */
export class SpreadsheetML2009Main extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0:
            case 1: return SpreadsheetML2009Main.b0;
            default: return SpreadsheetML2009Main.b0;
        }
    }
    get_j() {
        return "x14";
    }
    get j() {
        return this.get_j();
    }
    static cy(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = false;
        g = false;
        h = false;
        i = false;
        j = null;
        k = null;
        l = null;
        m = null;
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_DataValidationType_$type, n.d, b);
                    break;
                case "errorStyle":
                    c = XmlNamespaceDefinitionBase.b(ST_DataValidationErrorStyle_$type, n.d, c);
                    break;
                case "imeMode":
                    d = XmlNamespaceDefinitionBase.b(ST_DataValidationImeMode_$type, n.d, d);
                    break;
                case "operator":
                    e = XmlNamespaceDefinitionBase.b(ST_DataValidationOperator_$type, n.d, e);
                    break;
                case "allowBlank":
                    f = ST_OnOff.e(n.d);
                    break;
                case "showDropDown":
                    g = ST_OnOff.e(n.d);
                    break;
                case "showInputMessage":
                    h = ST_OnOff.e(n.d);
                    break;
                case "showErrorMessage":
                    i = ST_OnOff.e(n.d);
                    break;
                case "errorTitle":
                    j = n.d;
                    break;
                case "error":
                    k = n.d;
                    break;
                case "promptTitle":
                    l = n.d;
                    break;
                case "prompt":
                    m = n.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static dg(a, b = 0, c = 0, d = 0, e = 0, f = false, g = false, h = false, i = false, j = null, k = null, l = null, m = null) {
        a.ad.p(SpreadsheetML2009Main.bd, "x14");
        let n;
        if (b != 0) {
            n = XmlNamespaceDefinitionBase.f(ST_DataValidationType_$type, b);
            a.ad.h("type", n);
        }
        if (c != 0) {
            n = XmlNamespaceDefinitionBase.f(ST_DataValidationErrorStyle_$type, c);
            a.ad.h("errorStyle", n);
        }
        if (d != 0) {
            n = XmlNamespaceDefinitionBase.f(ST_DataValidationImeMode_$type, d);
            a.ad.h("imeMode", n);
        }
        if (e != 0) {
            n = XmlNamespaceDefinitionBase.f(ST_DataValidationOperator_$type, e);
            a.ad.h("operator", n);
        }
        if (f != false) {
            n = ST_OnOff.g(f);
            a.ad.h("allowBlank", n);
        }
        if (g != false) {
            n = ST_OnOff.g(g);
            a.ad.h("showDropDown", n);
        }
        if (h != false) {
            n = ST_OnOff.g(h);
            a.ad.h("showInputMessage", n);
        }
        if (i != false) {
            n = ST_OnOff.g(i);
            a.ad.h("showErrorMessage", n);
        }
        n = j;
        a.ad.h("errorTitle", n);
        n = k;
        a.ad.h("error", n);
        n = l;
        a.ad.h("promptTitle", n);
        n = m;
        a.ad.h("prompt", n);
    }
    static cz(a, b, c, d, e) {
        b = false;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "disablePrompts":
                    b = ST_OnOff.e(f.d);
                    break;
                case "xWindow":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "yWindow":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "count":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static dh(a, b = false, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetML2009Main.be, "x14");
        let f;
        if (b != false) {
            f = ST_OnOff.g(b);
            a.ad.h("disablePrompts", f);
        }
        if (nullableNotEquals(c, null)) {
            f = c.value.toString();
            a.ad.h("xWindow", f);
        }
        if (nullableNotEquals(d, null)) {
            f = d.value.toString();
            a.ad.h("yWindow", f);
        }
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("count", f);
        }
    }
    static c0(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static di(a) {
        a.ad.p(SpreadsheetML2009Main.bn, "x14");
    }
    static c1(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static dj(a) {
        a.ad.p(SpreadsheetML2009Main.bo, "x14");
    }
    static c2(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetML2009Main.bv, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static dk(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetML2009Main.bv, SpreadsheetML2009Main.b0, b);
    }
    static de(a) {
        a.ad.p(SpreadsheetML2009Main.a9, "x14");
    }
    static cw(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case SpreadsheetML2009Main.bv:
                    b = c.d;
                    break;
            }
        }
        return {
            p1: b
        };
    }
    static dd(a, b, c) {
        a.ad.p(SpreadsheetML2009Main.a8, "x14");
        let d;
        if (stringIsNullOrEmpty(b) == false) {
            d = b;
            a.ad.i("xmlns", "xm", null, d);
        }
        if (c.hasValue && c.value) {
            d = ST_OnOff.g(c.value);
            a.ad.h("pivot", d);
        }
    }
    static dc(a) {
        a.ad.p(SpreadsheetML2009Main.a6, "x14");
    }
    static da(a, b, c = Nullable$1.toNullable(ST_CfType_$type, null), d = 0, e = false, f = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), g = Nullable$1.toNullable(Boolean_$type, null)) {
        let h = Nullable$1.toNullable(Number_$type, null);
        let i = Nullable$1.toNullable(Boolean_$type, null);
        let j = Nullable$1.toNullable(Boolean_$type, null);
        let k = Nullable$1.toNullable(Boolean_$type, null);
        let l = null;
        let m = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        let n = Nullable$1.toNullable(Number_$type, null);
        let o = Nullable$1.toNullable(Number_$type, null);
        let p = Nullable$1.toNullable(Boolean_$type, null);
        SpreadsheetMLMain.zp(a, SpreadsheetML2009Main.aw, c, h, d, e, i, j, k, f, l, m, n, o, p, b, g);
    }
    static cv(a, b, c, d) {
        let e = SpreadsheetMLMain.t6(a, SpreadsheetML2009Main.ax, b, c, d);
        b = e.p2;
        c = e.p3;
        d = e.p4;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static db(a, b, c = true) {
        a.ad.p(SpreadsheetML2009Main.ax, "x14");
        let d;
        d = XmlNamespaceDefinitionBase.f(ST_CfvoType_$type, b);
        a.ad.h("type", d);
        if (c != true) {
            d = ST_OnOff.g(c);
            a.ad.h("gte", d);
        }
    }
    static cx(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = Nullable$1.toNullable(ST_DataBarDirection_$type, null);
        h = Nullable$1.toNullable(Boolean_$type, null);
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "minLength":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "maxLength":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "showValue":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "border":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "gradient":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "direction":
                    g = Nullable$1.toNullable(ST_DataBarDirection_$type, XmlNamespaceDefinitionBase.b(ST_DataBarDirection_$type, k.d));
                    break;
                case "negativeBarColorSameAsPositive":
                    h = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "negativeBarBorderColorSameAsPositive":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(k.d));
                    break;
                case "axisPosition":
                    j = Nullable$1.toNullable(ST_DataBarAxisPosition_$type, XmlNamespaceDefinitionBase.b(ST_DataBarAxisPosition_$type, k.d));
                    break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static df(a, b, c, d, e, f, g, h, i, j) {
        a.ad.p(SpreadsheetML2009Main.bc, "x14");
        let k;
        if (b.hasValue) {
            k = b.value.toString();
            a.ad.h("minLength", k);
        }
        if (c.hasValue) {
            k = c.value.toString();
            a.ad.h("maxLength", k);
        }
        if (d.hasValue && d.value != true) {
            k = ST_OnOff.g(d.value);
            a.ad.h("showValue", k);
        }
        if (e.hasValue && e.value) {
            k = ST_OnOff.g(e.value);
            a.ad.h("border", k);
        }
        if (f.hasValue && f.value != true) {
            k = ST_OnOff.g(f.value);
            a.ad.h("gradient", k);
        }
        if (g.hasValue && g.value != 0) {
            k = XmlNamespaceDefinitionBase.f(ST_DataBarDirection_$type, g.value);
            a.ad.h("direction", k);
        }
        if (h.hasValue && h.value != false) {
            k = ST_OnOff.g(h.value);
            a.ad.h("negativeBarColorSameAsPositive", k);
        }
        if (i.hasValue && i.value != true) {
            k = ST_OnOff.g(i.value);
            a.ad.h("negativeBarBorderColorSameAsPositive", k);
        }
        if (j.hasValue && j.value != 0) {
            k = XmlNamespaceDefinitionBase.f(ST_DataBarAxisPosition_$type, j.value);
            a.ad.h("axisPosition", k);
        }
    }
    static cu(a, b, c) {
        b = 3;
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "iconSet":
                    b = XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, d.d);
                    break;
                case "iconId":
                    c = parseUInt32_1(d.d);
                    break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static c9(a, b, c) {
        a.ad.p(SpreadsheetML2009Main.av, "x14");
        let d;
        d = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, b);
        a.ad.h("iconSet", d);
        d = c.toString();
        a.ad.h("iconId", d);
    }
    static c3(a, b, c, d, e) {
        b = null;
        c = false;
        d = false;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "icon":
                    c = ST_OnOff.e(f.d);
                    break;
                case "advise":
                    d = ST_OnOff.e(f.d);
                    break;
                case "preferPic":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static dl(a, b = null, c = false, d = false, e = false) {
        a.ad.p(SpreadsheetML2009Main.b5, "x14");
        let f;
        f = b;
        a.ad.h("name", f);
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("icon", f);
        }
        if (d != false) {
            f = ST_OnOff.g(d);
            a.ad.h("advise", f);
        }
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("preferPic", f);
        }
    }
    static c4(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static dm(a) {
        a.ad.p(SpreadsheetML2009Main.b7, "x14");
    }
    static c7(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static dq(a, b) {
        a.ad.p(SpreadsheetML2009Main.cf, "x14");
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static c5(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static dn(a, b) {
        a.ad.p(SpreadsheetML2009Main.cg, "x14");
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static c6(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static dp(a) {
        a.ad.p(SpreadsheetML2009Main.ch, "x14");
    }
    static c8(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static dr(a) {
        a.ad.p(SpreadsheetML2009Main.cj, "x14");
    }
}
SpreadsheetML2009Main.$t = markType(SpreadsheetML2009Main, 'SpreadsheetML2009Main', XmlNamespaceDefinitionBase.$);
SpreadsheetML2009Main.b0 = "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main";
SpreadsheetML2009Main.ar = SpreadsheetML2009Main.b0 + "/axisColor";
SpreadsheetML2009Main.au = SpreadsheetML2009Main.b0 + "/borderColor";
SpreadsheetML2009Main.a8 = SpreadsheetML2009Main.b0 + "/conditionalFormatting";
SpreadsheetML2009Main.a9 = SpreadsheetML2009Main.b0 + "/conditionalFormattings";
SpreadsheetML2009Main.av = SpreadsheetML2009Main.b0 + "/cfIcon";
SpreadsheetML2009Main.aw = SpreadsheetML2009Main.b0 + "/cfRule";
SpreadsheetML2009Main.ax = SpreadsheetML2009Main.b0 + "/cfvo";
SpreadsheetML2009Main.ay = SpreadsheetML2009Main.b0 + "/color";
SpreadsheetML2009Main.a6 = SpreadsheetML2009Main.b0 + "/colorScale";
SpreadsheetML2009Main.bc = SpreadsheetML2009Main.b0 + "/dataBar";
SpreadsheetML2009Main.bd = SpreadsheetML2009Main.b0 + "/dataValidation";
SpreadsheetML2009Main.be = SpreadsheetML2009Main.b0 + "/dataValidations";
SpreadsheetML2009Main.bi = SpreadsheetML2009Main.b0 + "/dxf";
SpreadsheetML2009Main.bm = SpreadsheetML2009Main.b0 + "/fillColor";
SpreadsheetML2009Main.bn = SpreadsheetML2009Main.b0 + "/formula1";
SpreadsheetML2009Main.bo = SpreadsheetML2009Main.b0 + "/formula2";
SpreadsheetML2009Main.br = SpreadsheetML2009Main.b0 + "/iconFilter";
SpreadsheetML2009Main.bt = SpreadsheetML2009Main.b0 + "/iconSet";
SpreadsheetML2009Main.bv = SpreadsheetML2009Main.b0 + "/id";
SpreadsheetML2009Main.b3 = SpreadsheetML2009Main.b0 + "/negativeBorderColor";
SpreadsheetML2009Main.b4 = SpreadsheetML2009Main.b0 + "/negativeFillColor";
SpreadsheetML2009Main.b5 = SpreadsheetML2009Main.b0 + "/oleItem";
SpreadsheetML2009Main.b7 = SpreadsheetML2009Main.b0 + "/pivotCaches";
SpreadsheetML2009Main.cf = SpreadsheetML2009Main.b0 + "/slicer";
SpreadsheetML2009Main.cg = SpreadsheetML2009Main.b0 + "/slicerCache";
SpreadsheetML2009Main.ch = SpreadsheetML2009Main.b0 + "/slicerCaches";
SpreadsheetML2009Main.cj = SpreadsheetML2009Main.b0 + "/slicerList";
SpreadsheetML2009Main.cl = SpreadsheetML2009Main.b0 + "/sortCondition";
SpreadsheetML2009Main.cm = SpreadsheetML2009Main.b0 + "/sparkline";
SpreadsheetML2009Main.cn = SpreadsheetML2009Main.b0 + "/sparklineGroup";
SpreadsheetML2009Main.co = SpreadsheetML2009Main.b0 + "/sparklineGroups";
SpreadsheetML2009Main.cq = SpreadsheetML2009Main.b0 + "/sparklines";
SpreadsheetML2009Main.az = SpreadsheetML2009Main.b0 + "/colorAxis";
SpreadsheetML2009Main.a0 = SpreadsheetML2009Main.b0 + "/colorFirst";
SpreadsheetML2009Main.a1 = SpreadsheetML2009Main.b0 + "/colorHigh";
SpreadsheetML2009Main.a2 = SpreadsheetML2009Main.b0 + "/colorLast";
SpreadsheetML2009Main.a3 = SpreadsheetML2009Main.b0 + "/colorLow";
SpreadsheetML2009Main.a4 = SpreadsheetML2009Main.b0 + "/colorMarkers";
SpreadsheetML2009Main.a5 = SpreadsheetML2009Main.b0 + "/colorNegative";
SpreadsheetML2009Main.a7 = SpreadsheetML2009Main.b0 + "/colorSeries";
SpreadsheetML2009Main.an = new SpreadsheetML2009Main();
/**
 * @hidden
 */
export class SpreadsheetMLMain extends XmlNamespaceDefinitionBase {
    constructor() {
        super();
    }
    i(a) {
        switch (a) {
            case 0: return SpreadsheetMLMain.lg;
            case 1: return SpreadsheetMLMain.lf;
            default: return SpreadsheetMLMain.lg;
        }
    }
    get_j() {
        return null;
    }
    get j() {
        return this.get_j();
    }
    static tj(a, b, c, d) {
        if (a == null) {
            a = new StringBuilder(1, b.length);
        }
        a.m(b, d, c - d);
        d = c + 1;
        return {
            p0: a,
            p3: d
        };
    }
    static hg(a) {
        if (a == null) {
            return null;
        }
        let b = null;
        let c = 0;
        for (let d = 0; d < a.length; d++) {
            let e = a.charAt(d);
            if (e == '_') {
                if (a.length <= d + 6 || a.charAt(d + 1) != 'x' || a.charAt(d + 6) != '_') {
                    continue;
                }
                if (DocCoreUtils.d(a.charAt(d + 2)) == false || DocCoreUtils.d(a.charAt(d + 3)) == false || DocCoreUtils.d(a.charAt(d + 4)) == false || DocCoreUtils.d(a.charAt(d + 5)) == false) {
                    continue;
                }
                let f = SpreadsheetMLMain.tj(b, a, d, c);
                b = f.p0;
                c = f.p3;
                b.l("_x005F_");
            }
            if (e.charCodeAt(0) == 9 || e.charCodeAt(0) == 10 || e.charCodeAt(0) == 13 || (32 <= e.charCodeAt(0) && e.charCodeAt(0) <= 55295) || (57344 <= e.charCodeAt(0) && e.charCodeAt(0) <= 65533)) {
                continue;
            }
            if (65535 <= e.charCodeAt(0)) {
                continue;
            }
            let g = SpreadsheetMLMain.tj(b, a, d, c);
            b = g.p0;
            c = g.p3;
            b.q("_x{0:X4}_", e.charCodeAt(0));
        }
        if (c == 0) {
            return a;
        }
        let h = SpreadsheetMLMain.tj(b, a, a.length, c);
        b = h.p0;
        c = h.p3;
        return b.toString();
    }
    static rv(a, b = false) {
        if (a == null) {
            return null;
        }
        let c = null;
        let d = 0;
        for (let e = 0; e < a.length; e++) {
            let f = a.charAt(e);
            if (f != '_') {
                if (b) {
                    if (f == '\n') {
                        let g = SpreadsheetMLMain.tj(c, a, e, d);
                        c = g.p0;
                        d = g.p3;
                    }
                    else if (f == '\r') {
                        let h = SpreadsheetMLMain.tj(c, a, e, d);
                        c = h.p0;
                        d = h.p3;
                        if (e + 1 < a.length && a.charAt(e + 1) == '\n') {
                            e++;
                            d++;
                        }
                    }
                }
                continue;
            }
            if (a.length <= e + 6 || a.charAt(e + 1) != 'x' || a.charAt(e + 6) != '_') {
                continue;
            }
            let i = a.substr(e + 2, 4);
            let j;
            if (((() => { let k = tryParseInt32_2(i, 515, CultureInfo.invariantCulture, j); j = k.p3; return k.ret; })()) == false) {
                continue;
            }
            let k = SpreadsheetMLMain.tj(c, a, e, d);
            c = k.p0;
            d = k.p3;
            c.h(String.fromCharCode(j));
            e += 6;
            d += 6;
        }
        if (d == 0) {
            return a;
        }
        let l = SpreadsheetMLMain.tj(c, a, a.length, d);
        c = l.p0;
        d = l.p3;
        return c.toString();
    }
    static uq(a, b, c) {
        c = true;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "val":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static aab(a, b, c = true) {
        a.ad.p(b, null);
        let d;
        if (c != true) {
            d = ST_OnOff.g(c);
            a.ad.h("val", d);
        }
    }
    static ur(a, b, c) {
        c = 0;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "style":
                    c = XmlNamespaceDefinitionBase.b(ST_BorderStyle_$type, d.d, c);
                    break;
                default: break;
            }
        }
        return {
            p2: c
        };
    }
    static aac(a, b, c = 0) {
        a.ad.p(b, null);
        let d;
        if (c != 0) {
            d = XmlNamespaceDefinitionBase.f(ST_BorderStyle_$type, c);
            a.ad.h("style", d);
        }
    }
    static us(a, b, c, d, e, f, g) {
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "auto":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(h.d));
                    break;
                case "indexed":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "rgb":
                    let i = ST_UnsignedIntHex.d(h.d);
                    if (h.d != null && h.d.length == 6) {
                        i = new ST_UnsignedIntHex(1, u32BitwiseOr(ST_UnsignedIntHex.h(i), 4278190080));
                    }
                    e = Nullable$1.toNullable(ST_UnsignedIntHex.$, i);
                    break;
                case "theme":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "tint":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static aad(a, b, c = Nullable$1.toNullable(Boolean_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(ST_UnsignedIntHex.$, null), f = Nullable$1.toNullable(Number_$type, null), g = 0) {
        a.ad.p(b, null);
        let h;
        if (nullableNotEquals(c, null)) {
            h = ST_OnOff.g(c.value);
            a.ad.h("auto", h);
        }
        if (nullableNotEquals(d, null)) {
            h = d.value.toString();
            a.ad.h("indexed", h);
        }
        if (nullableNotEquals(e, null)) {
            h = e.value.toString();
            a.ad.h("rgb", h);
        }
        if (nullableNotEquals(f, null)) {
            h = f.value.toString();
            a.ad.h("theme", h);
        }
        if (g != 0) {
            h = g.toString();
            a.ad.h("tint", h);
        }
    }
    static ut(a, b, c) {
        let d = XmlNamespaceDefinitionBase.u(a, b, c);
        c = d.p2;
        return {
            p2: c
        };
    }
    static aae(a, b, c) {
        XmlNamespaceDefinitionBase.ai(a, b, null, c);
    }
    static uu(a, b, c, d) {
        c = 0;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "count":
                    c = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "manualBreakCount":
                    d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d
        };
    }
    static aaf(a, b, c = 0, d = 0) {
        a.ad.p(b, null);
        let e;
        if (c != 0) {
            e = c.toString();
            a.ad.h("count", e);
        }
        if (d != 0) {
            e = d.toString();
            a.ad.h("manualBreakCount", e);
        }
    }
    static uv(a, b, c, d) {
        d = false;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "array":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        c = a.ab.ad;
        return {
            p2: c,
            p3: d
        };
    }
    static aag(a, b, c, d = false) {
        a.ad.p(b, null);
        let e;
        if (d != false) {
            e = ST_OnOff.g(d);
            a.ad.h("array", e);
        }
        a.ad.u(c);
    }
    static tk(a, b, c, d, e, f, g, h, i, j) {
        b = Nullable$1.toNullable(ST_HorizontalAlignment_$type, null);
        c = Nullable$1.toNullable(ST_VerticalAlignment_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = false;
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = false;
        i = false;
        j = Nullable$1.toNullable(Number_$type, null);
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "horizontal":
                    b = Nullable$1.toNullable(ST_HorizontalAlignment_$type, XmlNamespaceDefinitionBase.b(ST_HorizontalAlignment_$type, k.d));
                    break;
                case "vertical":
                    c = Nullable$1.toNullable(ST_VerticalAlignment_$type, XmlNamespaceDefinitionBase.b(ST_VerticalAlignment_$type, k.d));
                    break;
                case "textRotation":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "wrapText":
                    e = ST_OnOff.e(k.d);
                    break;
                case "indent":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "relativeIndent":
                    g = Nullable$1.toNullable(Number_$type, parseInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                case "justifyLastLine":
                    h = ST_OnOff.e(k.d);
                    break;
                case "shrinkToFit":
                    i = ST_OnOff.e(k.d);
                    break;
                case "readingOrder":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(k.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static y5(a, b = Nullable$1.toNullable(ST_HorizontalAlignment_$type, null), c = Nullable$1.toNullable(ST_VerticalAlignment_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = false, f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = false, i = false, j = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.cj, null);
        let k;
        if (nullableNotEquals(b, null)) {
            k = XmlNamespaceDefinitionBase.f(ST_HorizontalAlignment_$type, b.value);
            a.ad.h("horizontal", k);
        }
        if (nullableNotEquals(c, null)) {
            k = XmlNamespaceDefinitionBase.f(ST_VerticalAlignment_$type, c.value);
            a.ad.h("vertical", k);
        }
        if (nullableNotEquals(d, null)) {
            k = d.value.toString();
            a.ad.h("textRotation", k);
        }
        if (e != false) {
            k = ST_OnOff.g(e);
            a.ad.h("wrapText", k);
        }
        if (nullableNotEquals(f, null)) {
            k = f.value.toString();
            a.ad.h("indent", k);
        }
        if (nullableNotEquals(g, null)) {
            k = g.value.toString();
            a.ad.h("relativeIndent", k);
        }
        if (h != false) {
            k = ST_OnOff.g(h);
            a.ad.h("justifyLastLine", k);
        }
        if (i != false) {
            k = ST_OnOff.g(i);
            a.ad.h("shrinkToFit", k);
        }
        if (nullableNotEquals(j, null)) {
            k = j.value.toString();
            a.ad.h("readingOrder", k);
        }
    }
    static tl(a, b, c) {
        b = false;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "moveWithCells":
                    b = ST_OnOff.e(d.d);
                    break;
                case "sizeWithCells":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static y6(a, b = false, c = false) {
        a.ad.p(SpreadsheetMLMain.co, null);
        let d;
        if (b != false) {
            d = ST_OnOff.g(b);
            a.ad.h("moveWithCells", d);
        }
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("sizeWithCells", d);
        }
    }
    static tm(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.cz, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static y7(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.cz, null, b);
    }
    static tn(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static y8(a) {
        a.ad.p(SpreadsheetMLMain.c1, null);
    }
    static to(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ref":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static y9(a, b) {
        a.ad.p(SpreadsheetMLMain.c5, null);
        let c;
        c = b;
        a.ad.h("ref", c);
    }
    static tp(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.dc, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static za(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.dc, b);
    }
    static tq(a, b, c, d, e, f) {
        let g = SpreadsheetMLMain.us(a, SpreadsheetMLMain.dg, b, c, d, e, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        f = g.p6;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static zb(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(ST_UnsignedIntHex.$, null), e = Nullable$1.toNullable(Number_$type, null), f = 0) {
        SpreadsheetMLMain.aad(a, SpreadsheetMLMain.dg, b, c, d, e, f);
    }
    static tr(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static zc(a) {
        a.ad.p(SpreadsheetMLMain.dj, null);
    }
    static ts(a, b, c, d) {
        b = false;
        c = false;
        d = true;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "diagonalUp":
                    b = ST_OnOff.e(e.d);
                    break;
                case "diagonalDown":
                    c = ST_OnOff.e(e.d);
                    break;
                case "outline":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static zd(a, b = false, c = false, d = true) {
        a.ad.p(SpreadsheetMLMain.dk, null);
        let e;
        if (b != false) {
            e = ST_OnOff.g(b);
            a.ad.h("diagonalUp", e);
        }
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("diagonalDown", e);
        }
        if (d != true) {
            e = ST_OnOff.g(d);
            a.ad.h("outline", e);
        }
    }
    static tt(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ze(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.dm, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static tu(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.dn, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static zf(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.dn, b);
    }
    static tv(a, b, c, d, e, f) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = false;
        f = false;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "id":
                    b = parseUInt32_1(g.d, CultureInfo.invariantCulture);
                    break;
                case "min":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(g.d, CultureInfo.invariantCulture));
                    break;
                case "max":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(g.d, CultureInfo.invariantCulture));
                    break;
                case "man":
                    e = ST_OnOff.e(g.d);
                    break;
                case "pt":
                    f = ST_OnOff.e(g.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static zg(a, b = 0, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = false, f = false) {
        a.ad.p(SpreadsheetMLMain.dq, null);
        let g;
        if (b != 0) {
            g = b.toString();
            a.ad.h("id", g);
        }
        if (c.hasValue && c.value != 0) {
            g = c.value.toString();
            a.ad.h("min", g);
        }
        if (d.hasValue && d.value != 0) {
            g = d.value.toString();
            a.ad.h("max", g);
        }
        if (e != false) {
            g = ST_OnOff.g(e);
            a.ad.h("man", g);
        }
        if (f != false) {
            g = ST_OnOff.g(f);
            a.ad.h("pt", g);
        }
    }
    static tw(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = 1;
        d = false;
        e = 0;
        f = false;
        g = 100;
        h = 0.001;
        i = true;
        j = true;
        k = true;
        l = true;
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "calcId":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "calcMode":
                    c = XmlNamespaceDefinitionBase.b(ST_CalcMode_$type, o.d, c);
                    break;
                case "fullCalcOnLoad":
                    d = ST_OnOff.e(o.d);
                    break;
                case "refMode":
                    e = XmlNamespaceDefinitionBase.b(ST_RefMode_$type, o.d, e);
                    break;
                case "iterate":
                    f = ST_OnOff.e(o.d);
                    break;
                case "iterateCount":
                    g = parseUInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "iterateDelta":
                    h = parseNumber(o.d, CultureInfo.invariantCulture);
                    break;
                case "fullPrecision":
                    i = ST_OnOff.e(o.d);
                    break;
                case "calcCompleted":
                    j = ST_OnOff.e(o.d);
                    break;
                case "calcOnSave":
                    k = ST_OnOff.e(o.d);
                    break;
                case "concurrentCalc":
                    l = ST_OnOff.e(o.d);
                    break;
                case "concurrentManualCount":
                    m = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "forceFullCalc":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static zh(a, b = Nullable$1.toNullable(Number_$type, null), c = 1, d = false, e = 0, f = false, g = 100, h = 0.001, i = true, j = true, k = true, l = true, m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(SpreadsheetMLMain.d0, null);
        let o;
        if (nullableNotEquals(b, null)) {
            o = b.value.toString();
            a.ad.h("calcId", o);
        }
        if (c != 1) {
            o = XmlNamespaceDefinitionBase.f(ST_CalcMode_$type, c);
            a.ad.h("calcMode", o);
        }
        if (d != false) {
            o = ST_OnOff.g(d);
            a.ad.h("fullCalcOnLoad", o);
        }
        if (e != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_RefMode_$type, e);
            a.ad.h("refMode", o);
        }
        if (f != false) {
            o = ST_OnOff.g(f);
            a.ad.h("iterate", o);
        }
        if (g != 100) {
            o = g.toString();
            a.ad.h("iterateCount", o);
        }
        if (h != 0.001) {
            o = h.toString();
            a.ad.h("iterateDelta", o);
        }
        if (i != true) {
            o = ST_OnOff.g(i);
            a.ad.h("fullPrecision", o);
        }
        if (j != true) {
            o = ST_OnOff.g(j);
            a.ad.h("calcCompleted", o);
        }
        if (k != true) {
            o = ST_OnOff.g(k);
            a.ad.h("calcOnSave", o);
        }
        if (l != true) {
            o = ST_OnOff.g(l);
            a.ad.h("concurrentCalc", o);
        }
        if (nullableNotEquals(m, null)) {
            o = m.value.toString();
            a.ad.h("concurrentManualCount", o);
        }
        if (nullableNotEquals(n, null)) {
            o = ST_OnOff.g(n.value);
            a.ad.h("forceFullCalc", o);
        }
    }
    static tx(a, b, c) {
        let d = SpreadsheetMLMain.uv(a, SpreadsheetMLMain.d1, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static zi(a, b, c = false) {
        SpreadsheetMLMain.aag(a, SpreadsheetMLMain.d1, b, c);
    }
    static ty(a, b, c, d, e, f, g) {
        b = null;
        c = 0;
        d = 2;
        e = 0;
        f = 0;
        g = false;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "r":
                    b = h.d;
                    break;
                case "s":
                    c = parseUInt32_1(h.d, CultureInfo.invariantCulture);
                    break;
                case "t":
                    d = SpreadsheetMLMain.aq(h.d);
                    break;
                case "cm":
                    e = parseUInt32_1(h.d, CultureInfo.invariantCulture);
                    break;
                case "vm":
                    f = parseUInt32_1(h.d, CultureInfo.invariantCulture);
                    break;
                case "ph":
                    g = ST_OnOff.e(h.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static aq(a) {
        switch (a) {
            case "b": return 0;
            case "d": return 1;
            case "e": return 3;
            case "n": return 2;
            case "s": return 4;
            case "str": return 5;
            case "inlineStr": return 6;
            default: return 2;
        }
    }
    static zj(a, b, c = 0, d = 2, e = 0, f = 0, g = false) {
        a.ad.r("c");
        a.ad.j("r", b);
        if (c != 0) {
            a.ad.j("s", c.toString());
        }
        if (d != 2) {
            a.ad.j("t", XLOpenXmlUtilities.a(d));
        }
        if (e != 0) {
            a.ad.j("cm", e.toString());
        }
        if (f != 0) {
            a.ad.j("vm", f.toString());
        }
        if (g != false) {
            a.ad.j("ph", ST_OnOff.g(g));
        }
    }
    static tz(a, b, c, d) {
        b = null;
        c = 2;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "r":
                    b = e.d;
                    break;
                case "t":
                    c = XmlNamespaceDefinitionBase.b(ST_CellType_$type, e.d, c);
                    break;
                case "vm":
                    d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static zk(a, b = null, c = 2, d = 0) {
        a.ad.p(SpreadsheetMLMain.d4, null);
        let e;
        e = b;
        a.ad.h("r", e);
        if (c != 2) {
            e = XLOpenXmlUtilities.a(c);
            a.ad.h("t", e);
        }
        if (d != 0) {
            e = d.toString();
            a.ad.h("vm", e);
        }
    }
    static t0(a, b, c, d, e, f, g) {
        c = null;
        b = 0;
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = false;
        g = false;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "name":
                    c = SpreadsheetMLMain.rv(h.d);
                    break;
                case "xfId":
                    b = parseUInt32_1(h.d, CultureInfo.invariantCulture);
                    break;
                case "builtinId":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "iLevel":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "hidden":
                    f = ST_OnOff.e(h.d);
                    break;
                case "customBuiltin":
                    g = ST_OnOff.e(h.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static zl(a, b, c = null, d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = false, g = false) {
        a.ad.p(SpreadsheetMLMain.d7, null);
        let h;
        h = SpreadsheetMLMain.hg(c);
        a.ad.h("name", h);
        h = b.toString();
        a.ad.h("xfId", h);
        if (nullableNotEquals(d, null)) {
            h = d.value.toString();
            a.ad.h("builtinId", h);
        }
        if (nullableNotEquals(e, null)) {
            h = e.value.toString();
            a.ad.h("iLevel", h);
        }
        if (f != false) {
            h = ST_OnOff.g(f);
            a.ad.h("hidden", h);
        }
        if (g != false) {
            h = ST_OnOff.g(g);
            a.ad.h("customBuiltin", h);
        }
    }
    static t1(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static zm(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.d8, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static t2(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static zn(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.d9, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static t3(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static zo(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.ea, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static t4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
        c = Nullable$1.toNullable(ST_CfType_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        g = true;
        h = false;
        i = false;
        j = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null);
        k = null;
        l = Nullable$1.toNullable(ST_TimePeriod_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Number_$type, null);
        o = false;
        p = null;
        q = Nullable$1.toNullable(Boolean_$type, null);
        for (let r of fromEnum(a.ab.u)) {
            let t1 = r.a.e(a.d);
            L0: while (true) {
                switch (t1) {
                    case "type":
                        c = Nullable$1.toNullable(ST_CfType_$type, XmlNamespaceDefinitionBase.b(ST_CfType_$type, r.d));
                        break;
                    case "dxfId":
                        d = Nullable$1.toNullable(Number_$type, parseUInt32_1(r.d, CultureInfo.invariantCulture));
                        break;
                    case "priority":
                        e = Nullable$1.toNullable(Number_$type, parseInt32_1(r.d, CultureInfo.invariantCulture));
                        break;
                    case "stopIfTrue":
                        f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(r.d));
                        break;
                    case "aboveAverage":
                        g = ST_OnOff.e(r.d);
                        break;
                    case "activePresent":
                        if (b != SpreadsheetML2009Main.aw) {
                            t1 = void 0;
                            continue L0;
                        }
                        q = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(r.d));
                        break;
                    case "percent":
                        h = ST_OnOff.e(r.d);
                        break;
                    case "bottom":
                        i = ST_OnOff.e(r.d);
                        break;
                    case "operator":
                        j = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, XmlNamespaceDefinitionBase.b(ST_ConditionalFormattingOperator_$type, r.d));
                        break;
                    case "text":
                        k = r.d;
                        break;
                    case "timePeriod":
                        l = Nullable$1.toNullable(ST_TimePeriod_$type, XmlNamespaceDefinitionBase.b(ST_TimePeriod_$type, r.d));
                        break;
                    case "rank":
                        m = Nullable$1.toNullable(Number_$type, parseUInt32_1(r.d, CultureInfo.invariantCulture));
                        break;
                    case "stdDev":
                        n = Nullable$1.toNullable(Number_$type, parseInt32_1(r.d, CultureInfo.invariantCulture));
                        break;
                    case "equalAverage":
                        o = ST_OnOff.e(r.d);
                        break;
                    case "id":
                        if (b != SpreadsheetML2009Main.aw) {
                            t1 = void 0;
                            continue L0;
                        }
                        p = r.d;
                        break;
                    default: break;
                }
                break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q
        };
    }
    static zp(a, b, c = Nullable$1.toNullable(ST_CfType_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = 0, f = false, g = Nullable$1.toNullable(Boolean_$type, null), h = Nullable$1.toNullable(Boolean_$type, null), i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(ST_ConditionalFormattingOperator_$type, null), k = null, l = Nullable$1.toNullable(ST_TimePeriod_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Number_$type, null), o = Nullable$1.toNullable(Boolean_$type, null), p = null, q = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(b, null);
        let r;
        if (nullableNotEquals(c, null)) {
            r = XmlNamespaceDefinitionBase.f(ST_CfType_$type, c.value);
            a.ad.h("type", r);
        }
        if (nullableNotEquals(d, null)) {
            r = d.value.toString();
            a.ad.h("dxfId", r);
        }
        if (e != 0) {
            r = e.toString();
            a.ad.h("priority", r);
        }
        if (f != false) {
            r = ST_OnOff.g(f);
            a.ad.h("stopIfTrue", r);
        }
        if (g.hasValue) {
            r = ST_OnOff.g(g.value);
            a.ad.h("aboveAverage", r);
        }
        if (h.hasValue) {
            r = ST_OnOff.g(h.value);
            a.ad.h("percent", r);
        }
        if (i.hasValue) {
            r = ST_OnOff.g(i.value);
            a.ad.h("bottom", r);
        }
        if (nullableNotEquals(j, null)) {
            r = XmlNamespaceDefinitionBase.f(ST_ConditionalFormattingOperator_$type, j.value);
            a.ad.h("operator", r);
        }
        r = k;
        a.ad.h("text", r);
        if (nullableNotEquals(l, null)) {
            r = XmlNamespaceDefinitionBase.f(ST_TimePeriod_$type, l.value);
            a.ad.h("timePeriod", r);
        }
        if (nullableNotEquals(m, null)) {
            r = m.value.toString();
            a.ad.h("rank", r);
        }
        if (nullableNotEquals(n, null)) {
            r = n.value.toString();
            a.ad.h("stdDev", r);
        }
        if (o.hasValue) {
            r = ST_OnOff.g(o.hasValue);
            a.ad.h("equalAverage", r);
        }
        if (stringIsNullOrEmpty(p) == false) {
            r = p;
            a.ad.h("id", r);
        }
        if (q.hasValue && q.value) {
            if (b != SpreadsheetML2009Main.aw) {
            }
            r = ST_OnOff.g(q.value);
            a.ad.h("activePresent", r);
        }
    }
    static t5(a, b, c, d) {
        let e = SpreadsheetMLMain.t6(a, SpreadsheetMLMain.eg, b, c, d);
        b = e.p2;
        c = e.p3;
        d = e.p4;
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static t6(a, b, c, d, e) {
        c = 0;
        d = null;
        e = true;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "type":
                    c = XmlNamespaceDefinitionBase.b(ST_CfvoType_$type, f.d, c);
                    break;
                case "val":
                    d = f.d;
                    break;
                case "gte":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p2: c,
            p3: d,
            p4: e
        };
    }
    static zq(a, b, c = null, d = true) {
        a.ad.p(SpreadsheetMLMain.eg, null);
        let e;
        e = XmlNamespaceDefinitionBase.f(ST_CfvoType_$type, b);
        a.ad.h("type", e);
        e = c;
        a.ad.h("val", e);
        if (d != true) {
            e = ST_OnOff.g(d);
            a.ad.h("gte", e);
        }
    }
    static t7(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static zr(a) {
        a.ad.p(SpreadsheetMLMain.ei, null);
        let b = a.d._z;
        a.ad.l(OfficeDocumentRelationships.an);
        a.ad.l(SpreadsheetMLMain.ao);
    }
    static ub(a, b, c, d, e) {
        c = false;
        d = 100;
        b = 0;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "tabSelected":
                    c = ST_OnOff.e(f.d);
                    break;
                case "zoomScale":
                    d = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "workbookViewId":
                    b = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "zoomToFit":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static zv(a, b, c = false, d = 100, e = true) {
        a.ad.p(SpreadsheetMLMain.oy, null);
        let f;
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("tabSelected", f);
        }
        if (d != 100) {
            f = d.toString();
            a.ad.h("zoomScale", f);
        }
        f = b.toString();
        a.ad.h("workbookViewId", f);
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("zoomToFit", f);
        }
    }
    static t8(a, b, c) {
        b = true;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "published":
                    b = ST_OnOff.e(d.d);
                    break;
                case "codeName":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static zs(a, b = true, c = null) {
        a.ad.p(SpreadsheetMLMain.ov, null);
        let d;
        if (b != true) {
            d = ST_OnOff.g(b);
            a.ad.h("published", d);
        }
        if (c != null) {
            d = c;
            a.ad.h("codeName", d);
        }
    }
    static t9(a, b, c, d) {
        b = Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
        c = false;
        d = false;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "password":
                    b = Nullable$1.toNullable(ST_UnsignedShortHex.$, ST_UnsignedShortHex.b(e.d));
                    break;
                case "objects":
                    c = ST_OnOff.e(e.d);
                    break;
                case "content":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static zt(a, b = Nullable$1.toNullable(ST_UnsignedShortHex.$, null), c = false, d = false) {
        a.ad.p(SpreadsheetMLMain.ow, null);
        let e;
        if (nullableNotEquals(b, null)) {
            e = b.value.toString();
            a.ad.h("password", e);
        }
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("objects", e);
        }
        if (d != false) {
            e = ST_OnOff.g(d);
            a.ad.h("content", e);
        }
    }
    static ua(a, b, c, d, e, f, g) {
        b = null;
        c = null;
        d = null;
        e = Nullable$1.toNullable(Number_$type, null);
        f = false;
        g = false;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "algorithmName":
                    b = h.d;
                    break;
                case "hashValue":
                    c = h.d;
                    break;
                case "saltValue":
                    d = h.d;
                    break;
                case "spinCount":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d, CultureInfo.invariantCulture));
                    break;
                case "objects":
                    f = ST_OnOff.e(h.d);
                    break;
                case "content":
                    g = ST_OnOff.e(h.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static zu(a, b = null, c = null, d = null, e = Nullable$1.toNullable(Number_$type, null), f = false, g = false) {
        a.ad.p(SpreadsheetMLMain.ow, null);
        let h;
        h = b;
        a.ad.h("algorithmName", h);
        h = c;
        a.ad.h("hashValue", h);
        h = d;
        a.ad.h("saltValue", h);
        if (nullableNotEquals(e, null)) {
            h = e.value.toString();
            a.ad.h("spinCount", h);
        }
        if (f != false) {
            h = ST_OnOff.g(f);
            a.ad.h("objects", h);
        }
        if (g != false) {
            h = ST_OnOff.g(g);
            a.ad.h("content", h);
        }
    }
    static uc(a, b, c) {
        let d = SpreadsheetMLMain.uu(a, SpreadsheetMLMain.eq, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static zw(a, b, c) {
        SpreadsheetMLMain.aaf(a, SpreadsheetMLMain.eq, b, c);
    }
    static ud(a, b, c, d, e, f, g, h, i, j, k) {
        b = 0;
        c = 0;
        d = Nullable$1.toNullable(Number_$type, null);
        e = 0;
        f = false;
        g = false;
        h = false;
        i = false;
        j = 0;
        k = false;
        for (let l of fromEnum(a.ab.u)) {
            switch (l.a.e(a.d)) {
                case "min":
                    b = parseUInt32_1(l.d, CultureInfo.invariantCulture);
                    break;
                case "max":
                    c = parseUInt32_1(l.d, CultureInfo.invariantCulture);
                    break;
                case "width":
                    d = Nullable$1.toNullable(Number_$type, parseNumber(l.d, CultureInfo.invariantCulture));
                    break;
                case "style":
                    e = parseUInt32_1(l.d, CultureInfo.invariantCulture);
                    break;
                case "hidden":
                    f = ST_OnOff.e(l.d);
                    break;
                case "bestFit":
                    g = ST_OnOff.e(l.d);
                    break;
                case "customWidth":
                    h = ST_OnOff.e(l.d);
                    break;
                case "phonetic":
                    i = ST_OnOff.e(l.d);
                    break;
                case "outlineLevel":
                    j = parseUInt8_1(l.d, CultureInfo.invariantCulture);
                    break;
                case "collapsed":
                    k = ST_OnOff.e(l.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k
        };
    }
    static zx(a, b, c, d = Nullable$1.toNullable(Number_$type, null), e = 0, f = false, g = false, h = false, i = false, j = 0, k = false) {
        a.ad.p(SpreadsheetMLMain.ep, null);
        let l;
        l = b.toString();
        a.ad.h("min", l);
        l = c.toString();
        a.ad.h("max", l);
        if (nullableNotEquals(d, null)) {
            l = d.value.toString();
            a.ad.h("width", l);
        }
        if (e != 0) {
            l = e.toString();
            a.ad.h("style", l);
        }
        if (f != false) {
            l = ST_OnOff.g(f);
            a.ad.h("hidden", l);
        }
        if (g != false) {
            l = ST_OnOff.g(g);
            a.ad.h("bestFit", l);
        }
        if (h != false) {
            l = ST_OnOff.g(h);
            a.ad.h("customWidth", l);
        }
        if (i != false) {
            l = ST_OnOff.g(i);
            a.ad.h("phonetic", l);
        }
        if (j != 0) {
            l = j.toString();
            a.ad.h("outlineLevel", l);
        }
        if (k != false) {
            l = ST_OnOff.g(k);
            a.ad.h("collapsed", l);
        }
    }
    static ue(a, b, c, d, e, f) {
        let g = SpreadsheetMLMain.us(a, SpreadsheetMLMain.et, b, c, d, e, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        f = g.p6;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static zy(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(ST_UnsignedIntHex.$, null), e = Nullable$1.toNullable(Number_$type, null), f = 0) {
        SpreadsheetMLMain.aad(a, SpreadsheetMLMain.et, b, c, d, e, f);
    }
    static uf(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = true;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "dxfId":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "cellColor":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static zz(a, b = Nullable$1.toNullable(Number_$type, null), c = true) {
        a.ad.p(SpreadsheetMLMain.eu, null);
        let d;
        if (nullableNotEquals(b, null)) {
            d = b.value.toString();
            a.ad.h("dxfId", d);
        }
        d = ST_OnOff.g(c);
        a.ad.h("cellColor", d);
    }
    static z0(a) {
        a.ad.p(SpreadsheetMLMain.ex, null);
    }
    static ug(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static z1(a) {
        a.ad.p(SpreadsheetMLMain.ew, null);
    }
    static uh(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static z2(a) {
        a.ad.p(SpreadsheetMLMain.ey, null);
    }
    static ui(a, b, c, d, e) {
        b = null;
        c = 0;
        d = Nullable$1.toNullable(ST_Guid.$, null);
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "ref":
                    b = f.d;
                    break;
                case "authorId":
                    c = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "guid":
                    d = Nullable$1.toNullable(ST_Guid.$, ST_Guid.c(f.d));
                    break;
                case "shapeId":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static z3(a, b, c, d = Nullable$1.toNullable(ST_Guid.$, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.e0, null);
        let f;
        f = b;
        a.ad.h("ref", f);
        f = c.toString();
        a.ad.h("authorId", f);
        if (nullableNotEquals(d, null)) {
            f = d.value.toString();
            a.ad.h("guid", f);
        }
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("shapeId", f);
        }
    }
    static uj(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static z4(a) {
        a.ad.p(SpreadsheetMLMain.e2, null);
    }
    static uk(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static z5(a) {
        a.ad.p(SpreadsheetMLMain.e3, null);
    }
    static ul(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.e6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static z6(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.e6, b);
    }
    static um(a, b, c) {
        b = null;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "sqref":
                    b = XmlNamespaceDefinitionBase.e(String_$type, d.d, (e) => e);
                    break;
                case "pivot":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static z7(a, b, c = false) {
        a.ad.p(SpreadsheetMLMain.e7, null);
        let d;
        if (b != null) {
            d = stringJoin1(String_$type, " ", b);
            a.ad.h("sqref", d);
        }
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("pivot", d);
        }
    }
    static un(a, b, c, d) {
        b = 0;
        c = null;
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "shapeId":
                    b = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case OfficeDocumentRelationships.ar:
                    c = e.d;
                    break;
                case "name":
                    d = e.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static z8(a, b, c, d = null) {
        a.ad.p(SpreadsheetMLMain.fc, null);
        let e;
        e = b.toString();
        a.ad.h("shapeId", e);
        e = c;
        a.ad.h(OfficeDocumentRelationships.ar, e);
        e = d;
        a.ad.h("name", e);
    }
    static uo(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        b = true;
        c = true;
        d = true;
        e = false;
        f = false;
        g = false;
        h = true;
        i = true;
        j = true;
        k = null;
        l = null;
        m = null;
        n = null;
        o = "pict";
        p = null;
        for (let q of fromEnum(a.ab.u)) {
            switch (q.a.e(a.d)) {
                case "locked":
                    b = ST_OnOff.e(q.d);
                    break;
                case "defaultSize":
                    c = ST_OnOff.e(q.d);
                    break;
                case "print":
                    d = ST_OnOff.e(q.d);
                    break;
                case "disabled":
                    e = ST_OnOff.e(q.d);
                    break;
                case "recalcAlways":
                    f = ST_OnOff.e(q.d);
                    break;
                case "uiObject":
                    g = ST_OnOff.e(q.d);
                    break;
                case "autoFill":
                    h = ST_OnOff.e(q.d);
                    break;
                case "autoLine":
                    i = ST_OnOff.e(q.d);
                    break;
                case "autoPict":
                    j = ST_OnOff.e(q.d);
                    break;
                case "macro":
                    k = q.d;
                    break;
                case "altText":
                    l = q.d;
                    break;
                case "linkedCell":
                    m = q.d;
                    break;
                case "listFillRange":
                    n = q.d;
                    break;
                case "cf":
                    o = q.d;
                    break;
                case OfficeDocumentRelationships.ar:
                    p = q.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p
        };
    }
    static z9(a, b = true, c = true, d = true, e = false, f = false, g = false, h = true, i = true, j = true, k = null, l = null, m = null, n = null, o = "pict", p = null) {
        a.ad.p(SpreadsheetMLMain.fd, null);
        let q;
        if (b != true) {
            q = ST_OnOff.g(b);
            a.ad.h("locked", q);
        }
        if (c != true) {
            q = ST_OnOff.g(c);
            a.ad.h("defaultSize", q);
        }
        if (d != true) {
            q = ST_OnOff.g(d);
            a.ad.h("print", q);
        }
        if (e != false) {
            q = ST_OnOff.g(e);
            a.ad.h("disabled", q);
        }
        if (f != false) {
            q = ST_OnOff.g(f);
            a.ad.h("recalcAlways", q);
        }
        if (g != false) {
            q = ST_OnOff.g(g);
            a.ad.h("uiObject", q);
        }
        if (h != true) {
            q = ST_OnOff.g(h);
            a.ad.h("autoFill", q);
        }
        if (i != true) {
            q = ST_OnOff.g(i);
            a.ad.h("autoLine", q);
        }
        if (j != true) {
            q = ST_OnOff.g(j);
            a.ad.h("autoPict", q);
        }
        q = k;
        DrawingNamespaceDefinitionBase.da(a, q);
        q = l;
        a.ad.h("altText", q);
        q = m;
        a.ad.h("linkedCell", q);
        q = n;
        a.ad.h("listFillRange", q);
        q = o;
        a.ad.h("cf", q);
        q = p;
        a.ad.h(OfficeDocumentRelationships.ar, q);
    }
    static up(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aaa(a) {
        a.ad.p(SpreadsheetMLMain.fe, null);
    }
    static uw(a, b, c, d, e) {
        b = new ST_Guid();
        c = 100;
        d = 0;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "guid":
                    b = ST_Guid.c(f.d);
                    break;
                case "scale":
                    c = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "state":
                    d = XmlNamespaceDefinitionBase.b(ST_SheetState_$type, f.d, d);
                    break;
                case "zoomToFit":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aah(a, b, c = 100, d = 0, e = false) {
        a.ad.p(SpreadsheetMLMain.fp, null);
        let f;
        f = b.toString();
        a.ad.h("guid", f);
        if (c != 100) {
            f = c.toString();
            a.ad.h("scale", f);
        }
        if (d != 0) {
            f = XmlNamespaceDefinitionBase.f(ST_SheetState_$type, d);
            a.ad.h("state", f);
        }
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("zoomToFit", f);
        }
    }
    static ux(a, b, c) {
        c = 2;
        b = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "operator":
                    c = XmlNamespaceDefinitionBase.b(ST_FilterOperator_$type, d.d, c);
                    break;
                case "val":
                    b = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static aai(a, b, c = 2) {
        a.ad.p(SpreadsheetMLMain.fj, null);
        let d;
        if (c != 2) {
            d = XmlNamespaceDefinitionBase.f(ST_FilterOperator_$type, c);
            a.ad.h("operator", d);
        }
        d = b;
        a.ad.h("val", d);
    }
    static uy(a, b) {
        b = false;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "and":
                    b = ST_OnOff.e(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aaj(a, b = false) {
        a.ad.p(SpreadsheetMLMain.fk, null);
        let c;
        if (b != false) {
            c = ST_OnOff.g(b);
            a.ad.h("and", c);
        }
    }
    static uz(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
        b = new ST_Guid();
        c = 100;
        d = 64;
        e = false;
        f = false;
        g = true;
        h = true;
        i = true;
        j = true;
        k = false;
        l = false;
        m = false;
        n = false;
        o = false;
        p = false;
        q = 0;
        r = false;
        s = 0;
        t = true;
        u = null;
        for (let v of fromEnum(a.ab.u)) {
            switch (v.a.e(a.d)) {
                case "guid":
                    b = ST_Guid.c(v.d);
                    break;
                case "scale":
                    c = parseUInt32_1(v.d, CultureInfo.invariantCulture);
                    break;
                case "colorId":
                    d = parseUInt32_1(v.d, CultureInfo.invariantCulture);
                    break;
                case "showPageBreaks":
                    e = ST_OnOff.e(v.d);
                    break;
                case "showFormulas":
                    f = ST_OnOff.e(v.d);
                    break;
                case "showGridLines":
                    g = ST_OnOff.e(v.d);
                    break;
                case "showRowCol":
                    h = ST_OnOff.e(v.d);
                    break;
                case "outlineSymbols":
                    i = ST_OnOff.e(v.d);
                    break;
                case "zeroValues":
                    j = ST_OnOff.e(v.d);
                    break;
                case "fitToPage":
                    k = ST_OnOff.e(v.d);
                    break;
                case "printArea":
                    l = ST_OnOff.e(v.d);
                    break;
                case "filter":
                    m = ST_OnOff.e(v.d);
                    break;
                case "showAutoFilter":
                    n = ST_OnOff.e(v.d);
                    break;
                case "hiddenRows":
                    o = ST_OnOff.e(v.d);
                    break;
                case "hiddenColumns":
                    p = ST_OnOff.e(v.d);
                    break;
                case "state":
                    q = XmlNamespaceDefinitionBase.b(ST_SheetState_$type, v.d, q);
                    break;
                case "filterUnique":
                    r = ST_OnOff.e(v.d);
                    break;
                case "view":
                    s = XmlNamespaceDefinitionBase.b(ST_SheetViewType_$type, v.d, s);
                    break;
                case "showRuler":
                    t = ST_OnOff.e(v.d);
                    break;
                case "topLeftCell":
                    u = v.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u
        };
    }
    static aak(a, b, c = 100, d = 64, e = false, f = false, g = true, h = true, i = true, j = true, k = false, l = false, m = false, n = false, o = false, p = false, q = 0, r = false, s = 0, t = true, u = null) {
        a.ad.p(SpreadsheetMLMain.fp, null);
        let v;
        v = b.toString();
        a.ad.h("guid", v);
        if (c != 100) {
            v = c.toString();
            a.ad.h("scale", v);
        }
        if (d != 64) {
            v = d.toString();
            a.ad.h("colorId", v);
        }
        if (e != false) {
            v = ST_OnOff.g(e);
            a.ad.h("showPageBreaks", v);
        }
        if (f != false) {
            v = ST_OnOff.g(f);
            a.ad.h("showFormulas", v);
        }
        if (g != true) {
            v = ST_OnOff.g(g);
            a.ad.h("showGridLines", v);
        }
        if (h != true) {
            v = ST_OnOff.g(h);
            a.ad.h("showRowCol", v);
        }
        if (i != true) {
            v = ST_OnOff.g(i);
            a.ad.h("outlineSymbols", v);
        }
        if (j != true) {
            v = ST_OnOff.g(j);
            a.ad.h("zeroValues", v);
        }
        if (k != false) {
            v = ST_OnOff.g(k);
            a.ad.h("fitToPage", v);
        }
        if (l != false) {
            v = ST_OnOff.g(l);
            a.ad.h("printArea", v);
        }
        if (m != false) {
            v = ST_OnOff.g(m);
            a.ad.h("filter", v);
        }
        if (n != false) {
            v = ST_OnOff.g(n);
            a.ad.h("showAutoFilter", v);
        }
        if (o != false) {
            v = ST_OnOff.g(o);
            a.ad.h("hiddenRows", v);
        }
        if (p != false) {
            v = ST_OnOff.g(p);
            a.ad.h("hiddenColumns", v);
        }
        if (q != 0) {
            v = XmlNamespaceDefinitionBase.f(ST_SheetState_$type, q);
            a.ad.h("state", v);
        }
        if (r != false) {
            v = ST_OnOff.g(r);
            a.ad.h("filterUnique", v);
        }
        if (s != 0) {
            v = XmlNamespaceDefinitionBase.f(ST_SheetViewType_$type, s);
            a.ad.h("view", v);
        }
        if (t != true) {
            v = ST_OnOff.g(t);
            a.ad.h("showRuler", v);
        }
        v = u;
        a.ad.h("topLeftCell", v);
    }
    static u0(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aal(a) {
        a.ad.p(SpreadsheetMLMain.fq, null);
    }
    static u1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) {
        b = null;
        c = new ST_Guid();
        g = false;
        h = Nullable$1.toNullable(Number_$type, null);
        i = false;
        j = false;
        k = false;
        l = true;
        m = true;
        n = false;
        o = false;
        p = true;
        q = true;
        r = true;
        s = 0;
        t = 0;
        e = 0;
        f = 0;
        u = 600;
        d = 0;
        v = true;
        w = true;
        x = 1;
        y = 0;
        for (let z of fromEnum(a.ab.u)) {
            switch (z.a.e(a.d)) {
                case "name":
                    b = z.d;
                    break;
                case "guid":
                    c = ST_Guid.c(z.d);
                    break;
                case "autoUpdate":
                    g = ST_OnOff.e(z.d);
                    break;
                case "mergeInterval":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(z.d, CultureInfo.invariantCulture));
                    break;
                case "changesSavedWin":
                    i = ST_OnOff.e(z.d);
                    break;
                case "onlySync":
                    j = ST_OnOff.e(z.d);
                    break;
                case "personalView":
                    k = ST_OnOff.e(z.d);
                    break;
                case "includePrintSettings":
                    l = ST_OnOff.e(z.d);
                    break;
                case "includeHiddenRowCol":
                    m = ST_OnOff.e(z.d);
                    break;
                case "maximized":
                    n = ST_OnOff.e(z.d);
                    break;
                case "minimized":
                    o = ST_OnOff.e(z.d);
                    break;
                case "showHorizontalScroll":
                    p = ST_OnOff.e(z.d);
                    break;
                case "showVerticalScroll":
                    q = ST_OnOff.e(z.d);
                    break;
                case "showSheetTabs":
                    r = ST_OnOff.e(z.d);
                    break;
                case "xWindow":
                    s = parseInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "yWindow":
                    t = parseInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "windowWidth":
                    e = parseUInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "windowHeight":
                    f = parseUInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "tabRatio":
                    u = parseUInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "activeSheetId":
                    d = parseUInt32_1(z.d, CultureInfo.invariantCulture);
                    break;
                case "showFormulaBar":
                    v = ST_OnOff.e(z.d);
                    break;
                case "showStatusbar":
                    w = ST_OnOff.e(z.d);
                    break;
                case "showComments":
                    x = XmlNamespaceDefinitionBase.b(ST_Comments_$type, z.d, x);
                    break;
                case "showObjects":
                    y = XmlNamespaceDefinitionBase.b(ST_Objects_$type, z.d, y);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w,
            p23: x,
            p24: y
        };
    }
    static aam(a, b, c, d, e, f, g = false, h = Nullable$1.toNullable(Number_$type, null), i = false, j = false, k = false, l = true, m = true, n = false, o = false, p = true, q = true, r = true, s = 0, t = 0, u = 600, v = true, w = true, x = 1, y = 0) {
        a.ad.p(SpreadsheetMLMain.fs, null);
        let z;
        z = b;
        a.ad.h("name", z);
        z = c.toString();
        a.ad.h("guid", z);
        if (g != false) {
            z = ST_OnOff.g(g);
            a.ad.h("autoUpdate", z);
        }
        if (nullableNotEquals(h, null)) {
            z = h.value.toString();
            a.ad.h("mergeInterval", z);
        }
        if (i != false) {
            z = ST_OnOff.g(i);
            a.ad.h("changesSavedWin", z);
        }
        if (j != false) {
            z = ST_OnOff.g(j);
            a.ad.h("onlySync", z);
        }
        if (k != false) {
            z = ST_OnOff.g(k);
            a.ad.h("personalView", z);
        }
        if (l != true) {
            z = ST_OnOff.g(l);
            a.ad.h("includePrintSettings", z);
        }
        if (m != true) {
            z = ST_OnOff.g(m);
            a.ad.h("includeHiddenRowCol", z);
        }
        if (n != false) {
            z = ST_OnOff.g(n);
            a.ad.h("maximized", z);
        }
        if (o != false) {
            z = ST_OnOff.g(o);
            a.ad.h("minimized", z);
        }
        if (p != true) {
            z = ST_OnOff.g(p);
            a.ad.h("showHorizontalScroll", z);
        }
        if (q != true) {
            z = ST_OnOff.g(q);
            a.ad.h("showVerticalScroll", z);
        }
        if (r != true) {
            z = ST_OnOff.g(r);
            a.ad.h("showSheetTabs", z);
        }
        if (s != 0) {
            z = s.toString();
            a.ad.h("xWindow", z);
        }
        if (t != 0) {
            z = t.toString();
            a.ad.h("yWindow", z);
        }
        z = e.toString();
        a.ad.h("windowWidth", z);
        z = f.toString();
        a.ad.h("windowHeight", z);
        if (u != 600) {
            z = u.toString();
            a.ad.h("tabRatio", z);
        }
        z = d.toString();
        a.ad.h("activeSheetId", z);
        if (v != true) {
            z = ST_OnOff.g(v);
            a.ad.h("showFormulaBar", z);
        }
        if (w != true) {
            z = ST_OnOff.g(w);
            a.ad.h("showStatusbar", z);
        }
        if (x != 1) {
            z = XmlNamespaceDefinitionBase.f(ST_Comments_$type, x);
            a.ad.h("showComments", z);
        }
        if (y != 0) {
            z = XmlNamespaceDefinitionBase.f(ST_Objects_$type, y);
            a.ad.h("showObjects", z);
        }
    }
    static u2(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aan(a) {
        a.ad.p(SpreadsheetMLMain.ft, null);
    }
    static u3(a, b, c, d) {
        c = Nullable$1.toNullable(Number_$type, null);
        b = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "minLength":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "maxLength":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "showValue":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(e.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static aao(a, b, c, d) {
        a.ad.p(SpreadsheetMLMain.fu, null);
        let e;
        if (b.hasValue) {
            e = b.value.toString();
            a.ad.h("minLength", e);
        }
        if (c.hasValue) {
            e = c.value.toString();
            a.ad.h("maxLength", e);
        }
        if (d.hasValue) {
            e = ST_OnOff.g(d.value);
            a.ad.h("showValue", e);
        }
    }
    static u4(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        let o;
        let p = SpreadsheetMLMain.u5(a, o, c, d, e, f, g, h, i, j, k, l, m, n);
        o = p.p1;
        c = p.p2;
        d = p.p3;
        e = p.p4;
        f = p.p5;
        g = p.p6;
        h = p.p7;
        i = p.p8;
        j = p.p9;
        k = p.p10;
        l = p.p11;
        m = p.p12;
        n = p.p13;
        b = XmlNamespaceDefinitionBase.e(String_$type, o, (q) => q);
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static aap(a, b, c = 0, d = 0, e = 0, f = 0, g = false, h = false, i = false, j = false, k = null, l = null, m = null, n = null) {
        SpreadsheetMLMain.aaq(a, b == null ? null : stringJoin1(String_$type, " ", b), c, d, e, f, g, h, i, j, k, l, m, n);
    }
    static u5(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = null;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = false;
        h = false;
        i = false;
        j = false;
        k = null;
        l = null;
        m = null;
        n = null;
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "sqref":
                    b = o.d;
                    break;
                case "type":
                    c = XmlNamespaceDefinitionBase.b(ST_DataValidationType_$type, o.d, c);
                    break;
                case "errorStyle":
                    d = XmlNamespaceDefinitionBase.b(ST_DataValidationErrorStyle_$type, o.d, d);
                    break;
                case "imeMode":
                    e = XmlNamespaceDefinitionBase.b(ST_DataValidationImeMode_$type, o.d, e);
                    break;
                case "operator":
                    f = XmlNamespaceDefinitionBase.b(ST_DataValidationOperator_$type, o.d, f);
                    break;
                case "allowBlank":
                    g = ST_OnOff.e(o.d);
                    break;
                case "showDropDown":
                    h = ST_OnOff.e(o.d);
                    break;
                case "showInputMessage":
                    i = ST_OnOff.e(o.d);
                    break;
                case "showErrorMessage":
                    j = ST_OnOff.e(o.d);
                    break;
                case "errorTitle":
                    k = o.d;
                    break;
                case "error":
                    l = o.d;
                    break;
                case "promptTitle":
                    m = o.d;
                    break;
                case "prompt":
                    n = o.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static aaq(a, b, c = 0, d = 0, e = 0, f = 0, g = false, h = false, i = false, j = false, k = null, l = null, m = null, n = null) {
        a.ad.p(SpreadsheetMLMain.fx, null);
        let o;
        o = b;
        a.ad.h("sqref", o);
        if (c != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationType_$type, c);
            a.ad.h("type", o);
        }
        if (d != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationErrorStyle_$type, d);
            a.ad.h("errorStyle", o);
        }
        if (e != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationImeMode_$type, e);
            a.ad.h("imeMode", o);
        }
        if (f != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_DataValidationOperator_$type, f);
            a.ad.h("operator", o);
        }
        if (g != false) {
            o = ST_OnOff.g(g);
            a.ad.h("allowBlank", o);
        }
        if (h != false) {
            o = ST_OnOff.g(h);
            a.ad.h("showDropDown", o);
        }
        if (i != false) {
            o = ST_OnOff.g(i);
            a.ad.h("showInputMessage", o);
        }
        if (j != false) {
            o = ST_OnOff.g(j);
            a.ad.h("showErrorMessage", o);
        }
        o = k;
        a.ad.h("errorTitle", o);
        o = l;
        a.ad.h("error", o);
        o = m;
        a.ad.h("promptTitle", o);
        o = n;
        a.ad.h("prompt", o);
    }
    static u6(a, b, c, d, e) {
        b = false;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "disablePrompts":
                    b = ST_OnOff.e(f.d);
                    break;
                case "xWindow":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "yWindow":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                case "count":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aar(a, b = false, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.fy, null);
        let f;
        if (b != false) {
            f = ST_OnOff.g(b);
            a.ad.h("disablePrompts", f);
        }
        if (nullableNotEquals(c, null)) {
            f = c.value.toString();
            a.ad.h("xWindow", f);
        }
        if (nullableNotEquals(d, null)) {
            f = d.value.toString();
            a.ad.h("yWindow", f);
        }
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("count", f);
        }
    }
    static u7(a, b, c, d, e, f, g, h) {
        c = 0;
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        b = 0;
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "year":
                    c = parseUInt16_1(i.d, CultureInfo.invariantCulture);
                    break;
                case "month":
                    d = Nullable$1.toNullable(Number_$type, parseUInt16_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "day":
                    e = Nullable$1.toNullable(Number_$type, parseUInt16_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "hour":
                    f = Nullable$1.toNullable(Number_$type, parseUInt16_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "minute":
                    g = Nullable$1.toNullable(Number_$type, parseUInt16_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "second":
                    h = Nullable$1.toNullable(Number_$type, parseUInt16_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "dateTimeGrouping":
                    b = XmlNamespaceDefinitionBase.b(ST_DateTimeGrouping_$type, i.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static aas(a, b, c, d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.f1, null);
        let i;
        i = c.toString();
        a.ad.h("year", i);
        if (nullableNotEquals(d, null)) {
            i = d.value.toString();
            a.ad.h("month", i);
        }
        if (nullableNotEquals(e, null)) {
            i = e.value.toString();
            a.ad.h("day", i);
        }
        if (nullableNotEquals(f, null)) {
            i = f.value.toString();
            a.ad.h("hour", i);
        }
        if (nullableNotEquals(g, null)) {
            i = g.value.toString();
            a.ad.h("minute", i);
        }
        if (nullableNotEquals(h, null)) {
            i = h.value.toString();
            a.ad.h("second", i);
        }
        i = XmlNamespaceDefinitionBase.f(ST_DateTimeGrouping_$type, b);
        a.ad.h("dateTimeGrouping", i);
    }
    static u8(a, b, c, d, e) {
        b = null;
        c = false;
        d = false;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "ole":
                    c = ST_OnOff.e(f.d);
                    break;
                case "advise":
                    d = ST_OnOff.e(f.d);
                    break;
                case "preferPic":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aat(a, b = null, c = false, d = false, e = false) {
        a.ad.p(SpreadsheetMLMain.f4, null);
        let f;
        f = b;
        a.ad.h("name", f);
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("ole", f);
        }
        if (d != false) {
            f = ST_OnOff.g(d);
            a.ad.h("advise", f);
        }
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("preferPic", f);
        }
    }
    static u9(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aau(a) {
        a.ad.p(SpreadsheetMLMain.f5, null);
    }
    static va(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "ddeService":
                    b = d.d;
                    break;
                case "ddeTopic":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static aav(a, b = null, c = null) {
        a.ad.p(SpreadsheetMLMain.f6, null);
        let d;
        d = b;
        a.ad.h("ddeService", d);
        d = c;
        a.ad.h("ddeTopic", d);
    }
    static vc(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        i = Nullable$1.toNullable(Number_$type, null);
        j = false;
        k = false;
        l = false;
        m = false;
        n = Nullable$1.toNullable(Number_$type, null);
        o = null;
        p = false;
        q = false;
        for (let r of fromEnum(a.ab.u)) {
            switch (r.a.e(a.d)) {
                case "name":
                    c = r.d;
                    break;
                case "comment":
                    d = r.d;
                    break;
                case "customMenu":
                    e = r.d;
                    break;
                case "description":
                    f = r.d;
                    break;
                case "help":
                    g = r.d;
                    break;
                case "statusBar":
                    h = r.d;
                    break;
                case "localSheetId":
                    i = Nullable$1.toNullable(Number_$type, parseUInt32_1(r.d, CultureInfo.invariantCulture));
                    break;
                case "hidden":
                    j = ST_OnOff.e(r.d);
                    break;
                case "function":
                    k = ST_OnOff.e(r.d);
                    break;
                case "vbProcedure":
                    l = ST_OnOff.e(r.d);
                    break;
                case "xlm":
                    m = ST_OnOff.e(r.d);
                    break;
                case "functionGroupId":
                    n = Nullable$1.toNullable(Number_$type, parseUInt32_1(r.d, CultureInfo.invariantCulture));
                    break;
                case "shortcutKey":
                    o = r.d;
                    break;
                case "publishToServer":
                    p = ST_OnOff.e(r.d);
                    break;
                case "workbookParameter":
                    q = ST_OnOff.e(r.d);
                    break;
                default: break;
            }
        }
        b = SpreadsheetMLMain.rv(a.ab.ad, true);
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q
        };
    }
    static aax(a, b, c, d = null, e = null, f = null, g = null, h = null, i = Nullable$1.toNullable(Number_$type, null), j = false, k = false, l = false, m = false, n = Nullable$1.toNullable(Number_$type, null), o = null, p = false, q = false) {
        a.ad.p(SpreadsheetMLMain.gg, null);
        let r;
        r = c;
        a.ad.h("name", r);
        if (d != null) {
            r = d;
            a.ad.h("comment", r);
        }
        if (e != null) {
            r = e;
            a.ad.h("customMenu", r);
        }
        if (f != null) {
            r = f;
            a.ad.h("description", r);
        }
        if (g != null) {
            r = g;
            a.ad.h("help", r);
        }
        if (h != null) {
            r = h;
            a.ad.h("statusBar", r);
        }
        if (nullableNotEquals(i, null)) {
            r = i.value.toString();
            a.ad.h("localSheetId", r);
        }
        if (j != false) {
            r = ST_OnOff.g(j);
            a.ad.h("hidden", r);
        }
        if (k != false) {
            r = ST_OnOff.g(k);
            a.ad.h("function", r);
        }
        if (l != false) {
            r = ST_OnOff.g(l);
            a.ad.h("vbProcedure", r);
        }
        if (m != false) {
            r = ST_OnOff.g(m);
            a.ad.h("xlm", r);
        }
        if (nullableNotEquals(n, null)) {
            r = n.value.toString();
            a.ad.h("functionGroupId", r);
        }
        if (o != null) {
            r = o;
            a.ad.h("shortcutKey", r);
        }
        if (p != false) {
            r = ST_OnOff.g(p);
            a.ad.h("publishToServer", r);
        }
        if (q != false) {
            r = ST_OnOff.g(q);
            a.ad.h("workbookParameter", r);
        }
        if (b != null) {
            a.ad.u(SpreadsheetMLMain.hg(b));
        }
    }
    static vb(a, b, c, d) {
        b = null;
        c = null;
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "name":
                    b = e.d;
                    break;
                case "refersTo":
                    c = e.d;
                    break;
                case "sheetId":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static aaw(a, b, c = null, d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.gg, null);
        let e;
        e = b;
        a.ad.h("name", e);
        e = c;
        a.ad.h("refersTo", e);
        if (nullableNotEquals(d, null)) {
            e = d.value.toString();
            a.ad.h("sheetId", e);
        }
    }
    static vd(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aay(a) {
        a.ad.p(SpreadsheetMLMain.gh, null);
    }
    static ve(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.gq, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aaz(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.gq, b);
    }
    static vf(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ref":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aa0(a, b) {
        a.ad.p(SpreadsheetMLMain.gv, null);
        let c;
        c = b;
        a.ad.h("ref", c);
    }
    static vg(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aa1(a, b) {
        a.ad.p(SpreadsheetMLMain.g1, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static vh(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        b = null;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = Nullable$1.toNullable(Number_$type, null);
        l = Nullable$1.toNullable(Number_$type, null);
        m = Nullable$1.toNullable(Number_$type, null);
        n = Nullable$1.toNullable(Number_$type, null);
        o = Nullable$1.toNullable(Number_$type, null);
        p = Nullable$1.toNullable(Number_$type, null);
        q = Nullable$1.toNullable(Number_$type, null);
        r = Nullable$1.toNullable(Number_$type, null);
        s = Nullable$1.toNullable(Number_$type, null);
        t = Nullable$1.toNullable(Number_$type, null);
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = u.d;
                    break;
                case "lho":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "lhe":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "lhf":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "cho":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "che":
                    g = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "chf":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rho":
                    i = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rhe":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rhf":
                    k = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "lfo":
                    l = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "lfe":
                    m = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "lff":
                    n = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "cfo":
                    o = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "cfe":
                    p = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "cff":
                    q = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rfo":
                    r = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rfe":
                    s = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "rff":
                    t = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static aa2(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = Nullable$1.toNullable(Number_$type, null), l = Nullable$1.toNullable(Number_$type, null), m = Nullable$1.toNullable(Number_$type, null), n = Nullable$1.toNullable(Number_$type, null), o = Nullable$1.toNullable(Number_$type, null), p = Nullable$1.toNullable(Number_$type, null), q = Nullable$1.toNullable(Number_$type, null), r = Nullable$1.toNullable(Number_$type, null), s = Nullable$1.toNullable(Number_$type, null), t = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.g2, null);
        let u;
        u = b;
        a.ad.h(OfficeDocumentRelationships.ar, u);
        if (nullableNotEquals(c, null)) {
            u = c.value.toString();
            a.ad.h("lho", u);
        }
        if (nullableNotEquals(d, null)) {
            u = d.value.toString();
            a.ad.h("lhe", u);
        }
        if (nullableNotEquals(e, null)) {
            u = e.value.toString();
            a.ad.h("lhf", u);
        }
        if (nullableNotEquals(f, null)) {
            u = f.value.toString();
            a.ad.h("cho", u);
        }
        if (nullableNotEquals(g, null)) {
            u = g.value.toString();
            a.ad.h("che", u);
        }
        if (nullableNotEquals(h, null)) {
            u = h.value.toString();
            a.ad.h("chf", u);
        }
        if (nullableNotEquals(i, null)) {
            u = i.value.toString();
            a.ad.h("rho", u);
        }
        if (nullableNotEquals(j, null)) {
            u = j.value.toString();
            a.ad.h("rhe", u);
        }
        if (nullableNotEquals(k, null)) {
            u = k.value.toString();
            a.ad.h("rhf", u);
        }
        if (nullableNotEquals(l, null)) {
            u = l.value.toString();
            a.ad.h("lfo", u);
        }
        if (nullableNotEquals(m, null)) {
            u = m.value.toString();
            a.ad.h("lfe", u);
        }
        if (nullableNotEquals(n, null)) {
            u = n.value.toString();
            a.ad.h("lff", u);
        }
        if (nullableNotEquals(o, null)) {
            u = o.value.toString();
            a.ad.h("cfo", u);
        }
        if (nullableNotEquals(p, null)) {
            u = p.value.toString();
            a.ad.h("cfe", u);
        }
        if (nullableNotEquals(q, null)) {
            u = q.value.toString();
            a.ad.h("cff", u);
        }
        if (nullableNotEquals(r, null)) {
            u = r.value.toString();
            a.ad.h("rfo", u);
        }
        if (nullableNotEquals(s, null)) {
            u = s.value.toString();
            a.ad.h("rfe", u);
        }
        if (nullableNotEquals(t, null)) {
            u = t.value.toString();
            a.ad.h("rff", u);
        }
    }
    static vi(a, b = SpreadsheetMLMain.g5) {
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aa3(a, b = SpreadsheetMLMain.g5) {
        a.ad.p(b, null);
    }
    static vj(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aa4(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.g7, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static vk(a, b, c, d) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_DynamicFilterType_$type, e.d, b);
                    break;
                case "val":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(e.d, CultureInfo.invariantCulture));
                    break;
                case "maxVal":
                    d = Nullable$1.toNullable(Number_$type, parseNumber(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static aa5(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.g8, null);
        let e;
        e = XmlNamespaceDefinitionBase.f(ST_DynamicFilterType_$type, b);
        a.ad.h("type", e);
        if (nullableNotEquals(c, null)) {
            e = c.value.toString();
            a.ad.h("val", e);
        }
        if (nullableNotEquals(d, null)) {
            e = d.value.toString();
            a.ad.h("maxVal", e);
        }
    }
    static vl(a, b, c, d, e) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Date_$type, null);
        e = Nullable$1.toNullable(Date_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_DynamicFilterType_$type, f.d, b);
                    break;
                case "val":
                    c = Nullable$1.toNullable(Number_$type, parseNumber(f.d, CultureInfo.invariantCulture));
                    break;
                case "valIso":
                    d = Nullable$1.toNullable(Date_$type, dateParse(f.d, CultureInfo.invariantCulture));
                    break;
                case "maxValIso":
                    e = Nullable$1.toNullable(Date_$type, dateParse(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aa6(a, b, c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Date_$type, null), e = Nullable$1.toNullable(Date_$type, null)) {
        a.ad.p(SpreadsheetMLMain.g8, null);
        let f;
        f = XmlNamespaceDefinitionBase.f(ST_DynamicFilterType_$type, b);
        a.ad.h("type", f);
        if (nullableNotEquals(c, null)) {
            f = c.value.toString();
            a.ad.h("val", f);
        }
        if (nullableNotEquals(d, null)) {
            f = dateToString(d.value, CultureInfo.invariantCulture);
            a.ad.h("valIso", f);
        }
        if (nullableNotEquals(e, null)) {
            f = dateToString(e.value, CultureInfo.invariantCulture);
            a.ad.h("maxValIso", f);
        }
    }
    static vm(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.ha, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aa7(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.ha, b);
    }
    static vn(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.hh, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aa8(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.hh, null, b);
    }
    static vo(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.hi, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aa9(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.hi, null, b);
    }
    static vp(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "uri":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aba(a, b, c = null) {
        a.ad.p(SpreadsheetMLMain.hj, null);
        let d;
        d = b;
        a.ad.h("uri", d);
        if (stringIsNullOrEmpty(c) == false) {
            d = c;
            a.ad.i("xmlns", "x14", null, d);
        }
    }
    static vq(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.hk, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static abb(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.hk, b);
    }
    static vr(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abc(a, b) {
        a.ad.p(SpreadsheetMLMain.hl, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static vs(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static abd(a) {
        a.ad.p(SpreadsheetMLMain.hm, null);
        let b = a.d._z;
        a.ad.l(SpreadsheetMLMain.ao);
    }
    static vt(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abe(a, b) {
        a.ad.p(SpreadsheetMLMain.hn, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static vu(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static abf(a) {
        a.ad.p(SpreadsheetMLMain.ho, null);
    }
    static vv(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static abg(a) {
        a.ad.p(SpreadsheetMLMain.hp, null);
    }
    static vw(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abh(a, b) {
        a.ad.p(SpreadsheetMLMain.hr, null);
        let c;
        c = b.toString();
        a.ad.h("val", c);
    }
    static vx(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = 0;
        c = false;
        d = null;
        e = false;
        f = false;
        g = false;
        h = false;
        i = null;
        j = null;
        k = false;
        l = Nullable$1.toNullable(Number_$type, null);
        m = false;
        let o = false;
        for (let p of fromEnum(a.ab.u)) {
            switch (p.a.e(a.d)) {
                case "t":
                    b = XmlNamespaceDefinitionBase.b(ST_CellFormulaType_$type, p.d, b);
                    break;
                case "aca":
                    c = ST_OnOff.e(p.d);
                    break;
                case "ref":
                    d = p.d;
                    break;
                case "dt2D":
                    e = ST_OnOff.e(p.d);
                    break;
                case "dtr":
                    f = ST_OnOff.e(p.d);
                    break;
                case "del1":
                    g = ST_OnOff.e(p.d);
                    break;
                case "del2":
                    h = ST_OnOff.e(p.d);
                    break;
                case "r1":
                    i = p.d;
                    break;
                case "r2":
                    j = p.d;
                    break;
                case "ca":
                    k = ST_OnOff.e(p.d);
                    break;
                case "si":
                    l = Nullable$1.toNullable(Number_$type, parseUInt32_1(p.d, CultureInfo.invariantCulture));
                    break;
                case "bx":
                    m = ST_OnOff.e(p.d);
                    break;
                case XmlNamespace.ar:
                    o = (p.d == "preserve");
                    break;
                default: break;
            }
        }
        n = a.ab.ad;
        if (n != null && o == false) {
            n = n.trim();
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static abi(a, b, c = 0, d = false, e = null, f = false, g = false, h = false, i = false, j = null, k = null, l = false, m = Nullable$1.toNullable(Number_$type, null), n = false) {
        a.ad.p(SpreadsheetMLMain.hq, null);
        let o;
        if (c != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_CellFormulaType_$type, c);
            a.ad.h("t", o);
        }
        if (d != false) {
            o = ST_OnOff.g(d);
            a.ad.h("aca", o);
        }
        o = e;
        a.ad.h("ref", o);
        if (f != false) {
            o = ST_OnOff.g(f);
            a.ad.h("dt2D", o);
        }
        if (g != false) {
            o = ST_OnOff.g(g);
            a.ad.h("dtr", o);
        }
        if (h != false) {
            o = ST_OnOff.g(h);
            a.ad.h("del1", o);
        }
        if (i != false) {
            o = ST_OnOff.g(i);
            a.ad.h("del2", o);
        }
        o = j;
        a.ad.h("r1", o);
        o = k;
        a.ad.h("r2", o);
        if (l != false) {
            o = ST_OnOff.g(l);
            a.ad.h("ca", o);
        }
        if (nullableNotEquals(m, null)) {
            o = m.value.toString();
            a.ad.h("si", o);
        }
        if (n != false) {
            o = ST_OnOff.g(n);
            a.ad.h("bx", o);
        }
        if (b != null) {
            if (stringIsNullOrEmpty(b) == false) {
                if (/\s/i.test(b.charAt(0)) || /\s/i.test(b.charAt(b.length - 1))) {
                    XmlNamespace.as(a.ad);
                }
            }
            a.ad.u(b);
        }
    }
    static vy(a, b, c, d, e, f) {
        let g = SpreadsheetMLMain.us(a, SpreadsheetMLMain.hs, b, c, d, e, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        f = g.p6;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static abj(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(ST_UnsignedIntHex.$, null), e = Nullable$1.toNullable(Number_$type, null), f = 0) {
        SpreadsheetMLMain.aad(a, SpreadsheetMLMain.hs, b, c, d, e, f);
    }
    static v0(a, b, c, d) {
        c = false;
        b = null;
        d = 0;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "readOnlyRecommended":
                    c = ST_OnOff.e(e.d);
                    break;
                case "userName":
                    b = e.d;
                    break;
                case "reservationPassword":
                    d = ST_UnsignedShortHex.d(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static abl(a, b, c = false, d = 0) {
        a.ad.p(SpreadsheetMLMain.ht, null);
        let e;
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("readOnlyRecommended", e);
        }
        e = b;
        a.ad.h("userName", e);
        e = new ST_UnsignedShortHex(1, d).toString();
        a.ad.h("reservationPassword", e);
    }
    static vz(a, b, c, d, e, f, g) {
        c = false;
        b = null;
        d = null;
        e = null;
        f = null;
        g = Nullable$1.toNullable(Number_$type, null);
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "readOnlyRecommended":
                    c = ST_OnOff.e(h.d);
                    break;
                case "userName":
                    b = h.d;
                    break;
                case "algorithmName":
                    d = h.d;
                    break;
                case "hashValue":
                    e = Convert.fromBase64String(h.d);
                    break;
                case "saltValue":
                    f = Convert.fromBase64String(h.d);
                    break;
                case "spinCount":
                    g = Nullable$1.toNullable(Number_$type, parseUInt32_1(h.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static abk(a, b, c = false, d = null, e = null, f = null, g = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.ht, null);
        let h;
        if (c != false) {
            h = ST_OnOff.g(c);
            a.ad.h("readOnlyRecommended", h);
        }
        h = b;
        a.ad.h("userName", h);
        h = d;
        a.ad.h("algorithmName", h);
        if (e != null) {
            h = Convert.toBase64String(e);
            a.ad.h("hashValue", h);
        }
        if (f != null) {
            h = Convert.toBase64String(f);
            a.ad.h("saltValue", h);
        }
        if (nullableNotEquals(g, null)) {
            h = g.value.toString();
            a.ad.h("spinCount", h);
        }
    }
    static v1(a, b, c, d, e, f) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "appName":
                    b = g.d;
                    break;
                case "lastEdited":
                    c = g.d;
                    break;
                case "lowestEdited":
                    d = g.d;
                    break;
                case "rupBuild":
                    e = g.d;
                    break;
                case "codeName":
                    f = g.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static abm(a, b = null, c = null, d = null, e = null, f = null) {
        a.ad.p(SpreadsheetMLMain.hu, null);
        let g;
        g = b;
        a.ad.h("appName", g);
        g = c;
        a.ad.h("lastEdited", g);
        g = d;
        a.ad.h("lowestEdited", g);
        g = e;
        a.ad.h("rupBuild", g);
        g = f;
        a.ad.h("codeName", g);
    }
    static v2(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static abn(a) {
        a.ad.p(SpreadsheetMLMain.hv, null);
    }
    static v3(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abo(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.hx, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static v4(a, b, c, d) {
        b = 0;
        c = false;
        d = true;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "colId":
                    b = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "hiddenButton":
                    c = ST_OnOff.e(e.d);
                    break;
                case "showButton":
                    d = ST_OnOff.e(e.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static abp(a, b, c = false, d = true) {
        a.ad.p(SpreadsheetMLMain.h0, null);
        let e;
        e = b.toString();
        a.ad.h("colId", e);
        if (c != false) {
            e = ST_OnOff.g(c);
            a.ad.h("hiddenButton", e);
        }
        if (d != true) {
            e = ST_OnOff.g(d);
            a.ad.h("showButton", e);
        }
    }
    static v5(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abq(a, b) {
        a.ad.p(SpreadsheetMLMain.hy, null);
        let c;
        c = b;
        a.ad.h("val", c);
    }
    static v6(a, b, c) {
        b = false;
        c = 10;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "blank":
                    b = ST_OnOff.e(d.d);
                    break;
                case "calendarType":
                    c = XmlNamespaceDefinitionBase.b(ST_CalendarType_$type, d.d, c);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static abr(a, b = false, c = 10) {
        a.ad.p(SpreadsheetMLMain.h3, null);
        let d;
        if (b != false) {
            d = ST_OnOff.g(b);
            a.ad.h("blank", d);
        }
        if (c != 10) {
            d = XmlNamespaceDefinitionBase.f(ST_CalendarType_$type, c);
            a.ad.h("calendarType", d);
        }
    }
    static v7(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.h6, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static abs(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.h6, null, b);
    }
    static v8(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.h7, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static abt(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.h7, null, b);
    }
    static v9(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static abu(a) {
        a.ad.p(SpreadsheetMLMain.id, null);
    }
    static wa(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static abv(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.ig, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static wd(a, b) {
        let c = SpreadsheetMLMain.ut(a, SpreadsheetMLMain.iq, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aby(a, b) {
        SpreadsheetMLMain.aae(a, SpreadsheetMLMain.iq, b);
    }
    static wb(a, b) {
        let c = SpreadsheetMLMain.ut(a, SpreadsheetMLMain.ir, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static abw(a, b) {
        SpreadsheetMLMain.aae(a, SpreadsheetMLMain.ir, b);
    }
    static wc(a, b) {
        let c = SpreadsheetMLMain.ut(a, SpreadsheetMLMain.is, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static abx(a, b) {
        SpreadsheetMLMain.aae(a, SpreadsheetMLMain.is, b);
    }
    static we(a, b, c, d, e, f, g) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_GradientType_$type, h.d, b);
                    break;
                case "degree":
                    c = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "left":
                    d = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "right":
                    e = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "top":
                    f = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "bottom":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static abz(a, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0) {
        a.ad.p(SpreadsheetMLMain.ix, null);
        let h;
        if (b != 0) {
            h = XmlNamespaceDefinitionBase.f(ST_GradientType_$type, b);
            a.ad.h("type", h);
        }
        if (c != 0) {
            h = c.toString();
            a.ad.h("degree", h);
        }
        if (d != 0) {
            h = d.toString();
            a.ad.h("left", h);
        }
        if (e != 0) {
            h = e.toString();
            a.ad.h("right", h);
        }
        if (f != 0) {
            h = f.toString();
            a.ad.h("top", h);
        }
        if (g != 0) {
            h = g.toString();
            a.ad.h("bottom", h);
        }
    }
    static wf(a, b, c, d, e) {
        b = false;
        c = false;
        d = true;
        e = true;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "differentOddEven":
                    b = ST_OnOff.e(f.d);
                    break;
                case "differentFirst":
                    c = ST_OnOff.e(f.d);
                    break;
                case "scaleWithDoc":
                    d = ST_OnOff.e(f.d);
                    break;
                case "alignWithMargins":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static ab0(a, b = false, c = false, d = true, e = true) {
        a.ad.p(SpreadsheetMLMain.i4, null);
        let f;
        if (b != false) {
            f = ST_OnOff.g(b);
            a.ad.h("differentOddEven", f);
        }
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("differentFirst", f);
        }
        if (d != true) {
            f = ST_OnOff.g(d);
            a.ad.h("scaleWithDoc", f);
        }
        if (e != true) {
            f = ST_OnOff.g(e);
            a.ad.h("alignWithMargins", f);
        }
    }
    static wg(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.jg, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ab1(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.jg, b);
    }
    static wh(a, b, c, d, e, f) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "ref":
                    b = g.d;
                    break;
                case OfficeDocumentRelationships.ar:
                    c = g.d;
                    break;
                case "location":
                    d = g.d;
                    break;
                case "tooltip":
                    e = g.d;
                    break;
                case "display":
                    f = g.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static ab2(a, b = null, c = null, d = null, e = null, f = null) {
        a.ad.p(SpreadsheetMLMain.jm, null);
        let g;
        g = b;
        a.ad.h("ref", g);
        g = c;
        a.ad.h(OfficeDocumentRelationships.ar, g);
        g = d;
        a.ad.h("location", g);
        g = e;
        a.ad.h("tooltip", g);
        g = f;
        a.ad.h("display", g);
    }
    static wi(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ab3(a) {
        a.ad.p(SpreadsheetMLMain.jn, null);
    }
    static wj(a, b, c) {
        b = 0;
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "iconSet":
                    b = XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, d.d, b);
                    break;
                case "iconId":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        if (b <= 16) {
        }
        return {
            p1: b,
            p2: c
        };
    }
    static ab4(a, b, c = Nullable$1.toNullable(Number_$type, null)) {
        if (b <= 16) {
            SpreadsheetMLMain.ab5(a, SpreadsheetMLMain.jq, null, b, c);
        }
        else {
            a.ad.g([new AlternateContentChoice(0, SpreadsheetML2009Main.an, () => SpreadsheetMLMain.ab5(a, SpreadsheetML2009Main.br, null, b, c))], () => {
                SpreadsheetMLMain.aaj(a);
                SpreadsheetMLMain.aai(a, "");
                a.ad.k();
                SpreadsheetMLMain.aai(a, " ", 5);
                a.ad.k();
                a.ad.k();
            });
        }
    }
    static ab5(a, b, c, d, e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, c);
        let f;
        f = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, d);
        a.ad.h("iconSet", f);
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("iconId", f);
        }
        a.ad.k();
    }
    static wk(a, b, c, d, e, f) {
        b = 3;
        c = true;
        d = false;
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = false;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "iconSet":
                    b = XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, g.d, b);
                    break;
                case "percent":
                    c = ST_OnOff.e(g.d);
                    break;
                case "reverse":
                    d = ST_OnOff.e(g.d);
                    break;
                case "showValue":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "custom":
                    f = ST_OnOff.e(g.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static ab6(a, b, c, d, e, f, g) {
        a.ad.p(b, null);
        let h;
        if (c.hasValue && c.value != 3) {
            h = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, c.value);
            a.ad.h("iconSet", h);
        }
        if (d.hasValue && d.value == false) {
            h = ST_OnOff.g(d.value);
            a.ad.h("percent", h);
        }
        if (e.hasValue && e.value) {
            h = ST_OnOff.g(e.value);
            a.ad.h("reverse", h);
        }
        if (f.hasValue && f.value == false) {
            h = ST_OnOff.g(f.value);
            a.ad.h("showValue", h);
        }
        if (g.hasValue && g.value) {
            h = ST_OnOff.g(g.value);
            a.ad.h("custom", h);
        }
    }
    static wl(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.jo, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ab7(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.jo, b);
    }
    static wm(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ab8(a) {
        a.ad.p(SpreadsheetMLMain.j1, null);
    }
    static wn(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ab9(a) {
        a.ad.p(SpreadsheetMLMain.b7, null);
    }
    static wo(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.kc, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aca(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.kc, b);
    }
    static wp(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static acb(a, b) {
        a.ad.p(SpreadsheetMLMain.ke, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static wq(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static acc(a, b) {
        a.ad.p(SpreadsheetMLMain.kf, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static wr(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "ref":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static acd(a, b) {
        a.ad.p(SpreadsheetMLMain.k4, null);
        let c;
        c = b;
        a.ad.h("ref", c);
    }
    static ws(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ace(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.k5, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static wt(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static acf(a, b) {
        a.ad.p(SpreadsheetMLMain.ld, null);
        let c;
        c = b;
        a.ad.h("val", c);
    }
    static wu(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "numFmtId":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "formatCode":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static acg(a, b, c) {
        a.ad.p(SpreadsheetMLMain.lh, null);
        let d;
        d = b.toString();
        a.ad.h("numFmtId", d);
        d = c;
        a.ad.h("formatCode", d);
    }
    static wv(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ach(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.lj, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static ww(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.ll, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aci(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.ll, null, b);
    }
    static wx(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.lm, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static acj(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.lm, null, b);
    }
    static wy(a, b, c, d, e) {
        b = null;
        c = false;
        d = false;
        e = false;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "icon":
                    c = ST_OnOff.e(f.d);
                    break;
                case "advise":
                    d = ST_OnOff.e(f.d);
                    break;
                case "preferPic":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static ack(a, b = null, c = false, d = false, e = false) {
        a.ad.p(SpreadsheetMLMain.lo, null);
        let f;
        f = b;
        a.ad.h("name", f);
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("icon", f);
        }
        if (d != false) {
            f = ST_OnOff.g(d);
            a.ad.h("advise", f);
        }
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("preferPic", f);
        }
    }
    static wz(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static acl(a) {
        a.ad.p(SpreadsheetMLMain.lp, null);
    }
    static w0(a, b, c) {
        b = null;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = d.d;
                    break;
                case "progId":
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static acm(a, b = null, c = null) {
        a.ad.p(SpreadsheetMLMain.lq, null);
        let d;
        d = b;
        a.ad.h(OfficeDocumentRelationships.ar, d);
        d = c;
        a.ad.h("progId", d);
    }
    static w1(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.lu, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static acn(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.lu, b);
    }
    static w2(a, b, c, d, e) {
        b = false;
        c = true;
        d = true;
        e = true;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "applyStyles":
                    b = ST_OnOff.e(f.d);
                    break;
                case "summaryBelow":
                    c = ST_OnOff.e(f.d);
                    break;
                case "summaryRight":
                    d = ST_OnOff.e(f.d);
                    break;
                case "showOutlineSymbols":
                    e = ST_OnOff.e(f.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aco(a, b = false, c = true, d = true, e = true) {
        a.ad.p(SpreadsheetMLMain.lz, null);
        let f;
        if (b != false) {
            f = ST_OnOff.g(b);
            a.ad.h("applyStyles", f);
        }
        if (c != true) {
            f = ST_OnOff.g(c);
            a.ad.h("summaryBelow", f);
        }
        if (d != true) {
            f = ST_OnOff.g(d);
            a.ad.h("summaryRight", f);
        }
        if (e != true) {
            f = ST_OnOff.g(e);
            a.ad.h("showOutlineSymbols", f);
        }
    }
    static w3(a, b, c, d, e, f, g) {
        b = 0;
        c = 0;
        d = 0;
        e = 0;
        f = 0;
        g = 0;
        for (let h of fromEnum(a.ab.u)) {
            switch (h.a.e(a.d)) {
                case "left":
                    b = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "right":
                    c = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "top":
                    d = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "bottom":
                    e = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "header":
                    f = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                case "footer":
                    g = parseNumber(h.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g
        };
    }
    static acp(a, b, c, d, e, f, g) {
        a.ad.p(SpreadsheetMLMain.l1, null);
        let h;
        h = b.toString();
        a.ad.h("left", h);
        h = c.toString();
        a.ad.h("right", h);
        h = d.toString();
        a.ad.h("top", h);
        h = e.toString();
        a.ad.h("bottom", h);
        h = f.toString();
        a.ad.h("header", h);
        h = g.toString();
        a.ad.h("footer", h);
    }
    static w4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        b = 1;
        c = null;
        d = null;
        e = 100;
        f = 1;
        g = 1;
        h = 1;
        i = 0;
        j = 0;
        k = true;
        l = false;
        m = false;
        n = 0;
        o = false;
        p = 0;
        q = 600;
        r = 600;
        s = 1;
        t = null;
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case "paperSize":
                    b = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "paperHeight":
                    c = u.d;
                    break;
                case "paperWidth":
                    d = u.d;
                    break;
                case "scale":
                    e = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "firstPageNumber":
                    f = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "fitToWidth":
                    g = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "fitToHeight":
                    h = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "pageOrder":
                    i = XmlNamespaceDefinitionBase.b(ST_PageOrder_$type, u.d, i);
                    break;
                case "orientation":
                    j = XmlNamespaceDefinitionBase.b(ST_Orientation_$type, u.d, j);
                    break;
                case "usePrinterDefaults":
                    k = ST_OnOff.e(u.d);
                    break;
                case "blackAndWhite":
                    l = ST_OnOff.e(u.d);
                    break;
                case "draft":
                    m = ST_OnOff.e(u.d);
                    break;
                case "cellComments":
                    n = XmlNamespaceDefinitionBase.b(ST_CellComments_$type, u.d, n);
                    break;
                case "useFirstPageNumber":
                    o = ST_OnOff.e(u.d);
                    break;
                case "errors":
                    p = XmlNamespaceDefinitionBase.b(ST_PrintError_$type, u.d, p);
                    break;
                case "horizontalDpi":
                    q = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "verticalDpi":
                    r = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "copies":
                    s = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case OfficeDocumentRelationships.ar:
                    t = u.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static acq(a, b = 1, c = null, d = null, e = 100, f = 1, g = 1, h = 1, i = 0, j = 0, k = true, l = false, m = false, n = 0, o = false, p = 0, q = 600, r = 600, s = 1, t = null) {
        a.ad.p(SpreadsheetMLMain.l3, null);
        let u;
        if (b != 1) {
            u = b.toString();
            a.ad.h("paperSize", u);
        }
        if (c != null) {
            u = c;
            a.ad.h("paperHeight", u);
        }
        if (d != null) {
            u = d;
            a.ad.h("paperWidth", u);
        }
        if (e != 100) {
            u = e.toString();
            a.ad.h("scale", u);
        }
        if (f != 1) {
            u = f.toString();
            a.ad.h("firstPageNumber", u);
        }
        if (g != 1) {
            u = g.toString();
            a.ad.h("fitToWidth", u);
        }
        if (h != 1) {
            u = h.toString();
            a.ad.h("fitToHeight", u);
        }
        if (i != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_PageOrder_$type, i);
            a.ad.h("pageOrder", u);
        }
        if (j != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_Orientation_$type, j);
            a.ad.h("orientation", u);
        }
        if (k != true) {
            u = ST_OnOff.g(k);
            a.ad.h("usePrinterDefaults", u);
        }
        if (l != false) {
            u = ST_OnOff.g(l);
            a.ad.h("blackAndWhite", u);
        }
        if (m != false) {
            u = ST_OnOff.g(m);
            a.ad.h("draft", u);
        }
        if (n != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_CellComments_$type, n);
            a.ad.h("cellComments", u);
        }
        if (o != false) {
            u = ST_OnOff.g(o);
            a.ad.h("useFirstPageNumber", u);
        }
        if (p != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_PrintError_$type, p);
            a.ad.h("errors", u);
        }
        if (q != 600) {
            u = q.toString();
            a.ad.h("horizontalDpi", u);
        }
        if (r != 600) {
            u = r.toString();
            a.ad.h("verticalDpi", u);
        }
        if (s != 1) {
            u = s.toString();
            a.ad.h("copies", u);
        }
        if (t != null) {
            u = t;
            a.ad.h(OfficeDocumentRelationships.ar, u);
        }
    }
    static w5(a, b, c) {
        b = true;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "autoPageBreaks":
                    b = ST_OnOff.e(d.d);
                    break;
                case "fitToPage":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static acr(a, b = true, c = false) {
        a.ad.p(SpreadsheetMLMain.l4, null);
        let d;
        if (b != true) {
            d = ST_OnOff.g(b);
            a.ad.h("autoPageBreaks", d);
        }
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("fitToPage", d);
        }
    }
    static w6(a, b, c, d, e, f) {
        b = 0;
        c = 0;
        d = null;
        e = 3;
        f = 0;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "xSplit":
                    b = parseNumber(g.d, CultureInfo.invariantCulture);
                    break;
                case "ySplit":
                    c = parseNumber(g.d, CultureInfo.invariantCulture);
                    break;
                case "topLeftCell":
                    d = g.d;
                    break;
                case "activePane":
                    e = XmlNamespaceDefinitionBase.b(ST_Pane_$type, g.d, e);
                    break;
                case "state":
                    f = XmlNamespaceDefinitionBase.b(ST_PaneState_$type, g.d, f);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static acs(a, b = 0, c = 0, d = null, e = 3, f = 0) {
        a.ad.p(SpreadsheetMLMain.l5, null);
        let g;
        if (b != 0) {
            g = b.toString();
            a.ad.h("xSplit", g);
        }
        if (c != 0) {
            g = c.toString();
            a.ad.h("ySplit", g);
        }
        g = d;
        a.ad.h("topLeftCell", g);
        if (e != 3) {
            g = XmlNamespaceDefinitionBase.f(ST_Pane_$type, e);
            a.ad.h("activePane", g);
        }
        if (f != 0) {
            g = XmlNamespaceDefinitionBase.f(ST_PaneState_$type, f);
            a.ad.h("state", g);
        }
    }
    static w7(a, b) {
        b = Nullable$1.toNullable(ST_PatternType_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "patternType":
                    b = Nullable$1.toNullable(ST_PatternType_$type, XmlNamespaceDefinitionBase.b(ST_PatternType_$type, c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static act(a, b = Nullable$1.toNullable(ST_PatternType_$type, null)) {
        a.ad.p(SpreadsheetMLMain.mb, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = XmlNamespaceDefinitionBase.f(ST_PatternType_$type, b.value);
            a.ad.h("patternType", c);
        }
    }
    static w8(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static acu(a, b) {
        a.ad.p(SpreadsheetMLMain.mh, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static w9(a, b, c) {
        b = 0;
        c = null;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "cacheId":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case OfficeDocumentRelationships.ar:
                    c = d.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static acv(a, b, c) {
        a.ad.p(SpreadsheetMLMain.mk, null);
        let d;
        d = b.toString();
        a.ad.h("cacheId", d);
        d = c;
        a.ad.h(OfficeDocumentRelationships.ar, d);
    }
    static xa(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static acw(a) {
        a.ad.p(SpreadsheetMLMain.ml, null);
    }
    static xb(a, b, c, d, e, f) {
        b = false;
        c = false;
        d = false;
        e = false;
        f = true;
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "horizontalCentered":
                    b = ST_OnOff.e(g.d);
                    break;
                case "verticalCentered":
                    c = ST_OnOff.e(g.d);
                    break;
                case "headings":
                    d = ST_OnOff.e(g.d);
                    break;
                case "gridLines":
                    e = ST_OnOff.e(g.d);
                    break;
                case "gridLinesSet":
                    f = ST_OnOff.e(g.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static acx(a, b = false, c = false, d = false, e = false, f = true) {
        a.ad.p(SpreadsheetMLMain.ms, null);
        let g;
        if (b != false) {
            g = ST_OnOff.g(b);
            a.ad.h("horizontalCentered", g);
        }
        if (c != false) {
            g = ST_OnOff.g(c);
            a.ad.h("verticalCentered", g);
        }
        if (d != false) {
            g = ST_OnOff.g(d);
            a.ad.h("headings", g);
        }
        if (e != false) {
            g = ST_OnOff.g(e);
            a.ad.h("gridLines", g);
        }
        if (f != true) {
            g = ST_OnOff.g(f);
            a.ad.h("gridLinesSet", g);
        }
    }
    static xc(a, b, c, d, e) {
        b = null;
        c = null;
        d = null;
        e = Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "password":
                    e = Nullable$1.toNullable(ST_UnsignedShortHex.$, ST_UnsignedShortHex.b(f.d));
                    break;
                case "sqref":
                    c = f.d;
                    break;
                case "name":
                    d = f.d;
                    break;
                case "securityDescriptor":
                    b = f.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static xd(a, b, c, d, e, f, g, h) {
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = Nullable$1.toNullable(Number_$type, null);
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "algorithmName":
                    e = i.d;
                    break;
                case "hashValue":
                    f = i.d;
                    break;
                case "saltValue":
                    g = i.d;
                    break;
                case "spinCount":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "sqref":
                    c = i.d;
                    break;
                case "name":
                    d = i.d;
                    break;
                case "securityDescriptor":
                    b = i.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static acy(a, b, c, d, e = Nullable$1.toNullable(ST_UnsignedShortHex.$, null)) {
        a.ad.p(SpreadsheetMLMain.my, null);
        let f;
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("password", f);
        }
        f = c;
        a.ad.h("sqref", f);
        f = d;
        a.ad.h("name", f);
        if (!stringIsNullOrEmpty(b)) {
            f = b;
            a.ad.h("securityDescriptor", f);
        }
    }
    static acz(a, b, c, d, e = null, f = null, g = null, h = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.my, null);
        let i;
        if (!stringIsNullOrEmpty(b)) {
            i = b;
            a.ad.h("securityDescriptor", i);
        }
        i = c;
        a.ad.h("sqref", i);
        i = d;
        a.ad.h("name", i);
        if (!stringIsNullOrEmpty(e)) {
            i = e;
            a.ad.h("algorithmName", i);
        }
        if (!stringIsNullOrEmpty(f)) {
            i = f;
            a.ad.h("hashValue", i);
        }
        if (!stringIsNullOrEmpty(g)) {
            i = g;
            a.ad.h("saltValue", i);
        }
        if (nullableNotEquals(h, null)) {
            i = h.value.toString();
            a.ad.h("spinCount", i);
        }
    }
    static xe(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ac0(a) {
        a.ad.p(SpreadsheetMLMain.mz, null);
    }
    static xf(a, b, c) {
        b = Nullable$1.toNullable(Boolean_$type, null);
        c = Nullable$1.toNullable(Boolean_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "locked":
                    b = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                case "hidden":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(d.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static ac1(a, b = Nullable$1.toNullable(Boolean_$type, null), c = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(SpreadsheetMLMain.m0, null);
        let d;
        if (nullableNotEquals(b, null)) {
            d = ST_OnOff.g(b.value);
            a.ad.h("locked", d);
        }
        if (nullableNotEquals(c, null)) {
            d = ST_OnOff.g(c.value);
            a.ad.h("hidden", d);
        }
    }
    static xg(a) {
    }
    static ac2(a) {
        a.ad.p(SpreadsheetMLMain.m7, null);
    }
    static xh(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ac3(a, b) {
        a.ad.p(SpreadsheetMLMain.nv, null);
        let c;
        c = b;
        a.ad.h("val", c);
    }
    static xi(a, b) {
        b = Nullable$1.toNullable(ST_UnsignedIntHex.$, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "rgb":
                    b = Nullable$1.toNullable(ST_UnsignedIntHex.$, ST_UnsignedIntHex.d(c.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ac4(a, b = Nullable$1.toNullable(ST_UnsignedIntHex.$, null)) {
        a.ad.p(SpreadsheetMLMain.nx, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("rgb", c);
        }
    }
    static xj(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.n1, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ac5(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.n1, b);
    }
    static xk(a, b, c) {
        let d = SpreadsheetMLMain.uu(a, SpreadsheetMLMain.n5, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static ac6(a, b, c) {
        SpreadsheetMLMain.aaf(a, SpreadsheetMLMain.n5, b, c);
    }
    static xm(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "r":
                    b = parseUInt32_1(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ac8(a, b) {
        a.ad.p(SpreadsheetMLMain.n4, null);
        let c;
        c = b.toString();
        a.ad.h("r", c);
    }
    static xl(a, b, c, d, e, f, g, h, i, j, k, l, m, n = false) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = null;
        d = 0;
        e = false;
        f = Nullable$1.toNullable(Number_$type, null);
        g = false;
        h = false;
        i = 0;
        j = false;
        k = false;
        l = false;
        m = false;
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "r":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "spans":
                    if (n == false) {
                        c = XmlNamespaceDefinitionBase.e(String_$type, o.d, (p) => p);
                    }
                    break;
                case "s":
                    d = parseUInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "customFormat":
                    e = ST_OnOff.e(o.d);
                    break;
                case "ht":
                    f = Nullable$1.toNullable(Number_$type, parseNumber(o.d, CultureInfo.invariantCulture));
                    break;
                case "hidden":
                    g = ST_OnOff.e(o.d);
                    break;
                case "customHeight":
                    h = ST_OnOff.e(o.d);
                    break;
                case "outlineLevel":
                    i = parseUInt8_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "collapsed":
                    j = ST_OnOff.e(o.d);
                    break;
                case "thickTop":
                    k = ST_OnOff.e(o.d);
                    break;
                case "thickBot":
                    l = ST_OnOff.e(o.d);
                    break;
                case "ph":
                    m = ST_OnOff.e(o.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static ac7(a, b = Nullable$1.toNullable(Number_$type, null), c = null, d = 0, e = false, f = Nullable$1.toNullable(Number_$type, null), g = false, h = false, i = 0, j = false, k = false, l = false, m = false) {
        a.ad.p(SpreadsheetMLMain.n4, null);
        let n;
        if (nullableNotEquals(b, null)) {
            n = b.value.toString();
            a.ad.h("r", n);
        }
        if (c != null) {
            n = stringJoin1(String_$type, " ", c);
            a.ad.h("spans", n);
        }
        if (d != 0) {
            n = d.toString();
            a.ad.h("s", n);
        }
        if (e != false) {
            n = ST_OnOff.g(e);
            a.ad.h("customFormat", n);
        }
        if (nullableNotEquals(f, null)) {
            n = f.value.toString();
            a.ad.h("ht", n);
        }
        if (g != false) {
            n = ST_OnOff.g(g);
            a.ad.h("hidden", n);
        }
        if (h != false) {
            n = ST_OnOff.g(h);
            a.ad.h("customHeight", n);
        }
        if (i != 0) {
            n = i.toString();
            a.ad.h("outlineLevel", n);
        }
        if (j != false) {
            n = ST_OnOff.g(j);
            a.ad.h("collapsed", n);
        }
        if (k != false) {
            n = ST_OnOff.g(k);
            a.ad.h("thickTop", n);
        }
        if (l != false) {
            n = ST_OnOff.g(l);
            a.ad.h("thickBot", n);
        }
        if (m != false) {
            n = ST_OnOff.g(m);
            a.ad.h("ph", n);
        }
    }
    static xn(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ac9(a) {
        a.ad.p(SpreadsheetMLMain.n6, null);
    }
    static xo(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_FontScheme_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ada(a, b) {
        a.ad.p(SpreadsheetMLMain.oe, null);
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_FontScheme_$type, b);
        a.ad.h("val", c);
    }
    static xp(a, b, c, d, e) {
        b = 3;
        c = null;
        d = 0;
        e = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "pane":
                    b = XmlNamespaceDefinitionBase.b(ST_Pane_$type, f.d, b);
                    break;
                case "activeCell":
                    c = f.d;
                    break;
                case "activeCellId":
                    d = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "sqref":
                    e = XmlNamespaceDefinitionBase.e(String_$type, f.d, (g) => g);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static adb(a, b = 3, c = null, d = 0, e = null) {
        a.ad.p(SpreadsheetMLMain.oh, null);
        let f;
        if (b != 3) {
            f = XmlNamespaceDefinitionBase.f(ST_Pane_$type, b);
            a.ad.h("pane", f);
        }
        f = c;
        a.ad.h("activeCell", f);
        if (d != 0) {
            f = d.toString();
            a.ad.h("activeCellId", f);
        }
        if (e != null) {
            f = stringJoin1(String_$type, " ", e);
            a.ad.h("sqref", f);
        }
    }
    static xq(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.ok, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static adc(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.ok, b);
    }
    static xr(a, b) {
        b = false;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "fullCalcOnLoad":
                    b = ST_OnOff.e(c.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static add(a, b = false) {
        a.ad.p(SpreadsheetMLMain.oo, null);
        let c;
        if (b != false) {
            c = ST_OnOff.g(b);
            a.ad.h("fullCalcOnLoad", c);
        }
    }
    static xs(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ade(a) {
        a.ad.p(SpreadsheetMLMain.op, null);
    }
    static xt(a, b, c) {
        b = 0;
        c = false;
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "sheetId":
                    b = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                    break;
                case "refreshError":
                    c = ST_OnOff.e(d.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static adf(a, b, c = false) {
        a.ad.p(SpreadsheetMLMain.op, null);
        let d;
        d = b.toString();
        a.ad.h("sheetId", d);
        if (c != false) {
            d = ST_OnOff.g(c);
            a.ad.h("refreshError", d);
        }
    }
    static xu(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static adg(a) {
        a.ad.p(SpreadsheetMLMain.oq, null);
    }
    static xv(a, b, c, d, e) {
        b = null;
        c = 0;
        d = 0;
        e = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "sheetId":
                    c = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "state":
                    d = XmlNamespaceDefinitionBase.b(ST_SheetState_$type, f.d, d);
                    break;
                case OfficeDocumentRelationships.ar:
                    e = f.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static adh(a, b, c, d, e) {
        a.ad.p(SpreadsheetMLMain.om, null);
        let f;
        f = b;
        a.ad.h("name", f);
        f = c.toString();
        a.ad.h("sheetId", f);
        if (d != 0) {
            f = XmlNamespaceDefinitionBase.f(ST_SheetState_$type, d);
            a.ad.h("state", f);
        }
        f = e;
        a.ad.h(OfficeDocumentRelationships.ar, f);
    }
    static xw(a, b, c, d, e, f, g, h, i, j) {
        c = 8;
        d = Nullable$1.toNullable(Number_$type, null);
        b = 0;
        e = false;
        f = false;
        g = false;
        h = false;
        i = 0;
        j = 0;
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "baseColWidth":
                    c = parseUInt32_1(k.d, CultureInfo.invariantCulture);
                    break;
                case "defaultColWidth":
                    d = Nullable$1.toNullable(Number_$type, parseNumber(k.d, CultureInfo.invariantCulture));
                    break;
                case "defaultRowHeight":
                    b = parseNumber(k.d, CultureInfo.invariantCulture);
                    break;
                case "customHeight":
                    e = ST_OnOff.e(k.d);
                    break;
                case "zeroHeight":
                    f = ST_OnOff.e(k.d);
                    break;
                case "thickTop":
                    g = ST_OnOff.e(k.d);
                    break;
                case "thickBottom":
                    h = ST_OnOff.e(k.d);
                    break;
                case "outlineLevelRow":
                    i = parseUInt8_1(k.d, CultureInfo.invariantCulture);
                    break;
                case "outlineLevelCol":
                    j = parseUInt8_1(k.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static adi(a, b, c = 8, d = Nullable$1.toNullable(Number_$type, null), e = false, f = false, g = false, h = false, i = 0, j = 0) {
        a.ad.p(SpreadsheetMLMain.or, null);
        let k;
        if (c != 8) {
            k = c.toString();
            a.ad.h("baseColWidth", k);
        }
        if (nullableNotEquals(d, null)) {
            k = d.value.toString();
            a.ad.h("defaultColWidth", k);
        }
        k = b.toString();
        a.ad.h("defaultRowHeight", k);
        if (e != false) {
            k = ST_OnOff.g(e);
            a.ad.h("customHeight", k);
        }
        if (f != false) {
            k = ST_OnOff.g(f);
            a.ad.h("zeroHeight", k);
        }
        if (g != false) {
            k = ST_OnOff.g(g);
            a.ad.h("thickTop", k);
        }
        if (h != false) {
            k = ST_OnOff.g(h);
            a.ad.h("thickBottom", k);
        }
        if (i != 0) {
            k = i.toString();
            a.ad.h("outlineLevelRow", k);
        }
        if (j != 0) {
            k = j.toString();
            a.ad.h("outlineLevelCol", k);
        }
    }
    static xx(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static adj(a, b) {
        a.ad.p(SpreadsheetMLMain.ot, null);
        let c;
        c = b;
        a.ad.h("val", c);
    }
    static xy(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static adk(a) {
        a.ad.p(SpreadsheetMLMain.ou, null);
    }
    static xz(a, b, c, d, e, f, g, h, i, j) {
        b = false;
        c = false;
        d = null;
        e = false;
        f = false;
        g = true;
        h = null;
        i = false;
        j = true;
        for (let k of fromEnum(a.ab.u)) {
            switch (k.a.e(a.d)) {
                case "syncHorizontal":
                    b = ST_OnOff.e(k.d);
                    break;
                case "syncVertical":
                    c = ST_OnOff.e(k.d);
                    break;
                case "syncRef":
                    d = k.d;
                    break;
                case "transitionEvaluation":
                    e = ST_OnOff.e(k.d);
                    break;
                case "transitionEntry":
                    f = ST_OnOff.e(k.d);
                    break;
                case "published":
                    g = ST_OnOff.e(k.d);
                    break;
                case "codeName":
                    h = k.d;
                    break;
                case "filterMode":
                    i = ST_OnOff.e(k.d);
                    break;
                case "enableFormatConditionsCalculation":
                    j = ST_OnOff.e(k.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j
        };
    }
    static adl(a, b = false, c = false, d = null, e = false, f = false, g = true, h = null, i = false, j = true) {
        a.ad.p(SpreadsheetMLMain.ov, null);
        let k;
        if (b != false) {
            k = ST_OnOff.g(b);
            a.ad.h("syncHorizontal", k);
        }
        if (c != false) {
            k = ST_OnOff.g(c);
            a.ad.h("syncVertical", k);
        }
        k = d;
        a.ad.h("syncRef", k);
        if (e != false) {
            k = ST_OnOff.g(e);
            a.ad.h("transitionEvaluation", k);
        }
        if (f != false) {
            k = ST_OnOff.g(f);
            a.ad.h("transitionEntry", k);
        }
        if (g != true) {
            k = ST_OnOff.g(g);
            a.ad.h("published", k);
        }
        k = h;
        a.ad.h("codeName", k);
        if (i != false) {
            k = ST_OnOff.g(i);
            a.ad.h("filterMode", k);
        }
        if (j != true) {
            k = ST_OnOff.g(j);
            a.ad.h("enableFormatConditionsCalculation", k);
        }
    }
    static x0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
        b = Nullable$1.toNullable(ST_UnsignedShortHex.$, null);
        c = false;
        d = false;
        e = false;
        f = true;
        g = true;
        h = true;
        i = true;
        j = true;
        k = true;
        l = true;
        m = true;
        n = false;
        o = true;
        p = true;
        q = true;
        r = false;
        for (let s of fromEnum(a.ab.u)) {
            switch (s.a.e(a.d)) {
                case "password":
                    b = Nullable$1.toNullable(ST_UnsignedShortHex.$, ST_UnsignedShortHex.b(s.d));
                    break;
                case "sheet":
                    c = ST_OnOff.e(s.d);
                    break;
                case "objects":
                    d = ST_OnOff.e(s.d);
                    break;
                case "scenarios":
                    e = ST_OnOff.e(s.d);
                    break;
                case "formatCells":
                    f = ST_OnOff.e(s.d);
                    break;
                case "formatColumns":
                    g = ST_OnOff.e(s.d);
                    break;
                case "formatRows":
                    h = ST_OnOff.e(s.d);
                    break;
                case "insertColumns":
                    i = ST_OnOff.e(s.d);
                    break;
                case "insertRows":
                    j = ST_OnOff.e(s.d);
                    break;
                case "insertHyperlinks":
                    k = ST_OnOff.e(s.d);
                    break;
                case "deleteColumns":
                    l = ST_OnOff.e(s.d);
                    break;
                case "deleteRows":
                    m = ST_OnOff.e(s.d);
                    break;
                case "selectLockedCells":
                    n = ST_OnOff.e(s.d);
                    break;
                case "sort":
                    o = ST_OnOff.e(s.d);
                    break;
                case "autoFilter":
                    p = ST_OnOff.e(s.d);
                    break;
                case "pivotTables":
                    q = ST_OnOff.e(s.d);
                    break;
                case "selectUnlockedCells":
                    r = ST_OnOff.e(s.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r
        };
    }
    static adm(a, b = Nullable$1.toNullable(ST_UnsignedShortHex.$, null), c = false, d = false, e = false, f = true, g = true, h = true, i = true, j = true, k = true, l = true, m = true, n = false, o = true, p = true, q = true, r = false) {
        a.ad.p(SpreadsheetMLMain.ow, null);
        let s;
        if (nullableNotEquals(b, null)) {
            s = b.value.toString();
            a.ad.h("password", s);
        }
        if (c != false) {
            s = ST_OnOff.g(c);
            a.ad.h("sheet", s);
            if (d != false) {
                s = ST_OnOff.g(d);
                a.ad.h("objects", s);
            }
            if (e != false) {
                s = ST_OnOff.g(e);
                a.ad.h("scenarios", s);
            }
        }
        if (f != true) {
            s = ST_OnOff.g(f);
            a.ad.h("formatCells", s);
        }
        if (g != true) {
            s = ST_OnOff.g(g);
            a.ad.h("formatColumns", s);
        }
        if (h != true) {
            s = ST_OnOff.g(h);
            a.ad.h("formatRows", s);
        }
        if (i != true) {
            s = ST_OnOff.g(i);
            a.ad.h("insertColumns", s);
        }
        if (j != true) {
            s = ST_OnOff.g(j);
            a.ad.h("insertRows", s);
        }
        if (k != true) {
            s = ST_OnOff.g(k);
            a.ad.h("insertHyperlinks", s);
        }
        if (l != true) {
            s = ST_OnOff.g(l);
            a.ad.h("deleteColumns", s);
        }
        if (m != true) {
            s = ST_OnOff.g(m);
            a.ad.h("deleteRows", s);
        }
        if (n != false) {
            s = ST_OnOff.g(n);
            a.ad.h("selectLockedCells", s);
        }
        if (o != true) {
            s = ST_OnOff.g(o);
            a.ad.h("sort", s);
        }
        if (p != true) {
            s = ST_OnOff.g(p);
            a.ad.h("autoFilter", s);
        }
        if (q != true) {
            s = ST_OnOff.g(q);
            a.ad.h("pivotTables", s);
        }
        if (r != false) {
            s = ST_OnOff.g(r);
            a.ad.h("selectUnlockedCells", s);
        }
    }
    static b3(a) {
        if (a.d._z == 1) {
            return true;
        }
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                case "algorithmName":
                case "hashValue":
                case "saltValue":
                case "spinCount": return true;
                case "password": return false;
            }
        }
        return false;
    }
    static x1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
        b = null;
        c = null;
        d = null;
        e = Nullable$1.toNullable(Number_$type, null);
        f = false;
        g = false;
        h = false;
        i = true;
        j = true;
        k = true;
        l = true;
        m = true;
        n = true;
        o = true;
        p = true;
        q = false;
        r = true;
        s = true;
        t = true;
        u = false;
        for (let v of fromEnum(a.ab.u)) {
            switch (v.a.e(a.d)) {
                case "algorithmName":
                    b = v.d;
                    break;
                case "hashValue":
                    c = v.d;
                    break;
                case "saltValue":
                    d = v.d;
                    break;
                case "spinCount":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(v.d, CultureInfo.invariantCulture));
                    break;
                case "sheet":
                    f = ST_OnOff.e(v.d);
                    break;
                case "objects":
                    g = ST_OnOff.e(v.d);
                    break;
                case "scenarios":
                    h = ST_OnOff.e(v.d);
                    break;
                case "formatCells":
                    i = ST_OnOff.e(v.d);
                    break;
                case "formatColumns":
                    j = ST_OnOff.e(v.d);
                    break;
                case "formatRows":
                    k = ST_OnOff.e(v.d);
                    break;
                case "insertColumns":
                    l = ST_OnOff.e(v.d);
                    break;
                case "insertRows":
                    m = ST_OnOff.e(v.d);
                    break;
                case "insertHyperlinks":
                    n = ST_OnOff.e(v.d);
                    break;
                case "deleteColumns":
                    o = ST_OnOff.e(v.d);
                    break;
                case "deleteRows":
                    p = ST_OnOff.e(v.d);
                    break;
                case "selectLockedCells":
                    q = ST_OnOff.e(v.d);
                    break;
                case "sort":
                    r = ST_OnOff.e(v.d);
                    break;
                case "autoFilter":
                    s = ST_OnOff.e(v.d);
                    break;
                case "pivotTables":
                    t = ST_OnOff.e(v.d);
                    break;
                case "selectUnlockedCells":
                    u = ST_OnOff.e(v.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u
        };
    }
    static adn(a, b = null, c = null, d = null, e = Nullable$1.toNullable(Number_$type, null), f = false, g = false, h = false, i = true, j = true, k = true, l = true, m = true, n = true, o = true, p = true, q = false, r = true, s = true, t = true, u = false) {
        a.ad.p(SpreadsheetMLMain.ow, null);
        let v;
        v = b;
        a.ad.h("algorithmName", v);
        v = c;
        a.ad.h("hashValue", v);
        v = d;
        a.ad.h("saltValue", v);
        if (nullableNotEquals(e, null)) {
            v = e.value.toString();
            a.ad.h("spinCount", v);
        }
        if (f != false) {
            v = ST_OnOff.g(f);
            a.ad.h("sheet", v);
            if (g != false) {
                v = ST_OnOff.g(g);
                a.ad.h("objects", v);
            }
            if (h != false) {
                v = ST_OnOff.g(h);
                a.ad.h("scenarios", v);
            }
        }
        if (i != true) {
            v = ST_OnOff.g(i);
            a.ad.h("formatCells", v);
        }
        if (j != true) {
            v = ST_OnOff.g(j);
            a.ad.h("formatColumns", v);
        }
        if (k != true) {
            v = ST_OnOff.g(k);
            a.ad.h("formatRows", v);
        }
        if (l != true) {
            v = ST_OnOff.g(l);
            a.ad.h("insertColumns", v);
        }
        if (m != true) {
            v = ST_OnOff.g(m);
            a.ad.h("insertRows", v);
        }
        if (n != true) {
            v = ST_OnOff.g(n);
            a.ad.h("insertHyperlinks", v);
        }
        if (o != true) {
            v = ST_OnOff.g(o);
            a.ad.h("deleteColumns", v);
        }
        if (p != true) {
            v = ST_OnOff.g(p);
            a.ad.h("deleteRows", v);
        }
        if (q != false) {
            v = ST_OnOff.g(q);
            a.ad.h("selectLockedCells", v);
        }
        if (r != true) {
            v = ST_OnOff.g(r);
            a.ad.h("sort", v);
        }
        if (s != true) {
            v = ST_OnOff.g(s);
            a.ad.h("autoFilter", v);
        }
        if (t != true) {
            v = ST_OnOff.g(t);
            a.ad.h("pivotTables", v);
        }
        if (u != false) {
            v = ST_OnOff.g(u);
            a.ad.h("selectUnlockedCells", v);
        }
    }
    static x2(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static ado(a) {
        a.ad.p(SpreadsheetMLMain.ox, null);
    }
    static x3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        c = false;
        d = false;
        e = true;
        f = true;
        g = true;
        h = false;
        i = false;
        j = true;
        k = true;
        l = true;
        m = true;
        n = 0;
        o = null;
        p = 64;
        q = 100;
        r = 0;
        s = 0;
        t = 0;
        b = 0;
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case "windowProtection":
                    c = ST_OnOff.e(u.d);
                    break;
                case "showFormulas":
                    d = ST_OnOff.e(u.d);
                    break;
                case "showGridLines":
                    e = ST_OnOff.e(u.d);
                    break;
                case "showRowColHeaders":
                    f = ST_OnOff.e(u.d);
                    break;
                case "showZeros":
                    g = ST_OnOff.e(u.d);
                    break;
                case "rightToLeft":
                    h = ST_OnOff.e(u.d);
                    break;
                case "tabSelected":
                    i = ST_OnOff.e(u.d);
                    break;
                case "showRuler":
                    j = ST_OnOff.e(u.d);
                    break;
                case "showOutlineSymbols":
                    k = ST_OnOff.e(u.d);
                    break;
                case "defaultGridColor":
                    l = ST_OnOff.e(u.d);
                    break;
                case "showWhiteSpace":
                    m = ST_OnOff.e(u.d);
                    break;
                case "view":
                    n = XmlNamespaceDefinitionBase.b(ST_SheetViewType_$type, u.d, n);
                    break;
                case "topLeftCell":
                    o = u.d;
                    break;
                case "colorId":
                    p = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "zoomScale":
                    q = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "zoomScaleNormal":
                    r = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "zoomScaleSheetLayoutView":
                    s = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "zoomScalePageLayoutView":
                    t = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                case "workbookViewId":
                    b = parseUInt32_1(u.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static adp(a, b, c = false, d = false, e = true, f = true, g = true, h = false, i = false, j = true, k = true, l = true, m = true, n = 0, o = null, p = 64, q = 100, r = 0, s = 0, t = 0) {
        a.ad.p(SpreadsheetMLMain.oy, null);
        let u;
        if (c != false) {
            u = ST_OnOff.g(c);
            a.ad.h("windowProtection", u);
        }
        if (d != false) {
            u = ST_OnOff.g(d);
            a.ad.h("showFormulas", u);
        }
        if (e != true) {
            u = ST_OnOff.g(e);
            a.ad.h("showGridLines", u);
        }
        if (f != true) {
            u = ST_OnOff.g(f);
            a.ad.h("showRowColHeaders", u);
        }
        if (g != true) {
            u = ST_OnOff.g(g);
            a.ad.h("showZeros", u);
        }
        if (h != false) {
            u = ST_OnOff.g(h);
            a.ad.h("rightToLeft", u);
        }
        if (i != false) {
            u = ST_OnOff.g(i);
            a.ad.h("tabSelected", u);
        }
        if (j != true) {
            u = ST_OnOff.g(j);
            a.ad.h("showRuler", u);
        }
        if (k != true) {
            u = ST_OnOff.g(k);
            a.ad.h("showOutlineSymbols", u);
        }
        if (l != true) {
            u = ST_OnOff.g(l);
            a.ad.h("defaultGridColor", u);
        }
        if (m != true) {
            u = ST_OnOff.g(m);
            a.ad.h("showWhiteSpace", u);
        }
        if (n != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_SheetViewType_$type, n);
            a.ad.h("view", u);
        }
        u = o;
        a.ad.h("topLeftCell", u);
        if (p != 64) {
            u = p.toString();
            a.ad.h("colorId", u);
        }
        if (q != 100) {
            u = q.toString();
            a.ad.h("zoomScale", u);
        }
        if (r != 0) {
            u = r.toString();
            a.ad.h("zoomScaleNormal", u);
        }
        if (s != 0) {
            u = s.toString();
            a.ad.h("zoomScaleSheetLayoutView", u);
        }
        if (t != 0) {
            u = t.toString();
            a.ad.h("zoomScalePageLayoutView", u);
        }
        u = b.toString();
        a.ad.h("workbookViewId", u);
    }
    static x4(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static adq(a) {
        a.ad.p(SpreadsheetMLMain.oz, null);
    }
    static x5(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static adr(a) {
        a.ad.p(SpreadsheetMLMain.pv, null);
    }
    static x6(a, b, c, d, e, f, g, h) {
        c = false;
        d = 0;
        b = null;
        e = null;
        f = Nullable$1.toNullable(Number_$type, null);
        g = 0;
        h = Nullable$1.toNullable(Number_$type, null);
        for (let i of fromEnum(a.ab.u)) {
            switch (i.a.e(a.d)) {
                case "descending":
                    c = ST_OnOff.e(i.d);
                    break;
                case "sortBy":
                    d = XmlNamespaceDefinitionBase.b(ST_SortBy_$type, i.d, d);
                    break;
                case "ref":
                    b = i.d;
                    break;
                case "customList":
                    e = i.d;
                    break;
                case "dxfId":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(i.d, CultureInfo.invariantCulture));
                    break;
                case "iconSet":
                    g = XmlNamespaceDefinitionBase.b(ST_IconSetType_$type, i.d, g);
                    break;
                case "iconId":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(i.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        if (g <= 16) {
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h
        };
    }
    static ads(a, b, c = false, d = 0, e = null, f = Nullable$1.toNullable(Number_$type, null), g = 0, h = Nullable$1.toNullable(Number_$type, null)) {
        if (g <= 16) {
            SpreadsheetMLMain.adt(a, SpreadsheetMLMain.p1, null, b, c, d, e, f, g, h);
        }
        else {
            a.ad.g([new AlternateContentChoice(0, SpreadsheetML2009Main.an, () => SpreadsheetMLMain.adt(a, SpreadsheetML2009Main.cl, null, b, c, d, e, f, g, h))]);
        }
    }
    static adt(a, b, c, d, e = false, f = 0, g = null, h = Nullable$1.toNullable(Number_$type, null), i = 0, j = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(b, c);
        let k;
        if (e != false) {
            k = ST_OnOff.g(e);
            a.ad.h("descending", k);
        }
        if (f != 0) {
            k = XmlNamespaceDefinitionBase.f(ST_SortBy_$type, f);
            a.ad.h("sortBy", k);
        }
        k = d;
        a.ad.h("ref", k);
        k = g;
        a.ad.h("customList", k);
        if (nullableNotEquals(h, null)) {
            k = h.value.toString();
            a.ad.h("dxfId", k);
        }
        if (i != 0) {
            k = XmlNamespaceDefinitionBase.f(ST_IconSetType_$type, i);
            a.ad.h("iconSet", k);
        }
        if (nullableNotEquals(j, null)) {
            k = j.value.toString();
            a.ad.h("iconId", k);
        }
        a.ad.k();
    }
    static x7(a, b, c, d, e) {
        c = false;
        d = false;
        e = 0;
        b = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "columnSort":
                    c = ST_OnOff.e(f.d);
                    break;
                case "caseSensitive":
                    d = ST_OnOff.e(f.d);
                    break;
                case "sortMethod":
                    e = XmlNamespaceDefinitionBase.b(ST_SortMethod_$type, f.d, e);
                    break;
                case "ref":
                    b = f.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static adu(a, b, c = false, d = false, e = 0) {
        a.ad.p(SpreadsheetMLMain.p3, null);
        let f;
        if (c != false) {
            f = ST_OnOff.g(c);
            a.ad.h("columnSort", f);
        }
        if (d != false) {
            f = ST_OnOff.g(d);
            a.ad.h("caseSensitive", f);
        }
        if (e != 0) {
            f = XmlNamespaceDefinitionBase.f(ST_SortMethod_$type, e);
            a.ad.h("sortMethod", f);
        }
        f = b;
        a.ad.h("ref", f);
    }
    static x8(a, b, c) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        for (let d of fromEnum(a.ab.u)) {
            switch (d.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                case "uniqueCount":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c
        };
    }
    static adv(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.p7, null);
        let d;
        if (nullableNotEquals(b, null)) {
            d = b.value.toString();
            a.ad.h("count", d);
        }
        if (nullableNotEquals(c, null)) {
            d = c.value.toString();
            a.ad.h("uniqueCount", d);
        }
    }
    static x9(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.p8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static adw(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.p8, b);
    }
    static ya(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "position":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static adx(a, b) {
        a.ad.p(SpreadsheetMLMain.qc, null);
        let c;
        c = b.toString();
        a.ad.h("position", c);
    }
    static yb(a, b) {
        let c = SpreadsheetMLMain.uq(a, SpreadsheetMLMain.qe, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static ady(a, b = true) {
        SpreadsheetMLMain.aab(a, SpreadsheetMLMain.qe, b);
    }
    static yc(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static adz(a) {
        a.ad.p(SpreadsheetMLMain.qg, null);
        let b = a.d._z;
        a.ad.l(SpreadsheetMLMain.ao);
    }
    static yd(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = parseNumber(c.d, CultureInfo.invariantCulture);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ad0(a, b) {
        a.ad.p(SpreadsheetMLMain.qm, null);
        let c;
        c = b.toString();
        a.ad.h("val", c);
    }
    static ye(a, b, c, d, e, f) {
        let g = SpreadsheetMLMain.us(a, SpreadsheetMLMain.qp, b, c, d, e, f);
        b = g.p2;
        c = g.p3;
        d = g.p4;
        e = g.p5;
        f = g.p6;
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static ad1(a, b, c, d, e, f) {
        SpreadsheetMLMain.aad(a, SpreadsheetMLMain.qp, b, c, d, e, f);
    }
    static yf(a, b, c, d, e, f, g, h, i, j, k, l, m) {
        b = 0;
        c = null;
        d = null;
        e = 0;
        f = null;
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = null;
        l = null;
        m = null;
        for (let n of fromEnum(a.ab.u)) {
            switch (n.a.e(a.d)) {
                case "id":
                    b = parseUInt32_1(n.d, CultureInfo.invariantCulture);
                    break;
                case "uniqueName":
                    c = n.d;
                    break;
                case "name":
                    d = n.d;
                    break;
                case "totalsRowFunction":
                    e = XmlNamespaceDefinitionBase.b(ST_TotalsRowFunction_$type, n.d, e);
                    break;
                case "totalsRowLabel":
                    f = n.d;
                    break;
                case "queryTableFieldId":
                    g = Nullable$1.toNullable(Number_$type, parseUInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                case "headerRowDxfId":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                case "dataDxfId":
                    i = Nullable$1.toNullable(Number_$type, parseUInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                case "totalsRowDxfId":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(n.d, CultureInfo.invariantCulture));
                    break;
                case "headerRowCellStyle":
                    k = n.d;
                    break;
                case "dataCellStyle":
                    l = n.d;
                    break;
                case "totalsRowCellStyle":
                    m = n.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m
        };
    }
    static ad2(a, b, c = null, d = null, e = 0, f = null, g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = null, l = null, m = null) {
        a.ad.p(SpreadsheetMLMain.qt, null);
        let n;
        n = b.toString();
        a.ad.h("id", n);
        n = c;
        a.ad.h("uniqueName", n);
        n = d;
        a.ad.h("name", n);
        if (e != 0) {
            n = XmlNamespaceDefinitionBase.f(ST_TotalsRowFunction_$type, e);
            a.ad.h("totalsRowFunction", n);
        }
        n = f;
        a.ad.h("totalsRowLabel", n);
        if (nullableNotEquals(g, null)) {
            n = g.value.toString();
            a.ad.h("queryTableFieldId", n);
        }
        if (nullableNotEquals(h, null)) {
            n = h.value.toString();
            a.ad.h("headerRowDxfId", n);
        }
        if (nullableNotEquals(i, null)) {
            n = i.value.toString();
            a.ad.h("dataDxfId", n);
        }
        if (nullableNotEquals(j, null)) {
            n = j.value.toString();
            a.ad.h("totalsRowDxfId", n);
        }
        n = k;
        a.ad.h("headerRowCellStyle", n);
        n = l;
        a.ad.h("dataCellStyle", n);
        n = m;
        a.ad.h("totalsRowCellStyle", n);
    }
    static yg(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ad3(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.qu, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static yh(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) {
        b = 0;
        c = null;
        d = null;
        e = null;
        f = null;
        g = 0;
        h = 1;
        i = false;
        j = false;
        k = 0;
        l = true;
        m = false;
        n = Nullable$1.toNullable(Number_$type, null);
        o = Nullable$1.toNullable(Number_$type, null);
        p = Nullable$1.toNullable(Number_$type, null);
        q = Nullable$1.toNullable(Number_$type, null);
        r = Nullable$1.toNullable(Number_$type, null);
        s = Nullable$1.toNullable(Number_$type, null);
        t = null;
        u = null;
        v = null;
        w = Nullable$1.toNullable(Number_$type, null);
        for (let x of fromEnum(a.ab.u)) {
            switch (x.a.e(a.d)) {
                case "id":
                    b = parseUInt32_1(x.d, CultureInfo.invariantCulture);
                    break;
                case "name":
                    c = x.d;
                    break;
                case "displayName":
                    d = x.d;
                    break;
                case "comment":
                    e = x.d;
                    break;
                case "ref":
                    f = x.d;
                    break;
                case "tableType":
                    g = XmlNamespaceDefinitionBase.b(ST_TableType_$type, x.d, g);
                    break;
                case "headerRowCount":
                    h = parseUInt32_1(x.d, CultureInfo.invariantCulture);
                    break;
                case "insertRow":
                    i = ST_OnOff.e(x.d);
                    break;
                case "insertRowShift":
                    j = ST_OnOff.e(x.d);
                    break;
                case "totalsRowCount":
                    k = parseUInt32_1(x.d, CultureInfo.invariantCulture);
                    break;
                case "totalsRowShown":
                    l = ST_OnOff.e(x.d);
                    break;
                case "published":
                    m = ST_OnOff.e(x.d);
                    break;
                case "headerRowDxfId":
                    n = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "dataDxfId":
                    o = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "totalsRowDxfId":
                    p = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "headerRowBorderDxfId":
                    q = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "tableBorderDxfId":
                    r = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "totalsRowBorderDxfId":
                    s = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                case "headerRowCellStyle":
                    t = x.d;
                    break;
                case "dataCellStyle":
                    u = x.d;
                    break;
                case "totalsRowCellStyle":
                    v = x.d;
                    break;
                case "connectionId":
                    w = Nullable$1.toNullable(Number_$type, parseUInt32_1(x.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t,
            p20: u,
            p21: v,
            p22: w
        };
    }
    static ad4(a, b, c, d, e, f, g = 0, h = 1, i = false, j = false, k = 0, l = true, m = false, n = Nullable$1.toNullable(Number_$type, null), o = Nullable$1.toNullable(Number_$type, null), p = Nullable$1.toNullable(Number_$type, null), q = Nullable$1.toNullable(Number_$type, null), r = Nullable$1.toNullable(Number_$type, null), s = Nullable$1.toNullable(Number_$type, null), t = null, u = null, v = null, w = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.qq, null);
        let x;
        x = b.toString();
        a.ad.h("id", x);
        x = c;
        a.ad.h("name", x);
        x = d;
        a.ad.h("displayName", x);
        x = e;
        a.ad.h("comment", x);
        x = f;
        a.ad.h("ref", x);
        if (g != 0) {
            x = XmlNamespaceDefinitionBase.f(ST_TableType_$type, g);
            a.ad.h("tableType", x);
        }
        if (h != 1) {
            x = h.toString();
            a.ad.h("headerRowCount", x);
        }
        if (i != false) {
            x = ST_OnOff.g(i);
            a.ad.h("insertRow", x);
        }
        if (j != false) {
            x = ST_OnOff.g(j);
            a.ad.h("insertRowShift", x);
        }
        if (k != 0) {
            x = k.toString();
            a.ad.h("totalsRowCount", x);
        }
        if (l != true) {
            x = ST_OnOff.g(l);
            a.ad.h("totalsRowShown", x);
        }
        if (m != false) {
            x = ST_OnOff.g(m);
            a.ad.h("published", x);
        }
        if (nullableNotEquals(n, null)) {
            x = n.value.toString();
            a.ad.h("headerRowDxfId", x);
        }
        if (nullableNotEquals(o, null)) {
            x = o.value.toString();
            a.ad.h("dataDxfId", x);
        }
        if (nullableNotEquals(p, null)) {
            x = p.value.toString();
            a.ad.h("totalsRowDxfId", x);
        }
        if (nullableNotEquals(q, null)) {
            x = q.value.toString();
            a.ad.h("headerRowBorderDxfId", x);
        }
        if (nullableNotEquals(r, null)) {
            x = r.value.toString();
            a.ad.h("tableBorderDxfId", x);
        }
        if (nullableNotEquals(s, null)) {
            x = s.value.toString();
            a.ad.h("totalsRowBorderDxfId", x);
        }
        x = t;
        a.ad.h("headerRowCellStyle", x);
        x = u;
        a.ad.h("dataCellStyle", x);
        x = v;
        a.ad.h("totalsRowCellStyle", x);
        if (nullableNotEquals(w, null)) {
            x = w.value.toString();
            a.ad.h("connectionId", x);
        }
    }
    static yi(a, b) {
        b = null;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case OfficeDocumentRelationships.ar:
                    b = c.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ad5(a, b = null) {
        a.ad.p(SpreadsheetMLMain.qv, null);
        let c;
        c = b;
        a.ad.h(OfficeDocumentRelationships.ar, c);
    }
    static yj(a, b) {
        b = Nullable$1.toNullable(Number_$type, null);
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(c.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ad6(a, b = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.qw, null);
        let c;
        if (nullableNotEquals(b, null)) {
            c = b.value.toString();
            a.ad.h("count", c);
        }
    }
    static yk(a, b, c, d, e) {
        b = null;
        c = true;
        d = true;
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "name":
                    b = f.d;
                    break;
                case "pivot":
                    c = ST_OnOff.e(f.d);
                    break;
                case "table":
                    d = ST_OnOff.e(f.d);
                    break;
                case "count":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static ad7(a, b, c = true, d = true, e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.qx, null);
        let f;
        f = b;
        a.ad.h("name", f);
        if (c != true) {
            f = ST_OnOff.g(c);
            a.ad.h("pivot", f);
        }
        if (d != true) {
            f = ST_OnOff.g(d);
            a.ad.h("table", f);
        }
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("count", f);
        }
    }
    static yl(a, b, c, d) {
        b = 0;
        c = 1;
        d = Nullable$1.toNullable(Number_$type, null);
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "type":
                    b = XmlNamespaceDefinitionBase.b(ST_TableStyleType_$type, e.d, b);
                    break;
                case "size":
                    c = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                    break;
                case "dxfId":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static ad8(a, b, c = 1, d = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.qy, null);
        let e;
        e = XmlNamespaceDefinitionBase.f(ST_TableStyleType_$type, b);
        a.ad.h("type", e);
        if (c != 1) {
            e = c.toString();
            a.ad.h("size", e);
        }
        if (nullableNotEquals(d, null)) {
            e = d.value.toString();
            a.ad.h("dxfId", e);
        }
    }
    static ym(a, b, c, d, e, f) {
        b = null;
        c = Nullable$1.toNullable(Boolean_$type, null);
        d = Nullable$1.toNullable(Boolean_$type, null);
        e = Nullable$1.toNullable(Boolean_$type, null);
        f = Nullable$1.toNullable(Boolean_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "name":
                    b = g.d;
                    break;
                case "showFirstColumn":
                    c = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "showLastColumn":
                    d = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "showRowStripes":
                    e = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                case "showColumnStripes":
                    f = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(g.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static ad9(a, b, c, d, e, f) {
        a.ad.p(SpreadsheetMLMain.qz, null);
        let g;
        g = b;
        a.ad.h("name", g);
        if (nullableNotEquals(c, null)) {
            g = ST_OnOff.g(c.value);
            a.ad.h("showFirstColumn", g);
        }
        if (nullableNotEquals(d, null)) {
            g = ST_OnOff.g(d.value);
            a.ad.h("showLastColumn", g);
        }
        if (nullableNotEquals(e, null)) {
            g = ST_OnOff.g(e.value);
            a.ad.h("showRowStripes", g);
        }
        if (nullableNotEquals(f, null)) {
            g = ST_OnOff.g(f.value);
            a.ad.h("showColumnStripes", g);
        }
    }
    static yn(a, b, c, d) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = null;
        d = null;
        for (let e of fromEnum(a.ab.u)) {
            switch (e.a.e(a.d)) {
                case "count":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(e.d, CultureInfo.invariantCulture));
                    break;
                case "defaultTableStyle":
                    c = e.d;
                    break;
                case "defaultPivotStyle":
                    d = e.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d
        };
    }
    static aea(a, b = Nullable$1.toNullable(Number_$type, null), c = null, d = null) {
        a.ad.p(SpreadsheetMLMain.q0, null);
        let e;
        if (nullableNotEquals(b, null)) {
            e = b.value.toString();
            a.ad.h("count", e);
        }
        e = c;
        a.ad.h("defaultTableStyle", e);
        e = d;
        a.ad.h("defaultPivotStyle", e);
    }
    static yo(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.qn, b);
        b = c.p2;
        b = SpreadsheetMLMain.rv(b);
        return {
            p1: b
        };
    }
    static aeb(a, b) {
        b = SpreadsheetMLMain.hg(b);
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.qn, null, b);
    }
    static yp(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aec(a) {
        a.ad.p(SpreadsheetMLMain.q4, null);
    }
    static yr(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.re, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aee(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.re, b);
    }
    static yq(a, b, c, d, e) {
        c = true;
        d = false;
        b = 0;
        e = Nullable$1.toNullable(Number_$type, null);
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "top":
                    c = ST_OnOff.e(f.d);
                    break;
                case "percent":
                    d = ST_OnOff.e(f.d);
                    break;
                case "val":
                    b = parseNumber(f.d, CultureInfo.invariantCulture);
                    break;
                case "filterVal":
                    e = Nullable$1.toNullable(Number_$type, parseNumber(f.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aed(a, b, c = true, d = false, e = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.rg, null);
        let f;
        if (c != true) {
            f = ST_OnOff.g(c);
            a.ad.h("top", f);
        }
        if (d != false) {
            f = ST_OnOff.g(d);
            a.ad.h("percent", f);
        }
        f = b.toString();
        a.ad.h("val", f);
        if (nullableNotEquals(e, null)) {
            f = e.value.toString();
            a.ad.h("filterVal", f);
        }
    }
    static ys(a, b, c) {
        let d = SpreadsheetMLMain.uv(a, SpreadsheetMLMain.rm, b, c);
        b = d.p2;
        c = d.p3;
        return {
            p1: b,
            p2: c
        };
    }
    static aef(a, b, c = false) {
        SpreadsheetMLMain.aag(a, SpreadsheetMLMain.rm, b, c);
    }
    static yt(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_UnderlineValues_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aeg(a, b = 0) {
        a.ad.p(SpreadsheetMLMain.rt, null);
        let c;
        if (b != 0) {
            c = XmlNamespaceDefinitionBase.f(ST_UnderlineValues_$type, b);
            a.ad.h("val", c);
        }
    }
    static yu(a, b) {
        let c = XmlNamespaceDefinitionBase.u(a, SpreadsheetMLMain.r3, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aeh(a, b) {
        XmlNamespaceDefinitionBase.ai(a, SpreadsheetMLMain.r3, null, b);
    }
    static aei(a, b, c) {
        a.ad.r("v");
        if (c) {
            XmlNamespace.as(a.ad);
        }
        a.ad.u(b);
    }
    static yv(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "val":
                    b = XmlNamespaceDefinitionBase.b(ST_VerticalAlignRun_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static aej(a, b) {
        a.ad.p(SpreadsheetMLMain.r7, null);
        let c;
        c = XmlNamespaceDefinitionBase.f(ST_VerticalAlignRun_$type, b);
        a.ad.h("val", c);
    }
    static yw(a, b) {
        let c = SpreadsheetMLMain.ur(a, SpreadsheetMLMain.r8, b);
        b = c.p2;
        return {
            p1: b
        };
    }
    static aek(a, b = 0) {
        SpreadsheetMLMain.aac(a, SpreadsheetMLMain.r8, b);
    }
    static yx(a, b) {
        b = 0;
        for (let c of fromEnum(a.ab.u)) {
            switch (c.a.e(a.d)) {
                case "conformance":
                    b = XmlNamespaceDefinitionBase.b(ST_ConformanceClass_$type, c.d, b);
                    break;
                default: break;
            }
        }
        return {
            p1: b
        };
    }
    static ael(a, b = 0) {
        a.ad.p(SpreadsheetMLMain.sj, null);
        a.ad.l(OfficeDocumentRelationships.an);
        a.ad.l(SpreadsheetMLMain.ao);
        let c = XmlNamespaceDefinitionBase.g(ST_ConformanceClass_$type, b, 0, false);
        a.ad.h("conformance", c);
    }
    static yy(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        b = false;
        c = 0;
        d = true;
        e = false;
        f = false;
        g = true;
        h = false;
        i = true;
        j = 0;
        k = null;
        l = false;
        m = false;
        n = false;
        o = false;
        p = false;
        q = true;
        r = false;
        s = Nullable$1.toNullable(Number_$type, null);
        t = true;
        for (let u of fromEnum(a.ab.u)) {
            switch (u.a.e(a.d)) {
                case "date1904":
                    b = ST_OnOff.e(u.d);
                    break;
                case "showObjects":
                    c = XmlNamespaceDefinitionBase.b(ST_Objects_$type, u.d, c);
                    break;
                case "showBorderUnselectedTables":
                    d = ST_OnOff.e(u.d);
                    break;
                case "filterPrivacy":
                    e = ST_OnOff.e(u.d);
                    break;
                case "promptedSolutions":
                    f = ST_OnOff.e(u.d);
                    break;
                case "showInkAnnotation":
                    g = ST_OnOff.e(u.d);
                    break;
                case "backupFile":
                    h = ST_OnOff.e(u.d);
                    break;
                case "saveExternalLinkValues":
                    i = ST_OnOff.e(u.d);
                    break;
                case "updateLinks":
                    j = XmlNamespaceDefinitionBase.b(ST_UpdateLinks_$type, u.d, j);
                    break;
                case "codeName":
                    k = u.d;
                    break;
                case "hidePivotFieldList":
                    l = ST_OnOff.e(u.d);
                    break;
                case "showPivotChartFilter":
                    m = ST_OnOff.e(u.d);
                    break;
                case "allowRefreshQuery":
                    n = ST_OnOff.e(u.d);
                    break;
                case "publishItems":
                    o = ST_OnOff.e(u.d);
                    break;
                case "checkCompatibility":
                    p = ST_OnOff.e(u.d);
                    break;
                case "autoCompressPictures":
                    q = ST_OnOff.e(u.d);
                    break;
                case "refreshAllConnections":
                    r = ST_OnOff.e(u.d);
                    break;
                case "defaultThemeVersion":
                    s = Nullable$1.toNullable(Number_$type, parseUInt32_1(u.d, CultureInfo.invariantCulture));
                    break;
                case "dateCompatibility":
                    t = ST_OnOff.e(u.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n,
            p14: o,
            p15: p,
            p16: q,
            p17: r,
            p18: s,
            p19: t
        };
    }
    static aem(a, b = false, c = 0, d = true, e = false, f = false, g = true, h = false, i = true, j = 0, k = null, l = false, m = false, n = false, o = false, p = false, q = true, r = false, s = Nullable$1.toNullable(Number_$type, null), t = true) {
        a.ad.p(SpreadsheetMLMain.so, null);
        let u;
        if (b != false) {
            u = ST_OnOff.g(b);
            a.ad.h("date1904", u);
        }
        if (c != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_Objects_$type, c);
            a.ad.h("showObjects", u);
        }
        if (d != true) {
            u = ST_OnOff.g(d);
            a.ad.h("showBorderUnselectedTables", u);
        }
        if (e != false) {
            u = ST_OnOff.g(e);
            a.ad.h("filterPrivacy", u);
        }
        if (f != false) {
            u = ST_OnOff.g(f);
            a.ad.h("promptedSolutions", u);
        }
        if (g != true) {
            u = ST_OnOff.g(g);
            a.ad.h("showInkAnnotation", u);
        }
        if (h != false) {
            u = ST_OnOff.g(h);
            a.ad.h("backupFile", u);
        }
        if (i != true) {
            u = ST_OnOff.g(i);
            a.ad.h("saveExternalLinkValues", u);
        }
        if (j != 0) {
            u = XmlNamespaceDefinitionBase.f(ST_UpdateLinks_$type, j);
            a.ad.h("updateLinks", u);
        }
        if (k != null) {
            u = k;
            a.ad.h("codeName", u);
        }
        if (l != false) {
            u = ST_OnOff.g(l);
            a.ad.h("hidePivotFieldList", u);
        }
        if (m != false) {
            u = ST_OnOff.g(m);
            a.ad.h("showPivotChartFilter", u);
        }
        if (n != false) {
            u = ST_OnOff.g(n);
            a.ad.h("allowRefreshQuery", u);
        }
        if (o != false) {
            u = ST_OnOff.g(o);
            a.ad.h("publishItems", u);
        }
        if (p != false) {
            u = ST_OnOff.g(p);
            a.ad.h("checkCompatibility", u);
        }
        if (q != true) {
            u = ST_OnOff.g(q);
            a.ad.h("autoCompressPictures", u);
        }
        if (r != false) {
            u = ST_OnOff.g(r);
            a.ad.h("refreshAllConnections", u);
        }
        if (nullableNotEquals(s, null)) {
            u = s.value.toString();
            a.ad.h("defaultThemeVersion", u);
        }
        if (t != true) {
            u = ST_OnOff.g(t);
            a.ad.h("dateCompatibility", u);
        }
    }
    static yz(a, b, c, d, e, f) {
        b = false;
        c = false;
        d = false;
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        for (let g of fromEnum(a.ab.u)) {
            switch (g.a.e(a.d)) {
                case "lockStructure":
                    b = ST_OnOff.e(g.d);
                    break;
                case "lockWindows":
                    c = ST_OnOff.e(g.d);
                    break;
                case "lockRevision":
                    d = ST_OnOff.e(g.d);
                    break;
                case "workbookPassword":
                    e = Nullable$1.toNullable(Number_$type, ST_UnsignedShortHex.d(g.d));
                    break;
                case "revisionsPassword":
                    f = Nullable$1.toNullable(Number_$type, ST_UnsignedShortHex.d(g.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f
        };
    }
    static aen(a, b = false, c = false, d = false, e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.sp, null);
        let g;
        if (b != false) {
            g = ST_OnOff.g(b);
            a.ad.h("lockStructure", g);
        }
        if (c != false) {
            g = ST_OnOff.g(c);
            a.ad.h("lockWindows", g);
        }
        if (d != false) {
            g = ST_OnOff.g(d);
            a.ad.h("lockRevision", g);
        }
        if (nullableNotEquals(f, null)) {
            g = new ST_UnsignedShortHex(1, f.value).toString();
            a.ad.h("revisionsPassword", g);
        }
        if (nullableNotEquals(e, null)) {
            g = new ST_UnsignedShortHex(1, e.value).toString();
            a.ad.h("workbookPassword", g);
        }
    }
    static y0(a, b, c, d, e, f, g, h, i, j, k, l) {
        b = false;
        c = false;
        d = false;
        e = null;
        f = null;
        g = null;
        h = Nullable$1.toNullable(Number_$type, null);
        i = null;
        j = null;
        k = null;
        l = Nullable$1.toNullable(Number_$type, null);
        for (let m of fromEnum(a.ab.u)) {
            switch (m.a.e(a.d)) {
                case "lockStructure":
                    b = ST_OnOff.e(m.d);
                    break;
                case "lockWindows":
                    c = ST_OnOff.e(m.d);
                    break;
                case "lockRevision":
                    d = ST_OnOff.e(m.d);
                    break;
                case "revisionsAlgorithmName":
                    e = m.d;
                    break;
                case "revisionsHashValue":
                    f = m.d;
                    break;
                case "revisionsSaltValue":
                    g = m.d;
                    break;
                case "revisionsSpinCount":
                    h = Nullable$1.toNullable(Number_$type, parseUInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                case "workbookAlgorithmName":
                    i = m.d;
                    break;
                case "workbookHashValue":
                    j = m.d;
                    break;
                case "workbookSaltValue":
                    k = m.d;
                    break;
                case "workbookSpinCount":
                    l = Nullable$1.toNullable(Number_$type, parseUInt32_1(m.d, CultureInfo.invariantCulture));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l
        };
    }
    static aeo(a, b = false, c = false, d = false, e = null, f = null, g = null, h = Nullable$1.toNullable(Number_$type, null), i = null, j = null, k = null, l = Nullable$1.toNullable(Number_$type, null)) {
        a.ad.p(SpreadsheetMLMain.sp, null);
        let m;
        if (b != false) {
            m = ST_OnOff.g(b);
            a.ad.h("lockStructure", m);
        }
        if (c != false) {
            m = ST_OnOff.g(c);
            a.ad.h("lockWindows", m);
        }
        if (d != false) {
            m = ST_OnOff.g(d);
            a.ad.h("lockRevision", m);
        }
        if (e != null) {
            m = e;
            a.ad.h("revisionsAlgorithmName", m);
        }
        if (f != null) {
            m = f.toString();
            a.ad.h("revisionsHashValue", m);
        }
        if (g != null) {
            m = g.toString();
            a.ad.h("revisionsSaltValue", m);
        }
        if (nullableNotEquals(h, null)) {
            m = h.value.toString();
            a.ad.h("revisionsSpinCount", m);
        }
        if (i != null) {
            m = i;
            a.ad.h("workbookAlgorithmName", m);
        }
        if (j != null) {
            m = j.toString();
            a.ad.h("workbookHashValue", m);
        }
        if (k != null) {
            m = k.toString();
            a.ad.h("workbookSaltValue", m);
        }
        if (nullableNotEquals(l, null)) {
            m = l.value.toString();
            a.ad.h("workbookSpinCount", m);
        }
    }
    static y1(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = 0;
        c = false;
        d = true;
        e = true;
        f = true;
        g = Nullable$1.toNullable(Number_$type, null);
        h = Nullable$1.toNullable(Number_$type, null);
        i = Nullable$1.toNullable(Number_$type, null);
        j = Nullable$1.toNullable(Number_$type, null);
        k = 600;
        l = 0;
        m = 0;
        n = true;
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "visibility":
                    b = XmlNamespaceDefinitionBase.b(ST_Visibility_$type, o.d, b);
                    break;
                case "minimized":
                    c = ST_OnOff.e(o.d);
                    break;
                case "showHorizontalScroll":
                    d = ST_OnOff.e(o.d);
                    break;
                case "showVerticalScroll":
                    e = ST_OnOff.e(o.d);
                    break;
                case "showSheetTabs":
                    f = ST_OnOff.e(o.d);
                    break;
                case "xWindow":
                    g = Nullable$1.toNullable(Number_$type, parseInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "yWindow":
                    h = Nullable$1.toNullable(Number_$type, parseInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "windowWidth":
                    i = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "windowHeight":
                    j = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "tabRatio":
                    k = parseUInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "firstSheet":
                    l = parseUInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "activeTab":
                    m = parseUInt32_1(o.d, CultureInfo.invariantCulture);
                    break;
                case "autoFilterDateGrouping":
                    n = ST_OnOff.e(o.d);
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static aep(a, b = 0, c = false, d = true, e = true, f = true, g = Nullable$1.toNullable(Number_$type, null), h = Nullable$1.toNullable(Number_$type, null), i = Nullable$1.toNullable(Number_$type, null), j = Nullable$1.toNullable(Number_$type, null), k = 600, l = 0, m = 0, n = true) {
        a.ad.p(SpreadsheetMLMain.ss, null);
        let o;
        if (b != 0) {
            o = XmlNamespaceDefinitionBase.f(ST_Visibility_$type, b);
            a.ad.h("visibility", o);
        }
        if (c != false) {
            o = ST_OnOff.g(c);
            a.ad.h("minimized", o);
        }
        if (d != true) {
            o = ST_OnOff.g(d);
            a.ad.h("showHorizontalScroll", o);
        }
        if (e != true) {
            o = ST_OnOff.g(e);
            a.ad.h("showVerticalScroll", o);
        }
        if (f != true) {
            o = ST_OnOff.g(f);
            a.ad.h("showSheetTabs", o);
        }
        if (nullableNotEquals(g, null)) {
            o = g.value.toString();
            a.ad.h("xWindow", o);
        }
        if (nullableNotEquals(h, null)) {
            o = h.value.toString();
            a.ad.h("yWindow", o);
        }
        if (nullableNotEquals(i, null)) {
            o = i.value.toString();
            a.ad.h("windowWidth", o);
        }
        if (nullableNotEquals(j, null)) {
            o = j.value.toString();
            a.ad.h("windowHeight", o);
        }
        if (k != 600) {
            o = k.toString();
            a.ad.h("tabRatio", o);
        }
        if (l != 0) {
            o = l.toString();
            a.ad.h("firstSheet", o);
        }
        if (m != 0) {
            o = m.toString();
            a.ad.h("activeTab", o);
        }
        if (n != true) {
            o = ST_OnOff.g(n);
            a.ad.h("autoFilterDateGrouping", o);
        }
    }
    static y2(a) {
        for (let b of fromEnum(a.ab.u)) {
            switch (b.a.e(a.d)) {
                default: break;
            }
        }
    }
    static aeq(a) {
        a.ad.p(SpreadsheetMLMain.su, null);
        let b = a.d._z;
        a.ad.l(OfficeDocumentRelationships.an);
        a.ad.l(SpreadsheetMLMain.ao);
    }
    static y3(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        b = Nullable$1.toNullable(Number_$type, null);
        c = Nullable$1.toNullable(Number_$type, null);
        d = Nullable$1.toNullable(Number_$type, null);
        e = Nullable$1.toNullable(Number_$type, null);
        f = Nullable$1.toNullable(Number_$type, null);
        g = false;
        h = false;
        i = Nullable$1.toNullable(Boolean_$type, null);
        j = Nullable$1.toNullable(Boolean_$type, null);
        k = Nullable$1.toNullable(Boolean_$type, null);
        l = Nullable$1.toNullable(Boolean_$type, null);
        m = Nullable$1.toNullable(Boolean_$type, null);
        n = Nullable$1.toNullable(Boolean_$type, null);
        for (let o of fromEnum(a.ab.u)) {
            switch (o.a.e(a.d)) {
                case "numFmtId":
                    b = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "fontId":
                    c = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "fillId":
                    d = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "borderId":
                    e = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "xfId":
                    f = Nullable$1.toNullable(Number_$type, parseUInt32_1(o.d, CultureInfo.invariantCulture));
                    break;
                case "quotePrefix":
                    g = ST_OnOff.e(o.d);
                    break;
                case "pivotButton":
                    h = ST_OnOff.e(o.d);
                    break;
                case "applyNumberFormat":
                    i = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "applyFont":
                    j = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "applyFill":
                    k = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "applyBorder":
                    l = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "applyAlignment":
                    m = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                case "applyProtection":
                    n = Nullable$1.toNullable(Boolean_$type, ST_OnOff.e(o.d));
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e,
            p5: f,
            p6: g,
            p7: h,
            p8: i,
            p9: j,
            p10: k,
            p11: l,
            p12: m,
            p13: n
        };
    }
    static aer(a, b = Nullable$1.toNullable(Number_$type, null), c = Nullable$1.toNullable(Number_$type, null), d = Nullable$1.toNullable(Number_$type, null), e = Nullable$1.toNullable(Number_$type, null), f = Nullable$1.toNullable(Number_$type, null), g = false, h = false, i = Nullable$1.toNullable(Boolean_$type, null), j = Nullable$1.toNullable(Boolean_$type, null), k = Nullable$1.toNullable(Boolean_$type, null), l = Nullable$1.toNullable(Boolean_$type, null), m = Nullable$1.toNullable(Boolean_$type, null), n = Nullable$1.toNullable(Boolean_$type, null)) {
        a.ad.p(SpreadsheetMLMain.sx, null);
        let o;
        if (nullableNotEquals(b, null)) {
            o = b.value.toString();
            a.ad.h("numFmtId", o);
        }
        if (nullableNotEquals(c, null)) {
            o = c.value.toString();
            a.ad.h("fontId", o);
        }
        if (nullableNotEquals(d, null)) {
            o = d.value.toString();
            a.ad.h("fillId", o);
        }
        if (nullableNotEquals(e, null)) {
            o = e.value.toString();
            a.ad.h("borderId", o);
        }
        if (nullableNotEquals(f, null)) {
            o = f.value.toString();
            a.ad.h("xfId", o);
        }
        if (g != false) {
            o = ST_OnOff.g(g);
            a.ad.h("quotePrefix", o);
        }
        if (h != false) {
            o = ST_OnOff.g(h);
            a.ad.h("pivotButton", o);
        }
        if (nullableNotEquals(i, null)) {
            o = ST_OnOff.g(i.value);
            a.ad.h("applyNumberFormat", o);
        }
        if (nullableNotEquals(j, null)) {
            o = ST_OnOff.g(j.value);
            a.ad.h("applyFont", o);
        }
        if (nullableNotEquals(k, null)) {
            o = ST_OnOff.g(k.value);
            a.ad.h("applyFill", o);
        }
        if (nullableNotEquals(l, null)) {
            o = ST_OnOff.g(l.value);
            a.ad.h("applyBorder", o);
        }
        if (nullableNotEquals(m, null)) {
            o = ST_OnOff.g(m.value);
            a.ad.h("applyAlignment", o);
        }
        if (nullableNotEquals(n, null)) {
            o = ST_OnOff.g(n.value);
            a.ad.h("applyProtection", o);
        }
    }
    static y4(a, b, c, d, e) {
        b = 0;
        c = null;
        e = false;
        d = null;
        for (let f of fromEnum(a.ab.u)) {
            switch (f.a.e(a.d)) {
                case "mapId":
                    b = parseUInt32_1(f.d, CultureInfo.invariantCulture);
                    break;
                case "xpath":
                    c = f.d;
                    break;
                case "denormalized":
                    e = ST_OnOff.e(f.d);
                    break;
                case "xmlDataType":
                    d = f.d;
                    break;
                default: break;
            }
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    }
    static aes(a, b, c, d, e = false) {
        a.ad.p(SpreadsheetMLMain.s0, null);
        let f;
        f = b.toString();
        a.ad.h("mapId", f);
        f = c;
        a.ad.h("xpath", f);
        if (e != false) {
            f = ST_OnOff.g(e);
            a.ad.h("denormalized", f);
        }
        f = d;
        a.ad.h("xmlDataType", f);
    }
}
SpreadsheetMLMain.$t = markType(SpreadsheetMLMain, 'SpreadsheetMLMain', XmlNamespaceDefinitionBase.$);
SpreadsheetMLMain.lg = "http://schemas.openxmlformats.org/spreadsheetml/2006/main";
SpreadsheetMLMain.lf = "http://purl.oclc.org/ooxml/spreadsheetml/main";
SpreadsheetMLMain.cj = SpreadsheetMLMain.lf + "/alignment";
SpreadsheetMLMain.co = SpreadsheetMLMain.lf + "/anchor";
SpreadsheetMLMain.cz = SpreadsheetMLMain.lf + "/author";
SpreadsheetMLMain.c1 = SpreadsheetMLMain.lf + "/authors";
SpreadsheetMLMain.c5 = SpreadsheetMLMain.lf + "/autoFilter";
SpreadsheetMLMain.dc = SpreadsheetMLMain.lf + "/b";
SpreadsheetMLMain.dg = SpreadsheetMLMain.lf + "/bgColor";
SpreadsheetMLMain.dj = SpreadsheetMLMain.lf + "/bookViews";
SpreadsheetMLMain.dk = SpreadsheetMLMain.lf + "/border";
SpreadsheetMLMain.dm = SpreadsheetMLMain.lf + "/borders";
SpreadsheetMLMain.dn = SpreadsheetMLMain.lf + "/bottom";
SpreadsheetMLMain.dq = SpreadsheetMLMain.lf + "/brk";
SpreadsheetMLMain.dt = SpreadsheetMLMain.lf + "/c";
SpreadsheetMLMain.d0 = SpreadsheetMLMain.lf + "/calcPr";
SpreadsheetMLMain.d1 = SpreadsheetMLMain.lf + "/calculatedColumnFormula";
SpreadsheetMLMain.d4 = SpreadsheetMLMain.lf + "/cell";
SpreadsheetMLMain.d7 = SpreadsheetMLMain.lf + "/cellStyle";
SpreadsheetMLMain.d8 = SpreadsheetMLMain.lf + "/cellStyles";
SpreadsheetMLMain.d9 = SpreadsheetMLMain.lf + "/cellStyleXfs";
SpreadsheetMLMain.ea = SpreadsheetMLMain.lf + "/cellXfs";
SpreadsheetMLMain.ef = SpreadsheetMLMain.lf + "/cfRule";
SpreadsheetMLMain.eg = SpreadsheetMLMain.lf + "/cfvo";
SpreadsheetMLMain.ei = SpreadsheetMLMain.lf + "/chartsheet";
SpreadsheetMLMain.ep = SpreadsheetMLMain.lf + "/col";
SpreadsheetMLMain.eq = SpreadsheetMLMain.lf + "/colBreaks";
SpreadsheetMLMain.et = SpreadsheetMLMain.lf + "/color";
SpreadsheetMLMain.ex = SpreadsheetMLMain.lf + "/colorScale";
SpreadsheetMLMain.eu = SpreadsheetMLMain.lf + "/colorFilter";
SpreadsheetMLMain.ew = SpreadsheetMLMain.lf + "/colors";
SpreadsheetMLMain.ey = SpreadsheetMLMain.lf + "/cols";
SpreadsheetMLMain.e0 = SpreadsheetMLMain.lf + "/comment";
SpreadsheetMLMain.e2 = SpreadsheetMLMain.lf + "/commentList";
SpreadsheetMLMain.e3 = SpreadsheetMLMain.lf + "/comments";
SpreadsheetMLMain.e6 = SpreadsheetMLMain.lf + "/condense";
SpreadsheetMLMain.e7 = SpreadsheetMLMain.lf + "/conditionalFormatting";
SpreadsheetMLMain.fc = SpreadsheetMLMain.lf + "/control";
SpreadsheetMLMain.fd = SpreadsheetMLMain.lf + "/controlPr";
SpreadsheetMLMain.fe = SpreadsheetMLMain.lf + "/controls";
SpreadsheetMLMain.fj = SpreadsheetMLMain.lf + "/customFilter";
SpreadsheetMLMain.fk = SpreadsheetMLMain.lf + "/customFilters";
SpreadsheetMLMain.fp = SpreadsheetMLMain.lf + "/customSheetView";
SpreadsheetMLMain.fq = SpreadsheetMLMain.lf + "/customSheetViews";
SpreadsheetMLMain.fs = SpreadsheetMLMain.lf + "/customWorkbookView";
SpreadsheetMLMain.ft = SpreadsheetMLMain.lf + "/customWorkbookViews";
SpreadsheetMLMain.fu = SpreadsheetMLMain.lf + "/dataBar";
SpreadsheetMLMain.fx = SpreadsheetMLMain.lf + "/dataValidation";
SpreadsheetMLMain.fy = SpreadsheetMLMain.lf + "/dataValidations";
SpreadsheetMLMain.f1 = SpreadsheetMLMain.lf + "/dateGroupItem";
SpreadsheetMLMain.f4 = SpreadsheetMLMain.lf + "/ddeItem";
SpreadsheetMLMain.f5 = SpreadsheetMLMain.lf + "/ddeItems";
SpreadsheetMLMain.f6 = SpreadsheetMLMain.lf + "/ddeLink";
SpreadsheetMLMain.gg = SpreadsheetMLMain.lf + "/definedName";
SpreadsheetMLMain.gh = SpreadsheetMLMain.lf + "/definedNames";
SpreadsheetMLMain.gq = SpreadsheetMLMain.lf + "/diagonal";
SpreadsheetMLMain.gv = SpreadsheetMLMain.lf + "/dimension";
SpreadsheetMLMain.g1 = SpreadsheetMLMain.lf + "/drawing";
SpreadsheetMLMain.g2 = SpreadsheetMLMain.lf + "/drawingHF";
SpreadsheetMLMain.g5 = SpreadsheetMLMain.lf + "/dxf";
SpreadsheetMLMain.g7 = SpreadsheetMLMain.lf + "/dxfs";
SpreadsheetMLMain.g8 = SpreadsheetMLMain.lf + "/dynamicFilter";
SpreadsheetMLMain.ha = SpreadsheetMLMain.lf + "/end";
SpreadsheetMLMain.hh = SpreadsheetMLMain.lf + "/evenFooter";
SpreadsheetMLMain.hi = SpreadsheetMLMain.lf + "/evenHeader";
SpreadsheetMLMain.hj = SpreadsheetMLMain.lf + "/ext";
SpreadsheetMLMain.hk = SpreadsheetMLMain.lf + "/extend";
SpreadsheetMLMain.hl = SpreadsheetMLMain.lf + "/externalBook";
SpreadsheetMLMain.hm = SpreadsheetMLMain.lf + "/externalLink";
SpreadsheetMLMain.hn = SpreadsheetMLMain.lf + "/externalReference";
SpreadsheetMLMain.ho = SpreadsheetMLMain.lf + "/externalReferences";
SpreadsheetMLMain.hp = SpreadsheetMLMain.lf + "/extLst";
SpreadsheetMLMain.hq = SpreadsheetMLMain.lf + "/f";
SpreadsheetMLMain.hr = SpreadsheetMLMain.lf + "/family";
SpreadsheetMLMain.hs = SpreadsheetMLMain.lf + "/fgColor";
SpreadsheetMLMain.ht = SpreadsheetMLMain.lf + "/fileSharing";
SpreadsheetMLMain.hu = SpreadsheetMLMain.lf + "/fileVersion";
SpreadsheetMLMain.hv = SpreadsheetMLMain.lf + "/fill";
SpreadsheetMLMain.hx = SpreadsheetMLMain.lf + "/fills";
SpreadsheetMLMain.hy = SpreadsheetMLMain.lf + "/filter";
SpreadsheetMLMain.h0 = SpreadsheetMLMain.lf + "/filterColumn";
SpreadsheetMLMain.h3 = SpreadsheetMLMain.lf + "/filters";
SpreadsheetMLMain.h6 = SpreadsheetMLMain.lf + "/firstFooter";
SpreadsheetMLMain.h7 = SpreadsheetMLMain.lf + "/firstHeader";
SpreadsheetMLMain.id = SpreadsheetMLMain.lf + "/font";
SpreadsheetMLMain.ig = SpreadsheetMLMain.lf + "/fonts";
SpreadsheetMLMain.ij = SpreadsheetMLMain.lf + "/format";
SpreadsheetMLMain.ip = SpreadsheetMLMain.lf + "/formats";
SpreadsheetMLMain.iq = SpreadsheetMLMain.lf + "/formula";
SpreadsheetMLMain.ir = SpreadsheetMLMain.lf + "/formula1";
SpreadsheetMLMain.is = SpreadsheetMLMain.lf + "/formula2";
SpreadsheetMLMain.ix = SpreadsheetMLMain.lf + "/gradientFill";
SpreadsheetMLMain.i4 = SpreadsheetMLMain.lf + "/headerFooter";
SpreadsheetMLMain.jg = SpreadsheetMLMain.lf + "/horizontal";
SpreadsheetMLMain.jm = SpreadsheetMLMain.lf + "/hyperlink";
SpreadsheetMLMain.jn = SpreadsheetMLMain.lf + "/hyperlinks";
SpreadsheetMLMain.jo = SpreadsheetMLMain.lf + "/i";
SpreadsheetMLMain.jq = SpreadsheetMLMain.lf + "/iconFilter";
SpreadsheetMLMain.js = SpreadsheetMLMain.lf + "/iconSet";
SpreadsheetMLMain.j1 = SpreadsheetMLMain.lf + "/indexedColors";
SpreadsheetMLMain.b7 = SpreadsheetMLMain.lf + "/is";
SpreadsheetMLMain.kc = SpreadsheetMLMain.lf + "/left";
SpreadsheetMLMain.ke = SpreadsheetMLMain.lf + "/legacyDrawing";
SpreadsheetMLMain.kf = SpreadsheetMLMain.lf + "/legacyDrawingHF";
SpreadsheetMLMain.k4 = SpreadsheetMLMain.lf + "/mergeCell";
SpreadsheetMLMain.k5 = SpreadsheetMLMain.lf + "/mergeCells";
SpreadsheetMLMain.ld = SpreadsheetMLMain.lf + "/name";
SpreadsheetMLMain.lh = SpreadsheetMLMain.lf + "/numFmt";
SpreadsheetMLMain.lj = SpreadsheetMLMain.lf + "/numFmts";
SpreadsheetMLMain.ll = SpreadsheetMLMain.lf + "/oddFooter";
SpreadsheetMLMain.lm = SpreadsheetMLMain.lf + "/oddHeader";
SpreadsheetMLMain.lo = SpreadsheetMLMain.lf + "/oleItem";
SpreadsheetMLMain.lp = SpreadsheetMLMain.lf + "/oleItems";
SpreadsheetMLMain.lq = SpreadsheetMLMain.lf + "/oleLink";
SpreadsheetMLMain.lu = SpreadsheetMLMain.lf + "/outline";
SpreadsheetMLMain.lz = SpreadsheetMLMain.lf + "/outlinePr";
SpreadsheetMLMain.l1 = SpreadsheetMLMain.lf + "/pageMargins";
SpreadsheetMLMain.l3 = SpreadsheetMLMain.lf + "/pageSetup";
SpreadsheetMLMain.l4 = SpreadsheetMLMain.lf + "/pageSetUpPr";
SpreadsheetMLMain.l5 = SpreadsheetMLMain.lf + "/pane";
SpreadsheetMLMain.mb = SpreadsheetMLMain.lf + "/patternFill";
SpreadsheetMLMain.mh = SpreadsheetMLMain.lf + "/picture";
SpreadsheetMLMain.mk = SpreadsheetMLMain.lf + "/pivotCache";
SpreadsheetMLMain.ml = SpreadsheetMLMain.lf + "/pivotCaches";
SpreadsheetMLMain.mm = SpreadsheetMLMain.lf + "/pivotTableDefinition";
SpreadsheetMLMain.ms = SpreadsheetMLMain.lf + "/printOptions";
SpreadsheetMLMain.my = SpreadsheetMLMain.lf + "/protectedRange";
SpreadsheetMLMain.mz = SpreadsheetMLMain.lf + "/protectedRanges";
SpreadsheetMLMain.m0 = SpreadsheetMLMain.lf + "/protection";
SpreadsheetMLMain.m7 = SpreadsheetMLMain.lf + "/r";
SpreadsheetMLMain.nv = SpreadsheetMLMain.lf + "/rFont";
SpreadsheetMLMain.nx = SpreadsheetMLMain.lf + "/rgbColor";
SpreadsheetMLMain.n1 = SpreadsheetMLMain.lf + "/right";
SpreadsheetMLMain.n4 = SpreadsheetMLMain.lf + "/row";
SpreadsheetMLMain.n5 = SpreadsheetMLMain.lf + "/rowBreaks";
SpreadsheetMLMain.n6 = SpreadsheetMLMain.lf + "/rPr";
SpreadsheetMLMain.oe = SpreadsheetMLMain.lf + "/scheme";
SpreadsheetMLMain.oh = SpreadsheetMLMain.lf + "/selection";
SpreadsheetMLMain.om = SpreadsheetMLMain.lf + "/sheet";
SpreadsheetMLMain.oo = SpreadsheetMLMain.lf + "/sheetCalcPr";
SpreadsheetMLMain.op = SpreadsheetMLMain.lf + "/sheetData";
SpreadsheetMLMain.oq = SpreadsheetMLMain.lf + "/sheetDataSet";
SpreadsheetMLMain.or = SpreadsheetMLMain.lf + "/sheetFormatPr";
SpreadsheetMLMain.ot = SpreadsheetMLMain.lf + "/sheetName";
SpreadsheetMLMain.ou = SpreadsheetMLMain.lf + "/sheetNames";
SpreadsheetMLMain.ov = SpreadsheetMLMain.lf + "/sheetPr";
SpreadsheetMLMain.ow = SpreadsheetMLMain.lf + "/sheetProtection";
SpreadsheetMLMain.ox = SpreadsheetMLMain.lf + "/sheets";
SpreadsheetMLMain.oy = SpreadsheetMLMain.lf + "/sheetView";
SpreadsheetMLMain.oz = SpreadsheetMLMain.lf + "/sheetViews";
SpreadsheetMLMain.ok = SpreadsheetMLMain.lf + "/shadow";
SpreadsheetMLMain.pv = SpreadsheetMLMain.lf + "/si";
SpreadsheetMLMain.p1 = SpreadsheetMLMain.lf + "/sortCondition";
SpreadsheetMLMain.p3 = SpreadsheetMLMain.lf + "/sortState";
SpreadsheetMLMain.p7 = SpreadsheetMLMain.lf + "/sst";
SpreadsheetMLMain.p8 = SpreadsheetMLMain.lf + "/start";
SpreadsheetMLMain.qc = SpreadsheetMLMain.lf + "/stop";
SpreadsheetMLMain.qe = SpreadsheetMLMain.lf + "/strike";
SpreadsheetMLMain.qg = SpreadsheetMLMain.lf + "/styleSheet";
SpreadsheetMLMain.qm = SpreadsheetMLMain.lf + "/sz";
SpreadsheetMLMain.qn = SpreadsheetMLMain.lf + "/t";
SpreadsheetMLMain.qp = SpreadsheetMLMain.lf + "/tabColor";
SpreadsheetMLMain.qq = SpreadsheetMLMain.lf + "/table";
SpreadsheetMLMain.qt = SpreadsheetMLMain.lf + "/tableColumn";
SpreadsheetMLMain.qu = SpreadsheetMLMain.lf + "/tableColumns";
SpreadsheetMLMain.qv = SpreadsheetMLMain.lf + "/tablePart";
SpreadsheetMLMain.qw = SpreadsheetMLMain.lf + "/tableParts";
SpreadsheetMLMain.qx = SpreadsheetMLMain.lf + "/tableStyle";
SpreadsheetMLMain.qy = SpreadsheetMLMain.lf + "/tableStyleElement";
SpreadsheetMLMain.qz = SpreadsheetMLMain.lf + "/tableStyleInfo";
SpreadsheetMLMain.q0 = SpreadsheetMLMain.lf + "/tableStyles";
SpreadsheetMLMain.q4 = SpreadsheetMLMain.lf + "/text";
SpreadsheetMLMain.re = SpreadsheetMLMain.lf + "/top";
SpreadsheetMLMain.rg = SpreadsheetMLMain.lf + "/top10";
SpreadsheetMLMain.rm = SpreadsheetMLMain.lf + "/totalsRowFormula";
SpreadsheetMLMain.rt = SpreadsheetMLMain.lf + "/u";
SpreadsheetMLMain.r3 = SpreadsheetMLMain.lf + "/v";
SpreadsheetMLMain.r7 = SpreadsheetMLMain.lf + "/vertAlign";
SpreadsheetMLMain.r8 = SpreadsheetMLMain.lf + "/vertical";
SpreadsheetMLMain.sj = SpreadsheetMLMain.lf + "/workbook";
SpreadsheetMLMain.so = SpreadsheetMLMain.lf + "/workbookPr";
SpreadsheetMLMain.sp = SpreadsheetMLMain.lf + "/workbookProtection";
SpreadsheetMLMain.ss = SpreadsheetMLMain.lf + "/workbookView";
SpreadsheetMLMain.su = SpreadsheetMLMain.lf + "/worksheet";
SpreadsheetMLMain.sx = SpreadsheetMLMain.lf + "/xf";
SpreadsheetMLMain.s0 = SpreadsheetMLMain.lf + "/xmlColumnPr";
SpreadsheetMLMain.ao = new SpreadsheetMLMain();
//# sourceMappingURL=documents.openxml.js.map
