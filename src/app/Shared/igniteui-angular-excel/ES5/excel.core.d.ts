import { ValueType, Type, SystemException, BaseError, Base, IEnumerable$1, IEnumerable, IEnumerator$1, IDisposable, IEnumerator, IList$1, Stream, Nullable$1, IConvertible, Point, ICollection$1, IFormatProvider, IComparable$1, IEqualityComparer$1, EnumeratorWrapper, IEquatable$1, IComparable } from "../../igniteui-angular-core/ES5/type";
import { Color } from "../../igniteui-angular-core/ES5/Color";
import { DependencyObject } from "../../igniteui-angular-core/ES5/DependencyObject";
import { Calendar, CultureInfo, DateTimeFormat } from "../../igniteui-angular-core/ES5/culture";
import { ArgumentOutOfRangeException } from "../../igniteui-angular-core/ES5/ArgumentOutOfRangeException";
import { List$1 } from "../../igniteui-angular-core/ES5/List$1";
import { ArgumentException } from "../../igniteui-angular-core/ES5/ArgumentException";
import { KeyValuePair$2 } from "../../igniteui-angular-core/ES5/KeyValuePair$2";
import { Comparer$1 } from "../../igniteui-angular-core/ES5/Comparer$1";
import { ImageFormat, WorkItem, IPackageFactory, ST_IconSetType, WorkItem$1, StructuredStorageManager, IPackage, ImageData, BinaryData, OleDataSpacesEncryptionMode, RoundTripControlData, ST_TotalsRowFunction, ValueTuple$2, Directory, ST_ShapeType, SummaryInformation, DocumentSummaryInformation, CT_TextBodyPropertiesBase, IShallowCloneable, ST_CellType, ProtectionValidationInfo, IPackageRelationship, ST_SortBy, ST_DynamicFilterType, ST_FilterOperator, ST_DateTimeGrouping, CT_Transform2D, CT_GroupTransform2D } from "./documents.core";
import { Encoding } from "../../igniteui-angular-core/ES5/Encoding";
import { Rect } from "../../igniteui-angular-core/ES5/Rect";
import { StringComparer } from "../../igniteui-angular-core/ES5/StringComparer";
import { Dictionary$2 } from "../../igniteui-angular-core/ES5/Dictionary$2";
import { IComparer$1 } from "../../igniteui-angular-core/ES5/IComparer$1";
import { WeakReference } from "../../igniteui-angular-core/ES5/WeakReference";
import { Uri } from "../../igniteui-angular-core/ES5/Uri";
import { Guid } from "../../igniteui-angular-core/ES5/Guid";
import { HashSet$1 } from "../../igniteui-angular-core/ES5/HashSet$1";
import { Regex } from "../../igniteui-angular-core/ES5/Regex";
import { StringBuilder } from "../../igniteui-angular-core/ES5/StringBuilder";
import { Size } from "../../igniteui-angular-core/ES5/Size";
import { Tuple$3 } from "../../igniteui-angular-core/ES5/Tuple$3";
import { IDictionary$2 } from "../../igniteui-angular-core/ES5/IDictionary$2";
import { Stack$1 } from "../../igniteui-angular-core/ES5/Stack$1";
import { IgSize } from "../../igniteui-angular-core/ES5/IgSize";
import { DomRenderer } from "../../igniteui-angular-core/ES5/dom";
import { ReadOnlyCollection$1 } from "../../igniteui-angular-core/ES5/ReadOnlyCollection$1";
import { IgRect } from "../../igniteui-angular-core/ES5/IgRect";
import { IgPoint } from "../../igniteui-angular-core/ES5/IgPoint";
import { Tuple$2 } from "../../igniteui-angular-core/ES5/Tuple$2";
/**
 * @hidden
 */
export declare const enum ReferenceActionCode {
    Create = 0,
    Remove = 1
}
/**
 * @hidden
 */
export declare let ReferenceActionCode_$type: Type;
/**
 * @hidden
 */
export declare const enum NodeState {
    NotVisited = 0,
    Visiting = 1,
    Visited = 2
}
/**
 * @hidden
 */
export declare let NodeState_$type: Type;
/**
 * @hidden
 */
export declare const enum UltraCalcOperatorFunction {
    Add = 0,
    Subtract = 1,
    Multiply = 2,
    Divide = 3,
    Equal = 4,
    NotEqual = 5,
    GreaterThanOrEqual = 6,
    GreaterThan = 7,
    LessThanOrEqual = 8,
    LessThan = 9,
    Concatenate = 10,
    Exponent = 11,
    Percent = 12,
    UnaryMinus = 13,
    UnaryPlus = 14
}
/**
 * @hidden
 */
export declare let UltraCalcOperatorFunction_$type: Type;
/**
 * @hidden
 */
export declare const enum UltraCalcFormulaTokenType {
    Value = 0,
    Function = 1
}
/**
 * @hidden
 */
export declare let UltraCalcFormulaTokenType_$type: Type;
/**
 * Enumeration of error codes assigned to [[ExcelCalcErrorValue]].
 */
export declare enum ExcelCalcErrorCode {
    /**
     * Occurs when an invalid or disconnected reference is encountered while evaluating a formula
     */
    Reference = 0,
    /**
     * Occurs when the wrong type of argument or operand is used in a formula
     */
    Value = 1,
    /**
     * Occurs when a number is divided by zero (0)
     */
    Div = 2,
    /**
     * Occurs when @NA is entered into a formula
     */
    NA = 3,
    /**
     * Occurs with invalid numeric values in a formula or function
     */
    Num = 4,
    /**
     * Occurs when a circularity formula is used when circularities are not allowed.
     */
    Circularity = 5,
    /**
     * Occurs when there is an intersection of two references that do not contain any common cells.
     */
    Null = 6,
    /**
     * Occurs when text in a formula is not recognized.
     */
    Name1 = 7
}
/**
 * @hidden
 */
export declare let ExcelCalcErrorCode_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatterFlags {
    None = 0,
    Date = 1,
    Time = 2
}
/**
 * @hidden
 */
export declare let ValueFormatterFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum DayCountBasis {
    NASD360 = 0,
    Actual = 1,
    Actual360 = 2,
    Actual365 = 3,
    European360 = 4
}
/**
 * @hidden
 */
export declare let DayCountBasis_$type: Type;
/**
 * @hidden
 */
export declare const enum CalcArgumentFlags {
    SkipEmptyReferences = 1,
    SkipHiddenRows = 2,
    IgnoreRefString = 4,
    IgnoreRefBoolean = 8,
    AdjustFor1904System = 16,
    TreatIndirectStringsAsZero = 32,
    IgnoreArrayBoolean = 64,
    TreatNullAsZero = 128,
    IgnoreErrors = 256,
    TreatErrorsAsZero = 512,
    IgnoreArrayString = 1024,
    SkipSubtotals = 2048,
    SkipHiddenColumns = 4096,
    SkipHiddenCells = 4098,
    Normal = 1229,
    NormalA = 1249,
    Count = 1485,
    CountA = 673,
    EnumerableNumericOnlyFlags = 1101
}
/**
 * @hidden
 */
export declare let CalcArgumentFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum CalcArgumentSource {
    Direct = 0,
    Array = 1,
    Reference = 2
}
/**
 * @hidden
 */
export declare let CalcArgumentSource_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatter_WellKnownPartType {
    Whitespace = 0,
    GeneralString = 1,
    VerbatimString = 2,
    DecimalSeparator = 3,
    DigitOrEmpty = 4,
    DigitOrZero = 5,
    DigitOrWhitespace = 6,
    GroupShiftPlaceholder = 7,
    Percent = 8,
    FractionSeparator = 9,
    Scientific = 10,
    ScientificWithSign = 11,
    AMPMShortLL = 12,
    AMPMShortLU = 13,
    AMPMShortUL = 14,
    AMPMShortUU = 15,
    AMPMLong = 16,
    AMPMChinese = 17,
    HoursShort = 18,
    HoursLong = 19,
    HoursTotal = 20,
    Milliseconds1 = 21,
    Milliseconds2 = 22,
    Milliseconds3 = 23,
    MinutesShort = 24,
    MinutesLong = 25,
    MinutesTotal = 26,
    SecondsShort = 27,
    SecondsLong = 28,
    SecondsTotal = 29,
    BuddhistYearsShort = 30,
    BuddhistYearsLong = 31,
    DaysShort = 32,
    DaysLong = 33,
    DayShortDescription = 34,
    DayLongDescription = 35,
    MonthsShort = 36,
    MonthsLong = 37,
    MonthShortDescription = 38,
    MonthLongDescription = 39,
    MonthFirstLetter = 40,
    YearsShort = 41,
    YearsLong = 42,
    EraYearsShort = 43,
    EraYearsLong = 44,
    EraEnglishName = 45,
    EraAbbreviatedName = 46,
    EraName = 47,
    DayShortDescriptionLocalized = 48,
    DayLongDescriptionLocalized = 49
}
/**
 * @hidden
 */
export declare let ValueFormatter_WellKnownPartType_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatter_SectionType {
    Default = 0,
    Date = 1,
    Number = 2,
    Text = 3
}
/**
 * @hidden
 */
export declare let ValueFormatter_SectionType_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatter_NumberSection {
    Number = 0,
    Fraction = 1,
    GeneratedNumerator = 2,
    GeneratedDenominator = 3,
    ScientificCoefficient = 4,
    ScientificCoefficientFraction = 5,
    ScientificExponent = 6,
    ScientificExponentFraction = 7
}
/**
 * @hidden
 */
export declare let ValueFormatter_NumberSection_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatter_LiteralType {
    Normal = 0,
    Repeated = 1,
    Placeholder = 2
}
/**
 * @hidden
 */
export declare let ValueFormatter_LiteralType_$type: Type;
/**
 * @hidden
 */
export declare const enum ValueFormatter_CompareOperator {
    AnyValue = 0,
    Equals = 1,
    NotEquals = 2,
    LessThan = 3,
    LessThanOrEquals = 4,
    GreaterThan = 5,
    GreaterThanOrEquals = 6
}
/**
 * @hidden
 */
export declare let ValueFormatter_CompareOperator_$type: Type;
/**
 * @hidden
 */
export declare const enum PropertyType {
    TransformLeft = 0,
    TransformTop = 1,
    TransformRight = 2,
    TransformBottom = 3,
    TransformRotation = 4,
    TransformFFlipV = 62,
    TransformFFlipH = 63,
    TransformBooleanProperties = 63,
    ProtectionLockAgainstUngrouping = 118,
    ProtectionLockRotation = 119,
    ProtectionLockAspectRatio = 120,
    ProtectionLockPosition = 121,
    ProtectionLockAgainstSelect = 122,
    ProtectionLockCropping = 123,
    ProtectionLockVertices = 124,
    ProtectionLockText = 125,
    ProtectionLockAdjustHandles = 126,
    ProtectionLockAgainstGrouping = 127,
    ProtectionBooleanProperties = 127,
    TextID = 128,
    TextLeft = 129,
    TextTop = 130,
    TextRight = 131,
    TextBottom = 132,
    TextAnchorText = 135,
    TextShapeNext = 138,
    TextDirection = 139,
    TextSelectText = 187,
    TextAutoTextMargin = 188,
    TextRotateText = 189,
    TextFitToText = 190,
    TextFitToShape = 191,
    TextBooleanProperties = 191,
    BLIPId = 260,
    BLIPName = 261,
    BLIPFlags = 262,
    BLIPPictureId = 267,
    BLIPPictureActive = 319,
    GeometryRight = 322,
    GeometryBottom = 323,
    GeometryShapePath = 324,
    GeometryVertices = 325,
    GeometrySegmentInfo = 326,
    GeometryConnectionSites = 337,
    GeometryConnectionSitesDirection = 338,
    GeometryAdjustHandles = 341,
    GeometryGuides = 342,
    GeometryInscribe = 343,
    GeometryTypeOfConnectionSites = 344,
    GeometryFragments = 345,
    GeometryFillOK = 383,
    FillStyleColor = 385,
    FillStyleOpacity = 386,
    FillStyleBackColor = 387,
    FillStyleColorModification = 389,
    FillStyleBLIPName = 391,
    FillStyleRectLeft = 401,
    FillStyleRectTop = 402,
    FillStyleRectRight = 403,
    FillStyleRectBottom = 404,
    FillStyleShadeColors = 407,
    FillStyleRecolorFillAsPicture = 441,
    FillStyleUseShapeAnchor = 442,
    FillStyleFilled = 443,
    FillStyleHitTestFill = 444,
    FillStyleShape = 445,
    FillStyleUseRect = 446,
    FillStyleNoFillHitTest = 447,
    FillStyleBooleanProperties = 447,
    LineStyleColor = 448,
    LineStyleOpacity = 449,
    LineStyleColorModification = 451,
    LineStyleWidth = 459,
    LineStyleDashStyle = 463,
    LineStyleInsetPen = 505,
    LineStyleInsetPenOK = 506,
    LineStyleArrowheadsOK = 507,
    LineStyleLine = 508,
    LineStyleHitTestLine = 509,
    LineStyleFillShape = 510,
    LineStyleNoLineDrawDash = 511,
    LineStyleBooleanProperties = 511,
    ShadowColor = 513,
    ShadowColorModification = 515,
    ShadowSoftness = 540,
    ShadowObscured = 575,
    ShapeMaster = 769,
    ShapePolicyLabel = 822,
    ShapePolicyBarcode = 823,
    ShapeFlipHOverride = 824,
    ShapeFlipVOverride = 825,
    ShapeOleIcon = 826,
    ShapePreferRelativeResize = 827,
    ShapeLockShapeType = 828,
    ShapeInitiator = 829,
    ShapeDeleteAttachedObject = 830,
    ShapeBackground = 831,
    ShapeBooleanProperties = 831,
    GroupShapeName = 896,
    GroupShapeDescription = 897,
    GroupShapeWrapPolygonVertices = 899,
    GroupTableRowProperties = 928,
    Office2007Data = 937,
    GroupShapeLayoutInCell = 944,
    GroupShapeIsBullet = 945,
    GroupShapeStandardHR = 946,
    GroupShapeNoshadeHR = 947,
    GroupShapeHorizRule = 948,
    GroupShapeUserDrawn = 949,
    GroupShapeAllowOverlap = 950,
    GroupShapeReallyHidden = 951,
    GroupShapeScriptAnchor = 952,
    GroupShapeEditedWrap = 953,
    GroupShapeBehindDocument = 954,
    GroupShapeOnDblClickNotify = 955,
    GroupShapeIsButton = 956,
    GroupShapeOneD = 957,
    GroupShapeHidden = 958,
    GroupShapePrint = 959,
    GroupShapeBooleanProperties = 959,
    DiagramRelationTable = 1284,
    DiagramConstrainBounds = 1288,
    LineLeftStyleDashStyle = 1349,
    LineTopStyleDashStyle = 1423,
    LineRightStyleDashStyle = 1487,
    LineBottomStyleDashStyle = 1551,
    LineColumnStyleDashStyle = 1615,
    ClipVertices = 1728,
    ClipSegmentsInfo = 1729
}
/**
 * @hidden
 */
export declare let PropertyType_$type: Type;
/**
 * @hidden
 */
export declare const enum EscherRecordType {
    DrawingGroupContainer = 61440,
    BLIPStoreContainer = 61441,
    DrawingContainer = 61442,
    GroupContainer = 61443,
    ShapeContainer = 61444,
    SolverContainer = 61445,
    DrawingGroup = 61446,
    BLIPStoreEntry = 61447,
    Drawing = 61448,
    GroupShape = 61449,
    Shape = 61450,
    PropertyTable1 = 61451,
    Textbox = 61452,
    ClientTextbox = 61453,
    Anchor = 61454,
    ChildAnchor = 61455,
    ClientAnchor = 61456,
    ClientData = 61457,
    ConnectorRule = 61458,
    AlignRule = 61459,
    ArcRule = 61460,
    ClientRule = 61461,
    ClassID = 61462,
    CalloutRule = 61463,
    BLIPMin = 61464,
    BLIPMax = 61719,
    Regroup = 61720,
    Selections = 61721,
    ColorMRU = 61722,
    DeletedPSPL = 61725,
    SplitMenuColors = 61726,
    OLEObject = 61727,
    ColorScheme = 61728,
    PropertyTable2 = 61729,
    PropertyTable3 = 61730
}
/**
 * @hidden
 */
export declare let EscherRecordType_$type: Type;
/**
 * @hidden
 */
export declare const enum BLIPUsage {
    Default = 0,
    Texture = 1,
    Max = 255
}
/**
 * @hidden
 */
export declare let BLIPUsage_$type: Type;
/**
 * @hidden
 */
export declare const enum BLIPType {
    Error = 0,
    Unknown = 1,
    EMF = 2,
    WMF = 3,
    PICT = 4,
    JPEG = 5,
    PNG = 6,
    DIB = 7,
    TIFF = 17,
    CMYKJPEG = 18,
    FirstClient = 32,
    LastClient = 255
}
/**
 * @hidden
 */
export declare let BLIPType_$type: Type;
/**
 * @hidden
 */
export declare const enum BLIPRecordType {
    Unknwon = 0,
    WMF = 534,
    EMF = 980,
    PICT = 1346,
    PNG = 1760,
    JPEG = 1130,
    DIB = 1960,
    CMYKJPEG = 1762,
    TIFF = 1764,
    Client = 2048
}
/**
 * @hidden
 */
export declare let BLIPRecordType_$type: Type;
/**
 * @hidden
 */
export declare const enum PictureClipboardFormat {
    Emf = 2,
    Bitmap = 9,
    Unspecified = 65535
}
/**
 * @hidden
 */
export declare let PictureClipboardFormat_$type: Type;
/**
 * @hidden
 */
export declare const enum ObjectType {
    Group = 0,
    Line = 1,
    Rectangle = 2,
    Oval = 3,
    Arc = 4,
    Chart = 5,
    Text = 6,
    Button = 7,
    Picture = 8,
    Polygon = 9,
    CheckBox = 11,
    OptionButton = 12,
    EditBox = 13,
    Label = 14,
    DialogBox = 15,
    Spinner = 16,
    ScrollBar = 17,
    ListBox = 18,
    GroupBox = 19,
    ComboBox = 20,
    Comment = 25,
    MicrosoftOfficeDrawing = 30
}
/**
 * @hidden
 */
export declare let ObjectType_$type: Type;
/**
 * @hidden
 */
export declare const enum OBJRecordType {
    Macro = 4,
    Button = 5,
    GroupMarker = 6,
    ClipboardFormat = 7,
    PictureOptionFlags = 8,
    PictureFormulaStyleMacro = 9,
    CheckBoxLink = 10,
    RadioButton = 11,
    ScrollBar = 12,
    Note = 13,
    ScrollBarFormulaStyleMacro = 14,
    GroupBoxData = 15,
    EditControlData = 16,
    RadioButtonData = 17,
    CheckBoxData = 18,
    ListBoxData = 19,
    CheckBoxLinkFormulaStyleMacro = 20,
    CommonObjectData = 21
}
/**
 * @hidden
 */
export declare let OBJRecordType_$type: Type;
/**
 * @hidden
 */
export declare const enum IconSet {
    _3Arrows = 0,
    _3ArrowsGray = 1,
    _3Flags = 2,
    _3TrafficLights1 = 3,
    _3Signs = 4,
    _3TrafficLights2 = 5,
    _3Symbols = 6,
    _3Symbols2 = 7,
    _4Arrows = 8,
    _4ArrowsGray = 9,
    _4RedToBlack = 10,
    _4Ratings = 11,
    _4TrafficLights = 12,
    _5Arrows = 13,
    _5ArrowsGray = 14,
    _5Ratings = 15,
    _5Quarters = 16
}
/**
 * @hidden
 */
export declare let IconSet_$type: Type;
/**
 * @hidden
 */
export declare const enum CfValueType {
    Zero = 0,
    Number = 1,
    Min = 2,
    Max = 3,
    Percent = 4,
    Percentile = 5,
    Formula = 7
}
/**
 * @hidden
 */
export declare let CfValueType_$type: Type;
/**
 * @hidden
 */
export declare const enum CfDateOperator {
    Today = 0,
    Tomorrow = 6,
    Yesterday = 1,
    Last7Days = 2,
    LastMonth = 5,
    NextMonth = 8,
    ThisWeek = 3,
    NextWeek = 7,
    LastWeek = 4,
    ThisMonth = 9
}
/**
 * @hidden
 */
export declare let CfDateOperator_$type: Type;
/**
 * @hidden
 */
export declare const enum CfTextOperator {
    Contains = 0,
    NotContains = 1,
    BeginsWith = 2,
    EndsWith = 3
}
/**
 * @hidden
 */
export declare let CfTextOperator_$type: Type;
/**
 * @hidden
 */
export declare const enum CfTemplate {
    CellValue = 0,
    Formula = 1,
    ColorScale = 2,
    DataBar = 3,
    IconSet = 4,
    FilterAKATopTen = 5,
    Unique = 7,
    ContainsText = 8,
    Blanks = 9,
    NoBlanks = 10,
    Errors = 11,
    NoErrors = 12,
    Today = 15,
    Tomorrow = 16,
    Yesterday = 17,
    Last7Days = 18,
    LastMonth = 19,
    NextMonth = 20,
    ThisWeek = 21,
    NextWeek = 22,
    LastWeek = 23,
    ThisMonth = 24,
    AboveAverage = 25,
    BelowAverage = 26,
    Duplicate = 27,
    AboveOrEqualToAverage = 29,
    BelowOrEqualToAverage = 30
}
/**
 * @hidden
 */
export declare let CfTemplate_$type: Type;
/**
 * @hidden
 */
export declare const enum CfOperator {
    Zero = 0,
    Between = 1,
    NotBetween = 2,
    Equal = 3,
    NotEqual = 4,
    GreaterThan = 5,
    LessThan = 6,
    GreaterEqual = 7,
    LessEqual = 8
}
/**
 * @hidden
 */
export declare let CfOperator_$type: Type;
/**
 * @hidden
 */
export declare const enum CfType {
    Zero = 0,
    CellValueIs = 1,
    FormulaIs = 2,
    ColorScale = 3,
    DataBar = 4,
    FilterAKATopTen = 5,
    IconSet = 6
}
/**
 * @hidden
 */
export declare let CfType_$type: Type;
/**
 * @hidden
 */
export declare const enum XColorType {
    Auto = 0,
    Indexed = 1,
    RGB = 2,
    Themed = 3,
    NotSet = 4
}
/**
 * @hidden
 */
export declare let XColorType_$type: Type;
/**
 * @hidden
 */
export declare const enum SourceType {
    Range = 0,
    Sharepoint = 1,
    XML = 2,
    ExternalData = 3
}
/**
 * @hidden
 */
export declare let SourceType_$type: Type;
/**
 * @hidden
 */
export declare const enum SharedFeatureType {
    Protection = 2,
    Fec2 = 3,
    Factoid = 4,
    List = 5
}
/**
 * @hidden
 */
export declare let SharedFeatureType_$type: Type;
/**
 * @hidden
 */
export declare const enum FontScheme {
    None = 0,
    Major = 1,
    Minor = 2,
    Nil = 255
}
/**
 * @hidden
 */
export declare let FontScheme_$type: Type;
/**
 * @hidden
 */
export declare const enum BIFF8RecordType {
    Default = 0,
    Record1904 = 34,
    ACTIVEXMARKER = 445,
    ADDIN = 135,
    ADDMENU = 194,
    AREAFORMAT = 4106,
    ARRAY = 545,
    AUTOFILTER = 158,
    AUTOFILTER12 = 2174,
    AUTOFILTERINFO = 157,
    AXCEXT = 4194,
    AXESUSED = 4166,
    AXIS = 4125,
    AXISLINE = 4129,
    AXISPARENT = 4161,
    BACKUP = 64,
    BEGIN = 4147,
    BITMAP = 233,
    BLANK = 513,
    BOF = 2057,
    BOOKBOOL = 218,
    BOOKEXT = 2147,
    BOOLERR = 517,
    BOTTOMMARGIN = 41,
    BOUNDSHEET = 133,
    BRAI = 4177,
    CALCCOUNT = 12,
    CALCMODE = 13,
    CATLAB = 2134,
    CATSERRANGE = 4128,
    CELLWATCH = 2156,
    CF = 433,
    CF12 = 2170,
    CFEX = 2171,
    CHART = 4098,
    CHART3DBarSHAPE = 4191,
    CHARTFORMAT = 4116,
    CHARTFRTINFO = 2128,
    CODEPAGE = 66,
    COLINFO = 125,
    CONDFMT = 432,
    CONDFMT12 = 2169,
    CONTINUE = 60,
    CONTINUEFRT = 2066,
    CONTINUEFRT11 = 2165,
    CONTINUEFRT12 = 2175,
    COORDLIST = 169,
    COUNTRY = 140,
    CRASHRECERR = 2149,
    CRN = 90,
    CRTCOOPT = 2251,
    CRTLINK = 4130,
    DATAFORMAT = 4102,
    DATALABEXT = 2154,
    DATALABEXTCONTENTS = 2155,
    DBCELL = 215,
    DBQUERYEXT = 2051,
    DCON = 80,
    DCONBIN = 437,
    DCONNAME = 82,
    DCONREF = 81,
    DEFAULTROWHEIGHT = 549,
    DEFAULTTEXT = 4132,
    DEFCOLWIDTH = 85,
    DELMENU = 195,
    DELTA = 16,
    DIMENSIONS = 512,
    DOCROUTE = 184,
    DROPDOWNOBJIDS = 2164,
    DSF = 353,
    DV = 446,
    DVAL = 434,
    DXF = 2189,
    EDG = 136,
    EFONT = 69,
    END = 4148,
    ENDBLOCK = 2131,
    EOF = 10,
    EXCEL9FILE = 448,
    EXTERNCOUNT = 22,
    EXTERNNAME = 35,
    EXTERNSHEET = 23,
    EXTSST = 255,
    EXTSTRING = 2052,
    FEAT = 2152,
    FEAT11 = 2162,
    FEAT12 = 2168,
    FEATHEADR = 2151,
    FEATHEADR11 = 2161,
    FILEPASS = 47,
    FILESHARING = 91,
    FILESHARING2 = 293,
    FILTERMODE = 155,
    FMQRY = 2246,
    FMSQRY = 2247,
    FNGROUPCOUNT = 156,
    FNGROUPNAME = 154,
    FONT = 49,
    FONTX = 4134,
    FOOTER = 21,
    FORMAT = 1054,
    FORMULA = 6,
    FRAME = 4146,
    GCW = 171,
    GRIDSET = 130,
    GUTS = 128,
    HCENTER = 131,
    HEADER = 20,
    HEADERFOOTER = 2204,
    HFPicture = 2150,
    HIDEOBJ = 141,
    HLINK = 440,
    HLINKTOOLTIP = 2048,
    HORIZONTALPAGEBREAKS = 27,
    IMDATA = 127,
    INDEX = 523,
    INTERFACEEND = 226,
    INTERFACEHDR = 225,
    ITERATION = 17,
    LABEL = 516,
    LABELRANGES = 351,
    LABELSST = 253,
    LEFTMARGIN = 38,
    LEGEND = 4117,
    LHNGRAPH = 149,
    LHRECORD = 148,
    LINE = 4120,
    LINEFORMAT = 4103,
    LIST12 = 2167,
    LISTCF = 2245,
    LISTCONDFMT = 2244,
    LISTDV = 2243,
    LISTFIELD = 2242,
    LISTOBJ = 2241,
    LNEXT = 2249,
    LPR = 152,
    MARKERFORMAT = 4105,
    MERGEDCELLS = 229,
    MKREXT = 2250,
    MMS = 193,
    MSODRAWING = 236,
    MSODRAWINGGROUP = 235,
    MSODRAWINGSELECTION = 237,
    MULBLANK = 190,
    MULRK = 189,
    NAME = 24,
    NAMEEXT = 2196,
    NOTE = 28,
    NUMBER = 515,
    OBJ = 93,
    OBJECTLINK = 4135,
    OBJPROTECT = 99,
    OBPROJ = 211,
    OLEDBCONN = 2058,
    OLESIZE = 222,
    PAGELAYOUTINFO = 2187,
    PALETTE = 146,
    PANE = 65,
    PARAMQRY = 220,
    PASSWORD = 19,
    PIEFORMAT = 4107,
    PLOTAREA = 4149,
    PLOTGROWTH = 4196,
    PLS = 77,
    PLV = 2248,
    POS = 4175,
    PRECISION = 14,
    PRINTGRIDLINES = 43,
    PRINTHEADERS = 42,
    PROTECT = 18,
    PROT4REV = 431,
    PROT4REVPASS = 444,
    PUB = 137,
    QSI = 429,
    QSIF = 2055,
    QSIR = 2054,
    QSISXTAG = 2050,
    REALTIMEDATA = 2067,
    RECALCID = 449,
    RECIPNAME = 185,
    REFMODE = 15,
    REFRESHALL = 439,
    RIGHTMARGIN = 39,
    RK = 638,
    ROW = 520,
    RSTRING = 214,
    SAVERECALC = 95,
    SCENARIO = 175,
    SCENMAN = 174,
    SCENPROTECT = 221,
    SCL = 160,
    SELECTION = 29,
    SERIES = 4099,
    SERIESTEXT = 4109,
    SERTOCRT = 4165,
    SETUP = 161,
    SHEETEXT = 2146,
    SHRFMLA = 1212,
    SHTPROPS = 4164,
    SORT = 144,
    SORTDATA12 = 2197,
    SOUND = 150,
    SST = 252,
    STANDARDWIDTH = 153,
    STARTBLOCK = 2130,
    STRING = 519,
    STYLE = 659,
    STYLEEXT = 2194,
    SUB = 145,
    SUPBOOK = 430,
    SXADDL = 2148,
    SXDB = 198,
    SXDBEX = 290,
    SXDI = 197,
    SXDXF = 244,
    SXEX = 241,
    SXEXT = 220,
    SXFDBTYPE = 443,
    SXFILT = 242,
    SXFMLA = 249,
    SXFORMAT = 251,
    SXFORMULA = 259,
    SXIDSTM = 213,
    SXITM = 245,
    SXIVD = 180,
    SXLI = 181,
    SXNAME = 246,
    SXPAIR = 248,
    SXPI = 182,
    SXPIEX = 2062,
    SXRULE = 240,
    SXSELECT = 247,
    SXSTRING = 205,
    SXTBL = 208,
    SXTBPG = 210,
    SXTBRGIITM = 209,
    SXTH = 2061,
    SXVD = 177,
    SXVDEX = 256,
    SXVDTEX = 2063,
    SXVI = 178,
    SXVIEW = 176,
    SXVIEWEX = 2060,
    SXVIEWEX9 = 2064,
    SXVS = 227,
    TABID = 317,
    TABIDCONF = 234,
    TABLE = 566,
    TABLESTYLE = 2191,
    TABLESTYLEELEMENT = 2192,
    TABLESTYLES = 2190,
    TEMPLATE = 96,
    TEXT = 4133,
    THEME = 2198,
    TICK = 4126,
    TOPMARGIN = 40,
    TXO = 438,
    TXTQUERY = 2053,
    UDDESC = 223,
    UNCALCED = 94,
    UNITS = 4097,
    USERBVIEW = 425,
    USERSVIEWBEGIN = 426,
    USERSVIEWEND = 427,
    USESELFS = 352,
    VALUERANGE = 4127,
    VBAOBJECTNAME = 442,
    VCENTER = 132,
    VERTICALPAGEBREAKS = 26,
    WEBPUB = 2049,
    WINDOW1 = 61,
    WINDOW2 = 574,
    WINDOWPROTECT = 25,
    WOPT = 2059,
    WRITEACCESS = 92,
    WRITEPROT = 134,
    WSBOOL = 129,
    XCT = 89,
    XF = 224,
    XFCRC = 2172,
    XFEXT = 2173,
    XL5MODIFY = 354
}
/**
 * @hidden
 */
export declare let BIFF8RecordType_$type: Type;
/**
 * @hidden
 */
export declare const enum XFPropType {
    PatternFill = 0,
    ForegroundColor = 1,
    BackgroundColor = 2,
    GradientFill = 3,
    GradientStop = 4,
    FontColor = 5,
    TopBorder = 6,
    BottomBorder = 7,
    LeftBorder = 8,
    RightBorder = 9,
    DiagonalBorder = 10,
    VerticalBorder = 11,
    HorizontalBorder = 12,
    DiagonalUpBorder = 13,
    DiagonalDownBorder = 14,
    HorizontalAlignment = 15,
    VerticalAlignment = 16,
    TextRotation = 17,
    TextIndentationLevel = 18,
    ReadingOrder = 19,
    WrappedText = 20,
    JustifyDistributed = 21,
    ShrinkToFit = 22,
    CellMerged = 23,
    FontName = 24,
    FontBold = 25,
    FontUnderline = 26,
    FontSubscriptSuperscript = 27,
    FontItalic = 28,
    FontStrikethrough = 29,
    FontOutline = 30,
    FontShadow = 31,
    FontCondensed = 32,
    FontExtended = 33,
    FontCharacterSet = 34,
    FontFamily = 35,
    FontHeight = 36,
    FontScheme = 37,
    NumberFormat = 38,
    NumberFormatId = 41,
    TextIndentationLevelRelative = 42,
    Locked = 43,
    Hidden = 44
}
/**
 * @hidden
 */
export declare let XFPropType_$type: Type;
/**
 * @hidden
 */
export declare const enum ExtPropType {
    ForegroundColor = 4,
    BackgroundColor = 5,
    GradientFill = 6,
    TopBorderColor = 7,
    BottomBorderColor = 8,
    LeftBorderColor = 9,
    RightBorderColor = 10,
    DiagonalBorderColor = 11,
    CellTextColor = 13,
    FontScheme = 14,
    TextIndentationLevel = 15
}
/**
 * @hidden
 */
export declare let ExtPropType_$type: Type;
/**
 * @hidden
 */
export declare const enum SubstreamType {
    WorkbookGlobals = 5,
    VisualBasicModule = 6,
    Worksheet = 16,
    Chart = 32,
    MacroSheet = 64,
    WorkspaceFile = 256
}
/**
 * @hidden
 */
export declare let SubstreamType_$type: Type;
/**
 * @hidden
 */
export declare const enum BiffSheetType {
    Worksheet = 0,
    MacroSheet = 1,
    Chart = 2,
    VBModule = 6
}
/**
 * @hidden
 */
export declare let BiffSheetType_$type: Type;
/**
 * @hidden
 */
export declare const enum ErrorAlertStyle {
    Stop = 0,
    Warning = 1,
    Infromation = 2
}
/**
 * @hidden
 */
export declare let ErrorAlertStyle_$type: Type;
/**
 * @hidden
 */
export declare const enum DataValidationOperatorType {
    Between = 0,
    NotBetween = 1,
    Equal = 2,
    NotEqual = 3,
    GreaterThan = 4,
    LessThan = 5,
    GreaterThanOrEqual = 6,
    LessThanOrEqual = 7
}
/**
 * @hidden
 */
export declare let DataValidationOperatorType_$type: Type;
/**
 * @hidden
 */
export declare const enum DataValidationType {
    AnyValue = 0,
    WholeNumber = 1,
    Decimal = 2,
    List = 3,
    Date = 4,
    Time = 5,
    TextLength = 6,
    Formula = 7
}
/**
 * @hidden
 */
export declare let DataValidationType_$type: Type;
/**
 * @hidden
 */
export declare const enum SeriesValuesType {
    Numeric = 0,
    string1 = 1
}
/**
 * @hidden
 */
export declare let SeriesValuesType_$type: Type;
/**
 * @hidden
 */
export declare const enum Series_BitValues {
    ApplyPicToEnd = 1,
    ApplyPicToFront = 2,
    ApplyPicToSides = 4,
    InvertIfNegative = 8,
    Smooth = 16,
    ShowDataLabels = 32,
    ShowWaterfallConnectorLines = 64
}
/**
 * @hidden
 */
export declare let Series_BitValues_$type: Type;
/**
 * @hidden
 */
export declare const enum XValuesDataType {
    string1 = 0,
    StringArray = 1,
    Number = 2
}
/**
 * @hidden
 */
export declare let XValuesDataType_$type: Type;
/**
 * Constants which determine the type of a [[Wall]],
 * i.e., back, side, or floor. Applicable only for 3-D charts.
 */
export declare enum WallType {
    /**
     * The back wall, i.e., "behind" the plot area.
     */
    Back = 0,
    /**
     * The side wall. Note that only one side is ever visible,
     * based on the rotation around the Y-axis.
     */
    Side = 1,
    /**
     * The bottom wall, i.e., the floor of the chart.
     */
    Floor = 2,
    /**
     * Applies to the back and side walls, and the floor.
     */
    All = 3
}
/**
 * @hidden
 */
export declare let WallType_$type: Type;
/**
 * Determines the horizontal alignment for a title
 */
export declare enum VerticalTitleAlignment {
    /**
     * The title will be aligned on the bottom
     */
    Bottom = -4107,
    /**
     * The title will be centered vertically
     */
    Center = -4108,
    /**
     * The title will be distributed
     */
    Distributed = -4117,
    /**
     * The title will be justified
     */
    Justify = -4130,
    /**
     * The title will be aligned on the top
     */
    Top = -4160
}
/**
 * @hidden
 */
export declare let VerticalTitleAlignment_$type: Type;
/**
 * Constants which distinguish between an up or down bar in a stock chart.
 */
export declare enum UpDownBarType {
    /**
     * Up bar.
     */
    Up = 0,
    /**
     * Down bar.
     */
    Down = 1
}
/**
 * @hidden
 */
export declare let UpDownBarType_$type: Type;
/**
 * Constants which define the various types of trendlines
 * supported by a [[WorksheetChart]].
 */
export declare enum TrendlineType {
    /**
     * The trendline is exponential.
     */
    Exponential = 0,
    /**
     * The trendline is linear.
     */
    Linear = 1,
    /**
     * The trendline is logarithmic.
     */
    Logarithmic = 2,
    /**
     * The trendline depicts a moving average.
     */
    MovingAverage = 3,
    /**
     * The trendline depicts a polynomial of order/degree <i>n</i>,
     * when <i>n</i> is specified by the ChartTrendline.PolynomialOrder
     * property.
     */
    Polynomial = 4,
    /**
     * The trendline depicts a power curve.
     */
    Power = 5
}
/**
 * @hidden
 */
export declare let TrendlineType_$type: Type;
/**
 * Constants which define the order/degree of the polynomial
 * applied to a [[Trendline]] when the trendline
 * type is <i>Polynomial</i>.
 * @see [[TrendlineType]]
 */
export declare enum TrendlinePolynomialOrder {
    /**
     * A second-order/degree polynomial.
     */
    Second = 2,
    /**
     * A third-order/degree polynomial.
     */
    Third = 3,
    /**
     * A fourth-order/degree polynomial.
     */
    Fourth = 4,
    /**
     * A fifth-order/degree polynomial.
     */
    Fifth = 5,
    /**
     * A sixth-order/degree polynomial.
     */
    Sixth = 6
}
/**
 * @hidden
 */
export declare let TrendlinePolynomialOrder_$type: Type;
/**
 * Constants which determine the unit of measure for [[Axis]] date/time values.
 */
export declare enum TimeUnit {
    /**
     * The Axis interval is expressed in days.
     */
    Days = 0,
    /**
     * The Axis interval is expressed in months.
     */
    Months = 1,
    /**
     * The Axis interval is expressed in years.
     */
    Years = 2
}
/**
 * @hidden
 */
export declare let TimeUnit_$type: Type;
/**
 * Constants which determine the placement of an axis' <see cref="Axis.MajorTickMark">major</see>
 * and <see cref="Axis.MinorTickMark">minor</see> tick marks.
 */
export declare enum TickMark {
    /**
     * The tick marks cross the axis line.
     */
    Cross = 4,
    /**
     * The tick marks appear on the side of the axis line
     * closest to the inside of the plot area.
     */
    Inside = 2,
    /**
     * Tick marks are not displayed.
     */
    None = 4142,
    /**
     * The tick marks appear on the side of the axis line
     * closest to the outside of the plot area.
     */
    Outside = 3
}
/**
 * @hidden
 */
export declare let TickMark_$type: Type;
/**
 * Determines the alignment for axis [[Axis.tickLabels]]
 */
export declare enum TickLabelAlignment {
    /**
     * The tick labels will be aligned on the left
     */
    Left = -4131,
    /**
     * The tick labels will be centered
     */
    Center = -4108,
    /**
     * The tick labels will be aligned on the right
     */
    Right = -4152
}
/**
 * @hidden
 */
export declare let TickLabelAlignment_$type: Type;
/**
 * Constants which determine the placement of an axis' <see cref="Axis.TickLabels">tick labels</see>.
 */
export declare enum TickLabelPosition {
    /**
     * Tick labels appear near the highest data value.
     */
    High = -4127,
    /**
     * Tick labels appear near the lowest data value.
     */
    Low = -4134,
    /**
     * Tick labels appear near the axis.
     */
    NextToAxis = 4,
    /**
     * Tick labels are not displayed.
     */
    None = -4142
}
/**
 * @hidden
 */
export declare let TickLabelPosition_$type: Type;
/**
 * Constants which describe whether text is allowed to continue
 * vertically outside the bounds of the containing element.
 */
export declare enum TextVerticalOverflow {
    /**
     * The text is clipped by the containing element.
     */
    Clip = 0,
    /**
     * The text is allowed to continue outside the bounds
     * of the containing element.
     */
    Overflow = 1,
    /**
     * Overflowing text is truncated and an ellipsis is displayed.
     */
    Ellipsis = 2
}
/**
 * @hidden
 */
export declare let TextVerticalOverflow_$type: Type;
/**
 * Constants which describe whether text is allowed to continue
 * horizontally outside the bounds of the containing element.
 */
export declare enum TextHorizontalOverflow {
    /**
     * The text is clipped by the containing element.
     */
    Clip = 0,
    /**
     * The text is allowed to continue outside the bounds
     * of the containing element.
     */
    Overflow = 1
}
/**
 * @hidden
 */
export declare let TextHorizontalOverflow_$type: Type;
/**
 * Determines the direction in which text flows.
 */
export declare enum TextDirection {
    /**
     * Text flows along the horizontal plane. Note that under this setting,
     * text rotation is also supported, with the angle of rotation being
     * relative to the horizontal plane.
     */
    Horizontal = 0,
    /**
     * Text flows along the vertical plane. The plane is defined by rotating
     * the horizontal axis by 90 degrees in the clockwise direction.
     */
    Vertical = 1,
    /**
     * Text flows along the vertical plane. The plane is defined by rotating
     * the horizontal axis by 270 degrees in the clockwise direction.
     */
    Vertical270 = 2,
    /**
     * Text flows along the vertical plane with East Asian vertical orientation.
     */
    EastAsianVertical = 3,
    /**
     * Text flows along the vertical plane with Mongolian vertical orientation.
     */
    MongolianVertical = 4,
    /**
     * Text flows along the vertical plane with WordArt vertical orientation.
     */
    WordArtVertical = 5,
    /**
     * Similar to <i>WordArtVertical</i>, with a right-to-left text reading direction.
     */
    WordArtVerticalRtl = 6
}
/**
 * @hidden
 */
export declare let TextDirection_$type: Type;
/**
 * Constants which determine the manner in which series values
 * are used to color regions on a geographic map chart.
 * <p class="body">
 * Applicable only when the associated series [[Series.chartType]] is <i>RegionMap</i>.
 * </p>
 */
export declare enum SeriesValuesColorBy {
    /**
     * The coloring of map regions is determined by the numerical value of the associated data point.
     */
    NumericalValue = 0,
    /**
     * The coloring of map regions is determined by the value of the associated data point,
     * which is assumed to represent a category.
     */
    SecondaryCategory = 1
}
/**
 * @hidden
 */
export declare let SeriesValuesColorBy_$type: Type;
/**
 * Determines the type of [[Series]].
 */
export declare enum SeriesType {
    /**
     * Area; used by both area and area 3D charts.
     */
    Area = 0,
    /**
     * Bar; used by both bar and bar 3D charts.
     */
    Bar = 1,
    /**
     * Line; used by line, line 3D, and stock charts.
     */
    Line = 2,
    /**
     * Pie; used by pie, pie 3D, doughnut, and 'of pie' charts.
     */
    Pie = 3,
    /**
     * Radar.
     */
    Radar = 4,
    /**
     * Surface; used by surface and surface 3D charts.
     */
    Surface = 5,
    /**
     * Scatter.
     */
    Scatter = 6,
    /**
     * Bubble.
     */
    Bubble = 7
}
/**
 * @hidden
 */
export declare let SeriesType_$type: Type;
/**
 * Determines the numerical scale of the axis
 */
export declare enum ScaleType {
    /**
     * The scale is linear.
     */
    Linear = -4132,
    /**
     * The scale is logarithmic.
     */
    Logarithmic = -4133
}
/**
 * @hidden
 */
export declare let ScaleType_$type: Type;
/**
 * Constants which determine the reading order.
 */
export declare enum ReadingOrder {
    /**
     * The direction is based on context.
     */
    Context = -5002,
    /**
     * The order is left-to-right.
     */
    LeftToRight = -5003,
    /**
     * The order is right-to-left.
     */
    RightToLeft = -5004
}
/**
 * @hidden
 */
export declare let ReadingOrder_$type: Type;
/**
 * Constants which determine the method of calculation
 * used when determining the median for a box and whisker chart.
 */
export declare enum QuartileCalculation {
    /**
     * The median is included in the calculation if <i>n</i> (the number of values in the data) is odd.
     */
    InclusiveMedian = 0,
    /**
     * The median is excluded from the calculation if <i>n</i> (the number of values in the data) is odd.
     */
    ExclusiveMedian = 1
}
/**
 * @hidden
 */
export declare let QuartileCalculation_$type: Type;
/**
 * Constants which determine the manner in which a picture is displayed.
 */
export declare enum PictureType {
    /**
     * The picture is stretched to fill it's containing element.
     */
    Stretch = 1,
    /**
     * The picture is stacked or tiled to fill it's containing element.
     */
    Stack = 2,
    /**
     * The picture is scaled to fill it's containing element.
     */
    Scale = 3
}
/**
 * @hidden
 */
export declare let PictureType_$type: Type;
/**
 * Constants which define the label positioning for a <i>Treemap</i> chart.
 */
export declare enum ParentLabelLayout {
    /**
     * Labels are not displayed.
     */
    None = 0,
    /**
     * Labels are displayed as banners.
     */
    Banner = 1,
    /**
     * Labels are displayed with overlapping.
     */
    Overlapping = 2
}
/**
 * @hidden
 */
export declare let ParentLabelLayout_$type: Type;
/**
 * Constants which determine the style of the markers displayed by line charts.
 */
export declare enum MarkerStyle {
    /**
     * The marker style is determined automatically.
     */
    Automatic = -4105,
    /**
     * The marker is circular.
     */
    Circle = 8,
    /**
     * The marker is a dash.
     */
    Dash = -4115,
    /**
     * The marker is diamond-shaped.
     */
    Diamond = 2,
    /**
     * The marker is a dot or bullet.
     */
    Dot = -4118,
    /**
     * No marker is displayed.
     */
    None = -4142,
    /**
     * The marker appears as a picture.
     */
    Picture = -4147,
    /**
     * The marker appears as a plus sign (+).
     */
    Plus = 9,
    /**
     * The marker appears as a square.
     */
    Square = 1,
    /**
     * The marker appears as a star.
     */
    Star = 5,
    /**
     * The marker appears as a triangle.
     */
    Triangle = 3,
    /**
     * The marker appears as an 'X'
     */
    X = -4168
}
/**
 * @hidden
 */
export declare let MarkerStyle_$type: Type;
/**
 * Determines the style of a line, i.e., solid, dashed, dotted, etc.
 * @see [[ChartLine.lineStyle]]
 */
export declare enum LineStyle {
    /**
     * Solid line.
     */
    Solid = 0,
    /**
     * Dashed line.
     */
    Dash = 1,
    /**
     * Alternating dashes and dots.
     */
    DashDot = 2,
    /**
     * Dotted line.
     */
    Dot = 3,
    /**
     * Large dashed line.
     */
    LargeDash = 4,
    /**
     * Large alternating dashes and dots.
     */
    LargeDashDot = 5,
    /**
     * Large alternating dashes and pairs of dots.
     */
    LargeDashDotDot = 6,
    /**
     * No line.
     */
    None = 7,
    /**
     * System-defined dashed line.
     */
    SysDash = 8,
    /**
     * System-defined alternating dashes and dots.
     */
    SysDashDot = 9,
    /**
     * System-defined alternating dashes and pairs of dots.
     */
    SysDashDotDot = 10,
    /**
     * System-defined dotted line.
     */
    SysDot = 11
}
/**
 * @hidden
 */
export declare let LineStyle_$type: Type;
/**
 * Constants which determine the placement of the chart's
 * [[Legend]].
 */
export declare enum LegendPosition {
    /**
     * The legend appears at the bottom of the chart.
     */
    Bottom = 0,
    /**
     * The legend appears near the left edge of the chart.
     */
    Left = 1,
    /**
     * The legend appears near the right edge of the chart.
     */
    Right = 2,
    /**
     * The legend appears at the top of the chart.
     */
    Top = 3,
    /**
     * The legend appears near the top right corner of the chart.
     */
    TopRight = 4,
    /**
     * The legend's size and location is determined by the
     * [[Legend.left]], [[Legend.top]],
     * [[Legend.width]], and [[Legend.height]]
     * properties.
     */
    Custom = 5,
    /**
     * The legend position is determined automatically by Excel.
     */
    Default = 6,
    /**
     * The legend appears near the top left corner of the chart.
     * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
     */
    TopLeft = 7,
    /**
     * The legend appears near the bottom left corner of the chart.
     * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
     */
    BottomLeft = 8,
    /**
     * The legend appears near the bottom right corner of the chart.
     * Supported only for Histogram, Pareto, Treemap, Sunburst, Box and Whisker, and Waterfall chart types.
     */
    BottomRight = 9
}
/**
 * @hidden
 */
export declare let LegendPosition_$type: Type;
/**
 * @hidden
 */
export declare const enum HorizontalTitleAlignment {
    Center = -4108,
    Distributed = -4117,
    Justify = -4130,
    Left = -4131,
    Right = -4152
}
/**
 * @hidden
 */
export declare let HorizontalTitleAlignment_$type: Type;
/**
 * Constants which define whether a gridline is major or minor.
 */
export declare enum GridLineType {
    /**
     * [[Axis.majorGridLines]]
     */
    Major = 0,
    /**
     * [[Axis.minorGridLines]]
     */
    Minor = 1
}
/**
 * @hidden
 */
export declare let GridLineType_$type: Type;
/**
 * Constants which determine the type of gradient applied to a
 * [[ChartGradientFill]].
 */
export declare enum GradientType {
    /**
     * The gradient extends in a linear direction.
     */
    Linear = 0,
    /**
     * The gradient extends along a radial curve.
     */
    Radial = 1,
    /**
     * The gradient extends along a rectangular path.
     */
    Rectangular = 2,
    /**
     * The gradient direction is determined by the shape's path.
     */
    Path = 3
}
/**
 * @hidden
 */
export declare let GradientType_$type: Type;
/**
 * Constants which specify the units used to depict errors on an
 * <see cref="ErrorBars">error bar</see>.
 */
export declare enum ErrorValueType {
    /**
     * The error range is defined by a fixed numerical value.
     */
    FixedValue = 0,
    /**
     * The error range is defined by a percentage.
     */
    Percentage = 1,
    /**
     * The error range is defined by standard deviation.
     */
    StandardDeviation = 2,
    /**
     * The error range is defined by standard error.
     */
    StandardError = 3
}
/**
 * @hidden
 */
export declare let ErrorValueType_$type: Type;
/**
 * Constants which specify the direction in which an
 * <see cref="ErrorBars">error bar</see> extends.
 */
export declare enum ErrorBarDirection {
    /**
     * The error bar extends in both directions.
     */
    Both = 0,
    /**
     * The error bar extends only in the positive direction.
     */
    Plus = 1,
    /**
     * The error bar extends only in the negative direction.
     */
    Minus = 2
}
/**
 * @hidden
 */
export declare let ErrorBarDirection_$type: Type;
/**
 * Constants which determine the style of the endpoint
 * of a line on a line chart.
 */
export declare enum EndStyleCap {
    /**
     * The line terminates with a cap.
     */
    Cap = 1,
    /**
     * No cap is displayed at the end of the line.
     */
    NoCap = 2
}
/**
 * @hidden
 */
export declare let EndStyleCap_$type: Type;
/**
 * Constants which determine whether a chart element is positioned
 * automatically or at a specific location in the chart space.
 */
export declare enum ElementPosition {
    /**
     * The chart element is positioned automatically as appropriate
     * for that element. For example, a [[ChartTitle]] is typically
     * positioned at the top of the chart space, centered horizontally.
     */
    Automatic = -4105,
    /**
     * Custom.
     */
    Custom = -4114,
    /**
     * The chart element is positioned above the plot area, centered horizontally.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    Top = 100,
    /**
     * The chart element is positioned to the left of the plot area, centered vertically.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    Left = 101,
    /**
     * The chart element is positioned to the right of the plot area, centered vertically.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    Right = 102,
    /**
     * The chart element is positioned under the plot area, centered horizontally.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    Bottom = 103,
    /**
     * The chart element is positioned above the plot area, horizontally aligned with the left edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    TopLeft = 104,
    /**
     * The chart element is positioned above the plot area, horizontally aligned with the right edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    TopRight = 105,
    /**
     * The chart element is positioned below the plot area, horizontally aligned with the left edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    BottomLeft = 106,
    /**
     * The chart element is positioned below the plot area, horizontally aligned with the right edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    BottomRight = 107,
    /**
     * The chart element is positioned to the left of the plot area, vertically aligned with the top edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    LeftTop = 108,
    /**
     * The chart element is positioned to the left of the plot area, vertically aligned with the bottom edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    LeftBottom = 109,
    /**
     * The chart element is positioned to the right of the plot area, vertically aligned with the top edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    RightTop = 110,
    /**
     * The chart element is positioned to the right of the plot area, vertically aligned with the bottom edge.
     * Applicable only for <i>BoxAndWhisker</i>, <i>Histogram</i>, <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, and <i>Waterfall</i> chart types.
     */
    RightBottom = 111
}
/**
 * @hidden
 */
export declare let ElementPosition_$type: Type;
/**
 * Constants which determine the unit of expression for
 * [[Axis]] value labels.
 */
export declare enum DisplayUnit {
    /**
     * The raw value is displayed without special formatting.
     */
    None = -4142,
    /**
     * The [[Axis.displayUnitCustom]] property determines the display unit.
     */
    Custom = -4114,
    /**
     * 100,000,000
     */
    HundredMillions = -8,
    /**
     * 100
     */
    Hundreds = -2,
    /**
     * 100,000
     */
    HundredThousands = -5,
    /**
     * 1,000,000,000,000 (trillions)
     */
    MillionMillions = -10,
    /**
     * 1,000,000
     */
    Millions = -6,
    /**
     * 10,000,000
     */
    TenMillions = -7,
    /**
     * 10,000
     */
    TenThousands = -4,
    /**
     * 1,000,000,000 (billions)
     */
    ThousandMillions = -9,
    /**
     * 1,000
     */
    Thousands = -3,
    /**
     * Displays as a percentage. Applicable only to
     * Box and Whisker, Histogram, Pareto, Sunburst, Treemap, and Waterfall chart types;
     * if used for any other chart type, resolved to <i>Hundreds</i>.
     */
    Percentage = 1
}
/**
 * @hidden
 */
export declare let DisplayUnit_$type: Type;
/**
 * Constants which define how blank cell values are plotted on the chart.
 */
export declare enum DisplayBlanksAs {
    /**
     * Points representing blank cell values are not plotted on the chart.
     */
    NotPlotted = 1,
    /**
     * Blank cell values are interpreted as having a value of zero.
     */
    Zero = 2,
    /**
     * The value is interpolated from adjacent values.
     */
    Interpolated = 3
}
/**
 * @hidden
 */
export declare let DisplayBlanksAs_$type: Type;
/**
 * Constants which define the location at which a [[DataLabel]] is positioned.
 * <p class="body">
 * Note that which constants in this enumeration are applicable is dependent on the chart type.
 * </p>
 * <p class="body">
 * The following table lists the supported constants for each chart type.
 * </p>
 * <p class="body">
 * <table border="1">
 * <tr>
 * <th><b>Chart Type</b></th><th><b>Supported Constant(s)</b></th>
 * </tr>
 * <tr>
 * <td>3D charts (except pie/doughnut)</td><td>Custom</td>
 * </tr>
 * <tr>
 * <td>Area, Radar</td><td>Custom</td>
 * </tr>
 * <tr>
 * <td>Surface</td><td>Data labels are not supported</td>
 * </tr>
 * <tr>
 * <td>Bar/Column (stacked)</td><td>Center, InsideEnd, InsideBase</td>
 * </tr>
 * <tr>
 * <td>Bar/Column (clustered)</td><td>Center, InsideEnd, InsideBase, OutsideEnd</td>
 * </tr>
 * <tr>
 * <td>Line/Scatter/Bubble</td><td>Center, Left, Right, Above, Below</td>
 * </tr>
 * <tr>
 * <td>Pie/Doughnut</td><td>Center, InsideEnd, OutsideEnd, BestFit</td>
 * </tr>
 * </table>
 * </p>
 * @see [[DataLabel.labelPosition]]
 * @see [[Series.dataLabels]]
 * @see [[DataLabel]]
 */
export declare enum DataLabelPosition {
    /**
     * The label position is not specified, and is determined automatically by Excel.
     */
    Default = 0,
    /**
     * The label is centered with respect to the associated data point.
     */
    Center = 1,
    /**
     * The label's left edge coincides with the left edge of the series bar/line.
     */
    InsideBase = 2,
    /**
     * The label's right edge coincides with the right edge of the series bar/line.
     */
    InsideEnd = 3,
    /**
     * The label's left edge coincides with the right edge of the series bar/line.
     */
    OutsideEnd = 4,
    /**
     * The label's position is explicitly defined via the [[ChartTextAreaBase.left]]
     * and [[ChartTextAreaBase.top]] properties.
     */
    Custom = 5,
    /**
     * The label is positioned to the left of the associated data point.
     */
    Left = 6,
    /**
     * The label is positioned to the right of the associated data point.
     */
    Right = 7,
    /**
     * The label is positioned above the associated data point.
     */
    Above = 8,
    /**
     * The label is positioned below the associated data point.
     */
    Below = 9,
    /**
     * The label is positioned where it best fits with relation to the associated pie slice.
     */
    BestFit = 10
}
/**
 * @hidden
 */
export declare let DataLabelPosition_$type: Type;
/**
 * @hidden
 */
export declare const enum ChartTypeContext {
    Default = 0,
    Series = 1
}
/**
 * @hidden
 */
export declare let ChartTypeContext_$type: Type;
/**
 * Constants which identify the chart's type, i.e.,
 * area chart, bar chart, pie chart, etc.
 */
export declare enum ChartType {
    /**
     * Not an actual value; used for variable initialization.
     */
    Unknown = 0,
    /**
     * 3D Area.
     */
    Area3D = -4098,
    /**
     * 3D Stacked Area.
     */
    Area3DStacked = 78,
    /**
     * 100% Stacked Area.
     */
    Area3DStacked100 = 79,
    /**
     * 3D Clustered Bar.
     */
    Bar3DClustered = 60,
    /**
     * 3D Stacked Bar.
     */
    Bar3DStacked = 61,
    /**
     * 3D 100% Stacked Bar.
     */
    Bar3DStacked100 = 62,
    /**
     * 3D Column.
     */
    Column3D = -4100,
    /**
     * 3D Clustered Column.
     */
    Column3DClustered = 54,
    /**
     * 3D Stacked Column.
     */
    Column3DStacked = 55,
    /**
     * 3D 100% Stacked Column.
     */
    Column3DStacked100 = 56,
    /**
     * 3D Line.
     */
    Line3D = -4101,
    /**
     * 3D Pie.
     */
    Pie3D = -4102,
    /**
     * Exploded 3D Pie.
     */
    Pie3DExploded = 70,
    /**
     * Area
     */
    Area = 1,
    /**
     * Stacked Area.
     */
    AreaStacked = 76,
    /**
     * 100% Stacked Area.
     */
    AreaStacked100 = 77,
    /**
     * Clustered Bar.
     */
    BarClustered = 57,
    /**
     * Bar of Pie.
     */
    BarOfPie = 71,
    /**
     * Stacked Bar.
     */
    BarStacked = 58,
    /**
     * 100% Stacked Bar.
     */
    BarStacked100 = 59,
    /**
     * Bubble.
     */
    Bubble = 15,
    /**
     * Bubble with 3D effects.
     */
    Bubble3DEffect = 87,
    /**
     * Clustered Column.
     */
    ColumnClustered = 51,
    /**
     * Stacked Column.
     */
    ColumnStacked = 52,
    /**
     * 100% Stacked Column.
     */
    ColumnStacked100 = 53,
    /**
     * Clustered Cone Bar.
     */
    ConeBarClustered = 102,
    /**
     * Stacked Cone Bar.
     */
    ConeBarStacked = 103,
    /**
     * 100% Stacked Cone Bar.
     */
    ConeBarStacked100 = 104,
    /**
     * 3D Cone Column.
     */
    ConeCol = 105,
    /**
     * Clustered Cone Column.
     */
    ConeColClustered = 99,
    /**
     * Stacked Cone Column.
     */
    ConeColStacked = 100,
    /**
     * 100% Stacked Cone Column.
     */
    ConeColStacked100 = 101,
    /**
     * Clustered Cylinder Bar.
     */
    CylinderBarClustered = 95,
    /**
     * Stacked Cylinder Bar.
     */
    CylinderBarStacked = 96,
    /**
     * 100% Stacked Cylinder Bar.
     */
    CylinderBarStacked100 = 97,
    /**
     * 3D Cylinder Column.
     */
    CylinderCol = 98,
    /**
     * Clustered Cone Column.
     */
    CylinderColClustered = 92,
    /**
     * Stacked Cone Column.
     */
    CylinderColStacked = 93,
    /**
     * 100% Stacked Cylinder Column.
     */
    CylinderColStacked100 = 94,
    /**
     * Doughnut.
     */
    Doughnut = -4120,
    /**
     * Exploded Doughnut.
     */
    DoughnutExploded = 80,
    /**
     * Line.
     */
    Line = 4,
    /**
     * Line with Markers.
     */
    LineMarkers = 65,
    /**
     * Stacked Line with Markers.
     */
    LineMarkersStacked = 66,
    /**
     * 100% Stacked Line with Markers.
     */
    LineMarkersStacked100 = 67,
    /**
     * Stacked Line.
     */
    LineStacked = 63,
    /**
     * 100% Stacked Line.
     */
    LineStacked100 = 64,
    /**
     * Pie.
     */
    Pie = 5,
    /**
     * Exploded Pie.
     */
    PieExploded = 69,
    /**
     * Pie of Pie.
     */
    PieOfPie = 68,
    /**
     * Clustered Pyramid Bar.
     */
    PyramidBarClustered = 109,
    /**
     * Stacked Pyramid Bar.
     */
    PyramidBarStacked = 110,
    /**
     * 100% Stacked Pyramid Bar.
     */
    PyramidBarStacked100 = 111,
    /**
     * 3D Pyramid Column.
     */
    PyramidCol = 112,
    /**
     * Clustered Pyramid Column.
     */
    PyramidColClustered = 106,
    /**
     * Stacked Pyramid Column.
     */
    PyramidColStacked = 107,
    /**
     * 100% Stacked Pyramid Column.
     */
    PyramidColStacked100 = 108,
    /**
     * Radar.
     */
    Radar = -4151,
    /**
     * Filled Radar.
     */
    RadarFilled = 82,
    /**
     * Radar with Data Markers.
     */
    RadarMarkers = 81,
    /**
     * High-Low-Close.
     */
    StockHLC = 88,
    /**
     * Open-High-Low-Close.
     */
    StockOHLC = 89,
    /**
     * Volume-High-Low-Close.
     */
    StockVHLC = 90,
    /**
     * Volume-Open-High-Low-Close.
     */
    StockVOHLC = 91,
    /**
     * Surface (a.k.a. Contour).
     */
    Surface = 83,
    /**
     * 3D Surface (Top View).
     */
    SurfaceTopView = 85,
    /**
     * 3D Surface (Top View wireframe).
     */
    SurfaceTopViewWireframe = 86,
    /**
     * Surface (a.k.a. Contour - wireframe).
     */
    SurfaceWireframe = 84,
    /**
     * Scatter.
     */
    XYScatter = -4169,
    /**
     * Scatter with Lines.
     */
    XYScatterLines = 74,
    /**
     * Scatter with Lines and No Data Markers.
     */
    XYScatterLinesNoMarkers = 75,
    /**
     * Scatter with Smoothed Lines.
     */
    XYScatterSmooth = 72,
    /**
     * Scatter with Smoothed Lines and No Data Markers.
     */
    XYScatterSmoothNoMarkers = 73,
    /**
     * Combination of different chart types.
     */
    Combo = 113,
    /**
     * Box and whisker (Office2016 or later)
     */
    BoxAndWhisker = 114,
    /**
     * Funnel (Office365 only)
     */
    Funnel = 115,
    /**
     * Pareto chart with bars and lines (Office2016 or later)
     */
    Pareto = 116,
    /**
     * Histogram chart (Office2016 or later)
     */
    Histogram = 117,
    /**
     * Sunburst chart (Office2016 or later)
     */
    Sunburst = 118,
    /**
     * Tree map chart (Office2016 or later)
     */
    Treemap = 119,
    /**
     * Waterfall chart (Office2016 or later)
     */
    Waterfall = 120,
    /**
     * Region map (geographic) chart (Office365 only)
     */
    RegionMap = 121
}
/**
 * @hidden
 */
export declare let ChartType_$type: Type;
/**
 * @hidden
 */
export declare const enum ChartsheetProtectionType {
    Objects = 1,
    Contents = 2
}
/**
 * @hidden
 */
export declare let ChartsheetProtectionType_$type: Type;
/**
 * Constants which define the type of a category axis.
 */
export declare enum CategoryType {
    /**
     * Scale is determined automatically.
     */
    AutomaticScale = -4105,
    /**
     * A category [[Axis]].
     */
    CategoryScale = 2,
    /**
     * A date/time [[Axis]].
     */
    TimeScale = 3
}
/**
 * @hidden
 */
export declare let CategoryType_$type: Type;
/**
 * Determines the style of a border line, i.e., solid, dashed, dotted, etc.
 * @see [[ChartBorder.lineStyle]]
 */
export declare enum BorderLineStyle {
    /**
     * Solid line.
     */
    Solid = 0,
    /**
     * Dashed line.
     */
    Dash = 1,
    /**
     * Alternating dashes and dots.
     */
    DashDot = 2,
    /**
     * Dotted line.
     */
    Dot = 3,
    /**
     * Large dashed line.
     */
    LargeDash = 4,
    /**
     * Large alternating dashes and dots.
     */
    LargeDashDot = 5,
    /**
     * Large alternating dashes and pairs of dots.
     */
    LargeDashDotDot = 6,
    /**
     * No line.
     */
    None = 7,
    /**
     * System-defined dashed line.
     */
    SysDash = 8,
    /**
     * System-defined alternating dashes and dots.
     */
    SysDashDot = 9,
    /**
     * System-defined alternating dashes and pairs of dots.
     */
    SysDashDotDot = 10,
    /**
     * System-defined dotted line.
     */
    SysDot = 11
}
/**
 * @hidden
 */
export declare let BorderLineStyle_$type: Type;
/**
 * @hidden
 */
export declare const enum IntervalClosedSide {
    Left = 0,
    Right = 1
}
/**
 * @hidden
 */
export declare let IntervalClosedSide_$type: Type;
/**
 * Constants which define the shape used by a bar chart series.
 */
export declare enum BarShape {
    /**
     * Square box
     */
    Box = 0,
    /**
     * Pyramid-shaped bar extending to the series maximum.
     */
    PyramidToPoint = 1,
    /**
     * Truncated pyramid-shaped bar.
     */
    PyramidToMax = 2,
    /**
     * Cylinder shaped bar.
     */
    Cylinder = 3,
    /**
     * Cone-shaped bar extending to the series maximum.
     */
    ConeToPoint = 4,
    /**
     * Truncated cone-shaped bar.
     */
    ConeToMax = 5
}
/**
 * @hidden
 */
export declare let BarShape_$type: Type;
/**
 * Specifies the axis type.
 */
export declare enum AxisType {
    /**
     * Axis displays categories.
     */
    Category = 1,
    /**
     * Axis displays values.
     */
    Value = 2,
    /**
     * Axis displays data series along the Z-axis (3D charts only).
     */
    SeriesAxis = 3
}
/**
 * @hidden
 */
export declare let AxisType_$type: Type;
/**
 * Constants which determine the placement of an [[Axis]],
 * as relative to the chart space.
 */
export declare enum AxisPosition {
    /**
     * The axis is positioned automatically, with the value axes
     * appearing on the left/right, and the category axes appearing
     * on the top/bottom.
     */
    Automatic = 0,
    /**
     * The axis appears alongside the bottom edge of the chart.
     */
    Bottom = 1,
    /**
     * The axis appears alongside the left edge of the chart.
     */
    Left = 2,
    /**
     * The axis appears alongside the right edge of the chart.
     */
    Right = 3,
    /**
     * The axis appears alongside the top edge of the chart.
     */
    Top = 4
}
/**
 * @hidden
 */
export declare let AxisPosition_$type: Type;
/**
 * Specifies the group of the axis, i.e., whether it is a primary
 * or secondary axis.
 */
export declare enum AxisGroup {
    /**
     * Primary axis group.
     */
    Primary = 1,
    /**
     * Secondary axis group. Invalid for [[AxisType.seriesAxis]] in 3D charts
     */
    Secondary = 2
}
/**
 * @hidden
 */
export declare let AxisGroup_$type: Type;
/**
 * Constants which describe the point at which
 * <see cref="Axis">axes</see> intersect.
 */
export declare enum AxisCrosses {
    /**
     * The crossing point is determined automatically.
     */
    Automatic = -4105,
    /**
     * A custom value is designated as the crossing point, using the
     * [[Axis.crossesAt]] property
     */
    Custom = -4114,
    /**
     * The axes cross at the point coinciding with the axis' maximum value.
     */
    Maximum = 2,
    /**
     * The axes cross at the point coinciding with the axis' minimum value.
     */
    Minimum = 4
}
/**
 * @hidden
 */
export declare let AxisCrosses_$type: Type;
/**
 * Constants which define the manner in which colors are used
 * to depict series values in a geographic map chart.
 */
export declare enum GeographicMapSeriesColor {
    /**
     * Two colors define the minimum and maximum series values.
     */
    Sequential = 0,
    /**
     * Three colors define the minimum, midpoint, and maximum series values.
     */
    Diverging = 1
}
/**
 * @hidden
 */
export declare let GeographicMapSeriesColor_$type: Type;
/**
 * Constants which define the manner in which map labels are displayed.
 */
export declare enum GeographicMapLabels {
    /**
     * Map labels are not displayed.
     */
    None = 0,
    /**
     * Map labels are displayed only for regions inside which the label can fit.
     */
    BestFit = 1,
    /**
     * Map labels are displayed for all regions.
     */
    ShowAll = 2
}
/**
 * @hidden
 */
export declare let GeographicMapLabels_$type: Type;
/**
 * Constants which define the level of granularity for a geographic map chart.
 */
export declare enum GeographicMappingArea {
    /**
     * Only regions for which series data is available are displayed.
     */
    DataOnly = 0,
    /**
     * A postal region is displayed.
     */
    PostalCode = 1,
    /**
     * A county is displayed.
     */
    County = 2,
    /**
     * A state is displayed.
     */
    State = 3,
    /**
     * The entire country or region is displayed, with areas for which no
     * series data is available appearing in a lighter color.
     */
    CountryOrRegion = 4,
    /**
     * Multiple countries or regions are displayed, with areas for which no
     * series data is available appearing in a lighter color.
     */
    MultipleCountriesOrRegions = 5,
    /**
     * The entire world map is displayed, with areas for which no
     * series data is available appearing in a lighter color.
     */
    World = 6
}
/**
 * @hidden
 */
export declare let GeographicMappingArea_$type: Type;
/**
 * Constants which define the projection for a geographic map chart.
 */
export declare enum GeographicMapProjection {
    /**
     * Albers equal-area conic projection.
     */
    Albers = 0,
    /**
     * Mercator cylindrical map projection.
     */
    Mercator = 1,
    /**
     * Miller cylindrical map projection.
     */
    Miller = 2,
    /**
     * Robinson flat map projection.
     */
    Robinson = 3
}
/**
 * @hidden
 */
export declare let GeographicMapProjection_$type: Type;
/**
 * @hidden
 */
export declare const enum Axis_BitValues {
    AxisBetweenCategories = 1,
    BaseUnitIsAuto = 2,
    MajorUnitIsAuto = 4,
    MaximumScaleIsAuto = 8,
    MinimumScaleIsAuto = 16,
    MinorUnitIsAuto = 32,
    ReversePlotOrder = 64,
    TickLabelSpacingIsAuto = 128,
    Visible = 256
}
/**
 * @hidden
 */
export declare let Axis_BitValues_$type: Type;
/**
 * Constants which determine  the manner in which cell values
 * are compared to the [[ConditionValue.value]]
 * property when conditional criteria is evaluated by an
 * [[IconSetConditionalFormat]].
 */
export declare enum ThresholdComparison {
    /**
     * The cell value can be greater than <b>or equal to</b> the threshold <see cref="ConditionValue.Value">value</see>.
     */
    GreaterEqual = 0,
    /**
     * The cell value must be greater than <b>but not equal to</b> the threshold <see cref="ConditionValue.Value">value</see>.
     */
    Greater = 1
}
/**
 * @hidden
 */
export declare let ThresholdComparison_$type: Type;
/**
 * Constants which specify the manner in which the color for negative-value
 * data bars is determined.
 */
export declare enum DataBarNegativeBarColorType {
    /**
     * Use the value of the [[NegativeBarFormat.barColor]] property.
     */
    Color = 0,
    /**
     * Use the same color as that of the positive-value data bars.
     */
    SameAsPositive = 1
}
/**
 * @hidden
 */
export declare let DataBarNegativeBarColorType_$type: Type;
/**
 * Constants which determine whether <see cref="DataBarConditionalFormat">data bars</see> are filled with a solid color or
 * with a gradient.
 */
export declare enum DataBarDirection {
    /**
     * The direction the data bar is displayed is based on context.
     */
    Context = -5002,
    /**
     * The data bar is displayed from left-to-right.
     */
    LeftToRight = -5003,
    /**
     * The data bar is displayed from right-to-left.
     */
    RightToLeft = -5004
}
/**
 * @hidden
 */
export declare let DataBarDirection_$type: Type;
/**
 * Constants which determine whether <see cref="DataBarConditionalFormat">data bars</see> are filled with a solid color or
 * with a gradient.
 */
export declare enum DataBarFillType {
    /**
     * Data bars are filled with a solid color.
     */
    SolidColor = 0,
    /**
     * Data bars are filled with a linear gradient.
     */
    Gradient = 1
}
/**
 * @hidden
 */
export declare let DataBarFillType_$type: Type;
/**
 * Constants which determine the axis position for a [[DataBarConditionalFormat]].
 */
export declare enum DataBarAxisPosition {
    /**
     * Displays the axis at a variable position based on the ratio of the minimum
     * negative value to the maximum positive value in the associated range. Positive
     * values are displayed in a left-to-right direction; negative values are displayed
     * from right to left. When all values are positive, or all values are negative,
     * no axis is displayed.
     */
    Automatic = 0,
    /**
     * Displays the axis at the midpoint of the cell, regardless of the set of values
     * in the associated range. Positive values are displayed in a left-to-right
     * direction; negative values are displayed from right to left.
     */
    Midpoint = 1,
    /**
     * No axis is displayed; positive and negative values are both displayed in
     * the left-to-right direction.
     */
    None = 2
}
/**
 * @hidden
 */
export declare let DataBarAxisPosition_$type: Type;
/**
 * Constants which identify whether a [[ColorScaleConditionalFormat]]
 * supports two or three thresholds. Used to differentiate between a 2-color and
 * 3-color scale.
 */
export declare enum ColorScaleType {
    /**
     * The color scale supports only the <see cref="ColorScaleConditionalFormat.MinimumThreshold">minimum</see>
     * and <see cref="ColorScaleConditionalFormat.MaximumThreshold">maximum</see> thresholds.
     */
    TwoColor = 0,
    /**
     * In addition to the the <see cref="ColorScaleConditionalFormat.MinimumThreshold">minimum</see>
     * and <see cref="ColorScaleConditionalFormat.MaximumThreshold">maximum</see> thresholds, the color
     * scale also supports a <see cref="ColorScaleConditionalFormat.MidpointThreshold">midpoint</see>
     * threshold.
     */
    ThreeColor = 1
}
/**
 * @hidden
 */
export declare let ColorScaleType_$type: Type;
/**
 * Constants which identify the threshold of a [[ColorScaleCriterion]].
 */
export declare enum ColorScaleCriterionThreshold {
    /**
     * Identifies the minimum threshold.
     */
    Minimum = 0,
    /**
     * Identifies the midpoint threshold.
     */
    Midpoint = 1,
    /**
     * Identifies the maximum threshold.
     */
    Maximum = 2
}
/**
 * @hidden
 */
export declare let ColorScaleCriterionThreshold_$type: Type;
/**
 * Constants which identify the type of value which defines the criteria for a
 * [[ColorScaleCriterion]] or [[IconCriterion]].
 */
export declare enum FormatConditionValueType {
    /**
     * The criteria is defined by a numeric value.
     */
    Number = 0,
    /**
     * The criteria is defined by a percentage.
     */
    Percentage = 1,
    /**
     * The criteria is defined by a percentile rating.
     */
    Percentile = 2,
    /**
     * The criteria is defined by a formula.
     */
    Formula = 3,
    /**
     * The criteria is defined by the lowest value across the associated range.
     */
    LowestValue = 4,
    /**
     * The criteria is defined by the highest value across the associated range.
     */
    HighestValue = 5,
    /**
     * The shortest data bar is proportional to the lowest value across the associated range.
     * Applicable only to the [[IconCriterion]] class.
     */
    AutomaticMinimum = 6,
    /**
     * The longest data bar is proportional to the highest value across the associated range.
     * Applicable only to the [[IconCriterion]] class.
     */
    AutomaticMaximum = 7
}
/**
 * @hidden
 */
export declare let FormatConditionValueType_$type: Type;
/**
 * Constants which define the manner in which a cell's date/time value is compared
 * when evaluating a [[DateTimeConditionalFormat]].
 */
export declare enum FormatConditionTimePeriod {
    /**
     * The cell's date/time value is compared to the current date.
     */
    Today = 0,
    /**
     * The cell's date/time value is compared to the day after the current date.
     */
    Tomorrow = 1,
    /**
     * The cell's date/time value is compared to the day before the current date.
     */
    Yesterday = 2,
    /**
     * The cell's date/time value is compared to the current week, as defined by the
     * [[CalendarWeekRule]].
     */
    ThisWeek = 3,
    /**
     * The cell's date/time value is compared to the week after the current one, as defined by the
     * [[CalendarWeekRule]].
     */
    NextWeek = 4,
    /**
     * The cell's date/time value is compared to the week before the current one, as defined by the
     * [[CalendarWeekRule]].
     */
    LastWeek = 5,
    /**
     * The cell's date/time value meets the condition if it lies within the range
     * of the past seven days, without regard to the
     * [[CalendarWeekRule]].
     */
    LastSevenDays = 6,
    /**
     * The cell's date/time value is compared to the current month.
     */
    ThisMonth = 7,
    /**
     * The cell's date/time value is compared to the month after the current one.
     */
    NextMonth = 8,
    /**
     * The cell's date/time value is compared to the month before the current one.
     */
    LastMonth = 9
}
/**
 * @hidden
 */
export declare let FormatConditionTimePeriod_$type: Type;
/**
 * Constans which identify whether a [[RankConditionalFormat]] evaluates
 * to true for the top or bottom ranked values across the associated range.
 */
export declare enum FormatConditionTopBottom {
    /**
     * The cell value must fall within the bottom ranking of values for the associated range.
     */
    Bottom = 0,
    /**
     * The cell value must fall within the top ranking of values for the associated range.
     */
    Top = 1
}
/**
 * @hidden
 */
export declare let FormatConditionTopBottom_$type: Type;
/**
 * Constants which specify the manner in which cell values are compared
 * when evaluating a [[AverageConditionalFormat]].
 */
export declare enum FormatConditionAboveBelow {
    /**
     * The cell value must be above the average for the associated range
     * in order to meet the associated condition.
     */
    AboveAverage = 0,
    /**
     * The cell value must be below the average for the associated range
     * in order to meet the associated condition.
     */
    BelowAverage = 1,
    /**
     * The cell value must be equal to or above the average for the associated range
     * in order to meet the associated condition.
     */
    EqualAboveAverage = 2,
    /**
     * The cell value must be equal to or below the average for the associated range
     * in order to meet the associated condition.
     */
    EqualBelowAverage = 3,
    /**
     * The cell value must be above the standard deviation for the associated range
     * in order to meet the associated condition.
     */
    AboveStandardDeviation = 4,
    /**
     * The cell value must be below the standard deviation for the associated range
     * in order to meet the associated condition.
     */
    BelowStandardDeviation = 5
}
/**
 * @hidden
 */
export declare let FormatConditionAboveBelow_$type: Type;
/**
 * Constants which specify the text comparison method applied when
 * evaluating a <see cref="ConditionalFormatBase">format condition</see>.
 */
export declare enum FormatConditionTextOperator {
    /**
     * The string being evaluated must begin with the value to which
     * it is being compared in order for the condition to be met.
     */
    BeginsWith = 0,
    /**
     * The string being evaluated must end with the value to which
     * it is being compared in order for the condition to be met.
     */
    EndsWith = 1,
    /**
     * The string being evaluated must match some part of the value to which
     * it is being compared in order for the condition to be met.
     */
    Contains = 2,
    /**
     * Negates the [[FormatConditionTextOperator.contains]] value; the string being evaluated
     * must not match any part of the value to which it is being compared in
     * order for the condition to be met.
     */
    DoesNotContain = 3
}
/**
 * @hidden
 */
export declare let FormatConditionTextOperator_$type: Type;
/**
 * Constants which specify the manner in which a cell value is
 * compared against one or more operands.
 */
export declare enum FormatConditionOperator {
    /**
     * The condition evaluates to true if the cell value is between
     * the values of the two operands.
     */
    Between = 0,
    /**
     * The condition evaluates to true if the cell value is not between
     * the values of the two operands.
     */
    NotBetween = 1,
    /**
     * The condition evaluates to true if the cell value is equal to
     * the value of the operand.
     */
    Equal = 2,
    /**
     * The condition evaluates to true if the cell value is not equal to
     * the value of the operand.
     */
    NotEqual = 3,
    /**
     * The condition evaluates to true if the cell value is greater than
     * the value of the operand.
     */
    Greater = 4,
    /**
     * The condition evaluates to true if the cell value is less than
     * the value of the operand.
     */
    Less = 5,
    /**
     * The condition evaluates to true if the cell value is greater than
     * or equal to the value of the operand.
     */
    GreaterEqual = 6,
    /**
     * The condition evaluates to true if the cell value is less than
     * or equal to the value of the operand.
     */
    LessEqual = 7
}
/**
 * @hidden
 */
export declare let FormatConditionOperator_$type: Type;
/**
 * Constants which determine the criteria for a format <see cref="ConditionBase">condition</see>.
 */
export declare enum FormatConditionType {
    /**
     * The format is based on the cell's value, which is evaluated against
     * one or more conditions to determine whether the value meets a particular
     * criteria.
     */
    CellValue = 0,
    /**
     * The format is determined by evaluating a formula.
     */
    Expression = 1,
    /**
     * Represents a conditional formatting rule which applies gradations to
     * cell colors to indicate relative differences in the values of cells
     * which belong to the associated range.
     */
    ColorScale = 2,
    /**
     * Represents a conditional formatting rule which renders a color bar
     * inside the cell to indicate relative differences in the values of cells
     * which belong to the associated range.
     */
    DataBar = 3,
    /**
     * Cells with the top/bottom <i>n</i> values are formatted, where <i>n</i>
     * represents a numeric, percentage, or percentile ranking. For example,
     * this type can be used to to enable a 'top ten' condition.
     */
    Rank = 4,
    /**
     * Represents a conditional formatting rule which displays an icon
     * inside the cell which indicates the cell's value as relative to
     * the highest and lowest value in the associated range.
     */
    IconSets = 5,
    /**
     * Cells with values which are unique across the associated range are formatted.
     */
    UniqueValues = 6,
    /**
     * Cells with values which are duplicated (non-unique) across the associated range are formatted.
     */
    DuplicateValues = 7,
    /**
     * The format is determined by whether the cell's value matches a literal string value.
     */
    TextString = 8,
    /**
     * Cells with no value are formatted. Note that foreground-related
     * properties such as font colors are not applicable.
     */
    Blanks = 9,
    /**
     * The format is determined by whether a cell's date value falls within
     * a given period of time.
     */
    TimePeriod = 10,
    /**
     * Cells with values which are greater than or less than the average value
     * for the associated region are formatted.
     */
    Average = 11,
    /**
     * Cells with a non-empty value are formatted.
     */
    NoBlanks = 12,
    /**
     * The format is applied to cells which contain an error.
     */
    Errors = 13,
    /**
     * The format is applied to cells which do not contain an error.
     */
    NoErrors = 14
}
/**
 * @hidden
 */
export declare let FormatConditionType_$type: Type;
/**
 * @hidden
 */
export declare const enum FormatConditionNotificationType {
    NoneRquired = 0,
    WhenCellInRegionChanges = 1,
    WhenAnyCellChanges = 2
}
/**
 * @hidden
 */
export declare let FormatConditionNotificationType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetFilterSettings_WorksheetFilterFlags {
    RefilterRequired = 1
}
/**
 * @hidden
 */
export declare let WorksheetFilterSettings_WorksheetFilterFlags_$type: Type;
/**
 * Represents the various filter types available for the [[TopOrBottomFilter]].
 * @see [[TopOrBottomFilter.type]]
 */
export declare enum TopOrBottomFilterType {
    /**
     * Filter in the top N values in the sorted list of values.
     */
    TopValues = 0,
    /**
     * Filter in the bottom N values in the sorted list of values.
     */
    BottomValues = 1,
    /**
     * Filter in the top N percent of values the sorted list of values.
     */
    TopPercentage = 2,
    /**
     * Filter in the bottom N percent of values the sorted list of values.
     */
    BottomPercentage = 3
}
/**
 * @hidden
 */
export declare let TopOrBottomFilterType_$type: Type;
/**
 * Represents the various relative date offsets which can be filtered by the [[RelativeDateRangeFilter]].
 * @see [[RelativeDateRangeFilter.offset]]
 */
export declare enum RelativeDateRangeOffset {
    /**
     * Filter in values in the previous duration relative to the filter's creation date.
     */
    Previous = 0,
    /**
     * Filter in values in the current duration relative to the filter's creation date.
     */
    Current = 1,
    /**
     * Filter in values in the next duration relative to the filter's creation date.
     */
    Next = 2
}
/**
 * @hidden
 */
export declare let RelativeDateRangeOffset_$type: Type;
/**
 * Represents the various durations which can be filtered by the [[RelativeDateRangeFilter]].
 * @see [[RelativeDateRangeFilter.duration]]
 */
export declare enum RelativeDateRangeDuration {
    /**
     * The duration of accepted values is one day.
     */
    Day = 0,
    /**
     * The duration of accepted values is one week.
     */
    Week = 1,
    /**
     * The duration of accepted values is one month.
     */
    Month = 2,
    /**
     * The duration of accepted values is one quarter.
     */
    Quarter = 3,
    /**
     * The duration of accepted values is one year.
     */
    Year = 4
}
/**
 * @hidden
 */
export declare let RelativeDateRangeDuration_$type: Type;
/**
 * Represents the various types, or precisions, of a [[FixedDateGroup]].
 * @see [[FixedDateGroup.type]]
 */
export declare enum FixedDateGroupType {
    /**
     * The group represents the day in which the [[FixedDateGroup.value]] exists.
     */
    Day = 0,
    /**
     * The group represents the hour in which the [[FixedDateGroup.value]] exists.
     */
    Hour = 1,
    /**
     * The group represents the minute in which the [[FixedDateGroup.value]] exists.
     */
    Minute = 2,
    /**
     * The group represents the month in which the [[FixedDateGroup.value]] exists.
     */
    Month = 3,
    /**
     * The group represents the second in which the [[FixedDateGroup.value]] exists.
     */
    Second = 4,
    /**
     * The group represents the year in which the [[FixedDateGroup.value]] exists.
     */
    Year = 5
}
/**
 * @hidden
 */
export declare let FixedDateGroupType_$type: Type;
/**
 * Represents the various comparisons which can be used in the [[CustomFilterCondition]].
 * @see [[CustomFilterCondition.comparisonOperator]]
 */
export declare enum ExcelComparisonOperator {
    /**
     * Filter in values which are equal to the comparison value.
     */
    Equals = 0,
    /**
     * Filter in values which are not equal to the comparison value.
     */
    NotEqual = 1,
    /**
     * Filter in values which are greater than the comparison value.
     */
    GreaterThan = 2,
    /**
     * Filter in values which are greater than or equal to the comparison value.
     */
    GreaterThanOrEqual = 3,
    /**
     * Filter in values which are less than the comparison value.
     */
    LessThan = 4,
    /**
     * Filter in values which are less than or equal to the comparison value.
     */
    LessThanOrEqual = 5,
    /**
     * Filter in string values which begin with the comparison value.
     */
    BeginsWith = 6,
    /**
     * Filter in string values which do not begin with the comparison value.
     */
    DoesNotBeginWith = 7,
    /**
     * Filter in string values which ends with the comparison value.
     */
    EndsWith = 8,
    /**
     * Filter in string values which do not end with the comparison value.
     */
    DoesNotEndWith = 9,
    /**
     * Filter in string values which contain the comparison value.
     */
    Contains = 10,
    /**
     * Filter in string values which do not contain the comparison value.
     */
    DoesNotContain = 11
}
/**
 * @hidden
 */
export declare let ExcelComparisonOperator_$type: Type;
/**
 * Represents the various date range types which can be filtered by the [[DatePeriodFilter]].
 * @see [[DatePeriodFilter.type]]
 */
export declare enum DatePeriodFilterType {
    /**
     * Filter in dates in a specific month of any year.
     */
    Month = 0,
    /**
     * Filter in dates in a specific quarter of any year.
     */
    Quarter = 1
}
/**
 * @hidden
 */
export declare let DatePeriodFilterType_$type: Type;
/**
 * Represents the various logical operators used to combine the conditions of the [[CustomFilter]].
 * @see [[CustomFilter.conditionalOperator]]
 */
export declare enum ConditionalOperator {
    /**
     * Filter in values where only [[CustomFilter.condition1]] and [[CustomFilter.condition2]] pass.
     */
    And = 0,
    /**
     * Filter in values where either [[CustomFilter.condition1]] or [[CustomFilter.condition2]] (or both) pass.
     */
    Or = 1
}
/**
 * @hidden
 */
export declare let ConditionalOperator_$type: Type;
/**
 * Represents the various calendar types available for the [[FixedValuesFilter]]
 * @see [[FixedValuesFilter.calendarType]]
 */
export declare enum CalendarType {
    /**
     * The Gregorian calendar should be used.
     */
    Gregorian = 0,
    /**
     * The Arabic version of the Gregorian calendar should be used.
     */
    GregorianArabic = 1,
    /**
     * The Middle East French version of the Gregorian calendar should be used.
     */
    GregorianMeFrench = 2,
    /**
     * The US English version of the Gregorian calendar should be used.
     */
    GregorianUs = 3,
    /**
     * The transliterated English version of the Gregorian calendar should be used.
     */
    GregorianXlitEnglish = 4,
    /**
     * The transliterated French version of the Gregorian calendar should be used.
     */
    GregorianXlitFrench = 5,
    /**
     * The Hebrew lunar calendar, as described by the Gauss formula for Passover and The Complete Restatement of Oral Law,
     * should be used.
     */
    Hebrew = 6,
    /**
     * The Hijri lunar calendar, as described by the Kingdom of Saudi Arabia, Ministry of Islamic Affairs, Endowments, Dawah
     * and Guidance, should be used.
     */
    Hijri = 7,
    /**
     * The Japanese Emperor Era calendar, as described by Japanese Industrial Standard JIS X 0301, should be used.
     */
    Japan = 8,
    /**
     * The Korean Tangun Era calendar, as described by Korean Law Enactment No. 4, should be used.
     */
    Korea = 9,
    /**
     * Specifies that no calendar should be used.
     */
    None = 10,
    /**
     * The Saka Era calendar, as described by the Calendar Reform Committee of India, as part of the Indian Ephemeris and Nautical
     * Almanac, should be used.
     */
    Saka = 11,
    /**
     * The Taiwanese calendar, as defined by the Chinese National Standard CNS 7648, should be used.
     */
    Taiwan = 12,
    /**
     * The Thai calendar, as defined by the Royal Decree of H.M. King Vajiravudh (Rama VI) in Royal Gazette B. E. 2456 (1913 A.D.)
     * and by the decree of Prime Minister Phibunsongkhram (1941 A.D.) to start the year on the Gregorian January 1 and to map year
     * zero to Gregorian year 543 B.C., should be used.
     */
    Thai = 13
}
/**
 * @hidden
 */
export declare let CalendarType_$type: Type;
/**
 * Represents the various types of the [[AverageFilter]].
 * @see [[AverageFilter.type]]
 */
export declare enum AverageFilterType {
    /**
     * Filter in values above the average of the entire range of data being filtered.
     */
    AboveAverage = 0,
    /**
     * Filter in values below the average of the entire range of data being filtered.
     */
    BelowAverage = 1
}
/**
 * @hidden
 */
export declare let AverageFilterType_$type: Type;
/**
 * @hidden
 */
export declare const enum RefBase_InternalFlags {
    NodeStateMask = 3,
    HasNewFormulaToBeCalculated = 4,
    IsDirty = 8,
    IsInCalcNetwork = 16,
    IsInCircularity = 32,
    IsInNamedReferenceOnlyCircularity = 64,
    IgnoreNextCalculatedValue = 128
}
/**
 * @hidden
 */
export declare let RefBase_InternalFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum NonNumericElementBehavior {
    CausesError = 0,
    TreatAsZero = 1,
    Ignore = 2
}
/**
 * @hidden
 */
export declare let NonNumericElementBehavior_$type: Type;
/**
 * @hidden
 */
export declare const enum TokenClass {
    Reference = 32,
    Value = 64,
    Array = 96,
    Control = 255
}
/**
 * @hidden
 */
export declare let TokenClass_$type: Type;
/**
 * @hidden
 */
export declare const enum Token {
    Exp = 1,
    Tbl = 2,
    Add = 3,
    Sub = 4,
    Mul = 5,
    Div = 6,
    Power = 7,
    Concat = 8,
    LT = 9,
    LE = 10,
    EQ = 11,
    GE = 12,
    GT = 13,
    NE = 14,
    Isect = 15,
    Union = 16,
    Range = 17,
    Uplus = 18,
    Uminus = 19,
    Percent = 20,
    Paren = 21,
    MissArg = 22,
    Str = 23,
    Extended = 24,
    Attr = 25,
    Err = 28,
    Bool = 29,
    Int = 30,
    Number = 31,
    ArrayR = 32,
    ArrayV = 64,
    ArrayA = 96,
    FuncR = 33,
    FuncV = 65,
    FuncA = 97,
    FuncVarR = 34,
    FuncVarV = 66,
    FuncVarA = 98,
    NameR = 35,
    NameV = 67,
    NameA = 99,
    RefR = 36,
    RefV = 68,
    RefA = 100,
    AreaR = 37,
    AreaV = 69,
    AreaA = 101,
    MemAreaR = 38,
    MemAreaV = 70,
    MemAreaA = 102,
    MemErrR = 39,
    MemErrV = 71,
    MemErrA = 103,
    MemNoMemR = 40,
    MemNoMemV = 72,
    MemNoMemA = 104,
    MemFuncR = 41,
    MemFuncV = 73,
    MemFuncA = 105,
    RefErrR = 42,
    RefErrV = 74,
    RefErrA = 106,
    AreaErrR = 43,
    AreaErrV = 75,
    AreaErrA = 107,
    RefNR = 44,
    RefNV = 76,
    RefNA = 108,
    AreaNR = 45,
    AreaNV = 77,
    AreaNA = 109,
    NameXR = 57,
    NameXV = 89,
    NameXA = 121,
    Ref3dR = 58,
    Ref3dV = 90,
    Ref3dA = 122,
    Area3DR = 59,
    Area3DV = 91,
    Area3DA = 123,
    RefErr3dR = 60,
    RefErr3dV = 92,
    RefErr3dA = 124,
    AreaErr3dR = 61,
    AreaErr3dV = 93,
    AreaErr3dA = 125,
    Excel2007Token = 4096,
    StructuredTableReferenceR = 4128,
    StructuredTableReferenceV = 4160,
    StructuredTableReferenceA = 4192
}
/**
 * @hidden
 */
export declare let Token_$type: Type;
/**
 * @hidden
 */
export declare const enum AttrTokenBase_AttrType {
    Volatile = 1,
    If = 2,
    Choose = 4,
    Skip = 8,
    Sum = 16,
    Assign = 32,
    Space = 64,
    SpaceVolatile = 65
}
/**
 * @hidden
 */
export declare let AttrTokenBase_AttrType_$type: Type;
/**
 * @hidden
 */
export declare const enum WhitespaceType {
    SpacesBeforeNextToken = 0,
    CarriageReturnsBeforeNextToken = 1,
    SpacesBeforeOpeningParens = 2,
    CarriageReturnsBeforeOpeningParens = 3,
    SpacesBeforeClosingParens = 4,
    CarriageReturnsBeforeClosingParens = 5,
    SpacesFollowEqualitySign = 6
}
/**
 * @hidden
 */
export declare let WhitespaceType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetSortSettings_WorksheetSortFlags {
    SortRequired = 1
}
/**
 * @hidden
 */
export declare let WorksheetSortSettings_WorksheetSortFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum SortMethod {
    Default = 0,
    PinYin = 1,
    Stroke = 2
}
/**
 * @hidden
 */
export declare let SortMethod_$type: Type;
/**
 * Represents the various sort directions which can be used with a [[SortCondition]].
 * @see [[SortCondition.sortDirection]]
 */
export declare enum SortDirection {
    /**
     * Sort values in an ascending manner.
     */
    Ascending = 0,
    /**
     * Sort values in an descending manner.
     */
    Descending = 1
}
/**
 * @hidden
 */
export declare let SortDirection_$type: Type;
/**
 * @hidden
 */
export declare const enum SparklineGroup_BitValues {
    DateAxis = 1,
    Markers = 2,
    HighPoint = 4,
    LowPoint = 8,
    FirstPoint = 16,
    LastPoint = 32,
    NegativePoints = 64,
    DisplayXAxis = 128,
    DisplayHidden = 256,
    RightToLeft = 512,
    Isinitialized = 1024,
    IsRemovedFromColection = 2048
}
/**
 * @hidden
 */
export declare let SparklineGroup_BitValues_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetRow_InternalFlags {
    Hidden = 1,
    HasThickTop = 2,
    HasThickBottom = 4,
    HasThickTopIsDirty = 8,
    HasThickBottomIsDirty = 16,
    HasCustomHeight = 32,
    WasRemoved = 64,
    ClonableFlags = 32
}
/**
 * @hidden
 */
export declare let WorksheetRow_InternalFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetColumn_InternalFlags {
    WasRemoved = 1
}
/**
 * @hidden
 */
export declare let WorksheetColumn_InternalFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum CellFormatValueChangedOptions {
    DefaultBehavior = 0,
    PreventAdjacentBorderSyncronization = 1,
    PreventCellToMergedRegionSyncronization = 2,
    PreventMergedRegionToCellSyncronization = 4,
    PreventOwnerToCellSynchronization = 8,
    PreventFontToFormattedStringSynchronization = 16,
    AlwaysSendChangeNotifications = 32,
    SkipDirtyResolvedRowHeight = 64,
    PreventAllSyncronization = -97
}
/**
 * @hidden
 */
export declare let CellFormatValueChangedOptions_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetCellFormatType {
    CellFormat = 0,
    StyleFormat = 1,
    DifferentialFormat = 2
}
/**
 * @hidden
 */
export declare let WorksheetCellFormatType_$type: Type;
/**
 * @hidden
 */
export declare const enum PreventTextFormattingTypes {
    None = 0,
    string1 = 1
}
/**
 * @hidden
 */
export declare let PreventTextFormattingTypes_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetCellBlock_ValueCoercionType {
    None = 0,
    TableHeaderCell = 1,
    TableTotalCell = 2
}
/**
 * @hidden
 */
export declare let WorksheetCellBlock_ValueCoercionType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetCellBlock_DataTypeEncoded {
    byte1 = 0,
    SByte = 1,
    Int16 = 2,
    UInt16 = 3,
    Int32 = 4,
    UInt32 = 5,
    Single = 6,
    boolean1 = 7,
    DBNull = 8,
    ErrorValue = 9,
    Formula = 10,
    Decimal = 11,
    StringBuilder = 12,
    char1 = 14,
    DateTimeNotConvertible = 15,
    en = 16,
    Guid = 17
}
/**
 * @hidden
 */
export declare let WorksheetCellBlock_DataTypeEncoded_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetCellBlock_DataType {
    Null = 0,
    Int64 = 1,
    UInt64 = 2,
    double1 = 3,
    DateTime = 4,
    string1 = 5,
    FormattedString = 6,
    Encoded = 7
}
/**
 * @hidden
 */
export declare let WorksheetCellBlock_DataType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorkbookStyleCollection_RemovalType {
    HideBuiltInStyles = 0,
    RemoveBuiltInStyles = 1,
    ResetBuiltInStyles = 2
}
/**
 * @hidden
 */
export declare let WorkbookStyleCollection_RemovalType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorkbookFontProxy_PropertyIds {
    Bold = 0,
    ColorInfo = 1,
    Height = 2,
    Italic = 3,
    Name1 = 4,
    Strikeout = 5,
    SuperscriptSubscriptStyle = 6,
    UnderlineStyle = 7
}
/**
 * @hidden
 */
export declare let WorkbookFontProxy_PropertyIds_$type: Type;
/**
 * @hidden
 */
export declare const enum FontFamilyInternal {
    DontCare = 0,
    Roman = 1,
    Swiss = 2,
    Modern = 3,
    Script = 4,
    Decorative = 5
}
/**
 * @hidden
 */
export declare let FontFamilyInternal_$type: Type;
/**
 * @hidden
 */
export declare const enum SystemColorsInternal_SystemColorValue {
    ActiveBorder = 0,
    ActiveCaption = 1,
    ActiveCaptionText = 2,
    AppWorkspace = 3,
    ButtonFace = 4,
    ButtonHighlight = 5,
    ButtonShadow = 6,
    Control = 7,
    ControlDark = 8,
    ControlDarkDark = 9,
    ControlLight = 10,
    ControlLightLight = 11,
    ControlText = 12,
    Desktop = 13,
    GradientActiveCaption = 14,
    GradientInactiveCaption = 15,
    GrayText = 16,
    Highlight = 17,
    HighlightText = 18,
    HotTrack = 19,
    InactiveBorder = 20,
    InactiveCaption = 21,
    InactiveCaptionText = 22,
    Info = 23,
    InfoText = 24,
    Menu = 25,
    MenuBar = 26,
    MenuHighlight = 27,
    MenuText = 28,
    ScrollBar = 29,
    Window = 30,
    WindowFrame = 31,
    WindowText = 32,
    MaxValue = 33
}
/**
 * @hidden
 */
export declare let SystemColorsInternal_SystemColorValue_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetTableColumn_InternalFlags {
    HasBeenInitialized = 1,
    HoldHasBeenInitialized = 2,
    OverwriteExistingValues = 4,
    SuspendCellValueSynchronizations = 8
}
/**
 * @hidden
 */
export declare let WorksheetTableColumn_InternalFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetTable_TableFlags {
    DisplayBandedColumns = 1,
    DisplayBandedRows = 2,
    DisplayFirstColumnFormatting = 4,
    DisplayLastColumnFormatting = 8,
    HasTotalsRowEverBeenVisible = 16,
    IsFilterUIVisible = 32,
    IsHeaderRowVisible = 64,
    IsInsertRowVisible = 128,
    IsResizing = 256,
    IsTotalsRowVisible = 512,
    PreventAssigningUniqueColumnNames = 1024,
    Published = 2048,
    RefilterRequired = 4096,
    SuspendAreaFormatSynchronization = 8192,
    WereCellsShiftedToShowInsertRow = 16384,
    IsChangingHeaderOrTotalRowVisibility = 32768,
    IsProcessingUndo = 65536
}
/**
 * @hidden
 */
export declare let WorksheetTable_TableFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetProtectionType {
    Objects = 1,
    Scenarios = 2,
    FormatCells = 4,
    FormatColumns = 8,
    FormatRows = 16,
    InsertColumns = 32,
    InsertRows = 64,
    InsertHyperlinks = 128,
    DeleteColumns = 256,
    DeleteRows = 512,
    Sort = 1024,
    AutoFilter = 2048,
    PivotTables = 4096
}
/**
 * @hidden
 */
export declare let WorksheetProtectionType_$type: Type;
/**
 * Enumeration used to indicate which cells may be selected when the Worksheet is protected.
 * @see [[WorksheetProtection.selectionMode]]
 */
export declare enum WorksheetProtectedSelectionMode {
    /**
     * All cells including locked cells may be selected.
     */
    AllCells = 0,
    /**
     * Only cells that are unlocked may be selected via the keyboard or mouse. Note a cell that is locked may be selected if a range selection is created between 2 unlocked cells.
     */
    UnlockedCells = 1,
    /**
     * The selection cannot be change.
     */
    NoCells = 2
}
/**
 * @hidden
 */
export declare let WorksheetProtectedSelectionMode_$type: Type;
/**
 * @hidden
 */
export declare const enum LoadOnDemandTree_FindState {
    ValueNotFound = 0,
    ValueFound = 1,
    ValueInserted = 2
}
/**
 * @hidden
 */
export declare let LoadOnDemandTree_FindState_$type: Type;
/**
 * @hidden
 */
export declare const enum ApplyFormulaFlags {
    None = 0,
    PreventNumberFormat = 1
}
/**
 * @hidden
 */
export declare let ApplyFormulaFlags_$type: Type;
/**
 * @hidden
 */
export declare const enum Formula_InternalFlags {
    RecalculateAlways = 1,
    AreTokenReferencesResolved = 2,
    HasHyperlink = 4,
    IsConnected = 8,
    IsDirtyOnLoad = 16,
    MayUseDynamicReferences = 32,
    HasMissingFunctions = 64
}
/**
 * @hidden
 */
export declare let Formula_InternalFlags_$type: Type;
/**
 * Represents the various visibilities of a worksheet.
 * <p class="body">
 * The worksheet visibility indicates how the worksheet will be displayed in the tab bar at
 * the bottom of the workbook window in Microsoft Excel.
 * </p>
 */
export declare enum WorksheetVisibility {
    /**
     * The worksheet tab is present in the tab bar.
     */
    Visible = 0,
    /**
     * The worksheet tab is not present in the tab bar. The worksheet can be made visible
     * from the Unhide dialog in Microsoft Excel.
     */
    Hidden = 1,
    /**
     * The worksheet tab is not present in the tab bar. The worksheet can only be made visible
     * again through a Visual Basic procedure in Microsoft Excel. The worksheet can not be made
     * visible through the user interface.
     */
    StrongHidden = 2
}
/**
 * @hidden
 */
export declare let WorksheetVisibility_$type: Type;
/**
 * Represents the various views for a worksheet.
 */
export declare enum WorksheetView {
    /**
     * The worksheet is displayed in the normal view.
     */
    Normal = 0,
    /**
     * The worksheet is displayed as it will appear when printed. This view displays where
     * printed pages will begin and end as well as any headers or footers for the workbook.
     * This value is only supported in Excel 2007 and defaults to Normal in earlier version.
     */
    PageLayout = 1,
    /**
     * This view shows a preview of where pages will break when the worksheet is printed.
     */
    PageBreakPreview = 2
}
/**
 * @hidden
 */
export declare let WorksheetView_$type: Type;
/**
 * Represents the various units in which a column width can be represented.
 * @see [[Worksheet.getDefaultColumnWidth]]
 * @see [[Worksheet.setDefaultColumnWidth]]
 * @see [[WorksheetColumn.getWidth]]
 * @see [[WorksheetColumn.setWidth]]
 */
export declare enum WorksheetColumnWidthUnit {
    /**
     * The column width is represented in units of the '0' digit character width, including column padding. The digit is
     * measured with the default font for the workbook. The padding is a few pixels on either side of the column plus an
     * additional pixel for the gridline.
     */
    Character = 0,
    /**
     * The column width is represented in 256ths of the '0' digit character width, including column padding, which means this
     * value will be 256 times the width expressed in Character units. The digit is measured with the default font for the
     * workbook. The padding is a few pixels on either side of the column plus an additional pixel for the gridline. These
     * units are the units in which the [[WorksheetColumn.width]] and [[Worksheet.defaultColumnWidth]]
     * properties are expressed.
     */
    Character256th = 1,
    /**
     * The column width is represented in units of the '0' digit character width, excluding padding. The digit is measured with
     * the default font for the workbook. These units are the units in which Microsoft Excel displays column widths to the user
     * and accepts new column widths from the user in the 'Column Width' dialog.
     */
    CharacterPaddingExcluded = 2,
    /**
     * The column width is represented in pixels.
     */
    Pixel = 3,
    /**
     * The column width is represented in points.
     */
    Point = 4,
    /**
     * The column width is represented in twips (20ths of a point).
     */
    Twip = 5
}
/**
 * @hidden
 */
export declare let WorksheetColumnWidthUnit_$type: Type;
/**
 * Represents the various areas which can have a format applied at the table style level.
 * <p class="note">
 * <b>Note:</b> Only certain properties can be set on the table style are formats. The are as follows:
 * <list type="bullet">
 * <item>[[IWorksheetCellFormat.bottomBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.bottomBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.fill]]</item>
 * <item>[[IWorksheetCellFormat.leftBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.leftBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.rightBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.rightBorderStyle]]</item>
 * <item>[[IWorksheetCellFormat.topBorderColorInfo]]</item>
 * <item>[[IWorksheetCellFormat.topBorderStyle]]</item>
 * <item><see cref="IWorkbookFont.Bold">Font.Bold</see></item>
 * <item><see cref="IWorkbookFont.ColorInfo">Font.ColorInfo</see></item>
 * <item><see cref="IWorkbookFont.Italic">Font.Italic</see></item>
 * <item><see cref="IWorkbookFont.Strikeout">Font.Strikeout</see></item>
 * <item><see cref="IWorkbookFont.UnderlineStyle">Font.UnderlineStyle</see></item>
 * </list>
 * Setting any other format or font properties on the table style areas will cause an exception.
 * </p>
 * @see [[WorksheetTableStyle.areaFormats]]
 */
export declare enum WorksheetTableStyleArea {
    /**
     * The format is applied to the entire table.
     */
    WholeTable = 0,
    /**
     * The format is applied to the odd numbered column stripes in the table.
     */
    ColumnStripe = 7,
    /**
     * The format is applied to the even numbered column stripes in the table.
     */
    AlternateColumnStripe = 8,
    /**
     * The format is applied to the odd numbered row stripes in the table.
     */
    RowStripe = 5,
    /**
     * The format is applied to the even numbered row stripes in the table.
     */
    AlternateRowStripe = 6,
    /**
     * The format is applied to the last column in the table.
     */
    LastColumn = 4,
    /**
     * The format is applied to the first column in the table.
     */
    FirstColumn = 3,
    /**
     * The format is applied to the header row in the table.
     */
    HeaderRow = 1,
    /**
     * The format is applied to the totals row in the table.
     */
    TotalRow = 2,
    /**
     * The format is applied to the first header cell in the table.
     */
    FirstHeaderCell = 9,
    /**
     * The format is applied to the last header cell in the table.
     */
    LastHeaderCell = 10,
    /**
     * The format is applied to the first total cell in the table.
     */
    FirstTotalCell = 11,
    /**
     * The format is applied to the last total cell in the table.
     */
    LastTotalCell = 12
}
/**
 * @hidden
 */
export declare let WorksheetTableStyleArea_$type: Type;
/**
 * Represents the various areas which can have a format applied at the table column level.
 * @see [[WorksheetTableColumn.areaFormats]]
 */
export declare enum WorksheetTableColumnArea {
    /**
     * The format is applied to the data area of the table column.
     */
    DataArea = 0,
    /**
     * The format is applied to the header cell of the table column.
     */
    HeaderCell = 1,
    /**
     * The format is applied to the total cell of the table column.
     */
    TotalCell = 2
}
/**
 * @hidden
 */
export declare let WorksheetTableColumnArea_$type: Type;
/**
 * Represents the various areas which can have a format applied at the table level.
 * @see [[WorksheetTable.areaFormats]]
 */
export declare enum WorksheetTableArea {
    /**
     * The format is applied to the entire table. Only the outer border properties can be set on this area format.
     * Setting any other will cause an exception.
     */
    WholeTable = 0,
    /**
     * The format is applied to the data area of the table.
     */
    DataArea = 1,
    /**
     * The format is applied to the header row of the table. All but the top border properties can be set on this
     * area format. Setting the top border properties will cause an exception.
     */
    HeaderRow = 2,
    /**
     * The format is applied to the totals row of the table. All but the bottom border properties can be set on this
     * area format. Setting the bottom border properties will cause an exception.
     */
    TotalsRow = 3
}
/**
 * @hidden
 */
export declare let WorksheetTableArea_$type: Type;
/**
 * Determines whether worksheet rows of columns are sorted within the region
 * @see [[WorksheetSortSettings]]
 * @see [[Worksheet.sortSettings]]
 */
export declare enum WorksheetSortType {
    /**
     * Sort rows
     */
    Rows = 0,
    /**
     * Sort columns
     */
    Columns = 1
}
/**
 * @hidden
 */
export declare let WorksheetSortType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetPermissions {
    None = 0,
    SelectLockedCells = 1,
    SelectUnlockedCells = 2,
    FormatCells = 4,
    FormatColumns = 8,
    FormatRows = 16,
    InsertColumns = 32,
    InsertRows = 64,
    InsertHyperlinks = 128,
    DeleteColumns = 256,
    DeleteRows = 512,
    Sort = 1024,
    Filter = 2048,
    PivotTable = 4096,
    EditObjects = 8192,
    EditScenarios = 16384,
    All = -1
}
/**
 * @hidden
 */
export declare let WorksheetPermissions_$type: Type;
/**
 * Represents the various theme colors in a workbook.
 * @see [[WorkbookColorInfo.themeColorType]]
 */
export declare enum WorkbookThemeColorType {
    /**
     * Represents the Text/Background - Light 1 theme color.
     */
    Light1 = 0,
    /**
     * Represents the Text/Background - Dark 1 theme color.
     */
    Dark1 = 1,
    /**
     * Represents the Text/Background - Light 2 theme color.
     */
    Light2 = 2,
    /**
     * Represents the Text/Background - Dark 2 theme color.
     */
    Dark2 = 3,
    /**
     * Represents the Accent 1 theme color.
     */
    Accent1 = 4,
    /**
     * Represents the Accent 2 theme color.
     */
    Accent2 = 5,
    /**
     * Represents the Accent 3 theme color.
     */
    Accent3 = 6,
    /**
     * Represents the Accent 4 theme color.
     */
    Accent4 = 7,
    /**
     * Represents the Accent 5 theme color.
     */
    Accent5 = 8,
    /**
     * Represents the Accent 6 theme color.
     */
    Accent6 = 9,
    /**
     * Represents the Hyperlink theme color.
     */
    Hyperlink = 10,
    /**
     * Represents the Followed Hyperlink theme color.
     */
    FollowedHyperlink = 11
}
/**
 * @hidden
 */
export declare let WorkbookThemeColorType_$type: Type;
/**
 * Represents the various file formats in which a workbook can be saved.
 */
export declare enum WorkbookFormat {
    /**
     * The Excel 97-2003 BIFF8 file format.
     */
    Excel97To2003 = 0,
    /**
     * The Excel 97-2003 Template BIFF8 file format.
     */
    Excel97To2003Template = 1,
    /**
     * The Excel 2007 XML file format.
     */
    Excel2007 = 2,
    /**
     * The Excel 2007 Macro-Enabled XML file format.
     */
    Excel2007MacroEnabled = 3,
    /**
     * The Excel 2007 Macro-Enabled Template XML file format.
     */
    Excel2007MacroEnabledTemplate = 4,
    /**
     * The Excel 2007 Template XML file format.
     */
    Excel2007Template = 5,
    /**
     * The Strict Open XML file format (ISO/IEC 29500 Strict).
     */
    StrictOpenXml = 6
}
/**
 * @hidden
 */
export declare let WorkbookFormat_$type: Type;
/**
 * Represents the various encryption modes that can be used to encrypt documents saved in the 2007 file formats and later.
 */
export declare enum WorkbookEncryptionMode {
    /**
     * Standard encryption used in Excel 2007 and later
     */
    Standard = 0,
    /**
     * Agile encryption used in Excel 2010 and later
     */
    Agile = 1
}
/**
 * @hidden
 */
export declare let WorkbookEncryptionMode_$type: Type;
/**
 * Represents the various vertical text alignment types.
 */
export declare enum VerticalTextAlignment {
    /**
     * Align the text to the bottom of the available area.
     */
    Bottom = 0,
    /**
     * Align the center to the bottom of the available area.
     */
    Center = 1,
    /**
     * Align the text to the top of the available area.
     */
    Top = 2
}
/**
 * @hidden
 */
export declare let VerticalTextAlignment_$type: Type;
/**
 * Enumeration for vertical alignment styles. Default value is used in property override situations.
 */
export declare enum VerticalCellAlignment {
    /**
     * Use the current default.
     */
    Default = -1,
    /**
     * Top alignment.
     */
    Top = 0,
    /**
     * Center alignment.
     */
    Center = 1,
    /**
     * Bottom alignment.
     */
    Bottom = 2,
    /**
     * Justify alignment.
     */
    Justify = 3,
    /**
     * Distributed alignment.
     */
    Distributed = 4
}
/**
 * @hidden
 */
export declare let VerticalCellAlignment_$type: Type;
/**
 * Flagged enumeration which indicates which groups of formatting properties are used in a format.
 * @see [[IWorksheetCellFormat.formatOptions]]
 */
export declare enum WorksheetCellFormatOptions {
    /**
     * No format properties are used on the format.
     */
    None = 0,
    /**
     * The [[IWorksheetCellFormat.formatString]] property is used on the format.
     */
    ApplyNumberFormatting = 1,
    /**
     * The [[IWorksheetCellFormat.alignment]], [[IWorksheetCellFormat.indent]], [[IWorksheetCellFormat.rotation]],
     * [[IWorksheetCellFormat.shrinkToFit]], [[IWorksheetCellFormat.verticalAlignment]], and
     * [[IWorksheetCellFormat.wrapText]] properties are used on the format.
     */
    ApplyAlignmentFormatting = 2,
    /**
     * The [[IWorksheetCellFormat.font]] property is used on the format.
     */
    ApplyFontFormatting = 4,
    /**
     * The [[IWorksheetCellFormat.bottomBorderColorInfo]], [[IWorksheetCellFormat.bottomBorderStyle]],
     * [[IWorksheetCellFormat.diagonalBorderColorInfo]], [[IWorksheetCellFormat.diagonalBorders]],
     * [[IWorksheetCellFormat.diagonalBorderStyle]], [[IWorksheetCellFormat.leftBorderColorInfo]],
     * [[IWorksheetCellFormat.leftBorderStyle]], [[IWorksheetCellFormat.rightBorderColorInfo]],
     * [[IWorksheetCellFormat.rightBorderStyle]], [[IWorksheetCellFormat.topBorderColorInfo]], and
     * [[IWorksheetCellFormat.topBorderStyle]] properties are used on the format.
     */
    ApplyBorderFormatting = 8,
    /**
     * The [[IWorksheetCellFormat.fill]] property is used on the format.
     */
    ApplyFillFormatting = 16,
    /**
     * The [[IWorksheetCellFormat.locked]] property is used on the format.
     */
    ApplyProtectionFormatting = 32,
    /**
     * All properties are used on the format.
     */
    All = 63
}
/**
 * @hidden
 */
export declare let WorksheetCellFormatOptions_$type: Type;
/**
 * Represents the various way to combine a cell's value and format string to get its text.
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 * @see [[WorksheetRow.getCellText]]
 */
export declare enum TextFormatMode {
    /**
     * Format the cell text as it is displayed in the Microsoft Excel UI. This takes into account the cell width when
     * formatting the text.
     */
    AsDisplayed = 0,
    /**
     * Format the cell text as if it had unlimited space in the cell. However, this will not include padding characters
     * from the format string.
     */
    IgnoreCellWidth = 1
}
/**
 * @hidden
 */
export declare let TextFormatMode_$type: Type;
/**
 * @hidden
 */
export declare const enum StyleCategory {
    Custom = 0,
    GoodBadNeutral = 1,
    DataModel = 2,
    TitleAndHeading = 3,
    Themed = 4,
    NumberFormat = 5
}
/**
 * @hidden
 */
export declare let StyleCategory_$type: Type;
/**
 * @hidden
 */
export declare const enum StructuredTableReferenceKeywordType {
    All = 0,
    Data = 1,
    Headers = 2,
    Totals = 3,
    ThisRow = 4
}
/**
 * @hidden
 */
export declare let StructuredTableReferenceKeywordType_$type: Type;
/**
 * Determines the type if sparkline
 * @see [[SparklineGroup.type]]
 */
export declare enum SparklineType {
    /**
     * A line sparkline
     */
    Line = 0,
    /**
     * A series of vertical columns
     */
    Column = 1,
    /**
     * Deprecated - same as WinLoss
     */
    Stacked = 2,
    /**
     * Positive and negative values stacked
     */
    WinLoss = 2
}
/**
 * @hidden
 */
export declare let SparklineType_$type: Type;
/**
 * Determines how blanks are displayed in a sparkline
 * @see [[SparklineGroup.displayBlanksAs]]
 */
export declare enum SparklineDisplayBlanksAs {
    /**
     * Empty cells are plotted as interpolated.
     */
    Span = 0,
    /**
     * Empty cells are not plotted.
     */
    Gap = 1,
    /**
     * Empty cells are plotted as zero.
     */
    Zero = 2
}
/**
 * @hidden
 */
export declare let SparklineDisplayBlanksAs_$type: Type;
/**
 * Determines how the min or max axis is calculated for a
 * @see [[Sparkline]]
 * @see [[SparklineGroup.verticalAxisMaxType]]
 * @see [[SparklineGroup.verticalAxisMinType]]
 */
export declare enum SparklineAxisMinMax {
    /**
     * Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
     */
    Individual = 0,
    /**
     * Specifies that the vertical axis minimum or maximum is shared across all sparklines in this sparkline group and is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
     */
    Group = 1,
    /**
     * Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is specified by the [[SparklineGroup.verticalAxisMin]] or the [[SparklineGroup.verticalAxisMax]] attribute of the [[SparklineGroup]].
     */
    Custom = 2
}
/**
 * @hidden
 */
export declare let SparklineAxisMinMax_$type: Type;
/**
 * Indicates the type of workbook [[Sheet]]
 */
export declare enum SheetType {
    /**
     * A sheet that contains rows and columns of data.
     */
    Worksheet = 0,
    /**
     * A sheet that displays a single [[WorksheetChart]]
     */
    Chartsheet = 1
}
/**
 * @hidden
 */
export declare let SheetType_$type: Type;
/**
 * @hidden
 */
export declare const enum ShapeType {
    NotPrimitive = 0,
    Rectangle = 1,
    RoundRectangle = 2,
    Ellipse = 3,
    Diamond = 4,
    IsocelesTriangle = 5,
    RightTriangle = 6,
    Parallelogram = 7,
    Trapezoid = 8,
    Hexagon = 9,
    Octagon = 10,
    Plus = 11,
    Star = 12,
    Arrow = 13,
    ThickArrow = 14,
    HomePlate = 15,
    Cube = 16,
    Balloon = 17,
    Seal = 18,
    Arc = 19,
    Line = 20,
    Plaque = 21,
    Can = 22,
    Donut = 23,
    TextSimple = 24,
    TextOctagon = 25,
    TextHexagon = 26,
    TextCurve = 27,
    TextWave = 28,
    TextRing = 29,
    TextOnCurve = 30,
    TextOnRing = 31,
    StraightConnector1 = 32,
    BentConnector2 = 33,
    BentConnector3 = 34,
    BentConnector4 = 35,
    BentConnector5 = 36,
    CurvedConnector2 = 37,
    CurvedConnector3 = 38,
    CurvedConnector4 = 39,
    CurvedConnector5 = 40,
    Callout1 = 41,
    Callout2 = 42,
    Callout3 = 43,
    AccentCallout1 = 44,
    AccentCallout2 = 45,
    AccentCallout3 = 46,
    BorderCallout1 = 47,
    BorderCallout2 = 48,
    BorderCallout3 = 49,
    AccentBorderCallout1 = 50,
    AccentBorderCallout2 = 51,
    AccentBorderCallout3 = 52,
    Ribbon = 53,
    Ribbon2 = 54,
    Chevron = 55,
    Pentagon = 56,
    NoSmoking = 57,
    Seal8 = 58,
    Seal16 = 59,
    Seal32 = 60,
    WedgeRectCallout = 61,
    WedgeRRectCallout = 62,
    WedgeEllipseCallout = 63,
    Wave = 64,
    FoldedCorner = 65,
    LeftArrow = 66,
    DownArrow = 67,
    UpArrow = 68,
    LeftRightArrow = 69,
    UpDownArrow = 70,
    IrregularSeal1 = 71,
    IrregularSeal2 = 72,
    LightningBolt = 73,
    Heart = 74,
    PictureFrame = 75,
    QuadArrow = 76,
    LeftArrowCallout = 77,
    RightArrowCallout = 78,
    UpArrowCallout = 79,
    DownArrowCallout = 80,
    LeftRightArrowCallout = 81,
    UpDownArrowCallout = 82,
    QuadArrowCallout = 83,
    Bevel = 84,
    LeftBracket = 85,
    RightBracket = 86,
    LeftBrace = 87,
    RightBrace = 88,
    LeftUpArrow = 89,
    BentUpArrow = 90,
    BentArrow = 91,
    Seal24 = 92,
    StripedRightArrow = 93,
    NotchedRightArrow = 94,
    BlockArc = 95,
    SmileyFace = 96,
    VerticalScroll = 97,
    HorizontalScroll = 98,
    CircularArrow = 99,
    NotchedCircularArrow = 100,
    UturnArrow = 101,
    CurvedRightArrow = 102,
    CurvedLeftArrow = 103,
    CurvedUpArrow = 104,
    CurvedDownArrow = 105,
    CloudCallout = 106,
    EllipseRibbon = 107,
    EllipseRibbon2 = 108,
    FlowChartProcess = 109,
    FlowChartDecision = 110,
    FlowChartInputOutput = 111,
    FlowChartPredefinedProcess = 112,
    FlowChartInternalStorage = 113,
    FlowChartDocument = 114,
    FlowChartMultidocument = 115,
    FlowChartTerminator = 116,
    FlowChartPreparation = 117,
    FlowChartManualInput = 118,
    FlowChartManualOperation = 119,
    FlowChartConnector = 120,
    FlowChartPunchedCard = 121,
    FlowChartPunchedTape = 122,
    FlowChartSummingJunction = 123,
    FlowChartOr = 124,
    FlowChartCollate = 125,
    FlowChartSort = 126,
    FlowChartExtract = 127,
    FlowChartMerge = 128,
    FlowChartOfflineStorage = 129,
    FlowChartOnlineStorage = 130,
    FlowChartMagneticTape = 131,
    FlowChartMagneticDisk = 132,
    FlowChartMagneticDrum = 133,
    FlowChartDisplay = 134,
    FlowChartDelay = 135,
    TextPlainText = 136,
    TextStop = 137,
    TextTriangle = 138,
    TextTriangleInverted = 139,
    TextChevron = 140,
    TextChevronInverted = 141,
    TextRingInside = 142,
    TextRingOutside = 143,
    TextArchUpCurve = 144,
    TextArchDownCurve = 145,
    TextCircleCurve = 146,
    TextButtonCurve = 147,
    TextArchUpPour = 148,
    TextArchDownPour = 149,
    TextCirclePour = 150,
    TextButtonPour = 151,
    TextCurveUp = 152,
    TextCurveDown = 153,
    TextCascadeUp = 154,
    TextCascadeDown = 155,
    TextWave1 = 156,
    TextWave2 = 157,
    TextWave3 = 158,
    TextWave4 = 159,
    TextInflate = 160,
    TextDeflate = 161,
    TextInflateBottom = 162,
    TextDeflateBottom = 163,
    TextInflateTop = 164,
    TextDeflateTop = 165,
    TextDeflateInflate = 166,
    TextDeflateInflateDeflate = 167,
    TextFadeRight = 168,
    TextFadeLeft = 169,
    TextFadeUp = 170,
    TextFadeDown = 171,
    TextSlantUp = 172,
    TextSlantDown = 173,
    TextCanUp = 174,
    TextCanDown = 175,
    FlowChartAlternateProcess = 176,
    FlowChartOffpageConnector = 177,
    Callout90 = 178,
    AccentCallout90 = 179,
    BorderCallout90 = 180,
    AccentBorderCallout90 = 181,
    LeftRightUpArrow = 182,
    Sun = 183,
    Moon = 184,
    BracketPair = 185,
    BracePair = 186,
    Seal4 = 187,
    DoubleWave = 188,
    ActionButtonBlank = 189,
    ActionButtonHome = 190,
    ActionButtonHelp = 191,
    ActionButtonInformation = 192,
    ActionButtonForwardNext = 193,
    ActionButtonBackPrevious = 194,
    ActionButtonEnd = 195,
    ActionButtonBeginning = 196,
    ActionButtonReturn = 197,
    ActionButtonDocument = 198,
    ActionButtonSound = 199,
    ActionButtonMovie = 200,
    HostControl = 201,
    TextBox = 202
}
/**
 * @hidden
 */
export declare let ShapeType_$type: Type;
/**
 * Represents the ways shapes will be repositioned when rows and columns are resized.
 */
export declare enum ShapePositioningMode {
    /**
     * Shapes will move and size with the cells. If columns before (or rows above) the shape are expanded,
     * the shape will shift left. If columns within a shape are expanded, the shape will be widened.
     */
    MoveAndSizeWithCells = 0,
    /**
     * Shapes will move but not size with the cells. If columns before (or rows above) the shape are
     * expanded, the shape will shift left. If columns within a shape are expanded, the shape will not
     * be widened.
     */
    MoveWithCells = 2,
    /**
     * Shapes will not move or size with the cells. The shape will remain in its absolute pixel position of
     * the worksheet, regardless the rows and columns resized before or inside it.
     */
    DontMoveOrSizeWithCells = 3
}
/**
 * @hidden
 */
export declare let ShapePositioningMode_$type: Type;
/**
 * Represents the various scroll bar configurations available for the workbook.
 */
export declare enum ScrollBars {
    /**
     * No scroll bars are shown in Microsoft Excel.
     */
    None = 0,
    /**
     * Only the horizontal scroll bar is shown in Microsoft Excel.
     */
    Horizontal = 1,
    /**
     * Only the vertical scroll bar is shown in Microsoft Excel.
     */
    Vertical = 2,
    /**
     * Both scroll bars are shown in Microsoft Excel.
     */
    Both = 3
}
/**
 * @hidden
 */
export declare let ScrollBars_$type: Type;
/**
 * Represents the ways to scale a worksheet when it is printed.
 */
export declare enum ScalingType {
    /**
     * The scaling factor is used to scale the worksheet when printing.
     */
    UseScalingFactor = 0,
    /**
     * The page maximums are used to determine how many pages the worksheet can be printed on.
     * Less pages can be used if there is not enough printable content in the worksheet.
     */
    FitToPages = 1
}
/**
 * @hidden
 */
export declare let ScalingType_$type: Type;
/**
 * @hidden
 */
export declare const enum ReferenceShiftType {
    MaintainReference = 0,
    MaintainRelativeReferenceOffset = 1
}
/**
 * @hidden
 */
export declare let ReferenceShiftType_$type: Type;
/**
 * Represents the various ways to print cell notes.
 */
export declare enum PrintNotes {
    /**
     * Cell notes are not printed.
     */
    DontPrint = 0,
    /**
     * Cell notes are printed as they are shown on the worksheet. With this option, cell
     * notes will only appear in the printed worksheet if they are displayed on the worksheet
     * in Microsoft Excel. If the notes just show indicators in Excel, the indicators and notes
     * will not be printed.
     */
    PrintAsDisplayed = 1,
    /**
     * Cell notes are printed on the last page, after the entire worksheet has printed.
     */
    PrintAtEndOfSheet = 2
}
/**
 * @hidden
 */
export declare let PrintNotes_$type: Type;
/**
 * Represents the various ways to print cell errors in a worksheet.
 */
export declare enum PrintErrors {
    /**
     * Errors are printed just as they are displayed on the worksheet.
     */
    PrintAsDisplayed = 0,
    /**
     * Errors are not prints, as though the cells containing them have no value.
     */
    DontPrint = 1,
    /**
     * Errors are printed as two dashes "--".
     */
    PrintAsDashes = 2,
    /**
     * Errors are prints as "#N/A".
     */
    PrintAsNA = 3
}
/**
 * @hidden
 */
export declare let PrintErrors_$type: Type;
/**
 * Represents the shape types that are predefined in Microsoft Excel.
 */
export declare enum PredefinedShapeType {
    /**
     * Represents the [[DiamondShape]] shape.
     */
    Diamond = 4,
    /**
     * Represents the [[EllipseShape]] shape.
     */
    Ellipse = 3,
    /**
     * Represents the [[HeartShape]] shape.
     */
    Heart = 74,
    /**
     * Represents the [[IrregularSeal1Shape]] shape.
     */
    IrregularSeal1 = 71,
    /**
     * Represents the [[IrregularSeal2Shape]] shape.
     */
    IrregularSeal2 = 72,
    /**
     * Represents the [[LightningBoltShape]] shape.
     */
    LightningBolt = 73,
    /**
     * Represents the [[LineShape]] shape.
     */
    Line = 20,
    /**
     * Represents the [[PentagonShape]] shape.
     */
    Pentagon = 56,
    /**
     * Represents the [[RectangleShape]] shape.
     */
    Rectangle = 1,
    /**
     * Represents the [[RightTriangleShape]] shape.
     */
    RightTriangle = 6,
    /**
     * Represents the [[StraightConnector1Shape]] shape.
     */
    StraightConnector1 = 32
}
/**
 * @hidden
 */
export declare let PredefinedShapeType_$type: Type;
/**
 * Represents the types of precision which can be used when obtaining the value of a cell.
 */
export declare enum Precision {
    /**
     * The display value of the cell is used. If the cell's actual value is 10.005, but it is using currency formatting,
     * it will display as $10.01.  When this cell is used in calculations, its displayed value of 10.01 will be used.
     */
    UseDisplayValues = 0,
    /**
     * The actual value of the cell is used. If the cell's actual value is 10.005, but it is using currency formatting,
     * it will display as $10.01.  When this cell is used in calculations, its stored value of 10.005 will be used,
     * even though the display shows a slightly different value.
     */
    UseRealCellValues = 1
}
/**
 * @hidden
 */
export declare let Precision_$type: Type;
/**
 * Represents the options available for getting or setting the bounds of a shape, cell, or region.
 */
export declare enum PositioningOptions {
    /**
     * No special options should be used. Get and set actual bounds on the worksheet in its current state.
     */
    None = 0,
    /**
     * Ignore the [[RowColumnBase.hidden]] value on all rows and columns.
     * Get and set bounds as if all rows and columns were currently visible.
     */
    TreatAllRowsAndColumnsAsVisible = 1
}
/**
 * @hidden
 */
export declare let PositioningOptions_$type: Type;
/**
 * Represents the various paper sizes available for printing.
 */
export declare enum PaperSize {
    /**
     * Undefined
     */
    Undefined = 0,
    /**
     * Letter 8 1/2\" x 11\"
     */
    Letter = 1,
    /**
     * Letter small 8 1/2\" x 11\"
     */
    LetterSmall = 2,
    /**
     * Tabloid 11\" x 17\"
     */
    Tabloid = 3,
    /**
     * Ledger 17\" x 11\"
     */
    Ledger = 4,
    /**
     * Legal 8 1/2\" x 14\"
     */
    Legal = 5,
    /**
     * Statement 5 1/2\" x 8 1/2\"
     */
    Statement = 6,
    /**
     * Executive 7 1/4\" x 10 1/2\"
     */
    Executive = 7,
    /**
     * A3 297mm x 420mm
     */
    A3 = 8,
    /**
     * A4 210mm x 297mm
     */
    A4 = 9,
    /**
     * A4 small 210mm x 297mm
     */
    A4Small = 10,
    /**
     * A5 148mm x 210mm
     */
    A5 = 11,
    /**
     * B4 (JIS) 257mm x 364mm
     */
    B4JIS = 12,
    /**
     * B5 (JIS) 182mm x 257mm
     */
    B5JIS = 13,
    /**
     * Folio 8 1/2\" x 13\"
     */
    Folio = 14,
    /**
     * Quarto 215mm x 275mm
     */
    Quarto = 15,
    /**
     * 10x14 10\" x 14\"
     */
    Size10x14 = 16,
    /**
     * 11x17 11\" x 17\"
     */
    Size11x17 = 17,
    /**
     * Note 8 1/2\" x 11\"
     */
    Note = 18,
    /**
     * Envelope #9 3 7/8\" x 8 7/8\"
     */
    Envelope9 = 19,
    /**
     * Envelope #10 4 1/8\" x 9 1/2\"
     */
    Envelope10 = 20,
    /**
     * Envelope #11 4 1/2\" x 10 3/8\"
     */
    Envelope11 = 21,
    /**
     * Envelope #12 4 3/4\" x 11\"
     */
    Envelope12 = 22,
    /**
     * Envelope #14 5\" x 11 1/2\"
     */
    Envelope14 = 23,
    /**
     * C 17\" x 22\"
     */
    C = 24,
    /**
     * D 22\" x 34\"
     */
    D = 25,
    /**
     * E 34\" x 44\"
     */
    E = 26,
    /**
     * Envelope DL 110mm x 220mm
     */
    EnvelopeDL = 27,
    /**
     * Envelope C5 162mm x 229mm
     */
    EnvelopeC5 = 28,
    /**
     * Envelope C3 324mm x 458mm
     */
    EnvelopeC3 = 29,
    /**
     * Envelope C4 229mm x 324mm
     */
    EnvelopeC4 = 30,
    /**
     * Envelope C6 114mm x 162mm
     */
    EnvelopeC6 = 31,
    /**
     * Envelope C6/C5 114mm x 229mm
     */
    EnvelopeC6C5 = 32,
    /**
     * B4 (ISO) 250mm x 353mm
     */
    B4ISO_1 = 33,
    /**
     * B5 (ISO) 176mm x 250mm
     */
    B5ISO = 34,
    /**
     * B6 (ISO) 125mm x 176mm
     */
    B6ISO = 35,
    /**
     * Envelope Italy 110mm x 230mm
     */
    EnvelopeItaly = 36,
    /**
     * Envelope Monarch 3 7/8\" x 7 1/2\"
     */
    EnvelopeMonarch = 37,
    /**
     * 6 3/4 Envelope 3 5/8\" x 6 1/2\"
     */
    Size634Envelope = 38,
    /**
     * US Standard Fanfold 14 7/8\" x 11\"
     */
    USStandardFanfold = 39,
    /**
     * German Std. Fanfold 8 1/2\" x 12\"
     */
    GermanStandardFanfold = 40,
    /**
     * German Legal Fanfold 8 1/2\" x 13\"
     */
    GermanLegalFanfold = 41,
    /**
     * B4 (ISO) 250mm x 353mm
     */
    B4ISO_2 = 42,
    /**
     * Japanese Postcard 100mm x 148mm
     */
    JapanesePostcard = 43,
    /**
     * 9x11 9\" x 11\"
     */
    Size9x11 = 44,
    /**
     * 10x11 10\" x 11\"
     */
    Size10x11 = 45,
    /**
     * 15x11 15\" x 11\"
     */
    Size15x11 = 46,
    /**
     * Envelope Invite 220mm x 220mm
     */
    EnvelopeInvite = 47,
    /**
     * Letter Extra 9 1/2\" x 12\"
     */
    LetterExtra = 50,
    /**
     * Legal Extra 9 1/2\" x 15\"
     */
    LegalExtra = 51,
    /**
     * Tabloid Extra 11 11/16\" x 18\"
     */
    TabloidExtra = 52,
    /**
     * A4 Extra 235mm x 322mm
     */
    A4Extra = 53,
    /**
     * Letter Transverse 8 1/2\" x 11\"
     */
    LetterTransverse = 54,
    /**
     * A4 Transverse 210mm x 297mm
     */
    A4Transverse = 55,
    /**
     * Letter Extra Transv. 9 1/2\" x 12\"
     */
    LetterExtraTransverse = 56,
    /**
     * Super A/A4 227mm x 356mm
     */
    SuperAA4 = 57,
    /**
     * Super B/A3 305mm x 487mm
     */
    SuperBA3 = 58,
    /**
     * Letter Plus 8 1/2\" x 12 11/16\"
     */
    LetterPlus = 59,
    /**
     * A4 Plus 210mm x 330mm
     */
    A4Plus = 60,
    /**
     * A5 Transverse 148mm x 210mm
     */
    A5Transverse = 61,
    /**
     * B5 (JIS) Transverse 182mm x 257mm
     */
    B5JISTransverse = 62,
    /**
     * A3 Extra 322mm x 445mm
     */
    A3Extra = 63,
    /**
     * A5 Extra 174mm x 235mm
     */
    A5Extra = 64,
    /**
     * B5 (ISO) Extra 201mm x 276mm
     */
    B5ISOExtra = 65,
    /**
     * A2 420mm x 594mm
     */
    A2 = 66,
    /**
     * A3 Transverse 297mm x 420mm
     */
    A3Transverse = 67,
    /**
     * A3 Extra Transverse 322mm x 445mm
     */
    A3ExtraTransverse = 68,
    /**
     * Dbl. Japanese Postcard 200mm x 148mm
     */
    DblJapanesePostcard = 69,
    /**
     * A6 105mm x 148mm
     */
    A6 = 70,
    /**
     * Letter Rotated 11\" x 8 1/2\"
     */
    LetterRotated = 75,
    /**
     * A3 Rotated 420mm x 297mm
     */
    A3Rotated = 76,
    /**
     * A4 Rotated 297mm x 210mm
     */
    A4Rotated = 77,
    /**
     * A5 Rotated 210mm x 148mm
     */
    A5Rotated = 78,
    /**
     * B4 (JIS) Rotated 364mm x 257mm
     */
    B4JISRotated = 79,
    /**
     * B5 (JIS) Rotated 257mm x 182mm
     */
    B5JISRotated = 80,
    /**
     * Japanese Postcard Rot. 148mm x 100mm
     */
    JapanesePostcardRotated = 81,
    /**
     * Dbl. Jap. Postcard Rot. 148mm x 200mm
     */
    DblJapanesePostcardRotated = 82,
    /**
     * A6 Rotated 148mm x 105mm
     */
    A6Rotated = 83,
    /**
     * B6 (JIS) 128mm x 182mm
     */
    B6JIS = 88,
    /**
     * B6 (JIS) Rotated 182mm x 128mm
     */
    B6JISRotated = 89,
    /**
     * 12x11 12\" x 11\"
     */
    Size12x11 = 90
}
/**
 * @hidden
 */
export declare let PaperSize_$type: Type;
/**
 * @hidden
 */
export declare const enum PaneLocation {
    BottomRight = 0,
    TopRight = 1,
    BottomLeft = 2,
    TopLeft = 3
}
/**
 * @hidden
 */
export declare let PaneLocation_$type: Type;
/**
 * Represents the way pages are numbered when printed.
 */
export declare enum PageNumbering {
    /**
     * Pages are automatically numbered based on the style of the worksheet.
     */
    Automatic = 0,
    /**
     * The starting page number specified is used for the first page, additional
     * pages receive a page number that it one greater than the previous page.
     */
    UseStartPageNumber = 1
}
/**
 * @hidden
 */
export declare let PageNumbering_$type: Type;
/**
 * Represents the ways to order the pages of multiple page worksheets.
 */
export declare enum PageOrder {
    /**
     * The first page to print is the top-left page. The next pages printed are below the first page.
     * When there are no more pages below, the page to the right of the top-left page is printed, then the pages
     * below it, and so on.
     */
    DownThenOver = 0,
    /**
     * The first page to print is the top-left page. The next pages printed are right of the first page.
     * When there are no more pages to the right, the page below the top-left page is printed, then the pages
     * to the right of it, and so on.
     */
    OverThenDown = 1
}
/**
 * @hidden
 */
export declare let PageOrder_$type: Type;
/**
 * Represents the page orientations available when a worksheet is printed.
 */
export declare enum Orientation {
    /**
     * The page is printed with the larger dimension horizontal.
     */
    Landscape = 0,
    /**
     * The page is printed with the larger dimension vertical.
     */
    Portrait = 1,
    /**
     * The page is printed with the default setting.
     */
    Default = 2
}
/**
 * @hidden
 */
export declare let Orientation_$type: Type;
/**
 * Represents the various way objects and shapes are displayed in the workbook.
 */
export declare enum ObjectDisplayStyle {
    /**
     * All object are be shown.
     */
    ShowAll = 0,
    /**
     * Placeholders are shown in place of objects.
     */
    ShowPlaceholders = 1,
    /**
     * No objects or shapes are shown.
     */
    HideAll = 2
}
/**
 * @hidden
 */
export declare let ObjectDisplayStyle_$type: Type;
/**
 * @hidden
 */
export declare const enum NameType {
    Normal = 0,
    AddInFunctionName = 1,
    OleObject = 2
}
/**
 * @hidden
 */
export declare let NameType_$type: Type;
/**
 * @hidden
 */
export declare const enum LengthType {
    EightBit = 0,
    SixteenBit = 1
}
/**
 * @hidden
 */
export declare let LengthType_$type: Type;
/**
 * Represents the various horizontal text alignment types.
 */
export declare enum HorizontalTextAlignment {
    /**
     * Align text in the center of the line.
     */
    Center = 0,
    /**
     * Distributes the words across the entire line.
     */
    Distributed = 1,
    /**
     * Align text so it is justified across the line.
     */
    Justified = 2,
    /**
     * Aligns the text with an adjusted kashida length for Arabic text.
     */
    JustifiedLow = 3,
    /**
     * Align the text to the left of the line.
     */
    Left = 4,
    /**
     * Align the text to the right of the line.
     */
    Right = 5,
    /**
     * Distributes Thai text by treating each character as a word.
     */
    ThaiDistributed = 6
}
/**
 * @hidden
 */
export declare let HorizontalTextAlignment_$type: Type;
/**
 * Enumeration for horizontal alignment styles. Default value is used in property override situations.
 */
export declare enum HorizontalCellAlignment {
    /**
     * Use the current default.
     */
    Default = -1,
    /**
     * Alignment depends on underlying data type.
     */
    General = 0,
    /**
     * Left alignment.
     */
    Left = 1,
    /**
     * Centered alignment.
     */
    Center = 2,
    /**
     * Right alignment.
     */
    Right = 3,
    /**
     * Repeat cell value to fill whole cell.
     */
    Fill = 4,
    /**
     * Justify alignment.
     */
    Justify = 5,
    /**
     * Centers the contents of the left-most cell in a center across selection group. All other cells in the center across selection group must be empty. The cells are not merged, and the data may appear to be in a cell other than the left-most cell.
     */
    CenterAcrossSelection = 6,
    /**
     * Distributed alignment.
     */
    Distributed = 7
}
/**
 * @hidden
 */
export declare let HorizontalCellAlignment_$type: Type;
/**
 * @hidden
 */
export declare const enum FunctionGroup {
    Financial = 1,
    DateAndTime = 2,
    MathAndTrig = 3,
    Statistical = 4,
    LookupAndReference = 5,
    Database = 6,
    Text = 7,
    Logical = 8,
    Information = 9,
    Commands = 10,
    Customizing = 11,
    MacroControl = 12,
    DDEExternal = 13,
    UserDefined = 14
}
/**
 * @hidden
 */
export declare let FunctionGroup_$type: Type;
/**
 * @hidden
 */
export declare const enum FormulaType {
    Formula = 0,
    ArrayFormula = 1,
    SharedFormula = 2,
    NamedReferenceFormula = 3,
    ExternalNamedReferenceFormula = 4,
    ListDataValidationFormula = 5,
    NonListDataValidationFormula = 6,
    ConditionalFormatFormula = 7
}
/**
 * @hidden
 */
export declare let FormulaType_$type: Type;
/**
 * Constants which identify a set of icons for an [[IconSetConditionalFormat]].
 */
export declare enum FormatConditionIconSet {
    /**
     * No icon is shown.
     */
    IconSetNoIcon = -1,
    /**
     * Microsoft.Office.Interop.Excel.xl3Arrows = 1
     */
    IconSet3Arrows = 1,
    /**
     * Microsoft.Office.Interop.Excel.xl3ArrowsGray = 2
     */
    IconSet3ArrowsGray = 2,
    /**
     * Microsoft.Office.Interop.Excel.xl3Flags = 3
     */
    IconSet3Flags = 3,
    /**
     * Microsoft.Office.Interop.Excel.xl3TrafficLights1 = 4
     */
    IconSet3TrafficLights1 = 4,
    /**
     * Microsoft.Office.Interop.Excel.xl3TrafficLights2 = 5
     */
    IconSet3TrafficLights2 = 5,
    /**
     * Microsoft.Office.Interop.Excel.xl3Signs = 6
     */
    IconSet3Signs = 6,
    /**
     * Microsoft.Office.Interop.Excel.xl3Symbols = 7
     */
    IconSet3Symbols = 7,
    /**
     * Microsoft.Office.Interop.Excel.xl3Symbols2 = 8
     */
    IconSet3Symbols2 = 8,
    /**
     * Microsoft.Office.Interop.Excel.xl4Arrows = 9
     */
    IconSet4Arrows = 9,
    /**
     * Microsoft.Office.Interop.Excel.xl4ArrowsGray = 10
     */
    IconSet4ArrowsGray = 10,
    /**
     * Microsoft.Office.Interop.Excel.xl4RedToBlack = 11
     */
    IconSet4RedToBlack = 11,
    /**
     * Microsoft.Office.Interop.Excel.xl4CRV = 12
     */
    IconSet4Rating = 12,
    /**
     * Microsoft.Office.Interop.Excel.xl4TrafficLights = 13
     */
    IconSet4TrafficLights = 13,
    /**
     * Microsoft.Office.Interop.Excel.xl5Arrows = 14
     */
    IconSet5Arrows = 14,
    /**
     * Microsoft.Office.Interop.Excel.xl5ArrowsGray = 15
     */
    IconSet5ArrowsGray = 15,
    /**
     * Microsoft.Office.Interop.Excel.xl5CRV = 16
     */
    IconSet5Rating = 16,
    /**
     * Microsoft.Office.Interop.Excel.xl5Quarters = 17
     */
    IconSet5Quarters = 17,
    /**
     * Microsoft.Office.Interop.Excel.xl3Stars = 18
     */
    IconSet3Stars = 18,
    /**
     * Microsoft.Office.Interop.Excel.xl3Triangles = 19
     */
    IconSet3Triangles = 19,
    /**
     * Microsoft.Office.Interop.Excel.xl5Boxes = 20
     */
    IconSet5Boxes = 20
}
/**
 * @hidden
 */
export declare let FormatConditionIconSet_$type: Type;
/**
 * Identifies the set of icons used by a [[IconCriterion]].
 * @see [[IconCriterion.icon]]
 */
export declare enum FormatConditionIcon {
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenUpArrow = 1
     */
    GreenUpArrow = 1,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowSideArrow = 2
     */
    YellowSideArrow = 2,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedDownArrow = 3
     */
    RedDownArrow = 3,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGrayUpArrow = 4
     */
    GrayUpArrow = 4,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGraySideArrow = 5
     */
    GraySideArrow = 5,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGrayDownArrow = 6
     */
    GrayDownArrow = 6,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenFlag = 7
     */
    GreenFlag = 7,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowFlag = 8
     */
    YellowFlag = 8,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedFlag = 9
     */
    RedFlag = 9,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenCircle = 10
     */
    GreenCircle = 10,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowCircle = 11
     */
    YellowCircle = 11,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedCircleWithBorder = 12
     */
    RedCircleWithBorder = 12,
    /**
     * Microsoft.Office.Interop.Excel.xlIconBlackCircleWithBorder = 13
     */
    BlackCircleWithBorder = 13,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenTrafficLight = 14
     */
    GreenTrafficLight = 14,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowTrafficLight = 15
     */
    YellowTrafficLight = 15,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedTrafficLight = 16
     */
    RedTrafficLight = 16,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowTriangle = 17
     */
    YellowTriangle = 17,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedDiamond = 18
     */
    RedDiamond = 18,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenCheckSymbol = 19
     */
    GreenCheckSymbol = 19,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowExclamationSymbol = 20
     */
    YellowExclamationSymbol = 20,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedCrossSymbol = 21
     */
    RedCrossSymbol = 21,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenCheck = 22
     */
    GreenCheck = 22,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowExclamation = 23
     */
    YellowExclamation = 23,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedCross = 24
     */
    RedCross = 24,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowUpInclineArrow = 25
     */
    YellowUpInclineArrow = 25,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowDownInclineArrow = 26
     */
    YellowDownInclineArrow = 26,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGrayUpInclineArrow = 27
     */
    GrayUpInclineArrow = 27,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGrayDownInclineArrow = 28
     */
    GrayDownInclineArrow = 28,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedCircle = 29
     */
    RedCircle = 29,
    /**
     * Microsoft.Office.Interop.Excel.xlIconPinkCircle = 30
     */
    PinkCircle = 30,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGrayCircle = 31
     */
    GrayCircle = 31,
    /**
     * Microsoft.Office.Interop.Excel.xlIconBlackCircle = 32
     */
    BlackCircle = 32,
    /**
     * Microsoft.Office.Interop.Excel.xlIconCircleWithOneWhiteQuarter = 33
     */
    CircleWithOneWhiteQuarter = 33,
    /**
     * Microsoft.Office.Interop.Excel.xlIconCircleWithTwoWhiteQuarters = 34
     */
    CircleWithTwoWhiteQuarters = 34,
    /**
     * Microsoft.Office.Interop.Excel.xlIconCircleWithThreeWhiteQuarters = 35
     */
    CircleWithThreeWhiteQuarters = 35,
    /**
     * Microsoft.Office.Interop.Excel.xlIconWhiteCircleAllWhiteQuarters = 36
     */
    WhiteCircleAllWhiteQuarters = 36,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon0Bars = 37
     */
    ZeroBars = 37,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon1Bar = 38
     */
    OneBar = 38,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon2Bars = 39
     */
    TwoBars = 39,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon3Bars = 40
     */
    ThreeBars = 40,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon4Bars = 41
     */
    FourBars = 41,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGoldStar = 42
     */
    GoldStar = 42,
    /**
     * Microsoft.Office.Interop.Excel.xlIconHalfGoldStar = 43
     */
    HalfGoldStar = 43,
    /**
     * Microsoft.Office.Interop.Excel.xlIconSilverStar = 44
     */
    SilverStar = 44,
    /**
     * Microsoft.Office.Interop.Excel.xlIconGreenUpTriangle = 45
     */
    GreenUpTriangle = 45,
    /**
     * Microsoft.Office.Interop.Excel.xlIconYellowDash = 46
     */
    YellowDash = 46,
    /**
     * Microsoft.Office.Interop.Excel.xlIconRedDownTriangle = 47
     */
    RedDownTriangle = 47,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon4FilledBoxes = 48
     */
    FourFilledBoxes = 48,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon3FilledBoxes = 49
     */
    ThreeFilledBoxes = 49,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon2FilledBoxes = 50
     */
    TwoFilledBoxes = 50,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon1FilledBox = 51
     */
    OneFilledBox = 51,
    /**
     * Microsoft.Office.Interop.Excel.xlIcon0FilledBoxes = 52
     */
    ZeroFilledBoxes = 52,
    /**
     * Microsoft.Office.Interop.Excel.xlIconNoCellIcon = -1
     */
    NoCellIcon = -1
}
/**
 * @hidden
 */
export declare let FormatConditionIcon_$type: Type;
/**
 * Enumeration for font underline styles. Default value is used in property override situations.
 */
export declare enum FontUnderlineStyle {
    /**
     * Use the current default.
     */
    Default = -1,
    /**
     * No underline style.
     */
    None = 0,
    /**
     * Single underline style.
     */
    Single = 1,
    /**
     * Double underline style.
     */
    double1 = 2,
    /**
     * Single accounting underline style.
     */
    SingleAccounting = 33,
    /**
     * Double accounting underline style.
     */
    DoubleAccounting = 34
}
/**
 * @hidden
 */
export declare let FontUnderlineStyle_$type: Type;
/**
 * Enumeration for font superscript or subscript style. Default value is used in property override situations.
 */
export declare enum FontSuperscriptSubscriptStyle {
    /**
     * Use the current default.
     */
    Default = -1,
    /**
     * No superscript or subscript style.
     */
    None = 0,
    /**
     * Superscript style.
     */
    Superscript = 1,
    /**
     * Subscript style.
     */
    Subscript = 2
}
/**
 * @hidden
 */
export declare let FontSuperscriptSubscriptStyle_$type: Type;
/**
 * Enumeration for fill pattern styles. Default value is used in property override situations.
 */
export declare enum FillPatternStyle {
    /**
     * Obsolete. Use None instead.
     */
    Default = -1,
    /**
     * No fill pattern.
     */
    None = 0,
    /**
     * Solid fill pattern with fill pattern foreground color.
     */
    Solid = 1,
    /**
     * "50% gray" fill pattern.
     */
    Gray50percent = 2,
    /**
     * "75% gray" fill pattern.
     */
    Gray75percent = 3,
    /**
     * "25% gray" fill pattern.
     */
    Gray25percent = 4,
    /**
     * Horizontal stripe fill pattern.
     */
    HorizontalStripe = 5,
    /**
     * Vertical stripe fill pattern.
     */
    VerticalStripe = 6,
    /**
     * Reverse diagonal stripe fill pattern.
     */
    ReverseDiagonalStripe = 7,
    /**
     * Diagonal stripe fill pattern.
     */
    DiagonalStripe = 8,
    /**
     * Diagonal crosshatch fill pattern.
     */
    DiagonalCrosshatch = 9,
    /**
     * Thick diagonal crosshatch fill pattern.
     */
    ThickDiagonalCrosshatch = 10,
    /**
     * Thin horizontal stripe fill pattern.
     */
    ThinHorizontalStripe = 11,
    /**
     * Thin vertical stripe fill pattern.
     */
    ThinVerticalStripe = 12,
    /**
     * Thin reverse diagonal stripe fill pattern.
     */
    ThinReverseDiagonalStripe = 13,
    /**
     * Thin diagonal stripe fill pattern.
     */
    ThinDiagonalStripe = 14,
    /**
     * Thin horizontal crosshatch fill pattern.
     */
    ThinHorizontalCrosshatch = 15,
    /**
     * Thin diagonal crosshatch fill pattern.
     */
    ThinDiagonalCrosshatch = 16,
    /**
     * "12.5% gray" fill pattern.
     */
    Gray12percent = 17,
    /**
     * "6.25% gray" fill pattern.
     */
    Gray6percent = 18
}
/**
 * @hidden
 */
export declare let FillPatternStyle_$type: Type;
/**
 * @hidden
 */
export declare const enum ExcelChangeAction {
    ApplyArrayFormula = 0,
    ApplyTableFilters = 1,
    ApplySortConditions = 2,
    CellComment = 3,
    CellFormat = 4,
    CellValue = 5,
    ChartAdd = 6,
    ChartModify = 7,
    ChartRemove = 8,
    Chartsheet = 9,
    ClearArrayFormula = 10,
    ClearDataTables = 11,
    ClearDataValidationRules = 12,
    ClearDisplayValues = 13,
    ClearFormattedTextParagraphs = 14,
    ClearFixedDateGroups = 15,
    ClearHyperlinks = 16,
    ClearNamedReferences = 17,
    ClearMergedRegions = 18,
    ClearPageBreaks = 19,
    ClearPrintAreas = 20,
    ClearShapes = 21,
    ClearSortConditions = 22,
    ClearTableFilters = 23,
    ClearTableStyles = 24,
    ClearWorksheetTables = 25,
    Column = 26,
    ColumnFormat = 27,
    ConditionalFormat = 28,
    DataTableAdd = 29,
    DataTableRemove = 30,
    DataValidationRule = 31,
    DataValidationRuleAdd = 32,
    DataValidationRuleRemove = 33,
    DocumentProperties = 34,
    DisplayOptions = 35,
    DisplayValueAdd = 36,
    DisplayValueRemove = 37,
    Filter = 38,
    FixedDateGroupAdd = 39,
    FixedDateGroupRemove = 40,
    FormattedString = 41,
    FormattedText = 42,
    FormattedTextParagraph = 43,
    FormattedTextParagraphAdd = 44,
    FormattedTextParagraphRemove = 45,
    FormulaTokensChanged = 46,
    Hyperlink = 47,
    HyperlinkAdd = 48,
    HyperlinkRemove = 49,
    MergedRegionAdd = 50,
    MergedRegionRemove = 51,
    NamedReference = 52,
    NamedReferenceAdd = 53,
    NamedReferenceRemove = 54,
    PageBreakAdd = 55,
    PageBreakRemove = 56,
    PrintAreaAdd = 57,
    PrintAreaRemove = 58,
    PrintOptions = 59,
    Row = 60,
    RowFormat = 61,
    Shape = 62,
    ShapeAdd = 63,
    ShapeRemove = 64,
    Sheet = 65,
    SparklineAdd = 66,
    SparklineRemove = 67,
    SparklineColorChange = 68,
    SparklineDataChange = 69,
    SparklineStyleChange = 70,
    SparklineTypeChange = 71,
    Table = 72,
    TableAdd = 73,
    TableColumn = 74,
    TableColumnInsert = 75,
    TableColumnRemove = 76,
    TableRowInsert = 77,
    TableRowRemove = 78,
    TableResize = 79,
    TableSort = 80,
    TableStyle = 81,
    TableStyleAdd = 82,
    TableStyleRemove = 83,
    TableRemove = 84,
    TableAreaFormat = 85,
    WindowOptions = 86,
    Workbook = 87,
    WorkbookFont = 88,
    WorkbookStyleCellFormat = 89,
    Worksheet = 90,
    SheetAdd = 91,
    SheetRemove = 92,
    WorksheetCellAdd = 93,
    WorksheetCellRemove = 94,
    WorksheetColumnAdd = 95,
    WorksheetColumnRemove = 96,
    WorksheetRowAdd = 97,
    WorksheetRowRemove = 98,
    Zoom = 99,
    ClearProtectedRanges = 100,
    ProtectedRangeAdd = 101,
    ProtectedRangeRemove = 102,
    WorksheetProtection = 103
}
/**
 * @hidden
 */
export declare let ExcelChangeAction_$type: Type;
/**
 * Represents the diagonal borders which can be displayed in cells.
 */
export declare enum DiagonalBorders {
    /**
     * The default value for the diagonal borders.
     */
    Default = 0,
    /**
     * No diagonal borders will be displayed in the cell.
     */
    None = 1,
    /**
     * A diagonal border going from the top-left to bottom-right corner will be displayed in the cell.
     */
    DiagonalDown = 3,
    /**
     * A diagonal border going from the bottom-left to top-right corner will be displayed in the cell.
     */
    DiagonalUp = 5,
    /**
     * Both diagonal borders will be displayed in the cell.
     */
    All = 7
}
/**
 * @hidden
 */
export declare let DiagonalBorders_$type: Type;
/**
 * Represents the various ways a date can be stored internally.
 */
export declare enum DateSystem {
    /**
     * Dates are stored as time elapsed since 1900.
     */
    From1900 = 0,
    /**
     * Dates are stored as time elapsed since 1904 (used mainly on Apple computers).
     */
    From1904 = 1
}
/**
 * @hidden
 */
export declare let DateSystem_$type: Type;
/**
 * @hidden
 */
export declare const enum ColorableItem {
    CellBorder = 0,
    CellFill = 1,
    CellFont = 2,
    WorksheetGrid = 3,
    WorksheetTab = 4
}
/**
 * @hidden
 */
export declare let ColorableItem_$type: Type;
/**
 * @hidden
 */
export declare const enum CellShiftType {
    HorizontalShift = 0,
    TableResizedWithoutShift = 1,
    VerticalRotate = 2,
    VerticalShift = 3
}
/**
 * @hidden
 */
export declare let CellShiftType_$type: Type;
/**
 * @hidden
 */
export declare const enum CellShiftResult {
    Success = 0,
    ErrorLossOfData = 1,
    ErrorLossOfObject = 2,
    ErrorSplitTable = 3,
    ErrorSplitFilterArea = 4,
    ErrorSplitMergedRegion = 5,
    ErrorSplitBlockingValue = 6
}
/**
 * @hidden
 */
export declare let CellShiftResult_$type: Type;
/**
 * @hidden
 */
export declare const enum CellShiftInitializeFormatType {
    UseDefaultFormat = 0,
    FromShiftedCellsAdjacentToInsertRegion = 1,
    FromStationaryCellsAdjacentToInsertRegion = 2
}
/**
 * @hidden
 */
export declare let CellShiftInitializeFormatType_$type: Type;
/**
 * @hidden
 */
export declare const enum CellShiftDeleteReason {
    NotDeleted = 0,
    ShiftDownCoveredAddress = 1,
    ShiftUpCoveredAddress = 2,
    ShiftedOffWorksheetBottom = 3,
    ShiftedOffWorksheetTop = 4
}
/**
 * @hidden
 */
export declare let CellShiftDeleteReason_$type: Type;
/**
 * Represents the various ways cells can be referenced in a formula.
 * <p class="body">
 * Setting this on the [[Workbook.cellReferenceMode]] will also affect the row and column labels.
 * </p>
 */
export declare enum CellReferenceMode {
    /**
     * Cells are referenced by first specifying characters representing the column and a one-based number
     * specifying the row (R54 or CA56). The dollar sign ($) can preface one or both identifiers to make them
     * absolute references ($A$7). Without the dollar sign, references still use absolute row and column addresses,
     * although shifting a formula to a new cell will perform a similar shift on all relative references.
     */
    A1 = 1,
    /**
     * Cells are referenced in the following format R<RowIndex>C<ColumnIndex> (R34C5 or R2C345).
     * These indices are one-based and represent absolute references. To create a relative reference in R1C1 mode, a relative
     * index must be placed inside square brackets following the R and/or C ( R[-1]C[5] or R9C[-3] ).  An R by itself
     * also represents a relative reference and is equivalent to R[0]. Similarly, C is equivalent to C[0], which means a
     * formula of =RC always references the cell which contains the formula.
     */
    R1C1 = 0
}
/**
 * @hidden
 */
export declare let CellReferenceMode_$type: Type;
/**
 * @hidden
 */
export declare const enum CellFormatValue {
    Alignment = 1,
    BottomBorderColorInfo = 2,
    BottomBorderStyle = 4,
    DiagonalBorderColorInfo = 8,
    DiagonalBorders = 16,
    DiagonalBorderStyle = 32,
    Fill = 64,
    FontBold = 128,
    FontColorInfo = 256,
    FontHeight = 512,
    FontItalic = 1024,
    FontName = 2048,
    FontStrikeout = 4096,
    FontSuperscriptSubscriptStyle = 8192,
    FontUnderlineStyle = 16384,
    FormatOptions = 32768,
    FormatString = 65536,
    Indent = 131072,
    LeftBorderColorInfo = 262144,
    LeftBorderStyle = 524288,
    Locked = 1048576,
    RightBorderColorInfo = 2097152,
    RightBorderStyle = 4194304,
    Rotation = 8388608,
    ShrinkToFit = 16777216,
    Style = 33554432,
    TopBorderColorInfo = 67108864,
    TopBorderStyle = 134217728,
    VerticalAlignment = 268435456,
    WrapText = 536870912,
    _EndValue = 1073741824,
    _OuterBorders = 208404486,
    _TopAndBottomBorders = 201326598,
    _UndoElementData = 33587200,
    ThemeProperties = 69470538,
    ThemeColorProperties = 69468490,
    AlignmentFormattingProperties = 830603265,
    BorderFormattingProperties = 208404542,
    FillFormattingProperties = 1073741888,
    FontFormattingProperties = 32640,
    NumberFormattingProperties = 1073807360,
    ProtectionFormattingProperties = 1074790400,
    AllFormattingProperties = 2147483647
}
/**
 * @hidden
 */
export declare let CellFormatValue_$type: Type;
/**
 * Represents the different cell border line styles.
 */
export declare enum CellBorderLineStyle {
    /**
     * Use the default border line style.
     */
    Default = -1,
    /**
     * No border.
     */
    None = 0,
    /**
     * Thin border.
     */
    Thin = 1,
    /**
     * Medium border.
     */
    Medium = 2,
    /**
     * Dashed border.
     */
    Dashed = 3,
    /**
     * Dotted border.
     */
    Dotted = 4,
    /**
     * Thick border.
     */
    Thick = 5,
    /**
     * Double-line border.
     */
    double1 = 6,
    /**
     * Dotted border with small dots.
     */
    Hair = 7,
    /**
     * Dotted border with big dots.
     */
    MediumDashed = 8,
    /**
     * Dash-dot border.
     */
    DashDot = 9,
    /**
     * Medium dash-dot border.
     */
    MediumDashDot = 10,
    /**
     * Dash-dot-dot border.
     */
    DashDotDot = 11,
    /**
     * Medium dash-dot-dot border.
     */
    MediumDashDotDot = 12,
    /**
     * Slanted dash-dot border.
     */
    SlantedDashDot = 13
}
/**
 * @hidden
 */
export declare let CellBorderLineStyle_$type: Type;
/**
 * Represents the the ways formulas are recalculated when their referenced values change.
 * @see [[Workbook.calculationMode]]
 */
export declare enum CalculationMode {
    /**
     * Formulas must be recalculated manually, by pressing a button in the Microsoft Excel interface.
     */
    Manual = 0,
    /**
     * Formulas and data tables are automatically recalculated when the values in referenced cells change.
     */
    Automatic = 1,
    /**
     * Only formulas are automatically recalculated when the values in referenced cells change.
     * Data tables must be recalculated manually.
     */
    AutomaticExceptForDataTables = 2
}
/**
 * @hidden
 */
export declare let CalculationMode_$type: Type;
/**
 * @hidden
 */
export declare const enum BuiltInStyleType {
    Normal = 0,
    RowLevelX = 1,
    ColLevelX = 2,
    Comma = 3,
    Currency = 4,
    Percent = 5,
    Comma0 = 6,
    Currency0 = 7,
    Hyperlink = 8,
    FollowedHyperlink = 9,
    Note = 10,
    WarningText = 11,
    Emphasis1 = 12,
    Emphasis2 = 13,
    Emphasis3 = 14,
    Title = 15,
    Heading1 = 16,
    Heading2 = 17,
    Heading3 = 18,
    Heading4 = 19,
    Input = 20,
    Output = 21,
    Calculation = 22,
    CheckCell = 23,
    LinkedCell = 24,
    Total = 25,
    Good = 26,
    Bad = 27,
    Neutral = 28,
    Accent1 = 29,
    Accent1pct20 = 30,
    Accent1pct40 = 31,
    Accent1pct60 = 32,
    Accent2 = 33,
    Accent2pct20 = 34,
    Accent2pct40 = 35,
    Accent2pct60 = 36,
    Accent3 = 37,
    Accent3pct20 = 38,
    Accent3pct40 = 39,
    Accent3pct60 = 40,
    Accent4 = 41,
    Accent4pct20 = 42,
    Accent4pct40 = 43,
    Accent4pct60 = 44,
    Accent5 = 45,
    Accent5pct20 = 46,
    Accent5pct40 = 47,
    Accent5pct60 = 48,
    Accent6 = 49,
    Accent6pct20 = 50,
    Accent6pct40 = 51,
    Accent6pct60 = 52,
    ExplanatoryText = 53
}
/**
 * @hidden
 */
export declare let BuiltInStyleType_$type: Type;
/**
 * @hidden
 */
export declare const enum BuiltInName {
    ConsolidateArea = 0,
    AutoOpen = 1,
    AutoClose = 2,
    Extract = 3,
    Database = 4,
    Criteria = 5,
    PrintArea = 6,
    PrintTitles = 7,
    Recorder = 8,
    DataForm = 9,
    AutoActivate = 10,
    AutoDeactivate = 11,
    SheetTitle = 12,
    FilterDatabase = 13
}
/**
 * @hidden
 */
export declare let BuiltInName_$type: Type;
/**
 * @hidden
 */
export declare const enum BorderThickness {
    Thin = 0,
    Medium = 1,
    Thick = 2
}
/**
 * @hidden
 */
export declare let BorderThickness_$type: Type;
/**
 * Represents the various operators which can be used when validating the cell value against two constraints.
 * @see [[TwoConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraint]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraint]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraint]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraint]]
 * @see [[TwoConstraintDataValidationRule.getLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setLowerConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.getUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraintFormula]]
 * @see [[TwoConstraintDataValidationRule.setUpperConstraintFormula]]
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 */
export declare enum TwoConstraintDataValidationOperator {
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is between the
     * constraints applied to the validation rule. The constraints are inclusive.
     */
    Between = 0,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is not between the
     * constraints applied to the validation rule. The constraints are exclusive.
     */
    NotBetween = 1
}
/**
 * @hidden
 */
export declare let TwoConstraintDataValidationOperator_$type: Type;
/**
 * Represents the various operators which can be used when validating the cell value against a constraint.
 * @see [[OneConstraintDataValidationRule]]
 * @see [[OneConstraintDataValidationRule.setConstraint]]
 * @see [[OneConstraintDataValidationRule.setConstraint]]
 * @see [[OneConstraintDataValidationRule.getConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.getConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.setConstraintFormula]]
 * @see [[OneConstraintDataValidationRule.setConstraintFormula]]
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 */
export declare enum OneConstraintDataValidationOperator {
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is equal to the
     * constraint applied to the validation rule.
     */
    EqualTo = 2,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is not equal to the
     * constraint applied to the validation rule.
     */
    NotEqualTo = 3,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is greater than the
     * constraint applied to the validation rule.
     */
    GreaterThan = 4,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is greater than or equal to the
     * constraint applied to the validation rule.
     */
    GreaterThanOrEqualTo = 6,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is less than the
     * constraint applied to the validation rule.
     */
    LessThan = 5,
    /**
     * Only allows the cell value if it or its text length, depending on the validation criteria, is less than or equal to the
     * constraint applied to the validation rule.
     */
    LessThanOrEqualTo = 7
}
/**
 * @hidden
 */
export declare let OneConstraintDataValidationOperator_$type: Type;
/**
 * Represents the various styles in which invalid values are handled by Microsoft Excel. When error messages are not
 * shown for invalid values, the error style is ignored and all invalid values are allowed to be set on cells.
 * @see [[DataValidationRule.errorStyle]]
 * @see [[DataValidationRule.showErrorMessageForInvalidValue]]
 */
export declare enum DataValidationErrorStyle {
    /**
     * Invalid values are not allowed. The error dialog shown in Microsoft Excel displays an error icon and retry and cancel
     * buttons. The retry button will put focus back in the cell and allow the user to try to enter a new value. The cancel
     * button will cancel the edit and revert the cell back to the previous value it contained before the edit operation.
     */
    Stop = 0,
    /**
     * Invalid values are allowed. The error dialog shown in Microsoft Excel displays a warning icon, asks the user if they
     * want to continue, and has yes, no and cancel buttons. The yes button commits the value to the cell. The no button will
     * put focus back in the cell and allow the user to try to enter a new value. And the cancel button will cancel the edit
     * and revert the cell back to the previous value it contained before the edit operation.
     */
    Warning = 1,
    /**
     * Invalid values are allowed. The error dialog shown in Microsoft Excel displays an information icon and ok and cancel
     * buttons. The ok button commits the value to the cell. The cancel button will cancel the edit and revert the cell back
     * to the previous value it contained before the edit operation.
     */
    Information = 2
}
/**
 * @hidden
 */
export declare let DataValidationErrorStyle_$type: Type;
/**
 * Determines what types of cell values are allowed and how the cell value is validated against the constraint(s).
 * @see [[ValueConstraintDataValidationRule.validationCriteria]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare enum DataValidationCriteria {
    /**
     * Only numbers are allowed and they cannot have a fractional part.
     * When comparing against constraints, the cell value is used.
     */
    WholeNumber = 1,
    /**
     * Only numbers are allowed.
     * When comparing against constraints, the cell value is used.
     */
    Decimal = 2,
    /**
     * Dates with or without time portions are allowed as well as numbers equivalent to valid dates.
     * When comparing against constraints, the cell value is used.
     */
    Date = 4,
    /**
     * Times are allowed are well as numbers equivalent to valid times without a date portion.
     * When comparing against constraints, the cell value is used.
     */
    Time = 5,
    /**
     * Non-error values are allowed.
     * When comparing against constraints, the length of the cell value's text equivalent is used.
     */
    TextLength = 6
}
/**
 * @hidden
 */
export declare let DataValidationCriteria_$type: Type;
/**
 * @hidden
 */
export declare const enum WorksheetChart_BitValues {
    AutoScaling = 1,
    IsInitializing = 2,
    PlotByRows = 4,
    PlotVisibleOnly = 8,
    RightAngleAxes = 16,
    VaryColors = 32
}
/**
 * @hidden
 */
export declare let WorksheetChart_BitValues_$type: Type;
/**
 * @hidden
 */
export declare const enum SeriesChartTypeGroup {
    Unsupported = 0,
    Area = 1,
    AreaStacked = 2,
    AreaStacked100 = 3,
    BarClustered = 4,
    BarStacked = 5,
    BarStacked100 = 6,
    ColClustered = 7,
    ColStacked = 8,
    ColStacked100 = 9,
    Line = 10,
    LineStacked = 11,
    LineStacked100 = 12,
    Pie = 13,
    PieOfPie = 14,
    BarOfPie = 15,
    Doughnut = 16,
    Radar = 17,
    RadarFilled = 18,
    ScatterStraight = 19,
    ScatterSmooth = 20
}
/**
 * @hidden
 */
export declare let SeriesChartTypeGroup_$type: Type;
/**
 * @hidden
 */
export declare const enum GroupSeriesMajorType {
    Undefined = 0,
    Area = 1,
    Bar = 2,
    Column = 3,
    Line = 4,
    Pie = 5,
    Radar = 6,
    Scatter = 7
}
/**
 * @hidden
 */
export declare let GroupSeriesMajorType_$type: Type;
/**
 * @hidden
 */
export declare const enum GroupSeriesType {
    Undefined = 0,
    Area = 1,
    AreaStacked = 2,
    AreaStacked100 = 3,
    Bar = 4,
    BarStacked = 5,
    BarStacked100 = 6,
    Column = 7,
    ColumnStacked = 8,
    ColumnStacked100 = 9,
    Line = 10,
    LineStacked = 11,
    LineStacked100 = 12,
    Pie = 13,
    Radar = 14,
    Scatter = 15
}
/**
 * @hidden
 */
export declare let GroupSeriesType_$type: Type;
/**
 * @hidden
 */
export declare const enum StackedType {
    NotApplicable = 0,
    Normal = 1,
    Stacked = 2,
    Stacked100 = 3
}
/**
 * @hidden
 */
export declare let StackedType_$type: Type;
/**
 * @hidden
 */
export declare const enum WorkbookColorInfo_ColorInfoState {
    IsAutomatic = 1,
    IsRGB = 2,
    IsThemeColor = 4,
    IsTintValid = 8,
    HasTransform = 16
}
/**
 * @hidden
 */
export declare let WorkbookColorInfo_ColorInfoState_$type: Type;
/**
 * @hidden
 */
export declare const enum IGVerticalTextAlignment {
    Top = 0,
    Center = 1,
    Bottom = 2,
    Justify = 3,
    Distributed = 4
}
/**
 * @hidden
 */
export declare let IGVerticalTextAlignment_$type: Type;
/**
 * @hidden
 */
export declare const enum IGTextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justify = 3,
    Distributed = 4,
    Fill = 5
}
/**
 * @hidden
 */
export declare let IGTextAlignment_$type: Type;
/**
 * @hidden
 */
export declare const enum DueDate {
    EndOfPeriod = 0,
    BegOfPeriod = 1
}
/**
 * @hidden
 */
export declare let DueDate_$type: Type;
/**
 * @hidden
 */
export declare const enum FirstWeekOfYear {
    System = 0,
    Jan1 = 1,
    FirstFourDays = 2,
    FirstFullWeek = 3
}
/**
 * @hidden
 */
export declare let FirstWeekOfYear_$type: Type;
/**
 * @hidden
 */
export declare const enum DateInterval {
    Year = 0,
    Quarter = 1,
    Month = 2,
    DayOfYear = 3,
    Day = 4,
    WeekOfYear = 5,
    Weekday = 6,
    Hour = 7,
    Minute = 8,
    Second = 9
}
/**
 * @hidden
 */
export declare let DateInterval_$type: Type;
/**
 * @hidden
 */
export declare const enum FirstDayOfWeek {
    System = 0,
    Sunday = 1,
    Monday = 2,
    Tuesday = 3,
    Wednesday = 4,
    Thursday = 5,
    Friday = 6,
    Saturday = 7
}
/**
 * @hidden
 */
export declare let FirstDayOfWeek_$type: Type;
/**
 * @hidden
 */
export declare const enum UnicodeCategory {
    UppercaseLetter = 0,
    LowercaseLetter = 1,
    TitlecaseLetter = 2,
    ModifierLetter = 3,
    OtherLetter = 4,
    NonSpacingMark = 5,
    SpacingCombiningMark = 6,
    EnclosingMark = 7,
    DecimalDigitNumber = 8,
    LetterNumber = 9,
    OtherNumber = 10,
    SpaceSeparator = 11,
    LineSeparator = 12,
    ParagraphSeparator = 13,
    Control = 14,
    Format = 15,
    Surrogate = 16,
    PrivateUse = 17,
    ConnectorPunctuation = 18,
    DashPunctuation = 19,
    OpenPunctuation = 20,
    ClosePunctuation = 21,
    InitialQuotePunctuation = 22,
    FinalQuotePunctuation = 23,
    OtherPunctuation = 24,
    MathSymbol = 25,
    CurrencySymbol = 26,
    ModifierSymbol = 27,
    OtherSymbol = 28,
    OtherNotAssigned = 29
}
/**
 * @hidden
 */
export declare let UnicodeCategory_$type: Type;
/**
 * @hidden
 */
export declare const enum GregorianCalendarTypes {
    Localized = 1,
    USEnglish = 2,
    MiddleEastFrench = 9,
    Arabic = 10,
    TransliteratedEnglish = 11,
    TransliteratedFrench = 12
}
/**
 * @hidden
 */
export declare let GregorianCalendarTypes_$type: Type;
/**
 * Represents an arithmetic error.
 */
export declare class ArithmeticException extends SystemException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * Represents an error in which a division by zero occurred during calculations.
 */
export declare class DivideByZeroException extends ArithmeticException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * Represents an error in which an attempt was made to treat a value as the wrong type.
 */
export declare class InvalidCastException extends SystemException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * @hidden
 */
export declare class Colors extends Base {
    static $t: Type;
    static readonly a: Color;
    static readonly b: Color;
    static readonly c: Color;
    static readonly d: Color;
    static readonly e: Color;
    static readonly f: Color;
    static readonly g: Color;
    static readonly h: Color;
    static readonly i: Color;
    static readonly j: Color;
    static readonly k: Color;
    static readonly l: Color;
    static readonly m: Color;
    static readonly n: Color;
    static readonly o: Color;
    static readonly p: Color;
    static readonly q: Color;
    static readonly r: Color;
    static readonly s: Color;
    static readonly t: Color;
    static readonly u: Color;
}
/**
 * @hidden
 */
export declare abstract class ImageSource extends DependencyObject {
    static $t: Type;
}
/**
 * @hidden
 */
export declare abstract class BitmapSource extends ImageSource {
    static $t: Type;
    constructor(a: number, b: number);
    _j: number;
    _k: number;
}
/**
 * @hidden
 */
export declare class WBitmap extends BitmapSource {
    static $t: Type;
    private _l;
    constructor(a: number, b: number);
    readonly _pixels: number[];
    _n(): void;
}
/**
 * Represents an error in I/O processing.
 */
export declare class IOException extends SystemException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * Represents an error in which an attempt was made to read past the end of a stream of data.
 */
export declare class EndOfStreamException extends IOException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * @hidden
 */
export declare class CharUnicodeInfo extends Base {
    static $t: Type;
    private static k;
    static staticInit(): void;
    static g(a: string): number;
    static h(a: string, b: number): number;
    static i(a: string): number;
    static j(a: string, b: number): number;
    static c(a: string): number;
    static d(a: string, b: number): number;
    static e(a: string): UnicodeCategory;
    private static a;
    static f(a: string, b: number): UnicodeCategory;
    static b(a: string): boolean;
}
/**
 * @hidden
 */
export declare class GregorianCalendar extends Calendar {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: GregorianCalendarTypes);
    constructor(a: number, ..._rest: any[]);
}
/**
 * @hidden
 */
export declare class HebrewCalendar extends Calendar {
    static $t: Type;
}
/**
 * @hidden
 */
export declare class HijriCalendar extends Calendar {
    static $t: Type;
}
/**
 * @hidden
 */
export declare class CalendarEraInfo extends Base {
    static $t: Type;
    readonly b: number;
    readonly a: Date;
    readonly e: number;
    readonly g: number;
    readonly f: number;
    readonly j: string;
    readonly h: string;
    readonly i: string;
    constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: string, i: string, j: string);
    static c(a: CalendarEraInfo[], b: number): number;
    static d(a: CalendarEraInfo[], b: number, c: number): number;
}
/**
 * @hidden
 */
export declare class JapaneseCalendar extends Calendar {
    static $t: Type;
    private static _l;
    private static _k;
    private static _m;
    static staticInit(): void;
    _getEraInfo(a: number): CalendarEraInfo;
    protected get_eras(): number[];
    addMonths(a: Date, b: number): Date;
    addYears(a: Date, b: number): Date;
    getDaysInMonth(a: number, b: number, c: number): number;
    getDaysInYear(a: number, b: number): number;
    getEra(a: Date): number;
    getYear(a: Date): number;
    toDateTime(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number): Date;
}
/**
 * @hidden
 */
export declare class KoreanCalendar extends Calendar {
    static $t: Type;
}
/**
 * @hidden
 */
export declare class TaiwanCalendar extends Calendar {
    static $t: Type;
}
/**
 * @hidden
 */
export declare class ThaiBuddhistCalendar extends Calendar {
    static $t: Type;
}
/**
 * @hidden
 */
export declare class UmAlQuraCalendar extends Calendar {
    static $t: Type;
}
/**
 * Represents an error in which a keyed collection was accessed with a key which does not exist in the collection.
 */
export declare class KeyNotFoundException extends SystemException {
    static $t: Type;
    constructor(message: string, innerException: BaseError);
}
/**
 * @hidden
 */
export declare class SortedList$2<TKey, TValue> extends Base implements IEnumerable$1<KeyValuePair$2<TKey, TValue>> {
    static $t: Type;
    protected $tKey: Type;
    protected $tValue: Type;
    private _f;
    private _g;
    private _i;
    constructor($tKey: Type, $tValue: Type, a: number);
    constructor($tKey: Type, $tValue: Type, a: number, b: Comparer$1<TKey>);
    constructor($tKey: Type, $tValue: Type, a: number, ..._rest: any[]);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<KeyValuePair$2<TKey, TValue>>;
    getEnumeratorObject(): IEnumerator;
    _m(a: TKey, b: TValue): void;
    _b(a: TKey): boolean;
    _l(a: TKey): number;
    _c(a: TKey): boolean;
    _n(a: number): void;
    _d(a: TKey, b: TValue): {
        ret: boolean;
        p1: TValue;
    };
    readonly _e: Comparer$1<TKey>;
    readonly _k: number;
    _item(a: TKey, b?: TValue): TValue;
    readonly _h: List$1<TKey>;
    readonly _j: List$1<TValue>;
}
/**
 * @hidden
 */
export declare class FinancialUtils extends Base {
    static $t: Type;
    static iPmt(a: number, b: number, c: number, d: number, e: number, f: DueDate): number;
    static pPmt(a: number, b: number, c: number, d: number, e: number, f: DueDate): number;
    static nPer(a: number, b: number, c: number, d: number, e: DueDate): number;
    private static d;
    private static a;
}
/**
 * @hidden
 */
export declare abstract class EncodingProperty extends Base {
    static $t: Type;
}
/**
 * @hidden
 */
export interface IImageEncoder {
    readonly imageFormat: ImageFormat;
    encode(image: BitmapSource, encodingProperties: IList$1<EncodingProperty>, stream: string | Uint8Array): void;
    _encode$i(a: BitmapSource, b: IList$1<EncodingProperty>, c: Stream): void;
}
/**
 * @hidden
 */
export declare let IImageEncoder_$type: Type;
/**
 * @hidden
 */
export declare class DefaultStyleHelper extends Base {
    static $t: Type;
    static a(a: List$1<WorksheetTableStyle>): WorkItem;
    static c(a: List$1<WorksheetTableStyle>): void;
    static b(a: List$1<WorkbookBuiltInStyle>): void;
}
/**
 * @hidden
 */
export declare class SecureString extends Base {
    static $t: Type;
    constructor();
}
/**
 * @hidden
 */
export declare class ExcelUtils extends Base {
    static $t: Type;
    static g9(a: number, b: number, c: number, d: number): Rect;
    static fk(a: () => void): void;
    static fl(a: (arg1: any) => void, b?: any): void;
    static ee(a: Stream): string;
    static g3(a: number[], b: number, c: number): WBitmap;
    static b(a: WBitmap, b: number, c: number): {
        ret: number[];
        p1: number;
        p2: number;
    };
    static g4(a: ImageHolder): WBitmap;
    static y(a: WBitmap, b: ImageFormat): ExcelImage;
    static readonly b1: string;
    static readonly b2: string;
    static readonly b3: string;
    static d3(a: any, b: CultureInfo): string;
    static cp(a: CalendarType): Calendar;
    static readonly cq: CultureInfo;
    static ce(a: number): Date;
    static az(a: FillPatternStyle): boolean;
    static a3(a: Type): boolean;
    static bc(a: Type): boolean;
    static bg(a: Type): boolean;
    static em(a: CultureInfo, b: boolean): StringComparer;
    static staticInit(): void;
    static readonly g7: Point;
    static readonly g8: Point;
    private static readonly d;
    static br: boolean;
    static readonly dq: Nullable$1<boolean>;
    static readonly ds: Nullable$1<number>;
    static readonly dt: Nullable$1<WorkbookThemeColorType>;
    static e0(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e1(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e2(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e3(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static gs(a: number, b: number, c: number, d: number, e: number): Color;
    static gt(a: Color, b: number): Color;
    private static cn;
    private static ck;
    static gu(a: Color, b: number): Color;
    static cv<T>($t: Type, a: IList$1<T>, b: T, c: IComparer$1<T>): number;
    static cw<T>($t: Type, a: List$1<WeakReference>, b: T, c: IComparer$1<T>, d: boolean, e: T): {
        ret: number;
        p4: T;
    };
    static cf(a: Workbook, b: IEnumerable$1<WorksheetRegion>): number;
    static cg(a: Workbook, b: number, c: IEnumerable$1<WorksheetRegion>): number;
    static ch(a: Workbook, b: IEnumerable$1<WorksheetRegion>): number;
    private static fn;
    static e4(a: number, b: number, c: number): {
        p0?: number;
    };
    static e5(a: number, b: number, c: number): {
        p0?: number;
    };
    static e6(a: number, b: number, c: number): {
        p0?: number;
    };
    static e7(a: number, b: number, c: number): {
        p0?: number;
    };
    static ez(a: Uri): Uri;
    static gx(a: number): Color;
    static gw(a: number, b: number, c: number): Color;
    static readonly gv: Color;
    static al(a: Color): boolean;
    static am(a: Color): boolean;
    static cx(a: Color): number;
    static d2(a: Color): string;
    static g1(a: Color): Color;
    static g2(a: Color): Color;
    static an(a: Workbook, b: WorksheetCellFormatData, c: CellConditionalFormat, d: CellFill): boolean;
    static ao(a: Workbook, b: WorksheetCellFormatData, c: CellConditionalFormat, d: WorkbookColorInfo): boolean;
    static ap(a: CellConditionalFormat, b: ST_IconSetType, c: Nullable$1<number>): boolean;
    static cr(a: number[]): Guid;
    private static fp;
    private static fq;
    private static fr;
    static eu(a: number, b: number[]): number;
    private static c;
    private static fo;
    static cs(a: number): number;
    static et(a: number): number;
    static gy(a: number, b: number, c: number): Color;
    static e8(a: Color, b: number, c: number, d: number): {
        p1: number;
        p2: number;
        p3: number;
    };
    static fb(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d?: boolean, e?: CellFormatValueChangedOptions): void;
    static e9(a: WorksheetCellFormatData, b: WorksheetCellFormatData, c: CellFormatValue): void;
    static fa(a: WorksheetCellFormatData, b: WorksheetCellFormatProxy, c: CellFormatValue): void;
    static fc(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d?: boolean, e?: boolean, f?: CellFormatValueChangedOptions, g?: boolean): void;
    static w(a: string, b: string, c: BaseError): ArgumentExceptionExtension;
    static x(a: string, b: any, c: string): ArgumentOutOfRangeExceptionExtension;
    static g5(a: number, b: number): Point;
    static g6(a: number, b: number): Point;
    static b8(): HashSet$1<Rect>;
    static d5(a: string, b: string): string;
    static d6(a: string, b: string, c: string): string;
    static d4(a: string, b: boolean, c: string, d: string): string;
    static ep(a: string, b: boolean): {
        ret: Regex;
        p1: boolean;
    };
    static fd(a: boolean, b?: string): void;
    static fe(a: string): void;
    static ff(): void;
    static fg(): void;
    static fh(a: boolean, b: string): void;
    static gz(a: number): Color;
    static ci(a: number): number;
    static d7(a: string, b: string): string;
    static aq(a: ICellShiftOperationOverride, b: WorksheetRegionAddress): boolean;
    static ar(a: ICellShiftOperationOverride, b: number, c: number, d: number, e: number): boolean;
    static as(a: ICellShiftOperationOverride, b: WorksheetRegionAddress): boolean;
    static at(a: ICellShiftOperationOverride, b: number, c: number, d: number, e: number): boolean;
    static c1(a: number): number;
    static ha(a: Rect): Rect;
    static cj(a: number): number;
    static dh(a: number): number;
    static fi(a: List$1<PropertyTableBase_PropertyValue>, b: Color, c: PropertyType, d: PropertyType): void;
    static ev(a: Color): number;
    static d8(a: string): string;
    static readonly en: Encoding;
    static c2(a: Encoding): number;
    static eo(a: number): Encoding;
    static d9(a: string): string;
    static ea(a: string): string;
    static fj(a: number): {
        p0?: number;
    };
    static eb(a: string): string;
    static z(a: any): SingleTargetFormula;
    static d1(a: number): number;
    private static c3;
    static m(a: CellFormatValue): CellFormatValue;
    static c4(a: number, b: number, c: number): number;
    static c6(a: number, b: number, c: number): number;
    static c7(a: number, b: number, c: number): number;
    static c5(a: number, b: number, c: number): number;
    static c8(a: number, b: number, c: number): number;
    static b9(a: WorksheetRegion): IEnumerable$1<any>;
    private static _ca;
    static ca(a: IEnumerable$1<WorksheetRegion>, b?: boolean): IEnumerable$1<any>;
    static dr(a: ReferenceToken): Nullable$1<CellAddressRange>;
    static n(a: WorksheetCellFormatOptions): CellFormatValue;
    static ac(a: Workbook, b: XColorType, c: number, d: Nullable$1<number>): WorkbookColorInfo;
    private static c9;
    static p(a: IChartObject, b: number): ChartSolidFill;
    static ec(a: DateTimeFormat): string;
    static ed(a: Type, b: any): string;
    static da(a: number): number;
    static ad(a: IWorkbookFont, b?: WorkbookThemeColorType): WorkbookColorInfo;
    static s(a: string): FontFamilyInternal;
    private static b4;
    private static b7;
    private static fx;
    static aa(a: any): StringElement;
    static db(a: number): number;
    static dc(a: CellConditionalFormat, b: WorksheetCellFormatData, c?: boolean): number;
    static ak(a: FormatConditionIconSet): ST_IconSetType;
    static cc(a: string, b: List$1<number>, c: List$1<string>): {
        ret: List$1<string>;
        p1: List$1<number>;
        p2: List$1<string>;
    };
    static o(a: CellFormatValue): CellFormatValue;
    static hc(): Size;
    static dd(a: Date): number;
    static cd(a: Formula): List$1<CellAddressRange>;
    static hd(): Size;
    private static de;
    static ef(a: string): string;
    static eg(a: string, ...b: any[]): string;
    private static b6;
    private static b5;
    private static cb;
    static a(a: CellFormatValue, b: boolean): CellFormatValue[];
    static dy(a: WeakReference): any;
    static f(a: Stream, b: string, c: WorkbookOptionsBase): WorkItem$1<WorkbookFormat>;
    private static g;
    static co: (arg1: IPackage) => Nullable$1<WorkbookFormat>;
    private static dg;
    static au(a: WorkbookFormat): boolean;
    static av(a: WorkbookFormat): boolean;
    static a4(a: any): boolean;
    static aw(a: CellBorderLineStyle): boolean;
    static ax(a: CellReferenceMode): boolean;
    static readonly ay: boolean;
    static a0(a: DiagonalBorders): boolean;
    static a1(a: DiagonalBorders): boolean;
    static a2(a: CellFormatValue): boolean;
    static a5(a: Nullable$1<boolean>): boolean;
    static a6(a: CellFormatValue): boolean;
    static a7(a: HorizontalCellAlignment): boolean;
    static a8(a: WorkbookFormat): boolean;
    static a9(a: any): boolean;
    static ba(a: any): boolean;
    static bb(a: any): boolean;
    static bd(a: number): boolean;
    static be(a: TextFormatMode): boolean;
    static bf(a: string): boolean;
    static bh(a: CellFormatValue): boolean;
    static bi(a: VerticalCellAlignment): boolean;
    static bj(a: Stream): boolean;
    static bl(a: WorksheetColumnWidthUnit): boolean;
    static bk(a: WorkbookFormat): boolean;
    static e(a: Workbook, b: Uri): ImageData;
    static cl(a: number): number;
    static i(a: BorderThickness, b: BorderThickness): BorderThickness;
    static ab<T>($t: Type, a: T, b: T): T;
    static v(a: IWorkbookFont[], b: Workbook): IWorkbookFont;
    static fs(a: Rect, b: number, c: number): {
        p0?: Rect;
    };
    static bm(a: string, b: WorkbookFormat, c: CultureInfo, d: number, e: number): {
        ret: boolean;
        p3: number;
        p4: number;
    };
    static bn(a: string, b: number, c: number, d: WorkbookFormat, e: CultureInfo, f: number, g: number): {
        ret: boolean;
        p5: number;
        p6: number;
    };
    static ai(a: string, b: Worksheet, c: CultureInfo): WorksheetRegion;
    static ft(a: string, b: WorkbookFormat, c: CultureInfo, d: number, e: number, f: number, g: number): {
        p3: number;
        p4: number;
        p5: number;
        p6: number;
    };
    static bo(a: string, b: WorkbookFormat, c: number, d: boolean, e: number, f: boolean): {
        ret: boolean;
        p2: number;
        p3: boolean;
        p4: number;
        p5: boolean;
    };
    static bp(a: string, b: number, c: number, d: WorkbookFormat, e: number, f: boolean, g: number, h: boolean): {
        ret: boolean;
        p4: number;
        p5: boolean;
        p6: number;
        p7: boolean;
    };
    static fu(a: string, b: WorkbookFormat, c: WorksheetRow, d: number, e: number, f: number, g: number, h: number): {
        p4: number;
        p5: number;
        p6: number;
        p7: number;
    };
    static fv(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo, e: WorksheetRow, f: number, g: number, h: number, i: number, j: number): {
        p6: number;
        p7: number;
        p8: number;
        p9: number;
    };
    static u(a: string, b: Sheet, c: number, d: number, e: CellReferenceMode, f: string, g: string, h: List$1<Tuple$3<Worksheet, WorksheetRegionAddress, string>>, i?: List$1<WorkbookReferenceBase>, j?: FormulaType): Formula;
    private static fy;
    static fw(a: any[], b: any): void;
    static fz(a: number, b: number): {
        p0?: number;
        p1?: number;
    };
    static g0(a: Color): Color;
    static eh(a: string): string;
    static bq(a: List$1<WorksheetCell>, b: WorksheetRow, c: number): boolean;
    static f0(a: DiagonalBorders): {
        p0?: DiagonalBorders;
    };
    static f1(a: DiagonalBorders): {
        p0?: DiagonalBorders;
    };
    static f2(a: List$1<WorksheetCell>): void;
    static dz(a: Worksheet, b: WorksheetRow, c: number, d: WorksheetRow, e: number, f: CellFormatValue): any;
    static d0(a: RowColumnBase, b: RowColumnBase, c: CellFormatValue): any;
    static ae(a: Workbook, b: FullColorExtInfo): WorkbookColorInfo;
    static l(a: Workbook, b: GradStopInfo): CellFillGradientStop;
    static k(a: Workbook, b: XFExtGradientInfo): CellFillGradient;
    static af(a: Workbook, b: XFPropColorInfo): WorkbookColorInfo;
    static f3(a: Color, b: number, c: number, d: number): {
        p1: number;
        p2: number;
        p3: number;
    };
    private static cm;
    static dj(a: number, b: number): number;
    static f4(a: ExcelImage, b: ImageFormat, c: Stream): void;
    static f6(a: number, b: Nullable$1<boolean>, c: number): {
        p0?: number;
    };
    static f5(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static f8(a: number, b: Nullable$1<boolean>, c: number): {
        p0?: number;
    };
    static f7(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static f9(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static bs(a: Size): boolean;
    static ga(a: Sheet, b: string, c: boolean, d: boolean, e: WorksheetRegion, f: CellReferenceMode, g: (arg1: number) => void, h: () => void, i: (arg1: Worksheet, arg2: WorksheetRegionAddress, arg3: WorksheetRegionAddress, arg4: string) => void): void;
    static ei(a: ChartType[], b?: string): string;
    static gc(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d: any, e: CellFormatValueChangedOptions): void;
    static gb<T>($t: Type, a: T, b: T): {
        p0?: T;
        p1?: T;
    };
    static bt(a: number, b: number): boolean;
    static bu(a: number, b: number): boolean;
    static bv(a: DiagonalBorders, b: DiagonalBorders): boolean;
    static bw(a: PreventTextFormattingTypes, b: PreventTextFormattingTypes): boolean;
    static bx(a: WorksheetCellFormatOptions, b: WorksheetCellFormatOptions): boolean;
    static ag(a: Color): WorkbookColorInfo;
    static dv(a: boolean): Nullable$1<boolean>;
    static dw(a: Nullable$1<boolean>): Nullable$1<boolean>;
    static ey(a: number): number;
    static t(a: ST_IconSetType): FormatConditionIconSet;
    static aj(a: FormatConditionIconSet): ST_IconSetType;
    static ah(a: WorkbookColorInfo, b: Workbook): WorkbookColorInfo;
    static j(a: CellFill, b: Workbook): CellFill;
    static q(a: ChartType): SeriesType;
    static ej(a: number, b: IFormatProvider): string;
    static gd(a: IFormattedRunOwner): void;
    static by(a: any, b: Workbook, c: IFormatProvider, d: boolean, e: number): {
        ret: boolean;
        p4: number;
    };
    static bz(a: number, b: number): {
        ret: boolean;
        p1: number;
    };
    static b0(a: Workbook, b: any, c: number): {
        ret: boolean;
        p2: number;
    };
    static dm(a: number): number;
    static dn(a: number): number;
    static hb(a: Rect): Rect;
    static ek(a: string): string;
    static el(a: string): string;
    static ge(a: CultureInfo, b: SortMethod): {
        p0?: CultureInfo;
    };
    static gf(a: WorksheetRegion[], b?: HashSet$1<IRegionBlockingValue>): void;
    static gg(a: number, b: number): void;
    static gh(a: Worksheet, b: number, c: string): void;
    static gi(a: Worksheet, b: number, c: string): void;
    static gj(a: Nullable$1<boolean>): void;
    static gk(a: Nullable$1<boolean>, b: string): void;
    static gl<T>($t: Type, a: T): void;
    static gm<T>($t: Type, a: T, b: string): void;
    static gn(a: Nullable$1<boolean>, b: string): void;
    static go(a: Worksheet, b: number, c: string): void;
    static gp(a: Worksheet, b: number, c: string): void;
    static gq(a: TextFormatMode): void;
    static gr(a: WorksheetColumnWidthUnit): void;
    static fm<T>($t: Type, a: IEnumerable$1<T>, b: (arg1: T) => void): void;
    static h(a: CellBorderLineStyle): BorderThickness;
    static du(a: Nullable$1<boolean>): Nullable$1<boolean>;
    static dk(a: Nullable$1<boolean>): number;
    static dx<T>($t: Type, a: T): Nullable$1<T>;
}
/**
 * @hidden
 */
export declare class Utilities_Int16Comparer extends Comparer$1<number> {
    static $t: Type;
    static readonly _c: Utilities_Int16Comparer;
    constructor();
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export interface IRegionAddress {
    containsColumns(a: number, b: number): boolean;
    intersectsWithColumns(a: number, b: number): boolean;
}
/**
 * @hidden
 */
export declare let IRegionAddress_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetRegionAddress extends ValueType implements IComparable$1<WorksheetRegionAddress>, IRegionAddress {
    static $t: Type;
    constructor(a: number, b: number, c: number, d: number, e: number);
    constructor(a: number, b: WorksheetCellAddress, c: WorksheetCellAddress);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly _b: WorksheetRegionAddress;
    private readonly _u;
    private readonly _y;
    private readonly _v;
    private readonly _aa;
    private readonly _z;
    compareTo(a: WorksheetRegionAddress): number;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    private static _ab;
    _a(): WorksheetRegionAddress;
    _g(a: WorksheetCellAddress): boolean;
    _i(a: number, b: number): boolean;
    _h(a: WorksheetRegionAddress): boolean;
    static _ag(a: WorksheetRegionAddress, b: WorksheetRegionAddress): Nullable$1<WorksheetRegionAddress>;
    _j(a: WorksheetRegionAddress): boolean;
    _k(a: Workbook): boolean;
    _l(a: Workbook): boolean;
    _ah(a: boolean, b: boolean, c: WorkbookFormat, d: CellReferenceMode, e?: string): string;
    _c(a: number): WorksheetRegionAddress;
    _d(a: number): WorksheetRegionAddress;
    _e(a: number): WorksheetRegionAddress;
    _f(a: number): WorksheetRegionAddress;
    readonly _w: number;
    readonly _ac: number;
    readonly _ad: number;
    readonly _m: boolean;
    readonly _n: boolean;
    readonly _x: number;
    readonly _ae: number;
    readonly _af: number;
    containsColumns(a: number, b: number): boolean;
    intersectsWithColumns(a: number, b: number): boolean;
    static _o(a: WorksheetRegionAddress, b: WorksheetRegionAddress): boolean;
    static _p(a: Nullable$1<WorksheetRegionAddress>, b: Nullable$1<WorksheetRegionAddress>): boolean;
    static _q(a: WorksheetRegionAddress, b: WorksheetRegionAddress): boolean;
    static _r(a: Nullable$1<WorksheetRegionAddress>, b: Nullable$1<WorksheetRegionAddress>): boolean;
}
/**
 * @hidden
 */
export declare abstract class ChangeInfo extends Base {
    static $t: Type;
    readonly c: string;
    readonly a: ExcelChangeAction;
    constructor(a: string, b: ExcelChangeAction);
    d(a: Workbook, b: any): void;
    b(a: Workbook, b: Sheet, c: string): any;
    e<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue): void;
    static f(a: ChangeInfo[], b: number, c: ChangeInfo): void;
    g<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue, d?: boolean): {
        p1?: TValue;
    };
    h<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue): void;
    static i(a: ChangeInfo[]): void;
}
/**
 * @hidden
 */
export declare class SilverlightFixes extends Base {
    static $t: Type;
    static staticInit(): void;
    static readonly v: Color;
    static readonly t: Encoding;
    static l(a: Encoding): number;
    static u(a: number): Encoding;
    static j(a: number): CultureInfo;
    static p(a: number): number;
    static o(a: number): number;
    static h(a: number, b: number): number;
    static g(a: number): number;
    static m(a: CultureInfo): number;
    static s(a: string): string;
    static d<T>($t: Type, a: ICollection$1<T>): boolean;
    static c(a: any): boolean;
    static r<T>($t: Type, a: ICollection$1<T>): any;
    static b(a: Color): boolean;
    static w(a: number): Color;
    static k(a: Color): number;
    static e(a: DateInterval, b: number, c: Date): Date;
    static a(a: string): DateInterval;
    static q(a: DateInterval, b: Date, c: Date, d: FirstDayOfWeek, e: FirstWeekOfYear): number;
    private static f;
    private static n;
    private static readonly i;
}
/**
 * @hidden
 */
export interface IWorkbookProvider {
    readonly workbook: Workbook;
}
/**
 * @hidden
 */
export declare let IWorkbookProvider_$type: Type;
/**
 * @hidden
 */
export interface ISheetProvider {
    readonly sheet: Sheet;
}
/**
 * @hidden
 */
export declare let ISheetProvider_$type: Type;
/**
 * @hidden
 */
export interface IChangeInfoContext extends IWorkbookProvider, ISheetProvider {
    readonly source: any;
}
/**
 * @hidden
 */
export declare let IChangeInfoContext_$type: Type;
/**
 * @hidden
 */
export declare class Workbook_ChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Workbook);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class ChangeInfo$2<TContext extends IChangeInfoContext, TValue> extends ChangeInfo {
    static $t: Type;
    protected $tContext: Type;
    protected $tValue: Type;
    readonly u: (arg1: TContext) => TValue;
    readonly r: boolean;
    readonly s: boolean;
    readonly m: WorksheetPermissions;
    readonly o: (arg1: TContext, arg2: TValue) => void;
    readonly p: (arg1: TContext, arg2: TValue) => void;
    private t;
    private n;
    private readonly q;
    constructor($tContext: Type, $tValue: Type, a: string, b: ExcelChangeAction, c: (arg1: TContext) => TValue, d: (arg1: TContext, arg2: TValue) => void, e: (arg1: TContext, arg2: TValue) => void, f: boolean, g: WorksheetPermissions, h: boolean, i: (arg1: TContext) => number, j: (arg1: TContext) => void);
    v(a: TContext): number;
    w(a: TContext): any;
    j(a: TContext): TValue;
    l(a: TContext): Workbook;
    k(a: TContext): Sheet;
    x(a: TContext, b: TValue, c: TValue): void;
    y(a: TContext, b: TValue): void;
    z(a: TContext): void;
}
export declare class Workbook extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static _br(a: Workbook): TextMetricsProviderBase;
    /**
     * @hidden
     */
    _f(): number[];
    /**
     * @hidden
     */
    readonly _cs: boolean;
    /**
     * @hidden
     */
    readonly _cw: boolean;
    static readonly maxExcel2007RowCount: number;
    static readonly maxExcel2007ColumnCount: number;
    static readonly maxExcelRowCount: number;
    static readonly maxExcelColumnCount: number;
    static readonly maxExcelCellFormatCount: number;
    static readonly maxExcel2007CellFormatCount: number;
    static readonly maxExcelWorkbookFonts: number;
    /**
     * @hidden
     */
    static readonly _gq: string;
    /**
     * @hidden
     */
    static readonly _gr: string;
    /**
     * @hidden
     */
    static readonly _gt: string;
    /**
     * @hidden
     */
    static readonly _gu: string;
    /**
     * @hidden
     */
    static readonly _gs: string;
    /**
     * @hidden
     */
    static readonly _b0: WorkbookFormat;
    /**
     * @hidden
     */
    private static readonly _fg;
    /**
     * @hidden
     */
    private static readonly _fj;
    /**
     * @hidden
     */
    private static readonly _fk;
    /**
     * @hidden
     */
    private static readonly _f7;
    /**
     * @hidden
     */
    private static readonly _f8;
    /**
     * @hidden
     */
    private static readonly _gd;
    /**
     * @hidden
     */
    private static readonly _ge;
    /**
     * @hidden
     */
    private static readonly _gf;
    /**
     * @hidden
     */
    static readonly _gp: string;
    /**
     * @hidden
     */
    private static readonly _fi;
    /**
     * @hidden
     */
    private static readonly _fl;
    /**
     * @hidden
     */
    private static readonly _fm;
    /**
     * @hidden
     */
    private static readonly _fn;
    /**
     * @hidden
     */
    private static readonly _ga;
    /**
     * @hidden
     */
    private static readonly _gb;
    /**
     * @hidden
     */
    private static readonly _gc;
    /**
     * @hidden
     */
    private static readonly _gh;
    /**
     * @hidden
     */
    private static readonly _fu;
    /**
     * @hidden
     */
    private static readonly _fq;
    /**
     * @hidden
     */
    private static readonly _gg;
    /**
     * @hidden
     */
    private static readonly _f9;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    static readonly _g1: Encoding;
    /**
     * @hidden
     */
    static readonly _fd: IFormatProvider;
    /**
     * @hidden
     */
    private static _je;
    /**
     * @hidden
     */
    private static _jf;
    /**
     * @hidden
     */
    static _fa: CultureInfo;
    /**
     * @hidden
     */
    private static _e9;
    /**
     * @hidden
     */
    static _ez: (arg1: Workbook, arg2: Stream, arg3: string, arg4: WorkbookLoadOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e2: (arg1: Workbook, arg2: Stream, arg3: WorkbookSaveOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e1: (arg1: Workbook, arg2: Stream, arg3: WorkbookLoadOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e3: (arg1: Workbook, arg2: Stream, arg3: WorkbookSaveOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e0: (arg1: Workbook, arg2: Stream, arg3: IPackageFactory) => WorkItem;
    private _dx;
    private _v;
    private _x;
    private _fh;
    private _b9;
    private _cb;
    private _z;
    private _bx;
    private _ag;
    private _ai;
    private _fo;
    private _ak;
    private _au;
    private _as;
    private _aw;
    private _b1;
    private _em;
    private _c3;
    private _dc;
    private _ev;
    private _f4;
    private _a4;
    private _bv;
    private _d0;
    private _a6;
    private _dg;
    private _di;
    private _dm;
    private _dp;
    private _b5;
    private _j;
    private _gz;
    private _b7;
    private _ce;
    private _bn;
    private _gi;
    private _ei;
    private _ek;
    private _ee;
    private _eg;
    private _bi;
    private _bg;
    private _dy;
    private _d;
    private _ae;
    private _ch;
    private _g;
    private _dr;
    private _d2;
    private _g5;
    private _e4;
    private _e7;
    private _a8;
    private _ba;
    private _de;
    private _jg;
    private readonly _dw;
    private _cl;
    private _d5;
    private _eb;
    private _ed;
    private _ec;
    private readonly _am;
    private _az;
    private readonly _bt;
    private _bk;
    private _dv;
    private readonly _b3;
    /**
     * @hidden
     */
    _bu: Workbook_MetricsProviderCache;
    /**
     * @hidden
     */
    _m: RoundTripControlData;
    /**
     * @hidden
     */
    _n: RoundTripControlData;
    /**
     * @hidden
     */
    _o: RoundTripControlData;
    /**
     * @hidden
     */
    _gx: string;
    /**
     * @hidden
     */
    _gy: string;
    /**
     * @hidden
     */
    _i: number[];
    /**
     * @hidden
     */
    _du: number;
    /**
     * @hidden
     */
    _fb: Guid;
    private _t;
    static staticInit(): void;
    constructor();
    constructor(format: WorkbookFormat);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    private static _bz;
    /**
     * Converts units of 1/256s of the average character width to pixels.
     * <p class="body">
     * The units of 1/256s of the average character width are based on the font height of the normal style.
     * </p>
     * @param characterWidth256ths The number of units of 1/256s of the average character width.
     * @return The number of pixels equivalent to the 'characterWidth256ths' value.
     * @see [[pixelsToCharacterWidth256ths]]
     * @see [[WorksheetColumn.width]]
     * @see [[Worksheet.defaultColumnWidth]]
     */
    characterWidth256thsToPixels(characterWidth256ths: number): number;
    /**
     * Clears all external data connections from the [[Workbook]].
     */
    clearConnectionData(): void;
    /**
     * Clears all pivot tables and associated slicers from the [[Workbook]].
     */
    clearPivotTableData(): void;
    /**
     * Factory method which creates new workbook font.
     * <p class="body">[[IWorkbookFont]] describes font used in excel workbook.
     * If many parts of excel workbook have same and complex (more than one property in common) font formatting, use this method in following manner:
     * <ol>
     * <li class="taskitem"><span class="taskitemtext">Create new font format with [[createNewWorkbookFont]],</span></li>
     * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given font format,</span></li>
     * <li class="taskitem"><span class="taskitemtext">Apply font format to all excel objects which use it with [[IWorkbookFont.setFontFormatting]] method.</span></li>
     * </ol></p>
     * <p class="body">Use of this procedure will simplify you code for complex font formats and increase speed of resulting program. It will not reduce total number of font formats in a workbook as font formats are internally cached no matter which method is used.</p>
     * @return The created excel font object.
     */
    createNewWorkbookFont(): IWorkbookFont;
    /**
     * Creates new worksheet cell format.
     * <p class="body">[[IWorksheetCellFormat]] describes cell specific formatting (font, number format, appearance etc.). Total number of different cell formats in excel workbook is limited to [[Workbook.maxExcelCellFormatCount]].
     * If many parts of excel workbook have same and complex (more than one property in common) cell formatting, use this method in following manner:
     * <ol>
     * <li class="taskitem"><span class="taskitemtext">Create new cell format with [[createNewWorksheetCellFormat]],</span></li>
     * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given cell format,</span></li>
     * <li class="taskitem"><span class="taskitemtext">Apply cell format to all excel objects which use it with [[IWorksheetCellFormat.setFormatting]] method.</span></li>
     * </ol></p>
     * <p class="body">Use of this procedure will simplify you code for complex cell formats and increase speed of resulting program. It will not reduce total number of cell formats in a workbook as cell formats are internally cached no matter which method is used.</p>
     * @return The cell format which was created.
     */
    createNewWorksheetCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _cd(a: WorksheetCellFormatType): WorksheetCellFormatData;
    /**
     * Gets the table with the specified name.
     * <p class="body">
     * Table names are compared case-insensitively.
     * </p>
     * @param name The name of the table to get.
     * @return A [[WorksheetTable]] instance if a table exists with the specified name; Otherwise null.
     */
    getTable(name: string): WorksheetTable;
    /**
     * Converts pixels to units of 1/256s of the average character width.
     * <p class="body">
     * The units of 1/256s of the average character width are based on the font height of the normal style.
     * </p>
     * @param pixels The number of pixels.
     * @return The number of units of 1/256s of the average character width equivalent to the 'pixels' value.
     * @see [[characterWidth256thsToPixels]]
     * @see [[WorksheetColumn.width]]
     * @see [[Worksheet.defaultColumnWidth]]
     */
    pixelsToCharacterWidth256ths(pixels: number): number;
    /**
     * Protects the Workbook without a password.
     * <p class="body">When a Workbook is protected without a password, the end user may unprotect the Workbook in Excel without
     * having to supply a password. To programatically unprotect a Workbook, one may use the [[unprotect]] method.</p>
     * <p class="body">When a Workbook is protected, the values of the properties of the [[WorkbookProtection]] instance from
     * this Workbook's [[protection]] property indicate the disabled operations.</p>
     * <p class="note"><b>Note:</b> If [[isProtected]] is already true, the method will be ignored.</p>
     * @param allowEditStructure Optional boolean indicating the new value for the [[WorkbookProtection.allowEditStructure]].
     * @param allowEditWindows Optional boolean indicating the new value for the [[WorkbookProtection.allowEditWindows]].
     * @see [[hasProtectionPassword]]
     * @see [[isProtected]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[unprotect]]
     */
    protect(allowEditStructure?: boolean, allowEditWindows?: boolean): void;
    /**
     * Recalculates all dirty formulas pending a calculation on the workbook.
     * <p class="body">
     * This can be used when the [[calculationMode]] is Manual. In Manual mode, when cells are dirtied, formulas referencing
     * those cells will not be recalculated until Recalculate is called or [[recalculateBeforeSave]] is True and the workbook is saved.
     * </p>
     * <p class="body">
     * To force a recalculation of non-dirty formulas, use the [[recalculate]] overload and specify True for the includeNonDirtyFormulas
     * parameter.
     * </p>
     * @see [[calculationMode]]
     * @see [[recalculateBeforeSave]]
     */
    recalculate(): void;
    /**
     * Recalculates all formulas on the workbook.
     * <p class="body">
     * This can be used when the [[calculationMode]] is Manual. In Manual mode, when cells are dirtied, formulas referencing
     * those cells will not be recalculated until Recalculate is called or [[recalculateBeforeSave]] is True and the workbook is saved.
     * </p>
     * @param includeNonDirtyFormulas True to recalculate all formulas on the workbook regardless of whether they had a pending evaluation. False to only calculate dirty formulas.
     * @see [[calculationMode]]
     * @see [[recalculateBeforeSave]]
     */
    recalculate(includeNonDirtyFormulas: boolean): void;
    /**
     * @hidden
     */
    _recalculate(): void;
    /**
     * @hidden
     */
    _recalculate1(a: boolean): void;
    /**
     * @hidden
     */
    _ip(a: boolean, b: boolean): void;
    /**
     * Registers a single [[ExcelCalcFunction]] instance.
     * <p class="body">
     * Users can build custom functions used in formulas by sub-classing the [[ExcelCalcFunction]] class.
     * Once the derived class is instantiated it must be registered by using the RegisterUserDefinedFunction method before being available and referenced by a formulas.
     * </p>
     * @param userDefinedFunction User defined function instance to register
     * @return Returns true if the type was registered successfully, else false if the registration failed
     */
    registerUserDefinedFunction(userDefinedFunction: ExcelCalcFunction): boolean;
    /**
     * Registers a custom function.
     * @param name The name of the function
     * @param minArgs The minimum number of arguments
     * @param maxArgs The maximum number of arguments
     * @param evaluate The function used to perform the calculation that gets an [[ExcelCalcNumberStack]] and the number of arguments on the stack for the function and returns an [[ExcelCalcValue]] that represents the result of the formula
     * @return Returns true if the type was registered successfully, else false if the registration failed
     */
    registerUserDefinedFunction(name: string, minArgs: number, maxArgs: number, evaluate: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    _registerUserDefinedFunction(a: ExcelCalcFunction): boolean;
    /**
     * @hidden
     */
    _registerUserDefinedFunction1(a: string, b: number, c: number, d: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue): boolean;
    /**
     * Resumes the calculation of formulas.
     * <p class="body">
     * If calculations were not suspended when this is called, it will have no effect.
     * </p>
     * <p class="body">
     * For each call to [[suspendCalculations]], a call to ResumeCalculations must be made. As soon as the number of calls to
     * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
     * </p>
     * @see [[suspendCalculations]]
     */
    resumeCalculations(): void;
    /**
     * Writes the workbook to a Uint8Array.
     * <p class="body">
     * The workbook will be written in the format specified by the [[currentFormat]].
     * </p>
     * @param saveOptions The options to use to save the stream or null to use the default options.
     * @param successCallback The function to call when the Workbook has been successfully saved into a Uint8Array or base-64 encoded string.
     * @param failCallback The function to call when saving the Workbook has caused an error.
     * @throws [[InvalidOperationException]] The workbook has no worksheets in its [[worksheets]] collection.
     * @throws [[InvalidOperationException]] No worksheet in this workbook's Worksheets collection has its DisplayOptions.Visibility
     * set to Visible.
     * @throws [[InvalidOperationException]] A [[CustomView]] in the workbook's [[customViews]] collection has all worksheets hidden.
     * At least one worksheet must be visible in all custom views.
     * @see [[isSaving]]
     */
    save(saveOptions: WorkbookSaveOptions, successCallback: (arg1: any) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * Writes the workbook to a Uint8Array.
     * <p class="body">
     * The workbook will be written in the format specified by the [[currentFormat]].
     * </p>
     * @param successCallback The function to call when the Workbook has been successfully saved into a Uint8Array or base-64 encoded string.
     * @param failCallback The function to call when saving the Workbook has caused an error.
     * @throws [[InvalidOperationException]] The workbook has no worksheets in its [[worksheets]] collection.
     * @throws [[InvalidOperationException]] No worksheet in this workbook's Worksheets collection has its DisplayOptions.Visibility
     * set to Visible.
     * @throws [[InvalidOperationException]] A [[CustomView]] in the workbook's [[customViews]] collection has all worksheets hidden.
     * At least one worksheet must be visible in all custom views.
     * @see [[isSaving]]
     */
    save(successCallback: (arg1: any) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    _save1(a: (arg1: any) => void, b: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    _save(a: WorkbookSaveOptions, b: (arg1: any) => void, c: (arg1: BaseError) => void): void;
    private _isSaving;
    /**
     * Gets the value indicating whether the [[Workbook]] is currently being saved.
     */
    /**
    * Gets the value indicating whether the [[Workbook]] is currently being saved.
    */
    isSaving: boolean;
    /**
     * @hidden
     */
    _ix(a: Stream, b?: WorkbookSaveOptions): void;
    /**
     * Sets the current format of the workbook.
     * @param format The file format to use when imposing format restrictions and saving.
     * @throws [[InvalidEnumArgumentException]] 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidOperationException]] The workbook already contains data which exceeds the limits imposed by 'format'.
     * @see [[currentFormat]]
     */
    setCurrentFormat(format: WorkbookFormat): void;
    /**
     * Temporarily suspends the calculation of formulas.
     * <p class="body">
     * This should be used when adding many formulas or modifying large amounts of data on a workbook at once so formulas are not calculated
     * each time cells are dirtied.
     * </p>
     * <p class="body">
     * For each call to SuspendCalculations, a call to [[resumeCalculations]] must be made. As soon as the number of calls to
     * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
     * </p>
     * @see [[resumeCalculations]]
     */
    suspendCalculations(): void;
    /**
     * Removes the Workbook protection.
     * @see [[isProtected]]
     * @see [[hasProtectionPassword]]
     * @see [[protect]]
     */
    unprotect(): void;
    /**
     * Loads a workbook from a Uint8Array or base64 encoded string.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param data The data from which to load the workbook.
     * @param loadOptions The options to use to load the stream or null to use the default options.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'data' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(data: string | Uint8Array, loadOptions: WorkbookLoadOptions, successCallback: (arg1: Workbook) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * Loads a workbook from a Uint8Array or base64 encoded string.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param data The data from which to load the workbook.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'data' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(data: string | Uint8Array, successCallback: (arg1: Workbook) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _load2(a: Stream, b: (arg1: Workbook) => void, c: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _load1(a: Stream, b: WorkbookLoadOptions, c: (arg1: Workbook) => void, d: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _bs(a: Stream, b?: WorkbookLoadOptions): Workbook;
    /**
     * @hidden
     */
    private static _p;
    /**
     * Returns the WorkbookFormat based on the file extension of the specified file.
     * @param fileName The filename of an excel file.
     * @return The workbook format based on the file extension of the file, or null if the correct format cannot be determined.
     */
    static getWorkbookFormat(fileName: string): WorkbookFormat | null;
    /**
     * @hidden
     */
    static _getWorkbookFormat$i(a: string): Nullable$1<WorkbookFormat>;
    /**
     * Determines whether the workbook in the specified stream is encrypted with an open password.
     * @param stream The stream to check for encryption.
     * @throws [[ArgumentNullException]] Occurs when 'stream' is null.
     * @return True if the stream contains a workbook which is encrypted; False otherwise
     */
    static isWorkbookEncrypted(stream: string | Uint8Array): boolean;
    /**
     * @hidden
     */
    static _isWorkbookEncrypted$i(a: Stream): boolean;
    /**
     * @hidden
     */
    _g7(a: BinaryData): void;
    /**
     * @hidden
     */
    _g8(a: BinaryData): void;
    /**
     * @hidden
     */
    _g9(a: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _ha(a: NamedCalcReferenceBase): void;
    /**
     * @hidden
     */
    _hb(a: PivotCacheInfo): void;
    /**
     * @hidden
     */
    _hc(a: PivotCacheInfo): void;
    /**
     * @hidden
     */
    _hd(a: BinaryData): void;
    /**
     * @hidden
     */
    readonly _cn: boolean;
    /**
     * @hidden
     */
    _he(a: string, b: Stream): void;
    /**
     * @hidden
     */
    private __d7;
    _d7(): IEnumerable$1<KeyValuePair$2<string, number[]>>;
    /**
     * @hidden
     */
    static _fc(a: Workbook): IDisposable;
    /**
     * @hidden
     */
    static _ep(a: Workbook, b: number, c: boolean): number;
    /**
     * @hidden
     */
    static _eq(a: number): number;
    /**
     * @hidden
     */
    static _er(a: Workbook, b: number, c: boolean, d?: boolean): number;
    /**
     * @hidden
     */
    static _es(a: number): number;
    /**
     * @hidden
     */
    _hi(): void;
    /**
     * @hidden
     */
    _hj(a: RefBase): void;
    /**
     * @hidden
     */
    _gv(a: string): string;
    /**
     * @hidden
     */
    _bh(a: boolean): SharedStringTable;
    /**
     * @hidden
     */
    static _fr(a: WorkbookFormat): number;
    /**
     * Returns the number of columns that are supported by the specified format.
     * @param format The format used by the workbook.
     * @return The maximum number of columns supported by the format.
     */
    static getMaxColumnCount(format: WorkbookFormat): number;
    /**
     * @hidden
     */
    static _fe(a: WorkbookFormat): number;
    /**
     * Returns the number of rows that are supported by the specified format.
     * @param format The format used by the workbook.
     * @return The maximum number of rows supported by the format.
     */
    static getMaxRowCount(format: WorkbookFormat): number;
    /**
     * @hidden
     */
    _a2(a: string, b: Worksheet): NamedReferenceBase;
    /**
     * @hidden
     */
    _g2(): number;
    /**
     * @hidden
     */
    _g4(): number;
    /**
     * @hidden
     */
    _hk(a: number): {
        p0?: number;
    };
    /**
     * @hidden
     */
    _d8(): IEnumerable$1<PivotCacheInfo>;
    /**
     * @hidden
     */
    _d9(): IEnumerable$1<PivotCacheInfo>;
    /**
     * @hidden
     */
    static _et(a: Workbook, b: boolean): number;
    /**
     * @hidden
     */
    _ea(): IEnumerable$1<BinaryData>;
    /**
     * @hidden
     */
    _cj(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _ao(a: WorksheetTableColumn, b: ST_TotalsRowFunction): Formula;
    /**
     * @hidden
     */
    _ck(a: WorksheetTableColumn): ST_TotalsRowFunction;
    /**
     * @hidden
     */
    private _gl;
    /**
     * @hidden
     */
    static _eu(a: Workbook, b: boolean): number;
    /**
     * @hidden
     */
    static _hl(a: Workbook, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): {
        p1: CellReferenceMode;
        p2: WorkbookFormat;
        p3: CultureInfo;
    };
    /**
     * @hidden
     */
    _bf(a: string): WorkbookReferenceBase;
    /**
     * @hidden
     */
    _be(a: string, b?: string): WorkbookReferenceBase;
    /**
     * @hidden
     */
    static _c5(a: string, b?: string): boolean;
    /**
     * @hidden
     */
    static _c6(a: string, b: string): boolean;
    /**
     * @hidden
     */
    _bc(a: string, b: string): DdeLinkWorkbookReference;
    /**
     * @hidden
     */
    _bd(a: string, b: Uri): OleLinkWorkbookReference;
    /**
     * @hidden
     */
    _a3(a: string): NamedReferenceBase;
    /**
     * @hidden
     */
    _bl(a: number): Sheet;
    /**
     * @hidden
     */
    _an(): FormatLimitErrors;
    /**
     * @hidden
     */
    _hm(a: (arg1: Sheet, arg2: Formula) => void, b: boolean): void;
    /**
     * @hidden
     */
    _hn(a: (arg1: Sheet, arg2: Formula) => void, b: IEnumerable$1<NamedReferenceBase>, c: IList$1<Sheet>, d: boolean): void;
    /**
     * @hidden
     */
    private _hp;
    /**
     * @hidden
     */
    private _ho;
    /**
     * @hidden
     */
    _hs(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _ht(a: CellCalcReference): void;
    /**
     * @hidden
     */
    _hu<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue, d: ChangeInfo$2<TContext, TValue>): void;
    /**
     * @hidden
     */
    _hv(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _hw(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _hx(a: WorksheetDataTable): void;
    /**
     * @hidden
     */
    _hy(): void;
    /**
     * @hidden
     */
    _hz(): void;
    /**
     * @hidden
     */
    _h0(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _h1(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _h2(a: NamedReferenceBase, b: string): void;
    /**
     * @hidden
     */
    _h8(a: WorkbookStyle): void;
    /**
     * @hidden
     */
    _ib(a: WorksheetTable, b: List$1<WorksheetTableColumn>, c: List$1<Formula>): void;
    /**
     * @hidden
     */
    _h9(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    /**
     * @hidden
     */
    _ia(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _go(a: Sheet, b: ExcelChangeAction, c: string): any;
    /**
     * @hidden
     */
    _ic(a: any): void;
    /**
     * @hidden
     */
    _id(a: any): void;
    /**
     * @hidden
     */
    _ig(): void;
    /**
     * @hidden
     */
    _h4(a: Sheet): void;
    /**
     * @hidden
     */
    _h5(a: Sheet, b: number): void;
    /**
     * @hidden
     */
    _h3(): void;
    /**
     * @hidden
     */
    _h6(a: Sheet, b: number): void;
    /**
     * @hidden
     */
    _h7(a: Sheet): void;
    /**
     * @hidden
     */
    _ar(a: string, b: CellReferenceMode, c: Worksheet, d: WorksheetRow, e: number, f: boolean, g?: boolean, h?: boolean): {
        ret: RefBase;
        p5: boolean;
    };
    /**
     * @hidden
     */
    _ap(a: FormulaContext, b: boolean, c?: boolean, d?: boolean): {
        ret: RefBase;
        p1: boolean;
    };
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    _ij(a: () => void): void;
    /**
     * @hidden
     */
    _il(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _iq(a: IWorkbookOwner): void;
    /**
     * @hidden
     */
    _ir(a: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _is(a: NamedCalcReferenceBase): void;
    /**
     * @hidden
     */
    static _ey(a: Workbook, b: number, c: boolean, d: boolean): number;
    /**
     * @hidden
     */
    _iz(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _i6(a: IWorkbookOwner): void;
    /**
     * @hidden
     */
    _i9(): void;
    /**
     * @hidden
     */
    _jc(a: string, b: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _jb(a: Formula, b: WorksheetRow, c: number): void;
    /**
     * @hidden
     */
    static _i2(): void;
    /**
     * @hidden
     */
    _i3(): void;
    /**
     * @hidden
     */
    static _i4(a: boolean): void;
    /**
     * @hidden
     */
    _jd(a: Sheet, b: string, c: string): void;
    /**
     * @hidden
     */
    _hf(a: StructuredStorageManager, b: Directory, c: string): void;
    /**
     * @hidden
     */
    private static _ac;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private _ih;
    /**
     * @hidden
     */
    private _ii;
    /**
     * @hidden
     */
    private _ie;
    /**
     * @hidden
     */
    private _s;
    /**
     * @hidden
     */
    private _i7;
    /**
     * @hidden
     */
    private _i8;
    /**
     * @hidden
     */
    _ja(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * Gets or sets the value which indicates how a formula will be recalculated when a referenced value changes.
     * <p class="body">
     * If this is set to a value of Manual, the [[recalculateBeforeSave]] property will determine
     * if formulas are recalculated just before saving the file.  Otherwise, that property is ignored.
     * </p>
     * The value which indicates how a formula will be recalculated when a referenced value changes.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[calculationMode]] enumeration.
     * @see [[recalculateBeforeSave]]
     */
    /**
    * Gets or sets the value which indicates how a formula will be recalculated when a referenced value changes.
    * <p class="body">
    * If this is set to a value of Manual, the [[recalculateBeforeSave]] property will determine
    * if formulas are recalculated just before saving the file.  Otherwise, that property is ignored.
    * </p>
    * The value which indicates how a formula will be recalculated when a referenced value changes.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[calculationMode]] enumeration.
    * @see [[recalculateBeforeSave]]
    */
    calculationMode: CalculationMode;
    /**
     * Gets or sets the value which indicates the way cells in the workbook are referenced.
     * <p class="body">
     * The value of this property will affect the row and columns labels of the workbook when opened in Microsoft Excel.
     * In addition, it will affect the display of formulas referencing different cells.
     * </p>
     * The value which indicates the way cells in the workbook are referenced.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[cellReferenceMode]] enumeration.
     */
    /**
    * Gets or sets the value which indicates the way cells in the workbook are referenced.
    * <p class="body">
    * The value of this property will affect the row and columns labels of the workbook when opened in Microsoft Excel.
    * In addition, it will affect the display of formulas referencing different cells.
    * </p>
    * The value which indicates the way cells in the workbook are referenced.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[cellReferenceMode]] enumeration.
    */
    cellReferenceMode: CellReferenceMode;
    /**
     * Gets or sets the culture to use as the current culture for the workbook when doing any culture-aware conversions
     * or comparisons.
     * <p class="note">
     * <b>Note:</b> The culture is not saved or loaded in workbook files, so this is only used at when accessing and
     * manipulating objects owned or associated with the Workbook.
     * </p>
     * The current culture for the workbook or Null to use the thread's current culture.
     */
    /**
    * Gets or sets the culture to use as the current culture for the workbook when doing any culture-aware conversions
    * or comparisons.
    * <p class="note">
    * <b>Note:</b> The culture is not saved or loaded in workbook files, so this is only used at when accessing and
    * manipulating objects owned or associated with the Workbook.
    * </p>
    * The current culture for the workbook or Null to use the thread's current culture.
    */
    culture: string | CultureInfo;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _culture$i: CultureInfo;
    /**
     * Gets the current format of the workbook. This is the format which will be used when saving and imposing format restrictions.
     * @see [[setCurrentFormat]]
     */
    readonly currentFormat: WorkbookFormat;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    customTableStyles(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    customTableStyles(name: string): WorksheetTableStyle;
    /**
     * Gets the collection of custom table styles in the workbook.
     * @see [[defaultTableStyle]]
     * @see [[standardTableStyles]]
     */
    customTableStyles(): CustomTableStyleCollection;
    /**
     * @hidden
     */
    readonly _customTableStyles$i: CustomTableStyleCollection;
    /**
     * Gets the custom view at the specified index.
     * The custom view at the specified index.
     * @param index The zero-based index of the custom view to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    customViews(index: number): CustomView;
    /**
     * Gets the collection of custom views for the workbook.
     * <p class="body">
     * Each custom view stores display settings and optionally print settings, which can later be applied to the workbook
     * and its worksheets as one operation, through both the Microsoft Excel UI and the Excel assembly by calling the
     * [[CustomView.apply]] method.
     * </p>
     * The collection of custom views for the workbook.
     * @see [[CustomView]]
     */
    customViews(): CustomViewCollection;
    /**
     * @hidden
     */
    readonly _customViews$i: CustomViewCollection;
    /**
     * @hidden
     */
    readonly _cq: boolean;
    /**
     * Gets or sets the date system used internally by Microsoft Excel.
     * The date system used internally by Microsoft Excel.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[dateSystem]] enumeration.
     */
    /**
    * Gets or sets the date system used internally by Microsoft Excel.
    * The date system used internally by Microsoft Excel.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[dateSystem]] enumeration.
    */
    dateSystem: DateSystem;
    /**
     * Gets or sets the default style for tables in the workbook.
     * <p class="body">
     * This can be set to any [[WorksheetTableStyle]] in the [[customTableStyles]] or [[standardTableStyles]] collection.
     * </p>
     * <p class="body">
     * This will never return a null value. If it is set to null, it will be reset to the TableStyleMedium2 table style.
     * </p>
     * <p class="body">
     * If this value is changed, it will not be applied to existing tables in the workbook. Only newly created tables will use
     * default table style on the workbook.
     * </p>
     * @throws [[ArgumentException]] The specified value is not in the [[customTableStyles]] or [[standardTableStyles]] collections.
     * @see [[customTableStyles]]
     * @see [[standardTableStyles]]
     * @see [[WorksheetTable.style]]
     */
    /**
    * Gets or sets the default style for tables in the workbook.
    * <p class="body">
    * This can be set to any [[WorksheetTableStyle]] in the [[customTableStyles]] or [[standardTableStyles]] collection.
    * </p>
    * <p class="body">
    * This will never return a null value. If it is set to null, it will be reset to the TableStyleMedium2 table style.
    * </p>
    * <p class="body">
    * If this value is changed, it will not be applied to existing tables in the workbook. Only newly created tables will use
    * default table style on the workbook.
    * </p>
    * @throws [[ArgumentException]] The specified value is not in the [[customTableStyles]] or [[standardTableStyles]] collections.
    * @see [[customTableStyles]]
    * @see [[standardTableStyles]]
    * @see [[WorksheetTable.style]]
    */
    defaultTableStyle: WorksheetTableStyle;
    /**
     * Gets the properties associated with the workbook document.
     * <p class="body">
     * The document properties are pieces of information which provide details on the content of the workbook,
     * such as the author, title, and subject of the workbook.
     * </p>
     * The properties associated with the workbook document.
     */
    readonly documentProperties: DocumentProperties;
    /**
     * @hidden
     */
    readonly _cr: boolean;
    /**
     * The editing culture affects certain language specific features such as formatting of dates.
     * or comparisons.
     * <p class="note">
     * <b>Note:</b> The EditingCulture is not saved or loaded in workbook files, so this is only used at when accessing and
     * manipulating objects owned or associated with the Workbook.
     * </p>
     * @see [[culture]]
     */
    /**
    * The editing culture affects certain language specific features such as formatting of dates.
    * or comparisons.
    * <p class="note">
    * <b>Note:</b> The EditingCulture is not saved or loaded in workbook files, so this is only used at when accessing and
    * manipulating objects owned or associated with the Workbook.
    * </p>
    * @see [[culture]]
    */
    editingCulture: string | CultureInfo;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _editingCulture$i: CultureInfo;
    /**
     * Returns a boolean indicating if the Workbook has been protected with a password.
     * <p class="body">When protecting a Workbook, a password is optional. The HasProtectionPassword will return true if the
     * Workbook is currently protected (see [[isProtected]]) and a password was specified when it was protected. To protect
     * a Workbook without a password, one may use the [[protect]]
     * method that doesn't take a password.</p>
     * @see [[isProtected]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    readonly hasProtectionPassword: boolean;
    /**
     * Returns a boolean indicating if the Workbook has been protected.
     * <p class="body">The IsProtected property will return true if the Workbook is currently protected. When a Workbook is protected
     * certain operations related to the Worksheets displayed or their order or the properties of the windows for the Workbook may be
     * restricted based on the values of the [[protection]].</p>
     * @see [[hasProtectionPassword]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    readonly isProtected: boolean;
    /**
     * Gets a value indicating whether the specified function will be recognized and solved by Microsoft Excel when the workbook is saved out.
     * @param functionName The case-insensitive name of the function.
     * @return True if the function will be recognized in Microsoft Excel; False otherwise.
     */
    isValidFunctionName(functionName: string): boolean;
    /**
     * Gets or sets the value which indicates whether iterations are allowed while calculating formulas containing
     * circular references.
     * <p class="body">
     * When iterative calculations are enabled, a formula is allowed to use circular references,
     * or directly or indirectly reference the cell to which it belongs. Microsoft Excel stops iteratively
     * calculating formulas after iterating [[maxRecursionIterations]] times or when all formula
     * values change by less than [[maxChangeInIteration]] between two iterations.
     * </p>
     * <p class="body">
     * When iterative calculations are disabled, circular references are not allowed, and a formula which
     * references the cell to which it belongs, directly or indirectly, will cause Microsoft Excel to show an
     * error message and the cell will contain a <see cref="ErrorValue.Circularity">Circularity</see> error.
     * </p>
     * The value which indicates whether iterations are allowed while calculating recursive formulas.
     * @see [[ErrorValue.circularity]]
     * @see [[maxChangeInIteration]]
     * @see [[maxRecursionIterations]]
     */
    /**
    * Gets or sets the value which indicates whether iterations are allowed while calculating formulas containing
    * circular references.
    * <p class="body">
    * When iterative calculations are enabled, a formula is allowed to use circular references,
    * or directly or indirectly reference the cell to which it belongs. Microsoft Excel stops iteratively
    * calculating formulas after iterating [[maxRecursionIterations]] times or when all formula
    * values change by less than [[maxChangeInIteration]] between two iterations.
    * </p>
    * <p class="body">
    * When iterative calculations are disabled, circular references are not allowed, and a formula which
    * references the cell to which it belongs, directly or indirectly, will cause Microsoft Excel to show an
    * error message and the cell will contain a <see cref="ErrorValue.Circularity">Circularity</see> error.
    * </p>
    * The value which indicates whether iterations are allowed while calculating recursive formulas.
    * @see [[ErrorValue.circularity]]
    * @see [[maxChangeInIteration]]
    * @see [[maxRecursionIterations]]
    */
    iterativeCalculationsEnabled: boolean;
    /**
     * Gets or sets the maximum change of the values in a formula between iterations which will exit from iteration.
     * <p class="body">
     * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
     * </p>
     * <p class="body">
     * When iterative calculations, or circular references, are enabled, this property determines the maximum change in
     * all values of a formula between two iterations that will cause the formula to exit iterative calculations. Iterative
     * calculations will also be stopped if the formula iterates [[maxRecursionIterations]] times.
     * </p>
     * The maximum change of the values in a formula between iterations which will exit from iteration.
     * @see [[iterativeCalculationsEnabled]]
     * @see [[maxRecursionIterations]]
     */
    /**
    * Gets or sets the maximum change of the values in a formula between iterations which will exit from iteration.
    * <p class="body">
    * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
    * </p>
    * <p class="body">
    * When iterative calculations, or circular references, are enabled, this property determines the maximum change in
    * all values of a formula between two iterations that will cause the formula to exit iterative calculations. Iterative
    * calculations will also be stopped if the formula iterates [[maxRecursionIterations]] times.
    * </p>
    * The maximum change of the values in a formula between iterations which will exit from iteration.
    * @see [[iterativeCalculationsEnabled]]
    * @see [[maxRecursionIterations]]
    */
    maxChangeInIteration: number;
    /**
     * Gets the maximum number of columns allowed in each worksheet based on the [[currentFormat]].
     */
    readonly maxColumnCount: number;
    /**
     * Gets or sets the maximum number of times formulas should be iteratively calculated.
     * <p class="body">
     * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
     * </p>
     * <p class="body">
     * When iterative calculations, or circular references, are enabled, this property determines the number of iterations
     * allowed when calculating iteratively.
     * </p>
     * The maximum number of times formulas should be iteratively calculated.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 32767.
     * @see [[iterativeCalculationsEnabled]]
     * @see [[maxChangeInIteration]]
     */
    /**
    * Gets or sets the maximum number of times formulas should be iteratively calculated.
    * <p class="body">
    * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
    * </p>
    * <p class="body">
    * When iterative calculations, or circular references, are enabled, this property determines the number of iterations
    * allowed when calculating iteratively.
    * </p>
    * The maximum number of times formulas should be iteratively calculated.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 32767.
    * @see [[iterativeCalculationsEnabled]]
    * @see [[maxChangeInIteration]]
    */
    maxRecursionIterations: number;
    /**
     * Gets the maximum number of rows allowed in each worksheet based on the [[currentFormat]].
     */
    readonly maxRowCount: number;
    /**
     * Gets the named reference at the specified index.
     * The named reference at the specified index.
     * @param index The zero-based index of the named reference to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    namedReferences(index: number): NamedReference;
    /**
     * Gets the collection of named references in the workbook.
     * <p class="body">
     * Named references are typically used to refer to cells or ranges of cells by name.
     * The named reference names are used by formulas instead of explicitly naming the
     * cells or cell ranges.
     * </p>
     * The collection of named references in the workbook.
     * @see [[NamedReference]]
     */
    namedReferences(): NamedReferenceCollection;
    /**
     * @hidden
     */
    readonly _namedReferences$i: NamedReferenceCollection;
    /**
     * @hidden
     */
    readonly _cv: boolean;
    /**
     * Gets or sets a color in the palette.
     * <p class="body">
     * When a color is set in the palette, [[isCustom]] will return True. The palette can than be reset with the
     * [[reset]] method.
     * </p>
     * <p class="body">
     * Colors added to the palette must be opaque.
     * </p>
     * @param index The index of the color to get or set in the palette.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than 55.
     * @throws [[ArgumentException]] The value assigned is an empty color, a system color, or is not opaque.
     * @see [[isCustom]]
     * @see [[reset]]
     */
    palette(index: number, value?: string | Color): string;
    /**
     * Gets the color palette used when the saved file is opened in Microsoft Excel 2003 and earlier versions.
     * <p class="body">
     * When the file is opened in Microsoft Excel 2003 and earlier versions, the actual colors used in cells and shapes may not be displayed.
     * Instead, the closest color in the palette will be displayed instead. Therefore, the palette can be customized if necessary to keep the
     * colors as accurate as possible in older versions of Excel.
     * </p>
     */
    palette(): WorkbookColorPalette;
    /**
     * @hidden
     */
    readonly _palette$i: WorkbookColorPalette;
    /**
     * Gets or sets the precision to use when obtaining a cell's value.
     * <p class="body">
     * The precision determines whether to use the actual value of the cell or the display value of the cell.
     * These are typically the same, but the format of a cell could cause a loss of precision in the displayed
     * value.  For example, if a cell's value is 18.975, and a currency format is used for the cell, the display
     * value will be 18.98.
     * </p>
     * The precision to use when obtaining a cell's value.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the  enumeration.
     */
    /**
    * Gets or sets the precision to use when obtaining a cell's value.
    * <p class="body">
    * The precision determines whether to use the actual value of the cell or the display value of the cell.
    * These are typically the same, but the format of a cell could cause a loss of precision in the displayed
    * value.  For example, if a cell's value is 18.975, and a currency format is used for the cell, the display
    * value will be 18.98.
    * </p>
    * The precision to use when obtaining a cell's value.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the  enumeration.
    */
    precision: Precision;
    /**
     * @hidden
     */
    _df: boolean;
    /**
     * Returns an object that provides information used when the Workbook has been protected.
     * @see [[hasProtectionPassword]]
     * @see [[isProtected]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    readonly protection: WorkbookProtection;
    /**
     * Gets or sets the value which indicates whether the workbook should recalculate all formulas before saving.
     * <p class="body">
     * This property only applies if the [[calculationMode]] is set to Manual.  Otherwise, it is ignored.
     * </p>
     * The value which indicates whether the workbook should recalculate all formulas before saving.
     * @see [[recalculate]]
     * @see [[calculationMode]]
     */
    /**
    * Gets or sets the value which indicates whether the workbook should recalculate all formulas before saving.
    * <p class="body">
    * This property only applies if the [[calculationMode]] is set to Manual.  Otherwise, it is ignored.
    * </p>
    * The value which indicates whether the workbook should recalculate all formulas before saving.
    * @see [[recalculate]]
    * @see [[calculationMode]]
    */
    recalculateBeforeSave: boolean;
    /**
     * Gets or sets the value which indicates whether to save values linked from external workbooks.
     * <p class="body">
     * This value will only be used when the workbook is opened in Microsoft Excel. When referencing external values
     * and saving a workbook through the Excel assembly, external linked values will never be saved.
     * </p>
     * The value which indicates whether to save values linked from external workbooks.
     */
    /**
    * Gets or sets the value which indicates whether to save values linked from external workbooks.
    * <p class="body">
    * This value will only be used when the workbook is opened in Microsoft Excel. When referencing external values
    * and saving a workbook through the Excel assembly, external linked values will never be saved.
    * </p>
    * The value which indicates whether to save values linked from external workbooks.
    */
    saveExternalLinkedValues: boolean;
    /**
     * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
     * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
     */
    /**
    * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
    * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
    */
    screenDpi: IgSize;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _screenDpi$i: Size;
    /**
     * @hidden
     */
    private _i0;
    /**
     * @hidden
     */
    private static _c2;
    /**
     * Gets the sheet at the specified index.
     * The sheet at the specified index.
     * @param index The zero-based index of the sheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    sheets(index: number): Sheet;
    /**
     * Gets the sheet with the specified name.
     * <p class="body">
     * Sheet names are compared case-insensitively.
     * </p>
     * The sheet with the specified name.
     * @param name The name of the sheet to get.
     * @throws [[InvalidOperationException]] A sheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    sheets(name: string): Sheet;
    /**
     * Gets the collection of sheets in the workbook.
     * <p class="body">
     * Use <see cref="Excel.WindowOptions.SelectedSheet">WindowOptions.SelectedSheet</see> to set the
     * selected sheet. The selected sheet is the sheet seen when the workbook is opened in Microsoft Excel.
     * </p>
     * The collection of worksheets in the workbook.
     */
    sheets(): SheetCollection;
    /**
     * @hidden
     */
    readonly _sheets$i: SheetCollection;
    /**
     * Gets or sets the value which indicates whether carriage return characters should be removed from string values in cells
     * when the workbook is saved to an Excel file.
     * <p class="body">
     * In Microsoft Excel 2003, carriage return characters are displayed as boxes. Most of the time, this should not be seen
     * and removing the carriage return characters has no adverse effect on the layout of the text within a cell. Therefore,
     * this property is True by default.
     * </p>
     * True if the saved workbook file should not contain the carriage return characters from cell values; False to export the
     * string values as they have been set on the cells.
     */
    /**
    * Gets or sets the value which indicates whether carriage return characters should be removed from string values in cells
    * when the workbook is saved to an Excel file.
    * <p class="body">
    * In Microsoft Excel 2003, carriage return characters are displayed as boxes. Most of the time, this should not be seen
    * and removing the carriage return characters has no adverse effect on the layout of the text within a cell. Therefore,
    * this property is True by default.
    * </p>
    * True if the saved workbook file should not contain the carriage return characters from cell values; False to export the
    * string values as they have been set on the cells.
    */
    shouldRemoveCarriageReturnsOnSave: boolean;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    standardTableStyles(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    standardTableStyles(name: string): WorksheetTableStyle;
    /**
     * Gets the read-only collection of preset table styles in the workbook.
     * @see [[defaultTableStyle]]
     * @see [[customTableStyles]]
     */
    standardTableStyles(): StandardTableStyleCollection;
    /**
     * @hidden
     */
    readonly _standardTableStyles$i: StandardTableStyleCollection;
    /**
     * Gets the style at the specified index.
     * The style at the specified index.
     * @param index The zero-based index of the style to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    styles(index: number): WorkbookStyle;
    /**
     * Gets the style with the specified name.
     * <p class="body">
     * Style names are compared case-insensitively.
     * </p>
     * The style with the specified name or null if no style with that name exists.
     * @param name The name of the style to get.
     * @throws [[ArgumentNullException]] 'name' is null.
     */
    styles(name: string): WorkbookStyle;
    /**
     * Gets the collection of custom styles in the workbook.
     * <p class="body">
     * Use this collection to add custom styles to Excel workbook. The user can apply those styles to different
     * parts of excel workbook and thereby set complex formatting with ease.
     * </p>
     * The collection of custom styles in the workbook.
     * @see [[WorkbookStyle]]
     */
    styles(): WorkbookStyleCollection;
    /**
     * @hidden
     */
    readonly _styles$i: WorkbookStyleCollection;
    /**
     * Gets or sets the value indicating whether the format strings should be validated when they are set.
     * <p class="body">
     * This value is False by default to maintain backward compatibility.
     * </p>
     * <p class="body">
     * When True, format strings will be validated when a [[IWorksheetCellFormat.formatString]] property is set. An invalid
     * format string will cause an exception. When False, invalid format strings will be allowed, but if the display text of a cell is
     * requested, an exception will be thrown at that time. If invalid format strings are allowed and the workbook is saved and opened
     * in Microsoft Excel, it will show an error.
     * </p>
     * @see [[IWorksheetCellFormat.formatString]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetRow.getCellText]]
     * @see [[WorksheetRow.getCellText]]
     */
    /**
    * Gets or sets the value indicating whether the format strings should be validated when they are set.
    * <p class="body">
    * This value is False by default to maintain backward compatibility.
    * </p>
    * <p class="body">
    * When True, format strings will be validated when a [[IWorksheetCellFormat.formatString]] property is set. An invalid
    * format string will cause an exception. When False, invalid format strings will be allowed, but if the display text of a cell is
    * requested, an exception will be thrown at that time. If invalid format strings are allowed and the workbook is saved and opened
    * in Microsoft Excel, it will show an error.
    * </p>
    * @see [[IWorksheetCellFormat.formatString]]
    * @see [[WorksheetCell.getText]]
    * @see [[WorksheetCell.getText]]
    * @see [[WorksheetRow.getCellText]]
    * @see [[WorksheetRow.getCellText]]
    */
    validateFormatStrings: boolean;
    /**
     * Gets the options which control various workbook level display properties.
     * <p class="body">
     * The window options control properties of the child MDI window showing the workbook in Microsoft Excel.
     * They also control display options of the workbook which do not change based on the selected worksheet.
     * </p>
     * The options which control various workbook level display properties.
     * @see [[CustomView.windowOptions]]
     */
    readonly windowOptions: WorkbookWindowOptions;
    /**
     * Gets the worksheet at the specified index.
     * The worksheet at the specified index.
     * @param index The zero-based index of the worksheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    worksheets(index: number): Worksheet;
    /**
     * Gets the worksheet with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The worksheet with the specified name.
     * @param name The name of the worksheet to get.
     * @throws [[InvalidOperationException]] A worksheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    worksheets(name: string): Worksheet;
    /**
     * Gets the collection of worksheets in the workbook.
     * <p class="body">
     * Use <see cref="Excel.WindowOptions.SelectedWorksheet">WindowOptions.SelectedWorksheet</see> to set the
     * selected worksheet. The selected worksheet is the worksheet seen when the workbook is opened in Microsoft Excel.
     * </p>
     * The collection of worksheets in the workbook.
     */
    worksheets(): WorksheetCollection;
    /**
     * @hidden
     */
    readonly _worksheets$i: WorksheetCollection;
    /**
     * @hidden
     */
    readonly _u: ActiveCellChangedInfo;
    /**
     * @hidden
     */
    readonly _a9: AddInFunctionsWorkbookReference;
    /**
     * @hidden
     */
    readonly _cm: boolean;
    /**
     * @hidden
     */
    readonly _ab: CellSizeMeasurementContext;
    /**
     * @hidden
     */
    readonly _bq: TextMetricsProviderBase;
    /**
     * @hidden
     */
    readonly _ca: WorksheetCellFormatCollection;
    /**
     * @hidden
     */
    _ad: ChartDeserializationCache;
    /**
     * @hidden
     */
    readonly _e6: CultureInfo;
    /**
     * @hidden
     */
    readonly _bb: CurrentWorkbookReference;
    /**
     * @hidden
     */
    _g3: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _e: number[];
    /**
     * @hidden
     */
    readonly _ef: List$1<BinaryData>;
    /**
     * @hidden
     */
    readonly _eh: List$1<BinaryData>;
    /**
     * @hidden
     */
    readonly _fp: number;
    /**
     * @hidden
     */
    _gk: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _cc: WorksheetCellFormatCollection;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ej: List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _el: List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    readonly _dz: Dictionary$2<string, WorkbookReferenceBase>;
    /**
     * @hidden
     */
    readonly _av: GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    readonly _at: GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    readonly _ax: GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    readonly _b2: WorkbookFormatCollection;
    /**
     * @hidden
     */
    readonly _ct: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _co: boolean;
    /**
     * @hidden
     */
    readonly _cp: boolean;
    /**
     * @hidden
     */
    readonly _cx: boolean;
    /**
     * @hidden
     */
    readonly _cy: boolean;
    /**
     * @hidden
     */
    readonly _cz: boolean;
    /**
     * @hidden
     */
    readonly _c1: boolean;
    /**
     * @hidden
     */
    readonly _en: List$1<NamedReference>;
    /**
     * @hidden
     */
    readonly _cu: boolean;
    /**
     * @hidden
     */
    readonly _c4: boolean;
    /**
     * @hidden
     */
    readonly _c9: boolean;
    /**
     * @hidden
     */
    _gw: string;
    /**
     * @hidden
     */
    readonly _fv: number;
    /**
     * @hidden
     */
    readonly _ff: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g6: number;
    /**
     * @hidden
     */
    _gn: Nullable$1<WorksheetRegionAddress>;
    /**
     * @hidden
     */
    readonly _d1: Dictionary$2<string, Formula>;
    /**
     * @hidden
     */
    _l: OleDataSpacesEncryptionMode;
    /**
     * @hidden
     */
    readonly _a0: IWorkbookOwner;
    /**
     * @hidden
     */
    static readonly _jh: Size;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _dj: boolean;
    /**
     * @hidden
     */
    readonly _d6: HashSet$1<number>;
    /**
     * @hidden
     */
    readonly _bj: SharedStringTable;
    /**
     * @hidden
     */
    readonly _h: Color[];
    /**
     * @hidden
     */
    static _c(): Color[];
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _k: BinaryData;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g0: string;
    /**
     * @hidden
     */
    _dt: boolean;
    /**
     * @hidden
     */
    readonly _bm: Sheet;
    /**
     * @hidden
     */
    readonly _gj: number;
    /**
     * @hidden
     */
    _it(): void;
    /**
     * @hidden
     */
    private static _d3;
    /**
     * @hidden
     */
    private static readonly _d4;
    /**
     * @hidden
     */
    readonly _w: ExcelCalcEngine;
    /**
     * @hidden
     */
    private static readonly _ji;
    /**
     * @hidden
     */
    readonly _jk: Size;
}
/**
 * @hidden
 */
export declare class Workbook_MetricsProviderCache extends Base implements IDisposable {
    static $t: Type;
    private _f;
    private readonly _e;
    private _c;
    private _a;
    constructor(a: Workbook);
    readonly _b: CellSizeMeasurementContext;
    readonly _d: TextMetricsProviderBase;
    _g(): void;
    dispose(): void;
}
/**
 * @hidden
 */
export declare class Workbook_OleLinkInfoComparer extends Base implements IEqualityComparer$1<ValueTuple$2<string, Uri>> {
    static $t: Type;
    static readonly _a: Workbook_OleLinkInfoComparer;
    constructor();
    equalsC(a: ValueTuple$2<string, Uri>, b: ValueTuple$2<string, Uri>): boolean;
    getHashCodeC(a: ValueTuple$2<string, Uri>): number;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElement extends Base {
    static $t: Type;
    private e;
    constructor();
    equals(a: any): boolean;
    getHashCode(): number;
    abstract g(a: Workbook): any;
    abstract c(a: GenericCacheElement): boolean;
    j(): void;
    k(): void;
    protected l(a: boolean): void;
    static h<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    static i<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: T, c: boolean): {
        p1?: T;
    };
    static a<T extends GenericCacheElement>($t: Type, a: T, b: GenericCachedCollection$1<T>): T;
    static m<T extends GenericCacheElement>($t: Type, a: T, b: GenericCachedCollection$1<T>): void;
    static o<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: GenericCachedCollection$1<T>, c: T): {
        p1?: GenericCachedCollection$1<T>;
        p2?: T;
    };
    protected n(): void;
    readonly f: number;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElementEx extends GenericCacheElement {
    static $t: Type;
    private s;
    private u;
    private w;
    constructor(a: Workbook);
    ab(a: IGenericCachedCollectionEx): void;
    ac(): void;
    abstract aa(a: GenericCacheElement): void;
    protected abstract af(): void;
    static z<T extends GenericCacheElementEx>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    static p<T extends GenericCacheElementEx>($t: Type, a: T, b: boolean): {
        ret: GenericCachedCollection$1<T>;
        p0?: T;
    };
    y(): any;
    static r<T extends GenericCacheElementEx>($t: Type, a: T, b: GenericCachedCollection$1<T>): T;
    static q<T extends GenericCacheElementEx>($t: Type, a: T): GenericCachedCollection$1<T>;
    static ad<T extends GenericCacheElementEx>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    ae(a: Workbook, b: boolean): void;
    t: IGenericCachedCollectionEx;
    x: boolean;
    v: Workbook;
}
/**
 * @hidden
 */
export interface IWorkbookFontDefaultsResolver {
    resolveDefaults(a: WorkbookFontData): void;
}
/**
 * @hidden
 */
export declare let IWorkbookFontDefaultsResolver_$type: Type;
/**
 * Represents the format for the cell.
 * <p class="body">
 * Depending on where the format is exposed, it will have a different meaning. For example, a cell's format just applies to itself,
 * but a row or column's format applies to all cells in that row or column. There are also style formats, which can be the parent of
 * other formats, meaning they provide defaults for values not set on the format. And finally, there are differential formats, such
 * as the format for areas in a table, which provide default values for cells which exist in the associated area.
 * </p>
 * @see [[WorksheetCell.cellFormat]]
 * @see [[RowColumnBase.cellFormat]]
 * @see [[WorksheetMergedCellsRegion.cellFormat]]
 * @see [[WorkbookStyle.styleFormat]]
 * @see [[WorksheetTable.areaFormats]]
 * @see [[WorksheetTableColumn.areaFormats]]
 * @see [[WorksheetTableStyle.areaFormats]]
 * @see [[WorksheetCell.getResolvedCellFormat]]
 * @see [[RowColumnBase.getResolvedCellFormat]]
 * @see [[WorksheetMergedCellsRegion.getResolvedCellFormat]]
 */
export interface IWorksheetCellFormat {
    setFormatting(source: IWorksheetCellFormat): void;
    alignment: HorizontalCellAlignment;
    bottomBorderColorInfo: WorkbookColorInfo;
    bottomBorderStyle: CellBorderLineStyle;
    diagonalBorderColorInfo: WorkbookColorInfo;
    diagonalBorders: DiagonalBorders;
    diagonalBorderStyle: CellBorderLineStyle;
    fill: CellFill;
    readonly font: IWorkbookFont;
    formatOptions: WorksheetCellFormatOptions;
    formatString: string;
    indent: number;
    leftBorderColorInfo: WorkbookColorInfo;
    leftBorderStyle: CellBorderLineStyle;
    locked: boolean | null;
    _locked$i: Nullable$1<boolean>;
    rightBorderColorInfo: WorkbookColorInfo;
    rightBorderStyle: CellBorderLineStyle;
    rotation: number;
    shrinkToFit: boolean | null;
    _shrinkToFit$i: Nullable$1<boolean>;
    style: WorkbookStyle;
    topBorderColorInfo: WorkbookColorInfo;
    topBorderStyle: CellBorderLineStyle;
    verticalAlignment: VerticalCellAlignment;
    wrapText: boolean | null;
    _wrapText$i: Nullable$1<boolean>;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormat_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetCellFormatData extends GenericCacheElementEx implements IWorkbookFontDefaultsResolver, IWorksheetCellFormat {
    static $t: Type;
    _as: CellFormatCache;
    private _b4;
    private _a3;
    private _ba;
    private _ag;
    private _cx;
    private _bt;
    private _bb;
    private _au;
    private _ah;
    private _aq;
    private _bo;
    private _bw;
    private _a5;
    private _ci;
    private _cj;
    private _b5;
    private _bc;
    private _ai;
    private _cz;
    private _av;
    private _bd;
    private _aj;
    private _ck;
    private _c0;
    private _bq;
    private _be;
    private _ak;
    private _b0;
    private _b2;
    private _a7;
    private _c1;
    private _cy;
    constructor(a: Workbook, b: WorksheetCellFormatType);
    resolveDefaults(a: WorkbookFontData): void;
    g(a: Workbook): any;
    _bu(): WorksheetCellFormatData;
    _bv(a: Workbook, b?: boolean): WorksheetCellFormatData;
    aa(a: GenericCacheElement): void;
    equals(a: any): boolean;
    _ca(a: WorksheetCellFormatData): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    ab(a: IGenericCachedCollectionEx): void;
    ac(): void;
    protected l(a: boolean): void;
    protected af(): void;
    setFormatting(a: IWorksheetCellFormat): void;
    _dh(a: WorksheetCellFormatOptions, b: WorksheetCellFormatData): void;
    _dk(): void;
    static _c8(a: CellFormatValue): any;
    _ay(a: CellFill): FillPatternStyle;
    static _az(a: CellFill, b: IWorksheetCellFormat): FillPatternStyle;
    _bi(a: CellFill, b: boolean, c: boolean): WorkbookColorInfo;
    static _bj(a: CellFill, b: boolean, c: boolean, d: IWorksheetCellFormat, e: boolean): WorkbookColorInfo;
    static _a2(a: Workbook, b: WorksheetCellFormatData): GenericCachedCollectionEx$1<WorkbookFontData>;
    _da(a: CellFormatValue, b?: (borderProperty: CellFormatValue, value: any) => {
        ret: boolean;
        p1: any;
    }): any;
    private _db;
    _dd(a: CellFormatValue): any;
    _cg(): List$1<ExtProp>;
    _ch(): List$1<XFProp>;
    _cc(): boolean;
    static _cf(a: CellFormatValue, b: any): boolean;
    _dm(): void;
    _ds(a: CellFormatValue): void;
    _dv(a: CellFormatValue, b: any): void;
    _dw(a: WorkbookColorInfo, b: ExtPropType, c: List$1<ExtProp>): void;
    _dx(a: WorkbookColorInfo, b: XFPropType, c: List$1<XFProp>): void;
    private static _di;
    _br(a: WorkbookStyle): WorkbookStyle;
    private _bx;
    private _dj;
    static _by(a: CellFormatValue): WorksheetCellFormatOptions;
    private static _at;
    private _dl;
    private _c9;
    private static _dc;
    _cb(a: WorksheetCellFormatOptions): boolean;
    private _dp;
    private _dq;
    _dr(a: WorksheetCellFormatOptions): void;
    private _dy;
    private _dz;
    private _d0;
    private _d1;
    private _d2;
    private _d3;
    private _bn;
    alignment: HorizontalCellAlignment;
    bottomBorderColorInfo: WorkbookColorInfo;
    bottomBorderStyle: CellBorderLineStyle;
    diagonalBorderColorInfo: WorkbookColorInfo;
    diagonalBorders: DiagonalBorders;
    diagonalBorderStyle: CellBorderLineStyle;
    fill: CellFill;
    readonly font: IWorkbookFont;
    formatOptions: WorksheetCellFormatOptions;
    _dt(a: WorksheetCellFormatOptions): void;
    private _dn;
    formatString: string;
    indent: number;
    leftBorderColorInfo: WorkbookColorInfo;
    leftBorderStyle: CellBorderLineStyle;
    locked: boolean | null;
    _locked$i: Nullable$1<boolean>;
    rightBorderColorInfo: WorkbookColorInfo;
    rightBorderStyle: CellBorderLineStyle;
    rotation: number;
    shrinkToFit: boolean | null;
    _shrinkToFit$i: Nullable$1<boolean>;
    style: WorkbookStyle;
    _du(a: WorkbookStyle): void;
    topBorderColorInfo: WorkbookColorInfo;
    topBorderStyle: CellBorderLineStyle;
    verticalAlignment: VerticalCellAlignment;
    wrapText: boolean | null;
    _wrapText$i: Nullable$1<boolean>;
    readonly _a4: HorizontalCellAlignment;
    readonly _bf: WorkbookColorInfo;
    readonly _al: CellBorderLineStyle;
    readonly _bg: WorkbookColorInfo;
    readonly _aw: DiagonalBorders;
    readonly _am: CellBorderLineStyle;
    readonly _ar: CellFill;
    readonly _c2: Nullable$1<boolean>;
    readonly _bh: WorkbookColorInfo;
    readonly _cq: number;
    readonly _c3: Nullable$1<boolean>;
    readonly _df: string;
    readonly _c4: Nullable$1<boolean>;
    readonly _a0: FontSuperscriptSubscriptStyle;
    readonly _a1: FontUnderlineStyle;
    readonly _bz: WorksheetCellFormatOptions;
    readonly _cs: number;
    readonly _dg: string;
    readonly _ct: number;
    readonly _bk: WorkbookColorInfo;
    readonly _an: CellBorderLineStyle;
    readonly _c5: Nullable$1<boolean>;
    readonly _bl: WorkbookColorInfo;
    readonly _ao: CellBorderLineStyle;
    readonly _cw: number;
    readonly _c6: Nullable$1<boolean>;
    readonly _bs: WorkbookStyle;
    readonly _bm: WorkbookColorInfo;
    readonly _ap: CellBorderLineStyle;
    readonly _a9: VerticalCellAlignment;
    readonly _c7: Nullable$1<boolean>;
    _b6: boolean;
    readonly _cl: number;
    readonly _cm: number;
    readonly _cn: number;
    readonly _cp: number;
    readonly _co: number;
    readonly _b7: boolean;
    readonly _a8: VerticalCellAlignment;
    readonly _b8: boolean;
    readonly _b9: boolean;
    readonly _bp: WorkbookFontProxy;
    _a6: FontScheme;
    _cr: number;
    readonly _cd: boolean;
    _ce: boolean;
    _b1: WorksheetCellFormatType;
    readonly _ax: DiagonalBorders;
    _b3: (arg1: WorksheetCellFormatOptions) => void;
}
/**
 * @hidden
 */
export declare class CellFormatCache extends Base {
    static $t: Type;
    c: number;
    a: WorksheetCellFormatData;
    f: any;
    d: HTMLCanvasElement;
    e: CanvasRenderingContext2D;
    b: boolean;
    constructor(a: WorksheetCellFormatData);
    g(): void;
    static h(a: any): void;
}
/**
 * @hidden
 */
export declare abstract class TextMetricsProviderBase extends Base implements IDisposable {
    static $t: Type;
    protected readonly _a: Workbook;
    constructor(a: Workbook);
    dispose(): void;
    protected get__b(): boolean;
    readonly _b: boolean;
    abstract _d(a: WorksheetCellFormatData): number;
    abstract _g(a: WorksheetCellFormatData, b: string, c: Nullable$1<Size>, d: boolean, e: boolean): Size;
    _e(a: WorksheetCellFormatData): number;
    static _c(a: FontUnderlineStyle): boolean;
    _f(a: Size): {
        p0?: Size;
    };
}
/**
 * @hidden
 */
export declare class DomTextMetricsProvider extends TextMetricsProviderBase {
    static $t: Type;
    private readonly _i;
    constructor(a: Workbook, b: DomRenderer);
    dispose(): void;
    private readonly _h;
    private _k;
    private _j;
    private _n;
    _d(a: WorksheetCellFormatData): number;
    _e(a: WorksheetCellFormatData): number;
    _g(a: WorksheetCellFormatData, b: string, c?: Nullable$1<Size>, d?: boolean, e?: boolean): Size;
    private _m;
    private _l;
}
/**
 * @hidden
 */
export declare class HtmlTextMetricsProvider extends TextMetricsProviderBase {
    static $t: Type;
    constructor(a: Workbook);
    dispose(): void;
    private readonly _h;
    private _j;
    private _l;
    private _k;
    _d(a: WorksheetCellFormatData): number;
    _e(a: WorksheetCellFormatData): number;
    _g(a: WorksheetCellFormatData, b: string, c?: Nullable$1<Size>, d?: boolean, e?: boolean): Size;
    private static _i;
    private _n;
    private _m;
}
/**
 * Abstract base class for [[WorkbookLoadOptions]] or [[WorkbookSaveOptions]].
 */
export declare abstract class WorkbookOptionsBase extends Base {
    static $t: Type;
    private _a;
    private _b;
    static staticInit(): void;
    constructor(a: IPackageFactory);
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _c: IPackageFactory;
    /**
     * @hidden
     */
    static _e: () => IPackageFactory;
    /**
     * @hidden
     */
    readonly _d: IPackageFactory;
}
/**
 * #elif WINRT#elif TINYCLR
 * Contains the options related to loading a workbook from a file or stream.
 * @see [[Workbook.load]]
 */
export declare class WorkbookLoadOptions extends WorkbookOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    _f(): number[];
    /**
     * @hidden
     */
    readonly _j: boolean;
    private _g;
    private _h;
    private _n;
    constructor();
    /**
     * Returns or sets a boolean indicating whether the Workbook will automatically call its [[Workbook.resumeCalculations]] methods before the Load method returns.
     * When the Load method starts the [[Workbook.suspendCalculations]] is invoked so that no
     * calculations occurs as the load is in progress. When the Load operation is complete and the Workbook
     * is about to be returned from the Load method, it will call the [[Workbook.resumeCalculations]]
     * method to ensure that the loaded formulas have been added to the calculation network and the formulas
     * can be calculated. However if one wanted to delay calling that method, perhaps to add additional formulas
     * to the workbook being loaded, one can set this property to false and then the Workbook will not call
     * ResumeCalculations. Instead it will be the responsibility of the caller to invoke this method.
     * @see [[Workbook.suspendCalculations]]
     * @see [[Workbook.resumeCalculations]]
     */
    /**
    * Returns or sets a boolean indicating whether the Workbook will automatically call its [[Workbook.resumeCalculations]] methods before the Load method returns.
    * When the Load method starts the [[Workbook.suspendCalculations]] is invoked so that no
    * calculations occurs as the load is in progress. When the Load operation is complete and the Workbook
    * is about to be returned from the Load method, it will call the [[Workbook.resumeCalculations]]
    * method to ensure that the loaded formulas have been added to the calculation network and the formulas
    * can be calculated. However if one wanted to delay calling that method, perhaps to add additional formulas
    * to the workbook being loaded, one can set this property to false and then the Workbook will not call
    * ResumeCalculations. Instead it will be the responsibility of the caller to invoke this method.
    * @see [[Workbook.suspendCalculations]]
    * @see [[Workbook.resumeCalculations]]
    */
    autoResumeCalculations: boolean;
    /**
     * Returns or sets the value for the [[Workbook.culture]] property.
     * @see [[Workbook.culture]]
     */
    /**
    * Returns or sets the value for the [[Workbook.culture]] property.
    * @see [[Workbook.culture]]
    */
    culture: string | CultureInfo;
    private _culture$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _culture$i: CultureInfo;
    /**
     * @hidden
     */
    readonly _k: boolean;
    /**
     * Returns or sets a boolean indicating whether duplicate formulas parsed during the load will be optimized for faster loading of the workbook.
     * <p class="body">
     * By default when an exact duplicate of a formula string is encountered during the load, the previously parsed formula
     * will be cloned rather than reparsing the string to create an entirely new formula.
     * </p>
     * <p class="note"><b>Note:</b> This property does not apply to the loading of the xls formats.</p>
     */
    /**
    * Returns or sets a boolean indicating whether duplicate formulas parsed during the load will be optimized for faster loading of the workbook.
    * <p class="body">
    * By default when an exact duplicate of a formula string is encountered during the load, the previously parsed formula
    * will be cloned rather than reparsing the string to create an entirely new formula.
    * </p>
    * <p class="note"><b>Note:</b> This property does not apply to the loading of the xls formats.</p>
    */
    isDuplicateFormulaParsingOptimized: boolean;
    /**
     * Returns a list of user defined functions that should be registered before the workbook is loaded.
     */
    readonly userDefinedFunctions: IList$1<ExcelCalcFunction>;
}
/**
 * Represents a range of cells in a worksheet that may be edited by the end user.
 */
export declare class WorksheetProtectedRange extends Base {
    static $t: Type;
    private _a;
    private _k;
    /**
     * @hidden
     */
    _b(): number[];
    /**
     * @hidden
     */
    _m(): string;
    /**
     * @hidden
     */
    _o(a: number[]): void;
    /**
     * @hidden
     */
    _p(a: string): void;
    private _d;
    private _g;
    private _l;
    private _f;
    /**
     * @hidden
     */
    readonly _c: WorkbookPasswordInfo;
    constructor(title: string);
    /**
     * Returns true if the range has a password associated with it.
     */
    readonly hasPassword: boolean;
    /**
     * Returns a boolean indicating if the range is currently locked.
     * <p class="body">When the associated Worksheet is protected, the ranges with a password
     * will be marked as protected until they are unprotected.</p>
     */
    /**
    * Returns a boolean indicating if the range is currently locked.
    * <p class="body">When the associated Worksheet is protected, the ranges with a password
    * will be marked as protected until they are unprotected.</p>
    */
    isProtected: boolean;
    /**
     * Returns a collection of ranges that may be edited when the worksheet is protected.
     */
    readonly ranges: ICollection$1<WorksheetRegion>;
    /**
     * Returns or sets the name of the range.
     */
    /**
    * Returns or sets the name of the range.
    */
    title: string;
    /**
     * Returns the worksheet with which the edit range is associated.
     */
    /**
    * Returns the worksheet with which the edit range is associated.
    */
    worksheet: Worksheet;
    /**
     * Removes the password from the range.
     * <p class="note"><b>Note:</b> If the range is not currently protected (i.e. [[isProtected]] returns
     * false) the method will not do anything.</p>
     * @see [[isProtected]]
     * @see [[hasPassword]]
     */
    unprotect(): void;
}
/**
 * @hidden
 */
export declare class MathUtilities extends Base {
    static $t: Type;
    static readonly l: CultureInfo;
    static q(a: number, b: CultureInfo): string;
    private static p;
    private static n;
    static r(a: number, b: CultureInfo): string;
    static b(a: string, b: IFormatProvider, c: number): {
        ret: boolean;
        p2: number;
    };
    static c(a: string, b: IFormatProvider, c: number): {
        ret: boolean;
        p2: number;
    };
    private static d;
    private static e;
    static m(a: number): number;
    static o(a: number): number;
    static f(a: number): number;
    private static a;
    static g(a: number, b: number): number;
    private static h;
    static i(a: number): number;
    static j(a: number): number;
    static k(a: number, b: number): number;
}
/**
 * Abstract base class for the fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillPattern]]
 * @see [[CellFillGradient]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare abstract class CellFill extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    abstract _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    abstract _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    abstract _c(a: Workbook): CellFill;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param stops Two or more gradient stops which describe the color transitions and their positions within the gradient.
     * @throws [[ArgumentException]] 'stops' contains less than two gradient stops. There must be at least two stops to define the gradient.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, ...stops: CellFillGradientStop[]): CellFillLinearGradient;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the start of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the end of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillLinearGradient;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param color1 The color at the start of the gradient.
     * @param color2 The color at the end of the gradient.
     * @throws [[ArgumentException]] 'color1' or 'color2' are the empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, color1: string | Color, color2: string | Color): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill2(a: number, b: Color, c: Color): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill1(a: number, b: WorkbookColorInfo, c: WorkbookColorInfo): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill(a: number, ...b: CellFillGradientStop[]): CellFillLinearGradient;
    /**
     * Creates a solid color or pattern fill that can be applied to a cell.
     * <p class="body">
     * 'backgroundColorInfo' and 'patternColorInfo' can be specified as null to use the default colors.
     * </p>
     * @param backgroundColorInfo A [[WorkbookColorInfo]] which describes the background color of the cell, which will only be seen if the
     * 'patternStyle' is not None.
     * @param patternColorInfo A [[WorkbookColorInfo]] which describes the pattern color of the cell, which will only be seen if the
     * 'patternStyle' is not None or Solid.
     * @param patternStyle The fill pattern for the cell.
     * @throws [[InvalidEnumArgumentException]] 'patternStyle' is Default or not defined in the [[FillPatternStyle]] enumeration.
     * @see [[CellFillPattern]]
     */
    static createPatternFill(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle): CellFillPattern;
    /**
     * Creates a solid color or pattern fill that can be applied to a cell.
     * @param backgroundColor The background color of the cell, which will only be seen if the 'patternStyle' is not None.
     * @param patternColor The pattern color of the cell, which will only be seen if the 'patternStyle' is not None or Solid.
     * @param patternStyle The fill pattern for the cell.
     * @throws [[ArgumentException]] 'backgroundColor' or 'patternColor' are the empty color or have a non-opaque alpha channel.
     * @throws [[InvalidEnumArgumentException]] 'patternStyle' is Default or not defined in the [[FillPatternStyle]] enumeration.
     * @see [[CellFillPattern]]
     */
    static createPatternFill(backgroundColor: string | Color, patternColor: string | Color, patternStyle: FillPatternStyle): CellFillPattern;
    /**
     * @hidden
     */
    static _createPatternFill1(a: Color, b: Color, c: FillPatternStyle): CellFillPattern;
    /**
     * @hidden
     */
    static _createPatternFill(a: WorkbookColorInfo, b: WorkbookColorInfo, c: FillPatternStyle): CellFillPattern;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the inner rectangle (cell center) of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param stops Two or more gradient stops which describe the color transitions and their positions within the gradient.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @throws [[ArgumentException]] 'stops' contains less than two gradient stops. There must be at least two stops to define the gradient.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, ...stops: CellFillGradientStop[]): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the inner rectangle of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param color1 The color at the inner rectangle of the gradient.
     * @param color2 The color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @throws [[ArgumentException]] 'color1' or 'color2' are empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, color1: string | Color, color2: string | Color): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * @param color1 The color at the inner rectangle (cell center) of the gradient.
     * @param color2 The color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'color1' or 'color2' are empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(color1: string | Color, color2: string | Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill4(a: Color, b: Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill3(a: number, b: number, c: number, d: number, e: Color, f: Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill(a: WorkbookColorInfo, b: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill2(a: number, b: number, c: number, d: number, e: WorkbookColorInfo, f: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill1(a: number, b: number, c: number, d: number, ...e: CellFillGradientStop[]): CellFillRectangularGradient;
    /**
     * Creates a solid color fill that can be applied to a cell.
     * @param solidColorInfo A [[WorkbookColorInfo]] which describes the solid color of the fill.
     * @see [[CellFillPattern]]
     */
    static createSolidFill(solidColorInfo: WorkbookColorInfo): CellFillPattern;
    /**
     * Creates a solid color fill that can be applied to a cell.
     * @param solidColor The solid color of the fill.
     * @throws [[ArgumentException]] 'solidColor' is the empty color or has a non-opaque alpha channel.
     * @see [[CellFillPattern]]
     */
    static createSolidFill(solidColor: string | Color): CellFillPattern;
    /**
     * @hidden
     */
    static _createSolidFill1(a: Color): CellFillPattern;
    /**
     * @hidden
     */
    static _createSolidFill(a: WorkbookColorInfo): CellFillPattern;
    /**
     * @hidden
     */
    static _q(a: WorkbookColorInfo): {
        p0?: WorkbookColorInfo;
    };
    /**
     * @hidden
     */
    static _p(a: Color): WorkbookColorInfo;
    /**
     * Gets the default cell fill, which is no background color.
     */
    static readonly noColor: CellFill;
}
/**
 * An immutable object which represents a solid or pattern fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillPattern extends CellFill {
    static $t: Type;
    private readonly _v;
    private readonly _w;
    private readonly _t;
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData, isCreatedInternally: boolean);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, doesReverseColorsForSolidFill: boolean, isCreatedInternally: boolean);
    constructor(backgroundColorIndex: number, foregroundColorIndex: number, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[CellFillPattern]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillPattern]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * @hidden
     */
    _y(a: WorksheetCellFormatData): WorkbookColorInfo;
    /**
     * @hidden
     */
    _z(a: boolean): WorkbookColorInfo;
    /**
     * @hidden
     */
    _aa(a: WorksheetCellFormatData): WorkbookColorInfo;
    /**
     * @hidden
     */
    _ab(a: boolean): WorkbookColorInfo;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the background color of the cell, which will only be seen if the
     * [[patternStyle]] is not None.
     */
    readonly backgroundColorInfo: WorkbookColorInfo;
    /**
     * Gets the fill pattern for the cell.
     */
    readonly patternStyle: FillPatternStyle;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the pattern color of the cell, which will only be seen if the
     * [[patternStyle]] is not None or Solid.
     */
    readonly patternColorInfo: WorkbookColorInfo;
}
/**
 * Abstract base class for a gradient fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare abstract class CellFillGradient extends CellFill {
    static $t: Type;
    private readonly _v;
    constructor(a: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    _t(a: Workbook, b: boolean): {
        ret: CellFillGradientStop[];
        p1: boolean;
    };
    /**
     * @hidden
     */
    _w(a: List$1<XFProp>): void;
    /**
     * Gets the read-only collection of gradient stops which describe the color transitions and their positions within the gradient.
     */
    readonly stops: IList$1<CellFillGradientStop>;
}
/**
 * An immutable object which represents a linear gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillLinearGradient extends CellFillGradient {
    static $t: Type;
    private readonly _x;
    constructor(angle: number, ...stops: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillLinearGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillLinearGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * Gets the angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     */
    readonly angle: number;
}
/**
 * An immutable object which represents a rectangular gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillRectangularGradient extends CellFillGradient {
    static $t: Type;
    private readonly _x;
    private readonly _y;
    private readonly _z;
    private readonly _aa;
    constructor(left: number, top: number, right: number, bottom: number, ...stops: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillRectangularGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillRectangularGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets the bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     */
    readonly bottom: number;
    /**
     * Gets the left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     */
    readonly left: number;
    /**
     * Gets the right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     */
    readonly right: number;
    /**
     * Gets the top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     */
    readonly top: number;
}
/**
 * Immutable class which describes a color transition in a cell fill gradient.
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare class CellFillGradientStop extends Base {
    static $t: Type;
    private readonly _b;
    private readonly _e;
    constructor(color: Color, offset: number);
    constructor(colorInfo: WorkbookColorInfo, offset: number);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[CellFillGradientStop]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillGradientStop]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _a(a: Workbook): CellFillGradientStop;
    /**
     * Gets the [[WorkbookColorInfo]] describing the color transition for the gradient stop.
     * @see [[offset]]
     */
    readonly colorInfo: WorkbookColorInfo;
    /**
     * Gets the position in the gradient of the color transition for the gradient stop, ranging from 0.0 to 1.0.
     * <p class="body">
     * When used in a [[CellFillLinearGradient]], a value of 0.0 is at the beginning of the gradient and 1.0 is at the end of the
     * gradient. When used in a [[CellFillRectangularGradient]], a value of 0.0 is at the inner rectangle and 1.0 is at the outer
     * edges of the cell.
     * </p>
     * @see [[colorInfo]]
     */
    readonly offset: number;
}
/**
 * An immutable object which represents a color in a Microsoft Excel workbook.
 * @see [[IWorksheetCellFormat.bottomBorderColorInfo]]
 * @see [[IWorksheetCellFormat.diagonalBorderColorInfo]]
 * @see [[IWorksheetCellFormat.leftBorderColorInfo]]
 * @see [[IWorksheetCellFormat.rightBorderColorInfo]]
 * @see [[IWorksheetCellFormat.topBorderColorInfo]]
 * @see [[IWorkbookFont.colorInfo]]
 * @see [[CellFillPattern.backgroundColorInfo]]
 * @see [[CellFillPattern.patternColorInfo]]
 * @see [[CellFillGradientStop.colorInfo]]
 */
export declare class WorkbookColorInfo extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a;
    private readonly _ag;
    private readonly _i;
    private readonly _v;
    private readonly _w;
    private _j;
    constructor();
    constructor(color: Color);
    constructor(color: Color, tint: number);
    constructor(color: Color, transform: WorkbookColorTransform);
    constructor(themeColorType: WorkbookThemeColorType);
    constructor(themeColorType: WorkbookThemeColorType, tint: number);
    constructor(themeColorType: WorkbookThemeColorType, transform: WorkbookColorTransform);
    constructor(color: Nullable$1<Color>, themeColorType: Nullable$1<WorkbookThemeColorType>, tint: Nullable$1<number>, isLoading: boolean, preventUsingAutomaticColor?: boolean);
    constructor(color: Nullable$1<Color>, themeColorType: Nullable$1<WorkbookThemeColorType>, tint: Nullable$1<number>, transform: WorkbookColorTransform, isLoading: boolean, preventUsingAutomaticColor?: boolean);
    constructor(workbook: Workbook, index: number);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[WorkbookColorInfo]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[WorkbookColorInfo]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the [[WorkbookColorInfo]].
     * @return
     */
    toString(): string;
    /**
     * Gets the actual color which will be seen in Microsoft Excel if the [[WorkbookColorInfo]] is used.
     * @throws [[ArgumentNullException]] The [[themeColorType]] is not null. When the ThemeColorType is set, the [[getResolvedColor]] method must be called with
     * a non-null [[Workbook]].
     * @return A Color which combines the [[color]] and [[tint]] if it is set.
     */
    getResolvedColor(): string;
    /**
     * Gets the actual color which will be seen in Microsoft Excel if the [[WorkbookColorInfo]] is used.
     * @param workbook The workbook in which the WorkbookColorInfo is used.
     * @throws [[ArgumentNullException]] 'workbook' is null and [[themeColorType]] is not null. When the ThemeColorType is set, the method must be called with a
     * non-null [[Workbook]].
     * @return A Color which combines the [[color]], [[themeColorType]], and/or [[tint]], depending on what is set.
     */
    getResolvedColor(workbook: Workbook): string;
    /**
     * @hidden
     */
    _getResolvedColor(): Color;
    /**
     * @hidden
     */
    _getResolvedColor1(a: Workbook): Color;
    /**
     * @hidden
     */
    _aj(a: Workbook, b?: boolean, c?: boolean): Color;
    /**
     * @hidden
     */
    _y(a: Workbook, b: ColorableItem): number;
    /**
     * @hidden
     */
    _o(a: Workbook, b: ColorableItem): boolean;
    /**
     * @hidden
     */
    _g(a: Workbook, b?: boolean): WorkbookColorInfo;
    /**
     * @hidden
     */
    _h(a: WorkbookColorTransform): WorkbookColorInfo;
    /**
     * @hidden
     */
    private static _u;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets the automatic color, which is the window text system color.
     * @see [[isAutomatic]]
     */
    static readonly automatic: WorkbookColorInfo;
    /**
     * Gets the base color associated of the [[WorkbookColorInfo]].
     * @see [[tint]]
     */
    readonly color: string | Color;
    /**
     * @hidden
     */
    readonly _color$i: Nullable$1<Color>;
    /**
     * Gets the value which indicates whether the [[WorkbookColorInfo]] is automatic, or the window text system color.
     */
    readonly isAutomatic: boolean;
    /**
     * Gets the base theme color associated of the [[WorkbookColorInfo]].
     * @see [[tint]]
     */
    readonly themeColorType: WorkbookThemeColorType | null;
    /**
     * @hidden
     */
    readonly _themeColorType$i: Nullable$1<WorkbookThemeColorType>;
    /**
     * Gets the to apply to the base color, from -1.0 (100% darken) to 1.0 (100% lighten).
     * @see [[color]]
     * @see [[themeColorType]]
     */
    readonly tint: number | null;
    /**
     * @hidden
     */
    readonly _tint$i: Nullable$1<number>;
    /**
     * Returns the associated [[WorkbookColorTransform]], or null
     * if this instance is not associated with a transform.
     */
    readonly transform: WorkbookColorTransform;
    /**
     * @hidden
     */
    readonly _n: boolean;
    /**
     * @hidden
     */
    readonly _p: boolean;
    /**
     * @hidden
     */
    static l_op_Equality(a: WorkbookColorInfo, b: WorkbookColorInfo): boolean;
    /**
     * @hidden
     */
    static l_op_Inequality(a: WorkbookColorInfo, b: WorkbookColorInfo): boolean;
    /**
     * @hidden
     */
    static l_op_Implicit_WorkbookColorInfo_Color(color: string | Color): WorkbookColorInfo;
    /**
     * @hidden
     */
    static _l_op_Implicit_WorkbookColorInfo_Color$i(a: Color): WorkbookColorInfo;
    /**
     * @hidden
     */
    static l_op_Implicit_WorkbookColorInfo_WorkbookThemeColorType(themeColorType: WorkbookThemeColorType): WorkbookColorInfo;
}
/**
 * Defines color transforms for a [[WorkbookColorInfo]] instance.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * Color transforms are not applicable to all contexts within which a WorkbookColorInfo is used;
 * currently they are only used by <see cref="WorksheetChart">charts</see>.
 * </p>
 * @see [[ChartSolidFill]]
 * @see [[GradientStop]]
 * @see [[ChartGradientFill]]
 */
export declare class WorkbookColorTransform extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _c;
    constructor(alpha: Nullable$1<number>, luminanceModulation: Nullable$1<number>, luminanceOffset: Nullable$1<number>, shade: Nullable$1<number>);
    /**
     * Defines the value of the alpha channel for the associated
     * [[WorkbookColorInfo]] instance, expressed
     * as a number between 0 and 1.
     * <p class="body">
     * Use this property to control the transparency of the associated color.
     * </p>
     * <p class="body">
     * For example, to make the associated color 50% transparent, assign a value of <b>.5</b> to this property.
     * </p>
     * <p class="body">
     * Assigning a value of null to this property implies that the associated
     * color has no specific alpha channel setting, i.e., the associated color
     * is fully opaque.
     * </p>
     */
    /**
    * Defines the value of the alpha channel for the associated
    * [[WorkbookColorInfo]] instance, expressed
    * as a number between 0 and 1.
    * <p class="body">
    * Use this property to control the transparency of the associated color.
    * </p>
    * <p class="body">
    * For example, to make the associated color 50% transparent, assign a value of <b>.5</b> to this property.
    * </p>
    * <p class="body">
    * Assigning a value of null to this property implies that the associated
    * color has no specific alpha channel setting, i.e., the associated color
    * is fully opaque.
    * </p>
    */
    alpha: number | null;
    private _alpha$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _alpha$i: Nullable$1<number>;
    /**
     * Defines the luminance modulation for the associated
     * [[WorkbookColorInfo]] instance, expressed
     * as a fractional number.
     * <p class="body">
     * Luminance is also referred to as brightness.
     * </p>
     * <p class="body">
     * This property specifies the amount by which the luminance of the associated
     * base color is increased. For example, a value of .5 yields a 50% reduction
     * in luminance. A value of 1.0 implies no change in luminance. A value greater
     * than 1.0 implies an increase in luminance; for example, a value of 2.0 doubles
     * the luminance.
     * </p>
     * <p class="body">
     * Assigning a value of null to this property implies that the associated color has no specific luminance modulation.
     * </p>
     * <p class="body">
     * Luminance modulation is applied by converting the base color from RGB to HSL, then
     * multiplying the luminance channel by the value of this property, then converting
     * back to RGB.
     * </p>
     * @see [[luminanceOffset]]
     */
    /**
    * Defines the luminance modulation for the associated
    * [[WorkbookColorInfo]] instance, expressed
    * as a fractional number.
    * <p class="body">
    * Luminance is also referred to as brightness.
    * </p>
    * <p class="body">
    * This property specifies the amount by which the luminance of the associated
    * base color is increased. For example, a value of .5 yields a 50% reduction
    * in luminance. A value of 1.0 implies no change in luminance. A value greater
    * than 1.0 implies an increase in luminance; for example, a value of 2.0 doubles
    * the luminance.
    * </p>
    * <p class="body">
    * Assigning a value of null to this property implies that the associated color has no specific luminance modulation.
    * </p>
    * <p class="body">
    * Luminance modulation is applied by converting the base color from RGB to HSL, then
    * multiplying the luminance channel by the value of this property, then converting
    * back to RGB.
    * </p>
    * @see [[luminanceOffset]]
    */
    luminanceModulation: number | null;
    private _luminanceModulation$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _luminanceModulation$i: Nullable$1<number>;
    /**
     * Defines the luminance offset for the associated
     * [[WorkbookColorInfo]] instance, expressed
     * as a fractional number.
     * <p class="body">
     * Luminance is also referred to as brightness.
     * </p>
     * <p class="body">
     * The luminance offset is applied by converting the base color from RGB to HSL, then
     * the value of this property to the luminance channel, then converting back to RGB.
     * </p>
     * <p class="body">
     * Assigning a value of null to this property implies that the associated color has no specific luminance offset.
     * </p>
     * @see [[luminanceModulation]]
     */
    /**
    * Defines the luminance offset for the associated
    * [[WorkbookColorInfo]] instance, expressed
    * as a fractional number.
    * <p class="body">
    * Luminance is also referred to as brightness.
    * </p>
    * <p class="body">
    * The luminance offset is applied by converting the base color from RGB to HSL, then
    * the value of this property to the luminance channel, then converting back to RGB.
    * </p>
    * <p class="body">
    * Assigning a value of null to this property implies that the associated color has no specific luminance offset.
    * </p>
    * @see [[luminanceModulation]]
    */
    luminanceOffset: number | null;
    private _luminanceOffset$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _luminanceOffset$i: Nullable$1<number>;
    /**
     * Defines the shading for the associated
     * [[WorkbookColorInfo]] instance, expressed
     * as a fractional number.
     * @see [[alpha]]
     */
    /**
    * Defines the shading for the associated
    * [[WorkbookColorInfo]] instance, expressed
    * as a fractional number.
    * @see [[alpha]]
    */
    shade: number | null;
    private _shade$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _shade$i: Nullable$1<number>;
    /**
     * @hidden
     */
    _b(): boolean;
    /**
     * @hidden
     */
    static _a(a: WorkbookColorTransform, b: WorkbookColorTransform): boolean;
}
/**
 * @hidden
 */
export declare abstract class FormattingRunBase extends Base {
    static $t: Type;
    private b;
    private j;
    constructor(a: IFormattedRunOwner, b: number);
    abstract i: number;
    abstract d(a: Workbook): IWorkbookFont;
    abstract f(a: Workbook): WorkbookFontProxy;
    a(a: Workbook, b: IFormattedRunOwner): FormattingRunBase;
    e(): WorkbookFontProxy;
    g(a: Workbook, b: WorkbookFontProxy): {
        ret: WorkbookFontProxy;
        p1?: WorkbookFontProxy;
    };
    m(a: FormattingRunBase, b: Workbook): void;
    abstract readonly h: boolean;
    k: number;
    readonly c: IFormattedRunOwner;
    protected get_l(): string;
    readonly l: string;
}
/**
 * @hidden
 */
export declare class CellFormattingRunPlaceholder extends FormattingRunBase {
    static $t: Type;
    private n;
    constructor(a: StringElement, b: IWorkbookFont);
    protected get_i(): number;
    protected set_i(a: number): void;
    i: number;
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    protected get_h(): boolean;
    readonly h: boolean;
    m(a: FormattingRunBase, b: Workbook): void;
    protected get_l(): string;
}
/**
 * @hidden
 */
export interface IFormattedRunOwner {
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    readonly startIndex: number;
    readonly unformattedString: string;
}
/**
 * @hidden
 */
export declare let IFormattedRunOwner_$type: Type;
/**
 * @hidden
 */
export declare class CellFormattingRunPlaceholder_RunOwner extends Base implements IFormattedRunOwner {
    static $t: Type;
    private a;
    constructor(a: StringElement);
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    readonly startIndex: number;
    readonly unformattedString: string;
}
/**
 * @hidden
 */
export interface ICellShiftOperationOverride {
    readonly count: number;
    readonly index: number;
    readonly isRemoveOperation: boolean;
    readonly isUndoOperation: boolean;
    readonly performsShift: boolean;
    readonly shiftsColumns: boolean;
    readonly shiftsRows: boolean;
    readonly worksheet: Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare let ICellShiftOperationOverride_$type: Type;
/**
 * @hidden
 */
export declare class CellShiftOperation extends ValueType {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: CellShiftType, d: number, e: number, f: number, g: number, h: number);
    constructor(a: number, b: Worksheet, c: CellShiftType, d: WorksheetTableResizeOperation, e: number, f: number, g: number, h: number, i: number, j: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly j;
    private readonly n;
    private readonly v;
    private readonly a;
    private readonly m;
    private readonly g;
    readonly u: List$1<WorksheetRegion>;
    i(a: WorksheetCellAddress): WorksheetCellAddress;
    private z;
    private ab;
    private aa;
    private ac;
    private ad;
    private ae;
    c(a: WorksheetCellAddress): {
        ret: ShiftAddressResult;
        p0?: WorksheetCellAddress;
    };
    d(a: number, b: number): {
        ret: ShiftAddressResult;
        p0?: number;
        p1?: number;
    };
    e(a: WorksheetRegionAddress, b: boolean): {
        ret: ShiftAddressResult;
        p0?: WorksheetRegionAddress;
    };
    f(a: WorksheetRegionAddress, b: boolean, c: boolean, d: List$1<WorksheetRegionAddress>): {
        ret: ShiftAddressResult;
        p0?: WorksheetRegionAddress;
        p3: List$1<WorksheetRegionAddress>;
    };
    private r;
    af(a: ICellShiftOperationOverride): void;
    s<T>($t: Type, a: ICellShiftOperationOverride, b: List$1<T>, c: T, d: WorksheetRegionAddress): boolean;
    private t;
    readonly x: Nullable$1<WorksheetRegionAddress>;
    readonly y: Nullable$1<WorksheetRegionAddress>;
    readonly o: boolean;
    readonly k: WorksheetRegionAddress;
    readonly l: WorksheetRegionAddress;
    readonly p: boolean;
    readonly q: boolean;
    readonly w: number;
    readonly b: CellShiftType;
    readonly h: Worksheet;
}
/**
 * @hidden
 */
export declare class ShiftAddressResult extends Base {
    static $t: Type;
    static readonly d: ShiftAddressResult;
    static readonly c: ShiftAddressResult;
    private a;
    private e;
    constructor(a: number, b: boolean);
    constructor(a: number, b: boolean, c: CellShiftDeleteReason);
    constructor(a: number, ..._rest: any[]);
    readonly b: CellShiftDeleteReason;
    readonly f: boolean;
    readonly g: boolean;
}
/**
 * @hidden
 */
export declare class SheetChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Sheet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly b;
    readonly sheet: Sheet;
    readonly workbook: Workbook;
    readonly c: Worksheet;
    readonly source: any;
    static a<TSheet extends Sheet, TValue>($tSheet: Type, $tValue: Type, a: string, b: ExcelChangeAction, c: (arg1: TSheet) => TValue, d: (arg1: TSheet, arg2: TValue) => void, e?: (arg1: TSheet, arg2: TValue) => void, f?: boolean, g?: boolean, h?: WorksheetPermissions): ChangeInfo;
}
/**
 * Base class for a sheet in a Microsoft Excel workbook.
 */
export declare abstract class Sheet extends Base implements IWorkbookProvider {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static _a;
    private _k;
    private _ah;
    private _v;
    private _q;
    private _m;
    private readonly _al;
    private _aj;
    /**
     * @hidden
     */
    readonly _h: SheetChangeInfoContext;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    readonly _c: CellReferenceMode;
    /**
     * @hidden
     */
    readonly _y: CultureInfo;
    /**
     * @hidden
     */
    readonly _o: WorkbookFormat;
    /**
     * @hidden
     */
    abstract readonly _e: DisplayOptionsBase;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _r: boolean;
    /**
     * Returns a boolean indicating if the Sheet has been protected with a password.
     * <p class="body">When protecting a Sheet, a password is optional. The HasProtectionPassword will return true if the
     * Sheet is currently protected (see [[isProtected]]) and a password was specified when it was protected.</p>
     * @see [[isProtected]]
     * @see@see [[sheetProtection]]
     * @see [[Worksheet.protect]]
     * @see [[unprotect]]
     */
    readonly hasProtectionPassword: boolean;
    /**
     * @hidden
     */
    readonly _t: boolean;
    /**
     * Returns a boolean indicating if the Worksheet has been protected.
     * <p class="body">The IsProtected property will return true if the Worksheet is currently protected. When a Worksheet is protected
     * only unprotected cells may be edited. In addition, other operations may be limited based on the properties of the
     * [[WorksheetProtection]] which may be accessed using the Protection property.</p>
     * @see [[hasProtectionPassword]]
     * @see [[sheetProtection]]
     * @see [[WorksheetProtection]]
     * @see@see [[Worksheet.protection]]
     * @see [[Chartsheet.protection]]
     * @see [[unprotect]]
     */
    readonly isProtected: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _w: boolean;
    /**
     * Gets or sets the sheet name.
     * <p class="body">The sheet name is case-insensitively unique in the workbook.</p>
     * <p class="body">
     * The sheet name is shown in the tab for the worksheet. In addition, the worksheet name can be used by formulas
     * from other worksheets to refer to cells in this worksheet.
     * </p>
     * The sheet name.
     * @throws [[ArgumentNullException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] The value assigned exceeds 31 characters in length.
     * @throws [[ArgumentException]] The value assigned is being used as the name of another sheet (sheet names are case-insensitively compared).
     */
    /**
    * Gets or sets the sheet name.
    * <p class="body">The sheet name is case-insensitively unique in the workbook.</p>
    * <p class="body">
    * The sheet name is shown in the tab for the worksheet. In addition, the worksheet name can be used by formulas
    * from other worksheets to refer to cells in this worksheet.
    * </p>
    * The sheet name.
    * @throws [[ArgumentNullException]] The value assigned is null or empty.
    * @throws [[ArgumentException]] The value assigned contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
    * @throws [[ArgumentException]] The value assigned exceeds 31 characters in length.
    * @throws [[ArgumentException]] The value assigned is being used as the name of another sheet (sheet names are case-insensitively compared).
    */
    name: string;
    /**
     * @hidden
     */
    private _at;
    /**
     * @hidden
     */
    abstract readonly _g: PrintOptionsBase;
    /**
     * Gets the value which indicates whether this worksheet is selected.
     * <p class="body">
     * If the worksheet has been removed from its parent [[Workbook.worksheets]] collection, this will always return False.
     * </p>
     * The value which indicates whether this worksheet is selected.
     * @see [[WindowOptions]]
     * @see */
    readonly selected: boolean;
    /**
     * @hidden
     */
    abstract readonly _p: WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _am: number;
    /**
     * Gets the zero-based index of this sheet in its parent [[Workbook.sheets]] collection.
     * <p class="body">
     * Negative one indicates the sheet has been removed from its parent collection.
     * </p>
     * The zero-based index of this sheet in its parent Sheets collection.
     * @see [[SheetCollection.indexOf]]
     * @see [[moveToSheetIndex]]
     */
    readonly sheetIndex: number;
    /**
     * @hidden
     */
    abstract readonly _i: SheetProtection;
    /**
     * Gets or sets the [[WorkbookColorInfo]] to use for the associated sheet's tab in the tab bar of Microsoft Excel.
     * <p class="body">
     * If the tab bar is not visible, this color will not be seen.
     * </p>
     * The WorkbookColorInfo to use for the associated sheet's tab in the tab bar of Microsoft Excel.
     * @see [[WindowOptions.tabBarVisible]]
     */
    /**
    * Gets or sets the [[WorkbookColorInfo]] to use for the associated sheet's tab in the tab bar of Microsoft Excel.
    * <p class="body">
    * If the tab bar is not visible, this color will not be seen.
    * </p>
    * The WorkbookColorInfo to use for the associated sheet's tab in the tab bar of Microsoft Excel.
    * @see [[WindowOptions.tabBarVisible]]
    */
    tabColorInfo: WorkbookColorInfo;
    /**
     * Returns a value indicating the type of sheet
     */
    abstract readonly type: SheetType;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ak: string;
    /**
     * Gets the [[workbook]] that owns the worksheet.
     * The Workbook that owns the worksheet.
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    protected get__ag(): number;
    /**
     * @hidden
     */
    readonly _ag: number;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    abstract _f(): PrintOptionsBase;
    /**
     * Moves the sheet to a new position in the owning workbook's collections of sheets.
     * @param index The new 0-based index to where the sheet should be moved.
     * @throws [[InvalidOperationException]] The sheet has previously been removed from its workbook.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of sheets in the owning workbook.
     * @see [[Workbook.sheets]]
     * @see [[SheetCollection.indexOf]]
     * @see [[sheetIndex]]
     */
    moveToSheetIndex(index: number): void;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    _aq(): void;
    /**
     * @hidden
     */
    _ar(): void;
    /**
     * @hidden
     */
    _as(a: WorksheetVisibility, b: WorksheetVisibility): void;
    /**
     * Removes the Sheet protection.
     * @see [[isProtected]]
     * @see [[hasProtectionPassword]]
     * @see [[Worksheet.protect]]
     */
    unprotect(): void;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static _aw(a: string, b: string): void;
    /**
     * @hidden
     */
    _av(a: FormatLimitErrors, b: WorkbookFormat): void;
}
/**
 * @hidden
 */
export interface IWorksheetShapeOwner extends ISheetProvider {
    onChildShapeBoundsChanged(a: WorksheetShape, b: WorksheetCellAddress, c: WorksheetCellAddress, d: boolean): void;
    onShapeAdded(a: WorksheetShape): void;
    onShapeRemoved(a: WorksheetShape): void;
    readonly areChildrenTopMost: boolean;
    readonly ChildShapes: WorksheetShapeCollection;
}
/**
 * @hidden
 */
export declare let IWorksheetShapeOwner_$type: Type;
/**
 * A sheet in a Mirosoft Excel workbook that displays a single chart.
 */
export declare class Chartsheet extends Sheet implements IWorksheetShapeOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static _ax;
    private readonly _a6;
    private _be;
    private _az;
    private _a1;
    private readonly _a3;
    private _ba;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    _f(): PrintOptionsBase;
    /**
     * @hidden
     */
    protected get__e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    readonly _e: DisplayOptionsBase;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__g(): PrintOptionsBase;
    /**
     * @hidden
     */
    readonly _g: PrintOptionsBase;
    /**
     * @hidden
     */
    protected get__p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _p: WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__i(): SheetProtection;
    /**
     * @hidden
     */
    readonly _i: SheetProtection;
    /**
     * Returns Chartsheet
     */
    protected get_type(): SheetType;
    /**
     * Returns Chartsheet
     */
    readonly type: SheetType;
    /**
     * Returns the [[WorksheetChart]] displayed in this chartsheet.
     */
    readonly chart: WorksheetChart;
    /**
     * Gets the object which controls the display of the chartsheet.
     * <p class="body">
     * The display options include any settings which affect the display of the chartsheet when viewed in Microsoft Excel.
     * These settings will not affect the printed chartsheet or the data stored in the chartsheet.
     * </p>
     * The object which controls the display of the chartsheet.
     * @see [[CustomView.getSheetDisplayOptions]]
     */
    readonly displayOptions: ChartsheetDisplayOptions;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bf: WBitmap;
    /**
     * @hidden
     */
    private _bd;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bb: any;
    /**
     * @hidden
     */
    _a7: ImageFormat;
    /**
     * Gets the object which controls how the chartsheet prints.
     * The object which controls how the chartsheet prints.
     * @see [[CustomView.getSheetPrintOptions]]
     */
    readonly printOptions: ChartsheetPrintOptions;
    /**
     * Returns an object that provides information used when the Chartsheet has been protected.
     * @see@see@see [[ChartsheetProtection]]
     * @see [[protect]]
     * @see */
    readonly protection: ChartsheetProtection;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * Protects the chartsheet without a password.
     * <p class="body">When a Chartsheet is protected without a password, the end user may unprotect the Chartsheet in Excel without
     * having to supply a password. To programatically unprotect a Chartsheet, one may use the Unprotect() method.</p>
     * <p class="body">The optional parameters are used to update the property values of the [[ChartsheetProtection]] instance from
     * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
     * be retained; otherwise the property will be updated with the specified value. For example, if the [[ChartsheetProtection.allowEditObjects]]
     * is currently true and the 'allowEditObjects' is null, then the property will continue to be true but if the
     * 'allowEditObjects' is false the [[ChartsheetProtection.allowEditObjects]] will be changed to false.</p>
     * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
     * @param allowEditObjects Optional boolean indicating the new value for the [[ChartsheetProtection.allowEditObjects]].
     * @param allowEditContents Optional boolean indicating the new value for the ChartsheetProtection.AllowEditScenarios.
     * @see@see@see [[protection]]
     * @see [[ChartsheetProtection]]
     * @see */
    protect(allowEditObjects?: boolean, allowEditContents?: boolean): void;
    /**
     * @hidden
     */
    _protect$i(a?: Nullable$1<boolean>, b?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    readonly areChildrenTopMost: boolean;
    /**
     * @hidden
     */
    readonly ChildShapes: WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * @hidden
 */
export interface IChartObject extends ISheetProvider, IWorkbookProvider {
    readonly chart: WorksheetChart;
    onPropertyChanged(): void;
    isReferencingAnythingInRegion(a: Worksheet, b: WorksheetRegionAddress): boolean;
    iterateFormulas(a: (arg1: Sheet, arg2: Formula) => void): void;
    onShiftRegion(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    undoChartShift(a: any): any;
    verifyFormulas(a: Worksheet): void;
}
/**
 * @hidden
 */
export declare let IChartObject_$type: Type;
/**
 * Abstract base class for objects that are exposed off a
 * @see [[WorksheetChart]]
 */
export declare abstract class ChartObject extends Base implements IChartObject, IChangeInfoContext {
    static $t: Type;
    private _c;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _f(a: Workbook, b?: boolean): WorkbookFontProxy;
    /**
     * @hidden
     */
    _l(a: IChartObject): void;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _j(a: ExcelChangeAction): any;
    /**
     * @hidden
     */
    _p(a: any): void;
    /**
     * @hidden
     */
    _q<TContext extends IChangeInfoContext, T>($tContext: Type, $t: Type, a: TContext, b: number, c: T, d: T): {
        p2?: T;
    };
    /**
     * @hidden
     */
    _r<TContext extends IChangeInfoContext, T>($tContext: Type, $t: Type, a: TContext, b: number, c: T, d: T, e?: (arg1: T) => void): {
        p2?: T;
    };
    /**
     * @hidden
     */
    _s(): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    static _v(a: IChartObject, b: IChartObject): void;
    /**
     * Returns the owning chart (read-only)
     * @see [[owner]]
     */
    readonly chart: WorksheetChart;
    /**
     * returns this object's owner. (read-only)
     * The owner or null if this object is owned directly by the Chart
     * @see [[chart]]
     */
    readonly owner: ChartObject;
    /**
     * The owning sheet (read-only)
     */
    readonly sheet: Sheet;
    /**
     * The owning workbook (read-only)
     */
    readonly workbook: Workbook;
    /**
     * The owning worksheet (read-only)
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    readonly _d: IChartObject;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    onPropertyChanged(): void;
    /**
     * @hidden
     */
    isReferencingAnythingInRegion(ws: Worksheet, region: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    iterateFormulas(callback: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    onShiftRegion(callback: (arg1: IChartObject, arg2: any) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoChartShift(context: any): any;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    verifyFormulas(removedWorksheet: Worksheet): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
}
/**
 * Exposes chart-level properties for [[Series]] which appear within a combo chart.
 * @see [[WorksheetChart.comboChartGroups]]
 */
export declare class ComboChartGroup extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ah;
    private _aj;
    private _ak;
    private _al;
    private _am;
    static staticInit(): void;
    constructor(a: ComboChartGroupCollection, b: ChartType, c: AxisGroup, d: boolean);
    /**
     * @hidden
     */
    _ac(a: ComboChartGroupCollection, b: ChartType, c: AxisGroup): ComboChartGroup;
    private _axisGroup;
    /**
     * Returns the [[axisGroup]] value with which this instance was created.
     */
    /**
    * Returns the [[axisGroup]] value with which this instance was created.
    */
    axisGroup: AxisGroup;
    private _chartType;
    /**
     * Returns the [[chartType]] value with which this instance was created.
     */
    /**
    * Returns the [[chartType]] value with which this instance was created.
    */
    chartType: ChartType;
    /**
     * Returns or sets the size of the hole in a doughnut chart,
     * expressed as a percentage of the size of the encompassing circle.
     * <p class="body">
     * This property is only applicable to doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 90, inclusive.
     * </p>
     * @see [[WorksheetChart.doughnutHoleSize]]
     */
    /**
    * Returns or sets the size of the hole in a doughnut chart,
    * expressed as a percentage of the size of the encompassing circle.
    * <p class="body">
    * This property is only applicable to doughnut charts.
    * </p>
    * <p class="body">
    * The valid range for this property is 0 through 90, inclusive.
    * </p>
    * @see [[WorksheetChart.doughnutHoleSize]]
    */
    doughnutHoleSize: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _doughnutHoleSize$i: Nullable$1<number>;
    /**
     * Returns or sets the angle, expressed in degrees which determines the origin
     * of the first slice, as relative to the 12 o'clock position of the emcompassing
     * circle.
     * <p class="body">
     * This property is only applicable to pie and doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between 0 and 360, inclusive.
     * </p>
     * @see [[WorksheetChart.firstSliceAngle]]
     */
    /**
    * Returns or sets the angle, expressed in degrees which determines the origin
    * of the first slice, as relative to the 12 o'clock position of the emcompassing
    * circle.
    * <p class="body">
    * This property is only applicable to pie and doughnut charts.
    * </p>
    * <p class="body">
    * The valid range for this property is between 0 and 360, inclusive.
    * </p>
    * @see [[WorksheetChart.firstSliceAngle]]
    */
    firstSliceAngle: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _firstSliceAngle$i: Nullable$1<number>;
    /**
     * Specifies the width of the gap between bars.
     * Applicable only for bar/column charts.
     * <p class="body">
     * This property is only applicable for bar charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between 0 and 500, inclusive.
     * </p>
     * @see [[WorksheetChart.gapWidth]]
     */
    /**
    * Specifies the width of the gap between bars.
    * Applicable only for bar/column charts.
    * <p class="body">
    * This property is only applicable for bar charts.
    * </p>
    * <p class="body">
    * The valid range for this property is between 0 and 500, inclusive.
    * </p>
    * @see [[WorksheetChart.gapWidth]]
    */
    gapWidth: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _gapWidth$i: Nullable$1<number>;
    /**
     * Determines the amount by which intersecting [[Series]] overlap,
     * expressed as a percentage of the bar size.
     * <p class="body">
     * This property is only applicable for bar charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between -100 and 100, inclusive.
     * </p>
     * @see [[WorksheetChart.seriesOverlap]]
     */
    /**
    * Determines the amount by which intersecting [[Series]] overlap,
    * expressed as a percentage of the bar size.
    * <p class="body">
    * This property is only applicable for bar charts.
    * </p>
    * <p class="body">
    * The valid range for this property is between -100 and 100, inclusive.
    * </p>
    * @see [[WorksheetChart.seriesOverlap]]
    */
    seriesOverlap: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _seriesOverlap$i: Nullable$1<number>;
    /**
     * @hidden
     */
    static _ar(a: ChartType, b: AxisGroup): string;
    /**
     * @hidden
     */
    static _as(a: ChartType, b: AxisGroup, c: SeriesChartTypeGroup): {
        ret: string;
        p2: SeriesChartTypeGroup;
    };
    /**
     * @hidden
     */
    static _at(a: SeriesChartTypeGroup, b: AxisGroup): string;
    /**
     * @hidden
     */
    static _ad(a: ChartType): SeriesChartTypeGroup;
    /**
     * @hidden
     */
    static _y(a: SeriesChartTypeGroup): ChartType[];
    /**
     * @hidden
     */
    static _au(a: ChartType): void;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class ComboChartGroupValidator extends Base {
    static $t: Type;
    static r(a: ChartType): boolean;
    static s(a: SeriesChartTypeGroup): boolean;
    static p(a: ChartType): boolean;
    static q(a: SeriesChartTypeGroup): boolean;
    static n(a: ChartType): boolean;
    static o(a: SeriesChartTypeGroup): boolean;
    static l(a: ChartType): boolean;
    static m(a: SeriesChartTypeGroup): boolean;
    static x(a: ChartType): boolean;
    static y(a: SeriesChartTypeGroup): boolean;
    static v(a: ChartType): boolean;
    static w(a: SeriesChartTypeGroup): boolean;
    static t(a: ChartType): boolean;
    static u(a: SeriesChartTypeGroup): boolean;
    static h(a: ChartType): StackedType;
    static i(a: SeriesChartTypeGroup): StackedType;
    static b(a: ChartType, b: StackedType): ChartType;
    private static g;
    private static f;
    static j(a: ChartType, b: ChartType, c?: boolean): boolean;
    static k(a: SeriesChartTypeGroup, b: SeriesChartTypeGroup): boolean;
    static aa(a: Series, b: ChartType, c: AxisGroup, d: SeriesCollection): List$1<Series>;
    static d(a: ChartType[], b?: boolean): ComboChartGroupValidationResult;
    private static e;
    static z(a: ChartType[], b: ChartType[]): {
        ret: boolean;
        p1: ChartType[];
    };
    static ac(a: SeriesCollection, b: ChartType[], c: AxisGroup[]): {
        p1?: ChartType[];
        p2?: AxisGroup[];
    };
    static c(a: Series, b: SeriesCollection, c: ChartType, d: AxisGroup): ChartTypeValidationResult;
    static a(a: Series, b: SeriesCollection, c: AxisGroup): AxisGroupValidationResult;
}
/**
 * @hidden
 */
export declare class AxisGroupValidationResult extends Base {
    static $t: Type;
    c: Nullable$1<ChartType>;
    b: BaseError;
    readonly a: boolean;
}
/**
 * @hidden
 */
export declare class ChartTypeValidationResult extends Base {
    static $t: Type;
    d: Nullable$1<AxisGroup>;
    c: BaseError;
    readonly a: boolean;
    b: List$1<Series>;
}
/**
 * @hidden
 */
export declare class ComboChartGroupValidationResult extends Base {
    static $t: Type;
    constructor();
    e: List$1<SeriesAxisGroup>;
    readonly d: boolean;
    c: ChartType[];
    private a;
    b(a: ChartType[]): AxisGroup[];
}
/**
 * @hidden
 */
export declare class SeriesAxisGroup extends Base implements IEnumerable$1<ChartType> {
    static $t: Type;
    constructor();
    _a(a: ChartType): boolean;
    private _b;
    toString(): string;
    getEnumerator(): IEnumerator$1<ChartType>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class ComboChartGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ComboChartGroupCollection, c: ComboChartGroup);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: ComboChartGroupCollection;
    readonly a: ComboChartGroup;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[ComboChartGroup]] objects for a [[WorksheetChart]]
 * <p class="body">
 * This collection is used to apply chart-specific properties to [[Series]] which
 * appear within a combo chart.
 * </p>
 * @see [[ComboChartGroup]]
 * @see [[WorksheetChart.comboChartGroups]]
 */
export declare class ComboChartGroupCollection extends ChartObject implements IEnumerable$1<ComboChartGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static _w;
    private _af;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Returns the [[ComboChartGroup]] instance associated with the specified
     * 'chartType' and 'axisGroup', or null if no such
     * instance exists.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     */
    item(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _item1(a: string): ComboChartGroup;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    readonly isReadOnly: boolean;
    /**
     * Creates a new [[ComboChartGroup]], or returns an existing one,
     * which matches the specified 'chartType' and 'axisGroup'.
     * <p class="body">
     * This method returns an object which provides a way to set chart-specific
     * properties for a [[Series]] that is displayed within a combo chart.
     * </p>
     * <p class="body">
     * For example, to change the [[WorksheetChart.gapWidth]] property for
     * each series associated with a bar chart contained within a combo chart, set the
     * [[ComboChartGroup.gapWidth]] property of the instance returned from
     * this method.
     * </p>
     * <p class="body">
     * If a [[ComboChartGroup]] instance corresponding to the specified
     * 'chartType' and 'axisGroup' already exists,
     * that instance is returned; otherwise a new instance is created and that instance
     * is returned.
     * </p>
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     * @see [[ComboChartGroup]]
     * @see [[remove]]
     * @throws [[NotSupportedException]] The specified 'chartType' is not supported within a combo chart.
     * See documentation for the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
     * method for a list of supported chart types.
     */
    add(chartType: ChartType, axisGroup: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    private _al;
    /**
     * Clears the collection.
     */
    clear(): void;
    [Symbol.iterator](): EnumeratorWrapper<ComboChartGroup>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<ComboChartGroup>;
    /**
     * Removes the specified [[ComboChartGroup]] from this collection.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return True if the item was removed, otherwise false.
     */
    remove(chartType: ChartType, axisGroup: AxisGroup): boolean;
    /**
     * Removes the specified [[ComboChartGroup]] from this collection.
     * @param comboChartGroup The [[ComboChartGroup]] instance to be removed.
     * @return True if the item was removed, otherwise false.
     */
    remove(comboChartGroup: ComboChartGroup): boolean;
    /**
     * @hidden
     */
    _remove1(a: ComboChartGroup): boolean;
    /**
     * @hidden
     */
    _remove(a: ChartType, b: AxisGroup): boolean;
    /**
     * @hidden
     */
    _am(a: ComboChartGroup): void;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    private static _ao;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Abstract base class for the fill of a shape.
 * @see [[WorksheetShape.fill]]
 * @see [[ShapeFillSolid]]
 */
export declare abstract class ShapeFill extends Base {
    static $t: Type;
    /**
     * Creates an instance to describe a solid fill outline.
     * @param solidColor The color of the fill to create.
     * @return A [[ShapeFillSolid]] instance with the specified color.
     */
    static fromColor(solidColor: string | Color): ShapeFill;
    /**
     * @hidden
     */
    static _fromColor$i(a: Color): ShapeFill;
    /**
     * Creates an instance to describe a solid fill outline.
     * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the fill to create.
     * @return A [[ShapeFillSolid]] instance with the specified color.
     */
    static fromColorInfo(solidColorInfo: WorkbookColorInfo): ShapeFill;
    /**
     * @hidden
     */
    abstract _d(a: WorksheetShape): void;
    /**
     * @hidden
     */
    abstract _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
}
/**
 * Abstract base class for the outline of a shape.
 * @see [[WorksheetShape.outline]]
 * @see [[ShapeOutlineSolid]]
 */
export declare abstract class ShapeOutline extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    abstract _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * Creates an instance to describe a solid color outline.
     * @param solidColor The color of the outline to create.
     * @return A [[ShapeOutlineSolid]] instance with the specified color.
     */
    static fromColor(solidColor: string | Color): ShapeOutline;
    /**
     * @hidden
     */
    static _fromColor$i(a: Color): ShapeOutline;
    /**
     * Creates an instance to describe a solid color outline.
     * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the outline to create.
     * @return A [[ShapeOutlineSolid]] instance with the specified color.
     */
    static fromColorInfo(solidColorInfo: WorkbookColorInfo): ShapeOutline;
    /**
     * @hidden
     */
    static _g(a: WorksheetShape): number;
    /**
     * @hidden
     */
    abstract _h(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _e: any;
    /**
     * @hidden
     */
    _f: any;
    /**
     * @hidden
     */
    _d: number;
}
/**
 * Abstract base class for all shapes (atomic or compound) in a worksheet.
 * <p class="body">
 * Atomic shapes are singular shape entities, such as an image, a polygon, or text.
 * Compound shapes are groupings of shapes, and are represented by [[WorksheetShapeGroup]]
 * instances.
 * </p>
 * <p class="body">
 * Currently, not all shape information is customizable (such as shape rotation).  However,
 * for round-tripping purposes, when a shape is loaded from an Excel file, this
 * information in maintained with the shape.  See [[clearUnknownData]] for more
 * information about unsupported data.
 * </p>
 */
export declare abstract class WorksheetShape extends Base implements IRegionAddress, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    static readonly _cf: number;
    /**
     * @hidden
     */
    static readonly _cg: number;
    /**
     * @hidden
     */
    static readonly _ch: number;
    /**
     * @hidden
     */
    static readonly _ci: number;
    /**
     * @hidden
     */
    static readonly _ck: number;
    /**
     * @hidden
     */
    static readonly _cj: number;
    /**
     * @hidden
     */
    static readonly _cl: number;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    private static _bf;
    /**
     * @hidden
     */
    private static _bg;
    private _an;
    private _u;
    private _ac;
    private _di;
    private _dp;
    private _o;
    private _w;
    private _ag;
    private _ai;
    private _ae;
    private _dk;
    private _b2;
    private _bd;
    private _bh;
    private _bj;
    private _bl;
    private _g;
    private _b5;
    private _cb;
    private _cd;
    private _e;
    private _cm;
    private _at;
    private _av;
    private _i;
    private _l;
    private _ba;
    static staticInit(): void;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * Clears the cached unknown shape data which was read in from a parsed excel file.
     * <p class="body">
     * This method will only be needed until all shape information is supported and customizable.
     * After all shape data can be controlled, this method will become obsolete. Currently, all
     * unsupported data will be stored with the shape for round-tripping purposes.  For example,
     * if an Excel file with complex and unsupported shapes is loaded into a
     * [[Workbook]] instance, some cell values are changed, and it is saved to
     * the same file, the complex shapes will still exist in the workbook.  However, if a
     * loaded shape needs to be modified before it is saved back, this method
     * allows for that unsupported data to be removed while all supported data is maintained.
     * </p>
     * <p class="note">
     * <B>Note:</B> This method only clears unsupported data.  In future versions of the product,
     * as more shape data is supported, this method will have different effects on the shape,
     * until eventually all data is supported and this method will have no effect on the shape.
     * </p>
     * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
     */
    clearUnknownData(): void;
    /**
     * Creates a shape which is predefined in Microsoft Excel.
     * @param shapeType The type of shape to create.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    static createPredefinedShape(shapeType: PredefinedShapeType): WorksheetShape;
    /**
     * @hidden
     */
    static _al(a: PredefinedShapeType, b: boolean): WorksheetShape;
    /**
     * Gets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before or within the shape are resized, these bounds will no longer reflect the
     * position of the shape.
     * </p>
     * @throws [[InvalidOperationException]] The [[topLeftCornerCell]] or [[bottomRightCornerCell]] are null, in which case the shape has no bounds.
     * @return The bounds of the shape on its worksheet.
     * @see [[setBoundsInTwips]]
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before or within the shape are resized, these bounds will no longer reflect the
     * position of the shape.
     * </p>
     * @param options The options to use when getting the bounds of the shape.
     * @throws [[InvalidOperationException]] The [[topLeftCornerCell]] or [[bottomRightCornerCell]] are null, in which case the shape has no bounds.
     * @return The bounds of the shape on its worksheet.
     * @see [[setBoundsInTwips]]
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * Sets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The shape will only be positioned at the specified bounds while the worksheet remains in the current configuration.
     * Depending on the [[positioningMode]] of the shape, it may change bounds if any rows or columns before or within the shape are resized.
     * </p>
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @param sheet The worksheet on which the shape should be placed.
     * @param bounds The new bounds where the shape should be placed.
     */
    setBoundsInTwips(sheet: Sheet, bounds: IgRect): void;
    /**
     * Sets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The shape will only be positioned at the specified bounds while the worksheet remains in the current configuration.
     * Depending on the [[positioningMode]] of the shape, it may change bounds if any rows or columns before or within the shape are resized.
     * </p>
     * @throws [[ArgumentNullException]] s
     *
     * 'sheet' is null.
     * @param sheet The sheet on which the shape should be placed.
     * @param bounds The new bounds where the shape should be placed.
     * @param options The options to use when setting the bounds of the shape.
     */
    setBoundsInTwips(sheet: Sheet, bounds: IgRect, options: PositioningOptions): void;
    /**
     * @hidden
     */
    _setBoundsInTwips(a: Sheet, b: Rect): void;
    /**
     * @hidden
     */
    _setBoundsInTwips1(a: Sheet, b: Rect, c: PositioningOptions): void;
    /**
     * @hidden
     */
    private static _c9;
    /**
     * @hidden
     */
    private _c8;
    /**
     * @hidden
     */
    _dd(a: WorksheetShapePosition): void;
    /**
     * @hidden
     */
    abstract _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    static _by(a: ShapeType): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    static _bz(a: ST_ShapeType): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    static _ds(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point): Rect;
    /**
     * @hidden
     */
    static _dt(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: PositioningOptions): Rect;
    /**
     * @hidden
     */
    static _du(a: Sheet, b: number, c: number, d: Point, e: number, f: number, g: Point, h: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _cr(): void;
    /**
     * @hidden
     */
    _cs(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cu(a: WorksheetElementResizeContext): void;
    /**
     * @hidden
     */
    _a9(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _cv(): void;
    /**
     * @hidden
     */
    _cw(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: boolean): void;
    /**
     * @hidden
     */
    _cy(): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _c2(a: WorkbookColorInfo, b: PropertyType, c: PropertyType): void;
    /**
     * @hidden
     */
    _c3(): void;
    /**
     * @hidden
     */
    _c4(a: WorksheetCell, b: WorksheetCellAddress, c: WorksheetCellAddress): void;
    /**
     * @hidden
     */
    _c5(a: Worksheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f?: boolean): void;
    /**
     * @hidden
     */
    _da(a: ShapePositioningMode, b: boolean): void;
    /**
     * @hidden
     */
    _r(a: CellShiftOperation, b: boolean, c: WorksheetRegionAddress): {
        ret: ShiftAddressResult;
        p2?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _s(a: CellShiftOperation, b: ICellShiftOperationOverride, c: Dictionary$2<WorksheetShape, Rect>): ShiftAddressResult;
    /**
     * @hidden
     */
    _t(a: CellShiftOperation, b: Rect, c: boolean, d: WorksheetCellAddress, e: Point, f: WorksheetCellAddress, g: Point): {
        ret: ShiftAddressResult;
        p3: WorksheetCellAddress;
        p4: Point;
        p5: WorksheetCellAddress;
        p6: Point;
    };
    /**
     * @hidden
     */
    private static _db;
    /**
     * @hidden
     */
    _dc(): void;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    _dh(a: ShapePositioningMode): void;
    /**
     * @hidden
     */
    private static _co;
    /**
     * @hidden
     */
    private _dm;
    /**
     * @hidden
     */
    private _bn;
    /**
     * @hidden
     */
    private _dn;
    /**
     * @hidden
     */
    private _cp;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _cx;
    /**
     * @hidden
     */
    static _c1(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    _de(a: (arg1: WorksheetShape) => Rect): void;
    /**
     * @hidden
     */
    private _df;
    /**
     * @hidden
     */
    private _a6;
    /**
     * Gets or sets the fill to use in the background of the shape.
     * <p class="note">
     * <b>Note:</b> some shapes, such as connectors or groups, cannot have a fill set. For these shapes, the value on this property
     * will be ignored and lost when the workbook is saved.
     * </p>
     * A [[ShapeFill]]-derived instance describing the fill of the shape, or null for no fill.
     * @see [[ShapeFill.fromColor]]
     * @see [[ShapeFillSolid]]
     * @see [[outline]]
     */
    /**
    * Gets or sets the fill to use in the background of the shape.
    * <p class="note">
    * <b>Note:</b> some shapes, such as connectors or groups, cannot have a fill set. For these shapes, the value on this property
    * will be ignored and lost when the workbook is saved.
    * </p>
    * A [[ShapeFill]]-derived instance describing the fill of the shape, or null for no fill.
    * @see [[ShapeFill.fromColor]]
    * @see [[ShapeFillSolid]]
    * @see [[outline]]
    */
    fill: ShapeFill;
    /**
     * @hidden
     */
    readonly _k: ShapeFill;
    /**
     * Gets or sets the cell where the bottom-right corner of the shape resides.
     * <p class="body">
     * This anchor cell, along with the [[topLeftCornerCell]], determines where the shape will be
     * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
     * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
     * </p>
     * The cell where the bottom-right corner of the shape resides.
     * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
     * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerCell]]
     * @see [[topLeftCornerPosition]]
     */
    /**
    * Gets or sets the cell where the bottom-right corner of the shape resides.
    * <p class="body">
    * This anchor cell, along with the [[topLeftCornerCell]], determines where the shape will be
    * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
    * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
    * </p>
    * The cell where the bottom-right corner of the shape resides.
    * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
    * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
    * @see [[bottomRightCornerPosition]]
    * @see [[topLeftCornerCell]]
    * @see [[topLeftCornerPosition]]
    */
    bottomRightCornerCell: WorksheetCell;
    /**
     * Gets or sets the position in the [[bottomRightCornerCell]] of the shape's bottom-right corner,
     * expressed in percentages.
     * <p class="body">
     * These percentages are expressed as distance across the associated dimension of the cell, starting at the
     * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
     * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
     * in the cell which is centered horizontally, and a tenth of the way down from the top.
     * </p>
     * The position in the bottom-right corner cell of the shape's bottom-right corner.
     * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
     * @see [[bottomRightCornerCell]]
     * @see [[topLeftCornerCell]]
     * @see [[topLeftCornerPosition]]
     */
    /**
    * Gets or sets the position in the [[bottomRightCornerCell]] of the shape's bottom-right corner,
    * expressed in percentages.
    * <p class="body">
    * These percentages are expressed as distance across the associated dimension of the cell, starting at the
    * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
    * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
    * in the cell which is centered horizontally, and a tenth of the way down from the top.
    * </p>
    * The position in the bottom-right corner cell of the shape's bottom-right corner.
    * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
    * @see [[bottomRightCornerCell]]
    * @see [[topLeftCornerCell]]
    * @see [[topLeftCornerPosition]]
    */
    bottomRightCornerPosition: IgPoint;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bottomRightCornerPosition$i: Point;
    /**
     * Gets or sets the value which indicates whether the shape is flipped horizontally along the vertical center line.
     * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
     */
    /**
    * Gets or sets the value which indicates whether the shape is flipped horizontally along the vertical center line.
    * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
    */
    flippedHorizontally: boolean;
    /**
     * Gets or sets the value which indicates whether the shape is flipped vertically along the horizontal center line.
     * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
     */
    /**
    * Gets or sets the value which indicates whether the shape is flipped vertically along the horizontal center line.
    * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
    */
    flippedVertically: boolean;
    /**
     * Gets or sets the outline to use for the shape.
     * <p class="note">
     * <b>Note:</b> some shapes, such as comments or groups, cannot have a outline set. For these shapes, the value on this property
     * will be ignored and lost when the workbook is saved.
     * </p>
     * A [[ShapeOutline]]-derived instance describing the outline of the shape, or null for no outline.
     * @see [[ShapeOutline.fromColorInfo]]
     * @see [[ShapeOutlineSolid]]
     * @see [[fill]]
     */
    /**
    * Gets or sets the outline to use for the shape.
    * <p class="note">
    * <b>Note:</b> some shapes, such as comments or groups, cannot have a outline set. For these shapes, the value on this property
    * will be ignored and lost when the workbook is saved.
    * </p>
    * A [[ShapeOutline]]-derived instance describing the outline of the shape, or null for no outline.
    * @see [[ShapeOutline.fromColorInfo]]
    * @see [[ShapeOutlineSolid]]
    * @see [[fill]]
    */
    outline: ShapeOutline;
    /**
     * @hidden
     */
    readonly _n: ShapeOutline;
    /**
     * Gets or sets the way shapes will be repositioned in excel when cells before or within the shape are resized.
     * <p class="body">
     * This value will not be saved for shapes contained in a [[WorksheetShapeGroup]], which inherit their
     * positioning mode from their parent group.
     * </p>
     * The way shapes will be repositioned in excel when cells before or within the shape are resized.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[ShapePositioningMode]] enumeration.
     */
    /**
    * Gets or sets the way shapes will be repositioned in excel when cells before or within the shape are resized.
    * <p class="body">
    * This value will not be saved for shapes contained in a [[WorksheetShapeGroup]], which inherit their
    * positioning mode from their parent group.
    * </p>
    * The way shapes will be repositioned in excel when cells before or within the shape are resized.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[ShapePositioningMode]] enumeration.
    */
    positioningMode: ShapePositioningMode;
    /**
     * @hidden
     */
    readonly _q: ShapePositioningMode;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b6: number;
    /**
     * Gets or sets the cell where the top-left corner of the shape resides.
     * <p class="body">
     * This anchor cell, along with the [[bottomRightCornerCell]], determines where the shape will be
     * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
     * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
     * </p>
     * The cell where the top-left corner of the shape resides.
     * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
     * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
     * @see [[bottomRightCornerCell]]
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerPosition]]
     */
    /**
    * Gets or sets the cell where the top-left corner of the shape resides.
    * <p class="body">
    * This anchor cell, along with the [[bottomRightCornerCell]], determines where the shape will be
    * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
    * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
    * </p>
    * The cell where the top-left corner of the shape resides.
    * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
    * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
    * @see [[bottomRightCornerCell]]
    * @see [[bottomRightCornerPosition]]
    * @see [[topLeftCornerPosition]]
    */
    topLeftCornerCell: WorksheetCell;
    /**
     * Gets or sets the position in the [[topLeftCornerCell]] of the shape's top-left corner,
     * expressed in percentages.
     * <p class="body">
     * These percentages are expressed as distance across the associated dimension of the cell, starting at the
     * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
     * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
     * in the cell which is centered horizontally, and a tenth of the way down from the top.
     * </p>
     * The position in the top-left corner cell of the shape's top-left corner.
     * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
     * @see [[bottomRightCornerCell]]
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerCell]]
     */
    /**
    * Gets or sets the position in the [[topLeftCornerCell]] of the shape's top-left corner,
    * expressed in percentages.
    * <p class="body">
    * These percentages are expressed as distance across the associated dimension of the cell, starting at the
    * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
    * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
    * in the cell which is centered horizontally, and a tenth of the way down from the top.
    * </p>
    * The position in the top-left corner cell of the shape's top-left corner.
    * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
    * @see [[bottomRightCornerCell]]
    * @see [[bottomRightCornerPosition]]
    * @see [[topLeftCornerCell]]
    */
    topLeftCornerPosition: IgPoint;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _topLeftCornerPosition$i: Point;
    /**
     * Gets or sets the value indicating whether the shape is visible on the worksheet.
     * The value indicating whether the shape is visible on the worksheet.
     */
    /**
    * Gets or sets the value indicating whether the shape is visible on the worksheet.
    * The value indicating whether the shape is visible on the worksheet.
    */
    visible: boolean;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    readonly sheet: Sheet;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _ad: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _af: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _v: Worksheet;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _f: ICalloutRule;
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * @hidden
     */
    readonly _aq: boolean;
    /**
     * @hidden
     */
    protected get__ar(): boolean;
    /**
     * @hidden
     */
    readonly _ar: boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    readonly _as: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bi: List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    readonly _a1: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bk: List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    readonly _a2: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bm: List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    readonly _a3: boolean;
    /**
     * @hidden
     */
    readonly _ao: WorksheetShapeCollection;
    /**
     * @hidden
     */
    _b3: any;
    /**
     * @hidden
     */
    _ax: boolean;
    /**
     * @hidden
     */
    _ay: boolean;
    /**
     * @hidden
     */
    _aa: WorksheetCell;
    /**
     * @hidden
     */
    _az: boolean;
    /**
     * @hidden
     */
    _a0: boolean;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    readonly _a4: boolean;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    readonly _a5: boolean;
    /**
     * @hidden
     */
    readonly _a7: boolean;
    /**
     * @hidden
     */
    protected get__a8(): boolean;
    /**
     * @hidden
     */
    readonly _a8: boolean;
    /**
     * @hidden
     */
    _b7: string;
    /**
     * @hidden
     */
    _b8: string;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _h: Obj;
    /**
     * @hidden
     */
    readonly _d: IWorksheetShapeOwner;
    /**
     * @hidden
     */
    readonly _bb: boolean;
    /**
     * @hidden
     */
    protected get__cn(): number;
    /**
     * @hidden
     */
    protected set__cn(a: number): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cn: number;
    /**
     * @hidden
     */
    protected get__ap(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _ap: WorksheetShapeCollection;
    /**
     * @hidden
     */
    _b4: any;
    /**
     * @hidden
     */
    _b9: string;
    /**
     * @hidden
     */
    _ca: string;
    /**
     * @hidden
     */
    readonly _ah: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _aj: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _x: Worksheet;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cc: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ce: number;
    /**
     * @hidden
     */
    abstract readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    abstract readonly _b1: Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bc: boolean;
    /**
     * @hidden
     */
    containsColumns(firstColumn: number, lastColumn: number): boolean;
    /**
     * @hidden
     */
    intersectsWithColumns(firstColumn: number, lastColumn: number): boolean;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export declare abstract class WorksheetShapeGroupBase extends WorksheetShape implements IWorksheetShapeOwner {
    static $t: Type;
    private _dw;
    private _dy;
    private _d1;
    private _d0;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__ar(): boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cv(): void;
    /**
     * @hidden
     */
    _cw(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: boolean): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    protected get__ap(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly areChildrenTopMost: boolean;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    _dv(a: number, b: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p1: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    _d2(a: List$1<IEscherRecord>): void;
    /**
     * @hidden
     */
    _d3(): void;
    /**
     * @hidden
     */
    private _d4;
    /**
     * @hidden
     */
    private static _d5;
    /**
     * @hidden
     */
    private static _d6;
    /**
     * @hidden
     */
    private static _d7;
    /**
     * @hidden
     */
    private static _d8;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    shapes(index: number): WorksheetShape;
    /**
     * Gets the collection of shapes contained in the group.
     * The collection of shapes contained in the group.
     */
    shapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _shapes$i: WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly ChildShapes: WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _dz: boolean;
}
/**
 * @hidden
 */
export interface IFormattedStringOwner extends ISheetProvider {
    onUnformattedStringChanged(a: FormattedString): void;
    onFormattingChanged(): void;
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    readonly allowDefaultValues: boolean;
    getDefaultFont(): IWorkbookFont;
}
/**
 * @hidden
 */
export declare let IFormattedStringOwner_$type: Type;
/**
 * Base class for objects which relate to the background fill of a chart element.
 */
export declare abstract class ChartFillBase extends ChartObject {
    static $t: Type;
    constructor(a: IChartObject);
}
/**
 * Represents a <see cref="ChartBorder">border</see> or
 * <see cref="ChartTickLines">tick line</see>.
 */
export declare class ChartLineBase extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ag: number;
    /**
     * @hidden
     */
    static readonly _ad: number;
    /**
     * @hidden
     */
    private static _w;
    private _aa;
    private _ac;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill color/gradient for the line.
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill color/gradient for the line.
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fill: ChartFillBase;
    /**
     * Determines the width of the line, expressed in points.
     * <p class="body">
     * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
     * </p>
     */
    /**
    * Determines the width of the line, expressed in points.
    * <p class="body">
    * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
    * </p>
    */
    widthInPoints: number;
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    readonly _ai: Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _aj(a: number): void;
}
/**
 * Represents the border of a chart element.
 * <p class="body">
 * The color of the border is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the border lines are controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export declare class ChartBorder extends ChartLineBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ar;
    private _an;
    static staticInit(): void;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * Returns or sets the line style for the border, i.e.,
     * solid, dashed, dotted, etc.
     */
    /**
    * Returns or sets the line style for the border, i.e.,
    * solid, dashed, dotted, etc.
    */
    lineStyle: BorderLineStyle;
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    readonly _ap: ChartFillBase;
    /**
     * @hidden
     */
    private static _ak;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _am;
    /**
     * @hidden
     */
    private static _al;
}
/**
 * @hidden
 */
export declare class Formula_TokensReplacedChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Formula, c: FormulaToken[], d: number[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly b;
    private readonly a;
    private readonly d;
    e(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a formula for a cell or group of cells.
 * <p class="body">
 * Formulas provide a way to show dynamic values in a cell. The value could be based any number of factors, such as
 * the values of other cells and the time of day.  Those alternate cells can even exist in different workbook files
 * on the user's machine or on the internet.
 * </p>
 * <p class="body">
 * See Microsoft Excel help for more information on formulas.
 * </p>
 * <p class="body">
 * Use one of the Parse or TryParse overloads to create a new formula.
 * </p>
 */
export declare abstract class Formula extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _be: number;
    /**
     * @hidden
     */
    static readonly _bd: number;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static _a;
    private _a8;
    private _q;
    private _a9;
    /**
     * @hidden
     */
    _d: FormulaToken[];
    private _r;
    static staticInit(): void;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, b: WorksheetDataTable);
    constructor(a: number, b: Formula, c?: boolean);
    constructor(a: number, ..._rest: any[]);
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * This uses the [[CellReferenceMode]] with which the formula was created to create cell
     * reference strings.
     * @return The string representing the formula.
     */
    toString(): string;
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * @param cellReferenceMode The cell reference mode used to create cell reference strings.
     * @return The string representing the formula.
     */
    toString(cellReferenceMode: CellReferenceMode): string;
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * @param cellReferenceMode The cell reference mode used to create cell reference strings.
     * @param culture The culture used to generate the formula string.
     * @return The string representing the formula.
     */
    toString(cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * Applies the formula to all specified regions of cells.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of all cells in all specified regions will
     * return the formula.
     * </p>
     * @param regions The regions of cells to apply the formula to.
     * @throws [[ArgumentNullException]] 'regions' is null.
     * @throws [[ArgumentException]] 'regions' has a length of 0.
     * @throws [[ArgumentException]] Not all regions specified are from the same worksheet.
     * @throws [[InvalidOperationException]] One or more regions specified contain array formulas or data tables which extend outside the region.
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     */
    applyTo(regions: WorksheetRegion[]): void;
    /**
     * Applies the formula to the specified cell.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of the specified cell will return the formula.
     * </p>
     * @param cell The cell to apply the formula to.
     * @throws [[ArgumentNullException]] 'cell' is null.
     * @throws [[InvalidOperationException]] 'cell' is part of an array formula or data table which is not confined to just the cell.
     * @see [[WorksheetCell.value]]
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     */
    applyTo(cell: WorksheetCell): void;
    /**
     * Applies the formula to the specified region of cells.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of all cells in the specified region will
     * return the formula.
     * </p>
     * @param region The region of cells to apply the formula to.
     * @throws [[ArgumentNullException]] 'region' is null.
     * @throws [[InvalidOperationException]] 'region' contains an array formula or data table which extends outside the region.
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     */
    applyTo(region: WorksheetRegion): void;
    /**
     * @hidden
     */
    _applyTo2(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _bp(a: WorksheetRow, b: number, c?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _applyTo3(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _applyTo(a: WorksheetRegion[]): void;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: CultureInfo): string;
    /**
     * @hidden
     */
    _bq(a: WorksheetRow, b: number, c: WorksheetRow, d: number, e?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion[], b: WorksheetRow, c: number, d?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _br(a: WorksheetRow, b: number, c: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _ad(a: Workbook, b: WorksheetRow, c: number, d: Point): boolean;
    /**
     * @hidden
     */
    abstract _g(): Formula;
    /**
     * @hidden
     */
    _b6(a: Workbook): void;
    /**
     * @hidden
     */
    _b5(a: FormulaContext): void;
    /**
     * @hidden
     */
    protected get__i(): Formula;
    /**
     * @hidden
     */
    readonly _i: Formula;
    /**
     * @hidden
     */
    _bs(a: Workbook, b: WorksheetTable): void;
    /**
     * @hidden
     */
    _bt(a: Workbook): void;
    /**
     * @hidden
     */
    static _u(a: Formula, b: WorksheetCell): SingleTargetFormula;
    /**
     * @hidden
     */
    _bu(): void;
    /**
     * @hidden
     */
    _ae(): boolean;
    /**
     * @hidden
     */
    _af(): boolean;
    /**
     * @hidden
     */
    _c(a: Workbook, b: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bv(a: Worksheet, b: WorkbookReferenceBase, c: Worksheet, d: Nullable$1<boolean>, e: (arg1: string) => string, f: (arg1: NamedReferenceBase, arg2: (arg1: Formula) => void) => NamedReferenceBase): void;
    /**
     * @hidden
     */
    _ao(a: Formula): boolean;
    /**
     * @hidden
     */
    _ar(a: Workbook, b: Worksheet, c: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _bw(a: Workbook, b: WorksheetRow, c: number, d: Point): void;
    /**
     * @hidden
     */
    _av(a: Sheet, b: CellShiftOperation, c: ReferenceShiftType): boolean;
    /**
     * @hidden
     */
    _bx(a: Workbook, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _by(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _b0(): void;
    /**
     * @hidden
     */
    _aw(a: WorksheetTable, b: List$1<WorksheetTableColumn>): boolean;
    /**
     * @hidden
     */
    _bz(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    /**
     * @hidden
     */
    _b2(a: FormulaToken[], b: number[]): void;
    /**
     * @hidden
     */
    _b3(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _b4(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _b9(a: FormulaToken[]): void;
    /**
     * @hidden
     */
    _v(a: number, b: number, c: WorkbookFormat, d: boolean): SingleTargetFormula;
    /**
     * @hidden
     */
    _w(a: number, b: number, c: WorkbookFormat): SingleTargetFormula;
    /**
     * @hidden
     */
    _x(a: number, b: number, c: WorkbookFormat): SingleTargetFormula;
    /**
     * @hidden
     */
    _ca(a: Workbook, b: FormatLimitErrors, c: WorkbookFormat, d: CellReferenceMode, e: boolean, f?: WorksheetRow, g?: number): void;
    /**
     * @hidden
     */
    _cb(): void;
    /**
     * @hidden
     */
    static _h(a: CellReferenceMode, b: FormulaType): Formula;
    /**
     * Determines whether two [[Formula]] instances are equal using the specified cell reference mode.
     * This essentially performs a case-insensitive string comparison, ignoring the white space in the formula.
     * @param formulaA The first Formula to compare.
     * @param formulaB The second Formula to compare.
     * @param cellReferenceMode The cell reference mode to use when comparing the two formulas.
     * @return True if the formulas are both null or both equivalent; False otherwise.
     */
    static areEqual(formulaA: Formula, formulaB: Formula, cellReferenceMode: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    static _p(a: string, b: Workbook, c?: Nullable$1<CellReferenceMode>): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param fileFormat The file format to use when parsing the formula. This will be used to determine certain limits which are format dependant.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param fileFormat The file format to use when parsing the formula. This will be used to determine certain limits which are format dependant.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat, culture: string | CultureInfo): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): Formula;
    /**
     * @hidden
     */
    static _parse(a: string, b: CellReferenceMode): Formula;
    /**
     * @hidden
     */
    static _parse4(a: string, b: CellReferenceMode, c: CultureInfo): Formula;
    /**
     * @hidden
     */
    static _parse2(a: string, b: CellReferenceMode, c: WorkbookFormat): Formula;
    /**
     * @hidden
     */
    static _parse3(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): Formula;
    /**
     * @hidden
     */
    static _k(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>): Formula;
    /**
     * @hidden
     */
    static _o(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>): Formula;
    /**
     * @hidden
     */
    static _ay(a: string, b: CellReferenceMode, c: Formula): {
        ret: boolean;
        p2: Formula;
    };
    /**
     * @hidden
     */
    static _a5(a: string, b: CellReferenceMode, c: CultureInfo, d: Formula): {
        ret: boolean;
        p3: Formula;
    };
    /**
     * @hidden
     */
    static _az(a: string, b: CellReferenceMode, c: Formula, d: FormulaParseException): {
        ret: boolean;
        p2: Formula;
        p3: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a6(a: string, b: CellReferenceMode, c: CultureInfo, d: Formula, e: FormulaParseException): {
        ret: boolean;
        p3: Formula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a1(a: string, b: CellReferenceMode, c: WorkbookFormat, d: Formula): {
        ret: boolean;
        p3: Formula;
    };
    /**
     * @hidden
     */
    static _a3(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: Formula): {
        ret: boolean;
        p4: Formula;
    };
    /**
     * @hidden
     */
    static _a2(a: string, b: CellReferenceMode, c: WorkbookFormat, d: Formula, e: FormulaParseException): {
        ret: boolean;
        p3: Formula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a4(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: Formula, f: FormulaParseException): {
        ret: boolean;
        p4: Formula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a0(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: Formula, h: FormulaParseException): {
        ret: boolean;
        p6: Formula;
        p7: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a7(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>, e: Formula, f: FormulaParseException): {
        ret: boolean;
        p4: Formula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    _au(a: FormulaTokenModifierVisitor): boolean;
    /**
     * @hidden
     */
    _b1(): void;
    /**
     * @hidden
     */
    abstract _b7(): void;
    /**
     * @hidden
     */
    private _b8;
    /**
     * @hidden
     */
    _bk(a: CellReferenceMode, b: CultureInfo): string;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ac: boolean;
    /**
     * @hidden
     */
    readonly _ba: CultureInfo;
    /**
     * @hidden
     */
    protected get__z(): WorkbookFormat;
    /**
     * @hidden
     */
    protected set__z(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _z: WorkbookFormat;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ai: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _aj: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _al: boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    readonly _am: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _an: boolean;
    /**
     * @hidden
     */
    protected get__ak(): boolean;
    /**
     * @hidden
     */
    readonly _ak: boolean;
    /**
     * @hidden
     */
    protected get__ap(): boolean;
    /**
     * @hidden
     */
    readonly _ap: boolean;
    /**
     * @hidden
     */
    readonly _aq: boolean;
    /**
     * @hidden
     */
    readonly _as: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _at: boolean;
    /**
     * @hidden
     */
    abstract readonly _ab: WorksheetRow;
    /**
     * @hidden
     */
    abstract readonly _aa: WorksheetCellAddress;
    /**
     * @hidden
     */
    abstract readonly _bb: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _e: FormulaToken[];
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ax: boolean;
    /**
     * @hidden
     */
    readonly _bg: any;
    /**
     * @hidden
     */
    readonly _s: FormulaType;
    /**
     * @hidden
     */
    protected get__y(): Workbook;
    /**
     * @hidden
     */
    readonly _y: Workbook;
    /**
     * @hidden
     */
    abstract readonly _t: Sheet;
}
/**
 * Interface implemented by the formula object.
 */
export interface IExcelCalcFormula {
    addDynamicReferenceI(reference: IExcelCalcReference): boolean;
    readonly dynamicReferences: IExcelCalcReferenceCollection;
    readonly formulaString: string;
    readonly hasAlwaysDirty: boolean;
    readonly baseReference: IExcelCalcReference;
    evaluate(reference: IExcelCalcReference): ExcelCalcValue;
    readonly staticReferences: IExcelCalcReferenceCollection;
}
/**
 * @hidden
 */
export declare let IExcelCalcFormula_$type: Type;
/**
 * Collection of [[IExcelCalcReference]] objects
 */
export interface IExcelCalcReferenceCollection extends IEnumerable {
}
/**
 * @hidden
 */
export declare let IExcelCalcReferenceCollection_$type: Type;
/**
 * The Primary Reference Inteface.
 */
export interface IExcelCalcReference {
    readonly absoluteName: string;
    readonly elementName: string;
    value: ExcelCalcValue;
    readonly formula: IExcelCalcFormula;
    readonly context: any;
    createReference(referenceString: string): IExcelCalcReference;
    readonly references: IExcelCalcReferenceCollection;
    containsReference(inReference: IExcelCalcReference): boolean;
    isSubsetReference(inReference: IExcelCalcReference): boolean;
    readonly isEnumerable: boolean;
    readonly normalizedAbsoluteName: string;
}
/**
 * @hidden
 */
export declare let IExcelCalcReference_$type: Type;
/**
 * @hidden
 */
export interface IExcelCalcReferenceCollectionEx extends IExcelCalcReferenceCollection, IEnumerable$1<IExcelCalcReference> {
}
/**
 * @hidden
 */
export declare let IExcelCalcReferenceCollectionEx_$type: Type;
/**
 * @hidden
 */
export declare class SingleTargetFormula extends Formula implements IExcelCalcFormula, IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _cc;
    private _ck;
    readonly _cl: List$1<IExcelCalcReference>;
    _cm: number;
    private _cg;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, b: WorksheetDataTable);
    constructor(a: number, b: Formula, c?: boolean);
    constructor(a: number, ..._rest: any[]);
    addDynamicReferenceI(a: IExcelCalcReference): boolean;
    readonly baseReference: IExcelCalcReference;
    readonly dynamicReferences: IExcelCalcReferenceCollection;
    evaluate(a: IExcelCalcReference): ExcelCalcValue;
    readonly formulaString: string;
    readonly staticReferences: IExcelCalcReferenceCollection;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
    _g(): Formula;
    protected get__z(): WorkbookFormat;
    protected set__z(a: WorkbookFormat): void;
    protected get__bb(): number;
    readonly _bb: number;
    protected get__ab(): WorksheetRow;
    readonly _ab: WorksheetRow;
    protected get__aa(): WorksheetCellAddress;
    readonly _aa: WorksheetCellAddress;
    _b7(): void;
    protected get__y(): Workbook;
    protected get__t(): Sheet;
    readonly _t: Sheet;
    _addDynamicReference1(a: IExcelCalcReference, b: ExcelCalcEngine): boolean;
    private _cn;
    _cs(a: ExcelCalcEngine): void;
    private static _co;
    private _ct;
    evaluateCore(a: Workbook): ExcelCalcValue;
    _cf(a: Workbook, b: IExcelCalcReference, c: boolean): ExcelCalcValue;
    _cq(): number;
    private _cp;
    private _cr;
    _cu(a: Workbook): void;
    private _cv;
    private _cw;
    _cx(a: RefBase, b: Workbook, c?: boolean): void;
    _cd: ExcelCalcValue;
    readonly hasAlwaysDirty: boolean;
    protected get__cj(): boolean;
    readonly _cj: boolean;
    readonly _ch: RefBase;
}
/**
 * @hidden
 */
export interface IWorksheetCellOwnedValue {
    verifyNewOwner(a: WorksheetRow, b: number): void;
    readonly isOwnedByAllCellsAppliedTo: boolean;
    setOwningCell(a: WorksheetRow, b: number): void;
}
/**
 * @hidden
 */
export declare let IWorksheetCellOwnedValue_$type: Type;
/**
 * @hidden
 */
export interface IFormattedString {
    setWorkbook(a: Workbook): void;
}
/**
 * @hidden
 */
export declare let IFormattedString_$type: Type;
/**
 * @hidden
 */
export interface IFormattedItem extends IWorkbookProvider {
    readonly owner: any;
    getOwnerAt(a: number): IFormattedRunOwner;
    onFormattingChanged(): void;
}
/**
 * @hidden
 */
export declare let IFormattedItem_$type: Type;
/**
 * Represents a string with mixed formatting in a cell or cell comment.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedString, a portion of the string is "selected" by calling either <see cref="GetFont(int)">GetFont(int)</see> or
 * <see cref="GetFont(int,int)">GetFont(int,int)</see>. Formatting properties are then set on the returned
 * [[FormattedStringFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedStringFont]] will return the formatting of the first
 * character in font's selection range. This is similar to Excel, which will update the formatting interface to
 * reflect the formatting of the first character in a selection range when a cell's text is selected.
 * </p>
 */
export declare class FormattedString extends Base implements IWorksheetCellOwnedValue, IComparable$1<FormattedString>, IFormattedString, IFormattedItem, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _a;
    private _l;
    private _i;
    private _h;
    constructor(workbook: Workbook, element: StringElement);
    constructor(workbook: Workbook, element: StringElement, isElementInCache: boolean, addElementToCache: boolean);
    constructor(unformattedString: string);
    constructor(..._rest: any[]);
    /**
     * Determines whether the specified [[Object]] is equal to this [[FormattedString]].
     * @param obj The value to test for equality to this FormattedString.
     * @return True if the 'obj' is a FormattedString instance and it contains the same unformatted
     * string and formatting as this FormattedString; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Calculates the has code for this [[FormattedString]].
     * @return A number which can be used in hashing functions.
     */
    getHashCode(): number;
    /**
     * Returns the [[String]] that represents this [[FormattedString]].
     * This is just the unformatted string.
     * <p class="body">
     * This will return the same value as [[unformattedString]].
     * </p>
     * @return The String that represents this FormattedString.
     */
    toString(): string;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    compareTo(other: FormattedString): number;
    /**
     * @hidden
     */
    readonly owner: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    getOwnerAt(startIndex: number): IFormattedRunOwner;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    setWorkbook(workbook: Workbook): void;
    /**
     * @hidden
     */
    readonly isOwnedByAllCellsAppliedTo: boolean;
    /**
     * @hidden
     */
    setOwningCell(row: WorksheetRow, columnIndex: number): void;
    /**
     * @hidden
     */
    _setOwningCell(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    verifyNewOwner(ownerRow: WorksheetRow, ownerColumnIndex: number): void;
    /**
     * @hidden
     */
    _verifyNewOwner1(a: IFormattedStringOwner): void;
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    private _y;
    /**
     * Creates a new [[FormattedString]] that is a copy of this one.
     * <p class="body">
     * This should be used if the same formatted string needs to be used in multiple cells.
     * The FormattedString class can only exist as the [[WorksheetCell.value]]
     * of one cell at a time. If the FormattedString is already the value of a cell, and needs
     * to be set as the value of another cell, clone the FormattedString and set the returned
     * clone as value of the cell.
     * </p>
     * <p class="body">
     * The cloned FormattedString only takes its original configuration for this instance.
     * If this instance is cloned and than changed, the clone will not be changed as well; it will
     * remain as it was when it was cloned.
     * </p>
     * @return A new FormattedString that is a copy of this one.
     */
    clone(): FormattedString;
    /**
     * @hidden
     */
    private static _aa;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _e(): FormattedStringElement;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index to
     * the end of the string.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedStringFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @return A FormattedStringFont instance which controls the formatting of the end portion of the string.
     */
    getFont(startIndex: number): FormattedStringFont;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index for
     * the specified number of characters.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedStringFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @param length The number of characters after the start index controlled by the returned font.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @throws [[ArgumentOutOfRangeException]] 'length' is less than one. A zero length string cannot be controlled by a formatting font.
     * @return A FormattedStringFont instance which controls the formatting of a portion of the string.
     */
    getFont(startIndex: number, length: number): FormattedStringFont;
    /**
     * @hidden
     */
    _getFont(a: number): FormattedStringFont;
    /**
     * @hidden
     */
    _getFont1(a: number, b: number): FormattedStringFont;
    /**
     * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
     */
    private _getFormattingRuns;
    getFormattingRuns(): IEnumerable$1<FormattedStringFont>;
    /**
     * @hidden
     */
    _c(): FormattingRunBase[];
    /**
     * @hidden
     */
    _z(a: GenericCachedCollection$1<StringElement>): void;
    /**
     * @hidden
     */
    _ac(a: Sheet): void;
    /**
     * @hidden
     */
    _af(): void;
    /**
     * Gets or sets the unformatted string.
     * <p class="body">
     * If the new unformatted string assigned is shorter than the old unformatted string, all formatting
     * outside the range of the new value will be lost.
     * </p>
     * The unformatted string.
     * @throws [[ArgumentNullException]] The value assigned is a null string.
     */
    /**
    * Gets or sets the unformatted string.
    * <p class="body">
    * If the new unformatted string assigned is shorter than the old unformatted string, all formatting
    * outside the range of the new value will be lost.
    * </p>
    * The unformatted string.
    * @throws [[ArgumentNullException]] The value assigned is a null string.
    */
    unformattedString: string;
    /**
     * @hidden
     */
    private _ad;
    /**
     * @hidden
     */
    readonly _m: StringElement;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _owner: IFormattedStringOwner;
    /**
     * @hidden
     */
    readonly _t: number;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
}
/**
 * Represents the text area of a chart element.
 * @see [[ChartTitle]]
 * @see [[DisplayUnitLabel]]
 */
export declare class ChartTextAreaBase extends ChartObject implements IFormattedStringOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bl;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _by;
    /**
     * @hidden
     */
    private static readonly _bz;
    /**
     * @hidden
     */
    private static readonly _b0;
    /**
     * @hidden
     */
    static readonly _br: number;
    /**
     * @hidden
     */
    static readonly _ai: HorizontalTitleAlignment;
    /**
     * @hidden
     */
    static readonly _ar: TextHorizontalOverflow;
    /**
     * @hidden
     */
    static readonly _bg: number;
    /**
     * @hidden
     */
    static readonly _af: ElementPosition;
    /**
     * @hidden
     */
    static readonly _al: ReadingOrder;
    /**
     * @hidden
     */
    static readonly _bh: number;
    /**
     * @hidden
     */
    static readonly _ao: TextDirection;
    /**
     * @hidden
     */
    static readonly _ax: VerticalTitleAlignment;
    /**
     * @hidden
     */
    static readonly _au: TextVerticalOverflow;
    /**
     * @hidden
     */
    static readonly _ba: boolean;
    /**
     * @hidden
     */
    private static _w;
    private _z;
    private _a8;
    private _ab;
    private _a4;
    private _b1;
    private _ah;
    private _aq;
    private _bd;
    private _ae;
    private _ak;
    private _be;
    private _az;
    private _an;
    private _bf;
    private _aw;
    private _at;
    private _a9;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     */
    /**
    * Determines the appearance of the border drawn around
    * the text area, as well as whether a border appears.
    */
    border: ChartBorder;
    /**
     * Defines the font properties for each formatted run in the
     * [[text]] that has no more specific setting. Read-only.
     * <p class="body">
     * Use this object to apply font formatting to the entire run of text
     * which comprises the chart or axis title.
     * </p>
     * <p class="body">
     * Font formatting can be applied to individual runs of text using the
     * [[FormattedString.getFont]] method of the object
     * returned from the [[text]] property. Any such formatting
     * overrides that which is defined by the DefaultFont settings.
     * </p>
     * <para class="note"><b>Note:</b> this property will return null until the [[ChartTitle]]
     * is set on the <see cref="WorksheetChart.ChartTitle">WorksheetChart.ChartTitle</see> property.</para>
     * @see [[text]]
     * @see [[FormattedString]]
     */
    readonly defaultFont: IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    readonly _a7: WorkbookColorInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the text area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill properties for the text area.
    * <p class="body">
    * This property returns null by default, indicating that no fill is applied.
    * </p>
    * <p class="body">
    * To apply a solid color fill, assign an instance of the
    * [[ChartSolidFill]] class to this property.
    * </p>
    * <p class="body">
    * To apply a gradient fill, assign an instance of the
    * [[ChartGradientFill]] class to this property.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    protected get__ad(): ChartFillBase;
    /**
     * @hidden
     */
    readonly _ad: ChartFillBase;
    /**
     * The formula used to get the text displayed within the text area. (read-only).
     * <para class="body">
     * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
     * </para>
     * @see [[setFormula]]
     */
    protected get_formula(): Formula;
    /**
     * The formula used to get the text displayed within the text area. (read-only).
     * <para class="body">
     * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
     * </para>
     * @see [[setFormula]]
     */
    readonly formula: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _a5: SingleTargetFormula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _aj: HorizontalTitleAlignment;
    /**
     * Determines whether text is allowed to continue horizontally
     * outside the bounds of the containing element.
     */
    /**
    * Determines whether text is allowed to continue horizontally
    * outside the bounds of the containing element.
    */
    horizontalOverflow: TextHorizontalOverflow;
    /**
     * The left position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the width of the chart element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the text area as close as possible to the
     * edge of the chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected get_left(): number;
    /**
     * The left position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the width of the chart element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the text area as close as possible to the
     * edge of the chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected set_left(a: number): void;
    /**
     * The left position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the width of the chart element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the text area as close as possible to the
     * edge of the chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    /**
    * The left position of the text area (ignored unless [[position]] is set to 'Custom').
    * <p class="body">
    * The value of this property is expressed as a fractional value between 0 and 1
    * which represents the ratio of the offset to the width of the chart element.
    * </p>
    * <p class="body">
    * For example, a value of 0 positions the text area as close as possible to the
    * edge of the chart element; a value of 1 positions it as close as possible to the opposite
    * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
    * the entire chart element, yields the offset.
    * </p>
    * @see [[position]]
    */
    left: number;
    /**
     * Determines whether the position of the text area is automatic or custom
     * as specified by the [[left]] and [[top]] properties.
     */
    protected get_position(): ElementPosition;
    /**
     * Determines whether the position of the text area is automatic or custom
     * as specified by the [[left]] and [[top]] properties.
     */
    protected set_position(a: ElementPosition): void;
    /**
     * Determines whether the position of the text area is automatic or custom
     * as specified by the [[left]] and [[top]] properties.
     */
    /**
    * Determines whether the position of the text area is automatic or custom
    * as specified by the [[left]] and [[top]] properties.
    */
    position: ElementPosition;
    /**
     * Determines the reading order
     */
    /**
    * Determines the reading order
    */
    readingOrder: ReadingOrder;
    /**
     * Determines the rotation of the text area, expressed in degrees.
     */
    /**
    * Determines the rotation of the text area, expressed in degrees.
    */
    rotation: number;
    /**
     * Returns or sets a [[FormattedString]] object which defines
     * the text to be displayed by the associated chart element.
     * <p class="body">
     * Because mixed font settings are supported for chart element text,
     * a special object is required to customize the text.
     * </p>
     * <p class="body">
     * For the simple case where all the text has the same formatting,
     * create an instance of the [[FormattedString]] class,
     * specifiying the text as the value of the 'unformattedString'
     * parameter.
     * </p>
     * <p class="body">
     * To apply font attributes to a given run of text, i.e., a substring
     * within the text, use the [[FormattedString.getFont]]
     * method, and set the applicable properties of the [[FormattedStringFont]]
     * instance returned from the GetFont method.
     * </p>
     * @see [[FormattedString..ctor]]
     * @see [[FormattedString.getFont]]
     */
    protected get_text(): FormattedString;
    /**
     * Returns or sets a [[FormattedString]] object which defines
     * the text to be displayed by the associated chart element.
     * <p class="body">
     * Because mixed font settings are supported for chart element text,
     * a special object is required to customize the text.
     * </p>
     * <p class="body">
     * For the simple case where all the text has the same formatting,
     * create an instance of the [[FormattedString]] class,
     * specifiying the text as the value of the 'unformattedString'
     * parameter.
     * </p>
     * <p class="body">
     * To apply font attributes to a given run of text, i.e., a substring
     * within the text, use the [[FormattedString.getFont]]
     * method, and set the applicable properties of the [[FormattedStringFont]]
     * instance returned from the GetFont method.
     * </p>
     * @see [[FormattedString..ctor]]
     * @see [[FormattedString.getFont]]
     */
    protected set_text(a: FormattedString): void;
    /**
     * Returns or sets a [[FormattedString]] object which defines
     * the text to be displayed by the associated chart element.
     * <p class="body">
     * Because mixed font settings are supported for chart element text,
     * a special object is required to customize the text.
     * </p>
     * <p class="body">
     * For the simple case where all the text has the same formatting,
     * create an instance of the [[FormattedString]] class,
     * specifiying the text as the value of the 'unformattedString'
     * parameter.
     * </p>
     * <p class="body">
     * To apply font attributes to a given run of text, i.e., a substring
     * within the text, use the [[FormattedString.getFont]]
     * method, and set the applicable properties of the [[FormattedStringFont]]
     * instance returned from the GetFont method.
     * </p>
     * @see [[FormattedString..ctor]]
     * @see [[FormattedString.getFont]]
     */
    /**
    * Returns or sets a [[FormattedString]] object which defines
    * the text to be displayed by the associated chart element.
    * <p class="body">
    * Because mixed font settings are supported for chart element text,
    * a special object is required to customize the text.
    * </p>
    * <p class="body">
    * For the simple case where all the text has the same formatting,
    * create an instance of the [[FormattedString]] class,
    * specifiying the text as the value of the 'unformattedString'
    * parameter.
    * </p>
    * <p class="body">
    * To apply font attributes to a given run of text, i.e., a substring
    * within the text, use the [[FormattedString.getFont]]
    * method, and set the applicable properties of the [[FormattedStringFont]]
    * instance returned from the GetFont method.
    * </p>
    * @see [[FormattedString..ctor]]
    * @see [[FormattedString.getFont]]
    */
    text: FormattedString;
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    /**
    * Determines the orientation and direction in which text flows.
    * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
    * @see [[rotation]]
    */
    textDirection: TextDirection;
    /**
     * The top position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the height of the associated chart
     * element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the title as close as possible to the
     * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected get_top(): number;
    /**
     * The top position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the height of the associated chart
     * element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the title as close as possible to the
     * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected set_top(a: number): void;
    /**
     * The top position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the height of the associated chart
     * element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the title as close as possible to the
     * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    /**
    * The top position of the text area (ignored unless [[position]] is set to 'Custom').
    * <p class="body">
    * The value of this property is expressed as a fractional value between 0 and 1
    * which represents the ratio of the offset to the height of the associated chart
    * element.
    * </p>
    * <p class="body">
    * For example, a value of 0 positions the title as close as possible to the
    * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
    * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
    * the entire chart element, yields the offset.
    * </p>
    * @see [[position]]
    */
    top: number;
    /**
     * Determines the vertical alignment of the text area.
     */
    /**
    * Determines the vertical alignment of the text area.
    */
    verticalAlignment: VerticalTitleAlignment;
    /**
     * Determines whether text is allowed to continue vertically
     * outside the bounds of the containing element.
     */
    /**
    * Determines whether text is allowed to continue vertically
    * outside the bounds of the containing element.
    */
    verticalOverflow: TextVerticalOverflow;
    /**
     * Determines whether text is wrapped when it would exceed
     * the bounds of the containing element.
     */
    /**
    * Determines whether text is wrapped when it would exceed
    * the bounds of the containing element.
    */
    wrapText: boolean;
    /**
     * Assigns a new [[Formula]] to this instance.
     * @param formula The string representation of the formula used to get the [[text]].
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[text]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _b2(a: Sheet, b: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _a3(a?: boolean): IWorkbookFont;
    /**
     * @hidden
     */
    _bb(a: boolean, b?: ElementPosition): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _a6;
    /**
     * @hidden
     */
    readonly allowDefaultValues: boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
}
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export declare class ChartTitle extends ChartTextAreaBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    static readonly _cd: number;
    private _b9;
    private _b8;
    static staticInit(): void;
    constructor();
    /**
     * @hidden
     */
    readonly _b7: IWorkbookFont;
    /**
     * @hidden
     */
    readonly _ca: boolean;
    /**
     * Determines whether the chart title is laid over the plot area.
     */
    /**
    * Determines whether the chart title is laid over the plot area.
    */
    overlay: boolean;
    /**
     * @hidden
     */
    _cf(a: IWorkbookFont): void;
    /**
     * @hidden
     */
    _cc(): boolean;
    /**
     * @hidden
     */
    private static _b4;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b5;
}
/**
 * Exposes properties which control the fill and width
 * of the drop lines in a stock chart.
 * @see [[WorksheetChart.dropLines]]
 */
export declare class ChartDropLines extends ChartLineBase {
    static $t: Type;
    constructor();
}
/**
 * Exposes properties which control the fill and width of the lines
 * which depict the high and low values in a stock chart.
 * @see [[WorksheetChart.highLowLines]]
 */
export declare class ChartHighLowLines extends ChartLineBase {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    readonly _ak: ChartFillBase;
}
/**
 * @hidden
 */
export declare class WorksheetChart_LegendChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetChart, c: Legend, d: LegendEntry[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: WorksheetChart;
    readonly b: Legend;
    readonly a: LegendEntry[];
    d(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Exposes properties which control the fill and width of the lines
 * which connect the first and second plot areas in a 'bar of pie'
 * or 'pie of pie' chart.
 * @see [[WorksheetChart.seriesLines]]
 */
export declare class ChartSeriesLines extends ChartLineBase {
    static $t: Type;
    private _al;
    constructor();
    /**
     * @hidden
     */
    readonly _ak: ChartFillBase;
}
/**
 * Represents the bars which depict gain or loss on a stock chart.
 */
export declare class UpDownBars extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ae: number;
    private _ad;
    private _aa;
    private _z;
    constructor();
    /**
     * Returns an [[UpDownBar]] instance which controls the appearance
     * of the down bars for a stock chart.
     * @see [[downBar]]
     * @see [[WorksheetChart.upDownBars]]
     * @see [[WorksheetChart.highLowLines]]
     */
    readonly downBar: UpDownBar;
    /**
     * Specifies the width of the gap between bars.
     */
    /**
    * Specifies the width of the gap between bars.
    */
    gapWidth: number;
    /**
     * Returns an [[UpDownBar]] instance which controls the appearance
     * of the up bars for a stock chart.
     * @see [[upBar]]
     * @see [[WorksheetChart.upDownBars]]
     * @see [[WorksheetChart.highLowLines]]
     */
    readonly upBar: UpDownBar;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
export declare class WorksheetChart extends WorksheetShapeGroupBase implements IChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ho: number;
    /**
     * @hidden
     */
    private static readonly _hh;
    /**
     * @hidden
     */
    private static readonly _hi;
    /**
     * @hidden
     */
    private static readonly _hj;
    /**
     * @hidden
     */
    private static readonly _hk;
    /**
     * @hidden
     */
    private static readonly _hx;
    /**
     * @hidden
     */
    private static readonly _hy;
    /**
     * @hidden
     */
    private static readonly _h0;
    /**
     * @hidden
     */
    private static readonly _h1;
    /**
     * @hidden
     */
    private static readonly _h3;
    /**
     * @hidden
     */
    private static readonly _h5;
    /**
     * @hidden
     */
    private static readonly _h7;
    /**
     * @hidden
     */
    private static readonly _h9;
    /**
     * @hidden
     */
    private static readonly _ia;
    /**
     * @hidden
     */
    static readonly _ib: number;
    /**
     * @hidden
     */
    private static readonly _ig;
    /**
     * @hidden
     */
    private static readonly _ih;
    /**
     * @hidden
     */
    private static readonly _ii;
    /**
     * @hidden
     */
    private static readonly _ik;
    /**
     * @hidden
     */
    private static readonly _im;
    /**
     * @hidden
     */
    private static readonly _ip;
    /**
     * @hidden
     */
    private static readonly _iq;
    /**
     * @hidden
     */
    private static readonly _is;
    /**
     * @hidden
     */
    private static readonly _it;
    /**
     * @hidden
     */
    private static readonly _iu;
    /**
     * @hidden
     */
    private static readonly _id;
    /**
     * @hidden
     */
    static readonly _hs: number;
    /**
     * @hidden
     */
    static readonly _ht: number;
    /**
     * @hidden
     */
    static readonly _hq: number;
    /**
     * @hidden
     */
    static readonly _hp: number;
    /**
     * @hidden
     */
    static readonly _hn: number;
    /**
     * @hidden
     */
    static readonly _hr: number;
    /**
     * @hidden
     */
    static readonly _hu: number;
    /**
     * @hidden
     */
    static readonly _hv: number;
    /**
     * @hidden
     */
    static readonly _ic: number;
    /**
     * @hidden
     */
    static _d9: ChangeInfo[];
    /**
     * @hidden
     */
    private static readonly _f0;
    private _fz;
    private _ef;
    private _fj;
    private _iv;
    private _el;
    private _e1;
    private _e3;
    private _g6;
    private _e6;
    private _g7;
    private _en;
    private _fk;
    private _g8;
    private _g9;
    private _ha;
    private _hb;
    private _er;
    /**
     * @hidden
     */
    _e8: Legend;
    private _hc;
    private _fa;
    private _hd;
    private _he;
    private _fc;
    private _hf;
    private _et;
    private _hg;
    private _fl;
    private _fh;
    private _fm;
    private _fy;
    private _fu;
    private _ew;
    private _ex;
    private _ev;
    private _ep;
    static staticInit(): void;
    /**
     * True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart. The [[rightAngleAxes]]  property must be True
     */
    /**
    * True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart. The [[rightAngleAxes]]  property must be True
    */
    autoScaling: boolean;
    /**
     * Indexer
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The corresponding axis or null if not in the collection.
     */
    axisCollection(type: AxisType, group?: AxisGroup): Axis;
    /**
     * Returns the axis collection (read-only)
     */
    axisCollection(): AxisCollection;
    /**
     * @hidden
     */
    readonly _axisCollection$i: AxisCollection;
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the back wall of a 3-D chart. Read-only.
     * @see [[floor]]
     * @see [[sideWall]]
     * @see [[wallDefault]]
     */
    readonly backWall: Wall;
    /**
     * Returns or sets the shape of [[Series]] bars.
     * Applicable only to 3D bar-type charts.
     * <p class="body">
     * This property is applicable only to the following chart types:
     * </p>
     * <p class="body">
     * <ul>
     * <li>Bar3DStacked</li>
     * <li>Column3DStacked</li>
     * <li>ConeBarStacked</li>
     * <li>ConeColStacked</li>
     * <li>PyramidBarStacked</li>
     * <li>PyramidColStacked</li>
     * <li>CylinderBarStacked</li>
     * <li>CylinderColStacked</li>
     * <li>Bar3DStacked100</li>
     * <li>Column3DStacked100</li>
     * <li>ConeBarStacked100</li>
     * <li>ConeColStacked100</li>
     * <li>PyramidBarStacked100</li>
     * <li>PyramidColStacked100</li>
     * <li>CylinderBarStacked100</li>
     * <li>CylinderColStacked100</li>
     * <li>Column3D</li>
     * <li>PyramidCol</li>
     * <li>ConeCol</li>
     * <li>CylinderCol</li>
     * </ul>
     * </p>
     * <p class="body">
     * Use this property to set the bar shape for all series bars.
     * </p>
     * <p class="body">
     * To set the shape for a particular series bar, use the [[Series.barShape]] property.
     * </p>
     * @see [[Series.barShape]]
     * @see [[chartType]]
     */
    /**
    * Returns or sets the shape of [[Series]] bars.
    * Applicable only to 3D bar-type charts.
    * <p class="body">
    * This property is applicable only to the following chart types:
    * </p>
    * <p class="body">
    * <ul>
    * <li>Bar3DStacked</li>
    * <li>Column3DStacked</li>
    * <li>ConeBarStacked</li>
    * <li>ConeColStacked</li>
    * <li>PyramidBarStacked</li>
    * <li>PyramidColStacked</li>
    * <li>CylinderBarStacked</li>
    * <li>CylinderColStacked</li>
    * <li>Bar3DStacked100</li>
    * <li>Column3DStacked100</li>
    * <li>ConeBarStacked100</li>
    * <li>ConeColStacked100</li>
    * <li>PyramidBarStacked100</li>
    * <li>PyramidColStacked100</li>
    * <li>CylinderBarStacked100</li>
    * <li>CylinderColStacked100</li>
    * <li>Column3D</li>
    * <li>PyramidCol</li>
    * <li>ConeCol</li>
    * <li>CylinderCol</li>
    * </ul>
    * </p>
    * <p class="body">
    * Use this property to set the bar shape for all series bars.
    * </p>
    * <p class="body">
    * To set the shape for a particular series bar, use the [[Series.barShape]] property.
    * </p>
    * @see [[Series.barShape]]
    * @see [[chartType]]
    */
    barShape: BarShape | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _barShape$i: Nullable$1<BarShape>;
    /**
     * Returns the resolved value of the [[barShape]] property.
     * @see [[barShape]]
     * @see [[Series.barShape]]
     */
    readonly barShapeResolved: BarShape;
    /**
     * @hidden
     */
    readonly _ej: BarShape;
    /**
     * @hidden
     */
    _ek(a: ChartType): BarShape;
    /**
     * Returns a [[chartArea]] object that represents the complete chart area for the chart. Read-only.
     */
    readonly chartArea: ChartArea;
    /**
     * Returns or sets an [[chartTitle]] object.
     */
    /**
    * Returns or sets an [[chartTitle]] object.
    */
    chartTitle: ChartTitle;
    /**
     * Specifies the chart type.
     * <p class="body">
     * All chart types are supported by the [[WorksheetChart]] type;
     * no derived classes exist or are necessary to support different chart types.
     * </p>
     * <p class="body">
     * Note that changing the chart type may cause related property values
     * to be changed.
     * </p>
     * <p class="body">
     * For example, when transitioning from a chart type which supports
     * line markers, The [[Series.markerStyle]] property is changed
     * to reflect the new chart style.
     * </p>
     * <p class="body">
     * Using another example, when transitioning from a chart type which does
     * not support <see cref="Axis">axes</see>, such as a pie or doughnut chart,
     * to a chart type that does support them, the [[axisCollection]]
     * is modified accordingly.
     * </p>
     * @see [[WorksheetShapeCollection.addChart]]
     */
    /**
    * Specifies the chart type.
    * <p class="body">
    * All chart types are supported by the [[WorksheetChart]] type;
    * no derived classes exist or are necessary to support different chart types.
    * </p>
    * <p class="body">
    * Note that changing the chart type may cause related property values
    * to be changed.
    * </p>
    * <p class="body">
    * For example, when transitioning from a chart type which supports
    * line markers, The [[Series.markerStyle]] property is changed
    * to reflect the new chart style.
    * </p>
    * <p class="body">
    * Using another example, when transitioning from a chart type which does
    * not support <see cref="Axis">axes</see>, such as a pie or doughnut chart,
    * to a chart type that does support them, the [[axisCollection]]
    * is modified accordingly.
    * </p>
    * @see [[WorksheetShapeCollection.addChart]]
    */
    chartType: ChartType;
    /**
     * Returns the [[ComboChartGroup]] instance associated with the specified
     * 'chartType' and 'axisGroup', or null if no such
     * instance exists.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     */
    comboChartGroups(chartType: ChartType, axisGroup: AxisGroup): ComboChartGroup;
    /**
     * Returns a collection of the [[ComboChartGroup]] instances associated with this chart.
     * <p class="body">
     * The properties of the [[WorksheetChart]] class which apply only to a specific chart type
     * are not applicable for combo charts. For example, the [[gapWidth]] property,
     * which applies to bar charts, is not used for bar charts which appear within a combo chart. The reason
     * for this is that combo charts support multiple occurrences of the same chart type,
     * making the WorksheetChart-level properties ambiguous in the context of a combo chart.
     * </p>
     * <p class="body">
     * This class makes it possible to set chart-specific properties for one or more occurrences of
     * a particular chart type, for a particular axis group.
     * </p>
     * <p class="body">
     * For example, consider a combo chart with two <i>ClusteredColumn</i> series, one on the primary
     * axis and another on the secondary.
     * To set the [[gapWidth]] property for the chart on the primary axis, add an item to
     * this collection with a [[chartType]] of <i>ClusteredColumn</i>, and an [[AxisGroup]]
     * of <i>Primary</i>. On the [[ComboChartGroup]] instance returned from the collection's Add method,
     * set the <i>GapWidth</i> property to the desired value.
     * </p>
     * <p class="body">
     * When the chart is serialized, this collection is checked against each series in the combo chart.
     * If the <see cref="Series.ChartType">ChartType</see> and the <see cref="Series.AxisGroup">AxisGroup</see>
     * match the respective properties on a ComboChartGroup instance, the value of that instance's <i>GapWidth</i>
     * property is applied to the chart element for that series. Because the other clustered column series exists
     * on the secondary axis, the property is not applied to that series, since while it has the same <i>ChartType</i>,
     * its <i>AxisGroup</i> is different.
     * </p>
     * @see [[ComboChartGroup]]
     * @see [[Series.chartType]]
     * @see [[Series.axisGroup]]
     */
    comboChartGroups(): ComboChartGroupCollection;
    /**
     * @hidden
     */
    readonly _comboChartGroups$i: ComboChartGroupCollection;
    /**
     * Returns or sets the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
     */
    /**
    * Returns or sets the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
    */
    depthPercent: number;
    /**
     * Returns or sets the way that blank cells are plotted on a chart.
     */
    /**
    * Returns or sets the way that blank cells are plotted on a chart.
    */
    displayBlanksAs: DisplayBlanksAs;
    /**
     * Returns or sets the size of the hole in a doughnut chart,
     * expressed as a percentage of the size of the encompassing circle.
     * <p class="body">
     * This property is only applicable to doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 90, inclusive.
     * </p>
     */
    /**
    * Returns or sets the size of the hole in a doughnut chart,
    * expressed as a percentage of the size of the encompassing circle.
    * <p class="body">
    * This property is only applicable to doughnut charts.
    * </p>
    * <p class="body">
    * The valid range for this property is 0 through 90, inclusive.
    * </p>
    */
    doughnutHoleSize: number;
    /**
     * Returns or sets a [[ChartDropLines]] instance which determines
     * the appearance for a stock chart's drop lines.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * High/low lines are not displayed by default; to enable them,
     * assign a [[ChartDropLines]]to this property.
     * to null.
     * </p>
     */
    /**
    * Returns or sets a [[ChartDropLines]] instance which determines
    * the appearance for a stock chart's drop lines.
    * <p class="body">
    * This property is only applicable for stock charts.
    * </p>
    * <p class="body">
    * High/low lines are not displayed by default; to enable them,
    * assign a [[ChartDropLines]]to this property.
    * to null.
    * </p>
    */
    dropLines: ChartDropLines;
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the bottom wall of a 3-D chart. Read-only.
     * @see [[backWall]]
     * @see [[sideWall]]
     * @see [[wallDefault]]
     */
    readonly floor: Wall;
    /**
     * Returns or sets the gap depth in a 3-D chart, expressed
     * as a percentage of the marker width. The value of this property must
     * be between 0 and 500.
     * @see [[gapWidth]]
     */
    /**
    * Returns or sets the gap depth in a 3-D chart, expressed
    * as a percentage of the marker width. The value of this property must
    * be between 0 and 500.
    * @see [[gapWidth]]
    */
    gapDepth: number;
    /**
     * @hidden
     */
    readonly _ix: Nullable$1<number>;
    /**
     * Returns or sets the distance between the data series in a bar chart,
     * as a percentage of the marker width. The value of this property must
     * be between 0 and 500.
     * @see [[gapDepth]]
     */
    /**
    * Returns or sets the distance between the data series in a bar chart,
    * as a percentage of the marker width. The value of this property must
    * be between 0 and 500.
    * @see [[gapDepth]]
    */
    gapWidth: number;
    /**
     * @hidden
     */
    readonly _iy: Nullable$1<number>;
    /**
     * Returns or sets the angle which determines the origin of the first
     * slice, as relative to the 12 o'clock position of the emcompassing circle.
     * <p class="body">
     * This property is only applicable to pie and doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 360, inclusive. Fractional
     * angles are not supported; nor are negative angles.
     * </p>
     * <p class="body">
     * By default, the first slice begins at the "12 o'clock" position of the
     * pie chart, i.e., the top center point of the encompassing circle.
     * </p>
     * <p class="body">
     * Use this property to offset the origin of the first slice; for example, a
     * value of 30 positions the first slice at the 1 o'clock position, 60 at the
     * 2 o'clock position, 90 for 3 o'clock, etc.
     * </p>
     * <p class="body">
     * Larger values move along the circumference of the emcompassing circle
     * in a clockwise direction, with a value of 0 or 360 both coinciding with
     * the 12 o'clock position.
     * </p>
     */
    /**
    * Returns or sets the angle which determines the origin of the first
    * slice, as relative to the 12 o'clock position of the emcompassing circle.
    * <p class="body">
    * This property is only applicable to pie and doughnut charts.
    * </p>
    * <p class="body">
    * The valid range for this property is 0 through 360, inclusive. Fractional
    * angles are not supported; nor are negative angles.
    * </p>
    * <p class="body">
    * By default, the first slice begins at the "12 o'clock" position of the
    * pie chart, i.e., the top center point of the encompassing circle.
    * </p>
    * <p class="body">
    * Use this property to offset the origin of the first slice; for example, a
    * value of 30 positions the first slice at the 1 o'clock position, 60 at the
    * 2 o'clock position, 90 for 3 o'clock, etc.
    * </p>
    * <p class="body">
    * Larger values move along the circumference of the emcompassing circle
    * in a clockwise direction, with a value of 0 or 360 both coinciding with
    * the 12 o'clock position.
    * </p>
    */
    firstSliceAngle: number;
    /**
     * Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
     */
    /**
    * Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
    */
    heightPercent: number;
    /**
     * Returns or sets a [[ChartHighLowLines]] instance which determines
     * the appearance for a stock chart's high/low lines.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * High/low lines depict the high and low prices for a stock chart.
     * </p>
     * <p class="body">
     * High/low lines are displayed by default; to disable them, set this property
     * to null.
     * </p>
     */
    /**
    * Returns or sets a [[ChartHighLowLines]] instance which determines
    * the appearance for a stock chart's high/low lines.
    * <p class="body">
    * This property is only applicable for stock charts.
    * </p>
    * <p class="body">
    * High/low lines depict the high and low prices for a stock chart.
    * </p>
    * <p class="body">
    * High/low lines are displayed by default; to disable them, set this property
    * to null.
    * </p>
    */
    highLowLines: ChartHighLowLines;
    /**
     * Returns or sets a [[legend]] object which represents
     * the legend for the chart.
     */
    /**
    * Returns or sets a [[legend]] object which represents
    * the legend for the chart.
    */
    legend: Legend;
    /**
     * Returns or sets a value that represents the perspective
     * for the 3-D chart view, expressed in degrees.
     * <p class="body">
     * This property supports values within the inclusive range of <b>0</b> and <b>120</b>.
     * </p>
     */
    /**
    * Returns or sets a value that represents the perspective
    * for the 3-D chart view, expressed in degrees.
    * <p class="body">
    * This property supports values within the inclusive range of <b>0</b> and <b>120</b>.
    * </p>
    */
    perspective: number;
    /**
     * Returns a PlotArea object that represents the plot area of a chart. Read-only.
     */
    readonly plotArea: PlotArea;
    /**
     * True if only visible cells are plotted. False if both visible and hidden cells are plotted.
     */
    /**
    * True if only visible cells are plotted. False if both visible and hidden cells are plotted.
    */
    plotVisibleOnly: boolean;
    /**
     * True if the chart axes are at right angles, independent of chart rotation or elevation. Applies only to 3-D line, column, and bar charts.
     */
    /**
    * True if the chart axes are at right angles, independent of chart rotation or elevation. Applies only to 3-D line, column, and bar charts.
    */
    rightAngleAxes: boolean;
    /**
     * Returns or sets the rotation of a 3-D chart view around the X-axis, expressed in degrees.
     * <p class="body">
     * This property controls the viewing perspective by rotating the
     * chart around the horizontal axis, such that the top of the chart
     * appears to move closer or further away.
     * </p>
     * <p class="body">
     * This property is only applicable to 3D charts.
     * </p>
     * @see [[rotationY]]
     */
    /**
    * Returns or sets the rotation of a 3-D chart view around the X-axis, expressed in degrees.
    * <p class="body">
    * This property controls the viewing perspective by rotating the
    * chart around the horizontal axis, such that the top of the chart
    * appears to move closer or further away.
    * </p>
    * <p class="body">
    * This property is only applicable to 3D charts.
    * </p>
    * @see [[rotationY]]
    */
    rotationX: number;
    /**
     * Returns or sets the rotation of a 3-D chart view around the Y-axis, expressed in degrees.
     * <p class="body">
     * This property controls the viewing perspective by rotating the
     * chart around the vertical axis, such that the left edge of the chart
     * appears to move closer or further away.
     * </p>
     * <p class="body">
     * This property is only applicable to 3D charts.
     * </p>
     * @see [[rotationX]]
     */
    /**
    * Returns or sets the rotation of a 3-D chart view around the Y-axis, expressed in degrees.
    * <p class="body">
    * This property controls the viewing perspective by rotating the
    * chart around the vertical axis, such that the left edge of the chart
    * appears to move closer or further away.
    * </p>
    * <p class="body">
    * This property is only applicable to 3D charts.
    * </p>
    * @see [[rotationX]]
    */
    rotationY: number;
    /**
     * Returns or sets the size of the second plot area in a 'bar of pie'
     * or 'pie of pie' chart, expressed as a percentage of the first plot
     * area's size.
     * <p class="body">
     * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
     * <see cref="WorksheetChart.ChartType">chart types</see>.
     * </p>
     * <p class="body">
     * This property supports values in the range of <b>5</b>  to <b>200</b>, inclusively.
     * </p>
     */
    /**
    * Returns or sets the size of the second plot area in a 'bar of pie'
    * or 'pie of pie' chart, expressed as a percentage of the first plot
    * area's size.
    * <p class="body">
    * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
    * <see cref="WorksheetChart.ChartType">chart types</see>.
    * </p>
    * <p class="body">
    * This property supports values in the range of <b>5</b>  to <b>200</b>, inclusively.
    * </p>
    */
    secondPlotSize: number;
    /**
     * Indexer
     * @param index A zero based index
     * @return
     */
    seriesCollection(index: number): Series;
    /**
     * Returns the series collection (read-only)
     */
    seriesCollection(): SeriesCollection;
    /**
     * @hidden
     */
    readonly _seriesCollection$i: SeriesCollection;
    /**
     * Determines the <see cref="ChartLineBase.Fill">fill</see> and
     * <see cref="ChartLineBase.WidthInPoints">width</see> for the lines
     * which connect the first and second plot areas in a 'bar of pie'
     * or 'pie of pie' chart.
     * <p class="body">
     * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
     * <see cref="WorksheetChart.ChartType">chart types</see>.
     * </p>
     * @see [[secondPlotSize]]
     */
    /**
    * Determines the <see cref="ChartLineBase.Fill">fill</see> and
    * <see cref="ChartLineBase.WidthInPoints">width</see> for the lines
    * which connect the first and second plot areas in a 'bar of pie'
    * or 'pie of pie' chart.
    * <p class="body">
    * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
    * <see cref="WorksheetChart.ChartType">chart types</see>.
    * </p>
    * @see [[secondPlotSize]]
    */
    seriesLines: ChartSeriesLines;
    /**
     * Determines the amount by which intersecting [[Series]] overlap,
     * expressed as a percentage of the bar size.
     * <p class="body">
     * This property is only applicable for 2D bar charts.
     * </p>
     * @see [[gapDepth]]
     * @see [[gapWidth]]
     */
    /**
    * Determines the amount by which intersecting [[Series]] overlap,
    * expressed as a percentage of the bar size.
    * <p class="body">
    * This property is only applicable for 2D bar charts.
    * </p>
    * @see [[gapDepth]]
    * @see [[gapWidth]]
    */
    seriesOverlap: number;
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the side wall of a 3-D chart. Read-only.
     * @see [[floor]]
     * @see [[backWall]]
     * @see [[wallDefault]]
     */
    readonly sideWall: Wall;
    /**
     * Returns or sets a [[UpDownBars]] instance which determines
     * the appearance for a stock chart's up/down bars.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * Up/down bars depict gains or losses across a series for a stock chart.
     * </p>
     */
    /**
    * Returns or sets a [[UpDownBars]] instance which determines
    * the appearance for a stock chart's up/down bars.
    * <p class="body">
    * This property is only applicable for stock charts.
    * </p>
    * <p class="body">
    * Up/down bars depict gains or losses across a series for a stock chart.
    * </p>
    */
    upDownBars: UpDownBars;
    /**
     * Returns or sets a boolean value indicating whether the fill colors
     * for <see cref="Series">series</see> and <see cref="DataPoint">data points</see>
     * are automatically selected by Excel.
     * <p class="body">
     * This property defaults to <b>true</b>, causing fill colors for
     * series and data points to be automatically selected by Excel.
     * </p>
     * <p class="body">
     * The automatically selected color can always be overridden for individual series
     * and/or data points using the [[Series.fill]], [[Series.line]],
     * and [[DataPoint.fill]] properties.
     * </p>
     * <p class="body">
     * In cases where VaryColors is set to true, but a fill is explicitly assigned,
     * the assigned fill is used for the associated series or data point, while series
     * or data points which have no explicitly assigned fill will have a fill color
     * automatically selected.
     * </p>
     * @see [[Series.fill]]
     * @see [[Series.line]]
     * @see [[DataPoint.fill]]
     */
    /**
    * Returns or sets a boolean value indicating whether the fill colors
    * for <see cref="Series">series</see> and <see cref="DataPoint">data points</see>
    * are automatically selected by Excel.
    * <p class="body">
    * This property defaults to <b>true</b>, causing fill colors for
    * series and data points to be automatically selected by Excel.
    * </p>
    * <p class="body">
    * The automatically selected color can always be overridden for individual series
    * and/or data points using the [[Series.fill]], [[Series.line]],
    * and [[DataPoint.fill]] properties.
    * </p>
    * <p class="body">
    * In cases where VaryColors is set to true, but a fill is explicitly assigned,
    * the assigned fill is used for the associated series or data point, while series
    * or data points which have no explicitly assigned fill will have a fill color
    * automatically selected.
    * </p>
    * @see [[Series.fill]]
    * @see [[Series.line]]
    * @see [[DataPoint.fill]]
    */
    varyColors: boolean;
    /**
     * Returns a [[Wall]] object which represents the back and side
     * walls, and floor of the chart. Applicable only for 3-D charts.
     * <p class="body">
     * Use this property to apply the same settings for the back wall, side wall, and floor.
     * </p>
     * <p class="body">
     * Use the [[backWall]] property to control the appearance of the back wall.
     * </p>
     * <p class="body">
     * Use the [[sideWall]] property to control the appearance of the side wall.
     * </p>
     * <p class="body">
     * Use the [[floor]] property to control the appearance of the bottom wall.
     * </p>
     * <p class="body">
     * The BackWall, SideWall, and Floor properties take precedence over this property.
     * </p>
     * @see [[backWall]]
     * @see [[sideWall]]
     * @see [[floor]]
     */
    readonly wallDefault: Wall;
    /**
     * Gets the worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * @hidden
     */
    readonly _ez: ChartSolidFill;
    /**
     * @hidden
     */
    readonly _e0: ChartSolidFill;
    /**
     * @hidden
     */
    readonly _ey: ChartSolidFill;
    /**
     * @hidden
     */
    readonly _eq: ChartEmptyFill;
    /**
     * @hidden
     */
    readonly _gc: boolean;
    /**
     * @hidden
     */
    readonly _gu: boolean;
    /**
     * @hidden
     */
    readonly _gv: boolean;
    /**
     * @hidden
     */
    readonly _gt: boolean;
    /**
     * Sets the source data range for a combo chart.
     * <p class="body">
     * Combo charts support multiple chart types within the main chart, with each different
     * chart type being associated with one or more [[Series]].
     * </p>
     * <p class="body">
     * Use this method to populate the [[seriesCollection]] for a combo chart.
     * </p>
     * <p class="body">
     * For example, given a 'dataRange' which yields three series, the caller
     * can specify an array with three elements as the value of the 'seriesChartTypes'
     * parameter. Each array element is then applied to the corresponding series, in the same order
     * in which they appear in the array.
     * </p>
     * <p class="body">
     * Duplicate ChartType values can appear in the 'seriesChartTypes' array,
     * in which case the corresponding series appear within the same chart. For example, specifying
     * an array with <i>ClusteredColumn</i>, <i>Line</i>, and <i>Line</i> results in a combo chart
     * with the first series appearing in a clustered column chart, and the remaining series appearing
     * in a line chart.
     * </p>
     * <p class="body">
     * Specifying null for the value of the 'seriesChartTypes' parameter
     * is treated the same as a two-element array containing 'ColumnClustered' and 'Line',
     * resulting in a clustered column chart for the first series, and a line chart for the
     * remaining series.
     * </p>
     * <p class="body">
     * If fewer values are present in the 'seriesChartTypes' array than the
     * number of series yielded from the specified 'dataRange', the remaining
     * series acquire the same ChartType and AxisGroup as the last element in the <i>seriesChartTypes</i>
     * array. If more values are present in the array than the number of series yielded, these values
     * are ignored.
     * </p>
     * <p class="body">
     * Certain chart type values are invalid for a combo chart; if any of these chart types
     * are present in the array, an exception is thrown, listing the invalid chart types.
     * </p>
     * <p class="body">
     * The following table lists the ChartType values which are supported in combo charts,
     * grouped by series type:
     * </p>
     * <p class="body">
     * <table border = "1" >
     * <tr><th> SeriesType </th ><th>ChartType (supported in combo charts)</th></tr>
     * <tr>
     *  <td>Area</td><td>Area, AreaStacked, AreaStacked100</td>
     * </tr>
     * 	<tr>
     * 		<td>Bar</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, BarClustered, BarStacked, BarStacked100, BarOfPie</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Line</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Pie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Radar</td><td>Radar, RadarFilled, RadarMarkers</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Scatter</td><td>XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Bubble</td><td><b>Not Supported</b></td>
     * 	</tr>
     * 	<tr>
     * 		<td>Surface</td><td><b>Not Supported</b></td>
     * 	</tr>
     * </table>
     * </p>
     * <p class="body">
     * Combo charts support a maximum of two axis groups. If the combination of values in the
     * 'seriesChartTypes' array necessitates more than two axis groups, an exception
     * is thrown.
     * </p>
     * <p class="body">
     * Combo charts require a minimum of two [[Series]]. If the specified 'dataRange'
     * yields less that two series, an exception is thrown.
     * </p>
     * <p class="body">
     * If the combination of series used in a combo chart is indistinguishable from a non-combo
     * chart, the chart may not be recognized by Excel as a combo chart. For example, adding two
     * series, one of type <i>Radar</i> and one of type <i>RadarMarkers</i>, is a valid combination.
     * When opened in Excel, however, such a chart will not be recognized as a combo chart, since the
     * combination of series does not necessitate multiple chart elements. All relevant property values
     * are persisted, however, and there is no distinguishable difference between the original chart
     * and the serialized one.
     * </p>
     * @param dataRange The data range for the combo chart
     * @param seriesChartTypes An array of [[chartType]] constants which specify the chart type for each series
     * yielded from the specified 'dataRange'.
     * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
     * @param cellReferenceMode Optional. Determines how to parse the dataRange.
     * @see [[Series]]
     * @see [[Axis]]
     * @see [[Series.chartType]]
     * @see [[Series.axisGroup]]
     * @throws [[BaseError]] The current value of the [[chartType]] property is not <i>Combo</i>.
     * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains one or more values which are not
     * supported within a combo chart.
     * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains a combination of values which
     * would require more than the maximum allowable number of axes (two).
     */
    setComboChartSourceData(dataRange: string, seriesChartTypes: ChartType[], plotByRows?: boolean, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setComboChartSourceData$i(a: string, b: ChartType[], c?: boolean, d?: Nullable$1<CellReferenceMode>): void;
    /**
     * Sets the source data range for the chart.
     * <p class="data">
     * For combo charts, this method always displays the first series in a clustered column chart,
     * with all subsequent series displayed in line charts. Use the [[setComboChartSourceData]]
     * to customize the series charts for a combo chart.
     * </p>
     * @param dataRange The data range for the chart
     * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
     * @param cellReferenceMode Optional. Determines how to parse the dataRange.
     */
    setSourceData(dataRange: string, plotByRows?: boolean, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setSourceData$i(a: string, b?: boolean, c?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    private _jr;
    /**
     * @hidden
     */
    _jb(): void;
    /**
     * @hidden
     */
    _g5(): List$1<LegendEntry>;
    /**
     * @hidden
     */
    static _i0(a: ChartType): Nullable$1<number>;
    /**
     * @hidden
     */
    static _g0(a: Nullable$1<SeriesType>): HashSet$1<ChartType>;
    /**
     * @hidden
     */
    static _gm(a: ChartType[]): boolean;
    /**
     * @hidden
     */
    static _gn(a: ChartType[], b: ChartType[]): {
        ret: boolean;
        p1: ChartType[];
    };
    /**
     * @hidden
     */
    static _go(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f8(a: ChartType, b: boolean, c: boolean): {
        ret: boolean;
        p1: boolean;
        p2: boolean;
    };
    /**
     * @hidden
     */
    static _gd(a: ChartType, b?: ChartTypeContext): boolean;
    /**
     * @hidden
     */
    static _ge(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gk(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f7(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gl(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gf(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gg(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gh(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f9(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f3(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gr(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f4(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _jd(a: ChartType, b: ChartFillBase, c: Nullable$1<MarkerStyle>): {
        p1: ChartFillBase;
        p2: Nullable$1<MarkerStyle>;
    };
    /**
     * @hidden
     */
    _i8(a?: Sheet): void;
    /**
     * @hidden
     */
    _ja(): void;
    /**
     * @hidden
     */
    static _gx(a: ChartType): boolean;
    /**
     * @hidden
     */
    _je(): void;
    /**
     * @hidden
     */
    static _jv(a: Sheet, b: ChartType): void;
    /**
     * @hidden
     */
    _jk(): void;
    /**
     * @hidden
     */
    private _jf;
    /**
     * @hidden
     */
    private _jg;
    /**
     * @hidden
     */
    _fr(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _fs(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _ft(a: SeriesChartTypeGroup, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _gq(a: ChartType, b: AxisGroup): boolean;
    /**
     * @hidden
     */
    _eh(a: Axis, b?: boolean): AxisPosition;
    /**
     * @hidden
     */
    private _i6;
    /**
     * @hidden
     */
    private _i7;
    /**
     * @hidden
     */
    private _hl;
    /**
     * @hidden
     */
    private _hm;
    /**
     * @hidden
     */
    private static _i2;
    /**
     * @hidden
     */
    private static _ff;
    /**
     * @hidden
     */
    private static _fg;
    /**
     * @hidden
     */
    private static _fe;
    /**
     * @hidden
     */
    private static _ed;
    /**
     * @hidden
     */
    private static _ee;
    /**
     * @hidden
     */
    private static _ea;
    /**
     * @hidden
     */
    private _f2;
    /**
     * @hidden
     */
    private _i3;
    /**
     * @hidden
     */
    private _jj;
    /**
     * @hidden
     */
    private _jl;
    /**
     * @hidden
     */
    private _jm;
    /**
     * @hidden
     */
    private _jo;
    /**
     * @hidden
     */
    private _jp;
    /**
     * @hidden
     */
    private _js;
    /**
     * @hidden
     */
    _jt(): void;
    /**
     * @hidden
     */
    private _jc;
    /**
     * @hidden
     */
    private _jw;
    /**
     * @hidden
     */
    private _ju;
    /**
     * @hidden
     */
    private _jx;
    /**
     * @hidden
     */
    _jy(): void;
    /**
     * @hidden
     */
    private _jh;
    /**
     * @hidden
     */
    private _ji;
    /**
     * @hidden
     */
    private static _i1;
    /**
     * @hidden
     */
    static _f6(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gi(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gj(a: ChartType, b: boolean): {
        ret: boolean;
        p1: boolean;
    };
    /**
     * @hidden
     */
    static _ga(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gb(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f5(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _e5(a: SeriesType): ChartType;
    /**
     * @hidden
     */
    static _gy(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _iz(a: ChartType): Nullable$1<MarkerStyle>;
    /**
     * @hidden
     */
    _i9(): void;
    /**
     * @hidden
     */
    static _gw(a: ChartType): boolean;
    /**
     * @hidden
     */
    readonly chart: WorksheetChart;
    /**
     * @hidden
     */
    onPropertyChanged(): void;
    /**
     * @hidden
     */
    isReferencingAnythingInRegion(ws: Worksheet, region: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    iterateFormulas(callback: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    onShiftRegion(callback: (arg1: IChartObject, arg2: any) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoChartShift(context: any): any;
    /**
     * @hidden
     */
    verifyFormulas(removedWorksheet: Worksheet): void;
    private _eb;
    private _fw;
    private _i4;
    private _g1;
    private _g2;
    constructor(a: number);
    constructor(a: number, b: UnknownShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g3: List$1<Formula>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ec: BinaryData;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _fx: Excel2007ChartData;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g4: List$1<FontXInfo>;
    /**
     * @hidden
     */
    readonly _i5: number;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElementProxy$1<T extends GenericCacheElementEx> extends Base {
    static $t: Type;
    protected $t: Type;
    protected c: T;
    constructor($t: Type, a: number, b: T, c: GenericCachedCollectionEx$1<T>);
    constructor($t: Type, a: number, b: GenericCachedCollectionEx$1<T>);
    constructor($t: Type, a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    g(a: GenericCachedCollection$1<T>): void;
    a(): GenericCachedCollection$1<T>;
    b(a: boolean): GenericCachedCollection$1<T>;
    h(a: GenericCachedCollection$1<T>): void;
    i(): void;
    protected k(a: T): void;
    private j;
    protected get_d(): T;
    readonly d: T;
}
/**
 * @hidden
 */
export declare abstract class WorksheetCellFormatProxy extends GenericCacheElementProxy$1<WorksheetCellFormatData> implements IWorksheetCellFormat {
    static $t: Type;
    private static readonly _ah;
    private static readonly _ag;
    private static readonly _af;
    private _t;
    private _r;
    private _x;
    constructor(a: number, b: WorksheetCellFormatData, c: GenericCachedCollectionEx$1<WorksheetCellFormatData>, d: IWorksheetCellFormatProxyOwner);
    constructor(a: number, b: GenericCachedCollectionEx$1<WorksheetCellFormatData>, c: IWorksheetCellFormatProxyOwner);
    constructor(a: number, ..._rest: any[]);
    private static _am;
    private static _an;
    private static _al;
    private static _aq;
    protected static _m(a: ExcelChangeAction, b: WorksheetPermissions): ChangeInfo[];
    private static _ad;
    private static _ac;
    private _n;
    static _o(a: IWorksheetCellFormat, b: WorksheetCellFormatData): CellFormatValue;
    private static _ae;
    _ai(): Nullable$1<WorksheetCellAddress>;
    _aj(a: CellFormatValue): any;
    static _y(a: IWorksheetCellFormat, b: IWorksheetCellFormat, c: CellFormatValue): boolean;
    _aa(a: CellFormatValue): boolean;
    _ao(a: CellFormatValue, b: CellFormatValueChangedOptions): void;
    _ap(a: CellFormatValue): void;
    _ar(a?: CellFormatValueChangedOptions): void;
    _as(a: CellFormatValue, b: CellFormatValueChangedOptions): void;
    _at(a: Nullable$1<WorksheetCellAddress>): void;
    _a1(a: IWorkbookFont, b: boolean, c: CellFormatValueChangedOptions): void;
    _a2<TValue>($tValue: Type, a: TValue, b: CellFormatValue, c: boolean, d: CellFormatValueChangedOptions, e: (arg1: IWorkbookFont) => TValue, f: (arg1: IWorkbookFont, arg2: TValue) => void): void;
    private _ab;
    setFormatting(a: IWorksheetCellFormat): void;
    _setFormatting1(a: IWorksheetCellFormat, b: CellFormatValueChangedOptions): void;
    _a7(a: IWorksheetCellFormat): void;
    protected _bc(a: IWorksheetCellFormatProxyOwner): void;
    _bk(a: CellFormatValue, b: any): void;
    _bl(a: CellFormatValue, b: any, c: boolean, d: CellFormatValueChangedOptions): void;
    private static _bo;
    private static _bp;
    private static _bq;
    alignment: HorizontalCellAlignment;
    _au(a: HorizontalCellAlignment, b: boolean, c: CellFormatValueChangedOptions): void;
    bottomBorderColorInfo: WorkbookColorInfo;
    _av(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    bottomBorderStyle: CellBorderLineStyle;
    _aw(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    diagonalBorderColorInfo: WorkbookColorInfo;
    _ax(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    diagonalBorders: DiagonalBorders;
    _ay(a: DiagonalBorders, b: boolean, c: CellFormatValueChangedOptions): void;
    diagonalBorderStyle: CellBorderLineStyle;
    _az(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    fill: CellFill;
    _a0(a: CellFill, b: boolean, c: CellFormatValueChangedOptions): void;
    readonly font: IWorkbookFont;
    formatOptions: WorksheetCellFormatOptions;
    readonly _w: WorksheetCellFormatOptions;
    private _a4;
    _a3(a: WorksheetCellFormatOptions, b: boolean, c: CellFormatValueChangedOptions): void;
    formatString: string;
    _a5(a: string, b: boolean, c: CellFormatValueChangedOptions): void;
    indent: number;
    _a8(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    leftBorderColorInfo: WorkbookColorInfo;
    _a9(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    leftBorderStyle: CellBorderLineStyle;
    _ba(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    locked: boolean | null;
    _locked$i: Nullable$1<boolean>;
    _bb(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    rightBorderColorInfo: WorkbookColorInfo;
    _bd(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    rightBorderStyle: CellBorderLineStyle;
    _be(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    rotation: number;
    _bf(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    shrinkToFit: boolean | null;
    _shrinkToFit$i: Nullable$1<boolean>;
    _bg(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    style: WorkbookStyle;
    _bh(a: WorkbookStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    topBorderColorInfo: WorkbookColorInfo;
    _bi(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    topBorderStyle: CellBorderLineStyle;
    _bj(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    verticalAlignment: VerticalCellAlignment;
    _bm(a: VerticalCellAlignment, b: boolean, c: CellFormatValueChangedOptions): void;
    wrapText: boolean | null;
    _wrapText$i: Nullable$1<boolean>;
    _bn(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    readonly _u: WorkbookFontOwnerAccessor;
    readonly _z: boolean;
    readonly _s: IWorksheetCellFormatProxyOwner;
    protected abstract readonly _l: ChangeInfo[];
    abstract readonly _q: ExcelChangeAction;
    protected get__ak(): any;
    readonly _ak: any;
    abstract readonly _v: Worksheet;
}
/**
 * @hidden
 */
export interface IWorksheetCellFormatProxyContext extends IChangeInfoContext {
    readonly proxy: WorksheetCellFormatProxy;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormatProxyContext_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_FormatChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetCellFormatProxy;
    readonly a: WorksheetCellFormatOptions;
    readonly c: Nullable$1<WorksheetCellAddress>;
    readonly proxy: WorksheetCellFormatProxy;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_SetFormattingChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: WorksheetCellFormatProxy;
    readonly b: WorksheetCellFormatOptions;
    readonly a: WorksheetCellFormatData;
    readonly d: Nullable$1<WorksheetCellAddress>;
    readonly proxy: WorksheetCellFormatProxy;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_SetFontFormattingChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetCellFormatProxy;
    readonly a: WorkbookFontData;
    readonly c: Nullable$1<WorksheetCellAddress>;
    readonly proxy: WorksheetCellFormatProxy;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a font for the cell in the related context.
 * <p class="body">
 * If a property of a font has a default value, value of the previous font in resolution chain is used. The resolution priority
 * is the following:
 * <list type="number">
 * <item>Cell (highest priority)</item>
 * <item>Row</item>
 * <item>Column</item>
 * <item>Default Cell Format (lowest priority)</item>
 * </list>
 * For example, if a column font is set to blue and bold and a row font is set to italic and not bold, the font in the cell at
 * the intersection of the row and column would have blue, italic text in the saved workbook.
 * </p>
 */
export interface IWorkbookFont {
    setFontFormatting(source: IWorkbookFont): void;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    colorInfo: WorkbookColorInfo;
    height: number;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    name: string;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    underlineStyle: FontUnderlineStyle;
}
/**
 * @hidden
 */
export declare let IWorkbookFont_$type: Type;
/**
 * @hidden
 */
export declare class WorkbookFontData extends GenericCacheElementEx implements IWorkbookFont {
    static $t: Type;
    static readonly _at: any;
    private _aq;
    private _al;
    private _an;
    private _ai;
    private _ao;
    private _ar;
    private _au;
    private _as;
    private _ag;
    private _ah;
    constructor(a: number, b: Workbook);
    constructor(a: number, b: WorkbookFontData);
    constructor(a: number, b: WorkbookFontData, c: Workbook);
    constructor(a: number, ..._rest: any[]);
    g(a: Workbook): any;
    _aj(a: Workbook): WorkbookFontData;
    aa(a: GenericCacheElement): void;
    equals(a: any): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    protected af(): void;
    setFontFormatting(a: IWorkbookFont): void;
    _ay(): void;
    _ak(a: IWorkbookFontDefaultsResolver): WorkbookFontData;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    colorInfo: WorkbookColorInfo;
    height: number;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    name: string;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    underlineStyle: FontUnderlineStyle;
    readonly _am: boolean;
}
/**
 * @hidden
 */
export declare class ConditionalFormatOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: ConditionalFormatBase);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get_d(): WorksheetCellFormatData;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
}
/**
 * Represents a custom view in Microsoft Excel.
 * <p class="body">
 * Custom views provide a way to save display options and optionally print options for the workbook and each worksheet in the workbook.
 * These options can be different from the options currently set on the workbook and worksheets.
 * </p>
 * <p class="body">
 * Multiple custom views can be saved with a workbook, and the options from a custom view can be applied to its associated workbook by
 * calling the [[apply]] method on it.
 * </p>
 * @see [[Workbook.customViews]]
 */
export declare class CustomView extends Base {
    static $t: Type;
    private _i;
    private _s;
    private _m;
    private _k;
    private _u;
    private _b;
    private _o;
    private _q;
    private _r;
    private _p;
    constructor(a: Workbook, b: boolean, c: boolean);
    /**
     * Applies all options from the custom view to the associated workbook and its worksheets.
     * <p class="body">
     * There is no state of the workbook indicating the custom view currently applied, so applying a custom view
     * simply copies over all options saved with it to the workbook and its worksheet. If an applied custom view
     * is then changed, those changes will not be updated on the workbook or worksheets. Instead, the custom view will need
     * to be applied again for those changes to be reflected on the workbook or worksheet.
     * </p>
     * @throws [[InvalidOperationException]] The custom view has previously been removed from its associated workbook.
     */
    apply(): void;
    /**
     * Gets the display options associated with the specified worksheet.
     * <p class="body">
     * Setting properties on the returned [[DisplayOptions]] instance will not change the actual
     * display of the worksheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the worksheet.
     * </p>
     * @param worksheet The worksheet whose associated display options are to be retrieved.
     * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if the worksheet does not belong to the workbook associated with this custom view;
     * otherwise, the display options associated with the worksheet.
     * @see [[Worksheet.displayOptions]]
     */
    getDisplayOptions(worksheet: Worksheet, createIfNull?: boolean): CustomViewDisplayOptions;
    /**
     * Gets the display options associated with the specified sheet.
     * <p class="body">
     * Setting properties on the returned [[DisplayOptionsBase]] instance will not change the actual
     * display of the sheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the sheet.
     * </p>
     * @param sheet The sheet whose associated display options are to be retrieved.
     * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded.
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @return Null if the sheet does not belong to the workbook associated with this custom view;
     * otherwise, the display options associated with the worksheet.
     * @see [[Worksheet.displayOptions]]
     * @see [[Chartsheet.displayOptions]]
     */
    getSheetDisplayOptions(sheet: Sheet, createIfNull?: boolean): DisplayOptionsBase;
    /**
     * Gets the hidden columns associated with the specified worksheet.
     * <p class="body">
     * Adding columns on the returned [[HiddenColumnCollection]] instance will not actually hide
     * columns in the worksheet. After modifying the hidden columns in this collection, the [[apply]]
     * method of the [[CustomView]] will hide or unhide the columns.
     * </p>
     * @param worksheet The worksheet whose associated hidden columns are to be retrieved.
     * @param createIfNull True to create the hidden column if it has not yet been allocated of the Worksheet. The options will be initialized based on the current state. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
     * associated with this custom view; otherwise, the collection of hidden columns associated with the worksheet.
     * @see [[RowColumnBase.hidden]]
     * @see [[saveHiddenRowsAndColumns]]
     */
    getHiddenColumns(worksheet: Worksheet, createIfNull?: boolean): HiddenColumnCollection;
    /**
     * Gets the hidden rows associated with the specified worksheet.
     * <p class="body">
     * Adding rows on the returned [[HiddenRowCollection]] instance will not actually hide
     * rows in the worksheet. After modifying the hidden rows in this collection, the [[apply]]
     * method of the [[CustomView]] will hide or unhide the rows.
     * </p>
     * @param worksheet The worksheet whose associated hidden rows are to be retrieved.
     * @param createIfNull True to create the hidden column if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
     * associated with this custom view; otherwise, the collection of hidden rows associated with the worksheet.
     * @see [[RowColumnBase.hidden]]
     * @see [[saveHiddenRowsAndColumns]]
     */
    getHiddenRows(worksheet: Worksheet, createIfNull?: boolean): HiddenRowCollection;
    /**
     * Gets the print options associated with the specified worksheet.
     * <p class="body">
     * Setting properties on the returned [[PrintOptions]] instance will not change the actual
     * print settings of the worksheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the worksheet.
     * </p>
     * @param worksheet The worksheet whose associated print options are to be retrieved.
     * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[savePrintOptions]] is False or if the worksheet does not belong to the workbook associated
     * with this custom view; otherwise, the print options associated with the worksheet.
     * @see [[Worksheet.printOptions]]
     * @see [[savePrintOptions]]
     */
    getPrintOptions(worksheet: Worksheet, createIfNull?: boolean): PrintOptions;
    /**
     * Gets the print options associated with the specified sheet.
     * <p class="body">
     * Setting properties on the returned [[PrintOptionsBase]] instance will not change the actual
     * print settings of the sheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the sheet.
     * </p>
     * @param sheet The sheet whose associated print options are to be retrieved.
     * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @return Null if [[savePrintOptions]] is False or if the sheet does not belong to the workbook associated
     * with this custom view; otherwise, the print options associated with the sheet.
     * @see [[Worksheet.printOptions]]
     * @see [[Chartsheet.printOptions]]
     * @see [[savePrintOptions]]
     */
    getSheetPrintOptions(sheet: Sheet, createIfNull?: boolean): PrintOptionsBase;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(a: Sheet): void;
    /**
     * @hidden
     */
    _z(a: Sheet): void;
    /**
     * @hidden
     */
    _aa(a: boolean): void;
    /**
     * @hidden
     */
    _ab(a: boolean): void;
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * Gets or sets the name of the custom view.
     * <p class="body">
     * The name of the custom view is displayed in the custom views dialog of Microsoft Excel and must be
     * case-insensitively unique to other custom views in the workbook.
     * </p>
     * The name of the custom view.
     * @throws [[ArgumentNullException]] The value assigned is a null or empty.
     * @throws [[ArgumentException]] The value assigned is the name of another custom view in this custom view's associated workbook (custom view
     * names are compared case-insensitively).
     */
    /**
    * Gets or sets the name of the custom view.
    * <p class="body">
    * The name of the custom view is displayed in the custom views dialog of Microsoft Excel and must be
    * case-insensitively unique to other custom views in the workbook.
    * </p>
    * The name of the custom view.
    * @throws [[ArgumentNullException]] The value assigned is a null or empty.
    * @throws [[ArgumentException]] The value assigned is the name of another custom view in this custom view's associated workbook (custom view
    * names are compared case-insensitively).
    */
    name: string;
    /**
     * Gets the value indicating whether hidden row and column settings are saved with the custom view.
     * <p class="body">
     * If the value is False, the return value of [[getHiddenColumns]] and [[getHiddenRows]]
     * will always be null, regardless of the worksheet specified.
     * </p>
     * The value indicating whether hidden row and column settings are saved with the custom view.
     * @see [[getHiddenColumns]]
     * @see [[getHiddenRows]]
     * @see [[HiddenColumnCollection]]
     * @see [[HiddenRowCollection]]
     */
    readonly saveHiddenRowsAndColumns: boolean;
    /**
     * Gets the value indicating whether print options are saved with the custom view.
     * <p class="body">
     * If the value is False, the return value of [[getPrintOptions]] will always be null,
     * regardless of the worksheet specified.
     * </p>
     * The value indicating whether print options are saved with the custom view.
     * @see [[getPrintOptions]]
     * @see [[PrintOptions]]
     */
    readonly savePrintOptions: boolean;
    /**
     * Gets the window options for the workbook associated with the custom view.
     * <p class="body">
     * Setting properties on the returned [[windowOptions]] instance will not change the actual
     * window options of the associated workbook. After setting properties, the [[apply]] method
     * of the [[CustomView]] will apply them to the workbook.
     * </p>
     * The window options for the workbook associated with the custom view..
     * @see */
    readonly windowOptions: CustomViewWindowOptions;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _t: Guid;
    /**
     * @hidden
     */
    readonly _j: Workbook;
}
/**
 * Abstract base class which exposes the various display options available for a sheet which can be
 * saved with both a sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 */
export declare abstract class DisplayOptionsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _a;
    private _f;
    private _h;
    constructor(a: Sheet);
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
     * </p>
     */
    reset(): void;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _d(): DisplayOptionsBase;
    /**
     * @hidden
     */
    abstract _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _p(a: WorksheetVisibility, b: WorksheetVisibility): void;
    /**
     * @hidden
     */
    _s(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets or sets the visibility of the sheet.
     * <p class="body">
     * The visibility determines whether the sheet's tab will appear in the tab bar at the
     * bottom of Microsoft Excel.
     * </p>
     * The visibility of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[WorksheetVisibility]] enumeration.
     */
    /**
    * Gets or sets the visibility of the sheet.
    * <p class="body">
    * The visibility determines whether the sheet's tab will appear in the tab bar at the
    * bottom of Microsoft Excel.
    * </p>
    * The visibility of the worksheet.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[WorksheetVisibility]] enumeration.
    */
    visibility: WorksheetVisibility;
    /**
     * @hidden
     */
    abstract readonly _j: boolean;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Abstract base class which exposes the various display options available for a worksheet which can be
 * saved with both a worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export declare abstract class DisplayOptions extends DisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a4: number;
    /**
     * @hidden
     */
    static readonly _a5: number;
    /**
     * @hidden
     */
    static readonly _a3: number;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _t;
    private _ac;
    private _w;
    private _a1;
    private _a7;
    private _aj;
    private _bk;
    private _bm;
    private _ap;
    private _ar;
    private _at;
    private _av;
    private _ax;
    private _az;
    private _aa;
    private _ag;
    private _ae;
    private _y;
    constructor(a: Worksheet);
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    _bq(a: WorksheetView): void;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _u;
    /**
     * Gets the settings which control the frozen panes in the worksheet.
     * <p class="body">
     * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be True.
     * </p>
     * <p class="note">
     * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
     * frozen or unfrozen, these settings may not be used.
     * </p>
     * The settings which control the frozen panes in the worksheet..
     * @see [[panesAreFrozen]]
     * @see [[unfrozenPaneSettings]]
     */
    readonly frozenPaneSettings: FrozenPaneSettings;
    /**
     * Gets or sets the color of the gridlines on the worksheet.
     * <p class="body">
     * If the workbook is using a standard palette, the color set may be changed if it is not in the palette.
     * In this case, the closest color in the standard palette will be used.
     * </p>
     * The color of the gridlines on the worksheet.
     * @throws [[InvalidOperationException]] The workbook is using a custom palette and setting this color would cause the custom palette to use
     * too many colors.
     */
    /**
    * Gets or sets the color of the gridlines on the worksheet.
    * <p class="body">
    * If the workbook is using a standard palette, the color set may be changed if it is not in the palette.
    * In this case, the closest color in the standard palette will be used.
    * </p>
    * The color of the gridlines on the worksheet.
    * @throws [[InvalidOperationException]] The workbook is using a custom palette and setting this color would cause the custom palette to use
    * too many colors.
    */
    gridlineColor: string | Color;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _gridlineColor$i: Color;
    /**
     * @hidden
     */
    private _bp;
    /**
     * Gets or sets the value which indicates if the panes in the worksheet are frozen.
     * <p class="body">
     * Depending on the value of this property, either the [[frozenPaneSettings]] or the
     * [[unfrozenPaneSettings]] will be used for the worksheet. The unused settings are
     * ignored and are not saved with the workbook stream.
     * </p>
     * The value which indicates if the panes in the worksheet are frozen.
     * @see [[frozenPaneSettings]]
     * @see [[unfrozenPaneSettings]]
     */
    /**
    * Gets or sets the value which indicates if the panes in the worksheet are frozen.
    * <p class="body">
    * Depending on the value of this property, either the [[frozenPaneSettings]] or the
    * [[unfrozenPaneSettings]] will be used for the worksheet. The unused settings are
    * ignored and are not saved with the workbook stream.
    * </p>
    * The value which indicates if the panes in the worksheet are frozen.
    * @see [[frozenPaneSettings]]
    * @see [[unfrozenPaneSettings]]
    */
    panesAreFrozen: boolean;
    /**
     * Gets or sets the value which indicates whether the expansion indicators should be shown below grouped,
     * or indented rows.
     */
    /**
    * Gets or sets the value which indicates whether the expansion indicators should be shown below grouped,
    * or indented rows.
    */
    showExpansionIndicatorBelowGroupedRows: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showExpansionIndicatorBelowGroupedRows$i: Nullable$1<boolean>;
    /**
     * Gets or sets the value which indicates whether the expansion indicators should be shown to the right of
     * grouped, or indented rows.
     */
    /**
    * Gets or sets the value which indicates whether the expansion indicators should be shown to the right of
    * grouped, or indented rows.
    */
    showExpansionIndicatorToRightOfGroupedColumns: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showExpansionIndicatorToRightOfGroupedColumns$i: Nullable$1<boolean>;
    /**
     * Gets or sets the value which indicates whether formulas are shown in cells.
     * <p class="body">
     * If this value is True, the formula string will be displayed in the cell. If the value is
     * False, the result of the formula will be displayed in the cell.
     * </p>
     * The value which indicates whether formulas are shown in cells.
     */
    /**
    * Gets or sets the value which indicates whether formulas are shown in cells.
    * <p class="body">
    * If this value is True, the formula string will be displayed in the cell. If the value is
    * False, the result of the formula will be displayed in the cell.
    * </p>
    * The value which indicates whether formulas are shown in cells.
    */
    showFormulasInCells: boolean;
    /**
     * Gets or sets the value which indicates whether gridlines are shown between cells.
     * The value which indicates whether gridlines are shown between cells.
     * @see [[PrintOptions.printGridlines]]
     */
    /**
    * Gets or sets the value which indicates whether gridlines are shown between cells.
    * The value which indicates whether gridlines are shown between cells.
    * @see [[PrintOptions.printGridlines]]
    */
    showGridlines: boolean;
    /**
     * Gets or sets the value which indicates whether outline symbols are shown for outlined columns and rows.
     * <p class="body">
     * If the outline symbols are displayed, they provide a visual representation of the outline levels or rows
     * and columns in Microsoft Excel.  In addition, the outline symbols include the expansion indicators which
     * allow for the expanding and collapsing of outline groups.
     * </p>
     * The value which indicates whether outline symbols are shown for outlined columns and rows.
     * @see [[RowColumnBase.outlineLevel]]
     */
    /**
    * Gets or sets the value which indicates whether outline symbols are shown for outlined columns and rows.
    * <p class="body">
    * If the outline symbols are displayed, they provide a visual representation of the outline levels or rows
    * and columns in Microsoft Excel.  In addition, the outline symbols include the expansion indicators which
    * allow for the expanding and collapsing of outline groups.
    * </p>
    * The value which indicates whether outline symbols are shown for outlined columns and rows.
    * @see [[RowColumnBase.outlineLevel]]
    */
    showOutlineSymbols: boolean;
    /**
     * Gets or sets the value which indicates whether to display row and column headers.
     * <p class="body">
     * The row and column headers show the identifier of the row or column. They also allow the user to easily select
     * all cells in a row or column by clicking them.
     * </p>
     * The value which indicates whether to display row and column headers.
     * @see [[PrintOptions.printRowAndColumnHeaders]]
     */
    /**
    * Gets or sets the value which indicates whether to display row and column headers.
    * <p class="body">
    * The row and column headers show the identifier of the row or column. They also allow the user to easily select
    * all cells in a row or column by clicking them.
    * </p>
    * The value which indicates whether to display row and column headers.
    * @see [[PrintOptions.printRowAndColumnHeaders]]
    */
    showRowAndColumnHeaders: boolean;
    /**
     * Gets or sets the value which indicates whether to show rulers in the page layout view.
     * <p class="body">
     * When this value is True, one ruler will display above the column headers of the active page
     * in page layout view. Another ruler will also display before the row headers of the active page.
     * </p>
     * <p class="note">
     * <b>Note:</b> This property will only affect the worksheet view if the [[view]] is
     * PageLayout.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
     * default to Normal view.
     * </p>
     * The value which indicates whether to show rulers in the page layout view.
     * @see [[view]]
     */
    /**
    * Gets or sets the value which indicates whether to show rulers in the page layout view.
    * <p class="body">
    * When this value is True, one ruler will display above the column headers of the active page
    * in page layout view. Another ruler will also display before the row headers of the active page.
    * </p>
    * <p class="note">
    * <b>Note:</b> This property will only affect the worksheet view if the [[view]] is
    * PageLayout.
    * </p>
    * <p class="note">
    * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
    * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
    * default to Normal view.
    * </p>
    * The value which indicates whether to show rulers in the page layout view.
    * @see [[view]]
    */
    showRulerInPageLayoutView: boolean;
    /**
     * Gets or sets the value which indicates whether zero values are shown in cells.
     * <p class="body">
     * If this value is True, cells with a value of zero will display their values; otherwise,
     * those cells will display as blanks.
     * </p>
     * The value which indicates whether zero values are shown in cells.
     */
    /**
    * Gets or sets the value which indicates whether zero values are shown in cells.
    * <p class="body">
    * If this value is True, cells with a value of zero will display their values; otherwise,
    * those cells will display as blanks.
    * </p>
    * The value which indicates whether zero values are shown in cells.
    */
    showZeroValues: boolean;
    /**
     * Gets the settings which control the unfrozen panes in the worksheet.
     * <p class="body">
     * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be False.
     * </p>
     * <p class="note">
     * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
     * frozen or unfrozen, these settings may not be used.
     * </p>
     * The settings which control the unfrozen panes in the worksheet.
     * @see [[panesAreFrozen]]
     * @see [[frozenPaneSettings]]
     */
    readonly unfrozenPaneSettings: UnfrozenPaneSettings;
    /**
     * Gets or sets the current view of the worksheet.
     * <p class="body">
     * The view determines the overall display of the worksheet in Microsoft Excel.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
     * default to Normal view.
     * </p>
     * The current view of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the WorksheetView enumeration.
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     */
    /**
    * Gets or sets the current view of the worksheet.
    * <p class="body">
    * The view determines the overall display of the worksheet in Microsoft Excel.
    * </p>
    * <p class="note">
    * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
    * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
    * default to Normal view.
    * </p>
    * The current view of the worksheet.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the WorksheetView enumeration.
    * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
    * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
    */
    view: WorksheetView;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _z: PaneLocation;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _a8: number;
    /**
     * @hidden
     */
    readonly _ai: boolean;
    /**
     * @hidden
     */
    readonly _af: WorksheetSelection;
    /**
     * @hidden
     */
    readonly _an: boolean;
    /**
     * @hidden
     */
    readonly _ao: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _a2: boolean;
    /**
     * @hidden
     */
    readonly _ad: Worksheet;
    /**
     * Removes any saved selection information.
     */
    clearSelection(): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _al(): boolean;
    /**
     * @hidden
     */
    _am(): boolean;
    /**
     * @hidden
     */
    _br(): void;
}
/**
 * Class which exposes the worksheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export declare class CustomViewDisplayOptions extends DisplayOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bz;
    /**
     * @hidden
     */
    private static readonly _b0;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _bx;
    /**
     * @hidden
     */
    readonly _bw: CustomView;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    readonly _j: boolean;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * Gets or sets the magnification level of the worksheet in the current [[DisplayOptions.view]].
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet in the current View.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     */
    /**
    * Gets or sets the magnification level of the worksheet in the current [[DisplayOptions.view]].
    * <p class="body">
    * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
    * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
    * </p>
    * The magnification level of the worksheet in the current View.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
    * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
    */
    magnificationInCurrentView: number;
}
/**
 * A collection of [[CustomView]] instances in a workbook.
 */
export declare class CustomViewCollection extends Base implements IList$1<CustomView> {
    static $t: Type;
    private _d;
    private _h;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: CustomView): void;
    /**
     * Adds a new custom view to the collection.
     * @param name The name to give the newly created custom view.
     * @param savePrintOptions True to save print options for each worksheet with the custom view; False otherwise.
     * @param saveHiddenRowsAndColumns True to save information about hidden rows and columns for each worksheet with the custom view; False otherwise.
     * @throws [[ArgumentNullException]] 'name' is a null or empty.
     * @throws [[ArgumentException]] 'name' is the name of another custom view in the collection (custom view names are compared
     * case-insensitively).
     * @return The newly created [[CustomView]] instance.
     */
    add(name: string, savePrintOptions: boolean, saveHiddenRowsAndColumns: boolean): CustomView;
    /**
     * @hidden
     */
    _add$e(a: CustomView): void;
    /**
     * @hidden
     */
    copyTo(array: CustomView[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: CustomView): boolean;
    [Symbol.iterator](): EnumeratorWrapper<CustomView>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<CustomView>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: CustomView): void;
    /**
     * @hidden
     */
    item(index: number, value?: CustomView): CustomView;
    /**
     * Gets the custom view at the specified index.
     * The custom view at the specified index.
     * @param index The zero-based index of the custom view to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(index: number): CustomView;
    /**
     * @hidden
     */
    _item$e(a: number, b?: CustomView): CustomView;
    /**
     * @hidden
     */
    indexOf(item: CustomView): number;
    /**
     * @hidden
     */
    _add(a: string, b: boolean, c: boolean): CustomView;
    /**
     * @hidden
     */
    _add1(a: CustomView): void;
    /**
     * Clears all custom views from the collection.
     */
    clear(): void;
    /**
     * Determines whether a custom view is in this collection.
     * @param customView The custom view to locate in the collection.
     * @return True if the custom view is found; False otherwise.
     */
    contains(customView: CustomView): boolean;
    /**
     * Removes the specified custom view from the collection.
     * @param customView The custom view to remove from the collection.
     * @return True if the custom view was successfully removed; False if the custom view was not
     * in the collection.
     */
    remove_1(customView: CustomView): boolean;
    /**
     * Removes the custom view at the specified index from the collection.
     * @param index The zero-based index of the custom view in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Gets the number of custom views in the collection.
     * The number of custom views in the collection.
     */
    readonly count: number;
    /**
     * @hidden
     */
    _item1(a: number): CustomView;
    /**
     * @hidden
     */
    _item(a: Guid): CustomView;
    /**
     * @hidden
     */
    readonly _e: Workbook;
}
/**
 * Abstract base class which exposes the various workbook window options available which can be saved with
 * both a workbook and a custom view.
 * <p class="body">
 * This class provides a way to control how a workbook is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewWindowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export declare abstract class WindowOptions extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _r: number;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _a;
    private _l;
    private _e;
    private _g;
    private _i;
    private _p;
    private _y;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    abstract _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _ab(a: WindowOptions, b: boolean): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _ae(a: Sheet, b: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _af;
    /**
     * Gets or sets the way the objects and shapes are displayed in the workbook.
     * The way the objects and shapes are displayed in the workbook.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[objectDisplayStyle]] enumeration.
     * @see [[WorksheetShape]]
     * @see [[Worksheet.shapes]]
     */
    /**
    * Gets or sets the way the objects and shapes are displayed in the workbook.
    * The way the objects and shapes are displayed in the workbook.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[objectDisplayStyle]] enumeration.
    * @see [[WorksheetShape]]
    * @see [[Worksheet.shapes]]
    */
    objectDisplayStyle: ObjectDisplayStyle;
    /**
     * Gets or sets the scroll bars shown in the workbook window.
     * <p class="body">
     * The vertical scroll bar occupies the entire height of the application if it is visible.
     * </p>
     * <p class="body">
     * The horizontal scroll bar occupies the width of the application not used by the worksheet
     * tab bar, if it is visible. Otherwise, it occupies the entire width of the application.
     * </p>
     * The scroll bars shown in the workbook window.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scrollBars]] enumeration.
     * @see [[tabBarWidth]]
     * @see [[tabBarVisible]]
     */
    /**
    * Gets or sets the scroll bars shown in the workbook window.
    * <p class="body">
    * The vertical scroll bar occupies the entire height of the application if it is visible.
    * </p>
    * <p class="body">
    * The horizontal scroll bar occupies the width of the application not used by the worksheet
    * tab bar, if it is visible. Otherwise, it occupies the entire width of the application.
    * </p>
    * The scroll bars shown in the workbook window.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scrollBars]] enumeration.
    * @see [[tabBarWidth]]
    * @see [[tabBarVisible]]
    */
    scrollBars: ScrollBars;
    /**
     * Gets or sets the selected worksheet of the workbook.
     * <p class="body">
     * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
     * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
     * when the workbook is saved, another worksheet will be selected.
     * </p>
     * The selected worksheet of the workbook.
     * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
     * [[workbook]] has at least one [[Worksheet]].
     * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
     */
    /**
    * Gets or sets the selected worksheet of the workbook.
    * <p class="body">
    * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
    * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
    * </p>
    * <p class="note">
    * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
    * when the workbook is saved, another worksheet will be selected.
    * </p>
    * The selected worksheet of the workbook.
    * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
    * [[workbook]] has at least one [[Worksheet]].
    * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
    */
    selectedSheet: Sheet;
    /**
     * @hidden
     */
    readonly _k: Sheet;
    /**
     * Gets or sets the selected worksheet of the workbook.
     * <p class="body">
     * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
     * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
     * when the workbook is saved, another worksheet will be selected.
     * </p>
     * The selected worksheet of the workbook.
     * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
     * [[workbook]] has at least one [[Worksheet]].
     * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
     */
    /**
    * Gets or sets the selected worksheet of the workbook.
    * <p class="body">
    * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
    * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
    * </p>
    * <p class="note">
    * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
    * when the workbook is saved, another worksheet will be selected.
    * </p>
    * The selected worksheet of the workbook.
    * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
    * [[workbook]] has at least one [[Worksheet]].
    * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
    */
    selectedWorksheet: Worksheet;
    /**
     * Gets or sets the value indicating whether the worksheet tab bar is visible.
     * <p class="body">
     * If the value is False, the [[tabBarWidth]] will not be used, but it will still
     * be serialized with the workbook.
     * </p>
     * The value indicating whether the worksheet tab bar is visible.
     * @see [[tabBarWidth]]
     * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
     */
    /**
    * Gets or sets the value indicating whether the worksheet tab bar is visible.
    * <p class="body">
    * If the value is False, the [[tabBarWidth]] will not be used, but it will still
    * be serialized with the workbook.
    * </p>
    * The value indicating whether the worksheet tab bar is visible.
    * @see [[tabBarWidth]]
    * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
    */
    tabBarVisible: boolean;
    /**
     * Gets or sets the width of the worksheet tab bar, expressed in 1/1000ths of the application width.
     * <p class="body">
     * This value is only used if [[tabBarVisible]] is True. Regardless of whether the tab bar is
     * visible, the width value is always saved with the workbook.
     * </p>
     * <p class="body">
     * A value of 1000 indicates the worksheet tab bar occupies the entire width of the application, while
     * a value of 0 indicates the worksheet tab bar has no width.
     * </p>
     * <p class="body">
     * All space not occupied by the worksheet tab bar will be used by the horizontal scroll bar, if it is visible.
     * </p>
     * The width of the worksheet tab bar, expressed in 1/1000ths of the application width.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 1000.
     * @see [[tabBarVisible]]
     * @see [[scrollBars]]
     * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
     */
    /**
    * Gets or sets the width of the worksheet tab bar, expressed in 1/1000ths of the application width.
    * <p class="body">
    * This value is only used if [[tabBarVisible]] is True. Regardless of whether the tab bar is
    * visible, the width value is always saved with the workbook.
    * </p>
    * <p class="body">
    * A value of 1000 indicates the worksheet tab bar occupies the entire width of the application, while
    * a value of 0 indicates the worksheet tab bar has no width.
    * </p>
    * <p class="body">
    * All space not occupied by the worksheet tab bar will be used by the horizontal scroll bar, if it is visible.
    * </p>
    * The width of the worksheet tab bar, expressed in 1/1000ths of the application width.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 1000.
    * @see [[tabBarVisible]]
    * @see [[scrollBars]]
    * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
    */
    tabBarWidth: number;
    /**
     * @hidden
     */
    abstract readonly _o: boolean;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents the workbook window options which are saved with custom views.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a custom view, but
 * not with a workbook. Therefore, these properties will not be applied when the
 * [[CustomView.apply]] method is called.
 * </p>
 * @see [[CustomView.windowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export declare class CustomViewWindowOptions extends WindowOptions {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ar: Rect;
    private _ag;
    private _ap;
    private _ah;
    private _aj;
    private _al;
    private _an;
    constructor(a: CustomView);
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    readonly _o: boolean;
    /**
     * @hidden
     */
    _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * Gets or sets the pixel bounds of the workbook's MDI child window when [[CustomView]]
     * owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This property will have no affect on the workbook if [[maximized]] is True. However, in this case,
     * the value of this property will still be saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The pixel bounds of the workbook's MDI child window when CustomView owning these
     * window options is applied.
     * @throws [[ArgumentException]] The left or top of the value assigned is outside the bounds of -32768 and 32767.
     * @throws [[ArgumentException]] The width or height of the value assigned is outside the bounds of 0 and 65535.
     * @see [[CustomView.apply]]
     */
    /**
    * Gets or sets the pixel bounds of the workbook's MDI child window when [[CustomView]]
    * owning these window options is applied.
    * <p class="note">
    * <b>Note:</b> This property will have no affect on the workbook if [[maximized]] is True. However, in this case,
    * the value of this property will still be saved with the workbook.
    * </p>
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
    * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
    * calling  on the associated CustomView will not apply this property. Only by
    * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
    * </p>
    * The pixel bounds of the workbook's MDI child window when CustomView owning these
    * window options is applied.
    * @throws [[ArgumentException]] The left or top of the value assigned is outside the bounds of -32768 and 32767.
    * @throws [[ArgumentException]] The width or height of the value assigned is outside the bounds of 0 and 65535.
    * @see [[CustomView.apply]]
    */
    boundsInPixels: IgRect;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _boundsInPixels$i: Rect;
    /**
     * Gets or sets the value indicating whether the workbook's MDI child window will be maximized
     * when the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether the workbook's MDI child window will be maximized when the CustomView owning these
     * window options is applied.
     * @see [[CustomView.apply]]
     * @see [[WorkbookWindowOptions.minimized]]
     */
    /**
    * Gets or sets the value indicating whether the workbook's MDI child window will be maximized
    * when the [[CustomView]] owning these window options is applied.
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
    * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
    * calling  on the associated CustomView will not apply this property. Only by
    * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
    * </p>
    * The value indicating whether the workbook's MDI child window will be maximized when the CustomView owning these
    * window options is applied.
    * @see [[CustomView.apply]]
    * @see [[WorkbookWindowOptions.minimized]]
    */
    maximized: boolean;
    /**
     * Gets or sets the value indicating whether Microsoft Excel will display the formula bar when
     * the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling [[CustomView.apply]] on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether Microsoft Excel will display the formula bar when the CustomView owning these window
     * options is applied.
     * @see [[CustomView.apply]]
     */
    /**
    * Gets or sets the value indicating whether Microsoft Excel will display the formula bar when
    * the [[CustomView]] owning these window options is applied.
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
    * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
    * calling [[CustomView.apply]] on the associated CustomView will not apply this property. Only by
    * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
    * </p>
    * The value indicating whether Microsoft Excel will display the formula bar when the CustomView owning these window
    * options is applied.
    * @see [[CustomView.apply]]
    */
    showFormulaBar: boolean;
    /**
     * Gets or sets the value indicating whether Microsoft Excel will display the status bar when
     * the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether Microsoft Excel will display the status bar when the CustomView owning these window
     * options is applied.
     * @see [[CustomView.apply]]
     */
    /**
    * Gets or sets the value indicating whether Microsoft Excel will display the status bar when
    * the [[CustomView]] owning these window options is applied.
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
    * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
    * calling  on the associated CustomView will not apply this property. Only by
    * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
    * </p>
    * The value indicating whether Microsoft Excel will display the status bar when the CustomView owning these window
    * options is applied.
    * @see [[CustomView.apply]]
    */
    showStatusBar: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ao: number;
}
/**
 * Base class for all data validations rules which can be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[AnyValueDataValidationRule]]
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class DataValidationRule extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _a;
    private _ag;
    private _ai;
    private _d;
    private _ak;
    private _am;
    private _g;
    private _t;
    private _v;
    constructor();
    /**
     * Creates a copy of this rule which can be applied to other worksheets.
     */
    clone(): DataValidationRule;
    /**
     * @hidden
     */
    abstract _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    abstract _m(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    abstract _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    abstract _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    abstract _x(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    abstract _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    static _q(a: Formula, b: Formula): boolean;
    /**
     * @hidden
     */
    static _r(a: string, b: string): boolean;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ao(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    _as(a: string, b: string, c: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    abstract _p: boolean;
    /**
     * @hidden
     */
    abstract readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    abstract readonly _k: DataValidationType;
    /**
     * Gets or sets the description which appears in the dialog box when an invalid value is applied to a cell
     * in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 225 characters.
     * </p>
     * The description to show the user or null to use a default error description.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 225 characters.
     * @see [[errorMessageTitle]]
     */
    /**
    * Gets or sets the description which appears in the dialog box when an invalid value is applied to a cell
    * in Microsoft Excel.
    * <p class="body">
    * This value is only used when [[showErrorMessageForInvalidValue]] is True.
    * </p>
    * <p class="note">
    * <b>Note:</b> the title cannot be more than 225 characters.
    * </p>
    * The description to show the user or null to use a default error description.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 225 characters.
    * @see [[errorMessageTitle]]
    */
    errorMessageDescription: string;
    /**
     * Gets or sets the title which appears in the dialog box when an invalid value is applied to a cell
     * in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 32 characters.
     * </p>
     * The title to show the user or null to use a default error dialog title.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
     * @see [[errorMessageDescription]]
     */
    /**
    * Gets or sets the title which appears in the dialog box when an invalid value is applied to a cell
    * in Microsoft Excel.
    * <p class="body">
    * This value is only used when [[showErrorMessageForInvalidValue]] is True.
    * </p>
    * <p class="note">
    * <b>Note:</b> the title cannot be more than 32 characters.
    * </p>
    * The title to show the user or null to use a default error dialog title.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
    * @see [[errorMessageDescription]]
    */
    errorMessageTitle: string;
    /**
     * Gets or sets the value which indicates whether the value is allowed when it is invalid and which options are given to
     * the user in the error dialog shown by Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationErrorStyle]] enumeration.
     * @see [[showErrorMessageForInvalidValue]]
     */
    /**
    * Gets or sets the value which indicates whether the value is allowed when it is invalid and which options are given to
    * the user in the error dialog shown by Microsoft Excel.
    * <p class="body">
    * This value is only used when [[showErrorMessageForInvalidValue]] is True.
    * </p>
    * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationErrorStyle]] enumeration.
    * @see [[showErrorMessageForInvalidValue]]
    */
    errorStyle: DataValidationErrorStyle;
    /**
     * Gets or sets the description in the tooltip which appears when the user selects the cell in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showInputMessage]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the description cannot be more than 255 characters.
     * </p>
     * The description to show the user in the tooltip.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 255 characters.
     * @see [[inputMessageTitle]]
     */
    /**
    * Gets or sets the description in the tooltip which appears when the user selects the cell in Microsoft Excel.
    * <p class="body">
    * This value is only used when [[showInputMessage]] is True.
    * </p>
    * <p class="note">
    * <b>Note:</b> the description cannot be more than 255 characters.
    * </p>
    * The description to show the user in the tooltip.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 255 characters.
    * @see [[inputMessageTitle]]
    */
    inputMessageDescription: string;
    /**
     * Gets or sets the title in the tooltip which appears when the user selects the cell in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showInputMessage]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 32 characters.
     * </p>
     * The title to show the user in the tooltip.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
     * @see [[inputMessageDescription]]
     */
    /**
    * Gets or sets the title in the tooltip which appears when the user selects the cell in Microsoft Excel.
    * <p class="body">
    * This value is only used when [[showInputMessage]] is True.
    * </p>
    * <p class="note">
    * <b>Note:</b> the title cannot be more than 32 characters.
    * </p>
    * The title to show the user in the tooltip.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
    * @see [[inputMessageDescription]]
    */
    inputMessageTitle: string;
    /**
     * Gets or sets the value which indicates whether the error dialog should appear in Microsoft Excel when invalid data
     * is entered in the cell.
     * <p class="body">
     * When the value is False, invalid data can be entered into cells, but when the user chooses to subsequently circle
     * invalid values in Microsoft Excel, the cell will be circled.
     * </p>
     * True to show the error dialog for invalid cell data; False otherwise.
     * @see [[errorMessageDescription]]
     * @see [[errorMessageTitle]]
     * @see [[errorStyle]]
     */
    /**
    * Gets or sets the value which indicates whether the error dialog should appear in Microsoft Excel when invalid data
    * is entered in the cell.
    * <p class="body">
    * When the value is False, invalid data can be entered into cells, but when the user chooses to subsequently circle
    * invalid values in Microsoft Excel, the cell will be circled.
    * </p>
    * True to show the error dialog for invalid cell data; False otherwise.
    * @see [[errorMessageDescription]]
    * @see [[errorMessageTitle]]
    * @see [[errorStyle]]
    */
    showErrorMessageForInvalidValue: boolean;
    /**
     * Gets or sets the value which indicates whether to show the user an input prompt tooltip when the user selects
     * the cell in Microsoft Excel.
     * <p class="body">
     * The input prompt will only be shown if this value is True and the [[inputMessageDescription]] is not null.
     * </p>
     * @see [[inputMessageDescription]]
     * @see [[inputMessageTitle]]
     */
    /**
    * Gets or sets the value which indicates whether to show the user an input prompt tooltip when the user selects
    * the cell in Microsoft Excel.
    * <p class="body">
    * The input prompt will only be shown if this value is True and the [[inputMessageDescription]] is not null.
    * </p>
    * @see [[inputMessageDescription]]
    * @see [[inputMessageTitle]]
    */
    showInputMessage: boolean;
    /**
     * @hidden
     */
    protected get__i(): FormulaType;
    /**
     * @hidden
     */
    readonly _i: FormulaType;
    /**
     * @hidden
     */
    readonly _h: DataValidationRuleCollection;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
    /**
     * @hidden
     */
    readonly _o: Worksheet;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents a data validation rule which allows any value to be set on the target cells.
 * This would be used to provide an input message to the user when the cell was selected.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class AnyValueDataValidationRule extends DataValidationRule {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    protected get__p(): boolean;
    /**
     * @hidden
     */
    protected set__p(a: boolean): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _p: boolean;
    /**
     * @hidden
     */
    _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    protected get__j(): DataValidationOperatorType;
    /**
     * @hidden
     */
    readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _x(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    protected get__k(): DataValidationType;
    /**
     * @hidden
     */
    readonly _k: DataValidationType;
    /**
     * @hidden
     */
    _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
}
/**
 * Base class for all data validations rules which prevent certain values form being applied to a cell.
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class LimitedValueDataValidationRule extends DataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _au;
    private _a3;
    constructor();
    /**
     * @hidden
     */
    protected get__p(): boolean;
    /**
     * @hidden
     */
    protected set__p(a: boolean): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _p: boolean;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _x(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    _aw(a: SingleTargetFormula, b: WorksheetCellAddress, c?: boolean): ExcelCalcValue;
    /**
     * @hidden
     */
    _bd(a: SingleTargetFormula, b: WorksheetReferenceCollection): {
        p0?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    _a6(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    static _a7(a: FormulaToken, b: boolean, c: boolean, d: boolean): boolean;
    /**
     * @hidden
     */
    _bc(a: () => string, b: WorkbookFormat): Nullable$1<LimitedValueDataValidationRule_FormulaChangeContext>;
    /**
     * @hidden
     */
    _be(a: ChangeInfo$2<LimitedValueDataValidationRule_FormulaChangeContext, string>, b: LimitedValueDataValidationRule_FormulaChangeContext, c: string): void;
    /**
     * @hidden
     */
    _az(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    _a1(a: SingleTargetFormula, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo, f: boolean): SingleTargetFormula;
    /**
     * @hidden
     */
    private _a0;
    /**
     * @hidden
     */
    abstract _a8(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    _bf(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _bg;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * @hidden
     */
    private static _av;
    /**
     * @hidden
     */
    private static _a5;
    /**
     * Gets or sets the value which indicates whether a null, or blank, value is allowed to be set on a cell.
     * True if a null value can be set on the cell; False otherwise.
     */
    /**
    * Gets or sets the value which indicates whether a null, or blank, value is allowed to be set on a cell.
    * True if a null value can be set on the cell; False otherwise.
    */
    allowNull: boolean;
    /**
     * @hidden
     */
    readonly _ax: CellReferenceMode;
    /**
     * @hidden
     */
    readonly _a9: CultureInfo;
    /**
     * @hidden
     */
    readonly _a2: WorkbookFormat;
}
/**
 * @hidden
 */
export declare class LimitedValueDataValidationRule_FormulaChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: LimitedValueDataValidationRule, c: string, d: WorkbookFormat);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: LimitedValueDataValidationRule;
    readonly c: string;
    readonly b: WorkbookFormat;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a data validation rule which allows any formula to be used to validate the value applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class CustomDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bh;
    private _bk;
    constructor();
    /**
     * @hidden
     */
    _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a6(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _ao(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    protected get__j(): DataValidationOperatorType;
    /**
     * @hidden
     */
    readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _a8(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__k(): DataValidationType;
    /**
     * @hidden
     */
    readonly _k: DataValidationType;
    /**
     * @hidden
     */
    _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getFormula]]
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    getFormula(address: string): string;
    /**
     * Gets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getFormula]]
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    getFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getFormula(a: string): string;
    /**
     * @hidden
     */
    _getFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param formula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'formula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'formula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[getFormula]]
     * @see [[getFormula]]
     * @see [[setFormula]]
     */
    setFormula(formula: string, address: string): void;
    /**
     * Sets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param formula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'formula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'formula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[getFormula]]
     * @see [[getFormula]]
     * @see [[setFormula]]
     */
    setFormula(formula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _bl(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _bs;
    /**
     * @hidden
     */
    private static _bj;
    /**
     * @hidden
     */
    private static _bi;
}
/**
 * Represents an error value in Microsoft Excel.
 */
export declare class ErrorValue extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _v: number;
    /**
     * @hidden
     */
    static readonly _u: number;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static readonly _w: number;
    /**
     * @hidden
     */
    static readonly _aa: number;
    /**
     * @hidden
     */
    static readonly _z: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    private static _h;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _k;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static readonly _ac;
    private _x;
    constructor(a: number);
    /**
     * Gets the string representation of the error value.
     * @return The string representation of the error value.
     */
    toString(): string;
    /**
     * @hidden
     */
    static _j(a: number): ErrorValue;
    /**
     * @hidden
     */
    _a(): ExcelCalcErrorValue;
    /**
     * Gets the ErrorValue representing the #N/A error.
     * <p class="body">
     * This error occurs when a value isn't available for some part of a formula.
     * </p>
     * The ErrorValue representing the #N/A error.
     */
    static readonly argumentOrFunctionNotAvailable: ErrorValue;
    /**
     * Gets the ErrorValue representing a circularity error.
     * <p class="body">
     * There is no error constant for a circularity in Microsoft Excel and a circularity cannot be the result of a formula in Microsoft Excel.
     * However, for run-time purposes, after loading or before saving a workbook, this error value will be used for the result of formulas
     * which cause circular references when the owning workbook has [[Workbook.iterativeCalculationsEnabled]] set to False.
     * </p>
     * <p class="body">
     * In Microsoft Excel, setting a circular reference formula on a cell will show an error dialog the first time the problem occurs. Subsequent
     * formulas violating the circular reference restriction will just evaluate to zero. Therefore, when this value is encountered in a cell, it
     * can be treated as a zero for calculation purposes. This error value will be returned though so an actual zero value in a cell can be
     * differentiated from a circularity error.
     * </p>
     * <p class="note">
     * <B>Note:</B> Because there is no circularity error constant in Microsoft Excel, this error value cannot be assigned to a cell manually.
     * Attempting to assign this error value to a cell will result in an InvalidOperationException to be thrown. This error value will only be
     * valid as the result of a formula which has been applied to a cell.
     * </p>
     * The ErrorValue representing a circularity error.
     */
    static readonly circularity: ErrorValue;
    /**
     * Gets the ErrorValue representing the #DIV/0! error.
     * <p class="body">
     * This error occurs when a number is divided by zero.
     * </p>
     * The ErrorValue representing the #DIV/0! error.
     */
    static readonly divisionByZero: ErrorValue;
    /**
     * Gets the ErrorValue representing the #NULL! error.
     * <p class="body">
     * This error occurs when there is an intersection of two references that do not contain any common cells.
     * The intersection operator is a space between two references.
     * </p>
     * The ErrorValue representing the #NULL! error.
     */
    static readonly emptyCellRangeIntersection: ErrorValue;
    /**
     * Gets the ErrorValue representing the #REF! error.
     * <p class="body">
     * This error occurs when a cell reference or cell range reference is not valid.
     * </p>
     * The ErrorValue representing the #REF! error.
     */
    static readonly invalidCellReference: ErrorValue;
    /**
     * Gets the ErrorValue representing the #NUM! error.
     * <p class="body">
     * This error occurs when there are invalid numeric values in a formula.
     * </p>
     * The ErrorValue representing the #NUM! error.
     */
    static readonly valueRangeOverflow: ErrorValue;
    /**
     * Gets the ErrorValue representing the #NAME? error.
     * <p class="body">
     * This error occurs when text in a formula is not recognized.
     * </p>
     * The ErrorValue representing the #NAME? error.
     */
    static readonly wrongFunctionName: ErrorValue;
    /**
     * Gets the ErrorValue representing the #VALUE! error.
     * <p class="body">
     * This error occurs when an incorrect argument or operand is used in a function.
     * </p>
     * The ErrorValue representing the #VALUE! error.
     */
    static readonly wrongOperandType: ErrorValue;
    /**
     * @hidden
     */
    readonly _y: number;
}
/**
 * @hidden
 */
export declare class StringElement extends GenericCacheElement implements IComparable$1<StringElement> {
    static $t: Type;
    static readonly _p: number[];
    private _z;
    private _x;
    constructor(a: string);
    g(a: Workbook): any;
    equals(a: any): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    toString(): string;
    compareTo(a: StringElement): number;
    _t<TArg, TResult>($tArg: Type, $tResult: Type, a: IStringElementVisitor$2<TArg, TResult>, b?: TArg): TResult;
    private static _v;
    static _r(a: string): StringElement;
    _ab(): void;
    _q(): StringElement;
    protected _ac(): void;
    _s(a: Workbook): StringElement;
    static _ad(a: Workbook, b: GenericCachedCollection$1<StringElement>, c: StringElement): {
        p1?: GenericCachedCollection$1<StringElement>;
        p2?: StringElement;
    };
    static _ae(a: Workbook, b: IFormattedStringOwner, c: GenericCachedCollection$1<StringElement>, d: StringElement): {
        p2?: GenericCachedCollection$1<StringElement>;
        p3?: StringElement;
    };
    protected get__u(): boolean;
    readonly _u: boolean;
    _aa: number;
    _y: string;
    readonly _w: number;
}
/**
 * @hidden
 */
export declare class FormattedStringElement extends StringElement implements IFormattedRunOwner {
    static $t: Type;
    private _ag;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    _t<TArg, TResult>($tArg: Type, $tResult: Type, a: IStringElementVisitor$2<TArg, TResult>, b?: TArg): TResult;
    g(a: Workbook): any;
    equals(a: any): boolean;
    _ab(): void;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    protected _ac(): void;
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    readonly startIndex: number;
    _ai(): void;
    static _af(a: StringElement): FormattedStringElement;
    readonly _ah: List$1<FormattingRunBase>;
    protected get__u(): boolean;
    readonly unformattedString: string;
}
/**
 * @hidden
 */
export interface IRegionBlockingSingleCellComponent {
    readonly owningValue: IRegionBlockingValue;
}
/**
 * @hidden
 */
export declare let IRegionBlockingSingleCellComponent_$type: Type;
/**
 * @hidden
 */
export declare class ArrayInteriorFormula extends SingleTargetFormula implements IRegionBlockingSingleCellComponent {
    static $t: Type;
    private readonly _cy;
    constructor(a: ArrayFormula);
    readonly owningValue: IRegionBlockingValue;
    _g(): Formula;
    protected get__i(): Formula;
    protected get__ak(): boolean;
    protected get__cj(): boolean;
    readonly _cz: ArrayFormula;
}
/**
 * @hidden
 */
export declare class DataTableInteriorFormula extends SingleTargetFormula implements IRegionBlockingSingleCellComponent {
    static $t: Type;
    private readonly _cy;
    constructor(a: WorksheetDataTable);
    readonly owningValue: IRegionBlockingValue;
    _g(): Formula;
    protected get__am(): boolean;
    protected get__cj(): boolean;
    readonly _cz: WorksheetDataTable;
}
/**
 * @hidden
 */
export interface ICellFormatOwner {
    readonly cellFormat: IWorksheetCellFormat;
    readonly cellFormatInternal: WorksheetCellFormatProxy;
    getResolvedCellFormat(): IWorksheetCellFormat;
    readonly hasCellFormat: boolean;
}
/**
 * @hidden
 */
export declare let ICellFormatOwner_$type: Type;
/**
 * @hidden
 */
export interface IWorksheetCellFormatProxyOwner {
    getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    verifyFormatOptions(a: WorksheetCellFormatProxy, b: WorksheetCellFormatOptions): void;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormatProxyOwner_$type: Type;
/**
 * Abstract base class for worksheet row and worksheet column.
 * @see [[WorksheetColumn]]
 * @see [[WorksheetRow]]
 */
export declare abstract class RowColumnBase extends Base implements ICellFormatOwner, IWorksheetCellFormatProxyOwner {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _p: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    static readonly _o: number;
    private _f;
    private _c;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    readonly cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    readonly hasCellFormat: boolean;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    abstract _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * Gets the resolved cell formatting for the cells in the row or column.
     * @return A format object describing the actual formatting that will be used when displayed the row or column in Microsoft Excel.
     * @throws [[InvalidOperationException]] If the object was removed from the worksheet.
     * @see [[cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    abstract _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    static _z(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    abstract _ad(): void;
    /**
     * Gets the default cell format for cells in this row or column.
     * <p class="body">
     * Any default properties of the cell's format will take their value from this format when getting a resolved format.
     * </p>
     * The default cell format for cells in this row or column.
     */
    readonly cellFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    readonly _hasCellFormat: boolean;
    /**
     * Gets or sets the value indicating whether the row or column is hidden.
     * The Hidden state also controls the expanded state of rows or columns in outline groups. Basically, an outline group
     * simply provides an easy way to hide and unhide all rows or columns in the group at the same time, via the expansion
     * indicator.
     * The value indicating whether the row or column is hidden.
     * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
     * @see [[outlineLevel]]
     * @see [[CustomView.getHiddenColumns]]
     * @see [[CustomView.getHiddenRows]]
     */
    /**
    * Gets or sets the value indicating whether the row or column is hidden.
    * The Hidden state also controls the expanded state of rows or columns in outline groups. Basically, an outline group
    * simply provides an easy way to hide and unhide all rows or columns in the group at the same time, via the expansion
    * indicator.
    * The value indicating whether the row or column is hidden.
    * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
    * @see [[outlineLevel]]
    * @see [[CustomView.getHiddenColumns]]
    * @see [[CustomView.getHiddenRows]]
    */
    hidden: boolean;
    /**
     * @hidden
     */
    _aa(a: boolean, b?: boolean): void;
    /**
     * Gets the 0-based index of the row or column in the worksheet.
     * The 0-based index of the row or column in the worksheet.
     */
    abstract readonly index: number;
    /**
     * Gets or sets the outline level for the row or column.
     * <p class="body">
     * Microsoft Excel supports hierarchical grouping of rows and columns with a maximum of seven levels of hierarchy.
     * To create a group, set adjacent rows or columns to same outline level. When rows or columns are grouped, an
     * outline indicator will provide a visual representation of the outline level.  In addition, an outline group has
     * an expansion indicator at one end of the group, which allows the user to easily hide and unhide all rows or column
     * in the group with a single click.
     * </p>
     * The outline level for the row or column.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid outline level range of 0 and 7.
     * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
     * @see [[hidden]]
     */
    /**
    * Gets or sets the outline level for the row or column.
    * <p class="body">
    * Microsoft Excel supports hierarchical grouping of rows and columns with a maximum of seven levels of hierarchy.
    * To create a group, set adjacent rows or columns to same outline level. When rows or columns are grouped, an
    * outline indicator will provide a visual representation of the outline level.  In addition, an outline group has
    * an expansion indicator at one end of the group, which allows the user to easily hide and unhide all rows or column
    * in the group with a single click.
    * </p>
    * The outline level for the row or column.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid outline level range of 0 and 7.
    * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
    * @see [[hidden]]
    */
    outlineLevel: number;
    /**
     * @hidden
     */
    private _ab;
    /**
     * Gets the worksheet to which the row or column belongs.
     * The worksheet to which the row or column belongs.
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    abstract readonly _a: ChangeInfo[];
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    readonly _j: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    abstract _l: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    abstract _n: number;
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    abstract readonly _m: boolean;
}
/**
 * @hidden
 */
export interface IWorksheetRegionAddressContext {
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * @hidden
 */
export declare let IWorksheetRegionAddressContext_$type: Type;
/**
 * Represents a row in a Microsoft Excel worksheet.
 */
export declare class WorksheetRow extends RowColumnBase implements IChangeInfoContext, IWorksheetRegionAddressContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _cr: number;
    /**
     * @hidden
     */
    static readonly _cy: number;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _a3;
    private _cl;
    private _af;
    private _bq;
    private _ag;
    private _cn;
    private _cw;
    private _cc;
    private _ce;
    private _bn;
    private _cd;
    constructor(a: Worksheet, b: number);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    readonly _a: ChangeInfo[];
    /**
     * @hidden
     */
    _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    protected get__l(): boolean;
    /**
     * @hidden
     */
    protected set__l(a: boolean): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _l: boolean;
    /**
     * Gets the 0-based index of the row in the worksheet.
     * The 0-based index of the row in the worksheet.
     */
    protected get_index(): number;
    /**
     * Gets the 0-based index of the row in the worksheet.
     * The 0-based index of the row in the worksheet.
     */
    readonly index: number;
    /**
     * @hidden
     */
    readonly _cx: number;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    protected get__n(): number;
    /**
     * @hidden
     */
    protected set__n(a: number): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _n: number;
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Applies a formula to the cell at the specified column index.
     * <p class="body">
     * 'formula' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the row belongs. If the row's [[Worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param formula The formula to parse and apply to the cell.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[FormulaParseException]] 'formula' is not a valid formula.
     * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellFormula]]
     * @see [[WorksheetCell.applyFormula]]
     */
    applyCellFormula(columnIndex: number, formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _applyCellFormula$i(a: number, b: string, c?: Nullable$1<CellReferenceMode>): void;
    /**
     * Gets the data table to which the cell at the specified index belongs.
     * <p class="body">
     * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
     * </p>
     * <p class="body">
     * If a data table is associated with the cell, getting the value of the cell with [[getCellValue]]
     * will return the calculated value for the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The data table to which the cell belongs or null if the cell does not belong to a data table.
     * @see [[Worksheet.dataTables]]
     * @see [[WorksheetDataTableCollection.add]]
     * @see [[getCellValue]]
     * @see [[WorksheetCell.associatedDataTable]]
     */
    getCellAssociatedDataTable(columnIndex: number): WorksheetDataTable;
    /**
     * @hidden
     */
    _bg(a: number): WorksheetDataTable;
    /**
     * Gets the merged cells region which contains the cell at the specified index, or null if the cell is not merged.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The merged cells region which contains the cell at the specified index, or null if the cell is not merged.
     * @see [[WorksheetCell.associatedMergedCellsRegion]]
     */
    getCellAssociatedMergedCellsRegion(columnIndex: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _bl(a: number): WorksheetMergedCellsRegion;
    /**
     * Gets the [[WorksheetTable]] to which the cell at the specified index belongs.
     * <p class="body">
     * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     */
    getCellAssociatedTable(columnIndex: number): WorksheetTable;
    /**
     * @hidden
     */
    _bp(a: number): WorksheetTable;
    /**
     * Gets the bounds of the cell at the specified column index in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The bounds of the cell at the specified column index on its worksheet.
     * @see [[WorksheetCell.getBoundsInTwips]]
     */
    getCellBoundsInTwips(columnIndex: number): IgRect;
    /**
     * Gets the bounds of the cell at the specified column index in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param options The options to use when getting the bounds of the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The bounds of the cell at the specified column index on its worksheet.
     * @see [[WorksheetCell.getBoundsInTwips]]
     */
    getCellBoundsInTwips(columnIndex: number, options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getCellBoundsInTwips(a: number): Rect;
    /**
     * @hidden
     */
    _el(a: number): Rect;
    /**
     * @hidden
     */
    _getCellBoundsInTwips1(a: number, b: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _em(a: number, b: PositioningOptions): Rect;
    /**
     * Gets or sets the comment applied to the cell at the specified column index.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The comment applied to the cell.
     * @see [[WorksheetCell.comment]]
     */
    getCellComment(columnIndex: number): WorksheetCellComment;
    /**
     * @hidden
     */
    _a6(a: number): WorksheetCellComment;
    /**
     * Gets the display text in the cell at the specified index.
     * <p class="body">
     * The display text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @see [[getCellValue]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getCellText(columnIndex: number): string;
    /**
     * Gets the text in the cell at the specified index.
     * <p class="body">
     * The text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param textFormatMode The format mode to use when getting the cell text.
     * @throws [[InvalidEnumArgumentException]] 'textFormatMode' is not defined in the [[TextFormatMode]] enumeration.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellValue]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getCellText(columnIndex: number, textFormatMode: TextFormatMode): string;
    /**
     * @hidden
     */
    _getCellText(a: number): string;
    /**
     * @hidden
     */
    _getCellText1(a: number, b: TextFormatMode): string;
    /**
     * @hidden
     */
    _da(a: number, b: TextFormatMode): string;
    /**
     * @hidden
     */
    _av(a: GetCellTextParameters): GetCellTextResult;
    /**
     * @hidden
     */
    _aw(a: WorksheetCellBlock, b: GetCellTextParameters): GetCellTextResult;
    /**
     * Gets the cell conditional format for the cell at the specified column index.
     * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of the criteria an instance of [[CellConditionalFormat]]
     * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
     * conditional format region then this method will return null.</para>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
     * @see [[Worksheet.conditionalFormats]]
     * @see [[CellConditionalFormat]]
     */
    getCellConditionalFormat(columnIndex: number): CellConditionalFormat;
    /**
     * Gets the cell formatting for the cell at the specified column index.
     * <p class="body">
     * Use this method to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
     * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The cell formatting for the cell at the specified column index.
     * @see [[getResolvedCellFormat]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[tryGetCellFormat]]
     */
    getCellFormat(columnIndex: number): IWorksheetCellFormat;
    /**
     * Gets the formula which has been applied to the cell at the specified column index.
     * <p class="body">
     * If a formula has been applied to the cell, getting the value with the [[getCellValue]] method will return the
     * calculated value of the formula.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The formula which has been applied to the cell or null if no formula has been applied.
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[applyCellFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     * @see [[WorksheetCell.formula]]
     */
    getCellFormula(columnIndex: number): Formula;
    /**
     * @hidden
     */
    _ar(a: number): Formula;
    /**
     * @hidden
     */
    _bi(a: number): WorksheetHyperlink;
    /**
     * Gets the effective hyperlink on the cell at the specified index.
     * <p class="body">
     * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
     * collection will be used.
     * </p>
     * <p class="body">
     * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
     * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
     * </p>
     * <p class="body">
     * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @see [[Worksheet.hyperlinks]]
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetHyperlink.isSealed]]
     */
    getCellHyperlink(columnIndex: number): WorksheetHyperlink;
    /**
     * Gets the value of the cell at the specified column index.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the cell.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[setCellValue]]
     * @see [[getCellAssociatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[getCellFormula]]
     * @see [[getCellAssociatedDataTable]]
     * @see [[WorksheetCell.value]]
     */
    getCellValue(columnIndex: number): any;
    /**
     * @hidden
     */
    _getCellValue1(a: number): any;
    /**
     * @hidden
     */
    _c5(a: number): any;
    /**
     * @hidden
     */
    _bh(a: number): WorksheetDataTable;
    /**
     * Gets the resolved cell formatting for the cells in the row or column.
     * @return A format object describing the actual formatting that will be used when displayed the row or column in Microsoft Excel.
     * @throws [[InvalidOperationException]] If the object was removed from the worksheet.
     * @see [[cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * Gets the resolved cell formatting for the cell at the specified column index.
     * <p class="body">
     * If any cell format properties are the default values on the cell, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return A format object describing the actual formatting that will be used when displayed the cell in Microsoft Excel.
     * @see [[getCellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     * @see [[WorksheetCell.getResolvedCellFormat]]
     */
    getResolvedCellFormat(columnIndex: number): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _getResolvedCellFormat1(a: number): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _az(a: number): IWorksheetCellFormat;
    /**
     * Sets the comment applied to the cell at the specified column index.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param comment The comment to apply to the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
     * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
     * anchors set but they are from different worksheets.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[WorksheetCell.comment]]
     */
    setCellComment(columnIndex: number, comment: WorksheetCellComment): void;
    /**
     * @hidden
     */
    _d2(a: number, b: WorksheetCellComment): void;
    /**
     * Sets the value of a cell at the specified column index.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the cell.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param value The value to assign to the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[Formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellValue]]
     * @see [[getCellAssociatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[getCellFormula]]
     * @see [[getCellAssociatedDataTable]]
     * @see [[WorksheetCell.value]]
     */
    setCellValue(columnIndex: number, value: any): void;
    /**
     * @hidden
     */
    _b9(a: number, b: IWorksheetCellFormat): {
        ret: boolean;
        p1: IWorksheetCellFormat;
    };
    /**
     * Returns a boolean indicating if the value of the cell is valid considering its associated [[WorksheetCell.dataValidationRule]]
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @return Returns false if the cell has an associated [[WorksheetCell.dataValidationRule]] and the current [[WorksheetCell.value]] does not pass the validation defined by that rule; otherwise true is returned.
     * @see [[getCellValue]]
     * @see [[setCellValue]]
     * @see [[Worksheet.dataValidationRules]]
     * @see [[DataValidationRule]]
     * @see [[WorksheetCell.dataValidationRule]]
     */
    validateCellValue(columnIndex: number): boolean;
    /**
     * @hidden
     */
    private _cj;
    /**
     * @hidden
     */
    private _cq;
    /**
     * @hidden
     */
    private _db;
    /**
     * @hidden
     */
    _de(): void;
    /**
     * @hidden
     */
    _df(a: number, b: number, c: boolean, d?: WorksheetRow, e?: Nullable$1<number>, f?: boolean, g?: boolean, h?: Nullable$1<number>): void;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    _dh(): void;
    /**
     * @hidden
     */
    _di(a?: boolean, b?: boolean): void;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    static _bs(a: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _bt(a: number): boolean;
    /**
     * @hidden
     */
    _a1(a: number): WorksheetCellBlock;
    /**
     * @hidden
     */
    private __cf;
    _cf(): IEnumerable$1<KeyValuePair$2<number, WorksheetCellBlock>>;
    /**
     * @hidden
     */
    _as(a: number): CellCalcReference;
    /**
     * @hidden
     */
    _am(a: number, b?: boolean): CellDataContext;
    /**
     * @hidden
     */
    private _al;
    /**
     * @hidden
     */
    _aj(a: number): WorksheetCellFormatData[];
    /**
     * @hidden
     */
    _bc(a: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _bb(a: WorksheetCellFormatData[], b: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _c7(a: number, b: CellReferenceMode, c: boolean, d?: boolean, e?: boolean): string;
    /**
     * @hidden
     */
    _a7(a: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _be(a: number, b: WorksheetCellFormatData, c: WorksheetCellFormatData[], d: boolean): WorksheetCellOwnedFormatProxy;
    /**
     * @hidden
     */
    _dj(a: number, b: number, c: (arg1: WorksheetRow, arg2: WorksheetCellFormatData, arg3: number) => void): void;
    /**
     * @hidden
     */
    _bv(a: number): boolean;
    /**
     * @hidden
     */
    private __ch;
    _ch(a?: number, b?: number, c?: boolean): IEnumerable$1<CellDataContext>;
    /**
     * @hidden
     */
    static _c2(a: WorksheetRow, b: number): any;
    /**
     * @hidden
     */
    private _c4;
    /**
     * @hidden
     */
    _c6(a: number): any;
    /**
     * @hidden
     */
    private __ci;
    _ci(a: boolean): IEnumerable$1<number>;
    /**
     * @hidden
     */
    private _dv;
    /**
     * @hidden
     */
    _dn(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _c0(a: number, b: number): Nullable$1<number>;
    /**
     * @hidden
     */
    _ck(a: number, b: number, c?: Nullable$1<HorizontalCellAlignment>): number;
    /**
     * @hidden
     */
    _c1(a: number, b: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    _ct(a?: boolean): number;
    /**
     * @hidden
     */
    private static _bm;
    /**
     * @hidden
     */
    _dm(a: WorksheetRow): void;
    /**
     * @hidden
     */
    _ds(a: WorksheetCellOwnedFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _dr(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _dt(a: Worksheet, b: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _du(a: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _dw(a: number, b: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _dx(a?: boolean): void;
    /**
     * @hidden
     */
    _dy(a: WorksheetCellFormatCollection): void;
    /**
     * @hidden
     */
    _dz(a: number, b: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _d0(a: number, b: ExcelCalcValue, c?: boolean): void;
    /**
     * @hidden
     */
    _d3(a: number, b: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    _d4(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _d6(a: number, b: any, c?: boolean): void;
    /**
     * @hidden
     */
    _d9(a: number, b: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _a2(a: number): WorksheetCellBlock;
    /**
     * @hidden
     */
    _at(a: number, b?: boolean): CellCalcReference;
    /**
     * @hidden
     */
    _a8(a: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _bd(a: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _a9;
    /**
     * @hidden
     */
    _eb(): void;
    /**
     * @hidden
     */
    _ea(a: SharedStringTable, b?: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _ec(a: number, b: StringElement): void;
    /**
     * @hidden
     */
    _ed(a: number, b: any, c: boolean, d?: boolean): void;
    /**
     * @hidden
     */
    _a0(a: MutableItemRange, b: number, c: number): MutableItemRange;
    /**
     * @hidden
     */
    _cb(): boolean;
    /**
     * @hidden
     */
    private _co;
    /**
     * @hidden
     */
    private _cp;
    /**
     * @hidden
     */
    private _dd;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _ba;
    /**
     * @hidden
     */
    private __cg;
    private _cg;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    private _dk;
    /**
     * @hidden
     */
    private _dl;
    /**
     * @hidden
     */
    private _dp;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    private static _b7;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    private _d7;
    /**
     * @hidden
     */
    private _ee;
    /**
     * @hidden
     */
    private _ef;
    /**
     * @hidden
     */
    private _eg;
    /**
     * @hidden
     */
    private _eh;
    /**
     * @hidden
     */
    private _ei;
    /**
     * Gets the cell at the specified column index in the owning row.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The cell at the specified column index in the owning row.
     * @param index The zero-based column index of the cell to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    cells(index: number): WorksheetCell;
    /**
     * Gets the collection of cells in the row.
     * <p class="body">
     * The collection of cells is a fixed length collection, with the maximum number of cells in the collection being
     * [[Workbook.maxExcelColumnCount]] or [[Workbook.maxExcel2007ColumnCount]],
     * depending on the <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see>.  Internally, the cells
     * are only created and added to the collection when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * MaxExcelColumnCount, and pass in each index to the collection's indexer.
     * </p>
     * The collection of cells in the row.
     */
    cells(): WorksheetCellCollection;
    /**
     * @hidden
     */
    readonly _cells$i: WorksheetCellCollection;
    /**
     * Gets or sets the height of the row in twips (1/20th of a point).
     * <p class="body">
     * If the height of the row is less than zero, the [[Worksheet.defaultRowHeight]] of the
     * owning worksheet will be used as the row's height.
     * </p>
     * <p class="body">
     * The value assigned must be between -1 and 8192. Invalid values will be automatically adjusted to valid values.
     * </p>
     * The height of the row in twips (1/20th of a point).
     * @throws [[InvalidOperationException]] From the setter if the row was removed from the worksheet.
     */
    /**
    * Gets or sets the height of the row in twips (1/20th of a point).
    * <p class="body">
    * If the height of the row is less than zero, the [[Worksheet.defaultRowHeight]] of the
    * owning worksheet will be used as the row's height.
    * </p>
    * <p class="body">
    * The value assigned must be between -1 and 8192. Invalid values will be automatically adjusted to valid values.
    * </p>
    * The height of the row in twips (1/20th of a point).
    * @throws [[InvalidOperationException]] From the setter if the row was removed from the worksheet.
    */
    height: number;
    /**
     * @hidden
     */
    private _d8;
    /**
     * @hidden
     */
    _cs(a?: boolean): number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cm: number;
    /**
     * @hidden
     */
    readonly _br: SortedList$2<number, CellCalcReference[]>;
    /**
     * @hidden
     */
    readonly _bx: boolean;
    /**
     * @hidden
     */
    readonly _ah: WorksheetCellFormatBlock[];
    /**
     * @hidden
     */
    readonly _by: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bz: boolean;
    /**
     * @hidden
     */
    readonly _b0: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b1: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b4: boolean;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    readonly _m: boolean;
    /**
     * @hidden
     */
    readonly _au: GenericCachedCollection$1<StringElement>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _b2;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b6: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _b5;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b3: boolean;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * @hidden
 */
export interface IWorksheetProvider {
    readonly worksheet: Worksheet;
}
/**
 * @hidden
 */
export declare let IWorksheetProvider_$type: Type;
/**
 * @hidden
 */
export interface ISortSettingsOwner extends IWorkbookProvider, IWorksheetProvider {
    onSortSettingsModified(): void;
    readonly culture: string | CultureInfo;
    readonly _culture$i: CultureInfo;
    readonly sortRegion: WorksheetRegion;
}
/**
 * @hidden
 */
export declare let ISortSettingsOwner_$type: Type;
/**
 * @hidden
 */
export interface ISupportFormulaShifts {
    shiftFormulas(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    undoFormulaShift(a: any, b: string): string;
}
/**
 * @hidden
 */
export declare let ISupportFormulaShifts_$type: Type;
/**
 * @hidden
 */
export declare class ConditionBase_RegionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionBase, c: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: ConditionBase;
    readonly c: string;
    readonly b: boolean;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Abstract base class which encapsulates the condition for a formatting rule.
 */
export declare abstract class ConditionBase extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a2: string;
    /**
     * @hidden
     */
    static readonly _az: string;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static _a;
    private _k;
    private _w;
    private _v;
    private _ap;
    private _aq;
    private _q;
    private _u;
    private _t;
    static staticInit(): void;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * Returns a reference to the associated worksheet.
     */
    readonly worksheet: Worksheet;
    /**
     * Returns a reference to the associated workbook.
     */
    readonly workbook: Workbook;
    /**
     * Returns the [[WorksheetRegion]] which identifies the cell range
     * with which this condition is associated.
     */
    readonly regions: ReadOnlyCollection$1<WorksheetRegion>;
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    readonly _x: boolean;
    /**
     * Returns a [[FormatConditionType]] value which identifies the
     * type of condition for this instance.
     */
    readonly conditionType: FormatConditionType;
    /**
     * @hidden
     */
    readonly _ag: boolean;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    readonly _j: FormatConditionNotificationType;
    /**
     * Returns or sets a value which determines the order of evaluation
     * when multiple conditional formatting rules exist.
     * <p class="body">
     * By default, <see cref="ConditionalFormatBase">conditions</see> are evaluated
     * in the order in which they appear within the containing
     * <see cref="ConditionalFormatCollection">collection</see>.
     * </p>
     * <p class="body">
     * This property makes it possible to weight one condition over another, essentially
     * overriding the condition's ordinal position within the collection.
     * </p>
     * <p class="body">
     * A lower number means a higher priority; for example, a condition with a
     * priority of 1 is evaluated before one with a priority of 2.
     * </p>
     * <p class="body">
     * If a cell value meets more than one condition, the format defined by the first
     * condition to be evaluated takes precedence.
     * </p>
     * <p class="body">
     * Setting the priority on one condition may cause the value of other conditions
     * in the collection to be changed to ensure that each condition has a unique value.
     * </p>
     */
    /**
    * Returns or sets a value which determines the order of evaluation
    * when multiple conditional formatting rules exist.
    * <p class="body">
    * By default, <see cref="ConditionalFormatBase">conditions</see> are evaluated
    * in the order in which they appear within the containing
    * <see cref="ConditionalFormatCollection">collection</see>.
    * </p>
    * <p class="body">
    * This property makes it possible to weight one condition over another, essentially
    * overriding the condition's ordinal position within the collection.
    * </p>
    * <p class="body">
    * A lower number means a higher priority; for example, a condition with a
    * priority of 1 is evaluated before one with a priority of 2.
    * </p>
    * <p class="body">
    * If a cell value meets more than one condition, the format defined by the first
    * condition to be evaluated takes precedence.
    * </p>
    * <p class="body">
    * Setting the priority on one condition may cause the value of other conditions
    * in the collection to be changed to ensure that each condition has a unique value.
    * </p>
    */
    priority: number;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    readonly _ah: boolean;
    /**
     * @hidden
     */
    protected get__ai(): boolean;
    /**
     * @hidden
     */
    readonly _ai: boolean;
    /**
     * Returns or sets a boolean indicating whether additional formatting rules
     * are evaluated if this rule evaluates to true. Applicable only in the case
     * where the containing <see cref="ConditionalFormatCollection">collection</see>
     * contains more than one element.
     * <p class="body">
     * If a cell value meets more than one condition, the format defined by the
     * first condition takes precedence. Individual format properties are "merged"
     * during the resolution process; for example, if one format has red borders
     * and another has a red foreground color, a cell value which meets both conditions
     * may be formatted with both red borders <b>and</b> a red foreground color.
     * </p>
     * <p class="body">
     * This property makes it possible to short-circuit the resolution process, so that
     * no other conditional formats are applied after the first condition evaluates to true.
     * </p>
     * <p class="body">
     * Using the above example, assume <i>StopIfTrue</i> is set to a value of true on the
     * conditional format with red borders, a second conditional format exists with a red
     * foreground color, and a cell value meets both conditions. Because the StopIfTrue
     * setting prevents additional formats from being evaluated, the cell will not show
     * a red foreground color, whereas with <i>StopIfTrue</i> being set to false, it
     * would show both red borders and a red foreground color.
     * </p>
     * <p class="body">
     * In addition to preventing subsequent conditions from being evaluated, the order
     * in which conditions are evaluated can be controlled using the [[priority]]
     * property.
     * </p>
     */
    /**
    * Returns or sets a boolean indicating whether additional formatting rules
    * are evaluated if this rule evaluates to true. Applicable only in the case
    * where the containing <see cref="ConditionalFormatCollection">collection</see>
    * contains more than one element.
    * <p class="body">
    * If a cell value meets more than one condition, the format defined by the
    * first condition takes precedence. Individual format properties are "merged"
    * during the resolution process; for example, if one format has red borders
    * and another has a red foreground color, a cell value which meets both conditions
    * may be formatted with both red borders <b>and</b> a red foreground color.
    * </p>
    * <p class="body">
    * This property makes it possible to short-circuit the resolution process, so that
    * no other conditional formats are applied after the first condition evaluates to true.
    * </p>
    * <p class="body">
    * Using the above example, assume <i>StopIfTrue</i> is set to a value of true on the
    * conditional format with red borders, a second conditional format exists with a red
    * foreground color, and a cell value meets both conditions. Because the StopIfTrue
    * setting prevents additional formats from being evaluated, the cell will not show
    * a red foreground color, whereas with <i>StopIfTrue</i> being set to false, it
    * would show both red borders and a red foreground color.
    * </p>
    * <p class="body">
    * In addition to preventing subsequent conditions from being evaluated, the order
    * in which conditions are evaluated can be controlled using the [[priority]]
    * property.
    * </p>
    */
    stopIfTrue: boolean;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    readonly _al: boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    readonly _am: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _af: boolean;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    readonly _z: boolean;
    /**
     * @hidden
     */
    readonly _ao: string;
    /**
     * @hidden
     */
    static _an(a: Worksheet): string;
    /**
     * @hidden
     */
    _g(a: IEnumerable$1<WorksheetRegion>, b?: boolean): ConditionBase;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _h(): ConditionBase;
    /**
     * @hidden
     */
    abstract _a5(): void;
    /**
     * @hidden
     */
    _y(a: number, b: number, c: boolean): boolean;
    /**
     * @hidden
     */
    _a6(a: IEnumerable$1<WorksheetRegionAddress>): void;
    /**
     * @hidden
     */
    static _at(a: Workbook, b: any): number;
    /**
     * @hidden
     */
    static _as(a: Workbook, b: any, c: RefBase, d: SingleTargetFormula): number;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: number, c: number, d: RefBase): {
        ret: number;
        p3?: RefBase;
    };
    /**
     * @hidden
     */
    _s(): WorksheetCellAddress;
    /**
     * @hidden
     */
    _p(): Workbook;
    /**
     * @hidden
     */
    static _aa(a: Formula, b: Worksheet): boolean;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    private _a8;
    /**
     * @hidden
     */
    _ac(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _ab(a: WorksheetRegionAddress[]): boolean;
    /**
     * @hidden
     */
    _ad(a: number, b: number): boolean;
    /**
     * @hidden
     */
    static _ae(a: number): boolean;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    abstract _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _ba(): void;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bc(): void;
    /**
     * @hidden
     */
    _be(a: string): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _o(a: string, b: Nullable$1<CellReferenceMode>): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: SingleTargetFormula): SingleTargetFormula;
    /**
     * @hidden
     */
    static _n(a: string, b: Workbook, c: Nullable$1<CellReferenceMode>, d?: FormulaType, e?: number, f?: number, g?: List$1<WorkbookReferenceBase>): SingleTargetFormula;
    /**
     * @hidden
     */
    _bh(a: WorksheetCellAddress, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _bi(a: string): void;
    /**
     * @hidden
     */
    _bj(): void;
    /**
     * @hidden
     */
    _bk(a: Worksheet, b: WorksheetRegionAddress[]): void;
    /**
     * @hidden
     */
    private _bl;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _bs(a: IEnumerable$1<WorksheetRegionAddress>): void;
    /**
     * Sets the [[priority]] value for this rule such that it
     * is the first condition to be evaluated. Applicable only in the case
     * where there is more than one element contained within the associated
     * <see cref="ConditionalFormatCollection">collection</see>.
     * <p class="body">
     * When multiple <see cref="ConditionalFormatBase">conditions</see> exist
     * in the same <see cref="ConditionalFormatCollection">collection</see>,
     * the order in which they are evaluated has bearing on which format is applied
     * to cells which meet those conditions.
     * </p>
     * <p class="body">
     * This method ensures that the associated condition is the first one to be
     * evaluated.
     * </p>
     * <p class="body">
     * To make a condition the last one to be evaluated, use the [[setLastPriority]]
     * method.
     * </p>
     * @see [[priority]]
     * @see [[setLastPriority]]
     */
    setFirstPriority(): void;
    /**
     * Sets the [[priority]] value for this rule such that it
     * is the last condition to be evaluated. Applicable only in the case
     * where there is more than one element contained within the associated
     * [[ConditionalFormatCollection]].
     * <p class="body">
     * Just as the [[setFirstPriority]] method ensures that the associated
     * condition is evalulated first, the <i>SetLastPriority</i> method ensures that
     * the associated condition is evaluated last.
     * </p>
     * <p class="body">
     * Calling this method on more than one condition essentially replaces the previously
     * designated condition as the last one to be evaluated with this one.
     * </p>
     * @see [[priority]]
     * @see [[setLastPriority]]
     * @see [[stopIfTrue]]
     */
    setLastPriority(): void;
    /**
     * Replaces the existing regions with new ones
     * @param regionAddress A string with one or more comma separated region address
     * @param cellReferenceMode An optional cell reference mode
     * @throws [[ArgumentException]] If regionAddress is invalid or contains a region from another worksheet
     */
    setRegions(regionAddress: string, cellReferenceMode: CellReferenceMode | null): void;
    /**
     * @hidden
     */
    _setRegions$i(a: string, b: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _aj(a: boolean, b: CellShiftOperation, c: ICellShiftOperationOverride, d: List$1<WorksheetRegionAddress>): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _bp(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: any, c: SingleTargetFormula, d: CellShiftOperation, e: ICellShiftOperationOverride): {
        p2?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    _a0(a?: CellReferenceMode, b?: boolean): string;
    /**
     * @hidden
     */
    static _a1(a: Worksheet, b: IList$1<WorksheetRegion>, c?: CellReferenceMode, d?: boolean, e?: boolean, f?: IList$1<string>, g?: Nullable$1<string>): string;
    /**
     * @hidden
     */
    static _c(a: Nullable$1<CellReferenceMode>, b: Workbook): CellReferenceMode;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * @hidden
     */
    _a3(a: string, b: SingleTargetFormula): {
        ret: string;
        p1?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    private static _br;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * @hidden
 */
export declare class Worksheet_CellCommentDeleteChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<KeyValuePair$2<WorksheetCellAddress, WorksheetCellComment>>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: Worksheet;
    readonly a: KeyValuePair$2<WorksheetCellAddress, WorksheetCellComment>[];
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class Worksheet_CellInsertDeleteChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: WorksheetRegionAddress, d: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: Worksheet;
    readonly b: WorksheetRegionAddress;
    readonly c: boolean;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export interface IWorksheetElementResizeContext {
    readonly hasHiddenChanges: boolean;
}
/**
 * @hidden
 */
export declare let IWorksheetElementResizeContext_$type: Type;
/**
 * @hidden
 */
export declare class Worksheet_HideUnhideChangeContext extends ValueType implements IChangeInfoContext, IWorksheetRegionAddressContext, IWorksheetElementResizeContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: number, d: number, e: boolean, f: boolean, g: List$1<IndexRange>, h: WorksheetResizeInfo);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    private readonly f;
    private readonly g;
    private readonly d;
    private readonly h;
    private c;
    private readonly e;
    i(): string;
    private b;
    j(a: ChangeInfo, b: boolean): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
    getRegionAddress(): WorksheetRegionAddress;
    readonly hasHiddenChanges: boolean;
}
/**
 * @hidden
 */
export declare class Worksheet_SharedFormulaGroupChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRegionAddress, c: any, d: Worksheet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly b;
    private readonly a;
    d(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class Worksheet_SharedFormulasShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<KeyValuePair$2<any, WorksheetRegionAddress>>, d: List$1<KeyValuePair$2<any, WorksheetRegionAddress>>, e: List$1<any>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly d;
    private readonly b;
    private readonly c;
    private readonly a;
    e(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class Worksheet_ResizeItemChangeContext extends ValueType implements IChangeInfoContext, IWorksheetRegionAddressContext, IWorksheetElementResizeContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<WorksheetElementResizeState>, d: boolean, e: WorksheetResizeInfo, f: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    private readonly e;
    private readonly d;
    private readonly b;
    private readonly c;
    f(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
    getRegionAddress(): WorksheetRegionAddress;
    readonly hasHiddenChanges: boolean;
}
/**
 * @hidden
 */
export declare class WorksheetShapePosition extends Base {
    static $t: Type;
    e: Point;
    d: Point;
    b: WorksheetCellAddress;
    a: WorksheetCellAddress;
    constructor(a: WorksheetShape);
    c(a: WorksheetShape): void;
}
/**
 * @hidden
 */
export declare class WorksheetResizeInfo extends Base {
    static $t: Type;
    private c;
    private d;
    private b;
    constructor();
    h(): void;
    private static e;
    private static g;
    private static a;
    i(a: WorksheetShape, b: Rect): void;
    j(): void;
}
/**
 * Represents one worksheet in a Microsoft Excel workbook.
 * <p class="body">
 * An Excel worksheet is essentially a table with a limited number of rows and columns. To create new worksheet, use
 * [[WorksheetCollection.add]] method of the [[Workbook.worksheets]]
 * collection on a [[Workbook]] instance.
 * </p>
 */
export declare class Worksheet extends Sheet implements IWorksheetShapeOwner, ISortSettingsOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _fz;
    /**
     * @hidden
     */
    private static readonly _f2;
    /**
     * @hidden
     */
    private static readonly _f3;
    /**
     * @hidden
     */
    private static readonly _f4;
    /**
     * @hidden
     */
    private static readonly _f5;
    /**
     * @hidden
     */
    private static readonly _gi;
    /**
     * @hidden
     */
    private static readonly _gj;
    /**
     * @hidden
     */
    private static readonly _gk;
    /**
     * @hidden
     */
    private static readonly _gn;
    /**
     * @hidden
     */
    private static readonly _gx;
    /**
     * @hidden
     */
    private static readonly _gy;
    /**
     * @hidden
     */
    private static readonly _gz;
    /**
     * @hidden
     */
    private static readonly _gv;
    /**
     * @hidden
     */
    static readonly _gw: number;
    /**
     * @hidden
     */
    private static readonly _gs;
    /**
     * @hidden
     */
    private static readonly _gu;
    /**
     * @hidden
     */
    private static readonly _gt;
    /**
     * @hidden
     */
    private static readonly _f7;
    /**
     * @hidden
     */
    private static readonly _f6;
    /**
     * @hidden
     */
    private static readonly _gr;
    /**
     * @hidden
     */
    static _ax: ChangeInfo[];
    private _fa;
    private _er;
    private _et;
    private _ev;
    private _ce;
    private _cg;
    private _fx;
    private _go;
    private _gq;
    private _f0;
    private _du;
    private _ci;
    private _jd;
    private _cs;
    private _bn;
    /**
     * @hidden
     */
    readonly _c7: WorksheetRowCollection;
    private _db;
    private _bq;
    private _el;
    private _bj;
    /**
     * @hidden
     */
    _d7: boolean;
    private _df;
    private _fb;
    private _fe;
    private _ej;
    private _b1;
    private _bw;
    private _g2;
    private _e5;
    private _e6;
    private _dj;
    private _dk;
    private _ay;
    private _az;
    private _dn;
    /**
     * @hidden
     */
    _g1: Nullable$1<WorksheetRegionAddress>;
    private _cl;
    private _e9;
    private readonly _cu;
    private _jf;
    private _e4;
    /**
     * @hidden
     */
    readonly _eq: Dictionary$2<any, WorksheetRegionAddress>;
    private _bl;
    private _bs;
    private _di;
    /**
     * @hidden
     */
    readonly _bp: RegionLookupTable$1<WorksheetShape>;
    private _bg;
    private _bu;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    readonly culture: string | CultureInfo;
    /**
     * @hidden
     */
    readonly _culture$i: CultureInfo;
    /**
     * @hidden
     */
    readonly sortRegion: WorksheetRegion;
    /**
     * @hidden
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly areChildrenTopMost: boolean;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * Clears all conditional formatting rules from the [[Worksheet]] so they do not get saved.
     * <para class="note"><b>Note:</b> this method is obsolete. Use the Worksheet.ConditionalFormats.Clear() method instead.</para>
     */
    clearConditionalFormattingData(): void;
    /**
     * Deletes a region of cells.
     * @param region The region to delete
     * @param shiftCellsLeft If true will shift cells left from the right of the region to occupy the deleted region, otherwise will shift cells up from below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[ArgumentNullException]] If region is null.
     * @see [[deleteCells]]
     * @see [[insertCells]]
     * @see [[insertCells]]
     */
    deleteCells(region: WorksheetRegion, shiftCellsLeft: boolean): void;
    /**
     * Deletes a region of cells.
     * @param address The address of the region to delete
     * @param shiftCellsLeft If true will shift cells left from the right of the region to occupy the deleted region, otherwise will shift cells up from below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[ArgumentException]] If address is not valid.
     * @see [[deleteCells]]
     * @see [[insertCells]]
     * @see [[insertCells]]
     */
    deleteCells(address: string, shiftCellsLeft: boolean): void;
    /**
     * @hidden
     */
    _deleteCells(a: WorksheetRegion, b: boolean): void;
    /**
     * @hidden
     */
    _deleteCells3(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _he(a: WorksheetRegionAddress, b: boolean): void;
    /**
     * @hidden
     */
    private _hf;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the cell address.
     * </p>
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param cellReferenceMode The cell reference mode to use to parse the cell address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, cellReferenceMode: CellReferenceMode): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param cellReferenceMode The cell reference mode to use to parse the cell address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the cell address.
     * </p>
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, originCell: WorksheetCell): WorksheetCell;
    /**
     * @hidden
     */
    _getCell(a: string): WorksheetCell;
    /**
     * @hidden
     */
    _getCell1(a: string, b: CellReferenceMode): WorksheetCell;
    /**
     * @hidden
     */
    _getCell3(a: string, b: WorksheetCell): WorksheetCell;
    /**
     * @hidden
     */
    _getCell2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetCell;
    /**
     * Gets the cell conditional format for the cell at the specified row and column index.
     * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of thse criteria an instance of [[CellConditionalFormat]]
     * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
     * conditional format region then this method will return null.</para>
     * @param rowIndex The 0-based index of the WorksheetRow within the [[rows]] collection.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'rowIndex' is less than zero or greater than or equal to the number of rows in the worksheet.
     * 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
     * @see [[conditionalFormats]]
     * @see [[CellConditionalFormat]]
     */
    getCellConditionalFormat(rowIndex: number, columnIndex: number): CellConditionalFormat;
    /**
     * @hidden
     */
    _getCellConditionalFormat1(a: number, b: number): CellConditionalFormat;
    /**
     * @hidden
     */
    private static _e8;
    /**
     * @hidden
     */
    _be(a: number, b: number, c: boolean): CellConditionalFormat;
    /**
     * Gets the default column width in the specified units.
     * <p class="body">
     * If 'units' is Character256th, the value returned will be the same as the value of the
     * [[defaultColumnWidth]] property.
     * </p>
     * @param units The units in which the width should be returned.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @return The default column width in the specified units.
     * @see [[defaultColumnWidth]]
     * @see [[setDefaultColumnWidth]]
     * @see [[WorksheetColumn.getWidth]]
     */
    getDefaultColumnWidth(units: WorksheetColumnWidthUnit): number;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, cellReferenceMode: CellReferenceMode): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, originCell: WorksheetCell): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion(a: string): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion1(a: string, b: CellReferenceMode): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion3(a: string, b: WorksheetCell): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetRegion;
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, cellReferenceMode: CellReferenceMode): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, originCell: WorksheetCell): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions(a: string): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions1(a: string, b: CellReferenceMode): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions3(a: string, b: WorksheetCell): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetRegion[];
    /**
     * Inserts a region of cells.
     * @param region The region to insert
     * @param shiftCellsRight If true will shift existing cells right to make room for the newly inserted cells, otherwise will shift existing cells down below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[ArgumentNullException]] If region is null.
     * @see [[insertCells]]
     * @see [[deleteCells]]
     * @see [[deleteCells]]
     */
    insertCells(region: WorksheetRegion, shiftCellsRight: boolean): void;
    /**
     * Inserts a region of cells.
     * @param address The region to insert
     * @param shiftCellsRight If true will shift existing cells right to make room for the newly inserted cells, otherwise will shift existing cells down below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[ArgumentException]] If address is not valid.
     * @see [[insertCells]]
     * @see [[deleteCells]]
     * @see [[deleteCells]]
     */
    insertCells(address: string, shiftCellsRight: boolean): void;
    /**
     * @hidden
     */
    _insertCells(a: WorksheetRegion, b: boolean): void;
    /**
     * @hidden
     */
    _insertCells3(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _hr(a: WorksheetRegionAddress, b: boolean): void;
    /**
     * @hidden
     */
    private _hs;
    /**
     * Hides the columns in the specified range.
     * @param startIndex The index of the first column to hide, or null to start hiding at the first column.
     * @param count The number of columns to hide. If null, a single column will be hidden when 'startIndex' is specified and
     * otherwise, all columns will be hidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
     */
    hideColumns(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _hideColumns$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Hides the rows in the specified range.
     * @param startIndex The index of the first row to hide, or null to start hiding at the first row.
     * @param count The number of rows to hide. If null, a single row will be hidden when 'startIndex' is specified and
     * otherwise, all rows will be hidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
     */
    hideRows(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _hideRows$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Moves the worksheet to a new position in the owning workbook's collections of worksheets.
     * @param index The new 0-based index to where the worksheet should be moved.
     * @throws [[InvalidOperationException]] The worksheet has previously been removed from its workbook.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of worksheets in the owning workbook.
     * @see [[Workbook.worksheets]]
     * @see [[WorksheetCollection.indexOf]]
     * @see [[index]]
     */
    moveToIndex(index: number): void;
    /**
     * Protects the worksheet without a password.
     * <p class="body">When a Worksheet is protected without a password, the end user may unprotect the Worksheet in Excel without
     * having to supply a password. To programatically unprotect a Worksheet, one may use the Unprotect() method.</p>
     * <p class="body">The optional parameters are used to update the property values of the [[WorksheetProtection]] instance from
     * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
     * be retained; otherwise the property will be updated with the specified value. For example, if the [[WorksheetProtection.allowDeletingColumns]]
     * is currently true and the 'allowDeletingColumns' is null, then the property will continue to be true but if the
     * 'allowDeletingColumns' is false the [[WorksheetProtection.allowDeletingColumns]] will be changed to false.</p>
     * <p class="body">When one protects a Worksheet in Excel, the UI allows one to choose which cells may be selected. To affect this state one would
     * change the [[WorksheetProtection.selectionMode]] property before or after protecting the Worksheet.</p>
     * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
     * @param allowDeletingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingColumns]].
     * @param allowDeletingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingRows]].
     * @param allowEditObjects Optional boolean indicating the new value for the [[WorksheetProtection.allowEditObjects]].
     * @param allowEditScenarios Optional boolean indicating the new value for the [[WorksheetProtection.allowEditScenarios]].
     * @param allowFiltering Optional boolean indicating the new value for the [[WorksheetProtection.allowFiltering]].
     * @param allowFormattingCells Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingCells]].
     * @param allowFormattingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingColumns]].
     * @param allowFormattingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingRows]].
     * @param allowInsertingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingColumns]].
     * @param allowInsertingHyperlinks Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingHyperlinks]].
     * @param allowInsertingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingRows]].
     * @param allowSorting Optional boolean indicating the new value for the [[WorksheetProtection.allowSorting]].
     * @param allowUsingPivotTables Optional boolean indicating the new value for the [[WorksheetProtection.allowUsingPivotTables]].
     * @see@see@see [[protection]]
     * @see [[WorksheetProtection]]
     * @see */
    protect(allowDeletingColumns?: boolean, allowDeletingRows?: boolean, allowEditObjects?: boolean, allowEditScenarios?: boolean, allowFiltering?: boolean, allowFormattingCells?: boolean, allowFormattingColumns?: boolean, allowFormattingRows?: boolean, allowInsertingColumns?: boolean, allowInsertingHyperlinks?: boolean, allowInsertingRows?: boolean, allowSorting?: boolean, allowUsingPivotTables?: boolean): void;
    /**
     * @hidden
     */
    _protect$i(a?: Nullable$1<boolean>, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>, d?: Nullable$1<boolean>, e?: Nullable$1<boolean>, f?: Nullable$1<boolean>, g?: Nullable$1<boolean>, h?: Nullable$1<boolean>, i?: Nullable$1<boolean>, j?: Nullable$1<boolean>, k?: Nullable$1<boolean>, l?: Nullable$1<boolean>, m?: Nullable$1<boolean>): void;
    /**
     * Sets the default column width in the specified units.
     * @param value The default column width to set on the worksheet, expressed in the specified 'units'.
     * @param units The units in which the 'value' is expressed.
     * @throws [[ArgumentException]] 'value' is infinity or NaN.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @see [[defaultColumnWidth]]
     * @see [[getDefaultColumnWidth]]
     * @see [[WorksheetColumn.setWidth]]
     */
    setDefaultColumnWidth(value: number, units: WorksheetColumnWidthUnit): void;
    /**
     * @hidden
     */
    _iq(a: number, b: WorksheetColumnWidthUnit, c: boolean, d: boolean): void;
    /**
     * Unhides the columns in the specified range.
     * @param startIndex The index of the first column to unhide, or null to start unhiding at the first column.
     * @param count The number of columns to unhide. If null, a single column will be unhidden when 'startIndex' is specified and
     * otherwise, all columns will be unhidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
     */
    unhideColumns(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _unhideColumns$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Unhides the rows in the specified range.
     * @param startIndex The index of the first row to unhide, or null to start unhiding at the first row.
     * @param count The number of rows to unhide. If null, a single row will be unhidden when 'startIndex' is specified and
     * otherwise, all rows will be unhidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
     */
    unhideRows(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _unhideRows$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * @hidden
     */
    _g5(a: WorksheetRegion, b: WorksheetRegion, c?: boolean): {
        p1: WorksheetRegion;
    };
    /**
     * @hidden
     */
    _dp(a: number, b: number, c: number): boolean;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    _g6(a: PivotTableInfo): void;
    /**
     * @hidden
     */
    _g7(a: BinaryData): void;
    /**
     * @hidden
     */
    _hc(): void;
    /**
     * @hidden
     */
    _a0(a: number, b: number): WorksheetColumnBlock[];
    /**
     * @hidden
     */
    _fj(a: number): number;
    /**
     * @hidden
     */
    _fk(a: number, b: boolean): number;
    /**
     * @hidden
     */
    _fl(a: number, b: WorksheetColumnWidthUnit, c?: boolean): number;
    /**
     * @hidden
     */
    _fm(a: number): number;
    /**
     * @hidden
     */
    _fn(a: number): number;
    /**
     * @hidden
     */
    _fw(a: number, b: WorksheetColumnWidthUnit, c?: boolean): number;
    /**
     * @hidden
     */
    _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    _f(): PrintOptionsBase;
    /**
     * @hidden
     */
    _b6(a: number, b: number, c: number): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _hh(): void;
    /**
     * @hidden
     */
    _hi(a: WorksheetRegionAddress, b?: HashSet$1<WorksheetMergedCellsRegion>): {
        p0?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _cw(a: WorksheetRegionAddress): WorksheetRegion;
    /**
     * @hidden
     */
    _cx(a: number, b: number, c: number, d: number): WorksheetRegion;
    /**
     * @hidden
     */
    _de(a: number, b: number): WorksheetTable;
    /**
     * @hidden
     */
    _b4(a: WorksheetRow, b: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _ck(a: WorksheetRow, b: number, c: number): WorksheetHyperlink;
    /**
     * @hidden
     */
    _cb(a: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _f9(a: number): number;
    /**
     * @hidden
     */
    _cn(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _co(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _e1(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _e0(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    private __ex;
    _ex(a: number, b: number, c: boolean): IEnumerable$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _gb(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _ga(a: WorksheetColumnBlock, b?: boolean): number;
    /**
     * @hidden
     */
    _gd(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _gc(a: WorksheetColumnBlock, b: boolean): number;
    /**
     * @hidden
     */
    _fp(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _fo(a: WorksheetColumnBlock, b: boolean): number;
    /**
     * @hidden
     */
    _fq(a: number, b: number, c?: boolean): number;
    /**
     * @hidden
     */
    _ge(): number;
    /**
     * @hidden
     */
    _cr(a: number, b: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _ey(): IEnumerable$1<PivotTableInfo>;
    /**
     * @hidden
     */
    _gh(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _gg(a: WorksheetRow, b: boolean): number;
    /**
     * @hidden
     */
    _fs(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _ft(a: number, b: number, c: boolean): number;
    /**
     * @hidden
     */
    _cp(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _cq(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _e3(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _e2(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _da(a: number, b: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p1: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    static _c9(a: WorksheetShapeCollection, b: number, c: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p2: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    _c2(a: Formula): WorksheetRegion;
    /**
     * @hidden
     */
    _c3(a: any): WorksheetRegion;
    /**
     * @hidden
     */
    _ez(): IEnumerable$1<BinaryData>;
    /**
     * @hidden
     */
    _fg(): List$1<IEscherRecord>;
    /**
     * @hidden
     */
    static _hm(a: WorksheetShapeCollection, b: List$1<IEscherRecord>): void;
    /**
     * @hidden
     */
    _b5(a: WorksheetCellFormatData, b: number, c: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _c4(a: number, b: number, c: number, d: number, e: boolean): WorksheetRegionAddress;
    /**
     * @hidden
     */
    _dd(a: WorksheetTable, b: boolean, c: string, d?: Nullable$1<CellReferenceMode>, e?: boolean): WorksheetTable;
    /**
     * @hidden
     */
    _g8(): void;
    /**
     * @hidden
     */
    _b7(a: number, b: number, c: number, d: CellShiftInitializeFormatType): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _ec(a: number): boolean;
    /**
     * @hidden
     */
    _ed(a: number, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _eg(a: number): boolean;
    /**
     * @hidden
     */
    _ef(a: WorksheetRow): boolean;
    /**
     * @hidden
     */
    _hw(a: number, b: number, c: number, d: boolean, e: number, f: WorksheetCellFormatData, g?: boolean): void;
    /**
     * @hidden
     */
    _hx(a: number, b: number): void;
    /**
     * @hidden
     */
    _hy(a: number, b: number): void;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _hz(a: boolean): void;
    /**
     * @hidden
     */
    _h0(): void;
    /**
     * @hidden
     */
    _aq(): void;
    /**
     * @hidden
     */
    _h2(a: Formula, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _h3(a: Formula, b?: boolean): void;
    /**
     * @hidden
     */
    _g4(a: ExcelChangeAction, b?: string): any;
    /**
     * @hidden
     */
    _h4(a: any): void;
    /**
     * @hidden
     */
    _h5(): void;
    /**
     * @hidden
     */
    _h7(): void;
    /**
     * @hidden
     */
    private _h6;
    /**
     * @hidden
     */
    _ia(a: WorksheetColumnBlock[]): void;
    /**
     * @hidden
     */
    private _h9;
    /**
     * @hidden
     */
    _ib(a: number, b: number, c: List$1<IFilterable>): void;
    /**
     * @hidden
     */
    _ic(a: WorksheetRegionAddress): {
        p0?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _ei(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _ie(): void;
    /**
     * @hidden
     */
    _ig(): void;
    /**
     * @hidden
     */
    _ih(a: WorksheetRegionAddress, b?: HashSet$1<WorksheetMergedCellsRegion>): void;
    /**
     * @hidden
     */
    _ii(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _ik(a: List$1<IndexRange>, b: number): void;
    /**
     * @hidden
     */
    _il(a: List$1<WorksheetElementResizeState>, b: WorksheetResizeInfo): void;
    /**
     * @hidden
     */
    _im(a: List$1<IndexRange>, b: number): void;
    /**
     * @hidden
     */
    _io(a: List$1<WorksheetElementResizeState>, b: WorksheetResizeInfo): void;
    /**
     * @hidden
     */
    _b8(a: CellShiftOperation, b: CellShiftInitializeFormatType, c?: ICellShiftOperationOverride, d?: boolean): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _b9(a: number, b: number, c: number, d: number, e: number, f: CellShiftInitializeFormatType): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _cc(a: number, b: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _en(a: WorksheetRow, b: number, c: Date, d?: boolean): {
        ret: boolean;
        p2: Date;
    };
    /**
     * @hidden
     */
    _cd(a: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _bi(a: number, b: number): DataValidationRule;
    /**
     * @hidden
     */
    _eo(a: WorksheetRow, b: number, c: number): {
        ret: boolean;
        p0?: WorksheetRow;
        p1?: number;
        p2?: number;
    };
    /**
     * @hidden
     */
    _a7(a: number, b: number, c: number, d: number, e: number, f: CellShiftType): CellShiftResult;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    private _ep;
    /**
     * @hidden
     */
    _av(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _jc(a: Formula, b: WorksheetRow, c: number): void;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private _fu;
    /**
     * @hidden
     */
    private _ha;
    /**
     * @hidden
     */
    _g9(): void;
    /**
     * @hidden
     */
    private static _a9;
    /**
     * @hidden
     */
    private static _a8;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _bb;
    /**
     * @hidden
     */
    private static _bc;
    /**
     * @hidden
     */
    private static _bd;
    /**
     * @hidden
     */
    private static _a1;
    /**
     * @hidden
     */
    private _hj;
    /**
     * @hidden
     */
    private _f8;
    /**
     * @hidden
     */
    private _hk;
    /**
     * @hidden
     */
    private _hl;
    /**
     * @hidden
     */
    private static _gf;
    /**
     * @hidden
     */
    private _hp;
    /**
     * @hidden
     */
    private _hu;
    /**
     * @hidden
     */
    _h1(): void;
    /**
     * @hidden
     */
    private _id;
    /**
     * @hidden
     */
    private static _i4;
    /**
     * @hidden
     */
    private static _i2;
    /**
     * @hidden
     */
    private static _i3;
    /**
     * @hidden
     */
    private static _i5;
    /**
     * @hidden
     */
    private static _i6;
    /**
     * @hidden
     */
    private static _i7;
    /**
     * @hidden
     */
    private static _i8;
    /**
     * @hidden
     */
    private static _jb;
    /**
     * Gets the column at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    columns(index: number): WorksheetColumn;
    /**
     * Gets the collection of columns in the worksheet.
     * <p class="body">
     * The collection of columns is a fixed length collection, with the maximum number of columns in the collection being
     * [[Workbook.maxExcelColumnCount]] or [[Workbook.maxExcel2007ColumnCount]],
     * depending on the <see cref="Excel.Workbook.CurrentFormat">Workbook.CurrentFormat</see>. Internally, the columns
     * are only created and added to the collection when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The collection of columns in the worksheet.
     * @see [[WorksheetColumn]]
     */
    columns(): WorksheetColumnCollection;
    /**
     * @hidden
     */
    readonly _columns$i: WorksheetColumnCollection;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    conditionalFormats(index: number): ConditionBase;
    /**
     * Returns a <see cref="ConditionalFormatting.ConditionalFormatCollection">collection</see>
     * to which <see cref="ConditionalFormatting.ConditionBase">conditions</see> can be added to
     * control the visual attributes of a [[WorksheetCell]] based on user-defined criteria.
     * @see [[ConditionalFormatCollection]]
     * @see [[ConditionalFormatCollection.addAverageCondition]]
     * @see [[ConditionalFormatCollection.addBlanksCondition]]
     * @see [[ConditionalFormatCollection.addColorScaleCondition]]
     * @see [[ConditionalFormatCollection.addDataBarCondition]]
     * @see [[ConditionalFormatCollection.addDateTimeCondition]]
     * @see [[ConditionalFormatCollection.addDuplicateCondition]]
     * @see [[ConditionalFormatCollection.addErrorsCondition]]
     * @see [[ConditionalFormatCollection.addFormulaCondition]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     * @see [[ConditionalFormatCollection.addNoBlanksCondition]]
     * @see [[ConditionalFormatCollection.addNoErrorsCondition]]
     * @see [[ConditionalFormatCollection.addOperatorCondition]]
     * @see [[ConditionalFormatCollection.addRankCondition]]
     * @see [[ConditionalFormatCollection.addTextCondition]]
     * @see [[ConditionalFormatCollection.addUniqueCondition]]
     * @see [[ConditionBase]]
     */
    conditionalFormats(): ConditionalFormatCollection;
    /**
     * @hidden
     */
    readonly _conditionalFormats$i: ConditionalFormatCollection;
    /**
     * Gets the data table at the specified index in the collection.
     * The data table at the specified index.
     * @param index The zero-based index of the data table to get.
     */
    dataTables(index: number): WorksheetDataTable;
    /**
     * Gets the collection of data tables in the worksheet.
     * The collection of data tables in the worksheet.
     * @see [[WorksheetDataTable]]
     */
    dataTables(): WorksheetDataTableCollection;
    /**
     * @hidden
     */
    readonly _dataTables$i: WorksheetDataTableCollection;
    /**
     * @hidden
     */
    readonly _d5: boolean;
    /**
     * Gets or sets the references which have the data validation rule applied to it.
     * @param rule A data validation rule.
     * @throws [[ArgumentNullException]] Occurs when the 'rule' is null.
     * @throws [[KeyNotFoundException]] Occurs when the property is retrieved and the 'rule' is not applied to the [[worksheet]].
     * @throws [[ArgumentException]] Occurs when the property is set and the value is from a Worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the property is set and the 'rule' is invalid based on its rule type's requirements.
     */
    dataValidationRules(rule: DataValidationRule, value?: WorksheetReferenceCollection): WorksheetReferenceCollection;
    /**
     * Gets the collection of data validation rules applied to cells in the Worksheet.
     * @see [[DataValidationRule]]
     * @see [[WorksheetCell.dataValidationRule]]
     */
    dataValidationRules(): DataValidationRuleCollection;
    /**
     * @hidden
     */
    readonly _dataValidationRules$i: DataValidationRuleCollection;
    /**
     * @hidden
     */
    readonly _d6: boolean;
    /**
     * Gets or sets the default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * <p class="body">
     * The default column width is the width of all columns which do not have their width set.
     * </p>
     * <p class="body">
     * The value assigned must be between 0 and 65535. Invalid values will be automatically adjusted to valid values.
     * </p>
     * <p class="body">
     * Setting or getting this property is equivalent to calling [[setDefaultColumnWidth]]
     * or [[getDefaultColumnWidth]] using the [[WorksheetColumnWidthUnit]] value of Character256th.
     * </p>
     * The default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * @see [[getDefaultColumnWidth]]
     * @see [[setDefaultColumnWidth]]
     * @see [[WorksheetColumn.width]]
     * @see [[Workbook.characterWidth256thsToPixels]]
     * @see [[Workbook.pixelsToCharacterWidth256ths]]
     */
    /**
    * Gets or sets the default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
    * <p class="body">
    * The default column width is the width of all columns which do not have their width set.
    * </p>
    * <p class="body">
    * The value assigned must be between 0 and 65535. Invalid values will be automatically adjusted to valid values.
    * </p>
    * <p class="body">
    * Setting or getting this property is equivalent to calling [[setDefaultColumnWidth]]
    * or [[getDefaultColumnWidth]] using the [[WorksheetColumnWidthUnit]] value of Character256th.
    * </p>
    * The default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
    * @see [[getDefaultColumnWidth]]
    * @see [[setDefaultColumnWidth]]
    * @see [[WorksheetColumn.width]]
    * @see [[Workbook.characterWidth256thsToPixels]]
    * @see [[Workbook.pixelsToCharacterWidth256ths]]
    */
    defaultColumnWidth: number;
    /**
     * @hidden
     */
    private _ir;
    /**
     * @hidden
     */
    private _is;
    /**
     * Gets or sets the default row height in twips (1/20th of a point).
     * <p class="body">
     * The default row height is the height of all rows which do not have their height explicitly set
     * to a positive number.
     * </p>
     * <p class="body">
     * If the assigned value is -1, the default row height will then be calculated based on the default font
     * for the workbook, and subsequently getting this property will return the font-based default row height.
     * </p>
     * The default row height in twips (1/20th of a point).
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the value range of -1 and 8192.
     */
    /**
    * Gets or sets the default row height in twips (1/20th of a point).
    * <p class="body">
    * The default row height is the height of all rows which do not have their height explicitly set
    * to a positive number.
    * </p>
    * <p class="body">
    * If the assigned value is -1, the default row height will then be calculated based on the default font
    * for the workbook, and subsequently getting this property will return the font-based default row height.
    * </p>
    * The default row height in twips (1/20th of a point).
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the value range of -1 and 8192.
    */
    defaultRowHeight: number;
    /**
     * @hidden
     */
    private _it;
    /**
     * @hidden
     */
    readonly _d4: boolean;
    /**
     * Gets the object which controls the display of the worksheet.
     * <p class="body">
     * The display options include any settings which affect the display of the worksheet when viewed in Microsoft Excel.
     * These settings will not affect the printed worksheet or the data stored in the worksheet.
     * </p>
     * The object which controls the display of the worksheet.
     * @see [[CustomView.getDisplayOptions]]
     */
    readonly displayOptions: WorksheetDisplayOptions;
    /**
     * Exposes methods to identify a region in the worksheet and to apply filters and optionally sort criteria to that region.
     */
    readonly filterSettings: WorksheetFilterSettings;
    /**
     * Gets the hyperlink at the specified index in the collection.
     * The hyperlink at the specified index.
     * @param index The zero-based index of the hyperlink to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    hyperlinks(index: number): WorksheetHyperlink;
    /**
     * Gets the collection of hyperlinks applied to cells and regions in the Worksheet.
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetCell.getHyperlink]]
     * @see [[WorksheetRow.getCellHyperlink]]
     */
    hyperlinks(): WorksheetHyperlinkCollection;
    /**
     * @hidden
     */
    readonly _hyperlinks$i: WorksheetHyperlinkCollection;
    /**
     * @hidden
     */
    readonly _d8: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _je: WBitmap;
    /**
     * @hidden
     */
    private _iz;
    /**
     * Gets the zero-based index of this worksheet in its parent [[Workbook.worksheets]] collection.
     * <p class="body">
     * Negative one indicates the worksheet has been removed from its parent collection.
     * </p>
     * The zero-based index of this worksheet in its parent Worksheets collection.
     * @see [[WorksheetCollection.indexOf]]
     * @see [[moveToIndex]]
     */
    readonly index: number;
    /**
     * Gets the merged cell region at the specified index.
     * The merged cell region at the specified index.
     * @param index The zero-based index of the merged cell region to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    mergedCellsRegions(index: number): WorksheetMergedCellsRegion;
    /**
     * Gets the collection of merged cell ranges in this worksheet.
     * <p class="body">Use [[WorksheetMergedCellsRegionCollection.add]] method to add new merged cell ranges to the worksheet.</p>
     * The collection of merged cell ranges in this worksheet.
     * @see [[WorksheetMergedCellsRegion]]
     */
    mergedCellsRegions(): WorksheetMergedCellsRegionCollection;
    /**
     * @hidden
     */
    readonly _mergedCellsRegions$i: WorksheetMergedCellsRegionCollection;
    /**
     * @hidden
     */
    readonly _d9: boolean;
    /**
     * Gets the object which controls how the worksheet prints.
     * <p class="body">
     * The print options include any settings which affect the printed appearance of the worksheet.  These settings will
     * not affect the data in the worksheet.  Although these are not display settings, some worksheet display styles will
     * display all or some of the print options, so these settings may affect the display of the worksheet when viewed in
     * Microsoft Excel.
     * </p>
     * The object which controls how the worksheet prints.
     * @see [[CustomView.getPrintOptions]]
     */
    readonly printOptions: PrintOptions;
    /**
     * Returns an object that provides information used when the Worksheet has been protected.
     * @see@see@see [[WorksheetProtection]]
     * @see [[protect]]
     * @see */
    readonly protection: WorksheetProtection;
    /**
     * Gets the row at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelRowCount]]
     * or [[Workbook.maxExcel2007RowCount]], depending on the [[Workbook.currentFormat]].
     */
    rows(index: number): WorksheetRow;
    /**
     * Gets the collection of rows in the worksheet.
     * <p class="body">
     * The collection of rows is a fixed length collection, with the maximum number of rows in the collection being
     * [[Workbook.maxExcelRowCount]] or [[Workbook.maxExcel2007RowCount]],
     * depending on the <see cref="Excel.Workbook.CurrentFormat">Workbook.CurrentFormat</see>.  Internally, the rows are only created and added to the collection
     * when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The collection of rows in the worksheet.
     * @see [[WorksheetRow]]
     */
    rows(): WorksheetRowCollection;
    /**
     * @hidden
     */
    readonly _rows$i: WorksheetRowCollection;
    /**
     * Exposes methods to identify a region in the worksheet and to apply sort criteria to that region.
     */
    readonly sortSettings: WorksheetSortSettings;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    shapes(index: number): WorksheetShape;
    /**
     * Gets the collection of shapes on the worksheet.
     * The collection of shapes on the worksheet.
     * @see [[WorksheetShape]]
     */
    shapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _shapes$i: WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly ChildShapes: WorksheetShapeCollection;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    sparklineGroups(index: number): SparklineGroup;
    /**
     * Returns a collection of [[SparklineGroup]]s (read-only)
     */
    sparklineGroups(): SparklineGroupCollection;
    /**
     * @hidden
     */
    readonly _sparklineGroups$i: SparklineGroupCollection;
    /**
     * Gets the [[WorksheetTable]] at the specified index.
     * The WorksheetTable at the specified index.
     * @param index The zero-based index of the WorksheetTable to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    tables(index: number): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The WorksheetTable with the specified name.
     * @param name The name of the WorksheetTable to get.
     * @throws [[InvalidOperationException]] A WorksheetTable with the specified name does not exist in the collection.
     * @see [[NamedReferenceBase.name]]
     */
    tables(name: string): WorksheetTable;
    /**
     * Gets the collection of [[WorksheetTable]] instances, or regions formatted as tables, in the worksheet.
     * @see [[WorksheetTable]]
     */
    tables(): WorksheetTableCollection;
    /**
     * @hidden
     */
    readonly _tables$i: WorksheetTableCollection;
    /**
     * Returns a value indicating the type of sheet
     */
    protected get_type(): SheetType;
    /**
     * Returns a value indicating the type of sheet
     */
    readonly type: SheetType;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _dr: boolean;
    /**
     * @hidden
     */
    readonly _es: Dictionary$2<WorksheetCellAddress, WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    readonly _d1: boolean;
    /**
     * @hidden
     */
    readonly _fc: List$1<CellShiftOperation>;
    /**
     * @hidden
     */
    readonly _fv: number;
    /**
     * @hidden
     */
    readonly _eu: Dictionary$2<WorksheetCellAddress, WorksheetCellComment>;
    /**
     * @hidden
     */
    readonly _d2: boolean;
    /**
     * @hidden
     */
    readonly _ew: Dictionary$2<ValueTuple$2<WorksheetRow, number>, any>;
    /**
     * @hidden
     */
    readonly _d3: boolean;
    /**
     * @hidden
     */
    readonly _fd: List$1<WorksheetCell>;
    /**
     * @hidden
     */
    readonly _ff: List$1<WorksheetColumnBlock>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b2: WorksheetCellFormatData;
    /**
     * @hidden
     */
    readonly _b3: WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    readonly _e: DisplayOptionsBase;
    /**
     * @hidden
     */
    readonly _gp: number;
    /**
     * @hidden
     */
    _ij(): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ds: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _dt: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _dv: boolean;
    /**
     * @hidden
     */
    _iu(a: boolean, b?: boolean): void;
    private _dl;
    /**
     * @hidden
     */
    readonly _dw: boolean;
    /**
     * @hidden
     */
    _iv(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    private _iw;
    private _dm;
    /**
     * @hidden
     */
    readonly _dx: boolean;
    /**
     * @hidden
     */
    _ix(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    private _iy;
    /**
     * @hidden
     */
    _dy(a: RowColumnBase): boolean;
    /**
     * @hidden
     */
    _dz(a: boolean): boolean;
    /**
     * @hidden
     */
    private readonly _d0;
    /**
     * @hidden
     */
    readonly _ea: boolean;
    /**
     * @hidden
     */
    readonly _eb: boolean;
    /**
     * @hidden
     */
    readonly _gl: number;
    /**
     * @hidden
     */
    readonly _ee: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g3: any;
    /**
     * @hidden
     */
    protected get__g(): PrintOptionsBase;
    /**
     * @hidden
     */
    readonly _g: PrintOptionsBase;
    /**
     * @hidden
     */
    _dh: ImageFormat;
    /**
     * @hidden
     */
    _eh: boolean;
    private _c5;
    /**
     * @hidden
     */
    readonly _c6: WorksheetResizeInfo;
    /**
     * @hidden
     */
    _i0(a: WorksheetResizeInfo, b: boolean): void;
    /**
     * @hidden
     */
    private _i1;
    /**
     * @hidden
     */
    protected get__p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    readonly _p: WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__i(): SheetProtection;
    /**
     * @hidden
     */
    readonly _i: SheetProtection;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ek: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _em: boolean;
    /**
     * @hidden
     */
    private static _e7;
    /**
     * @hidden
     */
    static readonly _fh: List$1<Tuple$3<Worksheet, WorksheetRegionAddress, string>>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _br: BiffSheetType;
    /**
     * @hidden
     */
    protected get__ag(): number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _jg: Point;
    /**
     * @hidden
     */
    readonly _fi: List$1<WorksheetCell>;
    /**
     * @hidden
     */
    readonly _g0: number;
}
/**
 * Represents a cell in a Microsoft Excel worksheet.
 */
export declare class WorksheetCell extends Base implements ICellFormatOwner, IComparable$1<WorksheetCell>, IFormattedStringOwner {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d: WorksheetCell;
    private _h;
    private _ac;
    private _aa;
    private _n;
    constructor(a: WorksheetRow, b: number);
    /**
     * @hidden
     */
    readonly cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    compareTo(other: WorksheetCell): number;
    /**
     * @hidden
     */
    readonly allowDefaultValues: boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * Determines whether the specified object is another [[WorksheetCell]] instance which refers
     * to the same location on the same worksheet as this cell.
     * @param obj The instance to check for equality.
     * @return True if the cells refer to the same location on the same worksheet; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code of the [[WorksheetCell]].
     * @return The hash code of the [[WorksheetCell]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the address of the cell.
     * @return The string representation of the address of the cell.
     */
    toString(): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @return The string representation of the address of the cell.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @param useRelativeColumn The value indicating whether to use a relative column address.
     * @param useRelativeRow The value indicating whether to use a relative row address.
     * @return The string representation of the address of the cell.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * Applies a formula to the cell.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the cell belongs. If the cell's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.applyCellFormula]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.ApplyCellFormula method.
     * </p>
     * @param value The formula to parse and apply to the cell.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
     * @see [[formula]]
     * @see [[WorksheetRow.applyCellFormula]]
     */
    applyFormula(value: string): void;
    /**
     * Removes the comment associated with the cell.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.setCellComment]] method and pass in null as the
     * comment parameter, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
     * WorksheetCell instance already exists, using this method is equivalent to using the WorksheetRow.SetCellComment method and
     * passing in null as the comment parameter.
     * </p>
     * @see [[comment]]
     * @see [[hasComment]]
     * @see [[WorksheetRow.setCellComment]]
     */
    clearComment(): void;
    /**
     * Gets the bounds of the cell in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellBoundsInTwips]] method, which
     * does not create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetBoundsInTwips method.
     * </p>
     * @return The bounds of the cell on its worksheet.
     * @see [[WorksheetRow.getCellBoundsInTwips]]
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the cell in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellBoundsInTwips]] method,
     * which does not create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetBoundsInTwips method.
     * </p>
     * @param options The options to use when getting the bounds of the cell.
     * @return The bounds of the cell on its worksheet.
     * @see [[WorksheetRow.getCellBoundsInTwips]]
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * Gets the string representation of the address of the cell.
     * @param worksheetRow The WorksheetRow of the cell.
     * @param columnIndex The index of the column of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @return The string representation of the address of the cell.
     */
    static getCellAddressString(worksheetRow: WorksheetRow, columnIndex: number, cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param worksheetRow The WorksheetRow of the cell.
     * @param columnIndex The index of the column of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @param useRelativeColumn The value indicating whether to use a relative column address.
     * @param useRelativeRow The value indicating whether to use a relative row address.
     * @return The string representation of the address of the cell.
     */
    static getCellAddressString(worksheetRow: WorksheetRow, columnIndex: number, cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    static _getCellAddressString(a: WorksheetRow, b: number, c: CellReferenceMode, d: boolean): string;
    /**
     * @hidden
     */
    static _getCellAddressString1(a: WorksheetRow, b: number, c: CellReferenceMode, d: boolean, e: boolean, f: boolean): string;
    /**
     * Gets the effective hyperlink on the cell.
     * <p class="body">
     * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
     * collection will be used.
     * </p>
     * <p class="body">
     * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
     * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
     * </p>
     * <p class="body">
     * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
     * </p>
     * @see [[Worksheet.hyperlinks]]
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetHyperlink.isSealed]]
     */
    getHyperlink(): WorksheetHyperlink;
    /**
     * Gets the text displayed in the cell.
     * <p class="body">
     * The display text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellText]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetText method.
     * </p>
     * @see [[value]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getText(): string;
    /**
     * Gets the text of the cell.
     * <p class="body">
     * The text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellText]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetText method.
     * </p>
     * @param textFormatMode The format mode to use when getting the cell text.
     * @throws [[InvalidEnumArgumentException]] 'textFormatMode' is not defined in the [[TextFormatMode]] enumeration.
     * @see [[value]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getText(textFormatMode: TextFormatMode): string;
    /**
     * @hidden
     */
    _getText(): string;
    /**
     * @hidden
     */
    _getText1(a: TextFormatMode): string;
    /**
     * Gets the resolved cell formatting for this cell.
     * <p class="body">
     * If any cell format properties are the default values on the cell, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getResolvedCellFormat]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetResolvedCellFormat method.
     * </p>
     * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
     * @see [[cellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     * @see [[WorksheetRow.getResolvedCellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * Returns True if a particular type of value can be exported to excel.
     * @param cellType The type to test.
     * @throws [[ArgumentNullException]] 'cellType' is null.
     * @return True if the type is supported as a cell value, False otherwise.
     */
    static isCellTypeSupported(cellType: Type): boolean;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode, b: boolean): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: boolean, c: boolean, d: boolean): string;
    /**
     * Returns a boolean indicating if the value of the cell is valid considering the associated [[dataValidationRule]]
     * @return Returns false if the cell has an associated [[dataValidationRule]] and the current [[value]] does not pass the validation defined by that rule; otherwise true is returned.
     * @see [[value]]
     * @see [[dataValidationRule]]
     * @see [[Worksheet.dataValidationRules]]
     */
    validateValue(): boolean;
    /**
     * @hidden
     */
    _l(): WorksheetRegion;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * Gets the data table to which the cell belongs.
     * <p class="body">
     * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
     * </p>
     * <p class="body">
     * If a data table is associated with the cell, getting the [[value]] will return the calculated value for the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedDataTable]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedDataTable method.
     * </p>
     * The data table to which the cell belongs or null if the cell does not belong to a data table.
     * @see [[Worksheet.dataTables]]
     * @see [[WorksheetDataTableCollection.add]]
     * @see [[WorksheetRow.getCellAssociatedDataTable]]
     */
    readonly associatedDataTable: WorksheetDataTable;
    /**
     * Gets the merged cells region which contains the cell, or null if the cell is not merged.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedMergedCellsRegion]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedMergedCellsRegion method.
     * </p>
     * The merged cells region which contains the cell, or null if the cell is not merged.
     * @see [[WorksheetRow.getCellAssociatedMergedCellsRegion]]
     */
    readonly associatedMergedCellsRegion: WorksheetMergedCellsRegion;
    /**
     * Gets the [[WorksheetTable]] to which this cell belongs.
     * <p class="body">
     * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedTable]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedTable method.
     * </p>
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     */
    readonly associatedTable: WorksheetTable;
    /**
     * Gets the cell formatting for this cell.
     * <p class="body">
     * Use this property to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
     * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
     * </p>
     * <p class="body">
     * If this cell belongs to a merged cell region, getting the CellFormat will get the CellFormat of the associated merged
     * cell region.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormat]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormat method.
     * </p>
     * The cell formatting for this cell.
     * @see [[getResolvedCellFormat]]
     * @see [[WorksheetRow.getCellFormat]]
     */
    readonly cellFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    readonly _cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * Gets the value which indicates whether the cell's format has been initialized yet.
     * @see [[cellFormat]]
     */
    readonly hasCellFormat: boolean;
    /**
     * Gets the column index of the cell.
     * The column index of the cell.
     */
    readonly columnIndex: number;
    /**
     * @hidden
     */
    readonly _ab: number;
    /**
     * Gets or sets the comment applied to the cell.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] or
     * [[WorksheetRow.setCellComment]] methods, which do not create [[WorksheetCell]] instances internally. However,
     * if a reference to the WorksheetCell instance already exists, using this property is equivalent to using the
     * WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
     * </p>
     * The comment applied to the cell.
     * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
     * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
     * anchors set but they are from different worksheets.
     * @see [[WorksheetRow.getCellComment]]
     * @see [[WorksheetRow.setCellComment]]
     */
    /**
    * Gets or sets the comment applied to the cell.
    * <p class="note">
    * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] or
    * [[WorksheetRow.setCellComment]] methods, which do not create [[WorksheetCell]] instances internally. However,
    * if a reference to the WorksheetCell instance already exists, using this property is equivalent to using the
    * WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
    * </p>
    * The comment applied to the cell.
    * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
    * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
    * anchors set but they are from different worksheets.
    * @see [[WorksheetRow.getCellComment]]
    * @see [[WorksheetRow.setCellComment]]
    */
    comment: WorksheetCellComment;
    /**
     * Gets or sets the data validation rule for the [[WorksheetCell]].
     * @throws [[ArgumentException]] Occurs when the value specified is already applied to cells in another worksheet.
     * @throws [[ArgumentException]] Occurs when the value specified is invalid based on its rule type's requirements.
     * @see [[Worksheet.dataValidationRules]]
     * @see [[AnyValueDataValidationRule]]
     * @see [[ListDataValidationRule]]
     * @see [[CustomDataValidationRule]]
     * @see [[OneConstraintDataValidationRule]]
     * @see [[TwoConstraintDataValidationRule]]
     */
    /**
    * Gets or sets the data validation rule for the [[WorksheetCell]].
    * @throws [[ArgumentException]] Occurs when the value specified is already applied to cells in another worksheet.
    * @throws [[ArgumentException]] Occurs when the value specified is invalid based on its rule type's requirements.
    * @see [[Worksheet.dataValidationRules]]
    * @see [[AnyValueDataValidationRule]]
    * @see [[ListDataValidationRule]]
    * @see [[CustomDataValidationRule]]
    * @see [[OneConstraintDataValidationRule]]
    * @see [[TwoConstraintDataValidationRule]]
    */
    dataValidationRule: DataValidationRule;
    /**
     * Get the value indicating whether the cell has an associated comment.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] method and check for a non null
     * return value, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
     * WorksheetCell instance already exists, using this property is equivalent to using the WorksheetRow.GetCellComment method
     * and checking for a non null return value.
     * </p>
     * True if the cell has an associated comment; False otherwise.
     * @see [[comment]]
     * @see [[WorksheetRow.getCellComment]]
     */
    readonly hasComment: boolean;
    /**
     * Gets the formula which has been applied to the cell.
     * <p class="body">
     * If a formula has been applied to the cell, getting the [[value]] will return the calculated value of the formula.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormula]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormula method.
     * </p>
     * The formula which has been applied to the cell or null if no formula has been applied.
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     * @see [[WorksheetRow.getCellFormula]]
     */
    readonly formula: Formula;
    /**
     * Gets the row index of the cell.
     * The row index of the cell.
     */
    readonly rowIndex: number;
    /**
     * Gets or sets the value of the cell.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellValue]] or [[WorksheetRow.setCellValue]]
     * methods, which do not create [[WorksheetCell]] instances internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
     * </p>
     * The value of the cell.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @see [[associatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[formula]]
     * @see [[associatedDataTable]]
     * @see [[WorksheetRow.getCellValue]]
     * @see [[WorksheetRow.setCellValue]]
     */
    /**
    * Gets or sets the value of the cell.
    * <p class="body">
    * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
    * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
    * will always return null. Setting the value of other cells in a merged cell region will have no effect.
    * </p>
    * <p class="body">
    * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
    * calculated value of the cell.
    * </p>
    * <p class="body">
    * The types supported for the value are:
    * <BR/>
    * <ul>
    * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
    * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
    * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
    * </ul>
    * </p>
    * <p class="note">
    * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellValue]] or [[WorksheetRow.setCellValue]]
    * methods, which do not create [[WorksheetCell]] instances internally. However, if a reference to the WorksheetCell instance
    * already exists, using this property is equivalent to using the WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
    * </p>
    * The value of the cell.
    * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
    * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
    * should be called on the Formula, passing in the cell.
    * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
    * should be set to a region containing the cell.
    * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
    * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
    * @see [[associatedMergedCellsRegion]]
    * @see [[WorksheetCell.isCellTypeSupported]]
    * @see [[WorksheetMergedCellsRegion.value]]
    * @see [[formula]]
    * @see [[associatedDataTable]]
    * @see [[WorksheetRow.getCellValue]]
    * @see [[WorksheetRow.setCellValue]]
    */
    value: any;
    /**
     * Gets the worksheet to which the cell belongs.
     * The worksheet to which the cell belongs.
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _e: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _m: WorksheetRegionAddress;
    /**
     * @hidden
     */
    readonly _o: WorksheetRow;
    /**
     * @hidden
     */
    static l_op_Equality(a: WorksheetCell, b: WorksheetCell): boolean;
    /**
     * @hidden
     */
    static l_op_Inequality(a: WorksheetCell, b: WorksheetCell): boolean;
}
/**
 * Represents a rectangular region of cells on a worksheet.
 */
export declare class WorksheetRegion extends Base implements IEnumerable$1<WorksheetCell> {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a: WorksheetRegion[];
    private _b;
    private _i;
    private _j;
    private _e;
    constructor(worksheet: Worksheet, firstRow: number, firstColumn: number, lastRow: number, lastColumn: number);
    constructor(worksheet: Worksheet, firstRow: number, firstColumn: number, lastRow: number, lastColumn: number, addCachedRegion: boolean);
    constructor(..._rest: any[]);
    /**
     * Determines whether the specified value equals this [[WorksheetRegion]].
     * @param obj The value to test for equality.
     */
    equals(obj: any): boolean;
    /**
     * Gtes the hash code for the [[WorksheetRegion]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the range of cells in the region.
     * @return The string representation of the range of cells in the region.
     */
    toString(): string;
    /**
     * Gets the string representation of the range of cells in the region.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the range address.
     * @return The string representation of the range of cells in the region.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the range of cells in the region.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the range address.
     * @param useRelativeColumn The value indicating whether to use a relative column address for the cells in the range.
     * @param useRelativeRow The value indicating whether to use a relative row address for the cells in the range.
     * @return The string representation of the range of cells in the region.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    _toString(): string;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetCell>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetCell>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Applies a array formula to the region of cells.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param value The array formula to parse and apply to the region.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The region contains another array formula or data table which extends outside the region.
     * @see [[ArrayFormula]]
     */
    applyArrayFormula(value: string): void;
    /**
     * Applies a formula to the region of cells.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param value The formula to parse and apply to the region.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The region contains an array formula or data table which extends outside the region.
     * @see [[Formula]]
     */
    applyFormula(value: string): void;
    /**
     * Formats the region as a table and adds an associated [[WorksheetTable]] to the [[Worksheet.tables]]
     * collection.
     * <p class="body">
     * When the table is created, the [[Workbook.defaultTableStyle]] will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @see [[WorksheetTable.style]]
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetTableCollection.add]]
     */
    formatAsTable(tableHasHeaders: boolean): WorksheetTable;
    /**
     * Formats the region as a table and adds an associated [[WorksheetTable]] to the [[Worksheet.tables]]
     * collection.
     * <p class="body">
     * When the table is created, the specified 'tableStyle' will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @param tableStyle The [[WorksheetTableStyle]] to apply to the table or null to use the [[Workbook.defaultTableStyle]].
     * @see [[WorksheetTable.style]]
     * @throws [[ArgumentException]] The specified 'tableStyle' does not exist in the [[Workbook.customTableStyles]] or
     * [[Workbook.standardTableStyles]] collections.
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     * @see [[WorksheetTable.style]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetTableCollection.add]]
     */
    formatAsTable(tableHasHeaders: boolean, tableStyle: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _formatAsTable(a: boolean): WorksheetTable;
    /**
     * @hidden
     */
    _formatAsTable1(a: boolean, b: WorksheetTableStyle): WorksheetTable;
    /**
     * Gets the bounds of the region in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the region are resized, these bounds will no longer reflect the
     * position of the region.
     * </p>
     * @return The bounds of the region on its worksheet.
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the region in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the region are resized, these bounds will no longer reflect the
     * position of the region.
     * </p>
     * @param options The options to use when getting the bounds of the region.
     * @return The bounds of the region on its worksheet.
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode, b: boolean): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: boolean, c: boolean, d: boolean): string;
    /**
     * @hidden
     */
    _aj(a: Formula, b: WorksheetRow, c: number, d?: ApplyFormulaFlags): {
        p1?: WorksheetRow;
        p2?: number;
    };
    /**
     * @hidden
     */
    _q(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _n(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _o(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _p(a: WorksheetRow, b: number): boolean;
    /**
     * @hidden
     */
    _s(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _t(a: number, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _al(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _d(a: CellShiftOperation, b: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    static _g(a: WorksheetRegion, b: WorksheetRegion): WorksheetRegion;
    /**
     * @hidden
     */
    static _am(a: number, b: number): void;
    /**
     * @hidden
     */
    _an(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    static _ap(a: number, b: number): void;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    readonly _h: WorksheetRegionAddress;
    /**
     * @hidden
     */
    readonly _c: RefBase;
    /**
     * Gets the index of the first column in the region.
     * The index of the first column in the region.
     */
    readonly firstColumn: number;
    /**
     * @hidden
     */
    readonly _v: number;
    /**
     * Gets the index of the first row in the region.
     * The index of the first row in the region.
     */
    readonly firstRow: number;
    /**
     * @hidden
     */
    readonly _aa: number;
    /**
     * @hidden
     */
    readonly _u: boolean;
    /**
     * Gets the index of the last column in the region.
     * The index of the last column in the region.
     */
    readonly lastColumn: number;
    /**
     * @hidden
     */
    readonly _w: number;
    /**
     * Gets the index of the last row in the region.
     * The index of the last row in the region.
     */
    readonly lastRow: number;
    /**
     * @hidden
     */
    readonly _k: WorksheetRow;
    /**
     * @hidden
     */
    readonly _ad: number;
    /**
     * Gets the worksheet on which the region resides.
     * The worksheet on which the region resides or null if the region has been shifted off the worksheet.
     */
    readonly worksheet: Worksheet;
}
/**
 * A collection of cells or regions which are all on the same [[worksheet]].
 */
export declare class WorksheetReferenceCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    private _w;
    private _x;
    private _y;
    private _u;
    private _a;
    private _b;
    constructor(worksheet: Worksheet);
    constructor(worksheet: Worksheet, references: string);
    constructor(cell: WorksheetCell);
    constructor(region: WorksheetRegion);
    constructor(..._rest: any[]);
    /**
     * Returns the string value represent the cell and region addresses in the collection.
     */
    toString(): string;
    /**
     * Returns the string value represent the cell and region addresses in the collection.
     * @param cellReferenceMode The cell reference mode with which to get the region strings.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     */
    toString(cellReferenceMode: CellReferenceMode): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    copyTo(array: WorksheetRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly count: number;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRegion>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    /**
     * Adds a region to the collection of references.
     * <p class="body">
     * The region added to the collection must be from the same [[worksheet]] as the collection.
     * </p>
     * <p class="body">
     * If the region is already contained in the collection, or there is a region in the collection which fully contains the specified region,
     * this call will have no effect on the collection.
     * </p>
     * @param region The region to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a Worksheet other than the references collection.
     */
    add(region: WorksheetRegion): void;
    /**
     * Adds a cell to the collection of references.
     * <p class="body">
     * The cell added to the collection must be from the same [[worksheet]] as the collection.
     * </p>
     * <p class="body">
     * If the cell is already contained in the collection, or there is a region in the collection which contains the cell, this call
     * will have no effect on the collection.
     * </p>
     * @param cell The cell to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a Worksheet other than the references collection.
     */
    add(cell: WorksheetCell): void;
    /**
     * Adds a list of references to the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If all references are already contained in the collection this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     */
    add(references: string): void;
    /**
     * Adds a list of references to the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If all references are already contained in the collection this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to add to the collection.
     * @param cellReferenceMode The cell reference mode with which to parse the 'references'.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     */
    add(references: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _add3(a: string): void;
    /**
     * @hidden
     */
    _add4(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _add1(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _add(a: WorksheetRegion): void;
    /**
     * Clears all references from the collection.
     */
    clear(): void;
    /**
     * Determines whether the collection contains the specified region.
     * @param region The region to search for in the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @return True if the region is contained in the collection or a region which fully contains the specified region is contained in the collection;
     * False otherwise.
     */
    contains(region: WorksheetRegion): boolean;
    /**
     * Determines whether the collection contains the specified cell.
     * @param cell The cell to search for in the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @return True if the cell is contained in the collection or a region which contains the cell is contained in the collection; False otherwise.
     */
    contains(cell: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains1(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains2(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _k(a: WorksheetRegionAddress): boolean;
    /**
     * Removes a region from the collection of references.
     * <p class="body">
     * If the region is not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param region The region to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @return True if any cells in the region were found and removed. False otherwise.
     */
    remove(region: WorksheetRegion): boolean;
    /**
     * Removes a cell from the collection of references.
     * <p class="body">
     * If the cell is not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param cell The cell to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @return True if the cell was found and removed. False otherwise.
     */
    remove(cell: WorksheetCell): boolean;
    /**
     * Removes a list of references from the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If the references are not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     * @return True if any cells in the references were found and removed. False otherwise.
     */
    remove(references: string): boolean;
    /**
     * Removes a list of references from the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If the references are not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to remove from the collection.
     * @param cellReferenceMode The cell reference mode with which to parse the 'references'.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     * @return True if any cells in the references were found and removed. False otherwise.
     */
    remove(references: string, cellReferenceMode: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    _remove3(a: string): boolean;
    /**
     * @hidden
     */
    _remove4(a: string, b: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    _remove1(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _remove(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove2(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode): string;
    /**
     * @hidden
     */
    static _e(a: WorksheetCell): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    static _f(a: WorksheetRegion): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    _al(a: WorksheetCell, b: WorksheetCell): {
        p0: WorksheetCell;
        p1: WorksheetCell;
    };
    /**
     * @hidden
     */
    _l(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _ap(a: CellShiftOperation, b: boolean): {
        p1: boolean;
    };
    /**
     * @hidden
     */
    _add2(a: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private _h;
    /**
     * @hidden
     */
    private _aj;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _g;
    /**
     * @hidden
     */
    private _s;
    /**
     * @hidden
     */
    static _r(a: Worksheet, b: string, c: CellReferenceMode, d: CultureInfo): List$1<WorksheetRegion>;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _as;
    /**
     * @hidden
     */
    private static _at;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    static _ab(a: CellReferenceMode, b: Worksheet, c: IEnumerable$1<WorksheetRegionAddress>, d?: string): string;
    /**
     * Gets the number of cells contains in all references in this collection.
     */
    readonly cellsCount: number;
    /**
     * Gets the worksheet for which this collection contains references.
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _t: List$1<WorksheetRegionAddress>;
    /**
     * @hidden
     */
    readonly _d: WorksheetCell;
}
/**
 * @hidden
 */
export declare class DataValidationRuleCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: DataValidationRuleCollection, c: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: DataValidationRuleCollection;
    readonly b: Nullable$1<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[DataValidationRule]] instances in a worksheet.
 * @see [[Worksheet.dataValidationRules]]
 */
export declare class DataValidationRuleCollection extends Base implements IDictionary$2<DataValidationRule, WorksheetReferenceCollection> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static _a;
    private _s;
    /**
     * @hidden
     */
    _f: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    addItem(key: DataValidationRule, value: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    containsKey(key: DataValidationRule): boolean;
    /**
     * @hidden
     */
    tryGetValue(key: DataValidationRule, value: WorksheetReferenceCollection): {
        ret: boolean;
        p1: WorksheetReferenceCollection;
    };
    /**
     * @hidden
     */
    readonly keys: ICollection$1<DataValidationRule>;
    /**
     * @hidden
     */
    readonly values: ICollection$1<WorksheetReferenceCollection>;
    /**
     * @hidden
     */
    add(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): void;
    /**
     * Applies an [[AnyValueDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: AnyValueDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[AnyValueDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: AnyValueDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[CustomDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: CustomDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[CustomDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: CustomDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies a data validation rule to the a set of references.
     * @param rule The data validation rule to apply to the set of references.
     * @param references The reference to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'references' collection are in the totals row of a table.
     */
    add(rule: DataValidationRule, references: WorksheetReferenceCollection): void;
    /**
     * Applies a data validation rule to the a set of references.
     * @param rule The data validation rule to apply to the set of references.
     * @param references The reference to which the data validation rule should be applied.
     * @param overwriteExistingRules Indicates whether cells in the references collection which already have data validation rules should have the rules overwritten.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when 'overwriteExistingRules' is False and the one or more of the cells in the 'references'
     * collection already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'references' collection are in the totals row of a table.
     */
    add(rule: DataValidationRule, references: WorksheetReferenceCollection, overwriteExistingRules: boolean): void;
    /**
     * Applies an [[ListDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: ListDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[ListDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: ListDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[OneConstraintDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: OneConstraintDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[OneConstraintDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: OneConstraintDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[TwoConstraintDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: TwoConstraintDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[TwoConstraintDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: TwoConstraintDataValidationRule, region: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): void;
    /**
     * @hidden
     */
    contains(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * Determines whether the specified data validation rule exists on the [[worksheet]].
     * @param rule The rule to test.
     * @return True if the rule is applied to one or more cells on the Worksheet; False otherwise.
     */
    contains(rule: DataValidationRule): boolean;
    /**
     * Determines whether the specified cell has a data validation rule applied to it.
     * @param cell The cell to test.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return True if the cell has a data validation rule applied; False otherwise.
     */
    contains(cell: WorksheetCell): boolean;
    /**
     * Determines whether the specified references collection has a data validation rule applied to any of it's cells.
     * @param references The references collection to test.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @return True if the any cell from the references collection has a data validation rule applied; False otherwise.
     */
    contains(references: WorksheetReferenceCollection): boolean;
    /**
     * Determines whether the specified region has a data validation rule applied to any of it's cells.
     * @param region The region to test.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @return True if the any cell from the region has a data validation rule applied; False otherwise.
     */
    contains(region: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * @hidden
     */
    copyTo(array: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * Removes the data validation rule form the cell if one is applied.
     * <p class="body">
     * If the rule is only applied to the specified cell, it will be removed from the collection.
     * </p>
     * @param cell The cell which should have its data validation rule cleared.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from the cell; False if the cell had no data validation rule applied.
     */
    remove(cell: WorksheetCell): boolean;
    /**
     * Removes the data validation rule form all cells in the specified collection.
     * <p class="body">
     * If any rules in the collection are not applied to any cells after this operation, they will be removed from the collection.
     * </p>
     * @param references The collection of references which should have its data validation rules cleared.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from any cells in the collection; False if the cells had no data validation rule applied.
     */
    remove(references: WorksheetReferenceCollection): boolean;
    /**
     * Removes the data validation rule form all cells in the specified region.
     * <p class="body">
     * If any rules in the collection are not applied to any cells after this operation, they will be removed from the collection.
     * </p>
     * @param region The region which should have its data validation rules cleared.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from any cells in the region; False if the region had no data validation rule applied.
     */
    remove(region: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add5(a: DataValidationRule, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _add6(a: DataValidationRule, b: WorksheetReferenceCollection, c: boolean): void;
    /**
     * @hidden
     */
    _add1(a: AnyValueDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add2(a: AnyValueDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add3(a: CustomDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add4(a: CustomDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add7(a: ListDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add8(a: ListDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add9(a: OneConstraintDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add10(a: OneConstraintDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add11(a: TwoConstraintDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add12(a: TwoConstraintDataValidationRule, b: WorksheetRegion): void;
    /**
     * Removes all data validation rules from the [[worksheet]].
     */
    clear(): void;
    /**
     * @hidden
     */
    _contains1(a: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _contains2(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains3(a: WorksheetReferenceCollection): boolean;
    /**
     * @hidden
     */
    _contains4(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains5(a: WorksheetRegionAddress): boolean;
    /**
     * Find the data validation rule applied to the specified cell.
     * @param cell The cell to test.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return A [[DataValidationRule]]-derived instance or null if the cell has no rule applied.
     */
    findRule(cell: WorksheetCell): DataValidationRule;
    /**
     * Gets a collection of all the references which have the specified or an equivalent rule applied to them.
     * @param rule The rule to test.
     * @return A collection of references in the [[worksheet]] with a rule applied to it that is equivalent to the specified 'rule'.
     */
    getAllReferences(rule: DataValidationRule): WorksheetReferenceCollection;
    /**
     * Removes the specified rule from the [[worksheet]].
     * @param rule The rule which should be removed.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @return True if the rule was contained on the Worksheet before removal; False otherwise.
     */
    removeItem(rule: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _remove2(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _remove3(a: WorksheetReferenceCollection): boolean;
    /**
     * @hidden
     */
    _remove4(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove5(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _r(a: DataValidationRule, b: WorksheetReferenceCollection): {
        ret: boolean;
        p1: WorksheetReferenceCollection;
    };
    /**
     * @hidden
     */
    _aj(a: DataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _ak(a: DataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _al(a: DataValidationRule, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _e(a: WorksheetRegionAddress): DataValidationRule;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private _ap;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _as;
    /**
     * Gets the number of data validation rules applied on the [[worksheet]].
     */
    readonly count: number;
    /**
     * Gets or sets the references which have the data validation rule applied to it.
     * @param rule A data validation rule.
     * @throws [[ArgumentNullException]] Occurs when the 'rule' is null.
     * @throws [[KeyNotFoundException]] Occurs when the property is retrieved and the 'rule' is not applied to the [[worksheet]].
     * @throws [[ArgumentException]] Occurs when the property is set and the value is from a Worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the property is set and the 'rule' is invalid based on its rule type's requirements.
     */
    item(a: DataValidationRule, b?: WorksheetReferenceCollection): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    readonly _g: Worksheet;
}
/**
 * Represents a data validation rule which allows a value from a list of accepted values to be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class ListDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bh;
    private _bq;
    private _bo;
    constructor();
    /**
     * @hidden
     */
    protected get__i(): FormulaType;
    /**
     * @hidden
     */
    _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a6(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _ao(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    protected get__j(): DataValidationOperatorType;
    /**
     * @hidden
     */
    readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _a8(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__k(): DataValidationType;
    /**
     * @hidden
     */
    readonly _k: DataValidationType;
    /**
     * @hidden
     */
    _bf(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the formula which specifies the accepted values.
     * <p class="body">
     * The is a string containing the list of accepted values or a reference to a cell or region in the same Workbook which contains
     * the accepted values.
     * </p>
     * <p class="body">
     * If the formula equals a string, it will be a list of accepted value, such as ="A,B,C". If one of the values must contain a double
     * quote ("), the character will be repeated in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The
     * separator between values will be a comma (,), unless the decimal separator for the current culture is a comma, in which case the
     * separator will be a semicolon (;).
     * </p>
     * <p class="body">
     * If the formula equals one or more references, it will be a reference to a single cell or region in the same Workbook. Union,
     * intersection, and range operators are not allowed. An formula might be something like =$A$1 or =Sheet2!$A$1:$A$5. In addition to a
     * single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is specified,
     * or a named reference that refers to a region, the region will consist of a single row or column. A formula that equals an error value
     * can also be returned, but will cause the cell to not accept any values and the drop down to be empty, so it is not very useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[tryGetValues]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    getValuesFormula(address: string): string;
    /**
     * Gets the formula which specifies the accepted values.
     * <p class="body">
     * The is a string containing the list of accepted values or a reference to a cell or region in the same Workbook which contains
     * the accepted values.
     * </p>
     * <p class="body">
     * If the formula equals a string, it will be a list of accepted value, such as ="A,B,C". If one of the values must contain a double
     * quote ("), the character will be repeated in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The
     * separator between values will be a comma (,), unless the decimal separator for the current culture is a comma, in which case the
     * separator will be a semicolon (;).
     * </p>
     * <p class="body">
     * If the formula equals one or more references, it will be a reference to a single cell or region in the same Workbook. Union,
     * intersection, and range operators are not allowed. An formula might be something like =$A$1 or =Sheet2!$A$1:$A$5. In addition to a
     * single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is specified,
     * or a named reference that refers to a region, the region will consist of a single row or column. A formula that equals an error value
     * can also be returned, but will cause the cell to not accept any values and the drop down to be empty, so it is not very useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[tryGetValues]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    getValuesFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getValuesFormula(a: string): string;
    /**
     * @hidden
     */
    _getValuesFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the list of accepted values the cell can accept.
     * <p class="body">
     * If [[LimitedValueDataValidationRule.allowNull]] is True, null values are allowed in addition to the list of accepted values.
     * </p>
     * <p class="body">
     * All values will have ToString called on them to covert the accepted values list to a formula.
     * </p>
     * <p class="note">
     * <b>Note:</b> the formula of accepted values is created by separating each value with a function parameter separator and concatenating
     * them into a single string. So a list of 1, 2, and 3 would have the following formula created: ="1,2,3". However, if the decimal separator
     * of the current culture is a comma (,) then a semicolon (;) will be used to separate the values instead. Because of this, if the ToString
     * of a value returns a string which contains one of these separators, the value will be split into two or more allowed values.
     * </p>
     * @param values The list of accepted values.
     * @throws [[ArgumentNullException]] Occurs when 'values' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when the 'values' array is empty.
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValues(...values: any[]): void;
    /**
     * Sets the formula which specifies the accepted values.
     * <p class="body">
     * The formula must be a string containing the list of accepted values or a reference to a cell or region in the same Workbook
     * which contains the accepted values.
     * </p>
     * <p class="body">
     * If a formula equaling a string is specified, it must be a string literal and it cannot be concatenated. For example, an
     * acceptable formula would be ="A,B,C". If one of the values must contain a double quote ("), the character should be repeated
     * in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The separator between values must be a comma (,),
     * unless the decimal separator for the current culture is a comma, in which case the separator must be a semicolon (;).
     * </p>
     * <p class="body">
     * If a formula equaling one or more references is specified, it must be a reference to a single cell or region in the same Workbook.
     * Union, intersection, and range operators are not allowed. An acceptable formula might be =$A$1 or =Sheet2!$A$1:$A$5. In addition
     * to a single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is
     * specified, or a named reference that refers to a region, the region must consist of a single row or column. A formula that equals
     * an error value is also allowed, but will cause the cell to not accept any values and the drop down to be empty, so it is not very
     * useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param valuesFormula The formula which provides the accepted values for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'valuesFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'valuesFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value contains something other than a string or reference.
     * @throws [[ArgumentException]] Occurs when the specified value contains a region reference which has more than one row and column.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[setValues]]
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValuesFormula(valuesFormula: string, address: string): void;
    /**
     * Sets the formula which specifies the accepted values.
     * <p class="body">
     * The formula must be a string containing the list of accepted values or a reference to a cell or region in the same Workbook
     * which contains the accepted values.
     * </p>
     * <p class="body">
     * If a formula equaling a string is specified, it must be a string literal and it cannot be concatenated. For example, an
     * acceptable formula would be ="A,B,C". If one of the values must contain a double quote ("), the character should be repeated
     * in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The separator between values must be a comma (,),
     * unless the decimal separator for the current culture is a comma, in which case the separator must be a semicolon (;).
     * </p>
     * <p class="body">
     * If a formula equaling one or more references is specified, it must be a reference to a single cell or region in the same Workbook.
     * Union, intersection, and range operators are not allowed. An acceptable formula might be =$A$1 or =Sheet2!$A$1:$A$5. In addition
     * to a single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is
     * specified, or a named reference that refers to a region, the region must consist of a single row or column. A formula that equals
     * an error value is also allowed, but will cause the cell to not accept any values and the drop down to be empty, so it is not very
     * useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param valuesFormula The formula which provides the accepted values for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'valuesFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'valuesFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value contains something other than a string or reference.
     * @throws [[ArgumentException]] Occurs when the specified value contains a region reference which has more than one row and column.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setValues]]
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValuesFormula(valuesFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setValuesFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setValuesFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _bs(a: any[]): {
        ret: boolean;
        p0: any[];
    };
    /**
     * @hidden
     */
    _bj(a?: (arg1: string) => any): any[];
    /**
     * @hidden
     */
    private static _bx;
    /**
     * @hidden
     */
    _bl(a: WorksheetCellAddress): ArrayProxy;
    /**
     * @hidden
     */
    _bn(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private static _bk;
    /**
     * @hidden
     */
    private _b4;
    /**
     * @hidden
     */
    private static _bt;
    /**
     * @hidden
     */
    private static _bm;
    /**
     * @hidden
     */
    private static _bi;
    /**
     * @hidden
     */
    private static _bp;
    /**
     * @hidden
     */
    private static _b0;
    /**
     * Gets or sets the value which indicates whether a drop down should be displayed in Microsoft Excel with the list of accepted values.
     * <p class="body">
     * If this is True, a drop down arrow will be displayed next to the cell when it is selected. When the user clicks the drop down arrow,
     * a drop down will be displayed with the list of accepted values.
     * </p>
     */
    /**
    * Gets or sets the value which indicates whether a drop down should be displayed in Microsoft Excel with the list of accepted values.
    * <p class="body">
    * If this is True, a drop down arrow will be displayed next to the cell when it is selected. When the user clicks the drop down arrow,
    * a drop down will be displayed with the list of accepted values.
    * </p>
    */
    showDropdown: boolean;
}
/**
 * Base class for all data validations rules which compare the cell value against one or more constraint when determining
 * the validity of the cell value.
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class ValueConstraintDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bh;
    private _bk;
    constructor();
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a6(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _a8(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__k(): DataValidationType;
    /**
     * @hidden
     */
    readonly _k: DataValidationType;
    /**
     * @hidden
     */
    _bf(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bq(a: DataValidationCriteria, b: string): void;
    /**
     * @hidden
     */
    static _bp(a: Formula): Nullable$1<number>;
    /**
     * @hidden
     */
    abstract _bm(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    private static _bj;
    /**
     * @hidden
     */
    private static _bi;
    /**
     * Gets or sets the criteria to use when validating the cell value against the constraint(s).
     * <p class="body">
     * Depending on the value specified, either then cell value or the length of its text equivalent will be compared against the
     * constraint(s). In addition, certain ValidationCriteria values may disallow a cell value even if it is valid when compared to
     * the constraint. For example, the ValidationCriteria.WholeNumber value will not allow any number with a fractional portion.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationCriteria]] enumeration.
     */
    /**
    * Gets or sets the criteria to use when validating the cell value against the constraint(s).
    * <p class="body">
    * Depending on the value specified, either then cell value or the length of its text equivalent will be compared against the
    * constraint(s). In addition, certain ValidationCriteria values may disallow a cell value even if it is valid when compared to
    * the constraint. For example, the ValidationCriteria.WholeNumber value will not allow any number with a fractional portion.
    * </p>
    * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationCriteria]] enumeration.
    */
    validationCriteria: DataValidationCriteria;
    /**
     * @hidden
     */
    private _br;
}
/**
 * Represents a data validation rule which can validate the cell value against a single constraint value or formula.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[OneConstraintDataValidationOperator]]
 */
export declare class OneConstraintDataValidationRule extends ValueConstraintDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b1;
    /**
     * @hidden
     */
    private static readonly _b3;
    /**
     * @hidden
     */
    private static readonly _b2;
    /**
     * @hidden
     */
    private static readonly _bs;
    private _bx;
    private _bv;
    constructor();
    constructor(validationOperator: OneConstraintDataValidationOperator, validationCriteria: DataValidationCriteria);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ao(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    protected get__j(): DataValidationOperatorType;
    /**
     * @hidden
     */
    readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    getConstraintFormula(address: string): string;
    /**
     * Gets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    getConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint value is determined by the [[validationOperator]] as well
     * as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint value.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setConstraint]] overload is preferred.
     * </p>
     * @param value The constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @see [[setConstraint]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setConstraint(value: Date): void;
    /**
     * Sets the constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint value is determined by the [[validationOperator]] as well
     * as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint value.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setConstraint]] overload is preferred.
     * </p>
     * @param value The constraint value used to compare against the cell value.
     * @see [[setConstraint]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setConstraint(value: number): void;
    /**
     * @hidden
     */
    _setConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setConstraint(a: Date): void;
    /**
     * Sets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param constraintFormula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'constraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'constraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    setConstraintFormula(constraintFormula: string, address: string): void;
    /**
     * Sets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param constraintFormula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'constraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'constraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    setConstraintFormula(constraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _b0(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _bz(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _by(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    private static _bt;
    /**
     * Gets or sets the validation operator to use when comparing the cell value against the constraint value or formula.
     * <p class="body">
     * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
     * length of the cell value's text equivalent is compared to the constraint value or formula.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[OneConstraintDataValidationOperator]] enumeration.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    /**
    * Gets or sets the validation operator to use when comparing the cell value against the constraint value or formula.
    * <p class="body">
    * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
    * length of the cell value's text equivalent is compared to the constraint value or formula.
    * </p>
    * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[OneConstraintDataValidationOperator]] enumeration.
    * @see [[setConstraint]]
    * @see [[setConstraint]]
    * @see [[getConstraintFormula]]
    * @see [[getConstraintFormula]]
    * @see [[setConstraintFormula]]
    * @see [[setConstraintFormula]]
    * @see [[ValueConstraintDataValidationRule.validationCriteria]]
    */
    validationOperator: OneConstraintDataValidationOperator;
}
/**
 * Represents a data validation rule which can validate the cell value against two constraint values or formulas.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[TwoConstraintDataValidationOperator]]
 */
export declare class TwoConstraintDataValidationRule extends ValueConstraintDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b5;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b8;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _bs;
    private _bx;
    private _by;
    private _bz;
    constructor();
    constructor(validationOperator: TwoConstraintDataValidationOperator, validationCriteria: DataValidationCriteria);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _l(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ao(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    protected get__j(): DataValidationOperatorType;
    /**
     * @hidden
     */
    readonly _j: DataValidationOperatorType;
    /**
     * @hidden
     */
    _aq(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _ar(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    _at(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getLowerConstraintFormula(address: string): string;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getLowerConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getLowerConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getLowerConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getUpperConstraintFormula(address: string): string;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getUpperConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getUpperConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getUpperConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the lower constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setLowerConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @throws [[ArgumentException]] Occurs when the specified value is greater than the upper constraint value. If the upper constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraint(value: Date): void;
    /**
     * Sets the lower constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setLowerConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when the specified value is greater than the upper constraint value. If the upper constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraint(value: number): void;
    /**
     * @hidden
     */
    _setLowerConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setLowerConstraint(a: Date): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param lowerConstraintFormula The lower constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'lowerConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'lowerConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'lowerConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraintFormula(lowerConstraintFormula: string, address: string): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param lowerConstraintFormula The lower constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'lowerConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'lowerConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'lowerConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraintFormula(lowerConstraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setLowerConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setLowerConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * Sets the upper constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setUpperConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @throws [[ArgumentException]] Occurs when the specified value is less than the lower constraint value. If the lower constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraint(value: Date): void;
    /**
     * Sets the upper constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setUpperConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when the specified value is less than the lower constraint value. If the lower constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraint(value: number): void;
    /**
     * @hidden
     */
    _setUpperConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setUpperConstraint(a: Date): void;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param upperConstraintFormula The upper constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'upperConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'upperConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'upperConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraintFormula(upperConstraintFormula: string, address: string): void;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param upperConstraintFormula The upper constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'upperConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'upperConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'upperConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraintFormula(upperConstraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setUpperConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setUpperConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _b2(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _b1(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _b4(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _b3(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _bv(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    _bw(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _ch;
    /**
     * @hidden
     */
    private _cm;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    private static _bt;
    /**
     * Gets or sets the validation operator to use when comparing the cell value against the constraint values or formulas.
     * <p class="body">
     * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
     * length of the cell value's text equivalent is compared to the constraint values or formulas.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[TwoConstraintDataValidationOperator]] enumeration.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    /**
    * Gets or sets the validation operator to use when comparing the cell value against the constraint values or formulas.
    * <p class="body">
    * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
    * length of the cell value's text equivalent is compared to the constraint values or formulas.
    * </p>
    * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[TwoConstraintDataValidationOperator]] enumeration.
    * @see [[setLowerConstraint]]
    * @see [[setLowerConstraint]]
    * @see [[setUpperConstraint]]
    * @see [[setUpperConstraint]]
    * @see [[getLowerConstraintFormula]]
    * @see [[getLowerConstraintFormula]]
    * @see [[getUpperConstraintFormula]]
    * @see [[getUpperConstraintFormula]]
    * @see [[setLowerConstraintFormula]]
    * @see [[setLowerConstraintFormula]]
    * @see [[setUpperConstraintFormula]]
    * @see [[setUpperConstraintFormula]]
    * @see [[ValueConstraintDataValidationRule.validationCriteria]]
    */
    validationOperator: TwoConstraintDataValidationOperator;
}
/**
 * @hidden
 */
export declare class DisplayValueCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: DisplayValueCollection, c: string, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: DisplayValueCollection;
    readonly c: string;
    readonly b: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of display text values.
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 * @see [[FixedValuesFilter.displayValues]]
 */
export declare class DisplayValueCollection extends Base implements IList$1<string> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FixedValuesFilter;
    private _e;
    static staticInit(): void;
    constructor(a: FixedValuesFilter);
    /**
     * @hidden
     */
    copyTo(array: string[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<string>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<string>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a display text value to the collection.
     * @param item The display text value to add to the collection.
     * @throws [[ArgumentNullException]] 'item' is null or empty.
     * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
     */
    add(item: string): void;
    /**
     * Clears the collection.
     * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
     * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
     */
    clear(): void;
    /**
     * Determines whether the specified value is in the collection.
     * <p class="body">
     * Display text values are compared case-insensitively.
     * </p>
     * @param item The display text value to find in the collection.
     * @return
     */
    contains(item: string): boolean;
    /**
     * Gets the index of the specified display text value in the collection.
     * @param item The display text value to find in the collection.
     * @return The 0-based index of the specified display text value in the collection or -1 if the item is not in the collection.
     */
    indexOf(item: string): number;
    /**
     * Inserts a display text value into the collection.
     * @param index The 0-based index where the value should be inserted.
     * @param item The display text value to insert into the collection.
     * @throws [[ArgumentNullException]] 'item' is null or empty.
     * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     */
    insert(index: number, item: string): void;
    /**
     * Removes a display text value from the collection.
     * <p class="body">
     * Display text values are compared case-insensitively.
     * </p>
     * @param item The display text value to remove from the collection.
     * @return True if the value was found and removed; False otherwise.
     */
    remove(item: string): boolean;
    /**
     * Removes the display text value at the specified index.
     * @param index The 0-based index of the value to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
     * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
     * is not allowed for a FixedValuesFilter.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    private _j;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private static _p;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private _s;
    /**
     * Gets the number of display text values in the collection.
     */
    readonly count: number;
    /**
     * Gets or sets the display text value at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned matches another value in the collection. Values are compared case-insensitively.
     */
    item(a: number, b?: string): string;
}
/**
 * Class which exposes the document level properties for a Microsoft Excel file.
 * <p class="body">
 * The properties exposed by this class can be changed on a Microsoft Excel file by right-clicking it
 * in Windows Explorer and editing the properties on the Summary tab.
 * </p>
 */
export declare class DocumentProperties extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _e;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _o;
    private _p;
    private _q;
    private _r;
    private _s;
    private _t;
    private _u;
    private _v;
    private _w;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    _ag(a: SummaryInformation, b: DocumentSummaryInformation): void;
    /**
     * @hidden
     */
    _ah(a: StructuredStorageManager): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets or sets the author of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the author of the document.
     */
    /**
    * Gets or sets the author of the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the author of the document.
    */
    author: string;
    /**
     * Gets or sets the category of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the category of the document.
     */
    /**
    * Gets or sets the category of the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the category of the document.
    */
    category: string;
    /**
     * Gets or sets the comments associated with the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the comments associated with the document.
     */
    /**
    * Gets or sets the comments associated with the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the comments associated with the document.
    */
    comments: string;
    /**
     * Gets or sets the company to which the document belongs.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the company to which the document belongs.
     */
    /**
    * Gets or sets the company to which the document belongs.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the company to which the document belongs.
    */
    company: string;
    /**
     * Gets or sets the keywords which describe the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the keywords which describe the document.
     */
    /**
    * Gets or sets the keywords which describe the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the keywords which describe the document.
    */
    keywords: string;
    /**
     * Gets or sets the manager associated with the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the manager associated with the document.
     */
    /**
    * Gets or sets the manager associated with the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the manager associated with the document.
    */
    manager: string;
    /**
     * Gets or sets the current status of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string representing the current status of the document.
     */
    /**
    * Gets or sets the current status of the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string representing the current status of the document.
    */
    status: string;
    /**
     * Gets or sets the subject of the contents of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the subject of the contents of the document.
     */
    /**
    * Gets or sets the subject of the contents of the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the subject of the contents of the document.
    */
    subject: string;
    /**
     * Gets or sets the title of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the title of the document.
     */
    /**
    * Gets or sets the title of the document.
    * <p class="body">
    * The value of the property has no effect on the contents of the file when opened in a host application.
    * It is simply extra data associated with the document.
    * </p>
    * A string specifying the title of the document.
    */
    title: string;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * @hidden
 */
export declare class FixedLengthSegmentTree$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    private b;
    private readonly k;
    readonly c: RegionLookupTable$1<T>;
    l: number;
    constructor($t: Type, a: RegionLookupTable$1<T>, b: number);
    m(): void;
    private a;
    n(a: number, b: number): {
        p0: number;
        p1: number;
    };
    h(a: number, b: number, c: HashSet$1<T>, d: (arg1: T) => boolean): List$1<T>;
    e(a: number, b: number, c: (arg1: T) => boolean): HashSet$1<T>;
    i(a: number, b: HashSet$1<T>, c: (arg1: T) => boolean): List$1<T>;
    f(a: number, b: (arg1: T) => boolean): HashSet$1<T>;
    j(a: number, b: number, c: HashSet$1<T>, d: (arg1: T) => boolean): List$1<T>;
    g(a: number, b: number, c: (arg1: T) => boolean): HashSet$1<T>;
    o(a: T, b: number, c: number): void;
    p(a: T, b: number, c: number): void;
    readonly d: boolean;
}
/**
 * @hidden
 */
export declare class FixedLengthSegmentTree_SegmentTreeNode$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    e: number;
    d: number;
    private c;
    private a;
    private b;
    constructor($t: Type, a: number, b: number);
    private f;
    private static g;
    h(a: boolean, b: number): {
        p1?: number;
    };
    i<TCol extends ICollection$1<T>>($tCol: Type, a: FixedLengthSegmentTree$1<T>, b: number, c: number, d: HashSet$1<T>, e: TCol, f: () => TCol, g: (arg1: T) => boolean): {
        p4?: TCol;
    };
    j<TCol extends ICollection$1<T>>($tCol: Type, a: number, b: HashSet$1<T>, c: TCol, d: () => TCol, e: (arg1: T) => boolean): {
        p2?: TCol;
    };
    k<TCol extends ICollection$1<T>>($tCol: Type, a: number, b: number, c: HashSet$1<T>, d: TCol, e: () => TCol, f: (arg1: T) => boolean): {
        p3?: TCol;
    };
    l(a: FixedLengthSegmentTree$1<T>, b: T, c: number, d: number): void;
    m(a: FixedLengthSegmentTree$1<T>, b: T, c: number, d: number): void;
    n(a: FixedLengthSegmentTree_SegmentTreeNode$1<T>): void;
}
/**
 * @hidden
 */
export declare class FormatLimitErrors extends Base {
    static $t: Type;
    private c;
    private e;
    private readonly a;
    constructor(a: Workbook);
    g(a: string): void;
    h(): void;
    readonly f: List$1<string>;
    readonly d: boolean;
    readonly b: Workbook;
}
/**
 * Abstract base class which controls the formatting of a range of characters in a [[FormattedString]] or [[FormattedText]].
 * @see [[FormattedStringFont]]
 * @see [[FormattedTextFont]]
 */
export declare abstract class FormattedFontBase extends Base implements IWorkbookFont, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _a;
    private readonly _f;
    private readonly _u;
    private readonly _q;
    constructor(a: IFormattedItem, b: number, c: number);
    /**
     * Sets all properties of this font to the properties of the specified font.
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, any default values on the specified font will be ignored.
     * </p>
     * @throws [[ArgumentNullException]] 'source' is null.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     * @param source The font whose properties should be copied over to this font.
     */
    setFontFormatting(source: IWorkbookFont): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    _aa(): void;
    /**
     * @hidden
     */
    _h(a: Workbook): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    abstract _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    _ab(a: IFormattedRunOwner, b: Workbook, c: List$1<FormattingRunBase>, d: number, e: IWorkbookFontDefaultsResolver, f: FormattingRunBase): {
        p5?: FormattingRunBase;
    };
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _e(a: List$1<FormattingRunBase>, b: number): FormattingRunBase;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _c;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private _ag;
    /**
     * Gets or sets the value indicating whether the font is bold.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is bold.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the value indicating whether the font is bold.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The value indicating whether the font is bold.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    bold: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bold$i: Nullable$1<boolean>;
    /**
     * Gets or sets the fore color of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The fore color of the font.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the fore color of the font.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The fore color of the font.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    colorInfo: WorkbookColorInfo;
    /**
     * Gets or sets the height of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The height of the font.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is positive and outside the valid font height range of 20 and 8180.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the height of the font.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The height of the font.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is positive and outside the valid font height range of 20 and 8180.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    height: number;
    /**
     * Gets or sets the value indicating whether the font is italic.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is italic.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the value indicating whether the font is italic.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The value indicating whether the font is italic.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    italic: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _italic$i: Nullable$1<boolean>;
    /**
     * Gets the number of characters covered by this font. Zero indicates the font controls from
     * the [[startIndex]] to the end of the string.
     * The number of characters covered by this font. Zero indicates the font controls from the
     * StartIndex to the end of the string.
     */
    readonly length: number;
    /**
     * Gets or sets the name of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The name of the font.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the name of the font.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The name of the font.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    name: string;
    /**
     * Gets the index of the first character covered by this font.
     * The index of the first character covered by this font.
     */
    readonly startIndex: number;
    /**
     * Gets or sets the value indicating whether the font is struck out.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is struck out.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the value indicating whether the font is struck out.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The value indicating whether the font is struck out.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    strikeout: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _strikeout$i: Nullable$1<boolean>;
    /**
     * Gets or sets the value indicating whether the font is superscript or subscript.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is superscript or subscript.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontSuperscriptSubscriptStyle]] enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the value indicating whether the font is superscript or subscript.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The value indicating whether the font is superscript or subscript.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontSuperscriptSubscriptStyle]] enumeration.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    /**
     * Gets or sets the underline style of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The underline style of the font.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontUnderlineStyle]] enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    /**
    * Gets or sets the underline style of the font.
    * <p class="body">
    * All characters in the selection range of this font will be affected by setting this property.
    * Getting this property will return a value which indicates the formatting of the first character
    * in this font's range.
    * </p>
    * <p class="note">
    * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
    * which is the value of a cell, and a default value is assigned, it will be ignored.
    * </p>
    * The underline style of the font.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontUnderlineStyle]] enumeration.
    * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
    * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
    */
    underlineStyle: FontUnderlineStyle;
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    readonly _k: boolean;
    /**
     * @hidden
     */
    readonly _g: IFormattedItem;
    /**
     * @hidden
     */
    abstract readonly _d: FormattingRunBase;
    /**
     * @hidden
     */
    abstract readonly _workbook: Workbook;
    /**
     * @hidden
     */
    abstract readonly _sheet: Sheet;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * @hidden
 */
export declare class FormattedStringValueReference extends Base implements IFormattedString {
    static $t: Type;
    private b;
    private a;
    private d;
    constructor(a: any, b: Workbook);
    setWorkbook(a: Workbook): void;
    toString(): string;
    readonly c: StringElement;
    readonly e: any;
}
/**
 * @hidden
 */
export interface IStringElementVisitor$2<TArg, TResult> {
    _visitFormattedStringElement$i(a: FormattedStringElement, b: TArg): TResult;
    _visitStringElement$i(a: StringElement, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IStringElementVisitor$2_$type: Type;
/**
 * Controls the formatting of a range of characters in a [[formattedString]].
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the [[formattedString]], a portion of the string is "selected" by calling either
 * <see cref="Excel.FormattedString.GetFont(int)">GetFont(int)</see> or
 * <see cref="Excel.FormattedString.GetFont(int,int)">GetFont(int,int)</see>. Formatting properties
 * are then set on the returned FormattedStringFont and all characters in the font's selection range are given these
 * properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedStringFont will return the formatting of the first character in font's
 * selection range. This is similar to Excel, which will update the formatting interface to reflect the formatting of the
 * first character in a selection range when a cell's text is selected.
 * </p>
 * @see@see@see */
export declare class FormattedStringFont extends FormattedFontBase {
    static $t: Type;
    constructor(a: FormattedString, b: number, c: number);
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    _h(a: Workbook): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    protected get__d(): FormattingRunBase;
    /**
     * @hidden
     */
    readonly _d: FormattingRunBase;
    /**
     * @hidden
     */
    protected get__sheet(): Sheet;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    protected get__workbook(): Workbook;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    _aa(): void;
    /**
     * Gets the formatted string which is controlled by this font.
     * The formatted string which is controlled by this font.
     */
    readonly formattedString: FormattedString;
}
/**
 * @hidden
 */
export declare class FormattedStringRun extends FormattingRunBase implements IComparable$1<FormattedStringRun> {
    static $t: Type;
    private _n;
    constructor(a: FormattedStringElement, b: number);
    equals(a: any): boolean;
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    getHashCode(): number;
    protected get_h(): boolean;
    readonly h: boolean;
    compareTo(a: FormattedStringRun): number;
    protected get_i(): number;
    protected set_i(a: number): void;
    i: number;
}
/**
 * Represents text with multiple paragraphs and mixed formatting in a shape.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedText, a portion of the text is "selected" by calling either [[getFont]]
 * or [[getFont]]. Formatting properties are then set on the returned
 * [[FormattedTextFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedTextFont]] will return the formatting of the first
 * character in font's selection range.
 * </p>
 * @see [[WorksheetShapeWithText.text]]
 */
export declare class FormattedText extends Base implements IFormattedItem, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _u: string;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _a;
    private _t;
    private _h;
    private _f;
    private _n;
    private _k;
    constructor();
    constructor(unformattedString: string);
    constructor(..._rest: any[]);
    /**
     * Returns the string that represents the [[FormattedText]], which is the unformatted string.
     * @return The string that represents the FormattedText.
     */
    toString(): string;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly owner: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    getOwnerAt(startIndex: number): IFormattedRunOwner;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * Creates a new [[FormattedText]] that is a copy of this one.
     * <p class="body">
     * This should be used if the same formatted text needs to be used in multiple shapes.
     * The FormattedText class can only exist as the [[WorksheetShapeWithText.text]]
     * of one shape at a time. If the FormattedText is already the text of a shape, and needs
     * to be set as the text of another shape, clone the FormattedText and set the returned
     * clone as text of the shape.
     * </p>
     * <p class="body">
     * The cloned FormattedText only takes its original configuration for this instance.
     * If this instance is cloned and than changed, the clone will not be changed as well; it will
     * remain as it was when it was cloned.
     * </p>
     * @return A new FormattedText that is a copy of this one.
     */
    clone(): FormattedText;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index to
     * the end of the string.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedTextFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @return A FormattedTextFont instance which controls the formatting of the end portion of the string.
     */
    getFont(startIndex: number): FormattedTextFont;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index for
     * the specified number of characters.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedTextFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @param length The number of characters after the start index controlled by the returned font.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @throws [[ArgumentOutOfRangeException]] 'length' is less than one. A zero length string cannot be controlled by a formatting font.
     * @return A FormattedTextFont instance which controls the formatting of a portion of the string.
     */
    getFont(startIndex: number, length: number): FormattedTextFont;
    /**
     * @hidden
     */
    _getFont(a: number): FormattedTextFont;
    /**
     * @hidden
     */
    _getFont1(a: number, b: number): FormattedTextFont;
    /**
     * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
     */
    private _getFormattingRuns;
    getFormattingRuns(): IEnumerable$1<FormattedTextFont>;
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _onFormattingChanged(): void;
    /**
     * @hidden
     */
    _y(a: FormattedTextParagraph, b: number, c: number): void;
    /**
     * @hidden
     */
    _aa(a: Sheet): void;
    /**
     * @hidden
     */
    _ac(a: WorksheetShapeWithText): void;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the paragraph at the specified zero-based index.
     * @param index The zero-based index of the paragraph to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     * @return The [[FormattedTextParagraph]] representing the paragraph at the specified index.
     */
    paragraphs(index: number): FormattedTextParagraph;
    /**
     * Gets the paragraphs in the formatted text.
     */
    paragraphs(): FormattedTextParagraphCollection;
    /**
     * @hidden
     */
    readonly _paragraphs$i: FormattedTextParagraphCollection;
    /**
     * Gets or sets the vertical alignment of the formatted text in the owning shape.
     * @throws [[InvalidEnumArgumentException]] The specified value is not defined in the [[VerticalTextAlignment]] enumeration.
     */
    /**
    * Gets or sets the vertical alignment of the formatted text in the owning shape.
    * @throws [[InvalidEnumArgumentException]] The specified value is not defined in the [[VerticalTextAlignment]] enumeration.
    */
    verticalAlignment: VerticalTextAlignment;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    _s: Nullable$1<HorizontalTextAlignment>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _owner: IFormattedTextOwner;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _o: CT_TextBodyPropertiesBase;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
}
/**
 * Controls the formatting of a range of characters in .
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the , a portion of the string is "selected" by calling either
 *  or .
 * Formatting properties are then set on the returned FormattedTextFont and all characters in the font's
 * selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedTextFont will return the formatting of the first character
 * in font's selection range.
 * </p>
 * @see@see@see */
export declare class FormattedTextFont extends FormattedFontBase {
    static $t: Type;
    constructor(a: FormattedText, b: number, c: number);
    /**
     * @hidden
     */
    _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    protected get__d(): FormattingRunBase;
    /**
     * @hidden
     */
    readonly _d: FormattingRunBase;
    /**
     * @hidden
     */
    protected get__sheet(): Sheet;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    protected get__workbook(): Workbook;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
    /**
     * Gets the  which is controlled by this font.
     * The FormattedText which is controlled by this font.
     */
    readonly formattedText: FormattedText;
}
/**
 * Represents a paragraph in .
 * @see */
export declare class FormattedTextParagraph extends Base implements IFormattedRunOwner, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _a;
    private _f;
    private readonly _r;
    private _j;
    private _c;
    private _p;
    private _t;
    constructor(a: FormattedText, b: number, c: string, d: string);
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    addRun(run: FormattingRunBase): void;
    /**
     * @hidden
     */
    createRun(absoluteStartIndex: number): FormattingRunBase;
    /**
     * @hidden
     */
    getFormattingRuns(workbook: Workbook): List$1<FormattingRunBase>;
    /**
     * @hidden
     */
    insertRun(runIndex: number, run: FormattingRunBase): void;
    /**
     * @hidden
     */
    _u(a: FormattedTextRun): void;
    /**
     * @hidden
     */
    _e(a: FormattedText): FormattedTextParagraph;
    /**
     * @hidden
     */
    _getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    /**
     * @hidden
     */
    _v(a: number, b: FormattedTextRun): void;
    /**
     * @hidden
     */
    _w(a: FormattedText): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ab;
    /**
     * Gets or sets the alignment of the paragraph.
     */
    /**
    * Gets or sets the alignment of the paragraph.
    */
    alignment: HorizontalTextAlignment;
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets the owning  to which the paragraph belongs or null if the
     * paragraph has been removed from its owning formatted text.
     */
    readonly formattedText: FormattedText;
    /**
     * Gets the zero-based index of the paragraph's first character in the overall formatted text.
     */
    /**
    * Gets the zero-based index of the paragraph's first character in the overall formatted text.
    */
    startIndex: number;
    /**
     * Gets or sets the raw string of the paragraph.
     * <p class="body">
     * If the new unformatted string assigned is shorter than the previous unformatted string, all formatting
     * outside the range of the new value will be lost.
     * </p>
     * The unformatted string.
     * @throws [[ArgumentNullException]] The value assigned is a null string.
     */
    /**
    * Gets or sets the raw string of the paragraph.
    * <p class="body">
    * If the new unformatted string assigned is shorter than the previous unformatted string, all formatting
    * outside the range of the new value will be lost.
    * </p>
    * The unformatted string.
    * @throws [[ArgumentNullException]] The value assigned is a null string.
    */
    unformattedString: string;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    readonly _s: string;
    /**
     * @hidden
     */
    readonly _n: number;
    /**
     * @hidden
     */
    _m(a: Nullable$1<boolean>): number;
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
}
/**
 * @hidden
 */
export declare class FormattedTextParagraphCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: FormattedTextParagraphCollection, c: FormattedTextParagraph, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FormattedTextParagraphCollection;
    readonly a: FormattedTextParagraph;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[FormattedTextParagraph]] instances in .
 * @see [[FormattedText.paragraphs]]
 */
export declare class FormattedTextParagraphCollection extends Base implements ICollection$1<FormattedTextParagraph> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FormattedText;
    private _h;
    static staticInit(): void;
    constructor(a: FormattedText);
    /**
     * @hidden
     */
    add(paragraph: FormattedTextParagraph): void;
    /**
     * Adds a paragraph with the specified text and returns the [[FormattedTextParagraph]]
     * representing the new paragraph.
     * @param paragraphText The text in the paragraph.
     * @return The FormattedTextParagraph representing the new paragraph.
     */
    add(paragraphText: string): FormattedTextParagraph;
    /**
     * @hidden
     */
    _add$e(a: FormattedTextParagraph): void;
    /**
     * @hidden
     */
    copyTo(array: FormattedTextParagraph[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: string): FormattedTextParagraph;
    /**
     * Removes all paragraphs from the formatted text.
     */
    clear(): void;
    /**
     * Determines whether the specified paragraph exists in the collection.
     * @param paragraph The paragraph to find in the collection.
     * @return True if the paragraph exists in the collection; False otherwise.
     */
    contains(paragraph: FormattedTextParagraph): boolean;
    [Symbol.iterator](): EnumeratorWrapper<FormattedTextParagraph>;
    /**
     * Gets the enumerator to iterate over all paragraphs.
     */
    getEnumerator(): IEnumerator$1<FormattedTextParagraph>;
    /**
     * Gets the zero-based index of the specified paragraph in the collection.
     * @param paragraph The paragraph to find in the collection.
     * @return The zero-based index of the paragraph in the collection or -1 if the paragraph doesn't exist in the collection.
     */
    indexOf(paragraph: FormattedTextParagraph): number;
    /**
     * Inserts a paragraph with the specified text and returns the [[FormattedTextParagraph]]
     * representing the new paragraph.
     * @param index The zero-based index in the collection where the paragraph should be inserted.
     * @param paragraphText The text in the paragraph.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than the number of paragraphs in the collection.
     * @return The FormattedTextParagraph representing the new paragraph.
     */
    insert(index: number, paragraphText: string): FormattedTextParagraph;
    /**
     * Removes the specified paragraph from the collection.
     * @param paragraph The paragraph to remove from the collection.
     * @return True if the paragraph was in the collection and was removed; False otherwise.
     */
    remove(paragraph: FormattedTextParagraph): boolean;
    /**
     * Removes the paragraph at the specified zero-based index in the collection.
     * @param index The zero-based index of the paragraph to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _n(a: FormattedTextParagraphCollection): void;
    /**
     * @hidden
     */
    _o(a: number, b: FormattedTextParagraph, c: string): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of paragraphs in the collection.
     */
    readonly count: number;
    /**
     * Gets the paragraph at the specified zero-based index.
     * @param index The zero-based index of the paragraph to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     * @return The [[FormattedTextParagraph]] representing the paragraph at the specified index.
     */
    item(a: number): FormattedTextParagraph;
}
/**
 * @hidden
 */
export declare class FormattedTextRun extends FormattingRunBase {
    static $t: Type;
    private q;
    private n;
    constructor(a: FormattedTextParagraph, b: number);
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    protected get_h(): boolean;
    readonly h: boolean;
    m(a: FormattingRunBase, b: Workbook): void;
    protected get_i(): number;
    protected set_i(a: number): void;
    i: number;
    readonly p: FormattedTextParagraph;
    o: IShallowCloneable;
}
/**
 * @hidden
 */
export interface IRegionBlockingValue {
    removeFromRegion(): void;
    throwBlockingException(): void;
    throwExceptionWhenMergedCellsInRegion(): void;
    throwExceptionWhenTableInRegion(): void;
    readonly blockedRegion: WorksheetRegion;
}
/**
 * @hidden
 */
export declare let IRegionBlockingValue_$type: Type;
/**
 * @hidden
 */
export declare class ArrayFormula_FormulaChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ArrayFormula, c: WorksheetRegion);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: ArrayFormula;
    readonly b: Worksheet;
    readonly d: WorksheetRegionAddress;
    c(): WorksheetRegion;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents an array formula for a group of cells.
 * <p class="body">
 * Array formulas are similar to regular formula in that they have the same grammar. However, array formulas must be set
 * on a single region of cells only. When the array formula is applied to a region of cells, each cell's
 * <see cref="WorksheetCell.Formula">Formula</see> property will be the array formula. The
 * <see cref="WorksheetCell.Formula">Value</see> of each cell cannot be changed unless [[clearCellRange]] is
 * called on the array formula or another value is applied to a region of cells which completely contains the array
 * formula's region.
 * </p>
 * <p class="body">
 * Because the array formula stores the region of the cells to which it is applied in the [[cellRange]] property,
 * the array formula can only be applied to one region of cells.
 * </p>
 * <p class="body">
 * Array formulas are created through Microsoft Excel by selecting a region of cells, entering a formula for
 * that range, and pressing Ctrl+Shift+Enter. This causes the formula of each cell in the region to appear as follows:
 * {=Formula}.
 * </p>
 * <p class="body">
 * See the Microsoft Excel documentation for more information on array formulas.
 * </p>
 */
export declare class ArrayFormula extends Formula implements IRegionBlockingValue {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cc;
    private _ck;
    constructor(a: number, b: number);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _bp(a: WorksheetRow, b: number, c?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion[], b: WorksheetRow, c: number, d?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _br(a: WorksheetRow, b: number, c: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _g(): Formula;
    /**
     * @hidden
     */
    protected get__z(): WorkbookFormat;
    /**
     * @hidden
     */
    protected set__z(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__ap(): boolean;
    /**
     * @hidden
     */
    protected get__bb(): number;
    /**
     * @hidden
     */
    readonly _bb: number;
    /**
     * @hidden
     */
    protected get__ab(): WorksheetRow;
    /**
     * @hidden
     */
    readonly _ab: WorksheetRow;
    /**
     * @hidden
     */
    protected get__aa(): WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _aa: WorksheetCellAddress;
    /**
     * @hidden
     */
    _b7(): void;
    /**
     * @hidden
     */
    protected get__t(): Sheet;
    /**
     * @hidden
     */
    readonly _t: Sheet;
    /**
     * @hidden
     */
    removeFromRegion(): void;
    /**
     * @hidden
     */
    throwBlockingException(): void;
    /**
     * @hidden
     */
    throwExceptionWhenMergedCellsInRegion(): void;
    /**
     * @hidden
     */
    throwExceptionWhenTableInRegion(): void;
    /**
     * @hidden
     */
    readonly blockedRegion: WorksheetRegion;
    /**
     * Removes this array formula as the formula for the cells to which it was applied.
     * <p class="body">
     * After this method returns, the [[cellRange]] will be null.
     * </p>
     */
    clearCellRange(): void;
    /**
     * @hidden
     */
    static _ci(a: string, b: Workbook): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param fileFormat The file format to use when parsing the array formula. This will be used to determine certain limits which are format dependant.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param fileFormat The file format to use when parsing the array formula. This will be used to determine certain limits which are format dependant.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat, culture: string | CultureInfo): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _parse7(a: string, b: CellReferenceMode): ArrayFormula;
    /**
     * @hidden
     */
    static _parse10(a: string, b: CellReferenceMode, c: CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _parse8(a: string, b: CellReferenceMode, c: WorkbookFormat): ArrayFormula;
    /**
     * @hidden
     */
    static _parse9(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _cn(a: string, b: CellReferenceMode, c: ArrayFormula): {
        ret: boolean;
        p2: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _ct(a: string, b: CellReferenceMode, c: CultureInfo, d: ArrayFormula): {
        ret: boolean;
        p3: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _co(a: string, b: CellReferenceMode, c: ArrayFormula, d: FormulaParseException): {
        ret: boolean;
        p2: ArrayFormula;
        p3: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cu(a: string, b: CellReferenceMode, c: CultureInfo, d: ArrayFormula, e: FormulaParseException): {
        ret: boolean;
        p3: ArrayFormula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cp(a: string, b: CellReferenceMode, c: WorkbookFormat, d: ArrayFormula): {
        ret: boolean;
        p3: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _cr(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: ArrayFormula): {
        ret: boolean;
        p4: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _cq(a: string, b: CellReferenceMode, c: WorkbookFormat, d: ArrayFormula, e: FormulaParseException): {
        ret: boolean;
        p3: ArrayFormula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cs(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: ArrayFormula, f: FormulaParseException): {
        ret: boolean;
        p4: ArrayFormula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    _c0(a: CellShiftOperation, b: ICellShiftOperationOverride, c: ShiftingArrayFormulaInfo): void;
    /**
     * @hidden
     */
    _cm(a: CellShiftOperation, b: Nullable$1<WorksheetRegionAddress>, c: ShiftingArrayFormulaInfo): {
        ret: boolean;
        p2: ShiftingArrayFormulaInfo;
    };
    /**
     * @hidden
     */
    private _cy;
    /**
     * @hidden
     */
    private static _cj;
    /**
     * @hidden
     */
    private static _cd;
    /**
     * @hidden
     */
    private static _c1;
    /**
     * @hidden
     */
    private static _c2;
    /**
     * Gets the cells to which the array formula is applied.
     * <p class="body">
     * If this is null, the formula has not yet been applied.
     * </p>
     * The cells to which the array formula is applied.
     */
    readonly cellRange: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class ShiftingArrayFormulaInfo extends Base {
    static $t: Type;
    private readonly b;
    private readonly a;
    constructor(a: ArrayFormula);
    c(a: CellShiftOperation, b: ArrayFormula): void;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor extends Base {
    static $t: Type;
    private a;
    private c;
    constructor();
    e(a: FormulaToken): void;
    g(): void;
    protected f(): void;
    h(): void;
    i(a: Area3DNToken): void;
    j(a: Area3DToken): void;
    k(a: AreaErr3DToken): void;
    l(a: AreaErrToken): void;
    m(a: AreaNToken): void;
    n(a: AreaToken): void;
    o(a: ArrayToken): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    s(a: AttrSpaceToken): void;
    t(a: AttrSumToken): void;
    u(a: AttrVolatileToken): void;
    v(a: BinaryOperatorToken): void;
    w(a: BoolToken): void;
    x(a: CellReferenceToken): void;
    y(a: ErrToken): void;
    z(a: ExpToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    ad(a: IntToken): void;
    ae(a: MemAreaOperator): void;
    af(a: MemErrOperator): void;
    ag(a: MemFuncOperator): void;
    ah(a: MemNoMemOperator): void;
    ai(a: MissArgToken): void;
    aj(a: NameToken): void;
    ak(a: NameXToken): void;
    al(a: NumberToken): void;
    am(a: OperandToken): void;
    an(a: ParenToken): void;
    aq(a: ReferenceToken): void;
    ao(a: Ref3DNToken): void;
    ap(a: Ref3DToken): void;
    ar(a: RefErr3dToken): void;
    as(a: RefErrToken): void;
    at(a: RefNToken): void;
    au(a: RefToken): void;
    av(a: StrToken): void;
    aw(a: StructuredTableReference): void;
    ax(a: TblToken): void;
    ay(a: UnaryOperatorToken): void;
    b: FormulaContext;
    protected d: number;
}
/**
 * @hidden
 */
export declare class Formula_CanShiftSafelyChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a1;
    private a3;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    au(a: RefToken): void;
    static a2(a: FormulaContext, b: Point): boolean;
    private static a0;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor$1<TResult> extends Base {
    static $t: Type;
    protected $tResult: Type;
    private b;
    protected az: number;
    private av;
    constructor($tResult: Type);
    d(a: FormulaToken): TResult;
    protected a0(): void;
    a1(): void;
    ax(): boolean;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    e(a: Area3DNToken): TResult;
    f(a: Area3DToken): TResult;
    g(a: AreaErr3DToken): TResult;
    h(a: AreaErrToken): TResult;
    i(a: AreaNToken): TResult;
    j(a: AreaToken): TResult;
    k(a: ArrayToken): TResult;
    l(a: AttrChooseToken): TResult;
    m(a: AttrIfToken): TResult;
    n(a: AttrSkipToken): TResult;
    o(a: AttrSpaceToken): TResult;
    p(a: AttrSumToken): TResult;
    q(a: AttrVolatileToken): TResult;
    r(a: BinaryOperatorToken): TResult;
    s(a: BoolToken): TResult;
    t(a: CellReferenceToken): TResult;
    u(a: ErrToken): TResult;
    v(a: ExpToken): TResult;
    w(a: FunctionOperator): TResult;
    x(a: IFunctionToken): TResult;
    y(a: FunctionVOperator): TResult;
    z(a: IntToken): TResult;
    aa(a: MemAreaOperator): TResult;
    ab(a: MemErrOperator): TResult;
    ac(a: MemFuncOperator): TResult;
    ad(a: MemNoMemOperator): TResult;
    ae(a: MissArgToken): TResult;
    af(a: NameToken): TResult;
    ag(a: NameXToken): TResult;
    ah(a: NumberToken): TResult;
    ai(a: OperandToken): TResult;
    aj(a: ParenToken): TResult;
    am(a: ReferenceToken): TResult;
    ak(a: Ref3DNToken): TResult;
    al(a: Ref3DToken): TResult;
    an(a: RefErr3dToken): TResult;
    ao(a: RefErrToken): TResult;
    ap(a: RefNToken): TResult;
    aq(a: RefToken): TResult;
    ar(a: StrToken): TResult;
    as(a: StructuredTableReference): TResult;
    at(a: TblToken): TResult;
    au(a: UnaryOperatorToken): TResult;
    c: FormulaContext;
    protected readonly aw: boolean;
    protected get_a(): FormulaToken[];
    protected readonly a: FormulaToken[];
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenModifierVisitor extends FormulaTokenVisitor$1<boolean> {
    static $t: Type;
    private a2;
    private a4;
    private readonly a7;
    private readonly a6;
    constructor();
    a1(): void;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    protected a3: FormulaToken;
    readonly a5: boolean;
}
/**
 * @hidden
 */
export declare class Formula_ConnectReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    f(a: Area3DToken): boolean;
    j(a: AreaToken): boolean;
    t(a: CellReferenceToken): boolean;
    af(a: NameToken): boolean;
    ag(a: NameXToken): boolean;
    al(a: Ref3DToken): boolean;
    aq(a: RefToken): boolean;
    as(a: StructuredTableReference): boolean;
    static bb(a: FormulaContext, b: NameToken): boolean;
    static bc(a: FormulaContext, b: NameXToken): boolean;
    static a9(a: FormulaContext, b: boolean): Formula_ConnectReferencesVisitor;
    bd(a: CellReferenceToken): boolean;
}
/**
 * @hidden
 */
export declare class Formula_ConvertTableReferencesToRangesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static a9(a: FormulaContext, b: WorksheetTable): Formula_ConvertTableReferencesToRangesVisitor;
}
/**
 * @hidden
 */
export declare class Formula_AllReferencedRegionsChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private a3;
    private a2;
    constructor();
    g(): void;
    x(a: CellReferenceToken): void;
    static az(a: FormulaContext, b: Worksheet): WorksheetRegionAddress[];
    private static a1;
}
/**
 * @hidden
 */
export declare class Formula_FixPasteReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private bc;
    private bf;
    private bb;
    private be;
    private readonly bd;
    private a8;
    private bg;
    constructor();
    a1(): void;
    f(a: Area3DToken): boolean;
    t(a: CellReferenceToken): boolean;
    af(a: NameToken): boolean;
    ag(a: NameXToken): boolean;
    al(a: Ref3DToken): boolean;
    as(a: StructuredTableReference): boolean;
    static ba(a: Worksheet, b: WorkbookReferenceBase, c: FormulaContext, d: Nullable$1<boolean>, e: (arg1: string) => string, f: (arg1: NamedReferenceBase, arg2: (arg1: Formula) => void) => NamedReferenceBase): Formula_FixPasteReferencesVisitor;
    private bh;
}
/**
 * @hidden
 */
export declare class Formula_IsReferencingAnythingInRegionChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a3;
    private a2;
    private a1;
    constructor();
    g(): void;
    x(a: CellReferenceToken): void;
    static a4(a: FormulaContext, b: Worksheet, c: WorksheetRegionAddress): boolean;
    private static a0;
}
/**
 * @hidden
 */
export declare class Formula_OffsetReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    j(a: AreaToken): boolean;
    v(a: ExpToken): boolean;
    aa(a: MemAreaOperator): boolean;
    aq(a: RefToken): boolean;
    at(a: TblToken): boolean;
    static a9(a: FormulaContext, b: Point): Formula_OffsetReferencesVisitor;
}
/**
 * @hidden
 */
export declare class Formula_CellsShiftedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private a8;
    private bb;
    constructor();
    a1(): void;
    j(a: AreaToken): boolean;
    aq(a: RefToken): boolean;
    private bc;
    private bd;
    private be;
    static ba(a: FormulaContext, b: CellShiftOperation, c: ReferenceShiftType): Formula_CellsShiftedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_CurrentFormatChangedVisitor extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a2;
    private a1;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    at(a: RefNToken): void;
    static a0(a: FormulaContext, b: WorkbookFormat, c: WorkbookFormat): Formula_CurrentFormatChangedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_NamedReferenceRemovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private a8;
    private bb;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static ba(a: FormulaContext, b: NamedReferenceBase): Formula_NamedReferenceRemovedVisitor;
    private bc;
}
/**
 * @hidden
 */
export declare class Formula_TableResizingVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bd;
    private bb;
    private ba;
    constructor();
    a1(): void;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static a9(a: FormulaContext, b: WorksheetTable, c: List$1<WorksheetTableColumn>): Formula_TableResizingVisitor;
    readonly bc: boolean;
}
/**
 * @hidden
 */
export declare class Formula_WorksheetMovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bb;
    private ba;
    constructor();
    a1(): void;
    t(a: CellReferenceToken): boolean;
    static a9(a: FormulaContext, b: Worksheet, c: number): Formula_WorksheetMovedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_WorksheetRemovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bb;
    private ba;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    t(a: CellReferenceToken): boolean;
    static a9(a: FormulaContext, b: Worksheet, c: number): Formula_WorksheetRemovedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_VerifyFormatLimitsVisitor extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private az;
    private a2;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    au(a: RefToken): void;
    static a1(a: FormulaContext, b: FormatLimitErrors, c: WorkbookFormat): Formula_VerifyFormatLimitsVisitor;
}
/**
 * @hidden
 */
export declare abstract class FormulaToken extends Base {
    static $t: Type;
    static readonly a: FormulaToken[];
    private g;
    constructor(a: TokenClass);
    toString(): string;
    abstract m(a: FormulaTokenVisitor): void;
    abstract d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    abstract e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    abstract l(a: FormulaContext, b: GetFormulaStringInfo): string;
    abstract readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    h: TokenClass;
    static c(a: IBiffRecordStream, b: number): FormulaToken;
    static b(a: IBiffRecordStream, b: number, c: number[], d: number): {
        ret: FormulaToken;
        p2?: number[];
        p3?: number;
    };
    static i(a: number): TokenClass;
}
/**
 * @hidden
 */
export declare class SharedTokenConverter extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    private static a2;
    private a4;
    constructor();
    d(a: FormulaToken): FormulaToken;
    e(a: Area3DNToken): FormulaToken;
    f(a: Area3DToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    ak(a: Ref3DNToken): FormulaToken;
    al(a: Ref3DToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    static a3(a: FormulaContext, b: boolean): SharedTokenConverter;
}
/**
 * The exception thrown when a formula parse error occurs.
 */
export declare class FormulaParseException extends BaseError {
    static $t: Type;
    private _c;
    private _e;
    private _g;
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: BaseError);
    constructor(charIndexOfError: number, formulaValue: string, message: string, portionWithError: string);
    constructor(..._rest: any[]);
    /**
     * Gets the character index in the [[formulaValue]] at which the parse error occurred.
     * The character index in the FormulaValue at which the parse error occurred.
     */
    readonly charIndexOfError: number;
    /**
     * Gets the formula string which had the error being parsed.
     * The formula string which had the error being parsed.
     */
    readonly formulaValue: string;
    /**
     * Gets the error message and the portion of the formula with the error.
     */
    protected get_message(): string;
    /**
     * Gets the portion of the formula which contains the error.
     */
    readonly portionWithError: string;
}
/**
 * @hidden
 */
export declare class NamedReferenceFormula extends SingleTargetFormula {
    static $t: Type;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: NamedReferenceFormula);
    constructor(a: number, b: SingleTargetFormula);
    constructor(a: number, ..._rest: any[]);
    _g(): Formula;
    _b7(): void;
}
/**
 * @hidden
 */
export declare class To3DTokenConverter extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    private static a3;
    private a2;
    constructor();
    d(a: FormulaToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    static a4(a: FormulaContext): To3DTokenConverter;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_DynamicReferenceCollection extends Base implements IExcelCalcReferenceCollection {
    static $t: Type;
    private readonly _a;
    constructor(a: SingleTargetFormula);
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_StaticReferenceCollection extends Base implements IExcelCalcReferenceCollection {
    static $t: Type;
    private readonly _a;
    constructor(a: SingleTargetFormula);
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_StaticReferenceFinder extends FormulaTokenVisitor {
    static $t: Type;
    private static a2;
    private a1;
    private a0;
    private readonly a5;
    private az;
    private readonly a4;
    constructor();
    g(): void;
    protected f(): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    v(a: BinaryOperatorToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    aj(a: NameToken): void;
    am(a: OperandToken): void;
    ay(a: UnaryOperatorToken): void;
    private a6;
    static a3(a: FormulaContext, b: SingleTargetFormula): SingleTargetFormula_StaticReferenceFinder;
    private a7;
    private a8;
}
/**
 * Abstract base class for classes which control pane settings.
 * @see [[FrozenPaneSettings]]
 * @see [[UnfrozenPaneSettings]]
 */
export declare abstract class PaneSettingsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _k;
    private _n;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * Resets the pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the first visible column in the right pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the right pane(s) of the worksheet and
     * is only used if the worksheet is split vertically.
     * </p>
     * The zero-based index of the first visible column in the right pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the first visible column in the right pane(s) of the worksheet.
    * <p class="body">
    * This affects the scroll position for the right pane(s) of the worksheet and
    * is only used if the worksheet is split vertically.
    * </p>
    * The zero-based index of the first visible column in the right pane(s).
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
    * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    firstColumnInRightPane: number;
    /**
     * Gets or sets the first visible row in the bottom pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the bottom pane(s) of the worksheet and
     * is only used if the worksheet is split horizontally.
     * </p>
     * The zero-based index of the first visible row in the bottom pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the first visible row in the bottom pane(s) of the worksheet.
    * <p class="body">
    * This affects the scroll position for the bottom pane(s) of the worksheet and
    * is only used if the worksheet is split horizontally.
    * </p>
    * The zero-based index of the first visible row in the bottom pane(s).
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
    * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    firstRowInBottomPane: number;
    /**
     * @hidden
     */
    abstract readonly _h: boolean;
    /**
     * @hidden
     */
    abstract readonly _i: boolean;
    /**
     * @hidden
     */
    readonly _e: DisplayOptions;
    /**
     * @hidden
     */
    _f(): PaneSettingsBase;
    /**
     * @hidden
     */
    _j(): boolean;
    /**
     * @hidden
     */
    _v(a: PaneSettingsBase): void;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Class which controls the way frozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[UnfrozenPaneSettings]]
 */
export declare class FrozenPaneSettings extends PaneSettingsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _w;
    private _aa;
    private _ad;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    protected get__i(): boolean;
    /**
     * @hidden
     */
    readonly _i: boolean;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the frozen pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the number of columns frozen at the left of the worksheet.
     * <p class="body">
     * The frozen columns will always remain in view, regardless of the horizontal scroll position of
     * the worksheet.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the number of frozen columns specified is more than the amount of visible columns
     * in the worksheet, the worksheet may not scroll correctly.
     * </p>
     * The number of columns frozen at the left of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid column count (0 to [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the number of columns frozen at the left of the worksheet.
    * <p class="body">
    * The frozen columns will always remain in view, regardless of the horizontal scroll position of
    * the worksheet.
    * </p>
    * <p class="note">
    * <B>Note:</B> If the number of frozen columns specified is more than the amount of visible columns
    * in the worksheet, the worksheet may not scroll correctly.
    * </p>
    * The number of columns frozen at the left of the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid column count (0 to [[Workbook.maxExcelColumnCount]] or
    * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    frozenColumns: number;
    /**
     * Gets or sets the number of rows frozen at the top of the worksheet.
     * <p class="body">
     * The frozen rows will always remain in view, regardless of the vertical scroll position of
     * the worksheet.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the number of frozen rows specified is more than the amount of visible rows
     * in the worksheet, the worksheet may not scroll correctly.
     * </p>
     * The number of rows frozen at the top of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid row count (0 to [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the number of rows frozen at the top of the worksheet.
    * <p class="body">
    * The frozen rows will always remain in view, regardless of the vertical scroll position of
    * the worksheet.
    * </p>
    * <p class="note">
    * <B>Note:</B> If the number of frozen rows specified is more than the amount of visible rows
    * in the worksheet, the worksheet may not scroll correctly.
    * </p>
    * The number of rows frozen at the top of the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid row count (0 to [[Workbook.maxExcelRowCount]] or
    * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    frozenRows: number;
    /**
     * @hidden
     */
    _z: boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _j(): boolean;
}
/**
 * @hidden
 */
export declare class GenericCachedCollection$1<T extends GenericCacheElement> extends Base implements ICollection$1<T> {
    static $t: Type;
    protected $t: Type;
    _b: GenericElementHashSet$1<T>;
    private _c;
    private _h;
    constructor($t: Type, a: number, b: Workbook, c: number);
    constructor($t: Type, a: number, b: Workbook, c: number, d: number);
    constructor($t: Type, a: number, ..._rest: any[]);
    add(a: T): void;
    clear(): void;
    contains(a: T): boolean;
    copyTo(a: T[], b: number): void;
    readonly count: number;
    readonly isReadOnly: boolean;
    remove(a: T): boolean;
    getEnumerator(): IEnumerator$1<T>;
    getEnumeratorObject(): IEnumerator;
    _add(a: T): void;
    _a(a: T): T;
    _g(a: T): number;
    _k(a: T, b: T): {
        p1: T;
    };
    protected _l(a: T): void;
    _n(a: boolean): void;
    _m(): void;
    _remove(a: T): boolean;
    readonly _count: number;
    _i: number;
    readonly _d: Workbook;
}
/**
 * @hidden
 */
export interface IGenericCachedCollectionEx extends IWorkbookProvider {
}
/**
 * @hidden
 */
export declare let IGenericCachedCollectionEx_$type: Type;
/**
 * @hidden
 */
export declare class GenericCachedCollectionEx$1<T extends GenericCacheElementEx> extends GenericCachedCollection$1<T> implements IGenericCachedCollectionEx {
    static $t: Type;
    protected $t: Type;
    private _o;
    constructor($t: Type, a: T, b: Workbook, c: number);
    protected _l(a: T): void;
    _remove(a: T): boolean;
    _p: T;
    readonly workbook: Workbook;
}
/**
 * @hidden
 */
export declare class GenericElementHashSet$1<T extends GenericCacheElement> extends Base {
    static $t: Type;
    protected $t: Type;
    private l;
    private a;
    private b;
    private c;
    private h;
    private k;
    private o;
    constructor($t: Type, a: number);
    private s;
    f(a: T, b: T): {
        ret: boolean;
        p1: T;
    };
    g(a: T, b: T): {
        ret: boolean;
        p1: T;
    };
    p(a: T[], b: number): void;
    d(a: number, b: number): {
        ret: GenericElementHashSet_Entry$1<T>[];
        p1: number;
    };
    e(a: number, b: number, c: number): {
        ret: GenericElementHashSet_Entry$1<T>[];
        p1: number;
        p2: number;
    };
    private _j;
    j(): IEnumerator$1<T>;
    u(a: boolean): void;
    t(): void;
    i(a: T): boolean;
    private static q;
    private n;
    private r;
    readonly m: number;
}
/**
 * @hidden
 */
export declare class GenericElementHashSet_Entry$1<T extends GenericCacheElement> extends ValueType {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: T, c: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly b: number;
    readonly a: T;
}
/**
 * @hidden
 */
export declare class HashHelpers extends Base {
    static $t: Type;
    private static readonly a;
    static c(a: number): number;
    static d(a: any): number;
    private static b;
}
/**
 * Represents a column in a Microsoft Excel worksheet.
 */
export declare class WorksheetColumn extends RowColumnBase implements IChangeInfoContext, IWorksheetRegionAddressContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    static readonly _au: number;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _ap;
    private _an;
    private _ai;
    private _al;
    constructor(a: Worksheet, b: number);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    readonly _a: ChangeInfo[];
    /**
     * @hidden
     */
    _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__l(): boolean;
    /**
     * @hidden
     */
    protected set__l(a: boolean): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _l: boolean;
    /**
     * Gets the 0-based index of the column in the worksheet.
     * The 0-based index of the column in the worksheet.
     */
    protected get_index(): number;
    /**
     * Gets the 0-based index of the column in the worksheet.
     * The 0-based index of the column in the worksheet.
     */
    readonly index: number;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    protected get__n(): number;
    /**
     * @hidden
     */
    protected set__n(a: number): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _n: number;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Sets the [[width]] to the extent required to display the contents of this column.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     */
    autoFitWidth(): void;
    /**
     * Sets the width to the extent required to display all of the contents for the specified range of rows.
     * @param startRowIndex A 0-based index of the first row whose contents are to be calculated
     * @param endRowIndex A 0-based index of the last row whose contents are to be calculated
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     * @throws [[ArgumentOutOfRangeException]] The 'startRowIndex' must be greater than or equal to 0, less than or equal to the 'endRowIndex' and less than or equal to the Count of the Rows in the Worksheet. Similarly the 'endRowIndex' must be greater than or equal to the 'startRowIndex' and less than the [[WorksheetRowCollection.maxCount]] of the Worksheet's [[Worksheet.rows]] collection which depends upon the [[Workbook.currentFormat]]
     */
    autoFitWidth(startRowIndex: number, endRowIndex: number): void;
    /**
     * @hidden
     */
    _autoFitWidth(): void;
    /**
     * @hidden
     */
    _autoFitWidth1(a: number, b: number): void;
    /**
     * Returns the width required for the column to display all of its contents.
     * @return The width needed for the column to display all of its contents. The value is the same units as used for the [[width]] property.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     */
    calculateAutoFitWidth(): number;
    /**
     * Returns the width required for the column to display all of the contents for the specified range of rows.
     * @param startRowIndex A 0-based index of the first row whose contents are to be calculated
     * @param endRowIndex A 0-based index of the last row whose contents are to be calculated
     * @return The width needed for the column to display the contents of the rows in the specified range. The value is the same units as used for the [[width]] property.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     * @throws [[ArgumentOutOfRangeException]] The 'startRowIndex' must be greater than or equal to 0, less than or equal to the 'endRowIndex' and less than or equal to the Count of the Rows in the Worksheet. Similarly the 'endRowIndex' must be greater than or equal to the 'startRowIndex' and less than the [[WorksheetRowCollection.maxCount]] of the Worksheet's [[Worksheet.rows]] collection which depends upon the [[Workbook.currentFormat]]
     */
    calculateAutoFitWidth(startRowIndex: number, endRowIndex: number): number;
    /**
     * @hidden
     */
    _calculateAutoFitWidth(): number;
    /**
     * @hidden
     */
    _calculateAutoFitWidth1(a: number, b: number): number;
    /**
     * Gets the column width in the specified units, or NaN if the column has the default width.
     * <p class="body">
     * If 'units' is Character256th, the value returned will be the same as the value of the [[width]]
     * property, with one exception: if the column has the default width, this method will return NaN and Width will return -1.
     * </p>
     * @param units The units in which the width should be returned.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @return The column width in the specified units, or NaN if the column has the default width.
     * @see [[width]]
     * @see [[setWidth]]
     * @see [[Worksheet.getDefaultColumnWidth]]
     */
    getWidth(units: WorksheetColumnWidthUnit): number;
    /**
     * Sets the column width in the specified units.
     * <p class="body">
     * Setting a value of NaN will reset the column width so that the column uses the default column width of the worksheet.
     * </p>
     * @param value The width to set on the column, expressed in the specified 'units'.
     * @param units The units in which the 'value' is expressed.
     * @throws [[ArgumentException]] 'value' is infinity.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @throws [[InvalidOperationException]] If the column was removed from the worksheet.
     * @see [[width]]
     * @see [[getWidth]]
     * @see [[Worksheet.setDefaultColumnWidth]]
     */
    setWidth(value: number, units: WorksheetColumnWidthUnit): void;
    /**
     * @hidden
     */
    _ay(a: number, b: number, c: CellSizeMeasurementContext): Nullable$1<number>;
    /**
     * @hidden
     */
    _a1(a: WorksheetColumn): void;
    /**
     * @hidden
     */
    _a2(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _aj(): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _ak(): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _a3(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _a4(): void;
    /**
     * @hidden
     */
    private static _ag;
    /**
     * @hidden
     */
    private static _af;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private _a5;
    /**
     * Gets or sets the column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * <p class="body">
     * If the width of the column is less than zero, the [[Worksheet.defaultColumnWidth]] of the
     * owning worksheet will be used as the column's width.
     * </p>
     * <p class="body">
     * The value assigned must be between -1 and 65535. Invalid values will be automatically adjusted to valid values.
     * </p>
     * <p class="body">
     * Setting or getting this property is equivalent to calling [[setWidth]] or [[getWidth]] using the
     * [[WorksheetColumnWidthUnit]] value of Character256th.
     * </p>
     * The column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * @throws [[InvalidOperationException]] From the setter if the column was removed from the worksheet.
     * @see [[getWidth]]
     * @see [[setWidth]]
     * @see [[Workbook.characterWidth256thsToPixels]]
     * @see [[Workbook.pixelsToCharacterWidth256ths]]
     */
    /**
    * Gets or sets the column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
    * <p class="body">
    * If the width of the column is less than zero, the [[Worksheet.defaultColumnWidth]] of the
    * owning worksheet will be used as the column's width.
    * </p>
    * <p class="body">
    * The value assigned must be between -1 and 65535. Invalid values will be automatically adjusted to valid values.
    * </p>
    * <p class="body">
    * Setting or getting this property is equivalent to calling [[setWidth]] or [[getWidth]] using the
    * [[WorksheetColumnWidthUnit]] value of Character256th.
    * </p>
    * The column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
    * @throws [[InvalidOperationException]] From the setter if the column was removed from the worksheet.
    * @see [[getWidth]]
    * @see [[setWidth]]
    * @see [[Workbook.characterWidth256thsToPixels]]
    * @see [[Workbook.pixelsToCharacterWidth256ths]]
    */
    width: number;
    /**
     * @hidden
     */
    private _a7;
    /**
     * @hidden
     */
    readonly _at: number;
    /**
     * @hidden
     */
    readonly _aq: number;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    readonly _m: boolean;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * A collection of hidden [[WorksheetColumn]] instances.
 * <p class="body">
 * The columns in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the columns in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other columns in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenColumns]]
 */
export declare class HiddenColumnCollection extends Base implements ICollection$1<WorksheetColumn> {
    static $t: Type;
    private _d;
    private _a;
    private _c;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    add(item: WorksheetColumn): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetColumn[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetColumn): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetColumn>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetColumn>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a column to the collection.
     * <p class="body">
     * This collection does not allow duplicate values. If the specified column already exists in the collection,
     * nothing will happen. This collection also keeps itself sorted, so the column added will not necessarily be
     * added at the end of the collection.
     * </p>
     * @throws [[ArgumentNullException]] 'column' is null.
     * @throws [[ArgumentException]] 'column' does not belong to the same worksheet this collection is associated with.
     * @param column The column to be added to the hidden columns collection.
     */
    add_1(column: WorksheetColumn): void;
    /**
     * Clears all columns from the collection.
     */
    clear(): void;
    /**
     * Determines whether the specified column exists in the collection.
     * @param column The column to search for in the collection.
     * @return True if the column exists in the collection; False otherwise or if the specified column is null.
     */
    contains(column: WorksheetColumn): boolean;
    /**
     * Removes the specified column from the collection if it exists.
     * @param column The column to removed from the collection.
     * @return True if the column existed in the collection and was removed; False otherwise or if the
     * specified column is null.
     */
    remove_1(column: WorksheetColumn): boolean;
    /**
     * Removes the column at the specified index in the collection.
     * @param index The zero-based index of the column in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _l(a: number, b: number): void;
    /**
     * @hidden
     */
    _b(): NamedReference;
    /**
     * @hidden
     */
    _n(a: Worksheet): void;
    /**
     * @hidden
     */
    private _k;
    /**
     * Gets the number of columns in the collection.
     * The number of columns in the collection.
     */
    readonly count: number;
    /**
     * Gets the column at the specified index.
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetColumn;
    /**
     * Gets the worksheet associated with this collection.
     * The worksheet associated with this collection.
     */
    readonly worksheet: Worksheet;
}
/**
 * A collection of hidden [[WorksheetRow]] instances.
 * <p class="body">
 * The rows in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the rows in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other rows in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenRows]]
 */
export declare class HiddenRowCollection extends Base implements ICollection$1<WorksheetRow> {
    static $t: Type;
    private _d;
    private _a;
    private _c;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    add(item: WorksheetRow): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetRow[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetRow): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRow>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetRow>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a row to the collection.
     * <p class="body">
     * This collection does not allow duplicate values. If the specified row already exists in the collection,
     * nothing will happen. This collection also keeps itself sorted, so the row added will not necessarily be
     * added at the end of the collection.
     * </p>
     * @throws [[ArgumentNullException]] 'row' is null.
     * @throws [[ArgumentException]] 'row' does not belong to the same worksheet this collection is associated with.
     * @param row The row to be added to the hidden rows collection.
     */
    add_1(row: WorksheetRow): void;
    /**
     * Clears all rows from the collection.
     */
    clear(): void;
    /**
     * Determines whether the specified row exists in the collection.
     * @param row The row to search for in the collection.
     * @return True if the row exists in the collection; False otherwise or if the specified row is null.
     */
    contains(row: WorksheetRow): boolean;
    /**
     * Removes the specified row from the collection if it exists.
     * @param row The row to removed from the collection.
     * @return True if the row existed in the collection and was removed; False otherwise or if the
     * specified row is null.
     */
    remove_1(row: WorksheetRow): boolean;
    /**
     * Removes the row at the specified index in the collection.
     * @param index The zero-based index of the row in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _l(a: number, b: number): void;
    /**
     * @hidden
     */
    _b(): NamedReference;
    /**
     * @hidden
     */
    _n(a: Worksheet): void;
    /**
     * @hidden
     */
    private _k;
    /**
     * Gets the number of rows in the collection.
     * The number of rows in the collection.
     */
    readonly count: number;
    /**
     * Gets the row at the specified index.
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetRow;
    /**
     * Gets the worksheet associated with this collection.
     * The worksheet associated with this collection.
     */
    readonly worksheet: Worksheet;
}
/**
 * @hidden
 */
export interface IFormattedTextOwner extends ISheetProvider {
    onFormattingChanged(a: FormattedText): void;
    onUnformattedStringChanged(a: FormattedText): void;
}
/**
 * @hidden
 */
export declare let IFormattedTextOwner_$type: Type;
/**
 * @hidden
 */
export declare class SheetCollection_ChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Workbook);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of sheets in a workbook.
 * @see [[Sheet]]
 * @see [[Worksheet]]
 * @see@see */
export declare class SheetCollection extends Base implements IList$1<Sheet> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static _a;
    private readonly _i;
    private _n;
    private _j;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: Sheet): void;
    /**
     * Creates a new [[Sheet]] and adds it to the collection.
     * <p class="body">
     * If the workbook originally had no sheets, the newly added sheet will become the selected sheet of
     * the workbook.  This can be changed after more sheets are added by setting the [[WindowOptions.selectedSheet]]
     * of the Workbook.
     * </p>
     * @param name The name to give the new Sheet.
     * @param type An enumeration indicating the type of sheet to create
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] 'name' exceeds 31 characters in length.
     * @throws [[ArgumentException]] 'name' is being used as the name of another sheet (sheet names are case-insensitively compared).
     * @return The Sheet created with the specified name.
     */
    add(name: string, type: SheetType): Sheet;
    /**
     * @hidden
     */
    _add$e(a: Sheet): void;
    /**
     * @hidden
     */
    copyTo(array: Sheet[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: Sheet): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Sheet>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<Sheet>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: Sheet): void;
    /**
     * @hidden
     */
    item(index: number, value?: Sheet): Sheet;
    /**
     * Gets the sheet at the specified index.
     * The sheet at the specified index.
     * @param index The zero-based index of the sheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): Sheet;
    /**
     * Gets the sheet with the specified name.
     * <p class="body">
     * Sheet names are compared case-insensitively.
     * </p>
     * The sheet with the specified name.
     * @param name The name of the sheet to get.
     * @throws [[InvalidOperationException]] A sheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    item(name: string): Sheet;
    /**
     * @hidden
     */
    _item$e(a: number, b?: Sheet): Sheet;
    /**
     * @hidden
     */
    _add1(a: string, b: SheetType): Sheet;
    /**
     * @hidden
     */
    _add2(a: string, b: number, c: SheetType): Sheet;
    /**
     * Clears all sheets from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with a worksheet for a scope, they will be removed from the [[Workbook]].
     * </p>
     */
    clear(): void;
    /**
     * @hidden
     */
    _t(): void;
    /**
     * Determines whether a sheet is in the collection.
     * @param sheet The sheet to locate in the collection.
     * @return True if the sheet is found; False otherwise.
     */
    contains(sheet: Sheet): boolean;
    /**
     * Determines whether a sheet with the specified name exists in the collection.
     * @param name The name of the sheet to search for. The name is compared case-insensitively.
     * @return True if a sheet with the specified name is found; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified sheet in the collection.
     * @param sheet The sheet of which to get the index.
     * @return The index of the specified sheet in the collection.
     * @see [[Sheet.sheetIndex]]
     */
    indexOf(sheet: Sheet): number;
    /**
     * @hidden
     */
    _insert1(a: number, b: string, c: number, d: SheetType): Sheet;
    /**
     * @hidden
     */
    private _u;
    /**
     * @hidden
     */
    _v(a: number, b: number): void;
    /**
     * Removes the specified sheet from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param sheet The sheet to remove from the collection.
     * @return True if the sheet was successfully removed from the collection;
     * False if the sheet did not exist in the collection.
     */
    remove_1(sheet: Sheet): boolean;
    /**
     * Removes the sheet at the specified index from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param index The index of the sheet to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    _x(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the number of sheets in the collection.
     * The number of sheets in the collection.
     */
    readonly count: number;
    /**
     * @hidden
     */
    _item(a: number): Sheet;
    /**
     * @hidden
     */
    _item1(a: string): Sheet;
}
/**
 * @hidden
 */
export declare class SortedIntRangeList extends Base {
    static $t: Type;
    private e;
    private d;
    constructor();
    readonly j: number;
    readonly k: number;
    m(a: number): void;
    n(a: number, b: number): void;
    o(): void;
    a(a: number): boolean;
    private g;
    l(a: number): Nullable$1<number>;
    i(a: number): number;
    h(a: number): number;
    private _c;
    c(): IEnumerable$1<number>;
    b(a: number): boolean;
    p(a: number): void;
    q(a: number, b: number): void;
}
/**
 * @hidden
 */
export declare class SortedIntRangeList_IntRange extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    c: number;
    b: number;
    readonly a: number;
    toString(): string;
}
/**
 * @hidden
 */
export interface IWorkbookOwner {
    readonly isUndoEnabled: boolean;
    onCellValueChange(a: WorksheetRow, b: number): void;
    onConditionalFormatChange(a: WorksheetRegion): void;
    _onChange$2$i<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: boolean, c: TValue, d: TValue, e: ChangeInfo$2<TContext, TValue>): void;
    onCustomViewApplied(a: CustomView): void;
    onTransactionalChangeBegin(a: ExcelChangeAction, b: string): any;
    onTransactionalChangeEnd(a: any): void;
    onTransactionalChangeRollback(a: any): void;
    onSheetRemoving(a: Sheet): void;
}
/**
 * @hidden
 */
export declare let IWorkbookOwner_$type: Type;
/**
 * @hidden
 */
export declare class WeakWorkbookOwner extends Base implements IWorkbookOwner {
    static $t: Type;
    private readonly b;
    constructor(a: IWorkbookOwner);
    readonly a: IWorkbookOwner;
    readonly isUndoEnabled: boolean;
    onCellValueChange(a: WorksheetRow, b: number): void;
    _onChange$2$i<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: boolean, c: TValue, d: TValue, e: ChangeInfo$2<TContext, TValue>): void;
    onConditionalFormatChange(a: WorksheetRegion): void;
    onCustomViewApplied(a: CustomView): void;
    onSheetRemoving(a: Sheet): void;
    onTransactionalChangeBegin(a: ExcelChangeAction, b: string): any;
    onTransactionalChangeEnd(a: any): void;
    onTransactionalChangeRollback(a: any): void;
}
/**
 * @hidden
 */
export declare class KnownBoxes extends Base {
    static $t: Type;
    static readonly w: any;
    static readonly x: any;
    static readonly f: any;
    static readonly n: any;
    static readonly c: any;
    static readonly d: any;
    static readonly e: any;
    static readonly g: any;
    static readonly h: any;
    static readonly i: any;
    static readonly j: any;
    static readonly k: any;
    static readonly l: any;
    static readonly m: any;
    static readonly o: any;
    static readonly p: any;
    static readonly q: any;
    static al(a: CellBorderLineStyle): any;
    static readonly s: any;
    static readonly r: any;
    static readonly t: any;
    static readonly u: any;
    static readonly v: any;
    static am(a: DiagonalBorders): any;
    static readonly y: any;
    static readonly z: any;
    static readonly aa: any;
    static au(a: Nullable$1<boolean>): any;
    static readonly ab: any;
    static readonly ac: any;
    static readonly ad: any;
    static readonly ae: any;
    static an(a: FontSuperscriptSubscriptStyle): any;
    static readonly af: any;
    static readonly ai: any;
    static readonly ag: any;
    static readonly ah: any;
    static readonly aj: any;
    static readonly ak: any;
    static ao(a: FontUnderlineStyle): any;
    static readonly ax: any;
    static readonly a0: any;
    static readonly av: any;
    static readonly aw: any;
    static readonly ay: any;
    static readonly az: any;
    static readonly a1: any;
    static readonly a2: any;
    static readonly a3: any;
    static ap(a: HorizontalCellAlignment): any;
    static readonly a4: any;
    static readonly a5: any;
    static at(a: number): any;
    static readonly a6: any;
    static readonly a7: any;
    static readonly ba: any;
    static readonly a8: any;
    static readonly bb: any;
    static readonly bc: any;
    static readonly a9: any;
    static as(a: ST_CellType): any;
    static readonly bf: any;
    static readonly bd: any;
    static readonly be: any;
    static readonly bg: any;
    static readonly bh: any;
    static readonly bi: any;
    static aq(a: VerticalCellAlignment): any;
    static readonly a: Dictionary$2<number, any>;
    private static b;
    static ar(a: WorksheetCellFormatOptions): any;
}
/**
 * @hidden
 */
export interface ILoadOnDemandTreeOwner$1<T> {
    _createValue$i(a: number): T;
    _getItemIndex$i(a: T): number;
    _initializeItemIndex$i(a: T, b: number, c: boolean): void;
    _isItemStillValid$i(a: T): boolean;
}
/**
 * @hidden
 */
export declare let ILoadOnDemandTreeOwner$1_$type: Type;
/**
 * @hidden
 */
export interface IBinaryTreeNodeOwner$1<T> {
    recalculateHeight(): boolean;
    verifyBalanceOfChild(a: LoadOnDemandTree_BinaryTreeNode$1<T>): boolean;
}
/**
 * @hidden
 */
export declare let IBinaryTreeNodeOwner$1_$type: Type;
/**
 * @hidden
 */
export declare class LoadOnDemandTree$1<T> extends Base implements ICollection$1<T>, IBinaryTreeNodeOwner$1<T> {
    static $t: Type;
    protected $t: Type;
    _a: ILoadOnDemandTreeOwner$1<T>;
    private _aj;
    protected _h: LoadOnDemandTree_BinaryTreeNode$1<T>;
    private _i;
    private _ae;
    private _n;
    private _q;
    private _r;
    private _s;
    private _ab;
    private _aa;
    constructor($t: Type, a: ILoadOnDemandTreeOwner$1<T>, b: number);
    recalculateHeight(): boolean;
    verifyBalanceOfChild(a: LoadOnDemandTree_BinaryTreeNode$1<T>): boolean;
    add(a: T): void;
    clear(): void;
    contains(a: T): boolean;
    copyTo(a: T[], b: number): void;
    readonly isReadOnly: boolean;
    remove(a: T): boolean;
    getEnumerator(): IEnumerator$1<T>;
    private __x;
    _x(a: number, b: number, c: boolean): IEnumerable$1<T>;
    getEnumeratorObject(): IEnumerator;
    _af(a: number, b: number): number;
    _ah(a: number): number;
    _ai(a: number): number;
    private _j;
    _k(a: LoadOnDemandTree_ChangeHistoryItem$1<T>, b: number, c: number): LoadOnDemandTree_ChangeAdjustmentPoint$1<T>;
    protected _l(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<T>;
    protected _m(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<T>;
    _f(a: number, b: IBinaryTreeNodeOwner$1<T>): LoadOnDemandTree_BinaryTreeNode$1<T>;
    private __w;
    private _w;
    protected _y(): IEnumerable$1<LoadOnDemandTree_BinaryTreeNode$1<T>>;
    private __z;
    protected _z(a: number, b: number, c: boolean): IEnumerable$1<LoadOnDemandTree_BinaryTreeNode$1<T>>;
    _b(a: number, b: boolean, c: LoadOnDemandTree_FindState): {
        ret: T;
        p2: LoadOnDemandTree_FindState;
    };
    _ao(a: number, b: number): void;
    private static _aq;
    _ar(a: number, b: number): void;
    _e(a: T, b: number): T;
    _p(a: number, b: T): {
        ret: boolean;
        p1: T;
    };
    private _am;
    _an(): void;
    _o(a: number, b: number): boolean;
    private _ap;
    private _d;
    private _g;
    private _as;
    protected readonly _ac: List$1<LoadOnDemandTree_ChangeAdjustmentPoint$1<T>>;
    readonly _u: number;
    readonly count: number;
    _item(a: number): T;
    _al: number;
    private readonly _ad;
}
/**
 * @hidden
 */
export declare class LoadOnDemandTree_ChangeAdjustmentPoint$1<T> extends Base {
    static $t: Type;
    protected $t: Type;
    protected readonly a: LoadOnDemandTree$1<T>;
    private i;
    private h;
    private j;
    readonly c: LoadOnDemandTree_ChangeHistoryItem$1<T>;
    constructor($t: Type, a: LoadOnDemandTree$1<T>, b: LoadOnDemandTree_ChangeHistoryItem$1<T>, c: number, d: number);
    readonly n: number;
    readonly l: number;
    readonly m: number;
    k: number;
    readonly p: number;
    readonly o: number;
    readonly d: boolean;
    readonly e: boolean;
    item(a: number, b?: T): T;
    q(a: LoadOnDemandTree_ChangeAdjustmentPoint$1<T>, b: List$1<LoadOnDemandTree_ChangeAdjustmentPoint$1<T>>, c: boolean): {
        p2?: boolean;
    };
    private r;
    private s;
    protected t(): void;
    f(a: number, b: number): boolean;
    private g;
    u(a: number): void;
}
/**
 * @hidden
 */
export declare abstract class LoadOnDemandTree_ChangeHistoryItem$1<T> extends Base {
    static $t: Type;
    protected $t: Type;
    readonly f: number;
    protected b: number;
    constructor($t: Type, a: number, b: number);
    d(a: number, b: number, c: number, d: boolean): number;
    e(a: number, b: number, c: boolean): number;
    readonly c: number;
    abstract readonly a: boolean;
    abstract g(a: number): void;
}
/**
 * @hidden
 */
export declare class LoadOnDemandTree_ChangeHistoryItemAdd$1<T> extends LoadOnDemandTree_ChangeHistoryItem$1<T> {
    static $t: Type;
    protected $t: Type;
    private h;
    constructor($t: Type, a: number, b: number);
    readonly j: boolean;
    protected get_a(): boolean;
    readonly a: boolean;
    readonly i: T[];
    g(a: number): void;
}
/**
 * @hidden
 */
export declare class LoadOnDemandTree_ChangeHistoryItemRemove$1<T> extends LoadOnDemandTree_ChangeHistoryItem$1<T> {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: number);
    protected get_a(): boolean;
    readonly a: boolean;
    g(a: number): void;
}
/**
 * @hidden
 */
export declare class LoadOnDemandTree_BinaryTreeNode$1<T> extends Base implements IBinaryTreeNodeOwner$1<T> {
    static $t: Type;
    protected $t: Type;
    private n;
    private k;
    private c;
    private f;
    private h;
    protected a: T[];
    constructor($t: Type, a: number, b: IBinaryTreeNodeOwner$1<T>, c: LoadOnDemandTree$1<T>);
    verifyBalanceOfChild(a: LoadOnDemandTree_BinaryTreeNode$1<T>): boolean;
    static j<T>($t: Type, a: LoadOnDemandTree_BinaryTreeNode$1<T>): {
        ret: boolean;
        p0?: LoadOnDemandTree_BinaryTreeNode$1<T>;
    };
    e(a: number, b: number, c: boolean, d: boolean, e: LoadOnDemandTree$1<T>, f: LoadOnDemandTree_FindState): {
        ret: LoadOnDemandTree_BinaryTreeNode$1<T>;
        p5: LoadOnDemandTree_FindState;
    };
    private static m;
    recalculateHeight(): boolean;
    readonly l: number;
    g: LoadOnDemandTree_BinaryTreeNode$1<T>;
    readonly d: IBinaryTreeNodeOwner$1<T>;
    i: LoadOnDemandTree_BinaryTreeNode$1<T>;
    readonly b: T[];
}
/**
 * Abstract base class for a named reference defined in the workbook.
 */
export declare abstract class NamedReferenceBase extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static readonly _ac: number;
    /**
     * @hidden
     */
    static readonly _aa: number;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    static readonly _ax: string;
    /**
     * @hidden
     */
    static readonly _ay: string;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    static readonly _ak: string;
    private _i;
    private _at;
    private _ad;
    private _q;
    private _b;
    private _al;
    private _o;
    private _u;
    private _w;
    constructor(a: any, b: boolean);
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    static _a3(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _a4(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _a5(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _av(a: BuiltInName): string;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * @hidden
     */
    _a7(a: string): void;
    /**
     * @hidden
     */
    _a8(a: string): void;
    /**
     * @hidden
     */
    static _a9(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    _aw(): string;
    /**
     * @hidden
     */
    static _ba(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    _bd(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _be(a: string, b: string, c: WorkbookFormat, d?: boolean): void;
    /**
     * @hidden
     */
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private _a2;
    /**
     * @hidden
     */
    static _s(a: string): boolean;
    /**
     * @hidden
     */
    abstract readonly _f: RefBase;
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    readonly _a: ChangeInfo[];
    /**
     * @hidden
     */
    abstract readonly _z: CultureInfo;
    /**
     * @hidden
     */
    protected get__l(): WorkbookFormat;
    /**
     * @hidden
     */
    readonly _l: WorkbookFormat;
    /**
     * @hidden
     */
    abstract readonly _k: Workbook;
    /**
     * Gets or sets the comment associated with the named reference or table.
     * The comment associated with the named reference or table.
     * @throws [[ArgumentException]] The value assigned is greater than 255 characters in length.
     */
    /**
    * Gets or sets the comment associated with the named reference or table.
    * The comment associated with the named reference or table.
    * @throws [[ArgumentException]] The value assigned is greater than 255 characters in length.
    */
    comment: string;
    /**
     * Gets or sets the name of the reference.
     * <p class="body">
     * See the overview on [[scope]] for details on how to access a named reference by name in formulas.
     * </p>
     * The name of the reference.
     * @throws [[ArgumentNullException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
     * @throws [[ArgumentException]] The value assigned is not a valid named reference. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] The value assigned is the name of another named reference with the same Scope.
     * Names are compared case-insensitively.
     */
    /**
    * Gets or sets the name of the reference.
    * <p class="body">
    * See the overview on [[scope]] for details on how to access a named reference by name in formulas.
    * </p>
    * The name of the reference.
    * @throws [[ArgumentNullException]] The value assigned is null or empty.
    * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
    * @throws [[ArgumentException]] The value assigned is not a valid named reference. The name must begin with a letter, underscore (_), or a backslash (\).
    * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
    * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
    * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
    * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
    * @throws [[InvalidOperationException]] The value assigned is the name of another named reference with the same Scope.
    * Names are compared case-insensitively.
    */
    name: string;
    /**
     * @hidden
     */
    private _bc;
    /**
     * Gets the scope of the named reference.
     * <p class="body">
     * This can either be the workbook which the named reference belongs to or one of the worksheets
     * in the workbook.
     * </p>
     * <p class="body">
     * The scope determines how formulas need to preface a name in order to use the named reference.
     * </p>
     * <p class="body">
     * If the scope is the workbook, formulas in any cell in the workbook can reference the named reference
     * by specifying just the name or the workbook's file name, an exclamation point, and the name:
     * <list type="bullet">
     * <item>=MyWorkbookName</item>
     * <item>='C:\MyWorkbook.xls'!MyWorkbookName</item>
     * </list>
     * When cells in other workbook's want to reference the named reference, they must use the second format
     * by first specifying the file name when the workbook-scoped named reference exists.
     * </p>
     * <p class="body">
     * If the scope is a worksheet, formulas in cells of the worksheet can reference the named reference
     * by specifying just the name. In addition, they can fully qualify the named reference with the worksheet name
     * and, optionally, the workbook file name:
     * <list type="bullet">
     * <item>=MyWorksheetName</item>
     * <item>=Sheet1!MyWorksheetName</item>
     * <item>='C:\[MyWorkbook.xls]Sheet1'!MyWorksheetName</item>
     * </list>
     * Formulas in cells of other worksheets in the same workbook can use the named reference as well, but they must
     * specify the worksheet name and, optionally, the workbook file name:
     * <list type="bullet">
     * <item>=Sheet2!OtherWorksheetName</item>
     * <item>='C:\[MyWorkbook.xls]Sheet2'!OtherWorksheetName</item>
     * </list>
     * Formulas in cells of other workbooks can also used the named reference, but they must specify the workbook file
     * name, worksheet name, and named reference name.
     * </p>
     * The scope of the named reference.
     */
    readonly scope: any;
    /**
     * @hidden
     */
    readonly _c: BuiltInName;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    readonly _m: boolean;
    /**
     * @hidden
     */
    abstract readonly _n: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _j: SingleTargetFormula;
    /**
     * @hidden
     */
    _bb(a: SingleTargetFormula, b: boolean): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _p: boolean;
    /**
     * @hidden
     */
    readonly _r: boolean;
    /**
     * @hidden
     */
    protected get__t(): boolean;
    /**
     * @hidden
     */
    readonly _t: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _v: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _x: boolean;
    /**
     * @hidden
     */
    protected get__y(): boolean;
    /**
     * @hidden
     */
    readonly _y: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _af: any;
    /**
     * @hidden
     */
    protected get__g(): NameType;
    /**
     * @hidden
     */
    readonly _g: NameType;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * @hidden
     */
    readonly _h: WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class NamedReference_FormulaInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: NamedReference, c: CellReferenceMode, d: CultureInfo);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: NamedReference;
    readonly c: NamedReferenceCollection;
    readonly a: CellReferenceMode;
    readonly d: CultureInfo;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a named reference defined in the workbook.
 * <p class="body">
 * Named references allow for names to be used in formulas instead of complex formulas or cell references.
 * For example, instead of using the formula =SUM(E1:E20), a named reference with a name of 'Sales' can be
 * defined to point to the range of E1:E20 (the named reference's formula would be defined like this:
 * =Sheet1!$E$1:$E$20). Then the original formula could be expressed as =SUM(Sales).
 * </p>
 * <p class="body">
 * Each named reference has an associated scope, which can either be the [[workbook]]
 * to which the named reference belongs or one of the [[Worksheet]] instances in the Workbook. The scope
 * determines how the name must be referenced in formulas for different cells. A scope of the workbook means
 * the named reference must be accessed by a formula in any cell of the workbook by specifying only the name.
 * A scope of the worksheet means formulas used in other worksheets must reference the name by first
 * specifying the worksheet scope, such as =SUM( Sheet2!Sales ). If the formula is in the same worksheet as
 * the scope of the named reference, the formula can reference the name with or without the worksheet name.
 * </p>
 * <p class="body">
 * Named references from external workbooks must always be referenced with the scope first. If the named
 * reference's scope is the external workbook, the name is accessed by specifying the workbook file name
 * followed by the name, such as in the following formula: ='C:\ExternalWorkbook.xls'!SalesTax. If the named
 * reference has a scope of a worksheet in the workbook, it is referenced by specifying the file name,
 * worksheet, and name: ='C:\[ExternalWorkbook.xls]Sheet1'!SalesTax.
 * </p>
 * <p class="body">
 * Named references with different scopes can have the same names, but if two named references have the same
 * scope, they must have case-insensitively unique names.
 * </p>
 */
export declare class NamedReference extends NamedReferenceBase implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _by;
    /**
     * @hidden
     */
    private static readonly _bf;
    private _bm;
    /**
     * @hidden
     */
    _bp: NamedReferenceCollection;
    private _bu;
    constructor(a: number, b: NamedReferenceCollection, c: any);
    constructor(a: number, b: NamedReferenceCollection, c: any, d: boolean);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    protected get__z(): CultureInfo;
    /**
     * @hidden
     */
    readonly _z: CultureInfo;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * Gets the string representation of the named reference.
     * @return The string representation of the named reference.
     */
    toString(): string;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * @hidden
     */
    private static _bl;
    /**
     * @hidden
     */
    private static _bg;
    /**
     * @hidden
     */
    _bi(a: boolean, b?: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bh(a: RefBase, b: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bo(a: boolean, b?: RefBase): RefBase;
    /**
     * @hidden
     */
    _b2(a: NamedReferenceCollection): void;
    /**
     * Sets the formula for a named reference.
     * <p class="body">
     * The formula will be parsed using the [[CellReferenceMode]] of the [[workbook]]
     * to which the NamedReference is applied. If the NamedReference has been removed from its collection, the A1 reference mode
     * will be used to parse the formula.
     * </p>
     * @param formula The string containing the formula value.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string): void;
    /**
     * Sets the formula for a named reference.
     * @param formula The string containing the formula value.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * Sets the formula for a named reference.
     * @param formula The string containing the formula value.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setFormula1(a: string): void;
    /**
     * @hidden
     */
    _setFormula2(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula3(a: string, b: CellReferenceMode, c: CultureInfo): void;
    private _bz;
    /**
     * @hidden
     */
    private static _b5;
    /**
     * @hidden
     */
    private static _b9;
    /**
     * @hidden
     */
    _b3(): void;
    /**
     * @hidden
     */
    _b4(): void;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _cb(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__n(): boolean;
    /**
     * @hidden
     */
    readonly _n: boolean;
    /**
     * Gets the formula which defines the named reference.
     * The formula which defines the named reference.
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    readonly formula: string;
    /**
     * Gets the value indicating whether the [[formula]] is a simple formula referring to a single cell, a single region,
     * or multiple regions in the same workbook as the named reference.
     * <p class="body">
     * If the reference is surrounded by parentheses or whitespace or the named reference has some other complex formula this will
     * return false.
     * </p>
     */
    readonly isSimpleReferenceFormula: boolean;
    /**
     * Gets the [[WorksheetCell]] referenced by the [[formula]].
     * <p class="body">
     * If named reference is a reference to one or more regions, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    readonly referencedCell: WorksheetCell;
    /**
     * @hidden
     */
    static _bq(a: CellCalcReference): WorksheetCell;
    /**
     * Gets the [[WorksheetRegion]] referenced by the [[formula]].
     * <p class="body">
     * If the named reference is a reference to a single cell or multiple regions, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    readonly referencedRegion: WorksheetRegion;
    /**
     * @hidden
     */
    static _bs(a: RegionCalcReferenceBase): WorksheetRegion;
    /**
     * Gets the array of [[WorksheetRegion]] instances referenced by the [[formula]].
     * <p class="body">
     * If the named reference is a reference to a single cell or region, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    readonly referencedRegions: WorksheetRegion[];
    /**
     * @hidden
     */
    static _bj(a: RegionGroupCalcReference): WorksheetRegion[];
    /**
     * @hidden
     */
    protected get__f(): RefBase;
    /**
     * @hidden
     */
    readonly _f: RefBase;
    /**
     * @hidden
     */
    readonly _bn: NamedCalcReference;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bv: boolean;
    /**
     * @hidden
     */
    protected get__k(): Workbook;
    /**
     * @hidden
     */
    readonly _k: Workbook;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * @hidden
 */
export declare class NamedReferenceCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: NamedReferenceCollection, c: NamedReference, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: NamedReferenceCollection;
    readonly a: NamedReference;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[NamedReference]] instances in a workbook.
 * @see [[NamedReference]]
 * @see */
export declare class NamedReferenceCollection extends Base implements ICollection$1<NamedReference> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _n: Workbook;
    private _r;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: NamedReference): void;
    /**
     * Adds a named reference with a scope of the collection's associated [[workbook]] to the collection.
     * <p class="body">
     * The [[CellReferenceMode]] of the owning [[workbook]] will be used to parse the formula.
     * </p>
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of the workbook.
     * Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string): NamedReference;
    /**
     * Adds a named reference with a scope of the collection's associated [[workbook]] to the collection.
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of the workbook.
     * Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, cellReferenceMode: CellReferenceMode): NamedReference;
    /**
     * Adds a named reference with a scope of a worksheet to the collection.
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param worksheet The scope of the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of
     * the specified 'worksheet'. Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @throws [[ArgumentException]] 'worksheet' does not belong to the workbook owning this collection.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, cellReferenceMode: CellReferenceMode, worksheet: Worksheet): NamedReference;
    /**
     * Adds a named reference with a scope of a worksheet to the collection.
     * <p class="body">
     * The [[CellReferenceMode]] of the owning [[workbook]] will be used to parse the formula.
     * </p>
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param worksheet The scope of the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of
     * the specified 'worksheet'. Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @throws [[ArgumentException]] 'worksheet' does not belong to the workbook owning this collection.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, worksheet: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _add$e(a: NamedReference): void;
    /**
     * @hidden
     */
    copyTo(array: NamedReference[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: NamedReference): boolean;
    [Symbol.iterator](): EnumeratorWrapper<NamedReference>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<NamedReference>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: string, b: string): NamedReference;
    /**
     * @hidden
     */
    _add2(a: string, b: string, c: CellReferenceMode): NamedReference;
    /**
     * @hidden
     */
    _add4(a: string, b: string, c: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _add3(a: string, b: string, c: CellReferenceMode, d: Worksheet): NamedReference;
    /**
     * Clears all named references from the collection.
     */
    clear(): void;
    /**
     * Determines whether a named reference is in the collection.
     * @param namedReference The named reference to locate in the collection.
     * @return True if the named reference is found; False otherwise.
     */
    contains(namedReference: NamedReference): boolean;
    /**
     * Finds a named reference in the collection with a scope of the collection's associated [[Workbook]].
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named reference to find.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return The named reference with the specified name or null if the named reference was not found.
     */
    find(name: string): NamedReference;
    /**
     * Finds a named reference in the collection with a scope of the specified worksheet.
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named reference to find.
     * @param worksheetScope The worksheet that the named reference found must have a scope of.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'worksheetScope' is null.
     * @return The named reference with the specified name or null if the named reference was not found.
     */
    find(name: string, worksheetScope: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _find(a: string): NamedReference;
    /**
     * @hidden
     */
    _find1(a: string, b: Worksheet): NamedReference;
    /**
     * Finds all named references in the collection with the specified name.
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named references to find.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return An array of [[NamedReference]] instances with the specified name.
     */
    findAll(name: string): NamedReference[];
    /**
     * Removes the specified named reference from the collection.
     * @param namedReference The named reference to remove fro the collection.
     * @return True if the named reference existed in the collection and was removed; False otherwise.
     */
    remove_1(namedReference: NamedReference): boolean;
    /**
     * Removes the named reference at the specified index in the collection.
     * @param index The zero-based index of the named reference in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _x(a: NamedReference): void;
    /**
     * @hidden
     */
    _y(a: NamedReference, b: boolean): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * Gets the number of named references in the collection.
     * The number of named references in the collection.
     */
    readonly count: number;
    /**
     * Gets the named reference at the specified index.
     * The named reference at the specified index.
     * @param index The zero-based index of the named reference to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): NamedReference;
    /**
     * Gets the workbook associated with this collection.
     * The workbook associated with this collection.
     */
    readonly workbook: Workbook;
}
/**
 * @hidden
 */
export declare class NamedReferenceUnconnected extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    private _bh;
    private _bg;
    constructor(a: number, b: string, c: WorkbookFormat, d: NameType, e?: boolean);
    constructor(a: number, b: string, c: any, d: boolean, e: WorkbookFormat, f?: boolean);
    constructor(a: number, ..._rest: any[]);
    protected get__f(): RefBase;
    readonly _f: RefBase;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get__z(): CultureInfo;
    readonly _z: CultureInfo;
    protected get__l(): WorkbookFormat;
    equals(a: any): boolean;
    getHashCode(): number;
    protected get__t(): boolean;
    _a1(a: GetFormulaStringInfo, b: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    readonly _k: Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * Base class for horizontal and vertical page breaks in a [[Worksheet]].
 * @see [[PrintOptions.clearPageBreaks]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 * @see [[VerticalPageBreak]]
 */
export declare abstract class PageBreak extends Base {
    static $t: Type;
    private _c;
    private _j;
    private _f;
    private readonly _n;
    private readonly _p;
    private _a;
    constructor(a: number, b: Nullable$1<number>, c: Nullable$1<number>);
    /**
     * Determines whether this [[PageBreak]] is equal to the specified object.
     * @param obj The object to test.
     * @return True if the object is the same type as this PageBreak and has the same data; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[PageBreak]].
     * @return A hash code for the instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _h(a: PageBreak): number;
    /**
     * Gets the print area in which the page break occurs.
     * A  instance that is the print area where the page break occurs or null if the
     * page break occurs across the entire sheet.
     * @see [[WorksheetRegion]]
     * @see [[PrintOptions.printAreas]]
     */
    /**
    * Gets the print area in which the page break occurs.
    * A  instance that is the print area where the page break occurs or null if the
    * page break occurs across the entire sheet.
    * @see [[WorksheetRegion]]
    * @see [[PrintOptions.printAreas]]
    */
    printArea: WorksheetRegion;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _d: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _k: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g: boolean;
    /**
     * @hidden
     */
    readonly _o: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _l: number;
    /**
     * @hidden
     */
    readonly _q: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _m: number;
}
/**
 * Represents a horizontal page break in a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 */
export declare class HorizontalPageBreak extends PageBreak implements IComparable$1<HorizontalPageBreak> {
    static $t: Type;
    constructor(firstRowOnPage: number);
    constructor(firstRowOnPage: number, printArea: WorksheetRegion);
    constructor(firstRowOnPage: number, min: Nullable$1<number>, max: Nullable$1<number>);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    compareTo(other: HorizontalPageBreak): number;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the 0-based index of the first row on the page after this break.
     */
    readonly firstRowOnPage: number;
}
/**
 * @hidden
 */
export declare class PageBreakCollection_CollectionChangeContext$1<T extends PageBreak> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: PageBreakCollection$1<T>, c: T, d: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: PageBreakCollection$1<T>;
    readonly b: T;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Base class for the collections of horizontal and vertical page breaks on a [[worksheet]].
 * @typedef T The type of page break the collection contains.
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreakCollection]]
 * @see [[VerticalPageBreakCollection]]
 */
export declare abstract class PageBreakCollection$1<T extends PageBreak> extends Base implements IList$1<T> {
    static $t: Type;
    protected $t: Type;
    /**
     * @hidden
     */
    _e: PrintOptions;
    private _i;
    constructor($t: Type, a: PrintOptions);
    /**
     * @hidden
     */
    insert(index: number, item: T): void;
    /**
     * @hidden
     */
    _insert$i(a: number, b: T): void;
    /**
     * @hidden
     */
    item(index: number, value?: T): T;
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[count]].
     * @return A [[PageBreak]]-derived instance.
     */
    item(index: number): T;
    /**
     * @hidden
     */
    _item$e(a: number, b?: T): T;
    /**
     * @hidden
     */
    copyTo(array: T[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<T>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a page break to the [[worksheet]].
     * @param pageBreak The page break to add to the Worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @throws [[ArgumentException]] Occurs when 'pageBreak' overlaps with another page break already in the collection.
     * @see [[PrintOptions.insertPageBreak]]
     * @see [[PrintOptions.insertPageBreak]]
     * @see [[PrintOptions.insertPageBreak]]
     */
    add(pageBreak: T): void;
    /**
     * @hidden
     */
    _add$i(a: T): void;
    /**
     * @hidden
     */
    _g(a: T, b: boolean): boolean;
    /**
     * Clears the collection of page breaks.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    clear(): void;
    /**
     * Determines whether the specified page break exists on the [[worksheet]].
     * @param pageBreak The page break to test.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return True if the page break is on the Worksheet; False otherwise.
     */
    contains(pageBreak: T): boolean;
    /**
     * @hidden
     */
    _contains$i(a: T): boolean;
    /**
     * Gets the 0-based index of the specified page break.
     * @param pageBreak The page break for which the index should be obtained.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return The 0-based index of the page break or -1 if the page break is no tin the collection.
     */
    indexOf(pageBreak: T): number;
    /**
     * @hidden
     */
    _indexOf$i(a: T): number;
    /**
     * Removes the specified page break from the [[worksheet]].
     * @param pageBreak The page break which should be removed.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return True if the page break was contained on the Worksheet before removal; False otherwise.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    remove(pageBreak: T): boolean;
    /**
     * @hidden
     */
    _remove$i(a: T): boolean;
    /**
     * Removes the page break at the specified index.
     * @param index The 0-based index of the page break to remove.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than zero or greater than or equal to the number of page breaks in the collection.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _k(): number;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of page breaks in this collection.
     */
    readonly count: number;
    /**
     * @hidden
     */
    _item(a: number): T;
    /**
     * @hidden
     */
    abstract readonly _h: boolean;
    /**
     * @hidden
     */
    readonly _f: Worksheet;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _l;
}
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 */
export declare class HorizontalPageBreakCollection extends PageBreakCollection$1<HorizontalPageBreak> {
    static $t: Type;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    _t(a: CellShiftOperation): void;
}
/**
 * Represents a vertical page break in a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 */
export declare class VerticalPageBreak extends PageBreak implements IComparable$1<VerticalPageBreak> {
    static $t: Type;
    constructor(firstColumOnPage: number);
    constructor(firstColumOnPage: number, printArea: WorksheetRegion);
    constructor(firstColumOnPage: number, min: Nullable$1<number>, max: Nullable$1<number>);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    compareTo(other: VerticalPageBreak): number;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the 0-based index of the first column on the page after this break.
     */
    readonly firstColumnOnPage: number;
}
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[VerticalPageBreak]]
 */
export declare class VerticalPageBreakCollection extends PageBreakCollection$1<VerticalPageBreak> {
    static $t: Type;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    readonly _h: boolean;
}
/**
 * @hidden
 */
export declare class PrintAreasCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: PrintAreasCollection, c: WorksheetRegion, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: PrintAreasCollection;
    readonly b: WorksheetRegion;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Gets the collection of print areas in a [[Worksheet]] or a worksheet's print settings in a [[CustomView]].
 * @see [[PrintOptions.printAreas]]
 */
export declare class PrintAreasCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _g;
    private _h;
    /**
     * @hidden
     */
    _d: PrintOptions;
    static staticInit(): void;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    copyTo(array: WorksheetRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRegion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a print area to the collection.
     * @param printArea The print area to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
     * @throws [[ArgumentException]] Occurs when 'printArea' overlaps with another print area in the collection.
     */
    add(printArea: WorksheetRegion): void;
    /**
     * @hidden
     */
    _o(a: WorksheetRegion, b: boolean): void;
    /**
     * Clears all print areas from the collection.
     * <p class="body">
     * If any page breaks are contained in a print area, they will be removed from their collection.
     * </p>
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    clear(): void;
    /**
     * Determines whether the specified print area is in the collection.
     * @param printArea The print area to search for in the collection.
     * @return True if the print area is in the collection; False otherwise.
     */
    contains(printArea: WorksheetRegion): boolean;
    /**
     * Removes the specified print area from the collection.
     * <p class="body">
     * If any page breaks are contained in the removed print area, they will be removed from their collection.
     * </p>
     * @param printArea The print area to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
     * @return True if the print area was found and removed; False otherwise.
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    remove(printArea: WorksheetRegion): boolean;
    /**
     * Removes the print area at the specified index from the collection.
     * <p class="body">
     * If any page breaks are contained in the removed print area, they will be removed from their collection.
     * </p>
     * @param index The index of the print area to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _m(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    _e(a: number, b: Nullable$1<number>, c: Nullable$1<number>, d: boolean): WorksheetRegion;
    /**
     * @hidden
     */
    _t(a: RefBase, b: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _s;
    /**
     * Gets the number of print areas in the collection.
     */
    readonly count: number;
    /**
     * Gets the print area at the specified index.
     * @param index The index of the print area to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @return A [[WorksheetRegion]] instance representing a print area in the [[Worksheet]].
     */
    item(a: number): WorksheetRegion;
}
/**
 * Base class which exposes the various print options available for a sheet which can be saved with both a
 * sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export declare abstract class PrintOptionsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _am: number;
    /**
     * @hidden
     */
    static readonly _ao: number;
    /**
     * @hidden
     */
    static readonly _an: number;
    /**
     * @hidden
     */
    static readonly _aj: number;
    /**
     * @hidden
     */
    static readonly _al: number;
    /**
     * @hidden
     */
    static readonly _ak: number;
    /**
     * @hidden
     */
    static readonly _k: PaperSize;
    /**
     * @hidden
     */
    static readonly _a2: number;
    /**
     * @hidden
     */
    static readonly _z: boolean;
    /**
     * @hidden
     */
    static readonly _y: boolean;
    /**
     * @hidden
     */
    static readonly _q: PrintNotes;
    /**
     * @hidden
     */
    static readonly _h: PageNumbering;
    /**
     * @hidden
     */
    static readonly _n: PrintErrors;
    /**
     * @hidden
     */
    static readonly _a1: number;
    /**
     * @hidden
     */
    static readonly _a3: number;
    /**
     * @hidden
     */
    static readonly _a0: number;
    /**
     * @hidden
     */
    static readonly _x: boolean;
    /**
     * @hidden
     */
    static readonly _aa: boolean;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _a;
    private _t;
    private _at;
    private _ax;
    private _av;
    private _ah;
    private _ar;
    private _ap;
    private _ab;
    private _bv;
    private _bx;
    private _bb;
    private _e;
    private _i;
    private _l;
    private _o;
    private _ad;
    private _r;
    private _bk;
    private _bo;
    private _bs;
    /**
     * @hidden
     */
    readonly _v: boolean;
    constructor(a: Sheet, b: boolean);
    /**
     * Resets the print options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _bz(a: PrintOptionsBase): void;
    /**
     * @hidden
     */
    _ag(): boolean;
    /**
     * @hidden
     */
    _b1(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    readonly _u: Sheet;
    /**
     * @hidden
     */
    _c: BinaryData;
    private _alignHeadersAndFootersWithMargins;
    /**
     * Gets or sets the value indicating whether to align header and footer margins with page margins.
     * @see [[header]]
     * @see [[footer]]
     * @see [[headerMargin]]
     * @see [[footerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     */
    /**
    * Gets or sets the value indicating whether to align header and footer margins with page margins.
    * @see [[header]]
    * @see [[footer]]
    * @see [[headerMargin]]
    * @see [[footerMargin]]
    * @see [[leftMargin]]
    * @see [[rightMargin]]
    */
    alignHeadersAndFootersWithMargins: boolean;
    /**
     * Gets or sets the margin at the bottom of each printed page of the worksheet, specified in inches.
     * The margin at the bottom of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    /**
    * Gets or sets the margin at the bottom of each printed page of the worksheet, specified in inches.
    * The margin at the bottom of each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[footerMargin]]
    * @see [[headerMargin]]
    * @see [[leftMargin]]
    * @see [[rightMargin]]
    * @see [[topMargin]]
    */
    bottomMargin: number;
    /**
     * Gets or sets the value indicating whether the printed pages should be printed using draft quality.
     * The value indicating whether the printed pages should be printed using draft quality.
     */
    /**
    * Gets or sets the value indicating whether the printed pages should be printed using draft quality.
    * The value indicating whether the printed pages should be printed using draft quality.
    */
    draftQuality: boolean;
    /**
     * Gets or sets the footer for each page of the printed worksheet.
     * <p class="body">
     * The '&' character in the header and footer is a special character. Depending on what is after it,
     * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
     * the available commands:
     * <list type="table">
     * 		<listheader>
     * 			<term>Section commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&L</term>
     * 			<description>
     * 				The following text will appear in the left section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&C</term>
     * 			<description>
     * 				The following text will appear in the center section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&R</term>
     * 			<description>
     * 				The following text will appear in the right section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 		<listheader>
     * 			<term>Replacement commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&&</term>
     * 			<description>Insert the '&' character.</description>
     * 		</item>
     * 		<item>
     * 			<term>&A</term>
     * 			<description>Insert the current worksheet name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&D</term>
     * 			<description>Insert the current date.</description>
     * 		</item>
     * 		<item>
     * 			<term>&F</term>
     * 			<description>Insert the current file name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&G</term>
     * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
     * 		</item>
     * 		<item>
     * 			<term>&N</term>
     * 			<description>Insert the  number of pages the worksheet will need to print.</description>
     * 		</item>
     * 		<item>
     * 			<term>&P</term>
     * 			<description>Insert the current page number.</description>
     * 		</item>
     * 		<item>
     * 			<term>&T</term>
     * 			<description>Insert the current time.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Z</term>
     * 			<description>Insert the current file path (without the file name).</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 	<listheader>
     * 			<term>Formatting commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&B</term>
     * 			<description>Toggle bold.</description>
     * 		</item>
     * 		<item>
     * 			<term>&E</term>
     * 			<description>Toggle double underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&I</term>
     * 			<description>Toggle italics.</description>
     * 		</item>
     * 		<item>
     * 			<term>&S</term>
     * 			<description>Toggle strikethrough.</description>
     * 		</item>
     * 		<item>
     * 			<term>&U</term>
     * 			<description>Toggle underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&X</term>
     * 			<description>Toggle superscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Y</term>
     * 			<description>Toggle subscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&<FontSize></term>
     * 			<description>
     * 				Sets a new font size for the following text. The size is expressed as a positive integer.
     * 				If a number is to follow this command in the header, it must be separated by a space.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>"</term>
     * 			<description>
     * 				Sets a new font for the following text. If the font name is not recognized, the default
     * 				font will be used.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>,<FontStyle>"</term>
     * 			<description>
     * 				Sets the new font and font style for the following text. The font style is usually "Regular",
     * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
     * 				available font styles can be seen in the font dialog when a font is selected.
     * 			</description>
     * 		</item>
     * 	</list>
     * </p>
     * <p class="body">
     * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
     * &N on &A&R&14&F.
     * </p>
     * The footer for each page of the worksheet.
     * @see [[header]]
     * @see [[footerMargin]]
     */
    /**
    * Gets or sets the footer for each page of the printed worksheet.
    * <p class="body">
    * The '&' character in the header and footer is a special character. Depending on what is after it,
    * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
    * the available commands:
    * <list type="table">
    * 		<listheader>
    * 			<term>Section commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&L</term>
    * 			<description>
    * 				The following text will appear in the left section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&C</term>
    * 			<description>
    * 				The following text will appear in the center section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&R</term>
    * 			<description>
    * 				The following text will appear in the right section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * </list>
    * <list type="table">
    * 		<listheader>
    * 			<term>Replacement commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&&</term>
    * 			<description>Insert the '&' character.</description>
    * 		</item>
    * 		<item>
    * 			<term>&A</term>
    * 			<description>Insert the current worksheet name.</description>
    * 		</item>
    * 		<item>
    * 			<term>&D</term>
    * 			<description>Insert the current date.</description>
    * 		</item>
    * 		<item>
    * 			<term>&F</term>
    * 			<description>Insert the current file name.</description>
    * 		</item>
    * 		<item>
    * 			<term>&G</term>
    * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
    * 		</item>
    * 		<item>
    * 			<term>&N</term>
    * 			<description>Insert the  number of pages the worksheet will need to print.</description>
    * 		</item>
    * 		<item>
    * 			<term>&P</term>
    * 			<description>Insert the current page number.</description>
    * 		</item>
    * 		<item>
    * 			<term>&T</term>
    * 			<description>Insert the current time.</description>
    * 		</item>
    * 		<item>
    * 			<term>&Z</term>
    * 			<description>Insert the current file path (without the file name).</description>
    * 		</item>
    * </list>
    * <list type="table">
    * 	<listheader>
    * 			<term>Formatting commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&B</term>
    * 			<description>Toggle bold.</description>
    * 		</item>
    * 		<item>
    * 			<term>&E</term>
    * 			<description>Toggle double underlining.</description>
    * 		</item>
    * 		<item>
    * 			<term>&I</term>
    * 			<description>Toggle italics.</description>
    * 		</item>
    * 		<item>
    * 			<term>&S</term>
    * 			<description>Toggle strikethrough.</description>
    * 		</item>
    * 		<item>
    * 			<term>&U</term>
    * 			<description>Toggle underlining.</description>
    * 		</item>
    * 		<item>
    * 			<term>&X</term>
    * 			<description>Toggle superscript.</description>
    * 		</item>
    * 		<item>
    * 			<term>&Y</term>
    * 			<description>Toggle subscript.</description>
    * 		</item>
    * 		<item>
    * 			<term>&<FontSize></term>
    * 			<description>
    * 				Sets a new font size for the following text. The size is expressed as a positive integer.
    * 				If a number is to follow this command in the header, it must be separated by a space.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&"<FontName>"</term>
    * 			<description>
    * 				Sets a new font for the following text. If the font name is not recognized, the default
    * 				font will be used.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&"<FontName>,<FontStyle>"</term>
    * 			<description>
    * 				Sets the new font and font style for the following text. The font style is usually "Regular",
    * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
    * 				available font styles can be seen in the font dialog when a font is selected.
    * 			</description>
    * 		</item>
    * 	</list>
    * </p>
    * <p class="body">
    * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
    * &N on &A&R&14&F.
    * </p>
    * The footer for each page of the worksheet.
    * @see [[header]]
    * @see [[footerMargin]]
    */
    footer: string;
    /**
     * Gets or sets the footer margin for each printed page of the worksheet, specified in inches.
     * The footer margin for each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[footer]]
     * @see [[bottomMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    /**
    * Gets or sets the footer margin for each printed page of the worksheet, specified in inches.
    * The footer margin for each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[footer]]
    * @see [[bottomMargin]]
    * @see [[headerMargin]]
    * @see [[leftMargin]]
    * @see [[rightMargin]]
    * @see [[topMargin]]
    */
    footerMargin: number;
    /**
     * Gets or sets the header for each page of the printed worksheet.
     * <p class="body">
     * The '&' character in the header and footer is a special character. Depending on what is after it,
     * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
     * the available commands:
     * <list type="table">
     * 		<listheader>
     * 			<term>Section commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&L</term>
     * 			<description>
     * 				The following text will appear in the left section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&C</term>
     * 			<description>
     * 				The following text will appear in the center section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&R</term>
     * 			<description>
     * 				The following text will appear in the right section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 		<listheader>
     * 			<term>Replacement commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&&</term>
     * 			<description>Insert the '&' character.</description>
     * 		</item>
     * 		<item>
     * 			<term>&A</term>
     * 			<description>Insert the current worksheet name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&D</term>
     * 			<description>Insert the current date.</description>
     * 		</item>
     * 		<item>
     * 			<term>&F</term>
     * 			<description>Insert the current file name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&G</term>
     * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
     * 		</item>
     * 		<item>
     * 			<term>&N</term>
     * 			<description>Insert the  number of pages the worksheet will need to print.</description>
     * 		</item>
     * 		<item>
     * 			<term>&P</term>
     * 			<description>Insert the current page number.</description>
     * 		</item>
     * 		<item>
     * 			<term>&T</term>
     * 			<description>Insert the current time.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Z</term>
     * 			<description>Insert the current file path (without the file name).</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 	<listheader>
     * 			<term>Formatting commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&B</term>
     * 			<description>Toggle bold.</description>
     * 		</item>
     * 		<item>
     * 			<term>&E</term>
     * 			<description>Toggle double underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&I</term>
     * 			<description>Toggle italics.</description>
     * 		</item>
     * 		<item>
     * 			<term>&S</term>
     * 			<description>Toggle strikethrough.</description>
     * 		</item>
     * 		<item>
     * 			<term>&U</term>
     * 			<description>Toggle underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&X</term>
     * 			<description>Toggle superscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Y</term>
     * 			<description>Toggle subscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&<FontSize></term>
     * 			<description>
     * 				Sets a new font size for the following text. The size is expressed as a positive integer.
     * 				If a number is to follow this command in the header, it must be separated by a space.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>"</term>
     * 			<description>
     * 				Sets a new font for the following text. If the font name is not recognized, the default
     * 				font will be used.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>,<FontStyle>"</term>
     * 			<description>
     * 				Sets the new font and font style for the following text. The font style is usually "Regular",
     * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
     * 				available font styles can be seen in the font dialog when a font is selected.
     * 			</description>
     * 		</item>
     * 	</list>
     * </p>
     * <p class="body">
     * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
     * &N on &A&R&14&F.
     * </p>
     * The header for each page of the worksheet.
     * @see [[footer]]
     * @see [[headerMargin]]
     */
    /**
    * Gets or sets the header for each page of the printed worksheet.
    * <p class="body">
    * The '&' character in the header and footer is a special character. Depending on what is after it,
    * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
    * the available commands:
    * <list type="table">
    * 		<listheader>
    * 			<term>Section commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&L</term>
    * 			<description>
    * 				The following text will appear in the left section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&C</term>
    * 			<description>
    * 				The following text will appear in the center section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&R</term>
    * 			<description>
    * 				The following text will appear in the right section. The formatting of new sections is
    * 				always the default formatting, regardless of the formatting of the previous section.
    * 			</description>
    * 		</item>
    * </list>
    * <list type="table">
    * 		<listheader>
    * 			<term>Replacement commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&&</term>
    * 			<description>Insert the '&' character.</description>
    * 		</item>
    * 		<item>
    * 			<term>&A</term>
    * 			<description>Insert the current worksheet name.</description>
    * 		</item>
    * 		<item>
    * 			<term>&D</term>
    * 			<description>Insert the current date.</description>
    * 		</item>
    * 		<item>
    * 			<term>&F</term>
    * 			<description>Insert the current file name.</description>
    * 		</item>
    * 		<item>
    * 			<term>&G</term>
    * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
    * 		</item>
    * 		<item>
    * 			<term>&N</term>
    * 			<description>Insert the  number of pages the worksheet will need to print.</description>
    * 		</item>
    * 		<item>
    * 			<term>&P</term>
    * 			<description>Insert the current page number.</description>
    * 		</item>
    * 		<item>
    * 			<term>&T</term>
    * 			<description>Insert the current time.</description>
    * 		</item>
    * 		<item>
    * 			<term>&Z</term>
    * 			<description>Insert the current file path (without the file name).</description>
    * 		</item>
    * </list>
    * <list type="table">
    * 	<listheader>
    * 			<term>Formatting commands</term>
    * 		</listheader>
    * 		<item>
    * 			<term>&B</term>
    * 			<description>Toggle bold.</description>
    * 		</item>
    * 		<item>
    * 			<term>&E</term>
    * 			<description>Toggle double underlining.</description>
    * 		</item>
    * 		<item>
    * 			<term>&I</term>
    * 			<description>Toggle italics.</description>
    * 		</item>
    * 		<item>
    * 			<term>&S</term>
    * 			<description>Toggle strikethrough.</description>
    * 		</item>
    * 		<item>
    * 			<term>&U</term>
    * 			<description>Toggle underlining.</description>
    * 		</item>
    * 		<item>
    * 			<term>&X</term>
    * 			<description>Toggle superscript.</description>
    * 		</item>
    * 		<item>
    * 			<term>&Y</term>
    * 			<description>Toggle subscript.</description>
    * 		</item>
    * 		<item>
    * 			<term>&<FontSize></term>
    * 			<description>
    * 				Sets a new font size for the following text. The size is expressed as a positive integer.
    * 				If a number is to follow this command in the header, it must be separated by a space.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&"<FontName>"</term>
    * 			<description>
    * 				Sets a new font for the following text. If the font name is not recognized, the default
    * 				font will be used.
    * 			</description>
    * 		</item>
    * 		<item>
    * 			<term>&"<FontName>,<FontStyle>"</term>
    * 			<description>
    * 				Sets the new font and font style for the following text. The font style is usually "Regular",
    * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
    * 				available font styles can be seen in the font dialog when a font is selected.
    * 			</description>
    * 		</item>
    * 	</list>
    * </p>
    * <p class="body">
    * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
    * &N on &A&R&14&F.
    * </p>
    * The header for each page of the worksheet.
    * @see [[footer]]
    * @see [[headerMargin]]
    */
    header: string;
    /**
     * Gets or sets the header margin for each printed page of the worksheet, specified in inches.
     * The header margin for each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[header]]
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    /**
    * Gets or sets the header margin for each printed page of the worksheet, specified in inches.
    * The header margin for each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[header]]
    * @see [[bottomMargin]]
    * @see [[footerMargin]]
    * @see [[leftMargin]]
    * @see [[rightMargin]]
    * @see [[topMargin]]
    */
    headerMargin: number;
    /**
     * Gets or sets the margin at the left of each printed page of the worksheet, specified in inches.
     * The margin at the left of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    /**
    * Gets or sets the margin at the left of each printed page of the worksheet, specified in inches.
    * The margin at the left of each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[bottomMargin]]
    * @see [[footerMargin]]
    * @see [[headerMargin]]
    * @see [[rightMargin]]
    * @see [[topMargin]]
    */
    leftMargin: number;
    /**
     * Gets or sets the number of copies to print.
     * The number of copies to print.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 65535.
     */
    /**
    * Gets or sets the number of copies to print.
    * The number of copies to print.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 65535.
    */
    numberOfCopies: number;
    /**
     * Gets or sets the orientation for each page of the printed worksheet.
     * The orientation for each page of the printed worksheet.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[orientation]] enumeration.
     */
    /**
    * Gets or sets the orientation for each page of the printed worksheet.
    * The orientation for each page of the printed worksheet.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[orientation]] enumeration.
    */
    orientation: Orientation;
    /**
     * Returns the resolved orientation for each page of the printed worksheet.
     */
    readonly orientationResolved: Orientation;
    /**
     * Gets or sets the method with which pages are numbered.
     * <p class="body">
     * If this is set to a value of UseStartPageNumber, the first page is numbered using the [[startPageNumber]].
     * </p>
     * The method with which pages are numbered.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageNumbering]] enumeration.
     * @see [[startPageNumber]]
     */
    /**
    * Gets or sets the method with which pages are numbered.
    * <p class="body">
    * If this is set to a value of UseStartPageNumber, the first page is numbered using the [[startPageNumber]].
    * </p>
    * The method with which pages are numbered.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageNumbering]] enumeration.
    * @see [[startPageNumber]]
    */
    pageNumbering: PageNumbering;
    /**
     * Gets or sets the paper size for each printed page of the worksheet.
     * The paper size for each printed page of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[paperSize]] enumeration.
     */
    /**
    * Gets or sets the paper size for each printed page of the worksheet.
    * The paper size for each printed page of the worksheet.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[paperSize]] enumeration.
    */
    paperSize: PaperSize;
    /**
     * Gets or sets the way error values of cells are printed.
     * <p class="body">
     * A cell can have an error value if its [[WorksheetCell.value]] is set directly to
     * an [[ErrorValue]] or if it is set to a [[Formula]] that evaluates to an
     * error.
     * </p>
     * The way error values of cells are printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printErrors]] enumeration.
     * @see [[ErrorValue]]
     * @see [[Formula]]
     */
    /**
    * Gets or sets the way error values of cells are printed.
    * <p class="body">
    * A cell can have an error value if its [[WorksheetCell.value]] is set directly to
    * an [[ErrorValue]] or if it is set to a [[Formula]] that evaluates to an
    * error.
    * </p>
    * The way error values of cells are printed.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printErrors]] enumeration.
    * @see [[ErrorValue]]
    * @see [[Formula]]
    */
    printErrors: PrintErrors;
    /**
     * Gets or sets the value indicating whether the worksheet should be printed in black and white.
     * The value indicating whether the worksheet should be printed in black and white.
     */
    /**
    * Gets or sets the value indicating whether the worksheet should be printed in black and white.
    * The value indicating whether the worksheet should be printed in black and white.
    */
    printInBlackAndWhite: boolean;
    /**
     * Gets or sets the way cell comments are printed.
     * <p class="body">
     * If this is set to a value of PrintAsDisplayed, the comments will only print if they are displayed on the worksheet.
     * If comments are hidden but indicators are shown, neither the indicators nor the comments will print.
     * </p>
     * The way cell notes are printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printNotes]] enumeration.
     * @see [[WorksheetCell.comment]]
     * @see [[WorksheetCellComment]]
     */
    /**
    * Gets or sets the way cell comments are printed.
    * <p class="body">
    * If this is set to a value of PrintAsDisplayed, the comments will only print if they are displayed on the worksheet.
    * If comments are hidden but indicators are shown, neither the indicators nor the comments will print.
    * </p>
    * The way cell notes are printed.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printNotes]] enumeration.
    * @see [[WorksheetCell.comment]]
    * @see [[WorksheetCellComment]]
    */
    printNotes: PrintNotes;
    /**
     * Gets or sets the horizontal print resolution in DPI.
     * The horizontal print resolution in DPI.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
     * @see [[verticalResolution]]
     */
    /**
    * Gets or sets the horizontal print resolution in DPI.
    * The horizontal print resolution in DPI.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
    * @see [[verticalResolution]]
    */
    resolution: number;
    /**
     * Gets or sets the margin at the right of each printed page of the worksheet, specified in inches.
     * The margin at the right of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[topMargin]]
     */
    /**
    * Gets or sets the margin at the right of each printed page of the worksheet, specified in inches.
    * The margin at the right of each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[bottomMargin]]
    * @see [[footerMargin]]
    * @see [[headerMargin]]
    * @see [[leftMargin]]
    * @see [[topMargin]]
    */
    rightMargin: number;
    private _scaleHeadersAndFootersWithDocument;
    /**
     * Gets or sets the value indicating whether to scale the headers and footers with the document scaling.
     * @see [[header]]
     * @see [[footer]]
     * @see [[PrintOptions.scalingFactor]]
     * @see [[ScalingType]]
     */
    /**
    * Gets or sets the value indicating whether to scale the headers and footers with the document scaling.
    * @see [[header]]
    * @see [[footer]]
    * @see [[PrintOptions.scalingFactor]]
    * @see [[ScalingType]]
    */
    scaleHeadersAndFootersWithDocument: boolean;
    /**
     * Gets or sets the page number for the first printed page of the worksheet.
     * <p class="body">
     * For this value to be used, [[pageNumbering]] must be set to a value of UseStartPageNumber.
     * </p>
     * The page number for the first printed page of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of -32765 and 32767.
     * @see [[pageNumbering]]
     */
    /**
    * Gets or sets the page number for the first printed page of the worksheet.
    * <p class="body">
    * For this value to be used, [[pageNumbering]] must be set to a value of UseStartPageNumber.
    * </p>
    * The page number for the first printed page of the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of -32765 and 32767.
    * @see [[pageNumbering]]
    */
    startPageNumber: number;
    /**
     * Gets or sets the margin at the top of each printed page of the worksheet, specified in inches.
     * The margin at the top of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     */
    /**
    * Gets or sets the margin at the top of each printed page of the worksheet, specified in inches.
    * The margin at the top of each printed page of the worksheet, specified in inches.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
    * @see [[bottomMargin]]
    * @see [[footerMargin]]
    * @see [[headerMargin]]
    * @see [[leftMargin]]
    * @see [[rightMargin]]
    */
    topMargin: number;
    /**
     * Gets or sets the vertical print resolution in DPI.
     * The vertical print resolution in DPI.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
     * @see [[resolution]]
     */
    /**
    * Gets or sets the vertical print resolution in DPI.
    * The vertical print resolution in DPI.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
    * @see [[resolution]]
    */
    verticalResolution: number;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents a range of contiguous rows or columns which should be repeated at the top or left or printed pages of the [[Worksheet]].
 * @see [[PrintOptions.columnsToRepeatAtLeft]]
 * @see [[PrintOptions.rowsToRepeatAtTop]]
 */
export declare class RepeatTitleRange extends Base {
    static $t: Type;
    private readonly _b;
    private readonly _e;
    constructor(startIndex: number, endIndex: number);
    /**
     * Determines whether the specified value equals this [[RepeatTitleRange]].
     * @param obj The value to test for equality.
     */
    equals(obj: any): boolean;
    /**
     * Gtes the hash code for the [[RepeatTitleRange]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the range.
     * @return The string representation of the range.
     */
    toString(): string;
    /**
     * Gets the index of the last row or column in the range.
     * @see [[RowColumnBase.index]]
     */
    readonly endIndex: number;
    /**
     * Gets the index of the first row or column in the range.
     * @see [[RowColumnBase.index]]
     */
    readonly startIndex: number;
}
/**
 * Class which exposes the various print options available for a worksheet which can be saved with both a
 * worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export declare class PrintOptions extends PrintOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _c1: number;
    /**
     * @hidden
     */
    static readonly _cz: number;
    /**
     * @hidden
     */
    static readonly _c0: number;
    /**
     * @hidden
     */
    static readonly _b7: PageOrder;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _b2;
    private _cl;
    private _cn;
    private _c2;
    private _c5;
    private _b8;
    private _dd;
    private _cg;
    private _cs;
    private _cu;
    private _b5;
    private _ci;
    private _cc;
    private _ca;
    private _ce;
    constructor(a: Worksheet, b: boolean);
    /**
     * Clears all page breaks from the [[PrintOptions]].
     * @see [[PageBreakCollection`1.clear]]
     * @see [[PageBreakCollection`1.remove]]
     * @see [[PageBreakCollection`1.removeAt]]
     */
    clearPageBreaks(): void;
    /**
     * Inserts a horizontal and/or vertical page break before the specified cell.
     * <p class="body">
     * If the cell is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the cell is at the top-left corner of the [[Worksheet]], an exception will be thrown. If the cell is on the left edge of the
     * Worksheet, a horizontal page break will be inserted above the cell. If the cell is on the top edge of the Worksheet, a vertical page break
     * will be inserted to the left of the cell. If the cell is anywhere else in the Worksheet, a horizontal page break will be inserted above the
     * cell and a vertical page break will be inserted to the left of the cell.
     * </p>
     * <p class="body">
     * If the cell is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the cell is at the top-left corner of the print area, no page breaks will be inserted. If the cell is on the left edge of the print area,
     * a horizontal page break will be inserted above the cell. If the cell is on the top edge of the print area, a vertical page break will be
     * inserted to the left of the cell. If the cell is anywhere else in the print area, a horizontal page break will be inserted above the cell
     * and a vertical page break will be inserted to the left of the cell.
     * </p>
     * <p class="body">
     * When page breaks are inserted in a print area, they will only extend to the edges of the print area.
     * </p>
     * @param cell The cell at which to insert the page break(s).
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when 'cell' is at the top-left corner of the [[Worksheet]].
     * @see [[horizontalPageBreaks]]
     * @see [[verticalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(cell: WorksheetCell): void;
    /**
     * Inserts a vertical page break to the left of the specified column.
     * <p class="body">
     * If the column is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the column is at the left edge of the [[Worksheet]], an exception will be thrown. If the column is anywhere else in the Worksheet,
     * a vertical page break will be inserted to the left of the column.
     * </p>
     * <p class="body">
     * If the column is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the column is at the left edge of the print area, no page break will be inserted. If the column is anywhere else in the print area, a
     * vertical page break will be inserted to the left of the column.
     * </p>
     * @param column The column at which to insert the page break.
     * @throws [[ArgumentNullException]] Occurs when 'column' is null.
     * @throws [[ArgumentException]] Occurs when 'column' is at the left edge of the [[Worksheet]].
     * @see [[verticalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(column: WorksheetColumn): void;
    /**
     * Inserts a horizontal page break above the specified row.
     * <p class="body">
     * If the row is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the row is at the top edge of the [[Worksheet]], an exception will be thrown. If the row is anywhere else in the Worksheet,
     * a horizontal page break will be inserted above the row.
     * </p>
     * <p class="body">
     * If the row is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the row is at the top edge of the print area, no page break will be inserted. If the row is anywhere else in the print area, a
     * horizontal page break will be inserted above the row.
     * </p>
     * @param row The row at which to insert the page break.
     * @throws [[ArgumentNullException]] Occurs when 'row' is null.
     * @throws [[ArgumentException]] Occurs when 'row' is at the top edge of the [[Worksheet]].
     * @see [[horizontalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(row: WorksheetRow): void;
    /**
     * @hidden
     */
    _insertPageBreak(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _insertPageBreak1(a: WorksheetColumn): void;
    /**
     * @hidden
     */
    _insertPageBreak2(a: WorksheetRow): void;
    /**
     * Resets the print options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _bz(a: PrintOptionsBase): void;
    /**
     * @hidden
     */
    _dq(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _ag(): boolean;
    /**
     * @hidden
     */
    _ds(a: boolean): void;
    /**
     * @hidden
     */
    _dr(a: Workbook, b: string, c: boolean, d: NamedReference, e: boolean): {
        p3?: NamedReference;
        p4: boolean;
    };
    /**
     * @hidden
     */
    _dt(a: Workbook, b: string, c: boolean, d: NamedReference, e: boolean): {
        p3?: NamedReference;
        p4: boolean;
    };
    /**
     * @hidden
     */
    private _dv;
    /**
     * @hidden
     */
    _b1(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _b4;
    /**
     * @hidden
     */
    private static _b3;
    /**
     * @hidden
     */
    private _du;
    /**
     * @hidden
     */
    readonly _ck: Worksheet;
    /**
     * Gets or sets the value indicating whether the printed pages should be centered horizontally.
     * The value indicating whether the printed pages should be centered horizontally.
     * @see [[centerVertically]]
     */
    /**
    * Gets or sets the value indicating whether the printed pages should be centered horizontally.
    * The value indicating whether the printed pages should be centered horizontally.
    * @see [[centerVertically]]
    */
    centerHorizontally: boolean;
    /**
     * Gets or sets the value indicating whether the printed pages should be centered vertically.
     * The value indicating whether the printed pages should be centered vertically.
     * @see [[centerHorizontally]]
     */
    /**
    * Gets or sets the value indicating whether the printed pages should be centered vertically.
    * The value indicating whether the printed pages should be centered vertically.
    * @see [[centerHorizontally]]
    */
    centerVertically: boolean;
    /**
     * Gets or sets the range of columns which should be printed on every page.
     * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
     * Occurs when the value specified is not null and its  value is greater than or equal
     * to the number of columns in the [[Worksheet]].
     * @see [[rowsToRepeatAtTop]]
     */
    /**
    * Gets or sets the range of columns which should be printed on every page.
    * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
    * Occurs when the value specified is not null and its  value is greater than or equal
    * to the number of columns in the [[Worksheet]].
    * @see [[rowsToRepeatAtTop]]
    */
    columnsToRepeatAtLeft: RepeatTitleRange;
    /**
     * @hidden
     */
    _dl(a: RepeatTitleRange, b: boolean): void;
    /**
     * @hidden
     */
    private static _dm;
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[PageBreakCollection`1.count]].
     * @return A [[PageBreak]]-derived instance.
     */
    horizontalPageBreaks(index: number): HorizontalPageBreak;
    /**
     * Gets the collection of horizontal page breaks in the [[Worksheet]].
     * @see [[HorizontalPageBreak]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     */
    horizontalPageBreaks(): HorizontalPageBreakCollection;
    /**
     * @hidden
     */
    readonly _horizontalPageBreaks$i: HorizontalPageBreakCollection;
    /**
     * @hidden
     */
    readonly _cp: boolean;
    /**
     * Gets or sets the maximum number of pages allowed in the horizontal direction to print the worksheet.
     * <p class="body">
     * A value of zero indicates no maximum is used in the horizontal direction. As many pages as needed will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> For MaxPagesHorizontally and [[maxPagesVertically]] to affect the way the worksheet is printed,
     * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
     * and these values aren't used, they will still be saved with the worksheet.
     * </p>
     * The maximum number of pages allowed in the horizontal direction to print the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
     * @see [[maxPagesVertically]]
     * @see [[scalingType]]
     */
    /**
    * Gets or sets the maximum number of pages allowed in the horizontal direction to print the worksheet.
    * <p class="body">
    * A value of zero indicates no maximum is used in the horizontal direction. As many pages as needed will be used.
    * </p>
    * <p class="note">
    * <B>Note:</B> For MaxPagesHorizontally and [[maxPagesVertically]] to affect the way the worksheet is printed,
    * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
    * and these values aren't used, they will still be saved with the worksheet.
    * </p>
    * The maximum number of pages allowed in the horizontal direction to print the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
    * @see [[maxPagesVertically]]
    * @see [[scalingType]]
    */
    maxPagesHorizontally: number;
    /**
     * Gets or sets the maximum number of pages allowed in the vertical direction to print the worksheet.
     * <p class="body">
     * A value of zero indicates no maximum is used in the vertical direction. As many pages as needed will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> For [[maxPagesHorizontally]] and MaxPagesVertically to affect the way the worksheet is printed,
     * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
     * and these values aren't used, they will still be saved with the worksheet.
     * </p>
     * The maximum number of pages allowed in the vertical direction to print the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
     * @see [[maxPagesHorizontally]]
     * @see [[scalingType]]
     */
    /**
    * Gets or sets the maximum number of pages allowed in the vertical direction to print the worksheet.
    * <p class="body">
    * A value of zero indicates no maximum is used in the vertical direction. As many pages as needed will be used.
    * </p>
    * <p class="note">
    * <B>Note:</B> For [[maxPagesHorizontally]] and MaxPagesVertically to affect the way the worksheet is printed,
    * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
    * and these values aren't used, they will still be saved with the worksheet.
    * </p>
    * The maximum number of pages allowed in the vertical direction to print the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
    * @see [[maxPagesHorizontally]]
    * @see [[scalingType]]
    */
    maxPagesVertically: number;
    /**
     * Gets or sets the order in which to print pages for multiple page worksheets.
     * The order in which to print pages for multiple page worksheets.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageOrder]] enumeration.
     */
    /**
    * Gets or sets the order in which to print pages for multiple page worksheets.
    * The order in which to print pages for multiple page worksheets.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageOrder]] enumeration.
    */
    pageOrder: PageOrder;
    /**
     * Gets the print area at the specified index.
     * @param index The index of the print area to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @return A [[WorksheetRegion]] instance representing a print area in the [[Worksheet]].
     */
    printAreas(index: number): WorksheetRegion;
    /**
     * Gets the collection of print areas in the [[Worksheet]].
     */
    printAreas(): PrintAreasCollection;
    /**
     * @hidden
     */
    readonly _printAreas$i: PrintAreasCollection;
    /**
     * @hidden
     */
    readonly _cq: boolean;
    /**
     * Gets or sets the value which indicates whether to print the worksheet gridlines.
     * The value which indicates whether to print the worksheet gridlines.
     * @see [[DisplayOptions.showGridlines]]
     */
    /**
    * Gets or sets the value which indicates whether to print the worksheet gridlines.
    * The value which indicates whether to print the worksheet gridlines.
    * @see [[DisplayOptions.showGridlines]]
    */
    printGridlines: boolean;
    /**
     * Gets or sets the value indicating whether to print row and column headers.
     * <p class="body">
     * The row and column headers show the identifier of the row or column.
     * </p>
     * The value indicating whether to print row and column headers.
     * @see [[DisplayOptions.showRowAndColumnHeaders]]
     */
    /**
    * Gets or sets the value indicating whether to print row and column headers.
    * <p class="body">
    * The row and column headers show the identifier of the row or column.
    * </p>
    * The value indicating whether to print row and column headers.
    * @see [[DisplayOptions.showRowAndColumnHeaders]]
    */
    printRowAndColumnHeaders: boolean;
    /**
     * Gets or sets the range of rows which should be printed on every page.
     * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
     * Occurs when the value specified is not null and its  value is greater than or equal
     * to the number of rows in the [[Worksheet]].
     * @see [[columnsToRepeatAtLeft]]
     */
    /**
    * Gets or sets the range of rows which should be printed on every page.
    * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
    * Occurs when the value specified is not null and its  value is greater than or equal
    * to the number of rows in the [[Worksheet]].
    * @see [[columnsToRepeatAtLeft]]
    */
    rowsToRepeatAtTop: RepeatTitleRange;
    /**
     * @hidden
     */
    _dn(a: RepeatTitleRange, b: boolean): void;
    /**
     * @hidden
     */
    private static _dp;
    /**
     * Gets or sets the scaling factor to use when printing the worksheet.
     * <p class="body">
     * The scaling factor is similar to magnifications in that is it stored as a percentage of the normal scaling.
     * A value of 100 indicates normal scaling whereas a value of 200 indicates the worksheet is scaled to twice its
     * normal size.
     * </p>
     * <p class="note">
     * <B>Note:</B> For ScalingFactor to affect the way the worksheet is printed, [[scalingType]] must be
     * set to a value of UseScalingFactor.
     * </p>
     * The scaling factor to use when printing the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 10 and 400.
     * @see [[scalingType]]
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    /**
    * Gets or sets the scaling factor to use when printing the worksheet.
    * <p class="body">
    * The scaling factor is similar to magnifications in that is it stored as a percentage of the normal scaling.
    * A value of 100 indicates normal scaling whereas a value of 200 indicates the worksheet is scaled to twice its
    * normal size.
    * </p>
    * <p class="note">
    * <B>Note:</B> For ScalingFactor to affect the way the worksheet is printed, [[scalingType]] must be
    * set to a value of UseScalingFactor.
    * </p>
    * The scaling factor to use when printing the worksheet.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 10 and 400.
    * @see [[scalingType]]
    * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
    * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
    * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
    */
    scalingFactor: number;
    /**
     * Gets or sets the method for scaling the worksheet when it is printed.
     * <p class="body">
     * If this is set to a value of UseScalingFactor, [[scalingFactor]] is used to uniformly scale
     * the worksheet on the printed pages.
     * </p>
     * <p class="body">
     * If this is set to a value of FitToPages, [[maxPagesHorizontally]] and [[maxPagesVertically]]
     * are used to set the maximum number of pages to fit the printed worksheet into in both directions.
     * </p>
     * The method for scaling the worksheet when it is printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scalingType]] enumeration.
     * @see [[maxPagesHorizontally]]
     * @see [[maxPagesVertically]]
     * @see [[scalingFactor]]
     */
    /**
    * Gets or sets the method for scaling the worksheet when it is printed.
    * <p class="body">
    * If this is set to a value of UseScalingFactor, [[scalingFactor]] is used to uniformly scale
    * the worksheet on the printed pages.
    * </p>
    * <p class="body">
    * If this is set to a value of FitToPages, [[maxPagesHorizontally]] and [[maxPagesVertically]]
    * are used to set the maximum number of pages to fit the printed worksheet into in both directions.
    * </p>
    * The method for scaling the worksheet when it is printed.
    * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scalingType]] enumeration.
    * @see [[maxPagesHorizontally]]
    * @see [[maxPagesVertically]]
    * @see [[scalingFactor]]
    */
    scalingType: ScalingType;
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[PageBreakCollection`1.count]].
     * @return A [[PageBreak]]-derived instance.
     */
    verticalPageBreaks(index: number): VerticalPageBreak;
    /**
     * Gets the collection of vertical page breaks in the [[Worksheet]].
     * @see [[VerticalPageBreak]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     */
    verticalPageBreaks(): VerticalPageBreakCollection;
    /**
     * @hidden
     */
    readonly _verticalPageBreaks$i: VerticalPageBreakCollection;
    /**
     * @hidden
     */
    readonly _cr: boolean;
}
/**
 * @hidden
 */
export declare class WorkbookPasswordInfo extends Base {
    static $t: Type;
    private i;
    private a;
    private d;
    private c;
    constructor(a: () => void);
    readonly f: boolean;
    g: boolean;
    b: ProtectionValidationInfo;
    e(a: string, b: number[], c: number[], d: Nullable$1<number>): {
        ret: boolean;
        p0: string;
        p1: number[];
        p2: number[];
        p3: Nullable$1<number>;
    };
    h(): Nullable$1<number>;
    j(a: boolean): void;
    k(a: any): void;
    l(): void;
}
/**
 * Provides information about the types of changes that are disabled when the associated Workbook is protected.
 * @see [[Workbook.hasProtectionPassword]]
 * @see [[Workbook.isProtected]]
 * @see [[Workbook.protection]]
 * @see [[Workbook.protect]]
 * @see [[Workbook.unprotect]]
 */
export declare class WorkbookProtection extends Base {
    static $t: Type;
    private _c;
    private _d;
    private _a;
    /**
     * @hidden
     */
    readonly _b: WorkbookPasswordInfo;
    constructor(a: Workbook);
    /**
     * Returns a boolean indicating if the sheets displayed may be modified when the Workbook is protected.
     */
    /**
    * Returns a boolean indicating if the sheets displayed may be modified when the Workbook is protected.
    */
    allowEditStructure: boolean;
    /**
     * Returns a boolean indicating if the Workbook windows may be modified when the Workbook is protected.
     */
    /**
    * Returns a boolean indicating if the Workbook windows may be modified when the Workbook is protected.
    */
    allowEditWindows: boolean;
    /**
     * @hidden
     */
    _h(a: any, b?: boolean, c?: boolean): void;
    /**
     * @hidden
     */
    private _g;
}
/**
 * @hidden
 */
export declare class WorksheetProtectedRangeRegionCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    private _a;
    private _b;
    constructor(a: WorksheetProtectedRange);
    add(a: WorksheetRegion): void;
    clear(): void;
    contains(a: WorksheetRegion): boolean;
    copyTo(a: WorksheetRegion[], b: number): void;
    readonly count: number;
    readonly isReadOnly: boolean;
    remove(a: WorksheetRegion): boolean;
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * A collection of [[WorksheetProtectedRange]] instances in a [[Worksheet]]
 */
export declare class WorksheetProtectedRangeCollection extends Base implements ICollection$1<WorksheetProtectedRange> {
    static $t: Type;
    private readonly _d;
    private readonly _a;
    constructor(a: Worksheet);
    /**
     * Gets the number of ranges in the collection.
     */
    readonly count: number;
    /**
     * Gets the range at the specified index in the collection.
     * The range at the specified index.
     * @param index The zero-based index of the range to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetProtectedRange;
    /**
     * Adds the specified range to the collection.
     * @param item The range to be added
     */
    add(item: WorksheetProtectedRange): void;
    /**
     * Clears all ranges from the collection.
     */
    clear(): void;
    /**
     * Determines whether a range is in the collection.
     * @param range The range to locate in the collection.
     * @return True if the range is found; False otherwise.
     */
    contains(range: WorksheetProtectedRange): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetProtectedRange>;
    /**
     * Gets an enumerator which can iterator all ranges in the collection.
     */
    getEnumerator(): IEnumerator$1<WorksheetProtectedRange>;
    /**
     * Inserts the specified range in the collection.
     * @param index The 0-based index in the collection where the range should be inserted.
     * @param range The range to insert in the collection.
     */
    insert(index: number, range: WorksheetProtectedRange): void;
    /**
     * Removes the specified range from the collection.
     * @param range The range to remove from the collection.
     * @return True if the range was successfully removed from the collection;
     * False if the range did not exist in the collection.
     */
    remove(range: WorksheetProtectedRange): boolean;
    /**
     * Removes the range at the specified index from the collection.
     * @param index The index of the range to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _b(a: string): WorksheetProtectedRange;
    /**
     * @hidden
     */
    _g(a: number): void;
    /**
     * @hidden
     */
    private _h;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    copyTo(array: WorksheetProtectedRange[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
}
/**
 * Provides information about the types of changes that are disabled when the associated Sheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Sheet.sheetProtection]]
 * @see@see [[Sheet.unprotect]]
 */
export declare abstract class SheetProtection extends Base implements IChangeInfoContext {
    static $t: Type;
    private _a;
    /**
     * @hidden
     */
    readonly _c: WorkbookPasswordInfo;
    constructor(a: Sheet);
    /**
     * @hidden
     */
    readonly _sheet: Sheet;
    /**
     * @hidden
     */
    _d(): void;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Provides information about the types of changes that are disabled when the associated Worksheet is protected.
 * <p class="body">When a Worksheet is protected, the contents of unprotected cells may be edited by the end-user. One way to unprotect a
 * cell is to change the [[IWorksheetCellFormat.locked]] property to false. Such cells may be edited by all users. Another way to
 * unprotect cells is using the [[allowedEditRanges]]. This is a collection of [[WorksheetProtectedRange]] instances that
 * define a range of cells that is optionally protected by another password. For any other cells, the Worksheet would need to be unprotected first.
 * A Worksheet may be programatically unprotected using the Worksheet.Unprotect() method.</p>
 * <p class="body">The [[selectionMode]] property is used to control which cells the end user may select when the Worksheet has been
 * protected. This property may be set before or after protecting a Worksheet.</p>
 * <p class="body">Many of the other properties of this class are read-only (e.g. [[allowDeletingColumns]]). The state
 * of these properties are optionally set when the Worksheet is protected (e.g. using the [[Worksheet.protect]]
 * method.</p>
 * @see@see@see [[Worksheet.protection]]
 * @see [[Worksheet.protect]]
 * @see */
export declare class WorksheetProtection extends SheetProtection {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _e;
    private _j;
    private _h;
    private _l;
    constructor(a: Worksheet);
    /**
     * Returns a boolean indicating if the deletion of columns is allowed in a protected worksheet.
     * @see [[allowDeletingRows]]
     * @see [[allowInsertingColumns]]
     * @see [[allowInsertingRows]]
     */
    /**
    * Returns a boolean indicating if the deletion of columns is allowed in a protected worksheet.
    * @see [[allowDeletingRows]]
    * @see [[allowInsertingColumns]]
    * @see [[allowInsertingRows]]
    */
    allowDeletingColumns: boolean;
    /**
     * Returns a boolean indicating if the deletion of rows is allowed in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowInsertingColumns]]
     * @see [[allowInsertingRows]]
     */
    /**
    * Returns a boolean indicating if the deletion of rows is allowed in a protected worksheet.
    * @see [[allowDeletingColumns]]
    * @see [[allowInsertingColumns]]
    * @see [[allowInsertingRows]]
    */
    allowDeletingRows: boolean;
    /**
     * Gets the range at the specified index in the collection.
     * The range at the specified index.
     * @param index The zero-based index of the range to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    allowedEditRanges(index: number): WorksheetProtectedRange;
    /**
     * Returns a collection of [[WorksheetProtectedRange]] instances that define which locked ranges of cells may be edited in a protected worksheet.
     * <p class="body">When a Worksheet is protected the only cells that may be edited are those whose [[IWorksheetCellFormat.locked]] property
     * has been set to false. All other cells are not editable by default. One can make additional cells or ranges of cells editable via this collection.
     * The [[WorksheetProtectedRange]] instances specify the range to which it applies and optionally a password that may be used to unlock that range.</p>
     */
    allowedEditRanges(): WorksheetProtectedRangeCollection;
    /**
     * @hidden
     */
    readonly _allowedEditRanges$i: WorksheetProtectedRangeCollection;
    /**
     * Returns a boolean indicating if objects such as shapes, comments, charts and controls may be created or changed when the worksheet is protected.
     */
    /**
    * Returns a boolean indicating if objects such as shapes, comments, charts and controls may be created or changed when the worksheet is protected.
    */
    allowEditObjects: boolean;
    /**
     * Returns a boolean indicating if existing scenarios are protected when the worksheet is protected.
     */
    /**
    * Returns a boolean indicating if existing scenarios are protected when the worksheet is protected.
    */
    allowEditScenarios: boolean;
    /**
     * Returns a boolean indicating if the user may use an auto filter created before the worksheet was protected.
     */
    /**
    * Returns a boolean indicating if the user may use an auto filter created before the worksheet was protected.
    */
    allowFiltering: boolean;
    /**
     * Returns a boolean indicating if the user may change the formatting of cells in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the user may change the formatting of cells in a protected worksheet.
    */
    allowFormattingCells: boolean;
    /**
     * Returns a boolean indicating if the user may change column information such as its width or visibility in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the user may change column information such as its width or visibility in a protected worksheet.
    */
    allowFormattingColumns: boolean;
    /**
     * Returns a boolean indicating if the user may change row information such as its height or visibility in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the user may change row information such as its height or visibility in a protected worksheet.
    */
    allowFormattingRows: boolean;
    /**
     * Returns a boolean indicating if the user may insert columns in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowDeletingRows]]
     * @see [[allowInsertingRows]]
     */
    /**
    * Returns a boolean indicating if the user may insert columns in a protected worksheet.
    * @see [[allowDeletingColumns]]
    * @see [[allowDeletingRows]]
    * @see [[allowInsertingRows]]
    */
    allowInsertingColumns: boolean;
    /**
     * Returns a boolean indicating if the user may insert hyperlinks in unlocked cells in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the user may insert hyperlinks in unlocked cells in a protected worksheet.
    */
    allowInsertingHyperlinks: boolean;
    /**
     * Returns a boolean indicating if the user may insert rows in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowInsertingColumns]]
     * @see [[allowDeletingRows]]
     */
    /**
    * Returns a boolean indicating if the user may insert rows in a protected worksheet.
    * @see [[allowDeletingColumns]]
    * @see [[allowInsertingColumns]]
    * @see [[allowDeletingRows]]
    */
    allowInsertingRows: boolean;
    /**
     * Returns a boolean indicating if the sorting is allowed in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the sorting is allowed in a protected worksheet.
    */
    allowSorting: boolean;
    /**
     * Returns a boolean indicating if the user can change pivot tables in a protected worksheet.
     */
    /**
    * Returns a boolean indicating if the user can change pivot tables in a protected worksheet.
    */
    allowUsingPivotTables: boolean;
    /**
     * Returns or sets an enumeration used to indicate how cell selection should be affected when the associated Worksheet is protected.
     */
    /**
    * Returns or sets an enumeration used to indicate how cell selection should be affected when the associated Worksheet is protected.
    */
    selectionMode: WorksheetProtectedSelectionMode;
    /**
     * @hidden
     */
    readonly _m: WorksheetProtectionType;
    /**
     * @hidden
     */
    readonly _ab: boolean;
    /**
     * @hidden
     */
    readonly _ac: boolean;
    /**
     * @hidden
     */
    _af(): void;
    /**
     * @hidden
     */
    _ag(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    _ah(a: any, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>, d?: Nullable$1<boolean>, e?: Nullable$1<boolean>, f?: Nullable$1<boolean>, g?: Nullable$1<boolean>, h?: Nullable$1<boolean>, i?: Nullable$1<boolean>, j?: Nullable$1<boolean>, k?: Nullable$1<boolean>, l?: Nullable$1<boolean>, m?: Nullable$1<boolean>, n?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private static _g;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    _d(): void;
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private _aj;
}
/**
 * @hidden
 */
export declare class RegionLookupTable$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    private readonly a;
    readonly b: ObjectPool$1<List$1<T>>;
    readonly t: () => HashSet$1<T>;
    readonly u: () => List$1<T>;
    private c;
    private d;
    private m;
    private readonly e;
    private readonly r;
    private readonly s;
    private v;
    private w;
    constructor($t: Type, a: Worksheet);
    x(a: WorksheetRegion, b: T): void;
    y(a: WorksheetRegionAddress, b: T): void;
    z(a: number, b: number, c: number, d: number, e: T): void;
    aa(): void;
    n(a: number, b: number): boolean;
    private o;
    private p;
    ab(a: number, b: number, c: number, d: number): {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    };
    f(a: number, b: number): RegionLookupTable_Result$1<T>;
    g(a: WorksheetRegionAddress): RegionLookupTable_Result$1<T>;
    private h;
    i(a: number, b: number): RegionLookupTable_Result$1<T>;
    j(a: WorksheetRegionAddress): RegionLookupTable_Result$1<T>;
    k(a: number, b: number, c: number, d: number): RegionLookupTable_Result$1<T>;
    l(a: number, b: number): RegionLookupTable_Result$1<T>;
    ac(a: WorksheetRegion, b: T): void;
    ad(a: WorksheetRegionAddress, b: T): void;
    ae(a: number, b: number, c: number, d: number, e: T): void;
    readonly q: boolean;
}
/**
 * @hidden
 */
export declare class RegionLookupTable_Result$1<T extends IRegionAddress> extends ValueType implements IDisposable {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: RegionLookupTable$1<T>, c: List$1<T>);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    private readonly _a;
    readonly _d: List$1<T>;
    dispose(): void;
    readonly _c: boolean;
}
/**
 * @hidden
 */
export declare abstract class RowColumnBinaryTreeNode$1<T extends RowColumnBase> extends LoadOnDemandTree_BinaryTreeNode$1<T> {
    static $t: Type;
    protected $t: Type;
    private r;
    private s;
    constructor($t: Type, a: number, b: IBinaryTreeNodeOwner$1<T>, c: LoadOnDemandTree$1<T>);
    o(a: number, b: number, c: number, d: boolean): number;
    abstract p(a: T, b: number): number;
    q(a: number, b: number, c: boolean): number;
    t(a: boolean): void;
}
/**
 * Abstract base class for collections of the main worksheet elements (rows, columns, and cells).
 * <p class="body">
 * Because of the large number of elements on a worksheet, this collection internally creates elements
 * when they are requested. Iterating this collection will only iterate the elements which have already
 * been created.
 * </p>
 * @typedef T The type of item contained in the collection.
 */
export declare abstract class WorksheetItemCollection$1<T> extends Base implements ICollection$1<T>, ILoadOnDemandTreeOwner$1<T> {
    static $t: Type;
    protected $t: Type;
    private _b;
    private _v;
    private readonly _d;
    private _t;
    constructor($t: Type, a: Worksheet, b: number);
    /**
     * @hidden
     */
    add(item: T): void;
    /**
     * @hidden
     */
    _add$i(a: T): void;
    /**
     * @hidden
     */
    clear(): void;
    /**
     * @hidden
     */
    contains(item: T): boolean;
    /**
     * @hidden
     */
    _contains$i(a: T): boolean;
    /**
     * @hidden
     */
    copyTo(array: T[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly count: number;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: T): boolean;
    /**
     * @hidden
     */
    _remove$i(a: T): boolean;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _createValue$i(index: number): T;
    /**
     * @hidden
     */
    _getItemIndex$i(item: T): number;
    /**
     * @hidden
     */
    _initializeItemIndex$i(item: T, index: number, applyingChangesToTree: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid$i(item: T): boolean;
    /**
     * @hidden
     */
    abstract _createValue(a: number): T;
    /**
     * @hidden
     */
    abstract _getItemIndex(a: T): number;
    /**
     * @hidden
     */
    abstract _initializeItemIndex(a: T, b: number, c: boolean): void;
    /**
     * @hidden
     */
    abstract _isItemStillValid(a: T): boolean;
    /**
     * @hidden
     */
    abstract _ae(a: number): void;
    /**
     * @hidden
     */
    abstract _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _q(a: number, b: number): number;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _x(a: CellShiftOperation): void;
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<T>;
    /**
     * @hidden
     */
    private __l;
    _l(): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _p(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    _m(a: number, b: number): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _n(a: number, b: number, c: boolean): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _o(a: number, b: number, c?: boolean): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _g(a: number, b?: boolean): T;
    /**
     * @hidden
     */
    _aa(a: number, b: number): void;
    /**
     * @hidden
     */
    _h(a: number): T;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ad(a: number, b: number): void;
    /**
     * @hidden
     */
    _ac(a: CellShiftResult): void;
    /**
     * @hidden
     */
    _i(a: T, b: number): T;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    abstract readonly maxCount: number;
    /**
     * @hidden
     */
    readonly _k: number;
    /**
     * @hidden
     */
    protected get__count(): number;
    /**
     * @hidden
     */
    readonly _count: number;
    /**
     * @hidden
     */
    readonly _c: LoadOnDemandTree$1<T>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _u: number;
    /**
     * @hidden
     */
    readonly _e: Worksheet;
}
/**
 * Base class for row collection and column collection.
 * @typedef T The type of item contained in the collection.
 */
export declare abstract class RowColumnCollectionBase$1<T> extends WorksheetItemCollection$1<T> {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: Worksheet, b: number);
}
/**
 * @hidden
 */
export declare class RowColumnLoadOnDemandTree$1<T extends RowColumnBase> extends LoadOnDemandTree$1<T> {
    static $t: Type;
    protected $t: Type;
    protected _at: Worksheet;
    constructor($t: Type, a: RowColumnCollectionBase$1<T>);
    _au(a: boolean): void;
    _av(a: number, b: boolean): void;
}
/**
 * @hidden
 */
export declare class ShapeFillNoFill extends ShapeFill {
    static $t: Type;
    static readonly _e: ShapeFillNoFill;
    constructor();
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    _d(a: WorksheetShape): void;
}
/**
 * Represents a shape fill with a solid color.
 * @see [[WorksheetShape.fill]]
 */
export declare class ShapeFillSolid extends ShapeFill {
    static $t: Type;
    private readonly _e;
    constructor();
    constructor(color: Color);
    constructor(colorInfo: WorkbookColorInfo);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    _d(a: WorksheetShape): void;
    /**
     * Gets or sets the [[WorkbookColorInfo]] describing the color of the fill.
     */
    readonly colorInfo: WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ShapeFillImage extends ShapeFill {
    static $t: Type;
    private _e;
    constructor(a: ImageData);
    readonly _f: ImageData;
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    _d(a: WorksheetShape): void;
}
/**
 * @hidden
 */
export interface IShapeFillVisitor$2<TArg, TResult> {
    _visitNoFill$i(a: ShapeFillNoFill, b: TArg): TResult;
    _visitSolid$i(a: ShapeFillSolid, b: TArg): TResult;
    _visitImage$i(a: ShapeFillImage, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IShapeFillVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class ShapeOutlineNoOutline extends ShapeOutline {
    static $t: Type;
    static readonly _i: ShapeOutlineNoOutline;
    constructor();
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    _h(a: WorksheetShape): void;
}
/**
 * Represents a shape outline with a solid color.
 * @see [[WorksheetShape.outline]]
 */
export declare class ShapeOutlineSolid extends ShapeOutline {
    static $t: Type;
    private readonly _i;
    constructor();
    constructor(color: Color);
    constructor(colorInfo: WorkbookColorInfo);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    _h(a: WorksheetShape): void;
    /**
     * Gets or sets the [[WorkbookColorInfo]] describing the color of the outline.
     */
    readonly colorInfo: WorkbookColorInfo;
}
/**
 * @hidden
 */
export interface IShapeOutlineVisitor$2<TArg, TResult> {
    _visitNoOutline$i(a: ShapeOutlineNoOutline, b: TArg): TResult;
    _visitSolid$i(a: ShapeOutlineSolid, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IShapeOutlineVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class SharedStringTable extends GenericCachedCollection$1<StringElement> {
    static $t: Type;
    private _t;
    private _p;
    constructor(a: Workbook);
    private _s;
    protected _l(a: StringElement): void;
    private _u;
    private _v;
    _remove(a: StringElement): boolean;
    _o(a: number, b: number): StringElement;
    _q(a: StringElement): number;
    _r(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class SharedStringTable_KeyGap extends ValueType implements IComparable$1<SharedStringTable_KeyGap> {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly _b: number;
    readonly _a: number;
    compareTo(a: SharedStringTable_KeyGap): number;
}
/**
 * A type representing a range of cells which can be sorted.
 */
export interface ISortable {
    readonly index: number;
}
/**
 * @hidden
 */
export declare let ISortable_$type: Type;
/**
 * Represents an index relative to a region
 * @see [[Worksheet.filterSettings]]
 * @see [[Worksheet.sortSettings]]
 */
export declare class RelativeIndex extends Base implements ISortable, IEquatable$1<RelativeIndex>, IComparable$1<RelativeIndex> {
    static $t: Type;
    private readonly _b;
    private _a;
    constructor(index: number);
    /**
     * Returns the relative index (read only)
     */
    readonly index: number;
    /**
     * @hidden
     */
    _c(a: WorksheetRegion, b?: WorksheetSortType): void;
    /**
     * @hidden
     */
    equals(other: RelativeIndex): boolean;
    /**
     * Compares this instance of a [[RelativeIndex]] to another.
     * @param obj
     * @return
     */
    compareTo(obj: RelativeIndex): number;
}
/**
 * @hidden
 */
export interface IAreaFormatsOwner$1<TArea> extends IWorksheetCellFormatProxyOwner, IGenericCachedCollectionEx {
    readonly isReadOnly: boolean;
    _onAreaFormatAdded$i(a: TArea, b: WorksheetCellFormatData): void;
    verifyCanBeModified(): void;
}
/**
 * @hidden
 */
export declare let IAreaFormatsOwner$1_$type: Type;
/**
 * Represents a style which can be applied to a [[WorksheetTable]].
 * @see [[WorksheetTable.style]]
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 * @see [[Workbook.standardTableStyles]]
 */
export declare class WorksheetTableStyle extends Base implements IAreaFormatsOwner$1<WorksheetTableStyleArea>, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _a;
    private _v;
    private _w;
    private _j;
    private _x;
    private readonly _o;
    private _p;
    private _al;
    private _g;
    private _y;
    constructor(name: string);
    constructor(name: string, isCustom: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableStyleArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * Duplicates the style and returns a deep copy.
     * <p class="body">
     * A cloned style must be added to the [[Workbook.customTableStyles]] collection before it can be applied to a
     * [[WorksheetTable]].
     * </p>
     * <p class="body">
     * The only value not cloned from the style is the [[isCustom]] value. Cloning a standard style creates a custom style with
     * the same style settings which can then be changed.
     * </p>
     * @param name The name to give to the cloned style.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return The clone of the style.
     */
    clone(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _m(a: string, b: boolean): WorksheetTableStyle;
    /**
     * @hidden
     */
    private static readonly _c;
    /**
     * @hidden
     */
    static _q(a: CellFormatValue): boolean;
    /**
     * @hidden
     */
    static _af(a: WorksheetTableStyleArea): number;
    /**
     * @hidden
     */
    _ak(a: WorksheetTableStyleArea): Nullable$1<number>;
    /**
     * @hidden
     */
    _n(): SortedList$2<number, WorksheetTableAreaFormatProxy$1<WorksheetTableStyleArea>>;
    /**
     * @hidden
     */
    _an(a: CustomTableStyleCollection): void;
    /**
     * @hidden
     */
    _ao(): void;
    /**
     * @hidden
     */
    _verifyCanBeModified(): void;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static readonly _e;
    /**
     * @hidden
     */
    private static readonly _d;
    /**
     * @hidden
     */
    private static _u;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * Gets or sets the number of columns which will span each alternate column stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The alternate column stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].AlternateColumnStripe value.
     * </p>
     * The number of columns which will span each alternate column stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[columnStripeWidth]]
     */
    /**
    * Gets or sets the number of columns which will span each alternate column stripe.
    * <p class="body">
    * The stripe sizes must be between 1 and 9, inclusive.
    * </p>
    * <p class="body">
    * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
    * stripe, then repeating.
    * </p>
    * <p class="body">
    * The alternate column stripe format is defined in the [[areaFormats]] collection and keyed by the
    * [[WorksheetTableStyleArea]].AlternateColumnStripe value.
    * </p>
    * The number of columns which will span each alternate column stripe.
    * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
    * @see [[columnStripeWidth]]
    */
    alternateColumnStripeWidth: number;
    /**
     * Gets or sets the number of rows which will span each alternate row stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The alternate row stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].AlternateRowStripe value.
     * </p>
     * The number of rows which will span each alternate row stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[rowStripeHeight]]
     */
    /**
    * Gets or sets the number of rows which will span each alternate row stripe.
    * <p class="body">
    * The stripe sizes must be between 1 and 9, inclusive.
    * </p>
    * <p class="body">
    * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
    * stripe, then repeating.
    * </p>
    * <p class="body">
    * The alternate row stripe format is defined in the [[areaFormats]] collection and keyed by the
    * [[WorksheetTableStyleArea]].AlternateRowStripe value.
    * </p>
    * The number of rows which will span each alternate row stripe.
    * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
    * @see [[rowStripeHeight]]
    */
    alternateRowStripeHeight: number;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableStyleArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of a [[WorksheetTable]] to which the style is applied.
     * <p class="body">
     * The area formats specified are differential formats. In other words, only the properties that are set to non-default values will be
     * applied to the appropriate cells. An area format can define only a background color or only font information and that format will be
     * applied to the cells while all other formatting properties on the cells will be maintained.
     * </p>
     * @see [[WorksheetTable.areaFormats]]
     * @see [[WorksheetTableColumn.areaFormats]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableStyleArea>;
    /**
     * @hidden
     */
    readonly _areaFormats$i: WorksheetTableAreaFormatsCollection$1<WorksheetTableStyleArea>;
    /**
     * Gets or sets the number of columns which will span each column stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The column stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].ColumnStripe value.
     * </p>
     * The number of columns which will span each column stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[alternateColumnStripeWidth]]
     */
    /**
    * Gets or sets the number of columns which will span each column stripe.
    * <p class="body">
    * The stripe sizes must be between 1 and 9, inclusive.
    * </p>
    * <p class="body">
    * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
    * stripe, then repeating.
    * </p>
    * <p class="body">
    * The column stripe format is defined in the [[areaFormats]] collection and keyed by the
    * [[WorksheetTableStyleArea]].ColumnStripe value.
    * </p>
    * The number of columns which will span each column stripe.
    * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
    * @see [[alternateColumnStripeWidth]]
    */
    columnStripeWidth: number;
    /**
     * Gets the value indicating whether the style is a custom style.
     * True id this is a custom table style; False if this is a read-only, standard table style.
     */
    readonly isCustom: boolean;
    /**
     * Gets or sets the name of the style.
     * The name of the style.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentException]] The value assigned is null, empty, or greater than 255 characters in length.
     * @throws [[ArgumentException]] The value assigned matches the name of another custom style in the owning [[Workbook.customTableStyles]] collection.
     * Table names are compared case-insensitively.
     */
    /**
    * Gets or sets the name of the style.
    * The name of the style.
    * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
    * @throws [[ArgumentException]] The value assigned is null, empty, or greater than 255 characters in length.
    * @throws [[ArgumentException]] The value assigned matches the name of another custom style in the owning [[Workbook.customTableStyles]] collection.
    * Table names are compared case-insensitively.
    */
    name: string;
    /**
     * Gets or sets the number of rows which will span each row stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The row stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].RowStripe value.
     * </p>
     * The number of rows which will span each row stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[alternateRowStripeHeight]]
     */
    /**
    * Gets or sets the number of rows which will span each row stripe.
    * <p class="body">
    * The stripe sizes must be between 1 and 9, inclusive.
    * </p>
    * <p class="body">
    * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
    * stripe, then repeating.
    * </p>
    * <p class="body">
    * The row stripe format is defined in the [[areaFormats]] collection and keyed by the
    * [[WorksheetTableStyleArea]].RowStripe value.
    * </p>
    * The number of rows which will span each row stripe.
    * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
    * @see [[alternateRowStripeHeight]]
    */
    rowStripeHeight: number;
    /**
     * @hidden
     */
    readonly _h: CustomTableStyleCollection;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _s: boolean;
    /**
     * @hidden
     */
    readonly _isReadOnly: boolean;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
}
/**
 * @hidden
 */
export declare class CustomTableStyleCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: CustomTableStyleCollection, c: WorksheetTableStyle, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: CustomTableStyleCollection;
    readonly b: WorksheetTableStyle;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of custom [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in the
 * [[workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 */
export declare class CustomTableStyleCollection extends Base implements ICollection$1<WorksheetTableStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _h;
    /**
     * @hidden
     */
    _d: Workbook;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    copyTo(array: WorksheetTableStyle[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a custom [[WorksheetTableStyle]] to the collection.
     * @param style The custom table style to add to the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @throws [[ArgumentException]] 'style' is a standard table style.
     * @throws [[ArgumentException]] 'style' is already in a CustomTableStyleCollection.
     * @throws [[ArgumentException]] 'style' has a name which matches one of the other custom table styles in the collection.
     * Names are compared case-insensitively.
     * @see [[WorksheetTableStyle.isCustom]]
     * @see [[WorksheetTableStyle.name]]
     */
    add(style: WorksheetTableStyle): void;
    /**
     * Clears the collection.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     */
    clear(): void;
    /**
     * Determines whether the specified [[WorksheetTableStyle]] is contained in the collection.
     * @param style The table style to find in the collection.
     * @return True if the style is in the collection; False otherwise.
     */
    contains(style: WorksheetTableStyle): boolean;
    /**
     * Gets the index of the specified style in the collection.
     * @param style The style to find in the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @return The 0-based index of the specified style in the collection or -1 if the style is not in the collection.
     */
    indexOf(style: WorksheetTableStyle): number;
    /**
     * Removes the specified [[WorksheetTableStyle]] from the collection.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * @param style The table style to remove from the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @return True if the style was in the collection and therefore removed; False otherwise.
     */
    remove(style: WorksheetTableStyle): boolean;
    /**
     * Removes the [[WorksheetTableStyle]] at the specified index.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * @param index The index of the table style to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _o(a: WorksheetTableStyle, b: string): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
     */
    readonly count: number;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    item(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    item(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    readonly _e: Workbook;
}
/**
 * A collection of standard [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in a
 * [[Workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.standardTableStyles]]
 */
export declare class StandardTableStyleCollection extends Base implements IEnumerable$1<WorksheetTableStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static _b;
    private _g;
    static staticInit(): void;
    constructor();
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    static _h: (arg1: List$1<WorksheetTableStyle>) => WorkItem;
    /**
     * @hidden
     */
    private _a;
    /**
     * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
     */
    readonly count: number;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    item(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    item(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    readonly _d: WorksheetTableStyle;
    /**
     * @hidden
     */
    static readonly _c: StandardTableStyleCollection;
}
/**
 * @hidden
 */
export declare class WorksheetTable_ResizeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable_ResizeContext);
    constructor(a: number, b: WorksheetTable, c: WorksheetRegionAddress);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetTable;
    readonly c: WorksheetRegionAddress;
    readonly a: WorksheetTableColumn[];
    readonly b: WorksheetTableColumn[];
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetTable_ColumnChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable, c: number, d: number, e: boolean, f: boolean, g: WorksheetTableColumn[], h: Tuple$3<WorksheetTableColumn, number, SortCondition>[], i: Nullable$1<WorksheetRegionAddress>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly h: number;
    readonly g: number;
    readonly f: boolean;
    readonly e: boolean;
    readonly d: WorksheetTable;
    readonly a: WorksheetTableColumn[];
    readonly b: Tuple$3<WorksheetTableColumn, number, SortCondition>[];
    readonly c: WorksheetRegionAddress;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetTable_RowChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable, c: number, d: number, e: Nullable$1<WorksheetRegionAddress>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: number;
    readonly b: WorksheetTable;
    readonly a: WorksheetRegionAddress;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a region of cells formatted as a table.
 * <p class="body">
 * Tables assist in managing and analyzing a range of related data. This management can be done separately from the rest of the
 * data in the worksheet.
 * </p>
 * <p class="body">
 * A table can have one or more columns sorted and filtered. There are various sorting and filtering criteria that can be applied
 * to the columns. The types pertaining to filtering can be found in the Infragistics.Documents.Excel.Filtering namespace and a filter
 * can be applied to a column by setting the [[WorksheetTableColumn.filter]] property. The types pertaining to sorting can
 * be found in the Infragistics.Documents.Excel.Sorting namespace and a column can be sorted by setting the
 * [[WorksheetTableColumn.sortCondition]] or by populating the
 * [[SortSettings`1.sortConditions]] collection on the [[sortSettings]].
 * </p>
 * <p class="body">
 * A table can contain calculated columns which dynamically determine their value based on a formula. A
 * [[WorksheetTableColumn]] can be made a calculated column by setting the [[WorksheetTableColumn.columnFormula]].
 * </p>
 * <p class="body">
 * A table can also contain a totals row which display total information about the table. This can be shown by setting
 * [[isTotalsRowVisible]] to True. When the totals row is displayed, each column can display text or a calculated value in the
 * totals row, by setting either the [[WorksheetTableColumn.totalLabel]] or [[WorksheetTableColumn.totalFormula]],
 * respectively.
 * </p>
 * @see [[Worksheet.tables]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetCell.associatedTable]]
 * @see [[WorksheetRow.getCellAssociatedTable]]
 */
export declare class WorksheetTable extends NamedReferenceBase implements IAreaFormatsOwner$1<WorksheetTableArea>, IChangeInfoContext, ISortSettingsOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _dd;
    /**
     * @hidden
     */
    private static readonly _de;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _dj;
    /**
     * @hidden
     */
    private static readonly _dk;
    /**
     * @hidden
     */
    private static readonly _dl;
    /**
     * @hidden
     */
    private static readonly _dm;
    /**
     * @hidden
     */
    private static readonly _dn;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static _bf;
    private _b2;
    private _b9;
    private _c6;
    private _b1;
    private readonly _dq;
    private _dr;
    private _bl;
    private _cb;
    private _c7;
    private _bj;
    /**
     * @hidden
     */
    _bw: WorksheetRegionAddress;
    private _bn;
    static staticInit(): void;
    constructor(a: string, b: number, c: number, d: number, e: number, f: number);
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    readonly culture: string | CultureInfo;
    /**
     * @hidden
     */
    readonly _culture$i: CultureInfo;
    /**
     * @hidden
     */
    readonly sortRegion: WorksheetRegion;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    protected get__f(): RefBase;
    /**
     * @hidden
     */
    readonly _f: RefBase;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    protected get__n(): boolean;
    /**
     * @hidden
     */
    readonly _n: boolean;
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    protected get__z(): CultureInfo;
    /**
     * @hidden
     */
    readonly _z: CultureInfo;
    /**
     * @hidden
     */
    protected get__y(): boolean;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * Gets the string representation of the table.
     * @return The string representation of the table.
     */
    toString(): string;
    /**
     * @hidden
     */
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    /**
     * @hidden
     */
    protected get__k(): Workbook;
    /**
     * @hidden
     */
    readonly _k: Workbook;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * Clears all filters from the columns in the table.
     * <p class="body">
     * If any filters are present and removed when this is called, all hidden rows in the data area of the table will be unhidden.
     * </p>
     * @see [[reapplyFilters]]
     * @see [[WorksheetTableColumn.filter]]
     */
    clearFilters(): void;
    /**
     * Clears all sort conditions from the columns in the table.
     * <p class="note">
     * <b>Note:</b> Just as in Microsoft Excel, clearing the sort conditions will not revert the table back to its original unsorted
     * state. The table will remain in its last sorted order.
     * </p>
     * @see [[sortSettings]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    clearSortConditions(): void;
    /**
     * Deletes one or more columns from the table
     * @param tableColumnIndex The deletion start relative to the first column in the table.
     * @param count The number of columns to delete.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the columns in the table.
     */
    deleteColumns(tableColumnIndex: number, count?: number): void;
    /**
     * Deletes one or more data rows from the table
     * @param dataRowIndex The deletion start relative to the first row in the [[dataAreaRegion]].
     * @param count The number of rows to delete.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the rows (excluding header and total rows) in the table.
     */
    deleteDataRows(dataRowIndex: number, count?: number): void;
    /**
     * Inserts one or more columns into the table
     * @param tableColumnIndex The insertion point relative to the first column in the table.
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insertColumns(tableColumnIndex: number, count?: number): void;
    /**
     * Inserts one or more data rows into the table
     * @param dataRowIndex The insertion point relative to the first row in the [[dataAreaRegion]].
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insertDataRows(dataRowIndex: number, count?: number): void;
    /**
     * Re-filters all data cells in the table based on the filters from the columns in the table.
     * <p class="body">
     * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
     * added or removed on a column in the table or when the ReapplyFilters method is called.
     * </p>
     * <p class="body">
     * If no columns in the table have filters set, this method will not do anything to the data.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * @see [[clearFilters]]
     * @see [[WorksheetTableColumn.filter]]
     */
    reapplyFilters(): void;
    /**
     * Re-sorts all data cells in the table based on the sort conditions from the columns in the table.
     * @see [[sortSettings]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    reapplySortConditions(): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegion The new region of headers (if currently visible) and data for the table, which must contain at least one data row, and overlap
     * and have the same top as the current table region.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegion' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegion' from a different worksheet or has been previously shifted off the table's worksheet.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegion' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegion' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegion' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegion: WorksheetRegion): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegionAddress The address of the new region of headers (if currently visible) and data for the table, which must contain at least one data row,
     * and overlap and have the same top as the current table region.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegionAddress' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegionAddress' is not a valid name or a valid cell or region address in the
     * workbook's cell reference mode.
     * @throws [[InvalidOperationException]] Occurs when 'headerAndDataRegionAddress' is a relative R1C1 address. The overload taking an origin cell must
     * be used to resolve relative R1C1 references.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegionAddress' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegionAddress: string): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegionAddress The address of the new region of headers (if currently visible) and data for the table, which must contain at least one data row,
     * and overlap and have the same top as the current table region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegionAddress' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegionAddress' is not a valid name or a valid cell or region address in the
     * workbook's cell reference mode.
     * @throws [[InvalidOperationException]] Occurs when 'headerAndDataRegionAddress' is a relative R1C1 address. The overload taking an origin cell must
     * be used to resolve relative R1C1 references.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegionAddress' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegionAddress: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _resize1(a: string): void;
    /**
     * @hidden
     */
    _resize2(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _resize(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    private _ez;
    /**
     * @hidden
     */
    private _er;
    /**
     * @hidden
     */
    _dv(a: number, b: number, c: WorksheetCellFormatProxy): void;
    /**
     * @hidden
     */
    _dz(): void;
    /**
     * @hidden
     */
    static _cd(a: WorksheetTableArea, b: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _ce(a: WorksheetRow, b: number): boolean;
    /**
     * @hidden
     */
    _cf(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _cg(a: number, b: number): boolean;
    /**
     * @hidden
     */
    private _d5;
    /**
     * @hidden
     */
    private _d6;
    /**
     * @hidden
     */
    _d8(a: number, b: number): {
        p0: number;
        p1: number;
    };
    /**
     * @hidden
     */
    _d7(a: WorksheetRegionAddress, b: number, c: number): {
        p1: number;
        p2: number;
    };
    /**
     * @hidden
     */
    _d9(): void;
    /**
     * @hidden
     */
    _ed(a: WorksheetTableColumn): void;
    /**
     * @hidden
     */
    _ea(): void;
    /**
     * @hidden
     */
    _ec(a: WorksheetTable, b: boolean): void;
    /**
     * @hidden
     */
    _b4(): WorksheetTableColumn;
    /**
     * @hidden
     */
    _b5(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    private _b8;
    /**
     * @hidden
     */
    _b6(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    _b7(a: number, b: WorksheetTableColumn): WorksheetTableColumn;
    /**
     * @hidden
     */
    _cn(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _ct(a: ICellShiftOperationOverride): boolean;
    /**
     * @hidden
     */
    _cy(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _ej(a: Workbook): void;
    /**
     * @hidden
     */
    _ek(a: boolean): void;
    /**
     * @hidden
     */
    _el(a: Worksheet): void;
    /**
     * @hidden
     */
    private _bo;
    /**
     * @hidden
     */
    static _es(a: CellShiftResult, b: string): void;
    /**
     * @hidden
     */
    _e0(): void;
    /**
     * @hidden
     */
    _bk(a: CellShiftOperation, b: ICellShiftOperationOverride, c: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    _e6(): void;
    /**
     * @hidden
     */
    private _du;
    /**
     * @hidden
     */
    private _dw;
    /**
     * @hidden
     */
    private _dx;
    /**
     * @hidden
     */
    private _dy;
    /**
     * @hidden
     */
    private _d1;
    /**
     * @hidden
     */
    private static _bh;
    /**
     * @hidden
     */
    private static _bi;
    /**
     * @hidden
     */
    private static _bg;
    /**
     * @hidden
     */
    private _cl;
    /**
     * @hidden
     */
    private static _eb;
    /**
     * @hidden
     */
    private _co;
    /**
     * @hidden
     */
    private _ef;
    /**
     * @hidden
     */
    private _ev;
    /**
     * @hidden
     */
    private _eh;
    /**
     * @hidden
     */
    private _ei;
    /**
     * @hidden
     */
    private _em;
    /**
     * @hidden
     */
    private _en;
    /**
     * @hidden
     */
    private _eo;
    /**
     * @hidden
     */
    private _ep;
    /**
     * @hidden
     */
    private _dp;
    /**
     * @hidden
     */
    private _eq;
    /**
     * @hidden
     */
    private _e2;
    /**
     * @hidden
     */
    private _c2;
    /**
     * @hidden
     */
    private _e7;
    /**
     * @hidden
     */
    private static _e8;
    /**
     * @hidden
     */
    private static _e9;
    /**
     * @hidden
     */
    private static _fa;
    /**
     * @hidden
     */
    private static _fb;
    /**
     * @hidden
     */
    private static _fc;
    /**
     * @hidden
     */
    private static _fd;
    /**
     * @hidden
     */
    private static _c4;
    /**
     * @hidden
     */
    private _fe;
    private _bv;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _bx;
    /**
     * @hidden
     */
    private _e1;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of the [[WorksheetTable]].
     * <p class="body">
     * The available areas of the table which can have a format set are the whole table, header, data, and totals areas.
     * </p>
     * <p class="body">
     * Applying a format to an area will apply the format to all cells in that area.
     * </p>
     * <p class="body">
     * If any area formats on the tables are set when the table is resized to give it more columns, the area formats of the new columns
     * will be initialized with the area formats from the table.
     * </p>
     * @see [[WorksheetTableColumn.filter]]
     * @see [[WorksheetTableColumn.areaFormats]]
     * @see [[WorksheetTableStyle]]
     * @see [[resize]]
     * @see [[resize]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableArea>;
    /**
     * @hidden
     */
    readonly _areaFormats$i: WorksheetTableAreaFormatsCollection$1<WorksheetTableArea>;
    /**
     * Gets the [[WorksheetTableColumn]] at the specified index.
     * @param index The 0-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of columns in the collection.
     * @return The WorksheetTableColumn at the specified index.
     */
    columns(index: number): WorksheetTableColumn;
    /**
     * Gets the [[WorksheetTableColumn]] with the specified name or null if it doesn't exist.
     * <p class="body">
     * Column names are compared case-insensitively.
     * </p>
     * @param name The name of the column to get.
     * @return The WorksheetTableColumn with the specified name or null a column with the specified name doesn't exist.
     * @see [[WorksheetTableColumn.name]]
     */
    columns(name: string): WorksheetTableColumn;
    /**
     * Gets the collection of columns in the table.
     * <p class="body">
     * Each column is represented by a [[WorksheetTableColumn]] instance and contains various settings for controlling
     * the contents, formatting, sorting, and filtering of the column.
     * </p>
     * @see [[WorksheetTableColumn]]
     */
    columns(): WorksheetTableColumnCollection;
    /**
     * @hidden
     */
    readonly _columns$i: WorksheetTableColumnCollection;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the table.
     * <p class="body">
     * The data area of the table can be changed by using one of the Resize overloads.
     * </p>
     * @see [[resize]]
     * @see [[resize]]
     */
    readonly dataAreaRegion: WorksheetRegion;
    /**
     * Gets or sets the value which indicates whether the alternate column format should be applied to the appropriate columns of the
     * [[WorksheetTable]].
     * <p class="body">
     * The column formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].ColumnStripe and
     * WorksheetTableStyleArea.AlternateColumnStripe values. If there is no area format applied for the AlternateColumnStripe value,
     * this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If this value is True and there is an area format for the alternate column stripe, the stripe widths are defined by the
     * [[WorksheetTableStyle.columnStripeWidth]] and [[WorksheetTableStyle.alternateColumnStripeWidth]] values.
     * </p>
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     * @see [[WorksheetTableStyle.columnStripeWidth]]
     * @see [[WorksheetTableStyle.alternateColumnStripeWidth]]
     */
    /**
    * Gets or sets the value which indicates whether the alternate column format should be applied to the appropriate columns of the
    * [[WorksheetTable]].
    * <p class="body">
    * The column formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
    * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].ColumnStripe and
    * WorksheetTableStyleArea.AlternateColumnStripe values. If there is no area format applied for the AlternateColumnStripe value,
    * this property has no effect on the display of the table.
    * </p>
    * <p class="body">
    * If this value is True and there is an area format for the alternate column stripe, the stripe widths are defined by the
    * [[WorksheetTableStyle.columnStripeWidth]] and [[WorksheetTableStyle.alternateColumnStripeWidth]] values.
    * </p>
    * @see [[style]]
    * @see [[WorksheetTableStyle.areaFormats]]
    * @see [[WorksheetTableStyleArea]]
    * @see [[WorksheetTableStyle.columnStripeWidth]]
    * @see [[WorksheetTableStyle.alternateColumnStripeWidth]]
    */
    displayBandedColumns: boolean;
    /**
     * Gets or sets the value which indicates whether the alternate row format should be applied to the appropriate rows of the
     * [[WorksheetTable]].
     * <p class="body">
     * The row formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].RowStripe and
     * WorksheetTableStyleArea.AlternateRowStripe values. If there is no area format applied for the AlternateRowStripe value,
     * this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If this value is True and there is an area format for the alternate row stripe, the stripe widths are defined by the
     * [[WorksheetTableStyle.rowStripeHeight]] and [[WorksheetTableStyle.alternateRowStripeHeight]] values.
     * </p>
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     * @see [[WorksheetTableStyle.rowStripeHeight]]
     * @see [[WorksheetTableStyle.alternateRowStripeHeight]]
     */
    /**
    * Gets or sets the value which indicates whether the alternate row format should be applied to the appropriate rows of the
    * [[WorksheetTable]].
    * <p class="body">
    * The row formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
    * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].RowStripe and
    * WorksheetTableStyleArea.AlternateRowStripe values. If there is no area format applied for the AlternateRowStripe value,
    * this property has no effect on the display of the table.
    * </p>
    * <p class="body">
    * If this value is True and there is an area format for the alternate row stripe, the stripe widths are defined by the
    * [[WorksheetTableStyle.rowStripeHeight]] and [[WorksheetTableStyle.alternateRowStripeHeight]] values.
    * </p>
    * @see [[style]]
    * @see [[WorksheetTableStyle.areaFormats]]
    * @see [[WorksheetTableStyleArea]]
    * @see [[WorksheetTableStyle.rowStripeHeight]]
    * @see [[WorksheetTableStyle.alternateRowStripeHeight]]
    */
    displayBandedRows: boolean;
    /**
     * Gets or sets the value which indicates whether the first column format should be applied to the appropriate column of the
     * [[WorksheetTable]].
     * <p class="body">
     * The first column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].FirstColumn
     * value. If there is no area format applied for the FirstColumn value, this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
     * will take precedence.
     * </p>
     * @see [[displayLastColumnFormatting]]
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     */
    /**
    * Gets or sets the value which indicates whether the first column format should be applied to the appropriate column of the
    * [[WorksheetTable]].
    * <p class="body">
    * The first column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
    * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].FirstColumn
    * value. If there is no area format applied for the FirstColumn value, this property has no effect on the display of the table.
    * </p>
    * <p class="body">
    * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
    * will take precedence.
    * </p>
    * @see [[displayLastColumnFormatting]]
    * @see [[style]]
    * @see [[WorksheetTableStyle.areaFormats]]
    * @see [[WorksheetTableStyleArea]]
    */
    displayFirstColumnFormatting: boolean;
    /**
     * Gets or sets the value which indicates whether the last column format should be applied to the appropriate column of the
     * [[WorksheetTable]].
     * <p class="body">
     * The last column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].LastColumn
     * value. If there is no area format applied for the LastColumn value, this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
     * will take precedence.
     * </p>
     * @see [[displayFirstColumnFormatting]]
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     */
    /**
    * Gets or sets the value which indicates whether the last column format should be applied to the appropriate column of the
    * [[WorksheetTable]].
    * <p class="body">
    * The last column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
    * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].LastColumn
    * value. If there is no area format applied for the LastColumn value, this property has no effect on the display of the table.
    * </p>
    * <p class="body">
    * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
    * will take precedence.
    * </p>
    * @see [[displayFirstColumnFormatting]]
    * @see [[style]]
    * @see [[WorksheetTableStyle.areaFormats]]
    * @see [[WorksheetTableStyleArea]]
    */
    displayLastColumnFormatting: boolean;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the header row of the table.
     * A WorksheetRegion which represents the region of cells in the header row of the table or null if the header row is not visible.
     * @see [[isHeaderRowVisible]]
     * @see [[resize]]
     * @see [[resize]]
     */
    readonly headerRowRegion: WorksheetRegion;
    /**
     * Gets or sets the value indicating whether to allow filtering and show filter buttons in the table headers.
     * <p class="body">
     * If [[isHeaderRowVisible]] is False, this property must be False and setting it to True will cause an error.
     * If [[isHeaderRowVisible]] is set to True, this property will also be set to True automatically.
     * </p>
     * @throws [[InvalidOperationException]] The value assigned is True and [[isHeaderRowVisible]] is False.
     * @see [[isHeaderRowVisible]]
     */
    /**
    * Gets or sets the value indicating whether to allow filtering and show filter buttons in the table headers.
    * <p class="body">
    * If [[isHeaderRowVisible]] is False, this property must be False and setting it to True will cause an error.
    * If [[isHeaderRowVisible]] is set to True, this property will also be set to True automatically.
    * </p>
    * @throws [[InvalidOperationException]] The value assigned is True and [[isHeaderRowVisible]] is False.
    * @see [[isHeaderRowVisible]]
    */
    isFilterUIVisible: boolean;
    /**
     * @hidden
     */
    private _e3;
    /**
     * Gets or sets the value which indicates whether the row containing column headers should be displayed.
     * <p class="body">
     * When the header row is visible, the cell above each column of data will contain the [[WorksheetTableColumn.name]]
     * value. Therefore, all header cells always contain a string value. Additionally, they will all be unique.
     * </p>
     * True if the row containing column headers is visible; False if it is hidden.
     * @see [[WorksheetTableColumn.name]]
     */
    /**
    * Gets or sets the value which indicates whether the row containing column headers should be displayed.
    * <p class="body">
    * When the header row is visible, the cell above each column of data will contain the [[WorksheetTableColumn.name]]
    * value. Therefore, all header cells always contain a string value. Additionally, they will all be unique.
    * </p>
    * True if the row containing column headers is visible; False if it is hidden.
    * @see [[WorksheetTableColumn.name]]
    */
    isHeaderRowVisible: boolean;
    /**
     * @hidden
     */
    private _e4;
    /**
     * Gets or sets the value which indicates whether the row containing column totals should be displayed.
     * <p class="body">
     * When the totals row is visible, the cell below each column of data will contain either a calculated value, a text value, or nothing.
     * To display a calculated value in the cell, set the [[WorksheetTableColumn.totalFormula]]. To display a text label, set the
     * [[WorksheetTableColumn.totalLabel]]. If both are set, the calculated value takes precedence.
     * </p>
     * True if the row containing column totals is visible; False if it is hidden.
     * @throws [[InvalidOperationException]] The value is set to True and the table occupies the last row of the worksheet.
     * @see [[WorksheetTableColumn.totalFormula]]
     * @see [[WorksheetTableColumn.totalLabel]]
     */
    /**
    * Gets or sets the value which indicates whether the row containing column totals should be displayed.
    * <p class="body">
    * When the totals row is visible, the cell below each column of data will contain either a calculated value, a text value, or nothing.
    * To display a calculated value in the cell, set the [[WorksheetTableColumn.totalFormula]]. To display a text label, set the
    * [[WorksheetTableColumn.totalLabel]]. If both are set, the calculated value takes precedence.
    * </p>
    * True if the row containing column totals is visible; False if it is hidden.
    * @throws [[InvalidOperationException]] The value is set to True and the table occupies the last row of the worksheet.
    * @see [[WorksheetTableColumn.totalFormula]]
    * @see [[WorksheetTableColumn.totalLabel]]
    */
    isTotalsRowVisible: boolean;
    /**
     * @hidden
     */
    private _e5;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cx: boolean;
    /**
     * Gets the settings which determine how the data within the table should be sorted.
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
     * only when they are are added or removed on a column in the table or when the [[reapplySortConditions]] method is called.
     * </p>
     * @see [[reapplySortConditions]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    readonly sortSettings: SortSettings$1<WorksheetTableColumn>;
    /**
     * Gets or sets the style to use on the [[WorksheetTable]].
     * <p class="body">
     * The [[WorksheetTableStyle]] defines formats to use in various areas of the table. These formats are used as defaults
     * for cells which don't have their formatting properties already set.
     * </p>
     * <p class="body">
     * The area formats specified in the WorksheetTableStyle are differential formats. In other words, only the properties that are set
     * to non-default values will be applied to the appropriate cells. An area format can define only a background color or only font
     * information and that format will be applied to the cells while all other formatting properties on the cells will be maintained.
     * </p>
     * <p class="body">
     * If this value is set to null, the Style will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * The [[WorksheetTableStyle]] instance which defines the various default table area formats.
     * @throws [[ArgumentException]] The value specified is not in the [[Workbook.customTableStyles]] or [[Workbook.standardTableStyles]]
     * collections.
     * @see [[Workbook.defaultTableStyle]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     */
    /**
    * Gets or sets the style to use on the [[WorksheetTable]].
    * <p class="body">
    * The [[WorksheetTableStyle]] defines formats to use in various areas of the table. These formats are used as defaults
    * for cells which don't have their formatting properties already set.
    * </p>
    * <p class="body">
    * The area formats specified in the WorksheetTableStyle are differential formats. In other words, only the properties that are set
    * to non-default values will be applied to the appropriate cells. An area format can define only a background color or only font
    * information and that format will be applied to the cells while all other formatting properties on the cells will be maintained.
    * </p>
    * <p class="body">
    * If this value is set to null, the Style will be set to the [[Workbook.defaultTableStyle]].
    * </p>
    * The [[WorksheetTableStyle]] instance which defines the various default table area formats.
    * @throws [[ArgumentException]] The value specified is not in the [[Workbook.customTableStyles]] or [[Workbook.standardTableStyles]]
    * collections.
    * @see [[Workbook.defaultTableStyle]]
    * @see [[Workbook.customTableStyles]]
    * @see [[Workbook.standardTableStyles]]
    */
    style: WorksheetTableStyle;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the totals row of the table.
     * A WorksheetRegion which represents the region of cells in the totals row of the table or null if the totals row is not visible.
     * @see [[isTotalsRowVisible]]
     * @see [[resize]]
     * @see [[resize]]
     */
    readonly totalsRowRegion: WorksheetRegion;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the whole table, including the header and totals rows,
     * if visible.
     * <p class="body">
     * The table region can be changed by using one of the Resize overloads.
     * </p>
     * @see [[resize]]
     * @see [[resize]]
     */
    readonly wholeTableRegion: WorksheetRegion;
    /**
     * Gets the [[worksheet]] to which the table belongs.
     * The Worksheet to which the table belongs or null if the table has been removed from the Worksheet.
     * @see [[Worksheet.tables]]
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _bq: WorksheetRegion;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cm: boolean;
    /**
     * @hidden
     */
    readonly _bz: WorksheetRow;
    /**
     * @hidden
     */
    readonly _ds: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cp: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cs: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cu: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cv: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _dt: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _c0: boolean;
    /**
     * @hidden
     */
    readonly _bs: WorksheetRegion;
    /**
     * @hidden
     */
    readonly _b0: WorksheetRow;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _c5: boolean;
    /**
     * @hidden
     */
    readonly _by: WorksheetRegionAddress;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _cz;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _c1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _c3;
}
/**
 * @hidden
 */
export declare class WorksheetTableResizeOperation extends Base {
    static $t: Type;
    readonly a: WorksheetRegionAddress;
    readonly b: WorksheetRegionAddress;
    readonly c: WorksheetRegionAddress;
    readonly d: WorksheetRegionAddress;
    constructor(a: WorksheetTable, b: WorksheetRegionAddress);
}
/**
 * A collection of formats for areas of a [[WorksheetTable]].
 * @typedef TArea An enumeration defining the various table areas which can contain formats.
 * @see [[WorksheetTable.areaFormats]]
 * @see [[WorksheetTableColumn.areaFormats]]
 * @see [[WorksheetTableStyle.areaFormats]]
 */
export declare class WorksheetTableAreaFormatsCollection$1<TArea> extends Base implements IEnumerable$1<KeyValuePair$2<TArea, IWorksheetCellFormat>> {
    static $t: Type;
    protected $tArea: Type;
    private _h;
    private _a;
    constructor($tArea: Type, a: IAreaFormatsOwner$1<TArea>);
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<TArea, IWorksheetCellFormat>>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<KeyValuePair$2<TArea, IWorksheetCellFormat>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the area has a non-default format applied.
     * @param area The area of which to test the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     * @return True if the area has a non-default format applied; False otherwise.
     */
    hasFormat(area: TArea): boolean;
    /**
     * @hidden
     */
    _hasFormat$i(a: TArea): boolean;
    /**
     * @hidden
     */
    _d(a: Workbook, b: TArea): WorksheetTableAreaFormatProxy$1<TArea>;
    /**
     * @hidden
     */
    private _e;
    /**
     * @hidden
     */
    _i(): IEnumerable$1<WorksheetTableAreaFormatProxy$1<TArea>>;
    /**
     * @hidden
     */
    _k(a: Workbook): void;
    /**
     * @hidden
     */
    _l(): void;
    /**
     * @hidden
     */
    _c(a: TArea): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _f(a: TArea): WorksheetTableAreaFormatProxy$1<TArea>;
    /**
     * Gets the number of area formats in the collection.
     */
    readonly count: number;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    item(a: TArea): IWorksheetCellFormat;
}
/**
 * @hidden
 */
export declare class WorksheetTableAreaFormatProxy$1<TArea> extends WorksheetCellFormatProxy {
    static $t: Type;
    protected $tArea: Type;
    private _bs;
    constructor($tArea: Type, a: TArea, b: WorksheetCellFormatData, c: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
    readonly _bt: TArea;
}
/**
 * @hidden
 */
export declare class WorksheetTableCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTableCollection, c: WorksheetTable, d: number, e: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly b: WorksheetTableCollection;
    readonly a: WorksheetTable;
    readonly c: boolean;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * The collection of [[WorksheetTable]] instances on a [[Worksheet]].
 * @see [[Worksheet.tables]]
 */
export declare class WorksheetTableCollection extends Base implements IList$1<WorksheetTable> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static _a;
    private _n;
    private _m;
    /**
     * @hidden
     */
    _d: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    insert(index: number, item: WorksheetTable): void;
    /**
     * @hidden
     */
    item(index: number, value?: WorksheetTable): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] at the specified index.
     * The WorksheetTable at the specified index.
     * @param index The zero-based index of the WorksheetTable to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The WorksheetTable with the specified name.
     * @param name The name of the WorksheetTable to get.
     * @throws [[InvalidOperationException]] A WorksheetTable with the specified name does not exist in the collection.
     * @see [[NamedReferenceBase.name]]
     */
    item(name: string): WorksheetTable;
    /**
     * @hidden
     */
    _item$e(a: number, b?: WorksheetTable): WorksheetTable;
    /**
     * @hidden
     */
    add(item: WorksheetTable): void;
    /**
     * Formats a region as a table and adds an associated [[WorksheetTable]] to the collection.
     * <p class="body">
     * When the table is created, the specified 'tableStyle' will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param region The region to format as a table.
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @param tableStyle The [[WorksheetTableStyle]] to apply to the table or null to use the [[Workbook.defaultTableStyle]].
     * @see [[WorksheetTable.style]]
     * @throws [[InvalidOperationException]] The owning worksheet has been removed from its workbook.
     * @throws [[ArgumentNullException]] 'region' is null or empty.
     * @throws [[ArgumentException]] 'region' is not a valid region address in the workbook's cell reference mode.
     * @throws [[ArgumentException]] The specified 'tableStyle' does not exist in the [[Workbook.customTableStyles]] or
     * [[Workbook.standardTableStyles]] collections.
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     * @see [[WorksheetTable.style]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetRegion.formatAsTable]]
     */
    add(region: string, tableHasHeaders: boolean, tableStyle?: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _add$e(a: WorksheetTable): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetTable[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetTable): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTable>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTable>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add2(a: string, b: boolean, c?: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _add1(a: WorksheetRegion, b: boolean, c: WorksheetTableStyle, d?: WorksheetTable, e?: boolean): WorksheetTable;
    /**
     * @hidden
     */
    private _s;
    /**
     * Clears the collection and removes all tables from the worksheet.
     */
    clear(): void;
    /**
     * Determines whether the specified [[WorksheetTable]] is in the collection.
     * @param table The WorksheetTable to find in the collection.
     * @return True if the WorksheetTable is in the collection; False otherwise.
     */
    contains(table: WorksheetTable): boolean;
    /**
     * Determines whether a [[WorksheetTable]] with the specified name is in the collection.
     * <p class="body">
     * Table names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTable to find.
     * @return True if a WorksheetTable with the specified name is in the collection; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified [[WorksheetTable]] in the collection.
     * @param table The WorksheetTable to find in the collection.
     * @return The 0-based index of the specified WorksheetTable in the collection or -1 if the item is not in the collection.
     */
    indexOf(table: WorksheetTable): number;
    /**
     * Removes the [[WorksheetTable]] from the collection.
     * @param table The WorksheetTable to remove from the collection.
     * @param convertToRange True to apply the table style formatting to the cells
     * @return True if the WorksheetTable was found and removed; False otherwise.
     */
    remove_1(table: WorksheetTable, convertToRange?: boolean): boolean;
    /**
     * Removes the [[WorksheetTable]] at the specified index.
     * @param index The 0-based index of the WorksheetTable to remove.
     * @param convertToRange True to apply the table style formatting to the cells
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number, convertToRange?: boolean): void;
    /**
     * @hidden
     */
    _g(a: number): WorksheetTable;
    /**
     * @hidden
     */
    _t(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _u(a: number, b: WorksheetTable): void;
    /**
     * @hidden
     */
    _k(a: number, b: number): boolean;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _r;
    /**
     * @hidden
     */
    private _v;
    /**
     * @hidden
     */
    private _x;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _z;
    /**
     * Gets the number of tables in the collection.
     * The number of tables in the collection.
     */
    readonly count: number;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTable;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTable;
}
/**
 * @hidden
 */
export interface IFilterable extends IWorkbookProvider, IWorksheetProvider {
    readonly columnIndex: number;
    readonly filter: Filter;
    getDataAreaRowIndexes(a: number, b: number): {
        p0: number;
        p1: number;
    };
    onFilterModified(): void;
}
/**
 * @hidden
 */
export declare let IFilterable_$type: Type;
/**
 * Abstract base class for all filters which filters cells in a worksheet.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[CustomFilter]]
 * @see [[FixedValuesFilter]]
 * @see [[TopOrBottomFilter]]
 * @see [[DynamicValuesFilter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 * @see [[FontColorFilter]]
 * @see [[FillFilter]]
 */
export declare abstract class Filter extends Base implements IChangeInfoContext {
    static $t: Type;
    private _a;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    static _c(a: WorksheetRow, b: number): GetCellTextResult;
    /**
     * @hidden
     */
    abstract _d(a: Filter): boolean;
    /**
     * @hidden
     */
    abstract _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _i(): void;
    /**
     * @hidden
     */
    _j(a: IFilterable): void;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    readonly _h: CultureInfo;
    /**
     * @hidden
     */
    readonly _b: IFilterable;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents a column in a [[WorksheetTable]].
 * <p class="body">
 * Each column contains various settings for controlling the contents, formatting, sorting, and filtering within it.
 * </p>
 */
export declare class WorksheetTableColumn extends Base implements IAreaFormatsOwner$1<WorksheetTableColumnArea>, IChangeInfoContext, IFilterable, ISortable {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _a;
    private _as;
    private _am;
    private _au;
    private _w;
    private _i;
    private _a8;
    private _a2;
    private _ak;
    private _x;
    private _a3;
    private _ao;
    constructor(a: WorksheetTable, b: number, c: number);
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableColumnArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly columnIndex: number;
    /**
     * @hidden
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    getDataAreaRowIndexes(dataAreaTopRowIndex: number, dataAreaBottomRowIndex: number): {
        p0: number;
        p1: number;
    };
    /**
     * @hidden
     */
    onFilterModified(): void;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * Applies an [[AverageFilter]] to the column.
     * @param type The value indicating whether to filter in values below or above the average of the data range.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[AverageFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyAverageFilter(type: AverageFilterType): AverageFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="note">
     * <b>Note:</b> If the filter condition value is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param condition The condition which must pass for the data to be filtered in.
     * @throws [[ArgumentNullException]] 'condition' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[CustomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(condition: CustomFilterCondition): CustomFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="body">
     * If 'condition2' is null, the 'conditionalOperator' value is irrelevant.
     * </p>
     * <p class="note">
     * <b>Note:</b> If one of the filter condition values is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param condition1 The first condition used to filter the data.
     * @param condition2 The second condition used to filter the data.
     * @param conditionalOperator The operator which defines how to logically combine 'condition1' and 'condition2'.
     * @throws [[ArgumentNullException]] 'condition1' is null.
     * @throws [[InvalidEnumArgumentException]] 'conditionalOperator' is not defined in the [[ConditionalOperator]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[CustomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(condition1: CustomFilterCondition, condition2: CustomFilterCondition, conditionalOperator: ConditionalOperator): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter(a: CustomFilterCondition): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter1(a: CustomFilterCondition, b: CustomFilterCondition, c: ConditionalOperator): CustomFilter;
    /**
     * Applies an [[DatePeriodFilter]] to the column.
     * <p class="body">
     * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
     * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
     * </p>
     * @param type The type of date period to filter in.
     * @param value The 1-based value of the month or quarter to filter in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
     * type is Month and value is less than 1 or greater than 12.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[DatePeriodFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyDatePeriodFilter(type: DatePeriodFilterType, value: number): DatePeriodFilter;
    /**
     * Applies a [[FillFilter]] to the column.
     * @param fill A [[CellFill]] by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fill' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[FillFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFillFilter(fill: CellFill): FillFilter;
    /**
     * @hidden
     */
    _j(a: boolean, ...b: string[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _m(a: boolean, b: IEnumerable$1<string>): FixedValuesFilter;
    /**
     * @hidden
     */
    _n(a: boolean, b: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FixedValuesFilter]] to the column.
     * @param includeBlanks The value which indicates whether blank cells should be filtered in.
     * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
     * @param dateGroups The collection of fixed date groups which should be filtered in.
     * @throws [[ArgumentNullException]] 'dateGroups' is null.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
     * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
     * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[FixedValuesFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFixedValuesFilter(includeBlanks: boolean, calendarType: CalendarType, ...dateGroups: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _applyFixedValuesFilter1(a: boolean, b: CalendarType, ...c: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _l(a: boolean, b: CalendarType, c: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param fontColorInfo A [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColorInfo' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[FontColorFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(fontColorInfo: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param fontColor The font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColor' is empty.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[FontColorFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(fontColor: string | Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter1(a: Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter(a: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[IconFilter]] to the column.
     * @param iconSet The icon set containing the icon.
     * @throws [[ArgumentException]] If the icon set is not valid.
     * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
     * @throws [[ArgumentOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
     * @see [[IconFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     */
    applyIconFilter(iconSet: FormatConditionIconSet, iconIndex: number | null): IconFilter;
    /**
     * @hidden
     */
    _applyIconFilter$i(a: FormatConditionIconSet, b: Nullable$1<number>): IconFilter;
    /**
     * @hidden
     */
    _r(a: ST_IconSetType, b: Nullable$1<number>): IconFilter;
    /**
     * Applies a [[RelativeDateRangeFilter]] to the column.
     * <p class="body">
     * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
     * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
     * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
     * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
     * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
     * dates in 1999, even if the workbook is opened in 2012.
     * </p>
     * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
     * @param duration The duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[RelativeDateRangeFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyRelativeDateRangeFilter(offset: RelativeDateRangeOffset, duration: RelativeDateRangeDuration): RelativeDateRangeFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column which will filter in the top 10 values in the list of sorted values.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[TopOrBottomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(): TopOrBottomFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column.
     * @param type The type of the filter.
     * @param value The number or percentage of value of values which should be filtered in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @throws [[ArgumentOutOfRangeException]] 'value' is less than 1 or greater than 500.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[TopOrBottomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(type: TopOrBottomFilterType, value: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter(): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter1(a: TopOrBottomFilterType, b: number): TopOrBottomFilter;
    /**
     * Applies a [[YearToDateFilter]] to the column.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[YearToDateFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyYearToDateFilter(): YearToDateFilter;
    /**
     * Removes the filter from the column if one is applied.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[applyAverageFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyDatePeriodFilter]]
     * @see [[applyFillFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyRelativeDateRangeFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyYearToDateFilter]]
     * @see [[filter]]
     */
    clearFilter(): void;
    /**
     * Sets the formula to use in the data cells in the column.
     * <p class="body">
     * If any relative cell or region references are in the specified formula, it will be assumed that the actual formula is being applied to
     * the first data cell in the column. When the formula is applied to other cells in the column, the relative references will be offset by
     * the appropriate amount.
     * </p>
     * <p class="body">
     * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
     * applied to them.
     * </p>
     * <p class="body">
     * If there was a different column formula applied previously and it was applied to any of the cells in the column, setting it to a
     * different formula will overwrite the formulas on those cells, regardless of the value of 'overwriteExistingValues'.
     * </p>
     * @param formula The formula for the data cells of the column or null to remove the current column formula.
     * @param overwriteExistingValues True to overwrite the existing cells values and apply the formula to all data cells in the column.
     * False to only apply the formula to the cells with no value set.
     * @throws [[ArgumentException]] @throws [[InvalidOperationException]] If column was removed from the table.
     * 'formula' is already applied to something else, such as a cell or table column.
     * @see [[columnFormula]]
     */
    setColumnFormula(formula: Formula, overwriteExistingValues: boolean): void;
    /**
     * @hidden
     */
    _setColumnFormula1(a: Formula, b: boolean): void;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    _ba(a: number, b: number, c: number): void;
    /**
     * @hidden
     */
    static _ap(a: WorksheetTableColumnArea, b: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _ah(a: WorksheetRegion): WorksheetRegion;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _be(a: WorksheetTableColumn, b: boolean): void;
    /**
     * @hidden
     */
    _onFilterModified(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _bh(): void;
    /**
     * @hidden
     */
    _bi(): void;
    /**
     * @hidden
     */
    _bj(a: WorksheetTable, b: number, c?: boolean): void;
    /**
     * @hidden
     */
    _bk(a?: boolean): void;
    /**
     * @hidden
     */
    _bl(a: Workbook): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegionAddress, b: WorksheetRegion, c: WorksheetRegion): void;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    _bo(): void;
    /**
     * @hidden
     */
    _bq(): void;
    /**
     * @hidden
     */
    _br(): void;
    /**
     * @hidden
     */
    _bs(): void;
    /**
     * @hidden
     */
    _bt(a: number): void;
    /**
     * @hidden
     */
    _bz(a: Formula): void;
    /**
     * @hidden
     */
    _b4(): void;
    /**
     * @hidden
     */
    _b7(a: WorksheetTableColumnArea): void;
    /**
     * @hidden
     */
    _b6(a: WorksheetTableAreaFormatProxy$1<WorksheetTableColumnArea>, b: CellFormatValue, c: boolean, d: WorksheetRegion, e: WorksheetCell): void;
    /**
     * @hidden
     */
    private _bb;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _a1;
    /**
     * @hidden
     */
    private _bp;
    /**
     * @hidden
     */
    private _by;
    /**
     * @hidden
     */
    private _b5;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * @hidden
     */
    private _b9;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private _cb;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableColumnArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of the column.
     * <p class="body">
     * The available areas of the column which can have a format set are the header, data, and totals areas.
     * </p>
     * <p class="body">
     * Applying a format to an area will apply the format to all cells in that area.
     * </p>
     * <p class="body">
     * If any area formats on the columns are set when the table is resized to give it more rows, the new cells in the column will
     * get the new format applied.
     * </p>
     * @see [[filter]]
     * @see [[WorksheetTable.areaFormats]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTable.resize]]
     * @see [[WorksheetTable.resize]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableColumnArea>;
    /**
     * @hidden
     */
    readonly _areaFormats$i: WorksheetTableAreaFormatsCollection$1<WorksheetTableColumnArea>;
    /**
     * Gets the formula associated with the data area of the column.
     * <p class="body">
     * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
     * applied to them.
     * </p>
     * A [[Formula]] instance representing the formula for the data area of the column or null if no formula is applied.
     * @see [[setColumnFormula]]
     */
    readonly columnFormula: Formula;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the column.
     */
    readonly dataAreaRegion: WorksheetRegion;
    /**
     * Gets the filter applied to the column.
     * <p class="body">
     * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
     * added or removed on a column in the table or when the [[WorksheetTable.reapplyFilters]] method is called.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * A [[filter]]-derived instance if a filter is applied or null if the column is not filtered.
     * @see [[applyAverageFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyDatePeriodFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyRelativeDateRangeFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyYearToDateFilter]]
     * @see [[clearFilter]]
     * @see [[WorksheetTable.clearFilters]]
     * @see [[WorksheetTable.reapplyFilters]]
     */
    /**
    * Gets the filter applied to the column.
    * <p class="body">
    * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
    * added or removed on a column in the table or when the [[WorksheetTable.reapplyFilters]] method is called.
    * </p>
    * <p class="note">
    * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
    * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
    * same row will also be hidden.
    * </p>
    * A [[filter]]-derived instance if a filter is applied or null if the column is not filtered.
    * @see [[applyAverageFilter]]
    * @see [[applyCustomFilter]]
    * @see [[applyCustomFilter]]
    * @see [[applyDatePeriodFilter]]
    * @see [[applyFontColorFilter]]
    * @see [[applyFontColorFilter]]
    * @see [[applyFixedValuesFilter]]
    * @see [[applyFixedValuesFilter]]
    * @see [[applyFixedValuesFilter]]
    * @see [[applyFixedValuesFilter]]
    * @see [[applyRelativeDateRangeFilter]]
    * @see [[applyTopOrBottomFilter]]
    * @see [[applyTopOrBottomFilter]]
    * @see [[applyYearToDateFilter]]
    * @see [[clearFilter]]
    * @see [[WorksheetTable.clearFilters]]
    * @see [[WorksheetTable.reapplyFilters]]
    */
    filter: Filter;
    /**
     * @hidden
     */
    private _bx;
    /**
     * Gets the [[WorksheetCell]] which represents the header cell for the column.
     * A WorksheetCell which represents the header cell for the column or null if the header row is not visible in the table.
     * @see [[WorksheetTable.isHeaderRowVisible]]
     */
    readonly headerCell: WorksheetCell;
    /**
     * Gets the 0-based index of the column in the owning [[WorksheetTable.columns]] collection.
     * The 0-based index of the column in its collection or -1 if the column has been removed from the table.
     * @see [[WorksheetTable.columns]]
     */
    readonly index: number;
    /**
     * Gets or sets the name of the column.
     * <p class="body">
     * If the header row is visible in the [[WorksheetTable]], the name of the column will be displayed in the cell of the
     * column in the header row.
     * </p>
     * <p class="body">
     * When the WorksheetTable is created, the column names will be taken from the cells in the header row. If the table does not
     * contain a header row, the column names will be generated.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the Name property is set to a null or empty string, a column name will be generated. If the value is set to a column name which
     * already exists in the table, the column with the higher index will have a number appended to its name so all column names can stay
     * unique.
     * </p>
     * The unique name of the column within the owning WorksheetTable.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[WorksheetTable.isHeaderRowVisible]]
     */
    /**
    * Gets or sets the name of the column.
    * <p class="body">
    * If the header row is visible in the [[WorksheetTable]], the name of the column will be displayed in the cell of the
    * column in the header row.
    * </p>
    * <p class="body">
    * When the WorksheetTable is created, the column names will be taken from the cells in the header row. If the table does not
    * contain a header row, the column names will be generated.
    * </p>
    * <p class="body">
    * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
    * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
    * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
    * cells in the header row have no value, they will be given a generated column name.
    * </p>
    * <p class="body">
    * If the Name property is set to a null or empty string, a column name will be generated. If the value is set to a column name which
    * already exists in the table, the column with the higher index will have a number appended to its name so all column names can stay
    * unique.
    * </p>
    * The unique name of the column within the owning WorksheetTable.
    * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
    * @see [[WorksheetTable.isHeaderRowVisible]]
    */
    name: string;
    /**
     * @hidden
     */
    private _b0;
    /**
     * Gets or sets the sort condition used to sort the column in the table.
     * <p class="body">
     * When a sort condition is set on the column, the SortConditions collection on the [[WorksheetTable.sortSettings]] will be cleared
     * and the new sort condition will be added. To sort by multiple columns, the sort conditions must be added to the SortConditions collection
     * instead of set on the column. However, if a sort condition is cleared with this property, just the sort condition for the column will be
     * removed from the SortConditions collection. All other SortConditions will remain in the collection.
     * </p>
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
     * only when they are are added or removed on a column in the table or when the [[WorksheetTable.reapplySortConditions]] method
     * is called.
     * </p>
     * The [[sortCondition]]-derived instance used to sort the column or null of the column is not sorted.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[WorksheetTable.sortSettings]]
     * @see [[SortSettings`1.sortConditions]]
     * @see [[SortConditionCollection`1]]
     * @see [[WorksheetTable.clearSortConditions]]
     * @see [[WorksheetTable.reapplySortConditions]]
     */
    /**
    * Gets or sets the sort condition used to sort the column in the table.
    * <p class="body">
    * When a sort condition is set on the column, the SortConditions collection on the [[WorksheetTable.sortSettings]] will be cleared
    * and the new sort condition will be added. To sort by multiple columns, the sort conditions must be added to the SortConditions collection
    * instead of set on the column. However, if a sort condition is cleared with this property, just the sort condition for the column will be
    * removed from the SortConditions collection. All other SortConditions will remain in the collection.
    * </p>
    * <p class="note">
    * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
    * only when they are are added or removed on a column in the table or when the [[WorksheetTable.reapplySortConditions]] method
    * is called.
    * </p>
    * The [[sortCondition]]-derived instance used to sort the column or null of the column is not sorted.
    * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
    * @see [[WorksheetTable.sortSettings]]
    * @see [[SortSettings`1.sortConditions]]
    * @see [[SortConditionCollection`1]]
    * @see [[WorksheetTable.clearSortConditions]]
    * @see [[WorksheetTable.reapplySortConditions]]
    */
    sortCondition: SortCondition;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * Gets the [[WorksheetTable]] to which the column belongs.
     * The WorksheetTable to which the column belongs or null if the column has been removed from the table.
     */
    readonly table: WorksheetTable;
    /**
     * Gets the [[WorksheetCell]] which represents the total cell for the column.
     * A WorksheetCell which represents the total cell for the column or null if the totals row is not visible in the table.
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    readonly totalCell: WorksheetCell;
    /**
     * Gets or sets the formula to use in the total cell of the column.
     * <p class="body">
     * The total formula can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
     * formula will not be applied anywhere. When the totals row is visible, it will be applied to the total cell of the column.
     * </p>
     * <p class="body">
     * Setting the TotalFormula to a non-null value will clear the [[totalLabel]], and vice versa.
     * </p>
     * @throws [[ArgumentException]] The value is already applied to something else, such as a cell or table column.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[totalLabel]]
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    /**
    * Gets or sets the formula to use in the total cell of the column.
    * <p class="body">
    * The total formula can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
    * formula will not be applied anywhere. When the totals row is visible, it will be applied to the total cell of the column.
    * </p>
    * <p class="body">
    * Setting the TotalFormula to a non-null value will clear the [[totalLabel]], and vice versa.
    * </p>
    * @throws [[ArgumentException]] The value is already applied to something else, such as a cell or table column.
    * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
    * @see [[totalLabel]]
    * @see [[WorksheetTable.isTotalsRowVisible]]
    */
    totalFormula: Formula;
    /**
     * @hidden
     */
    private _b2;
    /**
     * Gets or sets the text label to use in the total cell of the column.
     * <p class="body">
     * The total label can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
     * label will not be displayed anywhere. When the totals row is visible, it will be set as the value of the total cell of the column.
     * </p>
     * <p class="body">
     * Setting the [[totalFormula]] to a non-null value will clear the TotalLabel, and vice versa.
     * </p>
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[totalFormula]]
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    /**
    * Gets or sets the text label to use in the total cell of the column.
    * <p class="body">
    * The total label can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
    * label will not be displayed anywhere. When the totals row is visible, it will be set as the value of the total cell of the column.
    * </p>
    * <p class="body">
    * Setting the [[totalFormula]] to a non-null value will clear the TotalLabel, and vice versa.
    * </p>
    * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
    * @see [[totalFormula]]
    * @see [[WorksheetTable.isTotalsRowVisible]]
    */
    totalLabel: string;
    /**
     * @hidden
     */
    private _b3;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the whole column, including the header and total cells,
     * if visible.
     */
    readonly wholeColumnRegion: WorksheetRegion;
    /**
     * @hidden
     */
    readonly _a9: number;
    /**
     * @hidden
     */
    readonly _a5: string;
    /**
     * @hidden
     */
    readonly _ai: WorksheetRegion;
    /**
     * @hidden
     */
    readonly _a7: string;
    /**
     * @hidden
     */
    readonly _aa: Formula;
    /**
     * @hidden
     */
    readonly _workbook: Workbook;
    /**
     * @hidden
     */
    readonly _worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly _at: number;
}
/**
 * A read-only collection of all [[WorksheetTableColumn]] instances which exist in a [[WorksheetTable]].
 * @see [[WorksheetTable.columns]]
 */
export declare class WorksheetTableColumnCollection extends Base implements IEnumerable$1<WorksheetTableColumn> {
    static $t: Type;
    private _e;
    private _a;
    constructor(a: WorksheetTable);
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableColumn>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableColumn>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the specified [[WorksheetTableColumn]] is in the collection.
     * @param column The column to find in the collection.
     * @return True if the specified column is in the collection; False otherwise.
     * @see [[WorksheetTableColumn]]
     */
    contains(column: WorksheetTableColumn): boolean;
    /**
     * Gets the index of the specified [[WorksheetTableColumn]] in the collection.
     * @param column The WorksheetTableColumn to find in the collection.
     * @return The 0-based index of the specified WorksheetTableColumn in the collection or -1 if the item is not in the collection.
     */
    indexOf(column: WorksheetTableColumn): number;
    /**
     * @hidden
     */
    _h(a: number, b: WorksheetTableColumn): void;
    /**
     * @hidden
     */
    _i(a: number): void;
    /**
     * Gets the number of [[WorksheetTableColumn]] instances in the collection.
     * The number of columns in the collection.
     */
    readonly count: number;
    /**
     * Gets the [[WorksheetTableColumn]] at the specified index.
     * @param index The 0-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of columns in the collection.
     * @return The WorksheetTableColumn at the specified index.
     */
    item(index: number): WorksheetTableColumn;
    /**
     * Gets the [[WorksheetTableColumn]] with the specified name or null if it doesn't exist.
     * <p class="body">
     * Column names are compared case-insensitively.
     * </p>
     * @param name The name of the column to get.
     * @return The WorksheetTableColumn with the specified name or null a column with the specified name doesn't exist.
     * @see [[WorksheetTableColumn.name]]
     */
    item(name: string): WorksheetTableColumn;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableColumn;
}
/**
 * Class which controls the way unfrozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[FrozenPaneSettings]]
 */
export declare class UnfrozenPaneSettings extends PaneSettingsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _w;
    private _af;
    private _aj;
    private _z;
    private _ac;
    private _am;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    protected get__i(): boolean;
    /**
     * @hidden
     */
    readonly _i: boolean;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the unfrozen pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the first visible column in the left pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the left pane(s) of the worksheet and is used regardless of whether or not the
     * worksheet is split vertically.
     * </p>
     * The zero-based index of the first visible column in the left pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the first visible column in the left pane(s) of the worksheet.
    * <p class="body">
    * This affects the scroll position for the left pane(s) of the worksheet and is used regardless of whether or not the
    * worksheet is split vertically.
    * </p>
    * The zero-based index of the first visible column in the left pane(s).
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
    * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    firstColumnInLeftPane: number;
    /**
     * Gets or sets the first visible row in the top pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the top pane(s) of the worksheet and is used regardless of whether or not
     * the worksheet is split horizontally.
     * </p>
     * The zero-based index of the first visible row in the top pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    /**
    * Gets or sets the first visible row in the top pane(s) of the worksheet.
    * <p class="body">
    * This affects the scroll position for the top pane(s) of the worksheet and is used regardless of whether or not
    * the worksheet is split horizontally.
    * </p>
    * The zero-based index of the first visible row in the top pane(s).
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
    * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
    * [[Workbook.currentFormat]]).
    */
    firstRowInTopPane: number;
    /**
     * Gets or sets the width of the left pane in twips (1/20th of a point).
     * <p class="body">
     * If this value is zero, the left pane occupies the entire visible area of the worksheet.
     * Otherwise, the left pane occupies the specified width and the right pane occupies
     * the remaining area of the worksheet.
     * </p>
     * The width of the left pane, or zero if there is no horizontal pane split.
     * @throws [[ArgumentOutOfRangeException]] Thrown when the width specified is outside the valid width range (0 to 65535).
     */
    /**
    * Gets or sets the width of the left pane in twips (1/20th of a point).
    * <p class="body">
    * If this value is zero, the left pane occupies the entire visible area of the worksheet.
    * Otherwise, the left pane occupies the specified width and the right pane occupies
    * the remaining area of the worksheet.
    * </p>
    * The width of the left pane, or zero if there is no horizontal pane split.
    * @throws [[ArgumentOutOfRangeException]] Thrown when the width specified is outside the valid width range (0 to 65535).
    */
    leftPaneWidth: number;
    /**
     * Gets or sets the height of the top pane in twips (1/20th of a point).
     * <p class="body">
     * If this value is zero, the top pane occupies the entire visible area of the worksheet.
     * Otherwise, the top pane occupies the specified height and the bottom pane occupies
     * the remaining area of the worksheet.
     * </p>
     * The height of the top pane, or zero if there is no vertical pane split.
     * @throws [[ArgumentOutOfRangeException]] Thrown when the height specified is outside the valid height range (0 to 65535).
     */
    /**
    * Gets or sets the height of the top pane in twips (1/20th of a point).
    * <p class="body">
    * If this value is zero, the top pane occupies the entire visible area of the worksheet.
    * Otherwise, the top pane occupies the specified height and the bottom pane occupies
    * the remaining area of the worksheet.
    * </p>
    * The height of the top pane, or zero if there is no vertical pane split.
    * @throws [[ArgumentOutOfRangeException]] Thrown when the height specified is outside the valid height range (0 to 65535).
    */
    topPaneHeight: number;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    _j(): boolean;
    /**
     * @hidden
     */
    _ao(a: number, b: number): void;
}
/**
 * @hidden
 */
export declare class UnicodeStrings extends Base {
    static $t: Type;
    static a: string;
}
/**
 * Abstract base class for all shapes that can display text.
 * <p class="body">
 * Primitive shapes, such as polygons, and cell comments can display regular text or text with mixed formatting and are derived from this class.
 * </p>
 * @see [[WorksheetCellComment]]
 * @see [[UnknownShape]]
 */
export declare abstract class WorksheetShapeWithText extends WorksheetShape implements IFormattedTextOwner, IWorkbookFontDefaultsResolver {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d3: number;
    /**
     * @hidden
     */
    static readonly _d4: number;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    static readonly _eb: number;
    /**
     * @hidden
     */
    static readonly _d8: number;
    /**
     * @hidden
     */
    private static readonly _dv;
    private _d1;
    private _d5;
    private _d9;
    private _dy;
    private _ec;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    onFormattingChanged(sender: FormattedText): void;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedText): void;
    /**
     * @hidden
     */
    resolveDefaults(font: WorkbookFontData): void;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _ee(): void;
    /**
     * @hidden
     */
    private static _dx;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * @hidden
     */
    readonly _d0: boolean;
    /**
     * Gets or sets the formatted text of the shape.
     * The formatted text of the shape.
     */
    /**
    * Gets or sets the formatted text of the shape.
    * The formatted text of the shape.
    */
    text: FormattedText;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _d6: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ed: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ea: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _d2: number;
}
/**
 * @hidden
 */
export interface IWorksheetImage {
    image: ExcelImage;
    preferredFormat: ImageFormat;
}
/**
 * @hidden
 */
export declare let IWorksheetImage_$type: Type;
/**
 * Represents an unsupported shape which has been loaded from a workbook file.
 * <p class="body">
 * This class is used for round-tripping purposes, so unsupported shapes which have been
 * loaded can be saved back out with the workbook.  The class allows the unsupported shapes
 * to be identified in shape collections so they can be removed. This shape will become
 * obsolete in future versions when all shape types are supported.
 * </p>
 */
export declare class UnknownShape extends WorksheetShapeWithText implements IWorksheetImage {
    static $t: Type;
    private _el;
    private _em;
    private _eo;
    private _eh;
    private _ej;
    private _ei;
    constructor(a: number, b: ShapeType, c: number);
    constructor(a: number);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    image: ExcelImage;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    preferredFormat: ImageFormat;
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * Throws an exception because all data in an unknown shape is unknown, and clearing that data would leave
     * no data with the shape.
     * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
     */
    clearUnknownData(): void;
    /**
     * @hidden
     */
    _cr(): void;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _eq(a: Nullable$1<ShapeType>, b: ST_ShapeType): void;
    /**
     * @hidden
     */
    _ef: RoundTripControlData;
    /**
     * @hidden
     */
    _en: any;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ek: boolean;
    /**
     * @hidden
     */
    _eg: ILegacyShapeData;
    /**
     * @hidden
     */
    readonly _ep: number;
}
/**
 * @hidden
 */
export interface ILegacyShapeData {
    fmlaMacro: Formula;
}
/**
 * @hidden
 */
export declare let ILegacyShapeData_$type: Type;
/**
 * @hidden
 */
export declare class ColorsInternal extends Base {
    static $t: Type;
    static readonly a: Color;
    static readonly b: Color;
    static readonly d: Color;
    static readonly c: Color;
    static readonly e: Color;
}
/**
 * @hidden
 */
export declare class SystemColorsInternal extends Base {
    static $t: Type;
    private static a;
    private static readonly b;
    private static ad;
    private static ae;
    static c(a: Color): boolean;
    static readonly d: Color;
    static readonly e: Color;
    static readonly f: Color;
    static readonly g: Color;
    static readonly h: Color;
    static readonly i: Color;
    static readonly j: Color;
    static readonly k: Color;
    static readonly r: Color;
    static readonly s: Color;
    static readonly l: Color;
    static readonly m: Color;
    static readonly n: Color;
    static readonly o: Color;
    static readonly p: Color;
    static readonly q: Color;
    static readonly v: Color;
    static readonly w: Color;
    static readonly z: Color;
    static readonly aa: Color;
    static readonly x: Color;
    static readonly y: Color;
    static readonly t: Color;
    static readonly u: Color;
    static readonly ab: Color;
    static readonly ac: Color;
    static readonly af: Color;
    static readonly ag: Color;
    static readonly ah: Color;
    static readonly ai: Color;
    static readonly aj: Color;
    static readonly ak: Color;
    static readonly al: Color;
    static readonly am: Color;
    static readonly an: Color;
    static readonly ao: Color;
    static readonly ap: Color;
    static readonly aq: Color;
    static readonly ar: Color;
    static readonly as: Color;
    static readonly at: Color;
    static readonly au: Color;
    static readonly av: Color;
    static readonly aw: Color;
    static readonly ax: Color;
    static readonly ay: Color;
    static readonly az: Color;
    static readonly a0: Color;
    static readonly a3: Color;
    static readonly a4: Color;
    static readonly a1: Color;
    static readonly a2: Color;
    static readonly a5: Color;
    static readonly a6: Color;
    static readonly a7: Color;
    static readonly a8: Color;
    static readonly a9: Color;
    static readonly ba: Color;
    static readonly bb: Color;
    static readonly bc: Color;
    static readonly bd: Color;
    static readonly be: Color;
    static readonly bf: Color;
    static readonly bg: Color;
}
/**
 * @hidden
 */
export declare class SystemColorsInternal_ColorResolver extends Base {
    static $t: Type;
    private a;
    c(a: any): void;
    readonly b: Color[];
}
/**
 * @hidden
 */
export declare class UtilitiesInt32Comparer extends Comparer$1<number> {
    static $t: Type;
    static readonly _c: UtilitiesInt32Comparer;
    constructor();
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class ActiveCellChangedInfo extends Base {
    static $t: Type;
    private readonly a;
    constructor(a: Workbook);
    e(): void;
    b: Worksheet;
    d: number;
    c: number;
}
/**
 * @hidden
 */
export declare class ChartDeserializationCache extends Base {
    static $t: Type;
    constructor();
    a: Dictionary$2<string, any>;
    b: Dictionary$2<string, any>;
    d: any;
    c: Dictionary$2<string, any>;
}
/**
 * Represents the color palette used when the saved file is opened in Microsoft Excel 2003 and earlier versions.
 * @see [[Workbook.palette]]
 */
export declare class WorkbookColorPalette extends Base implements ICollection$1<Color> {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _g: number;
    /**
     * @hidden
     */
    static readonly _n: number;
    /**
     * @hidden
     */
    static readonly _u: number;
    /**
     * @hidden
     */
    static readonly _v: number;
    /**
     * @hidden
     */
    static readonly _y: number;
    /**
     * @hidden
     */
    static readonly _w: number;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    static readonly _h: number;
    /**
     * @hidden
     */
    static readonly _k: number;
    /**
     * @hidden
     */
    static readonly _j: number;
    /**
     * @hidden
     */
    static readonly _i: number;
    /**
     * @hidden
     */
    static readonly _p: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    static readonly _q: number;
    /**
     * @hidden
     */
    static readonly _r: number;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static _b;
    private _d;
    private _a;
    private readonly _c;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: string | Color): void;
    /**
     * @hidden
     */
    _add$i(a: Color): void;
    /**
     * @hidden
     */
    clear(): void;
    /**
     * @hidden
     */
    copyTo(array: Color[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: string | Color): boolean;
    /**
     * @hidden
     */
    _remove$i(a: Color): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Color>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<Color>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the specified color is in the color palette.
     * @param color The color to find in the palette.
     * @return Determines whether an equivalent color is in the palette.
     */
    contains(color: string | Color): boolean;
    /**
     * @hidden
     */
    _contains$i(a: Color): boolean;
    /**
     * Gets the index of the closest color in the color palette, which will be seen when the file is opened in Microsoft Excel 2003
     * and older versions.
     * @param color The color to match in the palette.
     * @return A 0-based index into the collection of the closest color available in the palette.
     */
    getIndexOfNearestColor(color: string | Color): number;
    /**
     * @hidden
     */
    _getIndexOfNearestColor$i(a: Color): number;
    /**
     * Resets the palette back to the default colors for Microsoft Excel.
     * @see [[isCustom]]
     */
    reset(): void;
    /**
     * @hidden
     */
    _l(a: WorkbookColorInfo, b: ColorableItem): number;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    _ae(a: number): Color;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    static _e(a: Color, b: Color): boolean;
    /**
     * @hidden
     */
    private static _ag;
    /**
     * @hidden
     */
    private _aa;
    /**
     * Gets the number of colors in the palette, which is always 56.
     */
    readonly count: number;
    /**
     * Gets or sets a color in the palette.
     * <p class="body">
     * When a color is set in the palette, [[isCustom]] will return True. The palette can than be reset with the
     * [[reset]] method.
     * </p>
     * <p class="body">
     * Colors added to the palette must be opaque.
     * </p>
     * @param index The index of the color to get or set in the palette.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than 55.
     * @throws [[ArgumentException]] The value assigned is an empty color, a system color, or is not opaque.
     * @see [[isCustom]]
     * @see [[reset]]
     */
    item(index: number, value?: string | Color): string;
    /**
     * @hidden
     */
    _item$i(a: number, b?: Color): Color;
    /**
     * Gets the value which indicates whether the palette has been cusotmized.
     * @see [[reset]]
     */
    readonly isCustom: boolean;
}
/**
 * @hidden
 */
export declare class UltimateFontDefaultsResolver extends Base implements IWorkbookFontDefaultsResolver {
    static $t: Type;
    static readonly a: UltimateFontDefaultsResolver;
    constructor();
    resolveDefaults(a: WorkbookFontData): void;
}
/**
 * @hidden
 */
export declare class WorkbookFontDataResolved extends Base implements IWorkbookFont {
    static $t: Type;
    private _a;
    constructor(a: WorksheetCellFormatProxy);
    equals(a: any): boolean;
    getHashCode(): number;
    setFontFormatting(a: IWorkbookFont): void;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    colorInfo: WorkbookColorInfo;
    height: number;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    name: string;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    underlineStyle: FontUnderlineStyle;
    _d(a: WorksheetCellFormatProxy): void;
    private _e;
}
/**
 * @hidden
 */
export declare class WorkbookFontOwnerAccessor extends Base implements IWorkbookFont {
    static $t: Type;
    private _a;
    constructor(a: WorksheetCellFormatProxy);
    setFontFormatting(a: IWorkbookFont): void;
    _setFontFormatting1(a: IWorkbookFont, b: boolean, c: CellFormatValueChangedOptions): void;
    private _e;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    _b(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    colorInfo: WorkbookColorInfo;
    _c(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    height: number;
    _f(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    _g(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    name: string;
    _h(a: string, b: boolean, c: CellFormatValueChangedOptions): void;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    _i(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    _j(a: FontSuperscriptSubscriptStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    underlineStyle: FontUnderlineStyle;
    _k(a: FontUnderlineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
}
/**
 * @hidden
 */
export declare class WorkbookFontProxy extends GenericCacheElementProxy$1<WorkbookFontData> implements IWorkbookFont {
    static $t: Type;
    private _m;
    private _q;
    private _n;
    constructor(a: number, b: WorkbookFontData, c: Workbook, d: WorksheetCellFormatData);
    constructor(a: number, b: WorkbookFontData, c: GenericCachedCollectionEx$1<WorkbookFontData>);
    constructor(a: number, ..._rest: any[]);
    g(a: GenericCachedCollection$1<WorkbookFontData>): void;
    static _l(a: IWorkbookFont, b: IWorkbookFont): CellFormatValue;
    _s(a: (arg1: WorkbookFontProxy_PropertyIds) => void): void;
    setFontFormatting(a: IWorkbookFont): void;
    _t(a: IWorkbookFont, b: boolean): void;
    static _o(a: IWorkbookFont, b: IWorkbookFont, c: CellFormatValue): boolean;
    private _u;
    _p(): boolean;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    colorInfo: WorkbookColorInfo;
    height: number;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    name: string;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    underlineStyle: FontUnderlineStyle;
    _r: Nullable$1<number>;
}
/**
 * @hidden
 */
export declare class WorkbookFormatCollection extends Base {
    static $t: Type;
    private static h;
    private static k;
    private i;
    private j;
    private s;
    private o;
    private p;
    private l;
    private b;
    private aa;
    private ab;
    private ag;
    private f;
    private n;
    private readonly g;
    private v;
    private y;
    constructor(a: Workbook);
    q(a: string): number;
    am(a: number, b: string): void;
    an(a: number, b: string, c: boolean): void;
    private ao;
    ap(a: number, b: string): void;
    private aq;
    private z;
    private static d;
    static aj(a: number): number;
    private _m;
    m(): IEnumerable$1<number>;
    ad(a: number): string;
    static af(a: CultureInfo): string;
    static ae(a: CultureInfo): string;
    a(a: number): ValueFormatter;
    c(a: number): boolean;
    private static ar;
    private static as;
    e(a: number): boolean;
    static ak(a: number): number;
    private at;
    private au;
    readonly r: number;
    item(a: number): string;
    private al;
}
/**
 * #elif WINRT#elif TINYCLR
 * Contains the options related to saving a workbook to a file or stream.
 * @see [[Workbook.save]]
 */
export declare class WorkbookSaveOptions extends WorkbookOptionsBase {
    static $t: Type;
    private _f;
    constructor();
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _g: WorkbookSaveFilter;
    private _type;
    /**
     * Gets or sets the format in which to save the workbook: "base64", "string", "uint8array", "arraybuffer", "blob"
     */
    /**
    * Gets or sets the format in which to save the workbook: "base64", "string", "uint8array", "arraybuffer", "blob"
    */
    type: string;
    /**
     * @hidden
     */
    static _h(a: WorkbookSaveOptions): WorkbookSaveFilter;
}
/**
 * @hidden
 */
export declare abstract class WorkbookSaveFilter extends Base {
    static $t: Type;
    abstract d(a: Worksheet): number;
    abstract e(a: Worksheet): number;
    a(a: Worksheet): IEnumerable$1<WorksheetMergedCellsRegion>;
    abstract b(a: Worksheet, b: boolean): IEnumerable$1<WorksheetRow>;
    abstract c(a: Workbook): IList$1<Sheet>;
}
/**
 * @hidden
 */
export declare class DefaultWorkbookSaveFilter extends WorkbookSaveFilter {
    static $t: Type;
    static readonly f: WorkbookSaveFilter;
    constructor();
    d(a: Worksheet): number;
    e(a: Worksheet): number;
    b(a: Worksheet, b: boolean): IEnumerable$1<WorksheetRow>;
    c(a: Workbook): IList$1<Sheet>;
}
/**
 * @hidden
 */
export declare class WorkbookStyle_StyleChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorkbookStyle);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a complex format which can be applied to a cell's format.
 * <p class="body">
 * When a style is applied to a cell by setting its CellFormat.Style property, the cell's format will pick up subsequent
 * changes to the format properties set by the style when it was applied. This will continue to happen until those format
 * properties are set to other values on the cell format.
 * </p>
 * @see [[IWorksheetCellFormat.style]]
 * @see [[Workbook.styles]]
 */
export declare abstract class WorkbookStyle extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static _a;
    private _j;
    private _q;
    private _h;
    private _f;
    static staticInit(): void;
    constructor(a: Workbook, b: IWorksheetCellFormat);
    /**
     * Resets the style to its original state.
     * <p class="body">
     * If this is a user defined style, the format of the style will be reset so that it provides no formatting properties.
     * If this is a built in style, this format will revert back to its preset state if it has previously been changed.
     * </p>
     */
    abstract reset(): void;
    /**
     * @hidden
     */
    _v(): void;
    /**
     * @hidden
     */
    _w(a: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the value indicating whether the style is a built in style in Microsoft Excel.
     */
    abstract readonly isBuiltIn: boolean;
    /**
     * Gets or sets the name of the workbook style.
     * <p class="body">
     * The style names must be case-insensitively unique and the names for built in styles cannot be changed.
     * </p>
     * The name of the workbook style.
     * @throws [[InvalidOperationException]] The value is assigned and the style is a built.
     * @throws [[ArgumentException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
     * @throws [[ArgumentException]] The value assigned matches the name of another style in the collection.
     * @see [[isBuiltIn]]
     */
    /**
    * Gets or sets the name of the workbook style.
    * <p class="body">
    * The style names must be case-insensitively unique and the names for built in styles cannot be changed.
    * </p>
    * The name of the workbook style.
    * @throws [[InvalidOperationException]] The value is assigned and the style is a built.
    * @throws [[ArgumentException]] The value assigned is null or empty.
    * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
    * @throws [[ArgumentException]] The value assigned matches the name of another style in the collection.
    * @see [[isBuiltIn]]
    */
    abstract name: string;
    /**
     * Gets the cell format which applies to the workbook style.
     * The cell format which applies to the workbook style.
     */
    readonly styleFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    abstract readonly _e: StyleCategory;
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    readonly _k: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _m: boolean;
    /**
     * @hidden
     */
    abstract readonly _n: boolean;
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    readonly _o: boolean;
    /**
     * @hidden
     */
    protected get__p(): boolean;
    /**
     * @hidden
     */
    readonly _p: boolean;
    /**
     * @hidden
     */
    readonly _i: WorksheetCellFormatData;
    /**
     * @hidden
     */
    readonly _g: Workbook;
}
/**
 * @hidden
 */
export declare class WorkbookBuiltInStyle extends WorkbookStyle implements IComparable$1<WorkbookBuiltInStyle> {
    static $t: Type;
    private _af;
    private _ae;
    private readonly _aj;
    private readonly _ab;
    constructor(a: Workbook, b: IWorksheetCellFormat, c: BuiltInStyleType, d: number);
    compareTo(a: WorkbookBuiltInStyle): number;
    protected get__e(): StyleCategory;
    readonly _e: StyleCategory;
    protected get__k(): boolean;
    protected get_isBuiltIn(): boolean;
    readonly isBuiltIn: boolean;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get_name(): string;
    protected set_name(a: string): void;
    name: string;
    _w(a: WorksheetCellFormatOptions): void;
    reset(): void;
    protected get__o(): boolean;
    protected get__p(): boolean;
    _ad(a: Workbook): WorkbookBuiltInStyle;
    readonly _ag: boolean;
    _ah: boolean;
    readonly _ak: number;
    readonly _ac: BuiltInStyleType;
    readonly _ai: boolean;
}
/**
 * @hidden
 */
export declare class WorkbookUserDefinedStyle extends WorkbookStyle {
    static $t: Type;
    private _ab;
    constructor(a: Workbook, b: IWorksheetCellFormat, c: string);
    protected get__e(): StyleCategory;
    readonly _e: StyleCategory;
    protected get_isBuiltIn(): boolean;
    readonly isBuiltIn: boolean;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get_name(): string;
    protected set_name(a: string): void;
    name: string;
    reset(): void;
    protected get__o(): boolean;
    protected get__p(): boolean;
}
/**
 * @hidden
 */
export declare class BuiltInStyleInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: BuiltInStyleType, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: BuiltInStyleType;
    readonly b: number;
}
/**
 * Introduce InvalidEnumArgumentException class to Silverlight
 */
export declare class InvalidEnumArgumentException extends ArgumentException {
    static $t: Type;
    constructor(message?: string, innerException?: BaseError);
    constructor(message: string, paramName: string);
    constructor(argumentName: string, invalidValue: number, enumClass: Type);
    constructor(..._rest: any[]);
}
/**
 * @hidden
 */
export declare class ExcelCalcEngine extends Base {
    static $t: Type;
    private readonly p;
    private readonly t;
    private e;
    private f;
    private readonly a;
    private r;
    private readonly s;
    private c;
    private j;
    private k;
    private readonly q;
    private g;
    private h;
    private readonly i;
    constructor(a: Workbook);
    v(a: IExcelCalcReference, b: RefBase): void;
    w(a: SingleTargetFormula): void;
    z(): void;
    aa(a?: boolean): void;
    ab(a: RefBase, b: boolean): void;
    ac(): void;
    static b(a: IExcelCalcReference): IExcelCalcReference;
    n(a: RefBase): boolean;
    ak(a: WorksheetDataTable): void;
    al(a: WorksheetDataTable): void;
    am(a: NamedCalcReferenceBase, b: ReferenceActionCode): void;
    an(a: WorksheetTable): void;
    ao(a: WorksheetTable): void;
    ap(a: CellCalcReference): void;
    aq(a: CellCalcReference, b: boolean): void;
    as(a: boolean): void;
    at(a: IExcelCalcReference, b: RefBase): void;
    au(a: SingleTargetFormula): void;
    ax(): void;
    private x;
    private y;
    private ad;
    private ae;
    private af;
    private ag;
    private ah;
    private ai;
    private u;
    private aj;
    private ar;
    private o;
    av(a: RefBase): {
        p0?: RefBase;
    };
    private aw;
    readonly d: UltraCalcFunctionFactory;
    readonly l: boolean;
    readonly m: boolean;
}
/**
 * @hidden
 */
export declare abstract class RefBase extends Base implements IExcelCalcReference {
    static $t: Type;
    static readonly _a: RefBase[];
    private _ap;
    private _p;
    private _h;
    private _i;
    private _an;
    _e: CalculationContext;
    constructor();
    readonly formula: IExcelCalcFormula;
    readonly references: IExcelCalcReferenceCollection;
    equals(a: any): boolean;
    abstract _z(a: IExcelCalcReference): boolean;
    abstract getHashCode(): number;
    toString(): string;
    _au(a: RefBase): void;
    abstract containsReference(a: IExcelCalcReference): boolean;
    createReference(a: string): IExcelCalcReference;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    _al(): IEnumerable$1<RefBase>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    abstract isSubsetReference(a: IExcelCalcReference): boolean;
    _aw(a: RefBase): void;
    _ax(): void;
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    _a0(a: SingleTargetFormula, b: boolean, c?: boolean, d?: boolean): void;
    _o(): RefBase;
    _b(a: boolean): ExcelCalcValue;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    _az(a: SingleTargetFormula): void;
    protected _a1(a: ExcelCalcValue): void;
    private _aa;
    private _av;
    private _ay;
    readonly absoluteName: string;
    protected get__formula(): SingleTargetFormula;
    readonly _formula: SingleTargetFormula;
    _aq: number;
    _d: NodeState;
    protected get__x(): boolean;
    readonly _x: boolean;
    abstract readonly _ao: number;
    protected get_context(): any;
    readonly context: any;
    abstract readonly elementName: string;
    _ab: boolean;
    readonly _ac: boolean;
    _ad: boolean;
    _af: boolean;
    protected get_isEnumerable(): boolean;
    readonly isEnumerable: boolean;
    _ag: boolean;
    _ah: boolean;
    protected get__aj(): boolean;
    readonly _aj: boolean;
    _ai: boolean;
    _j: RefBase;
    readonly normalizedAbsoluteName: string;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    readonly _f: IExcelCalcReferenceCollectionEx;
    _k: RefBase;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    readonly _references: IExcelCalcReferenceCollectionEx;
    protected get__l(): RefBase;
    readonly _l: RefBase;
    abstract readonly _w: WorksheetRow;
    protected get__as(): number;
    readonly _as: number;
    protected get__r(): Sheet;
    readonly _r: Sheet;
    protected get__ak(): boolean;
    protected readonly _ak: boolean;
    protected get_value(): ExcelCalcValue;
    protected set_value(a: ExcelCalcValue): void;
    value: ExcelCalcValue;
    abstract readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    readonly _t: Workbook;
    protected get__u(): Worksheet;
    readonly _u: Worksheet;
    protected get__q(): WorksheetReference;
    readonly _q: WorksheetReference;
}
/**
 * @hidden
 */
export declare abstract class RegionCalcReferenceBase extends RefBase implements IRegionAddress {
    static $t: Type;
    static readonly _a6: List$1<RegionCalcReferenceBase>;
    private _a2;
    constructor();
    protected get__x(): boolean;
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    abstract readonly _a3: WorksheetRegion;
    abstract _a4(a: number, b: number): boolean;
    abstract _a5(a: number, b: number): boolean;
    containsColumns(a: number, b: number): boolean;
    intersectsWithColumns(a: number, b: number): boolean;
}
/**
 * @hidden
 */
export declare abstract class CellCalcReferenceBase extends RefBase {
    static $t: Type;
    private _a9;
    protected _a8: number;
    private _a2;
    protected _a3: WorksheetRow;
    constructor(a: WorksheetRow, b: number);
    protected get__x(): boolean;
    protected get__ao(): number;
    readonly _ao: number;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    protected get__formula(): SingleTargetFormula;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    _az(a: SingleTargetFormula): void;
    protected _a1(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    _ba(a: number, b: number): {
        p0: number;
        p1: number;
    };
    protected _bb(a: WorksheetRow, b: number): void;
    readonly _a4: boolean;
    readonly _a5: boolean;
    readonly _a6: boolean;
    readonly _a7: boolean;
}
/**
 * @hidden
 */
export declare class CellCalcReference extends CellCalcReferenceBase {
    static $t: Type;
    private static _bc;
    constructor(a: WorksheetRow, b: number);
    containsReference(a: IExcelCalcReference): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    _bf(): void;
    _bg(): void;
    static _bd(a: WorksheetRow, b: number): CellCalcReference;
    _be(): boolean;
}
/**
 * @hidden
 */
export declare class DependencyGraph extends Base {
    static $t: Type;
    readonly b: CalculationNetworkLinkedList;
    private readonly e;
    c: DependencyGraph_EvaluationEnumerator;
    private j;
    private readonly s;
    private readonly r;
    private k;
    private readonly z;
    private readonly t;
    private static readonly f;
    private i;
    constructor(a: ExcelCalcEngine);
    ad(a: RefBase, b: RefBase): void;
    ae(a: SingleTargetFormula): void;
    af(a: RefBase): void;
    am(): void;
    ao(a: RefBase): void;
    aq(): void;
    n(a: boolean): boolean;
    y(): IEnumerator$1<RefBase>;
    q(a: RefBase): boolean;
    at(a: CellCalcReference): void;
    av(a: RefBase, b: RefBase): void;
    aw(a: SingleTargetFormula): void;
    a2(): void;
    private a3;
    ag(a: IEnumerable$1<RefBase>, b: RefBase, c: boolean, d: number): void;
    private static ah;
    private l;
    private m;
    private ai;
    private aj;
    private static readonly h;
    private static readonly aa;
    private ak;
    private readonly ab;
    private al;
    private an;
    private ap;
    private static ar;
    private static as;
    private u;
    private v;
    private w;
    private g;
    private d;
    private x;
    private o;
    private au;
    private ax;
    private static readonly a;
    private ay;
    private az;
    private static a0;
    private a1;
    readonly p: boolean;
}
/**
 * @hidden
 */
export declare class CalculationNetworkLinkedList extends Base implements IEnumerable$1<RefBase> {
    static $t: Type;
    private _a;
    private _b;
    constructor();
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<RefBase>;
    getEnumeratorObject(): IEnumerator;
    _e(a: RefBase, b: RefBase): void;
    _f(a: RefBase, b: RefBase): void;
    _g(a: RefBase): void;
    _h(a: RefBase): void;
    _i(a: RefBase): void;
    _j(): void;
    readonly _c: RefBase;
    readonly _d: RefBase;
}
/**
 * @hidden
 */
export declare class DependencyGraph_StronglyConnectedComponent extends Base {
    static $t: Type;
    private readonly e;
    constructor(a: IEnumerable$1<RefBase>);
    c(a: RefBase): boolean;
    f(a: DependencyGraph): void;
    b(a: RefBase): RefBase;
    a(a: RefBase): RefBase;
    d(): boolean;
}
/**
 * @hidden
 */
export declare class ObjectPool$1<T> extends Base {
    static $t: Type;
    protected $t: Type;
    private a;
    private c;
    private d;
    constructor($t: Type, a: () => T);
    b(): T;
    f(a: T): void;
}
/**
 * @hidden
 */
export declare class DependencyGraph_SuccessorsResolvedEnumerable extends Base implements IEnumerable$1<RefBase>, IEnumerator$1<RefBase> {
    static $t: Type;
    private _b;
    private readonly _c;
    private _e;
    private readonly _a;
    private _d;
    constructor(a: IEnumerable$1<RefBase>, b: RegionLookupTable_Result$1<RegionCalcReferenceBase>);
    getEnumerator(): IEnumerator$1<RefBase>;
    getEnumeratorObject(): IEnumerator;
    readonly current: RefBase;
    dispose(): void;
    readonly currentObject: any;
    moveNext(): boolean;
    reset(): void;
}
/**
 * Represents a data table for a range of cells.
 * <p class="body">
 * Data tables are a way to show the results of one or more formulas by trying many different values in the variables
 * of the formulas at the same time, and showing the different results in a table.  An excellent example of a data table
 * application would be for a multiplication table.  A multiplication table shows results for the formula =X*Y.  However,
 * it shows many different results for the formula, where each result is determined by using different values for X and Y.
 * These results are displayed in a table, where each cell in the table shows the formula's result for specific values of
 * X and Y, which are labeled in the row and column headers, respectively.  Therefore, each cell in a row will use the
 * same X value, and each cell in a column will use the same Y value.
 * </p>
 * <p class="body">
 * The multiplication table is known as a two-variable data table. Two-variable data tables are characterized by having a
 * single formula and values in the row and column headers of the table.  The formula is entered into the top-left cell of
 * the data table and usually references at least two cells outside the data table, known as the column-input and row-input
 * cells.  When the formula is evaluated for a specific cell in the data table, the reference to the column-input cell in the
 * formula is replaced with the value in the cell's row header (this may seem backwards, but the values in the row headers
 * run down the left column of the data table, which is why they are used for the column-input cell), and the reference to
 * the row-input cell is replaced with the value in the cell's column header.
 * </p>
 * <p class="body">
 * Another type of data table is the one-variable data table.  A one-variable data table can be a column-oriented or
 * a row-oriented data table.  A column-oriented data table has data in the cells of the left column and formulas in the
 * cells of the top row (anything in the top-left cell of the data table is ignored in this type of data table).  Usually,
 * the formulas in the top row all reference the same cell outside the data table, known as the column-input cell.  When a
 * cell in the table is evaluated, the formula in its column header is used, with the reference to the column-input cell
 * replaced by the value in cell's row header.
 * </p>
 * <p class="body">
 * A row-oriented one-variable data table is formed like a column-oriented data table, except the values run along the top
 * row, the formulas run down the left column, and the cell referenced by all formulas is known as the row-input cell.
 * </p>
 */
export declare class WorksheetDataTable extends Base implements IRegionBlockingValue {
    static $t: Type;
    private _c;
    private _i;
    private _k;
    private _t;
    private _r;
    private _q;
    private _u;
    private _s;
    constructor(a: Worksheet, b: WorksheetRegion, c: WorksheetCell, d: WorksheetCell);
    /**
     * @hidden
     */
    removeFromRegion(): void;
    /**
     * @hidden
     */
    throwBlockingException(): void;
    /**
     * @hidden
     */
    throwExceptionWhenMergedCellsInRegion(): void;
    /**
     * @hidden
     */
    throwExceptionWhenTableInRegion(): void;
    /**
     * @hidden
     */
    readonly blockedRegion: WorksheetRegion;
    /**
     * @hidden
     */
    _a(): RefBase;
    /**
     * @hidden
     */
    _v(): string;
    /**
     * @hidden
     */
    _b(): RefBase;
    /**
     * @hidden
     */
    _n(a: WorksheetRow, b: number, c: boolean): {
        ret: boolean;
        p2: boolean;
    };
    /**
     * @hidden
     */
    _o(a: CellShiftOperation): boolean;
    /**
     * @hidden
     */
    _p(a: CellShiftOperation, b: Nullable$1<WorksheetRegionAddress>): boolean;
    /**
     * @hidden
     */
    _y(a: Worksheet, b: WorksheetRegionAddress, c: Nullable$1<WorksheetCellAddress>, d: Nullable$1<WorksheetCellAddress>): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    static _ae(a: Worksheet, b: WorksheetRegion, c: string, d: WorksheetCell, e: string, f: WorksheetCell, g: string): void;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _x;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * Gets or sets the region of cells in the data table.
     * <p class="body">
     * Any interior cells (cells not in the left-most column or top row) in this region will have their values removed
     * when this is set. If any interior cells have array formulas with a region that crosses outside the data
     * table, an error will occur. However, if the array formula's region is confined to cells in the
     * interior of the data table, the array formula will have [[ArrayFormula.clearCellRange]]
     * called on it, which will remove it from all its cells. Similarly, if an existing data table's interior cells
     * contain some of the interior cells in this region as well as some external cells, an error will occur.
     * However, if all interior cells of the existing data table are contained in the interior cells of the new
     * region specified here, the existing data table will be removed from the worksheet.
     * </p>
     * <p class="body">
     * After the cells in the table have been specified, the interior cells' values cannot be modified.
     * </p>
     * <p class="note">
     * <B>Note:</B> The [[rowInputCell]] and [[columnInputCell]] cannot be with the region.
     * </p>
     * The region of cells in the data table.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[ArgumentException]] The value assigned is a region from a worksheet other than the data table's worksheet.
     * @throws [[InvalidOperationException]] The region specified contains the RowInputCell or the ColumnInputCell.
     * @throws [[InvalidOperationException]] One or more of the interior cells of the value assigned (all cells except the left-most column and top row) is an
     * interior cell of another data table or is a cell in an array formula, and the entire range of that other
     * entity extends outside the interior cells of the value assigned.
     * @throws [[ArgumentException]] The assigned value is only one row tall or one column wide. The cells in the table must be at least two rows by two columns.
     * @throws [[InvalidOperationException]] The assigned value contains merged regions which are not confined to the left-most column or top row. No merged regions
     * can exist in the interior cells of the data table and no merged regions can exist in the left-most column or top row
     * and extend outside the data table region.
     * @see [[ArrayFormula]]
     * @see [[columnInputCell]]
     * @see [[rowInputCell]]
     */
    /**
    * Gets or sets the region of cells in the data table.
    * <p class="body">
    * Any interior cells (cells not in the left-most column or top row) in this region will have their values removed
    * when this is set. If any interior cells have array formulas with a region that crosses outside the data
    * table, an error will occur. However, if the array formula's region is confined to cells in the
    * interior of the data table, the array formula will have [[ArrayFormula.clearCellRange]]
    * called on it, which will remove it from all its cells. Similarly, if an existing data table's interior cells
    * contain some of the interior cells in this region as well as some external cells, an error will occur.
    * However, if all interior cells of the existing data table are contained in the interior cells of the new
    * region specified here, the existing data table will be removed from the worksheet.
    * </p>
    * <p class="body">
    * After the cells in the table have been specified, the interior cells' values cannot be modified.
    * </p>
    * <p class="note">
    * <B>Note:</B> The [[rowInputCell]] and [[columnInputCell]] cannot be with the region.
    * </p>
    * The region of cells in the data table.
    * @throws [[ArgumentNullException]] The value assigned is null.
    * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
    * @throws [[ArgumentException]] The value assigned is a region from a worksheet other than the data table's worksheet.
    * @throws [[InvalidOperationException]] The region specified contains the RowInputCell or the ColumnInputCell.
    * @throws [[InvalidOperationException]] One or more of the interior cells of the value assigned (all cells except the left-most column and top row) is an
    * interior cell of another data table or is a cell in an array formula, and the entire range of that other
    * entity extends outside the interior cells of the value assigned.
    * @throws [[ArgumentException]] The assigned value is only one row tall or one column wide. The cells in the table must be at least two rows by two columns.
    * @throws [[InvalidOperationException]] The assigned value contains merged regions which are not confined to the left-most column or top row. No merged regions
    * can exist in the interior cells of the data table and no merged regions can exist in the left-most column or top row
    * and extend outside the data table region.
    * @see [[ArrayFormula]]
    * @see [[columnInputCell]]
    * @see [[rowInputCell]]
    */
    cellsInTable: WorksheetRegion;
    /**
     * @hidden
     */
    readonly _j: WorksheetRegionAddress;
    /**
     * Gets or sets the cell used as the column-input cell in the data table.
     * <p class="body">
     * This represents the cell reference in all formulas of the data table to replace with row header values.
     * If this and the [[rowInputCell]] are non-null, the data table is a two-variable data table.
     * Otherwise, if only one is non-null, this is a one-variable data table.
     * </p>
     * <p class="note">
     * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
     * </p>
     * The cell used as the column-input cell in the data table.
     * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
     * @throws [[InvalidOperationException]] The assigned value is null and RowInputCell is null. At least one input cell must be non-null.
     * @throws [[InvalidOperationException]] The assigned value is the same as RowInputCell. The input cells cannot be the same cell.
     * @see [[cellsInTable]]
     * @see [[rowInputCell]]
     */
    /**
    * Gets or sets the cell used as the column-input cell in the data table.
    * <p class="body">
    * This represents the cell reference in all formulas of the data table to replace with row header values.
    * If this and the [[rowInputCell]] are non-null, the data table is a two-variable data table.
    * Otherwise, if only one is non-null, this is a one-variable data table.
    * </p>
    * <p class="note">
    * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
    * </p>
    * The cell used as the column-input cell in the data table.
    * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
    * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
    * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
    * @throws [[InvalidOperationException]] The assigned value is null and RowInputCell is null. At least one input cell must be non-null.
    * @throws [[InvalidOperationException]] The assigned value is the same as RowInputCell. The input cells cannot be the same cell.
    * @see [[cellsInTable]]
    * @see [[rowInputCell]]
    */
    columnInputCell: WorksheetCell;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    readonly _l: boolean;
    /**
     * @hidden
     */
    readonly _m: boolean;
    /**
     * @hidden
     */
    readonly _h: WorksheetRegion;
    /**
     * Gets or sets the cell used as the row-input cell in the data table.
     * <p class="body">
     * This represents the cell reference in all formulas of the data table to replace with column header values.
     * If this and the [[columnInputCell]] are non-null, the data table is a two-variable data table.
     * Otherwise, if only one is non-null, this is a one-variable data table.
     * </p>
     * <p class="note">
     * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
     * </p>
     * The cell used as the row-input cell in the data table.
     * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
     * @throws [[InvalidOperationException]] The assigned value is null and ColumnInputCell is null. At least one input cell must be non-null.
     * @throws [[InvalidOperationException]] The assigned value is the same as ColumnInputCell. The input cells cannot be the same cell.
     * @see [[cellsInTable]]
     * @see [[columnInputCell]]
     */
    /**
    * Gets or sets the cell used as the row-input cell in the data table.
    * <p class="body">
    * This represents the cell reference in all formulas of the data table to replace with column header values.
    * If this and the [[columnInputCell]] are non-null, the data table is a two-variable data table.
    * Otherwise, if only one is non-null, this is a one-variable data table.
    * </p>
    * <p class="note">
    * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
    * </p>
    * The cell used as the row-input cell in the data table.
    * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
    * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
    * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
    * @throws [[InvalidOperationException]] The assigned value is null and ColumnInputCell is null. At least one input cell must be non-null.
    * @throws [[InvalidOperationException]] The assigned value is the same as ColumnInputCell. The input cells cannot be the same cell.
    * @see [[cellsInTable]]
    * @see [[columnInputCell]]
    */
    rowInputCell: WorksheetCell;
    /**
     * @hidden
     */
    private _ac;
    /**
     * Gets the worksheet on which this data table resides.
     */
    readonly worksheet: Worksheet;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionFactory extends Base implements IEnumerable {
    static $t: Type;
    private static _d;
    static readonly _e: UltraCalcFunctionFactory;
    private _h;
    private _a;
    static _f: (arg1: UltraCalcFunctionFactory) => void;
    constructor();
    _item(a: string): ExcelCalcFunction;
    _g(a: ExcelCalcFunction): boolean;
    private _i;
    private _j;
    _b(a: UltraCalcOperatorFunction): ExcelCalcFunction;
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class UltraCalcException extends BaseError {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, b: string, c: BaseError);
    constructor(a: number, ..._rest: any[]);
}
/**
 * @hidden
 */
export declare class UltraCalcErrorException extends UltraCalcException {
    static $t: Type;
    private _c;
    constructor(a: ExcelCalcErrorValue);
    readonly _value: ExcelCalcErrorValue;
    toString(): string;
}
/**
 * Provides methods and properties used to define and manage a calculation error value.
 */
export declare class ExcelCalcErrorValue extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    static readonly _e: ExcelCalcErrorValue;
    /**
     * @hidden
     */
    static readonly _f: ExcelCalcErrorValue;
    /**
     * @hidden
     */
    private _l;
    private _b;
    private _i;
    private _g;
    constructor(code: ExcelCalcErrorCode);
    constructor(code: ExcelCalcErrorCode, message: string);
    constructor(code: ExcelCalcErrorCode, message: string, value: any);
    constructor(..._rest: any[]);
    /**
     * Gets the error code for this class instance
     */
    readonly code: ExcelCalcErrorCode;
    /**
     * Gets error message for this class instance. Note that when setting this property the
     * message is assumed to be localized.
     */
    readonly message: string;
    /**
     * Gets the error object for this class instance
     */
    readonly errorValue: any;
    /**
     * Return a string message that denotes reason for error
     * @return String containing error message
     */
    toString(): string;
    /**
     * @hidden
     */
    _m(): void;
}
/**
 * @hidden
 */
export declare class ExcelCalcValue_ArrayProxyGroup extends Base {
    static $t: Type;
    private readonly a;
    constructor(a: ArrayProxy[]);
    readonly b: ArrayProxy[];
    readonly d: number;
    item(a: number, b?: ArrayProxy): ArrayProxy;
}
/**
 * @hidden
 */
export declare class CalculationContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: ExcelCalcNumberStack, c: TokenClass);
    constructor();
    constructor(a: number, ..._rest: any[]);
    c: TokenClass;
    a: ExcelCalcNumberStack;
    d: boolean;
    static b(a: CalculationContext): {
        ret: IExcelCalcReference;
        p0?: CalculationContext;
    };
}
/**
 * Provides methods that manage a composite data type representing a value.
 * <p class="body">
 * An instance of this class may contain one of several base data types including doubles, singles, integers, booleans, strings, and error values.
 * <p></p>
 * The class implements the IConvertible interface providing methods to perform conversions between the basic data types.
 * <p></p>
 * Additionally the class provides methods to perform basic arithmetic operations and comparisons between [[ExcelCalcValue]] objects.
 * </p>
 */
export declare class ExcelCalcValue extends Base implements IConvertible, IComparable {
    static $t: Type;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    _n: CalculationContext;
    /**
     * @hidden
     */
    private _br;
    /**
     * @hidden
     */
    private _bk;
    /**
     * Returns whether this class instance contains an array value.
     * @return True if this instance class contains an array, else false.
     * @see [[toArrayProxy]]
     */
    readonly isArray: boolean;
    /**
     * Returns whether this class instance contains a group of array values.
     * @return True if this instance class contains an array group, else false.
     * @see [[toArrayProxyGroup]]
     */
    readonly isArrayGroup: boolean;
    /**
     * @hidden
     */
    readonly _s: boolean;
    private _x;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _y: boolean;
    /**
     * Convert this class instance's value to an [[ArrayProxy]] data type.
     * @return An array equivalent to the value of this instance.
     * @see [[ArrayProxy]]
     */
    toArrayProxy(): ArrayProxy;
    /**
     * @hidden
     */
    _d(a: boolean): ArrayProxy;
    /**
     * @hidden
     */
    _e(): ArrayProxy;
    /**
     * Convert this class instance's value to an array group data type.
     * @return An array group equivalent to the value of this instance.
     * @see [[ArrayProxy]]
     */
    toArrayProxyGroup(): ArrayProxy[];
    /**
     * @hidden
     */
    _b(a: boolean): ArrayProxy[];
    /**
     * @hidden
     */
    readonly _o: Workbook;
    /**
     * @hidden
     */
    toUInt64(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toSByte(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toUInt16(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toUInt32(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    static readonly _g: ExcelCalcValue;
    private _bl;
    constructor(value: any);
    constructor();
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _bt(a: any): void;
    /**
     * Convert this class instance's value to an int
     * @return A signed 32-bit integer value containing the equivalent value of this instance
     */
    toInt(): number;
    /**
     * Convert this class instance's value to an int
     * <p class="body">
     * If there is no meaningful conversion to an integer this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A signed 32-bit integer value containing the equivalent value of this instance
     */
    toInt(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    _toInt(): number;
    /**
     * @hidden
     */
    _toInt1(a: IFormatProvider): number;
    /**
     * @hidden
     */
    private _bs;
    /**
     * Convert this instance's value to a [[IExcelCalcReference]].
     * <p class="body">
     * The instance value's underlying data type must be reference to return a reference, else an error reference is returned.
     * <p></p>
     * If there is no meaningful conversion to a reference, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @return If this instance contains a object that implements the [[IExcelCalcReference]] interface, this method returns the object instance, else an error reference is returned.
     */
    toReference(): IExcelCalcReference;
    /**
     * @hidden
     */
    _j(a: boolean): IExcelCalcReference;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private static _h;
    /**
     * Convert this instance's value to an [[ExcelCalcErrorValue]]
     * <p class="body">
     * This method returns an [[ExcelCalcErrorValue]] whose error code is set this instance's error code.
     * <p></p>
     * If there this instance does not contain an error, a [[ExcelCalcErrorValue]] containing a default value is returned
     * </p>
     * @return A [[ExcelCalcErrorValue]] containing the equivalent error code to the value of this instance
     */
    toErrorValue(): ExcelCalcErrorValue;
    /**
     * Returns a string representation of this instance's value.
     * @return String representation of instance's value
     */
    toString(): string;
    /**
     * Returns whether this class instance contains a [[IExcelCalcReference]] value
     * @return True if this instance class contains a reference, else false
     */
    readonly isReference: boolean;
    /**
     * Returns whether this class instance contains an error value
     * @return True if this class instance contains an error, else false
     */
    readonly isError: boolean;
    /**
     * @hidden
     */
    static _aa(a: any): boolean;
    /**
     * Returns whether this class instance contains a null value
     * @return True if this instance class contains a null value, else false
     */
    readonly isNull: boolean;
    /**
     * @hidden
     */
    static _ac(a: any): boolean;
    /**
     * Returns whether this class instance contains a DBNull value
     * @return True if this instance class contains a null value, else false
     */
    readonly isDBNull: boolean;
    /**
     * Returns whether this class instance contains a string value
     * @return True if this instance class contains a string, else false
     */
    readonly isString: boolean;
    /**
     * @hidden
     */
    static _ag(a: any): boolean;
    /**
     * Returns whether this class instance contains a boolean value
     * @return True if this instance class contains a boolean, else false
     */
    readonly isBoolean: boolean;
    /**
     * @hidden
     */
    static _u(a: any): boolean;
    /**
     * Returns whether this class instance contains a DateTime value
     * @return True if this instance class contains a DateTime, else false
     */
    readonly isDateTime: boolean;
    /**
     * Return the underlying value
     */
    readonly value: any;
    /**
     * Indicates if the value of the specified [[ExcelCalcValue]] is equivalent to the [[value]]
     * @param x First [[ExcelCalcValue]] to compare
     * @param y Second [[ExcelCalcValue]] to compare
     * @return True if the values are the same; otherwise false is returned.
     */
    static areValuesEqual(x: ExcelCalcValue, y: ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    compareToObject(value: any): number;
    /**
     * Compares current instance with the passed in [[ExcelCalcValue]] instance. Returns
     * -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     * @param value The object that this instance should be compared against.
     * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     */
    compareTo(value: ExcelCalcValue): number;
    /**
     * Compares x and y [[ExcelCalcValue]] instances and returns -1 if x is less than y,
     * 1 if x is greater than y and 0 if x and y are equal.
     * @param x The first value to compare.
     * @param y The value to compare with the first value.
     * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     */
    static compareTo(x: ExcelCalcValue, y: ExcelCalcValue): number;
    /**
     * @hidden
     */
    static _compareTo1(a: ExcelCalcValue, b: ExcelCalcValue): number;
    /**
     * @hidden
     */
    static _a4(a: ExcelCalcValue, b: any, c: ExcelCalcValue, d: any): number;
    /**
     * Indicates if the specified [[ExcelCalcValue]] has the save [[value]] as this instance.
     * @param value [[ExcelCalcValue]] to compare against.
     * @return True if the [[value]] of both instances are equal; otherwise false.
     */
    isSameValue(value: ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    _ah(a: IFormatProvider): boolean;
    /**
     * Gets the resolved value of the reference. This method will walk down the reference chain recursively to get the resolved value of the reference that is not just another reference.
     * @return
     */
    getResolvedValue(): any;
    /**
     * Gets the resolved value of the reference. This method will walk down the reference chain recursively to get the resolved value of the reference that is not just another reference.
     * @param willUseValueInCalculations True if the value returned will actually be used in calculations; False if the value is being requested to inspect some aspect of it, such as its type.
     */
    getResolvedValue(willUseValueInCalculations: boolean): any;
    /**
     * @hidden
     */
    _getResolvedValue(): any;
    /**
     * Convert this class instance's value to a double data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A double-precision floating-point equivalent to the value of this instance
     */
    toDouble(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a double data type
     * @see [[toDouble]]
     */
    toDouble(): number;
    /**
     * @hidden
     */
    _toDouble3(): number;
    /**
     * @hidden
     */
    _toDouble(a: IFormatProvider): number;
    /**
     * @hidden
     */
    _toDouble1(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    private _toDouble2;
    /**
     * @hidden
     */
    _ao(a: any, b: number, c: IFormatProvider, d: BaseError): {
        ret: boolean;
        p1: number;
        p3: BaseError;
    };
    /**
     * Convert this class instance's value to a DateTime data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A <b>DateTime</b> equivalent to the value of this instance
     */
    toDateTime(provider: IFormatProvider): Date;
    /**
     * Convert this class instance's value to a DateTime data type
     * @see [[toDateTime]]
     */
    toDateTime(): Date;
    /**
     * @hidden
     */
    _toDateTime1(): Date;
    /**
     * @hidden
     */
    _toDateTime(a: IFormatProvider): Date;
    /**
     * @hidden
     */
    _aj(a: IFormatProvider, b: Date, c?: boolean, d?: boolean): {
        ret: boolean;
        p1: Date;
    };
    /**
     * Convert this class instance's value to a float data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A single-precision floating-point equivalent to the value of this instance
     */
    toSingle(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a float data type
     * @see [[toSingle]]
     */
    toSingle(): number;
    /**
     * @hidden
     */
    _toSingle1(): number;
    /**
     * @hidden
     */
    _toSingle(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a boolean data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A boolean floating-point equivalent to the value of this instance
     */
    toBoolean(provider: IFormatProvider): boolean;
    /**
     * Convert this class instance's value to a boolean data type
     * @see [[toBoolean]]
     * @return A boolean floating-point equivalent to the value of this instance
     */
    toBoolean(): boolean;
    /**
     * @hidden
     */
    _toBoolean1(): boolean;
    /**
     * @hidden
     */
    _toBoolean(a: IFormatProvider): boolean;
    /**
     * Convert this class instance's value to a int data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 32-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt32(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a int data type
     * @see [[toInt32]]
     * @return A 32-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt32(): number;
    /**
     * @hidden
     */
    _toInt321(): number;
    /**
     * @hidden
     */
    _toInt32(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a short data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 16-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt16(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a short data type
     * @see [[toInt16]]
     */
    toInt16(): number;
    /**
     * @hidden
     */
    _toInt161(): number;
    /**
     * @hidden
     */
    _toInt16(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a string instance data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A string instance equivalent to the value of this instance
     */
    toString1(provider: IFormatProvider): string;
    /**
     * @hidden
     */
    _bp(a: any, b: IFormatProvider): string;
    /**
     * Convert this class instance's value to a byte data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 8-bit unsigned integer equivalent to the value of this instance
     */
    toByte(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a byte data type
     * @see [[toByte]]
     */
    toByte(): number;
    /**
     * @hidden
     */
    _toByte1(): number;
    /**
     * @hidden
     */
    _toByte(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a char type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A Unicode character equivalent to the value of this instance
     */
    toChar(provider: IFormatProvider): string;
    /**
     * Convert this class instance's value to a char data type
     * @see [[toChar]]
     * @return A Unicode character equivalent to the value of this instance
     */
    toChar(): string;
    /**
     * @hidden
     */
    _toChar1(): string;
    /**
     * @hidden
     */
    _toChar(a: IFormatProvider): string;
    /**
     * Convert this class instance's value to a long data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 64-bit signed integer equivalent to the value of this instance
     */
    toInt64(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a long data type
     * @see [[toInt64]]
     */
    toInt64(): number;
    /**
     * @hidden
     */
    _toInt641(): number;
    /**
     * @hidden
     */
    _toInt64(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a decimal data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A <b>Decimal</b> equivalent to the value of this instance
     */
    toDecimal(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a decimal data type
     * @see [[toDecimal]]
     * @return A <b>Decimal</b> equivalent to the value of this instance
     * @see [[toDecimal]]
     */
    toDecimal(): number;
    /**
     * @hidden
     */
    _toDecimal2(): number;
    /**
     * @hidden
     */
    _toDecimal1(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _toDecimal(a: IFormatProvider): number;
    /**
     * @hidden
     */
    private _al;
    /**
     * Converts a DateTime to Excel's numerical representation of a date.
     * <p class="body">
     * When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. This overload assumes the 1900 date system is being used
     * as so it corrects the date values.
     * </p>
     * @param dateValue The DateTime value to convert to the Microsoft Excel date format.
     */
    static dateTimeToExcelDate(workbook: Workbook, dateValue: Date): number;
    /**
     * Converts a DateTime to Excel's numerical representation of a date.
     * @param dateValue The DateTime value to convert to the Microsoft Excel date format.
     * @param shouldCorrect1900Dates When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. Pass False to disable this correction.
     */
    static dateTimeToExcelDate(workbook: Workbook, dateValue: Date, shouldCorrect1900Dates: boolean): number;
    /**
     * @hidden
     */
    static _dateTimeToExcelDate(a: Workbook, b: Date): Nullable$1<number>;
    /**
     * @hidden
     */
    static _dateTimeToExcelDate1(a: Workbook, b: Date, c: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    static _bb(a: Date, b: boolean, c: boolean): Nullable$1<number>;
    /**
     * Converts Excel's numerical representation of a date to a DateTime.
     * <p class="body">
     * When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. This overload assumes the 1900 date system is being used
     * as so it corrects the date values.
     * </p>
     * @param excelDate The Microsoft Excel date format which should be converted to a DateTime.
     */
    static excelDateToDateTime(workbook: Workbook, excelDate: number): Date;
    /**
     * Converts Excel's numerical representation of a date to a DateTime.
     * @param excelDate The Microsoft Excel date format which should be converted to a DateTime.
     * @param shouldCorrect1900Dates When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. Pass False to disable this correction.
     */
    static excelDateToDateTime(workbook: Workbook, excelDate: number, shouldCorrect1900Dates: boolean): Date;
    /**
     * @hidden
     */
    static _excelDateToDateTime(a: Workbook, b: number): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _excelDateToDateTime1(a: Workbook, b: number, c: boolean): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _be(a: Workbook, b: number, c: boolean, d: boolean): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _bq(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    static _ay(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _getResolvedValue3(a: boolean): any;
    /**
     * @hidden
     */
    _bj(a: boolean, b: boolean): any;
    /**
     * @hidden
     */
    private _bg;
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    static readonly _aq: boolean;
    /**
     * @hidden
     */
    static readonly _ap: boolean;
    /**
     * @hidden
     */
    readonly _a0: CultureInfo;
}
/**
 * Represents a two-dimensional array of [[ExcelCalcValue]] instances used in calculations.
 */
export declare abstract class ArrayProxy extends Base implements IEnumerable$1<ExcelCalcValue> {
    static $t: Type;
    private _e;
    [Symbol.iterator](): EnumeratorWrapper<ExcelCalcValue>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<ExcelCalcValue>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Gets the number of elements in the specified dimension of the array.
     * @param dimension The zero-based index of the dimension.
     * @return The number of elements in the specified dimension.
     */
    abstract getLength(dimension: number): number;
    /**
     * @hidden
     */
    abstract _c(a: ArrayValueContext): ExcelCalcValue;
    /**
     * @hidden
     */
    abstract _a(): ExcelCalcValue[][];
    /**
     * @hidden
     */
    private __i;
    _i(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    /**
     * @hidden
     */
    abstract _j(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    /**
     * @hidden
     */
    _m(a: boolean, b: (arg1: ExcelCalcValue, arg2: ArrayValueContext) => void): void;
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    _l(a: ExcelCalcValue): void;
    /**
     * Gets the [[ExcelCalcValue]] at the specified index.
     * @param x The index for the first dimension of the array. This is the relative column index for arrays representing cell regions on a worksheet.
     * @param y The index for the second dimension of the array. This is the relative row index for arrays representing cell regions on a worksheet.
     * @return An [[ExcelCalcValue]] representing the specified value in the array.
     */
    item(a: number, b: number): ExcelCalcValue;
    /**
     * @hidden
     */
    _b(a: ArrayValueContext): ExcelCalcValue;
    /**
     * @hidden
     */
    abstract readonly _g: boolean;
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _f: ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class CLRArrayProxy extends ArrayProxy {
    static $t: Type;
    private _o;
    constructor(a: number, b: ExcelCalcValue);
    constructor(a: number, b: ExcelCalcValue[][]);
    constructor(a: number, ..._rest: any[]);
    protected get__g(): boolean;
    readonly _g: boolean;
    private __j;
    _j(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _c(a: ArrayValueContext): ExcelCalcValue;
    _a(): ExcelCalcValue[][];
}
/**
 * Base class for formula functions.
 */
export declare abstract class ExcelCalcFunction extends Base {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    _ae(): void;
    /**
     * @hidden
     */
    readonly _o: boolean;
    /**
     * Function name used to reference the function in a formula
     */
    abstract readonly name: string;
    /**
     * Minimum number of arguments required for the function
     */
    abstract readonly minArgs: number;
    /**
     * Maximum number of arguments required for the function
     */
    abstract readonly maxArgs: number;
    /**
     * @hidden
     */
    private _z;
    /**
     * Evaluates the function against the arguments on the number stack.
     * @param numberStack Formula number stack containing function arguments.
     * @param argumentCount Denotes the number of function arguments pushed onto the number stack.
     */
    performEvaluation(numberStack: ExcelCalcNumberStack, argumentCount: number): void;
    /**
     * @hidden
     */
    _aj(a: ExcelCalcNumberStack, b: number): void;
    /**
     * Evaluates the function against the arguments on the number stack.
     * @param numberStack Formula number stack containing function arguments.
     * @param argumentCount Denotes the number of function arguments pushed onto the number stack.
     * @return An [[ExcelCalcValue]] that represents the result of the function evaluation.
     */
    protected abstract evaluate(numberStack: ExcelCalcNumberStack, argumentCount: number): ExcelCalcValue;
    /**
     * @hidden
     */
    static _t(a: ExcelCalcNumberStack, b: number, c: List$1<number>, d: boolean, e: boolean): boolean;
    /**
     * @hidden
     */
    private static _w;
    /**
     * A helper method for extracting the [[ExcelCalcValue]] instances from the stack.
     * @param numberStack Number stack whose values should be popped.
     * @param argumentCount Number of items to pop/evaluate from the number stack
     * @param skipEmptyValues True to ignore values whose IsNull returns true; otherwise false to include empty items in the list.
     * @return An array of [[ExcelCalcValue]] instances removed from the number stack.
     */
    getArguments(numberStack: ExcelCalcNumberStack, argumentCount: number, skipEmptyValues: boolean): ExcelCalcValue[];
    /**
     * A helper method for extracting the [[ExcelCalcValue]] instances from the stack.
     * @param numberStack Number stack whose values should be popped.
     * @param argumentCount Number of items to pop/evaluate from the number stack
     * @param skipEmptyValues True to ignore values whose IsNull returns true; otherwise false to include empty items in the list.
     * @param skipHiddenCells True to ignore values from hidden cells.
     * @return An array of UltraCalcValue instances removed from the number stack.
     */
    getArguments(numberStack: ExcelCalcNumberStack, argumentCount: number, skipEmptyValues: boolean, skipHiddenCells: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    protected _getArguments(a: ExcelCalcNumberStack, b: number, c: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    protected _getArguments1(a: ExcelCalcNumberStack, b: number, c: boolean, d: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    _ad(a: List$1<ExcelCalcValue>, b: ExcelCalcNumberStack, c: number, d: boolean): void;
    /**
     * @hidden
     */
    static _ac(a: List$1<ExcelCalcValue>, b: ExcelCalcValue, c: boolean, d: boolean, e?: boolean): void;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * @hidden
     */
    static _p(a: IExcelCalcReference): boolean;
    /**
     * @hidden
     */
    static _q(a: IExcelCalcReference, b: boolean, c: boolean): boolean;
    /**
     * @hidden
     */
    static _u(a: IExcelCalcReference): boolean;
    /**
     * Determines whether the parameter at the specified index will accept an enumerable reference.
     * @param parameterIndex In 0-based index of the parameter.
     * @return True if the parameter at the specified index can accept enumerable references; False otherwise or if the parameter is out of range for this function.
     */
    canParameterBeEnumerable(parameterIndex: number): boolean;
    /**
     * @hidden
     */
    static _c(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _d(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _f(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _g(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    protected get__k(): TokenClass;
    /**
     * @hidden
     */
    readonly _k: TokenClass;
    /**
     * Determines whether the function accepts an intermediate result array created by evaluating a nested function
     * on a per-element basis of an array or region parameter when a single value is expected.
     * <p class="body">
     * An intermediate result array will be generated when multiple values are specified where a single value is expected.
     * For example, the following formula will generate the value 15: =SUM(10/{1,2}). This is because "10/{1,2}" will
     * result in an intermediate result array of {10/1,10/2}, or {10,5}. Then each element is summed up to result in the
     * value 15. However, the SUM function does not allow intermediate result arrays for region references. So a function
     * such as =SUM(10/D6:E7) will result in a #VALUE! error. Unlike the SUM function, the LOOKUP function allows intermediate
     * result arrays from region references. So a formula like LOOKUP(10,D6:E7*2) will return a correct result if the value 10
     * can be found in the following intermediate result array when using the normal LOOKUP function logic: {D6*2,E6*2; D7*2,E7*2}.
     * Therefore, SUM would return True from this method only when 'isCreatedFromRegionReference' is False
     * and LOOKUP would return True from this method always (for a 'parameterIndex' value of 1 in this example).
     * </p>
     * <p class="note">
     * <b>Note:</b> if this function is being called in an array formula, the restrictions are relaxed in the following way:
     * if the function supports intermediate result arrays created from constant array, it will also support intermediate
     * result arrays created from region references, so the 'isCreatedFromRegionReference' value will always
     * be passed in as False.
     * </p>
     * @param parameterIndex The 0-based index of parameter in which the intermediate array will be passed.
     * @param isCreatedFromRegionReference True if the value which will generate the intermediate result array is a region reference; False if it is a constant array.
     * @return True to allow intermediate result arrays for the specified parameter; False otherwise.
     */
    doesParameterAllowIntermediateResultArray(parameterIndex: number, isCreatedFromRegionReference: boolean): boolean;
    private _h;
    /**
     * @hidden
     */
    _i(): Function;
    /**
     * @hidden
     */
    _j(a: number): TokenClass;
    /**
     * @hidden
     */
    static _l(a: ExcelCalcNumberStack): Workbook;
    /**
     * @hidden
     */
    protected get__r(): boolean;
    /**
     * @hidden
     */
    readonly _r: boolean;
    /**
     * @hidden
     */
    protected get__s(): boolean;
    /**
     * @hidden
     */
    readonly _s: boolean;
    /**
     * @hidden
     */
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare abstract class BuiltInFunctionBase extends ExcelCalcFunction {
    static $t: Type;
    constructor();
}
/**
 * @hidden
 */
export declare abstract class UltraCalcBinaryOperatorBase extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    protected abstract _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionPlus extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
}
/**
 * @hidden
 */
export declare class Function extends Base implements IComparable$1<Function> {
    static $t: Type;
    private _alw;
    private _ut;
    private _q0;
    private _w0;
    private _qq;
    private _qs;
    private _aav;
    private _aat;
    private _a;
    private _qi;
    private _c;
    private _ql;
    private _qv;
    private _aru;
    private readonly _aly;
    private readonly _al0;
    readonly _qo: boolean;
    constructor(a: string, b: number, c: number, d: number, e: boolean, f: boolean, g: number, h: number, i: number[], j: TokenClass, ...k: TokenClass[]);
    compareTo(a: Function): number;
    _qh(a: number): TokenClass;
    _qx(a: WorkbookFormat): number;
    readonly _vv: number;
    readonly _qk: boolean;
    readonly _qm: boolean;
    readonly _qn: boolean;
    readonly _qp: boolean;
    readonly _qr: boolean;
    readonly _qt: boolean;
    readonly _b: number[];
    readonly _qu: boolean;
    readonly _q1: number;
    readonly _alx: string;
    readonly _qw: boolean;
    readonly _qj: TokenClass;
    readonly _aau: number;
    readonly _aaw: number;
    readonly _arv: string;
    static _q2: Dictionary$2<number, Function[]>;
    private static _ar8;
    private static _q3;
    static _gt(a: string, b: string): Function;
    private static _q4;
    static _gu(a: number): Function;
    static _gv(a: string): Function;
    static _gx(a: string, b: number, c: number): Function;
    private static _gw;
    static _gz(a: string): Function;
    static readonly _b8: Function;
    static readonly _hf: Function;
    static readonly _iq: Function;
    static readonly _il: Function;
    static readonly _n6: Function;
    static readonly _ah: Function;
    static readonly _jt: Function;
    static readonly _jl: Function;
    static readonly _m0: Function;
    static readonly _bs: Function;
    static readonly _kb: Function;
    static readonly _kv: Function;
    static readonly _nw: Function;
    static readonly _dy: Function;
    static readonly _fd: Function;
    static readonly _nl: Function;
    static readonly _b4: Function;
    static readonly _on: Function;
    static readonly _ad: Function;
    static readonly _ln: Function;
    static readonly _nt: Function;
    static readonly _et: Function;
    static readonly _ja: Function;
    static readonly _jc: Function;
    static readonly _d: Function;
    static readonly _id: Function;
    static readonly _nk: Function;
    static readonly _mv: Function;
    static readonly _ji: Function;
    static readonly _h8: Function;
    static readonly _ml: Function;
    static readonly _jr: Function;
    static readonly _i6: Function;
    static readonly _pm: Function;
    static readonly _pd: Function;
    static readonly _e3: Function;
    static readonly _v: Function;
    static readonly _k9: Function;
    static readonly _kr: Function;
    static readonly _j1: Function;
    static readonly _db: Function;
    static readonly _d4: Function;
    static readonly _c5: Function;
    static readonly _dw: Function;
    static readonly _dv: Function;
    static readonly _d2: Function;
    static readonly _pn: Function;
    static readonly _d6: Function;
    static readonly _ou: Function;
    static readonly _i8: Function;
    static readonly _pa: Function;
    static readonly _jd: Function;
    static readonly _g2: Function;
    static readonly _l1: Function;
    static readonly _fy: Function;
    static readonly _ku: Function;
    static readonly _lo: Function;
    static readonly _mc: Function;
    static readonly _jy: Function;
    static readonly _ii: Function;
    static readonly _l7: Function;
    static readonly _jk: Function;
    static readonly _c1: Function;
    static readonly _o5: Function;
    static readonly _c6: Function;
    static readonly _j5: Function;
    static readonly _qa: Function;
    static readonly _py: Function;
    static readonly _ha: Function;
    static readonly _jw: Function;
    static readonly _nc: Function;
    static readonly _kt: Function;
    static readonly _y: Function;
    static readonly _m1: Function;
    static readonly _bt: Function;
    static readonly _k6: Function;
    static readonly _m8: Function;
    static readonly _o9: Function;
    static readonly _pg: Function;
    static readonly _ae: Function;
    static readonly _ab: Function;
    static readonly _h: Function;
    static readonly _bp: Function;
    static readonly _g9: Function;
    static readonly _pv: Function;
    static readonly _ix: Function;
    static readonly _jb: Function;
    static readonly _bf: Function;
    static readonly _jj: Function;
    static readonly _pk: Function;
    static readonly _l0: Function;
    static readonly _i4: Function;
    static readonly _ms: Function;
    static readonly _eq: Function;
    static readonly _pb: Function;
    static readonly _mj: Function;
    static readonly _n4: Function;
    static readonly _br: Function;
    static readonly _e8: Function;
    static readonly _be: Function;
    static readonly _ik: Function;
    static readonly _iy: Function;
    static readonly _is: Function;
    static readonly _ij: Function;
    static readonly _og: Function;
    static readonly _ka: Function;
    static readonly _c4: Function;
    static readonly _o6: Function;
    static readonly _np: Function;
    static readonly _of: Function;
    static readonly _dd: Function;
    static readonly _h9: Function;
    static readonly _bq: Function;
    static readonly _jo: Function;
    static readonly _jx: Function;
    static readonly _jz: Function;
    static readonly _ih: Function;
    static readonly _lt: Function;
    static readonly _b9: Function;
    static readonly _lz: Function;
    static readonly _e1: Function;
    static readonly _gs: Function;
    static readonly _d1: Function;
    static readonly _ir: Function;
    static readonly _n0: Function;
    static readonly _pr: Function;
    static readonly _d3: Function;
    static readonly _d7: Function;
    static readonly _pe: Function;
    static readonly _ip: Function;
    static readonly _dc: Function;
    static readonly _pl: Function;
    static readonly _e9: Function;
    static readonly _m9: Function;
    static readonly _mk: Function;
    static readonly _i5: Function;
    static readonly _mt: Function;
    static readonly _js: Function;
    static readonly _i7: Function;
    static readonly _mz: Function;
    static readonly _my: Function;
    static readonly _aa: Function;
    static readonly _da: Function;
    static readonly _l9: Function;
    static readonly _r: Function;
    static readonly _c8: Function;
    static readonly _o8: Function;
    static readonly _pt: Function;
    static readonly _jq: Function;
    static readonly _n9: Function;
    static readonly _nm: Function;
    static readonly _b5: Function;
    static readonly _oo: Function;
    static readonly _ac: Function;
    static readonly _i: Function;
    static readonly _af: Function;
    static readonly _dr: Function;
    static readonly _ia: Function;
    static readonly _c9: Function;
    static readonly _fv: Function;
    static readonly _en: Function;
    static readonly _ag: Function;
    static readonly _at: Function;
    static readonly _f7: Function;
    static readonly _au: Function;
    static readonly _a1: Function;
    static readonly _bh: Function;
    static readonly _bi: Function;
    static readonly _bu: Function;
    static readonly _bz: Function;
    static readonly _cn: Function;
    static readonly _ep: Function;
    static readonly _ev: Function;
    static readonly _e5: Function;
    static readonly _fa: Function;
    static readonly _fb: Function;
    static readonly _fc: Function;
    static readonly _fe: Function;
    static readonly _f5: Function;
    static readonly _f6: Function;
    static readonly _bb: Function;
    static readonly _he: Function;
    static readonly _jh: Function;
    static readonly _je: Function;
    static readonly _ke: Function;
    static readonly _kn: Function;
    static readonly _kp: Function;
    static readonly _ko: Function;
    static readonly _j0: Function;
    static readonly _nv: Function;
    static readonly _k1: Function;
    static readonly _lj: Function;
    static readonly _lp: Function;
    static readonly _os: Function;
    static readonly _p0: Function;
    static readonly _od: Function;
    static readonly _ob: Function;
    static readonly _oc: Function;
    static readonly _bo: Function;
    static readonly _b3: Function;
    static readonly _cj: Function;
    static readonly _fk: Function;
    static readonly _fx: Function;
    static readonly _ie: Function;
    static readonly _lc: Function;
    static readonly _m3: Function;
    static readonly _n3: Function;
    static readonly _nq: Function;
    static readonly _pf: Function;
    static readonly _ly: Function;
    static readonly _dq: Function;
    static readonly _gb: Function;
    static readonly _g4: Function;
    static readonly _oa: Function;
    static readonly _i0: Function;
    static readonly _nn: Function;
    static readonly _qg: Function;
    static readonly _i1: Function;
    static readonly _nr: Function;
    static readonly _l2: Function;
    static readonly _ld: Function;
    static readonly _lg: Function;
    static readonly _j2: Function;
    static readonly _pc: Function;
    static readonly _o7: Function;
    static readonly _by: Function;
    static readonly _ls: Function;
    static readonly _l6: Function;
    static readonly _di: Function;
    static readonly _n5: Function;
    static readonly _n7: Function;
    static readonly _cb: Function;
    static readonly _ca: Function;
    static readonly _iw: Function;
    static readonly _c2: Function;
    static readonly _c3: Function;
    static readonly _kw: Function;
    static readonly _mu: Function;
    static readonly _gy: Function;
    static readonly _hb: Function;
    static readonly _lm: Function;
    static readonly _ai: Function;
    static readonly _jm: Function;
    static readonly _ju: Function;
    static readonly _n1: Function;
    static readonly _ps: Function;
    static readonly _nz: Function;
    static readonly _pq: Function;
    static readonly _q: Function;
    static readonly _f: Function;
    static readonly _g: Function;
    static readonly _t: Function;
    static readonly _u: Function;
    static readonly _aj: Function;
    static readonly _ak: Function;
    static readonly _al: Function;
    static readonly _an: Function;
    static readonly _ao: Function;
    static readonly _ap: Function;
    static readonly _aq: Function;
    static readonly _av: Function;
    static readonly _aw: Function;
    static readonly _ax: Function;
    static readonly _bw: Function;
    static readonly _b2: Function;
    static readonly _cd: Function;
    static readonly _ce: Function;
    static readonly _cf: Function;
    static readonly _cg: Function;
    static readonly _ch: Function;
    static readonly _ci: Function;
    static readonly _cq: Function;
    static readonly _cr: Function;
    static readonly _cs: Function;
    static readonly _ct: Function;
    static readonly _cu: Function;
    static readonly _cv: Function;
    static readonly _cw: Function;
    static readonly _cx: Function;
    static readonly _cy: Function;
    static readonly _de: Function;
    static readonly _df: Function;
    static readonly _dg: Function;
    static readonly _dn: Function;
    static readonly _du: Function;
    static readonly _dz: Function;
    static readonly _d0: Function;
    static readonly _d5: Function;
    static readonly _ea: Function;
    static readonly _eb: Function;
    static readonly _eh: Function;
    static readonly _ei: Function;
    static readonly _ek: Function;
    static readonly _e2: Function;
    static readonly _fz: Function;
    static readonly _ga: Function;
    static readonly _gc: Function;
    static readonly _g6: Function;
    static readonly _g7: Function;
    static readonly _g8: Function;
    static readonly _hd: Function;
    static readonly _hg: Function;
    static readonly _hj: Function;
    static readonly _hk: Function;
    static readonly _hl: Function;
    static readonly _hm: Function;
    static readonly _hn: Function;
    static readonly _hs: Function;
    static readonly _ht: Function;
    static readonly _hu: Function;
    static readonly _hv: Function;
    static readonly _hw: Function;
    static readonly _hx: Function;
    static readonly _hy: Function;
    static readonly _hz: Function;
    static readonly _h2: Function;
    static readonly _h4: Function;
    static readonly _h5: Function;
    static readonly _h6: Function;
    static readonly _ig: Function;
    static readonly _im: Function;
    static readonly _iu: Function;
    static readonly _i3: Function;
    static readonly _jp: Function;
    static readonly _j7: Function;
    static readonly _j8: Function;
    static readonly _kf: Function;
    static readonly _ki: Function;
    static readonly _kq: Function;
    static readonly _ky: Function;
    static readonly _kz: Function;
    static readonly _k0: Function;
    static readonly _k2: Function;
    static readonly _k3: Function;
    static readonly _k4: Function;
    static readonly _k5: Function;
    static readonly _lv: Function;
    static readonly _lw: Function;
    static readonly _lx: Function;
    static readonly _l5: Function;
    static readonly _l8: Function;
    static readonly _md: Function;
    static readonly _m4: Function;
    static readonly _ne: Function;
    static readonly _nu: Function;
    static readonly _n8: Function;
    static readonly _op: Function;
    static readonly _oq: Function;
    static readonly _or: Function;
    static readonly _pz: Function;
    static readonly _p5: Function;
    static readonly _p7: Function;
    static readonly _p8: Function;
    static readonly _qb: Function;
    static readonly _qc: Function;
    static readonly _qd: Function;
    static readonly _qe: Function;
    static readonly _j: Function;
    static readonly _k: Function;
    static readonly _x: Function;
    static readonly _s: Function;
    static readonly _am: Function;
    static readonly _ar: Function;
    static readonly _as: Function;
    static readonly _ay: Function;
    static readonly _az: Function;
    static readonly _a0: Function;
    static readonly _a2: Function;
    static readonly _a3: Function;
    static readonly _a4: Function;
    static readonly _a5: Function;
    static readonly _a6: Function;
    static readonly _bc: Function;
    static readonly _bd: Function;
    static readonly _bj: Function;
    static readonly _bk: Function;
    static readonly _bl: Function;
    static readonly _bm: Function;
    static readonly _bn: Function;
    static readonly _bv: Function;
    static readonly _b0: Function;
    static readonly _b1: Function;
    static readonly _b6: Function;
    static readonly _b7: Function;
    static readonly _ck: Function;
    static readonly _cl: Function;
    static readonly _co: Function;
    static readonly _cp: Function;
    static readonly _c7: Function;
    static readonly _dh: Function;
    static readonly _ej: Function;
    static readonly _el: Function;
    static readonly _eu: Function;
    static readonly _ew: Function;
    static readonly _ex: Function;
    static readonly _ey: Function;
    static readonly _ez: Function;
    static readonly _e0: Function;
    static readonly _e7: Function;
    static readonly _ff: Function;
    static readonly _fg: Function;
    static readonly _fr: Function;
    static readonly _f2: Function;
    static readonly _f3: Function;
    static readonly _f4: Function;
    static readonly _f8: Function;
    static readonly _f9: Function;
    static readonly _hc: Function;
    static readonly _hh: Function;
    static readonly _ho: Function;
    static readonly _hp: Function;
    static readonly _hq: Function;
    static readonly _hr: Function;
    static readonly _h0: Function;
    static readonly _h1: Function;
    static readonly _h3: Function;
    static readonly _h7: Function;
    static readonly _io: Function;
    static readonly _iv: Function;
    static readonly _jf: Function;
    static readonly _jg: Function;
    static readonly _j3: Function;
    static readonly _j4: Function;
    static readonly _j9: Function;
    static readonly _kd: Function;
    static readonly _kj: Function;
    static readonly _kk: Function;
    static readonly _kl: Function;
    static readonly _km: Function;
    static readonly _kx: Function;
    static readonly _lb: Function;
    static readonly _le: Function;
    static readonly _lf: Function;
    static readonly _lh: Function;
    static readonly _li: Function;
    static readonly _lk: Function;
    static readonly _ll: Function;
    static readonly _lq: Function;
    static readonly _l3: Function;
    static readonly _l4: Function;
    static readonly _ma: Function;
    static readonly _mb: Function;
    static readonly _m2: Function;
    static readonly _na: Function;
    static readonly _nb: Function;
    static readonly _nh: Function;
    static readonly _ni: Function;
    static readonly _no: Function;
    static readonly _nx: Function;
    static readonly _ny: Function;
    static readonly _oh: Function;
    static readonly _oi: Function;
    static readonly _oj: Function;
    static readonly _ok: Function;
    static readonly _ol: Function;
    static readonly _om: Function;
    static readonly _ph: Function;
    static readonly _pi: Function;
    static readonly _po: Function;
    static readonly _pp: Function;
    static readonly _px: Function;
    static readonly _p1: Function;
    static readonly _p9: Function;
    static readonly _qf: Function;
    static readonly _d9: Function;
    static readonly _it: Function;
    static readonly _kg: Function;
    static readonly _p6: Function;
    static readonly _fl: Function;
    static readonly _fm: Function;
    static readonly _fn: Function;
    static readonly _fp: Function;
    static readonly _fo: Function;
    static readonly _cc: Function;
    static readonly _bx: Function;
    static readonly _hi: Function;
    static readonly _jn: Function;
    static readonly _jv: Function;
    static readonly _oe: Function;
    static readonly _ow: Function;
    static readonly _iz: Function;
    static readonly _mw: Function;
    static readonly _mx: Function;
    static readonly _oy: Function;
    static readonly _oz: Function;
    static readonly _o0: Function;
    static readonly _o1: Function;
    static readonly _o2: Function;
    static readonly _o3: Function;
    static readonly _o4: Function;
    static readonly _e: Function;
    static readonly _l: Function;
    static readonly _a8: Function;
    static readonly _a9: Function;
    static readonly _eo: Function;
    static readonly _gh: Function;
    static readonly _ic: Function;
    static readonly _i2: Function;
    static readonly _m7: Function;
    static readonly _nd: Function;
    static readonly _ox: Function;
    static readonly _pu: Function;
    static readonly _m: Function;
    static readonly _n: Function;
    static readonly _o: Function;
    static readonly _p: Function;
    static readonly _w: Function;
    static readonly _z: Function;
    static readonly _a7: Function;
    static readonly _ba: Function;
    static readonly _bg: Function;
    static readonly _cm: Function;
    static readonly _cz: Function;
    static readonly _c0: Function;
    static readonly _dj: Function;
    static readonly _dk: Function;
    static readonly _dl: Function;
    static readonly _dm: Function;
    static readonly _dp: Function;
    static readonly _ds: Function;
    static readonly _dt: Function;
    static readonly _dx: Function;
    static readonly _d8: Function;
    static readonly _ec: Function;
    static readonly _ed: Function;
    static readonly _ee: Function;
    static readonly _ef: Function;
    static readonly _eg: Function;
    static readonly _em: Function;
    static readonly _er: Function;
    static readonly _es: Function;
    static readonly _e4: Function;
    static readonly _e6: Function;
    static readonly _fh: Function;
    static readonly _fi: Function;
    static readonly _fj: Function;
    static readonly _fq: Function;
    static readonly _fs: Function;
    static readonly _ft: Function;
    static readonly _fu: Function;
    static readonly _fw: Function;
    static readonly _f0: Function;
    static readonly _f1: Function;
    static readonly _gd: Function;
    static readonly _ge: Function;
    static readonly _gf: Function;
    static readonly _gg: Function;
    static readonly _gi: Function;
    static readonly _gj: Function;
    static readonly _gk: Function;
    static readonly _gl: Function;
    static readonly _gm: Function;
    static readonly _gn: Function;
    static readonly _go: Function;
    static readonly _gp: Function;
    static readonly _gq: Function;
    static readonly _gr: Function;
    static readonly _g0: Function;
    static readonly _g1: Function;
    static readonly _g3: Function;
    static readonly _g5: Function;
    static readonly _ib: Function;
    static readonly _i9: Function;
    static readonly _j6: Function;
    static readonly _kc: Function;
    static readonly _kh: Function;
    static readonly _ks: Function;
    static readonly _k7: Function;
    static readonly _k8: Function;
    static readonly _la: Function;
    static readonly _lr: Function;
    static readonly _lu: Function;
    static readonly _me: Function;
    static readonly _mf: Function;
    static readonly _mg: Function;
    static readonly _mh: Function;
    static readonly _mi: Function;
    static readonly _mm: Function;
    static readonly _mn: Function;
    static readonly _mo: Function;
    static readonly _mp: Function;
    static readonly _mq: Function;
    static readonly _mr: Function;
    static readonly _m5: Function;
    static readonly _m6: Function;
    static readonly _nf: Function;
    static readonly _ng: Function;
    static readonly _nj: Function;
    static readonly _ns: Function;
    static readonly _n2: Function;
    static readonly _ot: Function;
    static readonly _ov: Function;
    static readonly _pj: Function;
    static readonly _pw: Function;
    static readonly _p2: Function;
    static readonly _p3: Function;
    static readonly _p4: Function;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionMinus extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionMultiply extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionDivide extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionEqual extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionNE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionGE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionGT extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    protected get__r(): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionLE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionLT extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionConcat extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionExpon extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionPercent extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionUnaryMinus extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionUnaryPlus extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLIntersect extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLRange extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLUnion extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatCollection extends GenericCachedCollectionEx$1<WorksheetCellFormatData> {
    static $t: Type;
    constructor(a: WorksheetCellFormatData, b: Workbook);
    _q(a: WorksheetCellFormatData): void;
    readonly workbook: Workbook;
}
/**
 * @hidden
 */
export declare class ValueFormatter_ValueFormatterContext extends Base {
    static $t: Type;
    i: number;
    l: any;
    a: ValueFormatter_GetTextWidthHelper;
    b: ValueFormatter_SectionType;
    f: boolean;
    g: boolean;
    c: ValueFormatterFlags;
    private s;
    private ab;
    private z;
    private v;
    private x;
    private ac;
    private ae;
    private ah;
    readonly o: StringBuilder;
    readonly p: StringBuilder;
    k: Nullable$1<boolean>;
    n: string;
    h: number;
    m: string;
    e: boolean;
    d: boolean;
    q(a: string, b?: string): void;
    t(): void;
    aa(): void;
    r(): void;
    y(): void;
    u(): void;
    ag(a: ValueFormatter_FormatSection, b: string, c: number): void;
    w(a: ValueFormatter_FormatSection): void;
    ad(): void;
    af(a: string): void;
    readonly j: number;
}
/**
 * @hidden
 */
export declare class ValueFormatter extends Base {
    static $t: Type;
    i: Workbook;
    constructor(a: number, b: Workbook, c: string, d: CultureInfo);
    constructor(a: number, b: string, c: CultureInfo, d?: CultureInfo);
    constructor(a: number, ..._rest: any[]);
    h(a: number, b: string, c: any, d: number, e: TextMetricsProviderBase, f: WorksheetCellFormatData, g: boolean, h?: boolean): GetCellTextResult;
    private static af;
    ag(): string;
    aa(a: number): number;
    c(a: number): IValueFormatterSectionInfo;
    f(a: number): ValueFormatter_SectionType;
    e(a: number): ValueFormatter_SectionType;
    j(): boolean;
    k(a: number): boolean;
    l(a: number): boolean;
    m(a: number): boolean;
    n(a: number): boolean;
    private ah;
    private static d;
    a: ValueFormatter_FormatSection[];
    static x: CultureInfo;
    y: CultureInfo;
    private static g;
    private static z;
    private b;
    private static p;
    private static q;
    private static r;
    private s;
    private t;
    static w(a: number, b?: number): number;
    private static u;
    v(a: number, b: string, c: string): {
        ret: boolean;
        p2: string;
    };
    private ai;
    readonly o: boolean;
}
/**
 * @hidden
 */
export declare class ValueFormatter_FormatSection extends Base {
    static $t: Type;
    cm(a: ValueFormatter_ValueFormatterContext, b: number, c: string, d: number): {
        p3?: number;
    };
    private cq;
    private static an;
    private static readonly a3;
    private static readonly a6;
    private static readonly a5;
    private bh;
    private bi;
    private bj;
    private bk;
    private bl;
    private a7;
    private a8;
    private b7;
    private a4;
    private d;
    private bc;
    private ak;
    private bn;
    private a0;
    private be;
    private k;
    private l;
    private b;
    private b3;
    private b1;
    private b5;
    private m;
    private n;
    private bs;
    private p;
    private u;
    private x;
    private z;
    private ab;
    private ah;
    private w;
    private b6;
    private af;
    private ai;
    private ao;
    private a2;
    private bw;
    private bz;
    private f;
    private aw;
    private ay;
    private i;
    constructor(a: ValueFormatter, b: number, c: CultureInfo);
    ck(a: string, b?: ValueFormatter_LiteralType): void;
    cl(a: string, b?: ValueFormatter_LiteralType): void;
    private cn;
    co(a: ValueFormatter_WellKnownPartType): void;
    cp(a: ValueFormatter_WellKnownPartType, b: number): void;
    b8(a: string): string;
    bb(a: number): Calendar;
    b9(a: Date, b: ValueFormatter_FormatValueState, c: number): string;
    ca(a: Date, b: ValueFormatter_FormatValueState, c: string, d?: boolean): string;
    cb(a: Date, b: ValueFormatter_FormatValueState, c: number): string;
    cc(a: Date, b: ValueFormatter_FormatValueState, c: string, d?: boolean): string;
    cd(a: number, b?: boolean, c?: boolean): string;
    ce(a: number): string;
    private static readonly a;
    cf(a: number, b: number, c?: boolean): string;
    cg(a: Date, b: number): string;
    ch(a: Calendar, b: Date, c: number): string;
    cr(a: ValueFormatter_ValueFormatterContext): {
        p0?: ValueFormatter_ValueFormatterContext;
    };
    cs(a: ValueFormatter_ValueFormatterContext, b: number): {
        p0?: ValueFormatter_ValueFormatterContext;
        p1: number;
    };
    readonly o: boolean;
    ci(): string;
    h(): ValueFormatter_WellKnownPart;
    cj(a: ValueFormatter_FormatValueState): string;
    readonly aa: boolean;
    readonly ac: boolean;
    ae(a: ValueFormatter_WellKnownPartType[]): boolean;
    br(a: ValueFormatter_WellKnownPartType[], b?: number): number;
    readonly aj: boolean;
    ct(a: string, b: number, c: string): {
        p0?: string;
    };
    cu(a: string, b: number, c: string, d: string): {
        p0?: string;
    };
    aq(a: number): boolean;
    cv(): void;
    ar(a: string): boolean;
    as(a: ValueFormatter_CompareOperator, b: number): boolean;
    at(a: ValueFormatter_CompareOperator, b: number, c: boolean): boolean;
    au(a: number): boolean;
    av(a: number, b?: boolean): boolean;
    cw(a: ValueFormatter_SectionType): void;
    ax(a: ValueFormatter_FormatValueState): boolean;
    cx(): void;
    private cy;
    readonly ba: Calendar;
    readonly a9: Calendar;
    readonly bd: CultureInfo;
    readonly bf: CultureInfo;
    readonly bg: CultureInfo;
    readonly j: ValueFormatterFlags;
    readonly c: ValueFormatter;
    readonly bo: number;
    b4: Nullable$1<number>;
    b2: Nullable$1<number>;
    readonly bp: number;
    readonly bq: number;
    readonly bt: number;
    readonly q: boolean;
    readonly r: boolean;
    readonly s: boolean;
    readonly v: boolean;
    readonly t: boolean;
    readonly y: boolean;
    readonly ad: boolean;
    readonly az: boolean;
    readonly ag: boolean;
    readonly al: boolean;
    readonly am: boolean;
    readonly ap: boolean;
    readonly e: ValueFormatter_Part;
    readonly bv: number;
    readonly bx: number;
    readonly by: number;
    readonly g: ValueFormatter_SectionType;
    readonly a1: boolean;
}
/**
 * @hidden
 */
export declare abstract class ValueFormatter_Part extends Base {
    static $t: Type;
    abstract b(a: ValueFormatter_FormatSection, b: string): string;
    abstract a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
}
/**
 * @hidden
 */
export declare class ValueFormatter_WellKnownPart extends ValueFormatter_Part {
    static $t: Type;
    private j;
    private c;
    constructor(a: ValueFormatter_WellKnownPartType, b: number);
    b(a: ValueFormatter_FormatSection, b: string): string;
    a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
    o(): void;
    private l;
    private m;
    private n;
    static e(a: ValueFormatter_WellKnownPartType): boolean;
    static f(a: ValueFormatter_WellKnownPartType): boolean;
    static g(a: ValueFormatter_WellKnownPartType): boolean;
    static h(a: ValueFormatter_WellKnownPartType): boolean;
    static i(a: ValueFormatter_WellKnownPartType): boolean;
    readonly d: ValueFormatter_WellKnownPartType;
}
/**
 * @hidden
 */
export declare class CalendarUtilities extends Base {
    static $t: Type;
    static b(a: Calendar): number;
    static a(a: CultureInfo): number;
}
/**
 * @hidden
 */
export declare class DBNumHelper extends Base {
    static $t: Type;
    private static f;
    private static a;
    private static h;
    private static d;
    private static g;
    private static b;
    private static i;
    private static e;
    private static j;
    static k(a: number): boolean;
    static l(a: number): boolean;
    static c(a: number, b: number): string[];
    static o(a: number, b: number): string;
    static v(a: number, b: number, c: number, d?: number): string;
}
/**
 * @hidden
 */
export declare class ValueFormatter_LiteralFormatPart extends ValueFormatter_Part {
    static $t: Type;
    private e;
    private c;
    constructor(a: string, b: ValueFormatter_LiteralType);
    b(a: ValueFormatter_FormatSection, b: string): string;
    a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
    private f;
    readonly g: string;
    readonly d: ValueFormatter_LiteralType;
}
/**
 * Extend the class ArgumentOutOfRangeException to add a constructor
 */
export declare class ArgumentOutOfRangeExceptionExtension extends ArgumentOutOfRangeException {
    static $t: Type;
    constructor(paramName?: string, message?: string);
    constructor(paramName: string, value: any, message: string);
    constructor(message: string, innerException: BaseError);
    constructor(..._rest: any[]);
}
/**
 * A collection of worksheets in a workbook.
 * @see [[Worksheet]]
 * @see */
export declare class WorksheetCollection extends Base implements IList$1<Worksheet> {
    static $t: Type;
    private readonly _j;
    private _f;
    private readonly _a;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: Worksheet): void;
    /**
     * Creates a new [[Worksheet]] and adds it to the collection.
     * <p class="body">
     * If the workbook originally had no worksheets, the newly added worksheet will become the selected worksheet of
     * the workbook.  This can be changed after more worksheets are added by setting the [[WindowOptions.selectedWorksheet]]
     * of the Workbook.
     * </p>
     * @param name The name to give the new Worksheet.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] 'name' exceeds 31 characters in length.
     * @throws [[ArgumentException]] 'name' is being used as the name of another worksheet (worksheet names are case-insensitively compared).
     * @return The Worksheet created with the specified name.
     */
    add(name: string): Worksheet;
    /**
     * @hidden
     */
    _add$e(a: Worksheet): void;
    /**
     * @hidden
     */
    copyTo(array: Worksheet[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: Worksheet): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Worksheet>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<Worksheet>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: Worksheet): void;
    /**
     * @hidden
     */
    item(index: number, value?: Worksheet): Worksheet;
    /**
     * Gets the worksheet at the specified index.
     * The worksheet at the specified index.
     * @param index The zero-based index of the worksheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): Worksheet;
    /**
     * Gets the worksheet with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The worksheet with the specified name.
     * @param name The name of the worksheet to get.
     * @throws [[InvalidOperationException]] A worksheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    item(name: string): Worksheet;
    /**
     * @hidden
     */
    _item$e(a: number, b?: Worksheet): Worksheet;
    /**
     * @hidden
     */
    _add1(a: string): Worksheet;
    /**
     * @hidden
     */
    _add2(a: string, b: number): Worksheet;
    /**
     * Clears all worksheets from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with a worksheet for a scope, they will be removed from the [[Workbook]].
     * </p>
     */
    clear(): void;
    /**
     * Determines whether a worksheet is in the collection.
     * @param worksheet The worksheet to locate in the collection.
     * @return True if the worksheet is found; False otherwise.
     */
    contains(worksheet: Worksheet): boolean;
    /**
     * @hidden
     */
    _n(): void;
    /**
     * Determines whether a worksheet with the specified name exists in the collection.
     * @param name The name of the worksheet to search for. The name is compared case-insensitively.
     * @return True if a worksheet with the specified name is found; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified worksheet in the collection.
     * @param worksheet The worksheet of which to get the index.
     * @return The index of the specified worksheet in the collection.
     * @see [[Worksheet.index]]
     */
    indexOf(worksheet: Worksheet): number;
    /**
     * @hidden
     */
    _o(a: number, b: number): void;
    /**
     * Removes the specified worksheet from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param worksheet The worksheet to remove from the collection.
     * @return True if the worksheet was successfully removed from the collection;
     * False if the worksheet did not exist in the collection.
     */
    remove_1(worksheet: Worksheet): boolean;
    /**
     * Removes the worksheet at the specified index from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param index The index of the worksheet to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Gets the number of worksheets in the collection.
     * The number of worksheets in the collection.
     */
    readonly count: number;
    /**
     * @hidden
     */
    _item(a: number): Worksheet;
    /**
     * @hidden
     */
    _item1(a: string): Worksheet;
    /**
     * @hidden
     */
    private readonly _k;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRowCollection, c: number, d: number, e: WorksheetRow[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: number;
    readonly d: number;
    readonly b: WorksheetRowCollection;
    readonly a: WorksheetRow[];
    readonly c: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of rows in a worksheet.
 * <p class="body">
 * Rows in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the rows which were already accessed.
 * </p>
 * @see [[WorksheetRow]]
 * @see [[Worksheet.rows]]
 */
export declare class WorksheetRowCollection extends RowColumnCollectionBase$1<WorksheetRow> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static _ag;
    private _al;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<WorksheetRow>;
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetRow;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetRow): number;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetRow, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetRow): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    readonly maxCount: number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    _aq(a: number, b: number, c: number, d: number, e?: boolean): {
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _aj(a: number): WorksheetRow;
    /**
     * @hidden
     */
    _ar(a: number, b: number, c: number, d: number, e?: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _ap(a: number, b: number, c: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    _as(a: HiddenRowCollection): void;
    /**
     * Inserts one or more rows into the collection
     * <para class="note"><b>Note:</b> An equal number of rows will be removed (i.e. bumped) off the end of the collection.</para>
     * @param index the insertion point
     * @param count The number of rows to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insert(index: number, count?: number): void;
    /**
     * @hidden
     */
    private _au;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    remove(item: WorksheetRow): boolean;
    /**
     * Removes one or more rows from the collection
     * @param index the index of the first row to remove point
     * @param count The number of rows to remove
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    remove(index: number, count?: number): void;
    /**
     * @hidden
     */
    _remove1(a: number, b?: number): void;
    /**
     * @hidden
     */
    private _ay;
    /**
     * @hidden
     */
    _az(a: boolean): void;
    /**
     * @hidden
     */
    _a0(a: number, b: boolean): void;
    /**
     * @hidden
     */
    private static _a1;
    /**
     * @hidden
     */
    private static _a2;
    /**
     * @hidden
     */
    private _a3;
    /**
     * Gets the row at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelRowCount]]
     * or [[Workbook.maxExcel2007RowCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetRow;
}
/**
 * @hidden
 */
export declare abstract class WorksheetElementResizeContext extends Base {
    static $t: Type;
    static b(a: RowColumnBase): WorksheetElementResizeContext;
    static j(a: List$1<IndexRange>, b: number, c: number): List$1<WorksheetElementResizeState>;
    static c(a: Worksheet, b: number, c: number, d: boolean, e?: List$1<IndexRange>): WorksheetElementResizeContext;
    static d(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean, d: number): WorksheetElementResizeContext;
    static e(a: Worksheet, b: number, c: number, d: Nullable$1<boolean>, e: boolean, f?: List$1<IndexRange>): WorksheetElementResizeContext;
    static k(a: Worksheet, b: number, c: number, d: boolean): List$1<IndexRange>;
    static n(a: Worksheet, b: number, c: number, d: Nullable$1<boolean>, e: boolean): List$1<IndexRange>;
    static l(a: Worksheet, b: number, c: number): List$1<WorksheetElementResizeState>;
    static m(a: Worksheet, b: number, c: number, d?: (arg1: WorksheetRow) => boolean): List$1<WorksheetElementResizeState>;
    static o(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean): {
        ret: List$1<WorksheetElementResizeState>;
        p2: boolean;
    };
    static p(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean): {
        ret: List$1<WorksheetElementResizeState>;
        p2: boolean;
    };
    z(a: Worksheet, b: boolean): void;
    y(): void;
    q(a: number): number;
    f(a: number): boolean;
    s(a: number, b?: boolean): number;
    t(a: number, b: number, c?: boolean): number;
    abstract g(a: number): boolean;
    abstract u(a: number, b: boolean): number;
    abstract v(a: number, b: number): number;
    aa(): void;
    ab(): void;
    abstract readonly i: List$1<IndexRange>;
    abstract readonly r: number;
    h: boolean;
    abstract readonly w: number;
    a: Worksheet;
    x: number;
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_ChartShiftInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: WorksheetChart, c: Tuple$2<IChartObject, any>[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetChart;
    readonly a: Tuple$2<IChartObject, any>[];
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetShapeCollection, c: WorksheetShape, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetShapeCollection;
    readonly a: WorksheetShape;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export interface IMultiChartContext {
    charts(): IEnumerable$1<WorksheetChart>;
}
/**
 * @hidden
 */
export declare let IMultiChartContext_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_ChartShiftContext extends ValueType implements IChangeInfoContext, IMultiChartContext {
    static $t: Type;
    constructor(a: number, b: WorksheetShapeCollection, c: WorksheetShapeCollection_ChartShiftInfo[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetShapeCollection;
    readonly a: WorksheetShapeCollection_ChartShiftInfo[];
    c(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
    private _charts;
    charts(): IEnumerable$1<WorksheetChart>;
}
/**
 * A collection of [[WorksheetShape]] instances in a [[Worksheet]]
 * or [[WorksheetShapeGroup]].
 * @see@see */
export declare class WorksheetShapeCollection extends Base implements ICollection$1<WorksheetShape> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    static _t: List$1<Tuple$2<IChartObject, any>>;
    /**
     * @hidden
     */
    static _s: List$1<WorksheetShapeCollection_ChartShiftInfo>;
    /**
     * @hidden
     */
    _e: IWorksheetShapeOwner;
    private _u;
    static staticInit(): void;
    constructor(a: IWorksheetShapeOwner);
    /**
     * @hidden
     */
    copyTo(array: WorksheetShape[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetShape): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetShape>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetShape>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a predefined shape to the collection with the specified bounds.
     * @param shapeType The type of shape to add to the collection.
     * @param sheet The [[sheet]] to which the 'boundsInTwips' relate.
     * @param boundsInTwips The bounds of the shape on the 'sheet' in twips (1/20th of a point).
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, sheet: Sheet, boundsInTwips: IgRect): WorksheetShape;
    /**
     * Adds a predefined shape to the collection with the specified anchors.
     * @param shapeType The type of shape to add to the collection.
     * @param topLeftCornerCell The cell where the top-left corner of the shape resides.
     * @param topLeftCornerPosition The position in the 'topLeftCornerCell' of the shape's top-left corner,
     * expressed in percentages.
     * @param bottomRightCornerCell The cell where the bottom-right corner of the shape resides.
     * @param bottomRightCornerPosition the position in the 'bottomRightCornerCell' of the shape's bottom-right
     * corner, expressed in percentages.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' or 'bottomRightCornerCell' is null.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' and 'bottomRightCornerCell' belong to different worksheets or a worksheet other
     * than the worksheet to which this collection belongs.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, topLeftCornerCell: WorksheetCell, topLeftCornerPosition: IgPoint, bottomRightCornerCell: WorksheetCell, bottomRightCornerPosition: IgPoint): WorksheetShape;
    /**
     * Adds a predefined shape to the collection with the specified bounds.
     * @param shapeType The type of shape to add to the collection.
     * @param boundsInTwips The bounds of the shape on the [[Worksheet]] in twips (1/20th of a point).
     * @throws [[InvalidOperationException]] This shapes collection belongs to a [[WorksheetShapeGroup]] which isn't placed on a Worksheet yet. In this case,
     * call [[add]] instead and specify the Worksheet where the group will be added.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, boundsInTwips: IgRect): WorksheetShape;
    /**
     * Adds a shape to the collection.
     * @param shape The shape to add to the collection.
     * @throws [[ArgumentNullException]] 'shape' is null.
     * @throws [[InvalidOperationException]] 'shape' has already been added to a worksheet or group.
     * @throws [[InvalidOperationException]] 'shape' does not have the [[WorksheetShape.topLeftCornerCell]]
     * or [[WorksheetShape.bottomRightCornerCell]] set.
     * @throws [[InvalidOperationException]] Adding 'shape' to this collection will place it on a different worksheet then either its
     * TopLeftCornerCell or BottomRightCornerCell or 'shape' is a [[WorksheetShapeGroup]]
     * and adding it to this collection will create a similar situation for one of its descendant shapes.
     * @throws [[InvalidOperationException]] 'shape' is a WorksheetShapeGroup and this is the group's collection of shapes.
     */
    add(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    _add2(a: PredefinedShapeType, b: Rect): WorksheetShape;
    /**
     * @hidden
     */
    _add(a: PredefinedShapeType, b: Sheet, c: Rect): WorksheetShape;
    /**
     * @hidden
     */
    _add1(a: PredefinedShapeType, b: WorksheetCell, c: Point, d: WorksheetCell, e: Point): WorksheetShape;
    /**
     * @hidden
     */
    _add3(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _add4(a: WorksheetShape, b: boolean, c?: (arg1: WorksheetChart) => void): void;
    /**
     * @hidden
     */
    private _ai;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param sheet The [[sheet]] to which the 'boundsInTwips' relate.
     * @param boundsInTwips The bounds of the shape on the 'sheet' in twips (1/20th of a point).
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[ArgumentNullException]] if sheet is null.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, sheet: Sheet, boundsInTwips: IgRect, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param topLeftCornerCell The cell where the top-left corner of the shape resides.
     * @param topLeftCornerPosition The position in the 'topLeftCornerCell' of the shape's top-left corner,
     * expressed in percentages.
     * @param bottomRightCornerCell The cell where the bottom-right corner of the shape resides.
     * @param bottomRightCornerPosition the position in the 'bottomRightCornerCell' of the shape's bottom-right
     * corner, expressed in percentages.
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' or 'bottomRightCornerCell' is null.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' and 'bottomRightCornerCell' belong to different worksheets or a worksheet other
     * than the worksheet to which this collection belongs.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, topLeftCornerCell: WorksheetCell, topLeftCornerPosition: IgPoint, bottomRightCornerCell: WorksheetCell, bottomRightCornerPosition: IgPoint, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param boundsInTwips The bounds of the shape on the worksheet in twips (1/20th of a point).
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[ArgumentNullException]] if worksheet is null.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, boundsInTwips: IgRect, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart2(a: ChartType, b: Rect, c?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart(a: ChartType, b: Sheet, c: Rect, d?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart1(a: ChartType, b: WorksheetCell, c: Point, d: WorksheetCell, e: Point, f?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Clears all shapes from the collection.
     */
    clear(): void;
    /**
     * Determines whether a shape is in the collection.
     * @param shape The shape to locate in the collection.
     * @return True if the shape is found; False otherwise.
     */
    contains(shape: WorksheetShape): boolean;
    /**
     * Removes the specified shape from the collection.
     * @param shape The shape to remove from the collection.
     * @return True if the shape was successfully removed from the collection;
     * False if the shape did not exist in the collection.
     */
    remove_1(shape: WorksheetShape): boolean;
    /**
     * Removes the shape at the specified index from the collection.
     * @param index The index of the shape to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _ag(): void;
    /**
     * @hidden
     */
    _al(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _ao(): void;
    /**
     * @hidden
     */
    _ah(a: (arg1: WorksheetShape) => void): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aj;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _aq;
    /**
     * Gets the number of shapes in the collection.
     * The number of shapes in the collection.
     */
    readonly count: number;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetShape;
    /**
     * @hidden
     */
    readonly _p: boolean;
    /**
     * @hidden
     */
    readonly _q: boolean;
    /**
     * @hidden
     */
    readonly _f: IWorksheetShapeOwner;
    /**
     * @hidden
     */
    readonly _g: Sheet;
}
/**
 * @hidden
 */
export declare class WorksheetCellAddress extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly b: WorksheetCellAddress;
    private readonly l;
    private readonly n;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    a(): WorksheetCellAddress;
    p(a: boolean, b: boolean, c: WorkbookFormat, d: CellReferenceMode): string;
    c(a: number): WorksheetCellAddress;
    d(a: number): WorksheetCellAddress;
    readonly m: number;
    readonly e: boolean;
    readonly o: number;
    static f(a: WorksheetCellAddress, b: WorksheetCellAddress): boolean;
    static g(a: Nullable$1<WorksheetCellAddress>, b: Nullable$1<WorksheetCellAddress>): boolean;
    static h(a: WorksheetCellAddress, b: WorksheetCellAddress): boolean;
    static i(a: Nullable$1<WorksheetCellAddress>, b: Nullable$1<WorksheetCellAddress>): boolean;
}
/**
 * Represents a comment for a cell.
 * <p class="body">
 * Comments cannot be added to a worksheet's or a shape group's shapes collection. Instead, they must be set directly on the cell
 * with the cell's [[WorksheetCell.comment]] property.
 * </p>
 * <p class="body">
 * It is not required that the anchors of this shape be initialized before setting it as the comment of a cell. If the
 * [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]] anchors are both null when
 * the comment is applied to a cell, default anchor cells will be used based on the cell.
 * </p>
 */
export declare class WorksheetCellComment extends WorksheetShape implements IFormattedStringOwner, IWorkbookFontDefaultsResolver {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d6: number;
    /**
     * @hidden
     */
    static readonly _d5: number;
    /**
     * @hidden
     */
    static readonly _d8: number;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    private static readonly _dv;
    private _d9;
    private _d1;
    private _d0;
    private _eb;
    private _d3;
    private _dy;
    constructor();
    constructor(shapeWithText: WorksheetShapeWithText);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    private _ed;
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    protected get__a8(): boolean;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _c3(): void;
    /**
     * @hidden
     */
    _c4(a: WorksheetCell, b: WorksheetCellAddress, c: WorksheetCellAddress): void;
    /**
     * @hidden
     */
    _r(a: CellShiftOperation, b: boolean, c: WorksheetRegionAddress): {
        ret: ShiftAddressResult;
        p2?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _dc(): void;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _dh(a: ShapePositioningMode): void;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * @hidden
     */
    readonly allowDefaultValues: boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    resolveDefaults(font: WorkbookFontData): void;
    /**
     * @hidden
     */
    _ee(): void;
    /**
     * @hidden
     */
    private static _dx;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * Gets or sets the author of the comment.
     * <p class="body">
     * This information is not displayed in the Microsoft Excel UI and is for informational purposes only.
     * </p>
     * The author of the comment.
     */
    /**
    * Gets or sets the author of the comment.
    * <p class="body">
    * This information is not displayed in the Microsoft Excel UI and is for informational purposes only.
    * </p>
    * The author of the comment.
    */
    author: string;
    /**
     * Gets the cell to which the comment is applied.
     * The cell to which the comment is applied.
     * @see [[WorksheetCell.comment]]
     */
    /**
    * Gets the cell to which the comment is applied.
    * The cell to which the comment is applied.
    * @see [[WorksheetCell.comment]]
    */
    cell: WorksheetCell;
    /**
     * @hidden
     */
    readonly _d4: WorksheetCellAddress;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ec: number;
    /**
     * Gets or sets the formatted text of the comment.
     * <p class="body">
     * Getting the value of this property will always return a non-null value. If null is set on the property, it will subsequently
     * return an empty formatted string.
     * </p>
     * The formatted text of the comment.
     */
    /**
    * Gets or sets the formatted text of the comment.
    * <p class="body">
    * Getting the value of this property will always return a non-null value. If null is set on the property, it will subsequently
    * return an empty formatted string.
    * </p>
    * The formatted text of the comment.
    */
    text: FormattedString;
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange extends WorksheetElementResizeContext {
    static $t: Type;
    static ac: WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange;
    private ae;
    private ad;
    private af;
    constructor();
    y(): void;
    ag(a: RowColumnBase): void;
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    readonly i: List$1<IndexRange>;
    protected get_r(): number;
    readonly r: number;
    protected get_w(): number;
    readonly w: number;
}
/**
 * @hidden
 */
export declare class WorksheetColumnBlock extends Base {
    static $t: Type;
    private a;
    private o;
    private e;
    private p;
    private l;
    private s;
    private f;
    constructor(a: number, b: number, c: number, d: WorksheetCellFormatData);
    constructor(a: number, b: number, c: number, d: WorksheetColumnBlock);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    c(a: Workbook): WorksheetColumnBlock;
    d(a: Workbook, b: number, c: number): WorksheetColumnBlock;
    g(a: number): boolean;
    n(a: Worksheet, b: WorksheetColumnWidthUnit, c?: boolean): number;
    x(a: FormatLimitErrors, b: WorkbookFormat): void;
    b: WorksheetCellFormatData;
    readonly t: number;
    q: number;
    i: boolean;
    j: boolean;
    readonly k: boolean;
    r: number;
    m: number;
    v: number;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatBlock extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: WorksheetCellFormatData[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: number;
    readonly a: WorksheetCellFormatData[];
}
/**
 * @hidden
 */
export declare class Worksheet_FontNameHeightPair extends ValueType {
    static $t: Type;
    constructor(a: number, b: string, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: number;
    readonly b: string;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class CellSizeMeasurementContext extends Base {
    static $t: Type;
    private readonly b;
    private readonly d;
    private readonly c;
    private readonly a;
    constructor(a: Workbook, b: TextMetricsProviderBase);
    e(a: WorksheetCellFormatData, b: string, c: number, d: number): number;
    k(a: WorksheetCellFormatData): number;
    l(a: WorksheetCellFormatData, b: string, c: number): number;
    private static j;
    private f;
    private m;
    private g;
    private h;
    private static i;
}
/**
 * @hidden
 */
export declare class CellDataContext extends Base {
    static $t: Type;
    private c;
    private i;
    private k;
    private q;
    private m;
    private g;
    private e;
    constructor(a: number, b: WorksheetCellBlock, c: WorksheetCellFormatData, d: boolean, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue);
    readonly d: WorksheetCellBlock;
    j: WorksheetCellFormatData;
    readonly l: boolean;
    readonly r: number;
    readonly n: boolean;
    readonly o: boolean;
    readonly h: WorksheetCellBlock_DataType;
    readonly f: WorksheetCellBlock_CellValue;
    readonly p: boolean;
    s(a: WorksheetRow): any;
    t(a: WorksheetRow): any;
    private static a;
    u(): void;
    static b(a: number, b: WorksheetCellBlock, c: WorksheetCellFormatData, d: boolean, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue): CellDataContext;
}
/**
 * @hidden
 */
export declare abstract class WorksheetCellBlock extends Base {
    static $t: Type;
    private readonly v;
    constructor(a: number);
    protected abstract h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    abstract al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected abstract e(a: number): WorksheetCellBlock_CellValue;
    protected abstract f(a: number): WorksheetCellBlock_DataType;
    protected abstract am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    abstract r(a: number): boolean;
    protected abstract an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    protected abstract aq(a: number, b: WorksheetCellBlock_DataType): void;
    abstract ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    abstract at(a: number, b: boolean): void;
    private static o;
    static q(a: string): boolean;
    static u(a: any): boolean;
    static ax(a: any): void;
    static az(a: IRegionBlockingValue, b: WorksheetRegion, c: WorksheetRegion): void;
    static a0(a: any): void;
    aj(a: WorksheetRow, b: number): void;
    i(a: WorksheetRow, b: number): boolean;
    j(a: number): boolean;
    k(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        ret: boolean;
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    m(a: number): boolean;
    n(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        ret: boolean;
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    l(a: WorksheetCellBlock_DataType, b: WorksheetCellBlock_CellValue): boolean;
    y(a: WorksheetRow, b: number, c?: boolean): any;
    b(a: WorksheetRow, b: number, c: GetCellTextParameters): GetCellTextResult;
    static a(a: Worksheet, b: WorksheetRow, c: number, d: GetCellTextParameters, e: any): GetCellTextResult;
    z(a: WorksheetRow, b: number): any;
    c(a: WorksheetRow, b: number): StringElement;
    ai(a: WorksheetRow, b: number, c: WorksheetCellBlock_DataType, d: WorksheetCellBlock_CellValue): StringBuilder;
    ac(a: WorksheetRow, b: number, c: WorksheetCellBlock_DataType, d: WorksheetCellBlock_CellValue): {
        ret: any;
        p2: WorksheetCellBlock_DataType;
        p3: WorksheetCellBlock_CellValue;
    };
    aa(a: WorksheetRow, b: number, c?: WorkbookSaveManager): any;
    ab(a: WorksheetRow, b: number, c: WorkbookSaveManager, d: WorksheetCellBlock_DataType, e: WorksheetCellBlock_CellValue): any;
    private ad;
    static ah(a: any): string;
    private g;
    p(a: WorksheetRow, b: number): boolean;
    static s(a: any): boolean;
    as(a: WorksheetRow, b: number, c: boolean, d: WorksheetCellBlock, e?: boolean): {
        p3: WorksheetCellBlock;
    };
    ao(a: WorksheetRow, b: number, c: any, d: WorksheetCellBlock, e?: boolean, f?: boolean): {
        p3: WorksheetCellBlock;
    };
    ap(a: WorksheetRow, b: number, c: any, d: any, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue, g: WorksheetCellBlock, h?: boolean): {
        p6: WorksheetCellBlock;
    };
    av(a: number, b: StringElement): void;
    private aw;
    ay(a: WorksheetRow, b: number, c: any, d: any, e: boolean): void;
    private ak;
    private x;
    private d;
    private af;
    private ae;
    private ag;
    private au;
    private static t;
    readonly w: number;
}
/**
 * Represents a merged region of cells, or cells which share a value and format and appear as one cell when
 * viewed in Microsoft Excel.
 * <p class="body">
 * Merged cell regions cannot overlap (a cell can only belong to one merged cell region). In addition,
 * [[ArrayFormula]] and [[WorksheetDataTable]] instances cannot be applied to merged cell
 * regions.
 * </p>
 */
export declare class WorksheetMergedCellsRegion extends WorksheetRegion implements ICellFormatOwner, IWorksheetCellFormatProxyOwner {
    static $t: Type;
    private _au;
    private _ay;
    /**
     * @hidden
     */
    static _aw: WorksheetMergedCellsRegion;
    constructor(a: Worksheet, b: number, c: number, d: number, e: number);
    /**
     * @hidden
     */
    readonly cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    readonly hasCellFormat: boolean;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    _aj(a: Formula, b: WorksheetRow, c: number, d?: ApplyFormulaFlags): {
        p1?: WorksheetRow;
        p2?: number;
    };
    /**
     * @hidden
     */
    _d(a: CellShiftOperation, b: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    _al(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    private static _a3;
    /**
     * @hidden
     */
    private static _a4;
    /**
     * @hidden
     */
    _a1(a: Nullable$1<CellFormatValue>, b: boolean): Dictionary$2<CellFormatValue, any>;
    /**
     * @hidden
     */
    static _a0(a: Worksheet, b: WorksheetRegionAddress, c: Nullable$1<CellFormatValue>, d: boolean): Dictionary$2<CellFormatValue, any>;
    /**
     * Gets the resolved cell formatting for this merged cell region.
     * <p class="body">
     * If any cell format properties are the default values on the merged cell region, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
     * @see [[cellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _a5(a: boolean): void;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    _a7(a: WorksheetRow, b: number, c: CellFormatValue): void;
    /**
     * @hidden
     */
    _a8(): void;
    /**
     * @hidden
     */
    _a9(): void;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _bb;
    /**
     * Gets the cell formatting for the merged cell region.
     * The cell formatting for the merged cell region.
     */
    readonly cellFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    readonly _hasCellFormat: boolean;
    /**
     * @hidden
     */
    readonly _cellFormatInternal: WorksheetCellFormatProxy;
    /**
     * Gets or sets the comment for the merged cells region.
     * <p class="body">
     * The comment of the merged region can also be accessed from the top-left cell of the merged region of cells.
     * </p>
     * The comment for the merged cells region.
     */
    /**
    * Gets or sets the comment for the merged cells region.
    * <p class="body">
    * The comment of the merged region can also be accessed from the top-left cell of the merged region of cells.
    * </p>
    * The comment for the merged cells region.
    */
    comment: WorksheetCellComment;
    /**
     * Gets the formula which has been applied to the merged region.
     * The formula which has been applied to the merged region or null if no formula has been applied.
     */
    readonly formula: Formula;
    /**
     * @hidden
     */
    readonly _az: boolean;
    /**
     * Gets or sets the value of the merged cell region.
     * <p class="body">The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the merged cell region.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @see [[WorksheetCell.value]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     */
    /**
    * Gets or sets the value of the merged cell region.
    * <p class="body">The types supported for the value are:
    * <BR/>
    * <ul>
    * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
    * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
    * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
    * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
    * </ul>
    * </p>
    * The value of the merged cell region.
    * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
    * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
    * should be called on the Formula, passing in the cell.
    * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
    * should be set to a region containing the cell.
    * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
    * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
    * @see [[WorksheetCell.value]]
    * @see [[WorksheetCell.isCellTypeSupported]]
    */
    value: any;
}
/**
 * Class which exposes the display options which can only be controlled through the worksheet.
 * @see [[Worksheet.displayOptions]]
 * @see [[CustomViewDisplayOptions]]
 */
export declare class WorksheetDisplayOptions extends DisplayOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _b5;
    private _b8;
    private _cb;
    private _by;
    private _b0;
    private _bx;
    private _b2;
    constructor(a: Worksheet, b: boolean);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    readonly _j: boolean;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _bq(a: WorksheetView): void;
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    private _b4;
    /**
     * @hidden
     */
    private _ch;
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in normal view.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in normal view.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInPageBreakView]]
     * @see [[magnificationInPageLayoutView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    /**
    * Gets or sets the magnification level of the worksheet when it is displayed in normal view.
    * <p class="body">
    * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
    * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
    * </p>
    * The magnification level of the worksheet when it is displayed in normal view.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
    * @see [[magnificationInPageBreakView]]
    * @see [[magnificationInPageLayoutView]]
    * @see [[DisplayOptions.view]]
    * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
    */
    magnificationInNormalView: number;
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in the page break preview.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in the page break preview.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInNormalView]]
     * @see [[magnificationInPageLayoutView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    /**
    * Gets or sets the magnification level of the worksheet when it is displayed in the page break preview.
    * <p class="body">
    * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
    * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
    * </p>
    * The magnification level of the worksheet when it is displayed in the page break preview.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
    * @see [[magnificationInNormalView]]
    * @see [[magnificationInPageLayoutView]]
    * @see [[DisplayOptions.view]]
    * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
    */
    magnificationInPageBreakView: number;
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in page layout view.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in page layout view.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInNormalView]]
     * @see [[magnificationInPageBreakView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    /**
    * Gets or sets the magnification level of the worksheet when it is displayed in page layout view.
    * <p class="body">
    * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
    * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
    * </p>
    * The magnification level of the worksheet when it is displayed in page layout view.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
    * @see [[magnificationInNormalView]]
    * @see [[magnificationInPageBreakView]]
    * @see [[DisplayOptions.view]]
    * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
    */
    magnificationInPageLayoutView: number;
    /**
     * Gets or sets the value indicating whether the columns are ordered right to left.
     * <p class="body">
     * If the columns are ordered right to left, other aspects of the worksheet display differently. The vertical scrollbar
     * will display on the left side of the worksheet and the worksheet tab bar, usually displayed on the left side of the
     * worksheet, will display on the right side.
     * </p>
     * The value indicating whether the columns are ordered right to left.
     */
    /**
    * Gets or sets the value indicating whether the columns are ordered right to left.
    * <p class="body">
    * If the columns are ordered right to left, other aspects of the worksheet display differently. The vertical scrollbar
    * will display on the left side of the worksheet and the worksheet tab bar, usually displayed on the left side of the
    * worksheet, will display on the right side.
    * </p>
    * The value indicating whether the columns are ordered right to left.
    */
    orderColumnsRightToLeft: boolean;
    /**
     * Gets or sets the value which indicates whether to show whitespace between worksheet pages in page layout view.
     * <p class="note">
     * <B>Note:</B> For this value to affect the display of the worksheet, the [[DisplayOptions.view]] must
     * be set to PageLayout. However, if a different view is used, this is still saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will default to Normal view.
     * </p>
     * The value which indicates whether to show white page between worksheet pages in page layout view.
     * @see [[DisplayOptions.view]]
     */
    /**
    * Gets or sets the value which indicates whether to show whitespace between worksheet pages in page layout view.
    * <p class="note">
    * <B>Note:</B> For this value to affect the display of the worksheet, the [[DisplayOptions.view]] must
    * be set to PageLayout. However, if a different view is used, this is still saved with the workbook.
    * </p>
    * <p class="note">
    * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
    * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will default to Normal view.
    * </p>
    * The value which indicates whether to show white page between worksheet pages in page layout view.
    * @see [[DisplayOptions.view]]
    */
    showWhitespaceInPageLayoutView: boolean;
    /**
     * Gets or sets the [[WorkbookColorInfo]] to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
     * <p class="body">
     * If the tab bar is not visible, this color will not be seen.
     * </p>
     * The WorkbookColorInfo to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
     * @see [[WindowOptions.tabBarVisible]]
     */
    /**
    * Gets or sets the [[WorkbookColorInfo]] to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
    * <p class="body">
    * If the tab bar is not visible, this color will not be seen.
    * </p>
    * The WorkbookColorInfo to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
    * @see [[WindowOptions.tabBarVisible]]
    */
    tabColorInfo: WorkbookColorInfo;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b3: number;
}
/**
 * @hidden
 */
export declare class GetCellTextParameters extends Base {
    static $t: Type;
    constructor(a: number);
    readonly e: number;
    a: PreventTextFormattingTypes;
    b: TextFormatMode;
    g: Nullable$1<boolean>;
    d: () => TextMetricsProviderBase;
    c: boolean;
    f: number;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlock_CellValue extends ValueType {
    static $t: Type;
    constructor();
    private d;
    private e;
    b: number;
    i: number;
    a: WorksheetCellBlock_DataTypeEncoded;
    g: number;
    f: number;
    c: number;
    h: number;
    j(a: StringElement): void;
}
/**
 * @hidden
 */
export declare class GetCellTextResult extends ValueType {
    static $t: Type;
    constructor(a: number, b: string);
    constructor();
    constructor(a: number, ..._rest: any[]);
    g: string;
    e: number;
    a: ValueFormatter_SectionType;
    f: string;
    b: ValueFormatterFlags;
    readonly c: boolean;
    readonly d: boolean;
}
/**
 * @hidden
 */
export declare abstract class WorkbookSerializationManager extends Base implements IDisposable {
    static $t: Type;
    private readonly _c;
    private readonly _k;
    private readonly _d;
    private readonly _a;
    private readonly _e;
    private readonly _f;
    constructor(a: Workbook, b: string);
    dispose(): void;
    protected disposeCore(a: boolean): void;
    readonly _g: List$1<WorksheetCellFormatData>;
    readonly _l: string;
    readonly _h: List$1<WorkbookFontData>;
    readonly _b: Workbook;
    readonly _i: List$1<WorkbookReferenceBase>;
    readonly _j: List$1<WorksheetReference>;
}
/**
 * @hidden
 */
export interface IColorFilterVisitor$2<TArg, TResult> {
    _visitFillFilter$i(a: FillFilter, b: TArg): TResult;
    _visitFontColorFilter$i(a: FontColorFilter, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorFilterVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare abstract class WorkbookSaveManager extends WorkbookSerializationManager implements IColorFilterVisitor$2<boolean, WorksheetCellFormatData> {
    static $t: Type;
    private readonly _au;
    private readonly _ai;
    private readonly _aj;
    private _a8;
    private readonly _ak;
    private readonly _al;
    private readonly _an;
    private readonly _ao;
    private readonly _a0;
    private readonly _ap;
    private _a9;
    private _ab;
    private _ac;
    private readonly _am;
    private readonly _ay;
    private readonly _x;
    private readonly _t;
    readonly _aq: Dictionary$2<Formula, string>;
    constructor(a: Workbook, b: string, c: WorkbookSaveOptions);
    _visitFillFilter$i(a: FillFilter, b: boolean): WorksheetCellFormatData;
    _visitFontColorFilter$i(a: FontColorFilter, b: boolean): WorksheetCellFormatData;
    abstract _a6(a: WorksheetCellFormatData): number;
    abstract _a7(a: WorkbookStyle): number;
    abstract _bk(): void;
    protected abstract _p(): WorkItem;
    _ba(a: WorksheetCellFormatData): number;
    _bd(a: WorkbookFontProxy, b: IWorkbookFontDefaultsResolver): void;
    _y(a: IColorFilter): WorksheetCellFormatData;
    _ad(a: WorksheetColumnBlock): boolean;
    _bf<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: WorkbookStyle, d: WorksheetCellFormatData): {
        p2: WorkbookStyle;
        p3: WorksheetCellFormatData;
    };
    _bg<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: WorkbookStyle, d: WorksheetCellFormatData, e: WorksheetCellFormatData, ...f: CellFormatValue[]): {
        p2: WorkbookStyle;
        p3: WorksheetCellFormatData;
        p4: WorksheetCellFormatData;
    };
    _a2(a: WorksheetTableColumn): Nullable$1<number>;
    _av(a: Worksheet): IEnumerable$1<WorksheetMergedCellsRegion>;
    _z(a: WorksheetShape): WorksheetShape;
    _aw(a: Worksheet, b?: boolean): IEnumerable$1<WorksheetRow>;
    _w(a: Worksheet): WorksheetSerializationCache;
    _s(a: Sheet): SheetSerializationCache;
    _u(a: WorksheetRow): WorksheetRowSerializationCache;
    _a3(a: WorksheetRow, b: CellDataContext, c?: boolean): any;
    private static _a4;
    private __ax;
    _ax(): IEnumerable$1<StringElement>;
    _aa(a: WorksheetTableStyle): SortedList$2<WorksheetTableStyleArea, number>;
    _ae(a: Worksheet): boolean;
    _o(): WorkItem;
    static _b5(a: WorksheetHyperlink, b: string, c: string, d: string): {
        p1: string;
        p2: string;
        p3: string;
    };
    protected _bo(a: IWorksheetImage): void;
    protected _b4(a: WorksheetShape): {
        p0?: WorksheetShape;
    };
    protected _bl(a: Worksheet): void;
    protected _bm(a: Worksheet): void;
    private _be;
    private static _ar;
    _bj(a: FormattedText, b: IWorkbookFontDefaultsResolver): void;
    private _bn;
    private _bp;
    private _bq;
    _br(): void;
    private _bs;
    private _bh;
    private _bt;
    private _bu;
    private _bv;
    private _bx;
    private _bw;
    private _bi;
    private _by;
    private _bz;
    private _af;
    private _v;
    private _b0;
    private _b1;
    private _b2;
    private _b3;
    protected abstract readonly _ag: boolean;
    readonly _bb: number;
    readonly _as: Dictionary$2<StringBuilder, number>;
    readonly _at: Dictionary$2<WorkbookStyle, number>;
    readonly _a1: number;
    readonly _bc: number;
    readonly _az: IList$1<Sheet>;
    protected readonly _ah: boolean;
    protected get__r(): CellContext;
    protected set__r(a: CellContext): void;
    _r: CellContext;
    protected get__q(): CellDataContext;
    protected set__q(a: CellDataContext): void;
    _q: CellDataContext;
}
/**
 * @hidden
 */
export declare class StringElementIndex extends Base {
    static $t: Type;
    c: number;
    constructor(a: number);
    private static a;
    static b(a: number): StringElementIndex;
    d(): void;
}
/**
 * A collection of cells in a row.
 * <p class="body">
 * Cells in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the cells which were already accessed.
 * </p>
 * @see [[WorksheetCell]]
 * @see [[WorksheetRow.cells]]
 */
export declare class WorksheetCellCollection extends RowColumnCollectionBase$1<WorksheetCell> {
    static $t: Type;
    private _ai;
    private _ah;
    constructor(a: WorksheetRow);
    /**
     * @hidden
     */
    protected get__count(): number;
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<WorksheetCell>;
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetCell;
    /**
     * @hidden
     */
    private __p;
    _p(): IEnumerator$1<WorksheetCell>;
    /**
     * @hidden
     */
    private __n;
    _n(a: number, b: number, c: boolean): IEnumerable$1<WorksheetCell>;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetCell): number;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetCell, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetCell): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    readonly maxCount: number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _aj(): void;
    /**
     * Gets the cell at the specified column index in the owning row.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The cell at the specified column index in the owning row.
     * @param index The zero-based column index of the cell to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetCell;
    /**
     * @hidden
     */
    _h(a: number): WorksheetCell;
}
/**
 * @hidden
 */
export declare class DependencyGraph_StronglyConnectedComponentSorter extends Base implements IComparer$1<RefBase> {
    static $t: Type;
    static readonly _a: DependencyGraph_StronglyConnectedComponentSorter;
    constructor();
    compare(a: RefBase, b: RefBase): number;
}
/**
 * @hidden
 */
export declare abstract class NamedCalcReferenceBase extends RefBase {
    static $t: Type;
    protected get__ao(): number;
    readonly _ao: number;
    protected get__aj(): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
}
/**
 * @hidden
 */
export declare class NamedCalcReference extends NamedCalcReferenceBase {
    static $t: Type;
    private _a4;
    private _a2;
    constructor(a: NamedReference);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    _az(a: SingleTargetFormula): void;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    readonly _a3: NamedReference;
}
/**
 * @hidden
 */
export declare class ExcelReferenceError extends RefBase {
    static $t: Type;
    static readonly _a2: ExcelReferenceError;
    constructor();
    _au(a: RefBase): void;
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class WorksheetDataTableCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetDataTableCollection, c: WorksheetDataTable, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetDataTableCollection;
    readonly a: WorksheetDataTable;
    readonly d: number;
    readonly c: WorksheetRegionAddress;
    readonly e: Nullable$1<WorksheetCellAddress>;
    readonly f: Nullable$1<WorksheetCellAddress>;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[WorksheetDataTable]] instances on a worksheet.
 */
export declare class WorksheetDataTableCollection extends Base implements ICollection$1<WorksheetDataTable> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _h;
    /**
     * @hidden
     */
    _d: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    add(item: WorksheetDataTable): void;
    /**
     * Creates a new data table and adds it to the collection.
     * <p class="body">
     * The input cells specified must be different cell references and at least one must be non-null.
     * See the [[WorksheetDataTable]] overview for more information on data tables.
     * </p>
     * @param cellsInTable The region of cells in the data table.
     * @param columnInputCell The cell used as the column-input cell in the data table.
     * @param rowInputCell The cell used as the row-input cell in the data table.
     * @throws [[ArgumentNullException]] 'cellsInTable' is null.
     * @throws [[ArgumentException]] 'cellsInTable' is a region which does not belongs to the worksheet which owns this collection.
     * @throws [[ArgumentException]] 'columnInputCell' is not null but does not belong to the worksheet which owns this collection.
     * @throws [[ArgumentException]] 'rowInputCell' is not null but does not belong to the worksheet which owns this collection.
     * @throws [[InvalidOperationException]] Both 'columnInputCell' and 'rowInputCell' are null.
     * @throws [[InvalidOperationException]] 'columnInputCell' and 'rowInputCell' are the same cell.
     * @throws [[InvalidOperationException]] 'columnInputCell' or 'rowInputCell' are contained in the
     * 'cellsInTable' region.
     * @throws [[InvalidOperationException]] One or more of the interior cells of the 'cellsInTable' region (all cells except the left-most column
     * and top row) is an interior cell of another data table or is a cell in an array formula, and the entire
     * range of that other entity extends outside the interior cells of 'cellsInTable'.
     * @return The newly created data table.
     */
    add(cellsInTable: WorksheetRegion, columnInputCell: WorksheetCell, rowInputCell: WorksheetCell): WorksheetDataTable;
    /**
     * @hidden
     */
    _add$e(a: WorksheetDataTable): void;
    /**
     * @hidden
     */
    contains(item: WorksheetDataTable): boolean;
    /**
     * @hidden
     */
    copyTo(array: WorksheetDataTable[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetDataTable): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetDataTable>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetDataTable>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: WorksheetRegion, b: WorksheetCell, c: WorksheetCell): WorksheetDataTable;
    /**
     * Clears all data tables from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     */
    clear(): void;
    /**
     * Removes the specified data table from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     * @param dataTable The data table to remove from the collection.
     * @return True if the dataTable was successfully removed; False if the dataTable was not in the collection.
     */
    remove_1(dataTable: WorksheetDataTable): boolean;
    /**
     * Removes the data table at the specified index from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     * @param index The zero-based index of the data table to remove from the collection.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of data tables in the collection.
     * The number of data tables in the collection.
     */
    readonly count: number;
    /**
     * Gets the data table at the specified index in the collection.
     * The data table at the specified index.
     * @param index The zero-based index of the data table to get.
     */
    item(a: number): WorksheetDataTable;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnCollection_CollectionChangeContextData);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: WorksheetColumnCollection_CollectionChangeContextData;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of columns in a worksheet.
 * <p class="body">
 * Columns in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * Therefore, if this collection is enumerated, it only enumerates the columns which were already accessed.
 * </p>
 * @see [[WorksheetColumn]]
 * @see [[Worksheet.columns]]
 */
export declare class WorksheetColumnCollection extends RowColumnCollectionBase$1<WorksheetColumn> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static _ag;
    private _ak;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetColumn;
    /**
     * @hidden
     */
    _p(): IEnumerator$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetColumn): number;
    /**
     * @hidden
     */
    _n(a: number, b: number, c: boolean): IEnumerable$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetColumn, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetColumn): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    readonly maxCount: number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private _al;
    /**
     * @hidden
     */
    _aq(a: number, b: number, c: number, d: number, e?: boolean): {
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _ar(a: number, b: number, c: number, d: number, e?: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _as(a: HiddenColumnCollection): void;
    /**
     * Inserts one or more columns into the collection
     * <para class="note"><b>Note:</b> An equal number of columns will be removed (i.e. bumped) off the end of the collection.</para>
     * @param index the insertion point
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insert(index: number, count?: number): void;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    _au(a: WorksheetColumn[], b: WorksheetColumnBlock[]): void;
    /**
     * @hidden
     */
    remove(item: WorksheetColumn): boolean;
    /**
     * Removes one or more columns from the collection
     * @param index the index of the first column to remove point
     * @param count The number of columns to remove
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    remove(index: number, count?: number): void;
    /**
     * @hidden
     */
    _remove1(a: number, b?: number): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    private _ax;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * @hidden
     */
    private _az;
    /**
     * @hidden
     */
    private static _a0;
    /**
     * @hidden
     */
    private _a1;
    /**
     * Gets the column at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetColumn;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_HorizontalSorter extends Base implements IComparer$1<WorksheetRegion> {
    static $t: Type;
    static readonly _a: WorksheetRegion_HorizontalSorter;
    constructor();
    compare(a: WorksheetRegion, b: WorksheetRegion): number;
}
/**
 * @hidden
 */
export declare class DependencyGraph_EvaluationEnumerator extends Base implements IEnumerator$1<RefBase> {
    static $t: Type;
    private _b;
    private readonly _a;
    private _d;
    private _c;
    constructor(a: DependencyGraph);
    dispose(): void;
    readonly current: RefBase;
    readonly currentObject: any;
    moveNext(): boolean;
    reset(): void;
    _e(a: HashSet$1<RefBase>): void;
}
/**
 * @hidden
 */
export declare class ObjectPool$2<T, TArg> extends Base {
    static $t: Type;
    protected $t: Type;
    protected $tArg: Type;
    private a;
    private d;
    private c;
    private e;
    constructor($t: Type, $tArg: Type, a: (arg1: TArg) => T, b: (arg1: T, arg2: TArg) => void);
    b(a: TArg): T;
    g(a: T): void;
}
/**
 * Stack of [[ExcelCalcValue]] instances used to evaluate formulas.
 * <p class="body">
 * The number stack is used for evaluating formulas.  When formulas are compiled, the formula tokens are
 * placed in a collection in post-fix, or Reverse Polish Notation (RPN) format.  RPN format arranges the formula token list so each
 * sub-expressions's terms are placed before their operator, and sub-expressions are ordered to enforce correct operator precedence.
 * This format allows the formula evaluate method to loop through the formula token collection front to back pushing an operator's terms onto
 * the number stack until an operator is reached.  Each time an operator is reached, it's subexpression is computed and resulting value pushed
 * onto the number stack.  Once the end of the end of the formula collection is reached, the formulas calculated value is at the top of the
 * number stack.
 * </p>
 */
export declare class ExcelCalcNumberStack extends Base {
    static $t: Type;
    constructor(formulaOwner: IExcelCalcReference, formula: SingleTargetFormula);
    constructor();
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _e(a: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    _f(a: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    _g(a: ExcelCalcValue): ExcelCalcValue;
    private readonly _o;
    private _a;
    private _y;
    private _z;
    /**
     * @hidden
     */
    private _b;
    /**
     * @hidden
     */
    readonly _p: SingleTargetFormula;
    private readonly _m;
    /**
     * @hidden
     */
    readonly _n: TokenClass;
    private readonly _j;
    /**
     * @hidden
     */
    readonly _k: IExcelCalcReference;
    /**
     * @hidden
     */
    _d(a: number): ExcelCalcValue;
    private _t;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _u: boolean;
    /**
     * Gets the [[WorksheetCell]] instance whose formula is currently being solved.
     */
    readonly owningCell: WorksheetCell;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ac(a: ExcelCalcFunction, b: number): void;
    private _q;
    /**
     * @hidden
     */
    readonly _r: Workbook;
    private _v;
    /**
     * @hidden
     */
    private static _l;
    /**
     * @hidden
     */
    static _c(a: any): ExcelCalcValue;
    /**
     * @hidden
     */
    static _ad(a: ExcelCalcValue): void;
    /**
     * Push a value onto number stack.
     * @param value Value to push onto the number stack
     */
    push(value: ExcelCalcValue): void;
    /**
     * Pop value off top of the number stack.
     * @return [[ExcelCalcValue]] that was at the top of the number stack.
     */
    pop(): ExcelCalcValue;
    /**
     * Return value off top of the number stack.
     * @return [[ExcelCalcValue]] that is at the top of the number stack.
     */
    peek(): ExcelCalcValue;
    /**
     * Remove all values from number stack.
     */
    clear(): void;
    /**
     * Clear elements off top of number stack until it contains given number of elements
     * @param elements Denotes the desired stack level
     */
    reset(elements: number): void;
    /**
     * Return the number of values on number stack
     * @return Number of stack values
     */
    count(): number;
    /**
     * @hidden
     */
    readonly _w: CultureInfo;
}
/**
 * @hidden
 */
export declare class FormulaContext extends Base {
    static $t: Type;
    private readonly a;
    private readonly n;
    private readonly g;
    private readonly c;
    private readonly k;
    private readonly e;
    private readonly i;
    constructor(a: number, b: Workbook);
    constructor(a: number, b: Workbook, c: Formula);
    constructor(a: number, b: Formula, c: CellReferenceMode, d: CultureInfo);
    constructor(a: number, b: Workbook, c: Worksheet, d: WorksheetRow, e: number, f: Formula);
    constructor(a: number, b: Sheet, c: number, d: number, e: WorkbookFormat, f: Formula, g?: CultureInfo, h?: CellReferenceMode);
    constructor(a: number, b: Workbook, c: Worksheet, d: WorksheetRow, e: number, f: Formula, g: CultureInfo, h: CellReferenceMode, i: WorkbookFormat);
    constructor(a: number, ..._rest: any[]);
    readonly b: CellReferenceMode;
    readonly o: CultureInfo;
    readonly h: WorkbookFormat;
    readonly d: Formula;
    readonly l: WorksheetCellAddress;
    readonly m: WorksheetRow;
    readonly f: Workbook;
    readonly j: Worksheet;
}
/**
 * @hidden
 */
export declare class FormulaEvaluator extends FormulaTokenVisitor {
    static $t: Type;
    private static a4;
    private a2;
    private a0;
    private a3;
    private a7;
    private bd;
    private az;
    private readonly a6;
    constructor();
    g(): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    v(a: BinaryOperatorToken): void;
    x(a: CellReferenceToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    aj(a: NameToken): void;
    am(a: OperandToken): void;
    ay(a: UnaryOperatorToken): void;
    private a8;
    private be;
    private bf;
    static a5(a: FormulaContext, b: IExcelCalcReference, c: ExcelCalcNumberStack): FormulaEvaluator;
    private a9;
    private bh;
    private bb;
    private bc;
    private a1;
    private ba;
    private bg;
    private bi;
    private bj;
}
/**
 * @hidden
 */
export declare class TempCellCalcReference extends RefBase {
    static $t: Type;
    private _a3;
    private _a9;
    private _a2;
    private _a4;
    private _a5;
    private static _ba;
    constructor(a: boolean, b: Sheet, c: WorksheetCellAddress);
    protected get__x(): boolean;
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    protected get__formula(): SingleTargetFormula;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    _az(a: SingleTargetFormula): void;
    protected get__ak(): boolean;
    protected _a1(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    protected get__u(): Worksheet;
    readonly _a6: boolean;
    readonly _a7: boolean;
    _a8: boolean;
    protected get__as(): number;
    protected get__r(): Sheet;
}
/**
 * @hidden
 */
export declare class CalcUtilities extends Base {
    static $t: Type;
    static i(a: WorksheetRegion, b: IExcelCalcReference): boolean;
    static c(a: any): ExcelCalcValue;
    static b(a: number): ExcelCalcErrorCode;
    static h(a: IExcelCalcReference): TokenClass;
    static e(a: string, b: WorksheetRow, c: number, d: Worksheet, e: Workbook): IExcelCalcReference;
    static f(a: string, b: WorksheetRow, c: number, d: Worksheet, e: Workbook, f: CellReferenceMode): IExcelCalcReference;
    static a(a: WorksheetRegion): ExcelCalcValue[][];
    static l(a: IExcelCalcReference): IList$1<WorksheetRegion>;
    static g(a: CellCalcReference, b: WorksheetRegion, c: ExcelCalcErrorValue): {
        ret: CellCalcReference;
        p2: ExcelCalcErrorValue;
    };
    static m(a: any, b: boolean): any;
    static j(a: WorksheetRegion, b: IExcelCalcReference): boolean;
    static d(a: ArrayProxy, b: CellCalcReference): ExcelCalcValue;
    static k(a: CellCalcReference, b: number, c: number, d: number, e: number): {
        ret: boolean;
        p3: number;
        p4: number;
    };
}
/**
 * @hidden
 */
export declare class DataValidationCalcReference extends CellCalcReferenceBase {
    static $t: Type;
    constructor(a: WorksheetRow, b: number, c: boolean);
    containsReference(a: IExcelCalcReference): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__ak(): boolean;
    protected get__c(): ExcelCalcValue;
    _bc: boolean;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenEvaluator$1<TStackItem> extends FormulaTokenVisitor$1<boolean> {
    static $t: Type;
    protected $tStackItem: Type;
    protected readonly bf: Stack$1<TStackItem>;
    constructor($tStackItem: Type);
    a1(): void;
    r(a: BinaryOperatorToken): boolean;
    t(a: CellReferenceToken): boolean;
    w(a: FunctionOperator): boolean;
    x(a: IFunctionToken): boolean;
    y(a: FunctionVOperator): boolean;
    ai(a: OperandToken): boolean;
    aj(a: ParenToken): boolean;
    al(a: Ref3DToken): boolean;
    am(a: ReferenceToken): boolean;
    aq(a: RefToken): boolean;
    au(a: UnaryOperatorToken): boolean;
    protected a4(a: IFunctionToken, b: string): TStackItem;
    a2(): EvaluationResult$1<TStackItem>;
    a3(a: boolean): EvaluationResult$1<TStackItem>;
    protected abstract a5(a: BinaryOperatorToken, b: TStackItem, c: TStackItem): TStackItem;
    protected abstract a6(a: IFunctionToken, b: TStackItem, c: TStackItem[]): TStackItem;
    protected abstract a7(a: OperandToken): TStackItem;
    protected abstract a8(a: ParenToken, b: TStackItem): TStackItem;
    protected abstract a9(a: UnaryOperatorToken, b: TStackItem): TStackItem;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    readonly bg: Stack$1<TStackItem>;
}
/**
 * @hidden
 */
export declare class FormulaEvaluator_ShouldSplitParameterHelper extends FormulaTokenEvaluator$1<number> {
    static $t: Type;
    private bl;
    private bk;
    private bi;
    private bh;
    private bn;
    private bm;
    constructor();
    a1(): void;
    bj(a: FormulaContext, b: number, c: number, d: boolean): boolean;
    protected a5(a: BinaryOperatorToken, b: number, c: number): number;
    protected a6(a: IFunctionToken, b: number, c: number[]): number;
    protected a7(a: OperandToken): number;
    protected a8(a: ParenToken, b: number): number;
    protected a9(a: UnaryOperatorToken, b: number): number;
    private bo;
}
/**
 * @hidden
 */
export declare class TokenReferenceResolver extends FormulaTokenEvaluator$1<FormulaToken> {
    static $t: Type;
    private static bi;
    private bl;
    private bh;
    private bm;
    constructor();
    protected a5(a: BinaryOperatorToken, b: FormulaToken, c: FormulaToken): FormulaToken;
    protected a6(a: IFunctionToken, b: FormulaToken, c: FormulaToken[]): FormulaToken;
    protected a7(a: OperandToken): FormulaToken;
    protected a8(a: ParenToken, b: FormulaToken): FormulaToken;
    protected a9(a: UnaryOperatorToken, b: FormulaToken): FormulaToken;
    protected get_a(): FormulaToken[];
    a1(): void;
    l(a: AttrChooseToken): boolean;
    m(a: AttrIfToken): boolean;
    n(a: AttrSkipToken): boolean;
    static bj(a: FormulaContext): TokenReferenceResolver;
    static bk(a: FormulaContext, b: FormulaToken[]): TokenReferenceResolver;
}
/**
 * @hidden
 */
export declare class EvaluationResult$1<T> extends ValueType {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: T);
    constructor($t: Type, a: number, b: Nullable$1<number>);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    private readonly a;
    private readonly c;
    private readonly e;
    readonly d: boolean;
    readonly b: T;
    readonly f: Nullable$1<number>;
}
/**
 * @hidden
 */
export declare abstract class SpecialFormulaToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    readonly n: boolean;
}
/**
 * @hidden
 */
export declare class TokenReferenceResolver_SkipTokenInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: AttrSkipToken, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: AttrSkipToken;
    readonly b: number;
}
/**
 * @hidden
 */
export declare class RefBase_DynamicReference extends RefBase {
    static $t: Type;
    private readonly _a2;
    constructor(a: RefBase);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    protected get__aj(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__l(): RefBase;
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__as(): number;
    _az(a: SingleTargetFormula): void;
    _o(): RefBase;
    protected get_value(): ExcelCalcValue;
    protected set_value(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__q(): WorksheetReference;
    protected get__t(): Workbook;
}
/**
 * @hidden
 */
export declare class NamedCalcReferenceUnconnected extends NamedCalcReferenceBase {
    static $t: Type;
    private _a2;
    constructor(a: NamedReferenceUnconnected);
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class EmptyReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    static readonly _a: EmptyReferencesCollection;
    constructor();
    getEnumeratorObject(): IEnumerator;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
}
/**
 * @hidden
 */
export declare class DependencyGraph_FinishTimeSorter extends Base implements IComparer$1<RefBase> {
    static $t: Type;
    static readonly _a: DependencyGraph_FinishTimeSorter;
    constructor();
    compare(a: RefBase, b: RefBase): number;
}
/**
 * @hidden
 */
export declare class ArrayValueContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: WorksheetRow, c: number, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: WorksheetRow;
    readonly b: number;
    readonly c: number;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: ConditionBase, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly b: ConditionalFormatCollection;
    readonly c: ConditionBase;
    readonly a: WorksheetRegionAddress[];
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_PriorityChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: ConditionBase, d: number, e: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: number;
    readonly b: ConditionBase;
    readonly a: ConditionalFormatCollection;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: List$1<Tuple$2<ConditionBase, WorksheetRegionAddress[]>>, d: List$1<Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>>, e: List$1<Tuple$3<ISupportFormulaShifts, any, string>>, f: List$1<ConditionBase>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: ConditionalFormatCollection;
    readonly c: Tuple$2<ConditionBase, WorksheetRegionAddress[]>[];
    readonly d: Tuple$3<ISupportFormulaShifts, any, string>[];
    readonly b: Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>[];
    readonly a: ConditionBase[];
    f(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Collection class for objects which derive from [[ConditionBase]].
 * <p class="body">
 * To enable a conditional format on a <see cref="WorksheetRegion">region</see>
 * of worksheet <see cref="WorksheetCell">cells</see>, add a [[ConditionBase]]-derived
 * instance to this collection.
 * </p>
 * <p class="body">
 * This collection exposes an Add method for each type of conditional format available.
 * </p>
 * <p class="body">
 * For example, to add a conditional format which is based on a value and a logical
 * operator, use the [[addOperatorCondition]]
 * method.
 * </p>
 * <p class="body">
 * The conditional formatting classes which derive from [[ConditionalFormatBase]]
 * expose a <see cref="ConditionalFormatBase.CellFormat">CellFormat</see> property, which
 * in turn exposes properties which control the visual attributes of cells which meet the
 * criteria defined by the condition. This format is applied to cells with a value which
 * passes the condition.
 * </p>
 * @see [[ConditionBase]]
 * @see [[addAverageCondition]]
 * @see [[addBlanksCondition]]
 * @see [[addColorScaleCondition]]
 * @see [[addDataBarCondition]]
 * @see [[addDateTimeCondition]]
 * @see [[addDuplicateCondition]]
 * @see [[addErrorsCondition]]
 * @see [[addFormulaCondition]]
 * @see [[addIconSetCondition]]
 * @see [[addNoBlanksCondition]]
 * @see [[addNoErrorsCondition]]
 * @see [[addOperatorCondition]]
 * @see [[addRankCondition]]
 * @see [[addTextCondition]]
 * @see [[addUniqueCondition]]
 */
export declare class ConditionalFormatCollection extends Base implements IEnumerable$1<ConditionBase> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    static readonly _aq: number;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    private _aa;
    /**
     * @hidden
     */
    _y: Worksheet;
    /**
     * @hidden
     */
    readonly _aj: List$1<ConditionBase>;
    /**
     * @hidden
     */
    static _ag: List$1<Tuple$2<ConditionBase, WorksheetRegionAddress[]>>;
    /**
     * @hidden
     */
    static _ah: List$1<Tuple$3<ISupportFormulaShifts, any, string>>;
    /**
     * @hidden
     */
    static _af: List$1<Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>>;
    /**
     * @hidden
     */
    static _ai: List$1<WorksheetRegionAddress>;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total number of items in the collection.
     */
    readonly count: number;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number): ConditionBase;
    /**
     * @hidden
     */
    readonly _x: Workbook;
    /**
     * @hidden
     */
    readonly _z: Worksheet;
    /**
     * @hidden
     */
    _as(a: ConditionBase, b?: boolean): void;
    /**
     * @hidden
     */
    private _at;
    /**
     * Adds a new [[OperatorConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param conditionOperator A [[FormatConditionOperator]] value which defines the initial value of the [[OperatorConditionalFormat.operator]] property. This parameter is optional and defaults to <i>Equal</i>.
     * @return The resulting [[OperatorConditionalFormat]] instance.
     * @see [[OperatorConditionalFormat]]
     */
    addOperatorCondition(regionAddress: string, conditionOperator?: FormatConditionOperator): OperatorConditionalFormat;
    /**
     * Adds a new [[FormulaConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param formula The formula which is used to determine whether a cell value meets the condition criteria.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @return The resulting [[FormulaConditionalFormat]] instance.
     * @see [[FormulaConditionalFormat]]
     * @see [[FormulaConditionalFormat.formula]]
     * @see [[FormulaConditionalFormat.setFormula]]
     */
    addFormulaCondition(regionAddress: string, formula: string, cellReferenceMode?: CellReferenceMode): FormulaConditionalFormat;
    /**
     * @hidden
     */
    _addFormulaCondition$i(a: string, b: string, c?: Nullable$1<CellReferenceMode>): FormulaConditionalFormat;
    /**
     * Adds a new [[RankConditionalFormat]] instance to this collection.
     * <p class="body">
     * A <i>RankConditionalFormat</i> can be used, for example, to format the "top ten" values in a given cell range.
     * </p>
     * <p class="body">
     * To change the number of top or bottom values, use the [[RankConditionalFormat.rank]] property.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param topBottom A [[FormatConditionTopBottom]] value which determines whether the top or bottom of the ranking is evaluated. This parameter is optional and defaults to <i>Top</i>.
     * @param rank The numeric, percentage, or percentile ranking. This parameter is optional and defaults to <i>10</i>.
     * @return The resulting [[RankConditionalFormat]] instance.
     * @see [[RankConditionalFormat]]
     */
    addRankCondition(regionAddress: string, topBottom?: FormatConditionTopBottom, rank?: number): RankConditionalFormat;
    /**
     * Adds a new [[AverageConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param aboveBelow A [[FormatConditionAboveBelow]] value which defines the initial value of the [[AverageConditionalFormat.aboveBelow]] property. This parameter is optional and defaults to <i>AboveAverage</i>.
     * @return The resulting [[AverageConditionalFormat]].
     * @see [[AverageConditionalFormat]]
     */
    addAverageCondition(regionAddress: string, aboveBelow?: FormatConditionAboveBelow): AverageConditionalFormat;
    /**
     * Adds a new [[UniqueConditionalFormat]] instance to this collection,
     * configured as a unique value condition.
     * <p class="body">
     * Use this method to add a condition which evaluates to true only for cell values which
     * are unique across the associated range.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[UniqueConditionalFormat]] instance.
     * @see [[UniqueConditionalFormat]]
     * @see [[addDuplicateCondition]]
     */
    addUniqueCondition(regionAddress: string): UniqueConditionalFormat;
    /**
     * Adds a new [[DuplicateConditionalFormat]] instance to this collection,
     * configured as a duplicate value condition.
     * <p class="body">
     * Use this method to add a condition which evaluates to true only for cell values which
     * are non-unique across the associated range.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[DuplicateConditionalFormat]] instance.
     * @see [[DuplicateConditionalFormat]]
     * @see [[addUniqueCondition]]
     */
    addDuplicateCondition(regionAddress: string): DuplicateConditionalFormat;
    /**
     * Adds a new [[DateTimeConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param dateOperator A [[FormatConditionTimePeriod]] which defines the time period against which cell date values are evaluated. This parameter is optional and defaults to <i>Today</i>.
     * @return The resulting [[DateTimeConditionalFormat]] instance.
     * @see [[DateTimeConditionalFormat]]
     */
    addDateTimeCondition(regionAddress: string, dateOperator?: FormatConditionTimePeriod): DateTimeConditionalFormat;
    /**
     * Adds a new [[TextOperatorConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param text A string which determines the string against which cell text values are evaluated. This parameter is optional and defaults to <i>null</i>.
     * @param textOperator A [[FormatConditionTextOperator]] value which determines the manner in which cell values are compared to the 'text' value. This parameter is optional and defaults to <i>BeginsWith</i>.
     * @return The resulting [[TextOperatorConditionalFormat]] instance.
     * @see [[TextOperatorConditionalFormat]]
     */
    addTextCondition(regionAddress: string, text?: string, textOperator?: FormatConditionTextOperator): TextOperatorConditionalFormat;
    /**
     * Adds a new [[BlanksConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[BlanksConditionalFormat]] instance.
     * @see [[BlanksConditionalFormat]]
     * @see [[addNoBlanksCondition]]
     */
    addBlanksCondition(regionAddress: string): BlanksConditionalFormat;
    /**
     * Adds a new [[NoBlanksConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[NoBlanksConditionalFormat]] instance.
     * @see [[NoBlanksConditionalFormat]]
     * @see [[addBlanksCondition]]
     */
    addNoBlanksCondition(regionAddress: string): NoBlanksConditionalFormat;
    /**
     * Adds a new [[ErrorsConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[ErrorsConditionalFormat]] instance.
     * @see [[ErrorsConditionalFormat]]
     * @see [[addNoErrorsCondition]]
     */
    addErrorsCondition(regionAddress: string): ErrorsConditionalFormat;
    /**
     * Adds a new [[NoErrorsConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[NoErrorsConditionalFormat]] instance.
     * @see [[ErrorsConditionalFormat]]
     * @see [[addErrorsCondition]]
     */
    addNoErrorsCondition(regionAddress: string): NoErrorsConditionalFormat;
    /**
     * Adds a new [[ColorScaleConditionalFormat]] instance to this collection.
     * <p class="body">
     * Note that when <i>TwoColor</i> is specified as the value of the 'colorScaleType'
     * parameter, the [[ColorScaleConditionalFormat.midpointThreshold]] property is not applicable;
     * attempting to set properties on the object returned from that property causes an exception to be thrown.
     * </p>
     * <p class="body">
     * The [[ColorScaleConditionalFormat.minimumThreshold]] and [[ColorScaleConditionalFormat.maximumThreshold]]
     * properties can be used to customize the coloring and threshold boundaries for the minimum and maximum points of the associated
     * range.
     * </p>
     * <p class="body">
     * For a 3-color scale, the [[ColorScaleConditionalFormat.midpointThreshold]] can also
     * be used to customize the midpoint threshold boundary.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param colorScaleType A [[ColorScaleType]] value which determines whether to add a 2-color or 3-color scale.
     * @return The resulting [[ColorScaleConditionalFormat]] instance.
     * @see [[ColorScaleConditionalFormat]]
     * @see [[ColorScaleCriterion]]
     */
    addColorScaleCondition(regionAddress: string, colorScaleType: ColorScaleType): ColorScaleConditionalFormat;
    /**
     * Adds a new [[IconSetConditionalFormat]] instance to this collection.
     * <p class="body">
     * Each constant in the [[FormatConditionIconSet]] enumeration contains either
     * 3, 4, or 5 in its name. This number identifies the number of thresholds supported by
     * the condition.
     * </p>
     * <p class="body">
     * A three-threshold condition supports thresholds of 33%, 67%, and 100%.
     * </p>
     * <p class="body">
     * A four-threshold condition supports thresholds of 25%, 50%, 75%, and 100%.
     * </p>
     * <p class="body">
     * A five-threshold condition supports thresholds of 20%, 40%, 60%, 80%, and 100%.
     * </p>
     * <p class="body">
     * A [[ColorScaleCriterion]] object for each threshold, is returned
     * from the [[IconSetConditionalFormat.iconCriteria]]
     * collection.
     * </p>
     * <p class="body">
     * These objects provide the ability to customize the values for the corresponding
     * threshold. For example, the icon that is displayed for a given index can be
     * overridden using the [[IconCriterion.icon]] property.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param iconSet A [[FormatConditionIconSet]] value which identifies the icon set to use. This parameter is optional and defaults to <i>IconSet3TrafficLights1</i>.
     * @return The resulting [[IconSetConditionalFormat]] instance.
     * @see [[IconSetConditionalFormat]]
     * @see [[IconSetConditionalFormat.iconCriteria]]
     * @see [[IconCriterion]]
     */
    addIconSetCondition(regionAddress: string, iconSet?: FormatConditionIconSet): IconSetConditionalFormat;
    /**
     * Adds a new [[DataBarConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[DataBarConditionalFormat]] instance.
     */
    addDataBarCondition(regionAddress: string): DataBarConditionalFormat;
    /**
     * Removes all items from the collection.
     */
    clear(): void;
    /**
     * Returns true if the collection contains the condition
     * @param condition The condition
     */
    contains(condition: ConditionBase): boolean;
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _g;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _a3;
    [Symbol.iterator](): EnumeratorWrapper<ConditionBase>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<ConditionBase>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    _av(a: List$1<ConditionBase>, b: number, c: number): void;
    /**
     * @hidden
     */
    _ac(a: number, b: number): boolean;
    /**
     * Gets the index of the item in the collection
     * @param condition
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(condition: ConditionBase): number;
    /**
     * @hidden
     */
    _ax(a: number, b: ConditionBase): void;
    /**
     * @hidden
     */
    _ay(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _az(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _a0(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ad(a: List$1<ConditionBase>, b: number, c: number, d: boolean): boolean;
    /**
     * @hidden
     */
    _a1(a: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _a2(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * Removes an item from the collection
     * @param condition
     * @return true is the item was removed or false if the item wasn't in the collection
     */
    remove(condition: ConditionBase): boolean;
    /**
     * Removes an item from the collection at a specifoed index
     * @param index The zero based index in the collection
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _a5(a: number, b: ConditionBase): void;
    /**
     * @hidden
     */
    _a6(a?: boolean): void;
    /**
     * @hidden
     */
    _a7(): void;
    /**
     * @hidden
     */
    private static _a8;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _a9;
    /**
     * @hidden
     */
    private _c;
    /**
     * @hidden
     */
    private _d;
    /**
     * @hidden
     */
    _aw(a: IList$1<ConditionBase>): void;
}
/**
 * @hidden
 */
export declare class HyperlinkResult extends Base {
    static $t: Type;
    readonly a: string;
    readonly b: string;
    constructor(a: string, b: string);
    toString(): string;
}
/**
 * @hidden
 */
export declare class FormulaStringGenerator extends FormulaTokenEvaluator$1<string> {
    static $t: Type;
    private static bi;
    private bq;
    private bm;
    private bh;
    private bo;
    private bp;
    constructor();
    protected a4(a: IFunctionToken, b: string): string;
    a2(): EvaluationResult$1<string>;
    protected a5(a: BinaryOperatorToken, b: string, c: string): string;
    protected a6(a: IFunctionToken, b: string, c: string[]): string;
    protected a7(a: OperandToken): string;
    protected a8(a: ParenToken, b: string): string;
    protected a9(a: UnaryOperatorToken, b: string): string;
    a1(): void;
    o(a: AttrSpaceToken): boolean;
    v(a: ExpToken): boolean;
    at(a: TblToken): boolean;
    protected bs(a: FormulaToken): string;
    private bt;
    static bj(a: FormulaContext): FormulaStringGenerator;
    static bk(a: FormulaContext, b: string[]): FormulaStringGenerator;
    static bl(a: FormulaContext, b: boolean): FormulaStringGenerator;
    protected static bu(a: FormulaStringGenerator, b: FormulaContext, c: boolean): void;
    private bv;
    protected get_bn(): boolean;
    protected readonly bn: boolean;
}
/**
 * @hidden
 */
export declare abstract class AttrTokenBase extends SpecialFormulaToken {
    static $t: Type;
    constructor();
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    static o(a: IBiffRecordStream, b: number[], c: number): {
        ret: AttrTokenBase;
        p1?: number[];
        p2?: number;
    };
    abstract readonly p: AttrTokenBase_AttrType;
    protected get_q(): boolean;
    readonly q: boolean;
}
/**
 * @hidden
 */
export declare class WhitespaceId extends ValueType {
    static $t: Type;
    constructor(a: number, b: WhitespaceType, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly b;
    private readonly a;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class AttrSpaceToken extends AttrTokenBase {
    static $t: Type;
    private static w;
    private u;
    private s;
    constructor(a: number);
    constructor(a: number, b: number, c: WhitespaceType);
    constructor(a: number, ..._rest: any[]);
    static r(a: number, b: WhitespaceType): AttrSpaceToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
    v: number;
    t: WhitespaceType;
}
/**
 * @hidden
 */
export declare class FormulaParser extends Base {
    static $t: Type;
    static b(a: string, b: CultureInfo): ErrorValue;
    static d(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: FormulaParseException): {
        ret: Formula;
        p6: FormulaParseException;
    };
    static e(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: number, h: number, i: FormulaParseException): {
        ret: Formula;
        p8: FormulaParseException;
    };
    static f(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>, e: FormulaParseException): {
        ret: Formula;
        p4: FormulaParseException;
    };
    private static m;
    private cu;
    cw: string;
    private readonly b8;
    readonly b9: List$1<FormulaParser_FormulaTokenInfo>;
    private bz;
    i: FormulaType;
    b4: string;
    private r;
    cp: number;
    private af;
    private g;
    private cg;
    private readonly p;
    private b7;
    private readonly dx;
    private readonly cd;
    private readonly cb;
    private readonly cc;
    private readonly ca;
    private readonly dy;
    private x;
    private readonly b6;
    j: FormulaContext;
    private ce;
    private cf;
    constructor();
    private ec;
    private c;
    private av;
    private a5;
    private be;
    private ag;
    private ah;
    private ai;
    private cq;
    private cr;
    private aj;
    private ak;
    private al;
    static am(a: string, b: number, c: WorkbookFormat, d: CultureInfo, e: number, f: boolean, g: number): {
        ret: boolean;
        p4?: number;
        p5?: boolean;
        p6: number;
    };
    private static an;
    private ao;
    static ap(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private aq;
    private cs;
    private ed;
    private at;
    private au;
    private c3;
    private c4;
    private c5;
    private c6;
    private aw;
    private ax;
    private s;
    private c7;
    private ay;
    private az;
    private a0;
    private a1;
    private c8;
    static c9(a: string, b: boolean, c: number): {
        ret: string;
        p2?: number;
    };
    static ac(a: string, b: boolean): boolean;
    private ee;
    private a2;
    private ar;
    private da;
    private as;
    private static z;
    static ef(a: string, b: string, c: string, d?: string): {
        p1: string;
        p2: string;
    };
    private a3;
    private a4;
    private co;
    private a6;
    private a7;
    private a8;
    static a9(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private static ba;
    private bb;
    static bc(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private bd;
    private ct;
    private bf;
    private bg;
    private bh;
    private bi;
    private db;
    private bj;
    private dc;
    private t;
    private static u;
    private static ae;
    private bk;
    private bl;
    private bm;
    static bu(a: string, b: boolean): {
        ret: boolean;
        p1: boolean;
    };
    private dz;
    private d0;
    private d1;
    private d2;
    private d3;
    private ea;
    private d4;
    private d6;
    d5(a: FormulaToken, b: number, c: number, d: FormulaParser_TextSpan, e: WhitespaceType): void;
    private eb;
    private d7;
    private d8;
    private d9;
    private q;
    private static k;
    static l(a: Workbook, b: Worksheet, c: WorksheetRow, d: number, e: CultureInfo, f: CellReferenceMode, g: FormulaType): FormulaContext;
    private v;
    private a;
    private static w;
    static cx(a: StructuredTableReferenceKeywordType): string;
    static bw(a: string): string;
    static bx(a: CultureInfo): string;
    static by(a: string): string;
    private y;
    static aa(a: string): boolean;
    static ab(a: string, b: WorkbookFormat, c: CultureInfo): boolean;
    private ad;
    eg(a: FormulaParser_PositionInfo): void;
    o(): FormulaParser_PositionInfo;
    static bo(a: string): boolean;
    bp(a: string): boolean;
    bq(a: string): boolean;
    private br;
    bs(a: string): boolean;
    private bt;
    private static readonly n;
    private readonly ch;
    private readonly ck;
    h: FormulaParseException;
    private readonly bn;
    private dg;
    private dk;
    private di;
    private dm;
    private dp;
    private dr;
    private dt;
    private dv;
    private readonly dh;
    private readonly dl;
    private readonly dj;
    private readonly dn;
    private readonly dq;
    private readonly ds;
    private readonly du;
    private readonly dw;
}
/**
 * Represents the aggregated conditioal format for a specific cell. It is returned via the <see cref="Worksheet.GetCellConditionalFormat(int, int)">Worksheet.GetCellConditionalFormat</see> and the <see cref="WorksheetRow.GetCellConditionalFormat">WorksheetRow.GetCellConditionalFormat</see> methods.
 */
export declare class CellConditionalFormat extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static _a: CellConditionalFormat;
    private _g;
    private _b;
    private _d;
    private _i;
    constructor(a: number);
    constructor(a: number, b: WorksheetCellFormatData, c: CellDataBarInfo, d: CellIconInfo);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns a cell format that represents the aggregated format for all conditional formats that apply to the cell (read-only).
     */
    readonly cellFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    readonly _h: WorksheetCellFormatData;
    /**
     * Returns a data bar info if applicable, otherwise null (read-only).
     */
    readonly dataBarInfo: CellDataBarInfo;
    /**
     * Returns an icon info if applicable, otherwise null (read-only).
     */
    readonly iconInfo: CellIconInfo;
    /**
     * Returns whether this cell has conditional formatting applied (read-only)
     */
    readonly hasConditionFormatting: boolean;
}
/**
 * Exposes the information necessary for drawing a data bar for a specific cell.
 * @see [[CellConditionalFormat]]
 */
export declare class CellDataBarInfo extends Base {
    static $t: Type;
    private _o;
    private _p;
    private _q;
    private _k;
    private _l;
    private _a;
    private _c;
    private _e;
    private _g;
    private _f;
    constructor(a: number, b: number, c: number, d: boolean, e: boolean, f: DataBarDirection, g: DataBarFillType, h: WorkbookColorInfo, i: WorkbookColorInfo, j: WorkbookColorInfo);
    /**
     * The color to use to draw the axis line or null if no axis line is to be drawn (read-only).
     * @see [[axisPosition]]
     */
    readonly axisColor: WorkbookColorInfo;
    /**
     * Specifies the position, as a percentage of the cell width, where the axis ahould be rendered (read-only)
     * a percentage from 0 to 100
     * <para class="note"><b>Note:</b> if [[axisColor]] returns null then this property can be ignored.</para>
     * @see [[axisColor]]
     */
    readonly axisPosition: number;
    /**
     * The color to use to draw the border around the data bar or null if no border is to be drawn (read-only).
     */
    readonly barBorder: WorkbookColorInfo;
    /**
     * The color to use to draw the data bar (read-only).
     * @see [[barFillType]]
     * @see [[barPositionFrom]]
     * @see [[barPositionTo]]
     */
    readonly barColor: WorkbookColorInfo;
    /**
     * Specifies whether the data bar should be filled with a sold color or a gradient (read-only).
     * @see [[barColor]]
     */
    readonly barFillType: DataBarFillType;
    /**
     * Species the position, as a percentage of the cell width, where the data bar should begin (read-only).
     * @see [[barPositionTo]]
     * @see [[direction]]
     */
    readonly barPositionFrom: number;
    /**
     * Species the position, as a percentage of the cell width, where the data bar should end (read-only).
     * @see [[barPositionFrom]]
     * @see [[direction]]
     */
    readonly barPositionTo: number;
    /**
     * Specifies the direction of the bata bar (read-only).
     * @see [[barPositionFrom]]
     * @see [[barPositionTo]]
     */
    readonly direction: DataBarDirection;
    /**
     * Returns true if the cell value is negative (read-only).
     */
    readonly isNegative: boolean;
    /**
     * Returns whether the cell value is to be shown along with the data bar (read-only).
     */
    readonly showValue: boolean;
}
/**
 * Exposes the information necessary for drawing an icon for a specific cell.
 * @see [[CellConditionalFormat]]
 */
export declare class CellIconInfo extends Base {
    static $t: Type;
    private _e;
    private _g;
    private _a;
    private _c;
    constructor(a: FormatConditionIconSet, b: FormatConditionIcon, c: number, d: boolean);
    /**
     * The icon to be drawn (read-only).
     */
    readonly icon: FormatConditionIcon;
    /**
     * The index of the icon in the icon set (read-only).
     */
    readonly iconIndex: number;
    /**
     * The icon set (read-only).
     */
    readonly iconSet: FormatConditionIconSet;
    /**
     * Returns whether the cell value is to be shown along with the data bar (read-only).
     */
    readonly showValue: boolean;
}
/**
 * @hidden
 */
export declare class ConditionMatchResult extends Base {
    static $t: Type;
    static readonly e: ConditionMatchResult;
    static readonly f: ConditionMatchResult;
    readonly i: boolean;
    private g;
    private a;
    private c;
    constructor(a: number, b: WorkbookColorInfo);
    constructor(a: number, b: CellDataBarInfo);
    constructor(a: number, b: CellIconInfo);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    readonly h: WorkbookColorInfo;
    readonly b: CellDataBarInfo;
    readonly d: CellIconInfo;
}
/**
 * Abstract base class for classes which control
 * the visual attributes of a [[WorksheetCell]],
 * based on whether the cell's value meets a logical condition.
 */
export declare abstract class ConditionalFormatBase extends ConditionBase implements IWorksheetCellFormatProxyOwner {
    static $t: Type;
    private _bt;
    private _bv;
    private _by;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * Returns an [[IWorksheetCellFormat]] interface implementation
     * which represents the format for cells which meet the criteria associated
     * with this condition.
     * <p class="body">
     * The IWorksheetCellFormat implementation defines the visual attributes which
     * are applied to cells whose value meets the associated condition.
     * </p>
     */
    readonly cellFormat: IWorksheetCellFormat;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bz: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _bw: WorksheetCellFormatData;
    /**
     * @hidden
     */
    readonly _bx: boolean;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
}
/**
 * @hidden
 */
export declare class WorksheetMergedRegionOwnedCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
}
/**
 * @hidden
 */
export declare class ValueFormatter_GetTextWidthHelper extends Base {
    static $t: Type;
    private readonly b;
    private readonly a;
    constructor(a: TextMetricsProviderBase, b: WorksheetCellFormatData);
    e(a: string): number;
    d(a: string): number;
    readonly c: boolean;
}
/**
 * @hidden
 */
export declare class ValueFormatter_FormatValueState extends Base {
    static $t: Type;
    private g;
    private m;
    private b;
    private aa;
    private o;
    private q;
    private s;
    private ac;
    private u;
    private d;
    private ae;
    private w;
    private ag;
    private i;
    private ai;
    private k;
    private y;
    private ak;
    private a;
    readonly f: boolean;
    constructor(a: ValueFormatter_FormatSection, b: number, c: boolean);
    am(): void;
    ao(): void;
    an(): void;
    ap(): void;
    aq(): void;
    private static ar;
    as(): void;
    private at;
    readonly h: number;
    n: number;
    readonly c: ValueFormatter_NumberSection;
    readonly ab: Nullable$1<Date>;
    p: number;
    r: number;
    readonly t: number;
    readonly ad: string;
    readonly v: number;
    e: boolean;
    readonly af: string;
    readonly x: number;
    readonly ah: string;
    readonly l: number;
    readonly j: number;
    readonly aj: string;
    readonly z: number;
    readonly al: string;
}
/**
 * @hidden
 */
export declare class ValueFormatter_FormatSection_FormulaValueInfo extends ValueType {
    static $t: Type;
    constructor();
    e: number;
    a: boolean;
    b: boolean;
    f: number;
    g: number;
    d: string;
    c: boolean;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree extends RowColumnLoadOnDemandTree$1<WorksheetRow> {
    static $t: Type;
    private _ay;
    constructor(a: WorksheetRowCollection);
    _f(a: number, b: IBinaryTreeNodeOwner$1<WorksheetRow>): LoadOnDemandTree_BinaryTreeNode$1<WorksheetRow>;
    _k(a: LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>, b: number, c: number): LoadOnDemandTree_ChangeAdjustmentPoint$1<WorksheetRow>;
    protected _l(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>;
    protected _m(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>;
    readonly _a1: number;
    private _a3;
    _a2(a: number, b: number, c: number, d: boolean): number;
    _a6(a: number, b: number, c: number, d: number, e: boolean): {
        p2: number;
        p3: number;
    };
    _a4(a: number, b: number, c: number, d: number, e: number, f: number, g: boolean): {
        p2: number;
        p3: number;
    };
    private _a5;
    private static _az;
    protected _a8(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    private _a9;
    _a7(a: number, b: number, c: number, d: number, e: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    private static _a0;
    _ba(): void;
    private _aw;
    private _ax;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowBinaryTreeNode extends RowColumnBinaryTreeNode$1<WorksheetRow> {
    static $t: Type;
    constructor(a: number, b: IBinaryTreeNodeOwner$1<WorksheetRow>, c: LoadOnDemandTree$1<WorksheetRow>);
    p(a: WorksheetRow, b: number): number;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint extends LoadOnDemandTree_ChangeAdjustmentPoint$1<WorksheetRow> {
    static $t: Type;
    private ac;
    private ad;
    private w;
    private x;
    private v;
    constructor(a: WorksheetRowCollection_RowsLoadOnDemandTree, b: LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>, c: number, d: number);
    protected t(): void;
    ae(a: number, b: number, c: boolean): number;
    y(a: number, b: number, c: number, d: boolean): {
        ret: number;
        p0?: number;
    };
    z(a: number, b: number, c: number, d: boolean): number;
    aa(a: number, b: number, c: boolean): number;
    private af;
    private ab;
    private ag;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd extends LoadOnDemandTree_ChangeHistoryItemAdd$1<WorksheetRow> {
    static $t: Type;
    private k;
    private l;
    constructor(a: number, b: number);
    d(a: number, b: number, c: number, d: boolean): number;
    e(a: number, b: number, c: boolean): number;
    private m;
    n(): void;
}
/**
 * @hidden
 */
export declare class WorksheetPaneSelection extends Base {
    static $t: Type;
    private e;
    constructor();
    b: WorksheetCellAddress;
    f: number;
    a: PaneLocation;
    readonly d: IList$1<WorksheetRegionAddress>;
    static c(a?: PaneLocation): WorksheetPaneSelection;
    g(a: WorksheetPaneSelection): void;
}
/**
 * Represents the window options which are saved with the workbook.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a workbook, but
 * not with a custom view.
 * </p>
 * @see [[Workbook.windowOptions]]
 * @see [[CustomViewWindowOptions]]
 */
export declare class WorkbookWindowOptions extends WindowOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ag;
    private _at;
    private _am;
    private _aj;
    private _ar;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    readonly _o: boolean;
    /**
     * @hidden
     */
    _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * Gets or sets the bounds of the workbook's MDI child window in twips (1/20th of a point).
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The bounds of the workbook's MDI child window in twips (1/20th of a point).
     * @throws [[ArgumentException]] The width or height of the value assigned are less than zero.
     */
    /**
    * Gets or sets the bounds of the workbook's MDI child window in twips (1/20th of a point).
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
    * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
    * a newly created CustomView will not be initialized with the setting from this property.
    * </p>
    * The bounds of the workbook's MDI child window in twips (1/20th of a point).
    * @throws [[ArgumentException]] The width or height of the value assigned are less than zero.
    */
    boundsInTwips: IgRect;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _boundsInTwips$i: Rect;
    /**
     * Gets or sets the index of the first visible tab in the worksheet tab bar.
     * <p class="body">
     * If the worksheet tab bar is not visible, this value will not be used, but it is still saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The index of the first visible tab in the worksheet tab bar.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than zero.
     * @see [[WindowOptions.tabBarVisible]]
     * @see [[WindowOptions.tabBarWidth]]
     */
    /**
    * Gets or sets the index of the first visible tab in the worksheet tab bar.
    * <p class="body">
    * If the worksheet tab bar is not visible, this value will not be used, but it is still saved with the workbook.
    * </p>
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
    * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
    * a newly created CustomView will not be initialized with the setting from this property.
    * </p>
    * The index of the first visible tab in the worksheet tab bar.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than zero.
    * @see [[WindowOptions.tabBarVisible]]
    * @see [[WindowOptions.tabBarWidth]]
    */
    firstVisibleTabIndex: number;
    /**
     * Gets or sets the value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
     * @see [[CustomViewWindowOptions.maximized]]
     */
    /**
    * Gets or sets the value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
    * <p class="note">
    * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
    * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
    * a newly created CustomView will not be initialized with the setting from this property.
    * </p>
    * The value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
    * @see [[CustomViewWindowOptions.maximized]]
    */
    minimized: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _as: number;
}
/**
 * @hidden
 */
export declare class WorksheetSelection extends Base {
    static $t: Type;
    private c;
    constructor();
    readonly b: IList$1<WorksheetPaneSelection>;
    a(a: PaneLocation): WorksheetPaneSelection;
    d(a: PaneLocation): number;
    e(a: WorksheetSelection): void;
}
/**
 * A collection of workbook styles, or complex formats which can be easily applied to cells in Microsoft Excel.
 * @see [[WorkbookStyle]]
 */
export declare class WorkbookStyleCollection extends Base implements ICollection$1<WorkbookStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _p;
    private _a;
    private _q;
    private _b;
    private _y;
    private _r;
    private _s;
    private _c;
    private _v;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: WorkbookStyle): void;
    /**
     * @hidden
     */
    copyTo(array: WorkbookStyle[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorkbookStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorkbookStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds new user defined style to the workbook.
     * @param styleFormat A cell format of the style.
     * @param name The name which will identify the style in Microsoft Excel.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] A style already exists with the a name of 'name'. Names are compared case-insensitively.
     * @return The added user defined style as a [[WorkbookStyle]] instance.
     */
    addUserDefinedStyle(styleFormat: IWorksheetCellFormat, name: string): WorkbookStyle;
    /**
     * Adds new user defined style to the workbook.
     * @param name The name which will identify the style in Microsoft Excel.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] A style already exists with the a name of 'name'. Names are compared case-insensitively.
     * @return The added user defined style as a [[WorkbookStyle]] instance.
     */
    addUserDefinedStyle(name: string): WorkbookStyle;
    /**
     * @hidden
     */
    _addUserDefinedStyle1(a: string): WorkbookStyle;
    /**
     * @hidden
     */
    _addUserDefinedStyle(a: IWorksheetCellFormat, b: string): WorkbookStyle;
    /**
     * Clears all styles, other than the Normal style, from the collection.
     * @see [[normalStyle]]
     */
    clear(): void;
    /**
     * Determines whether a style is in the collection.
     * @param style The style to locate in the collection.
     * @return True if the style is found; False otherwise.
     */
    contains(style: WorkbookStyle): boolean;
    /**
     * Removes the specified style from the collection.
     * @param style The style to remove from the collection.
     * @throws [[InvalidOperationException]] 'style' is the Normal style.
     * @return True if the style was successfully removed; False if the style was not
     * in the collection.
     * @see [[normalStyle]]
     */
    remove(style: WorkbookStyle): boolean;
    /**
     * Removes the style at the specified index from the collection.
     * @param index The zero-based index of the style in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] The style to remove at 'index' is the Normal style.
     * @see [[normalStyle]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _ae;
    /**
     * Resets the collection to its original state by clearing all styles and adding in preset built in styles.
     */
    reset(): void;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    _add(a: WorkbookStyle): WorkbookStyle;
    /**
     * @hidden
     */
    _e(a: WorkbookBuiltInStyle): WorkbookStyle;
    /**
     * @hidden
     */
    _f(a: IWorksheetCellFormat, b: string): WorkbookStyle;
    /**
     * @hidden
     */
    _o(a: BuiltInStyleType): boolean;
    /**
     * @hidden
     */
    _i(a: BuiltInStyleType): WorkbookStyle;
    /**
     * @hidden
     */
    _j(a: BuiltInStyleType, b: number): WorkbookStyle;
    /**
     * @hidden
     */
    private __u;
    _u(): IEnumerable$1<WorkbookBuiltInStyle>;
    /**
     * @hidden
     */
    _ac(a: WorkbookUserDefinedStyle, b: string): void;
    /**
     * @hidden
     */
    _ah(a: string, b: string): void;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    static _n: (arg1: List$1<WorkbookBuiltInStyle>) => void;
    /**
     * @hidden
     */
    static _ab(): void;
    /**
     * Gets the number of styles in the collection.
     * The number of styles in the collection.
     */
    readonly count: number;
    /**
     * Gets the style at the specified index.
     * The style at the specified index.
     * @param index The zero-based index of the style to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): WorkbookStyle;
    /**
     * Gets the style with the specified name.
     * <p class="body">
     * Style names are compared case-insensitively.
     * </p>
     * The style with the specified name or null if no style with that name exists.
     * @param name The name of the style to get.
     * @throws [[ArgumentNullException]] 'name' is null.
     */
    item(name: string): WorkbookStyle;
    /**
     * @hidden
     */
    _item(a: number): WorkbookStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorkbookStyle;
    /**
     * Gets the default style for the workbook.
     * <p class="body">
     * The normal style is the parent style for all cell and differential formats in the workbook, unless another parent style is specified.
     * </p>
     * @see [[IWorksheetCellFormat.style]]
     */
    readonly normalStyle: WorkbookStyle;
    /**
     * @hidden
     */
    static readonly _x: List$1<WorkbookBuiltInStyle>;
    /**
     * @hidden
     */
    static readonly _t: Dictionary$2<string, BuiltInStyleInfo>;
}
/**
 * @hidden
 */
export declare class WorkbookStyleCollection_RefEqualityComparer$1<T> extends Base implements IEqualityComparer$1<T> {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type);
    equalsC(a: T, b: T): boolean;
    getHashCodeC(a: T): number;
}
/**
 * @hidden
 */
export declare class Worksheet_SetColumnWidthInfo extends Base {
    static $t: Type;
    readonly c: number;
    readonly a: WorksheetColumnWidthUnit;
    readonly b: boolean;
    constructor(a: number, b: WorksheetColumnWidthUnit, c: boolean);
}
/**
 * @hidden
 */
export declare class Worksheet_ShiftRegionHelper extends Base {
    static $t: Type;
    private a;
    constructor(a: CellShiftOperation);
    b(a: WorksheetRegion, b: boolean): {
        p1: boolean;
    };
}
/**
 * @hidden
 */
export declare class Worksheet_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly a: ChangeInfo;
    readonly b: Worksheet_CellInsertDeleteChangeContext;
    private e;
    readonly c: boolean;
    readonly d: boolean;
    constructor(a: ChangeInfo, b: Worksheet_CellInsertDeleteChangeContext, c: boolean, d: boolean);
    readonly f: any;
    readonly count: number;
    readonly index: number;
    readonly shiftsColumns: boolean;
    readonly shiftsRows: boolean;
    readonly isRemoveOperation: boolean;
    readonly isUndoOperation: boolean;
    readonly performsShift: boolean;
    readonly worksheet: Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetCellShiftResult extends ValueType {
    static $t: Type;
    constructor(a: number, b: CellShiftResult, c: List$1<WorksheetTable>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: CellShiftResult;
    readonly b: List$1<WorksheetTable>;
}
/**
 * @hidden
 */
export declare class WorksheetDummyCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    constructor(a: WorksheetCellFormatData);
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
}
/**
 * @hidden
 */
export declare class MutableItemRange extends Base {
    static $t: Type;
    a: number;
    b: number;
    constructor(a: number, b: number);
}
/**
 * @hidden
 */
export declare class WorksheetCellBlock_DataTypesCompressed extends ValueType {
    static $t: Type;
    constructor();
    private b;
    private c;
    private d;
    a(a: number): WorksheetCellBlock_DataType;
    e(a: number, b: WorksheetCellBlock_DataType): void;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlockFull extends WorksheetCellBlock {
    static $t: Type;
    private bx;
    private by;
    private bz;
    private b0;
    private b1;
    private a1;
    private a2;
    private a3;
    private a4;
    private a5;
    private a6;
    private a7;
    private a8;
    private a9;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    private bf;
    private bg;
    private bh;
    private bi;
    private bj;
    private bk;
    private bl;
    private bm;
    private bn;
    private bo;
    private bp;
    private bq;
    private br;
    private bs;
    private bt;
    private bu;
    private bv;
    private bw;
    constructor(a: number);
    protected h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected e(a: number): WorksheetCellBlock_CellValue;
    protected f(a: number): WorksheetCellBlock_DataType;
    protected am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    r(a: number): boolean;
    protected an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    protected aq(a: number, b: WorksheetCellBlock_DataType): void;
    ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    at(a: number, b: boolean): void;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlockHalf extends WorksheetCellBlock {
    static $t: Type;
    private bq;
    private br;
    private bs;
    private bt;
    private bu;
    private bv;
    private bj;
    private bk;
    private bw;
    private by;
    private bx;
    private a2;
    private a3;
    private a4;
    private a5;
    private a6;
    private a7;
    private a8;
    private a9;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    private bf;
    private bg;
    private bh;
    constructor(a: number);
    protected h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected e(a: number): WorksheetCellBlock_CellValue;
    private a1;
    protected f(a: number): WorksheetCellBlock_DataType;
    private bi;
    protected am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    r(a: number): boolean;
    private bl;
    protected an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    private b1;
    protected aq(a: number, b: WorksheetCellBlock_DataType): void;
    private b3;
    ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    at(a: number, b: boolean): void;
    private bz;
    private b0;
    private bm;
    private bp;
    private b2;
}
/**
 * @hidden
 */
export declare class WorksheetCellLocation extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRow, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: WorksheetRow;
    readonly f: number;
    static readonly a: ChangeInfo$2<WorksheetCellLocation, WorksheetCellComment>;
    static readonly c: ChangeInfo$2<WorksheetCellLocation, any>;
    static h(a: WorksheetCellLocation): any;
    static d(a: WorksheetCellLocation): WorksheetCellComment;
    static j(a: WorksheetCellLocation, b: any): void;
    private static k;
    static i(a: WorksheetCellLocation, b: WorksheetCellComment): void;
    private static b;
    private static g;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatDataResolved extends Base implements IWorksheetCellFormat {
    static $t: Type;
    private _a;
    private _b;
    constructor(a: WorksheetCellFormatProxy);
    equals(a: any): boolean;
    getHashCode(): number;
    _f(a: CellFormatValue, b: any): {
        ret: boolean;
        p1: any;
    };
    _m(a: WorksheetCellFormatProxy): void;
    setFormatting(a: IWorksheetCellFormat): void;
    private _n;
    alignment: HorizontalCellAlignment;
    bottomBorderColorInfo: WorkbookColorInfo;
    bottomBorderStyle: CellBorderLineStyle;
    readonly _g: number;
    readonly _h: number;
    readonly _i: number;
    readonly _k: number;
    readonly _j: number;
    readonly _c: boolean;
    readonly _d: boolean;
    diagonalBorderColorInfo: WorkbookColorInfo;
    diagonalBorders: DiagonalBorders;
    diagonalBorderStyle: CellBorderLineStyle;
    fill: CellFill;
    readonly font: IWorkbookFont;
    formatOptions: WorksheetCellFormatOptions;
    formatString: string;
    indent: number;
    leftBorderColorInfo: WorkbookColorInfo;
    leftBorderStyle: CellBorderLineStyle;
    locked: boolean | null;
    _locked$i: Nullable$1<boolean>;
    rightBorderColorInfo: WorkbookColorInfo;
    rightBorderStyle: CellBorderLineStyle;
    rotation: number;
    shrinkToFit: boolean | null;
    _shrinkToFit$i: Nullable$1<boolean>;
    style: WorkbookStyle;
    topBorderColorInfo: WorkbookColorInfo;
    topBorderStyle: CellBorderLineStyle;
    verticalAlignment: VerticalCellAlignment;
    wrapText: boolean | null;
    _wrapText$i: Nullable$1<boolean>;
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellFormatDataResolved extends WorksheetCellFormatDataResolved {
    static $t: Type;
    private _o;
    constructor(a: WorksheetMergedCellsRegion);
    _f(a: CellFormatValue, b: any): {
        ret: boolean;
        p1: any;
    };
}
/**
 * @hidden
 */
export declare class WorksheetCellOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    private _bs;
    private _bw;
    private _bu;
    constructor(a: WorksheetCellFormatData, b: WorksheetCellFormatCollection, c: WorksheetRow, d: number, e: WorksheetCellFormatData[]);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    _ai(): Nullable$1<WorksheetCellAddress>;
    _at(a: Nullable$1<WorksheetCellAddress>): void;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
    protected get_d(): WorksheetCellFormatData;
    private _bx;
    private _by;
    readonly _bv: number;
    _bt: WorksheetCellFormatData;
}
/**
 * @hidden
 */
export declare class Excel2007ChartData extends Base {
    static $t: Type;
    a: BinaryData;
    c: Tuple$2<string, BinaryData>;
    d: Tuple$2<string, BinaryData>;
    e: Tuple$2<string, BinaryData>;
    b: List$1<Tuple$2<IPackageRelationship, ImageData>>;
}
/**
 * @hidden
 */
export declare class FontXInfo extends Base {
    static $t: Type;
    private readonly c;
    private readonly a;
    private readonly d;
    constructor(a: number, b: WorkbookLoadManager);
    e(a: WorkbookSaveManager): number;
    readonly b: WorkbookFontData;
}
/**
 * @hidden
 */
export declare class WorksheetColumnOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: WorksheetColumn);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get_d(): WorksheetCellFormatData;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
    private _bs;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly c: ChangeInfo;
    readonly d: WorksheetColumnCollection_CollectionChangeContext;
    readonly a: WorksheetColumnBlock[];
    private h;
    private readonly g;
    readonly b: WorksheetColumn[];
    readonly e: boolean;
    readonly f: boolean;
    constructor(a: ChangeInfo, b: WorksheetColumnCollection_CollectionChangeContext, c: number, d: boolean, e: boolean, f: WorksheetColumn[], g: WorksheetColumnBlock[]);
    i(): void;
    j(): void;
    k(): void;
    readonly count: number;
    readonly index: number;
    readonly shiftsColumns: boolean;
    readonly shiftsRows: boolean;
    readonly isRemoveOperation: boolean;
    readonly isUndoOperation: boolean;
    readonly performsShift: boolean;
    readonly worksheet: Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_CollectionChangeContextData extends Base {
    static $t: Type;
    readonly f: boolean;
    readonly h: number;
    readonly g: number;
    readonly e: WorksheetColumnCollection;
    readonly b: WorksheetColumn[];
    readonly a: WorksheetColumnBlock[];
    private c;
    constructor(a: WorksheetColumnCollection, b: boolean, c: number, d: number, e: WorksheetColumn[], f: WorksheetColumnBlock[]);
    i(a: WorksheetTable[]): void;
    readonly d: WorksheetTable[];
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_MultiElementResizeChange extends WorksheetElementResizeContext {
    static $t: Type;
    private readonly ac;
    private readonly ad;
    constructor(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean, d: number);
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    readonly i: List$1<IndexRange>;
    protected get_r(): number;
    readonly r: number;
    protected get_w(): number;
    readonly w: number;
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_MultiElementVisibilityChange extends WorksheetElementResizeContext {
    static $t: Type;
    private readonly ac;
    private readonly ad;
    private readonly ae;
    constructor(a: Worksheet, b: boolean, c: number, d: number, e: List$1<IndexRange>);
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    readonly i: List$1<IndexRange>;
    protected get_r(): number;
    readonly r: number;
    protected get_w(): number;
    readonly w: number;
}
/**
 * @hidden
 */
export declare class IndexRange extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: number;
    readonly b: number;
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeState extends Base {
    static $t: Type;
    d: number;
    e: number;
    c: number;
    b: boolean;
    a: boolean;
    constructor(a: number, b: number, c: number, d: boolean, e: boolean);
}
/**
 * Represents a hyperlink for a cell or region.
 * @see [[Worksheet.hyperlinks]]
 * @see [[WorksheetCell.getHyperlink]]
 * @see [[WorksheetRow.getCellHyperlink]]
 */
export declare class WorksheetHyperlink extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _a;
    private _aj;
    private _r;
    private _q;
    private readonly _p;
    private _ak;
    private _h;
    private _k;
    private _n;
    private _ah;
    private _al;
    private _f;
    constructor(sourceAddress: string, target: any, displayText?: string, toolTip?: string);
    constructor(sourceCell: WorksheetCell, target: any, displayText?: string, toolTip?: string);
    constructor(sourceRegion: WorksheetRegion, target: any, displayText?: string, toolTip?: string);
    constructor(sourceCell: WorksheetCell, target: string, displayText: string, isSealed: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * Gets the string representation of the hyperlink.
     * @return The string representation of the hyperlink.
     */
    toString(): string;
    /**
     * @hidden
     */
    private _au;
    /**
     * @hidden
     */
    static _at(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _s(): boolean;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    _a3(a: Worksheet, b?: boolean, c?: boolean): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    _ax(a: Worksheet, b: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _az(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _a4(): void;
    /**
     * @hidden
     */
    private _a5;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    private _a7;
    /**
     * @hidden
     */
    private _a8;
    /**
     * @hidden
     */
    private _a9;
    /**
     * Gets or sets the text to display in the cell when the hyperlink is added to a worksheet, or null to use the target text.
     * <p class="note">
     * <b>Note: the display text will only get applied if the target cell has no value or a string value.</b>
     * </p>
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 2084 characters.
     */
    /**
    * Gets or sets the text to display in the cell when the hyperlink is added to a worksheet, or null to use the target text.
    * <p class="note">
    * <b>Note: the display text will only get applied if the target cell has no value or a string value.</b>
    * </p>
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 2084 characters.
    */
    displayText: string;
    /**
     * @hidden
     */
    private _ay;
    /**
     * Gets the value indicating whether the hyperlink is sealed and cannot be modified.
     */
    readonly isSealed: boolean;
    /**
     * Gets or sets the address of the cell or region on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned cannot be parsed as a cell or region address in the owning workbook's current
     * cell reference mode.
     * @see [[sourceCell]]
     * @see [[sourceRegion]]
     */
    /**
    * Gets or sets the address of the cell or region on which the hyperlink resides.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
    * @throws [[ArgumentException]] Occurs when the value assigned cannot be parsed as a cell or region address in the owning workbook's current
    * cell reference mode.
    * @see [[sourceCell]]
    * @see [[sourceRegion]]
    */
    sourceAddress: string;
    /**
     * @hidden
     */
    private _a0;
    /**
     * Gets or sets the cell on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
     * @see [[sourceAddress]]
     * @see [[sourceRegion]]
     */
    /**
    * Gets or sets the cell on which the hyperlink resides.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
    * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
    * @see [[sourceAddress]]
    * @see [[sourceRegion]]
    */
    sourceCell: WorksheetCell;
    /**
     * @hidden
     */
    private _a1;
    /**
     * Gets or sets the region on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
     * @see [[sourceCell]]
     * @see [[sourceRegion]]
     */
    /**
    * Gets or sets the region on which the hyperlink resides.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
    * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
    * @see [[sourceCell]]
    * @see [[sourceRegion]]
    */
    sourceRegion: WorksheetRegion;
    /**
     * @hidden
     */
    private _a2;
    /**
     * Gets or sets the target of the hyperlink, which can be a string, [[WorksheetCell]], [[WorksheetRegion]], or
     * [[NamedReference]] instance. For bookmarks in an external document, separate the sub-address with a #,
     * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
     * "mailto:joe@company.com?subject=Email%20Subject".
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is not a string, WorksheetCell, WorksheetRegion, or NamedReference instance.
     * @throws [[ArgumentException]] Occurs when the specified value is a string longer than 256 characters.
     * @throws [[ArgumentException]] Occurs when the value assigned is a cell or region which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    /**
    * Gets or sets the target of the hyperlink, which can be a string, [[WorksheetCell]], [[WorksheetRegion]], or
    * [[NamedReference]] instance. For bookmarks in an external document, separate the sub-address with a #,
    * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
    * "mailto:joe@company.com?subject=Email%20Subject".
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the value assigned is not a string, WorksheetCell, WorksheetRegion, or NamedReference instance.
    * @throws [[ArgumentException]] Occurs when the specified value is a string longer than 256 characters.
    * @throws [[ArgumentException]] Occurs when the value assigned is a cell or region which is not from the same workbook as the owning workbook of the hyperlink.
    * @see [[targetAddress]]
    * @see [[targetCell]]
    * @see [[targetRegion]]
    * @see [[targetNamedReference]]
    */
    target: any;
    /**
     * Gets or sets the target address of the hyperlink. For bookmarks in an external document, separate the sub-address with a #,
     * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
     * "mailto:joe@company.com?subject=Email%20Subject".
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
     * @see [[target]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    /**
    * Gets or sets the target address of the hyperlink. For bookmarks in an external document, separate the sub-address with a #,
    * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
    * "mailto:joe@company.com?subject=Email%20Subject".
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
    * @see [[target]]
    * @see [[targetCell]]
    * @see [[targetRegion]]
    * @see [[targetNamedReference]]
    */
    targetAddress: string;
    /**
     * Gets or sets the target cell of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a cell which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    /**
    * Gets or sets the target cell of the hyperlink.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the value assigned is a cell which is not from the same workbook as the owning workbook of the hyperlink.
    * @see [[target]]
    * @see [[targetAddress]]
    * @see [[targetRegion]]
    * @see [[targetNamedReference]]
    */
    targetCell: WorksheetCell;
    /**
     * Gets or sets the target named reference of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a named reference which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     */
    /**
    * Gets or sets the target named reference of the hyperlink.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the value assigned is a named reference which is not from the same workbook as the owning workbook of the hyperlink.
    * @see [[target]]
    * @see [[targetAddress]]
    * @see [[targetCell]]
    * @see [[targetRegion]]
    */
    targetNamedReference: NamedReference;
    /**
     * Gets or sets the target region of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a region which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetNamedReference]]
     */
    /**
    * Gets or sets the target region of the hyperlink.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the value assigned is a region which is not from the same workbook as the owning workbook of the hyperlink.
    * @see [[target]]
    * @see [[targetAddress]]
    * @see [[targetCell]]
    * @see [[targetNamedReference]]
    */
    targetRegion: WorksheetRegion;
    /**
     * Gets or sets the text to use in a tool tip when hovering over the source cell or region, or null to use the default tool tip.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
     */
    /**
    * Gets or sets the text to use in a tool tip when hovering over the source cell or region, or null to use the default tool tip.
    * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
    * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
    */
    toolTip: string;
    /**
     * Gets the worksheet to which the hyperlink belongs.
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    _t: boolean;
    /**
     * @hidden
     */
    readonly _o: WorksheetRegionAddress;
    /**
     * @hidden
     */
    private _v;
    /**
     * @hidden
     */
    private readonly _c;
}
/**
 * @hidden
 */
export declare class WorksheetHyperlinkCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetHyperlinkCollection, c: WorksheetHyperlink, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: WorksheetHyperlinkCollection;
    readonly a: WorksheetHyperlink;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetHyperlinkCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetHyperlinkCollection, c: List$1<Tuple$3<WorksheetHyperlink, number, WorksheetRegionAddress>>, d: List$1<Tuple$2<WorksheetHyperlink, WorksheetRegionAddress>>, e: List$1<WorksheetHyperlink>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetHyperlinkCollection;
    readonly b: Tuple$3<WorksheetHyperlink, number, WorksheetRegionAddress>[];
    readonly c: Tuple$2<WorksheetHyperlink, WorksheetRegionAddress>[];
    readonly a: WorksheetHyperlink[];
    e(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[WorksheetHyperlink]] instances in a [[Worksheet]].
 * @see [[Worksheet.hyperlinks]]
 */
export declare class WorksheetHyperlinkCollection extends Base implements ICollection$1<WorksheetHyperlink> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    static readonly _k: number;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    readonly _g: List$1<WorksheetHyperlink>;
    /**
     * @hidden
     */
    readonly _e: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    copyTo(array: WorksheetHyperlink[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds the specified hyperlink to the collection.
     * @param hyperlink The hyperlink to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
     * of the collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
     * reference mode of the owning workbook.
     */
    add(hyperlink: WorksheetHyperlink): void;
    /**
     * Clears all hyperlinks from the collection.
     */
    clear(): void;
    /**
     * Determines whether a hyperlink is in the collection.
     * @param hyperlink The hyperlink to locate in the collection.
     * @return True if the hyperlink is found; False otherwise.
     */
    contains(hyperlink: WorksheetHyperlink): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetHyperlink>;
    /**
     * Gets an enumerator which can iterator all hyperlinks in the collection.
     */
    getEnumerator(): IEnumerator$1<WorksheetHyperlink>;
    /**
     * Inserts the specified hyperlink in the collection.
     * @param index The 0-based index in the collection where the hyperlink should be inserted.
     * @param hyperlink The hyperlink to insert in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than [[count]].
     * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
     * of the collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
     * reference mode of the owning workbook.
     */
    insert(index: number, hyperlink: WorksheetHyperlink): void;
    /**
     * @hidden
     */
    _n(a: number, b: WorksheetHyperlink, c: boolean): void;
    /**
     * Removes the specified hyperlink from the collection.
     * @param hyperlink The hyperlink to remove from the collection.
     * @return True if the hyperlink was successfully removed from the collection;
     * False if the hyperlink did not exist in the collection.
     */
    remove(hyperlink: WorksheetHyperlink): boolean;
    /**
     * Removes the hyperlink at the specified index from the collection.
     * @param index The index of the hyperlink to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _q(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _s(a: number, b?: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _t;
    /**
     * @hidden
     */
    private static _u;
    /**
     * Gets the number of hyperlinks on the [[Worksheet]].
     */
    readonly count: number;
    /**
     * Gets the hyperlink at the specified index in the collection.
     * The hyperlink at the specified index.
     * @param index The zero-based index of the hyperlink to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetHyperlink;
}
/**
 * Represents any image on the worksheet except the background image.
 * @see [[Worksheet.imageBackground]]
 */
export declare class WorksheetImage extends WorksheetShape implements IWorksheetImage {
    static $t: Type;
    private _dv;
    private _dx;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(image: string);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    image: ExcelImage;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    preferredFormat: ImageFormat;
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _image: ExcelImage;
}
/**
 * @hidden
 */
export declare class WorksheetItemPosition extends ValueType implements IEquatable$1<WorksheetItemPosition> {
    static $t: Type;
    constructor(a: number, b: number, c: number, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly _g;
    private readonly _h;
    private readonly _k;
    equals1(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    readonly _l: number;
    readonly _i: number;
    readonly _j: number;
    readonly _m: number;
    equals(a: WorksheetItemPosition): boolean;
    static _a(a: WorksheetItemPosition, b: WorksheetItemPosition): boolean;
    static _b(a: Nullable$1<WorksheetItemPosition>, b: Nullable$1<WorksheetItemPosition>): boolean;
    static _c(a: WorksheetItemPosition, b: WorksheetItemPosition): boolean;
    static _d(a: Nullable$1<WorksheetItemPosition>, b: Nullable$1<WorksheetItemPosition>): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellsRegionCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetMergedCellsRegionCollection, c: WorksheetMergedCellsRegion, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetMergedCellsRegionCollection;
    readonly a: WorksheetMergedCellsRegion;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellsRegionCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetMergedCellsRegionCollection, c: List$1<Tuple$2<WorksheetMergedCellsRegion, WorksheetRegionAddress>>, d: List$1<Tuple$3<WorksheetMergedCellsRegion, number, WorksheetRegionAddress>>, e: List$1<WorksheetMergedCellsRegion>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetMergedCellsRegionCollection;
    readonly c: Tuple$2<WorksheetMergedCellsRegion, WorksheetRegionAddress>[];
    readonly b: Tuple$3<WorksheetMergedCellsRegion, number, WorksheetRegionAddress>[];
    readonly a: WorksheetMergedCellsRegion[];
    e(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[WorksheetMergedCellsRegion]] instances in a [[Worksheet]].
 * @see [[WorksheetMergedCellsRegion]]
 * @see [[Worksheet.mergedCellsRegions]]
 */
export declare class WorksheetMergedCellsRegionCollection extends Base implements ICollection$1<WorksheetMergedCellsRegion> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    static readonly _o: number;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    _j: List$1<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    _e: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    add(item: WorksheetMergedCellsRegion): void;
    /**
     * Creates new merged cell region and adds it to the collection.
     * <p class="body">
     * The new merged cell region will take its value from the first cell containing a value, starting at the top-left and going across
     * then down in the region. The value of all other cells will be lost. Similarly, the new region will initialize its cell format
     * from the first cell containing a non-default cell format.
     * </p>
     * @param firstRow The index of the first row of the merged cell region.
     * @param firstColumn The index of the first column of the merged cell region.
     * @param lastRow The index of the last row of the merged cell region.
     * @param lastColumn The index of the last row column of the merged cell region.
     * @throws [[InvalidOperationException]] 'firstRow' is greater than 'lastRow' or
     * 'firstColumn' is greater than 'lastColumn'.
     * @throws [[ArgumentOutOfRangeException]] Any row or column indices specified are outside the valid row or column ranges.
     * @throws [[InvalidOperationException]] The new merged cell region overlaps with an existing merged cell region.
     * @return The newly created [[WorksheetMergedCellsRegion]].
     */
    add(firstRow: number, firstColumn: number, lastRow: number, lastColumn: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _add$e(a: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    contains(item: WorksheetMergedCellsRegion): boolean;
    /**
     * @hidden
     */
    copyTo(array: WorksheetMergedCellsRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetMergedCellsRegion): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: number, b: number, c: number, d: number): WorksheetMergedCellsRegion;
    /**
     * Clears all merged cell regions from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     */
    clear(): void;
    /**
     * @hidden
     */
    _r(a: number, b: WorksheetMergedCellsRegion, c: boolean, d?: boolean): void;
    /**
     * Checks if any part of specified region is already a part of a merged cell region.
     * @param firstRow The index of the first row of the merged cell region.
     * @param firstColumn The index of the first column of the merged cell region.
     * @param lastRow The index of the last row of the merged cell region.
     * @param lastColumn The index of the last row column of the merged cell region.
     * @return True if any part of specified region is a part of merged cell region; False otherwise.
     */
    isOverlappingWithMergedRegion(firstRow: number, firstColumn: number, lastRow: number, lastColumn: number): boolean;
    /**
     * Removes the specified merged cell region from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     * @param region The merged cell region to remove from the collection.
     * @return True if the merged cell region was successfully removed; False if the merged cell region was not
     * in the collection.
     */
    remove_1(region: WorksheetMergedCellsRegion): boolean;
    /**
     * Removes the merged cell region at the specified index from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     * @param index The zero-based index of the merged cell region in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _s(a: CellShiftOperation, b: ICellShiftOperationOverride, c: List$1<WorksheetMergedCellsRegion>): void;
    /**
     * @hidden
     */
    _x(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _t;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private _y;
    /**
     * Gets the number of merged cell regions in the collection.
     * The number of merged cell regions in the collection.
     */
    readonly count: number;
    /**
     * Gets the merged cell region at the specified index.
     * The merged cell region at the specified index.
     * @param index The zero-based index of the merged cell region to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetMergedCellsRegion;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_HorizontalAddressSorter extends Base implements IComparer$1<WorksheetRegionAddress> {
    static $t: Type;
    static readonly _a: WorksheetRegion_HorizontalAddressSorter;
    constructor();
    static _b(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    static _c(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    compare(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_HorizontalWeakSorter extends Base implements IComparer$1<WeakReference> {
    static $t: Type;
    static readonly _a: WorksheetRegion_HorizontalWeakSorter;
    constructor();
    compare(a: WeakReference, b: WeakReference): number;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_VerticalSorter extends Base implements IComparer$1<WorksheetRegion> {
    static $t: Type;
    static readonly _a: WorksheetRegion_VerticalSorter;
    constructor();
    compare(a: WorksheetRegion, b: WorksheetRegion): number;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_VerticalAddressSorter extends Base implements IComparer$1<WorksheetRegionAddress> {
    static $t: Type;
    static readonly _a: WorksheetRegion_VerticalAddressSorter;
    constructor();
    static _b(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    static _c(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    compare(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
}
/**
 * @hidden
 */
export declare class RegionShiftComparer$1<T extends WorksheetRegion> extends Base implements IComparer$1<T> {
    static $t: Type;
    protected $t: Type;
    private _a;
    private _b;
    constructor($t: Type, a: CellShiftOperation);
    compare(a: T, b: T): number;
}
/**
 * @hidden
 */
export declare class MutableWorksheetRegionAddress extends Base {
    static $t: Type;
    private d;
    private h;
    private e;
    private i;
    constructor();
    readonly f: number;
    readonly j: number;
    readonly b: boolean;
    readonly c: boolean;
    readonly g: number;
    readonly k: number;
    n(): void;
    a(): WorksheetRegionAddress;
    toString(): string;
    m(a: CellReferenceMode, b: boolean): string;
    q(n: number, o: number): void;
    o(n: WorksheetCellAddress): void;
    p(n: WorksheetRegionAddress): void;
}
/**
 * @hidden
 */
export declare class CellFormatContext extends Base {
    static $t: Type;
    private a;
    private b;
    private d;
    constructor(a: number, b: WorksheetCellFormatData, c: WorksheetCellFormatData[]);
    c(a: WorksheetRow): WorksheetCellFormatProxy;
    readonly e: number;
}
/**
 * @hidden
 */
export declare class WorksheetRowOwnedCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected readonly _l: ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    readonly _q: ExcelChangeAction;
    protected get__v(): Worksheet;
    readonly _v: Worksheet;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove extends LoadOnDemandTree_ChangeHistoryItemRemove$1<WorksheetRow> {
    static $t: Type;
    constructor(a: number, b: number);
    d(a: number, b: number, c: number, d: boolean): number;
    e(a: number, b: number, c: boolean): number;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly a: ChangeInfo;
    readonly c: WorksheetRowCollection_CollectionChangeContext;
    private f;
    readonly d: boolean;
    readonly e: boolean;
    readonly b: WorksheetRow;
    constructor(a: ChangeInfo, b: WorksheetRowCollection_CollectionChangeContext, c: boolean, d: boolean, e: WorksheetRow);
    readonly g: any;
    h(): void;
    readonly count: number;
    readonly index: number;
    readonly shiftsColumns: boolean;
    readonly shiftsRows: boolean;
    readonly isRemoveOperation: boolean;
    readonly isUndoOperation: boolean;
    readonly performsShift: boolean;
    readonly worksheet: Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export interface IWorksheetShapeVisitor$2<TArg, TResult> {
    _visitDiamondShape$i(a: DiamondShape, b: TArg): TResult;
    _visitEllipseShape$i(a: EllipseShape, b: TArg): TResult;
    _visitHeartShape$i(a: HeartShape, b: TArg): TResult;
    _visitIrregularSeal1Shape$i(a: IrregularSeal1Shape, b: TArg): TResult;
    _visitIrregularSeal2Shape$i(a: IrregularSeal2Shape, b: TArg): TResult;
    _visitLightningBoltShape$i(a: LightningBoltShape, b: TArg): TResult;
    _visitLineShape$i(a: LineShape, b: TArg): TResult;
    _visitPentagonShape$i(a: PentagonShape, b: TArg): TResult;
    _visitRectangleShape$i(a: RectangleShape, b: TArg): TResult;
    _visitRightTriangleShape$i(a: RightTriangleShape, b: TArg): TResult;
    _visitStraightConnector1Shape$i(a: StraightConnector1Shape, b: TArg): TResult;
    _visitUnknownShape$i(a: UnknownShape, b: TArg): TResult;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: TArg): TResult;
    _visitWorksheetChart$i(a: WorksheetChart, b: TArg): TResult;
    _visitWorksheetImage$i(a: WorksheetImage, b: TArg): TResult;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IWorksheetShapeVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetShapeVisitor$2<TArg, TResult> extends Base implements IWorksheetShapeVisitor$2<TArg, TResult> {
    static $t: Type;
    protected $tArg: Type;
    protected $tResult: Type;
    constructor($tArg: Type, $tResult: Type);
    visitDiamondShape(value: DiamondShape, argument: TArg): TResult;
    _visitDiamondShape$i(a: DiamondShape, b: TArg): TResult;
    visitEllipseShape(value: EllipseShape, argument: TArg): TResult;
    _visitEllipseShape$i(a: EllipseShape, b: TArg): TResult;
    visitHeartShape(value: HeartShape, argument: TArg): TResult;
    _visitHeartShape$i(a: HeartShape, b: TArg): TResult;
    visitIrregularSeal1Shape(value: IrregularSeal1Shape, argument: TArg): TResult;
    _visitIrregularSeal1Shape$i(a: IrregularSeal1Shape, b: TArg): TResult;
    visitIrregularSeal2Shape(value: IrregularSeal2Shape, argument: TArg): TResult;
    _visitIrregularSeal2Shape$i(a: IrregularSeal2Shape, b: TArg): TResult;
    visitLightningBoltShape(value: LightningBoltShape, argument: TArg): TResult;
    _visitLightningBoltShape$i(a: LightningBoltShape, b: TArg): TResult;
    visitLineShape(value: LineShape, argument: TArg): TResult;
    _visitLineShape$i(a: LineShape, b: TArg): TResult;
    visitPentagonShape(value: PentagonShape, argument: TArg): TResult;
    _visitPentagonShape$i(a: PentagonShape, b: TArg): TResult;
    visitRectangleShape(value: RectangleShape, argument: TArg): TResult;
    _visitRectangleShape$i(a: RectangleShape, b: TArg): TResult;
    visitRightTriangleShape(value: RightTriangleShape, argument: TArg): TResult;
    _visitRightTriangleShape$i(a: RightTriangleShape, b: TArg): TResult;
    visitStraightConnector1Shape(value: StraightConnector1Shape, argument: TArg): TResult;
    _visitStraightConnector1Shape$i(a: StraightConnector1Shape, b: TArg): TResult;
    visitUnknownShape(value: UnknownShape, argument: TArg): TResult;
    _visitUnknownShape$i(a: UnknownShape, b: TArg): TResult;
    visitWorksheetCellComment(value: WorksheetCellComment, argument: TArg): TResult;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: TArg): TResult;
    visitWorksheetChart(value: WorksheetChart, argument: TArg): TResult;
    _visitWorksheetChart$i(a: WorksheetChart, b: TArg): TResult;
    visitWorksheetImage(value: WorksheetImage, argument: TArg): TResult;
    _visitWorksheetImage$i(a: WorksheetImage, b: TArg): TResult;
    visitWorksheetShapeGroup(value: WorksheetShapeGroupBase, argument: TArg): TResult;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: TArg): TResult;
    a(a: WorksheetShape, b: TArg): TResult;
    b(a: WorksheetShape, b: TArg): TResult;
    c(a: WorksheetShapeWithText, b: TArg): TResult;
}
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export declare class WorksheetShapeGroup extends WorksheetShapeGroupBase {
    static $t: Type;
    constructor();
    constructor(loading: boolean);
    constructor(..._rest: any[]);
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_AxisShiftInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: Axis, c: string, d: string);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: Axis;
    readonly c: string;
    readonly b: string;
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_SeriesShiftInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: Series, c: string, d: string, e: string, f: string);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: Series;
    readonly c: string;
    readonly b: string;
    readonly d: string;
    readonly e: string;
}
/**
 * Represents a sparkline cell
 */
export declare class Sparkline extends Base {
    static $t: Type;
    private _e;
    private _h;
    private _d;
    private _l;
    private _n;
    constructor();
    /**
     * The region containing the data for the sparkline (read-only)
     * The data region if it is located on a worksheet within the same workbook, otherwise null.
     */
    readonly dataRegion: WorksheetRegion;
    /**
     * A striing that describes the region containing the data for the sparkline (read-only)
     * Should always be non-null.
     */
    readonly dataRegionName: string;
    /**
     * The cell location of the sparkline (read-only)
     */
    readonly location: WorksheetRegion;
    /**
     * @hidden
     */
    readonly _m: WorksheetRegionAddress;
    /**
     * @hidden
     */
    readonly _f: Worksheet;
    /**
     * @hidden
     */
    readonly _i: WorksheetCellAddress;
    /**
     * @hidden
     */
    readonly _g: Worksheet;
    /**
     * @hidden
     */
    _a(): Sparkline;
    /**
     * @hidden
     */
    _p(a: WorksheetRegion, b: WorksheetRegion, c: string): void;
    /**
     * @hidden
     */
    _b(a: WorksheetRegionAddress): Sparkline;
    /**
     * @hidden
     */
    _c(a: number, b: number): Sparkline;
}
/**
 * @hidden
 */
export declare class SparklineCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineCollection, c: Sparkline, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: number;
    readonly b: SparklineCollection;
    readonly a: Sparkline;
    readonly f: number;
    readonly d: number;
    readonly h: string;
    readonly g: Nullable$1<WorksheetRegionAddress>;
    readonly c: Worksheet;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[Sparkline]]s exposed from a [[SparklineGroup]]
 */
export declare class SparklineCollection extends Base implements IEnumerable$1<Sparkline> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _g: SparklineGroup;
    private _l;
    static staticInit(): void;
    constructor(a: number, b: SparklineGroup);
    constructor(a: number, b: SparklineGroup, c: Sparkline[]);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns the total number of items in the collection.
     */
    readonly count: number;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number, b?: Sparkline): Sparkline;
    /**
     * @hidden
     */
    readonly _h: Workbook;
    /**
     * @hidden
     */
    readonly _i: Worksheet;
    /**
     * Adds a new [[SparklineGroup]] with no sparklines
     * @param row The zero-based row of the sparkline cell.
     * @param column The zero-based column of the sparkline cell.
     * @param dataRegion A string describing the data region.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dataRegion. If null it defaults to the workbook's mode.
     * @return The added sparkine
     */
    add(row: number, column: number, dataRegion: string, cellReferenceMode?: CellReferenceMode): Sparkline;
    /**
     * @hidden
     */
    _add$i(a: number, b: number, c: string, d?: Nullable$1<CellReferenceMode>): Sparkline;
    /**
     * Clears all items from the collection
     */
    clear(): void;
    /**
     * Returns true if the collection contains the item
     * @param sparkline The sparkline to check
     */
    contains(sparkline: Sparkline): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Sparkline>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Sparkline>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * Gets the index of the item in the collection
     * @param sparkline
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(sparkline: Sparkline): number;
    /**
     * Removes a sparkline from the collection
     * @param sparkline The sparkline to remove.
     * @return true if successful, otherwise false
     */
    remove(sparkline: Sparkline): boolean;
    /**
     * Removes a sparkline from the collection
     * @param index The zero-based index of the sparkline to remove.
     * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _s(a: number, b: Sparkline, c: WorksheetRegion, d: WorksheetRegion, e: string, f?: boolean): void;
    /**
     * @hidden
     */
    _c(a: Sparkline[]): Sparkline[];
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _r;
    /**
     * @hidden
     */
    private _u;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class SparklineGroup_RegionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroup, c: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: SparklineGroup;
    readonly c: string;
    readonly b: boolean;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents a group of [[Sparkline]]s
 */
export declare class SparklineGroup extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _bk;
    /**
     * @hidden
     */
    private static readonly _bl;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static _a;
    private _ai;
    private _m;
    private _y;
    private _x;
    private _r;
    private _w;
    private _s;
    private _u;
    private _t;
    private _v;
    private _ah;
    private _am;
    private _e;
    private _a2;
    private _a3;
    private _a1;
    private _p;
    private _k;
    private _g;
    private _h;
    private _by;
    private _o;
    static staticInit(): void;
    constructor(a: number, b: Worksheet);
    constructor(a: number, b: Worksheet, c: SparklineType);
    constructor(a: number, ..._rest: any[]);
    /**
     * Determines the color of the axis
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[dateAxis]]
     */
    /**
    * Determines the color of the axis
    * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[dateAxis]]
    */
    colorAxis: WorkbookColorInfo;
    /**
     * Determines the color of the first point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[firstPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[firstPoint]]
     */
    /**
    * Determines the color of the first point
    * <para class="note"><b>Note:</b> this property is ignored unless the [[firstPoint]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[firstPoint]]
    */
    colorFirstPoint: WorkbookColorInfo;
    /**
     * Determines the color of the high point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[highPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[highPoint]]
     */
    /**
    * Determines the color of the high point
    * <para class="note"><b>Note:</b> this property is ignored unless the [[highPoint]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[highPoint]]
    */
    colorHighPoint: WorkbookColorInfo;
    /**
     * Determines the color of the last point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[lastPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[lastPoint]]
     */
    /**
    * Determines the color of the last point
    * <para class="note"><b>Note:</b> this property is ignored unless the [[lastPoint]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[lastPoint]]
    */
    colorLastPoint: WorkbookColorInfo;
    /**
     * Determines the color of the low point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[lowPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[lowPoint]]
     */
    /**
    * Determines the color of the low point
    * <para class="note"><b>Note:</b> this property is ignored unless the [[lowPoint]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[lowPoint]]
    */
    colorLowPoint: WorkbookColorInfo;
    /**
     * Determines the color of the markers
     * <para class="note"><b>Note:</b> this property is ignored unless the [[markers]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[markers]]
     */
    /**
    * Determines the color of the markers
    * <para class="note"><b>Note:</b> this property is ignored unless the [[markers]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[markers]]
    */
    colorMarkers: WorkbookColorInfo;
    /**
     * Determines the color of the negative point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[negativePoints]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[negativePoints]]
     */
    /**
    * Determines the color of the negative point
    * <para class="note"><b>Note:</b> this property is ignored unless the [[negativePoints]] property is explicity set to true.</para>
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    * @see [[negativePoints]]
    */
    colorNegativePoints: WorkbookColorInfo;
    /**
     * Determines the default color for the series
     * The color to use for the series.
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     */
    /**
    * Determines the default color for the series
    * The color to use for the series.
    * @throws [[ArgumentNullException]] Color can't be set to null.
    * @throws [[ArgumentException]] Color can't be set to 'Auto'.
    */
    colorSeries: WorkbookColorInfo;
    /**
     * Determines whether to use a date axis
     * @see [[colorAxis]]
     * @see [[dateRange]]
     * @see [[setDateRange]]
     */
    /**
    * Determines whether to use a date axis
    * @see [[colorAxis]]
    * @see [[dateRange]]
    * @see [[setDateRange]]
    */
    dateAxis: boolean;
    /**
     * The date range (read-only)
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @see [[dateAxis]]
     * @see [[dateRangeFormula]]
     * @see [[setDateRange]]
     */
    readonly dateRange: WorksheetRegion;
    /**
     * The date range formula (read-only)
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @see [[dateAxis]]
     * @see [[dateRangeFormula]]
     * @see [[setDateRange]]
     */
    readonly dateRangeFormula: Formula;
    /**
     * Determines how blanks will be displayed
     */
    /**
    * Determines how blanks will be displayed
    */
    displayBlanksAs: SparklineDisplayBlanksAs;
    /**
     * Determines whether values from cells that are hidden will be displayed
     */
    /**
    * Determines whether values from cells that are hidden will be displayed
    */
    displayHidden: boolean;
    /**
     * Determines if the x-axis will be displayed
     */
    /**
    * Determines if the x-axis will be displayed
    */
    displayXAxis: boolean;
    /**
     * Determines if the first point is displayed differently.
     * @see [[colorFirstPoint]]
     */
    /**
    * Determines if the first point is displayed differently.
    * @see [[colorFirstPoint]]
    */
    firstPoint: boolean;
    /**
     * A unique identifier for this group (read-only).
     * <para class="note"><b>Note:</b> this property is optional but if one group contains a guid then all groups in the collection nust also have guids generated for them.</para>
     * @see [[SparklineGroupCollection.generateGuidsForGroups]]
     */
    /**
    * A unique identifier for this group (read-only).
    * <para class="note"><b>Note:</b> this property is optional but if one group contains a guid then all groups in the collection nust also have guids generated for them.</para>
    * @see [[SparklineGroupCollection.generateGuidsForGroups]]
    */
    guid: Guid | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _guid$i: Nullable$1<Guid>;
    /**
     * Determines if the high point is displayed differently.
     * @see [[colorHighPoint]]
     */
    /**
    * Determines if the high point is displayed differently.
    * @see [[colorHighPoint]]
    */
    highPoint: boolean;
    /**
     * Determines if the last point is displayed differently.
     * @see [[colorLastPoint]]
     */
    /**
    * Determines if the last point is displayed differently.
    * @see [[colorLastPoint]]
    */
    lastPoint: boolean;
    /**
     * Determines the weight of a line in points.
     * @throws [[ArgumentOutOfRangeException]] if the value is less than zero or greather than 1584.
     */
    /**
    * Determines the weight of a line in points.
    * @throws [[ArgumentOutOfRangeException]] if the value is less than zero or greather than 1584.
    */
    lineWeight: number;
    /**
     * Determines if the low point is displayed differently.
     * @see [[colorLowPoint]]
     */
    /**
    * Determines if the low point is displayed differently.
    * @see [[colorLowPoint]]
    */
    lowPoint: boolean;
    /**
     * Determines if markers are displayed.
     * @see [[colorMarkers]]
     */
    /**
    * Determines if markers are displayed.
    * @see [[colorMarkers]]
    */
    markers: boolean;
    /**
     * Determines if the negative points are displayed differently.
     * @see [[colorNegativePoints]]
     */
    /**
    * Determines if the negative points are displayed differently.
    * @see [[colorNegativePoints]]
    */
    negativePoints: boolean;
    /**
     * Determines if the sparkline goes from right to left.
     */
    /**
    * Determines if the sparkline goes from right to left.
    */
    rightToLeft: boolean;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    sparklines(index: number, value?: Sparkline): Sparkline;
    /**
     * The collection of sparklines in the group (read-only)
     */
    sparklines(): SparklineCollection;
    /**
     * @hidden
     */
    readonly _sparklines$i: SparklineCollection;
    /**
     * The type of sparkline
     */
    /**
    * The type of sparkline
    */
    type: SparklineType;
    /**
     * A custom maximum value for the Y axis.
     * <para class="note"><b>Note:</b> if [[verticalAxisMaxType]] property is not set to 'Custom' then this property is ignored.</para>
     * @see [[verticalAxisMaxType]]
     */
    /**
    * A custom maximum value for the Y axis.
    * <para class="note"><b>Note:</b> if [[verticalAxisMaxType]] property is not set to 'Custom' then this property is ignored.</para>
    * @see [[verticalAxisMaxType]]
    */
    verticalAxisMax: number;
    /**
     * Determines how the maximum value for the Y axis is calculated.
     * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMax]] value will be used.</para>
     * @see [[verticalAxisMax]]
     */
    /**
    * Determines how the maximum value for the Y axis is calculated.
    * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMax]] value will be used.</para>
    * @see [[verticalAxisMax]]
    */
    verticalAxisMaxType: SparklineAxisMinMax;
    /**
     * A custom minimum value for the Y axis.
     * <para class="note"><b>Note:</b> if [[verticalAxisMinType]] property is not set to 'Custom' then this property is ignored.</para>
     * @see [[verticalAxisMinType]]
     */
    /**
    * A custom minimum value for the Y axis.
    * <para class="note"><b>Note:</b> if [[verticalAxisMinType]] property is not set to 'Custom' then this property is ignored.</para>
    * @see [[verticalAxisMinType]]
    */
    verticalAxisMin: number;
    /**
     * Determines how the minimum value for the Y axis is calculated.
     * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMin]] value will be used.</para>
     * @see [[verticalAxisMin]]
     */
    /**
    * Determines how the minimum value for the Y axis is calculated.
    * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMin]] value will be used.</para>
    * @see [[verticalAxisMin]]
    */
    verticalAxisMinType: SparklineAxisMinMax;
    /**
     * Returns a reference to the associated worksheet.
     */
    readonly worksheet: Worksheet;
    /**
     * Returns a reference to the associated workbook.
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly _an: WorksheetRegionAddress;
    /**
     * @hidden
     */
    readonly _aj: Worksheet;
    /**
     * @hidden
     */
    readonly _au: boolean;
    /**
     * @hidden
     */
    readonly _av: boolean;
    /**
     * Assigns a new [[dateRange]].
     * <para class="note"><b>Note:</b> [[dateRange]] is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @param dateRange The string representation of the formula.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dateRange. If null it defaults to the workbook's mode.
     * @see [[dateRange]]
     */
    setDateRange(dateRange: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setDateRange$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    private _b9;
    /**
     * @hidden
     */
    _b0(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _b2(): void;
    /**
     * @hidden
     */
    _b1(): void;
    /**
     * @hidden
     */
    _b4(a: string, b: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _as;
    /**
     * @hidden
     */
    _b3(a: string): void;
    /**
     * @hidden
     */
    private _b5;
    /**
     * @hidden
     */
    private _b6;
    /**
     * @hidden
     */
    private _b7;
    /**
     * @hidden
     */
    private static _ca;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_GroupModifyInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: SparklineGroup, c: string, d: WorksheetRegionAddress, e: Sparkline[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: SparklineGroup;
    readonly d: string;
    readonly c: WorksheetRegionAddress;
    readonly a: Sparkline[];
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroupCollection, c: SparklineGroup, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: SparklineGroupCollection;
    readonly a: SparklineGroup;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroupCollection, c: List$1<SparklineGroupCollection_GroupModifyInfo>, d: List$1<Tuple$2<SparklineGroup, number>>, e: List$1<SparklineGroup>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: SparklineGroupCollection;
    readonly c: SparklineGroupCollection_GroupModifyInfo[];
    readonly b: Tuple$2<SparklineGroup, number>[];
    readonly a: SparklineGroup[];
    e(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[SparklineGroup]]s exposed from a [[worksheet]]
 */
export declare class SparklineGroupCollection extends Base implements IEnumerable$1<SparklineGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    static _p: List$1<SparklineGroupCollection_GroupModifyInfo>;
    /**
     * @hidden
     */
    static _o: List$1<Tuple$2<SparklineGroup, number>>;
    /**
     * @hidden
     */
    static _q: List$1<Sparkline>;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    _i: Worksheet;
    /**
     * @hidden
     */
    _r: List$1<SparklineGroup>;
    private _k;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total number of items in the collection.
     */
    readonly count: number;
    /**
     * Determines if guids will be generated for groups.
     * <para class="note"><b>Note:</b> if any group has a guid then all of them must also have guids. Therefore, when this property is set to true all
     * groups in the collection, including groups that are subsequently added, will have guids generated for them. Also note that this property can not be set to false
     * if the collection contains any group with a guid.</para>
     * @throws [[ArgumentException]] Can't set GenerateGuidsForGroups to false if the collection contains groups that already have guids generated.
     * @see [[SparklineGroup.guid]]
     */
    /**
    * Determines if guids will be generated for groups.
    * <para class="note"><b>Note:</b> if any group has a guid then all of them must also have guids. Therefore, when this property is set to true all
    * groups in the collection, including groups that are subsequently added, will have guids generated for them. Also note that this property can not be set to false
    * if the collection contains any group with a guid.</para>
    * @throws [[ArgumentException]] Can't set GenerateGuidsForGroups to false if the collection contains groups that already have guids generated.
    * @see [[SparklineGroup.guid]]
    */
    generateGuidsForGroups: boolean;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number): SparklineGroup;
    /**
     * @hidden
     */
    readonly _h: Workbook;
    /**
     * @hidden
     */
    readonly _j: Worksheet;
    /**
     * Adds a new [[SparklineGroup]]
     * @param type The type of the group.
     * @param locationRange The aggregated location for the sparklines in the group.
     * @param dataRange The aggreagated data range for all the sparklines in the group.
     * @param groupInitializer An optional callback for initializing the group before it is added to the collection.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the location and data ranges. If null it defaults to the workbook's mode.
     * @return The added group
     */
    add(type: SparklineType, locationRange: string, dataRange: string, groupInitializer?: (arg1: SparklineGroup) => void, cellReferenceMode?: CellReferenceMode): SparklineGroup;
    /**
     * @hidden
     */
    _add$i(a: SparklineType, b: string, c: string, d?: (arg1: SparklineGroup) => void, e?: Nullable$1<CellReferenceMode>): SparklineGroup;
    /**
     * Clears all items from the collection
     */
    clear(): void;
    /**
     * Returns true if the collection contains the item
     * @param group The group to check
     */
    contains(group: SparklineGroup): boolean;
    [Symbol.iterator](): EnumeratorWrapper<SparklineGroup>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<SparklineGroup>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * Gets the index of the item in the collection
     * @param group
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(group: SparklineGroup): number;
    /**
     * Removes a group from the collection
     * @param group The group to remove.
     * @return true if successful, otherwise false
     */
    remove(group: SparklineGroup): boolean;
    /**
     * Removes a group from the collection
     * @param index The zero-based index of the group to remove.
     * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _f(a: SparklineType): SparklineGroup;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _ae(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _af(a: Sparkline): void;
    /**
     * @hidden
     */
    _ab(a: IList$1<SparklineGroup>): void;
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _y;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _aj;
}
/**
 * Abstract base class for the sort conditions which describe how to sort data in a region.
 * @see [[SortSettings`1.sortConditions]]
 * @see [[WorksheetTableColumn.sortCondition]]
 * @see [[OrderedSortCondition]]
 * @see [[CustomListSortCondition]]
 * @see [[FontColorSortCondition]]
 * @see [[FillSortCondition]]
 */
export declare abstract class SortCondition extends Base {
    static $t: Type;
    private readonly _b;
    constructor(a: number);
    constructor(a: number, b: SortDirection);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    abstract _a(): SortCondition;
    /**
     * @hidden
     */
    abstract _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[SortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[SortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    abstract _f(a: SortCondition): boolean;
    /**
     * Gets the value which indicates the sort direction represented by the sort condition.
     * Either SortDirection.Ascending or SortDirection.Descending.
     */
    readonly sortDirection: SortDirection;
    /**
     * @hidden
     */
    abstract readonly _d: ST_SortBy;
}
/**
 * Represents a sort condition which will sort cells based on a custom, ordered list of values.
 * <p class="body">
 * When the sort direction is ascending, the data range is sorted with the cells in the custom list appearing first, in the order they
 * appear in the list, followed by the other cells in the same relative order they had to each other before the sort. When the sort direction
 * is descending, the cells not in the list will appear first in the data region and they will appear in the same relative order they
 * had before the sort. They will be followed by the other cells in the reverse order of the list.
 * </p>
 * <p class="body">
 * The list of values specified on this sort condition are string values. If a cell being sorted has a string value, that value is used to
 * sort the cell. Otherwise, the cell text is used. For example, if the cell's value is 0.01, but it is formatted as a percentage cell,
 * the text used to sort it with this sort condition will be "1%" and not "0.01". When using the cell text, if the format string for the
 * cell includes padding characters which are repeated across the cells, they will not be included in the cell text used for comparison.
 * </p>
 * <p class="body">
 * When matching values from a cell to values in the custom list, strings are compared case-sensitively or case-insensitively based
 * on the [[SortSettings`1.caseSensitive]] setting.
 * </p>
 * <p class="body">
 * If the cell text contains any repeated padding characters, they are ignored when comparing strings.
 * </p>
 * @see [[SortSettings`1.caseSensitive]]
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 */
export declare class CustomListSortCondition extends SortCondition {
    static $t: Type;
    private _j;
    constructor(sortDirection: SortDirection, ...list: string[]);
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[CustomListSortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CustomListSortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    readonly _d: ST_SortBy;
    /**
     * @hidden
     */
    _l(): string;
    /**
     * @hidden
     */
    private _k;
    /**
     * Gets the ordered list of values by which to sort.
     * <p class="body">
     * The list of values specified on this sort condition are string values. If a cell being sorted has a string value, that value is used to
     * sort the cell. Otherwise, the cell text is used. For example, if the cell's value is 0.01, but it is formatted as a percentage cell,
     * the text used to sort it with this sort condition will be "1%" and not "0.01". When using the cell text, if the format string for the
     * cell includes padding characters which are repeated across the cells, they will not be included in the cell text used for comparison.
     * </p>
     * <p class="body">
     * When matching values from a cell to values in the custom list, strings are compared case-sensitively or case-insensitively based
     * on the [[SortSettings`1.caseSensitive]] setting.
     * </p>
     * <p class="body">
     * If the cell text contains any repeated padding characters, they are ignored when comparing strings.
     * </p>
     * @see [[SortSettings`1.caseSensitive]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetRow.getCellText]]
     */
    readonly list: IEnumerable$1<string>;
}
/**
 * @hidden
 */
export interface IColorSortCondition {
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, a: IColorSortConditionVisitor$2<TArg, TResult>, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorSortCondition_$type: Type;
/**
 * Represents a sort condition which will sort cells based on their background fill.
 * <p class="body">
 * This sort condition specifies a single [[CellFill]]. Cells of this color will be moved to the beginning of the data range
 * for the ascending sort direction and moved to the end of the data range for the descending sort direction. All matching cells will
 * be kept in their same relative order to each other. In addition, all non-matching cells will be kept in their same relative order to
 * each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export declare class FillSortCondition extends SortCondition implements IColorSortCondition {
    static $t: Type;
    private readonly _i;
    constructor(fill: CellFill);
    constructor(fill: CellFill, sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorSortConditionVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[FillSortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FillSortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    readonly _d: ST_SortBy;
    /**
     * @hidden
     */
    static _k(a: WorkbookLoadManager, b: Nullable$1<number>, c: SortDirection): FillSortCondition;
    /**
     * Gets the [[CellFill]] by which the cells should be sorted.
     * <p class="body">
     * Cells with this fill will be moved to the beginning of the data range for the ascending sort direction and moved to the end
     * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
     * In addition, all non-matching cells will be kept in their same relative order to each other.
     * </p>
     * The CellFill by which the cells should be sorted.
     * @see [[SortCondition.sortDirection]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.fill]]
     */
    readonly fill: CellFill;
}
/**
 * Represents a sort condition which will sort cells based on their fonts colors.
 * <p class="body">
 * This sort condition specifies a single color. Cells of this color will be moved to the beginning of the data range for the ascending
 * sort direction and moved to the end of the data range for the descending sort direction. All matching cells will be kept in their same
 * relative order to each other. In addition, all non-matching cells will be kept in their same relative order to each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export declare class FontColorSortCondition extends SortCondition implements IColorSortCondition {
    static $t: Type;
    private readonly _j;
    constructor(fontColorInfo: WorkbookColorInfo);
    constructor(fontColorInfo: WorkbookColorInfo, sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorSortConditionVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[FontColorSortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FontColorSortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    readonly _d: ST_SortBy;
    /**
     * @hidden
     */
    static _i(a: WorkbookLoadManager, b: Nullable$1<number>, c: SortDirection): FontColorSortCondition;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the color by which the cells should be sorted.
     * <p class="body">
     * Cells of this color will be moved to the beginning of the data range for the ascending sort direction and moved to the end
     * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
     * In addition, all non-matching cells will be kept in their same relative order to each other.
     * </p>
     * The WorkbookColorInfo which describes the color by which the cells should be sorted.
     * @see [[SortCondition.sortDirection]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.font]]
     * @see [[IWorkbookFont.colorInfo]]
     */
    readonly fontColorInfo: WorkbookColorInfo;
}
/**
 * @hidden
 */
export interface IColorSortConditionVisitor$2<TArg, TResult> {
    _visitFillSortCondition$i(a: FillSortCondition, b: TArg): TResult;
    _visitFontColorSortCondition$i(a: FontColorSortCondition, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorSortConditionVisitor$2_$type: Type;
/**
 * Represents a sort condition which will sort cells based on a specific conditioanl formmat icon.
 * <p class="body">
 * This sort condition specifies a single icon. Cells with this icon will be moved to the beginning of the data range for the ascending
 * sort direction and moved to the end of the data range for the descending sort direction. All matching cells will be kept in their same
 * relative order to each other. In addition, all non-matching cells will be kept in their same relative order to each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export declare class IconSortCondition extends SortCondition {
    static $t: Type;
    private readonly _l;
    private readonly _j;
    constructor(ascending: boolean, iconSetInternal: ST_IconSetType, iconIndex: Nullable$1<number>);
    constructor(iconSet: FormatConditionIconSet, iconIndex: Nullable$1<number>);
    constructor(iconSet: FormatConditionIconSet, iconIndex: Nullable$1<number>, sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    readonly _d: ST_SortBy;
    /**
     * The icon set (read-only).
     */
    readonly iconIndex: number | null;
    /**
     * @hidden
     */
    readonly _iconIndex$i: Nullable$1<number>;
    /**
     * The icon's index in the associated icon set or null for 'NoCellIcon' (read-only).
     */
    readonly iconSet: FormatConditionIconSet;
    /**
     * @hidden
     */
    readonly _n: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _k: ST_IconSetType;
}
/**
 * Represents an ordered sort condition, which can sort data in either an ascending or descending manner.
 * @see [[SortSettings`1.sortConditions]]
 */
export declare class OrderedSortCondition extends SortCondition {
    static $t: Type;
    constructor();
    constructor(sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    readonly _d: ST_SortBy;
    /**
     * @hidden
     */
    static _i<T extends ISortable>($t: Type, a: SortSettings$1<T>, b: Worksheet, c: any, d: any): number;
}
/**
 * @hidden
 */
export declare class SortConditionCollection_SortChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: SortConditionCollection$1<T>, c: KeyValuePair$2<T, SortCondition>, d: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: SortConditionCollection$1<T>;
    readonly b: KeyValuePair$2<T, SortCondition>;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * An ordered collection of sort conditions which are applied to a sort-able regions in a worksheet.
 * <p class="body">
 * The sort conditions in the collection are applied in order to the data.
 * </p>
 * <p class="note">
 * <B>Note:</B> The collection can hold a maximum of 64 sort condition.
 * </p>
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[SortSettings`1.sortConditions]]
 */
export declare class SortConditionCollection$1<T extends ISortable> extends Base implements IDictionary$2<T, SortCondition>, IList$1<KeyValuePair$2<T, SortCondition>> {
    static $t: Type;
    protected $t: Type;
    private _d;
    /**
     * @hidden
     */
    _f: SortSettings$1<T>;
    /**
     * @hidden
     */
    _j: List$1<KeyValuePair$2<T, SortCondition>>;
    private _e;
    constructor($t: Type, a: SortSettings$1<T>);
    /**
     * @hidden
     */
    containsKey(key: T): boolean;
    /**
     * @hidden
     */
    _containsKey$i(a: T): boolean;
    /**
     * @hidden
     */
    readonly keys: ICollection$1<T>;
    /**
     * @hidden
     */
    tryGetValue(key: T, value: SortCondition): {
        ret: boolean;
        p1: SortCondition;
    };
    /**
     * @hidden
     */
    _tryGetValue$i(a: T, b: SortCondition): {
        ret: boolean;
        p1: SortCondition;
    };
    /**
     * @hidden
     */
    readonly values: ICollection$1<SortCondition>;
    /**
     * @hidden
     */
    indexOf(item: KeyValuePair$2<T, SortCondition>): number;
    /**
     * Gets the index of the specified sort condition in the collection.
     * @param sortCondition The sort condition to find in the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return The 0-based index of the specified sort condition in the collection or -1 if the item is not in the collection.
     */
    indexOf(sortCondition: SortCondition): number;
    /**
     * Gets the index of the specified sort-able item in the collection.
     * @param sortableItem The sort-able item to find in the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return The 0-based index of the specified sort-able item in the collection or -1 if the item is not in the collection.
     */
    indexOf(sortableItem: T): number;
    /**
     * @hidden
     */
    _indexOf$e(a: KeyValuePair$2<T, SortCondition>): number;
    /**
     * @hidden
     */
    insert(index: number, item: KeyValuePair$2<T, SortCondition>): void;
    /**
     * Inserts a sort condition into the collection.
     * @param index The 0-based index where the sort condition should be inserted.
     * @param sortableItem The sort-able item over which the sort condition will be applied.
     * @param sortCondition The sort condition to apply to the sort-able item.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @throws [[ArgumentException]] 'sortableItem' is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    insert(index: number, sortableItem: T, sortCondition: SortCondition): void;
    /**
     * @hidden
     */
    _insert$e(a: number, b: KeyValuePair$2<T, SortCondition>): void;
    /**
     * @hidden
     */
    add(item: KeyValuePair$2<T, SortCondition>): void;
    /**
     * @hidden
     */
    contains(item: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * Determines whether the specified sort condition is in the collection.
     * @param sortCondition The sort condition to find in the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return True if the sort condition is in the collection; False otherwise.
     */
    contains(sortCondition: SortCondition): boolean;
    /**
     * Determines whether the specified sort-able item is in the collection.
     * @param sortableItem The sort-able item to find in the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return True if the sort-able item is in the collection; False otherwise.
     */
    contains(sortableItem: T): boolean;
    /**
     * @hidden
     */
    _contains$e(a: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * @hidden
     */
    copyTo(array: KeyValuePair$2<T, SortCondition>[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    /**
     * @hidden
     */
    remove(item: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * Removes a sort condition from the collection.
     * @param sortCondition The sort condition to remove from the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return True if the sort condition was found and removed; False otherwise.
     */
    remove(sortCondition: SortCondition): boolean;
    /**
     * @hidden
     */
    _remove$e(a: KeyValuePair$2<T, SortCondition>): boolean;
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<T, SortCondition>>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<KeyValuePair$2<T, SortCondition>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a sort condition to the collection.
     * @param sortableItem The sort-able item over which the sort condition will be applied.
     * @param sortCondition The sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @throws [[ArgumentException]] 'sortableItem' is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    addItem(sortableItem: T, sortCondition: SortCondition): void;
    /**
     * @hidden
     */
    _addItem$i(a: T, b: SortCondition): void;
    /**
     * @hidden
     */
    _add2(a: T, b: SortCondition, c?: boolean): void;
    /**
     * Adds a range of sort conditions to the collection.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    addRange(entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * @hidden
     */
    _contains2(a: T): boolean;
    /**
     * @hidden
     */
    _contains1(a: SortCondition): boolean;
    /**
     * @hidden
     */
    _indexOf2(a: T): number;
    /**
     * @hidden
     */
    _indexOf1(a: SortCondition): number;
    /**
     * @hidden
     */
    _insert1(a: number, b: T, c: SortCondition): void;
    /**
     * Inserts a range of sort conditions into the collection.
     * @param index The 0-based index where the sort condition should be inserted.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    insertRange(index: number, entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * @hidden
     */
    private _y;
    /**
     * Removes a sort-able item from the collection.
     * @param sortableItem The sort-able item to remove from the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return True if the sort-able item was found and removed; False otherwise.
     */
    removeItem(sortableItem: T): boolean;
    /**
     * @hidden
     */
    _removeItem$i(a: T): boolean;
    /**
     * @hidden
     */
    _remove2(a: SortCondition): boolean;
    /**
     * Removes the sort condition at the specified index.
     * @param index The 0-based index of the sort condition to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Clears the existing sort conditions from the collection and replaces them with new entries in a single atomic operation.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are more than 64 sort conditions.
     */
    replaceAll(entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * @hidden
     */
    _s(a: T, b: SortCondition): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    _ad(a: T): void;
    /**
     * @hidden
     */
    _ag(a: Tuple$3<T, number, SortCondition>[]): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private _aj;
    /**
     * Gets the number of sort conditions in the collection.
     */
    readonly count: number;
    /**
     * Gets or sets the sort condition for the specified sort-able item.
     * @param sortableItem The sort-able item for which to get or set the sort condition.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[InvalidOperationException]] The sort-able item is not already in the collection and there are already 64 sort conditions in the collection.
     */
    item(sortableItem: T, value?: SortCondition): SortCondition;
    /**
     * Gets or sets the pair of item and sort condition at the specified index.
     * @param index The index at which to get the pair of item and sort condition.
     * @throws [[ArgumentNullException]] The Key or Value of the assigned value is null.
     * @throws [[InvalidOperationException]] The Key of the assigned value already in the collection at a different index.
     */
    item(index: number, value?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * @hidden
     */
    _item1(a: number, b?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * @hidden
     */
    _item(a: T, b?: SortCondition): SortCondition;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _o;
}
/**
 * @hidden
 */
export declare class SortConditionCollection_KeysCollection$1<T extends ISortable> extends Base implements ICollection$1<T> {
    static $t: Type;
    protected $t: Type;
    private _a;
    constructor($t: Type, a: SortConditionCollection$1<T>);
    private _b;
    add(a: T): void;
    clear(): void;
    contains(a: T): boolean;
    copyTo(a: T[], b: number): void;
    readonly count: number;
    readonly isReadOnly: boolean;
    remove(a: T): boolean;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<T>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class SortConditionCollection_ValuesCollection$1<T extends ISortable> extends Base implements ICollection$1<SortCondition> {
    static $t: Type;
    protected $t: Type;
    private _a;
    constructor($t: Type, a: SortConditionCollection$1<T>);
    private _b;
    add(a: SortCondition): void;
    clear(): void;
    contains(a: SortCondition): boolean;
    copyTo(a: SortCondition[], b: number): void;
    readonly count: number;
    readonly isReadOnly: boolean;
    remove(a: SortCondition): boolean;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<SortCondition>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class SortSettings_SortChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: SortSettings$1<T>);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: SortSettings$1<T>;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class SortSettings_ShiftFormulaChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: CellShiftOperation, c: Formula);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    private readonly a;
    private readonly b;
    c(): void;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Represents the settings which apply to sorting a region of values.
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[WorksheetTable.sortSettings]]
 */
export declare class SortSettings$1<T extends ISortable> extends Base {
    static $t: Type;
    protected $t: Type;
    private _l;
    /**
     * @hidden
     */
    _d: ISortSettingsOwner;
    private _f;
    private _p;
    private _h;
    private _k;
    constructor($t: Type, a: ISortSettingsOwner, b: (arg1: T) => void);
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _v(a: SortSettings$1<T>): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _ag(a: T): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _u(a: ExcelChangeAction): any;
    /**
     * @hidden
     */
    _x(a: any): void;
    /**
     * @hidden
     */
    private static _aa;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * @hidden
     */
    private static _ac;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets or sets the value which indicates whether strings should be compared case-sensitively when they are sorted.
     * <p class="body">
     * This is only applicable to sort conditions which sort strings.
     * </p>
     * True to sort strings case-sensitively; False to ignore case.
     */
    /**
    * Gets or sets the value which indicates whether strings should be compared case-sensitively when they are sorted.
    * <p class="body">
    * This is only applicable to sort conditions which sort strings.
    * </p>
    * True to sort strings case-sensitively; False to ignore case.
    */
    caseSensitive: boolean;
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets or sets the sort condition for the specified sort-able item.
     * @param sortableItem The sort-able item for which to get or set the sort condition.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[InvalidOperationException]] The sort-able item is not already in the collection and there are already 64 sort conditions in the collection.
     */
    sortConditions(sortableItem: T, value?: SortCondition): SortCondition;
    /**
     * Gets or sets the pair of item and sort condition at the specified index.
     * @param index The index at which to get the pair of item and sort condition.
     * @throws [[ArgumentNullException]] The Key or Value of the assigned value is null.
     * @throws [[InvalidOperationException]] The Key of the assigned value already in the collection at a different index.
     */
    sortConditions(index: number, value?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * Gets the collection of sort conditions to use when sorting the region of data.
     * <p class="body">
     * If these settings are used in a [[WorksheetTable]], each sort condition in the collection applies to a
     * [[WorksheetTableColumn]].
     * </p>
     * <p class="body">
     * This collection is ordered based on precedence. The first sort condition in the collection has the highest sort precedence.
     * </p>
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    sortConditions(): SortConditionCollection$1<T>;
    /**
     * @hidden
     */
    readonly _sortConditions$i: SortConditionCollection$1<T>;
    /**
     * @hidden
     */
    readonly _n: boolean;
    /**
     * @hidden
     */
    readonly _o: boolean;
    /**
     * @hidden
     */
    readonly _e: ISortSettingsOwner;
    /**
     * @hidden
     */
    readonly _q: CultureInfo;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _i: SortMethod;
    /**
     * @hidden
     */
    protected get__j(): WorksheetSortType;
    /**
     * @hidden
     */
    readonly _j: WorksheetSortType;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    private static readonly _s;
}
/**
 * @hidden
 */
export declare class SortSettings_ColumnIndexComparer$1<T extends ISortable> extends Base implements IComparer$1<number> {
    static $t: Type;
    protected $t: Type;
    private _c;
    private _a;
    private _b;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet, c: number);
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class SortSettings_RowIndexComparer$1<T extends ISortable> extends Base implements IComparer$1<number> {
    static $t: Type;
    protected $t: Type;
    private _c;
    private _a;
    private _b;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet, c: number);
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class SortSettings_VisibleRowIndexBlock$1<T extends ISortable> extends Base {
    static $t: Type;
    protected $t: Type;
    b: number;
    readonly c: number;
    constructor($t: Type, a: number);
    readonly a: number;
}
/**
 * @hidden
 */
export declare class SortSettings_SortOperation$1<T extends ISortable> extends Base {
    static $t: Type;
    protected $t: Type;
    readonly b: SortSettings$1<T>;
    readonly c: Worksheet;
    private d;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet);
    a(a: number, b: number): CellConditionalFormat;
}
/**
 * Represents the settings which apply to sorting a region of values based on indices relative to either the Worksheet's [[Worksheet.filterSettings]] or [[Worksheet.sortSettings]] region.
 */
export declare class RelativeIndexSortSettings extends SortSettings$1<RelativeIndex> {
    static $t: Type;
    private _ah;
    constructor(a: ISortSettingsOwner, b: (arg1: RelativeIndex) => void);
    /**
     * @hidden
     */
    _w(): void;
    /**
     * Initializes the region to null
     */
    protected initializeRegion(): void;
    /**
     * @hidden
     */
    _aj(a: WorksheetRegionAddress, b: WorksheetRegionAddress, c: CellShiftOperation): void;
    /**
     * @hidden
     */
    _ak(a: number): void;
    /**
     * @hidden
     */
    _al(): void;
}
/**
 * Exposes methods to identify a region in the wroksheet and to apply sort criteria to that region.
 */
export declare class WorksheetSortSettings extends RelativeIndexSortSettings implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a3;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _am;
    private _a7;
    private _a8;
    private _ay;
    private _as;
    private _a6;
    private _ar;
    private _aw;
    private _a1;
    constructor(a: Worksheet, b: (arg1: RelativeIndex) => void);
    /**
     * Initializes the region to null
     */
    protected initializeRegion(): void;
    /**
     * @hidden
     */
    protected get__j(): WorksheetSortType;
    /**
     * Returns the region that the filter settings is applied to (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    readonly region: WorksheetRegion;
    /**
     * Determines whether columns or rows will be sorted within the region. 'Rows' is the default.
     * <para class="note"><b>Note:</b> when this property is changed all existing sort conditions will be cleared so this property should be set before sort conditions are added.</para>
     */
    /**
    * Determines whether columns or rows will be sorted within the region. 'Rows' is the default.
    * <para class="note"><b>Note:</b> when this property is changed all existing sort conditions will be cleared so this property should be set before sort conditions are added.</para>
    */
    sortType: WorksheetSortType;
    /**
     * @hidden
     */
    private _bk;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _au;
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _av;
    /**
     * @hidden
     */
    private _bi;
    /**
     * Clears the region as well as any existing sort criteria
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    clearRegion(): void;
    /**
     * Re-sorts all data cells in the region based on the sort conditions.
     * @see [[SortSettings`1.sortConditions]]
     */
    reapplySortConditions(): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="body">The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.</p>
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @param cellReferenceMode The reference to use the parse the address.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setRegion(a: string): void;
    /**
     * @hidden
     */
    _setRegion1(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _bj(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _bb(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _aq(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    /**
     * @hidden
     */
    _bl(a: boolean): void;
    /**
     * @hidden
     */
    _bm(): void;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    private _ba;
    /**
     * @hidden
     */
    private _az;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _a0;
    /**
     * @hidden
     */
    private _be;
    /**
     * @hidden
     */
    private _bo;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
    /**
     * @hidden
     */
    readonly source: any;
}
/**
 * Represents the diamond shape.
 */
export declare class DiamondShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the ellipse shape.
 */
export declare class EllipseShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the heart shape.
 */
export declare class HeartShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the irregular seal 1 shape.
 */
export declare class IrregularSeal1Shape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the irregular seal 2 shape.
 */
export declare class IrregularSeal2Shape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the lightning bolt shape.
 */
export declare class LightningBoltShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the line shape.
 */
export declare class LineShape extends WorksheetShape {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the pentagon shape.
 */
export declare class PentagonShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the rectangle shape.
 */
export declare class RectangleShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the right triangle shape.
 */
export declare class RightTriangleShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * Represents the straight connector 1 shape.
 */
export declare class StraightConnector1Shape extends WorksheetShape {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    readonly _b0: Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    readonly _b1: Nullable$1<ST_ShapeType>;
}
/**
 * @hidden
 */
export declare class AddInFunctionResolver extends FormulaTokenEvaluator$1<FormulaToken> {
    static $t: Type;
    private static bh;
    constructor();
    protected a5(a: BinaryOperatorToken, b: FormulaToken, c: FormulaToken): FormulaToken;
    protected a6(a: IFunctionToken, b: FormulaToken, c: FormulaToken[]): FormulaToken;
    protected a7(a: OperandToken): FormulaToken;
    protected a8(a: ParenToken, b: FormulaToken): FormulaToken;
    protected a9(a: UnaryOperatorToken, b: FormulaToken): FormulaToken;
    static bi(a: FormulaContext): AddInFunctionResolver;
}
/**
 * @hidden
 */
export declare class CellAddress extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: boolean, d: number, e: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly s;
    private readonly o;
    private readonly q;
    private readonly f;
    equals(a: any): boolean;
    getHashCode(): number;
    static u(a: number, b: number, c?: WorkbookFormat, d?: boolean, e?: boolean, f?: number, g?: number, h?: boolean, i?: CellReferenceMode): string;
    static v(a: number, b: boolean, c: WorkbookFormat, d: number, e: boolean, f: CellReferenceMode): string;
    static w(a: number, b: boolean, c: number, d: number, e: boolean, f: CellReferenceMode): string;
    static x(a: number, b: boolean, c: WorkbookFormat, d: number, e: boolean, f: CellReferenceMode): string;
    static y(a: number, b: boolean, c: number, d: number, e: boolean, f: CellReferenceMode): string;
    a(a: FormulaContext, b: Point, c?: boolean): CellAddress;
    b(a: WorkbookFormat, b: WorkbookFormat, c: boolean): CellAddress;
    c(a: FormulaContext, b: boolean): CellAddress;
    e(a: FormulaContext, b: boolean, c?: boolean): WorksheetCellAddress;
    d(a: FormulaContext): CellAddress;
    z(a: FormulaContext, b: boolean): string;
    aa(a: FormatLimitErrors, b: WorkbookFormat): void;
    ab(a: FormatLimitErrors, b: WorkbookFormat, c: boolean, d: boolean): void;
    readonly r: number;
    readonly g: boolean;
    readonly h: boolean;
    readonly t: number;
    readonly p: boolean;
    static i(a: CellAddress, b: CellAddress): boolean;
    static j(a: Nullable$1<CellAddress>, b: Nullable$1<CellAddress>): boolean;
    static k(a: CellAddress, b: CellAddress): boolean;
    static l(a: Nullable$1<CellAddress>, b: Nullable$1<CellAddress>): boolean;
}
/**
 * @hidden
 */
export declare class CellAddressRange extends ValueType {
    static $t: Type;
    constructor(a: number, b: CellAddress, c: CellAddress);
    constructor(a: number, b: WorksheetRegion);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly a;
    equals(a: any): boolean;
    getHashCode(): number;
    i(a: FormulaContext, b: boolean): WorksheetRegion;
    j(a: Worksheet, b: number, c: number, d: boolean): WorksheetRegion;
    e(a: FormulaContext, b: Point, c?: boolean): CellAddressRange;
    f(a: WorkbookFormat, b: WorkbookFormat, c: boolean): CellAddressRange;
    g(a: FormulaContext, b: boolean): CellAddressRange;
    k(a: FormulaContext, b: boolean, c?: boolean): WorksheetRegionAddress;
    h(a: FormulaContext): CellAddressRange;
    s(a: FormulaContext, b: boolean): string;
    t(a: FormatLimitErrors, b: WorkbookFormat): void;
    readonly b: CellAddress;
    readonly l: boolean;
    readonly d: CellAddress;
    static m(a: CellAddressRange, b: CellAddressRange): boolean;
    static n(a: Nullable$1<CellAddressRange>, b: Nullable$1<CellAddressRange>): boolean;
    static o(a: CellAddressRange, b: CellAddressRange): boolean;
    static p(a: Nullable$1<CellAddressRange>, b: Nullable$1<CellAddressRange>): boolean;
}
/**
 * @hidden
 */
export declare class FormulaParser_FormulaTokenInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: FormulaToken, c: number, d: AttrSpaceToken[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FormulaToken;
    a: AttrSpaceToken[];
    c: number;
    d(a: AttrSpaceToken[]): void;
}
/**
 * @hidden
 */
export declare class FormulaParser_SelectorFunctionOptimizationInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: ISelectorFunctionOptimizationToken);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: List$1<AttrSkipToken>;
    readonly a: ISelectorFunctionOptimizationToken;
}
/**
 * @hidden
 */
export declare class FormulaParser_PositionInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number, d: FormulaParser_TextSpan);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    private readonly c;
    private readonly e;
    readonly b: FormulaParser_TextSpan;
    readonly d: number;
    readonly f: number;
}
/**
 * @hidden
 */
export declare class FormulaParser_StructuredTableReferenceParser extends Base {
    static $t: Type;
    private a;
    constructor(a: FormulaParser);
    c(a: string, b: string, c: FormulaParser_TextSpan): boolean;
    private d;
    private e;
    private m;
    private f;
    private b;
    private l;
    private g;
    private n;
    private h;
    private i;
    private j;
    private k;
}
/**
 * @hidden
 */
export declare class FormulaParser_TextSpan extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly a: FormulaParser_TextSpan;
    readonly c: number;
    readonly d: number;
    readonly b: boolean;
}
/**
 * @hidden
 */
export declare class FormulaParser_WorksheetReferenceInfo extends ValueType {
    static $t: Type;
    constructor();
    b: string;
    c: string;
    d: string;
    a: boolean;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor$2<TArgument, TResult> extends Base {
    static $t: Type;
    protected $tArgument: Type;
    protected $tResult: Type;
    private b;
    private az;
    private aw;
    constructor($tArgument: Type, $tResult: Type);
    d(a: FormulaToken, b: TArgument): TResult;
    protected a1(): void;
    a2(): void;
    ax(a: TArgument): boolean;
    protected ay(a: TArgument, b: FormulaToken): {
        ret: boolean;
        p1: FormulaToken;
    };
    e(a: Area3DNToken, b: TArgument): TResult;
    f(a: Area3DToken, b: TArgument): TResult;
    g(a: AreaErr3DToken, b: TArgument): TResult;
    h(a: AreaErrToken, b: TArgument): TResult;
    i(a: AreaNToken, b: TArgument): TResult;
    j(a: AreaToken, b: TArgument): TResult;
    k(a: ArrayToken, b: TArgument): TResult;
    l(a: AttrChooseToken, b: TArgument): TResult;
    m(a: AttrIfToken, b: TArgument): TResult;
    n(a: AttrSkipToken, b: TArgument): TResult;
    o(a: AttrSpaceToken, b: TArgument): TResult;
    p(a: AttrSumToken, b: TArgument): TResult;
    q(a: AttrVolatileToken, b: TArgument): TResult;
    r(a: BinaryOperatorToken, b: TArgument): TResult;
    s(a: BoolToken, b: TArgument): TResult;
    t(a: CellReferenceToken, b: TArgument): TResult;
    u(a: ErrToken, b: TArgument): TResult;
    v(a: ExpToken, b: TArgument): TResult;
    w(a: FunctionOperator, b: TArgument): TResult;
    x(a: IFunctionToken, b: TArgument): TResult;
    y(a: FunctionVOperator, b: TArgument): TResult;
    z(a: IntToken, b: TArgument): TResult;
    aa(a: MemAreaOperator, b: TArgument): TResult;
    ab(a: MemErrOperator, b: TArgument): TResult;
    ac(a: MemFuncOperator, b: TArgument): TResult;
    ad(a: MemNoMemOperator, b: TArgument): TResult;
    ae(a: MissArgToken, b: TArgument): TResult;
    af(a: NameToken, b: TArgument): TResult;
    ag(a: NameXToken, b: TArgument): TResult;
    ah(a: NumberToken, b: TArgument): TResult;
    ai(a: OperandToken, b: TArgument): TResult;
    aj(a: ParenToken, b: TArgument): TResult;
    am(a: ReferenceToken, b: TArgument): TResult;
    ak(a: Ref3DNToken, b: TArgument): TResult;
    al(a: Ref3DToken, b: TArgument): TResult;
    an(a: RefErr3dToken, b: TArgument): TResult;
    ao(a: RefErrToken, b: TArgument): TResult;
    ap(a: RefNToken, b: TArgument): TResult;
    aq(a: RefToken, b: TArgument): TResult;
    ar(a: StrToken, b: TArgument): TResult;
    as(a: StructuredTableReference, b: TArgument): TResult;
    at(a: TblToken, b: TArgument): TResult;
    protected au(a: FormulaToken, b: TArgument, c: FormulaToken): {
        ret: TResult;
        p2: FormulaToken;
    };
    av(a: UnaryOperatorToken, b: TArgument): TResult;
    c: FormulaContext;
    protected a0: number;
    protected get_a(): FormulaToken[];
    protected readonly a: FormulaToken[];
}
/**
 * @hidden
 */
export declare class FormulaParser_ParseFormulaValidator extends FormulaTokenVisitor$2<FormulaParser, boolean> {
    static $t: Type;
    private static a3;
    constructor();
    static a4(a: FormulaParser): number;
    d(a: FormulaToken, b: FormulaParser): boolean;
    k(a: ArrayToken, b: FormulaParser): boolean;
    r(a: BinaryOperatorToken, b: FormulaParser): boolean;
    af(a: NameToken, b: FormulaParser): boolean;
    as(a: StructuredTableReference, b: FormulaParser): boolean;
}
/**
 * @hidden
 */
export declare class TokenClassResolver_FormulaTokenNode extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, ...c: TokenClassResolver_FormulaTokenNode[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly b: TokenClassResolver_FormulaTokenNode[];
    private readonly d;
    private readonly a;
    f(a: TokenClassResolver, b: TokenClass, c: boolean): void;
    readonly e: number;
    c(a: TokenClassResolver): TokenClass;
}
/**
 * @hidden
 */
export declare class TokenClassResolver extends FormulaTokenEvaluator$1<TokenClassResolver_FormulaTokenNode> {
    static $t: Type;
    private static bi;
    bh: FormulaType;
    constructor();
    a2(): EvaluationResult$1<TokenClassResolver_FormulaTokenNode>;
    protected a5(a: BinaryOperatorToken, b: TokenClassResolver_FormulaTokenNode, c: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    protected a6(a: IFunctionToken, b: TokenClassResolver_FormulaTokenNode, c: TokenClassResolver_FormulaTokenNode[]): TokenClassResolver_FormulaTokenNode;
    protected a7(a: OperandToken): TokenClassResolver_FormulaTokenNode;
    protected a8(a: ParenToken, b: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    protected a9(a: UnaryOperatorToken, b: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    a1(): void;
    static bj(a: FormulaContext, b: FormulaType): TokenClassResolver;
    bk(a: number, b: TokenClass): void;
}
/**
 * @hidden
 */
export declare class XLSXFormulaStringGenerator extends FormulaStringGenerator {
    static $t: Type;
    private static bw;
    private by;
    constructor();
    protected a4(a: IFunctionToken, b: string): string;
    protected a6(a: IFunctionToken, b: string, c: string[]): string;
    protected bs(a: FormulaToken): string;
    static bx(a: Formula, b: GetFormulaStringInfo): XLSXFormulaStringGenerator;
    a1(): void;
    protected get_bn(): boolean;
}
/**
 * @hidden
 */
export declare abstract class OperatorToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    readonly n: boolean;
    abstract readonly o: number;
}
/**
 * @hidden
 */
export declare abstract class BinaryOperatorToken extends OperatorToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_y(): boolean;
    readonly y: boolean;
}
/**
 * @hidden
 */
export declare class AddOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: AddOperator;
    static readonly aa: AddOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class OperandToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    abstract n(a: FormulaContext): any;
}
/**
 * @hidden
 */
export declare abstract class ReferenceToken extends OperandToken {
    static $t: Type;
    constructor(a: TokenClass);
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    s(a: WorkbookReferenceBase): void;
    protected get_p(): boolean;
    readonly p: boolean;
    protected get_q(): boolean;
    readonly q: boolean;
    protected get_r(): boolean;
    readonly r: boolean;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
    o: WorksheetReference;
}
/**
 * @hidden
 */
export declare abstract class CellReferenceToken extends ReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    abstract readonly v: boolean;
    abstract t(): CellReferenceToken;
    u(a: FormulaContext): Worksheet;
    protected get_w(): boolean;
    readonly w: boolean;
}
/**
 * @hidden
 */
export declare class AreaToken extends CellReferenceToken {
    static $t: Type;
    private y;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddressRange);
    constructor(a: number, b: CellAddressRange, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    readonly v: boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_p(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_f(): Token;
    readonly f: Token;
    x: CellAddressRange;
}
/**
 * @hidden
 */
export declare class AreaNToken extends AreaToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddressRange);
    constructor(a: number, b: CellAddressRange, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class Area3DNToken extends AreaNToken {
    static $t: Type;
    private z;
    constructor(a: number, b: WorksheetReference, c: CellAddressRange);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class Area3DToken extends AreaToken {
    static $t: Type;
    private z;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class AreaErr3DToken extends Area3DToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class AreaErrToken extends CellReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    readonly v: boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class ArrayToken extends OperandToken {
    static $t: Type;
    private o;
    private p;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Constant[][]);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    q: Constant[][];
}
/**
 * @hidden
 */
export interface ISelectorFunctionOptimizationToken {
    selectorFunctionTokenIndex: number;
    readonly skipTokenIndexes: List$1<number>;
}
/**
 * @hidden
 */
export declare let ISelectorFunctionOptimizationToken_$type: Type;
/**
 * @hidden
 */
export declare class AttrChooseToken extends AttrTokenBase implements ISelectorFunctionOptimizationToken {
    static $t: Type;
    private s;
    private r;
    constructor();
    selectorFunctionTokenIndex: number;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
    t: number;
    readonly skipTokenIndexes: List$1<number>;
}
/**
 * @hidden
 */
export declare class AttrIfToken extends AttrTokenBase implements ISelectorFunctionOptimizationToken {
    static $t: Type;
    private u;
    private t;
    constructor();
    selectorFunctionTokenIndex: number;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
    readonly r: boolean;
    v: number;
    readonly skipTokenIndexes: List$1<number>;
}
/**
 * @hidden
 */
export declare class AttrSkipToken extends AttrTokenBase {
    static $t: Type;
    private s;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
    t: number;
}
/**
 * @hidden
 */
export declare class AttrSpaceVolitileToken extends AttrSpaceToken {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: AttrSpaceToken);
    constructor(a: number, ..._rest: any[]);
    protected get_p(): AttrTokenBase_AttrType;
    protected get_q(): boolean;
}
/**
 * @hidden
 */
export interface IFunctionToken {
    readonly argumentCount: number;
    $function: Function;
    readonly formulaToken: FormulaToken;
}
/**
 * @hidden
 */
export declare let IFunctionToken_$type: Type;
/**
 * @hidden
 */
export declare class AttrSumToken extends AttrTokenBase implements IFunctionToken {
    static $t: Type;
    constructor();
    readonly argumentCount: number;
    $function: Function;
    readonly formulaToken: FormulaToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
}
/**
 * @hidden
 */
export declare class AttrVolatileToken extends AttrTokenBase {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    readonly p: AttrTokenBase_AttrType;
    protected get_q(): boolean;
}
/**
 * @hidden
 */
export declare class BoolToken extends OperandToken {
    static $t: Type;
    static readonly o: BoolToken;
    static readonly p: BoolToken;
    private q;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    r: boolean;
}
/**
 * @hidden
 */
export declare class ConcatOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: ConcatOperator;
    static readonly aa: ConcatOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class DivOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: DivOperator;
    static readonly aa: DivOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class EQOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: EQOperator;
    static readonly aa: EQOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class ErrToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: ErrorValue);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: ErrorValue;
}
/**
 * @hidden
 */
export declare class ExpToken extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: CellAddress);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_n(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: CellAddress;
}
/**
 * @hidden
 */
export declare class CloneTokenVisitor extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    constructor();
    static a2: CloneTokenVisitor;
    d(a: FormulaToken): FormulaToken;
    a1(): void;
    e(a: Area3DNToken): FormulaToken;
    f(a: Area3DToken): FormulaToken;
    g(a: AreaErr3DToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    l(a: AttrChooseToken): FormulaToken;
    m(a: AttrIfToken): FormulaToken;
    n(a: AttrSkipToken): FormulaToken;
    v(a: ExpToken): FormulaToken;
    aa(a: MemAreaOperator): FormulaToken;
    af(a: NameToken): FormulaToken;
    ag(a: NameXToken): FormulaToken;
    an(a: RefErr3dToken): FormulaToken;
    ak(a: Ref3DNToken): FormulaToken;
    al(a: Ref3DToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    at(a: TblToken): FormulaToken;
    as(a: StructuredTableReference): FormulaToken;
}
/**
 * @hidden
 */
export declare class ExpectedParameterClassVisitor extends FormulaTokenVisitor$2<number, TokenClass> {
    static $t: Type;
    constructor();
    static readonly a3: ExpectedParameterClassVisitor;
    d(a: FormulaToken, b: number): TokenClass;
    a2(): void;
    r(a: BinaryOperatorToken, b: number): TokenClass;
    x(a: IFunctionToken, b: number): TokenClass;
    av(a: UnaryOperatorToken, b: number): TokenClass;
}
/**
 * @hidden
 */
export declare class GetCalcFunctionVisitor extends FormulaTokenVisitor$2<UltraCalcFunctionFactory, ExcelCalcFunction> {
    static $t: Type;
    constructor();
    static readonly a3: GetCalcFunctionVisitor;
    d(a: FormulaToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    a2(): void;
    r(a: BinaryOperatorToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    x(a: IFunctionToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    aj(a: ParenToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    av(a: UnaryOperatorToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
}
/**
 * @hidden
 */
export declare class FunctionOperator extends OperatorToken implements IFunctionToken {
    static $t: Type;
    private z;
    private y;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Function);
    constructor(a: number, b: Function, c: number);
    constructor(a: number, ..._rest: any[]);
    readonly formulaToken: FormulaToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    argumentCount: number;
    $function: Function;
}
/**
 * @hidden
 */
export declare class FunctionVOperator extends FunctionOperator {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Function, c: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class GEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: GEOperator;
    static readonly aa: GEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class GTOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: GTOperator;
    static readonly aa: GTOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class IntToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: number;
}
/**
 * @hidden
 */
export declare class IsectOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: IsectOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class LEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: LEOperator;
    static readonly aa: LEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class LTOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: LTOperator;
    static readonly aa: LTOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class MatrixRowSeparatorToken extends SpecialFormulaToken {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class MemOperatorBase extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: TokenClass);
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: number;
}
/**
 * @hidden
 */
export declare class MemAreaOperator extends MemOperatorBase {
    static $t: Type;
    private q;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    r: CellAddressRange[];
}
/**
 * @hidden
 */
export declare class MemErrOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    readonly f: Token;
}
/**
 * @hidden
 */
export declare class MemFuncOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    readonly f: Token;
}
/**
 * @hidden
 */
export declare class MemNoMemOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    readonly f: Token;
}
/**
 * @hidden
 */
export declare class MissArgToken extends OperandToken {
    static $t: Type;
    static readonly o: MissArgToken;
    static readonly p: MissArgToken;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class MulOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: MulOperator;
    static readonly aa: MulOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class NameToken extends ReferenceToken {
    static $t: Type;
    private t;
    constructor(a: number, b: TokenClass, c?: boolean);
    constructor(a: number, b: string, c: FormulaContext, d: NameType, e?: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    readonly w: string;
    u: NamedReferenceBase;
    protected get_v(): any;
    readonly v: any;
}
/**
 * @hidden
 */
export declare class NameXToken extends NameToken {
    static $t: Type;
    private x;
    constructor(a: number, b: TokenClass, c?: boolean);
    constructor(a: number, b: string, c: string, d: string, e: FormulaContext, f: NameType, g?: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_q(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_r(): boolean;
    protected get_v(): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class NEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: NEOperator;
    static readonly aa: NEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class NumberToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: number;
}
/**
 * @hidden
 */
export declare class OpenParenOperator extends OperatorToken {
    static $t: Type;
    static readonly y: OpenParenOperator;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class UnaryOperatorToken extends OperatorToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
}
/**
 * @hidden
 */
export declare class ParenToken extends FormulaToken {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class PercentOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: PercentOperator;
    static readonly z: PercentOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class PowerOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: PowerOperator;
    static readonly aa: PowerOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class RangeOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: RangeOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class RefToken extends CellReferenceToken {
    static $t: Type;
    private x;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddress);
    constructor(a: number, b: CellAddress, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    readonly v: boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_p(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    y: CellAddress;
}
/**
 * @hidden
 */
export declare class RefNToken extends RefToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddress);
    constructor(a: number, b: CellAddress, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class Ref3DNToken extends RefNToken {
    static $t: Type;
    private z;
    constructor(a: number, b: WorksheetReference, c: CellAddress);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class Ref3DToken extends RefToken {
    static $t: Type;
    private z;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddress);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class RefErr3dToken extends Ref3DToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class RefErrToken extends CellReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    readonly v: boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class StrToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: string;
}
/**
 * @hidden
 */
export declare class StructuredTableReference extends ReferenceToken {
    static $t: Type;
    private t;
    private ab;
    private ac;
    private v;
    private x;
    constructor(a: number, b: string, c: string, d: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: StructuredTableReferenceKeywordType, e: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: string, e: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: StructuredTableReference_InnerReference, e: WorkbookFormat);
    constructor(a: number, b: StructuredTableReference);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    protected get_q(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_r(): boolean;
    s(a: WorkbookReferenceBase): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_f(): Token;
    readonly f: Token;
    z(a: FormulaContext): WorksheetTable;
    static ad(a: string): string;
    private ae;
    static af(a: string, b: boolean): string;
    ai(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    readonly aa: boolean;
    readonly u: StructuredTableReference_InnerReference;
    readonly ag: string;
    readonly ah: string;
    w: NamedReferenceBase;
    y: WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class StructuredTableReference_InnerReference extends Base {
    static $t: Type;
    private n;
    private l;
    private b;
    private c;
    private d;
    private e;
    private o;
    private m;
    constructor(a: number, b: StructuredTableReferenceKeywordType, c: boolean, d: Nullable$1<StructuredTableReferenceKeywordType>);
    constructor(a: number, b: StructuredTableReferenceKeywordType, c: boolean, d: Nullable$1<StructuredTableReferenceKeywordType>, e: boolean, f: string, g: string);
    constructor(a: number, b: string, c: string);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    s(a: CultureInfo, b: GetFormulaStringInfo): string;
    a(a: WorksheetTable, b: WorksheetRow): RefBase;
    t(a: WorksheetTable, b: string, c: string): void;
    readonly p: string;
    readonly i: boolean;
    g: boolean;
    h: boolean;
    readonly j: boolean;
    readonly q: string;
}
/**
 * @hidden
 */
export declare class SubOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: SubOperator;
    static readonly aa: SubOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class TblToken extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: CellAddress);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_n(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    p: CellAddress;
}
/**
 * @hidden
 */
export declare class UminusOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: UminusOperator;
    static readonly z: UminusOperator;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class UnionOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: UnionOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class UplusOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: UplusOperator;
    static readonly z: UplusOperator;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    protected get_o(): number;
    readonly o: number;
    protected get_f(): Token;
    readonly f: Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class Constant extends Base {
    static $t: Type;
    abstract readonly c: any;
    abstract f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    abstract g(a: IBiffRecordStream): void;
    abstract e(a: CultureInfo): string;
    abstract readonly b: number;
    static a(a: IBiffRecordStream, b: number[], c: number): {
        ret: Constant;
        p1?: number[];
        p2?: number;
    };
    toString(): string;
}
/**
 * @hidden
 */
export declare class BooleanConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    readonly b: number;
    protected get_c(): any;
    readonly c: any;
}
/**
 * @hidden
 */
export declare class EmptyConstant extends Constant {
    static $t: Type;
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    readonly b: number;
    protected get_c(): any;
    readonly c: any;
}
/**
 * @hidden
 */
export declare class ErrorConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: ErrorValue);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    readonly b: number;
    protected get_c(): any;
    readonly c: any;
}
/**
 * @hidden
 */
export declare class NumberConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    readonly b: number;
    protected get_c(): any;
    readonly c: any;
}
/**
 * @hidden
 */
export declare class StringConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    readonly b: number;
    protected get_c(): any;
    readonly c: any;
}
/**
 * @hidden
 */
export declare class ExternalCellCalcReference extends RefBase {
    static $t: Type;
    private _a3;
    private _a2;
    constructor(a: WorksheetReferenceExternal, b: number, c: number);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    readonly _a4: WorksheetCellAddress;
    protected get__q(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class ExternalNamedCalcReference extends NamedCalcReferenceBase {
    static $t: Type;
    private _a3;
    private _a2;
    constructor(a: ExternalNamedReference);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    _az(a: SingleTargetFormula): void;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
}
/**
 * @hidden
 */
export declare class ExternalRegionCalcReference extends RefBase {
    static $t: Type;
    private _a4;
    private _a2;
    private _a3;
    constructor(a: WorksheetReferenceExternal, b: WorksheetRegionAddress);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    readonly _a5: WorksheetRegionAddress;
    protected get__q(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class ExternalRegionCalcReference_ExternalRegionValuesArray extends ArrayProxy {
    static $t: Type;
    private _p;
    private _o;
    constructor(a: ExternalRegionCalcReference);
    protected get__g(): boolean;
    readonly _g: boolean;
    private __j;
    _j(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _c(a: ArrayValueContext): ExcelCalcValue;
    _a(): ExcelCalcValue[][];
}
/**
 * @hidden
 */
export declare class MatrixUtilities extends Base {
    static $t: Type;
    static f(a: number[][], b: number, c: number, d: number): number;
    static g(a: number[][], b: number): number;
    static a(a: number[][], b: number, c: ExcelCalcErrorValue): {
        ret: number[][];
        p2: ExcelCalcErrorValue;
    };
    static b(a: ArrayProxy, b: NonNumericElementBehavior, c: ExcelCalcErrorValue): {
        ret: number[][];
        p2: ExcelCalcErrorValue;
    };
    private static c;
    static e<T>($t: Type, a: T[][]): T[][];
    static d(a: ArrayProxy): ExcelCalcValue[][];
}
/**
 * @hidden
 */
export declare class MultiSheetCellCalcReference extends RefBase {
    static $t: Type;
    private readonly _a6;
    private readonly _a4;
    private readonly _a5;
    private readonly _a3;
    readonly _a7: List$1<WorksheetRegion>;
    private readonly _a2;
    constructor(a: Worksheet, b: Worksheet, c: WorksheetCellAddress);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class MultiSheetCellCalcReference_MultiSheetCellReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: MultiSheetCellCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class MultiSheetExternalCellCalcReference extends RefBase {
    static $t: Type;
    private readonly _a7;
    private readonly _a5;
    private readonly _a6;
    private readonly _a2;
    constructor(a: WorksheetReferenceExternal, b: WorksheetReferenceExternal, c: WorksheetCellAddress);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__q(): WorksheetReference;
    protected get__t(): Workbook;
    readonly _a8: WorksheetCellAddress;
    readonly _a3: WorksheetReference;
    readonly _a4: WorksheetReference;
}
/**
 * @hidden
 */
export declare class MultiSheetExternalRegionCalcReference extends RefBase {
    static $t: Type;
    private readonly _a7;
    private readonly _a5;
    private readonly _a6;
    private readonly _a2;
    constructor(a: WorksheetReferenceExternal, b: WorksheetReferenceExternal, c: WorksheetRegionAddress);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__t(): Workbook;
    protected get__q(): WorksheetReference;
    readonly _a8: WorksheetRegionAddress;
    readonly _a3: WorksheetReference;
    readonly _a4: WorksheetReference;
}
/**
 * @hidden
 */
export declare class MultiSheetRegionCalcReference extends RefBase {
    static $t: Type;
    private readonly _a4;
    private readonly _a5;
    private readonly _a3;
    private readonly _a6;
    readonly _a7: List$1<WorksheetRegion>;
    private readonly _a2;
    constructor(a: Worksheet, b: Worksheet, c: WorksheetRegionAddress);
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: MultiSheetRegionCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class RegionArrayProxyBase extends ArrayProxy {
    static $t: Type;
    private _o;
    constructor();
    protected get__g(): boolean;
    readonly _g: boolean;
    protected get__h(): boolean;
    private __j;
    _j(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _c(a: ArrayValueContext): ExcelCalcValue;
    _m(a: boolean, b: (arg1: ExcelCalcValue, arg2: ArrayValueContext) => void): void;
    _a(): ExcelCalcValue[][];
    private static _q;
    private _p;
    abstract readonly _r: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionCalcReference extends RegionCalcReferenceBase {
    static $t: Type;
    private _a8;
    private _a7;
    constructor(a: WorksheetRegion);
    _a4(a: number, b: number): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _a5(a: number, b: number): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected get__a3(): WorksheetRegion;
    readonly _a3: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionCalcReference_RegionArrayProxy extends RegionArrayProxyBase {
    static $t: Type;
    private _s;
    constructor(a: WorksheetRegion);
    protected get__r(): WorksheetRegion;
    readonly _r: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionCalcReferenceBase_RegionReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: RegionCalcReferenceBase);
    getEnumeratorObject(): IEnumerator;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    readonly _b: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionGroupCalcReference extends RefBase {
    static $t: Type;
    readonly _bb: ReadOnlyCollection$1<WorksheetRegion>;
    private _a8;
    private _a2;
    private _a9;
    constructor(a: number, b: List$1<WorksheetRegion>, c: WorksheetRegion);
    constructor(a: number, b: WorksheetRow, c: number);
    constructor(a: number, b: WorksheetRegion);
    constructor(a: number, ..._rest: any[]);
    private _bc;
    protected get__ao(): number;
    readonly _ao: number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    readonly _w: WorksheetRow;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    static _a7(a: IExcelCalcReference): RegionGroupCalcReference;
    static _a3(a: RegionGroupCalcReference, b: RegionGroupCalcReference): IExcelCalcReference;
    static _a4(a: RegionGroupCalcReference, b: RegionGroupCalcReference): IExcelCalcReference;
    static _a6(a: RegionGroupCalcReference, b: RegionGroupCalcReference): RefBase;
    private _a5;
    readonly _ba: ReadOnlyCollection$1<WorksheetRegion>;
}
/**
 * @hidden
 */
export declare class RegionGroupCalcReference_GeneralReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: RegionGroupCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class TableCalcReferenceBase extends RegionCalcReferenceBase {
    static $t: Type;
    private readonly _be;
    private readonly _bf;
    private readonly _bb;
    private readonly _a7;
    constructor(a: WorksheetRow, b: Nullable$1<StructuredTableReferenceKeywordType>, c: Nullable$1<StructuredTableReferenceKeywordType>);
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    protected get__t(): Workbook;
    protected get__c(): ExcelCalcValue;
    readonly _c: ExcelCalcValue;
    protected abstract _a8(a: WorksheetRow): TableCalcReferenceBase;
    private _a9;
    protected _bd(a: TableCalcReferenceBase): boolean;
    protected readonly _bg: Nullable$1<StructuredTableReferenceKeywordType>;
    protected readonly _bh: Nullable$1<StructuredTableReferenceKeywordType>;
    abstract readonly _bc: WorksheetTable;
    protected readonly _ba: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class TableCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bi;
    constructor(a: WorksheetRow, b: WorksheetTable, c: Nullable$1<StructuredTableReferenceKeywordType>, d: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _a8(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    _a5(a: number, b: number): boolean;
    getHashCode(): number;
    protected get__a3(): WorksheetRegion;
    readonly _a3: WorksheetRegion;
    protected get__bc(): WorksheetTable;
    readonly _bc: WorksheetTable;
}
/**
 * @hidden
 */
export declare class TableCalcReferenceBase_TableReferenceArrayProxy extends RegionArrayProxyBase {
    static $t: Type;
    private _s;
    constructor(a: TableCalcReferenceBase);
    protected get__r(): WorksheetRegion;
    readonly _r: WorksheetRegion;
}
/**
 * @hidden
 */
export declare class TableColumnCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bi;
    constructor(a: WorksheetRow, b: WorksheetTableColumn, c: Nullable$1<StructuredTableReferenceKeywordType>, d: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _a8(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    _a5(a: number, b: number): boolean;
    getHashCode(): number;
    protected get__a3(): WorksheetRegion;
    readonly _a3: WorksheetRegion;
    protected get__bc(): WorksheetTable;
    readonly _bc: WorksheetTable;
}
/**
 * @hidden
 */
export declare class TableColumnRangeCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bi;
    private _bj;
    constructor(a: WorksheetRow, b: WorksheetTableColumn, c: WorksheetTableColumn, d: Nullable$1<StructuredTableReferenceKeywordType>, e: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _a8(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    protected get_elementName(): string;
    readonly elementName: string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _a5(a: number, b: number): boolean;
    protected get__a3(): WorksheetRegion;
    readonly _a3: WorksheetRegion;
    protected get__bc(): WorksheetTable;
    readonly _bc: WorksheetTable;
}
/**
 * Abstract base class for all filter types which filter data based on a dynamic condition, such as the data present in the filtered
 * data range, the date when the filter was applied, or the date when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 */
export declare abstract class DynamicValuesFilter extends Filter {
    static $t: Type;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    static _l(a: WorkbookLoadManager, b: IFilterable, c: ST_DynamicFilterType, d: Nullable$1<number>, e: Nullable$1<number>): DynamicValuesFilter;
    /**
     * @hidden
     */
    static _k(a: IFilterable, b: ST_DynamicFilterType, c: Nullable$1<number>, d: Nullable$1<Date>, e: Nullable$1<Date>): DynamicValuesFilter;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    readonly _n: number;
    /**
     * @hidden
     */
    abstract readonly _m: ST_DynamicFilterType;
}
/**
 * Represents a filter which can filter data based on whether the data is below or above the average of the entire data range.
 * @see [[WorksheetTableColumn.filter]]
 */
export declare class AverageFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _p;
    private _u;
    private _s;
    constructor(a: number, b: IFilterable, c: AverageFilterType);
    constructor(a: number, b: IFilterable, c: AverageFilterType, d: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    readonly _m: ST_DynamicFilterType;
    /**
     * Gets the average that was computed the last time the filter was applied or 0 if any errors or all non-numeric values
     * were found when applying the filter.
     */
    readonly average: number;
    /**
     * Gets or sets the value indicating whether to filter in values below or above the average of the data range.
     * AboveAverage to show cells above the average of the data range; BelowAverage to show cells below the average.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[AverageFilterType]] enumeration.
     */
    /**
    * Gets or sets the value indicating whether to filter in values below or above the average of the data range.
    * AboveAverage to show cells above the average of the data range; BelowAverage to show cells below the average.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[AverageFilterType]] enumeration.
    */
    type: AverageFilterType;
    /**
     * @hidden
     */
    private _y;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
}
/**
 * A filter condition used in a [[CustomFilter]].
 * <p class="body">
 * The CustomFilterCondition contains a comparison operator and a value. The value of each cell in the data range is compared against
 * the condition value using the comparison operator.
 * </p>
 * @see [[CustomFilter.condition1]]
 * @see [[CustomFilter.condition2]]
 */
export declare class CustomFilterCondition extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _n: string;
    /**
     * @hidden
     */
    static readonly _o: string;
    private readonly _b;
    private readonly _d;
    private readonly _p;
    private readonly _l;
    private readonly _j;
    constructor(comparisonOperator: ExcelComparisonOperator, value: any);
    /**
     * Determines whether the [[CustomFilterCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CustomFilterCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    static _a(a: ST_FilterOperator, b: any): CustomFilterCondition;
    /**
     * @hidden
     */
    _m(): string;
    /**
     * @hidden
     */
    _q(a: WorkbookSaveManager, b: ST_FilterOperator, c: any): {
        p1: ST_FilterOperator;
        p2: any;
    };
    /**
     * @hidden
     */
    _g(a: Worksheet, b: WorksheetRow, c: number, d: number, e: any): boolean;
    /**
     * @hidden
     */
    static _h(a: ExcelComparisonOperator): boolean;
    /**
     * Gets the operator which describes how the cell values should be compared against [[value]].
     * @see [[value]]
     */
    readonly comparisonOperator: ExcelComparisonOperator;
    /**
     * Gets the value against which the cell values should be compared.
     * @see [[comparisonOperator]]
     */
    readonly value: any;
    /**
     * @hidden
     */
    readonly _f: boolean;
}
/**
 * Represents a filter which can filter data based on one or two custom conditions.
 * This filter type allows you to specify one or two filter conditions which have a comparison operator and value.
 * These two filter conditions can be combined with a logical and or a logical or operation.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[CustomFilterCondition]]
 */
export declare class CustomFilter extends Filter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _k;
    private _p;
    private _q;
    private _n;
    constructor(a: number, b: IFilterable, c: CustomFilterCondition);
    constructor(a: number, b: IFilterable, c: CustomFilterCondition, d: CustomFilterCondition, e: ConditionalOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * Gets or sets the first condition by which to filter the cells in the data range.
     * <p class="body">
     * The first filter condition is required. Setting Condition1 to null will cause an exception to be thrown.
     * </p>
     * <p class="body">
     * When both Condition1 and [[condition2]] are set, the [[conditionalOperator]] is used to determine
     * how the conditions should be logically combined.
     * </p>
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[condition2]]
     * @see [[conditionalOperator]]
     */
    /**
    * Gets or sets the first condition by which to filter the cells in the data range.
    * <p class="body">
    * The first filter condition is required. Setting Condition1 to null will cause an exception to be thrown.
    * </p>
    * <p class="body">
    * When both Condition1 and [[condition2]] are set, the [[conditionalOperator]] is used to determine
    * how the conditions should be logically combined.
    * </p>
    * @throws [[ArgumentNullException]] The value assigned is null.
    * @see [[condition2]]
    * @see [[conditionalOperator]]
    */
    condition1: CustomFilterCondition;
    /**
     * @hidden
     */
    private _x;
    /**
     * Gets or sets the second condition by which to filter the cells in the data range.
     * <p class="body">
     * The second filter condition is optional. A value of null indicates that only [[condition1]] should be used to
     * filter the data.
     * </p>
     * <p class="body">
     * When both Condition1 and Condition2 are set, the [[conditionalOperator]] is used to determine how the conditions
     * should be logically combined.
     * </p>
     * @see [[condition1]]
     * @see [[conditionalOperator]]
     */
    /**
    * Gets or sets the second condition by which to filter the cells in the data range.
    * <p class="body">
    * The second filter condition is optional. A value of null indicates that only [[condition1]] should be used to
    * filter the data.
    * </p>
    * <p class="body">
    * When both Condition1 and Condition2 are set, the [[conditionalOperator]] is used to determine how the conditions
    * should be logically combined.
    * </p>
    * @see [[condition1]]
    * @see [[conditionalOperator]]
    */
    condition2: CustomFilterCondition;
    /**
     * @hidden
     */
    private _y;
    /**
     * Gets or sets the operator which defines how to logically combine [[condition1]] and [[condition2]]
     * <p class="body">
     * When both Condition1 and Condition2 are set, the ConditionalOperator is used to determine how the conditions should be logically
     * combined. If only Condition1 is set and Condition2 is null, then ConditionalOperator is ignored.
     * </p>
     * And to require both conditions to pass for the data to be filtered in. Or to allow data to be filtered in when one or both
     * conditions are met.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[conditionalOperator]] enumeration.
     * @see [[condition1]]
     * @see [[condition2]]
     */
    /**
    * Gets or sets the operator which defines how to logically combine [[condition1]] and [[condition2]]
    * <p class="body">
    * When both Condition1 and Condition2 are set, the ConditionalOperator is used to determine how the conditions should be logically
    * combined. If only Condition1 is set and Condition2 is null, then ConditionalOperator is ignored.
    * </p>
    * And to require both conditions to pass for the data to be filtered in. Or to allow data to be filtered in when one or both
    * conditions are met.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[conditionalOperator]] enumeration.
    * @see [[condition1]]
    * @see [[condition2]]
    */
    conditionalOperator: ConditionalOperator;
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
}
/**
 * Represents a filter which can filter dates in a specific period.
 * <p class="body">
 * This filter allows dates to be filtered in if they are in a specific month or quarter of any year.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 */
export declare class DatePeriodFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _p;
    private _s;
    private _u;
    constructor(a: IFilterable, b: DatePeriodFilterType, c: number);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    readonly _m: ST_DynamicFilterType;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * Gets or sets the type of date period to filter in.
     * Month to filter in dates in a specific month of any year; Quarter to filter in dates in a specific quarter of any year.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] The value assigned is Quarter and the [[value]] is less than 1 or greater than 4 or
     * the value assigned is Month and the Value is less than 1 or greater than 12.
     * @see [[value]]
     */
    /**
    * Gets or sets the type of date period to filter in.
    * Month to filter in dates in a specific month of any year; Quarter to filter in dates in a specific quarter of any year.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[DatePeriodFilterType]] enumeration.
    * @throws [[ArgumentException]] The value assigned is Quarter and the [[value]] is less than 1 or greater than 4 or
    * the value assigned is Month and the Value is less than 1 or greater than 12.
    * @see [[value]]
    */
    type: DatePeriodFilterType;
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets or sets the 1-based value of the month or quarter to filter in.
     * <p class="body">
     * If the [[type]] is Month, a Value of 1 indicates January, 2 indicates February, and so on. If Type is Quarter,
     * a Value of 1 indicates Quarter 1, and so on.
     * </p>
     * The 1-based value of the month or quarter to filter in.
     * @throws [[ArgumentException]] [[type]] is Quarter and the value assigned is less than 1 or greater than 4 or
     * Type is Month and the value assigned is less than 1 or greater than 12.
     * @see [[type]]
     */
    /**
    * Gets or sets the 1-based value of the month or quarter to filter in.
    * <p class="body">
    * If the [[type]] is Month, a Value of 1 indicates January, 2 indicates February, and so on. If Type is Quarter,
    * a Value of 1 indicates Quarter 1, and so on.
    * </p>
    * The 1-based value of the month or quarter to filter in.
    * @throws [[ArgumentException]] [[type]] is Quarter and the value assigned is less than 1 or greater than 4 or
    * Type is Month and the value assigned is less than 1 or greater than 12.
    * @see [[type]]
    */
    value: number;
    /**
     * @hidden
     */
    private _aa;
}
/**
 * Abstract base class for filters which filter dates based on whether they are within a specified range of dates or not.
 * @see [[RelativeDateRangeFilter]]
 * @see [[YearToDateFilter]]
 */
export declare abstract class DateRangeFilter extends DynamicValuesFilter {
    static $t: Type;
    private _q;
    private _p;
    private _r;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: Date, d: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    abstract _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * Gets the exclusive end date of the filtered in date range.
     * @see [[start]]
     */
    readonly end: Date;
    /**
     * Gets the inclusive start date of the filtered in date range.
     * @see [[end]]
     */
    readonly start: Date;
}
/**
 * @hidden
 */
export interface IColorFilter {
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, a: IColorFilterVisitor$2<TArg, TResult>, b: TArg): TResult;
    readonly isCellColorFilter: boolean;
}
/**
 * @hidden
 */
export declare let IColorFilter_$type: Type;
/**
 * Represents a filter which will filter cells based on their background fills.
 * <p class="body">
 * This filter specifies a single [[CellFill]]. Cells of with this fill will be visible in the data range.
 * All other cells will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 */
export declare class FillFilter extends Filter implements IColorFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _k;
    private _m;
    constructor(a: IFilterable, b: CellFill);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorFilterVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    readonly isCellColorFilter: boolean;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    static _p(a: WorksheetTableColumn, b: WorksheetCellFormatData): FillFilter;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the [[CellFill]] by which the cells should be filtered.
     * <p class="body">
     * Cells of with this fill will be visible in the the data range. All other cells will be hidden.
     * </p>
     * The CellFill by which the cells should be filtered.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.fill]]
     */
    /**
    * Gets or sets the [[CellFill]] by which the cells should be filtered.
    * <p class="body">
    * Cells of with this fill will be visible in the the data range. All other cells will be hidden.
    * </p>
    * The CellFill by which the cells should be filtered.
    * @throws [[ArgumentNullException]] The value assigned is null.
    * @see [[WorksheetCell.cellFormat]]
    * @see [[IWorksheetCellFormat.fill]]
    */
    fill: CellFill;
    /**
     * @hidden
     */
    private _s;
}
/**
 * Represents a fixed range of dates.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export declare class FixedDateGroup extends Base {
    static $t: Type;
    private readonly _c;
    private readonly _h;
    private readonly _d;
    private readonly _i;
    constructor(type: FixedDateGroupType, value: Date);
    /**
     * Determines whether the [[FixedDateGroup]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FixedDateGroup]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * Gets the accepted date range based on the specified calendar type.
     * @param calendarType The calendar type in which to get the accepted date range.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @see [[start]]
     * @see [[end]]
     * @return A [[DateRange]] where the start is the inclusive start date of the accepted date range and the end is
     * the exclusive end date.
     */
    getRange(calendarType: CalendarType): DateRange;
    /**
     * @hidden
     */
    static _b(a: ST_DateTimeGrouping, b: number, c: Nullable$1<number>, d: Nullable$1<number>, e: Nullable$1<number>, f: Nullable$1<number>, g: Nullable$1<number>): FixedDateGroup;
    /**
     * @hidden
     */
    _n(a: Calendar, b: CalendarType, c: FixedDateGroup_DateRange): {
        p2: FixedDateGroup_DateRange;
    };
    /**
     * Gets the exclusive end date of the accepted date range with a [[CalendarType]] of None.
     * @see [[start]]
     * @see [[getRange]]
     */
    readonly end: Date;
    /**
     * Gets the inclusive start date of the accepted date range with a [[CalendarType]] of None.
     * @see [[end]]
     * @see [[getRange]]
     */
    readonly start: Date;
    /**
     * Gets the type, or precision, of the group.
     * <p class="body">
     * The group type indicates the precision of the [[value]], which defines the range of accepted dates in the group.
     * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
     * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
     * </p>
     * @see [[value]]
     */
    readonly type: FixedDateGroupType;
    /**
     * Gets the reference date which determines range of accepted dates.
     * <p class="body">
     * [[type]] indicates the precision of the Value, which defines the range of accepted dates in the group.
     * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
     * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
     * </p>
     * @see [[type]]
     */
    readonly value: Date;
    /**
     * @hidden
     */
    readonly _f: ST_DateTimeGrouping;
}
/**
 * @hidden
 */
export declare class FixedDateGroup_DateRange extends ValueType {
    static $t: Type;
    constructor(a: number, b: Date, c: Date);
    constructor();
    constructor(a: number, ..._rest: any[]);
    a: Date;
    b: Date;
}
/**
 * Represents a range of dates.
 */
export declare class DateRange extends Base {
    static $t: Type;
    start: Date;
    end: Date;
}
/**
 * @hidden
 */
export declare class FixedDateGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: FixedDateGroupCollection, c: FixedDateGroup, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FixedDateGroupCollection;
    readonly a: FixedDateGroup;
    readonly c: number;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of fixed date groups.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export declare class FixedDateGroupCollection extends Base implements IList$1<FixedDateGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FixedValuesFilter;
    private _e;
    static staticInit(): void;
    constructor(a: FixedValuesFilter);
    /**
     * @hidden
     */
    copyTo(array: FixedDateGroup[], arrayIndex: number): void;
    /**
     * @hidden
     */
    readonly isReadOnly: boolean;
    [Symbol.iterator](): EnumeratorWrapper<FixedDateGroup>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<FixedDateGroup>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a fixed date group to the collection.
     * @param item The fixed date group to add to the collection.
     * @throws [[ArgumentNullException]] 'item' is null.
     * @throws [[ArgumentException]] 'item' is already in the collection.
     */
    add(item: FixedDateGroup): void;
    /**
     * Clears the collection.
     * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
     * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
     */
    clear(): void;
    /**
     * Determines whether the specified fixed date group is in the collection.
     * @param item The fixed date group to find in the collection.
     * @return True if the item is in the collection; False otherwise.
     */
    contains(item: FixedDateGroup): boolean;
    /**
     * Gets the index of the specified fixed date group in the collection.
     * @param item The fixed date group to find in the collection.
     * @return The 0-based index of the specified fixed date group in the collection or -1 if the item is not in the collection.
     */
    indexOf(item: FixedDateGroup): number;
    /**
     * Inserts a fixed date group into the collection.
     * @param index The 0-based index where the value should be inserted.
     * @param item The fixed date group to insert into the collection.
     * @throws [[ArgumentNullException]] 'item' is null.
     * @throws [[ArgumentException]] 'item' is already in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     */
    insert(index: number, item: FixedDateGroup): void;
    /**
     * Removes the fixed date group from the collection.
     * @param item The fixed date group to remove from the collection.
     * @return True if the value was found and removed; False otherwise.
     */
    remove(item: FixedDateGroup): boolean;
    /**
     * Removes the fixed date group at the specified index.
     * @param index The 0-based index of the value to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
     * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
     * is not allowed for a FixedValuesFilter.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _j;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _n;
    /**
     * @hidden
     */
    private _o;
    /**
     * Gets the number of fixed date groups in the collection.
     */
    readonly count: number;
    /**
     * Gets or sets the fixed date group at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned is already in the collection.
     */
    item(a: number, b?: FixedDateGroup): FixedDateGroup;
}
/**
 * Represents a filter which can filter cells based on specific, fixed values, which are allowed to display.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 */
export declare class FixedValuesFilter extends Filter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _k;
    private _x;
    private _p;
    private _r;
    private _n;
    private _t;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    _aa(): number;
    /**
     * @hidden
     */
    _ab(a: boolean, b: IList$1<string>): {
        ret: number;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the calendar type used to interpret values in the [[dateGroups]] collection.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[calendarType]] enumeration.
     */
    /**
    * Gets or sets the calendar type used to interpret values in the [[dateGroups]] collection.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[calendarType]] enumeration.
    */
    calendarType: CalendarType;
    /**
     * @hidden
     */
    private _ae;
    /**
     * Gets or sets the fixed date group at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned is already in the collection.
     */
    dateGroups(index: number, value?: FixedDateGroup): FixedDateGroup;
    /**
     * Gets the collection of fixed date groups which should be filtered in.
     * @see [[displayValues]]
     */
    dateGroups(): FixedDateGroupCollection;
    /**
     * @hidden
     */
    readonly _dateGroups$i: FixedDateGroupCollection;
    /**
     * Gets or sets the display text value at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned matches another value in the collection. Values are compared case-insensitively.
     */
    displayValues(index: number, value?: string): string;
    /**
     * Gets the collection of cell text values which should be filtered in.
     * <p class="body">
     * Text values are compared case-insensitively.
     * </p>
     * <p class="note">
     * <b>Note:</b> If any text values are longer than 255 characters in length and the workbook is saved in one of the 2003 formats,
     * the correct rows will be hidden in the saved file, but the filter may be missing from the column or reapplying the filter
     * may hide some of the matching cells.
     * </p>
     * @see [[dateGroups]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetRow.getCellText]]
     */
    displayValues(): DisplayValueCollection;
    /**
     * @hidden
     */
    readonly _displayValues$i: DisplayValueCollection;
    /**
     * Gets or sets the value which indicates whether blank cells should be filtered in.
     * @throws [[InvalidOperationException]] The value is set to False and both [[dateGroups]] and [[displayValues]] contain no values.
     * This would prevent the filter from including any values, which is not allowed for a [[FixedValuesFilter]].
     */
    /**
    * Gets or sets the value which indicates whether blank cells should be filtered in.
    * @throws [[InvalidOperationException]] The value is set to False and both [[dateGroups]] and [[displayValues]] contain no values.
    * This would prevent the filter from including any values, which is not allowed for a [[FixedValuesFilter]].
    */
    includeBlanks: boolean;
    /**
     * @hidden
     */
    private _v;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    readonly _y: Calendar;
    /**
     * @hidden
     */
    readonly _w: boolean;
}
/**
 * Represents a filter which will filter cells based on their font colors.
 * <p class="body">
 * This filter specifies a single color. Cells with this color font will be visible in the data range. All other cells
 * will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFontColorFilter]]
 */
export declare class FontColorFilter extends Filter implements IColorFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _k;
    private _o;
    constructor(a: IFilterable, b: WorkbookColorInfo);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorFilterVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    readonly isCellColorFilter: boolean;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    static _n(a: WorksheetTableColumn, b: WorksheetCellFormatData): FontColorFilter;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * <p class="body">
     * Cells of this font color will be visible in the the data range. All other cells will be hidden.
     * </p>
     * The WorkbookColorInfo which describes the color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[Type]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.font]]
     * @see [[IWorkbookFont.colorInfo]]
     */
    /**
    * Gets or sets the [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
    * <p class="body">
    * Cells of this font color will be visible in the the data range. All other cells will be hidden.
    * </p>
    * The WorkbookColorInfo which describes the color by which the cells should be filtered.
    * @throws [[ArgumentNullException]] The value assigned is null.
    * @see [[Type]]
    * @see [[WorksheetCell.cellFormat]]
    * @see [[IWorksheetCellFormat.font]]
    * @see [[IWorkbookFont.colorInfo]]
    */
    fontColorInfo: WorkbookColorInfo;
    /**
     * @hidden
     */
    private _s;
}
/**
 * Represents a filter which can filter cells based on their conditional formatting icon.
 * <p class="body">
 * This filter allows cells to be filtered in if their conditional formatting icon matches the criteria.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[ConditionalFormatCollection.addIconSetCondition]]
 */
export declare class IconFilter extends Filter {
    static $t: Type;
    private readonly _n;
    private readonly _l;
    constructor(a: IFilterable, b: ST_IconSetType, c: Nullable$1<number>);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * The icon set (read-only).
     */
    readonly iconIndex: number | null;
    /**
     * @hidden
     */
    readonly _iconIndex$i: Nullable$1<number>;
    /**
     * The icon's index in the associated icon set or null for 'NoCellIcon' (read-only).
     */
    readonly iconSet: FormatConditionIconSet;
    /**
     * @hidden
     */
    readonly _p: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _m: ST_IconSetType;
}
/**
 * Represents a filter which can filter date cells based on dates relative to the when the filter was applied.
 * <p class="body">
 * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
 * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
 * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
 * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
 * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
 * dates in 1999, even if the workbook is opened in 2012.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyRelativeDateRangeFilter]]
 */
export declare class RelativeDateRangeFilter extends DateRangeFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ab;
    constructor(a: number, b: IFilterable, c: RelativeDateRangeOffset, d: RelativeDateRangeDuration);
    constructor(a: number, b: IFilterable, c: RelativeDateRangeOffset, d: RelativeDateRangeDuration, e: Date, f: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    readonly _m: ST_DynamicFilterType;
    /**
     * Gets or sets the duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @see [[offset]]
     */
    /**
    * Gets or sets the duration of the full range of accepted dates.
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeDuration]] enumeration.
    * @see [[offset]]
    */
    duration: RelativeDateRangeDuration;
    /**
     * @hidden
     */
    private _ah;
    /**
     * Gets or sets the offset of relative filter (previous, current, or next).
     * <p class="body">
     * Type combined with [[duration]] determines the relative date range to filter.
     * </p>
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @see [[duration]]
     */
    /**
    * Gets or sets the offset of relative filter (previous, current, or next).
    * <p class="body">
    * Type combined with [[duration]] determines the relative date range to filter.
    * </p>
    * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeOffset]] enumeration.
    * @see [[duration]]
    */
    offset: RelativeDateRangeOffset;
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents a filter which can filter in cells in the upper or lower portion of the sorted values.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 */
export declare class TopOrBottomFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _p;
    private _y;
    private _s;
    private _aa;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: TopOrBottomFilterType, d: number);
    constructor(a: number, b: IFilterable, c: TopOrBottomFilterType, d: number, e: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    readonly _m: ST_DynamicFilterType;
    /**
     * @hidden
     */
    static _t(a: boolean, b: boolean): TopOrBottomFilterType;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * Gets or sets the type of the filter.
     * TopValues or BottomValues to filter in the top or bottom N value in the list of sorted values; TopPercentage or BottomPercentage
     * to filter in the top or bottom N percentage of values in the list of sorted values.
     * @throws [[InvalidEnumArgumentException]] The value assign is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @see [[value]]
     */
    /**
    * Gets or sets the type of the filter.
    * TopValues or BottomValues to filter in the top or bottom N value in the list of sorted values; TopPercentage or BottomPercentage
    * to filter in the top or bottom N percentage of values in the list of sorted values.
    * @throws [[InvalidEnumArgumentException]] The value assign is not defined in the [[TopOrBottomFilterType]] enumeration.
    * @see [[value]]
    */
    type: TopOrBottomFilterType;
    /**
     * @hidden
     */
    private _af;
    /**
     * Gets or sets the number or percentage of value of values which should be filtered in.
     * <p class="body">
     * When [[type]] is TopValues or BottomValues, Value indicates the number of value which should be filtered in.
     * When Type is TopPercentage or BottomPercentage, Value indicates percentage to filter in. For example, a Value of 15 and
     * a Type of BottomPercentage will filter in the bottom 15 percent of values.
     * </p>
     * The number or percentage of items which should be filtered in.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 500.
     */
    /**
    * Gets or sets the number or percentage of value of values which should be filtered in.
    * <p class="body">
    * When [[type]] is TopValues or BottomValues, Value indicates the number of value which should be filtered in.
    * When Type is TopPercentage or BottomPercentage, Value indicates percentage to filter in. For example, a Value of 15 and
    * a Type of BottomPercentage will filter in the bottom 15 percent of values.
    * </p>
    * The number or percentage of items which should be filtered in.
    * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 500.
    */
    value: number;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    readonly _v: ST_FilterOperator;
    /**
     * @hidden
     */
    readonly _w: boolean;
    /**
     * @hidden
     */
    readonly _x: boolean;
    /**
     * @hidden
     */
    readonly _z: number;
}
/**
 * @hidden
 */
export declare class WorksheetColumnFilter extends Base implements IFilterable, IComparable$1<WorksheetColumnFilter> {
    static $t: Type;
    private readonly _c;
    private _d;
    private _a;
    constructor(a: number, b: Worksheet);
    constructor(a: number, b: Worksheet, c: number);
    constructor(a: number, ..._rest: any[]);
    _g(a: Filter): void;
    _h(a: number): void;
    readonly columnIndex: number;
    readonly filter: Filter;
    readonly _e: WorksheetRegionAddress;
    readonly _f: number;
    readonly workbook: Workbook;
    readonly worksheet: Worksheet;
    onFilterModified(): void;
    _b(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    compareTo(a: WorksheetColumnFilter): number;
    getDataAreaRowIndexes(a: number, b: number): {
        p0: number;
        p1: number;
    };
}
/**
 * @hidden
 */
export declare class WorksheetFilterSettings_AddFilterChangeInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnFilter);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private a;
    readonly c: number;
    readonly b: WorksheetRegionAddress;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class WorksheetFilterSettings_RemoveFilterChangeInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnFilter);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private b;
    a: Filter;
    readonly d: number;
    readonly c: WorksheetRegionAddress;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Exposes methods to identify a region in the wroksheet and to apply filters and optionally sort criteria to that region.
 */
export declare class WorksheetFilterSettings extends Base implements ISortSettingsOwner, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _au;
    /**
     * @hidden
     */
    private static _a;
    private _ap;
    private _aq;
    private _az;
    private _a0;
    private _ak;
    private _ac;
    private _ay;
    private _ai;
    private _ar;
    private _x;
    private _aa;
    private _am;
    private _al;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total region including the filter headers (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     * @see [[sortAndFilterAreaRegion]]
     */
    readonly region: WorksheetRegion;
    /**
     * Returns the region that the filters and sort settings are applied to (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     * @see [[region]]
     * @see [[sortSettings]]
     */
    readonly sortAndFilterAreaRegion: WorksheetRegion;
    /**
     * Gets the settings which determine how the data within the worksheet's filer region should be sorted.
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the region changes. Sort conditions are applied to the region
     * only when they are are added or removed or when the [[reapplySortConditions]] method is called.
     * </p>
     * @see [[reapplySortConditions]]
     */
    readonly sortSettings: RelativeIndexSortSettings;
    /**
     * @hidden
     */
    readonly _at: number;
    /**
     * @hidden
     */
    private readonly _aj;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ag: WorksheetRegionAddress;
    /**
     * @hidden
     */
    private _bk;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _ah;
    /**
     * @hidden
     */
    private _bl;
    /**
     * Applies an [[AverageFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The value indicating whether to filter in values below or above the average of the data range.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
     * @see [[AverageFilter]]
     * @see [[getFilter]]
     * @see [[clearFilters]]
     */
    applyAverageFilter(relativeColumnIndex: number, type: AverageFilterType): AverageFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="note">
     * <b>Note:</b> If the filter condition value is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param condition The condition which must pass for the data to be filtered in.
     * @throws [[ArgumentNullException]] 'condition' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[CustomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(relativeColumnIndex: number, condition: CustomFilterCondition): CustomFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="body">
     * If 'condition2' is null, the 'conditionalOperator' value is irrelevant.
     * </p>
     * <p class="note">
     * <b>Note:</b> If one of the filter condition values is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param condition1 The first condition used to filter the data.
     * @param condition2 The second condition used to filter the data.
     * @param conditionalOperator The operator which defines how to logically combine 'condition1' and 'condition2'.
     * @throws [[ArgumentNullException]] 'condition1' is null.
     * @throws [[InvalidEnumArgumentException]] 'conditionalOperator' is not defined in the [[ConditionalOperator]] enumeration.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[CustomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(relativeColumnIndex: number, condition1: CustomFilterCondition, condition2: CustomFilterCondition, conditionalOperator: ConditionalOperator): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter(a: number, b: CustomFilterCondition): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter1(a: number, b: CustomFilterCondition, c: CustomFilterCondition, d: ConditionalOperator): CustomFilter;
    /**
     * Applies an [[DatePeriodFilter]] to the column.
     * <p class="body">
     * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
     * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The type of date period to filter in.
     * @param value The 1-based value of the month or quarter to filter in.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
     * type is Month and value is less than 1 or greater than 12.
     * @see [[DatePeriodFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyDatePeriodFilter(relativeColumnIndex: number, type: DatePeriodFilterType, value: number): DatePeriodFilter;
    /**
     * Applies a [[FillFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fill A [[CellFill]] by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fill' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FillFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFillFilter(relativeColumnIndex: number, fill: CellFill): FillFilter;
    /**
     * @hidden
     */
    _k(a: number, b: boolean, ...c: string[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _n(a: number, b: boolean, c: IEnumerable$1<string>): FixedValuesFilter;
    /**
     * @hidden
     */
    _o(a: number, b: boolean, c: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FixedValuesFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param includeBlanks The value which indicates whether blank cells should be filtered in.
     * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
     * @param dateGroups The collection of fixed date groups which should be filtered in.
     * @throws [[ArgumentNullException]] 'dateGroups' is null.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
     * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
     * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FixedValuesFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFixedValuesFilter(relativeColumnIndex: number, includeBlanks: boolean, calendarType: CalendarType, ...dateGroups: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _applyFixedValuesFilter1(a: number, b: boolean, c: CalendarType, ...d: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _m(a: number, b: boolean, c: CalendarType, d: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fontColorInfo A [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColorInfo' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FontColorFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(relativeColumnIndex: number, fontColorInfo: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fontColor The font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColor' is empty.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FontColorFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(relativeColumnIndex: number, fontColor: string | Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter1(a: number, b: Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter(a: number, b: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[IconFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param iconSet The icon set containing the icon.
     * @throws [[ArgumentException]] If the icon set is not valid.
     * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
     * @throws [[IndexOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
     * @see [[IconFilter]]
     * @see [[Filter]]
     * @see [[clearFilter]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     */
    applyIconFilter(relativeColumnIndex: number, iconSet: FormatConditionIconSet, iconIndex: number | null): IconFilter;
    /**
     * @hidden
     */
    _applyIconFilter$i(a: number, b: FormatConditionIconSet, c: Nullable$1<number>): IconFilter;
    /**
     * @hidden
     */
    _s(a: number, b: ST_IconSetType, c: Nullable$1<number>): IconFilter;
    /**
     * Applies a [[RelativeDateRangeFilter]] to the column.
     * <p class="body">
     * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
     * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
     * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
     * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
     * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
     * dates in 1999, even if the workbook is opened in 2012.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
     * @param duration The duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[RelativeDateRangeFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyRelativeDateRangeFilter(relativeColumnIndex: number, offset: RelativeDateRangeOffset, duration: RelativeDateRangeDuration): RelativeDateRangeFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column which will filter in the top 10 values in the list of sorted values.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[TopOrBottomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(relativeColumnIndex: number): TopOrBottomFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The type of the filter.
     * @param value The number or percentage of value of values which should be filtered in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @throws [[ArgumentOutOfRangeException]] 'value' is less than 1 or greater than 500.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[TopOrBottomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(relativeColumnIndex: number, type: TopOrBottomFilterType, value: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter(a: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter1(a: number, b: TopOrBottomFilterType, c: number): TopOrBottomFilter;
    /**
     * Applies a [[YearToDateFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[YearToDateFilter]]
     * @see [[Filter]]
     * @see [[clearFilter]]
     */
    applyYearToDateFilter(relativeColumnIndex: number): YearToDateFilter;
    /**
     * Clears the filter that is applied to a specific column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     */
    clearFilter(relativeColumnIndex: number): void;
    /**
     * Clears all previously applied filters
     */
    clearFilters(): void;
    /**
     * Clears the region as well as any existing filters and sort criteria
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    clearRegion(): void;
    /**
     * Gets the filter that is applied to a specific column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @return The apllied filter or null if no filter was applied to this column.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     */
    getFilter(relativeColumnIndex: number): Filter;
    /**
     * Re-filters all data cells in the filter region based on the applied filters.
     * <p class="body">
     * Filters are not constantly evaluated as data within the region changes. Filters are applied to the region only when they are
     * added or removed or when the ReapplyFilters method is called.
     * </p>
     * <p class="body">
     * If no filters are applied this method will not do anything to the data.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * @see [[clearFilters]]
     */
    reapplyFilters(): void;
    /**
     * @hidden
     */
    private _be;
    /**
     * Re-sorts all data cells in the region based on the sort conditions.
     * @see [[sortSettings]]
     */
    reapplySortConditions(): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="body">The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.</p>
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @param cellReferenceMode The reference to use the parse the address.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setRegion(a: string): void;
    /**
     * @hidden
     */
    _setRegion1(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _a3(a: WorksheetColumnFilter): void;
    /**
     * @hidden
     */
    _ad(a: RelativeIndex): WorksheetRegion;
    /**
     * @hidden
     */
    _ba(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bc(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _z(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    _bo(): void;
    /**
     * @hidden
     */
    _bp(): void;
    /**
     * @hidden
     */
    _bq(a: NamedReference, b: boolean): void;
    /**
     * @hidden
     */
    _bu(a: boolean, b: NamedReference, c: boolean): {
        p1?: NamedReference;
        p2: boolean;
    };
    /**
     * @hidden
     */
    private _a4;
    /**
     * @hidden
     */
    private _a2;
    /**
     * @hidden
     */
    private _a5;
    /**
     * @hidden
     */
    private _a9;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    private _ao;
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    private _bv;
    /**
     * @hidden
     */
    private _bt;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _a1;
    /**
     * @hidden
     */
    private _bb;
    /**
     * @hidden
     */
    private static _br;
    /**
     * @hidden
     */
    private static _bs;
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    readonly culture: string | CultureInfo;
    /**
     * @hidden
     */
    readonly _culture$i: CultureInfo;
    /**
     * @hidden
     */
    readonly sortRegion: WorksheetRegion;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly worksheet: Worksheet;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * Represents a filter which can filter in date cells if the dates occur between the start of the current year
 * and the time when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyYearToDateFilter]]
 */
export declare class YearToDateFilter extends DateRangeFilter {
    static $t: Type;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: Date, d: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    readonly _m: ST_DynamicFilterType;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is above or below the average or standard deviation
 * for the associated range.
 */
export declare class AverageConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ca: string;
    /**
     * @hidden
     */
    static readonly _cb: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b9;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionAboveBelow);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns or sets a value which determines the manner in which cell values
     * are compared against the average or standard deviation for the associated
     * range.
     */
    /**
    * Returns or sets a value which determines the manner in which cell values
    * are compared against the average or standard deviation for the associated
    * range.
    */
    aboveBelow: FormatConditionAboveBelow;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * Returns or sets the numeric standard deviation for this condition.
     * Applicable only when the [[aboveBelow]] property is set
     * to 'AboveStandardDeviation' or 'BelowStandardDeviation'.
     */
    /**
    * Returns or sets the numeric standard deviation for this condition.
    * Applicable only when the [[aboveBelow]] property is set
    * to 'AboveStandardDeviation' or 'BelowStandardDeviation'.
    */
    numericStandardDeviation: number;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with no value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * <p class="body">
 * Since empty cells do not display content, the foreground-related properties of the
 * [[ConditionalFormatBase.cellFormat]] are not applicable.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export declare class BlanksConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Base class for the [[DataBarConditionalFormat]], [[IconSetConditionalFormat]],
 * and [[ColorScaleConditionalFormat]] classes.
 */
export declare abstract class ThresholdConditionBase extends ConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b4: string;
    /**
     * @hidden
     */
    private static readonly _b2;
    /**
     * @hidden
     */
    private static readonly _b3;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _bx;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines the values to which
     * this condition applies.
     * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
     * @see [[setFormula]]
     */
    readonly formula: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _by: SingleTargetFormula;
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    _b1(a: number, b: number, c: ConditionValue, d: RefBase): number;
    /**
     * @hidden
     */
    _b0(a: number, b: FormatConditionValueType): number;
    /**
     * Assigns a new [[Formula]] to the [[formula]] property.
     * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
     * @param formula The string representation of the formula.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _bz(a: RefBase): boolean;
    /**
     * @hidden
     */
    _b6(a: SingleTargetFormula): void;
}
/**
 * Exposes properties which control the coloring of a [[WorksheetCell]]
 * based on the cell's value as relative to minimum, midpoint, and maximum threshold values.
 * <p class="body">
 * This class support either a 2-color or 3-color scale, as determined by the value of the
 * <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
 * parameter of the constructor.
 * </p>
 * <p class="body">
 * For 2-color scales, cells in the associated range are colored based on how their
 * value relates to the <see cref="MinimumThreshold">minimum</see> and <see cref="MaximumThreshold">maximum</see>
 * thresholds.
 * </p>
 * <p class="body">
 * For 3-color scales, cells in the associated range are colored based on how their
 * value relates to the minimum, <see cref="MidpointThreshold">midpoint</see>, and
 * maximum thresholds.
 * </p>
 * <p class="body">
 * This class supports a maximum of three separate and distinct color thresholds.
 * </p>
 * <p class="body">
 * Specifying only one threshold is not supported and may result in unexpected behavior.
 * </p>
 * <p class="body">
 * If this instance is created as a 2-color scale, the [[midpointThreshold]]
 * property is not applicable. Attempting to set a property on the object returned from
 * the MidpointThreshold property in this case will cause an exception to be thrown.
 * </p>
 * @see [[minimumThreshold]]
 * @see [[maximumThreshold]]
 * @see [[midpointThreshold]]
 * @see [[colorScaleType]]
 * @see [[ColorScaleCriterion]]
 */
export declare class ColorScaleConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ci: string;
    /**
     * @hidden
     */
    static readonly _cg: string;
    /**
     * @hidden
     */
    static readonly _ch: string;
    private _cd;
    private _b9;
    private _b7;
    private _b8;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: ColorScaleType);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * Returns a [[ColorScaleType]] value which
     * identifies this instance as a 2-color or 3-color scale.
     * <p class="body">
     * A [[ColorScaleConditionalFormat]] instance which is created with
     * the 'TwoColor' value does not support the [[midpointThreshold]];
     * attempting to set a property on the object retuned from the MidpointThreshold
     * property will cause an exception to be thrown.
     * </p>
     */
    readonly colorScaleType: ColorScaleType;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the minimum threshold for this instance.
     * <p class="body">
     * The minimum threshold defines the criteria for the lowest or minimum value
     * across the associated range.
     * </p>
     * <p class="body">
     * For a 2-color scale, the [[maximumThreshold]] defines the next "stop";
     * for a 3-color scale, the [[midpointThreshold]] property defines the next stop.
     * </p>
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * minimum threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>HighestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[midpointThreshold]]
     * @see [[maximumThreshold]]
     */
    readonly minimumThreshold: ColorScaleCriterion;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the maximum threshold for this instance.
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * maximum threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[midpointThreshold]]
     * @see [[minimumThreshold]]
     */
    readonly maximumThreshold: ColorScaleCriterion;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the midpoint threshold for this instance.
     * <p class="body" >
     * The midpoint threshold is only supported for a [[ColorScaleConditionalFormat]]
     * instance with a value of 'ThreeColor' specified for the <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
     * parameter.
     * </p>
     * <p class="body" >
     * Attempting to set a property on the instance returned from this property will cause
     * an exception to be thrown if this instance was created as a 2-color scale.
     * </p>
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * midpoint threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[minimumThreshold]]
     * @see [[maximumThreshold]]
     */
    readonly midpointThreshold: ColorScaleCriterion;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    _cj(): void;
    /**
     * @hidden
     */
    private _cf;
    /**
     * @hidden
     */
    _ck(a: ColorScaleCriterion, b: string): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Base class for the [[IconCriterion]] and [[ColorScaleCriterion]] classes.
 * @see [[IconCriterion]]
 * @see [[ColorScaleCriterion]]
 */
export declare abstract class CriterionBase extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _k: string;
    /**
     * @hidden
     */
    static readonly _i: string;
    /**
     * @hidden
     */
    static readonly _l: string;
    private _a;
    constructor();
    /**
     * @hidden
     */
    abstract readonly _d: ThresholdConditionBase;
    /**
     * Returns the numeric value for this instance.
     * <p class="body">
     * This property is read-only; to assign a value type, use the
     * [[setValue]] or
     * [[setValue]]
     * methods.
     * </p>
     * <p class="body">
     * Note that the unit of measure for this value is determined by the
     * [[valueType]] property; for example, when <i>ValueType</i>
     * is set to <i>Number</i>, the value is interpreted as a numeric value,
     * but when set to <i>Percentage</i>, it is interpreted as a percentage.
     * </p>
     * @see [[valueType]]
     * @see [[formula]]
     * @see [[setValue]]
     */
    readonly value: number;
    /**
     * @hidden
     */
    readonly _b: ConditionValue;
    /**
     * Returns a [[FormatConditionValueType]] value which specifies
     * the manner in which the threshold values for this instance are determined.
     * <p class="body">
     * This property is read-only; to assign one of the following value types, use the
     * [[setValue]] method:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To assign a [[formula]], use the [[setFormula]] method.
     * </p>
     * @see [[setValue]]
     */
    readonly valueType: FormatConditionValueType;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines
     * whether cell values meet the criteria defined by the associated condition.
     * <p class="body">
     * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
     * </p>
     * <p class="body">
     * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
     * method.
     * </p>
     * @see [[setFormula]]
     */
    readonly formula: Formula;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _p(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * Assigns the specified formula to the [[formula]] property, and assigns
     * a value of <i>Formula</i> to the [[valueType]] property.
     * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
     * the value returned from the formula is interpreted. This parameter is optional and
     * defaults to 'Formula'.
     * @see [[formula]]
     * @see [[valueType]]
     * @see [[Formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode, valueType?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>, c?: FormatConditionValueType): void;
    /**
     * Sets the [[valueType]] property to the specified
     * [[FormatConditionValueType]] value.
     * <p class="body">
     * The 'valueType' parameter must be set to one of the following values
     * or an exception is thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To set the [[value]] property to a numeric value, use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * @param valueType The new value for the [[valueType]] property.
     */
    setValue(valueType: FormatConditionValueType): void;
    /**
     * Sets the [[value]] and [[valueType]] properties to the
     * specified values.
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to a [[FormatConditionValueType]]
     * value for which the [[value]] is not applicable, use the
     * [[setValue]] method.
     * </p>
     * @param value The new value for the [[value]] property.
     * @param valueType The new value for the [[valueType]] property. Must be set to either
     * <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i> or an exception is thrown.
     */
    setValue(value: number, valueType: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue1(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _v(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _j(a: any, b: string): string;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _m(): void;
    /**
     * @hidden
     */
    abstract _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _r(a: string): void;
    /**
     * @hidden
     */
    abstract _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _g(): boolean;
    /**
     * @hidden
     */
    _f(): boolean;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * Defines the criterion for a [[ColorScaleConditionalFormat]] threshold.
 * @see [[ColorScaleConditionalFormat.minimumThreshold]]
 * @see [[ColorScaleConditionalFormat.maximumThreshold]]
 * @see [[ColorScaleConditionalFormat.midpointThreshold]]
 */
export declare class ColorScaleCriterion extends CriterionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ar: string;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _x;
    private _aa;
    private _ac;
    private _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _af;
    constructor(a: ColorScaleConditionalFormat, b: ColorScaleCriterionThreshold);
    /**
     * @hidden
     */
    protected get__d(): ThresholdConditionBase;
    /**
     * @hidden
     */
    readonly _d: ThresholdConditionBase;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the color
     * information for the threshold associated with this instance.
     * <p class="body">
     * This property returns null if not explicitly set by the caller.
     * </p>
     */
    /**
    * Returns or sets a [[WorkbookColorInfo]] object which defines the color
    * information for the threshold associated with this instance.
    * <p class="body">
    * This property returns null if not explicitly set by the caller.
    * </p>
    */
    formatColor: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _al: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _ad: ColorScaleCriterionThreshold;
    /**
     * @hidden
     */
    _ab(a: ColorScaleConditionalFormat, b: boolean): ColorScaleCriterion;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ao(): boolean;
    /**
     * @hidden
     */
    _f(): boolean;
    /**
     * @hidden
     */
    readonly _an: boolean;
    /**
     * @hidden
     */
    private _am;
    /**
     * Returns the string representation of this instance.
     */
    toString(): string;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_PriorityConditionComparer extends Base implements IComparer$1<ConditionBase> {
    static $t: Type;
    static readonly _a: IComparer$1<ConditionBase>;
    compare(a: ConditionBase, b: ConditionBase): number;
}
/**
 * @hidden
 */
export declare class ConditionBase_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionBase, c: Tuple$3<number, number, WorksheetRegionAddress>[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: ConditionBase;
    readonly a: Tuple$3<number, number, WorksheetRegionAddress>[];
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * @hidden
 */
export declare class ConditionValueInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: FormatConditionValueType);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly h: number;
    readonly a: FormatConditionValueType;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    static b(a: ConditionValueInfo, b: ConditionValueInfo): boolean;
    static c(a: Nullable$1<ConditionValueInfo>, b: Nullable$1<ConditionValueInfo>): boolean;
    static d(a: ConditionValueInfo, b: ConditionValueInfo): boolean;
    static e(a: Nullable$1<ConditionValueInfo>, b: Nullable$1<ConditionValueInfo>): boolean;
}
/**
 * Exposes properties which define the value and its unit of measure
 * for a conditional format threshold.
 * <p class="body">
 * When the [[valueType]] property is set to <i>Number</i>, <i>Percentage</i>,
 * or <i>Percentile</i>, only the [[value]] property is applicable.
 * </p>
 * <p class="body">
 * Similarly, the [[formula]] property is only applicable when<i>ValueType</i>
 * is set to <i>Formula</i>.
 * </p>
 * <p class="body">
 * For the following settings of <i>ValueType</i>, neither <i>Value</i> nor <i>Formula</i>
 * is applicable, and the actual threshold is derived based on the highest and/or lowest
 * values in the associated range:
 * </p>
 * <p class="body">
 * <ul>
 * <li>AutomaticMinimum</li>
 * <li>AutomaticMaximum</li>
 * <li>LowestValue</li>
 * <li>HighestValue</li>
 * </ul>
 * </p>
 * @see [[value]]
 * @see [[formula]]
 * @see [[setFormula]]
 */
export declare class ConditionValue extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _y: string;
    /**
     * @hidden
     */
    static readonly _aa: string;
    /**
     * @hidden
     */
    static readonly _ab: string;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _a;
    private _k;
    private _l;
    private _h;
    private _t;
    private _e;
    private _j;
    constructor(a: ThresholdConditionBase, b: (arg1: ConditionValue, arg2: string) => void, c: (arg1: ConditionValue, arg2: number, arg3: FormatConditionValueType) => void);
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _u: number;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines
     * whether cell values meet the criteria defined by the associated condition.
     * <p class="body">
     * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
     * </p>
     * <p class="body">
     * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
     * method.
     * </p>
     * @see [[setFormula]]
     */
    readonly formula: Formula;
    /**
     * Returns the numeric value for this instance.
     * <p class="body">
     * This property is read-only; to assign a value type, use the
     * [[setValue]] or
     * [[setValue]]
     * methods.
     * </p>
     * <p class="body">
     * Note that the unit of measure for this value is determined by the
     * [[valueType]] property; for example, when <i>ValueType</i>
     * is set to <i>Number</i>, the value is interpreted as a numeric value,
     * but when set to <i>Percentage</i>, it is interpreted as a percentage.
     * </p>
     * @see [[valueType]]
     * @see [[formula]]
     * @see [[setValue]]
     */
    readonly value: number;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _f: ConditionValueInfo;
    /**
     * Returns a [[FormatConditionValueType]] value which specifies
     * the manner in which the threshold values for this instance are determined.
     * <p class="body">
     * This property is read-only; to assign one of the following value types, use the
     * [[setValue]] method:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To assign a [[formula]], use the [[setFormula]] method.
     * </p>
     * @see [[setValue]]
     */
    readonly valueType: FormatConditionValueType;
    /**
     * @hidden
     */
    _ac(): void;
    /**
     * @hidden
     */
    _d(a: ThresholdConditionBase, b: (arg1: ConditionValue, arg2: string) => void, c: (arg1: ConditionValue, arg2: number, arg3: FormatConditionValueType) => void): ConditionValue;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _ad(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ae(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    _ag(a: string): void;
    /**
     * @hidden
     */
    _o(): boolean;
    /**
     * @hidden
     */
    _n(): boolean;
    /**
     * @hidden
     */
    _p(): boolean;
    /**
     * @hidden
     */
    _m(): boolean;
    /**
     * Assigns the specified formula to the [[formula]] property, and assigns
     * a value of <i>Formula</i> to the [[valueType]] property.
     * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
     * the value returned from the formula is interpreted. This parameter is optional and
     * defaults to 'Formula'.
     * @see [[formula]]
     * @see [[valueType]]
     * @see [[Formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode, valueType?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>, c?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ai(a: SingleTargetFormula, b?: FormatConditionValueType): void;
    /**
     * Sets the [[valueType]] property to the specified
     * [[FormatConditionValueType]] value.
     * <p class="body">
     * The 'valueType' parameter must be set to one of the following values
     * or an exception is thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To set the [[value]] property to a numeric value, use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * @param valueType The new value for the [[valueType]] property.
     */
    setValue(valueType: FormatConditionValueType): void;
    /**
     * Sets the [[value]] and [[valueType]] properties to the
     * specified values.
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to a [[FormatConditionValueType]]
     * value for which the [[value]] is not applicable, use the
     * [[setValue]] method.
     * </p>
     * @param value The new value for the [[value]] property.
     * @param valueType The new value for the [[valueType]] property. Must be set to either
     * <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i> or an exception is thrown.
     * @throws [[ArgumentException]] If the value type or value is not appropriate for the condition.
     * @throws [[ArgumentOutOfRangeException]] If the value is out of range.
     */
    setValue(value: number, valueType: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue1(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    private _al;
    /**
     * Returns the string representation of this instance.
     */
    toString(): string;
    /**
     * @hidden
     */
    static _s(a: string, b: Nullable$1<number>, c: Nullable$1<number>): {
        ret: boolean;
        p1: Nullable$1<number>;
        p2: Nullable$1<number>;
    };
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * Exposes properties which displays data bars in a [[WorksheetCell]]
 * based on the cell's value as relative to the associated range.
 * <p class="body">
 * </p>
 */
export declare class DataBarConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _dj: string;
    /**
     * @hidden
     */
    static readonly _dk: string;
    /**
     * @hidden
     */
    static readonly _dl: string;
    /**
     * @hidden
     */
    static readonly _dm: string;
    /**
     * @hidden
     */
    static readonly _dn: string;
    /**
     * @hidden
     */
    static readonly _dp: string;
    /**
     * @hidden
     */
    static readonly _dt: string;
    /**
     * @hidden
     */
    static readonly _ds: string;
    /**
     * @hidden
     */
    static readonly _du: string;
    /**
     * @hidden
     */
    static readonly _dq: string;
    /**
     * @hidden
     */
    static readonly _dr: string;
    /**
     * @hidden
     */
    static readonly _dw: string;
    /**
     * @hidden
     */
    static readonly _dv: string;
    /**
     * @hidden
     */
    static readonly _de: number;
    /**
     * @hidden
     */
    static readonly _db: number;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _b7;
    private _cm;
    private _ce;
    private _cn;
    private _co;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cp;
    private _ci;
    private _cg;
    private _ca;
    private _cb;
    private _ck;
    private _c2;
    private _c3;
    private _cy;
    private _cx;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * color of the axis.
     */
    /**
    * Returns or sets a [[WorkbookColorInfo]] object which defines the
    * color of the axis.
    */
    axisColor: WorkbookColorInfo;
    /**
     * Returns or sets a [[DataBarAxisPosition]] value which determines
     * whether an axis is displayed.
     * @see [[DataBarAxisPosition]]
     */
    /**
    * Returns or sets a [[DataBarAxisPosition]] value which determines
    * whether an axis is displayed.
    * @see [[DataBarAxisPosition]]
    */
    axisPosition: DataBarAxisPosition;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * fill color of the data bar.
     */
    /**
    * Returns or sets a [[WorkbookColorInfo]] object which defines the
    * fill color of the data bar.
    */
    barColor: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _cv: WorkbookColorInfo;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * border color of the data bar.
     */
    /**
    * Returns or sets a [[WorkbookColorInfo]] object which defines the
    * border color of the data bar.
    */
    barBorderColor: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _ct: WorkbookColorInfo;
    /**
     * @hidden
     */
    static readonly _cw: WorkbookColorInfo;
    /**
     * Returns or sets a [[DataBarFillType]] value which determines
     * whether the data bar is filled with a solid color or a gradient.
     */
    /**
    * Returns or sets a [[DataBarFillType]] value which determines
    * whether the data bar is filled with a solid color or a gradient.
    */
    barFillType: DataBarFillType;
    /**
     * Returns or sets a [[DataBarDirection]] value which determines
     * the direction in which the data bar extends.
     */
    /**
    * Returns or sets a [[DataBarDirection]] value which determines
    * the direction in which the data bar extends.
    */
    direction: DataBarDirection;
    /**
     * Returns or sets a value which determines the manner in which the longest
     * bar is evaluated for this condition.
     * <p class="body">
     * The following values are not supported for the [[ConditionValue.valueType]]
     * property, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>None</li>
     * </ul>
     * </p>
     * @see [[minPoint]]
     * @see [[ConditionValue]]
     */
    readonly maxPoint: ConditionValue;
    /**
     * Returns or sets a value which determines the manner in which the shortest
     * bar is evaluated for this condition.
     * <p class="body">
     * The following values are not supported for the [[ConditionValue.valueType]]
     * property, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>HighestValue</li>
     * <li>AutomaticMaximum</li>
     * <li>None</li>
     * </ul>
     * </p>
     * @see [[minPoint]]
     * @see [[ConditionValue]]
     */
    readonly minPoint: ConditionValue;
    /**
     * Returns a [[negativeBarFormat]] object which defines the visual
     * attributes of negative-value data bars.
     */
    readonly negativeBarFormat: NegativeBarFormat;
    /**
     * Returns or sets an integer value which determines the length of
     * the longest data bar, expressed as a percentage of the cell's width.
     */
    /**
    * Returns or sets an integer value which determines the length of
    * the longest data bar, expressed as a percentage of the cell's width.
    */
    fillPercentMax: number;
    /**
     * Returns or sets an integer value which determines the length of
     * the shortest data bar, expressed as a percentage of the cell's width.
     */
    /**
    * Returns or sets an integer value which determines the length of
    * the shortest data bar, expressed as a percentage of the cell's width.
    */
    fillPercentMin: number;
    /**
     * Returns or sets a boolean value indicating whether borders
     * are displayed for both negative-value and positive-value
     * databars.
     */
    /**
    * Returns or sets a boolean value indicating whether borders
    * are displayed for both negative-value and positive-value
    * databars.
    */
    showBorder: boolean;
    /**
     * Returns or sets a boolean value indicating whether the cell
     * value is shown along with the data bar.
     * <p class="body">
     * By default, the cell value is displayed along with the databar;
     * use this property to prevent the cell value from appearing.
     * </p>
     */
    /**
    * Returns or sets a boolean value indicating whether the cell
    * value is shown along with the data bar.
    * <p class="body">
    * By default, the cell value is displayed along with the databar;
    * use this property to prevent the cell value from appearing.
    * </p>
    */
    showValue: boolean;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    readonly _cz: boolean;
    /**
     * @hidden
     */
    private static _b9;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    _dx(): void;
    /**
     * @hidden
     */
    _dz(a: string): void;
    /**
     * @hidden
     */
    _dy(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    private _d2;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    private static _d1;
    /**
     * @hidden
     */
    private _d0;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's date/time value falls within a given range of time.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with date/time
 * values which fall within a range of time as specified by the [[dateOperator]]
 * property.
 * </p>
 * <p class="body">
 * This condition provides only limited support for defining date/time ranges, i.e., the
 * current, previous, or next day, week or month. For wider ranges, or more precise conditions,
 * use the [[FormulaConditionalFormat]] class, and assign the desired date/time
 * formula to the [[FormulaConditionalFormat.formula]] property.
 * </p>
 * @see [[dateOperator]]
 * @see [[FormatConditionTimePeriod]]
 */
export declare class DateTimeConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b8: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionTimePeriod);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns or sets a [[FormatConditionTimePeriod]] value which
     * defines the range of time against which cell values are compared when
     * evaluating this condition.
     */
    /**
    * Returns or sets a [[FormatConditionTimePeriod]] value which
    * defines the range of time against which cell values are compared when
    * evaluating this condition.
    */
    dateOperator: FormatConditionTimePeriod;
    /**
     * @hidden
     */
    protected get__ai(): boolean;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    private static _b5;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique or duplicated across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are non-unique across
 * the associated range.
 * </p>
 * @see [[UniqueConditionalFormat]]
 */
export declare class DuplicateConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    private _b0;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which represents an error condition. For example, a cell
 * which displays the result of a formula whereby the formula results in
 * a divide-by-zero error meets the criteria of this condition.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoErrorsConditionalFormat]] class.
 * </p>
 * @see [[NoErrorsConditionalFormat]]
 */
export declare class ErrorsConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a <see cref="Excel.Formula">formula</see>.
 * @see [[formula]]
 */
export declare class FormulaConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b8: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b4;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: string, d?: Nullable$1<CellReferenceMode>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * Returns or sets the <see cref="Excel.Formula">formula</see> which defines the criteria for this condition.
     * <p class="body">
     * This property is not settable; however, the [[setFormula]]
     * method can be used to assign the formula.
     * </p>
     * @see [[setFormula]]
     */
    readonly formula: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _b5: SingleTargetFormula;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * Assigns a new [[Formula]] to this instance.
     * @param formula The string representation of the formula.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * @hidden
     */
    static _b9(a: string): string;
    /**
     * @hidden
     */
    static _ca(a: string): string;
}
/**
 * @hidden
 */
export declare class IconCriterionInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: FormatConditionIcon, c: FormatConditionIconSet, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: FormatConditionIcon;
    readonly b: FormatConditionIconSet;
    readonly i: number;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    static c(a: IconCriterionInfo, b: IconCriterionInfo): boolean;
    static d(a: Nullable$1<IconCriterionInfo>, b: Nullable$1<IconCriterionInfo>): boolean;
    static e(a: IconCriterionInfo, b: IconCriterionInfo): boolean;
    static f(a: Nullable$1<IconCriterionInfo>, b: Nullable$1<IconCriterionInfo>): boolean;
}
/**
 * Defines the criterion for an [[IconSetConditionalFormat]] threshold.
 * <p class="body">
 * This class provides the ability to override the default behavior of the
 * associated <see cref="IconSetConditionalFormat">condition</see> for the
 * threshold defined by this instance.
 * </p>
 * <p class="body">
 * For example, the icon displayed for cell values which fall within this threshold
 * is determined by the value of the [[IconSetConditionalFormat.iconSet]],
 * but can be overridden using the [[icon]] property.
 * </p>
 * <p class="body">
 * Similarly, the default unit for this criterion's <see cref="ConditionValue.Value">value</see> is percentage,
 * but this can be overridden using the [[ConditionValue.valueType]]
 * property. For example, to define the unit for the value as a specific number, assign
 * a value of <i>Number</i> to the <i>ValueType</i> property.
 * </p>
 * <p class="body">
 * The value for this threshold is defined by the parent condition, based on the
 * total number of thresholds. For [[IconSetConditionalFormat.iconSet]]
 * values which yield three thresholds, for example, the effective value is dependent
 * on the threshold, so that each threshold represents approximately 33% of the associated
 * range. This can be overridden using the [[CriterionBase.value]] property; for example, setting
 * the <i>ValueType</i> property to <i>Number</i> and the <i>Value</i> property to
 * a specific number overrides the behavior as defined by the parent condition, and forces
 * the threshold boundary to the specific numeric value.
 * </p>
 * <p class="body">
 * For this reason, the [[icon]], [[ConditionValue.value]], and [[ConditionValue.valueType]]
 * properties support null values, and are in fact set to null by default; this is interpreted
 * by the parent condition as "not set", resulting in the threshold criterion being determined
 * solely by the parent condition.
 * </p>
 * @see [[icon]]
 * @see [[CriterionBase.value]]
 * @see [[ValueType]]
 * @see [[IconSetConditionalFormat.iconSet]]
 */
export declare class IconCriterion extends CriterionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _at: string;
    /**
     * @hidden
     */
    static readonly _as: string;
    /**
     * @hidden
     */
    _ah: ThresholdComparison;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _x;
    private _ad;
    private _al;
    private _ab;
    private _af;
    constructor(a: number, b: IconSetCriterionCollection, c: number);
    constructor(a: number, b: IconSetCriterionCollection, c: number, d: FormatConditionIconSet, e: FormatConditionIcon);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__d(): ThresholdConditionBase;
    /**
     * @hidden
     */
    readonly _d: ThresholdConditionBase;
    /**
     * @hidden
     */
    readonly _ae: IconSetCriterionCollection;
    /**
     * Returns or sets a [[comparison]] value which
     * determines whether a "greater than" or "greater than or equal to"
     * comparison is made when comparing cell values to the <see cref="CriterionBase.Value">value</see>
     * of this instance.
     */
    /**
    * Returns or sets a [[comparison]] value which
    * determines whether a "greater than" or "greater than or equal to"
    * comparison is made when comparing cell values to the <see cref="CriterionBase.Value">value</see>
    * of this instance.
    */
    comparison: ThresholdComparison;
    /**
     * Returns or sets a [[FormatConditionIcon]] value which
     * identifies the icon displayed for this threshold as defined by the
     * [[IconSetConditionalFormat.iconSet]] and [[index]]
     * properties.
     * <p class="body">
     * By default, the icon displayed for this threshold is defined by the
     * parent <see cref="IconSetConditionalFormat">condition</see>, via the
     * value of the [[IconSetConditionalFormat.iconSet]] property.
     * </p>
     * <p class="body">
     * This property provides a way to override the default icon as defined by
     * the parent condition.
     * </p>
     * <p class="body">
     * This property defaults to the appropriate value given the <i>IconSet</i>
     * as defined by the parent condition and this instance's <i>Threshold</i>.
     * </p>
     * @see [[FormatConditionIcon]]
     * @see [[IconSetConditionalFormat.iconSet]]
     */
    /**
    * Returns or sets a [[FormatConditionIcon]] value which
    * identifies the icon displayed for this threshold as defined by the
    * [[IconSetConditionalFormat.iconSet]] and [[index]]
    * properties.
    * <p class="body">
    * By default, the icon displayed for this threshold is defined by the
    * parent <see cref="IconSetConditionalFormat">condition</see>, via the
    * value of the [[IconSetConditionalFormat.iconSet]] property.
    * </p>
    * <p class="body">
    * This property provides a way to override the default icon as defined by
    * the parent condition.
    * </p>
    * <p class="body">
    * This property defaults to the appropriate value given the <i>IconSet</i>
    * as defined by the parent condition and this instance's <i>Threshold</i>.
    * </p>
    * @see [[FormatConditionIcon]]
    * @see [[IconSetConditionalFormat.iconSet]]
    */
    icon: FormatConditionIcon;
    /**
     * @hidden
     */
    _av(a: FormatConditionIcon): void;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ac: IconCriterionInfo;
    /**
     * Returns a [[FormatConditionIconSet]] value which
     * identifies the icon set that includes this icon (read-only).
     * @see [[FormatConditionIconSet]]
     * @see [[IconSetConditionalFormat.iconSet]]
     */
    readonly iconSet: FormatConditionIconSet;
    /**
     * @hidden
     */
    readonly _ap: number;
    /**
     * @hidden
     */
    readonly _ak: boolean;
    /**
     * @hidden
     */
    readonly _aq: number;
    /**
     * @hidden
     */
    _aa(a: IconSetCriterionCollection): IconCriterion;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    static _an(a: FormatConditionIconSet): number;
    /**
     * @hidden
     */
    _au(a: FormatConditionIconSet, b: FormatConditionIcon, c: number): void;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _f(): boolean;
}
/**
 * @hidden
 */
export declare class IconSetConditionalFormat_IconSetChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: IconSetConditionalFormat, c: FormatConditionIconSet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: FormatConditionIconSet;
    readonly c: FormatConditionIconSet;
    readonly b: IconSetConditionalFormat;
    readonly a: IconCriterion[];
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * Exposes properties which displays icons in a [[WorksheetCell]]
 * based on the cell's value as relative to threshold values.
 * <p class="body">
 * This class provides the ability to display an icon inside a cell when that cell's
 * value meets the criteria defined by the relevant [[IconCriterion]].
 * </p>
 * <p class="body">
 * Each icon set contains between three and five individual icons. The number of icons
 * defines the number of thresholds; for example, a 3-icon set implies 3 thresholds, with
 * each threshold representing approximately 33% of the associated range. A 4-icon set
 * provides 4 thresholds, each representing 25% of the range; a 5-icon set contains 5
 * thresholds with each representing 20% of the range.
 * </p>
 * <p class="body">
 * Threshold ranges are pre-defined based on the number of icons in the associated set,
 * although this can be customized using the <see cref="CriterionBase.Value">Value</see> property
 * of the [[IconCriterion]] associated with that threshold.
 * </p>
 * <p class="body">
 * By default thresholds are expressed as percentages; use the <i>Value</i>
 * property to customize this to support a percentile rating or a specific value. How the
 * <i>Value</i> property is interpreted is dependent on the <see cref="CriterionBase.ValueType">ValueType</see> property.
 * </p>
 * <p class="body">
 * While the number of thresholds is always fixed at 3, 4, or 5, the icon which is displayed
 * for a given threshold can be customized using the [[IconCriterion.icon]] property.
 * </p>
 */
export declare class IconSetConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _cv: string;
    /**
     * @hidden
     */
    static readonly _cu: string;
    /**
     * @hidden
     */
    static readonly _cw: string;
    /**
     * @hidden
     */
    static readonly _cx: string;
    /**
     * @hidden
     */
    static readonly _cg: FormatConditionIconSet;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cr;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static _b7;
    private _ci;
    private _cj;
    private _ck;
    private _cd;
    private _cf;
    static staticInit(): void;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionIconSet);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * Returns the [[IconCriterion]] object corresponding to the
     * specified 'index'.
     * @param index A zero-based index.
     * @return The corresponding [[IconCriterion]] object
     */
    iconCriteria(index: number): IconCriterion;
    /**
     * Returns a <see cref="IconSetCriterionCollection">collection</see>
     * which defines the criteria for this condition.
     */
    iconCriteria(): IconSetCriterionCollection;
    /**
     * @hidden
     */
    readonly _iconCriteria$i: IconSetCriterionCollection;
    /**
     * Returns or sets a [[FormatConditionIconSet]] value which identifies
     * the set of icons used to express this condition.
     */
    /**
    * Returns or sets a [[FormatConditionIconSet]] value which identifies
    * the set of icons used to express this condition.
    */
    iconSet: FormatConditionIconSet;
    /**
     * @hidden
     */
    private _c0;
    /**
     * Returns true if the <see cref="IconCriterion.Icon">Icon</see>
     * property of one or more <see cref="IconCriterion">criterion</see>
     * returns a value which is from a different icon set as the one
     * returned from the [[iconSet]] property.
     */
    readonly isCustom: boolean;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cm: boolean;
    /**
     * Returns or sets a boolean value indicating whether the order in
     * which icons appear is reversed.
     */
    /**
    * Returns or sets a boolean value indicating whether the order in
    * which icons appear is reversed.
    */
    isReverseOrder: boolean;
    /**
     * Returns or sets a boolean value indicating whether the cell
     * value is shown along with the icon.
     * <p class="body">
     * By default, the cell value is displayed along with the icon;
     * use this property to prevent the cell value from appearing.
     * </p>
     */
    /**
    * Returns or sets a boolean value indicating whether the cell
    * value is shown along with the icon.
    * <p class="body">
    * By default, the cell value is displayed along with the icon;
    * use this property to prevent the cell value from appearing.
    * </p>
    */
    showValue: boolean;
    /**
     * @hidden
     */
    private _cy;
    /**
     * @hidden
     */
    private static _cb;
    /**
     * @hidden
     */
    private static _cc;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    static _b9(a: FormatConditionIconSet, b?: boolean): FormatConditionIcon[];
    /**
     * @hidden
     */
    private static _ca;
    /**
     * @hidden
     */
    static _cp(a: FormatConditionIcon, b: FormatConditionIconSet): {
        ret: number;
        p1?: FormatConditionIconSet;
    };
    /**
     * @hidden
     */
    _cz(a: IconCriterion, b: string): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    private static _c1;
}
/**
 * Collection class for objects of type [[IconCriterion]].
 * <p class="body">
 * This class does not expose an Add method because [[IconCriterion]]
 * instances are created based on the iconset.
 * </p>
 * <p class="body">
 * Enumerating this class causes immediate creation of all
 * [[IconCriterion]] objects.
 * </p>
 * <p class="body">
 * The <see cref="IconSetCriterionCollection.Count">Count</see> property
 * always returns either 3, 4, or 5, depending on the value of the
 * [[IconSetConditionalFormat.iconSet]] property.
 * </p>
 * @see [[IconCriterion]]
 * @see [[IconSetConditionalFormat.iconCriteria]]
 * @see [[IconSetConditionalFormat.iconSet]]
 * @see [[IconSetConditionalFormat]]
 * @see [[FormatConditionIconSet]]
 */
export declare class IconSetCriterionCollection extends Base implements IEnumerable$1<IconCriterion>, ISupportFormulaShifts {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _j;
    private _c;
    private _a;
    private _f;
    constructor(a: IconSetConditionalFormat, b: FormatConditionIconSet);
    /**
     * Returns the [[IconCriterion]] object corresponding to the
     * specified 'index'.
     * @param index A zero-based index.
     * @return The corresponding [[IconCriterion]] object
     */
    item(a: number): IconCriterion;
    /**
     * @hidden
     */
    readonly _d: IconSetConditionalFormat;
    /**
     * Returns the number of [[IconCriterion]] objects
     * contained within this collection.
     * <p class="body">
     * This property returns a value of 3, 4, or 5, depending on the
     * value of the [[IconSetConditionalFormat.iconSet]]
     * property.
     * </p>
     * @see [[FormatConditionIconSet]]
     */
    readonly count: number;
    /**
     * @hidden
     */
    readonly _h: boolean;
    /**
     * @hidden
     */
    _e(a: IconSetConditionalFormat, b: FormatConditionIconSet): IconSetCriterionCollection;
    /**
     * @hidden
     */
    _k(): void;
    /**
     * @hidden
     */
    readonly _g: boolean;
    /**
     * @hidden
     */
    _l(a: FormatConditionIconSet): void;
    /**
     * @hidden
     */
    _m(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: IconCriterion[]): void;
    /**
     * @hidden
     */
    _p(): void;
    /**
     * @hidden
     */
    _q(a: IconCriterion[]): void;
    /**
     * @hidden
     */
    _n(a: IconCriterion, b: string): void;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    [Symbol.iterator](): EnumeratorWrapper<IconCriterion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<IconCriterion>;
    /**
     * @hidden
     */
    _getEnumerator$e(): IEnumerator$1<IconCriterion>;
}
/**
 * Exposes properties which control the appearance of negative-value
 * <see cref="DataBarConditionalFormat">data bars</see>.
 */
export declare class NegativeBarFormat extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _aa: string;
    /**
     * @hidden
     */
    static readonly _ac: string;
    /**
     * @hidden
     */
    static readonly _ab: string;
    /**
     * @hidden
     */
    static readonly _ad: string;
    /**
     * @hidden
     */
    static readonly _i: DataBarNegativeBarColorType;
    /**
     * @hidden
     */
    static readonly _j: DataBarNegativeBarColorType;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _t;
    private _e;
    private _f;
    private _l;
    private _m;
    /**
     * @hidden
     */
    private static readonly _n;
    constructor(a: DataBarConditionalFormat, b: (arg1: string) => void);
    /**
     * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
     * whether the same border color as that which is used for data bars with positive cell
     * values is also used for data bars with negative cell values.
     * <p class="body">
     * By default, databars for cells with negative values use the same color
     * as those with positive values, and the [[barBorderColor]]
     * property is not used.
     * </p>
     * <p class="body">
     * Use this property to apply the color specified by the
     * [[barBorderColor]] property to the borders of databars
     * with negative cell values.
     * </p>
     * @see [[barBorderColor]]
     * @see [[DataBarConditionalFormat.barBorderColor]]
     */
    /**
    * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
    * whether the same border color as that which is used for data bars with positive cell
    * values is also used for data bars with negative cell values.
    * <p class="body">
    * By default, databars for cells with negative values use the same color
    * as those with positive values, and the [[barBorderColor]]
    * property is not used.
    * </p>
    * <p class="body">
    * Use this property to apply the color specified by the
    * [[barBorderColor]] property to the borders of databars
    * with negative cell values.
    * </p>
    * @see [[barBorderColor]]
    * @see [[DataBarConditionalFormat.barBorderColor]]
    */
    barBorderColorType: DataBarNegativeBarColorType;
    /**
     * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
     * whether the same color as that which is used for the positive data bars is used.
     * <p class="body">
     * By default, databars for cells with negative values have a different color
     * than those with positive values.
     * </p>
     * <p class="body">
     * Use this property to apply the same color to databars regardless of whether
     * the cell value is positive or negative.
     * </p>
     * @see [[barColor]]
     * @see [[DataBarConditionalFormat.barColor]]
     */
    /**
    * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
    * whether the same color as that which is used for the positive data bars is used.
    * <p class="body">
    * By default, databars for cells with negative values have a different color
    * than those with positive values.
    * </p>
    * <p class="body">
    * Use this property to apply the same color to databars regardless of whether
    * the cell value is positive or negative.
    * </p>
    * @see [[barColor]]
    * @see [[DataBarConditionalFormat.barColor]]
    */
    barColorType: DataBarNegativeBarColorType;
    /**
     * Returns a [[WorkbookColorInfo]] which defines the border color
     * applied to data bars with a negative value.
     * <p class="body">
     * This property is only applicable when the [[barBorderColorType]]
     * property is set to <i>Color</i>.
     * </p>
     * @see [[barBorderColorType]]
     */
    /**
    * Returns a [[WorkbookColorInfo]] which defines the border color
    * applied to data bars with a negative value.
    * <p class="body">
    * This property is only applicable when the [[barBorderColorType]]
    * property is set to <i>Color</i>.
    * </p>
    * @see [[barBorderColorType]]
    */
    barBorderColor: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _p: WorkbookColorInfo;
    /**
     * Returns a [[WorkbookColorInfo]] which defines the fill color
     * applied to data bars with a negative value.
     * <p class="body">
     * This property is only applicable when the [[barColorType]]
     * property is set to <i>Color</i>.
     * </p>
     * @see [[barBorderColorType]]
     */
    /**
    * Returns a [[WorkbookColorInfo]] which defines the fill color
    * applied to data bars with a negative value.
    * <p class="body">
    * This property is only applicable when the [[barColorType]]
    * property is set to <i>Color</i>.
    * </p>
    * @see [[barBorderColorType]]
    */
    barColor: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _r: WorkbookColorInfo;
    /**
     * @hidden
     */
    static readonly _s: WorkbookColorInfo;
    /**
     * @hidden
     */
    _k(a: DataBarConditionalFormat, b: boolean): NegativeBarFormat;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ae;
    /**
     * @hidden
     */
    _u(): boolean;
    /**
     * @hidden
     */
    readonly source: any;
    /**
     * @hidden
     */
    readonly workbook: Workbook;
    /**
     * @hidden
     */
    readonly sheet: Sheet;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a non-empty value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export declare class NoBlanksConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which does not constitute an error.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[ErrorsConditionalFormat]] class.
 * </p>
 * @see [[ErrorsConditionalFormat]]
 */
export declare class NoErrorsConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a logical operator.
 * @see [[operator]]
 * @see [[operand1]]
 */
export declare class OperatorConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b7;
    private _cb;
    private _cc;
    private _b2;
    private _b3;
    private _b4;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * Returns a [[FormatConditionOperator]] constant which determines the
     * manner in which the cell value is compared against the [[operand1]]
     * property.
     * <p class="body">
     * This property determines how the cell value is compared to the [[operand1]]
     * property; for example, whether it is equal, greater than, less than, etc.
     * </p>
     * <p class="body">
     * For the [[FormatConditionOperator]] values 'Between' and 'NotBetween',
     * the [[operand2]] property must also be set.
     * </p>
     * @see [[operand1]]
     * @see [[operand2]]
     */
    /**
    * Returns a [[FormatConditionOperator]] constant which determines the
    * manner in which the cell value is compared against the [[operand1]]
    * property.
    * <p class="body">
    * This property determines how the cell value is compared to the [[operand1]]
    * property; for example, whether it is equal, greater than, less than, etc.
    * </p>
    * <p class="body">
    * For the [[FormatConditionOperator]] values 'Between' and 'NotBetween',
    * the [[operand2]] property must also be set.
    * </p>
    * @see [[operand1]]
    * @see [[operand2]]
    */
    operator: FormatConditionOperator;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which defines
     * the criteria for the first operand of this condition.
     * <p class="body">
     * This property is not directly settable; however, the following methods can be used to
     * assign a formula:
     * </p>
     * <p class="body">
     * <ul>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1Formula]]</li>
     * </ul>
     * </p>
     * <p class="body">
     * When the [[operator]] property is set
     * to <i>Between</i> or <i>NotBetween</i>, this property defines the
     * lower limit of the range for "between" comparisons.
     * </p>
     * <p class="body">
     * Use the [[operand2]] property to define the
     * upper limit of the range for "between" comparisons.
     * </p>
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1Formula]]
     * @see [[operand2]]
     */
    readonly operand1: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _cd: SingleTargetFormula;
    /**
     * Returns or sets a <see cref="Excel.Formula">formula</see> for the second operand
     * which defines the criteria for this condition when the [[operator]]
     * property is set to <i>Between</i> or <i>NotBetween</i>
     * <p class="body">
     * This property is only applicable when the [[operator]] property is set
     * to <i>Between</i> or <i>NotBetween</i>.
     * </p>
     * <p class="body">
     * Use this property to define the upper limit of the range for "between" comparisons, and the
     * [[operand1]] property to define the lower limit.
     * </p>
     * <p class="body">
     * This property is not directly settable; however, the following methods can be used to
     * assign a formula:
     * </p>
     * <p class="body">
     * <ul>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2Formula]]</li>
     * </ul>
     * </p>
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2Formula]]
     * @see [[operand1]]
     */
    readonly operand2: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ce: SingleTargetFormula;
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    private static _ck;
    /**
     * @hidden
     */
    private static _cf;
    /**
     * Assigns a [[Formula]] to the [[operand1]] property.
     * <p class="body">
     * Note that the value of the 'formula' parameter must begin with an
     * equals sign (=).
     * </p>
     * @param formula The string representation of the [[Formula]] to be assigned to the [[operand1]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[operand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand2Formula]]
     */
    setOperand1Formula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setOperand1Formula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * Assigns a [[Formula]] to the [[operand2]] property.
     * <p class="body">
     * Note that the value of the 'formula' parameter must begin with an
     * equals sign (=).
     * </p>
     * @param formula The string representation of the [[Formula]] to be assigned to the [[operand2]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[operand2]]
     * @see [[operand1]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand1Formula]]
     */
    setOperand2Formula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setOperand2Formula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * Assigns the specified <i>System.DateTime</i> value to the [[operand1]] property.
     * @param value The <i>System.DateTime</i> value to assign.
     */
    setOperand1(value: Date): void;
    /**
     * Assigns the specified <i>System.Double</i> value to the [[operand1]] property.
     * @param value The <i>System.Double</i> value to assign.
     */
    setOperand1(value: number): void;
    /**
     * Assigns the specified <i>System.String</i> value to the [[operand1]] property.
     * @param value The <i>System.String</i> value to assign.
     */
    setOperand1(value: string): void;
    /**
     * @hidden
     */
    _setOperand11(a: number): void;
    /**
     * @hidden
     */
    _setOperand12(a: string): void;
    /**
     * @hidden
     */
    _setOperand1(a: Date): void;
    /**
     * Assigns the specified <i>System.DateTime</i> value to the [[operand2]] property.
     * @param value The <i>System.DateTime</i> value to assign.
     */
    setOperand2(value: Date): void;
    /**
     * Assigns the specified <i>System.Double</i> value to the [[operand2]] property.
     * @param value The <i>System.Double</i> value to assign.
     */
    setOperand2(value: number): void;
    /**
     * Assigns the specified <i>System.String</i> value to the [[operand2]] property.
     * @param value The <i>System.String</i> value to assign.
     */
    setOperand2(value: string): void;
    /**
     * @hidden
     */
    _setOperand21(a: number): void;
    /**
     * @hidden
     */
    _setOperand22(a: string): void;
    /**
     * @hidden
     */
    _setOperand2(a: Date): void;
    /**
     * @hidden
     */
    protected get__z(): boolean;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is within the top or bottom rank of values across the
 * associated range.
 * <p class="body">
 * A rank condition evaluates to true if a cell value is within the range defined by
 * the top or bottom <i>n</i> values across the associated range, where <i>n</i> represents
 * the [[rank]].
 * </p>
 * <p class="body">
 * A popular example of a rank condition is "top ten ", where cell values which are within
 * the range of the ten highest values across the range meet the condition. The [[rank]]
 * property, however, can be set to any arbitrary number or percentage, and is not limited to only
 * the top or bottom ten values.
 * </p>
 * <p class="body">
 * By default, this condition evaluates to true if a cell's value is at or above the specified rank;
 * to change this to the bottom of the ranking, set the [[topBottom]] property to 'Bottom'.
 * </p>
 * <p class="body">
 * The numeric criteria can be changed to a percentage using the [[isPercent]] property.
 * In this case, the <i>Rank</i> property is interepreted as a percentage.
 * </p>
 */
export declare class RankConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ch: string;
    /**
     * @hidden
     */
    static readonly _cf: string;
    /**
     * @hidden
     */
    static readonly _cg: string;
    /**
     * @hidden
     */
    static readonly _b9: number;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _cb;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    private _b6;
    private _b8;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionTopBottom, d?: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * Returns or sets a boolean value indicating whether the [[rank]] is determined
     * by a percentage value.
     * <p class="body">
     * By default, this condition evaluates cell values against the value of the [[rank]]
     * property, with the rank representing an explicit numeric value. Set this property to true
     * to identify the rank as a percentage.
     * </p>
     * <p class="body">
     * If the <i>IsPercent</i> property is set to true, this property supports only values
     * between 1 and 100, inclusively.
     * </p>
     */
    /**
    * Returns or sets a boolean value indicating whether the [[rank]] is determined
    * by a percentage value.
    * <p class="body">
    * By default, this condition evaluates cell values against the value of the [[rank]]
    * property, with the rank representing an explicit numeric value. Set this property to true
    * to identify the rank as a percentage.
    * </p>
    * <p class="body">
    * If the <i>IsPercent</i> property is set to true, this property supports only values
    * between 1 and 100, inclusively.
    * </p>
    */
    isPercent: boolean;
    /**
     * Returns or sets a value which specifies either the number or percentage
     * of the rank value for the associated condition.
     * <p class="body">
     * The default value of this property is 10, and the default value for the [[topBottom]]
     * property is 'Top', so that creating an instance of this class without specifying non-default
     * property values results in a "top ten" condition.
     * </p>
     * <p class="body">
     * The value of this property is interepreted as either a number or a percentage,
     * depending on the value of the [[isPercent]] property.
     * </p>
     * <p class="body">
     * If the <i>IsPercent</i> property is set to true, this property supports only values
     * between 1 and 100, inclusively.
     * </p>
     * @see [[isPercent]]
     */
    /**
    * Returns or sets a value which specifies either the number or percentage
    * of the rank value for the associated condition.
    * <p class="body">
    * The default value of this property is 10, and the default value for the [[topBottom]]
    * property is 'Top', so that creating an instance of this class without specifying non-default
    * property values results in a "top ten" condition.
    * </p>
    * <p class="body">
    * The value of this property is interepreted as either a number or a percentage,
    * depending on the value of the [[isPercent]] property.
    * </p>
    * <p class="body">
    * If the <i>IsPercent</i> property is set to true, this property supports only values
    * between 1 and 100, inclusively.
    * </p>
    * @see [[isPercent]]
    */
    rank: number;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * Returns or sets a value indicating whether a cell value must fall within
     * the top or bottom of the ranking across the associated range.
     */
    /**
    * Returns or sets a value indicating whether a cell value must fall within
    * the top or bottom of the ranking across the associated range.
    */
    topBottom: FormatConditionTopBottom;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * @hidden
 */
export declare class RankConditionalFormat_ValueCache extends Base {
    static $t: Type;
    private b;
    constructor(a: RankConditionalFormat);
    readonly c: number;
    a(a: number): boolean;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's text value meets the criteria defined by a string and a
 * [[FormatConditionTextOperator]] value.
 */
export declare class TextOperatorConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ch: string;
    /**
     * @hidden
     */
    static readonly _cg: string;
    /**
     * @hidden
     */
    static readonly _ca: string;
    /**
     * @hidden
     */
    static readonly _cb: string;
    /**
     * @hidden
     */
    static readonly _cd: string;
    /**
     * @hidden
     */
    static readonly _cc: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b5;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b8;
    private _b9;
    private _b3;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: string, d?: FormatConditionTextOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * Returns or sets the string value against which cell text is compared.
     */
    /**
    * Returns or sets the string value against which cell text is compared.
    */
    text: string;
    /**
     * Returns or sets a [[FormatConditionTextOperator]] value which
     * determines the manner in which the cell text is compared to the value of the
     * [[text]] property.
     */
    /**
    * Returns or sets a [[FormatConditionTextOperator]] value which
    * determines the manner in which the cell text is compared to the value of the
    * [[text]] property.
    */
    textOperator: FormatConditionTextOperator;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    static _ce(a: string, b: FormatConditionTextOperator, c?: string): string;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are unique across
 * the associated range.
 * </p>
 * @see [[DuplicateConditionalFormat]]
 */
export declare class UniqueConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b1: string;
    private _b0;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
}
/**
 * @hidden
 */
export declare class UniqueConditionalFormat_DuplicateValueHolder extends Base {
    static $t: Type;
    private e;
    private d;
    private b;
    private a;
    constructor(a: IEnumerable$1<WorksheetRegion>);
    c(a: any): boolean;
}
/**
 * Represents a unit label on an axis in a chart.
 */
export declare class DisplayUnitLabel extends ChartTextAreaBase {
    static $t: Type;
    constructor();
}
/**
 * Represents the major/minor gridlines for an [[Axis]].
 * <p class="body">
 * The color of the grid lines is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the grid lines is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export declare class ChartGridLines extends ChartLineBase {
    static $t: Type;
    private _al;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    private _gridLineType;
    /**
     * Returns a value indicating whether this instance
     * represents a major or minor gridline.
     */
    /**
    * Returns a value indicating whether this instance
    * represents a major or minor gridline.
    */
    gridLineType: GridLineType;
    /**
     * @hidden
     */
    _an(a: IChartObject, b: GridLineType): void;
    /**
     * @hidden
     */
    readonly _ak: ChartFillBase;
}
/**
 * Represents the tick lines for an [[Axis]].
 * <p class="body">
 * The color of the tick line is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the tick line is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 * @see [[Axis.tickLines]]
 */
export declare class ChartTickLines extends ChartLineBase {
    static $t: Type;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    readonly _ak: ChartFillBase;
}
/**
 * Represents a single axis in a chart.
 * <p class="body">
 * To change the color of the ticklines, use the [[ChartLineBase.fill]] property.
 * </p>
 */
export declare class Axis extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ck;
    /**
     * @hidden
     */
    private static readonly _cm;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _co;
    /**
     * @hidden
     */
    private static readonly _cn;
    /**
     * @hidden
     */
    private static readonly _cp;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cr;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cu;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _c0;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c2;
    /**
     * @hidden
     */
    private static readonly _c3;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _dj;
    /**
     * @hidden
     */
    private static readonly _dl;
    /**
     * @hidden
     */
    private static readonly _dm;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    static readonly _b2: number;
    /**
     * @hidden
     */
    static readonly _b3: number;
    /**
     * @hidden
     */
    static readonly _c8: number;
    /**
     * @hidden
     */
    static readonly _c9: number;
    /**
     * @hidden
     */
    static readonly _dd: number;
    /**
     * @hidden
     */
    static readonly _dc: number;
    /**
     * @hidden
     */
    static readonly _de: number;
    /**
     * @hidden
     */
    static readonly _b7: number;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _ad;
    private _ah;
    private _av;
    private _bc;
    private _an;
    private _af;
    private _bu;
    private _aa;
    private _ax;
    private _bv;
    private _az;
    private _dn;
    private _bw;
    private _ap;
    private _a8;
    private _bx;
    private _bd;
    private _by;
    private _bz;
    private _aq;
    private _a9;
    private _b0;
    private _be;
    private _aj;
    private _a1;
    private _a4;
    private _a6;
    private _cd;
    private _at;
    private _ce;
    private _al;
    constructor(a: IChartObject, b: AxisType, c: AxisGroup);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * True if the value axis crosses the category axis between categories.
     */
    /**
    * True if the value axis crosses the category axis between categories.
    */
    axisBetweenCategories: boolean;
    /**
     * Returns the group for the specified axis. Read-only
     */
    readonly axisGroup: AxisGroup;
    /**
     * Returns or sets a [[ChartTitle]] object that represents the title of the axis.
     */
    /**
    * Returns or sets a [[ChartTitle]] object that represents the title of the axis.
    */
    axisTitle: ChartTitle;
    /**
     * Returns or sets the base unit for the axis.
     * <para class="note">
     * Setting this property has no visible effect if the [[categoryType]]  property for the specified axis is set to 'CategoryScale'.
     * The set value is retained, however, and takes effect when the <b>CategoryType</b> property is set to 'TimeScale'.
     * </para>
     */
    /**
    * Returns or sets the base unit for the axis.
    * <para class="note">
    * Setting this property has no visible effect if the [[categoryType]]  property for the specified axis is set to 'CategoryScale'.
    * The set value is retained, however, and takes effect when the <b>CategoryType</b> property is set to 'TimeScale'.
    * </para>
    */
    baseUnit: TimeUnit;
    /**
     * True if Excel chooses appropriate base units for the specified category axis. The default value is True.
     */
    /**
    * True if Excel chooses appropriate base units for the specified category axis. The default value is True.
    */
    baseUnitIsAuto: boolean;
    /**
     * Returns or sets the category axis type.
     * <p class="body">
     * This property applies only to <see cref="Charts.AxisType">category</see> axes.
     * </p>
     * <p class="body">
     * When set to <i>Automatic</i>, the axis will resolve the
     * category type to either <i>CategoryScale</i> or <i>TimeScale</i>,
     * based on the type of the selected data.
     * </p>
     */
    /**
    * Returns or sets the category axis type.
    * <p class="body">
    * This property applies only to <see cref="Charts.AxisType">category</see> axes.
    * </p>
    * <p class="body">
    * When set to <i>Automatic</i>, the axis will resolve the
    * category type to either <i>CategoryScale</i> or <i>TimeScale</i>,
    * based on the type of the selected data.
    * </p>
    */
    categoryType: CategoryType;
    /**
     * Returns or sets the point on the specified axis where the other axis crosses.
     * <p class="body">
     * This property is only applicable to a category axis.
     * </p>
     * <p class="body">
     * Set this property to <i>Custom</i> to specify a data value as a crossing point,
     * using the [[crossesAt]] property to specify that value.
     * </p>
     * @see [[crossesAt]]
     */
    /**
    * Returns or sets the point on the specified axis where the other axis crosses.
    * <p class="body">
    * This property is only applicable to a category axis.
    * </p>
    * <p class="body">
    * Set this property to <i>Custom</i> to specify a data value as a crossing point,
    * using the [[crossesAt]] property to specify that value.
    * </p>
    * @see [[crossesAt]]
    */
    crosses: AxisCrosses;
    /**
     * Returns or sets the point on the [[Axis]] at which the
     * perpendicular axis intersects it.
     * <p class="body">
     * For a category axis, this value is interpreted as the value of a data point.
     * For example, on a category axis with a minimum data value of 0 and a maximum
     * of 500, setting this property to 250 causes this axis to appear near the center
     * of the plot area.
     * </p>
     * <p class="body">
     * For a value axis, this value is interpreted as the one-based number of the
     * category with which this axis should intersect.
     * </p>
     * <p class="body">
     * Setting this property causes the [[crosses]] property to change to 'Custom'.
     * </p>
     * <p class="body">
     * This property cannot be used on radar charts.
     * </p>
     * <p class="body">
     * For 3-D charts, this property indicates where the plane defined
     * by the category axes crosses the value axis.
     * </p>
     */
    /**
    * Returns or sets the point on the [[Axis]] at which the
    * perpendicular axis intersects it.
    * <p class="body">
    * For a category axis, this value is interpreted as the value of a data point.
    * For example, on a category axis with a minimum data value of 0 and a maximum
    * of 500, setting this property to 250 causes this axis to appear near the center
    * of the plot area.
    * </p>
    * <p class="body">
    * For a value axis, this value is interpreted as the one-based number of the
    * category with which this axis should intersect.
    * </p>
    * <p class="body">
    * Setting this property causes the [[crosses]] property to change to 'Custom'.
    * </p>
    * <p class="body">
    * This property cannot be used on radar charts.
    * </p>
    * <p class="body">
    * For 3-D charts, this property indicates where the plane defined
    * by the category axes crosses the value axis.
    * </p>
    */
    crossesAt: number;
    /**
     * @hidden
     */
    _dy(a: number, b?: boolean): void;
    /**
     * @hidden
     */
    readonly _dp: Nullable$1<number>;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _ab: Axis;
    /**
     * @hidden
     */
    readonly _ac: Axis;
    /**
     * @hidden
     */
    readonly _cg: number;
    /**
     * @hidden
     */
    _dr(a: Axis): Nullable$1<number>;
    /**
     * Returns or sets the unit label for the value axis.
     */
    /**
    * Returns or sets the unit label for the value axis.
    */
    displayUnit: DisplayUnit;
    /**
     * If the value of the DisplayUnit property 'Custom' , the DisplayUnitCustom property returns or sets the value of the displayed units. The value must be from 0 through 10E307
     */
    /**
    * If the value of the DisplayUnit property 'Custom' , the DisplayUnitCustom property returns or sets the value of the displayed units. The value must be from 0 through 10E307
    */
    displayUnitCustom: number;
    /**
     * Returns or sets an [[displayUnitLabel]] object.
     */
    /**
    * Returns or sets an [[displayUnitLabel]] object.
    */
    displayUnitLabel: DisplayUnitLabel;
    /**
     * Returns or sets a value indicating the width of the gaps between data points
     * or series, expressed as a percentage.
     * <p class="body">
     * This property is only applicable for <i>Box and Whisker</i>, <i>Histogram</i>,
     * <i>Pareto</i>, and <i>Waterfall</i> charts.
     * </p>
     */
    /**
    * Returns or sets a value indicating the width of the gaps between data points
    * or series, expressed as a percentage.
    * <p class="body">
    * This property is only applicable for <i>Box and Whisker</i>, <i>Histogram</i>,
    * <i>Pareto</i>, and <i>Waterfall</i> charts.
    * </p>
    */
    gapWidth: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _gapWidth$i: Nullable$1<number>;
    /**
     * Returns or sets the base of the logarithm when you are using log scales.
     * <para class="note">
     * Attempting to set this property to a value less than 2 causes an error. The default value is 10.
     * </para>
     */
    /**
    * Returns or sets the base of the logarithm when you are using log scales.
    * <para class="note">
    * Attempting to set this property to a value less than 2 causes an error. The default value is 10.
    * </para>
    */
    logBase: number;
    /**
     * Returns a [[ChartGridLines]] object which defines
     * the color and weight of the major ticklines.
     */
    /**
    * Returns a [[ChartGridLines]] object which defines
    * the color and weight of the major ticklines.
    */
    majorGridLines: ChartGridLines;
    /**
     * Returns or sets the type of major tick mark for the specified axis.
     */
    /**
    * Returns or sets the type of major tick mark for the specified axis.
    */
    majorTickMark: TickMark;
    /**
     * True if Excel calculates the major units for the value axis.
     */
    /**
    * True if Excel calculates the major units for the value axis.
    */
    majorUnitIsAuto: boolean;
    /**
     * Returns the major interval unit.
     * <p class="body">
     * To set the value of this property, use the [[setMajorMinorUnit]] method.
     * </p>
     * @see [[setMajorMinorUnit]]
     * @see [[minorUnit]]
     */
    /**
    * Returns the major interval unit.
    * <p class="body">
    * To set the value of this property, use the [[setMajorMinorUnit]] method.
    * </p>
    * @see [[setMajorMinorUnit]]
    * @see [[minorUnit]]
    */
    majorUnit: number;
    /**
     * Returns or sets the major unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
     */
    /**
    * Returns or sets the major unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
    */
    majorUnitScale: TimeUnit;
    /**
     * Returns or sets the maximum value on the value axis.
     */
    /**
    * Returns or sets the maximum value on the value axis.
    */
    maximumScale: number;
    /**
     * True if Excel calculates the maximum value for the value axis.
     */
    /**
    * True if Excel calculates the maximum value for the value axis.
    */
    maximumScaleIsAuto: boolean;
    /**
     * Returns or sets the minimum value on the value axis.
     */
    /**
    * Returns or sets the minimum value on the value axis.
    */
    minimumScale: number;
    /**
     * True if Excel calculates the minimum value for the value axis.
     */
    /**
    * True if Excel calculates the minimum value for the value axis.
    */
    minimumScaleIsAuto: boolean;
    /**
     * Returns a [[ChartGridLines]] object which defines
     * the color and weight of the minor ticklines.
     */
    /**
    * Returns a [[ChartGridLines]] object which defines
    * the color and weight of the minor ticklines.
    */
    minorGridLines: ChartGridLines;
    /**
     * Returns or sets the type of minor tick mark for the specified axis.
     */
    /**
    * Returns or sets the type of minor tick mark for the specified axis.
    */
    minorTickMark: TickMark;
    /**
     * Returns the minor interval unit.
     * <p class="body">
     * To set the value of this property, use the [[setMajorMinorUnit]] method.
     * </p>
     * @see [[setMajorMinorUnit]]
     * @see [[majorUnit]]
     */
    /**
    * Returns the minor interval unit.
    * <p class="body">
    * To set the value of this property, use the [[setMajorMinorUnit]] method.
    * </p>
    * @see [[setMajorMinorUnit]]
    * @see [[majorUnit]]
    */
    minorUnit: number;
    /**
     * True if Excel calculates the minor units for the value axis.
     */
    /**
    * True if Excel calculates the minor units for the value axis.
    */
    minorUnitIsAuto: boolean;
    /**
     * Returns or sets the minor unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
     */
    /**
    * Returns or sets the minor unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
    */
    minorUnitScale: TimeUnit;
    /**
     * Returns or sets an [[AxisPosition]] value which determines
     * the placement of the axis as relative to the chart space.
     * <p class="body">
     * This property is not applicable for series axes.
     * </p>
     */
    /**
    * Returns or sets an [[AxisPosition]] value which determines
    * the placement of the axis as relative to the chart space.
    * <p class="body">
    * This property is not applicable for series axes.
    * </p>
    */
    position: AxisPosition;
    /**
     * True if Excel plots data points from last to first.
     */
    /**
    * True if Excel plots data points from last to first.
    */
    reversePlotOrder: boolean;
    /**
     * Returns or sets a value indicating whether the axis scale is linear or logarithmic.
     * <p class="body">
     * This property is only applicable for <see cref="Type">value</see> axes.
     * </p>
     * <p class="body">
     * Logarithmic scaling is not supported for axes which are associated with a series
     * that contains negative values.
     * </p>
     */
    /**
    * Returns or sets a value indicating whether the axis scale is linear or logarithmic.
    * <p class="body">
    * This property is only applicable for <see cref="Type">value</see> axes.
    * </p>
    * <p class="body">
    * Logarithmic scaling is not supported for axes which are associated with a series
    * that contains negative values.
    * </p>
    */
    scaleType: ScaleType;
    /**
     * Describes the position of tick-mark labels on the specified axis.
     */
    /**
    * Describes the position of tick-mark labels on the specified axis.
    */
    tickLabelPosition: TickLabelPosition;
    /**
     * Returns a TickLabels object that represents the tick-mark labels for the specified axis. Read-only.
     */
    readonly tickLabels: TickLabels;
    /**
     * Returns or sets the number of categories or series between tick-mark labels. Applies only to category and series axes. Can be a value from 1 through 31999.
     */
    /**
    * Returns or sets the number of categories or series between tick-mark labels. Applies only to category and series axes. Can be a value from 1 through 31999.
    */
    tickLabelSpacing: number;
    /**
     * Returns or sets whether or not the tick label spacing is automatic.
     */
    /**
    * Returns or sets whether or not the tick label spacing is automatic.
    */
    tickLabelSpacingIsAuto: boolean;
    /**
     * Determines the appearance of the tick lines.
     * @see [[majorTickMark]]
     * @see [[minorTickMark]]
     */
    /**
    * Determines the appearance of the tick lines.
    * @see [[majorTickMark]]
    * @see [[minorTickMark]]
    */
    tickLines: ChartTickLines;
    /**
     * Returns or sets the number of categories or series between tick marks. Applies only to category and series axes. Can be a value from 1 through 31999.
     */
    /**
    * Returns or sets the number of categories or series between tick marks. Applies only to category and series axes. Can be a value from 1 through 31999.
    */
    tickMarkSpacing: number;
    /**
     * Returns the type of the axis (read-only)
     */
    readonly type: AxisType;
    /**
     * Returns or sets whether or not the axis is visible.
     */
    /**
    * Returns or sets whether or not the axis is visible.
    */
    visible: boolean;
    /**
     * @hidden
     */
    readonly _ds: string;
    /**
     * @hidden
     */
    readonly _b9: number;
    /**
     * @hidden
     */
    readonly _cb: number;
    /**
     * Sets the values of the [[majorUnit]] and [[minorUnit]] properties.
     * <p class="body">The value of the 'majorUnit' parameter must exceed the value of the 'minorUnit' parameter or an exception is thrown.</p>
     * <p class="body">
     * Typically the value of 'majorUnit' is an exact
     * multiple of 'minorUnit'; for example, for 5 minor
     * units per major unit, set majorUnit to 1 and minorUnit to .2.
     * </p>
     * @param majorUnit The new value for the [[majorUnit]] property.
     * @param minorUnit The new value for the [[minorUnit]] property.
     * @see [[majorUnit]]
     * @see [[minorUnit]]
     */
    setMajorMinorUnit(majorUnit: number, minorUnit: number): void;
    /**
     * @hidden
     */
    _dt(a: Nullable$1<number>, b: Nullable$1<number>): void;
    /**
     * @hidden
     */
    _du(a: Nullable$1<number>, b: Nullable$1<number>): {
        p0: Nullable$1<number>;
        p1: Nullable$1<number>;
    };
    /**
     * @hidden
     */
    _bt(): List$1<Series>;
    /**
     * @hidden
     */
    _a3(): Series;
    /**
     * @hidden
     */
    _dv(a: IChartObject, b: AxisGroup): void;
    /**
     * @hidden
     */
    _y(): ValueFormatter;
    /**
     * @hidden
     */
    private _bi;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _bl;
    /**
     * @hidden
     */
    private _dw;
    /**
     * @hidden
     */
    private _dx;
    /**
     * @hidden
     */
    private _d0;
}
/**
 * @hidden
 */
export declare class AxisCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: AxisCollection, c: Axis);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: AxisCollection;
    readonly a: Axis;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[Axis]] objects for a [[WorksheetChart]]
 */
export declare class AxisCollection extends ChartObject implements IEnumerable$1<Axis> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static _x;
    private _w;
    private _ae;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Indexer
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The corresponding axis or null if not in the collection.
     */
    item(a: AxisType, b?: AxisGroup): Axis;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    readonly isReadOnly: boolean;
    /**
     * Adds a new [[Axis]] into the collection with the specified type and groupo.
     * <para class="note">
     * <b>Note:</b> If there is an axis already in the collection of the type and group specified it will be replaced with the newly added one.
     * </para>
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The newly added [[Axis]]
     */
    add(type: AxisType, group?: AxisGroup): Axis;
    /**
     * @hidden
     */
    private _an;
    /**
     * Clears the collection.
     */
    clear(): void;
    [Symbol.iterator](): EnumeratorWrapper<Axis>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Axis>;
    /**
     * Removes an axis from the collection.
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return True if the axis was removed, otherwise false.
     */
    remove(type: AxisType, group: AxisGroup): boolean;
    /**
     * @hidden
     */
    _ao(a: Axis): void;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * @hidden
     */
    private static _as;
    /**
     * @hidden
     */
    private _at;
    /**
     * @hidden
     */
    _al(): void;
    /**
     * @hidden
     */
    _am(): void;
    /**
     * @hidden
     */
    _ap(a: TickMark, b: TickMark): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Base class for chart area elements
 */
export declare class ChartAreaBase extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ai: number;
    /**
     * @hidden
     */
    static readonly _aj: number;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    static readonly _al: number;
    /**
     * @hidden
     */
    static readonly _an: number;
    /**
     * @hidden
     */
    static readonly _ao: number;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static _w;
    private _aa;
    private _ac;
    private _ae;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the chart element area, as well as whether a border appears.
     */
    /**
    * Determines the appearance of the border drawn around
    * the chart element area, as well as whether a border appears.
    */
    border: ChartBorder;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the chart element area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * <p class="body">
     * To make the area transparent, assign an instance of the
     * [[ChartEmptyFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     * @see [[ChartEmptyFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill properties for the chart element area.
    * <p class="body">
    * This property returns null by default, indicating that no fill is applied.
    * </p>
    * <p class="body">
    * To apply a solid color fill, assign an instance of the
    * [[ChartSolidFill]] class to this property.
    * </p>
    * <p class="body">
    * To apply a gradient fill, assign an instance of the
    * [[ChartGradientFill]] class to this property.
    * </p>
    * <p class="body">
    * To make the area transparent, assign an instance of the
    * [[ChartEmptyFill]] class to this property.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    * @see [[ChartEmptyFill]]
    */
    fill: ChartFillBase;
    /**
     * Detrmines if the chart area is displayed with rounded corners
     */
    /**
    * Detrmines if the chart area is displayed with rounded corners
    */
    roundedCorners: boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the area in which the chart series is plotted.
 */
export declare class PlotArea extends ChartAreaBase {
    static $t: Type;
    private _as;
    private _at;
    private _au;
    private _av;
    private _aq;
    constructor(a: IChartObject);
    /**
     * Returns or sets the height of the area, expressed as a fraction of the
     * height of the containing chart element.
     * @see [[width]]
     * @see [[top]]
     * @see [[height]]
     */
    /**
    * Returns or sets the height of the area, expressed as a fraction of the
    * height of the containing chart element.
    * @see [[width]]
    * @see [[top]]
    * @see [[height]]
    */
    height: number;
    /**
     * Returns or sets a value which represents the left edge of the area,
     * expressed as a fraction of the width of the containing chart element.
     * <p class="body">
     * This property can be set to a value between zero and one, where one
     * represents the total width of the containing element.
     * </p>
     * <p class="body">
     * For example, to situate the area such that it's left edge coincides
     * with the center of the containing element, set this property to .5.
     * </p>
     * @see [[top]]
     * @see [[width]]
     * @see [[height]]
     */
    /**
    * Returns or sets a value which represents the left edge of the area,
    * expressed as a fraction of the width of the containing chart element.
    * <p class="body">
    * This property can be set to a value between zero and one, where one
    * represents the total width of the containing element.
    * </p>
    * <p class="body">
    * For example, to situate the area such that it's left edge coincides
    * with the center of the containing element, set this property to .5.
    * </p>
    * @see [[top]]
    * @see [[width]]
    * @see [[height]]
    */
    left: number;
    /**
     * Returns or sets a value which represents the top edge of the area,
     * expressed as a fraction of the height of the containing chart element.
     * <p class="body">
     * This property can be set to a value between zero and one, where one
     * represents the total height of the containing element.
     * </p>
     * <p class="body">
     * For example, to situate the area such that it's top edge coincides
     * with the center of the containing element, set this property to .5.
     * </p>
     * @see [[left]]
     * @see [[width]]
     * @see [[height]]
     */
    /**
    * Returns or sets a value which represents the top edge of the area,
    * expressed as a fraction of the height of the containing chart element.
    * <p class="body">
    * This property can be set to a value between zero and one, where one
    * represents the total height of the containing element.
    * </p>
    * <p class="body">
    * For example, to situate the area such that it's top edge coincides
    * with the center of the containing element, set this property to .5.
    * </p>
    * @see [[left]]
    * @see [[width]]
    * @see [[height]]
    */
    top: number;
    /**
     * Returns or sets the width of the area, expressed as a fraction of the
     * width of the containing chart element.
     * @see [[height]]
     * @see [[top]]
     * @see [[height]]
     */
    /**
    * Returns or sets the width of the area, expressed as a fraction of the
    * width of the containing chart element.
    * @see [[height]]
    * @see [[top]]
    * @see [[height]]
    */
    width: number;
    /**
     * Returns or sets the position of the plot area on the chart.
     */
    /**
    * Returns or sets the position of the plot area on the chart.
    */
    position: ElementPosition;
    /**
     * @hidden
     */
    readonly _ap: ChartFillBase;
}
/**
 * Represents the area in which the chart is displayed.
 */
export declare class ChartArea extends ChartAreaBase {
    static $t: Type;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    readonly _ap: ChartFillBase;
}
/**
 * Exposes properties which control the appearance of a line in a [[Series]].
 */
export declare class ChartLine extends ChartLineBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    static readonly _ap: number;
    private _an;
    static staticInit(): void;
    constructor();
    /**
     * Returns or sets the style for the line, i.e., solid, dashed, dotted, etc.
     */
    /**
    * Returns or sets the style for the line, i.e., solid, dashed, dotted, etc.
    */
    lineStyle: LineStyle;
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    private static _ak;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _am;
    /**
     * @hidden
     */
    private static _al;
}
/**
 * Base class for the display options for a chart sheet that are used for the display as well as its custom view.
 */
export declare abstract class ChartsheetDisplayOptionsBase extends DisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _t;
    private _y;
    private _w;
    constructor(a: Chartsheet);
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * Resets the display options to their default settings.
     */
    protected resetCore(): void;
    /**
     * Gets or sets the magnification level of the chartsheet.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the chartsheet in the current View.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a chartsheet. The level must be between 10 and 400.
     */
    /**
    * Gets or sets the magnification level of the chartsheet.
    * <p class="body">
    * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
    * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
    * </p>
    * The magnification level of the chartsheet in the current View.
    * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a chartsheet. The level must be between 10 and 400.
    */
    magnification: number;
    /**
     * Gets or sets whether the chart should be resized to match the size of the chart sheet window.
     */
    /**
    * Gets or sets whether the chart should be resized to match the size of the chart sheet window.
    */
    sizeWithWindow: boolean;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _u;
}
/**
 * Class which exposes the display options which can only be controlled through the chartsheet.
 * @see [[Chartsheet.displayOptions]]
 * @see [[CustomViewChartDisplayOptions]]
 */
export declare class ChartsheetDisplayOptions extends ChartsheetDisplayOptionsBase {
    static $t: Type;
    constructor(a: Chartsheet);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    readonly _j: boolean;
}
/**
 * Class which exposes the chartsheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getSheetDisplayOptions]]
 * @see [[ChartsheetDisplayOptions]]
 */
export declare class CustomViewChartDisplayOptions extends ChartsheetDisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _ad: CustomView;
    constructor(a: Chartsheet, b: CustomView);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    readonly _j: boolean;
}
/**
 * Class which exposes the various print options available for a chartsheet which can be saved with both a
 * chartsheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a chartsheet is printed.
 * </p>
 * @see [[Chartsheet.printOptions]]
 * @see [[CustomView.getSheetPrintOptions]]
 */
export declare class ChartsheetPrintOptions extends PrintOptionsBase {
    static $t: Type;
    constructor(a: Chartsheet, b: boolean);
}
/**
 * Provides information about the types of changes that are disabled when the associated Chartsheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Worksheet.protection]]
 * @see@see */
export declare class ChartsheetProtection extends SheetProtection {
    static $t: Type;
    private _e;
    constructor(a: Chartsheet);
    /**
     * Returns a boolean indicating if objects such as shapes and controls may be created or changed when the chartsheet is protected.
     */
    /**
    * Returns a boolean indicating if objects such as shapes and controls may be created or changed when the chartsheet is protected.
    */
    allowEditObjects: boolean;
    /**
     * Returns a boolean indicating if the chart is protected when the chartsheet is protected.
     */
    /**
    * Returns a boolean indicating if the chart is protected when the chartsheet is protected.
    */
    allowEditContents: boolean;
    /**
     * @hidden
     */
    readonly _f: ChartsheetProtectionType;
    /**
     * @hidden
     */
    _j(a: any, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
}
/**
 * Base class for chart elements which behave as a label.
 */
export declare class ChartLabelBase extends ChartTextAreaBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cb;
    /**
     * @hidden
     */
    static readonly _b9: number;
    private _cc;
    private _b7;
    constructor(a: IChartObject);
    /**
     * Returns or sets the format to use for numbers.
     * @see [[numberFormatLinked]]
     */
    /**
    * Returns or sets the format to use for numbers.
    * @see [[numberFormatLinked]]
    */
    numberFormat: string;
    /**
     * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
     * @see [[numberFormat]]
     */
    /**
    * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
    * @see [[numberFormat]]
    */
    numberFormatLinked: boolean;
    /**
     * @hidden
     */
    private static _b4;
    static staticInit(): void;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b5;
}
/**
 * Represents the label of a specific [[DataPoint]].
 */
export declare class DataLabel extends ChartLabelBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _c0;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c3;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    static readonly _c2: number;
    /**
     * @hidden
     */
    private static _ce;
    private _cv;
    private _cm;
    private _ci;
    private _dr;
    private _dc;
    private _dd;
    private _de;
    private _df;
    private _dg;
    private _dh;
    private _di;
    private _cw;
    static staticInit(): void;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Not supported.
     */
    protected get_formula(): Formula;
    /**
     * Returns or sets a value that represents the height of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected get_height(): number;
    /**
     * Returns or sets a value that represents the height of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected set_height(a: number): void;
    /**
     * Returns or sets a value that represents the height of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    /**
    * Returns or sets a value that represents the height of the
    * label, expressed as a ratio, relative to the size of the
    * chart area.
    */
    height: number;
    /**
     * Returns or sets a boolean value indicating whether this label
     * has been deleted.
     */
    protected get_isDeleted(): boolean;
    /**
     * Returns or sets a boolean value indicating whether this label
     * has been deleted.
     */
    protected set_isDeleted(a: boolean): void;
    /**
     * Returns or sets a boolean value indicating whether this label
     * has been deleted.
     */
    /**
    * Returns or sets a boolean value indicating whether this label
    * has been deleted.
    */
    isDeleted: boolean;
    /**
     * Returns or sets a value which determines the label's position
     * as relative to the series bar/line.
     * <p class="body">
     * When this property is set to <i>Custom</i>, the position is determined
     * by the values of the <see cref="ChartTextAreaBase.Left">Left</see> and
     * <see cref="ChartTextAreaBase.Top">Top</see> properties.
     * </p>
     * <p class="body">
     * When a custom label position is assigned, connecting lines appear between
     * the label and its respective [[DataPoint]]. These lines are referred
     * to as 'leader lines'; use the [[Series.leaderLines]] property to control
     * their appearance.
     * </p>
     * <p class="body">
     * Note that leader lines can be hidden by setting the [[SeriesDataLabels.showLeaderLines]]
     * property to <i>false</i>.
     * </p>
     * @see [[ChartTextAreaBase.left]]
     * @see [[ChartTextAreaBase.top]]
     * @see [[Series.leaderLines]]
     * @see [[SeriesDataLabels.showLeaderLines]]
     */
    /**
    * Returns or sets a value which determines the label's position
    * as relative to the series bar/line.
    * <p class="body">
    * When this property is set to <i>Custom</i>, the position is determined
    * by the values of the <see cref="ChartTextAreaBase.Left">Left</see> and
    * <see cref="ChartTextAreaBase.Top">Top</see> properties.
    * </p>
    * <p class="body">
    * When a custom label position is assigned, connecting lines appear between
    * the label and its respective [[DataPoint]]. These lines are referred
    * to as 'leader lines'; use the [[Series.leaderLines]] property to control
    * their appearance.
    * </p>
    * <p class="body">
    * Note that leader lines can be hidden by setting the [[SeriesDataLabels.showLeaderLines]]
    * property to <i>false</i>.
    * </p>
    * @see [[ChartTextAreaBase.left]]
    * @see [[ChartTextAreaBase.top]]
    * @see [[Series.leaderLines]]
    * @see [[SeriesDataLabels.showLeaderLines]]
    */
    labelPosition: DataLabelPosition;
    /**
     * This property is not supported. Use the [[labelPosition]] property instead.
     */
    protected get_position(): ElementPosition;
    /**
     * This property is not supported. Use the [[labelPosition]] property instead.
     */
    protected set_position(a: ElementPosition): void;
    /**
     * Returns or sets the separator used between multiple values in the label.
     */
    /**
    * Returns or sets the separator used between multiple values in the label.
    */
    separator: string;
    /**
     * Returns or sets if the bubble size is shown.
     * Applies only to [[Series]] which are displayed
     * within a bubble chart.
     */
    /**
    * Returns or sets if the bubble size is shown.
    * Applies only to [[Series]] which are displayed
    * within a bubble chart.
    */
    showBubbleSize: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showBubbleSize$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    protected get__co(): boolean;
    /**
     * @hidden
     */
    readonly _co: boolean;
    /**
     * Returns or sets a value indicating whether the category name is shown.
     * <p class="body">
     * The category name is not shown by default; to show the category name in the label, set this property to <i>true</i>.
     * </p>
     */
    /**
    * Returns or sets a value indicating whether the category name is shown.
    * <p class="body">
    * The category name is not shown by default; to show the category name in the label, set this property to <i>true</i>.
    * </p>
    */
    showCategoryName: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showCategoryName$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _cp: boolean;
    /**
     * Returns or sets if the [[Legend]] key is shown.
     * <p class="body">
     * The legend key is not shown by default; to show the legend key in the label, set this property to <i>true</i>.
     * </p>
     */
    /**
    * Returns or sets if the [[Legend]] key is shown.
    * <p class="body">
    * The legend key is not shown by default; to show the legend key in the label, set this property to <i>true</i>.
    * </p>
    */
    showLegendKey: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showLegendKey$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _cq: boolean;
    /**
     * Returns or sets a value indicating whether the percentage of the range is shown.
     * <p class="body">
     * The percentage is not shown by default; to show the percentage in the label, set this property to <i>true</i>.
     * </p>
     */
    /**
    * Returns or sets a value indicating whether the percentage of the range is shown.
    * <p class="body">
    * The percentage is not shown by default; to show the percentage in the label, set this property to <i>true</i>.
    * </p>
    */
    showPercentage: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showPercentage$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _cr: boolean;
    /**
     * Returns or sets a value indicating whether the series
     * <see cref="Series.Name">name</see> is shown in the label.
     * <p class="body">
     * The series name  is not shown by default; to show the series name in the label, set this property to <i>true</i>.
     * </p>
     */
    /**
    * Returns or sets a value indicating whether the series
    * <see cref="Series.Name">name</see> is shown in the label.
    * <p class="body">
    * The series name  is not shown by default; to show the series name in the label, set this property to <i>true</i>.
    * </p>
    */
    showSeriesName: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showSeriesName$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _ct: boolean;
    /**
     * Returns or sets a boolean value indicating whether the data label range is shown.
     * <p class="body">
     * The data label range is defined by the [[SeriesDataLabels.dataLabelsRange]]
     * </p>
     * <p class="body">
     * The data label range is not shown by default; to show the range in the label, set this property to <i>true</i>.
     * </p>
     * @see [[SeriesDataLabels.dataLabelsRange]]
     */
    /**
    * Returns or sets a boolean value indicating whether the data label range is shown.
    * <p class="body">
    * The data label range is defined by the [[SeriesDataLabels.dataLabelsRange]]
    * </p>
    * <p class="body">
    * The data label range is not shown by default; to show the range in the label, set this property to <i>true</i>.
    * </p>
    * @see [[SeriesDataLabels.dataLabelsRange]]
    */
    showRange: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showRange$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _cs: boolean;
    /**
     * Returns or sets a value indicating whether the value is shown.
     * <p class="body">
     * The value is shown by default; to prevent the value from displaying in the label, set this property to <i>false</i>.
     * </p>
     */
    /**
    * Returns or sets a value indicating whether the value is shown.
    * <p class="body">
    * The value is shown by default; to prevent the value from displaying in the label, set this property to <i>false</i>.
    * </p>
    */
    showValue: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _showValue$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _cu: boolean;
    /**
     * Returns or sets a value that represents the width of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected get_width(): number;
    /**
     * Returns or sets a value that represents the width of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected set_width(a: number): void;
    /**
     * Returns or sets a value that represents the width of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    /**
    * Returns or sets a value that represents the width of the
    * label, expressed as a ratio, relative to the size of the
    * chart area.
    */
    width: number;
    /**
     * @hidden
     */
    protected get__ad(): ChartFillBase;
    /**
     * @hidden
     */
    readonly _ch: ChartBorder;
    /**
     * @hidden
     */
    readonly _cl: IWorkbookFont;
    /**
     * @hidden
     */
    protected get__ck(): SeriesDataLabels;
    /**
     * @hidden
     */
    readonly _ck: SeriesDataLabels;
    /**
     * Not supported.
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _dt(a?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private static _cg;
    /**
     * @hidden
     */
    private static _cf;
}
/**
 * Defines the properties for all <see cref="DataLabel">data labels</see>
 * displayed for this [[Series]].
 * <p class="body">
 * This property provides a way to set properties on multiple <see cref="DataLabel">data labels</see>.
 * </p>
 * <p class="body">
 * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
 * </p>
 * <p class="body">
 * The property values of the [[DataPoint.dataLabel]] class take precedence
 * over the properties of this class.
 * </p>
 * @see [[DataLabel]]
 * @see [[DataPoint.dataLabel]]
 * @see [[Series.dataPointCollection]]
 */
export declare class SeriesDataLabels extends DataLabel {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _d6;
    /**
     * @hidden
     */
    private static readonly _d8;
    /**
     * @hidden
     */
    private static readonly _d9;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    private static readonly _d5;
    private _d0;
    private _dx;
    private _d3;
    static staticInit(): void;
    constructor(a: Series);
    /**
     * Not supported.
     */
    protected get_left(): number;
    /**
     * Not supported.
     */
    protected set_left(a: number): void;
    /**
     * Not supported.
     */
    protected get_top(): number;
    /**
     * Not supported.
     */
    protected set_top(a: number): void;
    /**
     * Not supported.
     */
    protected get_text(): FormattedString;
    /**
     * Not supported.
     */
    protected set_text(a: FormattedString): void;
    /**
     * Not supported.
     */
    protected get_isDeleted(): boolean;
    /**
     * Not supported.
     */
    protected set_isDeleted(a: boolean): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * Not supported.
     */
    protected get_height(): number;
    /**
     * Not supported.
     */
    protected set_height(a: number): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Not supported.
     */
    protected get_width(): number;
    /**
     * Not supported.
     */
    protected set_width(a: number): void;
    /**
     * Returns a [[Formula]] which defines the cell range
     * from which part or all of the label text is obtained.
     * <p class="body">
     * Use the [[setDataLabelsRange]]
     * method to assign a new value.
     * </p>
     * <p class="body">
     * The cell values obtained from this property are only displayed when the
     * [[DataLabel.showRange]] property is set to true.
     * </p>
     * <p class="body">
     * The specified range must contain only one column or one row, or an exception is thrown.
     * </p>
     * @see [[setDataLabelsRange]]
     * @see [[DataLabel.showRange]]
     */
    readonly dataLabelsRange: Formula;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _d1: SingleTargetFormula;
    /**
     * @hidden
     */
    readonly _ea: string;
    /**
     * Returns or sets a value which determines the label positioning
     * for a <i>Treemap</i> chart.
     * <p class="body">
     * This property is only applicable for <i>Treemap</i> charts.
     * </p>
     */
    /**
    * Returns or sets a value which determines the label positioning
    * for a <i>Treemap</i> chart.
    * <p class="body">
    * This property is only applicable for <i>Treemap</i> charts.
    * </p>
    */
    parentLabelLayout: ParentLabelLayout;
    /**
     * Returns or sets a boolean value indicating whether <see cref="Series.LeaderLines">leader lines</see>
     * are displayed for the data labels associated with this instance.
     * <p class="body">
     * Leader lines connect <see cref="DataLabel">data labels</see> to their respective
     * <see cref="DataPoint">data points</see>.
     * </p>
     * <p class="body">
     * The [[LeaderLines]] property provides a way to customize the appearance
     * of the connecting lines. These lines are only drawn, however, for data labels whose
     * [[DataLabel.labelPosition]] property is set to <i>Custom</i>.
     * </p>
     * <p class="body">
     * Use this property to allow leader lines to be shown using the default appearance, i.e.,
     * setting this property to true without specifying a custom appearance causes them to
     * acquire the default appearance as determined by Excel.
     * </p>
     * <p class="body">
     * Leader lines can be hidden by setting this property to <i>false</i>.
     * </p>
     * @see [[Series.leaderLines]]
     * @see [[DataLabel]]
     * @see [[DataLabel.labelPosition]]
     * @see [[ChartTextAreaBase.left]]
     * @see [[ChartTextAreaBase.top]]
     * @see [[DataPoint]]
     */
    /**
    * Returns or sets a boolean value indicating whether <see cref="Series.LeaderLines">leader lines</see>
    * are displayed for the data labels associated with this instance.
    * <p class="body">
    * Leader lines connect <see cref="DataLabel">data labels</see> to their respective
    * <see cref="DataPoint">data points</see>.
    * </p>
    * <p class="body">
    * The [[LeaderLines]] property provides a way to customize the appearance
    * of the connecting lines. These lines are only drawn, however, for data labels whose
    * [[DataLabel.labelPosition]] property is set to <i>Custom</i>.
    * </p>
    * <p class="body">
    * Use this property to allow leader lines to be shown using the default appearance, i.e.,
    * setting this property to true without specifying a custom appearance causes them to
    * acquire the default appearance as determined by Excel.
    * </p>
    * <p class="body">
    * Leader lines can be hidden by setting this property to <i>false</i>.
    * </p>
    * @see [[Series.leaderLines]]
    * @see [[DataLabel]]
    * @see [[DataLabel.labelPosition]]
    * @see [[ChartTextAreaBase.left]]
    * @see [[ChartTextAreaBase.top]]
    * @see [[DataPoint]]
    */
    showLeaderLines: boolean;
    /**
     * @hidden
     */
    protected get__ck(): SeriesDataLabels;
    /**
     * Assigns a [[Formula]] to the [[dataLabelsRange]]
     * @param formula The string representation of the formula used to obtain the data label text.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     */
    setDataLabelsRange(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setDataLabelsRange1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _eb(a: Sheet, b: SingleTargetFormula): void;
    /**
     * @hidden
     */
    private static _d2;
    /**
     * @hidden
     */
    private static _du;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * @hidden
     */
    private static _dv;
}
/**
 * Represents the a specific data point in a [[series]].
 * <p class="body">
 * This class encapsulates an individual point of data in a [[series]].
 * </p>
 * <p class="body">
 * A data point manifests differently depending on the chart type; for example,
 * on a bar chart it represents the bar itself, and for a line chart, it represents
 * a point on the line. For pie and doughnut charts, a data point represents a slice
 * or wedge in the pie/doughnut.
 * </p>
 * <p class="body">
 * Many of the properties exposed by this class are also found on the
 * [[series]] class; setting the property on the series affects
 * all points on the series, whereas setting a property on this class affects
 * only one individual point in the series.
 * </p>
 * <p class="body">
 * In cases where <i>most</i> of the data points share the same property values, use
 * the property of the Series class, overriding the property values for any individual
 * points using this class.
 * </p>
 * @see [[series]]
 * @see [[Series.explosion]]
 * @see [[Series.markerStyle]]
 */
export declare class DataPoint extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _a1;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static _w;
    private _bd;
    private _be;
    private _bf;
    private _z;
    private _am;
    private _bg;
    private _af;
    private _bh;
    private _aa;
    private _ag;
    private _bi;
    private _bj;
    private _aq;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns or sets a value indicating whether a picture is applied to the end
     * of the point or all points in the series.
     */
    /**
    * Returns or sets a value indicating whether a picture is applied to the end
    * of the point or all points in the series.
    */
    applyPicToEnd: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _applyPicToEnd$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _ar: boolean;
    /**
     * Returns or sets a value indicating whether a picture is applied to the front
     * of the point or all points in the series.
     */
    /**
    * Returns or sets a value indicating whether a picture is applied to the front
    * of the point or all points in the series.
    */
    applyPicToFront: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _applyPicToFront$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _as: boolean;
    /**
     * Returns or sets a value indicating whether a picture is applied to the sides
     * of the point or all points in the series.
     */
    /**
    * Returns or sets a value indicating whether a picture is applied to the sides
    * of the point or all points in the series.
    */
    applyPicToSides: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _applyPicToSides$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _at: boolean;
    /**
     * Determines the appearance of the border drawn around the
     * data point's [[fill]] area.
     * <p class="body">
     * For series which support <see cref="Fill">fills</see>, this property controls the
     * color and size of the line drawn around the data point's fill region.
     * </p>
     * @see [[fill]]
     */
    /**
    * Determines the appearance of the border drawn around the
    * data point's [[fill]] area.
    * <p class="body">
    * For series which support <see cref="Fill">fills</see>, this property controls the
    * color and size of the line drawn around the data point's fill region.
    * </p>
    * @see [[fill]]
    */
    border: ChartBorder;
    /**
     * @hidden
     */
    readonly _ac: ChartBorder;
    /**
     * Returns or sets a [[dataLabel]] instance which defines
     * the properties of the label displayed for this data point.
     * <p class="body">
     * In order to display data labels, the [[Series.showDataLabels]]
     * property must be set to true.
     * </p>
     * <p class="body">
     * Use the [[Series.dataLabels]] property to apply property
     * settings to all data labels in the series.
     * </p>
     * <p class="body">
     * Use the [[DataLabel.isDeleted]] property to hide the label
     * for a specific data point.
     * </p>
     * @see [[Series.showDataLabels]]
     * @see [[Series.dataLabels]]
     */
    /**
    * Returns or sets a [[dataLabel]] instance which defines
    * the properties of the label displayed for this data point.
    * <p class="body">
    * In order to display data labels, the [[Series.showDataLabels]]
    * property must be set to true.
    * </p>
    * <p class="body">
    * Use the [[Series.dataLabels]] property to apply property
    * settings to all data labels in the series.
    * </p>
    * <p class="body">
    * Use the [[DataLabel.isDeleted]] property to hide the label
    * for a specific data point.
    * </p>
    * @see [[Series.showDataLabels]]
    * @see [[Series.dataLabels]]
    */
    dataLabel: DataLabel;
    /**
     * Returns or sets the explosion value for a pie-chart or doughnut-chart slice.
     * <p class="body">
     * In the context of a pie or doughnut chart, a [[DataPoint]]
     * is synonymous with an individual slice of the pie/doughnut.
     * </p>
     * <p class="body">
     * <i>Explosion</i> refers to the amount by which a slice in the pie is
     * offset from the center point of the circle.
     * </p>
     * <p class="body">
     * The valid range of values is between 0 and 400, inclusive.
     * </p>
     * <p class="body">
     * Use the [[Series.explosion]] property to set the explosion
     * for all slices in the pie.
     * </p>
     * @see [[Series.explosion]]
     * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
     */
    /**
    * Returns or sets the explosion value for a pie-chart or doughnut-chart slice.
    * <p class="body">
    * In the context of a pie or doughnut chart, a [[DataPoint]]
    * is synonymous with an individual slice of the pie/doughnut.
    * </p>
    * <p class="body">
    * <i>Explosion</i> refers to the amount by which a slice in the pie is
    * offset from the center point of the circle.
    * </p>
    * <p class="body">
    * The valid range of values is between 0 and 400, inclusive.
    * </p>
    * <p class="body">
    * Use the [[Series.explosion]] property to set the explosion
    * for all slices in the pie.
    * </p>
    * @see [[Series.explosion]]
    * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
    */
    explosion: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _explosion$i: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _a3: number;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the data point.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * In this case, the default fill color for the associated [[series]]
     * is used.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill properties for the data point.
    * <p class="body">
    * This property returns null by default, indicating that no fill is applied.
    * In this case, the default fill color for the associated [[series]]
    * is used.
    * </p>
    * <p class="body">
    * To apply a solid color fill, assign an instance of the
    * [[ChartSolidFill]] class to this property.
    * </p>
    * <p class="body">
    * To apply a gradient fill, assign an instance of the
    * [[ChartGradientFill]] class to this property.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _ai: ChartFillBase;
    /**
     * Returns or sets a value indicating whether the pattern is inverted
     * in the item when it corresponds to a negative number.
     */
    /**
    * Returns or sets a value indicating whether the pattern is inverted
    * in the item when it corresponds to a negative number.
    */
    invertIfNegative: boolean | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _invertIfNegative$i: Nullable$1<boolean>;
    /**
     * @hidden
     */
    readonly _au: boolean;
    /**
     * Determines the appearance of the <see cref="ChartBorder">border</see>
     * (a.k.a. outline) of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker border for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker border is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerBorder]] property to customize the border
     * for all markers in the series.
     * </p>
     * @see [[Series.markerBorder]]
     */
    /**
    * Determines the appearance of the <see cref="ChartBorder">border</see>
    * (a.k.a. outline) of the marker for this data point.
    * <p class="body">
    * This property provides a way to customize the marker border for
    * an individual data point in the series.
    * </p>
    * <p class="body">
    * A value of null implies that the marker border is not explicitly
    * set on this data point, and should inherit the value from it's
    * associated [[series]].
    * </p>
    * <p class="body">
    * Use the [[Series.markerBorder]] property to customize the border
    * for all markers in the series.
    * </p>
    * @see [[Series.markerBorder]]
    */
    markerBorder: ChartBorder;
    /**
     * @hidden
     */
    readonly _ae: ChartBorder;
    /**
     * Defines the <see cref="ChartFillBase">fill</see> appearance of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker fill color for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker fill color is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerFill]] property to customize the fill color
     * for all markers in the series.
     * </p>
     * @see [[Series.markerFill]]
     */
    /**
    * Defines the <see cref="ChartFillBase">fill</see> appearance of the marker for this data point.
    * <p class="body">
    * This property provides a way to customize the marker fill color for
    * an individual data point in the series.
    * </p>
    * <p class="body">
    * A value of null implies that the marker fill color is not explicitly
    * set on this data point, and should inherit the value from it's
    * associated [[series]].
    * </p>
    * <p class="body">
    * Use the [[Series.markerFill]] property to customize the fill color
    * for all markers in the series.
    * </p>
    * @see [[Series.markerFill]]
    */
    markerFill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _al: ChartFillBase;
    /**
     * Determines the size of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker size for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker size is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerSize]] property to customize the size
     * of all markers in the series.
     * </p>
     * @see [[Series.markerSize]]
     */
    /**
    * Determines the size of the marker for this data point.
    * <p class="body">
    * This property provides a way to customize the marker size for
    * an individual data point in the series.
    * </p>
    * <p class="body">
    * A value of null implies that the marker size is not explicitly
    * set on this data point, and should inherit the value from it's
    * associated [[series]].
    * </p>
    * <p class="body">
    * Use the [[Series.markerSize]] property to customize the size
    * of all markers in the series.
    * </p>
    * @see [[Series.markerSize]]
    */
    markerSize: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _markerSize$i: Nullable$1<number>;
    /**
     * @hidden
     */
    readonly _a9: number;
    /**
     * Determines the style of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker style for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker style is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerStyle]] property to customize the style
     * of all markers in the series.
     * </p>
     * @see [[Series.markerStyle]]
     */
    /**
    * Determines the style of the marker for this data point.
    * <p class="body">
    * This property provides a way to customize the marker style for
    * an individual data point in the series.
    * </p>
    * <p class="body">
    * A value of null implies that the marker style is not explicitly
    * set on this data point, and should inherit the value from it's
    * associated [[series]].
    * </p>
    * <p class="body">
    * Use the [[Series.markerStyle]] property to customize the style
    * of all markers in the series.
    * </p>
    * @see [[Series.markerStyle]]
    */
    markerStyle: MarkerStyle | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _markerStyle$i: Nullable$1<MarkerStyle>;
    /**
     * @hidden
     */
    readonly _ao: MarkerStyle;
    /**
     * Returns or sets a boolean value indicating whether this data point represents
     * a total or subtotal in a waterfall chart.
     * <p class="body">
     * This property is only applicable for waterfall charts.
     * </p>
     * @see [[Series.showWaterfallConnectorLines]]
     */
    /**
    * Returns or sets a boolean value indicating whether this data point represents
    * a total or subtotal in a waterfall chart.
    * <p class="body">
    * This property is only applicable for waterfall charts.
    * </p>
    * @see [[Series.showWaterfallConnectorLines]]
    */
    setAsTotal: boolean;
    /**
     * @hidden
     */
    readonly _ap: Series;
    /**
     * @hidden
     */
    _aw(a: boolean): boolean;
    /**
     * @hidden
     */
    _aj(a: number): ChartFillBase;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * A collection of [[DataPoint]]s for a [[series]]
 */
export declare class DataPointCollection extends ChartObject implements IEnumerable$1<DataPoint> {
    static $t: Type;
    private _af;
    private _ad;
    private _z;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * @hidden
     */
    readonly _y: Series;
    /**
     * Returns the [[DataPoint]] instance at the specified
     * ordinal position within this collection.
     * @param index A zero based index
     * @return A [[DataPoint]] instance.
     */
    item(a: number): DataPoint;
    /**
     * @hidden
     */
    private _ai;
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: DataPoint): boolean;
    [Symbol.iterator](): EnumeratorWrapper<DataPoint>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<DataPoint>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: DataPoint): number;
    /**
     * @hidden
     */
    _al(a: number, b: List$1<Tuple$3<boolean, number, number>>, c: (arg1: IChartObject, arg2: any) => void): void;
    /**
     * @hidden
     */
    _an(): void;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    _w(): DataPoint[];
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    _aj(): void;
    /**
     * @hidden
     */
    _ab(a: Series, b: boolean): boolean;
    /**
     * @hidden
     */
    private _ae;
    /**
     * @hidden
     */
    _ak(a: Dictionary$2<number, DataPoint>): void;
    /**
     * @hidden
     */
    _am(): void;
}
/**
 * @hidden
 */
export declare class DataPointCollection_UndoContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: boolean, c: number, d: DataPoint[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: boolean;
    readonly c: number;
    readonly a: DataPoint[];
}
/**
 * Exposes properties which control the appearance and behavior
 * of a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * This class is only used by <i>RegionMap</i> charts.
 * </p>
 */
export declare class GeographicMapSettings extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _g: string;
    /**
     * @hidden
     */
    static readonly _j: string;
    /**
     * @hidden
     */
    static readonly _k: string;
    /**
     * @hidden
     */
    static readonly _l: string;
    constructor(cultureLanguage: string, cultureRegion: string, attribution: string, projection: Nullable$1<GeographicMapProjection>, area: Nullable$1<GeographicMappingArea>, labels: GeographicMapLabels, colors: GeographicMapColors);
    /**
     * @hidden
     */
    static _c(): GeographicMapSettings;
    /**
     * @hidden
     */
    readonly _m: string;
    private _cultureLanguage;
    /**
     * Returns the culture language for this instance.
     */
    /**
    * Returns the culture language for this instance.
    */
    cultureLanguage: string;
    private _cultureRegion;
    /**
     * Returns the culture region for this instance.
     */
    /**
    * Returns the culture region for this instance.
    */
    cultureRegion: string;
    private _attribution;
    /**
     * Returns the attribution for this instance.
     */
    /**
    * Returns the attribution for this instance.
    */
    attribution: string;
    /**
     * Returns the map projection for this instance.
     */
    /**
    * Returns the map projection for this instance.
    */
    projection: GeographicMapProjection | null;
    private _projection$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _projection$i: Nullable$1<GeographicMapProjection>;
    /**
     * Returns the mapping area for this instance.
     */
    /**
    * Returns the mapping area for this instance.
    */
    area: GeographicMappingArea | null;
    private _area$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _area$i: Nullable$1<GeographicMappingArea>;
    private _labels;
    /**
     * Returns a value indicating the manner in which map area labels are displayed.
     */
    /**
    * Returns a value indicating the manner in which map area labels are displayed.
    */
    labels: GeographicMapLabels;
    private _colors;
    /**
     * Returns a [[GeographicMapColors]] instance which defines the minimum,
     * midpoint, and maximum colors used for the applicable areas of a geographic map
     * chart.
     * @see [[GeographicMapColors]]
     */
    /**
    * Returns a [[GeographicMapColors]] instance which defines the minimum,
    * midpoint, and maximum colors used for the applicable areas of a geographic map
    * chart.
    * @see [[GeographicMapColors]]
    */
    colors: GeographicMapColors;
}
/**
 * Exposes properties related to series coloring for a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * Assign an instance of this class to the <see cref="GeographicMapSettings.Colors">Colors</see>
 * property of the [[GeographicMapSettings]] class to provide custom colors for map areas.
 * </p>
 */
export declare class GeographicMapColors extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _c: number[];
    /**
     * @hidden
     */
    readonly _b: number[];
    /**
     * @hidden
     */
    readonly _a: number[];
    constructor(seriesColor: GeographicMapSeriesColor, minimum: WorkbookColorInfo, midpoint: WorkbookColorInfo, maximum: WorkbookColorInfo);
    private _minimum;
    /**
     * Returns the color used for the minimum value.
     */
    /**
    * Returns the color used for the minimum value.
    */
    minimum: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _j: WorkbookColorInfo;
    private _midpoint;
    /**
     * Returns the color used for the midpoint value.
     */
    /**
    * Returns the color used for the midpoint value.
    */
    midpoint: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _h: WorkbookColorInfo;
    private _maximum;
    /**
     * Returns the color used for the maximum value.
     */
    /**
    * Returns the color used for the maximum value.
    */
    maximum: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _f: WorkbookColorInfo;
    private _seriesColor;
    /**
     * Returns a value indicating whether a sequential (two-color)
     * or divergent (three-color) scheme is used to color regions in
     * a geographic map chart.
     */
    /**
    * Returns a value indicating whether a sequential (two-color)
    * or divergent (three-color) scheme is used to color regions in
    * a geographic map chart.
    */
    seriesColor: GeographicMapSeriesColor;
}
/**
 * Represents leader lines on a chart. Leader lines connect data labels to data points.
 * <para class="note">
 * <b>Note:</b> this object is not a collection and there is no object that represents a single leader line.
 * </para>
 */
export declare class LeaderLines extends ChartLineBase {
    static $t: Type;
    private _ak;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    readonly _al: ChartFillBase;
}
/**
 * Represents a [[Trendline]] label.
 */
export declare class TrendlineLabel extends ChartLabelBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _cm;
    /**
     * @hidden
     */
    static readonly _cn: number;
    private _ch;
    private _ci;
    constructor();
    /**
     * Returns or sets a boolean value indicating whether the
     * default trendline equation is displayed within the label.
     * @see [[Trendline.label]]
     */
    /**
    * Returns or sets a boolean value indicating whether the
    * default trendline equation is displayed within the label.
    * @see [[Trendline.label]]
    */
    displayEquation: boolean;
    /**
     * Returns or sets a boolean value indicating whether the
     * default R-squared function is displayed within the label.
     * @see [[Trendline.label]]
     */
    /**
    * Returns or sets a boolean value indicating whether the
    * default R-squared function is displayed within the label.
    * @see [[Trendline.label]]
    */
    displayRSquared: boolean;
    /**
     * @hidden
     */
    private static _ce;
    static staticInit(): void;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _cg;
    /**
     * @hidden
     */
    private static _cf;
}
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export declare class TrendlineLine extends ChartLine {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    _as(a: number): ChartFillBase;
}
/**
 * Represents a [[Series]] trendline.
 * @see [[Series.trendlineCollection]]
 */
export declare class Trendline extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _at;
    /**
     * @hidden
     */
    private static readonly _au;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    static readonly _aq: number;
    private _aj;
    private _ak;
    private _a1;
    private _ab;
    private _z;
    private _ad;
    private _a3;
    private _af;
    private _ao;
    private _ah;
    /**
     * @hidden
     */
    static readonly _am: number;
    constructor(a: TrendlineCollection);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Specifies the number of periods or units by which the
     * trendline extends backward.
     */
    /**
    * Specifies the number of periods or units by which the
    * trendline extends backward.
    */
    backward: number;
    /**
     * Specifies the number of periods or units by which the
     * trendline extends forward.
     */
    /**
    * Specifies the number of periods or units by which the
    * trendline extends forward.
    */
    forward: number;
    /**
     * Specifies the value axis intercept for the trendline.
     * <p class="body">
     * If this property is left unset, or assigned a value of null,
     * the intercept is automatically determined by Excel.
     * </p>
     */
    /**
    * Specifies the value axis intercept for the trendline.
    * <p class="body">
    * If this property is left unset, or assigned a value of null,
    * the intercept is automatically determined by Excel.
    * </p>
    */
    intercept: number | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _intercept$i: Nullable$1<number>;
    /**
     * Returns or sets a [[TrendlineLabel]] instance
     * which determines the text and appearance of the trendline label.
     * <p class="body">
     * This property is null by default, which prevents a label from appearing.
     * </p>
     * <p class="body">
     * To display a label for the trendline, assign a [[TrendlineLabel]]
     * instance to this property.
     * </p>
     * @see [[TrendlineLabel]]
     */
    /**
    * Returns or sets a [[TrendlineLabel]] instance
    * which determines the text and appearance of the trendline label.
    * <p class="body">
    * This property is null by default, which prevents a label from appearing.
    * </p>
    * <p class="body">
    * To display a label for the trendline, assign a [[TrendlineLabel]]
    * instance to this property.
    * </p>
    * @see [[TrendlineLabel]]
    */
    label: TrendlineLabel;
    /**
     * Returns a [[legendEntry]] instance which determines the
     * appearance of this trendline's appearance in the [[WorksheetChart.legend]].
     * @see [[WorksheetChart.legend]]
     */
    /**
    * Returns a [[legendEntry]] instance which determines the
    * appearance of this trendline's appearance in the [[WorksheetChart.legend]].
    * @see [[WorksheetChart.legend]]
    */
    legendEntry: LegendEntry;
    /**
     * Returns or sets a [[TrendlineLine]] instance which controls
     * the color and width of the trendline.
     * <p class="body">
     * To prevent the trendline from appearing in the chart, set this property to null.
     * </p>
     */
    /**
    * Returns or sets a [[TrendlineLine]] instance which controls
    * the color and width of the trendline.
    * <p class="body">
    * To prevent the trendline from appearing in the chart, set this property to null.
    * </p>
    */
    line: TrendlineLine;
    /**
     * Specifies the name of the trendline.
     */
    /**
    * Specifies the name of the trendline.
    */
    name: string;
    /**
     * Specifies the order/degree of the polynomial function
     * which defines the trendline. Applicable only when the
     * [[trendlineType]] property is set to <i>Polynomial</i>.
     * <p class="body">
     * This property is only applicable when the [[trendlineType]]
     * property is set to <i>Polynomial</i>.
     * </p>
     * <p class="body">
     * Trendlines support second-degree through sixth-degree polynomials.
     * </p>
     */
    /**
    * Specifies the order/degree of the polynomial function
    * which defines the trendline. Applicable only when the
    * [[trendlineType]] property is set to <i>Polynomial</i>.
    * <p class="body">
    * This property is only applicable when the [[trendlineType]]
    * property is set to <i>Polynomial</i>.
    * </p>
    * <p class="body">
    * Trendlines support second-degree through sixth-degree polynomials.
    * </p>
    */
    order: TrendlinePolynomialOrder;
    /**
     * Specifies the period for a moving-average trendline.
     * Applicable only when the [[trendlineType]]
     * property is set to <i>MovingAverage</i>.
     */
    /**
    * Specifies the period for a moving-average trendline.
    * Applicable only when the [[trendlineType]]
    * property is set to <i>MovingAverage</i>.
    */
    period: number;
    /**
     * Specifies the type of trendline, i.e., linear, exponential, polynomial, etc.
     */
    /**
    * Specifies the type of trendline, i.e., linear, exponential, polynomial, etc.
    */
    trendlineType: TrendlineType;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class TrendlineCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: TrendlineCollection, c: Trendline, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: TrendlineCollection;
    readonly a: Trendline;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[Trendline]] objects belonging to the same [[Series]].
 * @see [[Series.trendlineCollection]]
 */
export declare class TrendlineCollection extends ChartObject implements IEnumerable$1<Trendline> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static _w;
    private _af;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns the [[Trendline]] instance at the specified
     * ordinal position within the collection.
     * @param index A zero based index
     */
    item(a: number): Trendline;
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    readonly isReadOnly: boolean;
    /**
     * Adds a new [[Trendline]] to the collection
     * @return The newly added [[Series]]
     */
    add(): Trendline;
    /**
     * @hidden
     */
    _al(a: Trendline): void;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * Returns a boolean value indicating whether the specified
     * instance is contained within this collection.
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: Trendline): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Trendline>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Trendline>;
    /**
     * Returns the index of the item in the collection.
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: Trendline): number;
    /**
     * Inserts a new [[Trendline]] into the collection at the specified index.
     * @param index The index at which to insert the new trendline.
     * @return The newly inserted [[Trendline]]
     */
    insert(index: number): Trendline;
    /**
     * @hidden
     */
    private _an;
    /**
     * Removes an item from the collection.
     * @param item The [[Trendline]] to remove
     * @return True if the trendline was removed, otherwise false.
     */
    remove(item: Trendline): boolean;
    /**
     * Removes the series at the specified index
     * @param index The zero-based index
     */
    removeAt(index: number): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _aq;
}
/**
 * Represents the error bars on a chart series.
 * <para>
 * Error bars indicate the degree of uncertainty for chart data. Only series in area, bar, column, line, and scatter groups on a 2-D chart can have error bars. Only series in scatter groups can have x and y error bars. This object isn't a collection. There's no object that represents a single error bar; you either have x error bars or y error bars turned on for all points in a series or you have them turned off.
 * </para>
 */
export declare class ErrorBars extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ae;
    private _ac;
    private _ag;
    private _z;
    private _ai;
    private _aj;
    constructor();
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Returns or sets a value which determines the direction in which
     * the error bars extend from the data points.
     */
    /**
    * Returns or sets a value which determines the direction in which
    * the error bars extend from the data points.
    */
    direction: ErrorBarDirection;
    /**
     * Returns or sets the end style for the error bars.
     */
    /**
    * Returns or sets the end style for the error bars.
    */
    endStyle: EndStyleCap;
    /**
     * Returns or sets a value which determines the units used to
     * evaluate the error.
     */
    /**
    * Returns or sets a value which determines the units used to
    * evaluate the error.
    */
    errorValueType: ErrorValueType;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill color/gradient for the line.
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill color/gradient for the line.
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _ab: ChartFillBase;
    /**
     * Determines the width of the line, expressed in points.
     * <p class="body">
     * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
     * </p>
     */
    /**
    * Determines the width of the line, expressed in points.
    * <p class="body">
    * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
    * </p>
    */
    widthInPoints: number;
    /**
     * Returns or sets a value which defines the error range.
     * <p class="body">
     * The unit for this property is determined by the [[errorValueType]] property.
     * </p>
     * @see [[errorValueType]]
     */
    /**
    * Returns or sets a value which defines the error range.
    * <p class="body">
    * The unit for this property is determined by the [[errorValueType]] property.
    * </p>
    * @see [[errorValueType]]
    */
    value: number;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents a solid color fill for a chart element.
 */
export declare class ChartSolidFill extends ChartFillBase {
    static $t: Type;
    private _x;
    constructor(color: WorkbookColorInfo);
    /**
     * @hidden
     */
    static _w(a: WorkbookThemeColorType, b?: Nullable$1<number>, c?: Nullable$1<number>, d?: Nullable$1<number>): ChartSolidFill;
    /**
     * Returns the color which is applied to the fill.
     */
    readonly color: WorkbookColorInfo;
}
/**
 * Represents a gradient fill for a chart element.
 * @see [[GradientStop]]
 * @see [[GradientType]]
 */
export declare class ChartGradientFill extends ChartFillBase {
    static $t: Type;
    private _z;
    private _w;
    private _aa;
    constructor(gradientType: GradientType, stops: IEnumerable$1<GradientStop>, angle: number);
    /**
     * Returns the angle defining the path along which the gradient extends;
     * applicable only for linear gradients.
     * <p class="body">
     * This property only applies to linear gradients.
     * </p>
     * <p class="body">
     * This property defines the angle the gradient path makes with the horizontal plane.
     * </p>
     * <p class="body">
     * For example, a gradient which extends from left to right can be changed to extend from
     * bottom to top by setting this property to 90 degrees.
     * </p>
     * <p class="body">
     * A value of 45 degrees yields a gradient which extends from the bottom left corner
     * of the containing element to the top right corner.
     * </p>
     */
    readonly angle: number;
    /**
     * Defines the style for the gradient.
     */
    readonly gradientType: GradientType;
    /**
     * Returns an enumerable list containing each [[GradientStop]]
     * associated with this gradient, ordered by their [[GradientStop.position]].
     * @return An array of [[GradientStop]] instances.
     */
    getStops(): IEnumerable$1<GradientStop>;
    /**
     * @hidden
     */
    private _ac;
}
/**
 * Placeholder which indicates that no fill should be
 * rendered for the associated chart element.
 * <p class="body">
 * Some chart elements require an explicit setting to prevent the fill from appearing.
 * </p>
 * <p class="body">
 * Whether a fill is automatically rendered by Excel is dependent on the chart element.
 * </p>
 * <p class="body">
 * Use this class to ensure that no fill is rendered for the associated chart element.
 * </p>
 * @see [[ChartSolidFill]]
 * @see [[ChartGradientFill]]
 */
export declare class ChartEmptyFill extends ChartFillBase {
    static $t: Type;
    constructor();
}
/**
 * Describes the location and color of a transition
 * point in a <see cref="ChartGradientFill">gradient</see>.
 */
export declare class GradientStop extends Base {
    static $t: Type;
    private _a;
    private _c;
    constructor(color: WorkbookColorInfo, position: number);
    /**
     * Returns the color for this gradient stop.
     */
    readonly color: WorkbookColorInfo;
    /**
     * Returns the position of this gradient stop, as a number between 0 and 1.
     * <p class="body">
     * The value assigned to the Position property represents a fraction
     * of the area to which the gradient is applied.
     * </p>
     * <p class="body">
     * For example, to add two stops of equal length, create one GradientStop
     * with a position of .5 and another with a position of 1.0.
     * </p>
     * <p class="body">
     * The first stop extends from the origin to the halfway point of the fill area,
     * and the second extends from the end of the first to the endpoint of the area
     * to be filled. For three uniform stops, use .33. .67, and 1.0 as the respective
     * positions; for four, use .25, .5, .75, and 1.0, etc.
     * </p>
     */
    readonly position: number;
    /**
     * @hidden
     */
    static _e(a: number, b?: string): void;
}
/**
 * @hidden
 */
export declare class GradientStop_SortComparer extends Base implements IComparer$1<GradientStop> {
    static $t: Type;
    compare(a: GradientStop, b: GradientStop): number;
}
/**
 * Represents the legend in a chart. Each chart can have only one legend.
 */
export declare class Legend extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ao;
    private _ab;
    private _ap;
    private _ac;
    private _au;
    private _av;
    private _ag;
    private _aq;
    private _ai;
    private _aw;
    private _ak;
    private _ax;
    private _ay;
    constructor();
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     */
    /**
    * Determines the appearance of the border drawn around
    * the text area, as well as whether a border appears.
    */
    border: ChartBorder;
    /**
     * Defines the font properties for <see cref="LegendEntries">legend entries</see>
     * which have no specific font settings. Read-only.
     * <p class="body">
     * To apply font settings to a specific legend entry, use the
     * [[LegendEntry.font]] property.
     * </p>
     * <para class="note"><b>Note:</b> this property will return null until the [[Legend]]
     * is set on the <see cref="WorksheetChart.Legend">WorksheetChart.Legend</see> property.</para>
     * @see [[LegendEntry.font]]
     */
    readonly defaultFont: IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    readonly _an: IWorkbookFont;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the font color(s) for <see cref="LegendEntry">legend entries</see>.
     * <p class="body">
     * Use this property to apply the same font color(s) to all legend entries.
     * </p>
     * <p class="body">
     * Use the [[LegendEntry.fontFill]] property to apply font color(s) for a particular legend entry.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the font color(s) for <see cref="LegendEntry">legend entries</see>.
    * <p class="body">
    * Use this property to apply the same font color(s) to all legend entries.
    * </p>
    * <p class="body">
    * Use the [[LegendEntry.fontFill]] property to apply font color(s) for a particular legend entry.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    defaultFontFill: ChartFillBase;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the legend's text area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill properties for the legend's text area.
    * <p class="body">
    * This property returns null by default, indicating that no fill is applied.
    * </p>
    * <p class="body">
    * To apply a solid color fill, assign an instance of the
    * [[ChartSolidFill]] class to this property.
    * </p>
    * <p class="body">
    * To apply a gradient fill, assign an instance of the
    * [[ChartGradientFill]] class to this property.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _af: ChartFillBase;
    /**
     * Returns or sets a value that represents the height of the legend area,
     * expressed as a fraction of the chart area's height.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total height of the chart area.
     * </p>
     * <p class="body">
     * A value of .1 (for example) represents a height that is equal to one-tenth the height
     * of the chart area.
     * </p>
     * @see [[width]]
     */
    /**
    * Returns or sets a value that represents the height of the legend area,
    * expressed as a fraction of the chart area's height.
    * <p class="body">
    * Valid values for this property range between zero and one, with a value of one
    * representing the total height of the chart area.
    * </p>
    * <p class="body">
    * A value of .1 (for example) represents a height that is equal to one-tenth the height
    * of the chart area.
    * </p>
    * @see [[width]]
    */
    height: number;
    /**
     * Returns or sets a value that represents the position of the left edge
     * of the legend area, expressed as a fraction of the chart area's width.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total width of the chart area.
     * </p>
     * @see [[top]]
     */
    /**
    * Returns or sets a value that represents the position of the left edge
    * of the legend area, expressed as a fraction of the chart area's width.
    * <p class="body">
    * Valid values for this property range between zero and one, with a value of one
    * representing the total width of the chart area.
    * </p>
    * @see [[top]]
    */
    left: number;
    /**
     * Indexer (read-only)
     * @param index A zero based index
     * @return
     */
    legendEntries(index: number): LegendEntry;
    /**
     * Returns a read only collection of <see cref="LegendEntry">legend entries</see>.
     * <p class="body">
     * This collection contains one entry for each [[Series]] in the associated
     * chart's [[WorksheetChart.seriesCollection]].
     * </p>
     * <p class="body">
     * This collection does <b>not</b> include legend entries for <see cref="Trendline">trendlines</see>.
     * </p>
     * <p class="body">
     * Use the [[Trendline.legendEntry]] property to obtain a reference to the
     * legend entry associated with a trendline.
     * </p>
     * @see [[WorksheetChart.legend]]
     */
    legendEntries(): LegendEntries;
    /**
     * @hidden
     */
    readonly _legendEntries$i: LegendEntries;
    /**
     * Returns or sets a boolean value indicating whether the legend
     * can intersect with the chart's plot area.
     */
    /**
    * Returns or sets a boolean value indicating whether the legend
    * can intersect with the chart's plot area.
    */
    overlay: boolean;
    /**
     * Returns or sets a value that represents the position of the legend on the chart.
     */
    /**
    * Returns or sets a value that represents the position of the legend on the chart.
    */
    position: LegendPosition;
    /**
     * Determines the rotation of the legend's text area,
     * expressed in degrees.
     */
    /**
    * Determines the rotation of the legend's text area,
    * expressed in degrees.
    */
    rotation: number;
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    /**
    * Determines the orientation and direction in which text flows.
    * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
    * @see [[rotation]]
    */
    textDirection: TextDirection;
    /**
     * Returns or sets a value that represents the position of the top edge
     * of the legend area, expressed as a fraction of the chart area's height.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total height of the chart area.
     * </p>
     * @see [[left]]
     */
    /**
    * Returns or sets a value that represents the position of the top edge
    * of the legend area, expressed as a fraction of the chart area's height.
    * <p class="body">
    * Valid values for this property range between zero and one, with a value of one
    * representing the total height of the chart area.
    * </p>
    * @see [[left]]
    */
    top: number;
    /**
     * Returns or sets a value that represents the width of the legend area,
     * expressed as a fraction of the chart area's width.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total width of the chart area.
     * </p>
     * @see [[height]]
     */
    /**
    * Returns or sets a value that represents the width of the legend area,
    * expressed as a fraction of the chart area's width.
    * <p class="body">
    * Valid values for this property range between zero and one, with a value of one
    * representing the total width of the chart area.
    * </p>
    * @see [[height]]
    */
    width: number;
    /**
     * @hidden
     */
    _at(): IList$1<ILegendEntry>;
    /**
     * @hidden
     */
    _as(): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export interface ILegendEntry {
    readonly names: string[];
    readonly fill: ChartFillBase;
    readonly fontFill: ChartFillBase;
    readonly borderFill: ChartFillBase;
    readonly font: IWorkbookFont;
}
/**
 * @hidden
 */
export declare let ILegendEntry_$type: Type;
/**
 * @hidden
 */
export declare class LegendEntryProxy extends Base implements ILegendEntry {
    static $t: Type;
    private a;
    private g;
    private c;
    private d;
    private b;
    constructor();
    static f(a: LegendEntry): LegendEntryProxy;
    static e(a: DataPoint, b: number): LegendEntryProxy;
    readonly borderFill: ChartFillBase;
    readonly fill: ChartFillBase;
    readonly fontFill: ChartFillBase;
    readonly font: IWorkbookFont;
    readonly names: string[];
}
/**
 * Represents a legend entry in a chart legend.
 * <p class="body">
 * <b>NOTE: </b> Legend entries are not supported for the following chart types:
 * </p>
 * <p>
 * <ul>
 * <li>Box and Whisker</li>
 * <li>Histogram</li>
 * <li>Pareto</li>
 * <li>Sunburst</li>
 * <li>Treemap</li>
 * <li>Waterfall</li>
 * </ul>
 * </p>
 */
export declare class LegendEntry extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ah;
    private _z;
    private _ai;
    constructor(a: IChartObject);
    /**
     * Returns or sets the <see cref="IWorkbookFont">font</see>
     * for this legend entry. Read-only.
     * <p class="body">
     * This property provides a way to specify font settings
     * for a particular legend entry; to apply font settings
     * to all legend entries, use the [[Legend.defaultFont]]
     * property.
     * </p>
     * @see [[Legend.defaultFont]]
     */
    readonly font: IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    readonly _af: IWorkbookFont;
    /**
     * @hidden
     */
    readonly _ag: WorkbookColorInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the font color(s) for this legend entry.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the font color(s) for this legend entry.
    * <p class="body">
    * This property returns null by default, indicating that no fill is applied.
    * </p>
    * <p class="body">
    * To apply a solid color fill, assign an instance of the
    * [[ChartSolidFill]] class to this property.
    * </p>
    * <p class="body">
    * To apply a gradient fill, assign an instance of the
    * [[ChartGradientFill]] class to this property.
    * </p>
    * @see [[ChartSolidFill]]
    * @see [[ChartGradientFill]]
    */
    fontFill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _ab: ChartFillBase;
    /**
     * Returns or sets a boolean value indicating whether this entry
     * has been removed from the [[WorksheetChart.legend]]
     * <p class="body">
     * Deletion does not remove the entry from the [[Legend.legendEntries]]
     * collection, but rather marks it as deleted, so that it does not appear
     * in the legend.
     * </p>
     * @see [[WorksheetChart.legend]]
     * @see [[legend]]
     * @see [[Trendline.legendEntry]]
     */
    /**
    * Returns or sets a boolean value indicating whether this entry
    * has been removed from the [[WorksheetChart.legend]]
    * <p class="body">
    * Deletion does not remove the entry from the [[Legend.legendEntries]]
    * collection, but rather marks it as deleted, so that it does not appear
    * in the legend.
    * </p>
    * @see [[WorksheetChart.legend]]
    * @see [[legend]]
    * @see [[Trendline.legendEntry]]
    */
    isDeleted: boolean;
    /**
     * @hidden
     */
    readonly _ac: Legend;
    /**
     * Marks the entry as being deleted.
     */
    del(): void;
    /**
     * @hidden
     */
    _ad(a: number): {
        ret: Series;
        p0: number;
    };
    /**
     * @hidden
     */
    _ak(): boolean;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * A collection of [[LegendEntry]]s for a [[WorksheetChart]]
 */
export declare class LegendEntries extends ChartObject implements IEnumerable$1<LegendEntry> {
    static $t: Type;
    private _aa;
    constructor(a: IChartObject);
    /**
     * Indexer (read-only)
     * @param index A zero based index
     * @return
     */
    item(a: number): LegendEntry;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: LegendEntry): boolean;
    [Symbol.iterator](): EnumeratorWrapper<LegendEntry>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<LegendEntry>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: LegendEntry): number;
    /**
     * @hidden
     */
    _x(a: number): LegendEntry;
    /**
     * @hidden
     */
    _ae(a: number, b: LegendEntry): void;
    /**
     * @hidden
     */
    _af(a: number): void;
    /**
     * @hidden
     */
    _ag(a: LegendEntry[]): void;
    /**
     * @hidden
     */
    _w(): LegendEntry[];
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Exposes properties related to category axis binning.
 * Applicable only for Histogram and Pareto charts.
 * <p class="body">
 * This class is immutable.
 * </p>
 * @see [[Series.axisBinning]]
 */
export declare class CategoryAxisBinning extends Base {
    static $t: Type;
    constructor(binWidth?: Nullable$1<number>, numberOfBins?: Nullable$1<number>, overflow?: boolean, overflowThreshold?: Nullable$1<number>, underflow?: boolean, underflowThreshold?: Nullable$1<number>);
    constructor();
    constructor(binWidth: Nullable$1<number>, numberOfBins: Nullable$1<number>, overflow: boolean, overflowThreshold: Nullable$1<number>, underflow: boolean, underflowThreshold: Nullable$1<number>, intervalClosedSide: IntervalClosedSide);
    constructor(..._rest: any[]);
    /**
     * Returns the number of data points in each range, i.e., how many
     * data points exist in each bin.
     * <p class="body">
     * Use this property to control the number of data points that should appear
     * in each bin, allowing the total number of bins to be determined automatically.
     * </p>
     * <p class="body">
     * BinWidth and [[numberOfBins]] are mutually exclusive.
     * </p>
     * @see [[numberOfBins]]
     */
    /**
    * Returns the number of data points in each range, i.e., how many
    * data points exist in each bin.
    * <p class="body">
    * Use this property to control the number of data points that should appear
    * in each bin, allowing the total number of bins to be determined automatically.
    * </p>
    * <p class="body">
    * BinWidth and [[numberOfBins]] are mutually exclusive.
    * </p>
    * @see [[numberOfBins]]
    */
    binWidth: number | null;
    private _binWidth$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _binWidth$i: Nullable$1<number>;
    /**
     * @hidden
     */
    _a: IntervalClosedSide;
    /**
     * Returns the total number of bins.
     * <p class="body">
     * Use this property to control the number of bins that should appear,
     * allowing the number of data points per bin to be determined automatically.
     * </p>
     * <p class="body">
     * NumberOfBins and [[binWidth]] are mutually exclusive.
     * </p>
     * @see [[binWidth]]
     */
    /**
    * Returns the total number of bins.
    * <p class="body">
    * Use this property to control the number of bins that should appear,
    * allowing the number of data points per bin to be determined automatically.
    * </p>
    * <p class="body">
    * NumberOfBins and [[binWidth]] are mutually exclusive.
    * </p>
    * @see [[binWidth]]
    */
    numberOfBins: number | null;
    private _numberOfBins$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _numberOfBins$i: Nullable$1<number>;
    private _overflow;
    /**
     * Specifies whether a bin is created for all values above a given threshold.
     * <p class="body">
     * Setting this property to true causes a bin to be created for values
     * above a given threshold.
     * </p>
     * <p class="body">
     * The threshold is determined automatically by default; use the
     * [[overflowThreshold]] property to specify a threshold
     * value.
     * </p>
     * @see [[overflowThreshold]]
     * @see [[underflow]]
     */
    /**
    * Specifies whether a bin is created for all values above a given threshold.
    * <p class="body">
    * Setting this property to true causes a bin to be created for values
    * above a given threshold.
    * </p>
    * <p class="body">
    * The threshold is determined automatically by default; use the
    * [[overflowThreshold]] property to specify a threshold
    * value.
    * </p>
    * @see [[overflowThreshold]]
    * @see [[underflow]]
    */
    overflow: boolean;
    /**
     * Determines the threshold for the [[overflow]] bin.
     * <p class="body">
     * This property is only applicable when the [[overflow]]
     * property is set to true.
     * </p>
     * <p class="body">
     * When this property is left unset, the threshold is determined automatically.
     * </p>
     * @see [[overflow]]
     * @see [[underflowThreshold]]
     */
    /**
    * Determines the threshold for the [[overflow]] bin.
    * <p class="body">
    * This property is only applicable when the [[overflow]]
    * property is set to true.
    * </p>
    * <p class="body">
    * When this property is left unset, the threshold is determined automatically.
    * </p>
    * @see [[overflow]]
    * @see [[underflowThreshold]]
    */
    overflowThreshold: number | null;
    private _overflowThreshold$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _overflowThreshold$i: Nullable$1<number>;
    private _underflow;
    /**
     * Specifies whether a bin is created for all values below a given threshold.
     * <p class="body">
     * Setting this property to true causes a bin to be created for values
     * below a given threshold.
     * </p>
     * <p class="body">
     * The threshold is determined automatically by default; use the
     * [[underflowThreshold]] property to specify a threshold
     * value.
     * </p>
     * @see [[overflowThreshold]]
     * @see [[overflow]]
     */
    /**
    * Specifies whether a bin is created for all values below a given threshold.
    * <p class="body">
    * Setting this property to true causes a bin to be created for values
    * below a given threshold.
    * </p>
    * <p class="body">
    * The threshold is determined automatically by default; use the
    * [[underflowThreshold]] property to specify a threshold
    * value.
    * </p>
    * @see [[overflowThreshold]]
    * @see [[overflow]]
    */
    underflow: boolean;
    /**
     * Determines the threshold for the [[underflow]] bin.
     * <p class="body">
     * This property is only applicable when the [[underflow]]
     * property is set to true.
     * </p>
     * <p class="body">
     * When this property is left unset, the threshold is determined automatically.
     * </p>
     * @see [[underflow]]
     * @see [[underflowThreshold]]
     */
    /**
    * Determines the threshold for the [[underflow]] bin.
    * <p class="body">
    * This property is only applicable when the [[underflow]]
    * property is set to true.
    * </p>
    * <p class="body">
    * When this property is left unset, the threshold is determined automatically.
    * </p>
    * @see [[underflow]]
    * @see [[underflowThreshold]]
    */
    underflowThreshold: number | null;
    private _underflowThreshold$i_1;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _underflowThreshold$i: Nullable$1<number>;
}
/**
 * Exposes properties related to the <i>BoxAndWhisker</i> chart type.
 * <p class="body">
 * This class is immutable.
 * </p>
 * @see [[Series.boxAndWhiskerSettings]]
 */
export declare class BoxAndWhiskerSettings extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _c: boolean;
    /**
     * @hidden
     */
    static readonly _f: boolean;
    /**
     * @hidden
     */
    static readonly _e: boolean;
    /**
     * @hidden
     */
    static readonly _d: boolean;
    /**
     * @hidden
     */
    static readonly _a: QuartileCalculation;
    constructor(showInnerPoints: boolean, showOutlierPoints: boolean, showMeanMarkers: boolean, showMeanLine: boolean, quartileCalculation: QuartileCalculation);
    private _showInnerPoints;
    /**
     * Determines whether inner points appear on a box and whisker chart.
     * <p class="body">
     * Inner points appear between the lower whisker line and the upper whisker line.
     * </p>
     * @see [[showOutlierPoints]]
     */
    /**
    * Determines whether inner points appear on a box and whisker chart.
    * <p class="body">
    * Inner points appear between the lower whisker line and the upper whisker line.
    * </p>
    * @see [[showOutlierPoints]]
    */
    showInnerPoints: boolean;
    private _showOutlierPoints;
    /**
     * Determines whether outlier points appear on a box and whisker chart.
     * <p class="body">
     * Outlier points appear either below the lower whisker line or above the upper whisker line.
     * </p>
     * @see [[showInnerPoints]]
     */
    /**
    * Determines whether outlier points appear on a box and whisker chart.
    * <p class="body">
    * Outlier points appear either below the lower whisker line or above the upper whisker line.
    * </p>
    * @see [[showInnerPoints]]
    */
    showOutlierPoints: boolean;
    private _showMeanMarkers;
    /**
     * Determines whether mean markers appear on a box and whisker chart.
     * @see [[showMeanLine]]
     */
    /**
    * Determines whether mean markers appear on a box and whisker chart.
    * @see [[showMeanLine]]
    */
    showMeanMarkers: boolean;
    private _showMeanLine;
    /**
     * Determines whether a mean line appears on a box and whisker chart.
     * <p class="body">
     * Mean lines connect the means of the boxes.
     * </p>
     * @see [[showMeanMarkers]]
     */
    /**
    * Determines whether a mean line appears on a box and whisker chart.
    * <p class="body">
    * Mean lines connect the means of the boxes.
    * </p>
    * @see [[showMeanMarkers]]
    */
    showMeanLine: boolean;
    private _quartileCalculation;
    /**
     * Determines the method for median calculation.
     */
    /**
    * Determines the method for median calculation.
    */
    quartileCalculation: QuartileCalculation;
}
/**
 * Abstract base class that defines a set of values in a [[Series]].
 */
export declare abstract class SeriesValuesBase extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _h: boolean;
    /**
     * @hidden
     */
    _a: any[];
    /**
     * @hidden
     */
    _e: Sheet;
    /**
     * @hidden
     */
    _f: SingleTargetFormula;
    /**
     * @hidden
     */
    _k: string;
    constructor(values: IEnumerable);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: Nullable$1<CellReferenceMode>);
    constructor(sheet: Sheet, formula: SingleTargetFormula, values: any[], dummy: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    protected get__d(): SeriesValuesType;
    /**
     * @hidden
     */
    readonly _d: SeriesValuesType;
    /**
     * Returns an object array containing the value of
     * each data point in the associated [[Series]].
     * @return An array of values where each element in the array represents the value of a data point in the associated Series.
     */
    getValues(): any[];
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    static _b<T>($t: Type, a: SingleTargetFormula, b: Sheet, c: boolean, d: (arg1: IList$1<ExcelCalcValue>) => T[]): T[];
    /**
     * @hidden
     */
    static _i(a: ExcelCalcValue): any;
    /**
     * @hidden
     */
    static _l(a: ExcelCalcValue): string;
    /**
     * @hidden
     */
    _g(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: Series, b: number, c: (arg1: IChartObject, arg2: any) => void, d: CellShiftOperation, e: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    _j(a: number, b: string): any;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _r;
}
/**
 * Defines a set of values in a series
 */
export declare class SeriesValues extends SeriesValuesBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _s: number[];
    /**
     * @hidden
     */
    _v: boolean;
    constructor(values: IEnumerable);
    constructor(sheet: Sheet, formula: SingleTargetFormula, values: any[], dummy: boolean);
    constructor(sheet: Sheet, sourceRange: string, cellReferenceMode?: Nullable$1<CellReferenceMode>, colorBy?: SeriesValuesColorBy);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    static _u(a: Sheet, b: SingleTargetFormula, c: any[]): SeriesValues;
    /**
     * @hidden
     */
    _t(a: string, b: number[]): {
        ret: any[];
        p0: string;
        p1: number[];
    };
}
/**
 * Defines the name of a series
 */
export declare class SeriesName extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _g: string;
    private readonly _c;
    /**
     * @hidden
     */
    _d: SingleTargetFormula;
    /**
     * @hidden
     */
    _h: string;
    constructor(name: string);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: Nullable$1<CellReferenceMode>);
    constructor(sheet: Sheet, formula: SingleTargetFormula);
    constructor(..._rest: any[]);
    /**
     * Gets the string representation of the [[SeriesName]].
     */
    toString(): string;
    /**
     * @hidden
     */
    static _b(a: Sheet, b: SingleTargetFormula, c: string): SeriesName;
    /**
     * @hidden
     */
    _a(): string[];
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _j(a: Series, b: number, c: (arg1: IChartObject, arg2: any) => void, d: CellShiftOperation, e: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _f(a: number, b: string): any;
    /**
     * @hidden
     */
    private _k;
}
/**
 * Defines a set of values in a series
 */
export declare class XValues extends SeriesValuesBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _s: number[];
    private _y;
    /**
     * @hidden
     */
    _ad: Nullable$1<boolean>;
    /**
     * @hidden
     */
    _ac: number;
    /**
     * @hidden
     */
    _ab: XValuesDataType;
    constructor(values: IEnumerable);
    constructor(dataType: XValuesDataType, values: IEnumerable, levels: number[]);
    constructor(sheet: Sheet, formula: SingleTargetFormula, dataType: XValuesDataType, values: any[], levels: number[]);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: Nullable$1<CellReferenceMode>);
    constructor(sheet: Sheet, plotByRows: boolean, dataType: XValuesDataType, formula: string, cellReferenceMode?: Nullable$1<CellReferenceMode>);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    protected get__d(): SeriesValuesType;
    /**
     * @hidden
     */
    readonly _z: Series;
    /**
     * Returns the actual values for this [[XValues]] instance.
     * @return An object array containing the actual data point values for the associated [[Series]].
     */
    getValues(): any[];
    /**
     * @hidden
     */
    _t(): any[];
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    static _aa(a: Sheet, b: SingleTargetFormula, c: any[], d: number[], e: XValuesDataType): XValues;
    /**
     * @hidden
     */
    _u(): GetXValuesResult;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _ae(a: Series): void;
    /**
     * @hidden
     */
    _af(): void;
}
/**
 * An object that represents a specific series in a chart
 */
export declare class Series extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cc;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ck;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _cp;
    /**
     * @hidden
     */
    private static readonly _cr;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cu;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _c0;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c3;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _dd;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    static readonly _de: number;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    static readonly _cm: number;
    /**
     * @hidden
     */
    static readonly _co: number;
    /**
     * @hidden
     */
    static readonly _cn: number;
    /**
     * @hidden
     */
    static readonly _c2: number;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _bc;
    private _bb;
    private _af;
    private _aa;
    private _dg;
    private _ah;
    private _ad;
    private _bj;
    private _av;
    private _bd;
    private _ax;
    private _az;
    private _ca;
    private _al;
    private _a1;
    private _a3;
    private _at;
    private _ai;
    private _am;
    private _dh;
    private _a5;
    private _bf;
    private _a9;
    private _a7;
    private _b8;
    private _cb;
    private _bn;
    private _bh;
    private _bk;
    private _bp;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Apply the picture to the end of the series.
     */
    /**
    * Apply the picture to the end of the series.
    */
    applyPicToEnd: boolean;
    /**
     * Apply the picture to the front of the series.
     */
    /**
    * Apply the picture to the front of the series.
    */
    applyPicToFront: boolean;
    /**
     * Apply the picture to the sides.
     */
    /**
    * Apply the picture to the sides.
    */
    applyPicToSides: boolean;
    /**
     * Returns or sets a [[CategoryAxisBinning]] instance which determines
     * the binning properties for the category axis on a histogram or pareto chart.
     * <p class="body">
     * This property is only applicable for histogram and pareto charts.
     * </p>
     */
    /**
    * Returns or sets a [[CategoryAxisBinning]] instance which determines
    * the binning properties for the category axis on a histogram or pareto chart.
    * <p class="body">
    * This property is only applicable for histogram and pareto charts.
    * </p>
    */
    axisBinning: CategoryAxisBinning;
    /**
     * Specifies which axis group this series applies to.
     * <p class="body">
     * This property is only applicable for combo charts.
     * </p>
     * <p class="body">
     * This property defaults to <i>Primary</i>, causing all series to
     * be plotted on the primary axis unless otherwise specified.
     * </p>
     * <p class="body">
     * To plot this series on the secondary value axis, set this property to <i>Secondary</i>.
     * </p>
     * <p class="body">
     * Setting this property to <i>Secondary</i> triggers creation of secondary
     * category and value axes.
     * </p>
     * <p class="body">
     * Not all series can be plotted on the same axis; the following table lists
     * each ChartType along with the other ChartTypes which can be plotted on the
     * same axis:
     * </p>
     * <p class="body">
     * <table border="1">
     * <tr><th>ChartType</th><th>Valid on same axis</th></tr>
     * <tr><td>ColumnClustered</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>ColumnStacked</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>ColumnStacked100</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>BarClustered</td><td>BarClustered only</td></tr>
     * <tr><td>BarStacked</td><td>BarStacked only</td></tr>
     * <tr><td>BarStacked100</td><td>BarStacked100 only</td></tr>
     * <tr><td>Line</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkers, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkersStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkersStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>Area</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>AreaStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>AreaStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>Pie</td><td>PieExploded, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>PieExploded</td><td>Pie, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>BarOfPie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>PieOfPie</td><td>Pie, PieExploded, BarOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>Doughnut</td><td>Pie, PieExploded, BarOfPie, PieOfPie, DoughnutExploded</td></tr>
     * <tr><td>DoughnutExploded</td><td>Pie, PieExploded, BarOfPie, PieOfPie, Doughnut</td></tr>
     * <tr><td>XYScatter</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterLines</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterLinesNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterSmooth</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterSmoothNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth</td></tr>
     * <tr><td>Radar</td><td>RadarFilled, RadarMarkers</td></tr>
     * <tr><td>RadarFilled</td><td>Radar, RadarMarkers</td></tr>
     * <tr><td>RadarMarkers</td><td>Radar, RadarFilled</td></tr>
     * </table>
     * </p>
     * <p class="body">
     * Attempting to set the series axis to the same value as an incompatible series
     * causes an exception to be thrown.
     * </p>
     * @see [[chartType]]
     * @see [[Axis]]
     * @see [[WorksheetChart.axisCollection]]
     * @throws [[NotSupportedException]] The target axis already contains a chart type which cannot share axes with this series
     * because of the value of the [[chartType]] property of this series.
     */
    /**
    * Specifies which axis group this series applies to.
    * <p class="body">
    * This property is only applicable for combo charts.
    * </p>
    * <p class="body">
    * This property defaults to <i>Primary</i>, causing all series to
    * be plotted on the primary axis unless otherwise specified.
    * </p>
    * <p class="body">
    * To plot this series on the secondary value axis, set this property to <i>Secondary</i>.
    * </p>
    * <p class="body">
    * Setting this property to <i>Secondary</i> triggers creation of secondary
    * category and value axes.
    * </p>
    * <p class="body">
    * Not all series can be plotted on the same axis; the following table lists
    * each ChartType along with the other ChartTypes which can be plotted on the
    * same axis:
    * </p>
    * <p class="body">
    * <table border="1">
    * <tr><th>ChartType</th><th>Valid on same axis</th></tr>
    * <tr><td>ColumnClustered</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>ColumnStacked</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>ColumnStacked100</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>BarClustered</td><td>BarClustered only</td></tr>
    * <tr><td>BarStacked</td><td>BarStacked only</td></tr>
    * <tr><td>BarStacked100</td><td>BarStacked100 only</td></tr>
    * <tr><td>Line</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkers, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>LineStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>LineStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>LineMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>LineMarkersStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>LineMarkersStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>Area</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>AreaStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>AreaStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>Pie</td><td>PieExploded, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
    * <tr><td>PieExploded</td><td>Pie, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
    * <tr><td>BarOfPie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td></tr>
    * <tr><td>PieOfPie</td><td>Pie, PieExploded, BarOfPie, Doughnut, DoughnutExploded</td></tr>
    * <tr><td>Doughnut</td><td>Pie, PieExploded, BarOfPie, PieOfPie, DoughnutExploded</td></tr>
    * <tr><td>DoughnutExploded</td><td>Pie, PieExploded, BarOfPie, PieOfPie, Doughnut</td></tr>
    * <tr><td>XYScatter</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>XYScatterLines</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>XYScatterLinesNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>XYScatterSmooth</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmoothNoMarkers</td></tr>
    * <tr><td>XYScatterSmoothNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth</td></tr>
    * <tr><td>Radar</td><td>RadarFilled, RadarMarkers</td></tr>
    * <tr><td>RadarFilled</td><td>Radar, RadarMarkers</td></tr>
    * <tr><td>RadarMarkers</td><td>Radar, RadarFilled</td></tr>
    * </table>
    * </p>
    * <p class="body">
    * Attempting to set the series axis to the same value as an incompatible series
    * causes an exception to be thrown.
    * </p>
    * @see [[chartType]]
    * @see [[Axis]]
    * @see [[WorksheetChart.axisCollection]]
    * @throws [[NotSupportedException]] The target axis already contains a chart type which cannot share axes with this series
    * because of the value of the [[chartType]] property of this series.
    */
    axisGroup: AxisGroup;
    /**
     * Determines the shape of the bar for this series.
     * Applicable only for 3D bar charts.
     * <p class="body">
     * This property controls the shape of the bar displayed for this series only.
     * </p>
     * <p class="body">
     * To set the bar shape for all series in the chart, use the [[WorksheetChart.barShape]] property.
     * </p>
     * @see [[WorksheetChart.barShape]]
     */
    /**
    * Determines the shape of the bar for this series.
    * Applicable only for 3D bar charts.
    * <p class="body">
    * This property controls the shape of the bar displayed for this series only.
    * </p>
    * <p class="body">
    * To set the bar shape for all series in the chart, use the [[WorksheetChart.barShape]] property.
    * </p>
    * @see [[WorksheetChart.barShape]]
    */
    barShape: BarShape | null;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    _barShape$i: Nullable$1<BarShape>;
    /**
     * Returns the resolved value of the [[barShape]] property.
     * @see [[barShape]]
     * @see [[WorksheetChart.barShape]]
     */
    readonly barShapeResolved: BarShape;
    /**
     * Determines the appearance of the border drawn around the
     * [[fill]] area. Applicable only for chart series
     * which support fills, such as bar charts, area charts, and
     * pie charts.
     * <p class="body">
     * For series which support <see cref="Fill">fills</see>, this property controls the
     * color and size of the line drawn around the fill region.
     * </p>
     * <p class="body">
     * For line-based series, use the [[line]] property.
     * </p>
     * @see [[fill]]
     * @see [[line]]
     */
    /**
    * Determines the appearance of the border drawn around the
    * [[fill]] area. Applicable only for chart series
    * which support fills, such as bar charts, area charts, and
    * pie charts.
    * <p class="body">
    * For series which support <see cref="Fill">fills</see>, this property controls the
    * color and size of the line drawn around the fill region.
    * </p>
    * <p class="body">
    * For line-based series, use the [[line]] property.
    * </p>
    * @see [[fill]]
    * @see [[line]]
    */
    border: ChartBorder;
    /**
     * Returns or sets a [[boxAndWhiskerSettings]] instance which determines
     * the properties for a box and whisker chart.
     * <p class="body">
     * This property is only applicable for box and whisker charts.
     * </p>
     */
    /**
    * Returns or sets a [[boxAndWhiskerSettings]] instance which determines
    * the properties for a box and whisker chart.
    * <p class="body">
    * This property is only applicable for box and whisker charts.
    * </p>
    */
    boxAndWhiskerSettings: BoxAndWhiskerSettings;
    /**
     * Returns or sets a [[values]] instance that determines the bubble sizes in a bubble chart.
     */
    /**
    * Returns or sets a [[values]] instance that determines the bubble sizes in a bubble chart.
    */
    bubbleSizes: SeriesValues;
    /**
     * Specifies the type of chart for this series. Applicable only
     * for combo charts.
     * <p class="body">
     * This property is only applicable for combo charts. Setting this
     * property for any other type of chart causes an exception to be thrown.
     * </p>
     * <p class="body">
     * Not all ChartType values are supported for series which are plotted within
     * a combo chart. For a list of the supported values, see documentation for
     * the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
     * method.
     * </p>
     * <p class="body">
     * If the value assigned to this property necessitates plotting this series
     * on a different axis than the one referenced by the [[axisGroup]]
     * property, and the other axis can accommodate this series, the AxisGroup
     * property is changed accordingly.
     * </p>
     * <p class="body">
     * If the other axis cannot accommodate this series, and other series which are
     * of the same series type exist on the same axis, an attempt is made to change
     * the ChartType of those other series. For example, if a different series exists
     * with a ChartType of <i>BarClustered</i>, and a value of <i>BarStacked</i> is
     * assigned to this series, the ChartType of   the other series is changed to
     * <i>BarStacked</i> in order to accommodate the setting of the property on this
     * series.
     * </p>
     * <p class="body">
     * If no adjustment can be made that would allow the ChartType to be changed to the
     * specified value, an exception is thrown.
     * </p>
     * <p class="body">
     * Note that in all cases, the value of the [[type]] property is
     * automatically changed to a value which is appropriate for the assigned ChartType.
     * </p>
     * @see [[type]]
     * @see [[axisGroup]]
     * @throws [[NotSupportedException]] The [[axisGroup]] on which this series currently resides cannot share an axis
     * with a series of this <i>ChartType</i>, and no adjustment could be made to avoid this.
     */
    /**
    * Specifies the type of chart for this series. Applicable only
    * for combo charts.
    * <p class="body">
    * This property is only applicable for combo charts. Setting this
    * property for any other type of chart causes an exception to be thrown.
    * </p>
    * <p class="body">
    * Not all ChartType values are supported for series which are plotted within
    * a combo chart. For a list of the supported values, see documentation for
    * the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
    * method.
    * </p>
    * <p class="body">
    * If the value assigned to this property necessitates plotting this series
    * on a different axis than the one referenced by the [[axisGroup]]
    * property, and the other axis can accommodate this series, the AxisGroup
    * property is changed accordingly.
    * </p>
    * <p class="body">
    * If the other axis cannot accommodate this series, and other series which are
    * of the same series type exist on the same axis, an attempt is made to change
    * the ChartType of those other series. For example, if a different series exists
    * with a ChartType of <i>BarClustered</i>, and a value of <i>BarStacked</i> is
    * assigned to this series, the ChartType of   the other series is changed to
    * <i>BarStacked</i> in order to accommodate the setting of the property on this
    * series.
    * </p>
    * <p class="body">
    * If no adjustment can be made that would allow the ChartType to be changed to the
    * specified value, an exception is thrown.
    * </p>
    * <p class="body">
    * Note that in all cases, the value of the [[type]] property is
    * automatically changed to a value which is appropriate for the assigned ChartType.
    * </p>
    * @see [[type]]
    * @see [[axisGroup]]
    * @throws [[NotSupportedException]] The [[axisGroup]] on which this series currently resides cannot share an axis
    * with a series of this <i>ChartType</i>, and no adjustment could be made to avoid this.
    */
    chartType: ChartType;
    /**
     * @hidden
     */
    _dr(a: ChartType, b: boolean): void;
    /**
     * @hidden
     */
    private _b6;
    /**
     * Returns a [[SeriesDataLabels]] instance which applies to all [[DataLabel]]
     * instances which do not have a specific setting for a given property.
     * <p class="body">
     * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
     * </p>
     */
    readonly dataLabels: SeriesDataLabels;
    /**
     * @hidden
     */
    private _dm;
    /**
     * Returns the [[DataPoint]] instance at the specified
     * ordinal position within this collection.
     * @param index A zero based index
     * @return A [[DataPoint]] instance.
     */
    dataPointCollection(index: number): DataPoint;
    /**
     * Returns a <see cref="DataPointCollection">collection</see>
     * of [[DataPoint]] instances which represent the
     * individual data points in this series.
     */
    dataPointCollection(): DataPointCollection;
    /**
     * @hidden
     */
    readonly _dataPointCollection$i: DataPointCollection;
    /**
     * Returns or sets an [[ErrorBars]] object.
     */
    /**
    * Returns or sets an [[ErrorBars]] object.
    */
    errorBars: ErrorBars;
    /**
     * Returns or sets a value which determines the amount by which individual slices
     * are offset from the center of the pie or doughnut, expressed as a percentage
     * of the radius.
     * <p class="body">
     * The valid range of values is between 0 and 400, inclusive.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
     */
    /**
    * Returns or sets a value which determines the amount by which individual slices
    * are offset from the center of the pie or doughnut, expressed as a percentage
    * of the radius.
    * <p class="body">
    * The valid range of values is between 0 and 400, inclusive.
    * </p>
    * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
    */
    explosion: number;
    /**
     * @hidden
     */
    readonly _dj: Nullable$1<number>;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill for this series. Not applicable for
     * line charts.
     * <p class="body">
     * This property is not applicable to charts which depict the data
     * series as a line. For these chart types, use the [[line]]
     * property, which controls the color and width of the line.
     * </p>
     * @see [[border]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill for this series. Not applicable for
    * line charts.
    * <p class="body">
    * This property is not applicable to charts which depict the data
    * series as a line. For these chart types, use the [[line]]
    * property, which controls the color and width of the line.
    * </p>
    * @see [[border]]
    */
    fill: ChartFillBase;
    /**
     * Returns or sets a [[geographicMapSettings]] instance
     * which defines the appearance and behavior for a geographic map chart.
     * <p class="body">
     * This property is only applicable when the <see cref="WorksheetChart.ChartType">ChartType</see>
     * property is set to <i>RegionMap</i>.
     * </p>
     */
    /**
    * Returns or sets a [[geographicMapSettings]] instance
    * which defines the appearance and behavior for a geographic map chart.
    * <p class="body">
    * This property is only applicable when the <see cref="WorksheetChart.ChartType">ChartType</see>
    * property is set to <i>RegionMap</i>.
    * </p>
    */
    geographicMapSettings: GeographicMapSettings;
    /**
     * Determines if negative values will be inverted.
     */
    /**
    * Determines if negative values will be inverted.
    */
    invertIfNegative: boolean;
    /**
     * Returns or sets the  instance.
     * <p class="body">
     * A leader line connects a [[DataLabel]] to it's associated series.
     * </p>
     * @see [[leaderLines]]
     * @see [[DataLabel]]
     * @see [[dataPointCollection]]
     */
    /**
    * Returns or sets the  instance.
    * <p class="body">
    * A leader line connects a [[DataLabel]] to it's associated series.
    * </p>
    * @see [[leaderLines]]
    * @see [[DataLabel]]
    * @see [[dataPointCollection]]
    */
    leaderLines: LeaderLines;
    /**
     * Determines the <see cref="ChartLineBase.Fill">fill</see> and
     * <see cref="ChartLineBase.WidthInPoints">width</see> of a series line.
     * <p class="body">
     * This property is not applicable for series which support <see cref="Fill">fills</see>,
     * such as bar, area, or pie charts.
     * </p>
     * <p class="body">
     * For chart series which supports fills, use the [[fill]] property
     * to control the fill color, and the [[border]] property for the
     * line drawn around that fill area.
     * </p>
     * @see [[fill]]
     * @see [[border]]
     * @see [[markerFill]]
     * @see [[markerBorder]]
     */
    /**
    * Determines the <see cref="ChartLineBase.Fill">fill</see> and
    * <see cref="ChartLineBase.WidthInPoints">width</see> of a series line.
    * <p class="body">
    * This property is not applicable for series which support <see cref="Fill">fills</see>,
    * such as bar, area, or pie charts.
    * </p>
    * <p class="body">
    * For chart series which supports fills, use the [[fill]] property
    * to control the fill color, and the [[border]] property for the
    * line drawn around that fill area.
    * </p>
    * @see [[fill]]
    * @see [[border]]
    * @see [[markerFill]]
    * @see [[markerBorder]]
    */
    line: ChartLine;
    /**
     * Determines the appearance of the <see cref="ChartBorder">border</see>
     * (a.k.a. outline) for the marker.
     */
    /**
    * Determines the appearance of the <see cref="ChartBorder">border</see>
    * (a.k.a. outline) for the marker.
    */
    markerBorder: ChartBorder;
    /**
     * Defines the <see cref="ChartFillBase">fill</see> appearance for the marker.
     */
    /**
    * Defines the <see cref="ChartFillBase">fill</see> appearance for the marker.
    */
    markerFill: ChartFillBase;
    /**
     * Determines the size of the markers.
     */
    /**
    * Determines the size of the markers.
    */
    markerSize: number;
    /**
     * @hidden
     */
    readonly _dk: Nullable$1<number>;
    /**
     * Determines the style of the markers
     */
    /**
    * Determines the style of the markers
    */
    markerStyle: MarkerStyle;
    /**
     * The name of the series
     */
    /**
    * The name of the series
    */
    name: SeriesName;
    /**
     * Returns or sets a reference to the owning [[Series]].
     * Applicable only for a line series in a <i>Pareto</i> chart.
     * <p class="body">
     * This property is only applicable for Series contained within a
     * <i>Pareto</i> chart.
     * </p>
     * <p class="body">
     * If the [[chartType]] property of this series, as well as that of
     * the associated <see cref="WorksheetChart">chart</see>, are not both set to
     * 'Pareto', an exception is thrown.
     * </p>
     * <p class="body">
     * If the value assigned to this property has a [[chartType]] of any value
     * other than 'ClusteredColumn', an exception is thrown.
     * </p>
     */
    /**
    * Returns or sets a reference to the owning [[Series]].
    * Applicable only for a line series in a <i>Pareto</i> chart.
    * <p class="body">
    * This property is only applicable for Series contained within a
    * <i>Pareto</i> chart.
    * </p>
    * <p class="body">
    * If the [[chartType]] property of this series, as well as that of
    * the associated <see cref="WorksheetChart">chart</see>, are not both set to
    * 'Pareto', an exception is thrown.
    * </p>
    * <p class="body">
    * If the value assigned to this property has a [[chartType]] of any value
    * other than 'ClusteredColumn', an exception is thrown.
    * </p>
    */
    owningSeries: Series;
    /**
     * Determines whether pictures are scaled, stacked, or stretched.
     */
    /**
    * Determines whether pictures are scaled, stacked, or stretched.
    */
    pictureType: PictureType;
    /**
     * Returns or sets a value which defines the unit of measure
     * when [[pictureType]] is set to <i>Stack</i>.
     */
    /**
    * Returns or sets a value which defines the unit of measure
    * when [[pictureType]] is set to <i>Stack</i>.
    */
    pictureUnit: number;
    /**
     * The plotting order for the data series.
     * <para class="note">
     * <b>Note:</b> this is the order in which the series names will appear in the legend. When there is only one series then this is omitted. This must be a whole number between 1 and the number of series on the chart. If you enter zero then 1 is used. If you enter a number greater than the number of series then the total number of series is used.
     * </para>
     */
    /**
    * The plotting order for the data series.
    * <para class="note">
    * <b>Note:</b> this is the order in which the series names will appear in the legend. When there is only one series then this is omitted. This must be a whole number between 1 and the number of series on the chart. If you enter zero then 1 is used. If you enter a number greater than the number of series then the total number of series is used.
    * </para>
    */
    plotOrder: number;
    /**
     * Returns or sets a boolean value indicating whether to display
     * [[dataLabels]].
     */
    /**
    * Returns or sets a boolean value indicating whether to display
    * [[dataLabels]].
    */
    showDataLabels: boolean;
    /**
     * Returns or sets a boolean value indicating whether to display
     * connecting lines between the data points in a waterfall chart.
     * <p class="body">
     * This property is only applicable for waterfall charts.
     * </p>
     * <p class="body">
     * Use the [[border]] property to control the visual
     * appearance of the connector lines.
     * </p>
     */
    /**
    * Returns or sets a boolean value indicating whether to display
    * connecting lines between the data points in a waterfall chart.
    * <p class="body">
    * This property is only applicable for waterfall charts.
    * </p>
    * <p class="body">
    * Use the [[border]] property to control the visual
    * appearance of the connector lines.
    * </p>
    */
    showWaterfallConnectorLines: boolean;
    /**
     * Determines whether a smoothing effect should be applied.
     */
    /**
    * Determines whether a smoothing effect should be applied.
    */
    smooth: boolean;
    /**
     * @hidden
     */
    readonly _b5: boolean;
    /**
     * Returns the [[Trendline]] instance at the specified
     * ordinal position within the collection.
     * @param index A zero based index
     */
    trendlineCollection(index: number): Trendline;
    /**
     * Returns a collection of [[Trendline]] instances for this series.
     * <p class="body">
     * Trendlines are supported for Area, Bar, Bubble, Line, and Scatter charts,
     * and are not supported for other chart types.
     * </p>
     * @see [[Trendline]]
     */
    trendlineCollection(): TrendlineCollection;
    /**
     * @hidden
     */
    readonly _trendlineCollection$i: TrendlineCollection;
    /**
     * @hidden
     */
    readonly _bw: boolean;
    /**
     * Returns or sets a [[SeriesType]] value which determines
     * the type of this series. Applicable only for combo charts.
     * <p class="body">
     * This property is only applicable for combo charts. Setting this
     * property for any other type of chart causes an exception to be thrown.
     * </p>
     * <p class="body">
     * Combo charts do not support <i>Bubble</i> or <i>Surface</i>; setting this property
     * to either of those values causes an exception to be thrown.
     * </p>
     * <p class="body">
     * The [[chartType]] property must be set to a value that is compatible
     * with assigned series type. If the current value of the ChartType property is
     * not compatible with the value assigned to this property, a reasonable default
     * value, which is compatible, is assigned to the ChartType property.
     * </p>
     * @see [[chartType]]
     */
    /**
    * Returns or sets a [[SeriesType]] value which determines
    * the type of this series. Applicable only for combo charts.
    * <p class="body">
    * This property is only applicable for combo charts. Setting this
    * property for any other type of chart causes an exception to be thrown.
    * </p>
    * <p class="body">
    * Combo charts do not support <i>Bubble</i> or <i>Surface</i>; setting this property
    * to either of those values causes an exception to be thrown.
    * </p>
    * <p class="body">
    * The [[chartType]] property must be set to a value that is compatible
    * with assigned series type. If the current value of the ChartType property is
    * not compatible with the value assigned to this property, a reasonable default
    * value, which is compatible, is assigned to the ChartType property.
    * </p>
    * @see [[chartType]]
    */
    type: SeriesType;
    /**
     * @hidden
     */
    private _b7;
    /**
     * Returns or sets a [[xValues]] instance that contains a collection of all the x values in the series.
     * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
     * </para>
     */
    /**
    * Returns or sets a [[xValues]] instance that contains a collection of all the x values in the series.
    * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
    * </para>
    */
    xValues: XValues;
    /**
     * @hidden
     */
    readonly _b1: boolean;
    /**
     * Returns or sets a [[values]] instance that contains a collection of all the values in the series.
     * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
     * </para>
     */
    /**
    * Returns or sets a [[values]] instance that contains a collection of all the values in the series.
    * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
    * </para>
    */
    values: SeriesValues;
    /**
     * @hidden
     */
    readonly _b0: boolean;
    /**
     * @hidden
     */
    readonly _z: Axis;
    /**
     * @hidden
     */
    _dl(a: any[], b: any[]): {
        p0: any[];
        p1: any[];
    };
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _dp;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    _ao(a: number): ChartFillBase;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    _aq(a: number): ChartFillBase;
    /**
     * @hidden
     */
    _ar(a: number): ChartFillBase;
    /**
     * @hidden
     */
    _bv(a: Workbook): boolean;
    /**
     * @hidden
     */
    static _bz(a: SeriesType): boolean;
    /**
     * @hidden
     */
    static _by(a: SeriesType, b: ChartType, c: ChartType): {
        ret: boolean;
        p2: ChartType;
    };
    /**
     * @hidden
     */
    _dn(): void;
    /**
     * @hidden
     */
    _ds(): void;
}
/**
 * @hidden
 */
export declare class GetXValuesResult extends Base {
    static $t: Type;
    constructor(a: List$1<XValue>, b: XValuesDataType);
    a: XValuesDataType;
    c: List$1<XValue>;
    b(a: number, b: number): {
        ret: List$1<number>;
        p0: number;
        p1: number;
    };
}
/**
 * @hidden
 */
export declare class XValue extends Base {
    static $t: Type;
    d: number;
    b: number;
    f: string;
    a: string[];
    readonly c: number;
    toString(): string;
    e(a?: string): string;
}
/**
 * @hidden
 */
export declare class SeriesCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SeriesCollection, c: Series, d: LegendEntry, e: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: SeriesCollection;
    readonly b: Series;
    readonly a: LegendEntry;
    readonly workbook: Workbook;
    readonly sheet: Sheet;
    readonly source: any;
}
/**
 * A collection of [[Series]] for a [[WorksheetChart]]
 */
export declare class SeriesCollection extends ChartObject implements IEnumerable$1<Series> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static _w;
    private _aj;
    private _ai;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Indexer
     * @param index A zero based index
     * @return
     */
    item(a: number): Series;
    /**
     * Returns the number of items in the collection (read-only)
     */
    readonly count: number;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    readonly isReadOnly: boolean;
    /**
     * Adds a new series to the collection
     * @return The newly added [[Series]]
     */
    add(): Series;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: Series): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Series>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Series>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: Series): number;
    /**
     * Inserts a new [[Series]] into the collection at the specified index.
     * @param index The index to insert the new series
     * @return The newly inserted [[Series]]
     */
    insert(index: number): Series;
    /**
     * @hidden
     */
    private _at;
    /**
     * Removes an item from the collection.
     * @param item The series to remove
     * @return True if the series was removed, otherwise false.
     */
    remove(item: Series): boolean;
    /**
     * Removes the series at the specified index
     * @param index The zero-based index
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _a0(): void;
    /**
     * @hidden
     */
    _a1(a: number): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _a2;
    /**
     * @hidden
     */
    private static _a3;
    /**
     * @hidden
     */
    _az(a: boolean, b?: boolean): void;
    /**
     * @hidden
     */
    _ay(a: MarkerStyle): void;
    /**
     * @hidden
     */
    _aw(a: ChartType, b: ChartType): void;
    /**
     * @hidden
     */
    _ax(a: ChartFillBase): void;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    _aq(a: Series): Nullable$1<number>;
    /**
     * @hidden
     */
    _ad(a: SeriesType): boolean;
    /**
     * @hidden
     */
    readonly _ae: boolean;
    /**
     * @hidden
     */
    readonly _ah: boolean;
    /**
     * @hidden
     */
    _ak(a: Nullable$1<SeriesType>, b: Nullable$1<AxisGroup>, c?: Series): List$1<Series>;
    /**
     * @hidden
     */
    _as(a: boolean, b: boolean): {
        p0: boolean;
        p1: boolean;
    };
}
/**
 * @hidden
 */
export declare class SeriesCollection_PlotOrderSortItem extends Base {
    static $t: Type;
    a: Series;
    b: number;
    c: number;
}
/**
 * @hidden
 */
export declare class SeriesCollection_PlotOrderSortComparer extends Base implements IComparer$1<SeriesCollection_PlotOrderSortItem> {
    static $t: Type;
    compare(a: SeriesCollection_PlotOrderSortItem, b: SeriesCollection_PlotOrderSortItem): number;
}
/**
 * Represents the tick-mark labels associated with tick marks on a chart [[Axis]].
 */
export declare class TickLabels extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a1;
    /**
     * @hidden
     */
    private static readonly _a3;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _at;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ai;
    private _z;
    private _al;
    private _ap;
    private _aq;
    private _bd;
    private _ar;
    private _a0;
    private _ac;
    private _ax;
    private _af;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Specifies the alignment of the tick labels
     */
    /**
    * Specifies the alignment of the tick labels
    */
    alignment: TickLabelAlignment;
    /**
     * Specifies which font to use. Read-only.
     * <para class="note"><b>Note:</b> this property will return null until the [[TickLabels]]
     * is set on the <see cref="Axis.TickLabels">Axis.TickLabels</see> property.</para>
     */
    readonly font: IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    readonly _ao: WorkbookColorInfo;
    /**
     * @hidden
     */
    readonly _an: IWorkbookFont;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill applied to the background of tick labels.
     * <p class="body">
     * This property is not applicable for <i>BoxAndWhisker</i>, <i>Histogram</i>,
     * <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, or <i>Waterfall</i> charts.
     * </p>
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill applied to the background of tick labels.
    * <p class="body">
    * This property is not applicable for <i>BoxAndWhisker</i>, <i>Histogram</i>,
    * <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, or <i>Waterfall</i> charts.
    * </p>
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _ab: ChartFillBase;
    /**
     * Specifies whether an axis is multilevel or not.
     */
    /**
    * Specifies whether an axis is multilevel or not.
    */
    multiLevel: boolean;
    /**
     * Returns or sets the format to use for numbers.
     * <p class="body">
     * Note that in some cases it may be necessary to set [[numberFormatLinked]]
     * to false in order to see the format applied. If the tick labels are not displaying the
     * format you specified, try setting NumberFormatLinked to false.
     * </p>
     * @see [[numberFormatLinked]]
     */
    /**
    * Returns or sets the format to use for numbers.
    * <p class="body">
    * Note that in some cases it may be necessary to set [[numberFormatLinked]]
    * to false in order to see the format applied. If the tick labels are not displaying the
    * format you specified, try setting NumberFormatLinked to false.
    * </p>
    * @see [[numberFormatLinked]]
    */
    numberFormat: string;
    /**
     * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
     * <p class="body">
     * Note that in some cases it may be necessary to set this property
     * to false in order to see the [[numberFormat]] applied.
     * If the tick labels are not displaying the format you specified,
     * try setting this property to false.
     * </p>
     * @see [[numberFormat]]
     */
    /**
    * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
    * <p class="body">
    * Note that in some cases it may be necessary to set this property
    * to false in order to see the [[numberFormat]] applied.
    * If the tick labels are not displaying the format you specified,
    * try setting this property to false.
    * </p>
    * @see [[numberFormat]]
    */
    numberFormatLinked: boolean;
    /**
     * Returns or sets a Long value that represents the distance between the levels of labels, and the distance between the first level and the axis line.
     */
    /**
    * Returns or sets a Long value that represents the distance between the levels of labels, and the distance between the first level and the axis line.
    */
    offset: number;
    /**
     * Determines the reading order
     */
    /**
    * Determines the reading order
    */
    readingOrder: ReadingOrder;
    /**
     * Determines the rotation of the text area, expressed in degrees.
     * <p class="body">
     * The Rotation property is only applicable when [[textDirection]]
     * is set to <i>Horizontal</i>.
     * </p>
     * @see [[textDirection]]
     */
    /**
    * Determines the rotation of the text area, expressed in degrees.
    * <p class="body">
    * The Rotation property is only applicable when [[textDirection]]
    * is set to <i>Horizontal</i>.
    * </p>
    * @see [[textDirection]]
    */
    rotation: number;
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    /**
    * Determines the orientation and direction in which text flows.
    * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
    * @see [[rotation]]
    */
    textDirection: TextDirection;
    /**
     * @hidden
     */
    _aw(): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the bar which depicts gain or loss on a stock chart.
 */
export declare class UpDownBar extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    static readonly _ah: number;
    private _ae;
    private _z;
    private _ab;
    constructor(a: UpDownBars, b: UpDownBarType);
    /**
     * Returns a value which identifies this instance as as up or down bar.
     */
    readonly barType: UpDownBarType;
    /**
     * Determines the appearance of the border drawn around
     * the bar, as well as whether a border appears.
     * @see [[fill]]
     */
    /**
    * Determines the appearance of the border drawn around
    * the bar, as well as whether a border appears.
    * @see [[fill]]
    */
    border: ChartBorder;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the bar.
     * @see [[border]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill properties for the bar.
    * @see [[border]]
    */
    fill: ChartFillBase;
    /**
     * @hidden
     */
    readonly _ad: ChartFillBase;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the walls and floor of a 3-D chart.
 * This object isn't a collection. There's no object
 * that represents a single wall; you must return all
 * the walls as a unit.
 */
export declare class Wall extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ab;
    private _ae;
    constructor(a: IChartObject, b: WallType);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     * @see [[fill]]
     */
    /**
    * Determines the appearance of the border drawn around
    * the text area, as well as whether a border appears.
    * @see [[fill]]
    */
    border: ChartBorder;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill for this series.
     * @see [[border]]
     */
    /**
    * Returns or sets a [[ChartFillBase]] derived object
    * which defines the fill for this series.
    * @see [[border]]
    */
    fill: ChartFillBase;
    /**
     * The thickness of the wall
     */
    /**
    * The thickness of the wall
    */
    thickness: number;
    private _type;
    /**
     * Returns the type of the wall, i.e., back, side, floor, or all.
     */
    /**
    * Returns the type of the wall, i.e., back, side, floor, or all.
    */
    type: WallType;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Extend the class ArgumentException to add a constructor
 */
export declare class ArgumentExceptionExtension extends ArgumentException {
    static $t: Type;
    constructor(message?: string, innerException?: BaseError);
    constructor(message: string, paramName: string, innerException?: BaseError);
    constructor(..._rest: any[]);
}
/**
 * @hidden
 */
export declare class ExcelImage extends Base {
    static $t: Type;
    private readonly a;
    private readonly c;
    readonly g: number;
    readonly f: number;
    readonly e: boolean;
    readonly h: Nullable$1<Guid>;
    constructor(a: number, b: ImageFormat, c: Stream, d: number, e: number, f: boolean, g: Guid);
    constructor(a: number, b: ImageFormat, c: Stream);
    constructor(a: number, ..._rest: any[]);
    readonly b: number[];
    readonly d: ImageFormat;
    i(a: Stream, b: ImageFormat): void;
}
/**
 * @hidden
 */
export declare class DdeItem extends Base {
    static $t: Type;
    readonly a: boolean;
    readonly b: boolean;
    readonly d: string;
    readonly c: boolean;
    constructor(a: string, b: boolean, c: boolean, d: boolean);
}
/**
 * @hidden
 */
export declare class DdeLinkNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: DdeLinkWorkbookReference, b: any);
    protected get__f(): RefBase;
    readonly _f: RefBase;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get__z(): CultureInfo;
    readonly _z: CultureInfo;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    readonly _k: Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare abstract class WorkbookReferenceBase extends Base {
    static $t: Type;
    private p;
    private q;
    private v;
    private s;
    private k;
    private r;
    constructor(a: Workbook);
    abstract b(a: string, b: any, c: boolean): NamedReferenceBase;
    abstract h(a: number): WorksheetReferenceSingle;
    abstract aa(a: number): string;
    abstract j(a: string): WorksheetReferenceSingle;
    abstract ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    ac(): void;
    d(a: FormulaContext): WorkbookReferenceBase;
    e(): WorkbookReferenceUnconnected;
    f(a: WorksheetReferenceSingle, b: WorksheetReferenceSingle): WorksheetReference;
    c(a: string, b: any, c: boolean): NamedReferenceBase;
    z(a: GetFormulaStringInfo, b?: boolean): string;
    g(a: string, b: string): WorksheetReference;
    i(a: number): WorksheetReferenceSingle;
    ad(): void;
    ae(a: number): void;
    protected y(a: GetFormulaStringInfo, b: boolean): {
        ret: string;
        p1: boolean;
    };
    protected o(a: string): Dictionary$2<any, NamedReferenceBase>;
    protected get_x(): string;
    readonly x: string;
    protected get_m(): boolean;
    readonly m: boolean;
    abstract readonly n: boolean;
    protected abstract readonly a: FormulaType;
    protected readonly t: List$1<NamedReferenceBase>;
    readonly u: ReadOnlyCollection$1<NamedReferenceBase>;
    readonly l: Workbook;
    protected get_w(): any;
    readonly w: any;
}
/**
 * @hidden
 */
export declare class DdeLinkWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly ah;
    private readonly ai;
    constructor(a: string, b: string, c: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_x(): string;
    static aj(a: string, b: string): string;
    protected get_n(): boolean;
    readonly n: boolean;
    readonly ag: List$1<DdeItem>;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
    readonly ak: string;
    readonly al: string;
}
/**
 * @hidden
 */
export declare class AddInFunctionNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: AddInFunctionsWorkbookReference, b: any);
    protected get__f(): RefBase;
    readonly _f: RefBase;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get__z(): CultureInfo;
    readonly _z: CultureInfo;
    protected get__l(): WorkbookFormat;
    toString(): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    readonly _k: Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class AddInFunctionsWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    constructor(a: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    readonly n: boolean;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
}
/**
 * @hidden
 */
export declare class CurrentWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private ai;
    private af;
    constructor(a: Workbook);
    b(a: string, b: any, c?: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ag(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    readonly n: boolean;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
    protected get_w(): any;
    aj(a: NamedReference): void;
    private ah;
    ak(a: Worksheet): void;
}
/**
 * @hidden
 */
export declare class ExternalNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    private _bg;
    constructor(a: ExternalWorkbookReference, b: any);
    protected get__f(): RefBase;
    readonly _f: RefBase;
    protected get__z(): CultureInfo;
    readonly _z: CultureInfo;
    protected get__l(): WorkbookFormat;
    _a6(a: boolean): void;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__k(): Workbook;
    readonly _k: Workbook;
    protected get__h(): WorkbookReferenceBase;
    protected get__n(): boolean;
    readonly _n: boolean;
}
/**
 * @hidden
 */
export declare class ExternalWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private ah;
    private af;
    constructor(a: string, b: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    readonly n: boolean;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
    toString(): string;
    readonly ag: List$1<string>;
}
/**
 * @hidden
 */
export declare class GetFormulaStringInfo extends Base {
    static $t: Type;
    static a: GetFormulaStringInfo;
    readonly c: Dictionary$2<WorkbookReferenceBase, number>;
    readonly b: boolean;
    constructor(a: Dictionary$2<WorkbookReferenceBase, number>, b: boolean);
}
/**
 * @hidden
 */
export declare class ImageHolder extends Base {
    static $t: Type;
    private a;
    private c;
    constructor(a: ExcelImage, b: ImageFormat);
    readonly b: ExcelImage;
    readonly d: ImageFormat;
}
/**
 * @hidden
 */
export declare abstract class MultipleCellValueInfo extends Base {
    static $t: Type;
    private e;
    private a;
    private g;
    private h;
    private i;
    constructor(a: WorksheetRow, b: WorksheetRowSerializationCache, c: List$1<WorksheetCellFormatData>, d: List$1<number>, e: List$1<any>);
    d(a: number): WorksheetCellFormatData;
    private static c;
    static f(a: WorkbookSaveManager, b: (saveManager: WorkbookSaveManager, row: WorksheetRow, cellDataContext: CellDataContext, value: any) => {
        ret: boolean;
        p3: any;
    }, c: List$1<WorksheetCellFormatData>, d: List$1<number>, e: List$1<any>): {
        ret: boolean;
        p2: List$1<WorksheetCellFormatData>;
        p3: List$1<number>;
        p4: List$1<any>;
    };
    n(a: number): any;
    readonly j: number;
    readonly k: number;
    readonly l: number;
    readonly b: WorksheetRowSerializationCache;
    readonly m: number;
}
/**
 * @hidden
 */
export declare class MultipleCellBlankInfo extends MultipleCellValueInfo {
    static $t: Type;
    private static readonly p;
    constructor(a: WorksheetRow, b: WorksheetRowSerializationCache, c: List$1<WorksheetCellFormatData>, d: List$1<number>, e: List$1<any>);
    static o(a: WorkbookSaveManager): MultipleCellBlankInfo;
    private static q;
}
/**
 * @hidden
 */
export declare class MultipleCellRKInfo extends MultipleCellValueInfo {
    static $t: Type;
    private static readonly p;
    constructor(a: WorksheetRow, b: WorksheetRowSerializationCache, c: List$1<WorksheetCellFormatData>, d: List$1<number>, e: List$1<any>);
    static o(a: WorkbookSaveManager): MultipleCellRKInfo;
    private static q;
}
/**
 * @hidden
 */
export declare class OleItem extends Base {
    static $t: Type;
    readonly a: boolean;
    readonly b: boolean;
    readonly d: string;
    readonly c: boolean;
    constructor(a: string, b: boolean, c: boolean, d: boolean);
}
/**
 * @hidden
 */
export declare class OleLinkNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: OleLinkWorkbookReference, b: any);
    protected get__f(): RefBase;
    readonly _f: RefBase;
    protected get__n(): boolean;
    readonly _n: boolean;
    protected get__z(): CultureInfo;
    readonly _z: CultureInfo;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    readonly _k: Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class OleLinkWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly aj;
    private readonly ah;
    constructor(a: string, b: Uri, c: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_x(): string;
    protected get_n(): boolean;
    readonly n: boolean;
    readonly ag: List$1<OleItem>;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
    readonly ak: Uri;
    readonly ai: string;
}
/**
 * @hidden
 */
export declare class PivotCacheInfo extends Base {
    static $t: Type;
    readonly b: number;
    readonly a: RoundTripControlData;
    constructor(a: RoundTripControlData, b: number);
}
/**
 * @hidden
 */
export declare class PivotTableInfo extends Base {
    static $t: Type;
    readonly b: any;
    readonly a: RoundTripControlData;
    constructor(a: any, b: RoundTripControlData);
}
/**
 * @hidden
 */
export declare abstract class WorkbookLoadManager extends WorkbookSerializationManager {
    static $t: Type;
    private readonly _t;
    constructor(a: Workbook, b: string);
    abstract _r(): WorksheetCellFormatData;
    protected abstract _p(): WorkItem;
    _y(a: NamedReference, b: boolean): void;
    static _v(a: Workbook, b: string, c: string): any;
    _ae(a: CT_Transform2D, b: number, c: CT_GroupTransform2D, d: Rect): Rect;
    _q(a: number): WorksheetReference;
    _o(): WorkItem;
    _z(): void;
    _ac<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: (arg1: T, arg2: CellFormatValue) => boolean, d: WorkbookStyle, e: WorksheetCellFormatData): void;
    _ad<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: (arg1: T, arg2: CellFormatValue) => boolean, d: WorkbookStyle, e: WorksheetCellFormatData, f: WorksheetCellFormatData, ...g: CellFormatValue[]): void;
    private static _aa;
    private static _ab;
    private _s;
    private static _w;
    private static readonly _x;
    readonly _u: List$1<StringElement>;
}
/**
 * @hidden
 */
export declare class WorkbookReferenceUnconnected extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly ag;
    constructor(a: string, b: boolean);
    d(a: FormulaContext): WorkbookReferenceBase;
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_m(): boolean;
    protected get_n(): boolean;
    readonly n: boolean;
    protected get_a(): FormulaType;
    protected readonly a: FormulaType;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_InitSerializationCacheFormulaHelper extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private az;
    constructor();
    g(): void;
    aj(a: NameToken): void;
    aq(a: ReferenceToken): void;
    aw(a: StructuredTableReference): void;
    static a1(a: FormulaContext, b: WorkbookSaveManager): WorkbookSaveManager_InitSerializationCacheFormulaHelper;
    private a2;
    private a3;
    private a4;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_InitSerializationCacheHelper extends WorksheetShapeVisitor$2<WorkbookSaveManager, boolean> implements IStringElementVisitor$2<Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>, boolean> {
    static $t: Type;
    static readonly d: WorkbookSaveManager_InitSerializationCacheHelper;
    constructor();
    _visitFormattedStringElement$i(a: FormattedStringElement, b: Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>): boolean;
    _visitStringElement$i(a: StringElement, b: Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>): boolean;
    visitWorksheetCellComment(value: WorksheetCellComment, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: WorkbookSaveManager): boolean;
    visitWorksheetChart(value: WorksheetChart, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetChart$i(a: WorksheetChart, b: WorkbookSaveManager): boolean;
    visitWorksheetShapeGroup(value: WorksheetShapeGroupBase, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: WorkbookSaveManager): boolean;
    c(a: WorksheetShapeWithText, b: WorkbookSaveManager): boolean;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_ColorSortConditionVisitorProxy$1<TArg> extends Base implements IColorSortConditionVisitor$2<TArg, boolean> {
    static $t: Type;
    protected $tArg: Type;
    private readonly a;
    private readonly c;
    private readonly d;
    private readonly e;
    constructor($tArg: Type, a: WorkbookSaveManager, b: boolean, c: boolean, d: Dictionary$2<TArg, number>);
    private b;
    visitFillSortCondition(value: FillSortCondition, arg: TArg): boolean;
    _visitFillSortCondition$i(a: FillSortCondition, b: TArg): boolean;
    visitFontColorSortCondition(value: FontColorSortCondition, arg: TArg): boolean;
    _visitFontColorSortCondition$i(a: FontColorSortCondition, b: TArg): boolean;
}
/**
 * @hidden
 */
export declare class CellContext extends Base {
    static $t: Type;
    constructor(a: WorksheetRow, b: WorksheetRowSerializationCache);
    b: WorksheetRow;
    a: WorksheetRowSerializationCache;
    c: any;
}
/**
 * @hidden
 */
export declare abstract class WorksheetReference extends Base {
    static $t: Type;
    private d;
    constructor(a: WorkbookReferenceBase);
    f(a: FormulaContext): WorksheetReference;
    g(a: WorkbookReferenceBase): WorksheetReference;
    abstract h(): WorksheetReference;
    abstract a(a: WorksheetCellAddress): IExcelCalcReference;
    abstract b(a: WorksheetRegionAddress): IExcelCalcReference;
    abstract o(a: GetFormulaStringInfo, b: boolean): string;
    abstract readonly l: number;
    abstract c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    readonly i: boolean;
    abstract readonly j: boolean;
    abstract readonly k: boolean;
    protected get_m(): number;
    readonly m: number;
    protected get_n(): any;
    readonly n: any;
    readonly p: string;
    readonly e: WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare abstract class WorksheetReferenceSingle extends WorksheetReference {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    h(): WorksheetReference;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_k(): boolean;
    readonly k: boolean;
    abstract q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    abstract r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    abstract readonly s: string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceError extends WorksheetReferenceSingle {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    g(a: WorkbookReferenceBase): WorksheetReference;
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_s(): string;
    readonly s: string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceExternal extends WorksheetReferenceSingle {
    static $t: Type;
    private w;
    private v;
    private y;
    constructor(a: WorkbookReferenceBase, b: number);
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_s(): string;
    readonly s: string;
    z(a: number, b: number): any;
    t(a: number): WorksheetReferenceExternalRowValues;
    aa(a: number, b: number, c: any): void;
    u(a: number): WorksheetReferenceExternalRowValues;
    readonly x: IEnumerable$1<WorksheetReferenceExternalRowValues>;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceExternalRowValues extends Base {
    static $t: Type;
    private d;
    private c;
    private b;
    private f;
    constructor(a: WorksheetReferenceExternal, b: number);
    h(a: number): any;
    a(a: number): IExcelCalcReference;
    i(a: number, b: any): void;
    readonly e: IEnumerable$1<KeyValuePair$2<number, any>>;
    readonly g: number;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceLocal extends WorksheetReferenceSingle {
    static $t: Type;
    private t;
    constructor(a: CurrentWorkbookReference, b: Worksheet);
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_s(): string;
    readonly s: string;
    protected get_n(): any;
    readonly u: Worksheet;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceSingleUnconnected extends WorksheetReferenceSingle {
    static $t: Type;
    private t;
    constructor(a: number, b: string, c: string);
    constructor(a: number, b: WorkbookReferenceUnconnected, c: string);
    constructor(a: number, ..._rest: any[]);
    g(a: WorkbookReferenceBase): WorksheetReference;
    h(): WorksheetReference;
    equals(a: any): boolean;
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    getHashCode(): number;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_i(): boolean;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_s(): string;
    readonly s: string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceToWorkbook extends WorksheetReferenceSingle {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    g(a: WorkbookReferenceBase): WorksheetReference;
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_s(): string;
    readonly s: string;
    protected get_n(): any;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceMulti extends WorksheetReference {
    static $t: Type;
    private q;
    private s;
    constructor(a: WorksheetReferenceSingle, b: WorksheetReferenceSingle);
    g(a: WorkbookReferenceBase): WorksheetReference;
    h(): WorksheetReference;
    protected get_l(): number;
    readonly l: number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_i(): boolean;
    protected get_j(): boolean;
    readonly j: boolean;
    protected get_k(): boolean;
    readonly k: boolean;
    protected get_m(): number;
    protected get_n(): any;
    readonly r: WorksheetReferenceSingle;
    readonly t: WorksheetReferenceSingle;
}
/**
 * @hidden
 */
export declare class WorksheetRowSerializationCache extends Base {
    static $t: Type;
    readonly a: boolean;
    readonly b: boolean;
    readonly c: number;
    readonly d: number;
    constructor(a: boolean, b: boolean, c: number, d: number);
}
/**
 * @hidden
 */
export declare class SheetSerializationCache extends Base {
    static $t: Type;
    a: string;
    b: number;
    c: number;
    d: number;
}
/**
 * @hidden
 */
export declare class WorksheetSerializationCache extends SheetSerializationCache {
    static $t: Type;
    readonly n: number;
    readonly o: number;
    readonly p: number;
    readonly q: number;
    readonly e: number;
    readonly f: number;
    readonly k: number;
    private readonly i;
    readonly g: Dictionary$2<number, number>;
    readonly h: Dictionary$2<number, number>;
    constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number);
    readonly j: List$1<WorksheetCellComment>;
    l(a: number): Nullable$1<number>;
    m(a: number): Nullable$1<number>;
}
/**
 * @hidden
 */
export interface IBiffRecordStream {
    parentStreamRaw: IBiffRecordStream;
    readonly endUnderlyingStreamPosition: number;
    readonly saveManager: WorkbookSaveManager;
    readByteFromBuffer(a: number[], b: number): {
        ret: number;
        p0?: number[];
        p1?: number;
    };
    readBytesFromBuffer(a: number, b: number[], c: number): {
        ret: number[];
        p1?: number[];
        p2?: number;
    };
    readDoubleFromBuffer(a: number[], b: number): {
        ret: number;
        p0?: number[];
        p1?: number;
    };
    readFormattedStringFromBuffer(a: LengthType, b: number[], c: number): {
        ret: StringElement;
        p1?: number[];
        p2?: number;
    };
    writeByte(a: number): void;
    writeByteArray(a: number[]): void;
    writeDouble(a: number): void;
    writeString(a: string, b: LengthType): void;
    writeFullColorExt(a: WorkbookColorInfo, b: ColorableItem): void;
    writeXFExtGradient(a: CellFillGradient): void;
}
/**
 * @hidden
 */
export declare let IBiffRecordStream_$type: Type;
/**
 * @hidden
 */
export declare class ConditionalFormattingUtils extends Base {
    static $t: Type;
    static g(a: ThresholdConditionBase): string;
    static d(a: ConditionalFormatBase): string;
    static f(a: TextOperatorConditionalFormat): string;
    static e(a: DateTimeConditionalFormat): string;
    private static a;
    private static c;
    private static b;
}
/**
 * @hidden
 */
export declare class FullColorExtInfo extends Base {
    static $t: Type;
    a: XColorType;
    b: number;
    c: number;
}
/**
 * @hidden
 */
export declare class GradStopInfo extends Base {
    static $t: Type;
    a: XColorType;
    d: number;
    b: number;
    c: number;
}
/**
 * @hidden
 */
export declare class XFExtGradientInfo extends Base {
    static $t: Type;
    g: number;
    b: number;
    d: number;
    e: number;
    f: number;
    c: number;
    a: GradStopInfo[];
}
/**
 * @hidden
 */
export declare class XFPropColorInfo extends Base {
    static $t: Type;
    b: number;
    a: number;
    c: number;
    d: number;
}
/**
 * @hidden
 */
export declare abstract class ExtProp extends Base {
    static $t: Type;
    abstract b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    abstract readonly a: ExtPropType;
    abstract c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class ExtPropColorBase extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: ExtPropType);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    readonly a: ExtPropType;
    c(a: IBiffRecordStream): void;
    abstract e(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ExtPropColor extends ExtPropColorBase {
    static $t: Type;
    private f;
    constructor(a: WorkbookColorInfo, b: ExtPropType);
    e(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ExtPropColorLoaded extends ExtPropColorBase {
    static $t: Type;
    private f;
    constructor(a: FullColorExtInfo, b: ExtPropType);
    e(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ExtPropFontScheme extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: FontScheme);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    readonly a: ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class ExtPropGradientFillBase extends ExtProp {
    static $t: Type;
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    c(a: IBiffRecordStream): void;
    abstract d(a: Workbook): CellFillGradient;
}
/**
 * @hidden
 */
export declare class ExtPropGradientFill extends ExtPropGradientFillBase {
    static $t: Type;
    private e;
    constructor(a: CellFillGradient);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    d(a: Workbook): CellFillGradient;
    protected get_a(): ExtPropType;
    readonly a: ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare class ExtPropGradientFillLoaded extends ExtPropGradientFillBase {
    static $t: Type;
    private e;
    constructor(a: XFExtGradientInfo);
    d(a: Workbook): CellFillGradient;
    protected get_a(): ExtPropType;
    readonly a: ExtPropType;
}
/**
 * @hidden
 */
export declare class ExtPropTextIndentationLevel extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: number);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    readonly a: ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class XFProp extends Base {
    static $t: Type;
    abstract b(a: Workbook, b: WorksheetCellFormatData): void;
    abstract readonly a: XFPropType;
}
/**
 * @hidden
 */
export declare class XFPropBool extends XFProp {
    static $t: Type;
    private d;
    private c;
    constructor(a: number, b: XFPropType, c: boolean);
    constructor(a: number, b: XFPropType, c: Nullable$1<boolean>);
    constructor(a: number, b: XFPropType, c: number);
    constructor(a: number, ..._rest: any[]);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly e: boolean;
    readonly f: number;
}
/**
 * @hidden
 */
export declare abstract class XFPropBorderBase extends XFProp {
    static $t: Type;
    private c;
    private e;
    constructor(a: XFPropType, b: CellBorderLineStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: CellBorderLineStyle;
    abstract f(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropBorder extends XFPropBorderBase {
    static $t: Type;
    private g;
    constructor(a: XFPropType, b: WorkbookColorInfo, c: CellBorderLineStyle);
    f(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropBorderLoaded extends XFPropBorderBase {
    static $t: Type;
    private g;
    constructor(a: XFPropType, b: XFPropColorInfo, c: CellBorderLineStyle);
    f(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropByte extends XFProp {
    static $t: Type;
    private c;
    private d;
    constructor(a: XFPropType, b: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly e: number;
}
/**
 * @hidden
 */
export declare abstract class XFPropColorBase extends XFProp {
    static $t: Type;
    b(a: Workbook, b: WorksheetCellFormatData): void;
    abstract c(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropColor extends XFPropColorBase {
    static $t: Type;
    private e;
    private d;
    constructor(a: XFPropType, b: WorkbookColorInfo);
    c(a: Workbook): WorkbookColorInfo;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly f: WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropColorLoaded extends XFPropColorBase {
    static $t: Type;
    private d;
    private e;
    constructor(a: XFPropType, b: XFPropColorInfo);
    c(a: Workbook): WorkbookColorInfo;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
}
/**
 * @hidden
 */
export declare class XFPropFillPattern extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FillPatternStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: FillPatternStyle;
}
/**
 * @hidden
 */
export declare class XFPropFontBold extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number, b: number);
    constructor(a: number, b: Nullable$1<boolean>);
    constructor(a: number, ..._rest: any[]);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: boolean;
    readonly e: number;
}
/**
 * @hidden
 */
export declare class XFPropFontHeight extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: number;
}
/**
 * @hidden
 */
export declare class XFPropFontName extends XFProp {
    static $t: Type;
    private c;
    constructor(a: string);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: string;
}
/**
 * @hidden
 */
export declare class XFPropFontSubscriptSuperscript extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontSuperscriptSubscriptStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: FontSuperscriptSubscriptStyle;
}
/**
 * @hidden
 */
export declare class XFPropFontScheme extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontScheme);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: FontScheme;
}
/**
 * @hidden
 */
export declare class XFPropFontUnderline extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontUnderlineStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: FontUnderlineStyle;
}
/**
 * @hidden
 */
export declare class XFPropGradientFill extends XFProp {
    static $t: Type;
    private c;
    private e;
    private g;
    private h;
    private i;
    private f;
    constructor(a: boolean, b: number, c: number, d: number, e: number, f: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: boolean;
    readonly j: number;
    readonly l: number;
    readonly m: number;
    readonly n: number;
    readonly k: number;
}
/**
 * @hidden
 */
export declare abstract class XFPropGradientStopBase extends XFProp {
    static $t: Type;
    private d;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    abstract c(a: Workbook): WorkbookColorInfo;
    readonly e: number;
}
/**
 * @hidden
 */
export declare class XFPropGradientStop extends XFPropGradientStopBase {
    static $t: Type;
    private f;
    constructor(a: WorkbookColorInfo, b: number);
    c(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropGradientStopLoaded extends XFPropGradientStopBase {
    static $t: Type;
    private f;
    constructor(a: XFPropColorInfo, b: number);
    c(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropHorizontalAlignment extends XFProp {
    static $t: Type;
    private c;
    constructor(a: HorizontalCellAlignment);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: HorizontalCellAlignment;
}
/**
 * @hidden
 */
export declare class XFPropNumberFormat extends XFProp {
    static $t: Type;
    private e;
    private c;
    constructor(a: number, b: string);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly f: number;
    readonly d: string;
}
/**
 * @hidden
 */
export declare class XFPropNumberFormatId extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: number;
}
/**
 * @hidden
 */
export declare class XFPropTextIndentationLevel extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: number;
}
/**
 * @hidden
 */
export declare class XFPropTextIndentationLevelRelative extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: number;
}
/**
 * @hidden
 */
export declare class XFPropTextRotation extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: number;
}
/**
 * @hidden
 */
export declare class XFPropVerticalAlignment extends XFProp {
    static $t: Type;
    private c;
    constructor(a: VerticalCellAlignment);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    readonly a: XFPropType;
    readonly d: VerticalCellAlignment;
}
/**
 * @hidden
 */
export declare class FtCbls extends Base {
    static $t: Type;
    b: number;
    c: number;
    d: number;
    constructor();
}
/**
 * @hidden
 */
export declare class FtCblsData extends Base {
    static $t: Type;
    c: number;
    b: number;
    a: boolean;
    constructor();
}
/**
 * @hidden
 */
export declare class FtCf extends Base {
    static $t: Type;
    a: PictureClipboardFormat;
    constructor();
    readonly b: PictureClipboardFormat;
}
/**
 * @hidden
 */
export declare class FtCmo extends Base {
    static $t: Type;
    a: ObjectType;
    s: number;
    u: number;
    w: number;
    x: number;
    y: number;
    constructor(a: number);
    constructor(a: number, b: ObjectType);
    constructor(a: number, ..._rest: any[]);
    readonly c: boolean;
    readonly d: boolean;
    readonly e: boolean;
    readonly f: boolean;
    readonly g: boolean;
    readonly h: boolean;
    readonly i: boolean;
    readonly j: boolean;
    t: number;
    readonly b: ObjectType;
}
/**
 * @hidden
 */
export declare class FtEdoData extends Base {
    static $t: Type;
    d: number;
    a: boolean;
    b: boolean;
    c: number;
    constructor();
}
/**
 * @hidden
 */
export declare class FtGboData extends Base {
    static $t: Type;
    b: number;
    a: boolean;
    constructor();
}
/**
 * @hidden
 */
export declare class FtGmo extends Base {
    static $t: Type;
    b: number;
    constructor();
}
/**
 * @hidden
 */
export declare class FtLbsData extends Base {
    static $t: Type;
    f: number;
    d: ObjFmla;
    g: number;
    j: number;
    h: number;
    i: number;
    c: LbsDropData;
    b: string[];
    a: boolean[];
    constructor();
    readonly e: ObjFmla;
}
/**
 * @hidden
 */
export declare class FtMacro extends Base {
    static $t: Type;
    b: ObjFmla;
    constructor();
    a(): Formula;
    readonly c: ObjFmla;
}
/**
 * @hidden
 */
export declare class FtNts extends Base {
    static $t: Type;
    a: Guid;
    b: number;
    d: number;
    constructor();
}
/**
 * @hidden
 */
export declare class FtPictFmla extends Base {
    static $t: Type;
    b: ObjFmla;
    g: number;
    f: number;
    d: PictFmlaKey;
    constructor();
    a(): Formula;
    readonly c: ObjFmla;
    readonly e: PictFmlaKey;
}
/**
 * @hidden
 */
export declare class FtPioGrbit extends Base {
    static $t: Type;
    j: number;
    constructor(a: boolean);
    readonly a: boolean;
    readonly b: boolean;
    readonly c: boolean;
    readonly d: boolean;
    readonly e: boolean;
    readonly f: boolean;
    readonly g: boolean;
    readonly i: boolean;
    readonly h: boolean;
}
/**
 * @hidden
 */
export declare class FtRbo extends Base {
    static $t: Type;
    c: number;
    b: number;
    constructor();
}
/**
 * @hidden
 */
export declare class FtRboData extends Base {
    static $t: Type;
    d: number;
    a: WorksheetShape;
    c: boolean;
    constructor();
    readonly e: number;
    b: WorksheetShape;
}
/**
 * @hidden
 */
export declare class FtSbs extends Base {
    static $t: Type;
    j: number;
    h: number;
    g: number;
    f: number;
    a: number;
    b: number;
    d: number;
    c: number;
    e: number;
    constructor();
}
/**
 * @hidden
 */
export declare class LbsDropData extends Base {
    static $t: Type;
    a: number;
    c: number;
    d: number;
    b: string;
    constructor();
}
/**
 * @hidden
 */
export declare class Obj extends Base {
    static $t: Type;
    d: FtCmo;
    h: FtGmo;
    c: FtCf;
    p: FtPioGrbit;
    a: FtCbls;
    r: FtRbo;
    u: FtSbs;
    m: FtNts;
    k: FtMacro;
    n: FtPictFmla;
    v: ObjLinkFmla;
    b: FtCblsData;
    s: FtRboData;
    f: FtEdoData;
    i: FtLbsData;
    g: FtGboData;
    constructor(a: number);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    readonly e: FtCmo;
    readonly w: ObjLinkFmla;
    readonly j: FtLbsData;
    readonly l: FtMacro;
    readonly q: FtPioGrbit;
    readonly o: FtPictFmla;
    readonly t: FtRboData;
}
/**
 * @hidden
 */
export declare class ObjectParsedFormula extends Base {
    static $t: Type;
    c: number;
    b: Rgce;
    constructor();
    a(): Formula;
}
/**
 * @hidden
 */
export declare class ObjFmla extends Base {
    static $t: Type;
    b: ObjectParsedFormula;
    d: PictFmlaEmbedInfo;
    constructor();
    a(): Formula;
    f(a: Sheet, b: (arg1: Sheet, arg2: Formula) => void): void;
    readonly e: PictFmlaEmbedInfo;
    readonly c: ObjectParsedFormula;
}
/**
 * @hidden
 */
export declare class ObjLinkFmla extends Base {
    static $t: Type;
    a: ObjFmla;
    constructor();
    readonly b: ObjFmla;
}
/**
 * @hidden
 */
export declare class PictFmlaEmbedInfo extends Base {
    static $t: Type;
    a: string;
    constructor();
    readonly b: string;
}
/**
 * @hidden
 */
export declare class PictFmlaKey extends Base {
    static $t: Type;
    a: number[];
    b: ObjFmla;
    d: ObjFmla;
    constructor();
    readonly c: ObjFmla;
    readonly e: ObjFmla;
}
/**
 * @hidden
 */
export declare class Rgce extends Base {
    static $t: Type;
    a: Formula;
    constructor();
    readonly b: Formula;
}
/**
 * @hidden
 */
export interface IEscherRecord {
}
/**
 * @hidden
 */
export declare let IEscherRecord_$type: Type;
/**
 * @hidden
 */
export interface ICalloutRule extends IEscherRecord {
    shapeId: number;
}
/**
 * @hidden
 */
export declare let ICalloutRule_$type: Type;
/**
 * @hidden
 */
export declare class PropertyTableBase_PropertyValue extends Base implements IComparable$1<PropertyTableBase_PropertyValue> {
    static $t: Type;
    private _a;
    private _e;
    private _c;
    private _h;
    constructor(a: number, b: PropertyType, c: any);
    constructor(a: number, b: PropertyType, c: any, d: boolean, e: boolean);
    constructor(a: number, ..._rest: any[]);
    readonly _d: boolean;
    readonly _f: boolean;
    readonly _g: boolean;
    readonly _b: PropertyType;
    _i: any;
    compareTo(a: PropertyTableBase_PropertyValue): number;
}
/**
 * @hidden
 */
export interface IValueFormatterSectionInfo {
    readonly fractionDigitCount: number;
    readonly hasAnyDateParts: boolean;
    readonly hasAnyTimeParts: boolean;
    readonly isDateSection: boolean;
    readonly isNumberSection: boolean;
    readonly percentCount: number;
    readonly showsGroupSeparators: boolean;
    readonly color: string;
    readonly hasParentheses: boolean;
    readonly hasVerbatimString: boolean;
}
/**
 * @hidden
 */
export declare let IValueFormatterSectionInfo_$type: Type;
/**
 * @hidden
 */
export declare class ValueFormatter_ValueFormatterSectionInfo extends Base implements IValueFormatterSectionInfo {
    static $t: Type;
    private a;
    constructor(a: any);
    readonly color: string;
    readonly fractionDigitCount: number;
    readonly hasAnyDateParts: boolean;
    readonly hasAnyTimeParts: boolean;
    readonly hasParentheses: boolean;
    readonly hasVerbatimString: boolean;
    readonly isDateSection: boolean;
    readonly isNumberSection: boolean;
    readonly percentCount: number;
    private readonly b;
    readonly showsGroupSeparators: boolean;
}
/**
 * @hidden
 */
export declare class CalcArgumentHelper extends Base {
    static $t: Type;
    private static a;
    static c(a: ExcelCalcValue, b: CalcArgumentSource, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
    private static b;
    static e(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: number) => void): ExcelCalcValue;
    static d(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class CalcFunctionUtilities extends Base {
    static $t: Type;
    static readonly w: number;
    static h(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number) => ExcelCalcValue): ExcelCalcValue;
    static j(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number, arg2: number) => ExcelCalcValue): ExcelCalcValue;
    static i(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number, arg2: number, arg3: number) => ExcelCalcValue): ExcelCalcValue;
    private static n;
    static p(a: number): List$1<ExcelCalcValue>;
    static ad(a: List$1<ExcelCalcValue>): void;
    private static m;
    static o(a: number): List$1<number>;
    static ac(a: List$1<number>): void;
    static e(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: List$1<number>) => ExcelCalcValue): ExcelCalcValue;
    static d(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: List$1<number>) => ExcelCalcValue): ExcelCalcValue;
    static f(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
    static g(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: number) => void): ExcelCalcValue;
    static l(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags): ExcelCalcValue;
    static k(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags): ExcelCalcValue;
    static c(a: ExcelCalcNumberStack, b: boolean, c: boolean, d: boolean): CalcArgumentFlags;
    static b(a: ExcelCalcNumberStack, b: boolean, c: boolean, d: boolean): CalcArgumentFlags;
    private static a;
    static q(a: List$1<number>): number;
    static r(a: List$1<number>): number;
    static s(a: List$1<number>, b: number): number;
    static t(a: number, b: number): number;
    static u(a: number, b: number, c: number): number;
    static v(a: List$1<number>): number;
    static x(a: number): number;
    static y(a: number, b: number, c: boolean): number;
    static z(a: List$1<number>): number;
    static ab(a: List$1<number>, b: boolean): number;
}
/**
 * @hidden
 */
export declare class CalcDateUtilities extends Base {
    static $t: Type;
    private static c;
    private static e;
    private static f;
    private static g;
    private static h;
    private static a;
    private static b;
    static d(a: Date, b: Date, c: DayCountBasis): number;
}
/**
 * @hidden
 */
export declare class CustomExcelCalcFunction extends ExcelCalcFunction {
    static $t: Type;
    private readonly _an;
    private readonly _am;
    private readonly _al;
    private readonly _ak;
    constructor(a: string, b: number, c: number, d: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue);
    protected get_name(): string;
    readonly name: string;
    protected get_minArgs(): number;
    readonly minArgs: number;
    protected get_maxArgs(): number;
    readonly maxArgs: number;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class CalcManagerUtilities extends Base {
    static $t: Type;
    static c(a: string, b: number, c: Date): Date;
    static b(a: DateInterval, b: number, c: Date): Date;
    static e(a: string, b: Date, c: Date, d: FirstDayOfWeek, e: FirstWeekOfYear): number;
    static d(a: DateInterval, b: Date, c: Date, d: FirstDayOfWeek, e: FirstWeekOfYear): number;
    static f(a: string): void;
    static g(a: boolean, b: string): void;
    static a(a: Type): any[];
}
